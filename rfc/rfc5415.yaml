- contents:
  - "      Control And Provisioning of Wireless Access Points (CAPWAP)\n                         Protocol
    Specification\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n   This document may contain material
    from IETF Documents or IETF\n   Contributions published or made publicly available
    before November\n   10, 2008.  The person(s) controlling the copyright in some
    of this\n   material may not have granted the IETF Trust the right to allow\n
    \  modifications of such material outside the IETF Standards Process.\n   Without
    obtaining an adequate license from the person(s) controlling\n   the copyright
    in such materials, this document may not be modified\n   outside the IETF Standards
    Process, and derivative works of it may\n   not be created outside the IETF Standards
    Process, except to format\n   it for publication as an RFC or to translate it
    into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This specification defines the Control And Provisioning of Wireless\n
    \  Access Points (CAPWAP) Protocol, meeting the objectives defined by\n   the
    CAPWAP Working Group in RFC 4564.  The CAPWAP protocol is\n   designed to be flexible,
    allowing it to be used for a variety of\n   wireless technologies.  This document
    describes the base CAPWAP\n   protocol, while separate binding extensions will
    enable its use with\n   additional wireless technologies.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................7\n
    \     1.1. Goals ......................................................8\n      1.2.
    Conventions Used in This Document ..........................9\n      1.3. Contributing
    Authors .......................................9\n      1.4. Terminology ...............................................10\n
    \  2. Protocol Overview ..............................................11\n      2.1.
    Wireless Binding Definition ...............................12\n      2.2. CAPWAP
    Session Establishment Overview .....................13\n      2.3. CAPWAP State
    Machine Definition ...........................15\n           2.3.1. CAPWAP Protocol
    State Transitions ..................17\n           2.3.2. CAPWAP/DTLS Interface
    ..............................31\n      2.4. Use of DTLS in the CAPWAP Protocol
    ........................33\n           2.4.1. DTLS Handshake Processing ..........................33\n
    \          2.4.2. DTLS Session Establishment .........................35\n           2.4.3.
    DTLS Error Handling ................................35\n           2.4.4. DTLS
    Endpoint Authentication and Authorization .....36\n   3. CAPWAP Transport ...............................................40\n
    \     3.1. UDP Transport .............................................40\n      3.2.
    UDP-Lite Transport ........................................41\n      3.3. AC Discovery
    ..............................................41\n      3.4. Fragmentation/Reassembly
    ..................................42\n      3.5. MTU Discovery .............................................43\n
    \  4. CAPWAP Packet Formats ..........................................43\n      4.1.
    CAPWAP Preamble ...........................................46\n      4.2. CAPWAP
    DTLS Header ........................................46\n      4.3. CAPWAP Header
    .............................................47\n      4.4. CAPWAP Data Messages
    ......................................50\n           4.4.1. CAPWAP Data Channel
    Keep-Alive .....................51\n           4.4.2. Data Payload .......................................52\n
    \          4.4.3. Establishment of a DTLS Data Channel ...............52\n      4.5.
    CAPWAP Control Messages ...................................52\n           4.5.1.
    Control Message Format .............................53\n           4.5.2. Quality
    of Service .................................56\n           4.5.3. Retransmissions
    ....................................57\n      4.6. CAPWAP Protocol Message Elements
    ..........................58\n           4.6.1. AC Descriptor ......................................61\n
    \          4.6.2. AC IPv4 List .......................................64\n           4.6.3.
    AC IPv6 List .......................................64\n           4.6.4. AC Name
    ............................................65\n           4.6.5. AC Name with
    Priority ..............................65\n           4.6.6. AC Timestamp .......................................66\n
    \          4.6.7. Add MAC ACL Entry ..................................66\n           4.6.8.
    Add Station ........................................67\n           4.6.9. CAPWAP
    Control IPv4 Address ........................68\n           4.6.10. CAPWAP Control
    IPv6 Address .......................68\n           4.6.11. CAPWAP Local IPv4 Address
    .........................69\n           4.6.12. CAPWAP Local IPv6 Address .........................69\n
    \          4.6.13. CAPWAP Timers .....................................70\n           4.6.14.
    CAPWAP Transport Protocol .........................71\n           4.6.15. Data
    Transfer Data ................................72\n           4.6.16. Data Transfer
    Mode ................................73\n           4.6.17. Decryption Error Report
    ...........................73\n           4.6.18. Decryption Error Report Period
    ....................74\n           4.6.19. Delete MAC ACL Entry ..............................74\n
    \          4.6.20. Delete Station ....................................75\n           4.6.21.
    Discovery Type ....................................75\n           4.6.22. Duplicate
    IPv4 Address ............................76\n           4.6.23. Duplicate IPv6
    Address ............................77\n           4.6.24. Idle Timeout ......................................78\n
    \          4.6.25. ECN Support .......................................78\n           4.6.26.
    Image Data ........................................79\n           4.6.27. Image
    Identifier ..................................79\n           4.6.28. Image Information
    .................................80\n           4.6.29. Initiate Download .................................81\n
    \          4.6.30. Location Data .....................................81\n           4.6.31.
    Maximum Message Length ............................81\n           4.6.32. MTU
    Discovery Padding .............................82\n           4.6.33. Radio Administrative
    State ........................82\n           4.6.34. Radio Operational State ...........................83\n
    \          4.6.35. Result Code .......................................84\n           4.6.36.
    Returned Message Element ..........................85\n           4.6.37. Session
    ID ........................................86\n           4.6.38. Statistics Timer
    ..................................87\n           4.6.39. Vendor Specific Payload
    ...........................87\n           4.6.40. WTP Board Data ....................................88\n
    \          4.6.41. WTP Descriptor ....................................89\n           4.6.42.
    WTP Fallback ......................................92\n           4.6.43. WTP
    Frame Tunnel Mode .............................92\n           4.6.44. WTP MAC
    Type ......................................93\n           4.6.45. WTP Name ..........................................94\n
    \          4.6.46. WTP Radio Statistics ..............................94\n           4.6.47.
    WTP Reboot Statistics .............................96\n           4.6.48. WTP
    Static IP Address Information .................97\n      4.7. CAPWAP Protocol
    Timers ....................................98\n           4.7.1. ChangeStatePendingTimer
    ............................98\n           4.7.2. DataChannelKeepAlive ...............................98\n
    \          4.7.3. DataChannelDeadInterval ............................99\n           4.7.4.
    DataCheckTimer .....................................99\n           4.7.5. DiscoveryInterval
    ..................................99\n           4.7.6. DTLSSessionDelete ..................................99\n
    \          4.7.7. EchoInterval .......................................99\n           4.7.8.
    IdleTimeout ........................................99\n           4.7.9. ImageDataStartTimer
    ...............................100\n           4.7.10. MaxDiscoveryInterval .............................100\n
    \          4.7.11. ReportInterval ...................................100\n           4.7.12.
    RetransmitInterval ...............................100\n           4.7.13. SilentInterval
    ...................................100\n           4.7.14. StatisticsTimer ..................................100\n
    \          4.7.15. WaitDTLS .........................................101\n           4.7.16.
    WaitJoin .........................................101\n      4.8. CAPWAP Protocol
    Variables ................................101\n           4.8.1. AdminState ........................................101\n
    \          4.8.2. DiscoveryCount ....................................101\n           4.8.3.
    FailedDTLSAuthFailCount ...........................101\n           4.8.4. FailedDTLSSessionCount
    ............................101\n           4.8.5. MaxDiscoveries ....................................102\n
    \          4.8.6. MaxFailedDTLSSessionRetry .........................102\n           4.8.7.
    MaxRetransmit .....................................102\n           4.8.8. RetransmitCount
    ...................................102\n           4.8.9. WTPFallBack .......................................102\n
    \     4.9. WTP Saved Variables ......................................102\n           4.9.1.
    AdminRebootCount ..................................102\n           4.9.2. FrameEncapType
    ....................................102\n           4.9.3. LastRebootReason ..................................103\n
    \          4.9.4. MacType ...........................................103\n           4.9.5.
    PreferredACs ......................................103\n           4.9.6. RebootCount
    .......................................103\n           4.9.7. Static IP Address
    .................................103\n           4.9.8. WTPLinkFailureCount ...............................103\n
    \          4.9.9. WTPLocation .......................................103\n           4.9.10.
    WTPName ..........................................103\n   5. CAPWAP Discovery
    Operations ...................................103\n      5.1. Discovery Request
    Message ................................103\n      5.2. Discovery Response Message
    ...............................105\n      5.3. Primary Discovery Request Message
    ........................106\n      5.4. Primary Discovery Response ...............................107\n
    \  6. CAPWAP Join Operations ........................................108\n      6.1.
    Join Request .............................................108\n      6.2. Join
    Response ............................................110\n   7. Control Channel
    Management ....................................111\n      7.1. Echo Request .............................................111\n
    \     7.2. Echo Response ............................................112\n   8.
    WTP Configuration Management ..................................112\n      8.1.
    Configuration Consistency ................................112\n           8.1.1.
    Configuration Flexibility .........................113\n      8.2. Configuration
    Status Request .............................114\n      8.3. Configuration Status
    Response ............................115\n      8.4. Configuration Update Request
    .............................116\n      8.5. Configuration Update Response ............................117\n
    \     8.6. Change State Event Request ...............................117\n      8.7.
    Change State Event Response ..............................118\n      8.8. Clear
    Configuration Request ..............................119\n      8.9. Clear Configuration
    Response .............................119\n   9. Device Management Operations
    ..................................120\n      9.1. Firmware Management ......................................120\n
    \          9.1.1. Image Data Request ................................124\n           9.1.2.
    Image Data Response ...............................125\n      9.2. Reset Request
    ............................................126\n      9.3. Reset Response ...........................................127\n
    \     9.4. WTP Event Request ........................................127\n      9.5.
    WTP Event Response .......................................128\n      9.6. Data
    Transfer ............................................128\n           9.6.1. Data
    Transfer Request .............................130\n           9.6.2. Data Transfer
    Response ............................131\n   10. Station Session Management ...................................131\n
    \     10.1. Station Configuration Request ...........................131\n      10.2.
    Station Configuration Response ..........................132\n   11. NAT Considerations
    ...........................................132\n   12. Security Considerations
    ......................................134\n      12.1. CAPWAP Security .........................................134\n
    \          12.1.1. Converting Protected Data into Unprotected Data ..135\n           12.1.2.
    Converting Unprotected Data into\n                   Protected Data (Insertion)
    .......................135\n           12.1.3. Deletion of Protected Records ....................135\n
    \          12.1.4. Insertion of Unprotected Records .................135\n           12.1.5.
    Use of MD5 .......................................136\n           12.1.6. CAPWAP
    Fragmentation .............................136\n      12.2. Session ID Security
    .....................................136\n      12.3. Discovery or DTLS Setup
    Attacks .........................137\n      12.4. Interference with a DTLS Session
    ........................137\n      12.5. CAPWAP Pre-Provisioning .................................138\n
    \     12.6. Use of Pre-Shared Keys in CAPWAP ........................139\n      12.7.
    Use of Certificates in CAPWAP ...........................140\n      12.8. Use
    of MAC Address in CN Field ..........................140\n      12.9. AAA Security
    ............................................141\n      12.10. WTP Firmware ...........................................141\n
    \  13. Operational Considerations ...................................141\n   14.
    Transport Considerations .....................................142\n   15. IANA
    Considerations ..........................................143\n      15.1. IPv4
    Multicast Address ..................................143\n      15.2. IPv6 Multicast
    Address ..................................144\n      15.3. UDP Port ................................................144\n
    \     15.4. CAPWAP Message Types ....................................144\n      15.5.
    CAPWAP Header Flags .....................................144\n      15.6. CAPWAP
    Control Message Flags ............................145\n      15.7. CAPWAP Message
    Element Type .............................145\n      15.8. CAPWAP Wireless Binding
    Identifiers .....................145\n      15.9. AC Security Types .......................................146\n
    \     15.10. AC DTLS Policy .........................................146\n      15.11.
    AC Information Type ....................................146\n      15.12. CAPWAP
    Transport Protocol Types ........................146\n      15.13. Data Transfer
    Type .....................................147\n      15.14. Data Transfer Mode
    .....................................147\n      15.15. Discovery Types ........................................147\n
    \     15.16. ECN Support ............................................148\n      15.17.
    Radio Admin State ......................................148\n      15.18. Radio
    Operational State ................................148\n      15.19. Radio Failure
    Causes ...................................148\n      15.20. Result Code ............................................149\n
    \     15.21. Returned Message Element Reason ........................149\n      15.22.
    WTP Board Data Type ....................................149\n      15.23. WTP
    Descriptor Type ....................................149\n      15.24. WTP Fallback
    Mode ......................................150\n      15.25. WTP Frame Tunnel
    Mode ..................................150\n      15.26. WTP MAC Type ...........................................150\n
    \     15.27. WTP Radio Stats Failure Type ...........................151\n      15.28.
    WTP Reboot Stats Failure Type ..........................151\n   16. Acknowledgments
    ..............................................151\n   17. References ...................................................151\n
    \     17.1. Normative References ....................................151\n      17.2.
    Informative References ..................................153\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes the CAPWAP protocol, a standard,\n
    \  interoperable protocol that enables an Access Controller (AC) to\n   manage
    a collection of Wireless Termination Points (WTPs).  The\n   CAPWAP protocol is
    defined to be independent of Layer 2 (L2)\n   technology, and meets the objectives
    in \"Objectives for Control and\n   Provisioning of Wireless Access Points (CAPWAP)\"
    [RFC4564].\n   The emergence of centralized IEEE 802.11 Wireless Local Area Network\n
    \  (WLAN) architectures, in which simple IEEE 802.11 WTPs are managed by\n   an
    Access Controller (AC), suggested that a standards-based,\n   interoperable protocol
    could radically simplify the deployment and\n   management of wireless networks.
    \ WTPs require a set of dynamic\n   management and control functions related to
    their primary task of\n   connecting the wireless and wired mediums.  Traditional
    protocols for\n   managing WTPs are either manual static configuration via HTTP,\n
    \  proprietary Layer 2-specific or non-existent (if the WTPs are self-\n   contained).
    \ An IEEE 802.11 binding is defined in [RFC5416] to\n   support use of the CAPWAP
    protocol with IEEE 802.11 WLAN networks.\n   CAPWAP assumes a network configuration
    consisting of multiple WTPs\n   communicating via the Internet Protocol (IP) to
    an AC.  WTPs are\n   viewed as remote radio frequency (RF) interfaces controlled
    by the\n   AC.  The CAPWAP protocol supports two modes of operation: Split and\n
    \  Local MAC (medium access control).  In Split MAC mode, all L2\n   wireless
    data and management frames are encapsulated via the CAPWAP\n   protocol and exchanged
    between the AC and the WTP.  As shown in\n   Figure 1, the wireless frames received
    from a mobile device, which is\n   referred to in this specification as a Station
    (STA), are directly\n   encapsulated by the WTP and forwarded to the AC.\n              +-+
    \        wireless frames        +-+\n              | |--------------------------------|
    |\n              | |              +-+               | |\n              | |--------------|
    |---------------| |\n              | |wireless PHY/ | |     CAPWAP    | |\n              |
    | MAC sublayer | |               | |\n              +-+              +-+               +-+\n
    \             STA              WTP                AC\n        Figure 1: Representative
    CAPWAP Architecture for Split MAC\n   The Local MAC mode of operation allows for
    the data frames to be\n   either locally bridged or tunneled as 802.3 frames.
    \ The latter\n   implies that the WTP performs the 802.11 Integration function.
    \ In\n   either case, the L2 wireless management frames are processed locally\n
    \  by the WTP and then forwarded to the AC.  Figure 2 shows the Local\n   MAC
    mode, in which a station transmits a wireless frame that is\n   encapsulated in
    an 802.3 frame and forwarded to the AC.\n              +-+wireless frames +-+
    802.3 frames +-+\n              | |----------------| |--------------| |\n              |
    |                | |              | |\n              | |----------------| |--------------|
    |\n              | |wireless PHY/   | |     CAPWAP   | |\n              | | MAC
    sublayer   | |              | |\n              +-+                +-+              +-+\n
    \             STA                WTP               AC\n        Figure 2: Representative
    CAPWAP Architecture for Local MAC\n   Provisioning WTPs with security credentials
    and managing which WTPs\n   are authorized to provide service are traditionally
    handled by\n   proprietary solutions.  Allowing these functions to be performed
    from\n   a centralized AC in an interoperable fashion increases manageability\n
    \  and allows network operators to more tightly control their wireless\n   network
    infrastructure.\n"
  - contents:
    - "1.1.  Goals\n   The goals for the CAPWAP protocol are listed below:\n   1.
      To centralize the authentication and policy enforcement functions\n      for
      a wireless network.  The AC may also provide centralized\n      bridging, forwarding,
      and encryption of user traffic.\n      Centralization of these functions will
      enable reduced cost and\n      higher efficiency by applying the capabilities
      of network\n      processing silicon to the wireless network, as in wired LANs.\n
      \  2. To enable shifting of the higher-level protocol processing from\n      the
      WTP.  This leaves the time-critical applications of wireless\n      control
      and access in the WTP, making efficient use of the\n      computing power available
      in WTPs, which are subject to severe\n      cost pressure.\n   3. To provide
      an extensible protocol that is not bound to a specific\n      wireless technology.
      \ Extensibility is provided via a generic\n      encapsulation and transport
      mechanism, enabling the CAPWAP\n      protocol to be applied to many access
      point types in the future,\n      via a specific wireless binding.\n   The CAPWAP
      protocol concerns itself solely with the interface between\n   the WTP and the
      AC.  Inter-AC and station-to-AC communication are\n   strictly outside the scope
      of this document.\n"
    title: 1.1.  Goals
  - contents:
    - "1.2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in RFC 2119 [RFC2119].\n"
    title: 1.2.  Conventions Used in This Document
  - contents:
    - "1.3.  Contributing Authors\n   This section lists and acknowledges the authors
      of significant text\n   and concepts included in this specification.\n   The
      CAPWAP Working Group selected the Lightweight Access Point\n   Protocol (LWAPP)
      [LWAPP] to be used as the basis of the CAPWAP\n   protocol specification.  The
      following people are authors of the\n   LWAPP document:\n      Bob O'Hara\n
      \     Email: bob.ohara@computer.org\n      Pat Calhoun, Cisco Systems, Inc.\n
      \     170 West Tasman Drive, San Jose, CA  95134\n      Phone: +1 408-902-3240,
      Email: pcalhoun@cisco.com\n      Rohit Suri, Cisco Systems, Inc.\n      170
      West Tasman Drive, San Jose, CA  95134\n      Phone: +1 408-853-5548, Email:
      rsuri@cisco.com\n      Nancy Cam Winget, Cisco Systems, Inc.\n      170 West
      Tasman Drive, San Jose, CA  95134\n      Phone: +1 408-853-0532, Email: ncamwing@cisco.com\n
      \     Scott Kelly, Aruba Networks\n      1322 Crossman Ave, Sunnyvale, CA 94089\n
      \     Phone: +1  408-754-8408, Email: skelly@arubanetworks.com\n      Michael
      Glenn Williams, Nokia, Inc.\n      313 Fairchild Drive, Mountain View, CA  94043\n
      \     Phone: +1 650-714-7758, Email: Michael.G.Williams@Nokia.com\n      Sue
      Hares, Green Hills Software\n      825 Victors Way, Suite 100, Ann Arbor, MI
      \ 48108\n      Phone: +1 734 222 1610, Email: shares@ndzh.com\n   Datagram Transport
      Layer Security (DTLS) [RFC4347] is used as the\n   security solution for the
      CAPWAP protocol.  The following people are\n   authors of significant DTLS-related
      text included in this document:\n      Scott Kelly, Aruba Networks\n      1322
      Crossman Ave, Sunnyvale, CA 94089\n      Phone: +1  408-754-8408\n      Email:
      skelly@arubanetworks.com\n      Eric Rescorla, Network Resonance\n      2483
      El Camino Real, #212,Palo Alto CA, 94303\n      Email: ekr@networkresonance.com\n
      \  The concept of using DTLS to secure the CAPWAP protocol was part of\n   the
      Secure Light Access Point Protocol (SLAPP) proposal [SLAPP].  The\n   following
      people are authors of the SLAPP proposal:\n      Partha Narasimhan, Aruba Networks\n
      \     1322 Crossman Ave, Sunnyvale, CA  94089\n      Phone: +1 408-480-4716\n
      \     Email: partha@arubanetworks.com\n      Dan Harkins\n      Trapeze Networks\n
      \     5753 W. Las Positas Blvd, Pleasanton, CA  94588\n      Phone: +1-925-474-2212\n
      \     EMail: dharkins@trpz.com\n      Subbu Ponnuswamy, Aruba Networks\n      1322
      Crossman Ave, Sunnyvale, CA  94089\n      Phone: +1 408-754-1213\n      Email:
      subbu@arubanetworks.com\n   The following individuals contributed significant
      security-related\n   text to the document [RFC5418]:\n      T. Charles Clancy,
      Laboratory for Telecommunications Sciences,\n      8080 Greenmead Drive, College
      Park, MD 20740\n      Phone: +1 240-373-5069, Email: clancy@ltsnet.net\n      Scott
      Kelly, Aruba Networks\n      1322 Crossman Ave, Sunnyvale, CA 94089\n      Phone:
      +1  408-754-8408, Email: scott@hyperthought.com\n"
    title: 1.3.  Contributing Authors
  - contents:
    - "1.4.  Terminology\n   Access Controller (AC): The network entity that provides
      WTP access\n   to the network infrastructure in the data plane, control plane,\n
      \  management plane, or a combination therein.\n   CAPWAP Control Channel: A
      bi-directional flow defined by the AC IP\n   Address, WTP IP Address, AC control
      port, WTP control port, and the\n   transport-layer protocol (UDP or UDP-Lite)
      over which CAPWAP Control\n   packets are sent and received.\n   CAPWAP Data
      Channel: A bi-directional flow defined by the AC IP\n   Address, WTP IP Address,
      AC data port, WTP data port, and the\n   transport-layer protocol (UDP or UDP-Lite)
      over which CAPWAP Data\n   packets are sent and received.\n   Station (STA):
      A device that contains an interface to a wireless\n   medium (WM).\n   Wireless
      Termination Point (WTP): The physical or network entity that\n   contains an
      RF antenna and wireless Physical Layer (PHY) to transmit\n   and receive station
      traffic for wireless access networks.\n   This document uses additional terminology
      defined in [RFC3753].\n"
    title: 1.4.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Protocol Overview\n   The CAPWAP protocol is a generic protocol defining
    AC and WTP control\n   and data plane communication via a CAPWAP protocol transport\n
    \  mechanism.  CAPWAP Control messages, and optionally CAPWAP Data\n   messages,
    are secured using Datagram Transport Layer Security (DTLS)\n   [RFC4347].  DTLS
    is a standards-track IETF protocol based upon TLS.\n   The underlying security-related
    protocol mechanisms of TLS have been\n   successfully deployed for many years.\n
    \  The CAPWAP protocol transport layer carries two types of payload,\n   CAPWAP
    Data messages and CAPWAP Control messages.  CAPWAP Data\n   messages encapsulate
    forwarded wireless frames.  CAPWAP protocol\n   Control messages are management
    messages exchanged between a WTP and\n   an AC.  The CAPWAP Data and Control packets
    are sent over separate\n   UDP ports.  Since both data and control packets can
    exceed the\n   Maximum Transmission Unit (MTU) length, the payload of a CAPWAP
    Data\n   or Control message can be fragmented.  The fragmentation behavior is\n
    \  defined in Section 3.\n   The CAPWAP Protocol begins with a Discovery phase.
    \ The WTPs send a\n   Discovery Request message, causing any Access Controller
    (AC)\n   receiving the message to respond with a Discovery Response message.\n
    \  From the Discovery Response messages received, a WTP selects an AC\n   with
    which to establish a secure DTLS session.  In order to establish\n   the secure
    DTLS connection, the WTP will need some amount of pre-\n   provisioning, which
    is specified in Section 12.5.  CAPWAP protocol\n   messages will be fragmented
    to the maximum length discovered to be\n   supported by the network.\n   Once
    the WTP and the AC have completed DTLS session establishment, a\n   configuration
    exchange occurs in which both devices agree on version\n   information.  During
    this exchange, the WTP may receive provisioning\n   settings.  The WTP is then
    enabled for operation.\n   When the WTP and AC have completed the version and
    provision exchange\n   and the WTP is enabled, the CAPWAP protocol is used to
    encapsulate\n   the wireless data frames sent between the WTP and AC.  The CAPWAP\n
    \  protocol will fragment the L2 frames if the size of the encapsulated\n   wireless
    user data (Data) or protocol control (Management) frames\n   causes the resulting
    CAPWAP protocol packet to exceed the MTU\n   supported between the WTP and AC.
    \ Fragmented CAPWAP packets are\n   reassembled to reconstitute the original encapsulated
    payload.  MTU\n   Discovery and Fragmentation are described in Section 3.\n   The
    CAPWAP protocol provides for the delivery of commands from the AC\n   to the WTP
    for the management of stations that are communicating with\n   the WTP.  This
    may include the creation of local data structures in\n   the WTP for the stations
    and the collection of statistical\n   information about the communication between
    the WTP and the stations.\n   The CAPWAP protocol provides a mechanism for the
    AC to obtain\n   statistical information collected by the WTP.\n   The CAPWAP
    protocol provides for a keep-alive feature that preserves\n   the communication
    channel between the WTP and AC.  If the AC fails to\n   appear alive, the WTP
    will try to discover a new AC.\n"
  - contents:
    - "2.1.  Wireless Binding Definition\n   The CAPWAP protocol is independent of
      a specific WTP radio\n   technology, as well its associated wireless link layer
      protocol.\n   Elements of the CAPWAP protocol are designed to accommodate the\n
      \  specific needs of each wireless technology in a standard way.\n   Implementation
      of the CAPWAP protocol for a particular wireless\n   technology MUST follow
      the binding requirements defined for that\n   technology.\n   When defining
      a binding for wireless technologies, the authors MUST\n   include any necessary
      definitions for technology-specific messages\n   and all technology-specific
      message elements for those messages.  At\n   a minimum, a binding MUST provide:\n
      \  1. The definition for a binding-specific Statistics message element,\n      carried
      in the WTP Event Request message.\n   2. A message element carried in the Station
      Configuration Request\n      message to configure station information on the
      WTP.\n   3. A WTP Radio Information message element carried in the Discovery,\n
      \     Primary Discovery, and Join Request and Response messages,\n      indicating
      the binding-specific radio types supported at the WTP\n      and AC.\n   If
      technology-specific message elements are required for any of the\n   existing
      CAPWAP messages defined in this specification, they MUST\n   also be defined
      in the technology binding document.\n   The naming of binding-specific message
      elements MUST begin with the\n   name of the technology type, e.g., the binding
      for IEEE 802.11,\n   provided in [RFC5416], begins with \"IEEE 802.11\".\n   The
      CAPWAP binding concept MUST also be used in any future\n   specifications that
      add functionality to either the base CAPWAP\n   protocol specification, or any
      published CAPWAP binding\n   specification.  A separate WTP Radio Information
      message element MUST\n   be created to properly advertise support for the specification.
      \ This\n   mechanism allows for future protocol extensibility, while providing\n
      \  the necessary capabilities advertisement, through the WTP Radio\n   Information
      message element, to ensure WTP/AC interoperability.\n"
    title: 2.1.  Wireless Binding Definition
  - contents:
    - "2.2.  CAPWAP Session Establishment Overview\n   This section describes the
      session establishment process message\n   exchanges between a CAPWAP WTP and
      AC.  The annotated ladder diagram\n   shows the AC on the right, the WTP on
      the left, and assumes the use\n   of certificates for DTLS authentication.  The
      CAPWAP protocol state\n   machine is described in detail in Section 2.3.  Note
      that DTLS allows\n   certain messages to be aggregated into a single frame,
      which is\n   denoted via an asterisk in Figure 3.\n           ============                         ============\n
      \              WTP                                   AC\n           ============
      \                        ============\n            [----------- begin optional
      discovery ------------]\n                           Discover Request\n                 ------------------------------------>\n
      \                          Discover Response\n                 <------------------------------------\n
      \           [----------- end optional discovery ------------]\n                      (--
      begin DTLS handshake --)\n                             ClientHello\n                 ------------------------------------>\n
      \                     HelloVerifyRequest (with cookie)\n                 <------------------------------------\n
      \                       ClientHello (with cookie)\n                 ------------------------------------>\n
      \                               ServerHello,\n                                Certificate,\n
      \                               ServerHelloDone*\n                 <------------------------------------\n
      \               (-- WTP callout for AC authorization --)\n                        Certificate
      (optional),\n                         ClientKeyExchange,\n                     CertificateVerify
      (optional),\n                         ChangeCipherSpec,\n                             Finished*\n
      \                ------------------------------------>\n                (--
      AC callout for WTP authorization --)\n                         ChangeCipherSpec,\n
      \                            Finished*\n                 <------------------------------------\n
      \               (-- DTLS session is established now --)\n                              Join
      Request\n                 ------------------------------------>\n                              Join
      Response\n                 <------------------------------------\n                      [--
      Join State Complete --]\n                   (-- assume image is up to date --)\n
      \                     Configuration Status Request\n                 ------------------------------------>\n
      \                     Configuration Status Response\n                 <------------------------------------\n
      \                   [-- Configure State Complete --]\n                       Change
      State Event Request\n                 ------------------------------------>\n
      \                      Change State Event Response\n                 <------------------------------------\n
      \                  [-- Data Check State Complete --]\n                        (--
      enter RUN state --)\n                                   :\n                                   :\n
      \                             Echo Request\n                 ------------------------------------>\n
      \                            Echo Response\n                 <------------------------------------\n
      \                                  :\n                                   :\n
      \                             Event Request\n                 ------------------------------------>\n
      \                            Event Response\n                 <------------------------------------\n
      \                                  :\n                                   :\n
      \               Figure 3: CAPWAP Control Protocol Exchange\n   At the end of
      the illustrated CAPWAP message exchange, the AC and WTP\n   are securely exchanging
      CAPWAP Control messages.  This illustration\n   is provided to clarify protocol
      operation, and does not include any\n   possible error conditions.  Section
      2.3 provides a detailed\n   description of the corresponding state machine.\n"
    title: 2.2.  CAPWAP Session Establishment Overview
  - contents:
    - "2.3.  CAPWAP State Machine Definition\n   The following state diagram represents
      the lifecycle of a WTP-AC\n   session.  Use of DTLS by the CAPWAP protocol results
      in the\n   juxtaposition of two nominally separate yet tightly bound state\n
      \  machines.  The DTLS and CAPWAP state machines are coupled through an\n   API
      consisting of commands (see Section 2.3.2.1) and notifications\n   (see Section
      2.3.2.2).  Certain transitions in the DTLS state machine\n   are triggered by
      commands from the CAPWAP state machine, while\n   certain transitions in the
      CAPWAP state machine are triggered by\n   notifications from the DTLS state
      machine.\n                            /-------------------------------------\\\n
      \                           |          /-------------------------\\|\n                            |
      \        p|                         ||\n                            |    q+----------+
      r +------------+  ||\n                            |     |   Run    |-->|   Reset
      \   |-\\||\n                            |     +----------+   +------------+
      |||\n                           n|  o      ^           ^     ^      s|||\n                +------------+--------/
      \          |     |       |||\n                | Data Check |             /-------/
      \   |       |||\n                +------------+<-------\\   |             |
      \      |||\n                                      |   |             |       |||\n
      \                      /------------------+--------\\    |       |||\n                      f|
      \            m|  h|    j   v   k|       |||\n               +--------+     +-----------+
      \    +--------------+|||\n               |  Join  |---->| Configure |     |
      \ Image Data  ||||\n               +--------+  n  +-----------+     +--------------+|||\n
      \               ^   |g                 i|                    l| |||\n                |
      \  |                   \\-------------------\\ | |||\n                |   \\--------------------------------------\\|
      | |||\n                \\------------------------\\                 || | |||\n
      \        /--------------<----------------+---------------\\ || | |||\n         |
      /------------<----------------+-------------\\ | || | |||\n         | |  4                          |d
      \          t| | vv v vvv\n         | |   +----------------+   +--------------+
      \  +-----------+\n         | |   |   DTLS Setup   |   | DTLS Connect |-->|  DTLS
      TD  |\n       /-|-|---+----------------+   +--------------+ e +-----------+\n
      \      | | |    |$  ^  ^   |5  ^6         ^              ^  |w\n       v v v
      \   |   |  |   |   \\-------\\  |              |  |\n       | | |    |   |  |
      \  \\---------\\ |  |  /-----------/  |\n       | | |    |   |  \\--\\          |
      |  |  |              |\n       | | |    |   |     |          | |  |  |              |\n
      \      | | |    v  3|  1  |%     #   v |  |a |b             v\n       | | \\->+------+-->+------+
      \  +-----------+    +--------+\n       | |    | Idle |   | Disc |   | Authorize
      |    |  Dead  |\n       | |    +------+<--+------+   +-----------+    +--------+\n
      \      | |     ^   0^  2      |!\n       | |     |    |         |   +-------+\n
      \     *| |u    |    \\---------+---| Start |\n       | |     |@             |
      \  +-------+\n       | \\->+---------+<------/\n       \\--->| Sulking |\n            +---------+&\n
      \                Figure 4: CAPWAP Integrated State Machine\n   The CAPWAP protocol
      state machine, depicted above, is used by both\n   the AC and the WTP.  In cases
      where states are not shared (i.e., not\n   implemented in one or the other of
      the AC or WTP), this is explicitly\n   called out in the transition descriptions
      below.  For every state\n   defined, only certain messages are permitted to
      be sent and received.\n   The CAPWAP Control message definitions specify the
      state(s) in which\n   each message is valid.\n   Since the WTP only communicates
      with a single AC, it only has a\n   single instance of the CAPWAP state machine.
      \ The state machine works\n   differently on the AC since it communicates with
      many WTPs.  The AC\n   uses the concept of three threads.  Note that the term
      thread used\n   here does not necessarily imply that implementers must use threads,\n
      \  but it is one possible way of implementing the AC's state machine.\n   Listener
      Thread:   The AC's Listener thread handles inbound DTLS\n      session establishment
      requests, through the DTLSListen command.\n      Upon creation, the Listener
      thread starts in the DTLS Setup state.\n      Once a DTLS session has been validated,
      which occurs when the\n      state machine enters the \"Authorize\" state, the
      Listener thread\n      creates a WTP session-specific Service thread and state
      context.\n      The state machine transitions in Figure 4 are represented by\n
      \     numerals.  It is necessary for the AC to protect itself against\n      various
      attacks that exist with non-authenticated frames.  See\n      Section 12 for
      more information.\n   Discovery Thread:   The AC's Discovery thread is responsible
      for\n      receiving, and responding to, Discovery Request messages.  The\n
      \     state machine transitions in Figure 4 are represented by numerals.\n      Note
      that the Discovery thread does not maintain any per-WTP-\n      specific context
      information, and a single state context exists.\n      It is necessary for the
      AC to protect itself against various\n      attacks that exist with non-authenticated
      frames.  See Section 12\n      for more information.\n   Service Thread:   The
      AC's Service thread handles the per-WTP states,\n      and one such thread exists
      per-WTP connection.  This thread is\n      created by the Listener thread when
      the Authorize state is\n      reached.  When created, the Service thread inherits
      a copy of the\n      state machine context from the Listener thread.  When\n
      \     communication with the WTP is complete, the Service thread is\n      terminated
      and all associated resources are released.  The state\n      machine transitions
      in Figure 4 are represented by alphabetic and\n      punctuation characters.\n"
    - contents:
      - "2.3.1.  CAPWAP Protocol State Transitions\n   This section describes the
        various state transitions, and the events\n   that cause them.  This section
        does not discuss interactions between\n   DTLS- and CAPWAP-specific states.
        \ Those interactions, and DTLS-\n   specific states and transitions, are discussed
        in Section 2.3.2.\n   Start to Idle (0):  This transition occurs once device
        initialization\n      is complete.\n      WTP:  This state transition is used
        to start the WTP's CAPWAP\n            state machine.\n      AC:   The AC
        creates the Discovery and Listener threads and starts\n            the CAPWAP
        state machine.\n   Idle to Discovery (1):  This transition occurs to support
        the CAPWAP\n      discovery process.\n      WTP:  The WTP enters the Discovery
        state prior to transmitting the\n            first Discovery Request message
        (see Section 5.1).  Upon\n            entering this state, the WTP sets the
        DiscoveryInterval\n            timer (see Section 4.7).  The WTP resets the
        DiscoveryCount\n            counter to zero (0) (see Section 4.8).  The WTP
        also clears\n            all information from ACs it may have received during
        a\n            previous Discovery phase.\n      AC:   This state transition
        is executed by the AC's Discovery\n            thread, and occurs when a Discovery
        Request message is\n            received.  The AC SHOULD respond with a Discovery
        Response\n            message (see Section 5.2).\n   Discovery to Discovery
        (#):  In the Discovery state, the WTP\n      determines to which AC to connect.\n
        \     WTP:  This transition occurs when the DiscoveryInterval timer\n            expires.
        \ If the WTP is configured with a list of ACs, it\n            transmits a
        Discovery Request message to every AC from which\n            it has not received
        a Discovery Response message.  For every\n            transition to this event,
        the WTP increments the\n            DiscoveryCount counter.  See Section 5.1
        for more\n            information on how the WTP knows the ACs to which it
        should\n            transmit the Discovery Request messages.  The WTP restarts\n
        \           the DiscoveryInterval timer whenever it transmits Discovery\n
        \           Request messages.\n      AC:   This is an invalid state transition
        for the AC.\n   Discovery to Idle (2):  This transition occurs on the AC's
        Discovery\n      thread when the Discovery processing is complete.\n      WTP:
        \ This is an invalid state transition for the WTP.\n      AC:   This state
        transition is executed by the AC's Discovery\n            thread when it has
        transmitted the Discovery Response, in\n            response to a Discovery
        Request.\n   Discovery to Sulking (!):  This transition occurs on a WTP when
        AC\n      Discovery fails.\n      WTP:  The WTP enters this state when the
        DiscoveryInterval timer\n            expires and the DiscoveryCount variable
        is equal to the\n            MaxDiscoveries variable (see Section 4.8).  Upon
        entering\n            this state, the WTP MUST start the SilentInterval timer.\n
        \           While in the Sulking state, all received CAPWAP protocol\n            messages
        MUST be ignored.\n      AC:   This is an invalid state transition for the
        AC.\n   Sulking to Idle (@):  This transition occurs on a WTP when it must\n
        \     restart the Discovery phase.\n      WTP:  The WTP enters this state
        when the SilentInterval timer (see\n            Section 4.7) expires.  The
        FailedDTLSSessionCount,\n            DiscoveryCount, and FailedDTLSAuthFailCount
        counters are\n            reset to zero.\n      AC:   This is an invalid state
        transition for the AC.\n   Sulking to Sulking (&):  The Sulking state provides
        the silent\n      period, minimizing the possibility for Denial-of-Service
        (DoS)\n      attacks.\n      WTP:  All packets received from the AC while
        in the sulking state\n            are ignored.\n      AC:   This is an invalid
        state transition for the AC.\n   Idle to DTLS Setup (3):  This transition
        occurs to establish a secure\n      DTLS session with the peer.\n      WTP:
        \ The WTP initiates this transition by invoking the DTLSStart\n            command
        (see Section 2.3.2.1), which starts the DTLS session\n            establishment
        with the chosen AC and the WaitDTLS timer is\n            started (see Section
        4.7).  When the Discovery phase is\n            bypassed, it is assumed the
        WTP has locally configured ACs.\n      AC:   Upon entering the Idle state
        from the Start state, the newly\n            created Listener thread automatically
        transitions to the\n            DTLS Setup and invokes the DTLSListen command
        (see\n            Section 2.3.2.1), and the WaitDTLS timer is started (see\n
        \           Section 4.7).\n   Discovery to DTLS Setup (%):  This transition
        occurs to establish a\n      secure DTLS session with the peer.\n      WTP:
        \ The WTP initiates this transition by invoking the DTLSStart\n            command
        (see Section 2.3.2.1), which starts the DTLS session\n            establishment
        with the chosen AC.  The decision of to which\n            AC to connect is
        the result of the Discovery phase, which is\n            described in Section
        3.3.\n      AC:   This is an invalid state transition for the AC.\n   DTLS
        Setup to Idle ($):  This transition occurs when the DTLS\n      connection
        setup fails.\n      WTP:  The WTP initiates this state transition when it
        receives a\n            DTLSEstablishFail notification from DTLS (see\n            Section
        2.3.2.2), and the FailedDTLSSessionCount or the\n            FailedDTLSAuthFailCount
        counter have not reached the value\n            of the MaxFailedDTLSSessionRetry
        variable (see Section 4.8).\n            This error notification aborts the
        secure DTLS session\n            establishment.  When this notification is
        received, the\n            FailedDTLSSessionCount counter is incremented.
        \ This state\n            transition also occurs if the WaitDTLS timer has
        expired.\n      AC:   This is an invalid state transition for the AC.\n   DTLS
        Setup to Sulking (*):  This transition occurs when repeated\n      attempts
        to set up the DTLS connection have failed.\n      WTP:  The WTP enters this
        state when the FailedDTLSSessionCount or\n            the FailedDTLSAuthFailCount
        counter reaches the value of the\n            MaxFailedDTLSSessionRetry variable
        (see Section 4.8).  Upon\n            entering this state, the WTP MUST start
        the SilentInterval\n            timer.  While in the Sulking state, all received
        CAPWAP and\n            DTLS protocol messages received MUST be ignored.\n
        \     AC:   This is an invalid state transition for the AC.\n   DTLS Setup
        to DTLS Setup (4):  This transition occurs when the DTLS\n      Session failed
        to be established.\n      WTP:  This is an invalid state transition for the
        WTP.\n      AC:   The AC's Listener initiates this state transition when it\n
        \           receives a DTLSEstablishFail notification from DTLS (see\n            Section
        2.3.2.2).  This error notification aborts the secure\n            DTLS session
        establishment.  When this notification is\n            received, the FailedDTLSSessionCount
        counter is incremented.\n            The Listener thread then invokes the
        DTLSListen command (see\n            Section 2.3.2.1).\n   DTLS Setup to Authorize
        (5):  This transition occurs when an incoming\n      DTLS session is being
        established, and the DTLS stack needs\n      authorization to proceed with
        the session establishment.\n      WTP:  This state transition occurs when
        the WTP receives the\n            DTLSPeerAuthorize notification (see Section
        2.3.2.2).  Upon\n            entering this state, the WTP performs an authorization
        check\n            against the AC credentials.  See Section 2.4.4 for more\n
        \           information on AC authorization.\n      AC:   This state transition
        is handled by the AC's Listener thread\n            when the DTLS module initiates
        the DTLSPeerAuthorize\n            notification (see Section 2.3.2.2).  The
        Listener thread\n            forks an instance of the Service thread, along
        with a copy\n            of the state context.  Once created, the Service
        thread\n            performs an authorization check against the WTP credentials.\n
        \           See Section 2.4.4 for more information on WTP authorization.\n
        \  Authorize to DTLS Setup (6):  This transition is executed by the\n      Listener
        thread to enable it to listen for new incoming sessions.\n      WTP:  This
        is an invalid state transition for the WTP.\n      AC:   This state transition
        occurs when the AC's Listener thread\n            has created the WTP context
        and the Service thread.  The\n            Listener thread then invokes the
        DTLSListen command (see\n            Section 2.3.2.1).\n   Authorize to DTLS
        Connect (a):  This transition occurs to notify the\n      DTLS stack that
        the session should be established.\n      WTP:  This state transition occurs
        when the WTP has successfully\n            authorized the AC's credentials
        (see Section 2.4.4).  This\n            is done by invoking the DTLSAccept
        DTLS command (see\n            Section 2.3.2.1).\n      AC:   This state transition
        occurs when the AC has successfully\n            authorized the WTP's credentials
        (see Section 2.4.4).  This\n            is done by invoking the DTLSAccept
        DTLS command (see\n            Section 2.3.2.1).\n   Authorize to DTLS Teardown
        (b):  This transition occurs to notify the\n      DTLS stack that the session
        should be aborted.\n      WTP:  This state transition occurs when the WTP
        has been unable to\n            authorize the AC, using the AC credentials.
        \ The WTP then\n            aborts the DTLS session by invoking the DTLSAbortSession\n
        \           command (see Section 2.3.2.1).  This state transition also\n            occurs
        if the WaitDTLS timer has expired.  The WTP starts\n            the DTLSSessionDelete
        timer (see Section 4.7.6).\n      AC:   This state transition occurs when
        the AC has been unable to\n            authorize the WTP, using the WTP credentials.
        \ The AC then\n            aborts the DTLS session by invoking the DTLSAbortSession\n
        \           command (see Section 2.3.2.1).  This state transition also\n            occurs
        if the WaitDTLS timer has expired.  The AC starts the\n            DTLSSessionDelete
        timer (see Section 4.7.6).\n   DTLS Connect to DTLS Teardown (c):  This transition
        occurs when the\n      DTLS Session failed to be established.\n      WTP:
        \ This state transition occurs when the WTP receives either a\n            DTLSAborted
        or DTLSAuthenticateFail notification (see\n            Section 2.3.2.2), indicating
        that the DTLS session was not\n            successfully established.  When
        this transition occurs due\n            to the DTLSAuthenticateFail notification,
        the\n            FailedDTLSAuthFailCount is incremented; otherwise, the\n
        \           FailedDTLSSessionCount counter is incremented.  This state\n            transition
        also occurs if the WaitDTLS timer has expired.\n            The WTP starts
        the DTLSSessionDelete timer (see\n            Section 4.7.6).\n      AC:   This
        state transition occurs when the AC receives either a\n            DTLSAborted
        or DTLSAuthenticateFail notification (see\n            Section 2.3.2.2), indicating
        that the DTLS session was not\n            successfully established, and both
        of the\n            FailedDTLSAuthFailCount and FailedDTLSSessionCount counters\n
        \           have not reached the value of the MaxFailedDTLSSessionRetry\n
        \           variable (see Section 4.8).  This state transition also\n            occurs
        if the WaitDTLS timer has expired.  The AC starts the\n            DTLSSessionDelete
        timer (see Section 4.7.6).\n   DTLS Connect to Join (d):  This transition
        occurs when the DTLS\n      Session is successfully established.\n      WTP:
        \ This state transition occurs when the WTP receives the\n            DTLSEstablished
        notification (see Section 2.3.2.2),\n            indicating that the DTLS
        session was successfully\n            established.  When this notification
        is received, the\n            FailedDTLSSessionCount counter is set to zero.
        \ The WTP\n            enters the Join state by transmitting the Join Request
        to\n            the AC.  The WTP stops the WaitDTLS timer.\n      AC:   This
        state transition occurs when the AC receives the\n            DTLSEstablished
        notification (see Section 2.3.2.2),\n            indicating that the DTLS
        session was successfully\n            established.  When this notification
        is received, the\n            FailedDTLSSessionCount counter is set to zero.
        \ The AC stops\n            the WaitDTLS timer, and starts the WaitJoin timer.\n
        \  Join to DTLS Teardown (e):  This transition occurs when the join\n      process
        has failed.\n      WTP:  This state transition occurs when the WTP receives
        a Join\n            Response message with a Result Code message element\n
        \           containing an error, or if the Image Identifier provided by\n
        \           the AC in the Join Response message differs from the WTP's\n            currently
        running firmware version and the WTP has the\n            requested image
        in its non-volatile memory.  This causes the\n            WTP to initiate
        the DTLSShutdown command (see\n            Section 2.3.2.1).  This transition
        also occurs if the WTP\n            receives one of the following DTLS notifications:\n
        \           DTLSAborted, DTLSReassemblyFailure, or DTLSPeerDisconnect.\n            The
        WTP starts the DTLSSessionDelete timer (see\n            Section 4.7.6).\n
        \     AC:   This state transition occurs either if the WaitJoin timer\n            expires
        or if the AC transmits a Join Response message with\n            a Result
        Code message element containing an error.  This\n            causes the AC
        to initiate the DTLSShutdown command (see\n            Section 2.3.2.1).  This
        transition also occurs if the AC\n            receives one of the following
        DTLS notifications:\n            DTLSAborted, DTLSReassemblyFailure, or DTLSPeerDisconnect.\n
        \           The AC starts the DTLSSessionDelete timer (see\n            Section
        4.7.6).\n   Join to Image Data (f):  This state transition is used by the
        WTP and\n      the AC to download executable firmware.\n      WTP:  The WTP
        enters the Image Data state when it receives a\n            successful Join
        Response message and determines that the\n            software version in
        the Image Identifier message element is\n            not the same as its currently
        running image.  The WTP also\n            detects that the requested image
        version is not currently\n            available in the WTP's non-volatile
        storage (see Section 9.1\n            for a full description of the firmware
        download process).\n            The WTP initializes the EchoInterval timer
        (see\n            Section 4.7), and transmits the Image Data Request message\n
        \           (see Section 9.1.1) requesting the start of the firmware\n            download.\n
        \     AC:   This state transition occurs when the AC receives the Image\n
        \           Data Request message from the WTP, after having sent its\n            Join
        Response to the WTP.  The AC stops the WaitJoin timer.\n            The AC
        MUST transmit an Image Data Response message (see\n            Section 9.1.2)
        to the WTP, which includes a portion of the\n            firmware.\n   Join
        to Configure (g):  This state transition is used by the WTP and\n      the
        AC to exchange configuration information.\n      WTP:  The WTP enters the
        Configure state when it receives a\n            successful Join Response message,
        and determines that the\n            included Image Identifier message element
        is the same as its\n            currently running image.  The WTP transmits
        the\n            Configuration Status Request message (see Section 8.2) to\n
        \           the AC with message elements describing its current\n            configuration.\n
        \     AC:   This state transition occurs when it receives the\n            Configuration
        Status Request message from the WTP (see\n            Section 8.2), which
        MAY include specific message elements to\n            override the WTP's configuration.
        \ The AC stops the WaitJoin\n            timer.  The AC transmits the Configuration
        Status Response\n            message (see Section 8.3) and starts the\n            ChangeStatePendingTimer
        timer (see Section 4.7).\n   Configure to Reset (h):  This state transition
        is used to reset the\n      connection either due to an error during the configuration
        phase,\n      or when the WTP determines it needs to reset in order for the
        new\n      configuration to take effect.  The CAPWAP Reset command is used
        to\n      indicate to the peer that it will initiate a DTLS teardown.\n      WTP:
        \ The WTP enters the Reset state when it receives a\n            Configuration
        Status Response message indicating an error or\n            when it determines
        that a reset of the WTP is required, due\n            to the characteristics
        of a new configuration.\n      AC:   The AC transitions to the Reset state
        when it receives a\n            Change State Event message from the WTP that
        contains an\n            error for which AC policy does not permit the WTP
        to provide\n            service.  This state transition also occurs when the
        AC\n            ChangeStatePendingTimer timer expires.\n   Configure to DTLS
        Teardown (i):  This transition occurs when the\n      configuration process
        aborts due to a DTLS error.\n      WTP:  The WTP enters this state when it
        receives one of the\n            following DTLS notifications: DTLSAborted,\n
        \           DTLSReassemblyFailure, or DTLSPeerDisconnect (see\n            Section
        2.3.2.2).  The WTP MAY tear down the DTLS session if\n            it receives
        frequent DTLSDecapFailure notifications.  The\n            WTP starts the
        DTLSSessionDelete timer (see Section 4.7.6).\n      AC:   The AC enters this
        state when it receives one of the\n            following DTLS notifications:
        DTLSAborted,\n            DTLSReassemblyFailure, or DTLSPeerDisconnect (see\n
        \           Section 2.3.2.2).  The AC MAY tear down the DTLS session if\n
        \           it receives frequent DTLSDecapFailure notifications.  The AC\n
        \           starts the DTLSSessionDelete timer (see Section 4.7.6).\n   Image
        Data to Image Data (j):  The Image Data state is used by the\n      WTP and
        the AC during the firmware download phase.\n      WTP:  The WTP enters the
        Image Data state when it receives an\n            Image Data Response message
        indicating that the AC has more\n            data to send.  This state transition
        also occurs when the\n            WTP receives the subsequent Image Data Requests,
        at which\n            time it resets the ImageDataStartTimer time to ensure
        it\n            receives the next expected Image Data Request from the AC.\n
        \           This state transition can also occur when the WTP's\n            EchoInterval
        timer (see Section 4.7.7) expires, in which\n            case the WTP transmits
        an Echo Request message (see\n            Section 7.1), and resets its EchoInterval
        timer.  The state\n            transition also occurs when the WTP receives
        an Echo\n            Response from the AC (see Section 7.2).\n      AC:   This
        state transition occurs when the AC receives the Image\n            Data Response
        message from the WTP while already in the\n            Image Data state.  This
        state transition also occurs when\n            the AC receives an Echo Request
        (see Section 7.1) from the\n            WTP, in which case it responds with
        an Echo Response (see\n            Section 7.2), and resets its EchoInterval
        timer (see\n            Section 4.7.7).\n   Image Data to Reset (k):  This
        state transition is used to reset the\n      DTLS connection prior to restarting
        the WTP after an image\n      download.\n      WTP:  When an image download
        completes, or if the\n            ImageDataStartTimer timer expires, the WTP
        enters the Reset\n            state.  The WTP MAY also transition to this
        state upon\n            receiving an Image Data Response message from the
        AC (see\n            Section 9.1.2) indicating a failure.\n      AC:   The
        AC enters the Reset state either when the image transfer\n            has
        successfully completed or an error occurs during the\n            image download
        process.\n   Image Data to DTLS Teardown (l):  This transition occurs when
        the\n      firmware download process aborts due to a DTLS error.\n      WTP:
        \ The WTP enters this state when it receives one of the\n            following
        DTLS notifications: DTLSAborted,\n            DTLSReassemblyFailure, or DTLSPeerDisconnect
        (see\n            Section 2.3.2.2).  The WTP MAY tear down the DTLS session
        if\n            it receives frequent DTLSDecapFailure notifications.  The\n
        \           WTP starts the DTLSSessionDelete timer (see Section 4.7.6).\n
        \     AC:   The AC enters this state when it receives one of the\n            following
        DTLS notifications: DTLSAborted,\n            DTLSReassemblyFailure, or DTLSPeerDisconnect
        (see\n            Section 2.3.2.2).  The AC MAY tear down the DTLS session
        if\n            it receives frequent DTLSDecapFailure notifications.  The
        AC\n            starts the DTLSSessionDelete timer (see Section 4.7.6).\n
        \  Configure to Data Check (m):  This state transition occurs when the\n      WTP
        and AC confirm the configuration.\n      WTP:  The WTP enters this state when
        it receives a successful\n            Configuration Status Response message
        from the AC.  The WTP\n            transmits the Change State Event Request
        message (see\n            Section 8.6).\n      AC:   This state transition
        occurs when the AC receives the Change\n            State Event Request message
        (see Section 8.6) from the WTP.\n            The AC responds with a Change
        State Event Response message\n            (see Section 8.7).  The AC MUST
        start the DataCheckTimer\n            timer and stops the ChangeStatePendingTimer
        timer (see\n            Section 4.7).\n   Data Check to DTLS Teardown (n):
        \ This transition occurs when the WTP\n      does not complete the Data Check
        exchange.\n      WTP:  This state transition occurs if the WTP does not receive
        the\n            Change State Event Response message before a CAPWAP\n            retransmission
        timeout occurs.  The WTP also transitions to\n            this state if the
        underlying reliable transport's\n            RetransmitCount counter has reached
        the MaxRetransmit\n            variable (see Section 4.7).  The WTP starts
        the\n            DTLSSessionDelete timer (see Section 4.7.6).\n      AC:   The
        AC enters this state when the DataCheckTimer timer\n            expires (see
        Section 4.7).  The AC starts the\n            DTLSSessionDelete timer (see
        Section 4.7.6).\n   Data Check to Run (o):  This state transition occurs when
        the linkage\n      between the control and data channels is established, causing
        the\n      WTP and AC to enter their normal state of operation.\n      WTP:
        \ The WTP enters this state when it receives a successful\n            Change
        State Event Response message from the AC.  The WTP\n            initiates
        the data channel, which MAY require the\n            establishment of a DTLS
        session, starts the\n            DataChannelKeepAlive timer (see Section 4.7.2)
        and transmits\n            a Data Channel Keep-Alive packet (see Section 4.4.1).
        \ The\n            WTP then starts the EchoInterval timer and\n            DataChannelDeadInterval
        timer (see Section 4.7).\n      AC:   This state transition occurs when the
        AC receives the Data\n            Channel Keep-Alive packet (see Section 4.4.1),
        with a\n            Session ID message element matching that included by the
        WTP\n            in the Join Request message.  The AC disables the\n            DataCheckTimer
        timer.  Note that if AC policy is to require\n            the data channel
        to be encrypted, this process would also\n            require the establishment
        of a data channel DTLS session.\n            Upon receiving the Data Channel
        Keep-Alive packet, the AC\n            transmits its own Data Channel Keep
        Alive packet.\n   Run to DTLS Teardown (p):  This state transition occurs
        when an error\n      has occurred in the DTLS stack, causing the DTLS session
        to be\n      torn down.\n      WTP:  The WTP enters this state when it receives
        one of the\n            following DTLS notifications: DTLSAborted,\n            DTLSReassemblyFailure,
        or DTLSPeerDisconnect (see\n            Section 2.3.2.2).  The WTP MAY tear
        down the DTLS session if\n            it receives frequent DTLSDecapFailure
        notifications.  The\n            WTP also transitions to this state if the
        underlying\n            reliable transport's RetransmitCount counter has reached
        the\n            MaxRetransmit variable (see Section 4.7).  The WTP starts\n
        \           the DTLSSessionDelete timer (see Section 4.7.6).\n      AC:   The
        AC enters this state when it receives one of the\n            following DTLS
        notifications: DTLSAborted,\n            DTLSReassemblyFailure, or DTLSPeerDisconnect
        (see\n            Section 2.3.2.2).  The AC MAY tear down the DTLS session
        if\n            it receives frequent DTLSDecapFailure notifications.  The
        AC\n            transitions to this state if the underlying reliable\n            transport's
        RetransmitCount counter has reached the\n            MaxRetransmit variable
        (see Section 4.7).  This state\n            transition also occurs when the
        AC's EchoInterval timer (see\n            Section 4.7.7) expires.  The AC
        starts the DTLSSessionDelete\n            timer (see Section 4.7.6).\n   Run
        to Run (q):  This is the normal state of operation.\n      WTP:  This is the
        WTP's normal state of operation.  The WTP resets\n            its EchoInterval
        timer whenever it transmits a request to\n            the AC.  There are many
        events that result in this state\n            transition:\n            Configuration
        Update:  The WTP receives a Configuration\n                  Update Request
        message (see Section 8.4).  The WTP\n                  MUST respond with a
        Configuration Update Response\n                  message (see Section 8.5).\n
        \           Change State Event:  The WTP receives a Change State Event\n                  Response
        message, or determines that it must initiate\n                  a Change State
        Event Request message, as a result of a\n                  failure or change
        in the state of a radio.\n            Echo Request:  The WTP sends an Echo
        Request message\n                  (Section 7.1) or receives the corresponding
        Echo\n                  Response message, (see Section 7.2) from the AC.  When\n
        \                 the WTP receives the Echo Response, it resets its\n                  EchoInterval
        timer (see Section 4.7.7).\n            Clear Config Request:  The WTP receives
        a Clear\n                  Configuration Request message (see Section 8.8)
        and\n                  MUST generate a corresponding Clear Configuration\n
        \                 Response message (see Section 8.9).  The WTP MUST\n                  reset
        its configuration back to manufacturer defaults.\n            WTP Event:  The
        WTP sends a WTP Event Request message,\n                  delivering information
        to the AC (see Section 9.4).\n                  The WTP receives a WTP Event
        Response message from the\n                  AC (see Section 9.5).\n            Data
        Transfer:  The WTP sends a Data Transfer Request or\n                  Data
        Transfer Response message to the AC (see\n                  Section 9.6).
        \ The WTP receives a Data Transfer\n                  Request or Data Transfer
        Response message from the AC\n                  (see Section 9.6).  Upon receipt
        of a Data Transfer\n                  Request, the WTP transmits a Data Transfer
        Response to\n                  the AC.\n            Station Configuration
        Request:  The WTP receives a Station\n                  Configuration Request
        message (see Section 10.1), to\n                  which it MUST respond with
        a Station Configuration\n                  Response message (see Section 10.2).\n
        \     AC:   This is the AC's normal state of operation.  Note that the\n            receipt
        of any Request from the WTP causes the AC to reset\n            its EchoInterval
        timer (see Section 4.7.7).\n            Configuration Update:  The AC sends
        a Configuration Update\n                  Request message (see Section 8.4)
        to the WTP to update\n                  its configuration.  The AC receives
        a Configuration\n                  Update Response message (see Section 8.5)
        from the\n                  WTP.\n            Change State Event:  The AC
        receives a Change State Event\n                  Request message (see Section
        8.6), to which it MUST\n                  respond with the Change State Event
        Response message\n                  (see Section 8.7).\n            Echo Request:
        \ The AC receives an Echo Request message (see\n                  Section
        7.1), to which it MUST respond with an Echo\n                  Response message
        (see Section 7.2).\n            Clear Config Response:  The AC sends a Clear
        Configuration\n                  Request message (see Section 8.8) to the
        WTP to clear\n                  its configuration.  The AC receives a Clear\n
        \                 Configuration Response message from the WTP (see\n                  Section
        8.9).\n            WTP Event:  The AC receives a WTP Event Request message
        from\n                  the WTP (see Section 9.4) and MUST generate a\n                  corresponding
        WTP Event Response message (see\n                  Section 9.5).\n            Data
        Transfer:  The AC sends a Data Transfer Request or Data\n                  Transfer
        Response message to the WTP (see\n                  Section 9.6).  The AC
        receives a Data Transfer Request\n                  or Data Transfer Response
        message from the WTP (see\n                  Section 9.6).  Upon receipt of
        a Data Transfer\n                  Request, the AC transmits a Data Transfer
        Response to\n                  the WTP.\n            Station Configuration
        Request:  The AC sends a Station\n                  Configuration Request
        message (see Section 10.1) or\n                  receives the corresponding
        Station Configuration\n                  Response message (see Section 10.2)
        from the WTP.\n   Run to Reset (r):  This state transition is used when either
        the AC\n      or WTP tears down the connection.  This may occur as part of\n
        \     normal operation, or due to error conditions.\n      WTP:  The WTP enters
        the Reset state when it receives a Reset\n            Request message from
        the AC.\n      AC:   The AC enters the Reset state when it transmits a Reset\n
        \           Request message to the WTP.\n   Reset to DTLS Teardown (s):  This
        transition occurs when the CAPWAP\n      reset is complete to terminate the
        DTLS session.\n      WTP:  This state transition occurs when the WTP transmits
        a Reset\n            Response message.  The WTP does not invoke the DTLSShutdown\n
        \           command (see Section 2.3.2.1).  The WTP starts the\n            DTLSSessionDelete
        timer (see Section 4.7.6).\n      AC:   This state transition occurs when
        the AC receives a Reset\n            Response message.  This causes the AC
        to initiate the\n            DTLSShutdown command (see Section 2.3.2.1).  The
        AC starts\n            the DTLSSessionDelete timer (see Section 4.7.6).\n
        \  DTLS Teardown to Idle (t):  This transition occurs when the DTLS\n      session
        has been shut down.\n      WTP:  This state transition occurs when the WTP
        has successfully\n            cleaned up all resources associated with the
        control plane\n            DTLS session, or if the DTLSSessionDelete timer
        (see\n            Section 4.7.6) expires.  The data plane DTLS session is
        also\n            shut down, and all resources released, if a DTLS session
        was\n            established for the data plane.  Any timers set for the\n
        \           current instance of the state machine are also cleared.\n      AC:
        \  This is an invalid state transition for the AC.\n   DTLS Teardown to Sulking
        (u):  This transition occurs when repeated\n      attempts to setup the DTLS
        connection have failed.\n      WTP:  The WTP enters this state when the FailedDTLSSessionCount
        or\n            the FailedDTLSAuthFailCount counter reaches the value of the\n
        \           MaxFailedDTLSSessionRetry variable (see Section 4.8).  Upon\n
        \           entering this state, the WTP MUST start the SilentInterval\n            timer.
        \ While in the Sulking state, all received CAPWAP and\n            DTLS protocol
        messages received MUST be ignored.\n      AC:   This is an invalid state transition
        for the AC.\n   DTLS Teardown to Dead (w):  This transition occurs when the
        DTLS\n      session has been shut down.\n      WTP:  This is an invalid state
        transition for the WTP.\n      AC:   This state transition occurs when the
        AC has successfully\n            cleaned up all resources associated with
        the control plane\n            DTLS session , or if the DTLSSessionDelete
        timer (see\n            Section 4.7.6) expires.  The data plane DTLS session
        is also\n            shut down, and all resources released, if a DTLS session
        was\n            established for the data plane.  Any timers set for the\n
        \           current instance of the state machine are also cleared.  The\n
        \           AC's Service thread is terminated.\n"
      title: 2.3.1.  CAPWAP Protocol State Transitions
    - contents:
      - "2.3.2.  CAPWAP/DTLS Interface\n   This section describes the DTLS Commands
        used by CAPWAP, and the\n   notifications received from DTLS to the CAPWAP
        protocol stack.\n"
      - contents:
        - "2.3.2.1.  CAPWAP to DTLS Commands\n   Six commands are defined for the
          CAPWAP to DTLS API.  These\n   \"commands\" are conceptual, and may be implemented
          as one or more\n   function calls.  This API definition is provided to clarify\n
          \  interactions between the DTLS and CAPWAP components of the integrated\n
          \  CAPWAP state machine.\n   Below is a list of the minimal command APIs:\n
          \  o  DTLSStart is sent to the DTLS component to cause a DTLS session to\n
          \     be established.  Upon invoking the DTLSStart command, the WaitDTLS\n
          \     timer is started.  The WTP initiates this DTLS command, as the AC\n
          \     does not initiate DTLS sessions.\n   o  DTLSListen is sent to the
          DTLS component to allow the DTLS\n      component to listen for incoming
          DTLS session requests.\n   o  DTLSAccept is sent to the DTLS component to
          allow the DTLS session\n      establishment to continue successfully.\n
          \  o  DTLSAbortSession is sent to the DTLS component to cause the\n      session
          that is in the process of being established to be aborted.\n      This command
          is also sent when the WaitDTLS timer expires.  When\n      this command
          is executed, the FailedDTLSSessionCount counter is\n      incremented.\n
          \  o  DTLSShutdown is sent to the DTLS component to cause session\n      teardown.\n
          \  o  DTLSMtuUpdate is sent by the CAPWAP component to modify the MTU\n
          \     size used by the DTLS component.  See Section 3.5 for more\n      information
          on MTU Discovery.  The default size is 1468 bytes.\n"
        title: 2.3.2.1.  CAPWAP to DTLS Commands
      - contents:
        - "2.3.2.2.  DTLS to CAPWAP Notifications\n   DTLS notifications are defined
          for the DTLS to CAPWAP API.  These\n   \"notifications\" are conceptual
          and may be implemented in numerous\n   ways (e.g., as function return values).
          \ This API definition is\n   provided to clarify interactions between the
          DTLS and CAPWAP\n   components of the integrated CAPWAP state machine.  It
          is important\n   to note that the notifications listed below MAY cause the
          CAPWAP\n   state machine to jump from one state to another using a state\n
          \  transition not listed in Section 2.3.1.  When a notification listed\n
          \  below occurs, the target CAPWAP state shown in Figure 4 becomes the\n
          \  current state.\n   Below is a list of the API notifications:\n   o  DTLSPeerAuthorize
          is sent to the CAPWAP component during DTLS\n      session establishment
          once the peer's identity has been received.\n      This notification MAY
          be used by the CAPWAP component to authorize\n      the session, based on
          the peer's identity.  The authorization\n      process will lead to the
          CAPWAP component initiating either the\n      DTLSAccept or DTLSAbortSession
          commands.\n   o  DTLSEstablished is sent to the CAPWAP component to indicate
          that a\n      secure channel now exists, using the parameters provided during\n
          \     the DTLS initialization process.  When this notification is\n      received,
          the FailedDTLSSessionCount counter is reset to zero.\n      When this notification
          is received, the WaitDTLS timer is stopped.\n   o  DTLSEstablishFail is
          sent when the DTLS session establishment has\n      failed, either due to
          a local error or due to the peer rejecting\n      the session establishment.
          \ When this notification is received,\n      the FailedDTLSSessionCount
          counter is incremented.\n   o  DTLSAuthenticateFail is sent when DTLS session
          establishment has\n      failed due to an authentication error.  When this
          notification is\n      received, the FailedDTLSAuthFailCount counter is
          incremented.\n   o  DTLSAborted is sent to the CAPWAP component to indicate
          that\n      session abort (as requested by CAPWAP) is complete; this occurs
          to\n      confirm a DTLS session abort or when the WaitDTLS timer expires.\n
          \     When this notification is received, the WaitDTLS timer is stopped.\n
          \  o  DTLSReassemblyFailure MAY be sent to the CAPWAP component to\n      indicate
          DTLS fragment reassembly failure.\n   o  DTLSDecapFailure MAY be sent to
          the CAPWAP module to indicate a\n      decapsulation failure.  DTLSDecapFailure
          MAY be sent to the CAPWAP\n      module to indicate an encryption/authentication
          failure.  This\n      notification is intended for informative purposes
          only, and is not\n      intended to cause a change in the CAPWAP state machine
          (see\n      Section 12.4).\n   o  DTLSPeerDisconnect is sent to the CAPWAP
          component to indicate the\n      DTLS session has been torn down.  Note
          that this notification is\n      only received if the DTLS session has been
          established.\n"
        title: 2.3.2.2.  DTLS to CAPWAP Notifications
      title: 2.3.2.  CAPWAP/DTLS Interface
    title: 2.3.  CAPWAP State Machine Definition
  - contents:
    - "2.4.  Use of DTLS in the CAPWAP Protocol\n   DTLS is used as a tightly integrated,
      secure wrapper for the CAPWAP\n   protocol.  In this document, DTLS and CAPWAP
      are discussed as\n   nominally distinct entities; however, they are very closely
      coupled,\n   and may even be implemented inseparably.  Since there are DTLS\n
      \  library implementations currently available, and since security\n   protocols
      (e.g., IPsec, TLS) are often implemented in widely\n   available acceleration
      hardware, it is both convenient and forward-\n   looking to maintain a modular
      distinction in this document.\n   This section describes a detailed walk-through
      of the interactions\n   between the DTLS module and the CAPWAP module, via 'commands'
      (CAPWAP\n   to DTLS) and 'notifications' (DTLS to CAPWAP) as they would be\n
      \  encountered during the normal course of operation.\n"
    - contents:
      - "2.4.1.  DTLS Handshake Processing\n   Details of the DTLS handshake process
        are specified in [RFC4347].\n   This section describes the interactions between
        the DTLS session\n   establishment process and the CAPWAP protocol.  Note
        that the\n   conceptual DTLS state is shown below to help understand the point
        at\n   which the DTLS states transition.  In the normal case, the DTLS\n   handshake
        will proceed as shown in Figure 5.  (NOTE: this example\n   uses certificates,
        but pre-shared keys are also supported.)\n           ============                         ============\n
        \              WTP                                   AC\n           ============
        \                        ============\n           ClientHello           ------>\n
        \                                <------       HelloVerifyRequest\n                                                   (with
        cookie)\n           ClientHello           ------>\n           (with cookie)\n
        \                                <------       ServerHello\n                                 <------
        \      Certificate\n                                 <------       ServerHelloDone\n
        \          (WTP callout for AC authorization\n                    occurs in
        CAPWAP Auth state)\n           Certificate*\n           ClientKeyExchange\n
        \          CertificateVerify*\n           ChangeCipherSpec\n           Finished
        \             ------>\n                                (AC callout for WTP
        authorization\n                                 occurs in CAPWAP Auth state)\n
        \                                              ChangeCipherSpec\n                                 <------
        \      Finished\n                         Figure 5: DTLS Handshake\n   DTLS,
        as specified, provides its own retransmit timers with an\n   exponential back-off.
        \ [RFC4347] does not specify how long\n   retransmissions should continue.
        \ Consequently, timing out incomplete\n   DTLS handshakes is entirely the
        responsibility of the CAPWAP module.\n   The DTLS implementation used by CAPWAP
        MUST support TLS Session\n   Resumption.  Session resumption is typically
        used to establish the\n   DTLS session used for the data channel.  Since the
        data channel uses\n   different port numbers than the control channel, the
        DTLS\n   implementation on the WTP MUST provide an interface that allows the\n
        \  CAPWAP module to request session resumption despite the use of the\n   different
        port numbers (TLS implementations usually attempt session\n   resumption only
        when connecting to the same IP address and port\n   number).  Note that session
        resumption is not guaranteed to occur,\n   and a full DTLS handshake may occur
        instead.\n   The DTLS implementation used by CAPWAP MUST use replay detection,
        per\n   Section 3.3 of [RFC4347].  Since the CAPWAP protocol handles\n   retransmissions
        by re-encrypting lost frames, any duplicate DTLS\n   frames are either unintentional
        or malicious and should be silently\n   discarded.\n"
      title: 2.4.1.  DTLS Handshake Processing
    - contents:
      - "2.4.2.  DTLS Session Establishment\n   The WTP, either through the Discovery
        process or through pre-\n   configuration, determines to which AC to connect.
        \ The WTP uses the\n   DTLSStart command to request that a secure connection
        be established\n   to the selected AC.  Prior to initiation of the DTLS handshake,
        the\n   WTP sets the WaitDTLS timer.  Upon invoking the DTLSStart or\n   DTLSListen
        commands, the WTP and AC, respectively, set the WaitDTLS\n   timer.  If the
        DTLSEstablished notification is not received prior to\n   timer expiration,
        the DTLS session is aborted by issuing the\n   DTLSAbortSession DTLS command.
        \ This notification causes the CAPWAP\n   module to transition to the Idle
        state.  Upon receiving a\n   DTLSEstablished notification, the WaitDTLS timer
        is deactivated.\n"
      title: 2.4.2.  DTLS Session Establishment
    - contents:
      - "2.4.3.  DTLS Error Handling\n   If the AC or WTP does not respond to any
        DTLS handshake messages sent\n   by its peer, the DTLS specification calls
        for the message to be\n   retransmitted.  Note that during the handshake,
        when both the AC and\n   the WTP are expecting additional handshake messages,
        they both\n   retransmit if an expected message has not been received (note
        that\n   retransmissions for CAPWAP Control messages work differently: all\n
        \  CAPWAP Control messages are either requests or responses, and the\n   peer
        who sent the request is responsible for retransmissions).\n   If the WTP or
        the AC does not receive an expected DTLS handshake\n   message despite of
        retransmissions, the WaitDTLS timer will\n   eventually expire, and the session
        will be terminated.  This can\n   happen if communication between the peers
        has completely failed, or\n   if one of the peers sent a DTLS Alert message
        that was lost in\n   transit (DTLS does not retransmit Alert messages).\n
        \  If a cookie fails to validate, this could represent a WTP error, or\n   it
        could represent a DoS attack.  Hence, AC resource utilization\n   SHOULD be
        minimized.  The AC MAY log a message indicating the\n   failure, and SHOULD
        treat the message as though no cookie were\n   present.\n   Since DTLS Handshake
        messages are potentially larger than the maximum\n   record size, DTLS supports
        fragmenting of Handshake messages across\n   multiple records.  There are
        several potential causes of re-assembly\n   errors, including overlapping
        and/or lost fragments.  The DTLS\n   component MUST send a DTLSReassemblyFailure
        notification to the\n   CAPWAP component.  Whether precise information is
        given along with\n   notification is an implementation issue, and hence is
        beyond the\n   scope of this document.  Upon receipt of such an error, the
        CAPWAP\n   component SHOULD log an appropriate error message.  Whether\n   processing
        continues or the DTLS session is terminated is\n   implementation dependent.\n
        \  DTLS decapsulation errors consist of three types: decryption errors,\n
        \  authentication errors, and malformed DTLS record headers.  Since DTLS\n
        \  authenticates the data prior to encapsulation, if decryption fails,\n   it
        is difficult to detect this without first attempting to\n   authenticate the
        packet.  If authentication fails, a decryption error\n   is also likely, but
        not guaranteed.  Rather than attempt to derive\n   (and require the implementation
        of) algorithms for detecting\n   decryption failures, decryption failures
        are reported as\n   authentication failures.  The DTLS component MUST provide
        a\n   DTLSDecapFailure notification to the CAPWAP component when such\n   errors
        occur.  If a malformed DTLS record header is detected, the\n   packets SHOULD
        be silently discarded, and the receiver MAY log an\n   error message.\n   There
        is currently only one encapsulation error defined: MTU\n   exceeded.  As part
        of DTLS session establishment, the CAPWAP\n   component informs the DTLS component
        of the MTU size.  This may be\n   dynamically modified at any time when the
        CAPWAP component sends the\n   DTLSMtuUpdate command to the DTLS component
        (see Section 2.3.2.1).\n   The value provided to the DTLS stack is the result
        of the MTU\n   Discovery process, which is described in Section 3.5.  The
        DTLS\n   component returns this notification to the CAPWAP component whenever\n
        \  a transmission request will result in a packet that exceeds the MTU.\n"
      title: 2.4.3.  DTLS Error Handling
    - contents:
      - "2.4.4.  DTLS Endpoint Authentication and Authorization\n   DTLS supports
        endpoint authentication with certificates or pre-shared\n   keys.  The TLS
        algorithm suites for each endpoint authentication\n   method are described
        below.\n"
      - contents:
        - "2.4.4.1.  Authenticating with Certificates\n   CAPWAP implementations only
          use cipher suites that are recommended\n   for use with DTLS, see [DTLS-DESIGN].
          \ At present, the following\n   algorithms MUST be supported when using
          certificates for CAPWAP\n   authentication:\n   o  TLS_RSA_WITH_AES_128_CBC_SHA
          [RFC5246]\n   The following algorithms SHOULD be supported when using certificates:\n
          \  o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA [RFC5246]\n   The following algorithms
          MAY be supported when using certificates:\n   o  TLS_RSA_WITH_AES_256_CBC_SHA
          [RFC5246]\n   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA [RFC5246]\n   Additional
          ciphers MAY be defined in subsequent CAPWAP\n   specifications.\n"
        title: 2.4.4.1.  Authenticating with Certificates
      - contents:
        - "2.4.4.2.  Authenticating with Pre-Shared Keys\n   Pre-shared keys present
          significant challenges from a security\n   perspective, and for that reason,
          their use is strongly discouraged.\n   Several methods for authenticating
          with pre-shared keys are defined\n   [RFC4279], and we focus on the following
          two:\n   o  Pre-Shared Key (PSK) key exchange algorithm - simplest method,\n
          \     ciphersuites use only symmetric key algorithms.\n   o  DHE_PSK key
          exchange algorithm - use a PSK to authenticate a\n      Diffie-Hellman exchange.
          \ These ciphersuites give some additional\n      protection against dictionary
          attacks and also provide Perfect\n      Forward Secrecy (PFS).\n   The first
          approach (plain PSK) is susceptible to passive dictionary\n   attacks; hence,
          while this algorithm MUST be supported, special care\n   should be taken
          when choosing that method.  In particular, user-\n   readable passphrases
          SHOULD NOT be used, and use of short PSKs SHOULD\n   be strongly discouraged.\n
          \  The following cryptographic algorithms MUST be supported when using\n
          \  pre-shared keys:\n   o  TLS_PSK_WITH_AES_128_CBC_SHA [RFC5246]\n   o
          \ TLS_DHE_PSK_WITH_AES_128_CBC_SHA [RFC5246]\n   The following algorithms
          MAY be supported when using pre-shared keys:\n   o  TLS_PSK_WITH_AES_256_CBC_SHA
          [RFC5246]\n   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA [RFC5246]\n   Additional
          ciphers MAY be defined in following CAPWAP specifications.\n"
        title: 2.4.4.2.  Authenticating with Pre-Shared Keys
      - contents:
        - "2.4.4.3.  Certificate Usage\n   Certificate authorization by the AC and
          WTP is required so that only\n   an AC may perform the functions of an AC
          and that only a WTP may\n   perform the functions of a WTP.  This restriction
          of functions to the\n   AC or WTP requires that the certificates used by
          the AC MUST be\n   distinguishable from the certificate used by the WTP.
          \ To accomplish\n   this differentiation, the x.509 certificates MUST include
          the\n   Extended Key Usage (EKU) certificate extension [RFC5280].\n   The
          EKU field indicates one or more purposes for which a certificate\n   may
          be used.  It is an essential part in authorization.  Its syntax\n   is described
          in [RFC5280] and [ISO.9834-1.1993] and is as follows:\n         ExtKeyUsageSyntax
          \ ::=  SEQUENCE SIZE (1..MAX) OF KeyPurposeId\n         KeyPurposeId  ::=
          \ OBJECT IDENTIFIER\n   Here we define two KeyPurposeId values, one for
          the WTP and one for\n   the AC.  Inclusion of one of these two values indicates
          a certificate\n   is authorized for use by a WTP or AC, respectively.  These
          values are\n   formatted as id-kp fields.\n             id-kp  OBJECT IDENTIFIER
          \ ::=\n                 { iso(1) identified-organization(3) dod(6) internet(1)\n
          \                  security(5) mechanisms(5) pkix(7) 3 }\n              id-kp-capwapAC
          \  OBJECT IDENTIFIER  ::=  { id-kp 18 }\n              id-kp-capwapWTP  OBJECT
          IDENTIFIER  ::=  { id-kp 19 }\n   All capwap devices MUST support the ExtendedKeyUsage
          certificate\n   extension if it is present in a certificate.  If the extension
          is\n   present, then the certificate MUST have either the id-kp-capwapAC
          or\n   the id-kp-anyExtendedKeyUsage keyPurposeID to act as an AC.\n   Similarly,
          if the extension is present, a device MUST have the id-kp-\n   capwapWTP
          or id-kp-anyExtendedKeyUsage keyPurposeID to act as a WTP.\n   Part of the
          CAPWAP certificate validation process includes ensuring\n   that the proper
          EKU is included and allowing the CAPWAP session to be\n   established only
          if the extension properly represents the device.\n   For instance, an AC
          SHOULD NOT accept a connection request from\n   another AC, and therefore
          MUST verify that the id-kp-capwapWTP EKU is\n   present in the certificate.\n
          \  CAPWAP implementations MUST support certificates where the common\n   name
          (CN) for both the WTP and AC is the MAC address of that device.\n   The
          MAC address MUST be encoded in the PrintableString format, using\n   the
          well-recognized MAC address format of 01:23:45:67:89:ab.  The CN\n   field
          MAY contain either of the EUI-48 [EUI-48] or EUI-64 [EUI-64]\n   MAC Address
          formats.  This seemingly unconventional use of the CN\n   field is consistent
          with other standards that rely on device\n   certificates that are provisioned
          during the manufacturing process,\n   such as Packet Cable [PacketCable],
          Cable Labs [CableLabs], and WiMAX\n   [WiMAX].  See Section 12.8 for more
          information on the use of the MAC\n   address in the CN field.\n   ACs and
          WTPs MUST authorize (e.g., through access control lists)\n   certificates
          of devices to which they are connecting, e.g., based on\n   the issuer,
          MAC address, or organizational information specified in\n   the certificate.
          \ The identities specified in the certificates bind a\n   particular DTLS
          session to a specific pair of mutually authenticated\n   and authorized
          MAC addresses.  The particulars of authorization\n   filter construction
          are implementation details which are, for the\n   most part, not within
          the scope of this specification.  However, at\n   minimum, all devices MUST
          verify that the appropriate EKU bit is set\n   according to the role of
          the peer device (AC versus WTP), and that\n   the issuer of the certificate
          is appropriate for the domain in\n   question.\n"
        title: 2.4.4.3.  Certificate Usage
      - contents:
        - "2.4.4.4.  PSK Usage\n   When DTLS uses PSK Ciphersuites, the ServerKeyExchange
          message MUST\n   contain the \"PSK identity hint\" field and the ClientKeyExchange\n
          \  message MUST contain the \"PSK identity\" field.  These fields are used\n
          \  to help the WTP select the appropriate PSK for use with the AC, and\n
          \  then indicate to the AC which key is being used.  When PSKs are\n   provisioned
          to WTPs and ACs, both the PSK Hint and PSK Identity for\n   the key MUST
          be specified.\n   The PSK Hint SHOULD uniquely identify the AC and the PSK
          Identity\n   SHOULD uniquely identify the WTP.  It is RECOMMENDED that these
          hints\n   and identities be the ASCII HEX-formatted MAC addresses of the\n
          \  respective devices, since each pairwise combination of WTP and AC\n   SHOULD
          have a unique PSK.  The PSK Hint and Identity SHOULD be\n   sufficient to
          perform authorization, as simply having knowledge of a\n   PSK does not
          necessarily imply authorization.\n   If a single PSK is being used for multiple
          devices on a CAPWAP\n   network, which is NOT RECOMMENDED, the PSK Hint
          and Identity can no\n   longer be a MAC address, so appropriate hints and
          identities SHOULD\n   be selected to identify the group of devices to which
          the PSK is\n   provisioned.\n"
        title: 2.4.4.4.  PSK Usage
      title: 2.4.4.  DTLS Endpoint Authentication and Authorization
    title: 2.4.  Use of DTLS in the CAPWAP Protocol
  title: 2.  Protocol Overview
- contents:
  - "3.  CAPWAP Transport\n   Communication between a WTP and an AC is established
    using the\n   standard UDP client/server model.  The CAPWAP protocol supports
    both\n   UDP and UDP-Lite [RFC3828] transport protocols.  When run over IPv4,\n
    \  UDP is used for the CAPWAP Control and Data channels.\n   When run over IPv6,
    the CAPWAP Control channel always uses UDP, while\n   the CAPWAP Data channel
    may use either UDP or UDP-Lite.  UDP-Lite is\n   the default transport protocol
    for the CAPWAP Data channel.  However,\n   if a middlebox or IPv4 to IPv6 gateway
    has been discovered, UDP is\n   used for the CAPWAP Data channel.\n   This section
    describes how the CAPWAP protocol is carried over IP and\n   UDP/UDP-Lite transport
    protocols.  The CAPWAP Transport Protocol\n   message element, Section 4.6.14,
    describes the rules to use in\n   determining which transport protocol is to be
    used.\n   In order for CAPWAP to be compatible with potential middleboxes in\n
    \  the network, CAPWAP implementations MUST send return traffic from the\n   same
    port on which they received traffic from a given peer.  Further,\n   any unsolicited
    requests generated by a CAPWAP node MUST be sent on\n   the same port.\n"
  - contents:
    - "3.1.  UDP Transport\n   One of the CAPWAP protocol requirements is to allow
      a WTP to reside\n   behind a middlebox, firewall, and/or Network Address Translation\n
      \  (NAT) device.  Since a CAPWAP session is initiated by the WTP\n   (client)
      to the well-known UDP port of the AC (server), the use of\n   UDP is a logical
      choice.  When CAPWAP is run over IPv4, the UDP\n   checksum field in CAPWAP
      packets MUST be set to zero.\n   CAPWAP protocol control packets sent from the
      WTP to the AC use the\n   CAPWAP Control channel, as defined in Section 1.4.
      \ The CAPWAP\n   control port at the AC is the well-known UDP port 5246.  The
      CAPWAP\n   control port at the WTP can be any port selected by the WTP.\n   CAPWAP
      protocol data packets sent from the WTP to the AC use the\n   CAPWAP Data channel,
      as defined in Section 1.4.  The CAPWAP data port\n   at the AC is the well-known
      UDP port 5247.  If an AC permits the\n   administrator to change the CAPWAP
      control port, the CAPWAP data port\n   MUST be the next consecutive port number.
      \ The CAPWAP data port at\n   the WTP can be any port selected by the WTP.\n"
    title: 3.1.  UDP Transport
  - contents:
    - "3.2.  UDP-Lite Transport\n   When CAPWAP is run over IPv6, UDP-Lite is the
      default transport\n   protocol, which reduces the checksum processing required
      for each\n   packet (compared to the use of UDP over IPv6 [RFC2460]).  When
      UDP-\n   Lite is used, the checksum field MUST have a coverage of 8 [RFC3828].\n
      \  UDP-Lite uses the same port assignments as UDP.\n"
    title: 3.2.  UDP-Lite Transport
  - contents:
    - "3.3.  AC Discovery\n   The AC Discovery phase allows the WTP to determine which
      ACs are\n   available and choose the best AC with which to establish a CAPWAP\n
      \  session.  The Discovery phase occurs when the WTP enters the optional\n   Discovery
      state.  A WTP does not need to complete the AC Discovery\n   phase if it uses
      a pre-configured AC.  This section details the\n   mechanism used by a WTP to
      dynamically discover candidate ACs.\n   A WTP and an AC will frequently not
      reside in the same IP subnet\n   (broadcast domain).  When this occurs, the
      WTP must be capable of\n   discovering the AC, without requiring that multicast
      services are\n   enabled in the network.\n   When the WTP attempts to establish
      communication with an AC, it sends\n   the Discovery Request message and receives
      the Discovery Response\n   message from the AC(s).  The WTP MUST send the Discovery
      Request\n   message to either the limited broadcast IP address (255.255.255.255),\n
      \  the well-known CAPWAP multicast address (224.0.1.140), or to the\n   unicast
      IP address of the AC.  For IPv6 networks, since broadcast\n   does not exist,
      the use of \"All ACs multicast address\" (FF0X:0:0:0:0:\n   0:0:18C) is used
      instead.  Upon receipt of the Discovery Request\n   message, the AC sends a
      Discovery Response message to the unicast IP\n   address of the WTP, regardless
      of whether the Discovery Request\n   message was sent as a broadcast, multicast,
      or unicast message.\n   WTP use of a limited IP broadcast, multicast, or unicast
      IP address\n   is implementation dependent.  ACs, on the other hand, MUST support\n
      \  broadcast, multicast, and unicast discovery.\n   When a WTP transmits a Discovery
      Request message to a unicast\n   address, the WTP must first obtain the IP address
      of the AC.  Any\n   static configuration of an AC's IP address on the WTP non-volatile\n
      \  storage is implementation dependent.  However, additional dynamic\n   schemes
      are possible, for example:\n   DHCP:  See [RFC5417] for more information on
      the use of DHCP to\n      discover AC IP addresses.\n   DNS:  The WTP MAY support
      use of DNS Service Records (SRVs) [RFC2782]\n      to discover the AC address(es).
      \ In this case, the WTP first\n      obtains (e.g., from local configuration)
      the correct domain name\n      suffix (e.g., \"example.com\") and performs an
      SRV lookup with\n      Service name \"capwap-control\" and Proto \"udp\".  Thus,
      the name\n      resolved in DNS would be, e.g., \"_capwap-\n      control._udp.example.com\".
      \ Note that the SRV record MAY specify a\n      non-default port number for
      the control channel; the port number\n      for the data channel is the next
      port number (control channel port\n      + 1).\n   An AC MAY also communicate
      alternative ACs to the WTP within the\n   Discovery Response message through
      the AC IPv4 List (see\n   Section 4.6.2) and AC IPv6 List (see Section 4.6.2).
      \ The addresses\n   provided in these two message elements are intended to help
      the WTP\n   discover additional ACs through means other than those listed above.\n
      \  The AC Name with Priority message element (see Section 4.6.5) is used\n   to
      communicate a list of preferred ACs to the WTP.  The WTP SHOULD\n   attempt
      to utilize the ACs listed in the order provided by the AC.\n   The Name-to-IP
      Address mapping is handled via the Discovery message\n   exchange, in which
      the ACs provide their identity in the AC Name (see\n   Section 4.6.4) message
      element in the Discovery Response message.\n   Once the WTP has received Discovery
      Response messages from the\n   candidate ACs, it MAY use other factors to determine
      the preferred\n   AC.  For instance, each binding defines a WTP Radio Information\n
      \  message element (see Section 2.1), which the AC includes in Discovery\n   Response
      messages.  The presence of one or more of these message\n   elements is used
      to identify the CAPWAP bindings supported by the AC.\n   A WTP MAY connect to
      an AC based on the supported bindings\n   advertised.\n"
    title: 3.3.  AC Discovery
  - contents:
    - "3.4.  Fragmentation/Reassembly\n   While fragmentation and reassembly services
      are provided by IP, the\n   CAPWAP protocol also provides such services.  Environments
      where the\n   CAPWAP protocol is used involve firewall, NAT, and \"middlebox\"\n
      \  devices, which tend to drop IP fragments to minimize possible DoS\n   attacks.
      \ By providing fragmentation and reassembly at the\n   application layer, any
      fragmentation required due to the tunneling\n   component of the CAPWAP protocol
      becomes transparent to these\n   intermediate devices.  Consequently, the CAPWAP
      protocol can be used\n   in any network topology including firewall, NAT, and
      middlebox\n   devices.\n   It is important to note that the fragmentation mechanism
      employed by\n   CAPWAP has known limitations and deficiencies, which are similar
      to\n   those described in [RFC4963].  The limited size of the Fragment ID\n
      \  field (see Section 4.3) can cause wrapping of the field, and hence\n   cause
      fragments from different datagrams to be incorrectly spliced\n   together (known
      as \"mis-associated\").  For example, a 100Mpbs link\n   with an MTU of 1500
      (causing fragmentation at 1450 bytes) would cause\n   the Fragment ID field
      wrap in 8 seconds.  Consequently, CAPWAP\n   implementers are warned to properly
      size their buffers for reassembly\n   purposes based on the expected wireless
      technology throughput.\n   CAPWAP implementations SHOULD perform MTU Discovery
      (see\n   Section 3.5), which can avoid the need for fragmentation.  At the\n
      \  time of writing of this specification, most enterprise switching and\n   routing
      infrastructure were capable of supporting \"mini-jumbo\" frames\n   (1800 bytes),
      which eliminates the need for fragmentation (assuming\n   the station's MTU
      is 1500 bytes).  The need for fragmentation\n   typically continues to exist
      when the WTP communicates with the AC\n   over a Wide Area Network (WAN).  Therefore,
      future versions of the\n   CAPWAP protocol SHOULD consider either increasing
      the size of the\n   Fragment ID field or providing alternative extensions.\n"
    title: 3.4.  Fragmentation/Reassembly
  - contents:
    - "3.5.  MTU Discovery\n   Once a WTP has discovered the AC with which it wishes
      to establish a\n   CAPWAP session, it SHOULD perform a Path MTU (PMTU) discovery.
      \ One\n   recommendation for performing PMTU discovery is to have the WTP\n
      \  transmit Discovery Request (see Section 5.1) messages, and include\n   the
      MTU Discovery Padding message element (see Section 4.6.32).  The\n   actual
      procedures used for PMTU discovery are described in [RFC1191]\n   for IPv4;
      for IPv6, [RFC1981] SHOULD be used.  Alternatively,\n   implementers MAY use
      the procedures defined in [RFC4821].  The WTP\n   SHOULD also periodically re-evaluate
      the PMTU using the guidelines\n   provided in these two RFCs, using the Primary
      Discovery Request (see\n   Section 5.3) along with the MTU Discovery Padding
      message element\n   (see Section 4.6.32).  When the MTU is initially known,
      or updated in\n   the case where an existing session already exists, the discovered\n
      \  PMTU is used to configure the DTLS component (see Section 2.3.2.1),\n   while
      non-DTLS frames need to be fragmented to fit the MTU, defined\n   in Section
      3.4.\n"
    title: 3.5.  MTU Discovery
  title: 3.  CAPWAP Transport
- contents:
  - "4.  CAPWAP Packet Formats\n   This section contains the CAPWAP protocol packet
    formats.  A CAPWAP\n   protocol packet consists of one or more CAPWAP Transport
    Layer packet\n   headers followed by a CAPWAP message.  The CAPWAP message can
    be\n   either of type Control or Data, where Control packets carry\n   signaling,
    and Data packets carry user payloads.  The CAPWAP frame\n   formats for CAPWAP
    Data packets, and for DTLS encapsulated CAPWAP\n   Data and Control packets are
    defined below.\n   The CAPWAP Control protocol includes two messages that are
    never\n   protected by DTLS: the Discovery Request message and the Discovery\n
    \  Response message.  These messages need to be in the clear to allow\n   the
    CAPWAP protocol to properly identify and process them.  The\n   format of these
    packets are as follows:\n       CAPWAP Control Packet (Discovery Request/Response):\n
    \      +-------------------------------------------+\n       | IP  | UDP | CAPWAP
    | Control | Message    |\n       | Hdr | Hdr | Header | Header  | Element(s) |\n
    \      +-------------------------------------------+\n   All other CAPWAP Control
    protocol messages MUST be protected via the\n   DTLS protocol, which ensures that
    the packets are both authenticated\n   and encrypted.  These packets include the
    CAPWAP DTLS Header, which\n   is described in Section 4.2.  The format of these
    packets is as\n   follows:\n    CAPWAP Control Packet (DTLS Security Required):\n
    \   +------------------------------------------------------------------+\n    |
    IP  | UDP | CAPWAP   | DTLS | CAPWAP | Control| Message   | DTLS |\n    | Hdr
    | Hdr | DTLS Hdr | Hdr  | Header | Header | Element(s)| Trlr |\n    +------------------------------------------------------------------+\n
    \                          \\---------- authenticated -----------/\n                                  \\-------------
    encrypted ------------/\n   The CAPWAP protocol allows optional protection of
    data packets, using\n   DTLS.  Use of data packet protection is determined by
    AC policy.\n   When DTLS is utilized, the optional CAPWAP DTLS Header is present,\n
    \  which is described in Section 4.2.  The format of CAPWAP Data packets\n   is
    shown below:\n       CAPWAP Plain Text Data Packet :\n       +-------------------------------+\n
    \      | IP  | UDP | CAPWAP | Wireless |\n       | Hdr | Hdr | Header | Payload
    \ |\n       +-------------------------------+\n       DTLS Secured CAPWAP Data
    Packet:\n       +--------------------------------------------------------+\n       |
    IP  | UDP |  CAPWAP  | DTLS | CAPWAP | Wireless | DTLS |\n       | Hdr | Hdr |
    DTLS Hdr | Hdr  |  Hdr   | Payload  | Trlr |\n       +--------------------------------------------------------+\n
    \                             \\------ authenticated -----/\n                                     \\-------
    encrypted --------/\n   UDP Header:  All CAPWAP packets are encapsulated within
    either UDP,\n      or UDP-Lite when used over IPv6.  Section 3 defines the specific\n
    \     UDP or UDP-Lite usage.\n   CAPWAP DTLS Header:  All DTLS encrypted CAPWAP
    protocol packets are\n      prefixed with the CAPWAP DTLS Header (see Section
    4.2).\n   DTLS Header:  The DTLS Header provides authentication and encryption\n
    \     services to the CAPWAP payload it encapsulates.  This protocol is\n      defined
    in [RFC4347].\n   CAPWAP Header:  All CAPWAP protocol packets use a common header
    that\n      immediately follows the CAPWAP preamble or DTLS Header.  The\n      CAPWAP
    Header is defined in Section 4.3.\n   Wireless Payload:  A CAPWAP protocol packet
    that contains a wireless\n      payload is a CAPWAP Data packet.  The CAPWAP protocol
    does not\n      specify the format of the wireless payload, which is defined by\n
    \     the appropriate wireless standard.  Additional information is in\n      Section
    4.4.\n   Control Header:  The CAPWAP protocol includes a signaling component,\n
    \     known as the CAPWAP Control protocol.  All CAPWAP Control packets\n      include
    a Control Header, which is defined in Section 4.5.1.\n      CAPWAP Data packets
    do not contain a Control Header field.\n   Message Elements:  A CAPWAP Control
    packet includes one or more\n      message elements, which are found immediately
    following the\n      Control Header.  These message elements are in a Type/Length/Value\n
    \     style header, defined in Section 4.6.\n   A CAPWAP implementation MUST be
    capable of receiving a reassembled\n   CAPWAP message of length 4096 bytes.  A
    CAPWAP implementation MAY\n   indicate that it supports a higher maximum message
    length, by\n   including the Maximum Message Length message element, see\n   Section
    4.6.31, in the Join Request message or the Join Response\n   message.\n"
  - contents:
    - "4.1.  CAPWAP Preamble\n   The CAPWAP preamble is common to all CAPWAP transport
      headers and is\n   used to identify the header type that immediately follows.
      \ The\n   reason for this preamble is to avoid needing to perform byte\n   comparisons
      in order to guess whether or not the frame is DTLS\n   encrypted.  It also provides
      an extensibility framework that can be\n   used to support additional transport
      types.  The format of the\n   preamble is as follows:\n         0\n         0
      1 2 3 4 5 6 7\n        +-+-+-+-+-+-+-+-+\n        |Version| Type  |\n        +-+-+-+-+-+-+-+-+\n
      \  Version:  A 4-bit field that contains the version of CAPWAP used in\n      this
      packet.  The value for this specification is zero (0).\n   Type:  A 4-bit field
      that specifies the payload type that follows the\n      UDP header.  The following
      values are supported:\n      0 -   CAPWAP Header.  The CAPWAP Header (see Section
      4.3)\n            immediately follows the UDP header.  If the packet is\n            received
      on the CAPWAP Data channel, the CAPWAP stack MUST\n            treat the packet
      as a clear text CAPWAP Data packet.  If\n            received on the CAPWAP
      Control channel, the CAPWAP stack\n            MUST treat the packet as a clear
      text CAPWAP Control packet.\n            If the control packet is not a Discovery
      Request or\n            Discovery Response packet, the packet MUST be dropped.\n
      \     1 -   CAPWAP DTLS Header.  The CAPWAP DTLS Header (and DTLS\n            packet)
      immediately follows the UDP header (see\n            Section 4.2).\n"
    title: 4.1.  CAPWAP Preamble
  - contents:
    - "4.2.  CAPWAP DTLS Header\n   The CAPWAP DTLS Header is used to identify the
      packet as a DTLS\n   encrypted packet.  The first eight bits include the common
      CAPWAP\n   Preamble.  The remaining 24 bits are padding to ensure 4-byte\n   alignment,
      and MAY be used in a future version of the protocol.  The\n   DTLS packet [RFC4347]
      always immediately follows this header.  The\n   format of the CAPWAP DTLS Header
      is as follows:\n        0                   1                   2                   3\n
      \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |CAPWAP Preamble|                    Reserved                   |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  CAPWAP Preamble:  The CAPWAP Preamble is defined in Section 4.1.  The\n      CAPWAP
      Preamble's Payload Type field MUST be set to one (1).\n   Reserved:  The 24-bit
      field is reserved for future use.  All\n      implementations complying with
      this protocol MUST set to zero any\n      bits that are reserved in the version
      of the protocol supported by\n      that implementation.  Receivers MUST ignore
      all bits not defined\n      for the version of the protocol they support.\n"
    title: 4.2.  CAPWAP DTLS Header
  - contents:
    - "4.3.  CAPWAP Header\n   All CAPWAP protocol messages are encapsulated using
      a common header\n   format, regardless of the CAPWAP Control or CAPWAP Data
      transport\n   used to carry the messages.  However, certain flags are not\n
      \  applicable for a given transport.  Refer to the specific transport\n   section
      in order to determine which flags are valid.\n   Note that the optional fields
      defined in this section MUST be present\n   in the precise order shown below.\n
      \       0                   1                   2                   3\n        0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |CAPWAP Preamble|  HLEN   |   RID   | WBID    |T|F|L|W|M|K|Flags|\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |          Fragment ID          |     Frag Offset         |Rsvd |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                 (optional) Radio MAC Address                  |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |            (optional) Wireless Specific Information           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                        Payload ....                           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  CAPWAP Preamble:  The CAPWAP Preamble is defined in Section 4.1.  The\n      CAPWAP
      Preamble's Payload Type field MUST be set to zero (0).  If\n      the CAPWAP
      DTLS Header is present, the version number in both\n      CAPWAP Preambles MUST
      match.  The reason for this duplicate field\n      is to avoid any possible
      tampering of the version field in the\n      preamble that is not encrypted
      or authenticated.\n   HLEN:  A 5-bit field containing the length of the CAPWAP
      transport\n      header in 4-byte words (similar to IP header length).  This
      length\n      includes the optional headers.\n   RID:  A 5-bit field that contains
      the Radio ID number for this\n      packet, whose value is between one (1) and
      31.  Given that MAC\n      Addresses are not necessarily unique across physical
      radios in a\n      WTP, the Radio Identifier (RID) field is used to indicate
      with\n      which physical radio the message is associated.\n   WBID:  A 5-bit
      field that is the wireless binding identifier.  The\n      identifier will indicate
      the type of wireless packet associated\n      with the radio.  The following
      values are defined:\n      0 -  Reserved\n      1 -  IEEE 802.11\n      2 -
      \ Reserved\n      3 -  EPCGlobal [EPCGlobal]\n   T: The Type 'T' bit indicates
      the format of the frame being\n      transported in the payload.  When this
      bit is set to one (1), the\n      payload has the native frame format indicated
      by the WBID field.\n      When this bit is zero (0), the payload is an IEEE
      802.3 frame.\n   F: The Fragment 'F' bit indicates whether this packet is a
      fragment.\n      When this bit is one (1), the packet is a fragment and MUST
      be\n      combined with the other corresponding fragments to reassemble the\n
      \     complete information exchanged between the WTP and AC.\n   L: The Last
      'L' bit is valid only if the 'F' bit is set and indicates\n      whether the
      packet contains the last fragment of a fragmented\n      exchange between WTP
      and AC.  When this bit is one (1), the packet\n      is the last fragment.  When
      this bit is (zero) 0, the packet is\n      not the last fragment.\n   W: The
      Wireless 'W' bit is used to specify whether the optional\n      Wireless Specific
      Information field is present in the header.  A\n      value of one (1) is used
      to represent the fact that the optional\n      header is present.\n   M: The
      Radio MAC 'M' bit is used to indicate that the Radio MAC\n      Address optional
      header is present.  This is used to communicate\n      the MAC address of the
      receiving radio.\n   K: The Keep-Alive 'K' bit indicates the packet is a Data
      Channel\n      Keep-Alive packet.  This packet is used to map the data channel
      to\n      the control channel for the specified Session ID and to maintain\n
      \     freshness of the data channel.  The 'K' bit MUST NOT be set for\n      data
      packets containing user data.\n   Flags:  A set of reserved bits for future
      flags in the CAPWAP Header.\n      All implementations complying with this protocol
      MUST set to zero\n      any bits that are reserved in the version of the protocol\n
      \     supported by that implementation.  Receivers MUST ignore all bits\n      not
      defined for the version of the protocol they support.\n   Fragment ID:  A 16-bit
      field whose value is assigned to each group of\n      fragments making up a
      complete set.  The Fragment ID space is\n      managed individually for each
      direction for every WTP/AC pair.\n      The value of Fragment ID is incremented
      with each new set of\n      fragments.  The Fragment ID wraps to zero after
      the maximum value\n      has been used to identify a set of fragments.\n   Fragment
      Offset:  A 13-bit field that indicates where in the payload\n      this fragment
      belongs during re-assembly.  This field is valid\n      when the 'F' bit is
      set to 1.  The fragment offset is measured in\n      units of 8 octets (64 bits).
      \ The first fragment has offset zero.\n      Note that the CAPWAP protocol does
      not allow for overlapping\n      fragments.\n   Reserved:  The 3-bit field is
      reserved for future use.  All\n      implementations complying with this protocol
      MUST set to zero any\n      bits that are reserved in the version of the protocol
      supported by\n      that implementation.  Receivers MUST ignore all bits not
      defined\n      for the version of the protocol they support.\n   Radio MAC Address:
      \ This optional field contains the MAC address of\n      the radio receiving
      the packet.  Because the native wireless frame\n      format to IEEE 802.3 format
      causes the MAC address of the WTP's\n      radio to be lost, this field allows
      the address to be communicated\n      to the AC.  This field is only present
      if the 'M' bit is set.  The\n      HLEN field assumes 4-byte alignment, and
      this field MUST be padded\n      with zeroes (0x00) if it is not 4-byte aligned.\n
      \     The field contains the basic format:\n        0                   1                   2
      \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
      3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |     Length    |                  MAC Address\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     Length:  The length of the MAC address field.  The formats and\n         lengths
      specified in [EUI-48] and [EUI-64] are supported.\n      MAC Address:  The MAC
      address of the receiving radio.\n   Wireless Specific Information:  This optional
      field contains\n      technology-specific information that may be used to carry
      per-\n      packet wireless information.  This field is only present if the\n
      \     'W' bit is set.  The WBID field in the CAPWAP Header is used to\n      identify
      the format of the Wireless-Specific Information optional\n      field.  The
      HLEN field assumes 4-byte alignment, and this field\n      MUST be padded with
      zeroes (0x00) if it is not 4-byte aligned.\n      The Wireless-Specific Information
      field uses the following format:\n        0                   1                   2
      \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
      3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |    Length     |                Data...\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     Length:  The 8-bit field contains the length of the data field,\n         with
      a maximum size of 255.\n      Data:  Wireless-specific information, defined
      by the wireless-\n         specific binding specified in the CAPWAP Header's
      WBID field.\n   Payload:  This field contains the header for a CAPWAP Data Message
      or\n      CAPWAP Control Message, followed by the data contained in the\n      message.\n"
    title: 4.3.  CAPWAP Header
  - contents:
    - "4.4.  CAPWAP Data Messages\n   There are two different types of CAPWAP Data
      packets: CAPWAP Data\n   Channel Keep-Alive packets and Data Payload packets.
      \ The first is\n   used by the WTP to synchronize the control and data channels
      and to\n   maintain freshness of the data channel.  The second is used to\n
      \  transmit user payloads between the AC and WTP.  This section\n   describes
      both types of CAPWAP Data packet formats.\n   Both CAPWAP Data messages are
      transmitted on the CAPWAP Data channel.\n"
    - contents:
      - "4.4.1.  CAPWAP Data Channel Keep-Alive\n   The CAPWAP Data Channel Keep-Alive
        packet is used to bind the CAPWAP\n   control channel with the data channel,
        and to maintain freshness of\n   the data channel, ensuring that the channel
        is still functioning.\n   The CAPWAP Data Channel Keep-Alive packet is transmitted
        by the WTP\n   when the DataChannelKeepAlive timer expires (see Section 4.7.2).\n
        \  When the CAPWAP Data Channel Keep-Alive packet is transmitted, the\n   WTP
        sets the DataChannelDeadInterval timer.\n   In the CAPWAP Data Channel Keep-Alive
        packet, all of the fields in\n   the CAPWAP Header, except the HLEN field
        and the 'K' bit, are set to\n   zero upon transmission.  Upon receiving a
        CAPWAP Data Channel Keep-\n   Alive packet, the AC transmits a CAPWAP Data
        Channel Keep-Alive\n   packet back to the WTP.  The contents of the transmitted
        packet are\n   identical to the contents of the received packet.\n   Upon
        receiving a CAPWAP Data Channel Keep-Alive packet, the WTP\n   cancels the
        DataChannelDeadInterval timer and resets the\n   DataChannelKeepAlive timer.
        \ The CAPWAP Data Channel Keep-Alive\n   packet is retransmitted by the WTP
        in the same manner as the CAPWAP\n   Control messages.  If the DataChannelDeadInterval
        timer expires, the\n   WTP tears down the control DTLS session, and the data
        DTLS session if\n   one existed.\n   The CAPWAP Data Channel Keep-Alive packet
        contains the following\n   payload immediately following the CAPWAP Header
        (see Section 4.3).\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |    Message Element Length     |  Message Element [0..N] ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Message Element Length:   The 16-bit Length field indicates the\n      number
        of bytes following the CAPWAP Header, with a maximum size\n      of 65535.\n
        \  Message Element[0..N]:   The message element(s) carry the information\n
        \     pertinent to each of the CAPWAP Data Channel Keep-Alive message.\n      The
        following message elements MUST be present in this CAPWAP\n      message:\n
        \        Session ID, see Section 4.6.37.\n"
      title: 4.4.1.  CAPWAP Data Channel Keep-Alive
    - contents:
      - "4.4.2.  Data Payload\n   A CAPWAP protocol Data Payload packet encapsulates
        a forwarded\n   wireless frame.  The CAPWAP protocol defines two different
        modes of\n   encapsulation: IEEE 802.3 and native wireless.  IEEE 802.3\n
        \  encapsulation requires that for 802.11 frames, the 802.11\n   *Integration*
        function be performed in the WTP.  An IEEE 802.3-\n   encapsulated user payload
        frame has the following format:\n       +------------------------------------------------------+\n
        \      | IP Header | UDP Header | CAPWAP Header | 802.3 Frame |\n       +------------------------------------------------------+\n
        \  The CAPWAP protocol also defines the native wireless encapsulation\n   mode.
        \ The format of the encapsulated CAPWAP Data frame is subject to\n   the rules
        defined by the specific wireless technology binding.  Each\n   wireless technology
        binding MUST contain a section entitled \"Payload\n   Encapsulation\", which
        defines the format of the wireless payload that\n   is encapsulated within
        CAPWAP Data packets.\n   For 802.3 payload frames, the 802.3 frame is encapsulated
        (excluding\n   the IEEE 802.3 Preamble, Start Frame Delimiter (SFD), and Frame
        Check\n   Sequence (FCS) fields).  If the encapsulated frame would exceed
        the\n   transport layer's MTU, the sender is responsible for the\n   fragmentation
        of the frame, as specified in Section 3.4.  The CAPWAP\n   protocol can support
        IEEE 802.3 frames whose length is defined in the\n   IEEE 802.3as specification
        [FRAME-EXT].\n"
      title: 4.4.2.  Data Payload
    - contents:
      - "4.4.3.  Establishment of a DTLS Data Channel\n   If the AC and WTP are configured
        to tunnel the data channel over\n   DTLS, the proper DTLS session must be
        initiated.  To avoid having to\n   reauthenticate and reauthorize an AC and
        WTP, the DTLS data channel\n   SHOULD be initiated using the TLS session resumption
        feature\n   [RFC5246].\n   The AC DTLS implementation MUST NOT initiate a
        data channel session\n   for a DTLS session for which there is no active control
        channel\n   session.\n"
      title: 4.4.3.  Establishment of a DTLS Data Channel
    title: 4.4.  CAPWAP Data Messages
  - contents:
    - "4.5.  CAPWAP Control Messages\n   The CAPWAP Control protocol provides a control
      channel between the\n   WTP and the AC.  Control messages are divided into the
      following\n   message types:\n   Discovery:  CAPWAP Discovery messages are used
      to identify potential\n      ACs, their load and capabilities.\n   Join:  CAPWAP
      Join messages are used by a WTP to request service from\n      an AC, and for
      the AC to respond to the WTP.\n   Control Channel Management:  CAPWAP Control
      channel management\n      messages are used to maintain the control channel.\n
      \  WTP Configuration Management:  The WTP Configuration messages are\n      used
      by the AC to deliver a specific configuration to the WTP.\n      Messages that
      retrieve statistics from a WTP are also included in\n      WTP Configuration
      Management.\n   Station Session Management:  Station Session Management messages
      are\n      used by the AC to deliver specific station policies to the WTP.\n
      \  Device Management Operations:  Device management operations are used\n      to
      request and deliver a firmware image to the WTP.\n   Binding-Specific CAPWAP
      Management Messages:  Messages in this\n      category are used by the AC and
      the WTP to exchange protocol-\n      specific CAPWAP management messages.  These
      messages may or may\n      not be used to change the link state of a station.\n
      \  Discovery, Join, Control Channel Management, WTP Configuration\n   Management,
      and Station Session Management CAPWAP Control messages\n   MUST be implemented.
      \ Device Management Operations messages MAY be\n   implemented.\n   CAPWAP Control
      messages sent from the WTP to the AC indicate that the\n   WTP is operational,
      providing an implicit keep-alive mechanism for\n   the WTP.  The Control Channel
      Management Echo Request and Echo\n   Response messages provide an explicit keep-alive
      mechanism when other\n   CAPWAP Control messages are not exchanged.\n"
    - contents:
      - "4.5.1.  Control Message Format\n   All CAPWAP Control messages are sent encapsulated
        within the CAPWAP\n   Header (see Section 4.3).  Immediately following the
        CAPWAP Header is\n   the control header, which has the following format:\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                       Message Type                            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |    Seq Num    |        Msg Element Length     |     Flags     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    | Msg Element [0..N] ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+\n"
      - contents:
        - "4.5.1.1.  Message Type\n   The Message Type field identifies the function
          of the CAPWAP Control\n   message.  To provide extensibility, the Message
          Type field is\n   comprised of an IANA Enterprise Number [RFC3232] and an
          enterprise-\n   specific message type number.  The first three octets contain
          the\n   IANA Enterprise Number in network byte order, with zero used for\n
          \  CAPWAP base protocol (this specification) defined message types.  The\n
          \  last octet is the enterprise-specific message type number, which has\n
          \  a range from 0 to 255.\n   The Message Type field is defined as:\n         Message
          Type =\n                 IANA Enterprise Number * 256 +\n                     Enterprise
          Specific Message Type Number\n   The CAPWAP protocol reliability mechanism
          requires that messages be\n   defined in pairs, consisting of both a Request
          and a Response\n   message.  The Response message MUST acknowledge the Request
          message.\n   The assignment of CAPWAP Control Message Type Values always
          occurs in\n   pairs.  All Request messages have odd numbered Message Type
          Values,\n   and all Response messages have even numbered Message Type Values.\n
          \  The Request value MUST be assigned first.  As an example, assigning a\n
          \  Message Type Value of 3 for a Request message and 4 for a Response\n
          \  message is valid, while assigning a Message Type Value of 4 for a\n   Response
          message and 5 for the corresponding Request message is\n   invalid.\n   When
          a WTP or AC receives a message with a Message Type Value field\n   that
          is not recognized and is an odd number, the number in the\n   Message Type
          Value Field is incremented by one, and a Response\n   message with a Message
          Type Value field containing the incremented\n   value and containing the
          Result Code message element with the value\n   (Unrecognized Request) is
          returned to the sender of the received\n   message.  If the unknown message
          type is even, the message is\n   ignored.\n   The valid values for CAPWAP
          Control Message Types are specified in\n   the table below:\n           CAPWAP
          Control Message           Message Type\n                                              Value\n
          \          Discovery Request                    1\n           Discovery
          Response                   2\n           Join Request                         3\n
          \          Join Response                        4\n           Configuration
          Status Request         5\n           Configuration Status Response        6\n
          \          Configuration Update Request         7\n           Configuration
          Update Response        8\n           WTP Event Request                    9\n
          \          WTP Event Response                  10\n           Change State
          Event Request          11\n           Change State Event Response         12\n
          \          Echo Request                        13\n           Echo Response
          \                      14\n           Image Data Request                  15\n
          \          Image Data Response                 16\n           Reset Request
          \                      17\n           Reset Response                      18\n
          \          Primary Discovery Request           19\n           Primary Discovery
          Response          20\n           Data Transfer Request               21\n
          \          Data Transfer Response              22\n           Clear Configuration
          Request         23\n           Clear Configuration Response        24\n
          \          Station Configuration Request       25\n           Station Configuration
          Response      26\n"
        title: 4.5.1.1.  Message Type
      - contents:
        - "4.5.1.2.  Sequence Number\n   The Sequence Number field is an identifier
          value used to match\n   Request and Response packets.  When a CAPWAP packet
          with a Request\n   Message Type Value is received, the value of the Sequence
          Number\n   field is copied into the corresponding Response message.\n   When
          a CAPWAP Control message is sent, the sender's internal sequence\n   number
          counter is monotonically incremented, ensuring that no two\n   pending Request
          messages have the same sequence number.  The Sequence\n   Number field wraps
          back to zero.\n"
        title: 4.5.1.2.  Sequence Number
      - contents:
        - "4.5.1.3.  Message Element Length\n   The Length field indicates the number
          of bytes following the Sequence\n   Number field.\n"
        title: 4.5.1.3.  Message Element Length
      - contents:
        - "4.5.1.4.  Flags\n   The Flags field MUST be set to zero.\n"
        title: 4.5.1.4.  Flags
      - contents:
        - "4.5.1.5.  Message Element [0..N]\n   The message element(s) carry the information
          pertinent to each of the\n   control message types.  Every control message
          in this specification\n   specifies which message elements are permitted.\n
          \  When a WTP or AC receives a CAPWAP message without a message element\n
          \  that is specified as mandatory for the CAPWAP message, then the\n   CAPWAP
          message is discarded.  If the received message was a Request\n   message
          for which the corresponding Response message carries message\n   elements,
          then a corresponding Response message with a Result Code\n   message element
          indicating \"Failure - Missing Mandatory Message\n   Element\" is returned
          to the sender.\n   When a WTP or AC receives a CAPWAP message with a message
          element\n   that the WTP or AC does not recognize, the CAPWAP message is\n
          \  discarded.  If the received message was a Request message for which\n
          \  the corresponding Response message carries message elements, then a\n
          \  corresponding Response message with a Result Code message element\n   indicating
          \"Failure - Unrecognized Message Element\" and one or more\n   Returned
          Message Element message elements is included, containing the\n   unrecognized
          message element(s).\n"
        title: 4.5.1.5.  Message Element [0..N]
      title: 4.5.1.  Control Message Format
    - contents:
      - "4.5.2.  Quality of Service\n   The CAPWAP base protocol does not provide
        any Quality of Service\n   (QoS) recommendations for use with the CAPWAP Data
        messages.  Any\n   wireless-specific CAPWAP binding specification that has
        QoS\n   requirements MUST define the application of QoS to the CAPWAP Data\n
        \  messages.\n   The IP header also includes the Explicit Congestion Notification\n
        \  (ECN) bits [RFC3168].  Section 9.1.1 of [RFC3168] describes two\n   levels
        of ECN functionality: full functionality and limited\n   functionality.  CAPWAP
        ACs and WTPs SHALL implement the limited\n   functionality and are RECOMMENDED
        to implement the full functionality\n   described in [RFC3168].\n"
      - contents:
        - "4.5.2.1.  Applying QoS to CAPWAP Control Message\n   It is recommended
          that CAPWAP Control messages be sent by both the AC\n   and the WTP with
          an appropriate Quality-of-Service precedence value,\n   ensuring that congestion
          in the network minimizes occurrences of\n   CAPWAP Control channel disconnects.
          \ Therefore, a QoS-enabled CAPWAP\n   device SHOULD use the following values:\n
          \  802.1Q:   The priority tag of 7 SHOULD be used.\n   DSCP:   The CS6 per-hop
          behavior Service Class SHOULD be used, which\n      is described in [RFC2474]).\n"
        title: 4.5.2.1.  Applying QoS to CAPWAP Control Message
      title: 4.5.2.  Quality of Service
    - contents:
      - "4.5.3.  Retransmissions\n   The CAPWAP Control protocol operates as a reliable
        transport.  For\n   each Request message, a Response message is defined, which
        is used to\n   acknowledge receipt of the Request message.  In addition, the
        control\n   header Sequence Number field is used to pair the Request and Response\n
        \  messages (see Section 4.5.1).\n   Response messages are not explicitly
        acknowledged; therefore, if a\n   Response message is not received, the original
        Request message is\n   retransmitted.\n   Implementations MUST keep track
        of the sequence number of the last\n   received Request message, and MUST
        cache the corresponding Response\n   message.  If a retransmission with the
        same sequence number is\n   received, the cached Response message MUST be
        retransmitted without\n   re-processing the Request.  If an older Request
        message is received,\n   meaning one where the sequence number is smaller,
        it MUST be ignored.\n   A newer Request message, meaning one whose sequence
        number is larger,\n   is processed as usual.\n   Note: A sequence number is
        considered \"smaller\" when s1 is smaller\n   than s2 modulo 256 if and only
        if (s1<s2 and (s2-s1)<128) or\n   (s1>s2 and (s1-s2)>128).\n   Both the WTP
        and the AC can only have a single request outstanding at\n   any given time.
        \ Retransmitted Request messages MUST NOT be altered\n   by the sender.\n
        \  After transmitting a Request message, the RetransmitInterval (see\n   Section
        4.7) timer and MaxRetransmit (see Section 4.8) variable are\n   used to determine
        if the original Request message needs to be\n   retransmitted.  The RetransmitInterval
        timer is used the first time\n   the Request is retransmitted.  The timer
        is then doubled every\n   subsequent time the same Request message is retransmitted,
        up to\n   MaxRetransmit but no more than half the EchoInterval timer (see\n
        \  Section 4.7.7).  Response messages are not subject to these timers.\n   If
        the sender stops retransmitting a Request message before reaching\n   MaxRetransmit
        retransmissions (which leads to transition to DTLS\n   Teardown, as described
        in Section 2.3.1), it cannot know whether the\n   recipient received and processed
        the Request or not.  In most\n   situations, the sender SHOULD NOT do this,
        and instead continue\n   retransmitting until a Response message is received,
        or transition to\n   DTLS Teardown occurs.  However, if the sender does decide
        to continue\n   the connection with a new or modified Request message, the
        new\n   message MUST have a new sequence number, and be treated as a new\n
        \  Request message by the receiver.  Note that there is a high chance\n   that
        both the WTP and the AC's sequence numbers will become out of\n   sync.\n
        \  When a Request message is retransmitted, it MUST be re-encrypted via\n
        \  the DTLS stack.  If the peer had received the Request message, and\n   the
        corresponding Response message was lost, it is necessary to\n   ensure that
        retransmitted Request messages are not identified as\n   replays by the DTLS
        stack.  Similarly, any cached Response messages\n   that are retransmitted
        as a result of receiving a retransmitted\n   Request message MUST be re-encrypted
        via DTLS.\n   Duplicate Response messages, identified by the Sequence Number
        field\n   in the CAPWAP Control message header, SHOULD be discarded upon\n
        \  receipt.\n"
      title: 4.5.3.  Retransmissions
    title: 4.5.  CAPWAP Control Messages
  - contents:
    - "4.6.  CAPWAP Protocol Message Elements\n   This section defines the CAPWAP
      Protocol message elements that are\n   included in CAPWAP protocol control messages.\n
      \  Message elements are used to carry information needed in control\n   messages.
      \ Every message element is identified by the Type Value\n   field, defined below.
      \ The total length of the message elements is\n   indicated in the message element's
      length field.\n   All of the message element definitions in this document use
      a diagram\n   similar to the one below in order to depict its format.  Note
      that to\n   simplify this specification, these diagrams do not include the header\n
      \  fields (Type and Length).  The header field values are defined in the\n   message
      element descriptions.\n   Unless otherwise specified, a control message that
      lists a set of\n   supported (or expected) message elements MUST NOT expect
      the message\n   elements to be in any specific order.  The sender MAY include
      the\n   message elements in any order.  Unless otherwise noted, one message\n
      \  element of each type is present in a given control message.\n   Unless otherwise
      specified, any configuration information sent by the\n   AC to the WTP MAY be
      saved to non-volatile storage (see Section 8.1)\n   for more information).\n
      \  Additional message elements may be defined in separate IETF\n   documents.\n
      \  The format of a message element uses the TLV format shown here:\n      0
      \                  1                   2                   3\n      0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |              Type             |             Length            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |   Value ...   |\n     +-+-+-+-+-+-+-+-+\n   The 16-bit Type field identifies
      the information carried in the Value\n   field and Length (16 bits) indicates
      the number of bytes in the Value\n   field.  The value of zero (0) is reserved
      and MUST NOT be used.  The\n   rest of the Type field values are allocated as
      follows:\n              Usage                              Type Values\n   CAPWAP
      Protocol Message Elements                   1 - 1023\n   IEEE 802.11 Message
      Elements                    1024 - 2047\n   Reserved for Future Use                         2048
      - 3071\n   EPCGlobal Message Elements                      3072 - 4095\n   Reserved
      for Future Use                         4096 - 65535\n   The table below lists
      the CAPWAP protocol Message Elements and their\n   Type values.\n   CAPWAP Message
      Element                            Type Value\n   AC Descriptor                                         1\n
      \  AC IPv4 List                                          2\n   AC IPv6 List
      \                                         3\n   AC Name                                               4\n
      \  AC Name with Priority                                 5\n   AC Timestamp
      \                                         6\n   Add MAC ACL Entry                                     7\n
      \  Add Station                                           8\n   Reserved                                              9\n
      \  CAPWAP Control IPV4 Address                          10\n   CAPWAP Control
      IPV6 Address                          11\n   CAPWAP Local IPV4 Address                            30\n
      \  CAPWAP Local IPV6 Address                            50\n   CAPWAP Timers
      \                                       12\n   CAPWAP Transport Protocol                            51\n
      \  Data Transfer Data                                   13\n   Data Transfer
      Mode                                   14\n   Decryption Error Report                              15\n
      \  Decryption Error Report Period                       16\n   Delete MAC ACL
      Entry                                 17\n   Delete Station                                       18\n
      \  Reserved                                             19\n   Discovery Type
      \                                      20\n   Duplicate IPv4 Address                               21\n
      \  Duplicate IPv6 Address                               22\n   ECN Support                                          53\n
      \  Idle Timeout                                         23\n   Image Data                                           24\n
      \  Image Identifier                                     25\n   Image Information
      \                                   26\n   Initiate Download                                    27\n
      \  Location Data                                        28\n   Maximum Message
      Length                               29\n   MTU Discovery Padding                                52\n
      \  Radio Administrative State                           31\n   Radio Operational
      State                              32\n   Result Code                                          33\n
      \  Returned Message Element                             34\n   Session ID                                           35\n
      \  Statistics Timer                                     36\n   Vendor Specific
      Payload                              37\n   WTP Board Data                                       38\n
      \  WTP Descriptor                                       39\n   WTP Fallback
      \                                        40\n   WTP Frame Tunnel Mode                                41\n
      \  Reserved                                             42\n   Reserved                                             43\n
      \  WTP MAC Type                                         44\n   WTP Name                                             45\n
      \  Unused/Reserved                                      46\n   WTP Radio Statistics
      \                                47\n   WTP Reboot Statistics                                48\n
      \  WTP Static IP Address Information                    49\n"
    - contents:
      - "4.6.1.  AC Descriptor\n   The AC Descriptor message element is used by the
        AC to communicate\n   its current state.  The value contains the following
        fields.\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |            Stations           |             Limit             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |          Active WTPs          |            Max WTPs           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |    Security   |  R-MAC Field  |   Reserved1   |  DTLS Policy  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                  AC Information Sub-Element...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   1 for AC Descriptor\n   Length:   >= 12\n   Stations:   The number
        of stations currently served by the AC\n   Limit:   The maximum number of
        stations supported by the AC\n   Active WTPs:   The number of WTPs currently
        attached to the AC\n   Max WTPs:   The maximum number of WTPs supported by
        the AC\n   Security:   An 8-bit mask specifying the authentication credential\n
        \     type supported by the AC (see Section 2.4.4).  The field has the\n      following
        format:\n         0 1 2 3 4 5 6 7\n        +-+-+-+-+-+-+-+-+\n        |Reserved
        |S|X|R|\n        +-+-+-+-+-+-+-+-+\n      Reserved:  A set of reserved bits
        for future use.  All\n         implementations complying with this protocol
        MUST set to zero\n         any bits that are reserved in the version of the
        protocol\n         supported by that implementation.  Receivers MUST ignore
        all\n         bits not defined for the version of the protocol they support.\n
        \     S:    The AC supports the pre-shared secret authentication, as\n            described
        in Section 12.6.\n      X:    The AC supports X.509 Certificate authentication,
        as\n            described in Section 12.7.\n      R:    A reserved bit for
        future use.  All implementations\n            complying with this protocol
        MUST set to zero any bits that\n            are reserved in the version of
        the protocol supported by\n            that implementation.  Receivers MUST
        ignore all bits not\n            defined for the version of the protocol they
        support.\n   R-MAC Field:   The AC supports the optional Radio MAC Address
        field\n      in the CAPWAP transport header (see Section 4.3).  The following\n
        \     enumerated values are supported:\n      0 -  Reserved\n      1 -  Supported\n
        \     2 -  Not Supported\n   Reserved:  A set of reserved bits for future
        use.  All\n      implementations complying with this protocol MUST set to
        zero any\n      bits that are reserved in the version of the protocol supported
        by\n      that implementation.  Receivers MUST ignore all bits not defined\n
        \     for the version of the protocol they support.\n   DTLS Policy:   The
        AC communicates its policy on the use of DTLS for\n      the CAPWAP data channel.
        \ The AC MAY communicate more than one\n      supported option, represented
        by the bit field below.  The WTP\n      MUST abide by one of the options communicated
        by AC.  The field\n      has the following format:\n         0 1 2 3 4 5 6
        7\n        +-+-+-+-+-+-+-+-+\n        |Reserved |D|C|R|\n        +-+-+-+-+-+-+-+-+\n
        \     Reserved:  A set of reserved bits for future use.  All\n         implementations
        complying with this protocol MUST set to zero\n         any bits that are
        reserved in the version of the protocol\n         supported by that implementation.
        \ Receivers MUST ignore all\n         bits not defined for the version of
        the protocol they support.\n      D:    DTLS-Enabled Data Channel Supported\n
        \     C:    Clear Text Data Channel Supported\n      R:    A reserved bit
        for future use.  All implementations\n            complying with this protocol
        MUST set to zero any bits that\n            are reserved in the version of
        the protocol supported by\n            that implementation.  Receivers MUST
        ignore all bits not\n            defined for the version of the protocol they
        support.\n   AC Information Sub-Element:   The AC Descriptor message element\n
        \     contains multiple AC Information sub-elements, and defines two\n      sub-types,
        each of which MUST be present.  The AC Information sub-\n      element has
        the following format:\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                AC Information Vendor Identifier               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |      AC Information Type      |     AC Information Length     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                     AC Information Data...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     AC Information Vendor Identifier:   A 32-bit value containing the\n
        \        IANA-assigned \"Structure of Management Information (SMI)\n         Network
        Management Private Enterprise Codes\".\n      AC Information Type:   Vendor-specific
        encoding of AC information\n         in the UTF-8 format [RFC3629].  The following
        enumerated values\n         are supported.  Both the Hardware and Software
        Version sub-\n         elements MUST be included in the AC Descriptor message
        element.\n         The values listed below are used in conjunction with the
        AC\n         Information Vendor Identifier field, whose value MUST be set
        to\n         zero (0).  This field, combined with the AC Information Vendor\n
        \        Identifier set to a non-zero (0) value, allows vendors to use a\n
        \        private namespace.\n         4 -   Hardware Version: The AC's hardware
        version number.\n         5 -   Software Version: The AC's Software (firmware)
        version\n               number.\n      AC Information Length:   Length of
        vendor-specific encoding of AC\n         information, with a maximum size
        of 1024.\n      AC Information Data:   Vendor-specific encoding of AC information.\n"
      title: 4.6.1.  AC Descriptor
    - contents:
      - "4.6.2.  AC IPv4 List\n   The AC IPv4 List message element is used to configure
        a WTP with the\n   latest list of ACs available for the WTP to join.\n        0
        \                  1                   2                   3\n        0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       AC IP Address[]                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   2 for AC IPv4 List\n   Length:   >= 4\n   AC IP Address:   An array
        of 32-bit integers containing AC IPv4\n      Addresses, containing no more
        than 1024 addresses.\n"
      title: 4.6.2.  AC IPv4 List
    - contents:
      - "4.6.3.  AC IPv6 List\n   The AC IPv6 List message element is used to configure
        a WTP with the\n   latest list of ACs available for the WTP to join.\n        0
        \                  1                   2                   3\n        0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       AC IP Address[]                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       AC IP Address[]                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       AC IP Address[]                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       AC IP Address[]                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   3 for AC IPV6 List\n   Length:   >= 16\n   AC IP Address:   An
        array of 128-bit integers containing AC IPv6\n      Addresses, containing
        no more than 1024 addresses.\n"
      title: 4.6.3.  AC IPv6 List
    - contents:
      - "4.6.4.  AC Name\n   The AC Name message element contains an UTF-8 [RFC3629]\n
        \  representation of the AC identity.  The value is a variable-length\n   byte
        string.  The string is NOT zero terminated.\n      0\n      0 1 2 3 4 5 6
        7\n     +-+-+-+-+-+-+-+-+\n     |   Name ...\n     +-+-+-+-+-+-+-+-+\n   Type:
        \  4 for AC Name\n   Length:   >= 1\n   Name:   A variable-length UTF-8 encoded
        string [RFC3629] containing\n      the AC's name, whose maximum size MUST
        NOT exceed 512 bytes.\n"
      title: 4.6.4.  AC Name
    - contents:
      - "4.6.5.  AC Name with Priority\n   The AC Name with Priority message element
        is sent by the AC to the\n   WTP to configure preferred ACs.  The number of
        instances of this\n   message element is equal to the number of ACs configured
        on the WTP.\n   The WTP also uses this message element to send its configuration
        to\n   the AC.\n      0                   1\n      0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |   Priority  |   AC
        Name...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Type:   5 for AC Name
        with Priority\n   Length:   >= 2\n   Priority:   A value between 1 and 255
        specifying the priority order\n      of the preferred AC.  For instance, the
        value of one (1) is used\n      to set the primary AC, the value of two (2)
        is used to set the\n      secondary, etc.\n   AC Name:   A variable-length
        UTF-8 encoded string [RFC3629]\n      containing the AC name, whose maximum
        size MUST NOT exceed 512\n      bytes.\n"
      title: 4.6.5.  AC Name with Priority
    - contents:
      - "4.6.6.  AC Timestamp\n   The AC Timestamp message element is sent by the
        AC to synchronize the\n   WTP clock.\n      0                   1                   2
        \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           Timestamp                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   6 for AC Timestamp\n   Length:   4\n   Timestamp:   The AC's current
        time, allowing all of the WTPs to be\n      time synchronized in the format
        defined by Network Time Protocol\n      (NTP) in RFC 1305 [RFC1305].  Only
        the most significant 32 bits of\n      the NTP time are included in this field.\n"
      title: 4.6.6.  AC Timestamp
    - contents:
      - "4.6.7.  Add MAC ACL Entry\n   The Add MAC Access Control List (ACL) Entry
        message element is used\n   by an AC to add a MAC ACL list entry on a WTP,
        ensuring that the WTP\n   no longer provides service to the MAC addresses
        provided in the\n   message.  The MAC addresses provided in this message element
        are not\n   expected to be saved in non-volatile memory on the WTP.  The MAC
        ACL\n   table on the WTP is cleared every time the WTP establishes a new\n
        \  session with an AC.\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    | Num of Entries|    Length     |         MAC Address ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   7 for Add MAC ACL Entry\n   Length:   >= 8\n   Num of Entries:
        \  The number of instances of the Length/MAC Address\n      fields in the
        array.  This value MUST NOT exceed 255.\n   Length:  The length of the MAC
        Address field.  The formats and\n      lengths specified in [EUI-48] and [EUI-64]
        are supported.\n   MAC Address:   MAC addresses to add to the ACL.\n"
      title: 4.6.7.  Add MAC ACL Entry
    - contents:
      - "4.6.8.  Add Station\n   The Add Station message element is used by the AC
        to inform a WTP\n   that it should forward traffic for a station.  The Add
        Station\n   message element is accompanied by technology-specific binding\n
        \  information element(s), which may include security parameters.\n   Consequently,
        the security parameters MUST be applied by the WTP for\n   the station.\n
        \  After station policy has been delivered to the WTP through the Add\n   Station
        message element, an AC MAY change any policies by sending a\n   modified Add
        Station message element.  When a WTP receives an Add\n   Station message element
        for an existing station, it MUST override any\n   existing state for the station.\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |    Radio ID   |     Length    |          MAC Address ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |  VLAN Name...\n     +-+-+-+-+-+-+-+-+\n   Type:   8 for Add Station\n
        \  Length:   >= 8\n   Radio ID:   An 8-bit value representing the radio, whose
        value is\n      between one (1) and 31.\n   Length:  The length of the MAC
        Address field.  The formats and\n      lengths specified in [EUI-48] and [EUI-64]
        are supported.\n   MAC Address:   The station's MAC address.\n   VLAN Name:
        \  An optional variable-length UTF-8 encoded string\n      [RFC3629], with
        a maximum length of 512 octets, containing the\n      VLAN Name on which the
        WTP is to locally bridge user data.  Note\n      this field is only valid
        with WTPs configured in Local MAC mode.\n"
      title: 4.6.8.  Add Station
    - contents:
      - "4.6.9.  CAPWAP Control IPv4 Address\n   The CAPWAP Control IPv4 Address message
        element is sent by the AC to\n   the WTP during the Discovery process and
        is used by the AC to provide\n   the interfaces available on the AC, and the
        current number of WTPs\n   connected.  When multiple CAPWAP Control IPV4 Address
        message\n   elements are returned, the WTP SHOULD perform load balancing across\n
        \  the multiple interfaces (see Section 6.1).\n      0                   1
        \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |           WTP Count           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   10 for CAPWAP Control IPv4 Address\n   Length:   6\n   IP Address:
        \  The IP address of an interface.\n   WTP Count:   The number of WTPs currently
        connected to the interface,\n      with a maximum value of 65535.\n"
      title: 4.6.9.  CAPWAP Control IPv4 Address
    - contents:
      - "4.6.10.  CAPWAP Control IPv6 Address\n   The CAPWAP Control IPv6 Address
        message element is sent by the AC to\n   the WTP during the Discovery process
        and is used by the AC to provide\n   the interfaces available on the AC, and
        the current number of WTPs\n   connected.  This message element is useful
        for the WTP to perform\n   load balancing across multiple interfaces (see
        Section 6.1).\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |           WTP Count           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   11 for CAPWAP Control IPv6 Address\n   Length:   18\n   IP Address:
        \  The IP address of an interface.\n   WTP Count:   The number of WTPs currently
        connected to the interface,\n      with a maximum value of 65535.\n"
      title: 4.6.10.  CAPWAP Control IPv6 Address
    - contents:
      - "4.6.11.  CAPWAP Local IPv4 Address\n   The CAPWAP Local IPv4 Address message
        element is sent by either the\n   WTP, in the Join Request, or by the AC,
        in the Join Response.  The\n   CAPWAP Local IPv4 Address message element is
        used to communicate the\n   IP Address of the transmitter.  The receiver uses
        this to determine\n   whether a middlebox exists between the two peers, by
        comparing the\n   source IP address of the packet against the value of the
        message\n   element.\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   30 for CAPWAP Local IPv4 Address\n   Length:   4\n   IP Address:
        \  The IP address of the sender.\n"
      title: 4.6.11.  CAPWAP Local IPv4 Address
    - contents:
      - "4.6.12.  CAPWAP Local IPv6 Address\n   The CAPWAP Local IPv6 Address message
        element is sent by either the\n   WTP, in the Join Request, or by the AC,
        in the Join Response.  The\n   CAPWAP Local IPv6 Address message element is
        used to communicate the\n   IP Address of the transmitter.  The receiver uses
        this to determine\n   whether a middlebox exists between the two peers, by
        comparing the\n   source IP address of the packet against the value of the
        message\n   element.\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           IP Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   50 for CAPWAP Local IPv6 Address\n   Length:   16\n   IP Address:
        \  The IP address of the sender.\n"
      title: 4.6.12.  CAPWAP Local IPv6 Address
    - contents:
      - "4.6.13.  CAPWAP Timers\n   The CAPWAP Timers message element is used by an
        AC to configure\n   CAPWAP timers on a WTP.\n      0                   1\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Discovery   | Echo Request  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   12 for CAPWAP Timers\n   Length:   2\n   Discovery:   The number
        of seconds between CAPWAP Discovery messages,\n      when the WTP is in the
        Discovery phase.  This value is used to\n      configure the MaxDiscoveryInterval
        timer (see Section 4.7.10).\n   Echo Request:   The number of seconds between
        WTP Echo Request CAPWAP\n      messages.  This value is used to configure
        the EchoInterval timer\n      (see Section 4.7.7).  The AC sets its EchoInterval
        timer to this\n      value, plus the maximum retransmission time as described
        in\n      Section 4.5.3.\n"
      title: 4.6.13.  CAPWAP Timers
    - contents:
      - "4.6.14.  CAPWAP Transport Protocol\n   When CAPWAP is run over IPv6, the
        UDP-Lite or UDP transports MAY be\n   used (see Section 3).  The CAPWAP IPv6
        Transport Protocol message\n   element is used by either the WTP or the AC
        to signal which transport\n   protocol is to be used for the CAPWAP data channel.\n
        \  Upon receiving the Join Request, the AC MAY set the CAPWAP Transport\n
        \  Protocol to UDP-Lite in the Join Response message if the CAPWAP\n   message
        was received over IPv6, and the CAPWAP Local IPv6 Address\n   message element
        (see Section 4.6.12) is present and no middlebox was\n   detected (see Section
        11).\n   Upon receiving the Join Response, the WTP MAY set the CAPWAP\n   Transport
        Protocol to UDP-Lite in the Configuration Status Request or\n   Image Data
        Request message if the AC advertised support for UDP-Lite,\n   the message
        was received over IPv6, the CAPWAP Local IPv6 Address\n   message element
        (see Section 4.6.12) and no middlebox was detected\n   (see Section 11).  Upon
        receiving either the Configuration Status\n   Request or the Image Data Request,
        the AC MUST observe the preference\n   indicated by the WTP in the CAPWAP
        Transport Protocol, as long as it\n   is consistent with what the AC advertised
        in the Join Response.\n   For any other condition, the CAPWAP Transport Protocol
        MUST be set to\n   UDP.\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n
        \    |   Transport   |\n     +-+-+-+-+-+-+-+-+\n   Type:   51 for CAPWAP Transport
        Protocol\n   Length:   1\n   Transport:   The transport to use for the CAPWAP
        Data channel.  The\n      following enumerated values are supported:\n      1
        -   UDP-Lite: The UDP-Lite transport protocol is to be used for\n            the
        CAPWAP Data channel.  Note that this option MUST NOT be\n            used
        if the CAPWAP Control channel is being used over IPv4.\n      2 -   UDP: The
        UDP transport protocol is to be used for the CAPWAP\n            Data channel.\n"
      title: 4.6.14.  CAPWAP Transport Protocol
    - contents:
      - "4.6.15.  Data Transfer Data\n   The Data Transfer Data message element is
        used by the WTP to provide\n   information to the AC for debugging purposes.\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Data Type   |   Data Mode   |         Data Length           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Data ....\n     +-+-+-+-+-+-+-+-+\n   Type:   13 for Data Transfer
        Data\n   Length:   >= 5\n   Data Type:   An 8-bit value representing the transfer
        Data Type.  The\n      following enumerated values are supported:\n      1
        -  Transfer data is included.\n      2 -  Last Transfer Data Block is included
        (End of File (EOF)).\n      5 -  An error occurred.  Transfer is aborted.\n
        \  Data Mode:   An 8-bit value describing the type of information being\n
        \     transmitted.  The following enumerated values are supported:\n      0
        -  Reserved\n      1 -  WTP Crash Data\n      2 -  WTP Memory Dump\n   Data
        Length:   Length of data field, with a maximum size of 65535.\n   Data:   Data
        being transferred from the WTP to the AC, whose type is\n      identified
        via the Data Mode field.\n"
      title: 4.6.15.  Data Transfer Data
    - contents:
      - "4.6.16.  Data Transfer Mode\n   The Data Transfer Mode message element is
        used by the WTP to indicate\n   the type of data transfer information it is
        sending to the AC for\n   debugging purposes.\n      0\n      0 1 2 3 4 5
        6 7\n     +-+-+-+-+-+-+-+-+\n     |   Data Mode   |\n     +-+-+-+-+-+-+-+-+\n
        \  Type:   14 for Data Transfer Mode\n   Length:   1\n   Data Mode:   An 8-bit
        value describing the type of information being\n      requested.  The following
        enumerated values are supported:\n      0 -  Reserved\n      1 -  WTP Crash
        Data\n      2 -  WTP Memory Dump\n"
      title: 4.6.16.  Data Transfer Mode
    - contents:
      - "4.6.17.  Decryption Error Report\n   The Decryption Error Report message
        element value is used by the WTP\n   to inform the AC of decryption errors
        that have occurred since the\n   last report.  Note that this error reporting
        mechanism is not used if\n   encryption and decryption services are provided
        in the AC.\n      0                   1                   2\n      0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Radio ID    |Num Of Entries |     Length    | MAC Address...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   15 for Decryption Error Report\n   Length:   >= 9\n   Radio ID:
        \  The Radio Identifier refers to an interface index on the\n      WTP, whose
        value is between one (1) and 31.\n   Num of Entries:   The number of instances
        of the Length/MAC Address\n      fields in the array.  This field MUST NOT
        exceed the value of 255.\n   Length:  The length of the MAC Address field.
        \ The formats and\n      lengths specified in [EUI-48] and [EUI-64] are supported.\n
        \  MAC Address:   MAC address of the station that has caused decryption\n
        \     errors.\n"
      title: 4.6.17.  Decryption Error Report
    - contents:
      - "4.6.18.  Decryption Error Report Period\n   The Decryption Error Report Period
        message element value is used by\n   the AC to inform the WTP how frequently
        it should send decryption\n   error report messages.  Note that this error
        reporting mechanism is\n   not used if encryption and decryption services
        are provided in the\n   AC.\n      0                   1                   2\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Radio ID    |        Report Interval        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   16 for Decryption Error Report Period\n   Length:   3\n   Radio
        ID:   The Radio Identifier refers to an interface index on the\n      WTP,
        whose value is between one (1) and 31.\n   Report Interval:   A 16-bit unsigned
        integer indicating the time, in\n      seconds.  The default value for this
        message element can be found\n      in Section 4.7.11.\n"
      title: 4.6.18.  Decryption Error Report Period
    - contents:
      - "4.6.19.  Delete MAC ACL Entry\n   The Delete MAC ACL Entry message element
        is used by an AC to delete a\n   MAC ACL entry on a WTP, ensuring that the
        WTP provides service to the\n   MAC addresses provided in the message.\n      0
        \                  1                   2                   3\n      0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    | Num of Entries|     Length    |          MAC Address ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   17 for Delete MAC ACL Entry\n   Length:   >= 8\n   Num of Entries:
        \  The number of instances of the Length/MAC Address\n      fields in the
        array.  This field MUST NOT exceed the value of 255.\n   Length:  The length
        of the MAC Address field.  The formats and\n      lengths specified in [EUI-48]
        and [EUI-64] are supported.\n   MAC Address:   An array of MAC addresses to
        delete from the ACL.\n"
      title: 4.6.19.  Delete MAC ACL Entry
    - contents:
      - "4.6.20.  Delete Station\n   The Delete Station message element is used by
        the AC to inform a WTP\n   that it should no longer provide service to a particular
        station.\n   The WTP MUST terminate service to the station immediately upon\n
        \  receiving this message element.\n   The transmission of a Delete Station
        message element could occur for\n   various reasons, including for administrative
        reasons, or if the\n   station has roamed to another WTP.\n   The Delete Station
        message element MAY be sent by the WTP, in the WTP\n   Event Request message,
        to inform the AC that a particular station is\n   no longer being provided
        service.  This could occur as a result of an\n   Idle Timeout (see section
        4.4.43), due to internal resource shortages\n   or for some other reason.\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |    Radio ID   |     Length    |        MAC Address...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   18 for Delete Station\n   Length:   >= 8\n   Radio ID:   An 8-bit
        value representing the radio, whose value is\n      between one (1) and 31.\n
        \  Length:  The length of the MAC Address field.  The formats and\n      lengths
        specified in [EUI-48] and [EUI-64] are supported.\n   MAC Address:   The station's
        MAC address.\n"
      title: 4.6.20.  Delete Station
    - contents:
      - "4.6.21.  Discovery Type\n   The Discovery Type message element is used by
        the WTP to indicate how\n   it has come to know about the existence of the
        AC to which it is\n   sending the Discovery Request message.\n      0\n      0
        1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     | Discovery Type|\n     +-+-+-+-+-+-+-+-+\n
        \  Type:   20 for Discovery Type\n   Length:   1\n   Discovery Type:   An
        8-bit value indicating how the WTP discovered\n      the AC.  The following
        enumerated values are supported:\n      0 -   Unknown\n      1 -   Static
        Configuration\n      2 -   DHCP\n      3 -   DNS\n      4 -   AC Referral
        (used when the AC was configured either through\n            the AC IPv4 List
        or AC IPv6 List message element)\n"
      title: 4.6.21.  Discovery Type
    - contents:
      - "4.6.22.  Duplicate IPv4 Address\n   The Duplicate IPv4 Address message element
        is used by a WTP to inform\n   an AC that it has detected another IP device
        using the same IP\n   address that the WTP is currently using.\n   The WTP
        MUST transmit this message element with the status set to 1\n   after it has
        detected a duplicate IP address.  When the WTP detects\n   that the duplicate
        IP address has been cleared, it MUST send this\n   message element with the
        status set to 0.\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                          IP Address                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |     Status    |     Length    |          MAC Address ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   21 for Duplicate IPv4 Address\n   Length:   >= 12\n   IP Address:
        \  The IP address currently used by the WTP.\n   Status:   The status of the
        duplicate IP address.  The value MUST be\n      set to 1 when a duplicate
        address is detected, and 0 when the\n      duplicate address has been cleared.\n
        \  Length:  The length of the MAC Address field.  The formats and\n      lengths
        specified in [EUI-48] and [EUI-64] are supported.\n   MAC Address:   The MAC
        address of the offending device.\n"
      title: 4.6.22.  Duplicate IPv4 Address
    - contents:
      - "4.6.23.  Duplicate IPv6 Address\n   The Duplicate IPv6 Address message element
        is used by a WTP to inform\n   an AC that it has detected another host using
        the same IP address\n   that the WTP is currently using.\n   The WTP MUST
        transmit this message element with the status set to 1\n   after it has detected
        a duplicate IP address.  When the WTP detects\n   that the duplicate IP address
        has been cleared, it MUST send this\n   message element with the status set
        to 0.\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                          IP Address                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                          IP Address                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                          IP Address                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                          IP Address                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |     Status    |     Length    |         MAC Address ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   22 for Duplicate IPv6 Address\n   Length:   >= 24\n   IP Address:
        \  The IP address currently used by the WTP.\n   Status:   The status of the
        duplicate IP address.  The value MUST be\n      set to 1 when a duplicate
        address is detected, and 0 when the\n      duplicate address has been cleared.\n
        \  Length:  The length of the MAC Address field.  The formats and\n      lengths
        specified in [EUI-48] and [EUI-64] are supported.\n   MAC Address:   The MAC
        address of the offending device.\n"
      title: 4.6.23.  Duplicate IPv6 Address
    - contents:
      - "4.6.24.  Idle Timeout\n   The Idle Timeout message element is sent by the
        AC to the WTP to\n   provide the Idle Timeout value that the WTP SHOULD enforce
        for its\n   active stations.  The value applies to all radios on the WTP.\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                            Timeout                            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   23 for Idle Timeout\n   Length:   4\n   Timeout:   The current
        Idle Timeout, in seconds, to be enforced by\n      the WTP.  The default value
        for this message element is specified\n      in Section 4.7.8.\n"
      title: 4.6.24.  Idle Timeout
    - contents:
      - "4.6.25.  ECN Support\n   The ECN Support message element is sent by both
        the WTP and the AC to\n   indicate their support for the Explicit Congestion
        Notification (ECN)\n   bits, as defined in [RFC3168].\n      0\n      0 1
        2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |  ECN Support  |\n     +-+-+-+-+-+-+-+-+\n
        \  Type:   53 for ECN Support\n   Length:   1\n   ECN Support:   An 8-bit
        value representing the sender's support for\n      ECN, as defined in [RFC3168].
        \ All CAPWAP Implementations MUST\n      support the Limited ECN Support mode.
        \ Full ECN Support is used if\n      both the WTP and AC advertise the capability
        for \"Full and Limited\n      ECN\" Support; otherwise, Limited ECN Support
        is used.\n      0 -  Limited ECN Support\n      1 -  Full and Limited ECN
        Support\n"
      title: 4.6.25.  ECN Support
    - contents:
      - "4.6.26.  Image Data\n   The Image Data message element is present in the
        Image Data Request\n   message sent by the AC and contains the following fields.\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Data Type   |                    Data ....\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   24 for Image Data\n   Length:   >= 1\n   Data Type:   An 8-bit
        value representing the image Data Type.  The\n      following enumerated values
        are supported:\n      1 -  Image data is included.\n      2 -  Last Image
        Data Block is included (EOF).\n      5 -  An error occurred.  Transfer is
        aborted.\n   Data:   The Image Data field contains up to 1024 characters,
        and its\n      length is inferred from this message element's length field.
        \ If\n      the block being sent is the last one, the Data Type field is set\n
        \     to 2.  The AC MAY opt to abort the data transfer by setting the\n      Data
        Type field to 5.  When the Data Type field is 5, the Value\n      field has
        a zero length.\n"
      title: 4.6.26.  Image Data
    - contents:
      - "4.6.27.  Image Identifier\n   The Image Identifier message element is sent
        by the AC to the WTP to\n   indicate the expected active software version
        that is to be run on\n   the WTP.  The WTP sends the Image Identifier message
        element in order\n   to request a specific software version from the AC.  The
        actual\n   download process is defined in Section 9.1.  The value is a variable-\n
        \  length UTF-8 encoded string [RFC3629], which is NOT zero terminated.\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                       Vendor Identifier                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                             Data...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   25 for Image Identifier\n   Length:   >= 5\n   Vendor Identifier:
        \  A 32-bit value containing the IANA-assigned \"SMI\n      Network Management
        Private Enterprise Codes\".\n   Data:   A variable-length UTF-8 encoded string
        [RFC3629] containing\n      the firmware identifier to be run on the WTP,
        whose length MUST\n      NOT exceed 1024 octets.  The length of this field
        is inferred from\n      this message element's length field.\n"
      title: 4.6.27.  Image Identifier
    - contents:
      - "4.6.28.  Image Information\n   The Image Information message element is present
        in the Image Data\n   Response message sent by the AC to the WTP and contains
        the following\n   fields.\n      0                   1                   2
        \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           File Size                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                              Hash                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                              Hash                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                              Hash                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                              Hash                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   26 for Image Information\n   Length:   20\n   File Size:   A 32-bit
        value containing the size of the file, in\n      bytes, that will be transferred
        by the AC to the WTP.\n   Hash:   A 16-octet MD5 hash of the image using the
        procedures defined\n      in [RFC1321].\n"
      title: 4.6.28.  Image Information
    - contents:
      - "4.6.29.  Initiate Download\n   The Initiate Download message element is used
        by the WTP to inform\n   the AC that the AC SHOULD initiate a firmware upgrade.
        \ The AC\n   subsequently transmits an Image Data Request message, which includes\n
        \  the Image Data message element.  This message element does not\n   contain
        any data.\n   Type:   27 for Initiate Download\n   Length:   0\n"
      title: 4.6.29.  Initiate Download
    - contents:
      - "4.6.30.  Location Data\n   The Location Data message element is a variable-length
        byte UTF-8\n   encoded string [RFC3629] containing user-defined location information\n
        \  (e.g., \"Next to Fridge\").  This information is configurable by the\n
        \  network administrator, and allows the WTP location to be determined.\n
        \  The string is not zero terminated.\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+-\n
        \    | Location ...\n     +-+-+-+-+-+-+-+-+-\n   Type:   28 for Location Data\n
        \  Length:   >= 1\n   Location:   A non-zero-terminated UTF-8 encoded string
        [RFC3629]\n      containing the WTP location, whose maximum size MUST NOT
        exceed\n      1024.\n"
      title: 4.6.30.  Location Data
    - contents:
      - "4.6.31.  Maximum Message Length\n   The Maximum Message Length message element
        is included in the Join\n   Request message by the WTP to indicate the maximum
        CAPWAP message\n   length that it supports to the AC.  The Maximum Message
        Length\n   message element is optionally included in Join Response message
        by\n   the AC to indicate the maximum CAPWAP message length that it supports\n
        \  to the WTP.\n         0              1\n         0 1 2 3 4 5 6 7 8 9 0
        1 2 3 4 5\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        |    Maximum
        Message Length     |\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Type:
        \  29 for Maximum Message Length\n   Length:   2\n   Maximum Message Length
        \ A 16-bit unsigned integer indicating the\n      maximum message length.\n"
      title: 4.6.31.  Maximum Message Length
    - contents:
      - "4.6.32.  MTU Discovery Padding\n   The MTU Discovery Padding message element
        is used as padding to\n   perform MTU discovery, and MUST contain octets of
        value 0xFF, of any\n   length.\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n
        \    |  Padding...\n     +-+-+-+-+-+-+-+-\n   Type:   52 for MTU Discovery
        Padding\n   Length:   Variable\n   Pad:   A variable-length pad, filled with
        the value 0xFF.\n"
      title: 4.6.32.  MTU Discovery Padding
    - contents:
      - "4.6.33.  Radio Administrative State\n   The Radio Administrative State message
        element is used to communicate\n   the state of a particular radio.  The Radio
        Administrative State\n   message element is sent by the AC to change the state
        of the WTP.\n   The WTP saves the value, to ensure that it remains across
        WTP resets.\n   The WTP communicates this message element during the configuration\n
        \  phase, in the Configuration Status Request message, to ensure that\n   the
        AC has the WTP radio current administrative state settings.  The\n   message
        element contains the following fields:\n         0                   1\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
        \  Radio ID    |  Admin State  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   31 for Radio Administrative State\n   Length:   2\n   Radio ID:
        \  An 8-bit value representing the radio to configure, whose\n      value
        is between one (1) and 31.  The Radio ID field MAY also\n      include the
        value of 0xff, which is used to identify the WTP.  If\n      an AC wishes
        to change the administrative state of a WTP, it\n      includes 0xff in the
        Radio ID field.\n   Admin State:   An 8-bit value representing the administrative
        state\n      of the radio.  The default value for the Admin State field is\n
        \     listed in Section 4.8.1.  The following enumerated values are\n      supported:\n
        \     0 -  Reserved\n      1 -  Enabled\n      2 -  Disabled\n"
      title: 4.6.33.  Radio Administrative State
    - contents:
      - "4.6.34.  Radio Operational State\n   The Radio Operational State message
        element is sent by the WTP to the\n   AC to communicate a radio's operational
        state.  This message element\n   is included in the Configuration Update Response
        message by the WTP\n   if it was requested to change the state of its radio,
        via the Radio\n   Administrative State message element, but was unable to
        comply to the\n   request.  This message element is included in the Change
        State Event\n   message when a WTP radio state was changed unexpectedly.  This
        could\n   occur due to a hardware failure.  Note that the operational state\n
        \  setting is not saved on the WTP, and therefore does not remain across\n
        \  WTP resets.  The value contains three fields, as shown below.\n      0
        \                  1                   2\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Radio ID    |     State     |     Cause     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   32 for Radio Operational State\n   Length:   3\n   Radio ID:   The
        Radio Identifier refers to an interface index on the\n      WTP, whose value
        is between one (1) and 31.  A value of 0xFF is\n      invalid, as it is not
        possible to change the WTP's operational\n      state.\n   State:   An 8-bit
        Boolean value representing the state of the radio.\n      The following enumerated
        values are supported:\n      0 -  Reserved\n      1 -  Enabled\n      2 -
        \ Disabled\n   Cause:   When a radio is inoperable, the cause field contains
        the\n      reason the radio is out of service.  The following enumerated\n
        \     values are supported:\n      0 -  Normal\n      1 -  Radio Failure\n
        \     2 -  Software Failure\n      3 -  Administratively Set\n"
      title: 4.6.34.  Radio Operational State
    - contents:
      - "4.6.35.  Result Code\n   The Result Code message element value is a 32-bit
        integer value,\n   indicating the result of the Request message corresponding
        to the\n   sequence number included in the Response message.\n      0                   1
        \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                         Result Code                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   33 for Result Code\n   Length:   4\n   Result Code:   The following
        enumerated values are defined:\n      0  Success\n      1  Failure (AC List
        Message Element MUST Be Present)\n      2  Success (NAT Detected)\n      3
        \ Join Failure (Unspecified)\n      4  Join Failure (Resource Depletion)\n
        \     5  Join Failure (Unknown Source)\n      6  Join Failure (Incorrect Data)\n
        \     7  Join Failure (Session ID Already in Use)\n      8  Join Failure (WTP
        Hardware Not Supported)\n      9  Join Failure (Binding Not Supported)\n      10
        Reset Failure (Unable to Reset)\n      11 Reset Failure (Firmware Write Error)\n
        \     12 Configuration Failure (Unable to Apply Requested Configuration\n
        \        - Service Provided Anyhow)\n      13 Configuration Failure (Unable
        to Apply Requested Configuration\n         - Service Not Provided)\n      14
        Image Data Error (Invalid Checksum)\n      15 Image Data Error (Invalid Data
        Length)\n      16 Image Data Error (Other Error)\n      17 Image Data Error
        (Image Already Present)\n      18 Message Unexpected (Invalid in Current State)\n
        \     19 Message Unexpected (Unrecognized Request)\n      20 Failure - Missing
        Mandatory Message Element\n      21 Failure - Unrecognized Message Element\n
        \     22 Data Transfer Error (No Information to Transfer)\n"
      title: 4.6.35.  Result Code
    - contents:
      - "4.6.36.  Returned Message Element\n   The Returned Message Element is sent
        by the WTP in the Change State\n   Event Request message to communicate to
        the AC which message elements\n   in the Configuration Status Response it
        was unable to apply locally.\n   The Returned Message Element message element
        contains a result code\n   indicating the reason that the configuration could
        not be applied,\n   and encapsulates the failed message element.\n      0
        \                  1                   2                   3\n      0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |    Reason     |    Length     |       Message Element...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   34 for Returned Message Element\n   Length:   >= 6\n   Reason:
        \  The reason the configuration in the offending message\n      element could
        not be applied by the WTP.  The following enumerated\n      values are supported:\n
        \     0 -  Reserved\n      1 -  Unknown Message Element\n      2 -  Unsupported
        Message Element\n      3 -  Unknown Message Element Value\n      4 -  Unsupported
        Message Element Value\n   Length:   The length of the Message Element field,
        which MUST NOT\n      exceed 255 octets.\n   Message Element:   The Message
        Element field encapsulates the message\n      element sent by the AC in the
        Configuration Status Response\n      message that caused the error.\n"
      title: 4.6.36.  Returned Message Element
    - contents:
      - "4.6.37.  Session ID\n   The Session ID message element value contains a randomly
        generated\n   unsigned 128-bit integer.\n      0                   1                   2
        \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           Session ID                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           Session ID                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           Session ID                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                           Session ID                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   35 for Session ID\n   Length:   16\n   Session ID:   A 128-bit
        unsigned integer used as a random session\n      identifier\n"
      title: 4.6.37.  Session ID
    - contents:
      - "4.6.38.  Statistics Timer\n   The Statistics Timer message element value
        is used by the AC to\n   inform the WTP of the frequency with which it expects
        to receive\n   updated statistics.\n      0                   1\n      0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
        \       Statistics Timer       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   36 for Statistics Timer\n   Length:   2\n   Statistics Timer:   A
        16-bit unsigned integer indicating the time, in\n      seconds.  The default
        value for this timer is specified in\n      Section 4.7.14.\n"
      title: 4.6.38.  Statistics Timer
    - contents:
      - "4.6.39.  Vendor Specific Payload\n   The Vendor Specific Payload message
        element is used to communicate\n   vendor-specific information between the
        WTP and the AC.  The Vendor\n   Specific Payload message element MAY be present
        in any CAPWAP\n   message.  The exchange of vendor-specific data between the
        MUST NOT\n   modify the behavior of the base CAPWAP protocol and state machine.\n
        \  The message element uses the following format:\n      0                   1
        \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                       Vendor Identifier                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |          Element ID           |    Data...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   37 for Vendor Specific Payload\n   Length:   >= 7\n   Vendor Identifier:
        \  A 32-bit value containing the IANA-assigned \"SMI\n      Network Management
        Private Enterprise Codes\" [RFC3232].\n   Element ID:   A 16-bit Element Identifier
        that is managed by the\n      vendor.\n   Data:   Variable-length vendor-specific
        information, whose contents\n      and format are proprietary and understood
        based on the Element ID\n      field.  This field MUST NOT exceed 2048 octets.\n"
      title: 4.6.39.  Vendor Specific Payload
    - contents:
      - "4.6.40.  WTP Board Data\n   The WTP Board Data message element is sent by
        the WTP to the AC and\n   contains information about the hardware present.\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                       Vendor Identifier                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                   Board Data Sub-Element...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   38 for WTP Board Data\n   Length:   >=14\n   Vendor Identifier:
        \  A 32-bit value containing the IANA-assigned \"SMI\n      Network Management
        Private Enterprise Codes\", identifying the WTP\n      hardware manufacturer.
        \ The Vendor Identifier field MUST NOT be\n      set to zero.\n   Board Data
        Sub-Element:   The WTP Board Data message element contains\n      multiple
        Board Data sub-elements, some of which are mandatory and\n      some are optional,
        as described below.  The Board Data Type values\n      are not extensible
        by vendors, and are therefore not coupled along\n      with the Vendor Identifier
        field.  The Board Data sub-element has\n      the following format:\n      0
        \                  1                   2                   3\n      0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |        Board Data Type        |       Board Data Length       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                      Board Data Value...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     Board Data Type:   The Board Data Type field identifies the data\n         being
        encoded.  The CAPWAP protocol defines the following\n         values, and
        each of these types identify whether their presence\n         is mandatory
        or optional:\n      0 -   WTP Model Number: The WTP Model Number MUST be included
        in\n            the WTP Board Data message element.\n      1 -   WTP Serial
        Number: The WTP Serial Number MUST be included in\n            the WTP Board
        Data message element.\n      2 -   Board ID: A hardware identifier, which
        MAY be included in\n            the WTP Board Data message element.\n      3
        -   Board Revision: A revision number of the board, which MAY be\n            included
        in the WTP Board Data message element.\n      4 -   Base MAC Address: The
        WTP's Base MAC address, which MAY be\n            assigned to the primary
        Ethernet interface.\n   Board Data Length:   The length of the data in the
        Board Data Value\n      field, whose length MUST NOT exceed 1024 octets.\n
        \  Board Data Value:   The data associated with the Board Data Type\n      field
        for this Board Data sub-element.\n"
      title: 4.6.40.  WTP Board Data
    - contents:
      - "4.6.41.  WTP Descriptor\n   The WTP Descriptor message element is used by
        a WTP to communicate\n   its current hardware and software (firmware) configuration.
        \ The\n   value contains the following fields:\n      0                   1
        \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Max Radios  | Radios in use |  Num Encrypt  |Encryp Sub-Elmt|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |     Encryption Sub-Element    |    Descriptor Sub-Element...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   39 for WTP Descriptor\n   Length:   >= 33\n   Max Radios:   An
        8-bit value representing the number of radios (where\n      each radio is
        identified via the Radio ID field) supported by the\n      WTP.\n   Radios
        in use:   An 8-bit value representing the number of radios in\n      use in
        the WTP.\n   Num Encrypt:   The number of 3-byte Encryption sub-elements that\n
        \     follow this field.  The value of the Num Encrypt field MUST be\n      between
        one (1) and 255.\n   Encryption Sub-Element:   The WTP Descriptor message
        element MUST\n      contain at least one Encryption sub-element.  One sub-element
        is\n      present for each binding supported by the WTP.  The Encryption\n
        \     sub-element has the following format:\n      0                   1                   2\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |Resvd|  WBID   |  Encryption Capabilities      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     Resvd:  The 3-bit field is reserved for future use.  All\n         implementations
        complying with this protocol MUST set to zero\n         any bits that are
        reserved in the version of the protocol\n         supported by that implementation.
        \ Receivers MUST ignore all\n         bits not defined for the version of
        the protocol they support.\n      WBID:   A 5-bit field that is the wireless
        binding identifier.\n         The identifier will indicate the type of wireless
        packet\n         associated with the radio.  The WBIDs defined in this\n         specification
        can be found in Section 4.3.\n      Encryption Capabilities:   This 16-bit
        field is used by the WTP to\n         communicate its capabilities to the
        AC.  A WTP that does not\n         have any encryption capabilities sets this
        field to zero (0).\n         Refer to the specific wireless binding for further\n
        \        specification of the Encryption Capabilities field.\n   Descriptor
        Sub-Element:   The WTP Descriptor message element contains\n      multiple
        Descriptor sub-elements, some of which are mandatory and\n      some are optional,
        as described below.  The Descriptor sub-element\n      has the following format:\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                  Descriptor Vendor Identifier                 |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |        Descriptor Type        |       Descriptor Length       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                       Descriptor Data...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     Descriptor Vendor Identifier:   A 32-bit value containing the\n         IANA-assigned
        \"SMI Network Management Private Enterprise\n         Codes\".\n      Descriptor
        Type:   The Descriptor Type field identifies the data\n         being encoded.
        \ The format of the data is vendor-specific\n         encoded in the UTF-8
        format [RFC3629].  The CAPWAP protocol\n         defines the following values,
        and each of these types identify\n         whether their presence is mandatory
        or optional.  The values\n         listed below are used in conjunction with
        the Descriptor Vendor\n         Identifier field, whose value MUST be set
        to zero (0).  This\n         field, combined with the Descriptor Vendor Identifier
        set to a\n         non-zero (0) value, allows vendors to use a private namespace.\n
        \        0 -   Hardware Version: The WTP hardware version number MUST be\n
        \              present.\n         1 -   Active Software Version: The WTP running
        software version\n               number MUST be present.\n         2 -   Boot
        Version: The WTP boot loader version number MUST be\n               present.\n
        \        3 -   Other Software Version: The WTP non-running software\n               (firmware)
        version number MAY be present.  This type is\n               used to communicate
        alternate software versions that are\n               available on the WTP's
        non-volatile storage.\n      Descriptor Length:   Length of the vendor-specific
        encoding of the\n         Descriptor Data field, whose length MUST NOT exceed
        1024\n         octets.\n      Descriptor Data:   Vendor-specific data of WTP
        information encoded\n         in the UTF-8 format [RFC3629].\n"
      title: 4.6.41.  WTP Descriptor
    - contents:
      - "4.6.42.  WTP Fallback\n   The WTP Fallback message element is sent by the
        AC to the WTP to\n   enable or disable automatic CAPWAP fallback in the event
        that a WTP\n   detects its preferred AC to which it is not currently connected.\n
        \     0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |     Mode      |\n
        \    +-+-+-+-+-+-+-+-+\n   Type:   40 for WTP Fallback\n   Length:   1\n   Mode:
        \  The 8-bit value indicates the status of automatic CAPWAP\n      fallback
        on the WTP.  When enabled, if the WTP detects that its\n      primary AC is
        available, and that the WTP is not connected to the\n      primary AC, the
        WTP SHOULD automatically disconnect from its\n      current AC and reconnect
        to its primary AC.  If disabled, the WTP\n      will only reconnect to its
        primary AC through manual intervention\n      (e.g., through the Reset Request
        message).  The default value for\n      this field is specified in Section
        4.8.9.  The following\n      enumerated values are supported:\n      0 -  Reserved\n
        \     1 -  Enabled\n      2 -  Disabled\n"
      title: 4.6.42.  WTP Fallback
    - contents:
      - "4.6.43.  WTP Frame Tunnel Mode\n   The WTP Frame Tunnel Mode message element
        allows the WTP to\n   communicate the tunneling modes of operation that it
        supports to the\n   AC.  A WTP that advertises support for all types allows
        the AC to\n   select which type will be used, based on its local policy.\n
        \     0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |Reservd|N|E|L|U|\n
        \    +-+-+-+-+-+-+-+-+\n   Type:   41 for WTP Frame Tunnel Mode\n   Length:
        \  1\n   Reservd:   A set of reserved bits for future use.  All\n      implementations
        complying with this protocol MUST set to zero any\n      bits that are reserved
        in the version of the protocol supported by\n      that implementation.  Receivers
        MUST ignore all bits not defined\n      for the version of the protocol they
        support.\n   N:    Native Frame Tunnel mode requires the WTP and AC to encapsulate\n
        \        all user payloads as native wireless frames, as defined by the\n
        \        wireless binding (see for example Section 4.4)\n   E:    The 802.3
        Frame Tunnel Mode requires the WTP and AC to\n         encapsulate all user
        payload as native IEEE 802.3 frames (see\n         Section 4.4).  All user
        traffic is tunneled to the AC.  This\n         value MUST NOT be used when
        the WTP MAC Type is set to Split\n         MAC.\n   L:    When Local Bridging
        is used, the WTP does not tunnel user\n         traffic to the AC; all user
        traffic is locally bridged.  This\n         value MUST NOT be used when the
        WTP MAC Type is set to Split\n         MAC.\n   R:    A reserved bit for future
        use.  All implementations complying\n         with this protocol MUST set
        to zero any bits that are reserved\n         in the version of the protocol
        supported by that\n         implementation.  Receivers MUST ignore all bits
        not defined for\n         the version of the protocol they support.\n"
      title: 4.6.43.  WTP Frame Tunnel Mode
    - contents:
      - "4.6.44.  WTP MAC Type\n   The WTP MAC-Type message element allows the WTP
        to communicate its\n   mode of operation to the AC.  A WTP that advertises
        support for both\n   modes allows the AC to select the mode to use, based
        on local policy.\n      0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n
        \    |   MAC Type    |\n     +-+-+-+-+-+-+-+-+\n   Type:   44 for WTP MAC
        Type\n   Length:   1\n   MAC Type:   The MAC mode of operation supported by
        the WTP.  The\n      following enumerated values are supported:\n      0 -
        \  Local MAC: Local MAC is the default mode that MUST be\n            supported
        by all WTPs.  When tunneling is enabled (see\n            Section 4.6.43),
        the encapsulated frames MUST be in the\n            802.3 format (see Section
        4.4.2), unless a wireless\n            management or control frame which MAY
        be in its native\n            format.  Any CAPWAP binding needs to specify
        the format of\n            management and control wireless frames.\n      1
        -   Split MAC: Split MAC support is optional, and allows the AC\n            to
        receive and process native wireless frames.\n      2 -   Both: WTP is capable
        of supporting both Local MAC and Split\n            MAC.\n"
      title: 4.6.44.  WTP MAC Type
    - contents:
      - "4.6.45.  WTP Name\n   The WTP Name message element is a variable-length byte
        UTF-8 encoded\n   string [RFC3629].  The string is not zero terminated.\n
        \     0\n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+-\n     |  WTP Name
        ...\n     +-+-+-+-+-+-+-+-+-\n   Type:   45 for WTP Name\n   Length:   >=
        1\n   WTP Name:   A non-zero-terminated UTF-8 encoded string [RFC3629]\n      containing
        the WTP name, whose maximum size MUST NOT exceed 512\n      bytes.\n"
      title: 4.6.45.  WTP Name
    - contents:
      - "4.6.46.  WTP Radio Statistics\n   The WTP Radio Statistics message element
        is sent by the WTP to the AC\n   to communicate statistics on radio behavior
        and reasons why the WTP\n   radio has been reset.  These counters are never
        reset on the WTP, and\n   will therefore roll over to zero when the maximum
        size has been\n   reached.\n      0                   1                   2
        \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |   Radio ID    | Last Fail Type|          Reset Count          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |       SW Failure Count        |        HW Failure Count       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |     Other  Failure Count      |     Unknown Failure Count     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |      Config Update Count      |     Channel Change Count      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |       Band Change Count       |      Current Noise Floor      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   47 for WTP Radio Statistics\n   Length:   20\n   Radio ID:   The
        radio ID of the radio to which the statistics apply,\n      whose value is
        between one (1) and 31.\n   Last Failure Type:   The last WTP failure.  The
        following enumerated\n      values are supported:\n      0 -  Statistic Not
        Supported\n      1 -  Software Failure\n      2 -  Hardware Failure\n      3
        -  Other Failure\n      255 -  Unknown (e.g., WTP doesn't keep track of info)\n
        \  Reset Count:   The number of times that the radio has been reset.\n   SW
        Failure Count:   The number of times that the radio has failed due\n      to
        software-related reasons.\n   HW Failure Count:   The number of times that
        the radio has failed due\n      to hardware-related reasons.\n   Other Failure
        Count:   The number of times that the radio has failed\n      due to known
        reasons, other than software or hardware failure.\n   Unknown Failure Count:
        \  The number of times that the radio has\n      failed for unknown reasons.\n
        \  Config Update Count:   The number of times that the radio\n      configuration
        has been updated.\n   Channel Change Count:   The number of times that the
        radio channel\n      has been changed.\n   Band Change Count:   The number
        of times that the radio has changed\n      frequency bands.\n   Current Noise
        Floor:   A signed integer that indicates the noise\n      floor of the radio
        receiver in units of dBm.\n"
      title: 4.6.46.  WTP Radio Statistics
    - contents:
      - "4.6.47.  WTP Reboot Statistics\n   The WTP Reboot Statistics message element
        is sent by the WTP to the\n   AC to communicate reasons why WTP reboots have
        occurred.  These\n   counters are never reset on the WTP, and will therefore
        roll over to\n   zero when the maximum size has been reached.\n      0                   1
        \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |         Reboot Count          |      AC Initiated Count       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |      Link Failure Count       |       SW Failure Count        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |       HW Failure Count        |      Other Failure Count      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |     Unknown Failure Count     |Last Failure Type|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Type:   48 for WTP Reboot Statistics\n   Length:   15\n   Reboot Count:
        \  The number of reboots that have occurred due to a WTP\n      crash.  A
        value of 65535 implies that this information is not\n      available on the
        WTP.\n   AC Initiated Count:   The number of reboots that have occurred at
        the\n      request of a CAPWAP protocol message, such as a change in\n      configuration
        that required a reboot or an explicit CAPWAP\n      protocol reset request.
        \ A value of 65535 implies that this\n      information is not available on
        the WTP.\n   Link Failure Count:   The number of times that a CAPWAP protocol\n
        \     connection with an AC has failed due to link failure.\n   SW Failure
        Count:   The number of times that a CAPWAP protocol\n      connection with
        an AC has failed due to software-related reasons.\n   HW Failure Count:   The
        number of times that a CAPWAP protocol\n      connection with an AC has failed
        due to hardware-related reasons.\n   Other Failure Count:   The number of
        times that a CAPWAP protocol\n      connection with an AC has failed due to
        known reasons, other than\n      AC initiated, link, SW or HW failure.\n   Unknown
        Failure Count:   The number of times that a CAPWAP protocol\n      connection
        with an AC has failed for unknown reasons.\n   Last Failure Type:   The failure
        type of the most recent WTP failure.\n      The following enumerated values
        are supported:\n      0 -  Not Supported\n      1 -  AC Initiated (see Section
        9.2)\n      2 -  Link Failure\n      3 -  Software Failure\n      4 -  Hardware
        Failure\n      5 -  Other Failure\n      255 -  Unknown (e.g., WTP doesn't
        keep track of info)\n"
      title: 4.6.47.  WTP Reboot Statistics
    - contents:
      - "4.6.48.  WTP Static IP Address Information\n   The WTP Static IP Address
        Information message element is used by an\n   AC to configure or clear a previously
        configured static IP address on\n   a WTP.  IPv6 WTPs are expected to use
        dynamic addresses.\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                          IP Address                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                            Netmask                            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                            Gateway                            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |    Static     |\n     +-+-+-+-+-+-+-+-+\n   Type:   49 for WTP Static
        IP Address Information\n   Length:   13\n   IP Address:   The IP address to
        assign to the WTP.  This field is\n      only valid if the static field is
        set to one.\n   Netmask:   The IP Netmask.  This field is only valid if the
        static\n      field is set to one.\n   Gateway:   The IP address of the gateway.
        \ This field is only valid\n      if the static field is set to one.\n   Static:
        \  An 8-bit Boolean stating whether or not the WTP should use\n      a static
        IP address.  A value of zero disables the static IP\n      address, while
        a value of one enables it.\n"
      title: 4.6.48.  WTP Static IP Address Information
    title: 4.6.  CAPWAP Protocol Message Elements
  - contents:
    - "4.7.  CAPWAP Protocol Timers\n   This section contains the definition of the
      CAPWAP timers.\n"
    - contents:
      - "4.7.1.  ChangeStatePendingTimer\n   The maximum time, in seconds, the AC
        will wait for the Change State\n   Event Request from the WTP after having
        transmitted a successful\n   Configuration Status Response message.\n   Default:
        25 seconds\n"
      title: 4.7.1.  ChangeStatePendingTimer
    - contents:
      - "4.7.2.  DataChannelKeepAlive\n   The DataChannelKeepAlive timer is used by
        the WTP to determine the\n   next opportunity when it must transmit the Data
        Channel Keep-Alive,\n   in seconds.\n   Default: 30 seconds\n"
      title: 4.7.2.  DataChannelKeepAlive
    - contents:
      - "4.7.3.  DataChannelDeadInterval\n   The minimum time, in seconds, a WTP MUST
        wait without having received\n   a Data Channel Keep-Alive packet before the
        destination for the Data\n   Channel Keep-Alive packets may be considered
        dead.  The value of this\n   timer MUST be no less than 2*DataChannelKeepAlive
        seconds and no\n   greater that 240 seconds.\n   Default: 60\n"
      title: 4.7.3.  DataChannelDeadInterval
    - contents:
      - "4.7.4.  DataCheckTimer\n   The number of seconds the AC will wait for the
        Data Channel Keep\n   Alive, which is required by the CAPWAP state machine's
        Data Check\n   state.  The AC resets the state machine if this timer expires
        prior\n   to transitioning to the next state.\n   Default: 30\n"
      title: 4.7.4.  DataCheckTimer
    - contents:
      - "4.7.5.  DiscoveryInterval\n   The minimum time, in seconds, that a WTP MUST
        wait after receiving a\n   Discovery Response message, before initiating a
        DTLS handshake.\n   Default: 5\n"
      title: 4.7.5.  DiscoveryInterval
    - contents:
      - "4.7.6.  DTLSSessionDelete\n   The minimum time, in seconds, a WTP MUST wait
        for DTLS session\n   deletion.\n   Default: 5\n"
      title: 4.7.6.  DTLSSessionDelete
    - contents:
      - "4.7.7.  EchoInterval\n   The minimum time, in seconds, between sending Echo
        Request messages\n   to the AC with which the WTP has joined.\n   Default:
        30\n"
      title: 4.7.7.  EchoInterval
    - contents:
      - "4.7.8.  IdleTimeout\n   The default Idle Timeout is 300 seconds.\n"
      title: 4.7.8.  IdleTimeout
    - contents:
      - "4.7.9.  ImageDataStartTimer\n   The number of seconds the WTP will wait for
        its peer to transmit the\n   Image Data Request.\n   Default: 30\n"
      title: 4.7.9.  ImageDataStartTimer
    - contents:
      - "4.7.10.  MaxDiscoveryInterval\n   The maximum time allowed between sending
        Discovery Request messages,\n   in seconds.  This value MUST be no less than
        2 seconds and no greater\n   than 180 seconds.\n   Default: 20 seconds.\n"
      title: 4.7.10.  MaxDiscoveryInterval
    - contents:
      - "4.7.11.  ReportInterval\n   The ReportInterval is used by the WTP to determine
        the interval the\n   WTP uses between sending the Decryption Error message
        elements to\n   inform the AC of decryption errors, in seconds.\n   The default
        Report Interval is 120 seconds.\n"
      title: 4.7.11.  ReportInterval
    - contents:
      - "4.7.12.  RetransmitInterval\n   The minimum time, in seconds, in which a
        non-acknowledged CAPWAP\n   packet will be retransmitted.\n   Default: 3\n"
      title: 4.7.12.  RetransmitInterval
    - contents:
      - "4.7.13.  SilentInterval\n   For a WTP, this is the minimum time, in seconds,
        a WTP MUST wait\n   before it MAY again send Discovery Request messages or
        attempt to\n   establish a DTLS session.  For an AC, this is the minimum time,
        in\n   seconds, during which the AC SHOULD ignore all CAPWAP and DTLS\n   packets
        received from the WTP that is in the Sulking state.\n   Default: 30 seconds\n"
      title: 4.7.13.  SilentInterval
    - contents:
      - "4.7.14.  StatisticsTimer\n   The StatisticsTimer is used by the WTP to determine
        the interval the\n   WTP uses between the WTP Events Requests it transmits
        to the AC to\n   communicate its statistics, in seconds.\n   Default: 120
        seconds\n"
      title: 4.7.14.  StatisticsTimer
    - contents:
      - "4.7.15.  WaitDTLS\n   The maximum time, in seconds, a WTP MUST wait without
        having received\n   a DTLS Handshake message from an AC.  This timer MUST
        be greater than\n   30 seconds.\n   Default: 60\n"
      title: 4.7.15.  WaitDTLS
    - contents:
      - "4.7.16.  WaitJoin\n   The maximum time, in seconds, an AC will wait after
        the DTLS session\n   has been established until it receives the Join Request
        from the WTP.\n   This timer MUST be greater than 20 seconds.\n   Default:
        60\n"
      title: 4.7.16.  WaitJoin
    title: 4.7.  CAPWAP Protocol Timers
  - contents:
    - "4.8.  CAPWAP Protocol Variables\n   This section defines the CAPWAP protocol
      variables, which are used\n   for various protocol functions.  Some of these
      variables are\n   configurable, while others are counters or have a fixed value.
      \ For\n   non-counter-related variables, default values are specified.\n   However,
      when a WTP's variable configuration is explicitly overridden\n   by an AC, the
      WTP MUST save the new value.\n"
    - contents:
      - "4.8.1.  AdminState\n   The default Administrative State value is enabled
        (1).\n"
      title: 4.8.1.  AdminState
    - contents:
      - "4.8.2.  DiscoveryCount\n   The number of Discovery Request messages transmitted
        by a WTP to a\n   single AC.  This is a monotonically increasing counter.\n"
      title: 4.8.2.  DiscoveryCount
    - contents:
      - "4.8.3.  FailedDTLSAuthFailCount\n   The number of failed DTLS session establishment
        attempts due to\n   authentication failures.\n"
      title: 4.8.3.  FailedDTLSAuthFailCount
    - contents:
      - "4.8.4.  FailedDTLSSessionCount\n   The number of failed DTLS session establishment
        attempts.\n"
      title: 4.8.4.  FailedDTLSSessionCount
    - contents:
      - "4.8.5.  MaxDiscoveries\n   The maximum number of Discovery Request messages
        that will be sent\n   after a WTP boots.\n   Default: 10\n"
      title: 4.8.5.  MaxDiscoveries
    - contents:
      - "4.8.6.  MaxFailedDTLSSessionRetry\n   The maximum number of failed DTLS session
        establishment attempts\n   before the CAPWAP device enters a silent period.\n
        \  Default: 3\n"
      title: 4.8.6.  MaxFailedDTLSSessionRetry
    - contents:
      - "4.8.7.  MaxRetransmit\n   The maximum number of retransmissions for a given
        CAPWAP packet\n   before the link layer considers the peer dead.\n   Default:
        5\n"
      title: 4.8.7.  MaxRetransmit
    - contents:
      - "4.8.8.  RetransmitCount\n   The number of retransmissions for a given CAPWAP
        packet.  This is a\n   monotonically increasing counter.\n"
      title: 4.8.8.  RetransmitCount
    - contents:
      - "4.8.9.  WTPFallBack\n   The default WTP Fallback value is enabled (1).\n"
      title: 4.8.9.  WTPFallBack
    title: 4.8.  CAPWAP Protocol Variables
  - contents:
    - "4.9.  WTP Saved Variables\n   In addition to the values defined in Section
      4.8, the following\n   values SHOULD be saved on the WTP in non-volatile memory.
      \ CAPWAP\n   wireless bindings MAY define additional values that SHOULD be stored\n
      \  on the WTP.\n"
    - contents:
      - "4.9.1.  AdminRebootCount\n   The number of times the WTP has rebooted administratively,
        defined in\n   Section 4.6.47.\n"
      title: 4.9.1.  AdminRebootCount
    - contents:
      - "4.9.2.  FrameEncapType\n   For WTPs that support multiple Frame Encapsulation
        Types, it is\n   useful to save the value configured by the AC.  The Frame\n
        \  Encapsulation Type is defined in Section 4.6.43.\n"
      title: 4.9.2.  FrameEncapType
    - contents:
      - "4.9.3.  LastRebootReason\n   The reason why the WTP last rebooted, defined
        in Section 4.6.47.\n"
      title: 4.9.3.  LastRebootReason
    - contents:
      - "4.9.4.  MacType\n   For WTPs that support multiple MAC-Types, it is useful
        to save the\n   value configured by the AC.  The MAC-Type is defined in\n
        \  Section 4.6.44.\n"
      title: 4.9.4.  MacType
    - contents:
      - "4.9.5.  PreferredACs\n   The preferred ACs, with the index, defined in Section
        4.6.5.\n"
      title: 4.9.5.  PreferredACs
    - contents:
      - "4.9.6.  RebootCount\n   The number of times the WTP has rebooted, defined
        in Section 4.6.47.\n"
      title: 4.9.6.  RebootCount
    - contents:
      - "4.9.7.  Static IP Address\n   The static IP address assigned to the WTP,
        as configured by the WTP\n   Static IP address Information message element
        (see Section 4.6.48).\n"
      title: 4.9.7.  Static IP Address
    - contents:
      - "4.9.8.  WTPLinkFailureCount\n   The number of times the link to the AC has
        failed, see\n   Section 4.6.47.\n"
      title: 4.9.8.  WTPLinkFailureCount
    - contents:
      - "4.9.9.  WTPLocation\n   The WTP Location, defined in Section 4.6.30.\n"
      title: 4.9.9.  WTPLocation
    - contents:
      - "4.9.10.  WTPName\n   The WTP Name, defined in Section 4.6.45.\n"
      title: 4.9.10.  WTPName
    title: 4.9.  WTP Saved Variables
  title: 4.  CAPWAP Packet Formats
- contents:
  - "5.  CAPWAP Discovery Operations\n   The Discovery messages are used by a WTP
    to determine which ACs are\n   available to provide service, and the capabilities
    and load of the\n   ACs.\n"
  - contents:
    - "5.1.  Discovery Request Message\n   The Discovery Request message is used by
      the WTP to automatically\n   discover potential ACs available in the network.
      \ The Discovery\n   Request message provides ACs with the primary capabilities
      of the\n   WTP.  A WTP must exchange this information to ensure subsequent\n
      \  exchanges with the ACs are consistent with the WTP's functional\n   characteristics.\n
      \  Discovery Request messages MUST be sent by a WTP in the Discover\n   state
      after waiting for a random delay less than\n   MaxDiscoveryInterval, after a
      WTP first comes up or is\n   (re)initialized.  A WTP MUST send no more than
      the maximum of\n   MaxDiscoveries Discovery Request messages, waiting for a
      random delay\n   less than MaxDiscoveryInterval between each successive message.\n
      \  This is to prevent an explosion of WTP Discovery Request messages.\n   An
      example of this occurring is when many WTPs are powered on at the\n   same time.\n
      \  If a Discovery Response message is not received after sending the\n   maximum
      number of Discovery Request messages, the WTP enters the\n   Sulking state and
      MUST wait for an interval equal to SilentInterval\n   before sending further
      Discovery Request messages.\n   Upon receiving a Discovery Request message,
      the AC will respond with\n   a Discovery Response message sent to the address
      in the source\n   address of the received Discovery Request message.  Once a
      Discovery\n   Response has been received, if the WTP decides to establish a
      session\n   with the responding AC, it SHOULD perform an MTU discovery, using
      the\n   process described in Section 3.5.\n   It is possible for the AC to receive
      a clear text Discovery Request\n   message while a DTLS session is already active
      with the WTP.  This is\n   most likely the case if the WTP has rebooted, perhaps
      due to a\n   software or power failure, but could also be caused by a DoS attack.\n
      \  In such cases, any WTP state, including the state machine instance,\n   MUST
      NOT be cleared until another DTLS session has been successfully\n   established,
      communicated via the DTLSSessionEstablished DTLS\n   notification (see Section
      2.3.2.2).\n   The binding specific WTP Radio Information message element (see\n
      \  Section 2.1) is included in the Discovery Request message to\n   advertise
      WTP support for one or more CAPWAP bindings.\n   The Discovery Request message
      is sent by the WTP when in the\n   Discovery state.  The AC does not transmit
      this message.\n   The following message elements MUST be included in the Discovery\n
      \  Request message:\n   o  Discovery Type, see Section 4.6.21\n   o  WTP Board
      Data, see Section 4.6.40\n   o  WTP Descriptor, see Section 4.6.41\n   o  WTP
      Frame Tunnel Mode, see Section 4.6.43\n   o  WTP MAC Type, see Section 4.6.44\n
      \  o  WTP Radio Information message element(s) that the WTP supports;\n      These
      are defined by the individual link layer CAPWAP Binding\n      Protocols (see
      Section 2.1).\n   The following message elements MAY be included in the Discovery\n
      \  Request message:\n   o  MTU Discovery Padding, see Section 4.6.32\n   o  Vendor
      Specific Payload, see Section 4.6.39\n"
    title: 5.1.  Discovery Request Message
  - contents:
    - "5.2.  Discovery Response Message\n   The Discovery Response message provides
      a mechanism for an AC to\n   advertise its services to requesting WTPs.\n   When
      a WTP receives a Discovery Response message, it MUST wait for an\n   interval
      not less than DiscoveryInterval for receipt of additional\n   Discovery Response
      messages.  After the DiscoveryInterval elapses,\n   the WTP enters the DTLS-Init
      state and selects one of the ACs that\n   sent a Discovery Response message
      and send a DTLS Handshake to that\n   AC.\n   One or more binding-specific WTP
      Radio Information message elements\n   (see Section 2.1) are included in the
      Discovery Request message to\n   advertise AC support for the CAPWAP bindings.
      \ The AC MAY include\n   only the bindings it shares in common with the WTP,
      known through the\n   WTP Radio Information message elements received in the
      Discovery\n   Request message, or it MAY include all of the bindings supported.\n
      \  The WTP MAY use the supported bindings in its AC decision process.\n   Note
      that if the WTP joins an AC that does not support a specific\n   CAPWAP binding,
      service for that binding MUST NOT be provided by the\n   WTP.\n   The Discovery
      Response message is sent by the AC when in the Idle\n   state.  The WTP does
      not transmit this message.\n   The following message elements MUST be included
      in the Discovery\n   Response Message:\n   o  AC Descriptor, see Section 4.6.1\n
      \  o  AC Name, see Section 4.6.4\n   o  WTP Radio Information message element(s)
      that the AC supports;\n      these are defined by the individual link layer
      CAPWAP Binding\n      Protocols (see Section 2.1 for more information).\n   o
      \ One of the following message elements MUST be included in the\n      Discovery
      Response Message:\n      *  CAPWAP Control IPv4 Address, see Section 4.6.9\n
      \     *  CAPWAP Control IPv6 Address, see Section 4.6.10\n   The following message
      elements MAY be included in the Discovery\n   Response message:\n   o  Vendor
      Specific Payload, see Section 4.6.39\n"
    title: 5.2.  Discovery Response Message
  - contents:
    - "5.3.  Primary Discovery Request Message\n   The Primary Discovery Request message
      is sent by the WTP to:\n   o  determine whether its preferred (or primary) AC
      is available, or\n   o  perform a Path MTU Discovery (see Section 3.5).\n   A
      Primary Discovery Request message is sent by a WTP when it has a\n   primary
      AC configured, and is connected to another AC.  This\n   generally occurs as
      a result of a failover, and is used by the WTP as\n   a means to discover when
      its primary AC becomes available.  Since the\n   WTP only has a single instance
      of the CAPWAP state machine, the\n   Primary Discovery Request is sent by the
      WTP when in the Run state.\n   The AC does not transmit this message.\n   The
      frequency of the Primary Discovery Request messages should be no\n   more often
      than the sending of the Echo Request message.\n   Upon receipt of a Primary
      Discovery Request message, the AC responds\n   with a Primary Discovery Response
      message sent to the address in the\n   source address of the received Primary
      Discovery Request message.\n   The following message elements MUST be included
      in the Primary\n   Discovery Request message.\n   o  Discovery Type, see Section
      4.6.21\n   o  WTP Board Data, see Section 4.6.40\n   o  WTP Descriptor, see
      Section 4.6.41\n   o  WTP Frame Tunnel Mode, see Section 4.6.43\n   o  WTP MAC
      Type, see Section 4.6.44\n   o  WTP Radio Information message element(s) that
      the WTP supports;\n      these are defined by the individual link layer CAPWAP
      Binding\n      Protocols (see Section 2.1 for more information).\n   The following
      message elements MAY be included in the Primary\n   Discovery Request message:\n
      \  o  MTU Discovery Padding, see Section 4.6.32\n   o  Vendor Specific Payload,
      see Section 4.6.39\n"
    title: 5.3.  Primary Discovery Request Message
  - contents:
    - "5.4.  Primary Discovery Response\n   The Primary Discovery Response message
      enables an AC to advertise its\n   availability and services to requesting WTPs
      that are configured to\n   have the AC as its primary AC.\n   The Primary Discovery
      Response message is sent by an AC after\n   receiving a Primary Discovery Request
      message.\n   When a WTP receives a Primary Discovery Response message, it may\n
      \  establish a CAPWAP protocol connection to its primary AC, based on\n   the
      configuration of the WTP Fallback Status message element on the\n   WTP.\n   The
      Primary Discovery Response message is sent by the AC when in the\n   Idle state.
      \ The WTP does not transmit this message.\n   The following message elements
      MUST be included in the Primary\n   Discovery Response message.\n   o  AC Descriptor,
      see Section 4.6.1\n   o  AC Name, see Section 4.6.4\n   o  WTP Radio Information
      message element(s) that the AC supports;\n      These are defined by the individual
      link layer CAPWAP Binding\n      Protocols (see Section 2.1 for more information).\n
      \  One of the following message elements MUST be included in the\n   Discovery
      Response Message:\n   o  CAPWAP Control IPv4 Address, see Section 4.6.9\n   o
      \ CAPWAP Control IPv6 Address, see Section 4.6.10\n   The following message
      elements MAY be included in the Primary\n   Discovery Response message:\n   o
      \ Vendor Specific Payload, see Section 4.6.39\n"
    title: 5.4.  Primary Discovery Response
  title: 5.  CAPWAP Discovery Operations
- contents:
  - "6.  CAPWAP Join Operations\n   The Join Request message is used by a WTP to request
    service from an\n   AC after a DTLS connection is established to that AC.  The
    Join\n   Response message is used by the AC to indicate that it will or will\n
    \  not provide service.\n"
  - contents:
    - "6.1.  Join Request\n   The Join Request message is used by a WTP to request
      service through\n   the AC.  If the WTP is performing the optional AC Discovery
      process\n   (see Section 3.3), the join process occurs after the WTP has received\n
      \  one or more Discovery Response messages.  During the Discovery\n   process,
      an AC MAY return more than one CAPWAP Control IPv4 Address\n   or CAPWAP Control
      IPv6 Address message elements.  When more than one\n   such message element
      is returned, the WTP SHOULD perform \"load\n   balancing\" by choosing the interface
      that is servicing the least\n   number of WTPs (known through the WTP Count
      field of the message\n   element).  Note, however, that other load balancing
      algorithms are\n   also permitted.  Once the WTP has determined its preferred
      AC, and\n   its associated interface, to which to connect, it establishes the\n
      \  DTLS session, and transmits the Join Request over the secured control\n   channel.
      \ When an AC receives a Join Request message it responds with\n   a Join Response
      message.\n   Upon completion of the DTLS handshake and receipt of the\n   DTLSEstablished
      notification, the WTP sends the Join Request message\n   to the AC.  When the
      AC is notified of the DTLS session\n   establishment, it does not clear the
      WaitDTLS timer until it has\n   received the Join Request message, at which
      time it sends a Join\n   Response message to the WTP, indicating success or
      failure.\n   One or more WTP Radio Information message elements (see Section
      2.1)\n   are included in the Join Request to request service for the CAPWAP\n
      \  bindings by the AC.  Including a binding that is unsupported by the\n   AC
      will result in a failed Join Response.\n   If the AC rejects the Join Request,
      it sends a Join Response message\n   with a failure indication and initiates
      an abort of the DTLS session\n   via the DTLSAbort command.\n   If an invalid
      (i.e., malformed) Join Request message is received, the\n   message MUST be
      silently discarded by the AC.  No response is sent to\n   the WTP.  The AC SHOULD
      log this event.\n   The Join Request is sent by the WTP when in the Join State.
      \ The AC\n   does not transmit this message.\n   The following message elements
      MUST be included in the Join Request\n   message.\n   o  Location Data, see
      Section 4.6.30\n   o  WTP Board Data, see Section 4.6.40\n   o  WTP Descriptor,
      see Section 4.6.41\n   o  WTP Name, see Section 4.6.45\n   o  Session ID, see
      Section 4.6.37\n   o  WTP Frame Tunnel Mode, see Section 4.6.43\n   o  WTP MAC
      Type, see Section 4.6.44\n   o  WTP Radio Information message element(s) that
      the WTP supports;\n      these are defined by the individual link layer CAPWAP
      Binding\n      Protocols (see Section 2.1 for more information).\n   o  ECN
      Support, see Section 4.6.25\n   At least one of the following message element
      MUST be included in the\n   Join Request message.\n   o  CAPWAP Local IPv4 Address,
      see Section 4.6.11\n   o  CAPWAP Local IPv6 Address, see Section 4.6.12\n   The
      following message element MAY be included in the Join Request\n   message.\n
      \  o  CAPWAP Transport Protocol, see Section 4.6.14\n   o  Maximum Message Length,
      see Section 4.6.31\n   o  WTP Reboot Statistics, see Section 4.6.47\n   o  Vendor
      Specific Payload, see Section 4.6.39\n"
    title: 6.1.  Join Request
  - contents:
    - "6.2.  Join Response\n   The Join Response message is sent by the AC to indicate
      to a WTP that\n   it is capable and willing to provide service to the WTP.\n
      \  The WTP, receiving a Join Response message, checks for success or\n   failure.
      \ If the message indicates success, the WTP clears the\n   WaitDTLS timer for
      the session and proceeds to the Configure state.\n   If the WaitDTLS Timer expires
      prior to reception of the Join Response\n   message, the WTP MUST terminate
      the handshake, deallocate session\n   state and initiate the DTLSAbort command.\n
      \  If an invalid (malformed) Join Response message is received, the WTP\n   SHOULD
      log an informative message detailing the error.  This error\n   MUST be treated
      in the same manner as AC non-responsiveness.  The\n   WaitDTLS timer will eventually
      expire, and the WTP MAY (if it is so\n   configured) attempt to join a new AC.\n
      \  If one of the WTP Radio Information message elements (see\n   Section 2.1)
      in the Join Request message requested support for a\n   CAPWAP binding that
      the AC does not support, the AC sets the Result\n   Code message element to
      \"Binding Not Supported\".\n   The AC includes the Image Identifier message
      element to indicate the\n   software version it expects the WTP to run.  This
      information is used\n   to determine whether the WTP MUST change its currently
      running\n   firmware image or download a new version (see Section 9.1.1).\n
      \  The Join Response message is sent by the AC when in the Join State.\n   The
      WTP does not transmit this message.\n   The following message elements MUST
      be included in the Join Response\n   message.\n   o  Result Code, see Section
      4.6.35\n   o  AC Descriptor, see Section 4.6.1\n   o  AC Name, see Section 4.6.4\n
      \  o  WTP Radio Information message element(s) that the AC supports;\n      these
      are defined by the individual link layer CAPWAP Binding\n      Protocols (see
      Section 2.1).\n   o  ECN Support, see Section 4.6.25\n   One of the following
      message elements MUST be included in the Join\n   Response Message:\n   o  CAPWAP
      Control IPv4 Address, see Section 4.6.9\n   o  CAPWAP Control IPv6 Address,
      see Section 4.6.10\n   One of the following message elements MUST be included
      in the Join\n   Response Message:\n   o  CAPWAP Local IPv4 Address, see Section
      4.6.11\n   o  CAPWAP Local IPv6 Address, see Section 4.6.12\n   The following
      message elements MAY be included in the Join Response\n   message.\n   o  AC
      IPv4 List, see Section 4.6.2\n   o  AC IPv6 List, see Section 4.6.3\n   o  CAPWAP
      Transport Protocol, see Section 4.6.14\n   o  Image Identifier, see Section
      4.6.27\n   o  Maximum Message Length, see Section 4.6.31\n   o  Vendor Specific
      Payload, see Section 4.6.39\n"
    title: 6.2.  Join Response
  title: 6.  CAPWAP Join Operations
- contents:
  - "7.  Control Channel Management\n   The Control Channel Management messages are
    used by the WTP and AC to\n   maintain a control communication channel.  CAPWAP
    Control messages,\n   such as the WTP Event Request message sent from the WTP
    to the AC\n   indicate to the AC that the WTP is operational.  When such control\n
    \  messages are not being sent, the Echo Request and Echo Response\n   messages
    are used to maintain the control communication channel.\n"
  - contents:
    - "7.1.  Echo Request\n   The Echo Request message is a keep-alive mechanism for
      CAPWAP control\n   messages.\n   Echo Request messages are sent periodically
      by a WTP in the Image\n   Data or Run state (see Section 2.3) to determine the
      state of the\n   control connection between the WTP and the AC.  The Echo Request\n
      \  message is sent by the WTP when the EchoInterval timer expires.\n   The Echo
      Request message is sent by the WTP when in the Run state.\n   The AC does not
      transmit this message.\n   The following message elements MAY be included in
      the Echo Request\n   message:\n   o  Vendor Specific Payload, see Section 4.6.39\n
      \  When an AC receives an Echo Request message it responds with an Echo\n   Response
      message.\n"
    title: 7.1.  Echo Request
  - contents:
    - "7.2.  Echo Response\n   The Echo Response message acknowledges the Echo Request
      message.\n   An Echo Response message is sent by an AC after receiving an Echo\n
      \  Request message.  After transmitting the Echo Response message, the\n   AC
      SHOULD reset its EchoInterval timer (see Section 4.7.7).  If\n   another Echo
      Request message or other control message is not received\n   by the AC when
      the timer expires, the AC SHOULD consider the WTP to\n   be no longer reachable.\n
      \  The Echo Response message is sent by the AC when in the Run state.\n   The
      WTP does not transmit this message.\n   The following message elements MAY be
      included in the Echo Response\n   message:\n   o  Vendor Specific Payload, see
      Section 4.6.39\n   When a WTP receives an Echo Response message it initializes
      the\n   EchoInterval to the configured value.\n"
    title: 7.2.  Echo Response
  title: 7.  Control Channel Management
- contents:
  - "8.  WTP Configuration Management\n   WTP Configuration messages are used to exchange
    configuration\n   information between the AC and the WTP.\n"
  - contents:
    - "8.1.  Configuration Consistency\n   The CAPWAP protocol provides flexibility
      in how WTP configuration is\n   managed.  A WTP can behave in one of two ways,
      which is\n   implementation specific:\n   1. The WTP retains no configuration
      and accepts the configuration\n      provided by the AC.\n   2. The WTP saves
      the configuration of parameters provided by the AC\n      that are non-default
      values into local non-volatile memory, and\n      are enforced during the WTP's
      power up initialization phase.\n   If the WTP opts to save configuration locally,
      the CAPWAP protocol\n   state machine defines the Configure state, which allows
      for\n   configuration exchange.  In the Configure state, the WTP sends its\n
      \  current configuration overrides to the AC via the Configuration\n   Status
      Request message.  A configuration override is a non-default\n   parameter.  As
      an example, in the CAPWAP protocol, the default\n   antenna configuration is
      internal omni antenna.  A WTP that either\n   has no internal antennas, or has
      been explicitly configured by the AC\n   to use external antennas, sends its
      antenna configuration during the\n   configure phase, allowing the AC to become
      aware of the WTP's current\n   configuration.\n   Once the WTP has provided
      its configuration to the AC, the AC sends\n   its configuration to the WTP.
      \ This allows the WTP to receive\n   configuration and policies from the AC.\n
      \  The AC maintains a copy of each active WTP configuration.  There is\n   no
      need for versioning or other means to identify configuration\n   changes.  If
      a WTP becomes inactive, the AC MAY delete the inactive\n   WTP configuration.
      \ If a WTP fails, and connects to a new AC, the WTP\n   provides its overridden
      configuration parameters, allowing the new AC\n   to be aware of the WTP configuration.\n
      \  This model allows for resiliency in case of an AC failure, ensuring\n   another
      AC can provide service to the WTP.  A new AC would be\n   automatically updated
      with WTP configuration changes, eliminating the\n   need for inter-AC communication
      and the need for all ACs to be aware\n   of the configuration of all WTPs in
      the network.\n   Once the CAPWAP protocol enters the Run state, the WTPs begin
      to\n   provide service.  It is common for administrators to require that\n   configuration
      changes be made while the network is operational.\n   Therefore, the Configuration
      Update Request is sent by the AC to the\n   WTP to make these changes at run-time.\n"
    - contents:
      - "8.1.1.  Configuration Flexibility\n   The CAPWAP protocol provides the flexibility
        to configure and manage\n   WTPs of varying design and functional characteristics.
        \ When a WTP\n   first discovers an AC, it provides primary functional information\n
        \  relating to its type of MAC and to the nature of frames to be\n   exchanged.
        \ The AC configures the WTP appropriately.  The AC also\n   establishes corresponding
        internal state for the WTP.\n"
      title: 8.1.1.  Configuration Flexibility
    title: 8.1.  Configuration Consistency
  - contents:
    - "8.2.  Configuration Status Request\n   The Configuration Status Request message
      is sent by a WTP to deliver\n   its current configuration to the AC.\n   The
      Configuration Status Request message carries binding-specific\n   message elements.
      \ Refer to the appropriate binding for the\n   definition of this structure.\n
      \  When an AC receives a Configuration Status Request message, it acts\n   upon
      the content of the message and responds to the WTP with a\n   Configuration
      Status Response message.\n   The Configuration Status Request message includes
      multiple Radio\n   Administrative State message elements, one for the WTP, and
      one for\n   each radio in the WTP.\n   The Configuration Status Request message
      is sent by the WTP when in\n   the Configure State.  The AC does not transmit
      this message.\n   The following message elements MUST be included in the Configuration\n
      \  Status Request message.\n   o  AC Name, see Section 4.6.4\n   o  Radio Administrative
      State, see Section 4.6.33\n   o  Statistics Timer, see Section 4.6.38\n   o
      \ WTP Reboot Statistics, see Section 4.6.47\n   The following message elements
      MAY be included in the Configuration\n   Status Request message.\n   o  AC Name
      with Priority, see Section 4.6.5\n   o  CAPWAP Transport Protocol, see Section
      4.6.14\n   o  WTP Static IP Address Information, see Section 4.6.48\n   o  Vendor
      Specific Payload, see Section 4.6.39\n"
    title: 8.2.  Configuration Status Request
  - contents:
    - "8.3.  Configuration Status Response\n   The Configuration Status Response message
      is sent by an AC and\n   provides a mechanism for the AC to override a WTP's
      requested\n   configuration.\n   A Configuration Status Response message is
      sent by an AC after\n   receiving a Configuration Status Request message.\n
      \  The Configuration Status Response message carries binding-specific\n   message
      elements.  Refer to the appropriate binding for the\n   definition of this structure.\n
      \  When a WTP receives a Configuration Status Response message, it acts\n   upon
      the content of the message, as appropriate.  If the\n   Configuration Status
      Response message includes a Radio Operational\n   State message element that
      causes a change in the operational state\n   of one of the radios, the WTP transmits
      a Change State Event to the\n   AC, as an acknowledgement of the change in state.\n
      \  The Configuration Status Response message is sent by the AC when in\n   the
      Configure state.  The WTP does not transmit this message.\n   The following
      message elements MUST be included in the Configuration\n   Status Response message.\n
      \  o  CAPWAP Timers, see Section 4.6.13\n   o  Decryption Error Report Period,
      see Section 4.6.18\n   o  Idle Timeout, see Section 4.6.24\n   o  WTP Fallback,
      see Section 4.6.42\n   One or both of the following message elements MUST be
      included in the\n   Configuration Status Response message:\n   o  AC IPv4 List,
      see Section 4.6.2\n   o  AC IPv6 List, see Section 4.6.3\n   The following message
      element MAY be included in the Configuration\n   Status Response message.\n
      \  o  WTP Static IP Address Information, see Section 4.6.48\n   o  Vendor Specific
      Payload, see Section 4.6.39\n"
    title: 8.3.  Configuration Status Response
  - contents:
    - "8.4.  Configuration Update Request\n   Configuration Update Request messages
      are sent by the AC to provision\n   the WTP while in the Run state.  This is
      used to modify the\n   configuration of the WTP while it is operational.\n   When
      a WTP receives a Configuration Update Request message, it\n   responds with
      a Configuration Update Response message, with a Result\n   Code message element
      indicating the result of the configuration\n   request.\n   The AC includes
      the Image Identifier message element (see\n   Section 4.6.27) to force the WTP
      to update its firmware while in the\n   Run state.  The WTP MAY proceed to download
      the requested firmware if\n   it determines the version specified in the Image
      Identifier message\n   element is not in its non-volatile storage by transmitting
      an Image\n   Data Request (see Section 9.1.1) that includes the Initiate Download\n
      \  message element (see Section 4.6.29).\n   The Configuration Update Request
      is sent by the AC when in the Run\n   state.  The WTP does not transmit this
      message.\n   One or more of the following message elements MAY be included in
      the\n   Configuration Update message:\n   o  AC Name with Priority, see Section
      4.6.5\n   o  AC Timestamp, see Section 4.6.6\n   o  Add MAC ACL Entry, see Section
      4.6.7\n   o  CAPWAP Timers, see Section 4.6.13\n   o  Decryption Error Report
      Period, see Section 4.6.18\n   o  Delete MAC ACL Entry, see Section 4.6.19\n
      \  o  Idle Timeout, see Section 4.6.24\n   o  Location Data, see Section 4.6.30\n
      \  o  Radio Administrative State, see Section 4.6.33\n   o  Statistics Timer,
      see Section 4.6.38\n   o  WTP Fallback, see Section 4.6.42\n   o  WTP Name,
      see Section 4.6.45\n   o  WTP Static IP Address Information, see Section 4.6.48\n
      \  o  Image Identifier, see Section 4.6.27\n   o  Vendor Specific Payload, see
      Section 4.6.39\n"
    title: 8.4.  Configuration Update Request
  - contents:
    - "8.5.  Configuration Update Response\n   The Configuration Update Response message
      is the acknowledgement\n   message for the Configuration Update Request message.\n
      \  The Configuration Update Response message is sent by a WTP after\n   receiving
      a Configuration Update Request message.\n   When an AC receives a Configuration
      Update Response message, the\n   result code indicates if the WTP successfully
      accepted the\n   configuration.\n   The Configuration Update Response message
      is sent by the WTP when in\n   the Run state.  The AC does not transmit this
      message.\n   The following message element MUST be present in the Configuration\n
      \  Update message.\n   Result Code, see Section 4.6.35\n   The following message
      elements MAY be present in the Configuration\n   Update Response message.\n
      \  o  Radio Operational State, see Section 4.6.34\n   o  Vendor Specific Payload,
      see Section 4.6.39\n"
    title: 8.5.  Configuration Update Response
  - contents:
    - "8.6.  Change State Event Request\n   The Change State Event Request message
      is used by the WTP for two\n   main purposes:\n   o  When sent by the WTP following
      the reception of a Configuration\n      Status Response message from the AC,
      the WTP uses the Change State\n      Event Request message to provide an update
      on the WTP radio's\n      operational state and to confirm that the configuration
      provided\n      by the AC was successfully applied.\n   o  When sent during
      the Run state, the WTP uses the Change State\n      Event Request message to
      notify the AC of an unexpected change in\n      the WTP's radio operational
      state.\n   When an AC receives a Change State Event Request message it responds\n
      \  with a Change State Event Response message and modifies its data\n   structures
      for the WTP as needed.  The AC MAY decide not to provide\n   service to the
      WTP if it receives an error, based on local policy,\n   and to transition to
      the Reset state.\n   The Change State Event Request message is sent by a WTP
      to\n   acknowledge or report an error condition to the AC for a requested\n
      \  configuration in the Configuration Status Response message.  The\n   Change
      State Event Request message includes the Result Code message\n   element, which
      indicates whether the configuration was successfully\n   applied.  If the WTP
      is unable to apply a specific configuration\n   request, it indicates the failure
      by including one or more Returned\n   Message Element message elements (see
      Section 4.6.36).\n   The Change State Event Request message is sent by the WTP
      in the\n   Configure or Run state.  The AC does not transmit this message.\n
      \  The WTP MAY save its configuration to persistent storage prior to\n   transmitting
      the response.  However, this is implementation specific\n   and is not required.\n
      \  The following message elements MUST be present in the Change State\n   Event
      Request message.\n   o  Radio Operational State, see Section 4.6.34\n   o  Result
      Code, see Section 4.6.35\n   One or more of the following message elements MAY
      be present in the\n   Change State Event Request message:\n   o  Returned Message
      Element(s), see Section 4.6.36\n   o  Vendor Specific Payload, see Section 4.6.39\n"
    title: 8.6.  Change State Event Request
  - contents:
    - "8.7.  Change State Event Response\n   The Change State Event Response message
      acknowledges the Change State\n   Event Request message.\n   A Change State
      Event Response message is sent by an AC in response to\n   a Change State Event
      Request message.\n   The Change State Event Response message is sent by the
      AC when in the\n   Configure or Run state.  The WTP does not transmit this message.\n
      \  The following message element MAY be included in the Change State\n   Event
      Response message:\n   o  Vendor Specific Payload, see Section 4.6.39\n   The
      WTP does not take any action upon receipt of the Change State\n   Event Response
      message.\n"
    title: 8.7.  Change State Event Response
  - contents:
    - "8.8.  Clear Configuration Request\n   The Clear Configuration Request message
      is used to reset the WTP\n   configuration.\n   The Clear Configuration Request
      message is sent by an AC to request\n   that a WTP reset its configuration to
      the manufacturing default\n   configuration.  The Clear Config Request message
      is sent while in the\n   Run state.\n   The Clear Configuration Request is sent
      by the AC when in the Run\n   state.  The WTP does not transmit this message.\n
      \  The following message element MAY be included in the Clear\n   Configuration
      Request message:\n   o  Vendor Specific Payload, see Section 4.6.39\n   When
      a WTP receives a Clear Configuration Request message, it resets\n   its configuration
      to the manufacturing default configuration.\n"
    title: 8.8.  Clear Configuration Request
  - contents:
    - "8.9.  Clear Configuration Response\n   The Clear Configuration Response message
      is sent by the WTP after\n   receiving a Clear Configuration Request message
      and resetting its\n   configuration parameters to the manufacturing default
      values.\n   The Clear Configuration Response is sent by the WTP when in the
      Run\n   state.  The AC does not transmit this message.\n   The Clear Configuration
      Response message MUST include the following\n   message element:\n   o  Result
      Code, see Section 4.6.35\n   The following message element MAY be included in
      the Clear\n   Configuration Request message:\n   o  Vendor Specific Payload,
      see Section 4.6.39\n"
    title: 8.9.  Clear Configuration Response
  title: 8.  WTP Configuration Management
- contents:
  - "9.  Device Management Operations\n   This section defines CAPWAP operations responsible
    for debugging,\n   gathering statistics, logging, and firmware management.  The\n
    \  management operations defined in this section are used by the AC to\n   either
    push/pull information to/from the WTP, or request that the WTP\n   reboot.  This
    section does not deal with the management of the AC per\n   se, and assumes that
    the AC is operational and configured.\n"
  - contents:
    - "9.1.  Firmware Management\n   This section describes the firmware download
      procedures used by the\n   CAPWAP protocol.  Firmware download can occur during
      the Image Data\n   or Run state.  The former allows the download to occur at
      boot time,\n   while the latter is used to trigger the download while an active\n
      \  CAPWAP session exists.  It is important to note that the CAPWAP\n   protocol
      does not provide the ability for the AC to identify whether\n   the firmware
      information provided by the WTP is correct or whether\n   the WTP is properly
      storing the firmware (see Section 12.10 for more\n   information).\n   Figure
      6 provides an example of a WTP that performs a firmware\n   upgrade while in
      the Image Data state.  In this example, the WTP does\n   not already have the
      requested firmware (Image Identifier = x), and\n   downloads the image from
      the AC.\n             WTP                                               AC\n
      \                               Join Request\n         -------------------------------------------------------->\n
      \                    Join Response (Image Identifier = x)\n         <------------------------------------------------------\n
      \             Image Data Request (Image Identifier = x,\n                                  Initiate
      Download)\n         -------------------------------------------------------->\n
      \          Image Data Response (Result Code = Success,\n                                Image
      Information = {size,hash})\n         <------------------------------------------------------\n
      \               Image Data Request (Image Data = Data)\n         <------------------------------------------------------\n
      \               Image Data Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \                                 .....\n                Image Data Request
      (Image Data = EOF)\n         <------------------------------------------------------\n
      \               Image Data Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \                    (WTP enters the Reset State)\n                  Figure
      6: WTP Firmware Download Case 1\n   Figure 7 provides an example in which the
      WTP has the image specified\n   by the AC in its non-volatile storage, but is
      not its current running\n   image.  In this case, the WTP opts to NOT download
      the firmware and\n   immediately reset to the requested image.\n             WTP
      \                                              AC\n                                Join
      Request\n         -------------------------------------------------------->\n
      \                    Join Response (Image Identifier = x)\n         <------------------------------------------------------\n
      \                    (WTP enters the Reset State)\n                  Figure
      7: WTP Firmware Download Case 2\n   Figure 8 provides an example of a WTP that
      performs a firmware\n   upgrade while in the Run state.  This mode of firmware
      upgrade allows\n   the WTP to download its image while continuing to provide
      service.\n   The WTP will not automatically reset until it is notified by the
      AC,\n   with a Reset Request message.\n             WTP                                               AC\n
      \               Configuration Update Request (Image Identifier = x)\n         <------------------------------------------------------\n
      \           Configuration Update Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \             Image Data Request (Image Identifier = x,\n                                  Initiate
      Download)\n         -------------------------------------------------------->\n
      \             Image Data Response (Result Code = Success,\n                                   Image
      Information = {size,hash})\n         <------------------------------------------------------\n
      \               Image Data Request (Image Data = Data)\n         <------------------------------------------------------\n
      \               Image Data Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \                                 .....\n                Image Data Request
      (Image Data = EOF)\n         <------------------------------------------------------\n
      \               Image Data Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \                                 .....\n                (administratively requested
      reboot request)\n                   Reset Request (Image Identifier = x)\n         <------------------------------------------------------\n
      \                 Reset Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \                 Figure 8: WTP Firmware Download Case 3\n   Figure 9 provides
      another example of the firmware download while in\n   the Run state.  In this
      example, the WTP already has the image\n   specified by the AC in its non-volatile
      storage.  The WTP opts to NOT\n   download the firmware.  The WTP resets upon
      receipt of a Reset\n   Request message from the AC.\n             WTP                                               AC\n
      \            Configuration Update Request (Image Identifier = x)\n         <------------------------------------------------------\n
      \     Configuration Update Response (Result Code = Already Have Image)\n         -------------------------------------------------------->\n
      \                                 .....\n                (administratively requested
      reboot request)\n                   Reset Request (Image Identifier = x)\n         <------------------------------------------------------\n
      \                 Reset Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \                 Figure 9: WTP Firmware Download Case 4\n"
    - contents:
      - "9.1.1.  Image Data Request\n   The Image Data Request message is used to
        update firmware on the WTP.\n   This message and its companion Response message
        are used by the AC to\n   ensure that the image being run on each WTP is appropriate.\n
        \  Image Data Request messages are exchanged between the WTP and the AC\n
        \  to download a new firmware image to the WTP.  When a WTP or AC\n   receives
        an Image Data Request message, it responds with an Image\n   Data Response
        message.  The message elements contained within the\n   Image Data Request
        message are required to determine the intent of\n   the request.\n   The decision
        that new firmware is to be downloaded to the WTP can\n   occur in one of two
        ways:\n      When the WTP joins the AC, the Join Response message includes
        the\n      Image Identifier message element, which informs the WTP of the\n
        \     firmware it is expected to run.  If the WTP does not currently\n      have
        the requested firmware version, it transmits an Image Data\n      Request
        message, with the appropriate Image Identifier message\n      element.  If
        the WTP already has the requested firmware in its\n      non-volatile flash,
        but is not its currently running image, it\n      simply resets to run the
        proper firmware.\n      Once the WTP is in the Run state, it is possible for
        the AC to\n      cause the WTP to initiate a firmware download by sending
        a\n      Configuration Update Request message with the Image Identifier\n
        \     message elements.  This will cause the WTP to transmit an Image\n      Data
        Request with the Image Identifier and the Initiate Download\n      message
        elements.  Note that when the firmware is downloaded in\n      this way, the
        WTP does not automatically reset after the download\n      is complete.  The
        WTP will only reset when it receives a Reset\n      Request message from the
        AC.  If the WTP already had the requested\n      firmware version in its non-volatile
        storage, the WTP does not\n      transmit the Image Data Request message and
        responds with a\n      Configuration Update Response message with the Result
        Code set to\n      Image Already Present.\n   Regardless of how the download
        was initiated, once the AC receives an\n   Image Data Request message with
        the Image Identifier message element,\n   it begins the transfer process by
        transmitting an Image Data Request\n   message that includes the Image Data
        message element.  This continues\n   until the firmware image has been transferred.\n
        \  The Image Data Request message is sent by the WTP or the AC when in\n   the
        Image Data or Run state.\n   The following message elements MAY be included
        in the Image Data\n   Request message:\n   o  CAPWAP Transport Protocol, see
        Section 4.6.14\n   o  Image Data, see Section 4.6.26\n   o  Vendor Specific
        Payload, see Section 4.6.39\n   The following message elements MAY be included
        in the Image Data\n   Request message when sent by the WTP:\n   o  Image Identifier,
        see Section 4.6.27\n   o  Initiate Download, see Section 4.6.29\n"
      title: 9.1.1.  Image Data Request
    - contents:
      - "9.1.2.  Image Data Response\n   The Image Data Response message acknowledges
        the Image Data Request\n   message.\n   An Image Data Response message is
        sent in response to a received\n   Image Data Request message.  Its purpose
        is to acknowledge the\n   receipt of the Image Data Request message.  The
        Result Code is\n   included to indicate whether a previously sent Image Data
        Request\n   message was invalid.\n   The Image Data Response message is sent
        by the WTP or the AC when in\n   the Image Data or Run state.\n   The following
        message element MUST be included in the Image Data\n   Response message:\n
        \  o  Result Code, see Section 4.6.35\n   The following message element MAY
        be included in the Image Data\n   Response message:\n   o  Vendor Specific
        Payload, see Section 4.6.39\n   The following message element MAY be included
        in the Image Data\n   Response message when sent by the AC:\n   o  Image Information,
        see Section 4.6.28\n   Upon receiving an Image Data Response message indicating
        an error,\n   the WTP MAY retransmit a previous Image Data Request message,
        or\n   abandon the firmware download to the WTP by transitioning to the\n
        \  Reset state.\n"
      title: 9.1.2.  Image Data Response
    title: 9.1.  Firmware Management
  - contents:
    - "9.2.  Reset Request\n   The Reset Request message is used to cause a WTP to
      reboot.\n   A Reset Request message is sent by an AC to cause a WTP to\n   reinitialize
      its operation.  If the AC includes the Image Identifier\n   message element
      (see Section 4.6.27), it indicates to the WTP that it\n   SHOULD use that version
      of software upon reboot.\n   The Reset Request is sent by the AC when in the
      Run state.  The WTP\n   does not transmit this message.\n   The following message
      element MUST be included in the Reset Request\n   message:\n   o  Image Identifier,
      see Section 4.6.27\n   The following message element MAY be included in the
      Reset Request\n   message:\n   o  Vendor Specific Payload, see Section 4.6.39\n
      \  When a WTP receives a Reset Request message, it responds with a Reset\n   Response
      message indicating success and then reinitializes itself.\n   If the WTP is
      unable to write to its non-volatile storage, to ensure\n   that it runs the
      requested software version indicated in the Image\n   Identifier message element,
      it MAY send the appropriate Result Code\n   message element, but MUST reboot.
      \ If the WTP is unable to reset,\n   including a hardware reset, it sends a
      Reset Response message to the\n   AC with a Result Code message element indicating
      failure.  The AC no\n   longer provides service to the WTP.\n"
    title: 9.2.  Reset Request
  - contents:
    - "9.3.  Reset Response\n   The Reset Response message acknowledges the Reset
      Request message.\n   A Reset Response message is sent by the WTP after receiving
      a Reset\n   Request message.\n   The Reset Response is sent by the WTP when
      in the Run state.  The AC\n   does not transmit this message.\n   The following
      message elements MAY be included in the Reset Response\n   message.\n   o  Result
      Code, see Section 4.6.35\n   o  Vendor Specific Payload, see Section 4.6.39\n
      \  When an AC receives a successful Reset Response message, it is\n   notified
      that the WTP will reinitialize its operation.  An AC that\n   receives a Reset
      Response message indicating failure may opt to no\n   longer provide service
      to the WTP.\n"
    title: 9.3.  Reset Response
  - contents:
    - "9.4.  WTP Event Request\n   The WTP Event Request message is used by a WTP
      to send information to\n   its AC.  The WTP Event Request message MAY be sent
      periodically, or\n   sent in response to an asynchronous event on the WTP.  For
      example, a\n   WTP MAY collect statistics and use the WTP Event Request message
      to\n   transmit the statistics to the AC.\n   When an AC receives a WTP Event
      Request message it will respond with\n   a WTP Event Response message.\n   The
      presence of the Delete Station message element is used by the WTP\n   to inform
      the AC that it is no longer providing service to the\n   station.  This could
      be the result of an Idle Timeout (see\n   Section 4.6.24), due to resource shortages,
      or some other reason.\n   The WTP Event Request message is sent by the WTP when
      in the Run\n   state.  The AC does not transmit this message.\n   The WTP Event
      Request message MUST contain one of the message\n   elements listed below, or
      a message element that is defined for a\n   specific wireless technology.  More
      than one of each message element\n   listed MAY be included in the WTP Event
      Request message.\n   o  Decryption Error Report, see Section 4.6.17\n   o  Duplicate
      IPv4 Address, see Section 4.6.22\n   o  Duplicate IPv6 Address, see Section
      4.6.23\n   o  WTP Radio Statistics, see Section 4.6.46\n   o  WTP Reboot Statistics,
      see Section 4.6.47\n   o  Delete Station, see Section 4.6.20\n   o  Vendor Specific
      Payload, see Section 4.6.39\n"
    title: 9.4.  WTP Event Request
  - contents:
    - "9.5.  WTP Event Response\n   The WTP Event Response message acknowledges receipt
      of the WTP Event\n   Request message.\n   A WTP Event Response message is sent
      by an AC after receiving a WTP\n   Event Request message.\n   The WTP Event
      Response message is sent by the AC when in the Run\n   state.  The WTP does
      not transmit this message.\n   The following message element MAY be included
      in the WTP Event\n   Response message:\n   o  Vendor Specific Payload, see Section
      4.6.39\n"
    title: 9.5.  WTP Event Response
  - contents:
    - "9.6.  Data Transfer\n   This section describes the data transfer procedures
      used by the\n   CAPWAP protocol.  The data transfer mechanism is used to upload\n
      \  information available at the WTP to the AC, such as crash or debug\n   information.
      \ The data transfer messages can only be exchanged while\n   in the Run state.\n
      \  Figure 10 provides an example of an AC that requests that the WTP\n   transfer
      its latest crash file.  Once the WTP acknowledges that it\n   has information
      to send, via the Data Transfer Response, it transmits\n   its own Data Transfer
      Request.  Upon receipt, the AC responds with a\n   Data Transfer Response, and
      the exchange continues until the WTP\n   transmits a Data Transfer Data message
      element that indicates an End\n   of File (EOF).\n             WTP                                               AC\n
      \          Data Transfer Request (Data Transfer Mode = Crash Data)\n         <------------------------------------------------------\n
      \             Data Transfer Response (Result Code = Success)\n         -------------------------------------------------------->\n
      \             Data Transfer Request (Data Transfer Data = Data)\n         -------------------------------------------------------->\n
      \             Data Transfer Response (Result Code = Success)\n         <------------------------------------------------------\n
      \                                 .....\n                Data Transfer Request
      (Data Transfer Data = EOF)\n         -------------------------------------------------------->\n
      \             Data Transfer Response (Result Code = Success)\n         <------------------------------------------------------\n
      \                   Figure 10: WTP Data Transfer Case 1\n   Figure 11 provides
      an example of an AC that requests that the WTP\n   transfer its latest crash
      file.  However, in this example, the WTP\n   does not have any crash information
      to send, and therefore sends a\n   Data Transfer Response with a Result Code
      indicating the error.\n            WTP                                               AC\n
      \         Data Transfer Request (Data Transfer Mode = Crash Data)\n        <------------------------------------------------------\n
      \            Data Transfer Response (Result Code = Data Transfer\n                                     Error
      (No Information to Transfer))\n        -------------------------------------------------------->\n
      \                   Figure 11: WTP Data Transfer Case 2\n"
    - contents:
      - "9.6.1.  Data Transfer Request\n   The Data Transfer Request message is used
        to deliver debug\n   information from the WTP to the AC.\n   The Data Transfer
        Request messages can be sent either by the AC or\n   the WTP.  When sent by
        the AC, it is used to request that data be\n   transmitted from the WTP to
        the AC, and includes the Data Transfer\n   Mode message element, which specifies
        the information desired by the\n   AC.  The Data Transfer Request is sent
        by the WTP in order to\n   transfer actual data to the AC, through the Data
        Transfer Data\n   message element.\n   Given that the CAPWAP protocol minimizes
        the need for WTPs to be\n   directly managed, the Data Transfer Request is
        an important\n   troubleshooting tool used by the AC to retrieve information
        that may\n   be available on the WTP.  For instance, some WTP implementations
        may\n   store crash information to help manufacturers identify software\n
        \  faults.  The Data Transfer Request message can be used to send such\n   information
        from the WTP to the AC.  Another possible use would be to\n   allow a remote
        debugger function in the WTP to use the Data Transfer\n   Request message
        to send console output to the AC for debugging\n   purposes.\n   When the
        WTP or AC receives a Data Transfer Request message, it\n   responds to the
        WTP with a Data Transfer Response message.  The AC\n   MAY log the information
        received through the Data Transfer Data\n   message element.\n   The Data
        Transfer Request message is sent by the WTP or AC when in\n   the Run state.\n
        \  When sent by the AC, the Data Transfer Request message MUST contain\n   the
        following message element:\n   o  Data Transfer Mode, see Section 4.6.16\n
        \  When sent by the WTP, the Data Transfer Request message MUST contain\n
        \  the following message element:\n   o  Data Transfer Data, see Section 4.6.15\n
        \  Regardless of whether the Data Transfer Request is sent by the AC or\n
        \  WTP, the following message element MAY be included in the Data\n   Transfer
        Request message:\n   o  Vendor Specific Payload, see Section 4.6.39\n"
      title: 9.6.1.  Data Transfer Request
    - contents:
      - "9.6.2.  Data Transfer Response\n   The Data Transfer Response message acknowledges
        the Data Transfer\n   Request message.\n   A Data Transfer Response message
        is sent in response to a received\n   Data Transfer Request message.  Its
        purpose is to acknowledge receipt\n   of the Data Transfer Request message.
        \ When sent by the WTP, the\n   Result Code message element is used to indicate
        whether the data\n   transfer requested by the AC can be completed.  When
        sent by the AC,\n   the Result Code message element is used to indicate receipt
        of the\n   data transferred in the Data Transfer Request message.\n   The
        Data Transfer Response message is sent by the WTP or AC when in\n   the Run
        state.\n   The following message element MUST be included in the Data Transfer\n
        \  Response message:\n   o  Result Code, see Section 4.6.35\n   The following
        message element MAY be included in the Data Transfer\n   Response message:\n
        \  o  Vendor Specific Payload, see Section 4.6.39\n   Upon receipt of a Data
        Transfer Response message, the WTP transmits\n   more information, if more
        information is available.\n"
      title: 9.6.2.  Data Transfer Response
    title: 9.6.  Data Transfer
  title: 9.  Device Management Operations
- contents:
  - "10.  Station Session Management\n   Messages in this section are used by the
    AC to create, modify, or\n   delete station session state on the WTPs.\n"
  - contents:
    - "10.1.  Station Configuration Request\n   The Station Configuration Request
      message is used to create, modify,\n   or delete station session state on a
      WTP.  The message is sent by the\n   AC to the WTP, and MAY contain one or more
      message elements.  The\n   message elements for this CAPWAP Control message
      include information\n   that is generally highly technology specific.  Refer
      to the\n   appropriate binding document for definitions of the messages elements\n
      \  that are included in this control message.\n   The Station Configuration
      Request message is sent by the AC when in\n   the Run state.  The WTP does not
      transmit this message.\n   The following CAPWAP Control message elements MAY
      be included in the\n   Station Configuration Request message.  More than one
      of each message\n   element listed MAY be included in the Station Configuration
      Request\n   message:\n   o  Add Station, see Section 4.6.8\n   o  Delete Station,
      see Section 4.6.20\n   o  Vendor Specific Payload, see Section 4.6.39\n"
    title: 10.1.  Station Configuration Request
  - contents:
    - "10.2.  Station Configuration Response\n   The Station Configuration Response
      message is used to acknowledge a\n   previously received Station Configuration
      Request message.\n   The Station Configuration Response message is sent by the
      WTP when in\n   the Run state.  The AC does not transmit this message.\n   The
      following message element MUST be present in the Station\n   Configuration Response
      message:\n   o  Result Code, see Section 4.6.35\n   The following message element
      MAY be included in the Station\n   Configuration Response message:\n   o  Vendor
      Specific Payload, see Section 4.6.39\n   The Result Code message element indicates
      that the requested\n   configuration was successfully applied, or that an error
      related to\n   processing of the Station Configuration Request message occurred
      on\n   the WTP.\n"
    title: 10.2.  Station Configuration Response
  title: 10.  Station Session Management
- contents:
  - "11.  NAT Considerations\n   There are three specific situations in which a NAT
    deployment may be\n   used in conjunction with a CAPWAP-enabled deployment.  The
    first\n   consists of a configuration in which a single WTP is behind a NAT\n
    \  system.  Since all communication is initiated by the WTP, and all\n   communication
    is performed over IP using two UDP ports, the protocol\n   easily traverses NAT
    systems in this configuration.\n   In the second case, two or more WTPs are deployed
    behind the same NAT\n   system.  Here, the AC would receive multiple connection
    requests from\n   the same IP address, and therefore cannot use the WTP's IP address\n
    \  alone to bind the CAPWAP Control and Data channel.  The CAPWAP Data\n   Check
    state, which establishes the data plane connection and\n   communicates the CAPWAP
    Data Channel Keep-Alive, includes the Session\n   Identifier message element,
    which is used to bind the control and\n   data plane.  Use of the Session Identifier
    message element enables\n   the AC to match the control and data plane flows from
    multiple WTPs\n   behind the same NAT system (multiple WTPs sharing the same IP\n
    \  address).  CAPWAP implementations MUST also use DTLS session\n   information
    on any encrypted CAPWAP channel to validate the source of\n   both the control
    and data plane, as described in Section 12.2.\n   In the third configuration,
    the AC is deployed behind a NAT.  In this\n   case, the AC is not reachable by
    the WTP unless a specific rule has\n   been configured on the NAT to translate
    the address and redirect\n   CAPWAP messages to the AC.  This deployment presents
    two issues.\n   First, an AC communicates its interfaces and corresponding WTP
    load\n   using the CAPWAP Control IPv4 Address and CAPWAP Control IPv6 Address\n
    \  message elements.  This message element is mandatory, but contains IP\n   addresses
    that are only valid in the private address space used by\n   the AC, which is
    not reachable by the WTP.  The WTP MUST NOT utilize\n   the information in these
    message elements if it detects a NAT (as\n   described in the CAPWAP Transport
    Protocol message element in\n   Section 4.6.14).  Second, since the addresses
    cannot be used by the\n   WTP, this effectively disables the load-balancing capabilities
    (see\n   Section 6.1) of the CAPWAP protocol.  Alternatively, the AC could\n   have
    a configured NAT'ed address, which it would include in either of\n   the two control
    address message elements, and the NAT would need to\n   be configured accordingly.\n
    \  In order for a CAPWAP WTP or AC to detect whether a middlebox is\n   present,
    both the Join Request (see Section 6.1) and the Join\n   Response (see Section
    6.2) include either the CAPWAP Local IPv4\n   Address (see Section 4.6.11) or
    the CAPWAP Local IPv6 Address (see\n   Section 4.6.12) message element.  Upon
    receiving one of these\n   messages, if the packet's source IP address differs
    from the address\n   found in either one of these message elements, it indicates
    that a\n   middlebox is present.\n   In order for CAPWAP to be compatible with
    potential middleboxes in\n   the network, CAPWAP implementations MUST send return
    traffic from the\n   same port on which it received traffic from a given peer.
    \ Further,\n   any unsolicited requests generated by a CAPWAP node MUST be sent
    on\n   the same port.\n   Note that this middlebox detection technique is not
    foolproof.  If\n   the public IP address assigned to the NAT is identical to the
    private\n   IP address used by the AC, detection by the WTP would fail.  This\n
    \  failure can lead to various protocol errors, so it is therefore\n   necessary
    for deployments to ensure that the NAT's IP address is not\n   the same as the
    ACs.\n   The CAPWAP protocol allows for all of the AC identities supporting a\n
    \  group of WTPs to be communicated through the AC List message element.\n   This
    feature MUST be ignored by the WTP when it detects the AC is\n   behind a middlebox.\n
    \  The CAPWAP protocol allows an AC to configure a static IP address on\n   a
    WTP using the WTP Static IP Address Information message element.\n   This message
    element SHOULD NOT be used in NAT'ed environments,\n   unless the administrator
    is familiar with the internal IP addressing\n   scheme within the WTP's private
    network, and does not rely on the\n   public address seen by the AC.\n   When
    a WTP detects the duplicate address condition, it generates a\n   message to the
    AC, which includes the Duplicate IP Address message\n   element.  The IP address
    embedded within this message element is\n   different from the public IP address
    seen by the AC.\n"
  title: 11.  NAT Considerations
- contents:
  - "12.  Security Considerations\n   This section describes security considerations
    for the CAPWAP\n   protocol.  It also provides security recommendations for protocols\n
    \  used in conjunction with CAPWAP.\n"
  - contents:
    - "12.1.  CAPWAP Security\n   As it is currently specified, the CAPWAP protocol
      sits between the\n   security mechanisms specified by the wireless link layer
      protocol\n   (e.g., IEEE 802.11i) and Authentication, Authorization, and\n   Accounting
      (AAA).  One goal of CAPWAP is to bootstrap trust between\n   the STA and WTP
      using a series of preestablished trust relationships:\n         STA            WTP
      \          AC            AAA\n         ==============================================\n
      \                           DTLS Cred     AAA Cred\n                         <------------><------------->\n
      \                        EAP Credential\n          <------------------------------------------>\n
      \          wireless link layer\n           (e.g., 802.11 PTK)\n          <-------------->
      or\n          <--------------------------->\n              (derived)\n                       Figure
      12: STA Session Setup\n   Within CAPWAP, DTLS is used to secure the link between
      the WTP and\n   AC.  In addition to securing control messages, it's also a link
      in\n   this chain of trust for establishing link layer keys.  Consequently,\n
      \  much rests on the security of DTLS.\n   In some CAPWAP deployment scenarios,
      there are two channels between\n   the WTP and AC: the control channel, carrying
      CAPWAP Control\n   messages, and the data channel, over which client data packets
      are\n   tunneled between the AC and WTP.  Typically, the control channel is\n
      \  secured by DTLS, while the data channel is not.\n   The use of parallel protected
      and unprotected channels deserves\n   special consideration, but does not create
      a threat.  There are two\n   potential concerns: attempting to convert protected
      data into\n   unprotected data and attempting to convert un-protected data into\n
      \  protected data.  These concerns are addressed below.\n"
    - contents:
      - "12.1.1.  Converting Protected Data into Unprotected Data\n   Since CAPWAP
        does not support authentication-only ciphers (i.e., all\n   supported ciphersuites
        include encryption and authentication), it is\n   not possible to convert
        protected data into unprotected data.  Since\n   encrypted data is (ideally)
        indistinguishable from random data, the\n   probability of an encrypted packet
        passing for a well-formed packet\n   is effectively zero.\n"
      title: 12.1.1.  Converting Protected Data into Unprotected Data
    - contents:
      - "12.1.2.  Converting Unprotected Data into Protected Data (Insertion)\n   The
        use of message authentication makes it impossible for the\n   attacker to
        forge protected records.  This makes conversion of\n   unprotected records
        to protected records impossible.\n"
      title: 12.1.2.  Converting Unprotected Data into Protected Data (Insertion)
    - contents:
      - "12.1.3.  Deletion of Protected Records\n   An attacker could remove protected
        records from the stream, though\n   not undetectably so, due the built-in
        reliability of the underlying\n   CAPWAP protocol.  In the worst case, the
        attacker would remove the\n   same record repeatedly, resulting in a CAPWAP
        session timeout and\n   restart.  This is effectively a DoS attack, and could
        be accomplished\n   by a man in the middle regardless of the CAPWAP protocol
        security\n   mechanisms chosen.\n"
      title: 12.1.3.  Deletion of Protected Records
    - contents:
      - "12.1.4.   Insertion of Unprotected Records\n   An attacker could inject packets
        into the unprotected channel, but\n   this may become evident if sequence
        number desynchronization occurs\n   as a result.  Only if the attacker is
        a man in the middle (MITM) can\n   packets be inserted undetectably.  This
        is a consequence of that\n   channel's lack of protection, and not a new threat
        resulting from the\n   CAPWAP security mechanism.\n"
      title: 12.1.4.   Insertion of Unprotected Records
    - contents:
      - "12.1.5.  Use of MD5\n   The Image Information message element (Section 4.6.28)
        makes use of\n   MD5 to compute the hash field.  The authenticity and integrity
        of the\n   image file is protected by DTLS, and in this context, MD5 is not
        used\n   as a cryptographically secure hash, but just as a basic checksum.\n
        \  Therefore, the use of MD5 is not considered a security vulnerability,\n
        \  and no mechanisms for algorithm agility are provided.\n"
      title: 12.1.5.  Use of MD5
    - contents:
      - "12.1.6.  CAPWAP Fragmentation\n   RFC 4963 [RFC4963] describes a possible
        security vulnerability where\n   a malicious entity can \"corrupt\" a flow
        by injecting fragments.  By\n   sending \"high\" fragments (those with offset
        greater than zero) with a\n   forged source address, the attacker can deliberately
        cause\n   corruption.  The use of DTLS on the CAPWAP Data channel can be used\n
        \  to avoid this possible vulnerability.\n"
      title: 12.1.6.  CAPWAP Fragmentation
    title: 12.1.  CAPWAP Security
  - contents:
    - "12.2.  Session ID Security\n   Since DTLS does not export a unique session
      identifier, there can be\n   no explicit protocol binding between the DTLS layer
      and CAPWAP layer.\n   As a result, implementations MUST provide a mechanism
      for performing\n   this binding.  For example, an AC MUST NOT associate decrypted
      DTLS\n   control packets with a particular WTP session based solely on the\n
      \  Session ID in the packet header.  Instead, identification should be\n   done
      based on which DTLS session decrypted the packet.  Otherwise,\n   one authenticated
      WTP could spoof another authenticated WTP by\n   altering the Session ID in
      the encrypted CAPWAP Header.\n   It should be noted that when the CAPWAP Data
      channel is unencrypted,\n   the WTP Session ID is exposed and possibly known
      to adversaries and\n   other WTPs.  This would allow the forgery of the source
      of data-\n   channel traffic.  This, however, should not be a surprise for\n
      \  unencrypted data channels.  When the data channel is encrypted, the\n   Session
      ID is not exposed, and therefore can safely be used to\n   associate a data
      and control channel.  The 128-bit length of the\n   Session ID mitigates online
      guessing attacks where an adversarial,\n   authenticated WTP tries to correlate
      his own data channel with\n   another WTP's control channel.  Note that for
      encrypted data\n   channels, the Session ID should only be used for correlation
      for the\n   first packet immediately after the initial DTLS handshake.  Future\n
      \  correlation should instead be done via identification of a packet's\n   DTLS
      session.\n"
    title: 12.2.  Session ID Security
  - contents:
    - "12.3.  Discovery or DTLS Setup Attacks\n   Since the Discovery Request messages
      are sent in the clear, it is\n   important that AC implementations NOT assume
      that receiving a\n   Discovery Request message from a WTP implies that the WTP
      has\n   rebooted, and consequently tear down any active DTLS sessions.\n   Discovery
      Request messages can easily be spoofed by malicious\n   devices, so it is important
      that the AC maintain two separate sets of\n   states for the WTP until the DTLSSessionEstablished
      notification is\n   received, indicating that the WTP was authenticated.  Once
      a new DTLS\n   session is successfully established, any state referring to the
      old\n   session can be cleared.\n   Similarly, when the AC is entering the DTLS
      Setup phase, it SHOULD\n   NOT assume that the WTP has reset, and therefore
      should not discard\n   active state until the DTLS session has been successfully\n
      \  established.  While the HelloVerifyRequest provides some protection\n   against
      denial-of-service (DoS) attacks on the AC, an adversary\n   capable of receiving
      packets at a valid address (or a malfunctioning\n   or misconfigured WTP) may
      repeatedly attempt DTLS handshakes with the\n   AC, potentially creating a resource
      shortage.  If either the\n   FailedDTLSSessionCount or the FailedDTLSAuthFailCount
      counter reaches\n   the value of MaxFailedDTLSSessionRetry variable (see Section
      4.8),\n   implementations MAY choose to rate-limit new DTLS handshakes for some\n
      \  period of time.  It is RECOMMENDED that implementations choosing to\n   implement
      rate-limiting use a random discard technique, rather than\n   mimicking the
      WTP's sulking behavior.  This will ensure that messages\n   from valid WTPs
      will have some probability of eliciting a response,\n   even in the face of
      a significant DoS attack.\n   Some CAPWAP implementations may wish to restrict
      the DTLS setup\n   process to only those peers that have been configured in
      the access\n   control list, authorizing only those clients to initiate a DTLS\n
      \  handshake.  Note that the impact of this on mitigating denial-of-\n   service
      attacks against the DTLS layer is minimal, because DTLS\n   already uses client-side
      cookies to minimize processor consumption\n   attacks.\n"
    title: 12.3.  Discovery or DTLS Setup Attacks
  - contents:
    - "12.4.  Interference with a DTLS Session\n   If a WTP or AC repeatedly receives
      packets that fail DTLS\n   authentication or decryption, this could indicate
      a DTLS\n   desynchronization between the AC and WTP, a link prone to\n   undetectable
      bit errors, or an attacker trying to disrupt a DTLS\n   session.\n   In the
      state machine (section 2.3), transitions to the DTLS Tear Down\n   (TD) state
      can be triggered by frequently receiving DTLS packets with\n   authentication
      or decryption errors.  The threshold or technique for\n   deciding when to move
      to the tear down state should be chosen\n   carefully.  Being able to easily
      transition to DTLS TD allows easy\n   detection of malfunctioning devices, but
      allows for denial-of-service\n   attacks.  Making it difficult to transition
      to DTLS TD prevents\n   denial-of-service attacks, but makes it more difficult
      to detect and\n   reset a malfunctioning session.  Implementers should set this
      policy\n   with care.\n"
    title: 12.4.  Interference with a DTLS Session
  - contents:
    - "12.5.  CAPWAP Pre-Provisioning\n   In order for CAPWAP to establish a secure
      communication with a peer,\n   some level of pre-provisioning on both the WTP
      and AC is necessary.\n   This section will detail the minimal number of configuration\n
      \  parameters.\n   When using pre-shared keys, it is necessary to configure
      the pre-\n   shared key for each possible peer with which a DTLS session may
      be\n   established.  To support this mode of operation, one or more entries\n
      \  of the following table may be configured on either the AC or WTP:\n   o  Identity:
      The identity of the peering AC or WTP.  This format MAY\n      be in the form
      of either an IP address or host name (the latter of\n      which needs to be
      resolved to an IP address using DNS).\n   o  Key: The pre-shared key for use
      with the peer when establishing\n      the DTLS session (see Section 12.6 for
      more information).\n   o  PSK Identity: Identity hint associated with the provisioned
      key\n      (see Section 2.4.4.4 for more information).\n   When using certificates,
      the following items need to be pre-\n   provisioned:\n   o  Device Certificate:
      The local device's certificate (see\n      Section 12.7 for more information).\n
      \  o  Trust Anchor: Trusted root certificate chain used to validate any\n      certificate
      received from CAPWAP peers.  Note that one or more\n      root certificates
      MAY be configured on a given device.\n   Regardless of the authentication method,
      the following item needs to\n   be pre-provisioned:\n   o  Access Control List:
      The access control list table contains the\n      identities of one or more
      CAPWAP peers, along with a rule.  The\n      rule is used to determine whether
      communication with the peer is\n      permitted (see Section 2.4.4.3 for more
      information).\n"
    title: 12.5.  CAPWAP Pre-Provisioning
  - contents:
    - "12.6.  Use of Pre-Shared Keys in CAPWAP\n   While use of pre-shared keys may
      provide deployment and provisioning\n   advantages not found in public-key-based
      deployments, it also\n   introduces a number of operational and security concerns.
      \ In\n   particular, because the keys must typically be entered manually, it\n
      \  is common for people to base them on memorable words or phrases.\n   These
      are referred to as \"low entropy passwords/passphrases\".\n   Use of low-entropy
      pre-shared keys, coupled with the fact that the\n   keys are often not frequently
      updated, tends to significantly\n   increase exposure.  For these reasons, the
      following recommendations\n   are made:\n   o  When DTLS is used with a pre-shared
      key (PSK) ciphersuite, each\n      WTP SHOULD have a unique PSK.  Since WTPs
      will likely be widely\n      deployed, their physical security is not guaranteed.
      \ If PSKs are\n      not unique for each WTP, key reuse would allow the compromise
      of\n      one WTP to result in the compromise of others.\n   o  Generating PSKs
      from low entropy passwords is NOT RECOMMENDED.\n   o  It is RECOMMENDED that
      implementations that allow the\n      administrator to manually configure the
      PSK also provide a\n      capability for generation of new random PSKs, taking
      RFC 4086\n      [RFC4086] into account.\n   o  Pre-shared keys SHOULD be periodically
      updated.  Implementations\n      MAY facilitate this by providing an administrative
      interface for\n      automatic key generation and periodic update, or it MAY
      be\n      accomplished manually instead.\n   Every pairwise combination of WTP
      and AC on the network SHOULD have a\n   unique PSK.  This prevents the domino
      effect (see \"Guidance for\n   Authentication, Authorization, and Accounting
      (AAA) Key Management\"\n   [RFC4962]).  If PSKs are tied to specific WTPs, then
      knowledge of the\n   PSK implies a binding to a specified identity that can
      be authorized.\n   If PSKs are shared, this binding between device and identity
      is no\n   longer possible.  Compromise of one WTP can yield compromise of\n
      \  another WTP, violating the CAPWAP security hierarchy.  Consequently,\n   sharing
      keys between WTPs is NOT RECOMMENDED.\n"
    title: 12.6.  Use of Pre-Shared Keys in CAPWAP
  - contents:
    - "12.7.  Use of Certificates in CAPWAP\n   For public-key-based DTLS deployments,
      each device SHOULD have unique\n   credentials, with an extended key usage authorizing
      the device to act\n   as either a WTP or AC.  If devices do not have unique
      credentials, it\n   is possible that by compromising one device, any other device
      using\n   the same credential may also be considered to be compromised.\n   Certificate
      validation involves checking a large variety of things.\n   Since the necessary
      things to validate are often environment-\n   specific, many are beyond the
      scope of this document.  In this\n   section, we provide some basic guidance
      on certificate validation.\n   Each device is responsible for authenticating
      and authorizing devices\n   with which they communicate.  Authentication entails
      validation of\n   the chain of trust leading to the peer certificate, followed
      by the\n   peer certificate itself.  Implementations SHOULD also provide a\n
      \  secure method for verifying that the credential in question has not\n   been
      revoked.\n   Note that if the WTP relies on the AC for network connectivity
      (e.g.,\n   the AC is a Layer 2 switch to which the WTP is directly connected),\n
      \  the WTP may not be able to contact an Online Certificate Status\n   Protocol
      (OCSP) server or otherwise obtain an up-to-date Certificate\n   Revocation List
      (CRL) if a compromised AC doesn't explicitly permit\n   this.  This cannot be
      avoided, except through effective physical\n   security and monitoring measures
      at the AC.\n   Proper validation of certificates typically requires checking
      to\n   ensure the certificate has not yet expired.  If devices have a real-\n
      \  time clock, they SHOULD verify the certificate validity dates.  If no\n   real-time
      clock is available, the device SHOULD make a best-effort\n   attempt to validate
      the certificate validity dates through other\n   means.  Failure to check a
      certificate's temporal validity can make a\n   device vulnerable to man-in-the-middle
      attacks launched using\n   compromised, expired certificates, and therefore
      devices should make\n   every effort to perform this validation.\n"
    title: 12.7.  Use of Certificates in CAPWAP
  - contents:
    - "12.8.  Use of MAC Address in CN Field\n   The CAPWAP protocol is an evolution
      of an existing protocol [LWAPP],\n   which is implemented on a large number
      of already deployed ACs and\n   WTPs.  Every one of these devices has an existing
      X.509 certificate,\n   which is provisioned at the time of manufacturing.  These
      X.509\n   certificates use the device's MAC address in the Common Name (CN)\n
      \  field.  It is well understood that encoding the MAC address in the CN\n   field
      is less than optimal, and using the SubjectAltName field would\n   be preferable.
      \ However, at the time of publication, there is no URN\n   specification that
      allows for the MAC address to be used in the\n   SubjectAltName field.  As such
      a specification is published by the\n   IETF, future versions of the CAPWAP
      protocol MAY require support for\n   the new URN scheme.\n"
    title: 12.8.  Use of MAC Address in CN Field
  - contents:
    - "12.9.  AAA Security\n   The AAA protocol is used to distribute Extensible Authentication\n
      \  Protocol (EAP) keys to the ACs, and consequently its security is\n   important
      to the overall system security.  When used with Transport\n   Layer Security
      (TLS) or IPsec, security guidelines specified in RFC\n   3539 [RFC3539] SHOULD
      be followed.\n   In general, the link between the AC and AAA server SHOULD be
      secured\n   using a strong ciphersuite keyed with mutually authenticated session\n
      \  keys.  Implementations SHOULD NOT rely solely on Basic RADIUS shared\n   secret
      authentication as it is often vulnerable to dictionary\n   attacks, but rather
      SHOULD use stronger underlying security\n   mechanisms.\n"
    title: 12.9.  AAA Security
  - contents:
    - "12.10.  WTP Firmware\n   The CAPWAP protocol defines a mechanism by which the
      AC downloads new\n   firmware to the WTP.  During the session establishment
      process, the\n   WTP provides information about its current firmware to the
      AC.  The\n   AC then decides whether the WTP's firmware needs to be updated.
      \ It\n   is important to note that the CAPWAP specification makes the explicit\n
      \  assumption that the WTP is providing the correct firmware version to\n   the
      AC, and is therefore not lying.  Further, during the firmware\n   download process,
      the CAPWAP protocol does not provide any mechanisms\n   to recognize whether
      the WTP is actually storing the firmware for\n   future use.\n"
    title: 12.10.  WTP Firmware
  title: 12.  Security Considerations
- contents:
  - "13.  Operational Considerations\n   The CAPWAP protocol assumes that it is the
    only configuration\n   interface to the WTP to configure parameters that are specified
    in\n   the CAPWAP specifications.  While the use of a separate management\n   protocol
    MAY be used for the purposes of monitoring the WTP directly,\n   configuring the
    WTP through a separate management interface is not\n   recommended.  Configuring
    the WTP through a separate protocol, such\n   as via a command line interface
    (CLI) or Simple Network Management\n   Protocol (SNMP), could lead to the AC state
    being out of sync with\n   the WTP.\n   The CAPWAP protocol does not deal with
    the management of the ACs.\n   The AC is assumed to be configured through some
    separate management\n   interface, which could be via a proprietary CLI, SNMP,
    Network\n   Configuration Protocol (NETCONF), or some other management protocol.\n
    \  The CAPWAP protocol's control channel is fairly lightweight from a\n   traffic
    perspective.  Once the WTP has been configured, the WTP sends\n   periodic statistics.
    \ Further, the specification calls for a keep-\n   alive packet to be sent on
    the protocol's data channel to make sure\n   that any possible middleboxes (e.g.,
    NAT) maintain their UDP state.\n   The overhead associated with the control and
    data channel is not\n   expected to impact network traffic.  That said, the CAPWAP
    protocol\n   does allow for the frequency of these packets to be modified through\n
    \  the DataChannelKeepAlive and StatisticsTimer (see Section 4.7.2 and\n   Section
    4.7.14, respectively).\n"
  title: 13.  Operational Considerations
- contents:
  - "14.  Transport Considerations\n   The CAPWAP WG carefully considered the congestion
    control\n   requirements of the CAPWAP protocol, both for the CAPWAP Control and\n
    \  Data channels.\n   CAPWAP specifies a single-threaded command/response protocol
    to be\n   used on the control channel, and we have specified that an\n   exponential
    back-off algorithm should be used when commands are\n   retransmitted.  When CAPWAP
    runs in its default mode (Local MAC), the\n   control channel is the only CAPWAP
    channel.\n   However, CAPWAP can also be run in Split MAC mode, in which case\n
    \  there will be a DTLS-encrypted data channel between each WTP and the\n   AC.
    \ The WG discussed various options for providing congestion\n   control on this
    channel.  However, due to performance problems with\n   TCP when it is run over
    another congestion control mechanism and the\n   fact that the vast majority of
    traffic run over the CAPWAP Data\n   channel is likely to be congestion-controlled
    IP traffic, the CAPWAP\n   WG felt that specifying a congestion control mechanism
    for the CAPWAP\n   Data channel would be more likely to cause problems than to
    resolve\n   any.\n   Because there is no congestion control mechanism specified
    for the\n   CAPWAP Data channel, it is RECOMMENDED that non-congestion-controlled\n
    \  traffic not be tunneled over CAPWAP.  When a significant amount of\n   non-congestion-controlled
    traffic is expected to be present on a\n   WLAN, the CAPWAP connection between
    the AC and the WTP for that LAN\n   should be configured to remain in Local MAC
    mode with Distribution\n   function at the WTP.\n   The lock step nature of the
    CAPWAP protocol's control channel can\n   cause the firmware download process
    to take some time, depending upon\n   the round-trip time (RTT).  This is not
    expected to be a problem\n   since the CAPWAP protocol allows firmware to be downloaded
    while the\n   WTP provides service to wireless clients/devices.\n   It is necessary
    for the WTP and AC to configure their MTU based on\n   the capabilities of the
    path.  See Section 3.5 for more information.\n   The CAPWAP protocol mandates
    support of the Explicit Congestion\n   Notification (ECN) through a mode of operation
    named \"limited\n   functionality option\", detailed in section 9.1.1 of [RFC3168].\n
    \  Future versions of the CAPWAP protocol should consider mandating\n   support
    for the \"full functionality option\".\n"
  title: 14.  Transport Considerations
- contents:
  - "15.  IANA Considerations\n   This section details the actions that IANA has taken
    in preparation\n   for publication of the specification.  Numerous registries
    have been\n   created, and the contents, document action (see [RFC5226], and\n
    \  registry format are all included below.  Note that in cases where bit\n   fields
    are referred to, the bit numbering is left to right, where the\n   leftmost bit
    is labeled as bit zero (0).\n   For future registration requests where an Expert
    Review is required,\n   a Designated Expert should be consulted, which is appointed
    by the\n   responsible IESG Area Director.  The intention is that any allocation\n
    \  will be accompanied by a published RFC, but given that other SDOs may\n   want
    to create standards built on top of CAPWAP, a document the\n   Designated Expert
    can review is also acceptable.  IANA should allow\n   for allocation of values
    prior to documents being approved for\n   publication, so the Designated Expert
    can approve allocations once it\n   seems clear that publication will occur.  The
    Designated Expert will\n   post a request to the CAPWAP WG mailing list (or a
    successor\n   designated by the Area Director) for comment and review.  Before
    a\n   period of 30 days has passed, the Designated Expert will either\n   approve
    or deny the registration request and publish a notice of the\n   decision to the
    CAPWAP WG mailing list or its successor, as well as\n   informing IANA.  A denial
    notice must be justified by an explanation,\n   and in the cases where it is possible,
    concrete suggestions on how\n   the request can be modified so as to become acceptable
    should be\n   provided.\n"
  - contents:
    - "15.1.  IPv4 Multicast Address\n   IANA has registered a new IPv4 multicast
      address called \"capwap-ac\"\n   from the Internetwork Control Block IPv4 multicast
      address registry;\n   see Section 3.3.\n"
    title: 15.1.  IPv4 Multicast Address
  - contents:
    - "15.2.  IPv6 Multicast Address\n   IANA has registered a new organization local
      multicast address called\n   the \"All ACs multicast address\" in the Variable
      Scope IPv6 multicast\n   address registry; see Section 3.3.\n"
    title: 15.2.  IPv6 Multicast Address
  - contents:
    - "15.3.  UDP Port\n   IANA registered two new UDP Ports, which are organization-local\n
      \  multicast addresses, in the registered port numbers registry; see\n   Section
      3.1.  The following values have been registered:\n   Keyword         Decimal
      \   Description                  References\n   -------         -------    -----------
      \                 ----------\n   capwap-control  5246/udp   CAPWAP Control Protocol
      \     This Document\n   capwap-data     5247/udp   CAPWAP Data Protocol         This
      Document\n"
    title: 15.3.  UDP Port
  - contents:
    - "15.4.  CAPWAP Message Types\n   The Message Type field in the CAPWAP Header
      (see Section 4.5.1.1) is\n   used to identify the operation performed by the
      message.  There are\n   multiple namespaces, which are identified via the first
      three octets\n   of the field containing the IANA Enterprise Number [RFC5226].\n
      \  IANA maintains the CAPWAP Message Types registry for all message\n   types
      whose Enterprise Number is set to zero (0).  The namespace is 8\n   bits (0-255),
      where the value of zero (0) is reserved and must not be\n   assigned.  The values
      one (1) through 26 are allocated in this\n   specification, and can be found
      in Section 4.5.1.1.  Any new\n   assignments of a CAPWAP Message Type whose
      Enterprise Number is set\n   to zero (0) requires an Expert Review.  The registry
      maintained by\n   IANA has the following format:\n           CAPWAP Control
      Message           Message Type     Reference\n                                              Value\n"
    title: 15.4.  CAPWAP Message Types
  - contents:
    - "15.5.  CAPWAP Header Flags\n   The Flags field in the CAPWAP Header (see Section
      4.3) is 9 bits in\n   length and is used to identify any special treatment related
      to the\n   message.  This specification defines bits zero (0) through five (5),\n
      \  while bits six (6) through eight (8) are reserved.  There are\n   currently
      three unused, reserved bits that are managed by IANA and\n   whose assignment
      require an Expert Review.  IANA created the CAPWAP\n   Header Flags registry,
      whose format is:\n           Flag Field Name                   Bit Position
      \   Reference\n"
    title: 15.5.  CAPWAP Header Flags
  - contents:
    - "15.6.  CAPWAP Control Message Flags\n   The Flags field in the CAPWAP Control
      Message header (see\n   Section 4.5.1.4) is used to identify any special treatment
      related to\n   the control message.  There are currently eight (8) unused, reserved\n
      \  bits.  The assignment of these bits is managed by IANA and requires\n   an
      Expert Review.  IANA created the CAPWAP Control Message Flags\n   registry,
      whose format is:\n           Flag Field Name                   Bit Position
      \   Reference\n"
    title: 15.6.  CAPWAP Control Message Flags
  - contents:
    - "15.7.  CAPWAP Message Element Type\n   The Type field in the CAPWAP Message
      Element header (see Section 4.6)\n   is used to identify the data being transported.
      \ The namespace is 16\n   bits (0-65535), where the value of zero (0) is reserved
      and must not\n   be assigned.  The values one (1) through 53 are allocated in
      this\n   specification, and can be found in Section 4.5.1.1.\n   The 16-bit
      namespace is further divided into blocks of addresses that\n   are reserved
      for specific CAPWAP wireless bindings.  The following\n   blocks are reserved:\n
      \        CAPWAP Protocol Message Elements                   1 - 1023\n         IEEE
      802.11 Message Elements                    1024 - 2047\n         EPCGlobal Message
      Elements                      3072 - 4095\n   This namespace is managed by IANA
      and assignments require an Expert\n   Review.  IANA created the CAPWAP Message
      Element Type registry, whose\n   format is:\n           CAPWAP Message Element
      \          Type Value       Reference\n"
    title: 15.7.  CAPWAP Message Element Type
  - contents:
    - "15.8.  CAPWAP Wireless Binding Identifiers\n   The Wireless Binding Identifier
      (WBID) field in the CAPWAP Header\n   (see Section 4.3) is used to identify
      the wireless technology\n   associated with the packet.  This specification
      allocates the values\n   one (1) and three (3).  Due to the limited address
      space available, a\n   new WBID request requires Expert Review.  IANA created
      the CAPWAP\n   Wireless Binding Identifier registry, whose format is:\n           CAPWAP
      Wireless Binding Identifier  Type Value      Reference\n"
    title: 15.8.  CAPWAP Wireless Binding Identifiers
  - contents:
    - "15.9.  AC Security Types\n   The Security field in the AC Descriptor message
      element (see\n   Section 4.6.1) is 8 bits in length and is used to identify
      the\n   authentication methods available on the AC.  This specification\n   defines
      bits five (5) and six (6), while bits zero (0) through four\n   (4) as well
      as bit seven (7) are reserved and unused.  These reserved\n   bits are managed
      by IANA and assignment requires Standards Action.\n   IANA created the AC Security
      Types registry, whose format is:\n           AC Security Type                  Bit
      Position    Reference\n"
    title: 15.9.  AC Security Types
  - contents:
    - "15.10.  AC DTLS Policy\n   The DTLS Policy field in the AC Descriptor message
      element (see\n   Section 4.6.1) is 8 bits in length and is used to identify
      whether\n   the CAPWAP Data Channel is to be secured.  This specification defines\n
      \  bits five (5) and six (6), while bits zero (0) through four (4) as\n   well
      as bit seven (7) are reserved and unused.  These reserved bits\n   are managed
      by IANA and assignment requires Standards Action.  IANA\n   created the AC DTLS
      Policy registry, whose format is:\n           AC DTLS Policy                    Bit
      Position    Reference\n"
    title: 15.10.  AC DTLS Policy
  - contents:
    - "15.11.  AC Information Type\n   The Information Type field in the AC Descriptor
      message element (see\n   Section 4.6.1) is used to represent information about
      the AC.  The\n   namespace is 16 bits (0-65535), where the value of zero (0)
      is\n   reserved and must not be assigned.  This field, combined with the AC\n
      \  Information Vendor ID, allows vendors to use a private namespace.\n   This
      specification defines the AC Information Type namespace when the\n   AC Information
      Vendor ID is set to zero (0), for which the values\n   four (4) and five (5)
      are allocated in this specification, and can be\n   found in Section 4.6.1.
      \ This namespace is managed by IANA and\n   assignments require an Expert Review.
      \ IANA created the AC\n   Information Type registry, whose format is:\n           AC
      Information Type              Type Value       Reference\n"
    title: 15.11.  AC Information Type
  - contents:
    - "15.12.  CAPWAP Transport Protocol Types\n   The Transport field in the CAPWAP
      Transport Protocol message element\n   (see Section 4.6.14) is used to identify
      the transport to use for the\n   CAPWAP Data Channel.  The namespace is 8 bits
      (0-255), where the\n   value of zero (0) is reserved and must not be assigned.
      \ The values\n   one (1) and two (2) are allocated in this specification, and
      can be\n   found in Section 4.6.14.  This namespace is managed by IANA and\n
      \  assignments require an Expert Review.  IANA created the CAPWAP\n   Transport
      Protocol Types registry, whose format is:\n           CAPWAP Transport Protocol
      Type   Type Value       Reference\n"
    title: 15.12.  CAPWAP Transport Protocol Types
  - contents:
    - "15.13.  Data Transfer Type\n   The Data Type field in the Data Transfer Data
      message element (see\n   Section 4.6.15) and Image Data message element (see
      Section 4.6.26)\n   is used to provide information about the data being carried.
      \ The\n   namespace is 8 bits (0-255), where the value of zero (0) is reserved\n
      \  and must not be assigned.  The values one (1), two (2), and five (5)\n   are
      allocated in this specification, and can be found in\n   Section 4.6.15.  This
      namespace is managed by IANA and assignments\n   require an Expert Review.  IANA
      created the Data Transfer Type\n   registry, whose format is:\n           Data
      Transfer Type               Type Value       Reference\n"
    title: 15.13.  Data Transfer Type
  - contents:
    - "15.14.  Data Transfer Mode\n   The Data Mode field in the Data Transfer Data
      message element (see\n   Section 4.6.15) and Data Transfer Mode message element
      (see\n   Section 15.14) is used to provide information about the data being\n
      \  carried.  The namespace is 8 bits (0-255), where the value of zero\n   (0)
      is reserved and must not be assigned.  The values one (1) and two\n   (2) are
      allocated in this specification, and can be found in\n   Section 15.14.  This
      namespace is managed by IANA and assignments\n   require an Expert Review.  IANA
      created the Data Transfer Mode\n   registry, whose format is:\n           Data
      Transfer Mode               Type Value       Reference\n"
    title: 15.14.  Data Transfer Mode
  - contents:
    - "15.15.  Discovery Types\n   The Discovery Type field in the Discovery Type
      message element (see\n   Section 4.6.21) is used by the WTP to indicate to the
      AC how it was\n   discovered.  The namespace is 8 bits (0-255).  The values
      zero (0)\n   through four (4) are allocated in this specification and can be
      found\n   in Section 4.6.21.  This namespace is managed by IANA and assignments\n
      \  require an Expert Review.  IANA created the Discovery Types registry,\n   whose
      format is:\n           Discovery Types                  Type Value       Reference\n"
    title: 15.15.  Discovery Types
  - contents:
    - "15.16.  ECN Support\n   The ECN Support field in the ECN Support message element
      (see\n   Section 4.6.25) is used by the WTP to represent its ECN Support.  The\n
      \  namespace is 8 bits (0-255).  The values zero (0) and one (1) are\n   allocated
      in this specification, and can be found in Section 4.6.25.\n   This namespace
      is managed by IANA and assignments require an Expert\n   Review.  IANA created
      the ECN Support registry, whose format is:\n           ECN Support                      Type
      Value       Reference\n"
    title: 15.16.  ECN Support
  - contents:
    - "15.17.  Radio Admin State\n   The Radio Admin field in the Radio Administrative
      State message\n   element (see Section 4.6.33) is used by the WTP to represent
      the\n   state of its radios.  The namespace is 8 bits (0-255), where the\n   value
      of zero (0) is reserved and must not be assigned.  The values\n   one (1) and
      two (2) are allocated in this specification, and can be\n   found in Section
      4.6.33.  This namespace is managed by IANA and\n   assignments require an Expert
      Review.  IANA created the Radio Admin\n   State registry, whose format is:\n
      \          Radio Admin State                Type Value       Reference\n"
    title: 15.17.  Radio Admin State
  - contents:
    - "15.18.  Radio Operational State\n   The State field in the Radio Operational
      State message element (see\n   Section 4.6.34) is used by the WTP to represent
      the operational state\n   of its radios.  The namespace is 8 bits (0-255), where
      the value of\n   zero (0) is reserved and must not be assigned.  The values
      one (1)\n   and two (2) are allocated in this specification, and can be found
      in\n   Section 4.6.34.  This namespace is managed by IANA and assignments\n
      \  require an Expert Review.  IANA created the Radio Operational State\n   registry,
      whose format is:\n           Radio Operational State          Type Value       Reference\n"
    title: 15.18.  Radio Operational State
  - contents:
    - "15.19.  Radio Failure Causes\n   The Cause field in the Radio Operational State
      message element (see\n   Section 4.6.34) is used by the WTP to represent the
      reason a radio\n   may have failed.  The namespace is 8 bits (0-255), where
      the value of\n   zero (0) through three (3) are allocated in this specification,
      and\n   can be found in Section 4.6.34.  This namespace is managed by IANA\n
      \  and assignments require an Expert Review.  IANA created the Radio\n   Failure
      Causes registry, whose format is:\n           Radio Failure Causes             Type
      Value       Reference\n"
    title: 15.19.  Radio Failure Causes
  - contents:
    - "15.20.  Result Code\n   The Result Code field in the Result Code message element
      (see\n   Section 4.6.35) is used to indicate the success or failure of a\n   CAPWAP
      Control message.  The namespace is 32 bits (0-4294967295),\n   where the value
      of zero (0) through 22 are allocated in this\n   specification, and can be found
      in Section 4.6.35.  This namespace is\n   managed by IANA and assignments require
      an Expert Review.  IANA\n   created the Result Code registry, whose format is:\n
      \          Result Code                      Type Value       Reference\n"
    title: 15.20.  Result Code
  - contents:
    - "15.21.  Returned Message Element Reason\n   The Reason field in the Returned
      Message Element message element (see\n   Section 4.6.36) is used to indicate
      the reason why a message element\n   was not processed successfully.  The namespace
      is 8 bits (0-255),\n   where the value of zero (0) is reserved and must not
      be assigned.\n   The values one (1) through four (4) are allocated in this\n
      \  specification, and can be found in Section 4.6.36.  This namespace is\n   managed
      by IANA and assignments require an Expert Review.  IANA\n   created the Returned
      Message Element Reason registry, whose format\n   is:\n           Returned Message
      Element Reason  Type Value       Reference\n"
    title: 15.21.  Returned Message Element Reason
  - contents:
    - "15.22.  WTP Board Data Type\n   The Board Data Type field in the WTP Board
      Data message element (see\n   Section 4.6.40) is used to represent information
      about the WTP\n   hardware.  The namespace is 16 bits (0-65535).  The WTP Board
      Data\n   Type values zero (0) through four (4) are allocated in this\n   specification,
      and can be found in Section 4.6.40.  This namespace is\n   managed by IANA and
      assignments require an Expert Review.  IANA\n   created the WTP Board Data Type
      registry, whose format is:\n           WTP Board Data Type              Type
      Value       Reference\n"
    title: 15.22.  WTP Board Data Type
  - contents:
    - "15.23.  WTP Descriptor Type\n   The Descriptor Type field in the WTP Descriptor
      message element (see\n   Section 4.6.41) is used to represent information about
      the WTP\n   software.  The namespace is 16 bits (0-65535).  This field, combined\n
      \  with the Descriptor Vendor ID, allows vendors to use a private\n   namespace.
      \ This specification defines the WTP Descriptor Type\n   namespace when the
      Descriptor Vendor ID is set to zero (0), for which\n   the values zero (0) through
      three (3) are allocated in this\n   specification, and can be found in Section
      4.6.41.  This namespace is\n   managed by IANA and assignments require an Expert
      Review.  IANA\n   created the WTP Board Data Type registry, whose format is:\n
      \          WTP Descriptor Type              Type Value       Reference\n"
    title: 15.23.  WTP Descriptor Type
  - contents:
    - "15.24.  WTP Fallback Mode\n   The Mode field in the WTP Fallback message element
      (see\n   Section 4.6.42) is used to indicate the type of AC fallback mechanism\n
      \  the WTP should employ.  The namespace is 8 bits (0-255), where the\n   value
      of zero (0) is reserved and must not be assigned.  The values\n   one (1) and
      two (2) are allocated in this specification, and can be\n   found in Section
      4.6.42.  This namespace is managed by IANA and\n   assignments require an Expert
      Review.  IANA created the WTP Fallback\n   Mode registry, whose format is:\n
      \          WTP Fallback Mode                Type Value       Reference\n"
    title: 15.24.  WTP Fallback Mode
  - contents:
    - "15.25.  WTP Frame Tunnel Mode\n   The Tunnel Type field in the WTP Frame Tunnel
      Mode message element\n   (see Section 4.6.43) is 8 bits and is used to indicate
      the type of\n   tunneling to use between the WTP and the AC.  This specification\n
      \  defines bits four (4) through six (6), while bits zero (0) through\n   three
      (3) as well as bit seven (7) are reserved and unused.  These\n   reserved bits
      are managed by IANA and assignment requires an Expert\n   Review.  IANA created
      the WTP Frame Tunnel Mode registry, whose\n   format is:\n           WTP Frame
      Tunnel Mode             Bit Position    Reference\n"
    title: 15.25.  WTP Frame Tunnel Mode
  - contents:
    - "15.26.  WTP MAC Type\n   The MAC Type field in the WTP MAC Type message element
      (see\n   Section 4.6.44) is used to indicate the type of MAC to use in\n   tunneled
      frames between the WTP and the AC.  The namespace is 8 bits\n   (0-255), where
      the value of zero (0) through two (2) are allocated in\n   this specification,
      and can be found in Section 4.6.44.  This\n   namespace is managed by IANA and
      assignments require an Expert\n   Review.  IANA created the WTP MAC Type registry,
      whose format is:\n           WTP MAC Type                     Type Value       Reference\n"
    title: 15.26.  WTP MAC Type
  - contents:
    - "15.27.  WTP Radio Stats Failure Type\n   The Last Failure Type field in the
      WTP Radio Statistics message\n   element (see Section 4.6.46) is used to indicate
      the last WTP\n   failure.  The namespace is 8 bits (0-255), where the value
      of zero\n   (0) through three (3) as well as the value 255 are allocated in
      this\n   specification, and can be found in Section 4.6.46.  This namespace
      is\n   managed by IANA and assignments require an Expert Review.  IANA\n   created
      the WTP Radio Stats Failure Type registry, whose format is:\n           WTP
      Radio Stats Failure Type     Type Value       Reference\n"
    title: 15.27.  WTP Radio Stats Failure Type
  - contents:
    - "15.28.  WTP Reboot Stats Failure Type\n   The Last Failure Type field in the
      WTP Reboot Statistics message\n   element (see Section 4.6.47) is used to indicate
      the last reboot\n   reason.  The namespace is 8 bits (0-255), where the value
      of zero (0)\n   through five (5) as well as the value 255 are allocated in this\n
      \  specification, and can be found in Section 4.6.47.  This namespace is\n   managed
      by IANA and assignments require an Expert Review.  IANA\n   created the WTP
      Reboot Stats Failure Type registry, whose format is:\n           WTP Reboot
      Stats Failure Type    Type Value       Reference\n"
    title: 15.28.  WTP Reboot Stats Failure Type
  title: 15.  IANA Considerations
- contents:
  - "16.  Acknowledgments\n   The following individuals are acknowledged for their
    contributions to\n   this protocol specification: Puneet Agarwal, Abhijit Choudhury,
    Pasi\n   Eronen, Saravanan Govindan, Peter Nilsson, David Perkins, and Yong\n
    \  Zhang.\n   Michael Vakulenko contributed text to describe how CAPWAP can be
    used\n   over Layer 3 (IP/UDP) networks.\n"
  title: 16.  Acknowledgments
- contents:
  - '17.  References

    '
  - contents:
    - "17.1.  Normative References\n   [RFC1191]          Mogul, J. and S. Deering,
      \"Path MTU discovery\",\n                      RFC 1191, November 1990.\n   [RFC1321]
      \         Rivest, R., \"The MD5 Message-Digest Algorithm\",\n                      RFC
      1321, April 1992.\n   [RFC1305]          Mills, D., \"Network Time Protocol
      (Version 3)\n                      Specification, Implementation\", RFC 1305,\n
      \                     March 1992.\n   [RFC1981]          McCann, J., Deering,
      S., and J. Mogul, \"Path MTU\n                      Discovery for IP version
      6\", RFC 1981,\n                      August 1996.\n   [RFC2119]          Bradner,
      S., \"Key words for use in RFCs to\n                      Indicate Requirement
      Levels\", BCP 14, RFC 2119,\n                      March 1997.\n   [RFC2460]
      \         Deering, S. and R. Hinden, \"Internet Protocol,\n                      Version
      6 (IPv6) Specification\", RFC 2460,\n                      December 1998.\n
      \  [RFC2474]          Nichols, K., Blake, S., Baker, F., and D. Black,\n                      \"Definition
      of the Differentiated Services Field\n                      (DS Field) in the
      IPv4 and IPv6 Headers\",\n                      RFC 2474, December 1998.\n   [RFC2782]
      \         Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS\n                      RR
      for specifying the location of services (DNS\n                      SRV)\",
      RFC 2782, February 2000.\n   [RFC3168]          Ramakrishnan, K., Floyd, S.,
      and D. Black, \"The\n                      Addition of Explicit Congestion Notification
      (ECN)\n                      to IP\", RFC 3168, September 2001.\n   [RFC3539]
      \         Aboba, B. and J. Wood, \"Authentication,\n                      Authorization
      and Accounting (AAA) Transport\n                      Profile\", RFC 3539, June
      2003.\n   [RFC3629]          Yergeau, F., \"UTF-8, a transformation format of\n
      \                     ISO 10646\", STD 63, RFC 3629, November 2003.\n   [RFC3828]
      \         Larzon, L-A., Degermark, M., Pink, S., Jonsson,\n                      L-E.,
      and G. Fairhurst, \"The Lightweight User\n                      Datagram Protocol
      (UDP-Lite)\", RFC 3828,\n                      July 2004.\n   [RFC4086]          Eastlake,
      D., Schiller, J., and S. Crocker,\n                      \"Randomness Requirements
      for Security\", BCP 106,\n                      RFC 4086, June 2005.\n   [RFC4279]
      \         Eronen, P. and H. Tschofenig, \"Pre-Shared Key\n                      Ciphersuites
      for Transport Layer Security (TLS)\",\n                      RFC 4279, December
      2005.\n   [RFC5246]          Dierks, T. and E. Rescorla, \"The Transport Layer\n
      \                     Security (TLS) Protocol Version 1.2\", RFC 5246,\n                      August
      2008.\n   [RFC4347]          Rescorla, E. and N. Modadugu, \"Datagram Transport\n
      \                     Layer Security\", RFC 4347, April 2006.\n   [RFC4821]
      \         Mathis, M. and J. Heffner, \"Packetization Layer\n                      Path
      MTU Discovery\", RFC 4821, March 2007.\n   [RFC4963]          Heffner, J., Mathis,
      M., and B. Chandler, \"IPv4\n                      Reassembly Errors at High
      Data Rates\", RFC 4963,\n                      July 2007.\n   [RFC5226]          Narten,
      T. and H. Alvestrand, \"Guidelines for\n                      Writing an IANA
      Considerations Section in RFCs\",\n                      BCP 26, RFC 5226, May
      2008.\n   [RFC5280]          Cooper, D., Santesson, S., Farrell, S., Boeyen,\n
      \                     S., Housley, R., and W. Polk, \"Internet X.509\n                      Public
      Key Infrastructure Certificate and\n                      Certificate Revocation
      List (CRL) Profile\",\n                      RFC 5280, May 2008.\n   [ISO.9834-1.1993]
      \ International Organization for Standardization,\n                      \"Procedures
      for the operation of OSI registration\n                      authorities - part
      1: general procedures\",\n                      ISO Standard 9834-1, 1993.\n
      \  [RFC5416]          Calhoun, P., Ed., Montemurro, M., Ed., and D.\n                      Stanley,
      Ed., \"Control And Provisioning of\n                      Wireless Access Points
      (CAPWAP) Protocol Binding\n                      for IEEE 802.11\", RFC 5416,
      March 2009.\n   [RFC5417]          Calhoun, P., \"Control And Provisioning of
      Wireless\n                      Access Points (CAPWAP) Access Controller DHCP\n
      \                     Option\", RFC 5417, March 2009.\n   [FRAME-EXT]        IEEE,
      \"IEEE Standard 802.3as-2006\", 2005.\n"
    title: 17.1.  Normative References
  - contents:
    - "17.2.  Informative References\n   [RFC3232]          Reynolds, J., \"Assigned
      Numbers: RFC 1700 is\n                      Replaced by an On-line Database\",
      RFC 3232,\n                      January 2002.\n   [RFC3753]          Manner,
      J. and M. Kojo, \"Mobility Related\n                      Terminology\", RFC
      3753, June 2004.\n   [RFC4564]          Govindan, S., Cheng, H., Yao, ZH., Zhou,
      WH., and\n                      L. Yang, \"Objectives for Control and Provisioning\n
      \                     of Wireless Access Points (CAPWAP)\", RFC 4564,\n                      July
      2006.\n   [RFC4962]          Housley, R. and B. Aboba, \"Guidance for\n                      Authentication,
      Authorization, and Accounting\n                      (AAA) Key Management\",
      BCP 132, RFC 4962,\n                      July 2007.\n   [LWAPP]            Calhoun,
      P., O'Hara, B., Suri, R., Cam Winget, N.,\n                      Kelly, S.,
      Williams, M., and S. Hares,\n                      \"Lightweight Access Point
      Protocol\", Work in\n                      Progress, March 2007.\n   [SLAPP]
      \           Narasimhan, P., Harkins, D., and S. Ponnuswamy,\n                      \"SLAPP:
      Secure Light Access Point Protocol\", Work\n                      in Progress,
      May 2005.\n   [DTLS-DESIGN]      Modadugu, et al., N., \"The Design and\n                      Implementation
      of Datagram TLS\", Feb 2004.\n   [EUI-48]           IEEE, \"Guidelines for use
      of a 48-bit Extended\n                      Unique Identifier\", Dec 2005.\n
      \  [EUI-64]           IEEE, \"GUIDELINES FOR 64-BIT GLOBAL IDENTIFIER\n                      (EUI-64)
      REGISTRATION AUTHORITY\".\n   [EPCGlobal]        \"See http://www.epcglobalinc.org/home\".\n
      \  [PacketCable]      \"PacketCable Security Specification PKT-SP-SEC-\n                      I12-050812\",
      August 2005, <PacketCable>.\n   [CableLabs]        \"OpenCable System Security
      Specification OC-SP-\n                      SEC-I07-061031\", October 2006,
      <CableLabs>.\n   [WiMAX]            \"WiMAX Forum X.509 Device Certificate Profile\n
      \                     Approved Specification V1.0.1\", April 2008,\n                      <WiMAX>.\n
      \  [RFC5418]          Kelly, S. and C. Clancy, \"Control And Provisioning\n
      \                     for Wireless Access Points (CAPWAP) Threat\n                      Analysis
      for IEEE 802.11 Deployments\", RFC 5418,\n                      March 2009.\n"
    title: 17.2.  Informative References
  title: 17.  References
- contents:
  - "Editors' Addresses\n   Pat R. Calhoun (editor)\n   Cisco Systems, Inc.\n   170
    West Tasman Drive\n   San Jose, CA  95134\n   Phone: +1 408-902-3240\n   EMail:
    pcalhoun@cisco.com\n   Michael P. Montemurro (editor)\n   Research In Motion\n
    \  5090 Commerce Blvd\n   Mississauga, ON  L4W 5M4\n   Canada\n   Phone: +1 905-629-4746
    x4999\n   EMail: mmontemurro@rim.com\n   Dorothy Stanley (editor)\n   Aruba Networks\n
    \  1322 Crossman Ave\n   Sunnyvale, CA  94089\n   Phone: +1 630-363-1389\n   EMail:
    dstanley@arubanetworks.com\n"
  title: Editors' Addresses
