- title: __initial_text__
  contents:
  - '                      Multicast Transport Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard.  Distribution of this memo is\n\
    \   unlimited.\n"
- title: Summary
  contents:
  - "Summary\n   This memo describes a protocol for reliable transport that utilizes\n\
    \   the multicast capability of applicable lower layer networking\n   architectures.\
    \  The transport definition permits an arbitrary number\n   of transport providers\
    \ to perform realtime collaborations without\n   requiring networking clients\
    \ (aka, applications) to possess detailed\n   knowledge of the population or geographical\
    \ dispersion of the\n   participating members.  It is not network architectural\
    \ specific, but\n   does implicitly require some form of multicasting (or broadcasting)\n\
    \   at the data link level, as well as some means of communicating that\n   capability\
    \ up through the layers to the transport.\n   Keywords: reliable transport, multicast,\
    \ broadcast, collaboration,\n   networking.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n           1. Introduction                               \
    \      2\n           2. Protocol description                             3\n \
    \          2.1 Definition of terms                             3\n           2.2\
    \ Packet format                                   6\n           2.2.1. Protocol\
    \ version                             7\n           2.2.2. Packet type and modifier\
    \                     7\n           2.2.3. Subchannel                        \
    \           9\n           2.2.4. Source connection identifier                \
    \ 9\n           2.2.5. Destination connection identifier           10\n      \
    \     2.2.6. Message acceptance                          10\n           2.2.7.\
    \ Heartbeat                                   12\n           2.2.8. Window   \
    \                                   12\n           2.2.9. Retention          \
    \                         12\n           2.3 Transport addresses             \
    \               12\n           2.3.1. Unknown transport address              \
    \     12\n           2.3.2. Web's multicast address                     13\n \
    \          2.3.3. Member addresses                            13\n           3.\
    \ Protocol behavior                               13\n           3.1. Establishing\
    \ a transport                      13\n           3.1.1. Join request        \
    \                        14\n           3.1.2. Join confirm/deny             \
    \              16\n           3.2 Maintaining data consistency               \
    \    17\n           3.2.1. Transmit tokens                             17\n  \
    \         3.2.2. Data transmission                           20\n           3.2.3.\
    \ Empty packets                               23\n           3.2.4. Missed data\
    \                                 26\n           3.2.5. Retrying operations  \
    \                       26\n           3.2.6. Retransmission                 \
    \             27\n           3.2.7. Duplicate suppression                    \
    \   29\n           3.2.8. Banishment                                  29\n   \
    \        3.3 Terminating the transport                      29\n           3.3.1.\
    \ Voluntary quits                             30\n           3.3.2. Master quit\
    \                                 30\n           3.3.3. Banishment           \
    \                       30\n           3.4 Transport parameters              \
    \             30\n           3.4.1. Quality of service                       \
    \   30\n           3.4.2. Selecting parameter values                  31\n   \
    \        3.4.3. Caching member information                  33\n           A.\
    \ Appendix: MTP as an Internet Protocol transport 34\n           A.1 Internet\
    \ Protocol multicast addressing         34\n           A.2 Encapsulation     \
    \                             35\n           A.3 Fields of the bridge protocol\
    \                  35\n           A.4 Relationship to other Internet Transports\
    \      36\n           References                                         36\n\
    \           Footnotes                                          37\n          \
    \ Security Considerations                            37\n           Authors' Addresses\
    \                                 38\n"
- title: 1.      Introduction
  contents:
  - "1.      Introduction\n   This document describes a flow controlled, atomic multicasting\n\
    \   transport protocol (MTP).  The purpose of this document is to present\n  \
    \ sufficient information to implement the protocol.\n   The MTP design has been\
    \ influenced by the large body of the\n   networking and distributed systems literature\
    \ and technology that has\n   been introduced during the last decade and a half.\
    \  Representative\n   sources include [Xer81], [BSTM79] and [Pos81] for transport\
    \ design,\n   and [Bog83] and [DIX82] for general concepts of broadcast and\n\
    \   multicast.  [CLZ87] influenced MTP's retransmission mechanisms, and\n   [Fre84]\
    \ influenced the transport timings. MTP over IP uses mechanisms\n   described\
    \ in [Dee89].  MTP's ordering and agreement protocols were\n   influenced by work\
    \ done in [CM87], [JB89] and [Cri88].  Finally, a\n   description of MTP's philosophy\
    \ and its motivation can be found in\n   [AFM91].\n"
- title: 2.      Protocol description
  contents:
  - "2.      Protocol description\n   MTP is a transport in that it is a client of\
    \ the network layer (as\n   defined by the OSI networking model) [1].  MTP provides\
    \ reliable\n   delivery of client data between one or more communicating processes,\n\
    \   as well as a predefined principal process. The collection of\n   processes\
    \ is called a web.\n   In addition to transporting data reliably and efficiently,\
    \ MTP\n   provides the synchronization necessary for web members to agree on\n\
    \   the order of receipt of all messages and can agree on the delivery of\n  \
    \ the message even in the face of partitions.  This ordering and\n   agreement\
    \ protocol uses serialized tokens granted by the master to\n   producers.\n  \
    \ The processes may have any one of three levels of capability. One\n   member\
    \ must be the master. The master instantiates and controls the\n   behavior of\
    \ the web, including its membership and performance. Non\n   master members may\
    \ be either producer/consumers or pure consumers.\n   The former class of member\
    \ is permitted to transmit user data to the\n   entire membership (and expected\
    \ to logically hear itself), while the\n   latter is prohibited from transmitting\
    \ user data.\n   MTP is a negative acknowledgement protocol, exploiting the highly\n\
    \   reliable delivery of the local area and wide area network\n   technologies\
    \ of today. Successful delivery of data is accepted by\n   consuming stations\
    \ silently rather than having the successful\n   delivery noted to the producing\
    \ process, thus reducing the amount of\n   reverse traffic required to maintain\
    \ synchronization.\n"
- title: 2.1     Definition of terms
  contents:
  - "2.1     Definition of terms\n   The following terms are used throughout this\
    \ document. They are\n   defined here to eliminate ambiguity.\n   consumer   \
    \ A consumer is a transport that is capable only of\n               receiving\
    \ user data. It may transmit control packets,\n               such as negative\
    \ acknowledgements, but may never transmit\n               any requests for the\
    \ transmit token or any form of data\n               or empty messages.\n   heartbeat\
    \   A heartbeat is an interval of time, nominally measured in\n              \
    \ milliseconds. It is a key parameter in the transport's\n               state\
    \ and can be adapted to the requirements of the\n               transport's client\
    \ to provide the desired quality of\n               service.\n   master      The\
    \ master is the principal member of the web. The master\n               capability\
    \ is a superset of a producer member.  The\n               master is mainly responsible\
    \ for giving out transmit\n               tokens to members who wish to send data,\
    \ and overseeing\n               the web's membership and operational parameters.\n\
    \   member      A web member is any process that has been permitted to\n     \
    \          join the web (by the master) as well as the master\n              \
    \ itself.\n   membership  Every member is classified as to its intentions for\n\
    \   class       joining the web. Membership classes are defined to be\n      \
    \         consumer, producer and master. Each successive class is a\n        \
    \       formal superset of the previous.\n   message     An MTP message is a concatenation\
    \ of the user data\n               portions of a series of data packets with the\
    \ last packet\n               in the series carrying an end of message indication.\
    \ A\n               message may contain any number of bytes of user data,\n  \
    \             including zero.\n   NSAP        The network service access point.\
    \ This is the network\n               address, or the node address of the machine,\
    \ where a\n               service is available.\n   producer    Producer is a\
    \ class of membership that is a formal\n               superset of a consumer.\
    \ A producer is permitted (and\n               expected) to transmit client data\
    \ as well as consume data\n               transmitted by other producers.\n  \
    \ retention   Retention is one of the three fundamental parameters that\n    \
    \           make up the transport's state (along with heartbeat and\n        \
    \       window). Retention is a number of heartbeats, and though\n           \
    \    applied in several different circumstances, is primarily\n              \
    \ used as the number of heartbeats a producing client must\n               maintain\
    \ buffered data should it need to be\n               retransmitted.\n   token\
    \       In order to transmit, a producer must first be in\n               possesion\
    \ of a token. Tokens are granted only by the\n               master and include\
    \ the message sequence number.\n               Consequently, they are fundamental\
    \ in the operation of\n               the ordering and agreement protocol used\
    \ by MTP.\n   TSAP        The transport service access point. This is the address\n\
    \               that uniquely defines particular instantiation of a\n        \
    \       service. TSAPs are formed by logically concatenating the\n           \
    \    node's NSAP with a transport identifier (and perhaps a\n               packet/protocol\
    \ type).\n   user data   User data is the client information carried in MTP data\n\
    \               packets and treated as uninterpreted octets by the\n         \
    \      transport. The end of message and subchannel indicators\n             \
    \  are also be treated as user data.\n   web         A collection of processes\
    \ collaborating on the solution\n               of a single problem.\n   window\
    \      The window is one of the fundamental elements of the\n               transport's\
    \ state that can be controlled to affect the\n               quality of service\
    \ being provided to the client. It\n               represents the number of user\
    \ data carrying packets that\n               may be multicast into the web during\
    \ a heartbeat by a\n               single member.\n"
- title: 2.2     Packet format
  contents:
  - "2.2     Packet format\n   An MTP packet consists of a transport protocol header\
    \ followed by a\n   variable amount of data. The protocol header, shown in Figure\
    \ 1, is\n   part of every packet. The remainder of the packet is either user data\n\
    \   (packet type = data) or additional transport specific information.\n   The\
    \ fields in the header are statically defined as n-bit wide\n   quantities. There\
    \ are no undefined fields or fields that may at any\n   time have undefined values.\
    \  Reserved fields, if they exist, must\n   always have a value of zero.\n   \
    \ 0           7 8           15 16         23 24         31\n   ----------------------------------------------------------\
    \    -----\n   |  protocol    |    packet   |    type     |    client   |    \
    \  |\n   |  version     |    type     |    modifier |    channel  |      |\n \
    \  ----------------------------------------------------------      |\n   |   \
    \                                                     |      |\n   |         \
    \     source connection identifier              |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              destination connection identifier         |\n   ----------------------------------------------------------\
    \ transport\n   |                                                        |   \
    \ header\n   |              message acceptance criteria               |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              heartbeat                                 |      |\n   ----------------------------------------------------------\
    \      |\n   |                            |                           |      |\n\
    \   |        window              |        retention          |      |\n   ----------------------------------------------------------\
    \    -----\n   |                                                        |    \
    \  |\n   |                                                        |      |\n \
    \  |                                                        |      |\n   |   \
    \                (data content and format             |\n   |                \
    \   dependent on packet type             |    data\n   |                   and\
    \ modifier)                        |    fields\n   |                         \
    \                               |\n   |                                      \
    \                  |      |\n   |                                            \
    \            |      |\n   |                                                  \
    \      |      |\n   ----------------------------------------------------------\
    \    -----\n                        Figure 1. MTP packet format\n"
- title: 2.2.1.  Protocol version
  contents:
  - "2.2.1.  Protocol version\n   The first 8 bits of the packet are the protocol\
    \ version number. This\n   document describes version 1 of the Multicast Transport\
    \ Protocol and\n   thus the version field has a value of 0x01.\n"
- title: 2.2.2.  Packet type and modifier
  contents:
  - "2.2.2.  Packet type and modifier\n   The second byte of the header is the packet\
    \ type and the following\n   byte contains the packet type modifier. Typical control\
    \ message\n   exchanges are in a request/response pair. The modifier field\n \
    \  simplifies the construction of responses by permitting reuse of the\n   incoming\
    \ message with minimal modification. The following table gives\n   the packet\
    \ type field values along with their modifiers. The\n   modifiers are valid only\
    \ in the context of the type. In the prose of\n   the definitions and later in\
    \ the document, the syntax for referring\n   to one of the entries described in\
    \ the following table will be\n   type[modifier]. For example, a reference to\
    \ data[eow] would be a\n   packet of type data with an end of window modifier.\n\
    \   type       modifier     description\n   data(0)    data(0)      The packet\
    \ is one that contains user\n                           information. Only the\
    \ process possessing a\n                           transmit token is permitted\
    \ to send data\n                           unless specifically requested to retransmit\n\
    \                           previously transmitted data. All packets of\n    \
    \                       type data are multicast to the entire web.\n         \
    \     eow(1)       A data packet with the eow (end of window)\n              \
    \             modifier set indicates that the transmitter\n                  \
    \         intends to send no more packets in this\n                          \
    \ heartbeat either because it has sent as many\n                           as\
    \ permitted given the window parameter or\n                           simply has\
    \ no more data to send during the\n                           current heartbeat.\
    \ This is not client\n                           information but rather a hint\
    \ to be used by\n                           transport providers to synchronize\
    \ the\n                           computation and transmission of naks.\n    \
    \          eom(2)       Data[eom] marks the end of the message to the\n      \
    \                     consumers, and the surrendering of the\n               \
    \            transmit token to the master. And like a\n                      \
    \     data[eow] a data[eom] packet implies the end\n                         \
    \  of window.\n   nak(1)     request(0)   A nak[request] packet is a consumer\n\
    \                           requesting a retransmission of one or more\n     \
    \                      data packets. The data field contains an\n            \
    \               ordered list of packet sequence numbers that\n               \
    \            are being requested. Naks of any form are\n                     \
    \      always unicast.\n              deny(1)      A nak[deny] message indicates\
    \ that the\n                           producer source of the nak[deny]) cannot\n\
    \                           retransmit one or more of the packets\n          \
    \                 requested. The process receiving the\n                     \
    \      nak[deny] must report the failure to its\n                           client.\n\
    \   empty(2)   dally(0)     An empty[dally] packet is multicast to\n         \
    \                  maintain synchronization when no client data\n            \
    \               is available.\n              cancel(1)    If a producer finds\
    \ itself in possession of a\n                           transmit token and has\
    \ no data to send, it\n                           may cancel the token[request]\
    \ by multicasting\n                           an empty[cancel] message.\n    \
    \          hibernate(2) If the master possesses all of the web's\n           \
    \                transmit tokens and all outstanding messages\n              \
    \             have been accepted or rejected, the master\n                   \
    \        may transmit empty[hibernate] packets at a\n                        \
    \   rate significantly slower than indicated by\n                           the\
    \ web's value of heartbeat.\n   join(3)    request(0)   A join[request] packet\
    \ is sent by a process\n                           wishing to join a web to the\
    \ web's unknown\n                           TSAP (see section 2.2.5).\n      \
    \        confirm(1)   The join[confirm] packet is the master's\n             \
    \              confirmation of the destination's request to\n                \
    \           join the web. It will be unicast by the\n                        \
    \   master (and only the master) to the station\n                           that\
    \ sent the join[request].\n              deny(2)      A join[deny] packet indicates\
    \ permission to\n                           join the web was denied. It may only\
    \ be\n                           transmitted by the master and will be unicast\n\
    \                           to the member that sent the join[request].\n   quit(4)\
    \    request(0)   A quit[request] may be unicast to the master\n             \
    \              by any member of the web at any time to\n                     \
    \      indicate the sending process wishes to\n                           withdraw\
    \ from the web. Any member may unicast\n                           a quit to another\
    \ member requesting that the\n                           destination member quit\
    \ the web due to\n                           intolerable behavior.  The master\
    \ may\n                           multicast a quit[request] requiring that the\n\
    \                           entire web disband. The request will be\n        \
    \                   multicast at regular heartbeat intervals\n               \
    \            until there are no responses to retention\n                     \
    \      requests.\n              confirm(1)   The quit[confirm] packet is the indication\n\
    \                           that a quit[request] has been observed and\n     \
    \                      appropriate local action has been taken.\n            \
    \               Quit[confirm] are always unicast.\n   token(5)   request(0)  \
    \ A token[request] is a producing member\n                           requesting\
    \ a transmit token from the master.\n                           Such packets are\
    \ unicast to the master.\n              confirm(1)   The token[confirm] packet\
    \ is sent by the\n                           master to assign the transmit token\
    \ to a\n                           member that has requested it. token[confirm]\n\
    \                           will be unicast to the member being granted\n    \
    \                       the token.\n   isMember(6) request(0)  An isMember[request]\
    \ is soliciting\n                           verification that the target member\
    \ is a\n                           recognized member of the web. All forms of\n\
    \                           the isMember packet are unicast to a specific\n  \
    \                         member.\n              confirm(1)   IsMember[confirm]\
    \ packets are positive\n                           responses to isMember[requests].\n\
    \              deny(2)      If the member receiving the isMember[request]\n  \
    \                         cannot confirm the target's membership in the\n    \
    \                       web, it responds with a isMember[deny].\n"
- title: 2.2.3.  Subchannel
  contents:
  - "2.2.3.  Subchannel\n   The fourth byte of the transport header contains the client's\n\
    \   subchannel value. The default value of the subchannel field is zero.\n   Semantics\
    \ of the subchannel value are defined by the transport client\n   and therefore\
    \ are only applicable to packets of type data. All other\n   packet types must\
    \ have a subchannel value of zero.\n"
- title: 2.2.4.  Source connection identifier
  contents:
  - "2.2.4.  Source connection identifier\n   The source connection identifier field\
    \ is a 32 bit field containing a\n   transmitting system unique value assigned\
    \ at the time the transport\n   is created. The field is used in identifying the\
    \ particular transport\n   instantiation and is a component of the TSAP. Every\
    \ packet\n   transmitted by the transport must have this field set.\n"
- title: 2.2.5.  Destination connection identifier
  contents:
  - "2.2.5.  Destination connection identifier\n   The destination connection identifier\
    \ is the 32 bit identifier of the\n   target transport. From the point of view\
    \ of a process sending a\n   packet, there are three types of destination connection\
    \ identifiers.\n   First, there is the unknown connection identifier (0x00000000).\
    \ The\n   unknown value is used only as the destination connection identifier\n\
    \   in the join[request] packet.\n   Second, there is the multicast connection\
    \ identifier gleaned from the\n   join[confirm] message sent by the master. The\
    \ multicast connection\n   identifier is used in conjunction with the multicast\
    \ NSAP to form the\n   destination TSAP of all packets multicast to the entire\
    \ web [2].\n   The last class of connection identifier is a unicast identifier\
    \ and\n   is used to form the destination TSAP when unicasting packets to\n  \
    \ individual members. Every member of the web has associated with it a\n   unicast\
    \ connection identifier that is used to form its own unicast\n   TSAP.\n"
- title: 2.2.6.  Message acceptance
  contents:
  - "2.2.6.  Message acceptance\n   MTP ensures that all processes agree on which\
    \ messages are accepted\n   and in what order they are accepted. The master controls\
    \ this aspect\n   of the protocol by controlling allocation of transmit tokens\
    \ and\n   setting the status of messages. Once a token for a message has been\n\
    \   assigned (see section 3.2.1) the master sets the status of that\n   message\
    \ according to the following rules [AFM91]:\n    If the master has seen the entire\
    \ message (i.e., has seen the\n    data[eom] and all intervening data packets),\
    \ the status is accepted.\n    If the master has not seen the entire message but\
    \ believes the\n    message sender is still operational and connected to the master\
    \ (as\n    determined by the master), the status is pending.\n    If the master\
    \ has not seen the entire message and believes the\n    sender to have failed\
    \ or partitioned away, the status is rejected.\n   Message status is carried in\
    \ the message acceptance record (see\n   Figure 2) of every packet, and processes\
    \ learn the status of earlier\n   messages by processing this information.\n \
    \  The acceptance criteria is a multiple part record that carries the\n   rules\
    \ of agreement to determine the message acceptance. The most\n   significant 8\
    \ bits is a flag that, if not zero, indicates\n   synchronization is required.\
    \  The field may vary on a per message\n   basis as directed by producing transport's\
    \ client. The default is\n   that no synchronization is required.\n   The second\
    \ part of the record is a 12 element vector that represents\n   the status of\
    \ the last 12 messages transmitted into the web.\n       0          7 8      \
    \    15 16          23 24         31\n      ---------------------------------------------------------\n\
    \      |            |                                          |\n      |  synchro\
    \   |         tri-state bitmask[12]            |\n      ---------------------------------------------------------\n\
    \      |      message             |      packet sequence       |\n      |    \
    \  sequence number     |      number                |\n      ---------------------------------------------------------\n\
    \                     Figure 2. Message acceptance record\n   Each element of\
    \ the array is two bits in length and may have one of\n   three values: accepted(0),\
    \ pending(1) or rejected(2). Initially, the\n   bit mask is set to all zeros.\
    \ When the token for message m is\n   transmitted, the first (left-most) element\
    \ of the vector represents\n   the the state of message m - 1, the second element\
    \ of the vector is\n   the status of message m - 2, and so forth. Therefore the\
    \ status of\n   the last 12 messages are visible, the status of older messages\
    \ are\n   lost, logically by shifting the elements out of the vector. Only the\n\
    \   master is permitted to set the status of messages. The master is not\n   permitted\
    \ to shift a status of pending beyond the end of the vector.\n   If that situation\
    \ arises, the master must instead not confirm any\n   token[request] until the\
    \ oldest message can be marked as either\n   rejected or accepted.\n   Message\
    \ sequence numbers are 16 bit unsigned values. The field is\n   initialized to\
    \ zero by the master when the transport is initialized,\n   and incremented by\
    \ one after each token is granted. Only the master\n   is permitted to change\
    \ the value of the message sequence number. Once\n   granted, that message sequence\
    \ number is consumed and the state of\n   the message must eventually become either\
    \ accepted or rejected. No\n   transmit tokens may be granted if the assignment\
    \ of a message\n   sequence number that would cause a value of pending to be shifted\n\
    \   beyond the end of the status vector.\n   Packet sequence numbers are unsigned\
    \ 16 bit numbers assigned by the\n   producing process on a per message basis.\
    \ Packet sequence numbers\n   start at a value of zero for each new message and\
    \ are incremented by\n   one (consumed) for each data packet making up the message.\
    \ Consumers\n   detecting missing packet sequence numbers must send a nak[request]\
    \ to\n   the appropriate producer to recover the missed data.\n   Control packets\
    \ always contain the message acceptance criteria with a\n   synchronization flag\
    \ set to zero (0x00), the highest message sequence\n   number observed and a packet\
    \ sequence number one greater than\n   previously observed. Control packets do\
    \ not consume any sequence\n   numbers.  Since control messages are not reliably\
    \ delivered, the\n   acceptance criteria should only be checked to see if they\
    \ fall within\n   the proper range of message numbers, relative to the current\
    \ message\n   number of the receiving station.  The range of acceptable sequence\n\
    \   numbers should be m-11 to m-13, inclusive, where m is the current\n   message\
    \ number.\n"
- title: 2.2.7.  Heartbeat
  contents:
  - "2.2.7.  Heartbeat\n   Heartbeat is an unsigned 32 bit field that has the units\
    \ of\n   milliseconds. The value of heartbeat is shared by all members of the\n\
    \   web. By definition at least one packet (either data, empty or quit\n   from\
    \ the master) will be multicast into the web within every\n   heartbeat period.\n"
- title: 2.2.8.  Window
  contents:
  - "2.2.8.  Window\n   The allocation window (or simply window) is a 16 bit unsigned\
    \ field\n   that indicates the maximum number of data packets that can be\n  \
    \ multicasted by a member in a single heartbeat. It is the sum of the\n   retransmitted\
    \ and new data packets.\n"
- title: 2.2.9.  Retention
  contents:
  - "2.2.9.  Retention\n   The retention field is a 16 bit unsigned value that is\
    \ the number of\n   heartbeats for which a producer must retain transmitted client\
    \ data\n   and state for the purpose of retransmission.\n"
- title: 2.3     Transport addresses
  contents:
  - "2.3     Transport addresses\n   Associated with each transport are logically\
    \ three transport service\n   access points (TSAP), logically formed by the concatenation\
    \ of a\n   network service access point (NSAP) and a transport connection\n  \
    \ identifier. These TSAPs are the unknown TSAP, the web's multicast\n   TSAP and\
    \ each individual member's TSAP.\n"
- title: 2.3.1.  Unknown transport address
  contents:
  - "2.3.1.  Unknown transport address\n   Stations that are just joining must use\
    \ the multicast NSAP associated\n   with the transport, but are not yet aware\
    \ of either the web's\n   multicast TSAP the master process' TSAP. Therefore,\
    \ joining stations\n   fabricate a temporary TSAP (referred to as a unknown TSAP)\
    \ by using a\n   connection identifier reserved to mean unknown (0x00000000).\
    \ The\n   join[confirm] message will be sourced from the master's TSAP and will\n\
    \   include the multicast transport connection identifier in the data\n   field.\
    \ Those values must be extracted from the join[confirm] and\n   remembered by\
    \ the joining process.\n"
- title: 2.3.2.  Web's multicast address
  contents:
  - "2.3.2.  Web's multicast address\n   The multicast TSAP is formed by logically\
    \ concatenating the multicast\n   NSAP associated with the transport creation\
    \ and the transport\n   connection identifier returned in the data field of the\
    \ join[confirm]\n   packet. If more than one network is involved in the web, then\
    \ the\n   multicast transport address becomes a list, one for each network\n \
    \  represented.  This list is supplied in the data field of\n   token[confirm]\
    \ packets.\n   The multicast TSAP is used as the target for all messages that\
    \ are\n   destined to the entire web, such as data and empty. The master's\n \
    \  decision to abandon the transport (quit) is also sent to the\n   multicast\
    \ transport address.\n"
- title: 2.3.3.  Member addresses
  contents:
  - "2.3.3.  Member addresses\n   The member TSAP is formed by using the process'\
    \ unicast NSAP\n   concatenated with a locally generated unique connection identifier.\n\
    \   That TSAP must be the source of every packet transmitted by the\n   process,\
    \ regardless of its destination, for the lifetime of the\n   transport.\n   Packets\
    \ unicast to specific members must contain the appropriate\n   TSAP.  For producers\
    \ and consumers this is not difficult. The only\n   TSAPs of interest are the\
    \ master and the station(s) currently\n   transmitting data.\n"
- title: 3.      Protocol behavior
  contents:
  - "3.      Protocol behavior\n   This section defines the expectations of the protocol\
    \ implementation.\n   These expectations should not be considered guidelines or\
    \ hints, but\n   rather part the protocol.\n"
- title: 3.1     Establishing a transport
  contents:
  - "3.1     Establishing a transport\n   Before any rendezvous can be affected, a\
    \ process must first acquire\n   an NSAP that will be the service access point\
    \ for the instantiation\n   [3].  The process that first establishes at that NSAP\
    \ is referred to\n   as the master of the web. The decision as to what process\
    \ acts as the\n   master must be made a priori in order to guarantee unambiguous\n\
    \   creation in the face of network partitions. The process should make a\n  \
    \ robust effort to verify that the NSAP being used is not already in\n   service.\
    \ It may do so by repeatedly sending join[requests] to the\n   web's unknown TSAP.\
    \ If there is no response to repeated transmissions\n   the process may be relatively\
    \ confident that the NSAP is not in use\n   and proceed with the creation of the\
    \ web. If not, the creation must\n   be aborted and the situation reported to\
    \ its client.\n"
- title: 3.1.1.  Join request
  contents:
  - "3.1.1.  Join request\n   Additional members may join the web at any time after\
    \ the\n   establishment of the master by the joining process sending a\n   join[request]\
    \ to the unknown TSAP. The joining process should have\n   already assigned a\
    \ unique connection identifier to its transport\n   instantiation that will be\
    \ used in the source TSAP of the\n   join[request]. The join[request] must contain\
    \ zeros in all of the\n   acceptance fields. The heartbeat, window and retention\
    \ parameters are\n   filled in as requested by the transport provider's client.\
    \ The data\n   of the message must contain the type, class and quality of service\n\
    \   parameters that the client has requested.\n   field               class  \
    \     definition\n   membership class    master(0)   There can be only a single\
    \ web\n                                   master, and that member has all\n  \
    \                                 privileges of a producer class member\n    \
    \                               plus those acquitted only to the\n           \
    \                        master.\n                       producer(1) A process\
    \ that has producer class\n                                   membership wishes\
    \ to transmit data\n                                   into the web as well as\
    \ consume.\n                       consumer(2) A consumer process is a read only\n\
    \                                   process. It will send naks in order\n    \
    \                               to reliably receive data but will\n          \
    \                         never ask for or be permitted to take\n            \
    \                       possession of a transmit token.\n   transport class  \
    \   reliable(0) Specifies a reliable transport, i.e.,\n                      \
    \             one that will generate and process\n                           \
    \        naks.  The implication is that the\n                                \
    \   data will be reliably delivered or\n                                   the\
    \ failure will be detected and\n                                   reported to\
    \ the client.\n                       unreliable(1)   The transport supports best\n\
    \                                   effort delivery. Such a transport may\n  \
    \                                 still fail if the error rates are too\n    \
    \                               high, but tolerable loss or\n                \
    \                   corruption of data will be permitted\n                   \
    \                [4].\n   transport type      NxN(0)      The transport will accept\
    \ multiple\n                                   processes with producing capability.\n\
    \                       1xN(1)      A 1xN transport permits only a single\n  \
    \                                 producer whose identity was\n              \
    \                     established a priori.\n   The client's desire for minimum\
    \ throughput (expressed in kilobytes\n   per second) is the lowest value that\
    \ will be accepted. That\n   throughput is calculated using the heartbeat and\
    \ window parameters of\n   the transport, and the maximum data unit size, not\
    \ by measuring\n   actual traffic. Any member that suggests a combination of those\n\
    \   parameters that result in an unacceptable throughput will be ignored\n   or\
    \ asked to withdraw from the web.\n   A joining client may also suggest a maximum\
    \ data unit size. This\n   field is expressed as a number of bytes that can be\
    \ included in a\n   data packet as client data.\n   If no response is received\
    \ in a single heartbeat, the join[request]\n   should be retransmitted using the\
    \ same source TSAP so the master can\n   detect the difference between a new process\
    \ and a retransmission of a\n   join[request].\n"
- title: 3.1.2.  Join confirm/deny
  contents:
  - "3.1.2.  Join confirm/deny\n   Only the master of the web will respond to join[request].\
    \ The\n   response may either permit the entry of the new process or deny it.\n\
    \   The request to join may be denied because the new member is\n   specifying\
    \ service parameters that are in conflict with those\n   established by the master.\
    \  If the join is confirmed the\n   join[confirm] will be unicast by the master\
    \ with a data field that\n   contains the web's current operating parameters.\
    \ If those parameters\n   are unacceptable to the joining process it may decide\
    \ to withdraw\n   from the web. Otherwise the parameters must be accepted as the\n\
    \   current operating values.\n    0           7 8           15 16         23\
    \ 24         31\n   ----------------------------------------------------------\
    \    -----\n   |  protocol    |    packet   |    type     |    client   |    \
    \  |\n   |  version     |    type     |    modifier |    channel  |      |\n \
    \  ----------------------------------------------------------      |\n   |   \
    \                                                     |      |\n   |         \
    \     source connection identifier              |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              destination connection identifier         |\n   ----------------------------------------------------------\
    \ transport\n   |                                                        |   \
    \ header\n   |              message acceptance criteria               |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              heartbeat                                 |      |\n   ----------------------------------------------------------\
    \      |\n   |                            |                           |      |\n\
    \   |        window              |        retention          |      |\n   ----------------------------------------------------------\
    \    -----\n   |  member     |   transport  |  transport  |             |    \
    \  |\n   |  class      |   class      |  type       |  reserved   |      |\n \
    \  ----------------------------------------------------------\n   |        minimum\
    \             |     maximum data          |    data\n   |        throughput  \
    \        |     unit size             |\n   ----------------------------------------------------------\
    \      |\n   |                  multicast connection                  |      |\n\
    \   |                  identifier                            |      |\n   ----------------------------------------------------------\
    \    -----\n                           Figure 3. join packet\n   The join[confirm]\
    \ will also contain the multicast connection\n   identifier.  This must be used\
    \ to form the TSAP that will be the\n   destination for all multicast messages\
    \ for the transport. The source\n   of the join[confirm] message will be the master's\
    \ TSAP and must be\n   recorded by the member for later use.\n   The master must\
    \ be in possession of all the transmit tokens when it\n   sends a join[confirm].\
    \ Requiring the master to have the transmit\n   tokens insures that the joining\
    \ member will enter the web and observe\n   only complete messages. It also permits\
    \ a notification of the\n   master's client of the join so that application state\
    \ may be\n   automatically sent to the newly joining member. The newly joined\n\
    \   member may be on a network not previously represented in the web's\n   membership,\
    \ thus requiring a new multicast TSAP be added to the\n   existing list. The entire\
    \ list will be conveyed in the data field of\n   all subsequent token[confirm]\
    \ messages (described later).\n"
- title: 3.2     Maintaining data consistency
  contents:
  - "3.2     Maintaining data consistency\n   The transport is responsible for maintaining\
    \ the consistency of the\n   data submitted for delivery by producing clients.\
    \ The actual client\n   data, while representing the bulk of the information that\
    \ flows\n   through the web, is accompanied by significant amounts of protocol\n\
    \   state information. In addition to the state information piggybacked\n   with\
    \ the client data, there is a minimum amount of protocol packets\n   that are\
    \ purely for use by the transport, invisible to the transport\n   client.\n"
- title: 3.2.1.  Transmit tokens
  contents:
  - "3.2.1.  Transmit tokens\n   Before any process may transmit client data or state\
    \ it must first\n   possess a transmit token. It may acquire the token by transmitting\
    \ a\n   token[request] to the master. Requests should be unicast to the\n   master's\
    \ TSAP and should be retransmitted at intervals approximately\n   equal to the\
    \ heartbeat. Since it is the central source for a transmit\n   token, the master\
    \ may apply some fairness algorithms to the passing\n   of permission to transmit.\
    \ At a minimum the requests should be queued\n   in a first in, first out order.\
    \ Duplicate requests from a single\n   member should be ignored, keeping instead\
    \ the first unhonored\n   request. When appropriate, the master will send a member\
    \ with a\n   request pending a token[confirm].  The data field of the response\n\
    \   contains all the multicast TSAPs that are represented in the current\n   web\
    \ at that point in time.\n   If the master detects no data or heartbeat messages\
    \ being transmitted\n   into the web it will assume the token is lost, presumably\
    \ because the\n   member holding the token has failed or has become partitioned\
    \ away\n   from the master. In such cases, the master may attempt to confirm the\n\
    \   state of the process (perhaps by sending isMember[request]). If the\n   member\
    \ does not respond it is removed from the active members of the\n   web, the message\
    \ is marked as rejected, the token is assumed by the\n   master.\n   Figure 4\
    \ shows a timing diagram of a token pass. Increasing time is\n   towards the bottom\
    \ of the figure. In this figure, process A has a\n   token, and process B requests\
    \ a token when there are no free tokens.\n                           A    master\
    \    B\n    \"A\" multicasts data    |             |  \"B\" requests\n       \
    \                    |\\     |      |  transmit token\n                      \
    \     | \\    |     /|\n                           |  \\   |    / |\n        \
    \                   |   \\  |   /  |\n    \"A\" multicasts data    |    \\ | \
    \ /   |  \"B\" retransmits\n    w/eom set              |\\    \\| /    |  token\
    \ request\n                           | \\    \\V    /|\n                    \
    \       |  \\   |\\   / |\n                           |   \\  | V /  |\n     \
    \                      |    \\ |  /   |\n                           |     \\|\
    \ /    |\n                           |      \\V     |\n                      \
    \     |      |\\     |\n                           |      | V    |\n         \
    \                  |      |\\     |  Master assigns\n                        \
    \   |      | \\    |  token to \"B\"\n                           |      |  \\\
    \   |\n                           |      |   \\  |\n                         \
    \  |      |    \\ |\n                           |      |     V|\n            \
    \               |      |      |\n                           |      |     /|  \"\
    B\" multicasts\n                           |      |    / |  data\n           \
    \                |      |   /  |\n                           |      |  /   |\n\
    \                           |      | /    |\n                           |    \
    \  |/     |\n                           |      /      |\n                    \
    \       |     /|      |\n                           |    V |      |\n        \
    \                   |      |      |\n                     Figure 4. Acquiring\
    \ the token\n   Token packets, like other control packets, do not consume sequence\n\
    \   numbers. Hence, the master must be able to use another mechanism to\n   determine\
    \ whether multiple token[request] from a single member are\n   actually requests\
    \ for a separate token, or are a retransmission of a\n   token[request].  To carry\
    \ out this obligation, the master and the\n   members must have an implicit understanding\
    \ of each other's state.\n    0           7 8           15 16         23 24  \
    \       31\n   ----------------------------------------------------------    -----\n\
    \   |  protocol    |    packet   |    type     |    client   |      |\n   |  version\
    \     |    type     |    modifier |    channel  |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              source connection identifier              |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              destination connection identifier         |\n   ----------------------------------------------------------\
    \ transport\n   |                                                        |   \
    \ header\n   |              message acceptance criteria               |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              heartbeat                                 |      |\n   ----------------------------------------------------------\
    \      |\n   |                            |                           |      |\n\
    \   |        window              |        retention          |      |\n   ----------------------------------------------------------\
    \    -----\n   |                                                        |    \
    \  |\n   |                                                        |      |\n \
    \  |                   TSAPs of all networks                |\n   |          \
    \         represented in the web               |    data\n   |               \
    \    membership                           |\n   |                            \
    \                            |      |\n   |                                  \
    \                      |      |\n   ----------------------------------------------------------\
    \    -----\n                          Figure 5. token packet\n   Assume that the\
    \ token, as viewed by the master, has three states:\n   idle        The token\
    \ is not currently assigned. Specifically the\n               message number that\
    \ it defines is not represented in the\n               current message acceptance\
    \ vector.\n   pending     The token has been assigned by the master via a\n  \
    \             token[confirm] packet, but the master has not yet seen\n       \
    \        any data packets to indicate that the from the producing\n          \
    \     member received the notification.\n   busy        The token has been assigned\
    \ and the master has seen data\n               packets carrying the assigned message\
    \ number. The message\n               comprised by those packets is still represented\
    \ in the\n               message acceptance vector.\n   Furthermore, a token that\
    \ is not idle also has associated with its\n   state the TSAP of the process that\
    \ owns (or owned) the token.\n   Based on this state, the master will respond\
    \ to any process that has\n   a token in pending state with a reassignment of\
    \ that token. This is\n   based on the assumption that the original token[confirm]\
    \ was not\n   received by the requesting process. The only other possibility is\n\
    \   that the process did receive the token and transmitted data packets\n   using\
    \ that token, but the master did not see them. But data messages\n   are by design\
    \ multi-packet messages, padded with empty packets if\n   necessary. The possibility\
    \ of the master missing all of the packets\n   of a message is considered less\
    \ than the possibility of the\n   requesting process missing a single token[confirm]\
    \ packet.\n   The process requesting tokens must consider the actions of the master\n\
    \   and what prompted them. In most cases the assumptions made by the\n   master\
    \ will be correct. However, there are two ambiguous situations.\n   There is the\
    \ situation that the master is most directly addressing,\n   not knowing whether\
    \ the requesting process has failed to observe the\n   token[confirm] or the master\
    \ has failed to see data packets\n   transmitted by the producing process. There\
    \ is also the possibility\n   that the requesting process timed out too quickly\
    \ and the\n   retransmission of the token[request] passed the token[confirm] in\
    \ the\n   night. In any case the producing process may find itself in\n   possession\
    \ of a token for which it has no need. These can be\n   dismissed by sending an\
    \ empty[cancel] packet.\n   Another possibility is that the requesting process\
    \ has actually made\n   use of the assigned token and is requesting another token.\
    \ Unless the\n   master has observed data using the token, the master will still\n\
    \   consider the token pending. Therefore, a process that receives a\n   duplicate\
    \ token[confirm] should interpret it as a nak and retransmit\n   any data packets\
    \ previously sent using the token's message sequence\n   number.\n"
- title: 3.2.2.  Data transmission
  contents:
  - "3.2.2.  Data transmission\n   Data is provided by the transport client in the\
    \ form of uninterpreted\n   bytes. The bytes are encapsulated in packets immediately\
    \ following\n   the protocol's fixed overhead fields. The packet may have any\
    \ number\n   of data bytes between zero and the maximum number of bytes of a\n\
    \   network protocol packet minus the network overhead and the fixed\n   transport\
    \ overhead.  Every packet that consumes a sequence number\n   must contain either\
    \ client data or client state transitions such as\n   the end of message indicator\
    \ or a subchannel transition.\n   Packets are transmitted in bursts of packets\
    \ called windows. The\n   protocol guarantees that no more than the current value\
    \ of window\n   data packets will be transmitted by a single process during a\n\
    \   heartbeat.  Every packet transmitted always contains the latest\n   heartbeat,\
    \ window and retention information. If full packets are\n   unavailable [5], empty[dally]\
    \ messages should be transmitted instead.\n   The only packets that will be transmitted\
    \ containing less than\n   maximum capacity will be data[eom] or those containing\
    \ client\n   subchannel transitions.\n            -----     |      |\n       \
    \       |       |\\     |\n              |       | \\    |\n                 \
    \     |\\ \\   |\n          heartbeat   | \\ \\  |\n                      |\\\
    \ \\ \\ |\n              |       | \\ \\ V|  data(n)\n              |       |\
    \  \\ \\ |\n            -----     |   \\ V|  data(n+1)\n                     \
    \ |\\   \\ |\n                      | \\   V|  data(n+w-1) w/eow\n           \
    \           |\\ \\   |\n                      | \\ \\  |\n                   \
    \   |\\ \\ \\ |\n                      | \\ \\ V|  data(n+w)\n               \
    \       |  \\ \\ |\n            -----     |   \\ V|  data(n+w+1)\n           \
    \           |\\   \\ |\n                      | \\   V|  data(n+2w-1) w/eow\n\
    \   w = window = 3     |  \\   |\n   r = retention = 2  |   \\  |\n          \
    \            |    \\ |\n                      |     V|  empty(n+2w)\n        \
    \              |      |\n            -----     |      |\n                    \
    \  |\\     |\n                      | \\    |\n                      |  \\   |\n\
    \                      |   \\  |\n                      |    \\ |\n          \
    \            |     V|  data(n+2w) w/eom\n                      |      |    Packets\
    \ n..n+w-1 are released,\n            -----     |      |    token is surrendered.\n\
    \                      |      |\n                      |      |\n            \
    \          |      |\n                      |      |\n                      | \
    \     |\n                      |      |\n                      |      |\n    \
    \        -----     |      |    Packets n+w..n+2w-1 are released.\n           \
    \         Figure 6. Normal data transmission\n   Figure 6 shows a timing diagram\
    \ of a process transmitting into a web\n   (without any complicating naks). Increasing\
    \ time is towards the\n   bottom of the figure. The transmitting process is obligated\
    \ to\n   retransmit requested packets for at least retention heartbeat\n   intervals\
    \ after their first transmission.\n    0           7 8           15 16       \
    \  23 24         31\n   ----------------------------------------------------------\
    \    -----\n   |  protocol    |    packet   |    type     |    client   |    \
    \  |\n   |  version     |    type     |    modifier |    channel  |      |\n \
    \  ----------------------------------------------------------      |\n   |   \
    \                                                     |      |\n   |         \
    \     source connection identifier              |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              destination connection identifier         |\n   ----------------------------------------------------------\
    \ transport\n   |                                                        |   \
    \ header\n   |              message acceptance criteria               |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              heartbeat                                 |      |\n   ----------------------------------------------------------\
    \      |\n   |                            |                           |      |\n\
    \   |        window              |        retention          |      |\n   ----------------------------------------------------------\
    \    -----\n   |                                                        |    \
    \  |\n   |                   uninterpreted data                   |\n   |    \
    \                                                    |    data\n   |         \
    \                                               |\n   |                      \
    \                                  |      |\n   ----------------------------------------------------------\
    \    -----\n                           Figure 7. data packet\n"
- title: 3.2.3.  Empty packets
  contents:
  - "3.2.3.  Empty packets\n   An empty packet is a control packet multicast into\
    \ the web at regular\n   intervals by a producer possessing a transmit token when\
    \ no client\n   data is available. Empty packets are sent to maintain synchronization\n\
    \   and to advertise the maximum sequence number of the producer. It\n   provides\
    \ the opportunity for consuming processes to detect and\n   request retransmission\
    \ of missed data as well as identifying the\n   owner of a transmit token.\n \
    \   0           7 8           15 16         23 24         31\n   ----------------------------------------------------------\
    \    -----\n   |  protocol    |    packet   |    type     |    client   |    \
    \  |\n   |  version     |    type     |    modifier |    channel  |      |\n \
    \  ----------------------------------------------------------      |\n   |   \
    \                                                     |      |\n   |         \
    \     source connection identifier              |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              destination connection identifier         |\n   ----------------------------------------------------------\
    \ transport\n   |                                                        |   \
    \ header\n   |              message acceptance criteria               |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              heartbeat                                 |      |\n   ----------------------------------------------------------\
    \      |\n   |                            |                           |      |\n\
    \   |        window              |        retention          |      |\n   ----------------------------------------------------------\
    \    -----\n                          Figure 8. empty packet\n   There are two\
    \ situations where the empty[dally] packet is used. The\n   first is when there\
    \ is insufficient data for a full packet presented\n   by the client during a\
    \ heartbeat. Partial packets should not be\n   transmitted unless there is a client\
    \ transition to be conveyed, yet\n   something must be transmitted during a heartbeat\
    \ or the master may\n   think the process owning a transmit token has failed.\
    \ Empty[dally] is\n   used instead of a data packet until the client provides\
    \ additional\n   data to fill a packet or indicates a state transition such as\
    \ an end\n   of message or subchannel transition.\n   The second situation where\
    \ empty[dally] is used is after the\n   transmission of short messages. Each message\
    \ should consist of\n   multiple packets in order to enhance the possibility that\
    \ consumers\n   will observe at least one packet of a message and therefore be\
    \ able\n   to identify the producer. The transport parameter retention has\n \
    \  approximately the correct properties for that insurance. Therefore, a\n   message\
    \ must consist of at least retention packets. If the client\n   data does not\
    \ require that many packets, empty[dally] packets must be\n   appended. A process\
    \ that has no transmittable data and is in\n   possession of a transmit token\
    \ must send an empty[cancel].\n   Transmissions of empty[cancel] packets pass\
    \ the ownership of the\n   transmit token back to the master. When the master\
    \ observes the\n   control packet, it will mark the referenced to message as rejected\
    \ so\n   that other consumers do not believe the message lost and attempt to\n\
    \   recover.\n   During periods of no activity (i.e., after all messages have\
    \ been\n   either accepted or rejected and there are no outstanding transmit\n\
    \   tokens) the master may enter hibernation mode by transmitting\n   empty[hibernate]\
    \ packets. In that mode the master will increase the\n   value of the transport\
    \ parameter heartbeat in order to reduce network\n   traffic. Such packets are\
    \ used to indicate that the packet's\n   heartbeat field should not be used for\
    \ resource computation by those\n   processes that observe it.\n"
- title: 3.2.4.  Missed data
  contents:
  - "3.2.4.  Missed data\n   The most common method of detecting data loss will be\
    \ the reception\n   of a data or a heartbeat message that has a sequence number\
    \ greater\n   than expected from that producer. The second most common method\
    \ will\n   be a message fragment (missing the end of message) and seeing no more\n\
    \   data or empty packets from the producer of the fragment for more than\n  \
    \ a single heartbeat. In any case the consumer process directs a\n   negative\
    \ acknowledgment (nak) to the producer of the incomplete\n   message. The data\
    \ field of the nak message contains a list of\n   ascending sequence number pairs\
    \ the consumer needs to recover the\n   missed data.\n    0           7 8    \
    \       15 16         23 24         31\n   ----------------------------------------------------------\
    \    -----\n   |  protocol    |    packet   |    type     |    client   |    \
    \  |\n   |  version     |    type     |    modifier |    channel  |      |\n \
    \  ----------------------------------------------------------      |\n   |   \
    \                                                     |      |\n   |         \
    \     source connection identifier              |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              destination connection identifier         |\n   ----------------------------------------------------------\
    \ transport\n   |                                                        |   \
    \ header\n   |              message acceptance criteria               |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              heartbeat                                 |      |\n   ----------------------------------------------------------\
    \      |\n   |                            |                           |      |\n\
    \   |        window              |        retention          |      |\n   ----------------------------------------------------------\
    \    -----\n   |                            |                           |    \
    \  |\n   |  message sequence (low)    |  packet sequence (low)    |\n   ----------------------------------------------------------\
    \    data\n   |                            |                           |\n   |\
    \  message sequence (high)   |  packet sequence (high)   |      |\n   ----------------------------------------------------------\
    \    -----\n                           Figure 9. nak packet\n"
- title: 3.2.5.  Retrying operations
  contents:
  - "3.2.5.  Retrying operations\n   Operations must be retried in order to assure\
    \ that a single packet\n   loss does not cause transport failure. In general the\
    \ right numbers\n   to do that with exist in the transport. The proper interval\
    \ between\n   retries is the transport's time constant or heartbeat. The proper\n\
    \   number of retries is retention.\n   Operations that are retriable (and represented\
    \ by their respective\n   message types) are join, nak, token, isMember and quit.\
    \ Another\n   application for the heartbeat and retention is when transmitting\n\
    \   empty messages. Empty[dally] messages are transmitted any time data\n   is\
    \ not available but the data[eom] has not yet been sent. Any process\n   not observing\
    \ data or empty for more than retention heartbeat\n   intervals will assume to\
    \ have failed or partitioned away and the\n   transport will be abandoned.\n"
- title: 3.2.6.  Retransmission
  contents:
  - "3.2.6.  Retransmission\n   If the producer receives a nak[request] from a consumer\
    \ process\n   requesting the retransmission of a packet that is no longer\n  \
    \ available, the producer must send a nak[deny] to the source of the\n   request.\
    \ If that puts the consumer in a failed state, the consumer\n   will initiate\
    \ the withdrawal from the web. If a producer receives a\n   nak[request] from\
    \ a consumer requesting the retransmission of one or\n   more packets, those packets\
    \ will be multicast to the entire web [6].\n   All will contain the original client\
    \ information (such as subchannel\n   and end of message state) and message and\
    \ packet sequence number.\n   However, the retransmitted packets must contain\
    \ updated protocol\n   parameter information (heartbeat, window and retention).\n\
    \   Retransmitted packets are subject to the same constraints regarding\n   heartbeat\
    \ and window as original transmissions. Therefore the\n   producer's retransmissions\
    \ consume a portion of the allocation window\n   allowing less new data to be\
    \ transmitted in a single heartbeat.\n   Retransmitted packets have priority over\
    \ (i.e., should be transmitted\n   before) new data packets.\n            -----\
    \     |       |     retransmission count = rx=0\n              |       |\\   \
    \  |\n              |       | \\    |\n              |       |\\ \\   |\n    \
    \          |       | \\ \\  |\n              |       |\\ \\ \\ |\n           \
    \   |       | \\ \\ V|  data(n)\n              |       |  \\ \\ |\n          \
    \            |   \\ *|  data(n+1)\n          heartbeat   |    \\ |\n         \
    \             |     V|  data(n+w-1-rx) w/eow       rx=0\n              |     \
    \  |      |\n              |       |     /|  nak(n') of n+1\n              | \
    \      |    / |\n              |       |   /  |\n              |       |  /  \
    \ |\n              |       | /    |\n              |       |V     |\n        \
    \    -----     |      |\n                      |\\     |\n                   \
    \   | \\    |\n                      |\\ \\   |\n                      | \\ \\\
    \  |\n                      |\\ \\ \\ |\n   w = window = 3     | \\ \\ *|  retransmission(n+1)\
    \        rx=1\n   r = retention = 1  |  \\ \\ |\n                      |   \\\
    \ V|  data(n+w)\n                      |    \\ |\n                      |    \
    \ V|  data(n+2w-1-rx) w/eow      rx=1\n                      |      |\n      \
    \                |     /|  nak(n') of n+1\n                      |    / |\n  \
    \          -----     |   /  |\n                      |\\ /   |\n             \
    \         | /    |\n                      |V \\   |\n                      |\\\
    \  \\  |\n                      | \\  \\ |\n                      |\\ \\  V| \
    \ data(n+2w-rx)              rx=1\n                      | \\ \\  |    Packets\
    \ n..n+w-1-0 can be released.\n                      |  \\ \\ |\n            \
    \          |   \\ V|  nak deny(n+1)              rx=2\n                      |\
    \    \\ |\n                      |     V|  data(n+3w-1-rx) w/eom      rx=2\n \
    \                     |      |\n           -----      |      |    Packets n+w..n+2w-1-1\
    \ are released.\n                  Figure 10. naks and retransmission\n"
- title: 3.2.7.  Duplicate suppression
  contents:
  - "3.2.7.  Duplicate suppression\n   The consumer must be prepared to ignore duplicate\
    \ packets received.\n   They will invariably be the result of the producer's retransmission\n\
    \   in response to another consumer's nak.\n"
- title: 3.2.8.  Banishment
  contents:
  - "3.2.8.  Banishment\n   If at any time a process detects another in violation\
    \ of the protocol\n   it may ask the offending process to withdraw from the web\
    \ by\n   unicasting to it a quit[request] that has the target field set to the\n\
    \   value of the offender's TSAP. Any member that exhibits a detectable\n   and\
    \ recoverable protocol violation and still responds willingly to\n   the quit[request]\
    \ will be noted as having truly correct social\n   behavior.\n    0          \
    \ 7 8           15 16         23 24         31\n   ----------------------------------------------------------\
    \    -----\n   |  protocol    |    packet   |    type     |    client   |    \
    \  |\n   |  version     |    type     |    modifier |    channel  |      |\n \
    \  ----------------------------------------------------------      |\n   |   \
    \                                                     |      |\n   |         \
    \     source connection identifier              |      |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              destination connection identifier         |\n   ----------------------------------------------------------\
    \ transport\n   |                                                        |   \
    \ header\n   |              message acceptance criteria               |\n   ----------------------------------------------------------\
    \      |\n   |                                                        |      |\n\
    \   |              heartbeat                                 |      |\n   ----------------------------------------------------------\
    \      |\n   |                            |                           |      |\n\
    \   |        window              |        retention          |      |\n   ----------------------------------------------------------\
    \    -----\n   |                                                        |\n  \
    \ |              target TSAP                               |\n   |           \
    \                                             |\n   ----------------------------------------------------------\n\
    \                          Figure 11. quit packet\n"
- title: 3.3     Terminating the transport
  contents:
  - "3.3     Terminating the transport\n   Transport termination is an advisory process\
    \ that may be initiated by\n   any member of the web. No process should intentionally\
    \ quit the web\n   while it has retransmittable data buffered. Stations should\
    \ make\n   every reasonable attempt advise the master of their intentions to\n\
    \   withdraw, as their departure may collapse the topology of the web and\n  \
    \ eliminate the need to carry multicast messages across network\n   boundaries.\n"
- title: 3.3.1.  Voluntary quits
  contents:
  - "3.3.1.  Voluntary quits\n   Voluntary quit[requests] are unicast to the master's\
    \ TSAP. When the\n   master receives a quit from a member of the web, it responds\
    \ with a\n   quit[confirm] packet. At that time the member will be formally\n\
    \   removed from the web. The request should be retransmitted at\n   heartbeat\
    \ intervals until the confirmation is received from the\n   master or as many\
    \ times as the web's value of retention.\n"
- title: 3.3.2.  Master quit
  contents:
  - "3.3.2.  Master quit\n   If the master initiates the transport termination it\
    \ effects all\n   members of the web. The master will retain all transmit tokens\
    \ and\n   refuse to assign them. Once the tokens are acquired, the master will\n\
    \   multicast a quit[request] to the entire web. That request should be\n   acknowledged\
    \ by every active member. When the master receives no\n   confirmations for retention\
    \ transmissions, it may assume every member\n   has terminated its transport and\
    \ then may follow suit.\n"
- title: 3.3.3.  Banishment
  contents:
  - "3.3.3.  Banishment\n   If the master receives any message other than a join[request]\
    \ from a\n   member that it does not recognize, it should transmit a quit[request]\n\
    \   with that process as a target. This covers cases where the consumer\n   did\
    \ not see the termination reply and retransmitted its original quit\n   request,\
    \ as well as unannounced and rejected consumers.\n"
- title: 3.4     Transport parameters
  contents:
  - "3.4     Transport parameters\n   The following section provides guidelines and\
    \ rationale for selecting\n   reasonable transport quality of service parameters.\
    \ It also describes\n   some of the reasoning behind the ranges of values presented.\n"
- title: 3.4.1.  Quality of service
  contents:
  - "3.4.1.  Quality of service\n   Active members of the web may suggest changes\
    \ in the transport's\n   quality of service parameters during the lifetime of\
    \ the transport.\n   Producers in general adjust the transport's parameters to\
    \ encourage a\n   higher level of throughput. Since consumers are responsible\
    \ for\n   certifying reliable delivery, it is expected that they will provide\n\
    \   the force encouraging more reliability and stability. Both are trying\n  \
    \ to optimize the quality of service. The negotiation that took place\n   when\
    \ members joined the web included the clients' desires with\n   regards to the\
    \ worst case behavior that will be tolerated. If a\n   member cannot maintain\
    \ the negotiated lower bound, it may asked to\n   withdraw from the web. That\
    \ process will be sent a unicast message\n   (quit[request]) indicating that it\
    \ should retire. There are\n   essentially three parameters maintained by the\
    \ transport that reflect\n   the client's quality of service requirements: heartbeat,\
    \ window and\n   retention. These three parameters can be adapted by the transport\
    \ to\n   reflect the capability of the members, the type of application being\n\
    \   supported and the network topology. When members join the web, they\n   suggest\
    \ values for the quality of service parameters to the master.\n   If the parameters\
    \ are acceptable, the master will respond with the\n   web's current operating\
    \ values. During the lifetime of the web, it is\n   expected that the parameters\
    \ be modified by its members, though they\n   may never result in a quality of\
    \ service less than the lower bounds\n   established by the joining procedure.\
    \ Producers may try to improve\n   performance by reducing the heartbeat interval\
    \ and increasing the\n   window size. This will have the effect of increasing\
    \ the resources\n   committed to the transport at any time. In order to keep the\n\
    \   resources under control, the producer may also reduce the retention.\n   Consumers\
    \ must rely on their clients to consume the data occupying\n   the resources of\
    \ the transport. To do so the consumer transport\n   implementation must monitor\
    \ the level of committed resources to\n   insure that it does not exceed its capabilities.\
    \ Since MTP is a NAK\n   based protocol, the consumer is required to tell the\
    \ producer if a\n   change in parameters is required. The new information must\
    \ be\n   delivered to the producer(s) before the consumer's resource situation\n\
    \   becomes critical in order to avoid missing data.\n   For more stable operation,\
    \ consumers would try to extend the\n   heartbeat interval and reduce the window.\
    \ To a certain degree, they\n   could also attempt to reduce the value of retention\
    \ in order to\n   reduce the amount of resources required to support the transport.\n\
    \   However, that requires a more stringent real-time capability.\n"
- title: 3.4.2.  Selecting parameter values
  contents:
  - "3.4.2.  Selecting parameter values\n   The value of heartbeat is approximately\
    \ the transport time constant.\n   Assuming that the transport can be modelled\
    \ as a closed loop system\n   function, reaction to feedback into the transport\
    \ should settle out\n   in three time constants. In a transport that is constrained\
    \ to a\n   single network, the dominant cause of processing delay of the\n   transport\
    \ will most likely be page fault resolution time.\n   For example, using a one\
    \ MIP processor on a ethernet and an industry\n   standard disk, the worst case\
    \ page fault resolution requiring two\n   seeks (one to write out a dirty page,\
    \ another to swap in the new\n   page) and an average seek time of 40 milliseconds,\
    \ page fault\n   resolution should be less than 80 milliseconds. Allowing for\
    \ some\n   additional overhead and scheduling delays, two times the worst case\n\
    \   page fault resolution time would appear to be the minimum suitable\n   transport\
    \ time constant one could expect. So,\n           Heartbeat (minimum) = 160 -\
    \ 200 milliseconds.\n   The transmit time for a full (ethernet) packet is approximately\
    \ 1.2\n   milliseconds. Processing time should be less than 3 milliseconds\n \
    \  (ignoring possible overlapped processing). Assuming disk access (with\n   no\
    \ faulting) is equivalent, and the total time per packet is the sum\n   of the\
    \ parts, or 8.4 milliseconds. Therefore, the theoretical maximum\n   value would\
    \ be approximately 17 packets per heartbeat. The transport\n   should be capable\
    \ of approximately 120 packets per second, or 19.2\n   packets per heartbeat.\n\
    \           Window (maximum) = 17 - 20 packets per heartbeat.\n   The (theoretical)\
    \ throughput with these parameters in effect is 180\n   kilobytes per second.\n\
    \   Reducing retention may introduce instability because the consumers\n   will\
    \ have less opportunity to react to missing data. Data can be\n   missed for a\
    \ variety of reasons. If constrained to the local net the\n   data lost due to\
    \ data link corruption should be in the neighborhood\n   of one packet in every\
    \ 50,000 (bit error rate of approximately 10-9).\n   Telephony links (between\
    \ routers, for instance) exhibit similar\n   characteristics. Several orders of\
    \ magnitude more packets are lost at\n   receiving processes, including packet\
    \ switch routers, than over the\n   physical links. The losses are usually a result\
    \ of congestion and\n   resource starvation at lower layers due to the processing\
    \ of (nearly)\n   back to back packets. The incidental packet loss of this type\
    \ is\n   virtually unavoidable. One can only require that a receiving process\n\
    \   be capable of receiving some number of back to back packets\n   successfully,\
    \ and that number must be at least greater then the value\n   of window. And beyond\
    \ that the probability of success can be made as\n   close to unity as required\
    \ by providing the receiver the opportunity\n   to observe the data multiple times.\n\
    \   The receiving process must detect packet loss. The simplest method is\n  \
    \ to notice gaps in the received message/packet sequence numbers. Such\n   detection\
    \ should be done after receiving an end of window or other\n   state transition\
    \ indication. As such, the naks cannot be transmitted,\n   let alone received,\
    \ until the following heartbeat. In order to not\n   have any single packet loss\
    \ cause transport failure, the naks should\n   have the opportunity to be transmitted\
    \ at least twice.\n   When the loss is detected, the nak must be transmitted and\
    \ should be\n   received at the producing process in less than two heartbeats\
    \ after\n   the data it references was transmitted. Again, it is the detection\n\
    \   time that dominates, not the transmission of the nak.\n           Retention\
    \ (minimum) = 3.\n   The resources committed to a producing transport using the\
    \ above\n   assumptions are buffers sufficient for 80 packets of 1500 bytes each.\n\
    \   Each buffer will be committed for 600 - 800 milliseconds.\n   Transports that\
    \ span multiple networks have unique problems. One such\n   problem is that if\
    \ a router drops a packet, all the processes on the\n   remote network may attempt\
    \ to send a nak[request] at the same time.\n   That is not likely to enhance the\
    \ router's quality of service.\n   Furthermore, it is obvious that any one nak[request]\
    \ will suffice to\n   prompt the producer to retransmit the desired packet. To\
    \ reduce the\n   number of nak[requests] in this situation, the following scheme\
    \ might\n   be employed.\n   First, extend the value of retention to a minimum\
    \ value of N. Then\n   use a randomizing function that returns a value between\
    \ zero and N -\n   2, choose how many heartbeat intervals to dally before sending\
    \ the\n   nak[request], thus spreading out the transmissions over time. In\n \
    \  order for the method to be meaningful, the minimum value of retention\n   must\
    \ be adjusted.\n           Retention (minimum) = 5 (for internet cases)\n"
- title: 3.4.3.  Caching member information
  contents:
  - "3.4.3.  Caching member information\n   In order to reduce transport member interaction\
    \ and to enhance\n   performance, a certain amount of caching should be employed\
    \ by\n   producing members. These caches may be filled by gleaning information\n\
    \   from reliable sources such as multicast data or, when all else fails,\n  \
    \ from responses solicited from the web's master by use of the\n   isMember[request].\
    \ IsMember[request] requests are unicast to a member\n   that is believed to have\
    \ an accurate state of the web, at least to\n   the degree that it can answer\
    \ the question posed. The destination of\n   such a message is usually the master.\
    \ But in cases where a process\n   (such as the master) wants to verify that a\
    \ process believes itself\n   to be valid, it can assign the target TSAP and the\
    \ destination to be\n   the same. It is assumed that every process can verify\
    \ itself.\n   If the member receiving the isMember[request] can confirm the\n\
    \   target's active membership status in the web, it responds with a\n   unicast\
    \ isMember[confirm]. The data field contains the credibility\n   value of the\
    \ confirmation, that is the time (in milliseconds) since\n   the information was\
    \ confirmed from a reliable source.\n   Caches are risky as the information stored\
    \ in them can become stale.\n   Consequently, with only a few exceptions, the\
    \ entries should be aged,\n   and when sufficiently old, discarded. Ideally they\
    \ may be renewed by\n   the same gleanable sources alluded to in the previous\
    \ paragraph. If\n   not, they are simply discarded and refilled when needed.\n\
    \   Web membership may be gleaned from any packet that does not have a\n   value\
    \ of unknown as the destination connection identifier. A\n   producing transport\
    \ may extract the TSAP from such packets and either\n   create or refresh local\
    \ caches. Then, if in the process of\n   transmitting and NAK is received from\
    \ one of the members whose\n   identity is cached, no explicit request will be\
    \ needed to verify the\n   source's membership.\n   The explicit source of membership\
    \ information is the master.\n   Information can be requested by using the isMember\
    \ message.\n   Information gathered in that manner should be treated the same\
    \ as\n   gleaned information with respect to aging.\n   The aging is a function\
    \ of the transport's time constant, or\n   heartbeat, and the retention. Information\
    \ about a producing member\n   must be cached at least as long as that producer\
    \ has incomplete\n   messages. It may be cached longer. The namespace for both\
    \ sequence\n   numbers and connection identifiers is intentionally long to insure\n\
    \   that reuse of those namespaces will not likely collide.\n"
- title: 'A.      Appendix: MTP as an Internet Protocol transport'
  contents:
  - "A.      Appendix: MTP as an Internet Protocol transport\n   MTP is a transport\
    \ layer protocol, designed to be layered on top of a\n   number of different network\
    \ layer protocols.  Such a protocol must\n   provide certain facilities that MTP\
    \ expects.  In particular, the\n   underlying network level protocol must provide\
    \ \"ports\" or \"sockets\"\n   to facilitate addressing of processes within a\
    \ machine, and a\n   mechanism for multicast addressing of datagrams.  These two\n\
    \   addressing facilities are also used to formulate the NSAP for MTP on\n   IP.\n"
- title: A.1     Internet Protocol multicast addressing
  contents:
  - "A.1     Internet Protocol multicast addressing\n   MTP on Internet Protocol uses\
    \ the Internet Protocol multicast\n   mechanisms defined in RFC 1112, \"Host Extensions\
    \ for IP\n   Multicasting\".  MTP requires \"Level 2\" conformance described in\
    \ that\n   paper, for hosts which need to both send and receive multicast\n  \
    \ packets, both on the local net and on an internet. MTP on Internet\n   Protocol\
    \ uses the permanent host group address 224.0.1.9.\n"
- title: A.2     Encapsulation
  contents:
  - "A.2     Encapsulation\n   The Internet Protocol does not provide a port mechanism\
    \ - ports are\n   defined at the transport level instead.  In order to encapsulate\
    \ MTP\n   packet within Internet Protocol packets, a simple convergence or\n \
    \  \"bridge\" protocol must be defined to run on top of Internet Protocol,\n \
    \  which will provide MTP with the mechanism needed to deliver packets\n   to\
    \ the proper processes.  We will call this protocol the\n   \"MTP/Internet Protocol\
    \ Bridge Protocol\", or just \"Bridge\".  The\n   protocol header is encapsulated\
    \ the Internet Protocol data - the\n   protocol field of the Internet Protocol\
    \ packet carries the value\n   indicating this packet is an MTP packet (92 decimal).\
    \  The MTP packet\n   itself is encapsulated in the Bridge data. Figure A.1 shows\
    \ the\n   positions of the fields within the MTP packet while table A.1 defines\n\
    \   the contents of those fields.\n"
- title: A.3  Fields of the bridge protocol
  contents:
  - "A.3  Fields of the bridge protocol\n       0           7 8           15 16  \
    \       23 24         31\n      ----------------------------------------------------------\n\
    \      |                            |                           |\n      |   \
    \  destination port       |     source port           |\n      ----------------------------------------------------------\n\
    \      |                            |                           |\n      |   \
    \  length                 |     checksum              |\n      ----------------------------------------------------------\n\
    \      |                                                        |\n      |   \
    \                   client data                       |\n      ----------------------------------------------------------\n\
    \               Figure A.1 MTP bridge protocol header fields\n   destination port\
    \ The port to which the packet is destined or sinked.\n   source port The port\
    \ from which the packet originates or is sourced.\n   length      The length in\
    \ octets of the bridged packet, including\n               header and all data\
    \ (the MTP packet).  The minimum value\n               in this field is 8, the\
    \ maximum is 65535.  The length\n               does not include any padding bytes\
    \ that were used to\n               compute the checksum.  Note that though this\
    \ field allows\n               for very long packets, most networks have significantly\n\
    \               shorter maximum frame sizes - the allowable and optimal\n    \
    \           packet size must be determined by means beyond the scope\n       \
    \        of this specification.\n   checksum    The 16 bit one's compliment of\
    \ the one's compliment sum\n               of the entire bridge protocol header\
    \ and data, padded\n               with a zero octet (if necessary) to make multiple\
    \ 16 bit\n               quanities. A computed checksum of all zeros should be\n\
    \               changed to all ones.  The checksum field is optional -\n     \
    \          all zeros in the field indicate that checksums are not in\n       \
    \        use.\n   data        The data field is the field that carries the actual\n\
    \               transport data. A single MTP packet will be carried the\n    \
    \           data field of each bridge packet.\n"
- title: A.4     Relationship to other Internet Protocol Transports
  contents:
  - "A.4     Relationship to other Internet Protocol Transports\n   The astute reader\
    \ might note that the MTP/Bridge Protocol looks much\n   like the User Datagram\
    \ Protocol (UDP).  UDP itself was not used\n   because the protocol field in the\
    \ Internet Protocol packet should\n   reflect the fact that the higher level protocol\
    \ of interest is MTP.\n"
- title: References
  contents:
  - "References\n   AFM91   Armstrong, S., A. Freier and K. Marzullo, \"MTP: An Atomic\n\
    \           Multicast Transport Protocol\", Xerox Webster Research Center\n  \
    \         technical report X9100359, March 1991.\n   Bog83   Boggs, D., \"Internet\
    \ Broadcasting\", Xerox PARC technical\n           report CSL-83-3, October 1983.\n\
    \   BSTM79  Boggs, D., J. Shoch, E. Taft, and R. Metcalfe, \"Pup: An\n       \
    \    Internetwork Architecture\", IEEE Transactions on\n           Communications,\
    \ COM-28(4), pages 612-624. April 1980.\n   DIX82   Digital Equipment Corp., Intel\
    \ Corp., Xerox Corp., \"The\n           Ethernet, a Local Area Network: Data Link\
    \ and Physical Layer\n           Specifications\", September 1982.\n   CLZ87 \
    \  Clark, D., M. Lambert, and L. Zhang, \"NETBLT: A high\n           throughput\
    \ transport protocol\", In Proceedings of ACM SIGCOMM\n           '87 Workshop,\
    \ pages 353-359, 1987.\n   CM87    Chang J., and M. Maxemchuck. \"Atomic broadcast\"\
    ,  ACM\n           Transactions on Computer Systems, 2(3):251-273, August 1987.\n\
    \   Cri88   Cristian, F., \"Reaching agreement on processor group\n          \
    \ membership in synchronous distributed systems\",  In\n           Proceedings\
    \ of the 18th International Conference on Fault-\n           Tolerant Computing.\
    \ IEEE TOCS, 1988.\n   Dee89   Deering, S., \"Host Extensions for IP Multicasting\"\
    , RFC 1112,\n           Stanford University, August 1989.\n   Fre84   Freier,\
    \ A., \"Compatability and interoperability\", Open letter\n           to XNS Interest\
    \ Group, Xerox Systems Developement Division,\n           December 13, 1984.\n\
    \   JB89    Joseph T., and K. Birman, \"Reliable Broadcast Protocols\",\n    \
    \       pages 294-318, ACM Press, New York, 1989.\n   Pos81   Postel, J., \"Transmission\
    \ Control Protocol - DARPA Internet\n           Program Protocol Specification\"\
    , RFC 793, DARPA, September\n           1981.\n   Xer81   Xerox Corp., \"Internet\
    \ Transport Protocols\", Xerox System\n           Integration Standard 028112,\
    \ Stamford, Connecticut. December\n           1981.\n"
- title: Footnotes
  contents:
  - "Footnotes\n   [1] The network layer is not specified by MTP. One of the goals\
    \ is to\n   specify a transport that can be implemented with equal functionality\n\
    \   on many network architectures.\n   [2] There's only one such multicast connection\
    \ identifier per web. If\n   there are multiple processes on the same machine\
    \ participating in a\n   web, the transport must descriminate between those processes\
    \ by using\n   the connnection identifier.\n   [3] Determining the network service\
    \ access point (NSAP) for a given\n   instantiation of a web is not addressed\
    \ by this protocol. This\n   document may define some policy, but the actual means\
    \ are left for\n   other mechanisms.\n   [4] Best effort delivery is also known\
    \ as highly reliable delivery.\n   It is somewhat unique that the qualifying adjective\
    \ highly weakens\n   the definition of reliable in this context.\n   [5] The resource\
    \ being flow controlled is packets carrying client\n   data.  Consequently, full\
    \ data units provide the greatest efficiency.\n   [6] There seems to be an opportunity\
    \ to suppress retransmissions to\n   networks that were not represented in the\
    \ set of naks received.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Susan M. Armstrong\n   Xerox Webster Research Center\n\
    \   800 Phillips Rd. MS 128-27E\n   Webster, NY 14580\n   Phone: (716) 422-6437\n\
    \   EMail: armstrong@wrc.xerox.com\n   Alan O. Freier\n   Apple Computer, Inc.\n\
    \   20525 Mariani Ave. MS 3-PK\n   Cupertino, CA 95014\n   Phone: (408) 974-9196\n\
    \   EMail: freier@apple.com\n   Keith A. Marzullo\n   Cornell University\n   Department\
    \ of Computer Science\n   Upson Hall\n   Ithaca, NY 14853-7501\n   Phone: (607)\
    \ 255-9188\n   EMail: marzullo@cs.cornell.edu\n      Keith Marzullo is supported\
    \ in part by the Defense Advanced\n      Research Projects Agency (DoD) under\
    \ NASA Ames grant number NAG\n      2-593, Contract N00140-87-C-8904.  The views,\
    \ opinions and\n      findings contained in this report are those of the authors\
    \ and\n      should not be construed as an official Department of Defense\n  \
    \    position, policy, or decision.\n"
