- title: __initial_text__
  contents:
  - "                Resource ReSerVation Protocol (RSVP) --\n                   Version\
    \ 1 Functional Specification\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes version 1 of RSVP, a resource reservation setup\n\
    \   protocol designed for an integrated services Internet.  RSVP provides\n  \
    \ receiver-initiated setup of resource reservations for multicast or\n   unicast\
    \ data flows, with good scaling and robustness properties.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ...................................................\
    \ 4\n      1.1 Data Flows ................................................. 7\n\
    \      1.2 Reservation Model .......................................... 8\n  \
    \    1.3 Reservation Styles .........................................11\n    \
    \  1.4 Examples of Styles .........................................14\n   2. RSVP\
    \ Protocol Mechanisms .......................................19\n      2.1 RSVP\
    \ Messages ..............................................19\n      2.2 Merging\
    \ Flowspecs ..........................................21\n      2.3 Soft State\
    \ .................................................22\n      2.4 Teardown ...................................................24\n\
    \      2.5 Errors .....................................................25\n  \
    \    2.6 Confirmation ...............................................27\n    \
    \  2.7 Policy Control .............................................27\n      2.8\
    \ Security ...................................................28\n      2.9 Non-RSVP\
    \ Clouds ............................................29\n      2.10 Host Model\
    \ ................................................30\n   3. RSVP Functional Specification\
    \ ..................................32\n      3.1 RSVP Message Formats .......................................32\n\
    \      3.2 Port Usage .................................................47\n  \
    \    3.3 Sending RSVP Messages ......................................48\n    \
    \  3.4 Avoiding RSVP Message Loops ................................50\n      3.5\
    \ Blockade State .............................................54\n      3.6 Local\
    \ Repair ...............................................56\n      3.7 Time Parameters\
    \ ............................................57\n      3.8 Traffic Policing and\
    \ Non-Integrated Service Hops ...........58\n      3.9 Multihomed Hosts ...........................................59\n\
    \      3.10 Future Compatibility ......................................61\n  \
    \    3.11 RSVP Interfaces ...........................................63\n   4.\
    \ Acknowledgments ................................................76\n   APPENDIX\
    \ A. Object Definitions ....................................77\n   APPENDIX B.\
    \ Error Codes and Values ................................92\n   APPENDIX C. UDP\
    \ Encapsulation .....................................98\n   APPENDIX D. Glossary\
    \ .............................................102\n   REFERENCES .......................................................111\n\
    \   SECURITY CONSIDERATIONS ..........................................111\n  \
    \ AUTHORS' ADDRESSES ...............................................112\n   What's\
    \ Changed\n   This revision contains the following very minor changes from the\
    \ ID14\n   version.\n      o    For clarity, each message type is now defined\
    \ separately in\n           Section 3.1.\n      o    We added more precise and\
    \ complete rules for accepting Path\n           messages for unicast and multicast\
    \ destinations (Section\n           3.1.3).\n      o    We added more precise\
    \ and complete rules for processing and\n           forwarding PathTear messages\
    \ (Section 3.1.5).\n      o    A note was added that a SCOPE object will be ignored\
    \ if it\n           appears in a ResvTear message (Section 3.1.6).\n      o  \
    \  A note was added that a SENDER_TSPEC or ADSPEC object will be\n           ignored\
    \ if it appears in a PathTear message (Section 3.1.5).\n      o    The obsolete\
    \ error code Ambiguous Filter Spec (09) was\n           removed, and a new (and\
    \ more consistent) name was given to\n           error code 08 (Appendix B).\n\
    \      o    In the generic interface to traffic control, the Adspec was\n    \
    \       added as a parameter to the AddFlow and ModFlow calls\n           (3.11.2).\
    \  This is needed to accommodate a node that updates\n           the slack term\
    \ (S) of Guaranteed service.\n      o    An error subtype was added for an Adspec\
    \ error (Appendix B).\n      o    Additional explanation was added for handling\
    \ a CONFIRM\n           object (Section 3.1.4).\n      o    The rules for forwarding\
    \ objects with unknown class type were\n           clarified.\n      o    Additional\
    \ discussion was added to the Introduction and to\n           Section 3.11.2 about\
    \ the relationship of RSVP to the link\n           layer.  (Section 3.10).\n \
    \     o    Section 2.7 on Policy and Security was split into two\n           sections,\
    \ and some additional discussion of security was\n           included.\n     \
    \ o    There were some minor editorial improvements.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document defines RSVP, a resource reservation setup\
    \ protocol\n   designed for an integrated services Internet [RSVP93, RFC 1633].\
    \  The\n   RSVP protocol is used by a host to request specific qualities of\n\
    \   service from the network for particular application data streams or\n   flows.\
    \  RSVP is also used by routers to deliver quality-of-service\n   (QoS) requests\
    \ to all nodes along the path(s) of the flows and to\n   establish and maintain\
    \ state to provide the requested service.  RSVP\n   requests will generally result\
    \ in resources being reserved in each\n   node along the data path.\n   RSVP requests\
    \ resources for simplex flows, i.e., it requests\n   resources in only one direction.\
    \  Therefore, RSVP treats a sender as\n   logically distinct from a receiver,\
    \ although the same application\n   process may act as both a sender and a receiver\
    \ at the same time.\n   RSVP operates on top of IPv4 or IPv6, occupying the place\
    \ of a\n   transport protocol in the protocol stack.  However, RSVP does not\n\
    \   transport application data but is rather an Internet control\n   protocol,\
    \ like ICMP, IGMP, or routing protocols.  Like the\n   implementations of routing\
    \ and management protocols, an\n   implementation of RSVP will typically execute\
    \ in the background, not\n   in the data forwarding path, as shown in Figure 1.\n\
    \   RSVP is not itself a routing protocol; RSVP is designed to operate\n   with\
    \ current and future unicast and multicast routing protocols.  An\n   RSVP process\
    \ consults the local routing database(s) to obtain routes.\n   In the multicast\
    \ case, for example, a host sends IGMP messages to\n   join a multicast group\
    \ and then sends RSVP messages to reserve\n   resources along the delivery path(s)\
    \ of that group.  Routing\n   protocols determine where packets get forwarded;\
    \ RSVP is only\n   concerned with the QoS of those packets that are forwarded\
    \ in\n   accordance with routing.\n   In order to efficiently accommodate large\
    \ groups, dynamic group\n   membership, and heterogeneous receiver requirements,\
    \ RSVP makes\n   receivers responsible for requesting a specific QoS [RSVP93].\
    \  A QoS\n   request from a receiver host application is passed to the local RSVP\n\
    \   process.  The RSVP protocol then carries the request to all the nodes\n  \
    \ (routers and hosts) along the reverse data path(s) to the data\n   source(s),\
    \ but only as far as the router where the receiver's data\n   path joins the multicast\
    \ distribution tree.  As a result, RSVP's\n   reservation overhead is in general\
    \ logarithmic rather than linear in\n   the number of receivers.\n           \
    \   HOST                              ROUTER\n _____________________________ \
    \      ____________________________\n"
- title: '|  _______                    |     |                            |'
  contents:
  - '|  _______                    |     |                            |

    '
- title: '| |       |   _______         |     |            _______         |'
  contents:
  - '| |       |   _______         |     |            _______         |

    '
- title: '| |Appli- |  |       |        |RSVP |           |       |        |'
  contents:
  - '| |Appli- |  |       |        |RSVP |           |       |        |

    '
- title: '| | cation|  | RSVP <---------------------------> RSVP  <---------->'
  contents:
  - '| | cation|  | RSVP <---------------------------> RSVP  <---------->

    '
- title: '| |       <-->       |        |     | _______   |       |        |'
  contents:
  - '| |       <-->       |        |     | _______   |       |        |

    '
- title: '| |       |  |process|  _____ |     ||Routing|  |process|  _____ |'
  contents:
  - '| |       |  |process|  _____ |     ||Routing|  |process|  _____ |

    '
- title: '| |_._____|  |       -->Polcy||     ||       <-->       -->Polcy||'
  contents:
  - '| |_._____|  |       -->Polcy||     ||       <-->       -->Polcy||

    '
- title: '|   |        |__.__._| |Cntrl||     ||process|  |__.__._| |Cntrl||'
  contents:
  - '|   |        |__.__._| |Cntrl||     ||process|  |__.__._| |Cntrl||

    '
- title: '|   |data       |  |   |_____||     ||__.____|     |  |   |_____||'
  contents:
  - '|   |data       |  |   |_____||     ||__.____|     |  |   |_____||

    '
- title: '|===|===========|==|==========|     |===|==========|==|==========|'
  contents:
  - '|===|===========|==|==========|     |===|==========|==|==========|

    '
- title: '|   |   --------|  |    _____ |     |   |  --------|  |    _____ |'
  contents:
  - '|   |   --------|  |    _____ |     |   |  --------|  |    _____ |

    '
- title: '|   |  |        |  ---->Admis||     |   |  |       |  ---->Admis||'
  contents:
  - '|   |  |        |  ---->Admis||     |   |  |       |  ---->Admis||

    '
- title: '|  _V__V_    ___V____  |Cntrl||     |  _V__V_    __V_____ |Cntrl||'
  contents:
  - '|  _V__V_    ___V____  |Cntrl||     |  _V__V_    __V_____ |Cntrl||

    '
- title: '| |      |  |        | |_____||     | |      |  |        ||_____||'
  contents:
  - '| |      |  |        | |_____||     | |      |  |        ||_____||

    '
- title: '| |Class-|  | Packet |        |     | |Class-|  | Packet |       |'
  contents:
  - '| |Class-|  | Packet |        |     | |Class-|  | Packet |       |

    '
- title: '| | ifier|==>Schedulr|================> ifier|==>Schedulr|===========>'
  contents:
  - '| | ifier|==>Schedulr|================> ifier|==>Schedulr|===========>

    '
- title: '| |______|  |________|        |data | |______|  |________|       |data'
  contents:
  - '| |______|  |________|        |data | |______|  |________|       |data

    '
- title: '|                             |     |                            |'
  contents:
  - '|                             |     |                            |

    '
- title: '|_____________________________|     |____________________________|'
  contents:
  - "|_____________________________|     |____________________________|\n        \
    \          Figure 1: RSVP in Hosts and Routers\n   Quality of service is implemented\
    \ for a particular data flow by\n   mechanisms collectively called \"traffic control\"\
    .  These mechanisms\n   include (1) a packet classifier, (2) admission control,\
    \ and (3) a\n   \"packet scheduler\" or some other link-layer-dependent mechanism\
    \ to\n   determine when particular packets are forwarded.  The \"packet\n   classifier\"\
    \ determines the QoS class (and perhaps the route) for each\n   packet.  For each\
    \ outgoing interface, the \"packet scheduler\" or other\n   link-layer-dependent\
    \ mechanism achieves the promised QoS.  Traffic\n   control implements QoS service\
    \ models defined by the Integrated\n   Services Working Group.\n   During reservation\
    \ setup, an RSVP QoS request is passed to two local\n   decision modules, \"admission\
    \ control\" and \"policy control\".\n   Admission control determines whether the\
    \ node has sufficient\n   available resources to supply the requested QoS.  Policy\
    \ control\n   determines whether the user has administrative permission to make\
    \ the\n   reservation.  If both checks succeed, parameters are set in the\n  \
    \ packet classifier and in the link layer interface (e.g., in the\n   packet scheduler)\
    \ to obtain the desired QoS.  If either check fails,\n   the RSVP program returns\
    \ an error notification to the application\n   process that originated the request.\n\
    \   RSVP protocol mechanisms provide a general facility for creating and\n   maintaining\
    \ distributed reservation state across a mesh of multicast\n   or unicast delivery\
    \ paths.  RSVP itself transfers and manipulates QoS\n   and policy control parameters\
    \ as opaque data, passing them to the\n   appropriate traffic control and policy\
    \ control modules for\n   interpretation.  The structure and contents of the QoS\
    \ parameters are\n   documented in specifications developed by the Integrated\
    \ Services\n   Working Group; see [RFC 2210].  The structure and contents of the\n\
    \   policy parameters are under development.\n   Since the membership of a large\
    \ multicast group and the resulting\n   multicast tree topology are likely to\
    \ change with time, the RSVP\n   design assumes that state for RSVP and traffic\
    \ control state is to be\n   built and destroyed incrementally in routers and\
    \ hosts.  For this\n   purpose, RSVP establishes \"soft\" state; that is, RSVP\
    \ sends periodic\n   refresh messages to maintain the state along the reserved\
    \ path(s).\n   In the absence of refresh messages, the state automatically times\
    \ out\n   and is deleted.\n   In summary, RSVP has the following attributes:\n\
    \   o    RSVP makes resource reservations for both unicast and many-to-\n    \
    \    many multicast applications, adapting dynamically to changing\n        group\
    \ membership as well as to changing routes.\n   o    RSVP is simplex, i.e., it\
    \ makes reservations for unidirectional\n        data flows.\n   o    RSVP is\
    \ receiver-oriented, i.e., the receiver of a data flow\n        initiates and\
    \ maintains the resource reservation used for that\n        flow.\n   o    RSVP\
    \ maintains \"soft\" state in routers and hosts, providing\n        graceful support\
    \ for dynamic membership changes and automatic\n        adaptation to routing\
    \ changes.\n   o    RSVP is not a routing protocol but depends upon present and\n\
    \        future routing protocols.\n   o    RSVP transports and maintains traffic\
    \ control and policy control\n        parameters that are opaque to RSVP.\n  \
    \ o    RSVP provides several reservation models or \"styles\" (defined\n     \
    \   below) to fit a variety of applications.\n   o    RSVP provides transparent\
    \ operation through routers that do not\n        support it.\n   o    RSVP supports\
    \ both IPv4 and IPv6.\n   Further discussion on the objectives and general justification\
    \ for\n   RSVP design are presented in [RSVP93] and [RFC 1633].\n   The remainder\
    \ of this section describes the RSVP reservation\n   services.  Section 2 presents\
    \ an overview of the RSVP protocol\n   mechanisms.  Section 3 contains the functional\
    \ specification of RSVP,\n   while Section 4 presents explicit message processing\
    \ rules.  Appendix\n   A defines the variable-length typed data objects used in\
    \ the RSVP\n   protocol.  Appendix B defines error codes and values.  Appendix\
    \ C\n   defines a UDP encapsulation of RSVP messages, for hosts whose\n   operating\
    \ systems provide inadequate raw network I/O support.\n   1.1 Data Flows\n   \
    \   RSVP defines a \"session\" to be a data flow with a particular\n      destination\
    \ and transport-layer protocol.  RSVP treats each\n      session independently,\
    \ and this document often omits the implied\n      qualification \"for the same\
    \ session\".\n      An RSVP session is defined by the triple: (DestAddress, ProtocolId\n\
    \      [, DstPort]).  Here DestAddress, the IP destination address of the\n  \
    \    data packets, may be a unicast or multicast address.  ProtocolId\n      is\
    \ the IP protocol ID.  The optional DstPort parameter is a\n      \"generalized\
    \ destination port\", i.e., some further demultiplexing\n      point in the transport\
    \ or application protocol layer.  DstPort\n      could be defined by a UDP/TCP\
    \ destination port field, by an\n      equivalent field in another transport protocol,\
    \ or by some\n      application-specific information.\n      Although the RSVP\
    \ protocol is designed to be easily extensible for\n      greater generality,\
    \ the basic protocol documented here supports\n      only UDP/TCP ports as generalized\
    \ ports.  Note that it is not\n      strictly necessary to include DstPort in\
    \ the session definition\n      when DestAddress is multicast, since different\
    \ sessions can always\n      have different multicast addresses.  However, DstPort\
    \ is necessary\n      to allow more than one unicast session addressed to the\
    \ same\n      receiver host.\n      Figure 2 illustrates the flow of data packets\
    \ in a single RSVP\n      session, assuming multicast data distribution.  The\
    \ arrows\n      indicate data flowing from senders S1 and S2 to receivers R1,\
    \ R2,\n      and R3, and the cloud represents the distribution mesh created by\n\
    \      multicast routing.  Multicast distribution forwards a copy of each\n  \
    \    data packet from a sender Si to every receiver Rj; a unicast\n      distribution\
    \ session has a single receiver R.  Each sender Si may\n      be running in a\
    \ unique Internet host, or a single host may contain\n      multiple senders distinguished\
    \ by \"generalized source ports\".\n              Senders                    \
    \          Receivers\n                          _____________________\n      \
    \                   (                     ) ===> R1\n                 S1 ===>\
    \ (    Multicast        )\n                         (                     ) ===>\
    \ R2\n                         (    distribution     )\n                 S2 ===>\
    \ (                     )\n                         (    by Internet      ) ===>\
    \ R3\n                         (_____________________)\n                 Figure\
    \ 2: Multicast Distribution Session\n      For unicast transmission, there will\
    \ be a single destination host\n      but there may be multiple senders; RSVP\
    \ can set up reservations\n      for multipoint-to-single-point transmission.\n\
    \   1.2 Reservation Model\n      An elementary RSVP reservation request consists\
    \ of a \"flowspec\"\n      together with a \"filter spec\"; this pair is called\
    \ a \"flow\n      descriptor\".  The flowspec specifies a desired QoS.  The filter\n\
    \      spec, together with a session specification, defines the set of\n     \
    \ data packets -- the \"flow\" -- to receive the QoS defined by the\n      flowspec.\
    \  The flowspec is used to set parameters in the node's\n      packet scheduler\
    \ or other link layer mechanism, while the filter\n      spec is used to set parameters\
    \ in the packet classifier.  Data\n      packets that are addressed to a particular\
    \ session but do not\n      match any of the filter specs for that session are\
    \ handled as\n      best-effort traffic.\n      The flowspec in a reservation\
    \ request will generally include a\n      service class and two sets of numeric\
    \ parameters: (1) an \"Rspec\"\n      (R for `reserve') that defines the desired\
    \ QoS, and (2) a \"Tspec\"\n      (T for `traffic') that describes the data flow.\
    \  The formats and\n      contents of Tspecs and Rspecs are determined by the\
    \ integrated\n      service models [RFC 2210] and are generally opaque to RSVP.\n\
    \      The exact format of a filter spec depends upon whether IPv4 or\n      IPv6\
    \ is in use; see Appendix A.  In the most general approach\n      [RSVP93], filter\
    \ specs may select arbitrary subsets of the packets\n      in a given session.\
    \  Such subsets might be defined in terms of\n      senders (i.e., sender IP address\
    \ and generalized source port), in\n      terms of a higher-level protocol, or\
    \ generally in terms of any\n      fields in any protocol headers in the packet.\
    \  For example, filter\n      specs might be used to select different subflows\
    \ of a\n      hierarchically-encoded video stream by selecting on fields in an\n\
    \      application-layer header.  In the interest of simplicity (and to\n    \
    \  minimize layer violation), the basic filter spec format defined in\n      the\
    \ present RSVP specification has a very restricted form: sender\n      IP address\
    \ and optionally the UDP/TCP port number SrcPort.\n      Because the UDP/TCP port\
    \ numbers are used for packet\n      classification, each router must be able\
    \ to examine these fields.\n      This raises three potential problems.\n    \
    \  1.   It is necessary to avoid IP fragmentation of a data flow for\n       \
    \    which a resource reservation is desired.\n           Document [RFC 2210]\
    \ specifies a procedure for applications\n           using RSVP facilities to\
    \ compute the minimum MTU over a\n           multicast tree and return the result\
    \ to the senders.\n      2.   IPv6 inserts a variable number of variable-length\
    \ Internet-\n           layer headers before the transport header, increasing\
    \ the\n           difficulty and cost of packet classification for QoS.\n    \
    \       Efficient classification of IPv6 data packets could be\n           obtained\
    \ using the Flow Label field of the IPv6 header.  The\n           details will\
    \ be provided in the future.\n      3.   IP-level Security, under either IPv4\
    \ or IPv6, may encrypt the\n           entire transport header, hiding the port\
    \ numbers of data\n           packets from intermediate routers.\n           A\
    \ small extension to RSVP for IP Security under IPv4 and IPv6\n           is described\
    \ separately in [RFC 2207].\n      RSVP messages carrying reservation requests\
    \ originate at receivers\n      and are passed upstream towards the sender(s).\
    \  Note: in this\n      document, we define the directional terms \"upstream\"\
    \ vs.\n      \"downstream\", \"previous hop\" vs. \"next hop\", and \"incoming\n\
    \      interface\" vs \"outgoing interface\" with respect to the direction\n \
    \     of data flow.\n      At each intermediate node, a reservation request triggers\
    \ two\n      general actions, as follows:\n      1.   Make a reservation on a\
    \ link\n           The RSVP process passes the request to admission control and\n\
    \           policy control.  If either test fails, the reservation is\n      \
    \     rejected and the RSVP process returns an error message to the\n        \
    \   appropriate receiver(s).  If both succeed, the node sets the\n           packet\
    \ classifier to select the data packets defined by the\n           filter spec,\
    \ and it interacts with the appropriate link layer\n           to obtain the desired\
    \ QoS defined by the flowspec.\n           The detailed rules for satisfying an\
    \ RSVP QoS request depend\n           upon the particular link layer technology\
    \ in use on each\n           interface.  Specifications are under development\
    \ in the ISSLL\n           Working Group for mapping reservation requests into\
    \ popular\n           link layer technologies.  For a simple leased line, the\n\
    \           desired QoS will be obtained from the packet scheduler in the\n  \
    \         link layer driver, for example.  If the link-layer technology\n    \
    \       implements its own QoS management capability, then RSVP must\n       \
    \    negotiate with the link layer to obtain the requested QoS.\n           Note\
    \ that the action to control QoS occurs at the place where\n           the data\
    \ enters the link-layer medium, i.e., at the upstream\n           end of the logical\
    \ or physical link, although an RSVP\n           reservation request originates\
    \ from receiver(s) downstream.\n      2.   Forward the request upstream\n    \
    \       A reservation request is propagated upstream towards the\n           appropriate\
    \ senders.  The set of sender hosts to which a\n           given reservation request\
    \ is propagated is called the \"scope\"\n           of that request.\n       \
    \    The reservation request that a node forwards upstream may\n           differ\
    \ from the request that it received from downstream, for\n           two reasons.\
    \  The traffic control mechanism may modify the\n           flowspec hop-by-hop.\
    \  More importantly, reservations from\n           different downstream branches\
    \ of the multicast tree(s) from\n           the same sender (or set of senders)\
    \ must be \" merged\" as\n           reservations travel upstream.\n      When\
    \ a receiver originates a reservation request, it can also\n      request a confirmation\
    \ message to indicate that its request was\n      (probably) installed in the\
    \ network.  A successful reservation\n      request propagates upstream along\
    \ the multicast tree until it\n      reaches a point where an existing reservation\
    \ is equal or greater\n      than that being requested.  At that point, the arriving\
    \ request is\n      merged with the reservation in place and need not be forwarded\n\
    \      further; the node may then send a reservation confirmation message\n  \
    \    back to the receiver.  Note that the receipt of a confirmation is\n     \
    \ only a high-probability indication, not a guarantee, that the\n      requested\
    \ service is in place all the way to the sender(s), as\n      explained in Section\
    \ 2.6.\n      The basic RSVP reservation model is \"one pass\": a receiver sends\
    \ a\n      reservation request upstream, and each node in the path either\n  \
    \    accepts or rejects the request.  This scheme provides no easy way\n     \
    \ for a receiver to find out the resulting end-to-end service.\n      Therefore,\
    \ RSVP supports an enhancement to one-pass service known\n      as \"One Pass\
    \ With Advertising\" (OPWA) [OPWA95].  With OPWA, RSVP\n      control packets\
    \ are sent downstream, following the data paths, to\n      gather information\
    \ that may be used to predict the end-to-end QoS.\n      The results (\"advertisements\"\
    ) are delivered by RSVP to the\n      receiver hosts and perhaps to the receiver\
    \ applications.  The\n      advertisements may then be used by the receiver to\
    \ construct, or\n      to dynamically adjust, an appropriate reservation request.\n\
    \   1.3 Reservation Styles\n      A reservation request includes a set of options\
    \ that are\n      collectively called the reservation \"style\".\n      One reservation\
    \ option concerns the treatment of reservations for\n      different senders within\
    \ the same session: establish a \"distinct\"\n      reservation for each upstream\
    \ sender, or else make a single\n      reservation that is \"shared\" among all\
    \ packets of selected\n      senders.\n      Another reservation option controls\
    \ the selection of senders; it\n      may be an \"explicit\" list of all selected\
    \ senders, or a \"wildcard\"\n      that implicitly selects all the senders to\
    \ the session.  In an\n      explicit sender-selection reservation, each filter\
    \ spec must match\n      exactly one sender, while in a wildcard sender-selection\
    \ no filter\n      spec is needed.\n           Sender   ||             Reservations:\n\
    \         Selection  ||     Distinct     |        Shared\n           _________||__________________|____________________\n\
    \                    ||                  |                    |\n          Explicit\
    \  ||  Fixed-Filter    |  Shared-Explicit   |\n                    ||  (FF) style\
    \      |  (SE) Style        |\n          __________||__________________|____________________|\n\
    \                    ||                  |                    |\n          Wildcard\
    \  ||  (None defined)  |  Wildcard-Filter   |\n                    ||        \
    \          |  (WF) Style        |\n          __________||__________________|____________________|\n\
    \                 Figure 3: Reservation Attributes and Styles\n      The following\
    \ styles are currently defined (see Figure 3):\n      o    Wildcard-Filter (WF)\
    \ Style\n           The WF style implies the options: \"shared\" reservation and\n\
    \           \"wildcard\" sender selection.  Thus, a WF-style reservation\n   \
    \        creates a single reservation shared by flows from all\n           upstream\
    \ senders.  This reservation may be thought of as a\n           shared \"pipe\"\
    , whose \"size\" is the largest of the resource\n           requests from all\
    \ receivers, independent of the number of\n           senders using it.  A WF-style\
    \ reservation is propagated\n           upstream towards all sender hosts, and\
    \ it automatically\n           extends to new senders as they appear.\n      \
    \     Symbolically, we can represent a WF-style reservation request\n        \
    \   by:\n               WF( * {Q})\n           where the asterisk represents wildcard\
    \ sender selection and Q\n           represents the flowspec.\n      o    Fixed-Filter\
    \ (FF) Style\n           The FF style implies the options: \"distinct\" reservations\
    \ and\n           \"explicit\" sender selection.  Thus, an elementary FF-style\n\
    \           reservation request creates a distinct reservation for data\n    \
    \       packets from a particular sender, not sharing them with other\n      \
    \     senders' packets for the same session.\n           Symbolically, we can\
    \ represent an elementary FF reservation\n           request by:\n           \
    \    FF( S{Q})\n           where S is the selected sender and Q is the corresponding\n\
    \           flowspec; the pair forms a flow descriptor.  RSVP allows\n       \
    \    multiple elementary FF-style reservations to be requested at\n          \
    \ the same time, using a list of flow descriptors:\n               FF( S1{Q1},\
    \ S2{Q2}, ...)\n           The total reservation on a link for a given session\
    \ is the\n           `sum' of Q1, Q2, ... for all requested senders.\n      o\
    \    Shared Explicit (SE) Style\n           The SE style implies the options:\
    \ \"shared\" reservation and\n           \"explicit\" sender selection.  Thus,\
    \ an SE-style reservation\n           creates a single reservation shared by selected\
    \ upstream\n           senders.  Unlike the WF style, the SE style allows a receiver\n\
    \           to explicitly specify the set of senders to be included.\n       \
    \    We can represent an SE reservation request containing a\n           flowspec\
    \ Q and a list of senders S1, S2, ... by:\n               SE( (S1,S2,...){Q} )\n\
    \      Shared reservations, created by WF and SE styles, are appropriate\n   \
    \   for those multicast applications in which multiple data sources\n      are\
    \ unlikely to transmit simultaneously.  Packetized audio is an\n      example\
    \ of an application suitable for shared reservations; since\n      a limited number\
    \ of people talk at once, each receiver might issue\n      a WF or SE reservation\
    \ request for twice the bandwidth required\n      for one sender (to allow some\
    \ over-speaking).  On the other hand,\n      the FF style, which creates distinct\
    \ reservations for the flows\n      from different senders, is appropriate for\
    \ video signals.\n      The RSVP rules disallow merging of shared reservations\
    \ with\n      distinct reservations, since these modes are fundamentally\n   \
    \   incompatible.  They also disallow merging explicit sender\n      selection\
    \ with wildcard sender selection, since this might produce\n      an unexpected\
    \ service for a receiver that specified explicit\n      selection.  As a result\
    \ of these prohibitions, WF, SE, and FF\n      styles are all mutually incompatible.\n\
    \      It would seem possible to simulate the effect of a WF reservation\n   \
    \   using the SE style.  When an application asked for WF, the RSVP\n      process\
    \ on the receiver host could use local state to create an\n      equivalent SE\
    \ reservation that explicitly listed all senders.\n      However, an SE reservation\
    \ forces the packet classifier in each\n      node to explicitly select each sender\
    \ in the list, while a WF\n      allows the packet classifier to simply \"wild\
    \ card\" the sender\n      address and port.  When there is a large list of senders,\
    \ a WF\n      style reservation can therefore result in considerably less\n  \
    \    overhead than an equivalent SE style reservation.  For this\n      reason,\
    \ both SE and WF are included in the protocol.\n      Other reservation options\
    \ and styles may be defined in the future.\n   1.4 Examples of Styles\n      This\
    \ section presents examples of each of the reservation styles\n      and shows\
    \ the effects of merging.\n      Figure 4 illustrates a router with two incoming\
    \ interfaces,\n      labeled (a) and (b), through which flows will arrive, and\
    \ two\n      outgoing interfaces, labeled (c) and (d), through which data will\n\
    \      be forwarded.  This topology will be assumed in the examples that\n   \
    \   follow.  There are three upstream senders; packets from sender S1\n      (S2\
    \ and S3) arrive through previous hop (a) ((b), respectively).\n      There are\
    \ also three downstream receivers; packets bound for R1\n      (R2 and R3) are\
    \ routed via outgoing interface (c) ((d),\n      respectively).  We furthermore\
    \ assume that outgoing interface (d)\n      is connected to a broadcast LAN, i.e.,\
    \ that replication occurs in\n      the network; R2 and R3 are reached via different\
    \ next hop routers\n      (not shown).\n      We must also specify the multicast\
    \ routes within the node of\n      Figure 4.  Assume first that data packets from\
    \ each Si shown in\n      Figure 4 are routed to both outgoing interfaces.  Under\
    \ this\n      assumption, Figures 5, 6, and 7 illustrate Wildcard-Filter,\n  \
    \    Fixed-Filter, and Shared-Explicit reservations, respectively.\n         \
    \                ________________\n                     (a)|                |\
    \ (c)\n      ( S1 ) ---------->|                |----------> ( R1 )\n        \
    \                |     Router     |      |\n                     (b)|        \
    \        | (d)  |---> ( R2 )\n      ( S2,S3 ) ------->|                |------|\n\
    \                        |________________|      |---> ( R3 )\n              \
    \                                  |\n                        Figure 4: Router\
    \ Configuration\n      For simplicity, these examples show flowspecs as one-dimensional\n\
    \      multiples of some base resource quantity B.  The \"Receives\" column\n\
    \      shows the RSVP reservation requests received over outgoing\n      interfaces\
    \ (c) and (d), and the \"Reserves\" column shows the\n      resulting reservation\
    \ state for each interface.   The \"Sends\"\n      column shows the reservation\
    \ requests that are sent upstream to\n      previous hops (a) and (b).  In the\
    \ \"Reserves\" column, each box\n      represents one reserved \"pipe\" on the\
    \ outgoing link, with the\n      corresponding flow descriptor.\n      Figure\
    \ 5, showing the WF style, illustrates two distinct\n      situations in which\
    \ merging is required.  (1) Each of the two next\n      hops on interface (d)\
    \ results in a separate RSVP reservation\n      request, as shown; these two requests\
    \ must be merged into the\n      effective flowspec, 3B, that is used to make\
    \ the reservation on\n      interface (d).  (2) The reservations on the interfaces\
    \ (c) and (d)\n      must be merged in order to forward the reservation requests\n\
    \      upstream; as a result, the larger flowspec 4B is forwarded\n      upstream\
    \ to each previous hop.\n                             |\n               Sends\
    \         |       Reserves             Receives\n                            \
    \ |\n                             |       _______\n         WF( *{4B} ) <- (a)\
    \  |  (c) | * {4B}|    (c) <- WF( *{4B} )\n                             |    \
    \  |_______|\n                             |\n      -----------------------|----------------------------------------\n\
    \                             |       _______\n         WF( *{4B} ) <- (b)  |\
    \  (d) | * {3B}|    (d) <- WF( *{3B} )\n                             |      |_______|\
    \        <- WF( *{2B} )\n              Figure 5: Wildcard-Filter (WF) Reservation\
    \ Example\n      Figure 6 shows Fixed-Filter (FF) style reservations.  For each\n\
    \      outgoing interface, there is a separate reservation for each\n      source\
    \ that has been requested, but this reservation will be\n      shared among all\
    \ the receivers that made the request.  The flow\n      descriptors for senders\
    \ S2 and S3, received through outgoing\n      interfaces (c) and (d), are packed\
    \ (not merged) into the request\n      forwarded to previous hop (b).  On the\
    \ other hand, the three\n      different flow descriptors specifying sender S1\
    \ are merged into\n      the single request FF( S1{4B} ) that is sent to previous\
    \ hop (a).\n                          |\n            Sends         |       Reserves\
    \             Receives\n                          |\n                        \
    \  |       ________\n     FF( S1{4B} ) <- (a)  |  (c) | S1{4B} |  (c) <- FF( S1{4B},\
    \ S2{5B} )\n                          |      |________|\n                    \
    \      |      | S2{5B} |\n                          |      |________|\n     ---------------------|---------------------------------------------\n\
    \                          |       ________\n                  <- (b)  |  (d)\
    \ | S1{3B} |  (d) <- FF( S1{3B}, S3{B} )\n     FF( S2{5B}, S3{B} )  |      |________|\
    \      <- FF( S1{B} )\n                          |      | S3{B}  |\n         \
    \                 |      |________|\n              Figure 6: Fixed-Filter (FF)\
    \ Reservation Example\n      Figure 7 shows an example of Shared-Explicit (SE)\
    \ style\n      reservations.  When SE-style reservations are merged, the\n   \
    \   resulting filter spec is the union of the original filter specs,\n      and\
    \ the resulting flowspec is the largest flowspec.\n                          |\n\
    \            Sends         |       Reserves             Receives\n           \
    \               |\n                          |       ________\n     SE( S1{3B}\
    \ ) <- (a)  |  (c) |(S1,S2) |   (c) <- SE( (S1,S2){B} )\n                    \
    \      |      |   {B}  |\n                          |      |________|\n     ---------------------|---------------------------------------------\n\
    \                          |      __________\n                  <- (b)  | (d)\
    \ |(S1,S2,S3)|  (d) <- SE( (S1,S3){3B} )\n     SE( (S2,S3){3B} )    |     |  \
    \ {3B}   |      <- SE( S2{2B} )\n                          |     |__________|\n\
    \            Figure 7: Shared-Explicit (SE) Reservation Example\n      The three\
    \ examples just shown assume that data packets from S1,\n      S2, and S3 are\
    \ routed to both outgoing interfaces.  The top part\n      of Figure 8 shows another\
    \ routing assumption: data packets from S2\n      and S3 are not forwarded to\
    \ interface (c), e.g., because the\n      network topology provides a shorter\
    \ path for these senders towards\n      R1, not traversing this node.  The bottom\
    \ part of Figure 8 shows\n      WF style reservations under this assumption. \
    \ Since there is no\n      route from (b) to (c), the reservation forwarded out\
    \ interface (b)\n      considers only the reservation on interface (d).\n    \
    \                     _______________\n                     (a)|             \
    \  | (c)\n      ( S1 ) ---------->| >-----------> |----------> ( R1 )\n      \
    \                  |    >          |\n                        |      >       \
    \ |\n                     (b)|        >      | (d)\n      ( S2,S3 ) ------->|\
    \ >-------->--> |----------> ( R2, R3 )\n                        |_______________|\n\
    \                       Router Configuration\n                             |\n\
    \               Sends         |       Reserves             Receives\n        \
    \                     |\n                             |       _______\n      \
    \   WF( *{4B} ) <- (a)  |  (c) | * {4B}|   (c) <- WF( *{4B} )\n              \
    \               |      |_______|\n                             |\n      -----------------------|----------------------------------------\n\
    \                             |       _______\n         WF( *{3B} ) <- (b)  |\
    \  (d) | * {3B}|   (d) <- WF( * {3B} )\n                             |      |_______|\
    \       <- WF( * {2B} )\n             Figure 8: WF Reservation Example -- Partial\
    \ Routing\n"
- title: 2. RSVP Protocol Mechanisms
  contents:
  - "2. RSVP Protocol Mechanisms\n   2.1 RSVP Messages\n       Previous       Incoming\
    \           Outgoing             Next\n       Hops           Interfaces      \
    \   Interfaces           Hops\n       _____             _____________________\
    \                _____\n      |     | data -->  |                     |  data\
    \ -->    |     |\n      |  A  |-----------| a                 c |--------------|\
    \  C  |\n      |_____| Path -->  |                     |  Path -->    |_____|\n\
    \              <-- Resv  |                     |  <-- Resv     _____\n       _____\
    \            |       ROUTER        |           |  |     |\n      |     |  |  \
    \      |                     |           |--|  D  |\n      |  B  |--| data-->|\
    \                     |  data --> |  |_____|\n      |_____|  |--------| b    \
    \             d |-----------|\n               | Path-->|                     |\
    \  Path --> |   _____\n       _____   | <--Resv|_____________________|  <-- Resv\
    \ |  |     |\n      |     |  |                                          |--| \
    \ D' |\n      |  B' |--|                                          |  |_____|\n\
    \      |_____|  |                                          |\n               \
    \          Figure 9: Router Using RSVP\n      Figure 9 illustrates RSVP's model\
    \ of a router node.  Each data\n      flow arrives from a \"previous hop\" through\
    \ a corresponding\n      \"incoming interface\" and departs through one or more\
    \ \"outgoing\n      interface\"(s).  The same interface may act in both the incoming\n\
    \      and outgoing roles for different data flows in the same session.\n    \
    \  Multiple previous hops and/or next hops may be reached through a\n      given\
    \ physical interface; for example, the figure implies that D\n      and D' are\
    \ connected to (d) with a broadcast LAN.\n      There are two fundamental RSVP\
    \ message types: Resv and Path.\n      Each receiver host sends RSVP reservation\
    \ request (Resv) messages\n      upstream towards the senders.  These messages\
    \ must follow exactly\n      the reverse of the path(s) the data packets will\
    \ use, upstream to\n      all the sender hosts included in the sender selection.\
    \  They\n      create and maintain \"reservation state\" in each node along the\n\
    \      path(s).  Resv messages must finally be delivered to the sender\n     \
    \ hosts themselves, so that the hosts can set up appropriate traffic\n      control\
    \ parameters for the first hop.  The processing of Resv\n      messages was discussed\
    \ previously in Section 1.2.\n      Each RSVP sender host transmits RSVP \"Path\"\
    \ messages downstream\n      along the uni-/multicast routes provided by the routing\n\
    \      protocol(s), following the paths of the data.  These Path messages\n  \
    \    store \"path state\" in each node along the way.  This path state\n     \
    \ includes at least the unicast IP address of the previous hop node,\n      which\
    \ is used to route the Resv messages hop-by-hop in the reverse\n      direction.\
    \  (In the future, some routing protocols may supply\n      reverse path forwarding\
    \ information directly, replacing the\n      reverse-routing function of path\
    \ state).\n      A Path message contains the following information in addition\
    \ to\n      the previous hop address:\n      o    Sender Template\n          \
    \ A Path message is required to carry a Sender Template, which\n           describes\
    \ the format of data packets that the sender will\n           originate.  This\
    \ template is in the form of a filter spec\n           that could be used to select\
    \ this sender's packets from\n           others in the same session on the same\
    \ link.\n           Sender Templates have exactly the same expressive power and\n\
    \           format as filter specs that appear in Resv messages.\n           Therefore\
    \ a Sender Template may specify only the sender IP\n           address and optionally\
    \ the UDP/TCP sender port, and it\n           assumes the protocol Id specified\
    \ for the session.\n      o    Sender Tspec\n           A Path message is required\
    \ to carry a Sender Tspec, which\n           defines the traffic characteristics\
    \ of the data flow that the\n           sender will generate.  This Tspec is used\
    \ by traffic control\n           to prevent over-reservation, and perhaps unnecessary\n\
    \           Admission Control failures.\n      o    Adspec\n           A Path\
    \ message may carry a package of OPWA advertising\n           information, known\
    \ as an \"Adspec\".  An Adspec received in a\n           Path message is passed\
    \ to the local traffic control, which\n           returns an updated Adspec; the\
    \ updated version is then\n           forwarded in Path messages sent downstream.\n\
    \      Path messages are sent with the same source and destination\n      addresses\
    \ as the data, so that they will be routed correctly\n      through non-RSVP clouds\
    \ (see Section 2.9).  On the other hand,\n      Resv messages are sent hop-by-hop;\
    \ each RSVP-speaking node\n      forwards a Resv message to the unicast address\
    \ of a previous RSVP\n      hop.\n   2.2 Merging Flowspecs\n      A Resv message\
    \ forwarded to a previous hop carries a flowspec that\n      is the \"largest\"\
    \ of the flowspecs requested by the next hops to\n      which the data flow will\
    \ be sent (however, see Section 3.5 for a\n      different merging rule used in\
    \ certain cases).  We say the\n      flowspecs have been \"merged\".  The examples\
    \ shown in Section 1.4\n      illustrated another case of merging, when there\
    \ are multiple\n      reservation requests from different next hops for the same\
    \ session\n      and with the same filter spec, but RSVP should install only one\n\
    \      reservation on that interface.  Here again, the installed\n      reservation\
    \ should have an effective flowspec that is the\n      \"largest\" of the flowspecs\
    \ requested by the different next hops.\n      Since flowspecs are opaque to RSVP,\
    \ the actual rules for comparing\n      flowspecs must be defined and implemented\
    \ outside RSVP proper.\n      The comparison rules are defined in the appropriate\
    \ integrated\n      service specification document.  An RSVP implementation will\
    \ need\n      to call service-specific routines to perform flowspec merging.\n\
    \      Note that flowspecs are generally multi-dimensional vectors; they\n   \
    \   may contain both Tspec and Rspec components, each of which may\n      itself\
    \ be multi-dimensional.  Therefore, it may not be possible to\n      strictly\
    \ order two flowspecs.  For example, if one request calls\n      for a higher\
    \ bandwidth and another calls for a tighter delay\n      bound, one is not \"\
    larger\" than the other.  In such a case,\n      instead of taking the larger,\
    \ the service-specific merging\n      routines must be able to return a third\
    \ flowspec that is at least\n      as large as each; mathematically, this is the\
    \ \"least upper bound\"\n      (LUB).  In some cases, a flowspec at least as small\
    \ is needed;\n      this is the \"greatest lower bound\" (GLB) GLB (Greatest Lower\n\
    \      Bound).\n      The following steps are used to calculate the effective\
    \ flowspec\n      (Re, Te) to be installed on an interface [RFC 2210].  Here Te\
    \ is\n      the effective Tspec and Re is the effective Rspec.\n      1.   An\
    \ effective flowspec is determined for the outgoing\n           interface.  Depending\
    \ upon the link-layer technology, this\n           may require merging flowspecs\
    \ from different next hops; this\n           means computing the effective flowspec\
    \ as the LUB of the\n           flowspecs.  Note that what flowspecs to merge\
    \ is determined\n           by the link layer medium (see Section 3.11.2), while\
    \ how to\n           merge them is determined by the service model in use [RFC\n\
    \           2210].\n           The result is a flowspec that is opaque to RSVP\
    \ but actually\n           consists of the pair (Re, Resv_Te), where is Re is\
    \ the\n           effective Rspec and Resv_Te is the effective Tspec.\n      2.\
    \   A service-specific calculation of Path_Te, the sum of all\n           Tspecs\
    \ that were supplied in Path messages from different\n           previous hops\
    \ (e.g., some or all of A, B, and B' in Figure\n           9), is performed.\n\
    \      3.   (Re, Resv_Te) and Path_Te are passed to traffic control.\n       \
    \    Traffic control will compute the effective flowspec as the\n           \"\
    minimum\" of Path_Te and Resv_Te, in a service-dependent\n           manner.\n\
    \      Section 3.11.6 defines a generic set of service-specific calls to\n   \
    \   compare flowspecs, to compute the LUB and GLB of flowspecs, and to\n     \
    \ compare and sum Tspecs.\n   2.3 Soft State\n      RSVP takes a \"soft state\"\
    \ approach to managing the reservation\n      state in routers and hosts.  RSVP\
    \ soft state is created and\n      periodically refreshed by Path and Resv messages.\
    \  The state is\n      deleted if no matching refresh messages arrive before the\n\
    \      expiration of a \"cleanup timeout\" interval.  State may also be\n    \
    \  deleted by an explicit \"teardown\" message, described in the next\n      section.\
    \  At the expiration of each \"refresh timeout\" period and\n      after a state\
    \ change, RSVP scans its state to build and forward\n      Path and Resv refresh\
    \ messages to succeeding hops.\n      Path and Resv messages are idempotent. \
    \ When a route changes, the\n      next Path message will initialize the path\
    \ state on the new route,\n      and future Resv messages will establish reservation\
    \ state there;\n      the state on the now-unused segment of the route will time\
    \ out.\n      Thus, whether a message is \"new\" or a \"refresh\" is determined\n\
    \      separately at each node, depending upon the existence of state at\n   \
    \   that node.\n      RSVP sends its messages as IP datagrams with no reliability\n\
    \      enhancement.  Periodic transmission of refresh messages by hosts\n    \
    \  and routers is expected to handle the occasional loss of an RSVP\n      message.\
    \  If the effective cleanup timeout is set to K times the\n      refresh timeout\
    \ period, then RSVP can tolerate K-1 successive RSVP\n      packet losses without\
    \ falsely deleting state.  The network traffic\n      control mechanism should\
    \ be statically configured to grant some\n      minimal bandwidth for RSVP messages\
    \ to protect them from\n      congestion losses.\n      The state maintained by\
    \ RSVP is dynamic; to change the set of\n      senders Si or to change any QoS\
    \ request, a host simply starts\n      sending revised Path and/or Resv messages.\
    \  The result will be an\n      appropriate adjustment in the RSVP state in all\
    \ nodes along the\n      path; unused state will time out if it is not explicitly\
    \ torn\n      down.\n      In steady state, state is refreshed hop-by-hop to allow\
    \ merging.\n      When the received state differs from the stored state, the stored\n\
    \      state is updated.  If this update results in modification of state\n  \
    \    to be forwarded in refresh messages, these refresh messages must\n      be\
    \ generated and forwarded immediately, so that state changes can\n      be propagated\
    \ end-to-end without delay.  However, propagation of a\n      change stops when\
    \ and if it reaches a point where merging causes\n      no resulting state change.\
    \  This minimizes RSVP control traffic\n      due to changes and is essential\
    \ for scaling to large multicast\n      groups.\n      State that is received\
    \ through a particular interface I* should\n      never be forwarded out the same\
    \ interface.  Conversely, state that\n      is forwarded out interface I* must\
    \ be computed using only state\n      that arrived on interfaces different from\
    \ I*.  A trivial example\n      of this rule is illustrated in Figure 10, which\
    \ shows a transit\n      router with one sender and one receiver on each interface\
    \ (and\n      assumes one next/previous hop per interface).  Interfaces (a) and\n\
    \      (c) serve as both outgoing and incoming interfaces for this\n      session.\
    \  Both receivers are making wildcard-style reservations,\n      in which the\
    \ Resv messages are forwarded to all previous hops for\n      senders in the group,\
    \ with the exception of the next hop from\n      which they came.  The result\
    \ is independent reservations in the\n      two directions.\n      There is an\
    \ additional rule governing the forwarding of Resv\n      messages: state from\
    \ Resv messages received from outgoing\n      interface Io should be forwarded\
    \ to incoming interface Ii only if\n      Path messages from Ii are forwarded\
    \ to Io.\n                         ________________\n                      a |\
    \                | c\n      ( R1, S1 ) <----->|     Router     |<-----> ( R2,\
    \ S2 )\n                        |________________|\n             Send        \
    \        |        Receive\n                                 |\n        WF( *{3B})\
    \ <-- (a)       |     (c) <-- WF( *{3B})\n                                 |\n\
    \             Receive             |          Send\n                          \
    \       |\n        WF( *{4B}) --> (a)       |     (c) --> WF( *{4B})\n       \
    \                          |\n             Reserve on (a)      |        Reserve\
    \ on (c)\n              __________         |        __________\n             |\
    \  * {4B}  |        |       |   * {3B} |\n             |__________|        | \
    \      |__________|\n                                 |\n                    \
    \ Figure 10: Independent Reservations\n   2.4 Teardown\n      RSVP \"teardown\"\
    \ messages remove path or reservation state\n      immediately.  Although it is\
    \ not necessary to explicitly tear down\n      an old reservation, we recommend\
    \ that all end hosts send a\n      teardown request as soon as an application\
    \ finishes.\n      There are two types of RSVP teardown message, PathTear and\n\
    \      ResvTear.  A PathTear message travels towards all receivers\n      downstream\
    \ from its point of initiation and deletes path state, as\n      well as all dependent\
    \ reservation state, along the way.  An\n      ResvTear message deletes reservation\
    \ state and travels towards all\n      senders upstream from its point of initiation.\
    \  A PathTear\n      (ResvTear) message may be conceptualized as a reversed-sense\
    \ Path\n      message (Resv message, respectively).\n      A teardown request\
    \ may be initiated either by an application in an\n      end system (sender or\
    \ receiver), or by a router as the result of\n      state timeout or service preemption.\
    \  Once initiated, a teardown\n      request must be forwarded hop-by-hop without\
    \ delay.  A teardown\n      message deletes the specified state in the node where\
    \ it is\n      received.  As always, this state change will be propagated\n  \
    \    immediately to the next node, but only if there will be a net\n      change\
    \ after merging.  As a result, a ResvTear message will prune\n      the reservation\
    \ state back (only) as far as possible.\n      Like all other RSVP messages, teardown\
    \ requests are not delivered\n      reliably.  The loss of a teardown request\
    \ message will not cause a\n      protocol failure because the unused state will\
    \ eventually time out\n      even though it is not explicitly deleted.  If a teardown\
    \ message\n      is lost, the router that failed to receive that message will\
    \ time\n      out its state and initiate a new teardown message beyond the loss\n\
    \      point.  Assuming that RSVP message loss probability is small, the\n   \
    \   longest time to delete state will seldom exceed one refresh\n      timeout\
    \ period.\n      It should be possible to tear down any subset of the established\n\
    \      state.  For path state, the granularity for teardown is a single\n    \
    \  sender.  For reservation state, the granularity is an individual\n      filter\
    \ spec.  For example, refer to Figure 7.  Receiver R1 could\n      send a ResvTear\
    \ message for sender S2 only (or for any subset of\n      the filter spec list),\
    \ leaving S1 in place.\n      A ResvTear message specifies the style and filters;\
    \ any flowspec\n      is ignored.  Whatever flowspec is in place will be removed\
    \ if all\n      its filter specs are torn down.\n   2.5 Errors\n      There are\
    \ two RSVP error messages, ResvErr and PathErr.  PathErr\n      messages are very\
    \ simple; they are simply sent upstream to the\n      sender that created the\
    \ error, and they do not change path state\n      in the nodes though which they\
    \ pass.  There are only a few\n      possible causes of path errors.\n      However,\
    \ there are a number of ways for a syntactically valid\n      reservation request\
    \ to fail at some node along the path.  A node\n      may also decide to preempt\
    \ an established reservation.  The\n      handling of ResvErr messages is somewhat\
    \ complex (Section 3.5).\n      Since a request that fails may be the result of\
    \ merging a number\n      of requests, a reservation error must be reported to\
    \ all of the\n      responsible receivers.  In addition, merging heterogeneous\n\
    \      requests creates a potential difficulty known as the \"killer\n      reservation\"\
    \ problem, in which one request could deny service to\n      another.  There are\
    \ actually two killer-reservation problems.\n      1.   The first killer reservation\
    \ problem (KR-I) arises when there\n           is already a reservation Q0 in\
    \ place.  If another receiver\n           now makes a larger reservation Q1 >\
    \ Q0, the result of merging\n           Q0 and Q1 may be rejected by admission\
    \ control in some\n           upstream node.  This must not deny service to Q0.\n\
    \           The solution to this problem is simple: when admission\n         \
    \  control fails for a reservation request, any existing\n           reservation\
    \ is left in place.\n      2.   The second killer reservation problem (KR-II)\
    \ is the\n           converse: the receiver making a reservation Q1 is persistent\n\
    \           even though Admission Control is failing for Q1 in some node.\n  \
    \         This must not prevent a different receiver from now\n           establishing\
    \ a smaller reservation Q0 that would succeed if\n           not merged with Q1.\n\
    \           To solve this problem, a ResvErr message establishes\n           additional\
    \ state, called \"blockade state\", in each node\n           through which it\
    \ passes.  Blockade state in a node modifies\n           the merging procedure\
    \ to omit the offending flowspec (Q1 in\n           the example) from the merge,\
    \ allowing a smaller request to be\n           forwarded and established.  The\
    \ Q1 reservation state is said\n           to be \"blockaded\".  Detailed rules\
    \ are presented in Section\n           3.5.\n      A reservation request that\
    \ fails Admission Control creates\n      blockade state but is left in place in\
    \ nodes downstream of the\n      failure point.  It has been suggested that these\
    \ reservations\n      downstream from the failure represent \"wasted\" reservations\
    \ and\n      should be timed out if not actively deleted.  However, the\n    \
    \  downstream reservations are left in place, for the following\n      reasons:\n\
    \      o    There are two possible reasons for a receiver persisting in a\n  \
    \         failed reservation: (1) it is polling for resource\n           availability\
    \ along the entire path, or (2) it wants to obtain\n           the desired QoS\
    \ along as much of the path as possible.\n           Certainly in the second case,\
    \ and perhaps in the first case,\n           the receiver will want to hold onto\
    \ the reservations it has\n           made downstream from the failure.\n    \
    \  o    If these downstream reservations were not retained, the\n           responsiveness\
    \ of RSVP to certain transient failures would be\n           impaired.  For example,\
    \ suppose a route \"flaps\" to an\n           alternate route that is congested,\
    \ so an existing reservation\n           suddenly fails, then quickly recovers\
    \ to the original route.\n           The blockade state in each downstream router\
    \ must not remove\n           the state or prevent its immediate refresh.\n  \
    \    o    If we did not refresh the downstream reservations, they might\n    \
    \       time out, to be restored every Tb seconds (where Tb is the\n         \
    \  blockade state timeout interval).  Such intermittent behavior\n           might\
    \ be very distressing for users.\n   2.6 Confirmation\n      To request a confirmation\
    \ for its reservation request, a receiver\n      Rj includes in the Resv message\
    \ a confirmation-request object\n      containing Rj's IP address.  At each merge\
    \ point, only the largest\n      flowspec and any accompanying confirmation-request\
    \ object is\n      forwarded upstream.  If the reservation request from Rj is\
    \ equal\n      to or smaller than the reservation in place on a node, its Resv\
    \ is\n      not forwarded further, and if the Resv included a confirmation-\n\
    \      request object, a ResvConf message is sent back to Rj.  If the\n      confirmation\
    \ request is forwarded, it is forwarded immediately,\n      and no more than once\
    \ for each request.\n      This confirmation mechanism has the following consequences:\n\
    \      o    A new reservation request with a flowspec larger than any in\n   \
    \        place for a session will normally result in either a ResvErr\n      \
    \     or a ResvConf message back to the receiver from each sender.\n         \
    \  In this case, the ResvConf message will be an end-to-end\n           confirmation.\n\
    \      o    The receipt of a ResvConf gives no guarantees.  Assume the\n     \
    \      first two reservation requests from receivers R1 and R2\n           arrive\
    \ at the node where they are merged.  R2, whose\n           reservation was the\
    \ second to arrive at that node, may\n           receive a ResvConf from that\
    \ node while R1's request has not\n           yet propagated all the way to a\
    \ matching sender and may still\n           fail.  Thus, R2 may receive a ResvConf\
    \ although there is no\n           end-to-end reservation in place; furthermore,\
    \ R2 may receive\n           a ResvConf followed by a ResvErr.\n   2.7 Policy\
    \ Control\n      RSVP-mediated QoS requests allow particular user(s) to obtain\n\
    \      preferential access to network resources.  To prevent abuse, some\n   \
    \   form of back pressure will generally be required on users who make\n     \
    \ reservations.  For example, such back pressure may be accomplished\n      by\
    \ administrative access policies, or it may depend upon some form\n      of user\
    \ feedback such as real or virtual billing for the \"cost\" of\n      a reservation.\
    \  In any case, reliable user identification and\n      selective admission will\
    \ generally be needed when a reservation is\n      requested.\n      The term\
    \ \"policy control\" is used for the mechanisms required to\n      support access\
    \ policies and back pressure for RSVP reservations.\n      When a new reservation\
    \ is requested, each node must answer two\n      questions: \"Are enough resources\
    \ available to meet this request?\"\n      and \"Is this user allowed to make\
    \ this reservation?\"  These two\n      decisions are termed the \"admission control\"\
    \ decision and the\n      \"policy control\" decision, respectively, and both\
    \ must be\n      favorable in order for RSVP to make a reservation.  Different\n\
    \      administrative domains in the Internet may have different\n      reservation\
    \ policies.\n      The input to policy control is referred to as \"policy data\"\
    , which\n      RSVP carries in POLICY_DATA objects.  Policy data may include\n\
    \      credentials identifying users or user classes, account numbers,\n     \
    \ limits, quotas, etc.  Like flowspecs, policy data is opaque to\n      RSVP,\
    \ which simply passes it to policy control when required.\n      Similarly, merging\
    \ of policy data must be done by the policy\n      control mechanism rather than\
    \ by RSVP itself.  Note that the merge\n      points for policy data are likely\
    \ to be at the boundaries of\n      administrative domains.  It may therefore\
    \ be necessary to carry\n      accumulated and unmerged policy data upstream through\
    \ multiple\n      nodes before reaching one of these merge points.\n      Carrying\
    \ user-provided policy data in Resv messages presents a\n      potential scaling\
    \ problem.  When a multicast group has a large\n      number of receivers, it\
    \ will be impossible or undesirable to carry\n      all receivers' policy data\
    \ upstream.  The policy data will have to\n      be administratively merged at\
    \ places near the receivers, to avoid\n      excessive policy data.  Further discussion\
    \ of these issues and an\n      example of a policy control scheme will be found\
    \ in [PolArch96].\n      Specifications for the format of policy data objects\
    \ and RSVP\n      processing rules for them are under development.\n   2.8 Security\n\
    \      RSVP raises the following security issues.\n      o    Message integrity\
    \ and node authentication\n           Corrupted or spoofed reservation requests\
    \ could lead to theft\n           of service by unauthorized parties or to denial\
    \ of service\n           caused by locking up network resources.  RSVP protects\n\
    \           against such attacks with a hop-by-hop authentication\n          \
    \ mechanism using an encrypted hash function.  The mechanism is\n           supported\
    \ by INTEGRITY objects that may appear in any RSVP\n           message.  These\
    \ objects use a keyed cryptographic digest\n           technique, which assumes\
    \ that RSVP neighbors share a secret.\n           Although this mechanism is part\
    \ of the base RSVP\n           specification, it is described in a companion document\n\
    \           [Baker96].\n           Widespread use of the RSVP integrity mechanism\
    \ will require\n           the availability of the long-sought key management\
    \ and\n           distribution infrastructure for routers.  Until that\n     \
    \      infrastructure becomes available, manual key management will\n        \
    \   be required to secure RSVP message integrity.\n      o    User authentication\n\
    \           Policy control will depend upon positive authentication of\n     \
    \      the user responsible for each reservation request.  Policy\n          \
    \ data may therefore include cryptographically protected user\n           certificates.\
    \  Specification of such certificates is a future\n           issue.\n       \
    \    Even without globally-verifiable user certificates, it may be\n         \
    \  possible to provide practical user authentication in many\n           cases\
    \ by establishing a chain of trust, using the hop-by-hop\n           INTEGRITY\
    \ mechanism described earlier.\n      o    Secure data streams\n           The\
    \ first two security issues concerned RSVP's operation.  A\n           third security\
    \ issue concerns resource reservations for\n           secure data streams.  In\
    \ particular, the use of IPSEC (IP\n           Security) in the data stream poses\
    \ a problem for RSVP:  if\n           the transport and higher level headers are\
    \ encrypted, RSVP's\n           generalized port numbers cannot be used to define\
    \ a session\n           or a sender.\n           To solve this problem, an RSVP\
    \ extension has been defined in\n           which the security association identifier\
    \ (IPSEC SPI) plays a\n           role roughly equivalent to the generalized ports\
    \ [RFC 2207].\n   2.9 Non-RSVP Clouds\n      It is impossible to deploy RSVP (or\
    \ any new protocol) at the same\n      moment throughout the entire Internet.\
    \  Furthermore, RSVP may\n      never be deployed everywhere.  RSVP must therefore\
    \ provide correct\n      protocol operation even when two RSVP-capable routers\
    \ are joined\n      by an arbitrary \"cloud\" of non-RSVP routers.  Of course,\
    \ an\n      intermediate cloud that does not support RSVP is unable to perform\n\
    \      resource reservation.  However, if such a cloud has sufficient\n      capacity,\
    \ it may still provide useful realtime service.\n      RSVP is designed to operate\
    \ correctly through such a non-RSVP\n      cloud.  Both RSVP and non-RSVP routers\
    \ forward Path messages\n      towards the destination address using their local\
    \ uni-/multicast\n      routing table.  Therefore, the routing of Path messages\
    \ will be\n      unaffected by non-RSVP routers in the path.  When a Path message\n\
    \      traverses a non-RSVP cloud, it carries to the next RSVP-capable\n     \
    \ node the IP address of the last RSVP-capable router before\n      entering the\
    \ cloud.  An Resv message is then forwarded directly to\n      the next RSVP-capable\
    \ router on the path(s) back towards the\n      source.\n      Even though RSVP\
    \ operates correctly through a non-RSVP cloud, the\n      non-RSVP-capable nodes\
    \ will in general perturb the QoS provided to\n      a receiver.  Therefore, RSVP\
    \ passes a `NonRSVP' flag bit to the\n      local traffic control mechanism when\
    \ there are non-RSVP-capable\n      hops in the path to a given sender.  Traffic\
    \ control combines this\n      flag bit with its own sources of information, and\
    \ forwards the\n      composed information on integrated service capability along\
    \ the\n      path to receivers using Adspecs [RFC 2210].\n      Some topologies\
    \ of RSVP routers and non-RSVP routers can cause\n      Resv messages to arrive\
    \ at the wrong RSVP-capable node, or to\n      arrive at the wrong interface of\
    \ the correct node.  An RSVP\n      process must be prepared to handle either\
    \ situation.  If the\n      destination address does not match any local interface\
    \ and the\n      message is not a Path or PathTear, the message must be forwarded\n\
    \      without further processing by this node.  To handle the wrong\n      interface\
    \ case, a \"Logical Interface Handle\" (LIH) is used.  The\n      previous hop\
    \ information included in a Path message includes not\n      only the IP address\
    \ of the previous node but also an LIH defining\n      the logical outgoing interface;\
    \ both values are stored in the path\n      state.  A Resv message arriving at\
    \ the addressed node carries both\n      the IP address and the LIH of the correct\
    \ outgoing interface, i.e,\n      the interface that should receive the requested\
    \ reservation,\n      regardless of which interface it arrives on.\n      The\
    \ LIH may also be useful when RSVP reservations are made over a\n      complex\
    \ link layer, to map between IP layer and link layer flow\n      entities.\n \
    \  2.10 Host Model\n      Before a session can be created, the session identification\n\
    \      (DestAddress, ProtocolId [, DstPort]) must be assigned and\n      communicated\
    \ to all the senders and receivers by some out-of-band\n      mechanism.  When\
    \ an RSVP session is being set up, the following\n      events happen at the end\
    \ systems.\n      H1   A receiver joins the multicast group specified by\n   \
    \        DestAddress, using IGMP.\n      H2   A potential sender starts sending\
    \ RSVP Path messages to the\n           DestAddress.\n      H3   A receiver application\
    \ receives a Path message.\n      H4   A receiver starts sending appropriate Resv\
    \ messages,\n           specifying the desired flow descriptors.\n      H5   A\
    \ sender application receives a Resv message.\n      H6   A sender starts sending\
    \ data packets.\n      There are several synchronization considerations.\n   \
    \   o    H1 and H2 may happen in either order.\n      o    Suppose that a new\
    \ sender starts sending data (H6) but there\n           are no multicast routes\
    \ because no receivers have joined the\n           group (H1).  Then the data\
    \ will be dropped at some router\n           node (which node depends upon the\
    \ routing protocol) until\n           receivers(s) appear.\n      o    Suppose\
    \ that a new sender starts sending Path messages (H2)\n           and data (H6)\
    \ simultaneously, and there are receivers but no\n           Resv messages have\
    \ reached the sender yet (e.g., because its\n           Path messages have not\
    \ yet propagated to the receiver(s)).\n           Then the initial data may arrive\
    \ at receivers without the\n           desired QoS.  The sender could mitigate\
    \ this problem by\n           awaiting arrival of the first Resv message (H5);\
    \ however,\n           receivers that are farther away may not have reservations\
    \ in\n           place yet.\n      o    If a receiver starts sending Resv messages\
    \ (H4) before\n           receiving any Path messages (H3), RSVP will return error\n\
    \           messages to the receiver.\n           The receiver may simply choose\
    \ to ignore such error messages,\n           or it may avoid them by waiting for\
    \ Path messages before\n           sending Resv messages.\n      A specific application\
    \ program interface (API) for RSVP is not\n      defined in this protocol spec,\
    \ as it may be host system dependent.\n      However, Section 3.11.1 discusses\
    \ the general requirements and\n      outlines a generic interface.\n"
- title: 3. RSVP Functional Specification
  contents:
  - "3. RSVP Functional Specification\n   3.1 RSVP Message Formats\n      An RSVP\
    \ message consists of a common header, followed by a body\n      consisting of\
    \ a variable number of variable-length, typed\n      \"objects\".  The following\
    \ subsections define the formats of the\n      common header, the standard object\
    \ header, and each of the RSVP\n      message types.\n      For each RSVP message\
    \ type, there is a set of rules for the\n      permissible choice of object types.\
    \  These rules are specified\n      using Backus-Naur Form (BNF) augmented with\
    \ square brackets\n      surrounding optional sub-sequences.  The BNF implies\
    \ an order for\n      the objects in a message.  However, in many (but not all)\
    \ cases,\n      object order makes no logical difference.  An implementation\n\
    \      should create messages with the objects in the order shown here,\n    \
    \  but accept the objects in any permissible order.\n      3.1.1 Common Header\n\
    \                0             1              2             3\n         +-------------+-------------+-------------+-------------+\n\
    \         | Vers | Flags|  Msg Type   |       RSVP Checksum       |\n        \
    \ +-------------+-------------+-------------+-------------+\n         |  Send_TTL\
    \   | (Reserved)  |        RSVP Length        |\n         +-------------+-------------+-------------+-------------+\n\
    \         The fields in the common header are as follows:\n         Vers: 4 bits\n\
    \              Protocol version number.  This is version 1.\n         Flags: 4\
    \ bits\n              0x01-0x08: Reserved\n                   No flag bits are\
    \ defined yet.\n         Msg Type: 8 bits\n              1 = Path\n          \
    \    2 = Resv\n              3 = PathErr\n              4 = ResvErr\n        \
    \      5 = PathTear\n              6 = ResvTear\n              7 = ResvConf\n\
    \         RSVP Checksum: 16 bits\n              The one's complement of the one's\
    \ complement sum of the\n              message, with the checksum field replaced\
    \ by zero for the\n              purpose of computing the checksum.  An all-zero\
    \ value\n              means that no checksum was transmitted.\n         Send_TTL:\
    \ 8 bits\n              The IP TTL value with which the message was sent.  See\n\
    \              Section 3.8.\n         RSVP Length: 16 bits\n              The\
    \ total length of this RSVP message in bytes, including\n              the common\
    \ header and the variable-length objects that\n              follow.\n      3.1.2\
    \ Object Formats\n         Every object consists of one or more 32-bit words with\
    \ a one-\n         word header, with the following format:\n                0\
    \             1              2             3\n         +-------------+-------------+-------------+-------------+\n\
    \         |       Length (bytes)      |  Class-Num  |   C-Type    |\n        \
    \ +-------------+-------------+-------------+-------------+\n         |      \
    \                                                 |\n         //             \
    \     (Object contents)                   //\n         |                     \
    \                                  |\n         +-------------+-------------+-------------+-------------+\n\
    \         An object header has the following fields:\n         Length\n      \
    \        A 16-bit field containing the total object length in\n              bytes.\
    \  Must always be a multiple of 4, and at least 4.\n         Class-Num\n     \
    \         Identifies the object class; values of this field are\n            \
    \  defined in Appendix A.  Each object class has a name,\n              which\
    \ is always capitalized in this document.  An RSVP\n              implementation\
    \ must recognize the following classes:\n              NULL\n                \
    \   A NULL object has a Class-Num of zero, and its C-Type\n                  \
    \ is ignored.  Its length must be at least 4, but can\n                   be any\
    \ multiple of 4.  A NULL object may appear\n                   anywhere in a sequence\
    \ of objects, and its contents\n                   will be ignored by the receiver.\n\
    \              SESSION\n                   Contains the IP destination address\
    \ (DestAddress),\n                   the IP protocol id, and some form of generalized\n\
    \                   destination port, to define a specific session for\n     \
    \              the other objects that follow.  Required in every\n           \
    \        RSVP message.\n              RSVP_HOP\n                   Carries the\
    \ IP address of the RSVP-capable node that\n                   sent this message\
    \ and a logical outgoing interface\n                   handle (LIH; see Section\
    \ 3.3).  This document refers\n                   to a RSVP_HOP object as a PHOP\
    \ (\"previous hop\")\n                   object for downstream messages or as\
    \ a NHOP (\" next\n                   hop\") object for upstream messages.\n \
    \             TIME_VALUES\n                   Contains the value for the refresh\
    \ period R used by\n                   the creator of the message; see Section\
    \ 3.7.\n                   Required in every Path and Resv message.\n        \
    \      STYLE\n                   Defines the reservation style plus style-specific\n\
    \                   information that is not in FLOWSPEC or FILTER_SPEC\n     \
    \              objects.  Required in every Resv message.\n              FLOWSPEC\n\
    \                   Defines a desired QoS, in a Resv message.\n              FILTER_SPEC\n\
    \                   Defines a subset of session data packets that should\n   \
    \                receive the desired QoS (specified by a FLOWSPEC\n          \
    \         object), in a Resv message.\n              SENDER_TEMPLATE\n       \
    \            Contains a sender IP address and perhaps some\n                 \
    \  additional demultiplexing information to identify a\n                   sender.\
    \  Required in a Path message.\n              SENDER_TSPEC\n                 \
    \  Defines the traffic characteristics of a sender's\n                   data\
    \ flow.  Required in a Path message.\n              ADSPEC\n                 \
    \  Carries OPWA data, in a Path message.\n              ERROR_SPEC\n         \
    \          Specifies an error in a PathErr, ResvErr, or a\n                  \
    \ confirmation in a ResvConf message.\n              POLICY_DATA\n           \
    \        Carries information that will allow a local policy\n                \
    \   module to decide whether an associated reservation is\n                  \
    \ administratively permitted.  May appear in Path,\n                   Resv, PathErr,\
    \ or ResvErr message.\n                   The use of POLICY_DATA objects is not\
    \ fully specified\n                   at this time; a future document will fill\
    \ this gap.\n              INTEGRITY\n                   Carries cryptographic\
    \ data to authenticate the\n                   originating node and to verify\
    \ the contents of this\n                   RSVP message.  The use of the INTEGRITY\
    \ object is\n                   described in [Baker96].\n              SCOPE\n\
    \                   Carries an explicit list of sender hosts towards\n       \
    \            which the information in the message is to be\n                 \
    \  forwarded.  May appear in a Resv, ResvErr, or\n                   ResvTear\
    \ message.  See Section 3.4.\n              RESV_CONFIRM\n                   Carries\
    \ the IP address of a receiver that requested a\n                   confirmation.\
    \  May appear in a Resv or ResvConf\n                   message.\n         C-Type\n\
    \              Object type, unique within Class-Num.  Values are defined\n   \
    \           in Appendix A.\n         The maximum object content length is 65528\
    \ bytes.  The Class-\n         Num and C-Type fields may be used together as a\
    \ 16-bit number\n         to define a unique type for each object.\n         The\
    \ high-order two bits of the Class-Num is used to determine\n         what action\
    \ a node should take if it does not recognize the\n         Class-Num of an object;\
    \ see Section 3.10.\n      3.1.3 Path Messages\n         Each sender host periodically\
    \ sends a Path message for each\n         data flow it originates.  It contains\
    \ a SENDER_TEMPLATE object\n         defining the format of the data packets and\
    \ a SENDER_TSPEC\n         object specifying the traffic characteristics of the\
    \ flow.\n         Optionally, it may contain may be an ADSPEC object carrying\n\
    \         advertising (OPWA) data for the flow.\n         A Path message travels\
    \ from a sender to receiver(s) along the\n         same path(s) used by the data\
    \ packets.  The IP source address\n         of a Path message must be an address\
    \ of the sender it\n         describes, while the destination address must be\
    \ the\n         DestAddress for the session.  These addresses assure that the\n\
    \         message will be correctly routed through a non-RSVP cloud.\n       \
    \  The format of a Path message is as follows:\n           <Path Message> ::=\
    \ <Common Header> [ <INTEGRITY> ]\n                                     <SESSION>\
    \ <RSVP_HOP>\n                                     <TIME_VALUES>\n           \
    \                         [ <POLICY_DATA> ... ]\n                            \
    \        [ <sender descriptor> ]\n           <sender descriptor> ::= <SENDER_TEMPLATE>\
    \ <SENDER_TSPEC>\n                                    [ <ADSPEC> ]\n         If\
    \ the INTEGRITY object is present, it must immediately follow\n         the common\
    \ header.  There are no other requirements on\n         transmission order, although\
    \ the above order is recommended.\n         Any number of POLICY_DATA objects\
    \ may appear.\n         The PHOP (i.e., RSVP_HOP) object of each Path message\
    \ contains\n         the previous hop address, i.e., the IP address of the interface\n\
    \         through which the Path message was most recently sent.  It also\n  \
    \       carries a logical interface handle (LIH).\n         Each RSVP-capable\
    \ node along the path(s) captures a Path\n         message and processes it to\
    \ create path state for the sender\n         defined by the SENDER_TEMPLATE and\
    \ SESSION objects.  Any\n         POLICY_DATA, SENDER_TSPEC, and ADSPEC objects\
    \ are also saved in\n         the path state.  If an error is encountered while\
    \ processing a\n         Path message, a PathErr message is sent to the originating\n\
    \         sender of the Path message.  Path messages must satisfy the\n      \
    \   rules on SrcPort and DstPort in Section 3.2.\n         Periodically, the RSVP\
    \ process at a node scans the path state\n         to create new Path messages\
    \ to forward towards the receiver(s).\n         Each message contains a sender\
    \ descriptor defining one sender,\n         and carries the original sender's\
    \ IP address as its IP source\n         address.  Path messages eventually reach\
    \ the applications on\n         all receivers; however, they are not looped back\
    \ to a receiver\n         running in the same application process as the sender.\n\
    \         The RSVP process forwards Path messages and replicates them as\n   \
    \      required by multicast sessions, using routing information it\n        \
    \ obtains from the appropriate uni-/multicast routing process.\n         The route\
    \ depends upon the session DestAddress, and for some\n         routing protocols\
    \ also upon the source (sender's IP) address.\n         The routing information\
    \ generally includes the list of zero or\n         more outgoing interfaces to\
    \ which the Path message is to be\n         forwarded.  Because each outgoing\
    \ interface has a different IP\n         address, the Path messages sent out different\
    \ interfaces\n         contain different PHOP addresses.  In addition, ADSPEC\
    \ objects\n         carried in Path messages will also generally differ for\n\
    \         different outgoing interfaces.\n         Path state for a given session\
    \ and sender may not necessarily\n         have a unique PHOP or unique incoming\
    \ interface.  There are two\n         cases, corresponding to multicast and unicast\
    \ sessions.\n         o    Multicast Sessions\n              Multicast routing\
    \ allows a stable distribution tree in\n              which Path messages from\
    \ the same sender arrive from more\n              than one PHOP, and RSVP must\
    \ be prepared to maintain all\n              such path state.  The RSVP rules\
    \ for handling this\n              situation are contained in Section 3.9.  RSVP\
    \ must not\n              forward (according to the rules of Section 3.9) Path\n\
    \              messages that arrive on an incoming interface different\n     \
    \         from that provided by routing.\n         o    Unicast Sessions\n   \
    \           For a short period following a unicast route change\n            \
    \  upstream, a node may receive Path messages from multiple\n              PHOPs\
    \ for a given (session, sender) pair.  The node cannot\n              reliably\
    \ determine which is the right PHOP, although the\n              node will receive\
    \ data from only one of the PHOPs at a\n              time.  One implementation\
    \ choice for RSVP is to ignore\n              PHOP in matching unicast past state,\
    \ and allow the PHOP to\n              flip among the candidates.  Another implementation\
    \ choice\n              is to maintain path state for each PHOP and to send Resv\n\
    \              messages upstream towards all such PHOPs.  In either case,\n  \
    \            the situation is a transient; the unused path state will\n      \
    \        time out or be torn down (because upstream path state\n             \
    \ timed out).\n      3.1.4 Resv Messages\n         Resv messages carry reservation\
    \ requests hop-by-hop from\n         receivers to senders, along the reverse paths\
    \ of data flows for\n         the session.  The IP destination address of a Resv\
    \ message is\n         the unicast address of a previous-hop node, obtained from\
    \ the\n         path state.  The IP source address is an address of the node\n\
    \         that sent the message.\n         The Resv message format is as follows:\n\
    \           <Resv Message> ::= <Common Header> [ <INTEGRITY> ]\n             \
    \                      <SESSION>  <RSVP_HOP>\n                               \
    \    <TIME_VALUES>\n                                   [ <RESV_CONFIRM> ]  [ <SCOPE>\
    \ ]\n                                   [ <POLICY_DATA> ... ]\n              \
    \                     <STYLE> <flow descriptor list>\n           <flow descriptor\
    \ list> ::=  <empty> |\n                            <flow descriptor list> <flow\
    \ descriptor>\n         If the INTEGRITY object is present, it must immediately\
    \ follow\n         the common header.  The STYLE object followed by the flow\n\
    \         descriptor list must occur at the end of the message, and\n        \
    \ objects within the flow descriptor list must follow the BNF\n         given\
    \ below.  There are no other requirements on transmission\n         order, although\
    \ the above order is recommended.\n         The NHOP (i.e., the RSVP_HOP) object\
    \ contains the IP address of\n         the interface through which the Resv message\
    \ was sent and the\n         LIH for the logical interface on which the reservation\
    \ is\n         required.\n         The appearance of a RESV_CONFIRM object signals\
    \ a request for a\n         reservation confirmation and carries the IP address\
    \ of the\n         receiver to which the ResvConf should be sent.  Any number\
    \ of\n         POLICY_DATA objects may appear.\n         The BNF above defines\
    \ a flow descriptor list as simply a list\n         of flow descriptors.  The\
    \ following style-dependent rules\n         specify in more detail the composition\
    \ of a valid flow\n         descriptor list for each of the reservation styles.\n\
    \         o    WF Style:\n                <flow descriptor list> ::=  <WF flow\
    \ descriptor>\n                <WF flow descriptor> ::= <FLOWSPEC>\n         o\
    \    FF style:\n                <flow descriptor list> ::=\n                 \
    \         <FLOWSPEC>  <FILTER_SPEC>  |\n                          <flow descriptor\
    \ list> <FF flow descriptor>\n                <FF flow descriptor> ::=\n     \
    \                     [ <FLOWSPEC> ] <FILTER_SPEC>\n              Each elementary\
    \ FF style request is defined by a single\n              (FLOWSPEC, FILTER_SPEC)\
    \ pair, and multiple such requests\n              may be packed into the flow\
    \ descriptor list of a single\n              Resv message.  A FLOWSPEC object\
    \ can be omitted if it is\n              identical to the most recent such object\
    \ that appeared in\n              the list; the first FF flow descriptor must\
    \ contain a\n              FLOWSPEC.\n         o    SE style:\n              \
    \  <flow descriptor list> ::= <SE flow descriptor>\n                <SE flow descriptor>\
    \ ::=\n                                       <FLOWSPEC> <filter spec list>\n\
    \                <filter spec list> ::=  <FILTER_SPEC>\n                     \
    \             |  <filter spec list> <FILTER_SPEC>\n         The reservation scope,\
    \ i.e., the set of senders towards which a\n         particular reservation is\
    \ to be forwarded (after merging), is\n         determined as follows:\n     \
    \    o    Explicit sender selection\n              The reservation is forwarded\
    \ to all senders whose\n              SENDER_TEMPLATE objects recorded in the\
    \ path state match a\n              FILTER_SPEC object in the reservation.  This\
    \ match must\n              follow the rules of Section 3.2.\n         o    Wildcard\
    \ sender selection\n              A request with wildcard sender selection will\
    \ match all\n              senders that route to the given outgoing interface.\n\
    \              Whenever a Resv message with wildcard sender selection is\n   \
    \           forwarded to more than one previous hop, a SCOPE object\n        \
    \      must be included in the message (see Section 3.4 below);\n            \
    \  in this case, the scope for forwarding the reservation is\n              constrained\
    \ to just the sender IP addresses explicitly\n              listed in the SCOPE\
    \ object.\n              A Resv message that is forwarded by a node is generally\n\
    \              the result of merging a set of incoming Resv messages\n       \
    \       (that are not blockaded; see Section 3.5).  If one of\n              these\
    \ merged messages contains a RESV_CONFIRM object and\n              has a FLOWSPEC\
    \ larger than the FLOWSPECs of the other\n              merged reservation requests,\
    \ then this RESV_CONFIRM object\n              is forwarded in the outgoing Resv\
    \ message.  A RESV_CONFIRM\n              object in one of the other merged requests\
    \ (whose\n              flowspecs are equal to, smaller than, or incomparable\
    \ to,\n              the merged flowspec, and which is not blockaded) will\n \
    \             trigger the generation of an ResvConf message containing\n     \
    \         the RESV_CONFIRM.  A RESV_CONFIRM object in a request that\n       \
    \       is blockaded will be neither forwarded nor returned; it\n            \
    \  will be dropped in the current node.\n      3.1.5 Path Teardown Messages\n\
    \         Receipt of a PathTear (path teardown) message deletes matching\n   \
    \      path state.  Matching state must have match the SESSION,\n         SENDER_TEMPLATE,\
    \ and PHOP objects.  In addition, a PathTear\n         message for a multicast\
    \ session can only match path state for\n         the incoming interface on which\
    \ the PathTear arrived.  If there\n         is no matching path state, a PathTear\
    \ message should be\n         discarded and not forwarded.\n         PathTear\
    \ messages are initiated explicitly by senders or by\n         path state timeout\
    \ in any node, and they travel downstream\n         towards all receivers.  A\
    \ unicast PathTear must not be\n         forwarded if there is path state for\
    \ the same (session, sender)\n         pair but a different PHOP.  Forwarding\
    \ of multicast PathTear\n         messages is governed by the rules of Section\
    \ 3.9.\n         A PathTear message must be routed exactly like the\n        \
    \ corresponding Path message.  Therefore, its IP destination\n         address\
    \ must be the session DestAddress, and its IP source\n         address must be\
    \ the sender address from the path state being\n         torn down.\n        \
    \     <PathTear Message> ::= <Common Header> [ <INTEGRITY> ]\n               \
    \                          <SESSION> <RSVP_HOP>\n                            \
    \            [ <sender descriptor> ]\n             <sender descriptor> ::= (see\
    \ earlier definition)\n         A PathTear message may include a SENDER_TSPEC\
    \ or ADSPEC object\n         in its sender descriptor, but these must be ignored.\
    \  The order\n         requirements are as given earlier for a Path message, but\
    \ the\n         above order is recommended.\n         Deletion of path state as\
    \ the result of a PathTear message or a\n         timeout must also adjust related\
    \ reservation state as required\n         to maintain consistency in the local\
    \ node.  The adjustment\n         depends upon the reservation style.  For example,\
    \ suppose a\n         PathTear deletes the path state for a sender S.  If the\
    \ style\n         specifies explicit sender selection (FF or SE), any reservation\n\
    \         with a filter spec matching S should be deleted; if the style\n    \
    \     has wildcard sender selection (WF), the reservation should be\n        \
    \ deleted if S is the last sender to the session.  These\n         reservation\
    \ changes should not trigger an immediate Resv\n         refresh message, since\
    \ the PathTear message has already made\n         the required changes upstream.\
    \  They should not trigger a\n         ResvErr message, since the result could\
    \ be to generate a shower\n         of such messages.\n      3.1.6 Resv Teardown\
    \ Messages\n         Receipt of a ResvTear (reservation teardown) message deletes\n\
    \         matching reservation state.  Matching reservation state must\n     \
    \    match the SESSION, STYLE, and FILTER_SPEC objects as well as\n         the\
    \ LIH in the RSVP_HOP object.  If there is no matching\n         reservation state,\
    \ a ResvTear message should be discarded.  A\n         ResvTear message may tear\
    \ down any subset of the filter specs\n         in FF-style or SE-style reservation\
    \ state.\n         ResvTear messages are initiated explicitly by receivers or\
    \ by\n         any node in which reservation state has timed out, and they\n \
    \        travel upstream towards all matching senders.\n         A ResvTear message\
    \ must be routed like the corresponding Resv\n         message, and its IP destination\
    \ address will be the unicast\n         address of a previous hop.\n         \
    \    <ResvTear Message> ::= <Common Header> [<INTEGRITY>]\n                  \
    \                       <SESSION> <RSVP_HOP>\n                               \
    \          [ <SCOPE> ] <STYLE>\n                                         <flow\
    \ descriptor list>\n             <flow descriptor list> ::= (see earlier definition)\n\
    \         FLOWSPEC objects in the flow descriptor list of a ResvTear\n       \
    \  message will be ignored and may be omitted.  The order\n         requirements\
    \ for INTEGRITY object, sender descriptor, STYLE\n         object, and flow descriptor\
    \ list are as given earlier for a\n         Resv message, but the above order\
    \ is recommended.  A ResvTear\n         message may include a SCOPE object, but\
    \ it must be ignored.\n         A ResvTear message will cease to be forwarded\
    \ at the node where\n         merging would have suppressed forwarding of the\
    \ corresponding\n         Resv message.  Depending upon the resulting state change\
    \ in a\n         node, receipt of a ResvTear message may cause a ResvTear\n  \
    \       message to be forwarded, a modified Resv message to be\n         forwarded,\
    \ or no message to be forwarded.  These three cases\n         can be illustrated\
    \ in the case of the FF-style reservations\n         shown in Figure 6.\n    \
    \     o    If receiver R2 sends a ResvTear message for its\n              reservation\
    \ S3{B}, the corresponding reservation is\n              removed from interface\
    \ (d) and a ResvTear for S3{B} is\n              forwarded out (b).\n        \
    \ o    If receiver R1 sends a ResvTear for its reservation\n              S1{4B},\
    \ the corresponding reservation is removed from\n              interface (c) and\
    \ a modified Resv message FF( S1{3B} ) is\n              immediately forwarded\
    \ out (a).\n         o    If receiver R3 sends a ResvTear message for S1{B}, there\n\
    \              is no change in the effective reservation S1{3B} on (d)\n     \
    \         and no message is forwarded.\n      3.1.7 Path Error Messages\n    \
    \     PathErr (path error) messages report errors in processing Path\n       \
    \  messages.  They are travel upstream towards senders and are\n         routed\
    \ hop-by-hop using the path state.  At each hop, the IP\n         destination\
    \ address is the unicast address of a previous hop.\n         PathErr messages\
    \ do not modify the state of any node through\n         which they pass; they\
    \ are only reported to the sender\n         application.\n           <PathErr\
    \ message> ::= <Common Header> [ <INTEGRITY> ]\n                             \
    \         <SESSION> <ERROR_SPEC>\n                                      [ <POLICY_DATA>\
    \ ...]\n                                     [ <sender descriptor> ]\n       \
    \    <sender descriptor> ::= (see earlier definition)\n         The ERROR_SPEC\
    \ object specifies the error and includes the IP\n         address of the node\
    \ that detected the error (Error Node\n         Address).  One or more POLICY_DATA\
    \ objects may be included\n         message to provide relevant information. \
    \ The sender descriptor\n         is copied from the message in error.  The object\
    \ order\n         requirements are as given earlier for a Path message, but the\n\
    \         above order is recommended.\n      3.1.8 Resv Error Messages\n     \
    \    ResvErr (reservation error) messages report errors in\n         processing\
    \ Resv messages, or they may report the spontaneous\n         disruption of a\
    \ reservation, e.g., by administrative\n         preemption.\n         ResvErr\
    \ messages travel downstream towards the appropriate\n         receivers, routed\
    \ hop-by-hop using the reservation state.  At\n         each hop, the IP destination\
    \ address is the unicast address of\n         a next-hop node.\n           <ResvErr\
    \ Message> ::= <Common Header> [ <INTEGRITY> ]\n                             \
    \         <SESSION>  <RSVP_HOP>\n                                      <ERROR_SPEC>\
    \  [ <SCOPE> ]\n                                      [ <POLICY_DATA> ...]\n \
    \                                   <STYLE> [ <error flow descriptor> ]\n    \
    \     The ERROR_SPEC object specifies the error and includes the IP\n        \
    \ address of the node that detected the error (Error Node\n         Address).\
    \  One or more POLICY_DATA objects may be included in\n         an error message\
    \ to provide relevant information (e.g.,, when a\n         policy control error\
    \ is being reported).  The RSVP_HOP object\n         contains the previous hop\
    \ address, and the STYLE object is\n         copied from the Resv message in error.\
    \  The use of the SCOPE\n         object in a ResvErr message is defined below\
    \ in Section 3.4.\n         The object order requirements are as given for Resv\
    \ messages,\n         but the above order is recommended.\n         The following\
    \ style-dependent rules define the composition of a\n         valid error flow\
    \ descriptor; the object order requirements are\n         as given earlier for\
    \ flow descriptor.\n         o    WF Style:\n                  <error flow descriptor>\
    \ ::= <WF flow descriptor>\n         o    FF style:\n                  <error\
    \ flow descriptor> ::= <FF flow descriptor>\n              Each flow descriptor\
    \ in a FF-style Resv message must be\n              processed independently, and\
    \ a separate ResvErr message\n              must be generated for each one that\
    \ is in error.\n         o    SE style:\n                  <error flow descriptor>\
    \ ::= <SE flow descriptor>\n              An SE-style ResvErr message may list\
    \ the subset of the\n              filter specs in the corresponding Resv message\
    \ to which\n              the error applies.\n         Note that a ResvErr message\
    \ contains only one flow descriptor.\n         Therefore, a Resv message that\
    \ contains N > 1 flow descriptors\n         (FF style) may create up to N separate\
    \ ResvErr messages.\n         Generally speaking, a ResvErr message should be\
    \ forwarded\n         towards all receivers that may have caused the error being\n\
    \         reported.  More specifically:\n         o    The node that detects an\
    \ error in a reservation request\n              sends a ResvErr message to the\
    \ next hop node from which\n              the erroneous reservation came.\n  \
    \            This ResvErr message must contain the information required\n    \
    \          to define the error and to route the error message in\n           \
    \   later hops.  It therefore includes an ERROR_SPEC object, a\n             \
    \ copy of the STYLE object, and the appropriate error flow\n              descriptor.\
    \  If the error is an admission control failure\n              while attempting\
    \ to increase an existing reservation, then\n              the existing reservation\
    \ must be left in place and the\n              InPlace flag bit must be on in\
    \ the ERROR_SPEC of the\n              ResvErr message.\n         o    Succeeding\
    \ nodes forward the ResvErr message to next hops\n              that have local\
    \ reservation state.  For reservations with\n              wildcard scope, there\
    \ is an additional limitation on\n              forwarding ResvErr messages, to\
    \ avoid loops; see Section\n              3.4.  There is also a rule restricting\
    \ the forwarding of a\n              Resv message after an Admission Control failure;\
    \ see\n              Section 3.5.\n              A ResvErr message that is forwarded\
    \ should carry the\n              FILTER_SPEC(s) from the corresponding reservation\
    \ state.\n         o    When a ResvErr message reaches a receiver, the STYLE\n\
    \              object, flow descriptor list, and ERROR_SPEC object\n         \
    \     (including its flags) should be delivered to the receiver\n            \
    \  application.\n      3.1.9 Confirmation Messages\n         ResvConf messages\
    \ are sent to (probabilistically) acknowledge\n         reservation requests.\
    \  A ResvConf message is sent as the result\n         of the appearance of a RESV_CONFIRM\
    \ object in a Resv message.\n         A ResvConf message is sent to the unicast\
    \ address of a receiver\n         host; the address is obtained from the RESV_CONFIRM\
    \ object.\n         However, a ResvConf message is forwarded to the receiver hop-\n\
    \         by-hop, to accommodate the hop-by-hop integrity check\n         mechanism.\n\
    \           <ResvConf message> ::= <Common Header> [ <INTEGRITY> ]\n         \
    \                             <SESSION> <ERROR_SPEC>\n                       \
    \               <RESV_CONFIRM>\n                                      <STYLE>\
    \ <flow descriptor list>\n           <flow descriptor list> ::= (see earlier definition)\n\
    \         The object order requirements are the same as those given\n        \
    \ earlier for a Resv message, but the above order is recommended.\n         The\
    \ RESV_CONFIRM object is a copy of that object in the Resv\n         message that\
    \ triggered the confirmation.  The ERROR_SPEC is\n         used only to carry\
    \ the IP address of the originating node, in\n         the Error Node Address;\
    \ the Error Code and Value are zero to\n         indicate a confirmation.  The\
    \ flow descriptor list specifies\n         the particular reservations that are\
    \ being confirmed; it may be\n         a subset of flow descriptor list of the\
    \ Resv that requested the\n         confirmation.\n   3.2 Port Usage\n      An\
    \ RSVP session is normally defined by the triple: (DestAddress,\n      ProtocolId,\
    \ DstPort).  Here DstPort is a UDP/TCP destination port\n      field (i.e., a\
    \ 16-bit quantity carried at octet offset +2 in the\n      transport header).\
    \  DstPort may be omitted (set to zero) if the\n      ProtocolId specifies a protocol\
    \ that does not have a destination\n      port field in the format used by UDP\
    \ and TCP.\n      RSVP allows any value for ProtocolId.  However, end-system\n\
    \      implementations of RSVP may know about certain values for this\n      field,\
    \ and in particular the values for UDP and TCP (17 and 6,\n      respectively).\
    \  An end system may give an error to an application\n      that either:\n   \
    \   o    specifies a non-zero DstPort for a protocol that does not\n         \
    \  have UDP/TCP-like ports, or\n      o    specifies a zero DstPort for a protocol\
    \ that does have\n           UDP/TCP-like ports.\n      Filter specs and sender\
    \ templates specify the pair: (SrcAddress,\n      SrcPort), where SrcPort is a\
    \ UDP/TCP source port field (i.e., a\n      16-bit quantity carried at octet offset\
    \ +0 in the transport\n      header).   SrcPort may be omitted (set to zero) in\
    \ certain cases.\n      The following rules hold for the use of zero DstPort and/or\n\
    \      SrcPort fields in RSVP.\n      1.   Destination ports must be consistent.\n\
    \           Path state and reservation state for the same DestAddress and\n  \
    \         ProtocolId must each have DstPort values that are all zero or\n    \
    \       all non-zero.  Violation of this condition in a node is a\n          \
    \ \"Conflicting Dest Ports\" error.\n      2.   Destination ports rule.\n    \
    \       If DstPort in a session definition is zero, all SrcPort\n           fields\
    \ used for that session must also be zero.  The\n           assumption here is\
    \ that the protocol does not have UDP/TCP-\n           like ports.   Violation\
    \ of this condition in a node is a \"Bad\n           Src Ports\" error.\n    \
    \  3.   Source Ports must be consistent.\n           A sender host must not send\
    \ path state both with and without\n           a zero SrcPort.  Violation of this\
    \ condition is a\n           \"Conflicting Sender Port\" error.\n      Note that\
    \ RSVP has no \"wildcard\" ports, i.e., a zero port cannot\n      match a non-zero\
    \ port.\n   3.3 Sending RSVP Messages\n      RSVP messages are sent hop-by-hop\
    \ between RSVP-capable routers as\n      \"raw\" IP datagrams with protocol number\
    \ 46.  Raw IP datagrams are\n      also intended to be used between an end system\
    \ and the first/last\n      hop router, although it is also possible to encapsulate\
    \ RSVP\n      messages as UDP datagrams for end-system communication, as\n   \
    \   described in Appendix C.  UDP encapsulation is needed for systems\n      that\
    \ cannot do raw network I/O.\n      Path, PathTear, and ResvConf messages must\
    \ be sent with the Router\n      Alert IP option [RFC 2113] in their IP headers.\
    \  This option may\n      be used in the fast forwarding path of a high-speed\
    \ router to\n      detect datagrams that require special processing.\n      Upon\
    \ the arrival of an RSVP message M that changes the state, a\n      node must\
    \ forward the state modification immediately.  However,\n      this must not trigger\
    \ sending a message out the interface through\n      which M arrived (which could\
    \ happen if the implementation simply\n      triggered an immediate refresh of\
    \ all state for the session).\n      This rule is necessary to prevent packet\
    \ storms on broadcast LANs.\n      In this version of the spec, each RSVP message\
    \ must occupy exactly\n      one IP datagram.  If it exceeds the MTU, such a datagram\
    \ will be\n      fragmented by IP and reassembled at the recipient node.  This\
    \ has\n      several consequences:\n      o    A single RSVP message may not exceed\
    \ the maximum IP datagram\n           size, approximately 64K bytes.\n      o\
    \    A congested non-RSVP cloud could lose individual message\n           fragments,\
    \ and any lost fragment will lose the entire\n           message.\n      Future\
    \ versions of the protocol will provide solutions for these\n      problems if\
    \ they prove burdensome.  The most likely direction will\n      be to perform\
    \ \"semantic fragmentation\", i.e., break the path or\n      reservation state\
    \ being transmitted into multiple self-contained\n      messages, each of an acceptable\
    \ size.\n      RSVP uses its periodic refresh mechanisms to recover from\n   \
    \   occasional packet losses.  Under network overload, however,\n      substantial\
    \ losses of RSVP messages could cause a failure of\n      resource reservations.\
    \  To control the queuing delay and dropping\n      of RSVP packets, routers should\
    \ be configured to offer them a\n      preferred class of service.  If RSVP packets\
    \ experience noticeable\n      losses when crossing a congested non-RSVP cloud,\
    \ a larger value\n      can be used for the timeout factor K (see section 3.7).\n\
    \      Some multicast routing protocols provide for \"multicast tunnels\",\n \
    \     which do IP encapsulation of multicast packets for transmission\n      through\
    \ routers that do not have multicast capability.  A\n      multicast tunnel looks\
    \ like a logical outgoing interface that is\n      mapped into some physical interface.\
    \  A multicast routing protocol\n      that supports tunnels will describe a route\
    \ using a list of\n      logical rather than physical interfaces.  RSVP can operate\
    \ across\n      such multicast tunnels in the following manner:\n      1.   When\
    \ a node N forwards a Path message out a logical outgoing\n           interface\
    \ L, it includes in the message some encoding of the\n           identity of L,\
    \ called the \"logical interface handle\" or LIH.\n           The LIH value is\
    \ carried in the RSVP_HOP object.\n      2.   The next hop node N' stores the\
    \ LIH value in its path state.\n      3.   When N' sends a Resv message to N,\
    \ it includes the LIH value\n           from the path state (again, in the RSVP_HOP\
    \ object).\n      4.   When the Resv message arrives at N, its LIH value provides\n\
    \           the information necessary to attach the reservation to the\n     \
    \      appropriate logical interface.  Note that N creates and\n           interprets\
    \ the LIH; it is an opaque value to N'.\n      Note that this only solves the\
    \ routing problem posed by tunnels.\n      The tunnel appears to RSVP as a non-RSVP\
    \ cloud.  To establish RSVP\n      reservations within the tunnel, additional\
    \ machinery will be\n      required, to be defined in the future.\n   3.4 Avoiding\
    \ RSVP Message Loops\n      Forwarding of RSVP messages must avoid looping.  In\
    \ steady state,\n      Path and Resv messages are forwarded on each hop only once\
    \ per\n      refresh period.  This avoids looping packets, but there is still\n\
    \      the possibility of an \"auto-refresh\" loop, clocked by the refresh\n \
    \     period.  Such auto-refresh loops keep state active \"forever\", even\n \
    \     if the end nodes have ceased refreshing it, until the receivers\n      leave\
    \ the multicast group and/or the senders stop sending Path\n      messages.  On\
    \ the other hand, error and teardown messages are\n      forwarded immediately\
    \ and are therefore subject to direct looping.\n      Consider each message type.\n\
    \      o    Path Messages\n           Path messages are forwarded in exactly the\
    \ same way as IP\n           data packets.  Therefore there should be no loops\
    \ of Path\n           messages (except perhaps for transient routing loops, which\n\
    \           we ignore here), even in a topology with cycles.\n      o    PathTear\
    \ Messages\n           PathTear messages use the same routing as Path messages\
    \ and\n           therefore cannot loop.\n      o    PathErr Messages\n      \
    \     Since Path messages do not loop, they create path state\n           defining\
    \ a loop-free reverse path to each sender.  PathErr\n           messages are always\
    \ directed to particular senders and\n           therefore cannot loop.\n    \
    \  o    Resv Messages\n           Resv messages directed to particular senders\
    \ (i.e., with\n           explicit sender selection) cannot loop.  However, Resv\n\
    \           messages with wildcard sender selection (WF style) have a\n      \
    \     potential for auto-refresh looping.\n      o    ResvTear Messages\n    \
    \       Although ResvTear messages are routed the same as Resv\n           messages,\
    \ during the second pass around a loop there will be\n           no state so any\
    \ ResvTear message will be dropped.  Hence\n           there is no looping problem\
    \ here.\n      o    ResvErr Messages\n           ResvErr messages for WF style\
    \ reservations may loop for\n           essentially the same reasons that Resv\
    \ messages loop.\n      o    ResvConf Messages\n           ResvConf messages are\
    \ forwarded towards a fixed unicast\n           receiver address and cannot loop.\n\
    \      If the topology has no loops, then looping of Resv and ResvErr\n      messages\
    \ with wildcard sender selection can be avoided by simply\n      enforcing the\
    \ rule given earlier: state that is received through a\n      particular interface\
    \ must never be forwarded out the same\n      interface.  However, when the topology\
    \ does have cycles, further\n      effort is needed to prevent auto-refresh loops\
    \ of wildcard Resv\n      messages and fast loops of wildcard ResvErr messages.\
    \  The\n      solution to this problem adopted by this protocol specification\
    \ is\n      for such messages to carry an explicit sender address list in a\n\
    \      SCOPE object.\n      When a Resv message with WF style is to be forwarded\
    \ to a\n      particular previous hop, a new SCOPE object is computed from the\n\
    \      SCOPE objects that were received in matching Resv messages.  If\n     \
    \ the computed SCOPE object is empty, the message is not forwarded\n      to the\
    \ previous hop; otherwise, the message is sent containing the\n      new SCOPE\
    \ object.  The rules for computing a new SCOPE object for\n      a Resv message\
    \ are as follows:\n      1.   The union is formed of the sets of sender IP addresses\
    \ listed\n           in all SCOPE objects in the reservation state for the given\n\
    \           session.\n           If reservation state from some NHOP does not\
    \ contain a SCOPE\n           object, a substitute sender list must be created\
    \ and included\n           in the union.  For a message that arrived on outgoing\n\
    \           interface OI, the substitute list is the set of senders that\n   \
    \        route to OI.\n      2.   Any local senders (i.e., any sender applications\
    \ on this\n           node) are removed from this set.\n      3.   If the SCOPE\
    \ object is to be sent to PHOP, remove from the\n           set any senders that\
    \ did not come from PHOP.\n      Figure 11 shows an example of wildcard-scoped\
    \ (WF style) Resv\n      messages.  The address lists within SCOPE objects are\
    \ shown in\n      square brackets.  Note that there may be additional connections\n\
    \      among the nodes, creating looping topology that is not shown.\n       \
    \                  ________________\n                      a |               \
    \ | c\n           R4, S4<----->|     Router     |<-----> R2, S2, S3\n        \
    \                |                |\n                      b |               \
    \ |\n           R1, S1<----->|                |\n                        |________________|\n\
    \          Send on (a):           |    Receive on (c):\n                     \
    \            |\n             <-- WF( [S4] )      |       <-- WF( [S4, S1])\n \
    \                                |\n          Send on (b):           |\n     \
    \                            |\n             <-- WF( [S1] )      |\n         \
    \                        |\n          Receive on (a):        |    Send on (c):\n\
    \                                 |\n             WF( [S1,S2,S3]) --> |      \
    \ WF( [S2, S3]) -->\n                                 |\n          Receive on\
    \ (b):        |\n                                 |\n             WF( [S2,S3,S4])\
    \ --> |\n                                 |\n           Figure 11: SCOPE Objects\
    \ in Wildcard-Scope Reservations\n      SCOPE objects are not necessary if the\
    \ multicast routing uses\n      shared trees or if the reservation style has explicit\
    \ sender\n      selection.  Furthermore, attaching a SCOPE object to a reservation\n\
    \      should be deferred to a node which has more than one previous hop\n   \
    \   for the reservation state.\n      The following rules are used for SCOPE objects\
    \ in ResvErr messages\n      with WF style:\n      1.   The node that detected\
    \ the error initiates an ResvErr message\n           containing a copy of the\
    \ SCOPE object associated with the\n           reservation state or message in\
    \ error.\n      2.   Suppose a wildcard-style ResvErr message arrives at a node\n\
    \           with a SCOPE object containing the sender host address list\n    \
    \       L.  The node forwards the ResvErr message using the rules of\n       \
    \    Section 3.1.8.  However,\n           the ResvErr message forwarded out OI\
    \ must contain a SCOPE\n           object derived from L by including only those\
    \ senders that\n           route to OI.  If this SCOPE object is empty, the ResvErr\n\
    \           message should not be sent out OI.\n   3.5 Blockade State\n      The\
    \ basic rule for creating a Resv refresh message is to merge the\n      flowspecs\
    \ of the reservation requests in place in the node, by\n      computing their\
    \ LUB.  However, this rule is modified by the\n      existence of \"blockade state\"\
    \ resulting from ResvErr messages, to\n      solve the KR-II problem (see Section\
    \ 2.5).  The blockade state\n      also enters into the routing of ResvErr messages\
    \ for Admission\n      Control failure.\n      When a ResvErr message for an Admission\
    \ Control failure is\n      received, its flowspec Qe is used to create or refresh\
    \ an element\n      of local blockade state.  Each element of blockade state consists\n\
    \      of a blockade flowspec Qb taken from the flowspec of the ResvErr\n    \
    \  message, and an associated blockade timer Tb.  When a blockade\n      timer\
    \ expires, the corresponding blockade state is deleted.\n      The granularity\
    \ of blockade state depends upon the style of the\n      ResvErr message that\
    \ created it.  For an explicit style, there may\n      be a blockade state element\
    \ (Qb(S),Tb(S)) for each sender S.  For\n      a wildcard style, blockade state\
    \ is per previous hop P.\n      An element of blockade state with flowspec Qb\
    \ is said to\n      \"blockade\" a reservation with flowspec Qi if Qb is not (strictly)\n\
    \      greater than Qi.  For example, suppose that the LUB of two\n      flowspecs\
    \ is computed by taking the max of each of their\n      corresponding components.\
    \  Then Qb blockades Qi if for some\n      component j, Qb[j] <= Qi[j].\n    \
    \  Suppose that a node receives a ResvErr message from previous hop P\n      (or,\
    \ if style is explicit, sender S) as the result of an Admission\n      Control\
    \ failure upstream.  Then:\n      1.   An element of blockade state is created\
    \ for P (or S) if it\n           did not exist.\n      2.   Qb(P) (or Qb(S)) is\
    \ set equal to the flowspec Qe from the\n           ResvErr message.\n      3.\
    \   A corresponding blockade timer Tb(P) (or Tb(S)) is started or\n          \
    \ restarted for a time Kb*R.  Here Kb is a fixed multiplier and\n           R\
    \ is the refresh interval for reservation state.  Kb should\n           be configurable.\n\
    \      4.   If there is some local reservation state that is not\n           blockaded\
    \ (see below), an immediate reservation refresh for P\n           (or S) is generated.\n\
    \      5.   The ResvErr message is forwarded to next hops in the\n           following\
    \ way.  If the InPlace bit is off, the ResvErr\n           message is forwarded\
    \ to all next hops for which there is\n           reservation state.  If the InPlace\
    \ bit is on, the ResvErr\n           message is forwarded only to the next hops\
    \ whose Qi is\n           blockaded by Qb.\n      Finally, we present the modified\
    \ rule for merging flowspecs to\n      create a reservation refresh message.\n\
    \      o    If there are any local reservation requests Qi that are not\n    \
    \       blockaded, these are merged by computing their LUB.  The\n           blockaded\
    \ reservations are ignored; this allows forwarding of\n           a smaller reservation\
    \ that has not failed and may perhaps\n           succeed, after a larger reservation\
    \ fails.\n      o    Otherwise (all local requests Qi are blockaded), they are\n\
    \           merged by taking the GLB (Greatest Lower Bound) of the Qi's.\n   \
    \        (The use of some definition of \"minimum\" improves performance\n   \
    \        by bracketing the failure level between the largest that\n          \
    \ succeeds and the smallest that fails.  The choice of GLB in\n           particular\
    \ was made because it is simple to define and\n           implement, and no reason\
    \ is known for using a different\n           definition of \"minimum\" here).\n\
    \      This refresh merging algorithm is applied separately to each flow\n   \
    \   (each sender or PHOP) contributing to a shared reservation (WF or\n      SE\
    \ style).\n      Figure 12 shows an example of the the application of blockade\n\
    \      state for a shared reservation (WF style).  There are two previous\n  \
    \    hops labeled (a) and (b), and two next hops labeled (c) and (d).\n      The\
    \ larger reservation 4B arrived from (c) first, but it failed\n      somewhere\
    \ upstream via PHOP (a), but not via PHOP (b).  The\n      figures show the final\
    \ \"steady state\" after the smaller\n      reservation 2B subsequently arrived\
    \ from (d).  This steady state\n      is perturbed roughly every Kb*R seconds,\
    \ when the blockade state\n      times out.  The next refresh then sends 4B to\
    \ previous hop (a);\n      presumably this will fail, sending a ResvErr message\
    \ that will\n      re-establish the blockade state, returning to the situation\
    \ shown\n      in the figure.  At the same time, the ResvErr message will be\n\
    \      forwarded to next hop (c) and to all receivers downstream\n      responsible\
    \ for the 4B reservations.\n               Send     Blockade |   Reserve     \
    \  Receive\n                       State {Qb}|\n                             \
    \    |   ________\n        (a) <- WF(*{2B})    {4B} |  | * {4B} | WF(*{4B}) <-\
    \ (c)\n                                 |  |________|\n                      \
    \           |\n      ---------------------------|-------------------------------\n\
    \                                 |\n                                 |   ________\n\
    \        (b) <- WF(*{4B})   (none)|  | * {2B} | WF(*{2B}) <- (d)\n           \
    \                      |  |________|\n                   Figure 12: Blockading\
    \ with Shared Style\n   3.6 Local Repair\n      When a route changes, the next\
    \ Path or Resv refresh message will\n      establish path or reservation state\
    \ (respectively) along the new\n      route.  To provide fast adaptation to routing\
    \ changes without the\n      overhead of short refresh periods, the local routing\
    \ protocol\n      module can notify the RSVP process of route changes for particular\n\
    \      destinations.  The RSVP process should use this information to\n      trigger\
    \ a quick refresh of state for these destinations, using the\n      new route.\n\
    \      The specific rules are as follows:\n      o    When routing detects a change\
    \ of the set of outgoing\n           interfaces for destination G, RSVP should\
    \ update the path\n           state, wait for a short period W, and then send\
    \ Path\n           refreshes for all sessions G/* (i.e., for any session with\n\
    \           destination G, regardless of destination port).\n           The short\
    \ wait period before sending Path refreshes is to\n           allow the routing\
    \ protocol to settle, and the value for W\n           should be chosen accordingly.\
    \  Currently W = 2 sec is\n           suggested; however, this value should be\
    \ configurable per\n           interface.\n      o    When a Path message arrives\
    \ with a Previous Hop address that\n           differs from the one stored in\
    \ the path state, RSVP should\n           send immediate Resv refreshes to that\
    \ PHOP.\n   3.7 Time Parameters\n      There are two time parameters relevant\
    \ to each element of RSVP\n      path or reservation state in a node: the refresh\
    \ period R between\n      generation of successive refreshes for the state by\
    \ the neighbor\n      node, and the local state's lifetime L.  Each RSVP Resv\
    \ or Path\n      message may contain a TIME_VALUES object specifying the R value\n\
    \      that was used to generate this (refresh) message.  This R value is\n  \
    \    then used to determine the value for L when the state is received\n     \
    \ and stored.  The values for R and L may vary from hop to hop.\n      In more\
    \ detail:\n      1.   Floyd and Jacobson [FJ94] have shown that periodic messages\n\
    \           generated by independent network nodes can become\n           synchronized.\
    \  This can lead to disruption in network\n           services as the periodic\
    \ messages contend with other network\n           traffic for link and forwarding\
    \ resources.  Since RSVP sends\n           periodic refresh messages, it must\
    \ avoid message\n           synchronization and ensure that any synchronization\
    \ that may\n           occur is not stable.\n           For this reason, the refresh\
    \ timer should be randomly set to\n           a value in the range [0.5R, 1.5R].\n\
    \      2.   To avoid premature loss of state, L must satisfy L >= (K +\n     \
    \      0.5)*1.5*R, where K is a small integer.  Then in the worst\n          \
    \ case, K-1 successive messages may be lost without state being\n           deleted.\
    \  To compute a lifetime L for a collection of state\n           with different\
    \ R values R0, R1, ..., replace R by max(Ri).\n           Currently K = 3 is suggested\
    \ as the default.  However, it may\n           be necessary to set a larger K\
    \ value for hops with high loss\n           rate.  K may be set either by manual\
    \ configuration per\n           interface, or by some adaptive technique that\
    \ has not yet\n           been specified.\n      3.   Each Path or Resv message\
    \ carries a TIME_VALUES object\n           containing the refresh time R used\
    \ to generate refreshes.\n           The recipient node uses this R to determine\
    \ the lifetime L of\n           the stored state created or refreshed by the message.\n\
    \      4.   The refresh time R is chosen locally by each node.  If the\n     \
    \      node does not implement local repair of reservations\n           disrupted\
    \ by route changes, a smaller R speeds up adaptation\n           to routing changes,\
    \ while increasing the RSVP overhead.  With\n           local repair, a router\
    \ can be more relaxed about R since the\n           periodic refresh becomes only\
    \ a backstop robustness\n           mechanism.  A node may therefore adjust the\
    \ effective R\n           dynamically to control the amount of overhead due to\
    \ refresh\n           messages.\n           The current suggested default for\
    \ R is 30 seconds.  However,\n           the default value Rdef should be configurable\
    \ per interface.\n      5.   When R is changed dynamically, there is a limit on\
    \ how fast\n           it may increase.  Specifically, the ratio of two successive\n\
    \           values R2/R1 must not exceed 1 + Slew.Max.\n           Currently,\
    \ Slew.Max is 0.30.  With K = 3, one packet may be\n           lost without state\
    \ timeout while R is increasing 30 percent\n           per refresh cycle.\n  \
    \    6.   To improve robustness, a node may temporarily send refreshes\n     \
    \      more often than R after a state change (including initial\n           state\
    \ establishment).\n      7.   The values of Rdef, K, and Slew.Max used in an implementation\n\
    \           should be easily modifiable per interface, as experience may\n   \
    \        lead to different values.  The possibility of dynamically\n         \
    \  adapting K and/or Slew.Max in response to measured loss rates\n           is\
    \ for future study.\n   3.8 Traffic Policing and Non-Integrated Service Hops\n\
    \      Some QoS services may require traffic policing at some or all of\n    \
    \  (1) the edge of the network, (2) a merging point for data from\n      multiple\
    \ senders, and/or (3) a branch point where traffic flow\n      from upstream may\
    \ be greater than the downstream reservation being\n      requested.  RSVP knows\
    \ where such points occur and must so\n      indicate to the traffic control mechanism.\
    \  On the other hand,\n      RSVP does not interpret the service embodied in the\
    \ flowspec and\n      therefore does not know whether policing will actually be\
    \ applied\n      in any particular case.\n      The RSVP process passes to traffic\
    \ control a separate policing\n      flag for each of these three situations.\n\
    \      o    E_Police_Flag -- Entry Policing\n           This flag is set in the\
    \ first-hop RSVP node that implements\n           traffic control (and is therefore\
    \ capable of policing).\n           For example, sender hosts must implement RSVP\
    \ but currently\n           many of them do not implement traffic control.  In\
    \ this case,\n           the E_Police_Flag should be off in the sender host, and\
    \ it\n           should only be set on when the first node capable of traffic\n\
    \           control is reached.  This is controlled by the E_Police flag\n   \
    \        in SESSION objects.\n      o    M_Police_Flag -- Merge Policing\n   \
    \        This flag should be set on for a reservation using a shared\n       \
    \    style (WF or SE) when flows from more than one sender are\n           being\
    \ merged.\n      o    B_Police_Flag -- Branch Policing\n           This flag should\
    \ be set on when the flowspec being installed\n           is smaller than, or\
    \ incomparable to, a FLOWSPEC in place on\n           any other interface, for\
    \ the same FILTER_SPEC and SESSION.\n      RSVP must also test for the presence\
    \ of non-RSVP hops in the path\n      and pass this information to traffic control.\
    \  From this flag bit\n      that the RSVP process supplies and from its own local\
    \ knowledge,\n      traffic control can detect the presence of a hop in the path\
    \ that\n      is not capable of QoS control, and it passes this information to\n\
    \      the receivers in Adspecs [RFC 2210].\n      With normal IP forwarding,\
    \ RSVP can detect a non-RSVP hop by\n      comparing the IP TTL with which a Path\
    \ message is sent to the TTL\n      with which it is received; for this purpose,\
    \ the transmission TTL\n      is placed in the common header.  However, the TTL\
    \ is not always a\n      reliable indicator of non-RSVP hops, and other means\
    \ must\n      sometimes be used.  For example, if the routing protocol uses IP\n\
    \      encapsulating tunnels, then the routing protocol must inform RSVP\n   \
    \   when non-RSVP hops are included.  If no automatic mechanism will\n      work,\
    \ manual configuration will be required.\n   3.9 Multihomed Hosts\n      Accommodating\
    \ multihomed hosts requires some special rules in\n      RSVP.  We use the term\
    \ `multihomed host' to cover both hosts (end\n      systems) with more than one\
    \ network interface and routers that are\n      supporting local application programs.\n\
    \      An application executing on a multihomed host may explicitly\n      specify\
    \ which interface any given flow will use for sending and/or\n      for receiving\
    \ data packets, to override the system-specified\n      default interface.  The\
    \ RSVP process must be aware of the default,\n      and if an application sets\
    \ a specific interface, it must also pass\n      that information to RSVP.\n \
    \     o    Sending Data\n           A sender application uses an API call (SENDER\
    \ in Section\n           3.11.1) to declare to RSVP the characteristics of the\
    \ data\n           flow it will originate.  This call may optionally include the\n\
    \           local IP address of the sender. If it is set by the\n           application,\
    \ this parameter must be the interface address for\n           sending the data\
    \ packets; otherwise, the system default\n           interface is implied.\n \
    \          The RSVP process on the host then sends Path messages for\n       \
    \    this application out the specified interface (only).\n      o    Making Reservations\n\
    \           A receiver application uses an API call (RESERVE in Section\n    \
    \       3.11.1) to request a reservation from RSVP.  This call may\n         \
    \  optionally include the local IP address of the receiver,\n           i.e.,\
    \ the interface address for receiving data packets.  In\n           the case of\
    \ multicast sessions, this is the interface on\n           which the group has\
    \ been joined.  If the parameter is\n           omitted, the system default interface\
    \ is used.\n           In general, the RSVP process should send Resv messages\
    \ for an\n           application out the specified interface.  However, when the\n\
    \           application is executing on a router and the session is\n        \
    \   multicast, a more complex situation arises.   Suppose in this\n          \
    \ case that a receiver application joins the group on an\n           interface\
    \ Iapp that differs from Isp, the shortest-path\n           interface to the sender.\
    \  Then there are two possible ways\n           for multicast routing to deliver\
    \ data packets to the\n           application.  The RSVP process must determine\
    \ which case\n           holds by examining the path state, to decide which incoming\n\
    \           interface to use for sending Resv messages.\n           1.   The multicast\
    \ routing protocol may create a separate\n                branch of the multicast\
    \ distribution `tree' to deliver\n                to Iapp.  In this case, there\
    \ will be path state for\n                both interfaces Isp and Iapp.  The path\
    \ state on Iapp\n                should only match a reservation from the local\n\
    \                application; it must be marked \"Local_only\" by the RSVP\n \
    \               process.  If \"Local_only\" path state for Iapp exists,\n    \
    \            the Resv message should be sent out Iapp.\n                Note that\
    \ it is possible for the path state blocks for\n                Isp and Iapp to\
    \ have the same next hop, if there is an\n                intervening non-RSVP\
    \ cloud.\n           2.   The multicast routing protocol may forward data within\n\
    \                the router from Isp to Iapp.  In this case, Iapp will\n     \
    \           appear in the list of outgoing interfaces of the path\n          \
    \      state for Isp, and the Resv message should be sent out\n              \
    \  Isp.\n           3.   When Path and PathTear messages are forwarded, path\n\
    \                state marked \"Local_Only\" must be ignored.\n   3.10 Future\
    \ Compatibility\n      We may expect that in the future new object C-Types will\
    \ be\n      defined for existing object classes, and perhaps new object\n    \
    \  classes will be defined.  It will be desirable to employ such new\n      objects\
    \ within the Internet using older implementations that do\n      not recognize\
    \ them.  Unfortunately, this is only possible to a\n      limited degree with\
    \ reasonable complexity.  The rules are as\n      follows (`b' represents a bit).\n\
    \      1.   Unknown Class\n           There are three possible ways that an RSVP\
    \ implementation can\n           treat an object with unknown class.  This choice\
    \ is\n           determined by the two high-order bits of the Class-Num octet,\n\
    \           as follows.\n           o    Class-Num = 0bbbbbbb\n              \
    \  The entire message should be rejected and an \"Unknown\n                Object\
    \ Class\" error returned.\n           o    Class-Num = 10bbbbbb\n            \
    \    The node should ignore the object, neither forwarding it\n              \
    \  nor sending an error message.\n           o    Class-Num = 11bbbbbb\n     \
    \           The node should ignore the object but forward it,\n              \
    \  unexamined and unmodified, in all messages resulting\n                from\
    \ this message.\n           The following more detailed rules hold for unknown-class\n\
    \           objects with a Class-Num of the form 11bbbbbb:\n           1.   Such\
    \ unknown-class objects received in PathTear,\n                ResvTear, PathErr,\
    \ or ResvErr messages should be\n                forwarded immediately in the\
    \ same messages.\n           2.   Such unknown-class objects received in Path\
    \ or Resv\n                messages should be saved with the corresponding state\n\
    \                and forwarded in any refresh message resulting from that\n  \
    \              state.\n           3.   When a Resv refresh is generated by merging\
    \ multiple\n                reservation requests, the refresh message should include\n\
    \                the union of unknown-class objects from the component\n     \
    \           requests.  Only one copy of each unique unknown-class\n          \
    \      object should be included in this union.\n           4.   The original\
    \ order of such unknown-class objects need\n                not be retained; however,\
    \ the message that is forwarded\n                must obey the general order requirements\
    \ for its message\n                type.\n           Although objects with unknown\
    \ class cannot be merged, these\n           rules will forward such objects until\
    \ they reach a node that\n           knows how to merge them.  Forwarding objects\
    \ with unknown\n           class enables incremental deployment of new objects;\
    \ however,\n           the scaling limitations of doing so must be carefully\n\
    \           examined before a new object class is deployed with both high\n  \
    \         bits on.\n      2.   Unknown C-Type for Known Class\n           One\
    \ might expect the known Class-Num to provide information\n           that could\
    \ allow intelligent handling of such an object.\n           However, in practice\
    \ such class-dependent handling is\n           complex, and in many cases it is\
    \ not useful.\n           Generally, the appearance of an object with unknown\
    \ C-Type\n           should result in rejection of the entire message and\n  \
    \         generation of an error message (ResvErr or PathErr as\n           appropriate).\
    \  The error message will include the Class-Num\n           and C-Type that failed\
    \ (see Appendix B); the end system that\n           originated the failed message\
    \ may be able to use this\n           information to retry the request using a\
    \ different C-Type\n           object, repeating this process until it runs out\
    \ of\n           alternatives or succeeds.\n           Objects of certain classes\
    \ (FLOWSPEC, ADSPEC, and\n           POLICY_DATA) are opaque to RSVP, which simply\
    \ hands them to\n           traffic control or policy modules.  Depending upon\
    \ its\n           internal rules, either of the latter modules may reject a C-\n\
    \           Type and inform the RSVP process; RSVP should then reject the\n  \
    \         message and send an error, as described in the previous\n          \
    \ paragraph.\n   3.11 RSVP Interfaces\n      RSVP on a router has interfaces to\
    \ routing and to traffic control.\n      RSVP on a host has an interface to applications\
    \ (i.e, an API) and\n      also an interface to traffic control (if it exists\
    \ on the host).\n      3.11.1 Application/RSVP Interface\n         This section\
    \ describes a generic interface between an\n         application and an RSVP control\
    \ process.  The details of a real\n         interface may be operating-system\
    \ dependent; the following can\n         only suggest the basic functions to be\
    \ performed.  Some of\n         these calls cause information to be returned asynchronously.\n\
    \         o    Register Session\n              Call: SESSION( DestAddress , ProtocolId,\
    \ DstPort\n                         [ , SESSION_object ]\n                   \
    \      [ , Upcall_Proc_addr ] )  -> Session-id\n              This call initiates\
    \ RSVP processing for a session, defined\n              by DestAddress together\
    \ with ProtocolId and possibly a\n              port number DstPort.  If successful,\
    \ the SESSION call\n              returns immediately with a local session identifier\n\
    \              Session-id, which may be used in subsequent calls.\n          \
    \    The Upcall_Proc_addr parameter defines the address of an\n              upcall\
    \ procedure to receive asynchronous error or event\n              notification;\
    \ see below.  The SESSION_object parameter is\n              included as an escape\
    \ mechanism to support some more\n              general definition of the session\
    \ (\"generalized\n              destination port\"), should that be necessary\
    \ in the\n              future.  Normally SESSION_object will be omitted.\n  \
    \       o    Define Sender\n              Call: SENDER( Session-id\n         \
    \                [ , Source_Address ]  [ , Source_Port ]\n                   \
    \      [ , Sender_Template ]\n                         [ , Sender_Tspec ]    [\
    \ , Adspec ]\n                         [ , Data_TTL ]        [ , Policy_data ]\
    \ )\n              A sender uses this call to define, or to modify the\n     \
    \         definition of, the attributes of the data flow.  The first\n       \
    \       SENDER call for the session registered as `Session-id'\n             \
    \ will cause RSVP to begin sending Path messages for this\n              session;\
    \ later calls will modify the path information.\n              The SENDER parameters\
    \ are interpreted as follows:\n              -    Source_Address\n           \
    \        This is the address of the interface from which the\n               \
    \    data will be sent.  If it is omitted, a default\n                   interface\
    \ will be used.  This parameter is needed\n                   only on a multihomed\
    \ sender host.\n              -    Source_Port\n                   This is the\
    \ UDP/TCP port from which the data will be\n                   sent.\n       \
    \       -    Sender_Template\n                   This parameter is included as\
    \ an escape mechanism to\n                   support a more general definition\
    \ of the sender\n                   (\"generalized source port\").  Normally this\
    \ parameter\n                   may be omitted.\n              -    Sender_Tspec\n\
    \                   This parameter describes the traffic flow to be sent;\n  \
    \                 see [RFC 2210].\n              -    Adspec\n               \
    \    This parameter may be specified to initialize the\n                   computation\
    \ of QoS properties along the path; see\n                   [RFC 2210].\n    \
    \          -    Data_TTL\n                   This is the (non-default) IP Time-To-Live\
    \ parameter\n                   that is being supplied on the data packets.  It\
    \ is\n                   needed to ensure that Path messages do not have a\n \
    \                  scope larger than multicast data packets.\n              -\
    \    Policy_data\n                   This optional parameter passes policy data\
    \ for the\n                   sender.  This data may be supplied by a system\n\
    \                   service, with the application treating it as opaque.\n   \
    \      o    Reserve\n              Call: RESERVE( session-id, [ receiver_address\
    \ , ]\n                        [ CONF_flag, ] [ Policy_data, ]\n             \
    \            style, style-dependent-parms )\n              A receiver uses this\
    \ call to make or to modify a resource\n              reservation for the session\
    \ registered as `session-id'.\n              The first RESERVE call will initiate\
    \ the periodic\n              transmission of Resv messages.  A later RESERVE\
    \ call may\n              be given to modify the parameters of the earlier call\
    \ (but\n              note that changing existing reservations may result in\n\
    \              admission control failures).\n              The optional `receiver_address'\
    \ parameter may be used by a\n              receiver on a multihomed host (or\
    \ router); it is the IP\n              address of one of the node's interfaces.\
    \  The CONF_flag\n              should be set on if a reservation confirmation\
    \ is desired,\n              off otherwise.  The `Policy_data' parameter specifies\n\
    \              policy data for the receiver, while the `style' parameter\n   \
    \           indicates the reservation style.  The rest of the\n              parameters\
    \ depend upon the style; generally these will be\n              appropriate flowspecs\
    \ and filter specs.\n              The RESERVE call returns immediately.  Following\
    \ a RESERVE\n              call, an asynchronous ERROR/EVENT upcall may occur\
    \ at any\n              time.\n         o    Release\n              Call: RELEASE(\
    \ session-id )\n              This call removes RSVP state for the session specified\
    \ by\n              session-id.  The node then sends appropriate teardown\n  \
    \            messages and ceases sending refreshes for this session-id.\n    \
    \     o    Error/Event Upcalls\n              The general form of a upcall is\
    \ as follows:\n              Upcall: <Upcall_Proc>( ) -> session-id, Info_type,\n\
    \                            information_parameters\n              Here \"Upcall_Proc\"\
    \ represents the upcall procedure whose\n              address was supplied in\
    \ the SESSION call.  This upcall may\n              occur asynchronously at any\
    \ time after a SESSION call and\n              before a RELEASE call, to indicate\
    \ an error or an event.\n              Currently there are five upcall types,\
    \ distinguished by\n              the Info_type parameter.  The selection of information\n\
    \              parameters depends upon the type.\n              1.   Info_type\
    \ = PATH_EVENT\n                   A Path Event upcall results from receipt of\
    \ the first\n                   Path message for this session, indicating to a\n\
    \                   receiver application that there is at least one\n        \
    \           active sender, or if the path state changes.\n                   Upcall:\
    \ <Upcall_Proc>( ) -> session-id,\n                               Info_type=PATH_EVENT,\n\
    \                               Sender_Tspec, Sender_Template\n              \
    \                 [ , Adspec ] [ , Policy_data ]\n                   This upcall\
    \ presents the Sender_Tspec, the\n                   Sender_Template, the Adspec,\
    \ and any policy data from\n                   a Path message.\n             \
    \ 2.   Info_type = RESV_EVENT\n                   A Resv Event upcall is triggered\
    \ by the receipt of\n                   the first RESV message, or by modification\
    \ of a\n                   previous reservation state, for this session.\n   \
    \                Upcall: <Upcall_Proc>( ) -> session-id,\n                   \
    \            Info_type=RESV_EVENT,\n                               Style, Flowspec,\
    \ Filter_Spec_list\n                               [ , Policy_data ]\n       \
    \            Here `Flowspec' will be the effective QoS that has\n            \
    \       been received.  Note that an FF-style Resv message\n                 \
    \  may result in multiple RESV_EVENT upcalls, one for\n                   each\
    \ flow descriptor.\n              3.   Info_type = PATH_ERROR\n              \
    \     An Path Error event indicates an error in sender\n                   information\
    \ that was specified in a SENDER call.\n                   Upcall: <Upcall_Proc>(\
    \ ) -> session-id,\n                                 Info_type=PATH_ERROR,\n \
    \                                Error_code , Error_value ,\n                \
    \                 Error_Node , Sender_Template\n                             \
    \    [ , Policy_data_list ]\n                   The Error_code parameter will\
    \ define the error, and\n                   Error_value may supply some additional\
    \ (perhaps\n                   system-specific) data about the error.  The\n \
    \                  Error_Node parameter will specify the IP address of\n     \
    \              the node that detected the error.  The\n                   Policy_data_list\
    \ parameter, if present, will contain\n                   any POLICY_DATA objects\
    \ from the failed Path message.\n              4.   Info_type = RESV_ERR\n   \
    \                An Resv Error event indicates an error in a\n               \
    \    reservation message to which this application\n                   contributed.\n\
    \                   Upcall: <Upcall_Proc>( ) -> session-id,\n                \
    \                 Info_type=RESV_ERROR,\n                                 Error_code\
    \ , Error_value ,\n                                 Error_Node , Error_flags ,\n\
    \                                 Flowspec, Filter_spec_list\n               \
    \                  [ , Policy_data_list ]\n                   The Error_code parameter\
    \ will define the error and\n                   Error_value may supply some additional\
    \ (perhaps\n                   system-specific) data.  The Error_Node parameter\
    \ will\n                   specify the IP address of the node that detected the\n\
    \                   event being reported.\n                   There are two Error_flags:\n\
    \                   -    InPlace\n                        This flag may be on\
    \ for an Admission Control\n                        failure, to indicate that\
    \ there was, and is, a\n                        reservation in place at the failure\
    \ node.  This\n                        flag is set at the failure point and forwarded\n\
    \                        in ResvErr messages.\n                   -    NotGuilty\n\
    \                        This flag may be on for an Admission Control\n      \
    \                  failure, to indicate that the flowspec requested\n        \
    \                by this receiver was strictly less than the\n               \
    \         flowspec that got the error.  This flag is set\n                   \
    \     at the receiver API.\n                   Filter_spec_list and Flowspec will\
    \ contain the\n                   corresponding objects from the error flow descriptor\n\
    \                   (see Section 3.1.8).  List_count will specify the\n      \
    \             number of FILTER_SPECS in Filter_spec_list.  The\n             \
    \      Policy_data_list parameter will contain any\n                   POLICY_DATA\
    \ objects from the ResvErr message.\n              5.   Info_type = RESV_CONFIRM\n\
    \                   A Confirmation event indicates that a ResvConf\n         \
    \          message was received.\n                   Upcall: <Upcall_Proc>( )\
    \ -> session-id,\n                                 Info_type=RESV_CONFIRM,\n \
    \                                Style, List_count,\n                        \
    \         Flowspec, Filter_spec_list\n                                 [ , Policy_data\
    \ ]\n                   The parameters are interpreted as in the Resv Error\n\
    \                   upcall.\n              Although RSVP messages indicating path\
    \ or resv events may\n              be received periodically, the API should make\
    \ the\n              corresponding asynchronous upcall to the application only\n\
    \              on the first occurrence or when the information to be\n       \
    \       reported changes.  All error and confirmation events\n              should\
    \ be reported to the application.\n      3.11.2 RSVP/Traffic Control Interface\n\
    \         It is difficult to present a generic interface to traffic\n        \
    \ control, because the details of establishing a reservation\n         depend\
    \ strongly upon the particular link layer technology in\n         use on an interface.\n\
    \         Merging of RSVP reservations is required because of multicast\n    \
    \     data delivery, which replicates data packets for delivery to\n         different\
    \ next-hop nodes.  At each such replication point, RSVP\n         must merge reservation\
    \ requests from the corresponding next\n         hops by computing the \"maximum\"\
    \ of their flowspecs.  At a given\n         router or host, one or more of the\
    \ following three replication\n         locations may be in use.\n         1.\
    \   IP layer\n              IP multicast forwarding performs replication in the\
    \ IP\n              layer.  In this case, RSVP must merge the reservations\n \
    \             that are in place on the corresponding outgoing interfaces\n   \
    \           in order to forward a request upstream.\n         2.   \"The network\"\
    \n              Replication might take place downstream from the node,\n     \
    \         e.g., in a broadcast LAN, in link-layer switches, or in a\n        \
    \      mesh of non-RSVP-capable routers (see Section 2.8).   In\n            \
    \  these cases, RSVP must merge the reservations from the\n              different\
    \ next hops in order to make the reservation on\n              the single outgoing\
    \ interface.  It must also merge\n              reservations requests from all\
    \ outgoing interfaces in\n              order to forward a request upstream.\n\
    \         3.   Link-layer driver\n              For a multi-access technology,\
    \ replication may occur in\n              the link layer driver or interface card.\
    \  For example,\n              this case might arise when there is a separate\
    \ ATM point-\n              to-point VC towards each next hop.  RSVP may need\
    \ to apply\n              traffic control independently to each VC, without merging\n\
    \              requests from different next hops.\n         In general, these\
    \ complexities do not impact the protocol\n         processing that is required\
    \ by RSVP, except to determine\n         exactly what reservation requests need\
    \ to be merged.  It may be\n         desirable to organize an RSVP implementation\
    \ into two parts: a\n         core that performs link-layer-independent processing,\
    \ and a\n         link-layer-dependent adaptation layer.  However, we present\n\
    \         here a generic interface that assumes that replication can\n       \
    \  occur only at the IP layer or in \"the network\".\n         o    Make a Reservation\n\
    \              Call: TC_AddFlowspec( Interface, TC_Flowspec,\n               \
    \                 TC_Tspec, TC_Adspec, Police_Flags )\n                      \
    \                  -> RHandle [, Fwd_Flowspec]\n              The TC_Flowspec\
    \ parameter defines the desired effective\n              QoS to admission control;\
    \ its value is computed as the\n              maximum over the flowspecs of different\
    \ next hops (see the\n              Compare_Flowspecs call below).  The TC_Tspec\
    \ parameter\n              defines the effective sender Tspec Path_Te (see Section\n\
    \              2.2).  The TC_Adspec parameter defines the effective\n        \
    \      Adspec.  The Police_Flags parameter carries the three\n              flags\
    \ E_Police_Flag, M_Police_Flag, and B_Police_Flag; see\n              Section\
    \ 3.8.\n              If this call is successful, it establishes a new\n     \
    \         reservation channel corresponding to RHandle; otherwise,\n         \
    \     it returns an error code.  The opaque number RHandle is\n              used\
    \ by the caller for subsequent references to this\n              reservation.\
    \  If the traffic control service updates the\n              flowspec, the call\
    \ will also return the updated object as\n              Fwd_Flowspec.\n      \
    \   o    Modify Reservation\n              Call: TC_ModFlowspec( Interface, RHandle,\
    \ TC_Flowspec,\n                                  TC_Tspec, TC_Adspec, Police_flags\
    \ )\n                                        [ -> Fwd_Flowspec ]\n           \
    \   This call is used to modify an existing reservation.\n              TC_Flowspec\
    \ is passed to Admission Control; if it is\n              rejected, the current\
    \ flowspec is left in force.  The\n              corresponding filter specs, if\
    \ any, are not affected.  The\n              other parameters are defined as in\
    \ TC_AddFlowspec.  If the\n              service updates the flowspec, the call\
    \ will also return\n              the updated object as Fwd_Flowspec.\n      \
    \   o    Delete Flowspec\n              Call: TC_DelFlowspec( Interface, RHandle\
    \ )\n              This call will delete an existing reservation, including\n\
    \              the flowspec and all associated filter specs.\n         o    Add\
    \ Filter Spec\n              Call: TC_AddFilter( Interface, RHandle,\n       \
    \                       Session , FilterSpec ) -> FHandle\n              This\
    \ call is used to associate an additional filter spec\n              with the\
    \ reservation specified by the given RHandle,\n              following a successful\
    \ TC_AddFlowspec call.  This call\n              returns a filter handle FHandle.\n\
    \         o    Delete Filter Spec\n              Call: TC_DelFilter( Interface,\
    \ FHandle )\n              This call is used to remove a specific filter, specified\n\
    \              by FHandle.\n         o    OPWA Update\n              Call: TC_Advertise(\
    \ Interface, Adspec,\n                                  Non_RSVP_Hop_flag ) ->\
    \ New_Adspec\n              This call is used for OPWA to compute the outgoing\n\
    \              advertisement New_Adspec for a specified interface.  The\n    \
    \          flag bit Non_RSVP_Hop_flag should be set whenever the RSVP\n      \
    \        daemon detects that the previous RSVP hop included one or\n         \
    \     more non-RSVP-capable routers.  TC_Advertise will insert\n             \
    \ this information into New_Adspec to indicate that a non-\n              integrated-service\
    \ hop was found; see Section 3.8.\n         o    Preemption Upcall\n         \
    \     Upcall: TC_Preempt() -> RHandle, Reason_code\n              In order to\
    \ grant a new reservation request, the admission\n              control and/or\
    \ policy control modules may preempt one or\n              more existing reservations.\
    \  This will trigger a\n              TC_Preempt() upcall to RSVP for each preempted\n\
    \              reservation, passing the RHandle of the reservation and a\n   \
    \           sub-code indicating the reason.\n      3.11.3 RSVP/Policy Control\
    \ Interface\n         This interface will be specified in a future document.\n\
    \      3.11.4 RSVP/Routing Interface\n         An RSVP implementation needs the\
    \ following support from the\n         routing mechanisms of the node.\n     \
    \    o    Route Query\n              To forward Path and PathTear messages, an\
    \ RSVP process\n              must be able to query the routing process(s) for\
    \ routes.\n                 Ucast_Route_Query( [ SrcAddress, ] DestAddress,\n\
    \                                     Notify_flag ) -> OutInterface\n        \
    \         Mcast_Route_Query( [ SrcAddress, ] DestAddress,\n                  \
    \                   Notify_flag )\n                                 -> [ IncInterface,\
    \ ] OutInterface_list\n              Depending upon the routing protocol, the\
    \ query may or may\n              not depend upon SrcAddress, i.e., upon the sender\
    \ host IP\n              address, which is also the IP source address of the\n\
    \              message.  Here IncInterface is the interface through which\n  \
    \            the packet is expected to arrive; some multicast routing\n      \
    \        protocols may not provide it.  If the Notify_flag is True,\n        \
    \      routing will save state necessary to issue unsolicited\n              route\
    \ change notification callbacks (see below) whenever\n              the specified\
    \ route changes.\n              A multicast route query may return an empty\n\
    \              OutInterface_list if there are no receivers downstream of\n   \
    \           a particular router.  A route query may also return a `No\n      \
    \        such route' error, probably as a result of a transient\n            \
    \  inconsistency in the routing (since a Path or PathTear\n              message\
    \ for the requested route did arrive at this node).\n              In either case,\
    \ the local state should be updated as\n              requested by the message,\
    \ which cannot be forwarded\n              further.  Updating local state will\
    \ make path state\n              available immediately for a new local receiver,\
    \ or it will\n              tear down path state immediately.\n         o    Route\
    \ Change Notification\n              If requested by a route query with the Notify_flag\
    \ True,\n              the routing process may provide an asynchronous callback\n\
    \              to the RSVP process that a specified route has changed.\n     \
    \            Ucast_Route_Change( ) -> [ SrcAddress, ] DestAddress,\n         \
    \                                       OutInterface\n                 Mcast_Route_Change(\
    \ ) -> [ SrcAddress, ] DestAddress,\n                               [ IncInterface,\
    \ ] OutInterface_list\n         o    Interface List Discovery\n              RSVP\
    \ must be able to learn what real and virtual\n              interfaces are active,\
    \ with their IP addresses.\n              It should be possible to logically disable\
    \ an interface\n              for RSVP.  When an interface is disabled for RSVP,\
    \ a Path\n              message should never be forwarded out that interface,\
    \ and\n              if an RSVP message is received on that interface, the\n \
    \             message should be silently discarded (perhaps with local\n     \
    \         logging).\n      3.11.5 RSVP/Packet I/O Interface\n         An RSVP\
    \ implementation needs the following support from the\n         packet I/O and\
    \ forwarding mechanisms of the node.\n         o    Promiscuous Receive Mode for\
    \ RSVP Messages\n              Packets received for IP protocol 46 but not addressed\
    \ to\n              the node must be diverted to the RSVP program for\n      \
    \        processing, without being forwarded.  The RSVP messages to\n        \
    \      be diverted in this manner will include Path, PathTear,\n             \
    \ and ResvConf messages.  These message types carry the\n              Router\
    \ Alert IP option, which can be used to pick them out\n              of a high-speed\
    \ forwarding path.  Alternatively, the node\n              can intercept all protocol\
    \ 46 packets.\n              On a router or multi-homed host, the identity of\
    \ the\n              interface (real or virtual) on which a diverted message is\n\
    \              received, as well as the IP source address and IP TTL with\n  \
    \            which it arrived, must also be available to the RSVP\n          \
    \    process.\n         o    Outgoing Link Specification\n              RSVP must\
    \ be able to force a (multicast) datagram to be\n              sent on a specific\
    \ outgoing real or virtual link,\n              bypassing the normal routing mechanism.\
    \  A virtual link\n              might be a multicast tunnel, for example.  Outgoing\
    \ link\n              specification is necessary to send different versions of\n\
    \              an outgoing Path message on different interfaces, and to\n    \
    \          avoid routing loops in some cases.\n         o    Source Address and\
    \ TTL Specification\n              RSVP must be able to specify the IP source\
    \ address and IP\n              TTL to be used when sending Path messages.\n \
    \        o    Router Alert\n              RSVP must be able to cause Path, PathTear,\
    \ and ResvConf\n              message to be sent with the Router Alert IP option.\n\
    \      3.11.6 Service-Dependent Manipulations\n         Flowspecs, Tspecs, and\
    \ Adspecs are opaque objects to RSVP;\n         their contents are defined in\
    \ service specification documents.\n         In order to manipulate these objects,\
    \ RSVP process must have\n         available to it the following service-dependent\
    \ routines.\n         o    Compare Flowspecs\n                 Compare_Flowspecs(\
    \ Flowspec_1, Flowspec_2 ) ->\n                                              \
    \          result_code\n              The possible result_codes indicate: flowspecs\
    \ are equal,\n              Flowspec_1 is greater, Flowspec_2 is greater, flowspecs\n\
    \              are incomparable but LUB can be computed, or flowspecs are\n  \
    \            incompatible.\n              Note that comparing two flowspecs implicitly\
    \ compares the\n              Tspecs that are contained.  Although the RSVP process\n\
    \              cannot itself parse a flowspec to extract the Tspec, it\n     \
    \         can use the Compare_Flowspecs call to implicitly calculate\n       \
    \       Resv_Te (see Section 2.2).\n         o    Compute LUB of Flowspecs\n \
    \                LUB_of_Flowspecs( Flowspec_1, Flowspec_2 ) ->\n             \
    \                                        Flowspec_LUB\n         o    Compute GLB\
    \ of Flowspecs\n                 GLB_of_Flowspecs( Flowspec_1, Flowspec_2 ) ->\n\
    \                                                     Flowspec_GLB\n         o\
    \    Compare Tspecs\n                 Compare_Tspecs( Tspec_1, Tspec_2 ) -> result_code\n\
    \              The possible result_codes indicate: Tspecs are equal, or\n    \
    \          Tspecs are unequal.\n         o    Sum Tspecs\n                 Sum_Tspecs(\
    \ Tspec_1, Tspec_2 ) -> Tspec_sum\n              This call is used to compute\
    \ Path_Te (see Section 2.2).\n"
- title: 4. Acknowledgments
  contents:
  - "4. Acknowledgments\n   The design of RSVP is based upon research performed in\
    \ 1992-1993 by a\n   collaboration including Lixia Zhang (UCLA), Deborah Estrin\n\
    \   (USC/ISI), Scott Shenker (Xerox PARC), Sugih Jamin (USC/Xerox PARC),\n   and\
    \ Daniel Zappala (USC).  Sugih Jamin developed the first prototype\n   implementation\
    \ of RSVP and successfully demonstrated it in May 1993.\n   Shai Herzog, and later\
    \ Steve Berson, continued development of RSVP\n   prototypes.\n   Since 1993,\
    \ many members of the Internet research community have\n   contributed to the\
    \ design and development of RSVP; these include (in\n   alphabetical order) Steve\
    \ Berson, Bob Braden, Lee Breslau, Dave\n   Clark, Deborah Estrin, Shai Herzog,\
    \ Craig Partridge, Scott Shenker,\n   John Wroclawski, Daniel Zappala, and Lixia\
    \ Zhang.  In addition, a\n   number of host and router vendors have made valuable\
    \ contributions to\n   the RSVP documents, particularly Fred Baker (Cisco), Mark\
    \ Baugher\n   (Intel), Lou Berger (Fore Systems), Don Hoffman (Sun), Steve Jakowski\n\
    \   (NetManage), John Krawczyk (Bay Networks), and Bill Nowicki (SGI), as\n  \
    \ well as many others.\n"
- title: APPENDIX A. Object Definitions
  contents:
  - "APPENDIX A. Object Definitions\n   C-Types are defined for the two Internet address\
    \ families IPv4 and\n   IPv6.  To accommodate other address families, additional\
    \ C-Types\n   could easily be defined.  These definitions are contained as an\n\
    \   Appendix, to ease updating.\n   All unused fields should be sent as zero and\
    \ ignored on receipt.\n   A.1 SESSION Class\n      SESSION Class = 1.\n      o\
    \    IPv4/UDP SESSION object: Class = 1, C-Type = 1\n           +-------------+-------------+-------------+-------------+\n\
    \           |             IPv4 DestAddress (4 bytes)                |\n      \
    \     +-------------+-------------+-------------+-------------+\n           |\
    \ Protocol Id |    Flags    |          DstPort          |\n           +-------------+-------------+-------------+-------------+\n\
    \      o    IPv6/UDP SESSION object: Class = 1, C-Type = 2\n           +-------------+-------------+-------------+-------------+\n\
    \           |                                                       |\n      \
    \     +                                                       +\n           |\
    \                                                       |\n           +      \
    \         IPv6 DestAddress (16 bytes)             +\n           |            \
    \                                           |\n           +                  \
    \                                     +\n           |                        \
    \                               |\n           +-------------+-------------+-------------+-------------+\n\
    \           | Protocol Id |     Flags   |          DstPort          |\n      \
    \     +-------------+-------------+-------------+-------------+\n      DestAddress\n\
    \           The IP unicast or multicast destination address of the\n         \
    \  session.  This field must be non-zero.\n      Protocol Id\n           The IP\
    \ Protocol Identifier for the data flow.  This field\n           must be non-zero.\n\
    \      Flags\n           0x01 = E_Police flag\n                The E_Police flag\
    \ is used in Path messages to determine\n                the effective \"edge\"\
    \ of the network, to control traffic\n                policing.  If the sender\
    \ host is not itself capable of\n                traffic policing, it will set\
    \ this bit on in Path\n                messages it sends.  The first node whose\
    \ RSVP is capable\n                of traffic policing will do so (if appropriate\
    \ to the\n                service) and turn the flag off.\n      DstPort\n   \
    \        The UDP/TCP destination port for the session.  Zero may be\n        \
    \   used to indicate `none'.\n           Other SESSION C-Types could be defined\
    \ in the future to\n           support other demultiplexing conventions in the\
    \ transport-\n           layer or application layer.\n   A.2 RSVP_HOP Class\n\
    \      RSVP_HOP class = 3.\n      o    IPv4 RSVP_HOP object: Class = 3, C-Type\
    \ = 1\n           +-------------+-------------+-------------+-------------+\n\
    \           |             IPv4 Next/Previous Hop Address            |\n      \
    \     +-------------+-------------+-------------+-------------+\n           |\
    \                 Logical Interface Handle              |\n           +-------------+-------------+-------------+-------------+\n\
    \      o    IPv6 RSVP_HOP object: Class = 3, C-Type = 2\n           +-------------+-------------+-------------+-------------+\n\
    \           |                                                       |\n      \
    \     +                                                       +\n           |\
    \                                                       |\n           +      \
    \       IPv6 Next/Previous Hop Address            +\n           |            \
    \                                           |\n           +                  \
    \                                     +\n           |                        \
    \                               |\n           +-------------+-------------+-------------+-------------+\n\
    \           |                Logical Interface Handle               |\n      \
    \     +-------------+-------------+-------------+-------------+\n      This object\
    \ carries the IP address of the interface through which\n      the last RSVP-knowledgeable\
    \ hop forwarded this message.  The\n      Logical Interface Handle (LIH) is used\
    \ to distinguish logical\n      outgoing interfaces, as discussed in Sections\
    \ 3.3 and 3.9.  A node\n      receiving an LIH in a Path message saves its value\
    \ and returns it\n      in the HOP objects of subsequent Resv messages sent to\
    \ the node\n      that originated the LIH.  The LIH should be identically zero\
    \ if\n      there is no logical interface handle.\n   A.3 INTEGRITY Class\n  \
    \    INTEGRITY class = 4.\n      See [Baker96].\n   A.4 TIME_VALUES Class\n  \
    \    TIME_VALUES class = 5.\n      o    TIME_VALUES Object: Class = 5, C-Type\
    \ = 1\n           +-------------+-------------+-------------+-------------+\n\
    \           |                   Refresh Period R                    |\n      \
    \     +-------------+-------------+-------------+-------------+\n      Refresh\
    \ Period\n           The refresh timeout period R used to generate this message;\n\
    \           in milliseconds.\n   A.5 ERROR_SPEC Class\n      ERROR_SPEC class\
    \ = 6.\n      o    IPv4 ERROR_SPEC object: Class = 6, C-Type = 1\n           +-------------+-------------+-------------+-------------+\n\
    \           |            IPv4 Error Node Address (4 bytes)          |\n      \
    \     +-------------+-------------+-------------+-------------+\n           |\
    \    Flags    |  Error Code |        Error Value        |\n           +-------------+-------------+-------------+-------------+\n\
    \      o    IPv6 ERROR_SPEC object: Class = 6, C-Type = 2\n           +-------------+-------------+-------------+-------------+\n\
    \           |                                                       |\n      \
    \     +                                                       +\n           |\
    \                                                       |\n           +      \
    \     IPv6 Error Node Address (16 bytes)          +\n           |            \
    \                                           |\n           +                  \
    \                                     +\n           |                        \
    \                               |\n           +-------------+-------------+-------------+-------------+\n\
    \           |    Flags    |  Error Code |        Error Value        |\n      \
    \     +-------------+-------------+-------------+-------------+\n      Error Node\
    \ Address\n           The IP address of the node in which the error was detected.\n\
    \      Flags\n           0x01 = InPlace\n                This flag is used only\
    \ for an ERROR_SPEC object in a\n                ResvErr message.  If it on, this\
    \ flag indicates that\n                there was, and still is, a reservation\
    \ in place at the\n                failure point.\n           0x02 = NotGuilty\n\
    \                This flag is used only for an ERROR_SPEC object in a\n      \
    \          ResvErr message, and it is only set in the interface to\n         \
    \       the receiver application.  If it on, this flag indicates\n           \
    \     that the FLOWSPEC that failed was strictly greater than\n              \
    \  the FLOWSPEC requested by this receiver.\n      Error Code\n           A one-octet\
    \ error description.\n      Error Value\n           A two-octet field containing\
    \ additional information about the\n                error.  Its contents depend\
    \ upon the Error Type.\n      The values for Error Code and Error Value are defined\
    \ in Appendix\n      B.\n   A.6 SCOPE Class\n      SCOPE class = 7.\n      This\
    \ object contains a list of IP addresses, used for routing\n      messages with\
    \ wildcard scope without loops.  The addresses must be\n      listed in ascending\
    \ numerical order.\n      o    IPv4 SCOPE List object: Class = 7, C-Type = 1\n\
    \           +-------------+-------------+-------------+-------------+\n      \
    \     |                IPv4 Src Address (4 bytes)             |\n           +-------------+-------------+-------------+-------------+\n\
    \           //                                                      //\n     \
    \      +-------------+-------------+-------------+-------------+\n           |\
    \                IPv4 Src Address (4 bytes)             |\n           +-------------+-------------+-------------+-------------+\n\
    \      o    IPv6  SCOPE list object: Class = 7, C-Type = 2\n           +-------------+-------------+-------------+-------------+\n\
    \           |                                                       |\n      \
    \     +                                                       +\n           |\
    \                                                       |\n           +      \
    \          IPv6 Src Address (16 bytes)            +\n           |            \
    \                                           |\n           +                  \
    \                                     +\n           |                        \
    \                               |\n           +-------------+-------------+-------------+-------------+\n\
    \           //                                                      //\n     \
    \      +-------------+-------------+-------------+-------------+\n           |\
    \                                                       |\n           +      \
    \                                                 +\n           |            \
    \                                           |\n           +                IPv6\
    \ Src Address (16 bytes)            +\n           |                          \
    \                             |\n           +                                \
    \                       +\n           |                                      \
    \                 |\n           +-------------+-------------+-------------+-------------+\n\
    \   A.7 STYLE Class\n      STYLE class = 8.\n      o    STYLE object: Class =\
    \ 8, C-Type = 1\n           +-------------+-------------+-------------+-------------+\n\
    \           |   Flags     |              Option Vector              |\n      \
    \     +-------------+-------------+-------------+-------------+\n      Flags:\
    \ 8 bits\n           (None assigned yet)\n      Option Vector: 24 bits\n     \
    \      A set of bit fields giving values for the reservation\n           options.\
    \  If new options are added in the future,\n           corresponding fields in\
    \ the option vector will be assigned\n           from the least-significant end.\
    \  If a node does not recognize\n           a style ID, it may interpret as much\
    \ of the option vector as\n           it can, ignoring new fields that may have\
    \ been defined.\n           The option vector bits are assigned (from the left)\
    \ as\n           follows:\n           19 bits: Reserved\n           2 bits: Sharing\
    \ control\n                00b: Reserved\n                01b: Distinct reservations\n\
    \                10b: Shared reservations\n                11b: Reserved\n   \
    \        3 bits: Sender selection control\n                000b: Reserved\n  \
    \              001b: Wildcard\n                010b: Explicit\n              \
    \  011b - 111b: Reserved\n      The low order bits of the option vector are determined\
    \ by the\n      style, as follows:\n              WF 10001b\n              FF\
    \ 01010b\n              SE 10010b\n   A.8 FLOWSPEC Class\n      FLOWSPEC class\
    \ = 9.\n      o    Reserved (obsolete) flowspec object: Class = 9, C-Type = 1\n\
    \      o    Inv-serv Flowspec object: Class = 9, C-Type = 2\n           The contents\
    \ and encoding rules for this object are specified\n           in documents prepared\
    \ by the int-serv working group [RFC\n           2210].\n   A.9 FILTER_SPEC Class\n\
    \      FILTER_SPEC class = 10.\n      o    IPv4 FILTER_SPEC object: Class = 10,\
    \ C-Type = 1\n           +-------------+-------------+-------------+-------------+\n\
    \           |               IPv4 SrcAddress (4 bytes)               |\n      \
    \     +-------------+-------------+-------------+-------------+\n           |\
    \    //////   |    //////   |          SrcPort          |\n           +-------------+-------------+-------------+-------------+\n\
    \      o    IPv6 FILTER_SPEC object: Class = 10, C-Type = 2\n           +-------------+-------------+-------------+-------------+\n\
    \           |                                                       |\n      \
    \     +                                                       +\n           |\
    \                                                       |\n           +      \
    \         IPv6 SrcAddress (16 bytes)              +\n           |            \
    \                                           |\n           +                  \
    \                                     +\n           |                        \
    \                               |\n           +-------------+-------------+-------------+-------------+\n\
    \           |    //////   |    //////   |          SrcPort          |\n      \
    \     +-------------+-------------+-------------+-------------+\n      o    IPv6\
    \ Flow-label FILTER_SPEC object: Class = 10, C-Type = 3\n           +-------------+-------------+-------------+-------------+\n\
    \           |                                                       |\n      \
    \     +                                                       +\n           |\
    \                                                       |\n           +      \
    \         IPv6 SrcAddress (16 bytes)              +\n           |            \
    \                                           |\n           +                  \
    \                                     +\n           |                        \
    \                               |\n           +-------------+-------------+-------------+-------------+\n\
    \           |   ///////   |         Flow Label (24 bits)            |\n      \
    \     +-------------+-------------+-------------+-------------+\n      SrcAddress\n\
    \           The IP source address for a sender host.  Must be non-zero.\n    \
    \  SrcPort\n           The UDP/TCP source port for a sender, or zero to indicate\n\
    \           `none'.\n      Flow Label\n           A 24-bit Flow Label, defined\
    \ in IPv6.  This value may be used\n           by the packet classifier to efficiently\
    \ identify the packets\n           belonging to a particular (sender->destination)\
    \ data flow.\n   A.10 SENDER_TEMPLATE Class\n      SENDER_TEMPLATE class = 11.\n\
    \      o    IPv4 SENDER_TEMPLATE object: Class = 11, C-Type = 1\n           Definition\
    \ same as IPv4/UDP FILTER_SPEC object.\n      o    IPv6 SENDER_TEMPLATE object:\
    \ Class = 11, C-Type = 2\n           Definition same as IPv6/UDP FILTER_SPEC object.\n\
    \      o    IPv6 Flow-label SENDER_TEMPLATE object: Class = 11, C-Type =\n   \
    \        3\n   A.11 SENDER_TSPEC Class\n      SENDER_TSPEC class = 12.\n     \
    \ o    Intserv SENDER_TSPEC object: Class = 12, C-Type = 2\n           The contents\
    \ and encoding rules for this object are specified\n           in documents prepared\
    \ by the int-serv working group.\n   A.12 ADSPEC Class\n      ADSPEC class = 13.\n\
    \      o    Intserv ADSPEC object: Class = 13, C-Type = 2\n           The contents\
    \ and format for this object are specified in\n           documents prepared by\
    \ the int-serv working group.\n   A.13 POLICY_DATA Class\n      POLICY_DATA class\
    \ = 14.\n      o    Type 1 POLICY_DATA object: Class = 14, C-Type = 1\n      \
    \     The contents of this object are for further study.\n   A.14 Resv_CONFIRM\
    \ Class\n      RESV_CONFIRM class = 15.\n      o    IPv4 RESV_CONFIRM object:\
    \ Class = 15, C-Type = 1\n           +-------------+-------------+-------------+-------------+\n\
    \           |            IPv4 Receiver Address (4 bytes)            |\n      \
    \     +-------------+-------------+-------------+-------------+\n      o    IPv6\
    \ RESV_CONFIRM object: Class = 15, C-Type = 2\n           +-------------+-------------+-------------+-------------+\n\
    \           |                                                       |\n      \
    \     +                                                       +\n           |\
    \                                                       |\n           +      \
    \      IPv6 Receiver Address (16 bytes)           +\n           |            \
    \                                           |\n           +                  \
    \                                     +\n           |                        \
    \                               |\n           +-------------+-------------+-------------+-------------+\n"
- title: APPENDIX B. Error Codes and Values
  contents:
  - "APPENDIX B. Error Codes and Values\n   The following Error Codes may appear in\
    \ ERROR_SPEC objects and be\n   passed to end systems.  Except where noted, these\
    \ Error Codes may\n   appear only in ResvErr messages.\n   o    Error Code = 00:\
    \ Confirmation\n        This code is reserved for use in the ERROR_SPEC object\
    \ of a\n        ResvConf message.  The Error Value will also be zero.\n   o  \
    \  Error Code = 01: Admission Control failure\n        Reservation request was\
    \ rejected by Admission Control due to\n        unavailable resources.\n     \
    \   For this Error Code, the 16 bits of the Error Value field are:\n         \
    \  ssur cccc cccc cccc\n        where the bits are:\n        ss = 00: Low order\
    \ 12 bits contain a globally-defined sub-code\n             (values listed below).\n\
    \        ss = 10: Low order 12 bits contain a organization-specific sub-\n   \
    \          code.  RSVP is not expected to be able to interpret this\n        \
    \     except as a numeric value.\n        ss = 11: Low order 12 bits contain a\
    \ service-specific sub-code.\n             RSVP is not expected to be able to\
    \ interpret this except as\n             a numeric value.\n             Since\
    \ the traffic control mechanism might substitute a\n             different service,\
    \ this encoding may include some\n             representation of the service in\
    \ use.\n             u = 0: RSVP rejects the message without updating local\n\
    \             state.\n        u = 1: RSVP may use message to update local state\
    \ and forward\n             the message.  This means that the message is informational.\n\
    \        r: Reserved bit, should be zero.\n        cccc cccc cccc: 12 bit code.\n\
    \        The following globally-defined sub-codes may appear in the low-\n   \
    \     order 12 bits when ssur = 0000:\n        -    Sub-code = 1: Delay bound\
    \ cannot be met\n        -    Sub-code = 2: Requested bandwidth unavailable\n\
    \        -    Sub-code = 3: MTU in flowspec larger than interface MTU.\n   o \
    \   Error Code = 02: Policy Control failure\n        Reservation or path message\
    \ has been rejected for administrative\n        reasons, for example, required\
    \ credentials not submitted,\n        insufficient quota or balance, or administrative\
    \ preemption.\n        This Error Code may appear in a PathErr or ResvErr message.\n\
    \        Contents of the Error Value field are to be determined in the\n     \
    \   future.\n   o    Error Code = 03: No path information for this Resv message.\n\
    \        No path state for this session.  Resv message cannot be\n        forwarded.\n\
    \   o    Error Code = 04: No sender information for this Resv message.\n     \
    \   There is path state for this session, but it does not include\n        the\
    \ sender matching some flow descriptor contained in the Resv\n        message.\
    \  Resv message cannot be forwarded.\n   o    Error Code = 05: Conflicting reservation\
    \ style\n        Reservation style conflicts with style(s) of existing\n     \
    \   reservation state.  The Error Value field contains the low-order\n       \
    \ 16 bits of the Option Vector of the existing style with which\n        the conflict\
    \ occurred.  This Resv message cannot be forwarded.\n   o    Error Code = 06:\
    \ Unknown reservation style\n        Reservation style is unknown.  This Resv\
    \ message cannot be\n        forwarded.\n   o    Error Code = 07: Conflicting\
    \ dest ports\n        Sessions for same destination address and protocol have\
    \ appeared\n        with both zero and non-zero dest port fields.  This Error\
    \ Code\n        may appear in a PathErr or ResvErr message.\n   o    Error Code\
    \ = 08: Conflicting sender ports\n        Sender port is both zero and non-zero\
    \ in Path messages for the\n        same session.  This Error Code may appear\
    \ only in a PathErr\n        message.\n   o    Error Code = 09, 10, 11: (reserved)\n\
    \   o    Error Code = 12: Service preempted\n        The service request defined\
    \ by the STYLE object and the flow\n        descriptor has been administratively\
    \ preempted.\n        For this Error Code, the 16 bits of the Error Value field\
    \ are:\n           ssur cccc cccc cccc\n        Here the high-order bits ssur\
    \ are as defined under Error Code\n        01.  The globally-defined sub-codes\
    \ that may appear in the low-\n        order 12 bits when ssur = 0000 are to be\
    \ defined in the future.\n   o    Error Code = 13: Unknown object class\n    \
    \    Error Value contains 16-bit value composed of (Class-Num, C-\n        Type)\
    \ of unknown object.  This error should be sent only if RSVP\n        is going\
    \ to reject the message, as determined by the high-order\n        bits of the\
    \ Class-Num.  This Error Code may appear in a PathErr\n        or ResvErr message.\n\
    \   o    Error Code = 14: Unknown object C-Type\n        Error Value contains\
    \ 16-bit value composed of (Class-Num, C-\n        Type) of object.\n   o    Error\
    \ Code = 15-19: (reserved)\n   o    Error Code = 20: Reserved for API\n      \
    \  Error Value field contains an API error code, for an API error\n        that\
    \ was detected asynchronously and must be reported via an\n        upcall.\n \
    \  o    Error Code = 21: Traffic Control Error\n        Traffic Control call failed\
    \ due to the format or contents of the\n        parameters to the request.  The\
    \ Resv or Path message that caused\n        the call cannot be forwarded, and\
    \ repeating the call would be\n        futile.\n        For this Error Code, the\
    \ 16 bits of the Error Value field are:\n           ss00 cccc cccc cccc\n    \
    \    Here the high-order bits ss are as defined under Error Code 01.\n       \
    \ The following globally-defined sub-codes may appear in the low\n        order\
    \ 12 bits (cccc cccc cccc) when ss = 00:\n        -    Sub-code = 01: Service\
    \ conflict\n             Trying to merge two incompatible service requests.\n\
    \        -    Sub-code = 02: Service unsupported\n             Traffic control\
    \ can provide neither the requested service\n             nor an acceptable replacement.\n\
    \        -    Sub-code = 03: Bad Flowspec value\n             Malformed or unreasonable\
    \ request.\n        -    Sub-code = 04: Bad Tspec value\n             Malformed\
    \ or unreasonable request.\n        -    Sub-code = 05: Bad Adspec value\n   \
    \          Malformed or unreasonable request.\n   o    Error Code = 22: Traffic\
    \ Control System error\n        A system error was detected and reported by the\
    \ traffic control\n        modules.  The Error Value will contain a system-specific\
    \ value\n        giving more information about the error.  RSVP is not expected\n\
    \        to be able to interpret this value.\n   o    Error Code = 23: RSVP System\
    \ error\n        The Error Value field will provide implementation-dependent\n\
    \        information on the error.  RSVP is not expected to be able to\n     \
    \   interpret this value.\n   In general, every RSVP message is rebuilt at each\
    \ hop, and the node\n   that creates an RSVP message is responsible for its correct\n\
    \   construction.  Similarly, each node is required to verify the correct\n  \
    \ construction of each RSVP message it receives.  Should a programming\n   error\
    \ allow an RSVP to create a malformed message, the error is not\n   generally\
    \ reported to end systems in an ERROR_SPEC object; instead,\n   the error is simply\
    \ logged locally, and perhaps reported through\n   network management mechanisms.\n\
    \   The only message formatting errors that are reported to end systems\n   are\
    \ those that may reflect version mismatches, and which the end\n   system might\
    \ be able to circumvent, e.g., by falling back to a\n   previous CType for an\
    \ object; see code 13 and 14 above.\n   The choice of message formatting errors\
    \ that an RSVP may detect and\n   log locally is implementation-specific, but\
    \ it will typically include\n   the following:\n   o    Wrong-length message:\
    \ RSVP Length field does not match message\n        length.\n   o    Unknown or\
    \ unsupported RSVP version.\n   o    Bad RSVP checksum\n   o    INTEGRITY failure\n\
    \   o    Illegal RSVP message Type\n   o    Illegal object length: not a multiple\
    \ of 4, or less than 4.\n   o    Next hop/Previous hop address in HOP object is\
    \ illegal.\n   o    Bad source port: Source port is non-zero in a filter spec\
    \ or\n        sender template for a session with destination port zero.\n   o\
    \    Required object class (specify) missing\n   o    Illegal object class (specify)\
    \ in this message type.\n   o    Violation of required object order\n   o    Flow\
    \ descriptor count wrong for style or message type\n   o    Logical Interface\
    \ Handle invalid\n   o    Unknown object Class-Num.\n   o    Destination address\
    \ of ResvConf message does not match Receiver\n        Address in the RESV_CONFIRM\
    \ object it contains.\n"
- title: APPENDIX C. UDP Encapsulation
  contents:
  - "APPENDIX C. UDP Encapsulation\n   An RSVP implementation will generally require\
    \ the ability to perform\n   \"raw\" network I/O, i.e., to send and receive IP\
    \ datagrams using\n   protocol 46.  However, some important classes of host systems\
    \ may not\n   support raw network I/O.  To use RSVP, such hosts must encapsulate\n\
    \   RSVP messages in UDP.\n   The basic UDP encapsulation scheme makes two assumptions:\n\
    \   1.   All hosts are capable of sending and receiving multicast packets\n  \
    \      if multicast destinations are to be supported.\n   2.   The first/last-hop\
    \ routers are RSVP-capable.\n   A method of relaxing the second assumption is\
    \ given later.\n   Let Hu be a \"UDP-only\" host that requires UDP encapsulation,\
    \ and Hr a\n   host that can do raw network I/O.  The UDP encapsulation scheme\
    \ must\n   allow RSVP interoperation among an arbitrary topology of Hr hosts,\
    \ Hu\n   hosts, and routers.\n   Resv, ResvErr, ResvTear, and PathErr messages\
    \ are sent to unicast\n   addresses learned from the path or reservation state\
    \ in the node.  If\n   the node keeps track of which previous hops and which interfaces\
    \ need\n   UDP encapsulation, these messages can be sent using UDP encapsulation\n\
    \   when necessary.  On the other hand, Path and PathTear messages are\n   sent\
    \ to the destination address for the session, which may be unicast\n   or multicast.\n\
    \   The tables in Figures 13 and 14 show the basic rules for UDP\n   encapsulation\
    \ of Path and PathTear messages, for unicast DestAddress\n   and multicast DestAddress,\
    \ respectively.  The other message types,\n   which are sent unicast, should follow\
    \ the unicast rules in Figure 13.\n   Under the `RSVP Send' columns in these figures,\
    \ the notation is\n   `mode(destaddr, destport)'; destport is omitted for raw\
    \ packets.  The\n   `Receive' columns show the group that is joined and, where\
    \ relevant,\n   the UDP Listen port.\n   It is useful to define two flavors of\
    \ UDP encapsulation, one to be\n   sent by Hu and the other to be sent by Hr and\
    \ R, to avoid double\n   processing by the recipient.  In practice, these two\
    \ flavors are\n   distinguished by differing UDP port numbers Pu and Pu'.\n  \
    \ The following symbols are used in the tables.\n   o    D is the DestAddress\
    \ for the particular session.\n   o    G* is a well-known group address of the\
    \ form 224.0.0.14, i.e., a\n        group that is limited to the local connected\
    \ network.\n   o    Pu and Pu' are two well-known UDP ports for UDP encapsulation\
    \ of\n        RSVP, with values 1698 and 1699.\n   o    Ra is the IP address of\
    \ the router interface `a'.\n   o    Router interface `a' is on the local network\
    \ connected to Hu and\n        Hr.\n   o\n   The following notes apply to these\
    \ figures:\n      [Note 1] Hu sends a unicast Path message either to the destination\n\
    \      address D, if D is local, or to the address Ra of the first-hop\n     \
    \ router.  Ra is presumably known to the host.\n      [Note 2] Here D is the address\
    \ of the local interface through\n      which the message arrived.\n      [Note\
    \ 3] This assumes that the application has joined the group D.\n   UNICAST DESTINATION\
    \ D:\n                   RSVP               RSVP\n   Node            Send    \
    \           Receive\n   ___       _____________          _______________\n   Hu\
    \         UDP(D/Ra,Pu)          UDP(D,Pu)\n                 [Note 1]       and\
    \ UDP(D,Pu')\n                                       [Note 2]\n   Hr         Raw(D)\
    \                Raw()\n               and if (UDP)     and UDP(D, Pu)\n     \
    \          then UDP(D,Pu')         [Note 2]\n                                \
    \    (Ignore Pu')\n   R (Interface a):\n              Raw(D)                Raw()\n\
    \               and if (UDP)     and UDP(Ra, Pu)\n               then UDP(D,Pu')\
    \      (Ignore Pu')\n   Figure 13: UDP Encapsulation Rules for Unicast Path and\
    \ Resv Messages\n   MULTICAST DESTINATION D:\n                  RSVP         \
    \           RSVP\n   Node           Send                    Receive\n   ___  \
    \         _____________        _________________\n   Hu             UDP(G*,Pu)\
    \              UDP(D,Pu')\n                                              [Note\
    \ 3]\n                                      and UDP(G*,Pu)\n   Hr            \
    \ Raw(D,Tr)               Raw()\n                   and if (UDP)       and UDP(G*,Pu)\n\
    \                     then UDP(D,Pu')     (Ignore Pu')\n   R (Interface a):\n\
    \                  Raw(D,Tr)               Raw()\n                   and if (UDP)\
    \       and UDP(G*,Pu)\n                     then UDP(D,Pu')     (Ignore Pu')\n\
    \      Figure 14: UDP Encapsulation Rules for Multicast Path Messages\n   A router\
    \ may determine if its interface X needs UDP encapsulation by\n   listening for\
    \ UDP-encapsulated Path messages that were sent to either\n   G* (multicast D)\
    \ or to the address of interface X (unicast D).  There\n   is one failure mode\
    \ for this scheme:  if no host on the connected\n   network acts as an RSVP sender,\
    \ there will be no Path messages to\n   trigger UDP encapsulation.  In this (unlikely)\
    \ case, it will be\n   necessary to explicitly configure UDP encapsulation on\
    \ the local\n   network interface of the router.\n   When a UDP-encapsulated packet\
    \ is received, the IP TTL is not\n   available to the application on most systems.\
    \  The RSVP process that\n   receives a UDP-encapsulated Path or PathTear message\
    \ should therefore\n   use the Send_TTL field of the RSVP common header as the\
    \ effective\n   receive TTL.  This may be overridden by manual configuration.\n\
    \   We have assumed that the first-hop RSVP-capable router R is on the\n   directly-connected\
    \ network.  There are several possible approaches if\n   this is not the case.\n\
    \   1.   Hu can send both unicast and multicast sessions to UDP(Ra,Pu)\n     \
    \   with TTL=Ta\n        Here Ta must be the TTL to exactly reach R.  If Ta is\
    \ too small,\n        the Path message will not reach R.  If Ta is too large,\
    \ R and\n        succeeding routers may forward the UDP packet until its hop\n\
    \        count expires.  This will turn on UDP encapsulation between\n       \
    \ routers within the Internet, perhaps causing bogus UDP traffic.\n        The\
    \ host Hu must be explicitly configured with Ra and Ta.\n   2.   A particular\
    \ host on the LAN connected to Hu could be designated\n        as an \"RSVP relay\
    \ host\".  A relay host would listen on (G*,Pu)\n        and forward any Path\
    \ messages directly to R, although it would\n        not be in the data path.\
    \  The relay host would have to be\n        configured with Ra and Ta.\n"
- title: APPENDIX D. Glossary
  contents:
  - "APPENDIX D. Glossary\n   o    Admission control\n        A traffic control function\
    \ that decides whether the packet\n        scheduler in the node can supply the\
    \ requested QoS while\n        continuing to provide the QoS requested by previously-admitted\n\
    \        requests.  See also \"policy control\" and \"traffic control\".\n   o\
    \    Adspec\n        An Adspec is a data element (object) in a Path message that\n\
    \        carries a package of OPWA advertising information.  See \"OPWA\".\n \
    \  o    Auto-refresh loop\n        An auto-refresh loop is an error condition\
    \ that occurs when a\n        topological loop of routers continues to refresh\
    \ existing\n        reservation state even though all receivers have stopped\n\
    \        requesting these reservations.  See section 3.4 for more\n        information.\n\
    \   o    Blockade state\n        Blockade state helps to solve a \"killer reservation\"\
    \ problem.\n        See sections 2.5 and 3.5, and \"killer reservation\".\n  \
    \ o    Branch policing\n        Traffic policing at a multicast branching point\
    \ on an outgoing\n        interface that has \"less\" resources reserved than\
    \ another\n        outgoing interface for the same flow.  See \"traffic policing\"\
    .\n   o    C-Type\n        The class type of an object; unique within class-name.\
    \  See\n        \"class-name\".\n   o    Class-name\n        The class of an object.\
    \  See \"object\".\n   o    DestAddress\n        The IP destination address; part\
    \ of session identification.  See\n        \"session\".\n   o    Distinct style\n\
    \        A (reservation) style attribute; separate resources are reserved\n  \
    \      for each different sender.  See also \"shared style\".\n   o    Downstream\n\
    \        Towards the data receiver(s).\n   o    DstPort\n        The IP (generalized)\
    \ destination port used as part of a session.\n        See \"generalized destination\
    \ port\".\n   o    Entry policing\n        Traffic policing done at the first\
    \ RSVP- (and policing-) capable\n        router on a data path.\n   o    ERROR_SPEC\n\
    \        Object that carries the error report in a PathErr or ResvErr\n      \
    \  message.\n   o    Explicit sender selection\n        A (reservation) style\
    \ attribute; all reserved senders are to be\n        listed explicitly in the\
    \ reservation message.  See also\n        \"wildcard sender selection\".\n   o\
    \    FF style\n        Fixed Filter reservation style, which has explicit sender\n\
    \        selection and distinct attributes.\n   o    FilterSpec\n        Together\
    \ with the session information, defines the set of data\n        packets to receive\
    \ the QoS specified in a flowspec.  The\n        filterspec is used to set parameters\
    \ in the packet classifier\n        function.  A filterspec may be carried in\
    \ a FILTER_SPEC or\n        SENDER_TEMPLATE object.\n   o    Flow descriptor\n\
    \        The combination of a flowspec and a filterspec.\n   o    Flowspec\n \
    \       Defines the QoS to be provided for a flow.  The flowspec is used\n   \
    \     to set parameters in the packet scheduling function to provide\n       \
    \ the requested quality of service.  A flowspec is carried in a\n        FLOWSPEC\
    \ object.  The flowspec format is opaque to RSVP and is\n        defined by the\
    \ Integrated Services Working Group.\n   o    Generalized destination port\n \
    \       The component of a session definition that provides further\n        transport\
    \ or application protocol layer demultiplexing beyond\n        DestAddress.  See\
    \ \"session\".\n   o    Generalized source port\n        The component of a filter\
    \ spec that provides further transport\n        or application protocol layer\
    \ demultiplexing beyond the sender\n        address.\n   o    GLB\n        Greatest\
    \ Lower Bound\n   o    Incoming interface\n        The interface on which data\
    \ packets are expected to arrive, and\n        on which Resv messages are sent.\n\
    \   o    INTEGRITY\n        Object of an RSVP control message that contains cryptographic\n\
    \        data to authenticate the originating node and to verify the\n       \
    \ contents of an RSVP message.\n   o    Killer reservation problem\n        The\
    \ killer reservation problem describes a case where a receiver\n        attempting\
    \ and failing to make a large QoS reservation prevents\n        smaller QoS reservations\
    \ from being established.  See Sections\n        2.5 and 3.5 for more information.\n\
    \   o    LIH\n        The LIH (Logical Interface Handle) is used to help deal\
    \ with\n        non-RSVP clouds.  See Section 2.9 for more information.\n   o\
    \    Local repair\n        Allows RSVP to rapidly adapt its reservations to changes\
    \ in\n        routing.  See Section 3.6 for more information.\n   o    LPM\n \
    \       Local Policy Module. the function that exerts policy control.\n   o  \
    \  LUB\n        Least Upper Bound.\n   o    Merge policing\n        Traffic policing\
    \ that takes place at data merge point of a\n        shared reservation.\n   o\
    \    Merging\n        The process of taking the maximum (or more generally the\
    \ least\n        upper bound) of the reservations arriving on outgoing\n     \
    \   interfaces, and forwarding this maximum on the incoming\n        interface.\
    \  See Section 2.2 for more information.\n   o    MTU\n        Maximum Transmission\
    \ Unit.\n   o    Next hop\n        The next router in the direction of traffic\
    \ flow.\n   o    NHOP\n        An object that carries the Next Hop information\
    \ in RSVP control\n        messages.\n   o    Node\n        A router or host system.\n\
    \   o    Non-RSVP clouds\n        Groups of hosts and routers that do not run\
    \ RSVP.  Dealing with\n        nodes that do not support RSVP is important for\
    \ backwards\n        compatibility.  See section 2.9.\n   o    Object\n      \
    \  An element of an RSVP control message; a type, length, value\n        triplet.\n\
    \   o    OPWA\n        Abbreviation for \"One Pass With Advertising\".  Describes\
    \ a\n        reservation setup model in which (Path) messages sent downstream\n\
    \        gather information that the receiver(s) can use to predict the\n    \
    \    end-to-end service.  The information that is gathered is called\n       \
    \ an advertisement.  See also \"Adspec\".\n   o    Outgoing interface\n      \
    \  Interface through which data packets and Path messages are\n        forwarded.\n\
    \   o    Packet classifier\n        Traffic control function in the primary data\
    \ packet forwarding\n        path that selects a service class for each packet,\
    \ in accordance\n        with the reservation state set up by RSVP.  The packet\n\
    \        classifier may be combined with the routing function.  See also\n   \
    \     \"traffic control\".\n   o    Packet scheduler\n        Traffic control\
    \ function in the primary data packet forwarding\n        path that implements\
    \ QoS for each flow, using one of the service\n        models defined by the Integrated\
    \ Services Working Group.  See\n        also \" traffic control\".\n   o    Path\
    \ state\n        Information kept in routers and hosts about all RSVP senders.\n\
    \   o    PathErr\n        Path Error RSVP control message.\n   o    PathTear\n\
    \        Path Teardown RSVP control message.\n   o    PHOP\n        An object\
    \ that carries the Previous Hop information in RSVP\n        control messages.\n\
    \   o    Police\n        See traffic policing.\n   o    Policy control\n     \
    \   A function that determines whether a new request for quality of\n        service\
    \ has administrative permission to make the requested\n        reservation.  Policy\
    \ control may also perform accounting (usage\n        feedback) for a reservation.\n\
    \   o    Policy data\n        Data carried in a Path or Resv message and used\
    \ as input to\n        policy control to determine authorization and/or usage\
    \ feedback\n        for the given flow.\n   o    Previous hop\n        The previous\
    \ router in the direction of traffic flow.  Resv\n        messages flow towards\
    \ previous hops.\n   o    ProtocolId\n        The component of session identification\
    \ that specifies the IP\n        protocol number used by the data stream.\n  \
    \ o    QoS\n        Quality of Service.\n   o    Reservation state\n        Information\
    \ kept in RSVP-capable nodes about successful RSVP\n        reservation requests.\n\
    \   o    Reservation style\n        Describes a set of attributes for a reservation,\
    \ including the\n        sharing attributes and sender selection attributes. \
    \ See Section\n        1.3 for details.\n   o    Resv message\n        Reservation\
    \ request RSVP control message.\n   o    ResvConf\n        Reservation Confirmation\
    \ RSVP control message, confirms\n        successful installation of a reservation\
    \ at some upstream node.\n   o    ResvErr\n        Reservation Error control message,\
    \ indicates that a reservation\n        request has failed or an active reservation\
    \ has been preempted.\n   o    ResvTear\n        Reservation Teardown RSVP control\
    \ message, deletes reservation\n        state.\n   o    Rspec\n        The component\
    \ of a flowspec that defines a desired QoS.  The\n        Rspec format is opaque\
    \ to RSVP and is defined by the Integrated\n        Services Working Group of\
    \ the IETF.\n   o    RSVP_HOP\n        Object of an RSVP control message that\
    \ carries the PHOP or NHOP\n        address of the source of the message.\n  \
    \ o    Scope\n        The set of sender hosts to which a given reservation request\
    \ is\n        to be propagated.\n   o    SE style\n        Shared Explicit reservation\
    \ style, which has explicit sender\n        selection and shared attributes.\n\
    \   o    Semantic fragmentation\n        A method of fragmenting a large RSVP\
    \ message using information\n        about the structure and contents of the message,\
    \ so that each\n        fragment is a logically complete RSVP message.\n   o \
    \   Sender template\n        Parameter in a Path message that defines a sender;\
    \ carried in a\n        SENDER_TEMPLATE object.  It has the form of a filter spec\
    \ that\n        can be used to select this sender's packets from other packets\n\
    \        in the same session on the same link.\n   o    Sender Tspec\n       \
    \ Parameter in a Path message, a Tspec that characterizes the\n        traffic\
    \ parameters for the data flow from the corresponding\n        sender.  It is\
    \ carried in a SENDER_TSPEC object.\n   o    Session\n        An RSVP session\
    \ defines one simplex unicast or multicast data\n        flow for which reservations\
    \ are required.  A session is\n        identified by the destination address,\
    \ transport-layer protocol,\n        and an optional (generalized) destination\
    \ port.\n   o    Shared style\n        A (reservation) style attribute: all reserved\
    \ senders share the\n        same reserved resources.  See also \"distinct style\"\
    .\n   o    Soft state\n        Control state in hosts and routers that will expire\
    \ if not\n        refreshed within a specified amount of time.\n   o    STYLE\n\
    \        Object of an RSVP message that specifies the desired reservation\n  \
    \      style.\n   o    Style\n        See \"reservation style\"\n   o    TIME_VALUES\n\
    \        Object in an RSVP control message that specifies the time period\n  \
    \      timer used for refreshing the state in this message.\n   o    Traffic control\n\
    \        The entire set of machinery in the node that supplies requested\n   \
    \     QoS to data streams.  Traffic control includes packet\n        classifier,\
    \ packet scheduler, and admission control functions.\n   o    Traffic policing\n\
    \        The function, performed by traffic control, of forcing a given\n    \
    \    data flow into compliance with the traffic parameters implied by\n      \
    \  the reservation.  It may involve dropping non-compliant packets\n        or\
    \ sending them with lower priority, for example.\n   o    TSpec\n        A traffic\
    \ parameter set that describes a flow.  The format of a\n        Tspec is opaque\
    \ to RSVP and is defined by the Integrated Service\n        Working Group.\n \
    \  o    UDP encapsulation\n        A way for hosts that cannot use raw sockets\
    \ to participate in\n        RSVP by encapsulating the RSVP protocol (raw) packets\
    \ in\n        ordinary UDP packets.  See Section APPENDIX C for more\n       \
    \ information.\n   o    Upstream\n        Towards the traffic source.  RSVP Resv\
    \ messages flow upstream.\n   o    WF style\n        Wildcard Filter reservation\
    \ style, which has wildcard sender\n        selection and shared attributes.\n\
    \   o    Wildcard sender selection\n        A (reservation) style attribute: traffic\
    \ from any sender to a\n        specific session receives the same QoS.  See also\
    \ \"explicit\n        sender selection\".\n"
- title: References
  contents:
  - 'References

    '
- title: '[Baker96]  Baker, F., "RSVP Cryptographic Authentication", Work in'
  contents:
  - "[Baker96]  Baker, F., \"RSVP Cryptographic Authentication\", Work in\n    Progress.\n"
- title: '[RFC 1633]  Braden, R., Clark, D., and S. Shenker, "Integrated Services'
  contents:
  - "[RFC 1633]  Braden, R., Clark, D., and S. Shenker, \"Integrated Services\n  \
    \  in the Internet Architecture: an Overview\", RFC 1633, ISI, MIT, and\n    PARC,\
    \ June 1994.\n"
- title: '[FJ94]  Floyd, S. and V. Jacobson, "Synchronization of Periodic Routing'
  contents:
  - "[FJ94]  Floyd, S. and V. Jacobson, \"Synchronization of Periodic Routing\n  \
    \  Messages\", IEEE/ACM Transactions on Networking, Vol. 2, No. 2,\n    April,\
    \ 1994.\n"
- title: '[RFC 2207]  Berger, L. and T. O''Malley, "RSVP Extensions for IPSEC Data'
  contents:
  - "[RFC 2207]  Berger, L. and T. O'Malley, \"RSVP Extensions for IPSEC Data\n  \
    \  Flows\", RFC 2207, September 1997.\n"
- title: '[RFC 2113]  Katz, D., "IP Router Alert Option", RFC 2113, cisco Systems,'
  contents:
  - "[RFC 2113]  Katz, D., \"IP Router Alert Option\", RFC 2113, cisco Systems,\n\
    \    February 1997.\n"
- title: '[RFC 2210]  Wroclawski, J., "The Use of RSVP with Integrated Services",'
  contents:
  - "[RFC 2210]  Wroclawski, J., \"The Use of RSVP with Integrated Services\",\n \
    \   RFC 2210, September 1997.\n"
- title: '[PolArch96]  Herzog, S., "Policy Control for RSVP: Architectural'
  contents:
  - "[PolArch96]  Herzog, S., \"Policy Control for RSVP: Architectural\n    Overview\"\
    .  Work in Progress.\n"
- title: '[OPWA95]  Shenker, S. and L. Breslau, "Two Issues in Reservation'
  contents:
  - "[OPWA95]  Shenker, S. and L. Breslau, \"Two Issues in Reservation\n    Establishment\"\
    , Proc. ACM SIGCOMM '95, Cambridge, MA, August 1995.\n"
- title: '[RSVP93]  Zhang, L., Deering, S., Estrin, D., Shenker, S., and D.'
  contents:
  - "[RSVP93]  Zhang, L., Deering, S., Estrin, D., Shenker, S., and D.\n    Zappala,\
    \ \"RSVP: A New Resource ReSerVation Protocol\", IEEE Network,\n    September\
    \ 1993.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   See Section 2.8.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Bob Braden\n   USC Information Sciences Institute\n  \
    \ 4676 Admiralty Way\n   Marina del Rey, CA 90292\n   Phone: (310) 822-1511\n\
    \   EMail: Braden@ISI.EDU\n   Lixia Zhang\n   UCLA Computer Science Department\n\
    \   4531G Boelter Hall\n   Los Angeles, CA 90095-1596 USA\n   Phone: 310-825-2695\n\
    \   EMail: lixia@cs.ucla.edu\n   Steve Berson\n   USC Information Sciences Institute\n\
    \   4676 Admiralty Way\n   Marina del Rey, CA 90292\n   Phone: (310) 822-1511\n\
    \   EMail: Berson@ISI.EDU\n   Shai Herzog\n   IBM T. J. Watson Research Center\n\
    \   P.O Box 704\n   Yorktown Heights, NY 10598\n   Phone: (914) 784-6059\n   EMail:\
    \ Herzog@WATSON.IBM.COM\n   Sugih Jamin\n   University of Michigan\n   CSE/EECS\n\
    \   1301 Beal Ave.\n   Ann Arbor, MI 48109-2122\n   Phone: (313) 763-1583\n  \
    \ EMail: jamin@EECS.UMICH.EDU\n"
