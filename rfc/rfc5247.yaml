- title: __initial_text__
  contents:
  - '   Extensible Authentication Protocol (EAP) Key Management Framework

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Extensible Authentication Protocol (EAP), defined in RFC 3748,\n\
    \   enables extensible network access authentication.  This document\n   specifies\
    \ the EAP key hierarchy and provides a framework for the\n   transport and usage\
    \ of keying material and parameters generated by\n   EAP authentication algorithms,\
    \ known as \"methods\".  It also provides\n   a detailed system-level security\
    \ analysis, describing the conditions\n   under which the key management guidelines\
    \ described in RFC 4962 can\n   be satisfied.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Requirements Language ......................................3\n  \
    \    1.2. Terminology ................................................3\n    \
    \  1.3. Overview ...................................................7\n      1.4.\
    \ EAP Key Hierarchy .........................................10\n      1.5. Security\
    \ Goals ............................................15\n      1.6. EAP Invariants\
    \ ............................................16\n   2. Lower-Layer Operation\
    \ ..........................................20\n      2.1. Transient Session Keys\
    \ ....................................20\n      2.2. Authenticator and Peer Architecture\
    \ .......................22\n      2.3. Authenticator Identification ..............................23\n\
    \      2.4. Peer Identification .......................................27\n  \
    \    2.5. Server Identification .....................................29\n   3.\
    \ Security Association Management ................................31\n      3.1.\
    \ Secure Association Protocol ...............................32\n      3.2. Key\
    \ Scope .................................................35\n      3.3. Parent-Child\
    \ Relationships ................................35\n      3.4. Local Key Lifetimes\
    \ .......................................37\n      3.5. Exported and Calculated\
    \ Key Lifetimes .....................37\n      3.6. Key Cache Synchronization\
    \ .................................40\n      3.7. Key Strength ..............................................40\n\
    \      3.8. Key Wrap ..................................................41\n  \
    \ 4. Handoff Vulnerabilities ........................................41\n    \
    \  4.1. EAP Pre-Authentication ....................................43\n      4.2.\
    \ Proactive Key Distribution ................................44\n      4.3. AAA\
    \ Bypass ................................................46\n   5. Security Considerations\
    \ ........................................50\n      5.1. Peer and Authenticator\
    \ Compromise .........................51\n      5.2. Cryptographic Negotiation\
    \ .................................53\n      5.3. Confidentiality and Authentication\
    \ ........................54\n      5.4. Key Binding ...............................................59\n\
    \      5.5. Authorization .............................................60\n  \
    \    5.6. Replay Protection .........................................63\n    \
    \  5.7. Key Freshness .............................................64\n      5.8.\
    \ Key Scope Limitation ......................................66\n      5.9. Key\
    \ Naming ................................................66\n      5.10. Denial-of-Service\
    \ Attacks ................................67\n   6. References .....................................................68\n\
    \      6.1. Normative References ......................................68\n  \
    \    6.2. Informative References ....................................68\n   Acknowledgments\
    \ ...................................................74\n   Appendix A - Exported\
    \ Parameters in Existing Methods ..............75\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Extensible Authentication Protocol (EAP), defined in\
    \ [RFC3748],\n   was designed to enable extensible authentication for network\
    \ access\n   in situations in which the Internet Protocol (IP) protocol is not\n\
    \   available.  Originally developed for use with Point-to-Point Protocol\n  \
    \ (PPP) [RFC1661], it has subsequently also been applied to IEEE 802\n   wired\
    \ networks [IEEE-802.1X], Internet Key Exchange Protocol version\n   2 (IKEv2)\
    \ [RFC4306], and wireless networks such as [IEEE-802.11] and\n   [IEEE-802.16e].\n\
    \   EAP is a two-party protocol spoken between the EAP peer and server.\n   Within\
    \ EAP, keying material is generated by EAP authentication\n   algorithms, known\
    \ as \"methods\".  Part of this keying material can be\n   used by EAP methods\
    \ themselves, and part of this material can be\n   exported.  In addition to the\
    \ export of keying material, EAP methods\n   can also export associated parameters\
    \ such as authenticated peer and\n   server identities and a unique EAP conversation\
    \ identifier, and can\n   import and export lower-layer parameters known as \"\
    channel binding\n   parameters\", or simply \"channel bindings\".\n   This document\
    \ specifies the EAP key hierarchy and provides a\n   framework for the transport\
    \ and usage of keying material and\n   parameters generated by EAP methods.  It\
    \ also provides a detailed\n   security analysis, describing the conditions under\
    \ which the\n   requirements described in \"Guidance for Authentication,\n   Authorization,\
    \ and Accounting (AAA) Key Management\" [RFC4962] can be\n   satisfied.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   The terms \"Cryptographic binding\", \"Cryptographic separation\"\
    , \"Key\n   strength\" and \"Mutual authentication\" are defined in [RFC3748]\
    \ and\n   are used with the same meaning in this document, which also\n   frequently\
    \ uses the following terms:\n   4-Way Handshake\n      A pairwise Authentication\
    \ and Key Management Protocol (AKMP)\n      defined in [IEEE-802.11], which confirms\
    \ mutual possession of a\n      Pairwise Master Key by two parties and distributes\
    \ a Group Key.\n   AAA  Authentication, Authorization, and Accounting\n      AAA\
    \ protocols with EAP support include \"RADIUS Support for EAP\"\n      [RFC3579]\
    \ and \"Diameter EAP Application\" [RFC4072].  In this\n      document, the terms\
    \ \"AAA server\" and \"backend authentication\n      server\" are used interchangeably.\n\
    \   AAA-Key\n      The term AAA-Key is synonymous with Master Session Key (MSK).\n\
    \      Since multiple keys can be transported by AAA, the term is\n      potentially\
    \ confusing and is not used in this document.\n   Authenticator\n      The entity\
    \ initiating EAP authentication.\n   Backend Authentication Server\n      A backend\
    \ authentication server is an entity that provides an\n      authentication service\
    \ to an authenticator.  When used, this\n      server typically executes EAP methods\
    \ for the authenticator.  This\n      terminology is also used in [IEEE-802.1X].\n\
    \   Channel Binding\n      A secure mechanism for ensuring that a subset of the\
    \ parameters\n      transmitted by the authenticator (such as authenticator\n\
    \      identifiers and properties) are agreed upon by the EAP peer and\n     \
    \ server.  It is expected that the parameters are also securely\n      agreed\
    \ upon by the EAP peer and authenticator via the lower layer\n      if the authenticator\
    \ advertised the parameters.\n   Derived Keying Material\n      Keys derived from\
    \ EAP keying material, such as Transient Session\n      Keys (TSKs).\n   EAP Keying\
    \ Material\n      Keys derived by an EAP method; this includes exported keying\n\
    \      material (MSK, Extended MSK (EMSK), Initialization Vector (IV)) as\n  \
    \    well as local keying material such as Transient EAP Keys (TEKs).\n   EAP\
    \ Pre-Authentication\n      The use of EAP to pre-establish EAP keying material\
    \ on an\n      authenticator prior to arrival of the peer at the access network\n\
    \      managed by that authenticator.\n   EAP Re-Authentication\n      EAP authentication\
    \ between an EAP peer and a server with whom the\n      EAP peer shares valid\
    \ unexpired EAP keying material.\n   EAP Server\n      The entity that terminates\
    \ the EAP authentication method with the\n      peer.  In the case where no backend\
    \ authentication server is used,\n      the EAP server is part of the authenticator.\
    \  In the case where\n      the authenticator operates in pass-through mode, the\
    \ EAP server is\n      located on the backend authentication server.\n   Exported\
    \ Keying Material\n      The EAP Master Session Key (MSK), Extended Master Session\
    \ Key\n      (EMSK), and Initialization Vector (IV).\n   Extended Master Session\
    \ Key (EMSK)\n      Additional keying material derived between the peer and server\n\
    \      that is exported by the EAP method.  The EMSK is at least 64\n      octets\
    \ in length and is never shared with a third party.  The EMSK\n      MUST be at\
    \ least as long as the MSK in size.\n   Initialization Vector (IV)\n      A quantity\
    \ of at least 64 octets, suitable for use in an\n      initialization vector field,\
    \ that is derived between the peer and\n      EAP server.  Since the IV is a known\
    \ value in methods such as\n      EAP-TLS (Transport Layer Security) [RFC5216],\
    \ it cannot be used by\n      itself for computation of any quantity that needs\
    \ to remain\n      secret.  As a result, its use has been deprecated and it is\n\
    \      OPTIONAL for EAP methods to generate it.  However, when it is\n      generated,\
    \ it MUST be unpredictable.\n   Keying Material\n      Unless otherwise qualified,\
    \ the term \"keying material\" refers to\n      EAP keying material as well as\
    \ derived keying material.\n   Key Scope\n      The parties to whom a key is available.\n\
    \   Key Wrap\n      The encryption of one symmetric cryptographic key in another.\
    \  The\n      algorithm used for the encryption is called a key wrap algorithm\n\
    \      or a key encryption algorithm.  The key used in the encryption\n      process\
    \ is called a key-encryption key (KEK).\n   Long-Term Credential\n      EAP methods\
    \ frequently make use of long-term secrets in order to\n      enable authentication\
    \ between the peer and server.  In the case of\n      a method based on pre-shared\
    \ key authentication, the long-term\n      credential is the pre-shared key. \
    \ In the case of a\n      public-key-based method, the long-term credential is\
    \ the\n      corresponding private key.\n   Lower Layer\n      The lower layer\
    \ is responsible for carrying EAP frames between the\n      peer and authenticator.\n\
    \   Lower-Layer Identity\n      A name used to identify the EAP peer and authenticator\
    \ within the\n      lower layer.\n   Master Session Key (MSK)\n      Keying material\
    \ that is derived between the EAP peer and server\n      and exported by the EAP\
    \ method.  The MSK is at least 64 octets in\n      length.\n   Network Access\
    \ Server (NAS)\n      A device that provides an access service for a user to a\
    \ network.\n   Pairwise Master Key (PMK)\n      Lower layers use the MSK in a\
    \ lower-layer dependent manner.  For\n      instance, in IEEE 802.11 [IEEE-802.11],\
    \ Octets 0-31 of the MSK are\n      known as the Pairwise Master Key (PMK); the\
    \ Temporal Key Integrity\n      Protocol (TKIP) and Advanced Encryption Standard\
    \ Counter Mode with\n      CBC-MAC Protocol (AES CCMP) ciphersuites derive their\
    \ Transient\n      Session Keys (TSKs) solely from the PMK, whereas the Wired\n\
    \      Equivalent Privacy (WEP) ciphersuite, as noted in \"IEEE 802.1X\n     \
    \ RADIUS Usage Guidelines\" [RFC3580], derives its TSKs from both\n      halves\
    \ of the MSK.  In [IEEE-802.16e], the MSK is truncated to 20\n      octets for\
    \ PMK and 20 octets for PMK2.\n   Peer\n      The entity that responds to the\
    \ authenticator.  In [IEEE-802.1X],\n      this entity is known as the Supplicant.\n\
    \   Security Association\n      A set of policies and cryptographic state used\
    \ to protect\n      information.  Elements of a security association include\n\
    \      cryptographic keys, negotiated ciphersuites and other parameters,\n   \
    \   counters, sequence spaces, authorization attributes, etc.\n   Secure Association\
    \ Protocol\n      An exchange that occurs between the EAP peer and authenticator\
    \ in\n      order to manage security associations derived from EAP exchanges.\n\
    \      The protocol establishes unicast and (optionally) multicast\n      security\
    \ associations, which include symmetric keys and a context\n      for the use\
    \ of the keys.  An example of a Secure Association\n      Protocol is the 4-way\
    \ handshake defined within [IEEE-802.11].\n   Session-Id\n      The EAP Session-Id\
    \ uniquely identifies an EAP authentication\n      exchange between an EAP peer\
    \ (as identified by the Peer-Id(s)) and\n      server (as identified by the Server-Id(s)).\
    \  For more information,\n      see Section 1.4.\n   Transient EAP Keys (TEKs)\n\
    \      Session keys that are used to establish a protected channel\n      between\
    \ the EAP peer and server during the EAP authentication\n      exchange.  The\
    \ TEKs are appropriate for use with the ciphersuite\n      negotiated between\
    \ EAP peer and server for use in protecting the\n      EAP conversation.  The\
    \ TEKs are stored locally by the EAP method\n      and are not exported.  Note\
    \ that the ciphersuite used to set up\n      the protected channel between the\
    \ EAP peer and server during EAP\n      authentication is unrelated to the ciphersuite\
    \ used to\n      subsequently protect data sent between the EAP peer and\n   \
    \   authenticator.\n   Transient Session Keys (TSKs)\n      Keys used to protect\
    \ data exchanged after EAP authentication has\n      successfully completed using\
    \ the ciphersuite negotiated between\n      the EAP peer and authenticator.\n"
- title: 1.3.  Overview
  contents:
  - "1.3.  Overview\n   Where EAP key derivation is supported, the conversation typically\n\
    \   takes place in three phases:\n      Phase 0: Discovery\n      Phase 1: Authentication\n\
    \               1a: EAP authentication\n               1b: AAA Key Transport (optional)\n\
    \      Phase 2: Secure Association Protocol\n               2a: Unicast Secure\
    \ Association\n               2b: Multicast Secure Association (optional)\n  \
    \ Of these phases, phase 0, 1b, and 2 are handled external to EAP.\n   phases\
    \ 0 and 2 are handled by the lower-layer protocol, and phase 1b\n   is typically\
    \ handled by a AAA protocol.\n   In the discovery phase (phase 0), peers locate\
    \ authenticators and\n   discover their capabilities.  A peer can locate an authenticator\n\
    \   providing access to a particular network, or a peer can locate an\n   authenticator\
    \ behind a bridge with which it desires to establish a\n   Secure Association.\
    \  Discovery can occur manually or automatically,\n   depending on the lower layer\
    \ over which EAP runs.\n   The authentication phase (phase 1) can begin once the\
    \ peer and\n   authenticator discover each other.  This phase, if it occurs, always\n\
    \   includes EAP authentication (phase 1a).  Where the chosen EAP method\n   supports\
    \ key derivation, in phase 1a, EAP keying material is derived\n   on both the\
    \ peer and the EAP server.\n   An additional step (phase 1b) is needed in deployments\
    \ that include a\n   backend authentication server, in order to transport keying\
    \ material\n   from the backend authentication server to the authenticator.  In\n\
    \   order to obey the principle of mode independence (see Section 1.6.1),\n  \
    \ where a backend authentication server is present, all keying material\n   needed\
    \ by the lower layer is transported from the EAP server to the\n   authenticator.\
    \  Since existing TSK derivation and transport\n   techniques depend solely on\
    \ the MSK, in existing implementations,\n   this is the only keying material replicated\
    \ in the AAA key transport\n   phase 1b.\n   Successful completion of EAP authentication\
    \ and key derivation by a\n   peer and EAP server does not necessarily imply that\
    \ the peer is\n   committed to joining the network associated with an EAP server.\n\
    \   Rather, this commitment is implied by the creation of a security\n   association\
    \ between the EAP peer and authenticator, as part of the\n   Secure Association\
    \ Protocol (phase 2).  The Secure Association\n   Protocol exchange (phase 2)\
    \ occurs between the peer and authenticator\n   in order to manage the creation\
    \ and deletion of unicast (phase 2a)\n   and multicast (phase 2b) security associations\
    \ between the peer and\n   authenticator.  The conversation between the parties\
    \ is shown in\n   Figure 1.\n   EAP peer                   Authenticator     \
    \          Auth. Server\n   --------                   -------------         \
    \      ------------\n    |<----------------------------->|                   \
    \            |\n    |     Discovery (phase 0)       |                        \
    \       |\n    |<----------------------------->|<----------------------------->|\n\
    \    |   EAP auth (phase 1a)         |  AAA pass-through (optional)  |\n    |\
    \                               |                               |\n    |     \
    \                          |<----------------------------->|\n    |          \
    \                     |       AAA Key transport       |\n    |               \
    \                |      (optional; phase 1b)     |\n    |<----------------------------->|\
    \                               |\n    |  Unicast Secure association   |     \
    \                          |\n    |          (phase 2a)           |          \
    \                     |\n    |                               |               \
    \                |\n    |<----------------------------->|                    \
    \           |\n    | Multicast Secure association  |                         \
    \      |\n    |     (optional; phase 2b)      |                              \
    \ |\n    |                               |                               |\n \
    \                 Figure 1: Conversation Overview\n"
- title: 1.3.1.  Examples
  contents:
  - "1.3.1.  Examples\n   Existing EAP lower layers implement phase 0, 2a, and 2b\
    \ in different\n   ways:\n   PPP\n      The Point-to-Point Protocol (PPP), defined\
    \ in [RFC1661], does not\n      support discovery, nor does it include a Secure\
    \ Association\n      Protocol.\n   PPPoE\n      PPP over Ethernet (PPPoE), defined\
    \ in [RFC2516], includes support\n      for a Discovery stage (phase 0).  In this\
    \ step, the EAP peer sends\n      a PPPoE Active Discovery Initiation (PADI) packet\
    \ to the broadcast\n      address, indicating the service it is requesting.  The\
    \ Access\n      Concentrator replies with a PPPoE Active Discovery Offer (PADO)\n\
    \      packet containing its name, the service name, and an indication of\n  \
    \    the services offered by the concentrator.  The discovery phase is\n     \
    \ not secured.  PPPoE, like PPP, does not include a Secure\n      Association\
    \ Protocol.\n   IKEv2\n      Internet Key Exchange v2 (IKEv2), defined in [RFC4306],\
    \ includes\n      support for EAP and handles the establishment of unicast security\n\
    \      associations (phase 2a).  However, the establishment of multicast\n   \
    \   security associations (phase 2b) typically does not involve EAP\n      and\
    \ needs to be handled by a group key management protocol such as\n      Group\
    \ Domain of Interpretation (GDOI) [RFC3547], Group Secure\n      Association Key\
    \ Management Protocol (GSAKMP) [RFC4535], Multimedia\n      Internet KEYing  (MIKEY)\
    \ [RFC3830], or Group Key Distribution\n      Protocol (GKDP) [GKDP].  Several\
    \ mechanisms have been proposed for\n      the discovery of IPsec security gateways.\
    \  [RFC2230] discusses the\n      use of Key eXchange (KX) Resource Records (RRs)\
    \ for IPsec gateway\n      discovery; while KX RRs are supported by many Domain\
    \ Name Service\n      (DNS) server implementations, they have not yet been widely\n\
    \      deployed.  Alternatively, DNS SRV RRs [RFC2782] can be used for\n     \
    \ this purpose.  Where DNS is used for gateway location, DNS\n      security mechanisms\
    \ such as DNS Security (DNSSEC) ([RFC4033],\n      [RFC4035]), TSIG [RFC2845],\
    \ and Simple Secure Dynamic Update\n      [RFC3007] are available.\n   IEEE 802.11\n\
    \      IEEE 802.11, defined in [IEEE-802.11], handles discovery via the\n    \
    \  Beacon and Probe Request/Response mechanisms.  IEEE 802.11 Access\n      Points\
    \ (APs) periodically announce their Service Set Identifiers\n      (SSIDs) as\
    \ well as capabilities using Beacon frames.  Stations can\n      query for APs\
    \ by sending a Probe Request.  Neither Beacon nor\n      Probe Request/Response\
    \ frames are secured.  The 4-way handshake\n      defined in [IEEE-802.11] enables\
    \ the derivation of unicast (phase\n      2a) and multicast/broadcast (phase 2b)\
    \ secure associations.  Since\n      the group key exchange transports a group\
    \ key from the AP to the\n      station, two 4-way handshakes can be needed in\
    \ order to support\n      peer-to-peer communications.  A proof of the security\
    \ of the IEEE\n      802.11 4-way handshake, when used with EAP-TLS, is provided\
    \ in\n      [He].\n   IEEE 802.1X\n      IEEE 802.1X-2004, defined in [IEEE-802.1X],\
    \ does not support\n      discovery (phase 0), nor does it provide for derivation\
    \ of unicast\n      or multicast secure associations.\n"
- title: 1.4.  EAP Key Hierarchy
  contents:
  - "1.4.  EAP Key Hierarchy\n   As illustrated in Figure 2, the EAP method key derivation\
    \ has, at the\n   root, the long-term credential utilized by the selected EAP\
    \ method.\n   If authentication is based on a pre-shared key, the parties store\
    \ the\n   EAP method to be used and the pre-shared key.  The EAP server also\n\
    \   stores the peer's identity as well as additional information.  This\n   information\
    \ is typically used outside of the EAP method to determine\n   whether to grant\
    \ access to a service.  The peer stores information\n   necessary to choose which\
    \ secret to use for which service.\n   If authentication is based on proof of\
    \ possession of the private key\n   corresponding to the public key contained\
    \ within a certificate, the\n   parties store the EAP method to be used and the\
    \ trust anchors used to\n   validate the certificates.  The EAP server also stores\
    \ the peer's\n   identity, and the peer stores information necessary to choose\
    \ which\n   certificate to use for which service.  Based on the long-term\n  \
    \ credential established between the peer and the server, methods\n   derive two\
    \ types of EAP keying material:\n      (a) Keying material calculated locally\
    \ by the EAP method but not\n          exported, such as the Transient EAP Keys\
    \ (TEKs).\n      (b) Keying material exported by the EAP method: Master Session\
    \ Key\n          (MSK), Extended Master Session Key (EMSK), Initialization\n \
    \         Vector (IV).\n   As noted in [RFC3748] Section 7.10:\n      In order\
    \ to provide keying material for use in a subsequently\n      negotiated ciphersuite,\
    \ an EAP method supporting key derivation\n      MUST export a Master Session\
    \ Key (MSK) of at least 64 octets, and\n      an Extended Master Session Key (EMSK)\
    \ of at least 64 octets.\n   EAP methods also MAY export the IV; however, the\
    \ use of the IV is\n   deprecated.  The EMSK MUST NOT be provided to an entity\
    \ outside the\n   EAP server or peer, nor is it permitted to pass any quantity\
    \ to an\n   entity outside the EAP server or peer from which the EMSK could be\n\
    \   computed without breaking some cryptographic assumption, such as\n   inverting\
    \ a one-way function.\n   EAP methods supporting key derivation and mutual authentication\n\
    \   SHOULD export a method-specific EAP conversation identifier known as\n   the\
    \ Session-Id, as well as one or more method-specific peer\n   identifiers (Peer-Id(s))\
    \ and MAY export one or more method-specific\n   server identifiers (Server-Id(s)).\
    \  EAP methods MAY also support the\n   import and export of channel binding parameters.\
    \  EAP method\n   specifications developed after the publication of this document\
    \ MUST\n   define the Peer-Id, Server-Id, and Session-Id.  The Peer-Id(s) and\n\
    \   Server-Id(s), when provided, identify the entities involved in\n   generating\
    \ EAP keying material.  For existing EAP methods, the\n   Peer-Id, Server-Id,\
    \ and Session-Id are defined in Appendix A.\n"
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         ---+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         ---+

    '
- title: '|                                                         |            ^'
  contents:
  - '|                                                         |            ^

    '
- title: '|                EAP Method                               |            |'
  contents:
  - '|                EAP Method                               |            |

    '
- title: '|                                                         |            |'
  contents:
  - '|                                                         |            |

    '
- title: '| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+   |            |'
  contents:
  - '| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+   |            |

    '
- title: '| |                                 |   |             |   |            |'
  contents:
  - '| |                                 |   |             |   |            |

    '
- title: '| |       EAP Method Key            |<->| Long-Term   |   |            |'
  contents:
  - '| |       EAP Method Key            |<->| Long-Term   |   |            |

    '
- title: '| |         Derivation              |   | Credential  |   |            |'
  contents:
  - '| |         Derivation              |   | Credential  |   |            |

    '
- title: '| |                                 |   |             |   |            |'
  contents:
  - '| |                                 |   |             |   |            |

    '
- title: '| |                                 |   +-+-+-+-+-+-+-+   |  Local to  |'
  contents:
  - '| |                                 |   +-+-+-+-+-+-+-+   |  Local to  |

    '
- title: '| |                                 |                     |       EAP  |'
  contents:
  - '| |                                 |                     |       EAP  |

    '
- title: '| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                     |     Method |'
  contents:
  - '| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                     |     Method |

    '
- title: '|   |             |               |                       |            |'
  contents:
  - '|   |             |               |                       |            |

    '
- title: '|   |             |               |                       |            |'
  contents:
  - '|   |             |               |                       |            |

    '
- title: '|   |             |               |                       |            |'
  contents:
  - '|   |             |               |                       |            |

    '
- title: '|   |             |               |                       |            |'
  contents:
  - '|   |             |               |                       |            |

    '
- title: '|   |         +-+-+-+-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+ |            |'
  contents:
  - '|   |         +-+-+-+-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+ |            |

    '
- title: '|   |         | TEK       | |MSK, EMSK  | |IV           | |            |'
  contents:
  - '|   |         | TEK       | |MSK, EMSK  | |IV           | |            |

    '
- title: '|   |         |Derivation | |Derivation | |Derivation   | |            |'
  contents:
  - '|   |         |Derivation | |Derivation | |Derivation   | |            |

    '
- title: '|   |         |           | |           | |(Deprecated) | |            |'
  contents:
  - '|   |         |           | |           | |(Deprecated) | |            |

    '
- title: '|   |         +-+-+-+-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+ |            |'
  contents:
  - '|   |         +-+-+-+-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+ |            |

    '
- title: '|   |               ^             |               |       |            |'
  contents:
  - '|   |               ^             |               |       |            |

    '
- title: '|   |               |             |               |       |            V'
  contents:
  - '|   |               |             |               |       |            V

    '
- title: +-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+         ---+
  contents:
  - "+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+         ---+\n  \
    \  |               |             |               |                    ^\n    |\
    \               |             |               |           Exported |\n    | Peer-Id(s),\
    \   | channel     | MSK (64+B)    | IV (64B)      by   |\n    | Server-Id(s),\
    \ | bindings    | EMSK (64+B)   | (Optional)    EAP  |\n    | Session-Id    |\
    \ & Result    |               |             Method |\n    V               V  \
    \           V               V                    V\n     Figure 2:  EAP Method\
    \ Parameter Import/Export\n   Peer-Id\n      If an EAP method that generates keys\
    \ authenticates one or more\n      method-specific peer identities, those identities\
    \ are exported by\n      the method as the Peer-Id(s).  It is possible for more\
    \ than one\n      Peer-Id to be exported by an EAP method.  Not all EAP methods\n\
    \      provide a method-specific peer identity; where this is not\n      defined,\
    \ the Peer-Id is the null string.  In EAP methods that do\n      not support key\
    \ generation, the Peer-Id MUST be the null string.\n      Where an EAP method\
    \ that derives keys does not provide a Peer-Id,\n      the EAP server will not\
    \ authenticate the identity of the EAP peer\n      with which it derived keying\
    \ material.\n   Server-Id\n      If an EAP method that generates keys authenticates\
    \ one or more\n      method-specific server identities, those identities are exported\n\
    \      by the method as the Server-Id(s).  It is possible for more than\n    \
    \  one Server-Id to be exported by an EAP method.  Not all EAP\n      methods\
    \ provide a method-specific server identity; where this is\n      not defined,\
    \ the Server-Id is the null string.  If the EAP method\n      does not generate\
    \ keying material, the Server-Id MUST be the null\n      string.  Where an EAP\
    \ method that derives keys does not provide a\n      Server-Id, the EAP peer will\
    \ not authenticate the identity of the\n      EAP server with which it derived\
    \ EAP keying material.\n   Session-Id\n      The Session-Id uniquely identifies\
    \ an EAP session between an EAP\n      peer (as identified by the Peer-Id) and\
    \ server (as identified by\n      the Server-Id).  Where non-expanded EAP Type\
    \ Codes are used (EAP\n      Type Code not equal to 254), the EAP Session-Id is\
    \ the\n      concatenation of the single octet EAP Type Code and a temporally\n\
    \      unique identifier obtained from the method (known as the\n      Method-Id):\n\
    \      Session-Id = Type-Code || Method-Id\n      Where expanded EAP Type Codes\
    \ are used, the EAP Session-Id\n      consists of the Expanded Type Code (including\
    \ the Type, Vendor-Id\n      (in network byte order) and Vendor-Type fields (in\
    \ network byte\n      order) defined in [RFC3748] Section 5.7), concatenated with\
    \ a\n      temporally unique identifier obtained from the method (Method-Id):\n\
    \      Session-Id = 0xFE || Vendor-Id || Vendor-Type || Method-Id\n      The Method-Id\
    \ is typically constructed from nonces or counters\n      used within the EAP\
    \ method exchange.  The inclusion of the Type\n      Code or Expanded Type Code\
    \ in the EAP Session-Id ensures that each\n      EAP method has a distinct Session-Id\
    \ space.  Since an EAP session\n      is not bound to a particular authenticator\
    \ or specific ports on\n      the peer and authenticator, the authenticator port\
    \ or identity are\n      not included in the Session-Id.\n   Channel Binding\n\
    \      Channel binding is the process by which lower-layer parameters are\n  \
    \    verified for consistency between the EAP peer and server.  In\n      order\
    \ to avoid introducing media dependencies, EAP methods that\n      transport channel\
    \ binding parameters MUST treat this data as\n      opaque octets.  See Section\
    \ 5.3.3 for further discussion.\n"
- title: 1.4.1.  Key Naming
  contents:
  - "1.4.1.  Key Naming\n   Each key created within the EAP key management framework\
    \ has a name\n   (a unique identifier), as well as a scope (the parties to whom\
    \ the\n   key is available).  The scope of exported keying material and TEKs is\n\
    \   defined by the authenticated method-specific peer identities\n   (Peer-Id(s))\
    \ and the authenticated server identities (Server-Id(s)),\n   where available.\n\
    \   MSK and EMSK Names\n        The MSK and EMSK are exported by the EAP peer\
    \ and EAP server,\n        and MUST be named using the EAP Session-Id and a binary\
    \ or\n        textual indication of the EAP keying material being referred to.\n\
    \   PMK Name\n        This document does not specify a naming scheme for the Pairwise\n\
    \        Master Key (PMK).  The PMK is only identified by the name of the\n  \
    \      key from which it is derived.\n        Note: IEEE 802.11 names the PMK\
    \ for the purposes of being able\n        to refer to it in the Secure Association\
    \ Protocol; the PMK name\n        (known as the PMKID) is based on a hash of the\
    \ PMK itself as\n        well as some other parameters (see [IEEE-802.11] Section\n\
    \        8.5.1.2).\n   TEK Name\n        Transient EAP Keys (TEKs) MAY be named;\
    \ their naming is\n        specified in the EAP method specification.\n   TSK\
    \ Name\n        Transient Session Keys (TSKs) are typically named.  Their naming\n\
    \        is specified in the lower layer so that the correct set of TSKs\n   \
    \     can be identified for processing a given packet.\n"
- title: 1.5.  Security Goals
  contents:
  - "1.5.  Security Goals\n   The goal of the EAP conversation is to derive fresh\
    \ session keys\n   between the EAP peer and authenticator that are known only\
    \ to those\n   parties, and for both the EAP peer and authenticator to demonstrate\n\
    \   that they are authorized to perform their roles either by each other\n   or\
    \ by a trusted third party (the backend authentication server).\n   Completion\
    \ of an EAP method exchange (phase 1a) supporting key\n   derivation results in\
    \ the derivation of EAP keying material (MSK,\n   EMSK, TEKs) known only to the\
    \ EAP peer (identified by the Peer-Id(s))\n   and EAP server (identified by the\
    \ Server-Id(s)).  Both the EAP peer\n   and EAP server know this keying material\
    \ to be fresh.  The Peer-Id\n   and Server-Id are discussed in Sections 1.4, 2.4,\
    \ and 2.5 as well as\n   in Appendix A.  Key freshness is discussed in Sections\
    \ 3.4, 3.5, and\n   5.7.\n   Completion of the AAA exchange (phase 1b) results\
    \ in the transport of\n   keying material from the EAP server (identified by the\
    \ Server-Id(s))\n   to the EAP authenticator (identified by the NAS-Identifier)\
    \ without\n   disclosure to any other party.  Both the EAP server and EAP\n  \
    \ authenticator know this keying material to be fresh.  Disclosure\n   issues\
    \ are discussed in Sections 3.8 and 5.3; security properties of\n   AAA protocols\
    \ are discussed in Sections 5.1 - 5.9.\n   The backend authentication server is\
    \ trusted to transport keying\n   material only to the authenticator that was\
    \ established with the\n   peer, and it is trusted to transport that keying material\
    \ to no other\n   parties.  In many systems, EAP keying material established by\
    \ the EAP\n   peer and EAP server are combined with publicly available data to\n\
    \   derive other keys.  The backend authentication server is trusted to\n   refrain\
    \ from deriving these same keys or acting as a\n   man-in-the-middle even though\
    \ it has access to the keying material\n   that is needed to do so.\n   The authenticator\
    \ is also a trusted party.  The authenticator is\n   trusted not to distribute\
    \ keying material provided by the backend\n   authentication server to any other\
    \ parties.  If the authenticator\n   uses a key derivation function to derive\
    \ additional keying material,\n   the authenticator is trusted to distribute the\
    \ derived keying\n   material only to the appropriate party that is known to the\
    \ peer, and\n   no other party.  When this approach is used, care must be taken\
    \ to\n   ensure that the resulting key management system meets all of the\n  \
    \ principles in [RFC4962], confirming that keys used to protect data\n   are to\
    \ be known only by the peer and authenticator.\n   Completion of the Secure Association\
    \ Protocol (phase 2) results in\n   the derivation or transport of Transient Session\
    \ Keys (TSKs) known\n   only to the EAP peer (identified by the Peer-Id(s)) and\
    \ authenticator\n   (identified by the NAS-Identifier).  Both the EAP peer and\n\
    \   authenticator know the TSKs to be fresh.  Both the EAP peer and\n   authenticator\
    \ demonstrate that they are authorized to perform their\n   roles.  Authorization\
    \ issues are discussed in Sections 4.3.2 and 5.5;\n   security properties of Secure\
    \ Association Protocols are discussed in\n   Section 3.1.\n"
- title: 1.6.  EAP Invariants
  contents:
  - "1.6.  EAP Invariants\n   Certain basic characteristics, known as \"EAP Invariants\"\
    , hold true\n   for EAP implementations:\n      Mode independence\n      Media\
    \ independence\n      Method independence\n      Ciphersuite independence\n"
- title: 1.6.1.  Mode Independence
  contents:
  - "1.6.1.  Mode Independence\n   EAP is typically deployed to support extensible\
    \ network access\n   authentication in situations where a peer desires network\
    \ access via\n   one or more authenticators.  Where authenticators are deployed\n\
    \   standalone, the EAP conversation occurs between the peer and\n   authenticator,\
    \ and the authenticator locally implements one or more\n   EAP methods.  However,\
    \ when utilized in \"pass-through\" mode, EAP\n   enables the deployment of new\
    \ authentication methods without\n   requiring the development of new code on\
    \ the authenticator.\n   While the authenticator can implement some EAP methods\
    \ locally and\n   use those methods to authenticate local users, it can at the\
    \ same\n   time act as a pass-through for other users and methods, forwarding\n\
    \   EAP packets back and forth between the backend authentication server\n   and\
    \ the peer.  This is accomplished by encapsulating EAP packets\n   within the\
    \ Authentication, Authorization, and Accounting (AAA)\n   protocol spoken between\
    \ the authenticator and backend authentication\n   server.  AAA protocols supporting\
    \ EAP include RADIUS [RFC3579] and\n   Diameter [RFC4072].\n   It is a fundamental\
    \ property of EAP that at the EAP method layer, the\n   conversation between the\
    \ EAP peer and server is unaffected by whether\n   the EAP authenticator is operating\
    \ in \"pass-through\" mode.  EAP\n   methods operate identically in all aspects,\
    \ including key derivation\n   and parameter import/export, regardless of whether\
    \ or not the\n   authenticator is operating as a pass-through.\n   The successful\
    \ completion of an EAP method that supports key\n   derivation results in the\
    \ export of EAP keying material and\n   parameters on the EAP peer and server.\
    \  Even though the EAP peer or\n   server can import channel binding parameters\
    \ that can include the\n   identity of the EAP authenticator, this information\
    \ is treated as\n   opaque octets.  As a result, within EAP, the only relevant\
    \ identities\n   are the Peer-Id(s) and Server-Id(s).  Channel binding parameters\
    \ are\n   only interpreted by the lower layer.\n   Within EAP, the primary function\
    \ of the AAA protocol is to maintain\n   the principle of mode independence. \
    \ As far as the EAP peer is\n   concerned, its conversation with the EAP authenticator,\
    \ and all\n   consequences of that conversation, are identical, regardless of\
    \ the\n   authenticator mode of operation.\n"
- title: 1.6.2.  Media Independence
  contents:
  - "1.6.2.  Media Independence\n   One of the goals of EAP is to allow EAP methods\
    \ to function on any\n   lower layer meeting the criteria outlined in [RFC3748]\
    \ Section 3.1.\n   For example, as described in [RFC3748], EAP authentication\
    \ can be run\n   over PPP [RFC1661], IEEE 802 wired networks [IEEE-802.1X], and\n\
    \   wireless networks such as 802.11 [IEEE-802.11] and 802.16\n   [IEEE-802.16e].\n\
    \   In order to maintain media independence, it is necessary for EAP to\n   avoid\
    \ consideration of media-specific elements.  For example, EAP\n   methods cannot\
    \ be assumed to have knowledge of the lower layer over\n   which they are transported,\
    \ and cannot be restricted to identifiers\n   associated with a particular usage\
    \ environment (e.g., Medium Access\n   Control (MAC) addresses).\n   Note that\
    \ media independence can be retained within EAP methods that\n   support channel\
    \ binding or method-specific identification.  An EAP\n   method need not be aware\
    \ of the content of an identifier in order to\n   use it.  This enables an EAP\
    \ method to use media-specific identifiers\n   such as MAC addresses without compromising\
    \ media independence.\n   Channel binding parameters are treated as opaque octets\
    \ by EAP\n   methods so that handling them does not require media-specific\n \
    \  knowledge.\n"
- title: 1.6.3.  Method Independence
  contents:
  - "1.6.3.  Method Independence\n   By enabling pass-through, authenticators can\
    \ support any method\n   implemented on the peer and server, not just locally\
    \ implemented\n   methods.  This allows the authenticator to avoid having to implement\n\
    \   the EAP methods configured for use by peers.  In fact, since a\n   pass-through\
    \ authenticator need not implement any EAP methods at all,\n   it cannot be assumed\
    \ to support any EAP method-specific code.  As\n   noted in [RFC3748] Section\
    \ 2.3:\n      Compliant pass-through authenticator implementations MUST by\n \
    \     default forward EAP packets of any Type.\n   This is useful where there\
    \ is no single EAP method that is both\n   mandatory to implement and offers acceptable\
    \ security for the media\n   in use.  For example, the [RFC3748] mandatory-to-implement\
    \ EAP method\n   (MD5-Challenge) does not provide dictionary attack resistance,\
    \ mutual\n   authentication, or key derivation, and as a result, is not\n   appropriate\
    \ for use in Wireless Local Area Network (WLAN)\n   authentication [RFC4017].\
    \  However, despite this, it is possible for\n   the peer and authenticator to\
    \ interoperate as long as a suitable EAP\n   method is supported both on the EAP\
    \ peer and server.\n"
- title: 1.6.4.  Ciphersuite Independence
  contents:
  - "1.6.4.  Ciphersuite Independence\n   Ciphersuite Independence is a requirement\
    \ for media independence.\n   Since lower-layer ciphersuites vary between media,\
    \ media independence\n   requires that exported EAP keying material be large enough\
    \ (with\n   sufficient entropy) to handle any ciphersuite.\n   While EAP methods\
    \ can negotiate the ciphersuite used in protection of\n   the EAP conversation,\
    \ the ciphersuite used for the protection of the\n   data exchanged after EAP\
    \ authentication has completed is negotiated\n   between the peer and authenticator\
    \ within the lower layer, outside of\n   EAP.\n   For example, within PPP, the\
    \ ciphersuite is negotiated within the\n   Encryption Control Protocol (ECP) defined\
    \ in [RFC1968], after EAP\n   authentication is completed.  Within [IEEE-802.11],\
    \ the AP\n   ciphersuites are advertised in the Beacon and Probe Responses prior\n\
    \   to EAP authentication and are securely verified during a 4-way\n   handshake\
    \ exchange.\n   Since the ciphersuites used to protect data depend on the lower\n\
    \   layer, requiring that EAP methods have knowledge of lower-layer\n   ciphersuites\
    \ would compromise the principle of media independence.\n   As a result, methods\
    \ export EAP keying material that is ciphersuite\n   independent.  Since ciphersuite\
    \ negotiation occurs in the lower\n   layer, there is no need for lower-layer\
    \ ciphersuite negotiation\n   within EAP.\n   In order to allow a ciphersuite\
    \ to be usable within the EAP keying\n   framework, the ciphersuite specification\
    \ needs to describe how TSKs\n   suitable for use with the ciphersuite are derived\
    \ from exported EAP\n   keying material.  To maintain method independence, algorithms\
    \ for\n   deriving TSKs MUST NOT depend on the EAP method, although algorithms\n\
    \   for TEK derivation MAY be specific to the EAP method.\n   Advantages of ciphersuite-independence\
    \ include:\n   Reduced update requirements\n        Ciphersuite independence enables\
    \ EAP methods to be used with new\n        ciphersuites without requiring the\
    \ methods to be updated.  If\n        EAP methods were to specify how to derive\
    \ transient session keys\n        for each ciphersuite, they would need to be\
    \ updated each time a\n        new ciphersuite is developed.  In addition, backend\n\
    \        authentication servers might not be usable with all EAP-capable\n   \
    \     authenticators, since the backend authentication server would\n        also\
    \ need to be updated each time support for a new ciphersuite\n        is added\
    \ to the authenticator.\n   Reduced EAP method complexity\n        Ciphersuite\
    \ independence enables EAP methods to avoid having to\n        include ciphersuite-specific\
    \ code.  Requiring each EAP method to\n        include ciphersuite-specific code\
    \ for transient session key\n        derivation would increase method complexity\
    \ and result in\n        duplicated effort.\n   Simplified configuration\n   \
    \     Ciphersuite independence enables EAP method implementations on\n       \
    \ the peer and server to avoid having to configure\n        ciphersuite-specific\
    \ parameters.  The ciphersuite is negotiated\n        between the peer and authenticator\
    \ outside of EAP.  Where the\n        authenticator operates in \"pass-through\"\
    \ mode, the EAP server is\n        not a party to this negotiation, nor is it\
    \ involved in the data\n        flow between the EAP peer and authenticator. \
    \ As a result, the\n        EAP server does not have knowledge of the ciphersuites\
    \ and\n        negotiation policies implemented by the peer and authenticator,\n\
    \        nor is it aware of the ciphersuite negotiated between them.  For\n  \
    \      example, since Encryption Control Protocol (ECP) negotiation\n        occurs\
    \ after authentication, when run over PPP, the EAP peer and\n        server cannot\
    \ anticipate the negotiated ciphersuite, and\n        therefore, this information\
    \ cannot be provided to the EAP\n        method.\n"
- title: 2.  Lower-Layer Operation
  contents:
  - "2.  Lower-Layer Operation\n   On completion of EAP authentication, EAP keying\
    \ material and\n   parameters exported by the EAP method are provided to the lower\
    \ layer\n   and AAA layer (if present).  These include the Master Session Key\n\
    \   (MSK), Extended Master Session Key (EMSK), Peer-Id(s), Server-Id(s),\n   and\
    \ Session-Id.  The Initialization Vector (IV) is deprecated, but\n   might be\
    \ provided.\n   In order to preserve the security of EAP keying material derived\n\
    \   within methods, lower layers MUST NOT export keys passed down by EAP\n   methods.\
    \  This implies that EAP keying material passed down to a\n   lower layer is for\
    \ the exclusive use of that lower layer and MUST NOT\n   be used within another\
    \ lower layer.  This prevents compromise of one\n   lower layer from compromising\
    \ other applications using EAP keying\n   material.\n   EAP keying material provided\
    \ to a lower layer MUST NOT be transported\n   to another entity.  For example,\
    \ EAP keying material passed down to\n   the EAP peer lower layer MUST NOT leave\
    \ the peer;  EAP keying\n   material passed down or transported to the EAP authenticator\
    \ lower\n   layer MUST NOT leave the authenticator.\n   On the EAP server, keying\
    \ material and parameters requested by and\n   passed down to the AAA layer MAY\
    \ be replicated to the AAA layer on\n   the authenticator (with the exception\
    \ of the EMSK).  On the\n   authenticator, the AAA layer provides the replicated\
    \ keying material\n   and parameters to the lower layer over which the EAP authentication\n\
    \   conversation took place.  This enables mode independence to be\n   maintained.\n\
    \   The EAP layer, as well as the peer and authenticator layers, MUST NOT\n  \
    \ modify or cache keying material or parameters (including channel\n   bindings)\
    \ passing in either direction between the EAP method layer\n   and the lower layer\
    \ or AAA layer.\n"
- title: 2.1.  Transient Session Keys
  contents:
  - "2.1.  Transient Session Keys\n   Where explicitly supported by the lower layer,\
    \ lower layers MAY cache\n   keying material, including exported EAP keying material\
    \ and/or TSKs;\n   the structure of this key cache is defined by the lower layer.\
    \  So as\n   to enable interoperability, new lower-layer specifications MUST\n\
    \   describe key caching behavior.  Unless explicitly specified by the\n   lower\
    \ layer, the EAP peer, server, and authenticator MUST assume that\n   peers and\
    \ authenticators do not cache keying material.  Existing EAP\n   lower layers\
    \ and AAA layers handle the generation of transient\n   session keys and caching\
    \ of EAP keying material in different ways:\n   IEEE 802.1X-2004\n        When\
    \ used with wired networks, IEEE 802.1X-2004 [IEEE-802.1X]\n        does not support\
    \ link-layer ciphersuites, and as a result, it\n        does not provide for the\
    \ generation of TSKs or caching of EAP\n        keying material and parameters.\
    \  Once EAP authentication\n        completes, it is assumed that EAP keying material\
    \ and parameters\n        are discarded; on IEEE 802 wired networks, there is\
    \ no\n        subsequent Secure Association Protocol exchange.  Perfect\n    \
    \    Forward Secrecy (PFS) is only possible if the negotiated EAP\n        method\
    \ supports this.\n   PPP\n        PPP, defined in [RFC1661], does not include\
    \ support for a Secure\n        Association Protocol, nor does it support caching\
    \ of EAP keying\n        material or parameters.  PPP ciphersuites derive their\
    \ TSKs\n        directly from the MSK, as described in [RFC2716] Section 3.5.\n\
    \        This is NOT RECOMMENDED, since if PPP were to support caching of\n  \
    \      EAP keying material, this could result in TSK reuse.  As a\n        result,\
    \ once the PPP session is terminated, EAP keying material\n        and parameters\
    \ MUST be discarded.  Since caching of EAP keying\n        material is not permitted\
    \ within PPP, there is no way to handle\n        TSK re-key without EAP re-authentication.\
    \  Perfect Forward\n        Secrecy (PFS) is only possible if the negotiated EAP\
    \ method\n        supports this.\n   IKEv2\n        IKEv2, defined in [RFC4306],\
    \ only uses the MSK for\n        authentication purposes and not key derivation.\
    \  The EMSK, IV,\n        Peer-Id, Server-Id or Session-Id are not used.  As a\
    \ result, the\n        TSKs derived by IKEv2 are cryptographically independent\
    \ of the\n        EAP keying material and re-key of IPsec SAs can be handled\n\
    \        without requiring EAP re-authentication.  Within IKEv2, it is\n     \
    \   possible to negotiate PFS, regardless of which EAP method is\n        negotiated.\
    \  IKEv2 as specified in [RFC4306] does not cache EAP\n        keying material\
    \ or parameters; once IKEv2 authentication\n        completes, it is assumed that\
    \ EAP keying material and parameters\n        are discarded.  The Session-Timeout\
    \ Attribute is therefore\n        interpreted as a limit on the VPN session time,\
    \ rather than an\n        indication of the MSK key lifetime.\n   IEEE 802.11\n\
    \        IEEE 802.11 enables caching of the MSK, but not the EMSK, IV,\n     \
    \   Peer-Id, Server-Id, or Session-Id.  More details about the\n        structure\
    \ of the cache are available in [IEEE-802.11].  In IEEE\n        802.11, TSKs\
    \ are derived from the MSK using a Secure Association\n        Protocol known\
    \ as the 4-way handshake, which includes a nonce\n        exchange.  This guarantees\
    \ TSK freshness even if the MSK is\n        reused.  The 4-way handshake also\
    \ enables TSK re-key without EAP\n        re-authentication.  PFS is only possible\
    \ within IEEE 802.11 if\n        caching is not enabled and the negotiated EAP\
    \ method supports\n        PFS.\n   IEEE 802.16e\n        IEEE 802.16e, defined\
    \ in [IEEE-802.16e], supports caching of the\n        MSK, but not the EMSK, IV,\
    \ Peer-Id, Server-Id, or Session-Id.\n        IEEE 802.16e supports a Secure Association\
    \ Protocol in which\n        TSKs are chosen by the authenticator without any\
    \ contribution by\n        the peer.  The TSKs are encrypted, authenticated, and\
    \ integrity\n        protected using the MSK and are transported from the\n  \
    \      authenticator to the peer.  TSK re-key is possible without EAP\n      \
    \  re-authentication.  PFS is not possible even if the negotiated\n        EAP\
    \ method supports it.\n   AAA\n        Existing implementations and specifications\
    \ for RADIUS/EAP\n        [RFC3579] or Diameter EAP [RFC4072] do not support caching\
    \ of\n        keying material or parameters.  In existing AAA clients, proxy\n\
    \        and server implementations, exported EAP keying material (MSK,\n    \
    \    EMSK, and IV), as well as parameters and derived keys are not\n        cached\
    \ and MUST be presumed lost after the AAA exchange\n        completes.\n     \
    \   In order to avoid key reuse, the AAA layer MUST delete\n        transported\
    \ keys once they are sent.  The AAA layer MUST NOT\n        retain keys that it\
    \ has previously sent.  For example, a AAA\n        layer that has transported\
    \ the MSK MUST delete it, and keys MUST\n        NOT be derived from the MSK from\
    \ that point forward.\n"
- title: 2.2.  Authenticator and Peer Architecture
  contents:
  - "2.2.  Authenticator and Peer Architecture\n   This specification does not impose\
    \ constraints on the architecture of\n   the EAP authenticator or peer.  For example,\
    \ any of the authenticator\n   architectures described in [RFC4118] can be used.\
    \  As a result, lower\n   layers need to identify EAP peers and authenticators\
    \ unambiguously,\n   without incorporating implicit assumptions about peer and\n\
    \   authenticator architectures.\n   For example, it is possible for multiple\
    \ base stations and a\n   \"controller\" (e.g., WLAN switch) to comprise a single\
    \ EAP\n   authenticator.  In such a situation, the \"base station identity\" is\n\
    \   irrelevant to the EAP method conversation, except perhaps as an\n   opaque\
    \ blob to be used in channel binding.  Many base stations can\n   share the same\
    \ authenticator identity.  An EAP authenticator or peer:\n      (a) can contain\
    \ one or more physical or logical ports;\n      (b) can advertise itself as one\
    \ or more \"virtual\" authenticators\n          or peers;\n      (c) can utilize\
    \ multiple CPUs;\n      (d) can support clustering services for load balancing\
    \ or\n          failover.\n   Both the EAP peer and authenticator can have more\
    \ than one physical\n   or logical port.  A peer can simultaneously access the\
    \ network via\n   multiple authenticators, or via multiple physical or logical\
    \ ports on\n   a given authenticator.  Similarly, an authenticator can offer network\n\
    \   access to multiple peers, each via a separate physical or logical\n   port.\
    \  When a single physical authenticator advertises itself as\n   multiple virtual\
    \ authenticators, it is possible for a single physical\n   port to belong to multiple\
    \ virtual authenticators.\n   An authenticator can be configured to communicate\
    \ with more than one\n   EAP server, each of which is configured to communicate\
    \ with a subset\n   of the authenticators.  The situation is illustrated in Figure\
    \ 3.\n"
- title: 2.3.  Authenticator Identification
  contents:
  - "2.3.  Authenticator Identification\n   The EAP method conversation is between\
    \ the EAP peer and server.  The\n   authenticator identity, if considered at all\
    \ by the EAP method, is\n   treated as an opaque blob for the purpose of channel\
    \ binding (see\n   Section 5.3.3).  However, the authenticator identity is important\
    \ in\n   two other exchanges - the AAA protocol exchange and the Secure\n   Association\
    \ Protocol conversation.\n   The AAA conversation is between the EAP authenticator\
    \ and the backend\n   authentication server.  From the point of view of the backend\n\
    \   authentication server, keying material and parameters are transported\n  \
    \ to the EAP authenticator identified by the NAS-Identifier Attribute.\n   Since\
    \ an EAP authenticator MUST NOT share EAP keying material or\n   parameters with\
    \ another party, if the EAP peer or backend\n   authentication server detects\
    \ use of EAP keying material and\n   parameters outside the scope defined by the\
    \ NAS-Identifier, the\n   keying material MUST be considered compromised.\n  \
    \ The Secure Association Protocol conversation is between the peer and\n   the\
    \ authenticator.  For lower layers that support key caching, it is\n   particularly\
    \ important for the EAP peer, authenticator, and backend\n   server to have a\
    \ consistent view of the usage scope of the\n   transported keying material. \
    \ In order to enable this, it is\n   RECOMMENDED that the Secure Association Protocol\
    \ explicitly\n   communicate the usage scope of the EAP keying material passed\
    \ down to\n   the lower layer, rather than implicitly assuming that this is defined\n\
    \   by the authenticator and peer endpoint addresses.\n                     +-+-+-+-+\n\
    \                     | EAP   |\n                     | Peer  |\n            \
    \         +-+-+-+-+\n                       | | |  Peer Ports\n              \
    \        /  |  \\\n                     /   |   \\\n                    /    |\
    \    \\\n                   /     |     \\\n                  /      |      \\\
    \n                 /       |       \\\n                /        |        \\\n\
    \               /         |         \\     Authenticator\n            | | |  \
    \    | | |      | | |   Ports\n          +-+-+-+-+  +-+-+-+-+  +-+-+-+-+\n   \
    \       |       |  |       |  |       |\n          | Auth1 |  | Auth2 |  | Auth3\
    \ |\n          |       |  |       |  |       |\n          +-+-+-+-+  +-+-+-+-+\
    \  +-+-+-+-+\n               \\        | \\         |\n                \\    \
    \   |  \\        |\n                 \\      |   \\       |\n   EAP over AAA \
    \  \\     |    \\      |\n     (optional)    \\    |     \\     |\n          \
    \          \\   |      \\    |\n                     \\  |       \\   |\n    \
    \                  \\ |        \\  |\n                   +-+-+-+-+-+  +-+-+-+-+-+\
    \  Backend\n                   |  EAP    |  |  EAP    |  Authentication\n    \
    \               | Server1 |  | Server2 |  Servers\n                   +-+-+-+-+-+\
    \  +-+-+-+-+-+\n   Figure 3: Relationship between EAP Peer, Authenticator, and\
    \ Server\n   Since an authenticator can have multiple ports, the scope of the\n\
    \   authenticator key cache cannot be described by a single endpoint\n   address.\
    \  Similarly, where a peer can have multiple ports and sharing\n   of EAP keying\
    \ material and parameters between peer ports of the same\n   link type is allowed,\
    \ the extent of the peer key cache cannot be\n   communicated by using a single\
    \ endpoint address.  Instead, it is\n   RECOMMENDED that the EAP peer and authenticator\
    \ consistently identify\n   themselves utilizing explicit identifiers, rather\
    \ than endpoint\n   addresses or port identifiers.\n   AAA protocols such as RADIUS\
    \ [RFC3579] and Diameter [RFC4072] provide\n   a mechanism for the identification\
    \ of AAA clients; since the EAP\n   authenticator and AAA client MUST be co-resident,\
    \ this mechanism is\n   applicable to the identification of EAP authenticators.\n\
    \   RADIUS [RFC2865] requires that an Access-Request packet contain one\n   or\
    \ more of the NAS-Identifier, NAS-IP-Address, and NAS-IPv6-Address\n   attributes.\
    \  Since a NAS can have more than one IP address, the\n   NAS-Identifier Attribute\
    \ is RECOMMENDED for explicit identification\n   of the authenticator, both within\
    \ the AAA protocol exchange and the\n   Secure Association Protocol conversation.\n\
    \   Problems that can arise where the peer and authenticator implicitly\n   identify\
    \ themselves using endpoint addresses include the following:\n   (a)  It is possible\
    \ that the peer will not be able to determine which\n        authenticator ports\
    \ are associated with which authenticators.\n        As a result, the EAP peer\
    \ will be unable to utilize the\n        authenticator key cache in an efficient\
    \ way, and will also be\n        unable to determine whether EAP keying material\
    \ has been shared\n        outside its authorized scope, and therefore needs to\
    \ be\n        considered compromised.\n   (b)  It is possible that the authenticator\
    \ will not be able to\n        determine which peer ports are associated with\
    \ which peers,\n        preventing the peer from communicating with it utilizing\n\
    \        multiple peer ports.\n   (c)  It is possible that the peer will not be\
    \ able to determine with\n        which virtual authenticator it is communicating.\
    \  For example,\n        multiple virtual authenticators can share a MAC address,\
    \ but\n        utilize different NAS-Identifiers.\n   (d)  It is possible that\
    \ the authenticator will not be able to\n        determine with which virtual\
    \ peer it is communicating.  Multiple\n        virtual peers can share a MAC address,\
    \ but utilize different\n        Peer-Ids.\n   (e)  It is possible that the EAP\
    \ peer and server will not be able to\n        verify the authenticator identity\
    \ via channel binding.\n   For example, problems (a), (c), and (e) occur in [IEEE-802.11],\
    \ which\n   utilizes peer and authenticator MAC addresses within the 4-way\n \
    \  handshake.  Problems (b) and (d) do not occur since [IEEE-802.11]\n   only\
    \ allows a virtual peer to utilize a single port.\n   The following steps enable\
    \ lower-layer identities to be securely\n   verified by all parties:\n   (f) \
    \ Specify the lower-layer parameters used to identify the\n        authenticator\
    \ and peer.  As noted earlier, endpoint or port\n        identifiers are not recommended\
    \ for identification of the\n        authenticator or peer when it is possible\
    \ for them to have\n        multiple ports.\n   (g)  Communicate the lower-layer\
    \ identities between the peer and\n        authenticator within phase 0.  This\
    \ allows the peer and\n        authenticator to determine the key scope if a key\
    \ cache is\n        utilized.\n   (h)  Communicate the lower-layer authenticator\
    \ identity between the\n        authenticator and backend authentication server\
    \ within the NAS-\n        Identifier Attribute.\n   (i)  Include the lower-layer\
    \ identities within channel bindings (if\n        supported) in phase 1a, ensuring\
    \ that they are communicated\n        between the EAP peer and server.\n   (j)\
    \  Support the integrity-protected exchange of identities within\n        phase\
    \ 2a.\n   (k)  Utilize the advertised lower-layer identities to enable the peer\n\
    \        and authenticator to verify that keys are maintained within the\n   \
    \     advertised scope.\n"
- title: 2.3.1.  Virtual Authenticators
  contents:
  - "2.3.1.  Virtual Authenticators\n   When a single physical authenticator advertises\
    \ itself as multiple\n   virtual authenticators, if the virtual authenticators\
    \ do not maintain\n   logically separate key caches, then by authenticating to\
    \ one virtual\n   authenticator, the peer can gain access to the other virtual\n\
    \   authenticators sharing a key cache.\n   For example, where a physical authenticator\
    \ implements \"Guest\" and\n   \"Corporate Intranet\" virtual authenticators,\
    \ an attacker acting as a\n   peer could authenticate with the \"Guest\" virtual\
    \ authenticator and\n   derive EAP keying material.  If the \"Guest\" and \"Corporate\
    \ Intranet\"\n   virtual authenticators share a key cache, then the peer can utilize\n\
    \   the EAP keying material derived for the \"Guest\" network to obtain\n   access\
    \ to the \"Corporate Intranet\" network.\n   The following steps can be taken\
    \ to mitigate this vulnerability:\n   (a)  Authenticators are REQUIRED to cache\
    \ associated authorizations\n        along with EAP keying material and parameters\
    \ and to apply\n        authorizations to the peer on each network access, regardless\
    \ of\n        which virtual authenticator is being accessed.  This ensures\n \
    \       that an attacker cannot obtain elevated privileges even where\n      \
    \  the key cache is shared between virtual authenticators, and a\n        peer\
    \ obtains access to one virtual authenticator utilizing a key\n        cache entry\
    \ created for use with another virtual authenticator.\n   (b)  It is RECOMMENDED\
    \ that physical authenticators maintain separate\n        key caches for each\
    \ virtual authenticator.  This ensures that a\n        cache entry created for\
    \ use with one virtual authenticator\n        cannot be used for access to another\
    \ virtual authenticator.\n        Since a key cache entry can no longer be shared\
    \ between virtual\n        authentications, this step provides protection beyond\
    \ that\n        offered in (a).  This is valuable in situations where\n      \
    \  authorizations are not used to enforce access limitations.  For\n        example,\
    \ where access is limited using a filter installed on a\n        router rather\
    \ than using authorizations provided to the\n        authenticator, a peer can\
    \ gain unauthorized access to resources\n        by exploiting a shared key cache\
    \ entry.\n   (c)  It is RECOMMENDED that each virtual authenticator identify\n\
    \        itself consistently to the peer and to the backend\n        authentication\
    \ server, so as to enable the peer to verify the\n        authenticator identity\
    \ via channel binding (see Section 5.3.3).\n   (d)  It is RECOMMENDED that each\
    \ virtual authenticator identify\n        itself distinctly, in order to enable\
    \ the peer and backend\n        authentication server to tell them apart.  For\
    \ example, this can\n        be accomplished by utilizing a distinct value of\
    \ the NAS-\n        Identifier Attribute.\n"
- title: 2.4.  Peer Identification
  contents:
  - "2.4.  Peer Identification\n   As described in [RFC3748] Section 7.3, the peer\
    \ identity provided in\n   the EAP-Response/Identity can be different from the\
    \ peer identities\n   authenticated by the EAP method.  For example, the identity\
    \ provided\n   in the EAP-Response/Identity can be a privacy identifier as described\n\
    \   in \"The Network Access Identifier\" [RFC4282] Section 2.  As noted in\n \
    \  [RFC4284], it is also possible to utilize a Network Access Identifier\n   (NAI)\
    \ for the purposes of source routing; an NAI utilized for source\n   routing is\
    \ said to be \"decorated\" as described in [RFC4282] Section\n   2.7.\n   When\
    \ the EAP peer provides the Network Access Identity (NAI) within\n   the EAP-Response/Identity,\
    \ as described in [RFC3579], the\n   authenticator copies the NAI included in\
    \ the EAP-Response/Identity\n   into the User-Name Attribute included within the\
    \ Access-Request.  As\n   the Access-Request is forwarded toward the backend authentication\n\
    \   server, AAA proxies remove decoration from the NAI included in the\n   User-Name\
    \ Attribute; the NAI included within the\n   EAP-Response/Identity encapsulated\
    \ in the Access-Request remains\n   unchanged.  As a result, when the Access-Request\
    \ arrives at the\n   backend authentication server, the EAP-Response/Identity\
    \ can differ\n   from the User-Name Attribute (which can have some or all of the\n\
    \   decoration removed).  In the absence of a Peer-Id, the backend\n   authentication\
    \ server SHOULD use the contents of the User-Name\n   Attribute, rather than the\
    \ EAP-Response/Identity, as the peer\n   identity.\n   It is possible for more\
    \ than one Peer-Id to be exported by an EAP\n   method.  For example, a peer certificate\
    \ can contain more than one\n   peer identity; in a tunnel method, peer identities\
    \ can be\n   authenticated within both an outer and inner exchange, and these\n\
    \   identities could be different in type and contents.  For example, an\n   outer\
    \ exchange could provide a Peer-Id in the form of a Relative\n   Distinguished\
    \ Name (RDN), whereas an inner exchange could identify\n   the peer via its NAI\
    \ or MAC address.  Where EAP keying material is\n   determined solely from the\
    \ outer exchange, only the outer Peer-Id(s)\n   are exported; where the EAP keying\
    \ material is determined from both\n   the inner and outer exchanges, then both\
    \ the inner and outer\n   Peer-Id(s) are exported by the tunnel method.\n"
- title: 2.5.  Server Identification
  contents:
  - "2.5.  Server Identification\n   It is possible for more than one Server-Id to\
    \ be exported by an EAP\n   method.  For example, a server certificate can contain\
    \ more than one\n   server identity; in a tunnel method, server identities could\
    \ be\n   authenticated within both an outer and inner exchange, and these\n  \
    \ identities could be different in type and contents.  For example, an\n   outer\
    \ exchange could provide a Server-Id in the form of an IP\n   address, whereas\
    \ an inner exchange could identify the server via its\n   Fully-Qualified Domain\
    \ Name (FQDN) or hostname.  Where EAP keying\n   material is determined solely\
    \ from the outer exchange, only the outer\n   Server-Id(s) are exported by the\
    \ EAP method; where the EAP keying\n   material is determined from both the inner\
    \ and outer exchanges, then\n   both the inner and outer Server-Id(s) are exported\
    \ by the EAP method.\n   As shown in Figure 3, an authenticator can be configured\
    \ to\n   communicate with multiple EAP servers; the EAP server that an\n   authenticator\
    \ communicates with can vary according to configuration\n   and network and server\
    \ availability.  While the EAP peer can assume\n   that all EAP servers within\
    \ a realm have access to the credentials\n   necessary to validate an authentication\
    \ attempt, it cannot assume\n   that all EAP servers share persistent state.\n\
    \   Authenticators can be configured with different primary or secondary\n   EAP\
    \ servers, in order to balance the load.  Also, the authenticator\n   can dynamically\
    \ determine the EAP server to which requests will be\n   sent; in the event of\
    \ a communication failure, the authenticator can\n   fail over to another EAP\
    \ server.  For example, in Figure 3,\n   Authenticator2 can be initially configured\
    \ with EAP server1 as its\n   primary backend authentication server, and EAP server2\
    \ as the backup,\n   but if EAP server1 becomes unavailable, EAP server2 can become\
    \ the\n   primary server.\n   In general, the EAP peer cannot direct an authentication\
    \ attempt to a\n   particular EAP server within a realm, this decision is made\
    \ by AAA\n   clients, nor can the peer determine with which EAP server it will\
    \ be\n   communicating, prior to the start of the EAP method conversation.\n \
    \  The Server-Id is not included in the EAP-Request/Identity, and since\n   the\
    \ EAP server may be determined dynamically, it typically is not\n   possible for\
    \ the authenticator to advertise the Server-Id during the\n   discovery phase.\
    \  Some EAP methods do not export the Server-Id so\n   that it is possible that\
    \ the EAP peer will not learn with which\n   server it was conversing after the\
    \ EAP conversation completes\n   successfully.\n   As a result, an EAP peer, on\
    \ connecting to a new authenticator or\n   reconnecting to the same authenticator,\
    \ can find itself communicating\n   with a different EAP server.  Fast reconnect,\
    \ defined in [RFC3748]\n   Section 7.2, can fail if the EAP server with which\
    \ the peer\n   communicates is not the same one with which it initially established\n\
    \   a security association.  For example, an EAP peer attempting an\n   EAP-TLS\
    \ session resume can find that the new EAP-TLS server will not\n   have access\
    \ to the TLS Master Key identified by the TLS Session-Id,\n   and therefore the\
    \ session resumption attempt will fail, requiring\n   completion of a full EAP-TLS\
    \ exchange.\n   EAP methods that export the Server-Id MUST authenticate the server.\n\
    \   However, not all EAP methods supporting mutual authentication provide\n  \
    \ a non-null Server-Id; some methods only enable the EAP peer to verify\n   that\
    \ the EAP server possesses a long-term secret, but do not provide\n   the identity\
    \ of the EAP server.  In this case, the EAP peer will know\n   that an authenticator\
    \ has been authorized by an EAP server, but will\n   not confirm the identity\
    \ of the EAP server.  Where the EAP method\n   does not provide a Server-Id, the\
    \ peer cannot identify the EAP server\n   with which it generated keying material.\
    \  This can make it difficult\n   for the EAP peer to identify the location of\
    \ a key possessed by that\n   EAP server.\n   As noted in [RFC5216] Section 5.2,\
    \ EAP methods supporting\n   authentication using server certificates can determine\
    \ the Server-Id\n   from the subject or subjectAltName fields in the server certificate.\n\
    \   Validating the EAP server identity can help the EAP peer to decide\n   whether\
    \ a specific EAP server is authorized.  In some cases, such as\n   where the certificate\
    \ extensions defined in [RFC4334] are included in\n   the server certificate,\
    \ it can even be possible for the peer to\n   verify some channel binding parameters\
    \ from the server certificate.\n   It is possible for problems to arise in situations\
    \ where the EAP\n   server identifies itself differently to the EAP peer and\n\
    \   authenticator.  For example, it is possible that the Server-Id\n   exported\
    \ by EAP methods will not be identical to the Fully Qualified\n   Domain Name\
    \ (FQDN) of the backend authentication server.  Where\n   certificate-based authentication\
    \ is used within RADIUS or Diameter,\n   it is possible that the subjectAltName\
    \ used in the backend\n   authentication server certificate will not be identical\
    \ to the\n   Server-Id or backend authentication server FQDN.  This is not\n \
    \  normally an issue in EAP, as the authenticator will be unaware of the\n   identities\
    \ used between the EAP peer and server.  However, this can\n   be an issue for\
    \ key caching, if the authenticator is expected to\n   locate a backend authentication\
    \ server corresponding to a Server-Id\n   provided by an EAP peer.\n   Where the\
    \ backend authentication server FQDN differs from the\n   subjectAltName in the\
    \ backend authentication server certificate, it\n   is possible that the AAA client\
    \ will not be able to determine whether\n   it is talking to the correct backend\
    \ authentication server.  Where\n   the Server-Id and backend authentication server\
    \ FQDN differ, it is\n   possible that the combination of the key scope (Peer-Id(s),\
    \ Server-\n   Id(s)) and EAP conversation identifier (Session-Id) will not be\n\
    \   sufficient to determine where the key resides.  For example, the\n   authenticator\
    \ can identify backend authentication servers by their IP\n   address (as occurs\
    \ in RADIUS), or using a Fully Qualified Domain Name\n   (as in Diameter).  If\
    \ the Server-Id does not correspond to the IP\n   address or FQDN of a known backend\
    \ authentication server, then it may\n   not be possible to locate which backend\
    \ authentication server\n   possesses the key.\n"
- title: 3.  Security Association Management
  contents:
  - "3.  Security Association Management\n   EAP, as defined in [RFC3748], supports\
    \ key derivation, but does not\n   provide for the management of lower-layer security\
    \ associations.\n   Missing functionality includes:\n   (a)  Security Association\
    \ negotiation.  EAP does not negotiate\n        lower-layer unicast or multicast\
    \ security associations,\n        including cryptographic algorithms or traffic\
    \ profiles.  EAP\n        methods only negotiate cryptographic algorithms for\
    \ their own\n        use, not for the underlying lower layers.  EAP also does\
    \ not\n        negotiate the traffic profiles to be protected with the\n     \
    \   negotiated ciphersuites; in some cases the traffic to be\n        protected\
    \ can have lower-layer source and destination addresses\n        different from\
    \ the lower-layer peer or authenticator addresses.\n   (b)  Re-key.  EAP does\
    \ not support the re-keying of exported EAP\n        keying material without EAP\
    \ re-authentication, although EAP\n        methods can support \"fast reconnect\"\
    \ as defined in [RFC3748]\n        Section 7.2.1.\n   (c)  Key delete/install\
    \ semantics.  EAP does not synchronize\n        installation or deletion of keying\
    \ material on the EAP peer and\n        authenticator.\n   (d)  Lifetime negotiation.\
    \  EAP does not support lifetime negotiation\n        for exported EAP keying\
    \ material, and existing EAP methods also\n        do not support key lifetime\
    \ negotiation.\n   (e)  Guaranteed TSK freshness.  Without a post-EAP handshake,\
    \ TSKs\n        can be reused if EAP keying material is cached.\n   These deficiencies\
    \ are typically addressed via a post-EAP handshake\n   known as the Secure Association\
    \ Protocol.\n"
- title: 3.1.  Secure Association Protocol
  contents:
  - "3.1.  Secure Association Protocol\n   Since neither EAP nor EAP methods provide\
    \ for establishment of\n   lower-layer security associations, it is RECOMMENDED\
    \ that these\n   facilities be provided within the Secure Association Protocol,\n\
    \   including:\n   (a)  Entity Naming.  A basic feature of a Secure Association\
    \ Protocol\n        is the explicit naming of the parties engaged in the exchange.\n\
    \        Without explicit identification, the parties engaged in the\n       \
    \ exchange are not identified and the scope of the EAP keying\n        parameters\
    \ negotiated during the EAP exchange is undefined.\n   (b)  Mutual proof of possession\
    \ of EAP keying material.  During the\n        Secure Association Protocol, the\
    \ EAP peer and authenticator MUST\n        demonstrate possession of the keying\
    \ material transported\n        between the backend authentication server and\
    \ authenticator\n        (e.g., MSK), in order to demonstrate that the peer and\n\
    \        authenticator have been authorized.  Since mutual proof of\n        possession\
    \ is not the same as mutual authentication, the peer\n        cannot verify authenticator\
    \ assertions (including the\n        authenticator identity) as a result of this\
    \ exchange.\n        Authenticator identity verification is discussed in Section\
    \ 2.3.\n   (c)  Secure capabilities negotiation.  In order to protect against\n\
    \        spoofing during the discovery phase, ensure selection of the\n      \
    \  \"best\" ciphersuite, and protect against forging of negotiated\n        security\
    \ parameters, the Secure Association Protocol MUST\n        support secure capabilities\
    \ negotiation.  This includes the\n        secure negotiation of usage modes,\
    \ session parameters (such as\n        security association identifiers (SAIDs)\
    \ and key lifetimes),\n        ciphersuites and required filters, including confirmation\
    \ of\n        security-relevant capabilities discovered during phase 0.  The\n\
    \        Secure Association Protocol MUST support integrity and replay\n     \
    \   protection of all capability negotiation messages.\n   (d)  Key naming and\
    \ selection.  Where key caching is supported, it is\n        possible for the\
    \ EAP peer and authenticator to share more than\n        one key of a given type.\
    \  As a result, the Secure Association\n        Protocol MUST explicitly name\
    \ the keys used in the proof of\n        possession exchange, so as to prevent\
    \ confusion when more than\n        one set of keying material could potentially\
    \ be used as the\n        basis for the exchange.  Use of the key naming mechanism\n\
    \        described in Section 1.4.1 is RECOMMENDED.\n        In order to support\
    \ the correct processing of phase 2 security\n        associations, the Secure\
    \ Association (phase 2) protocol MUST\n        support the naming of phase 2 security\
    \ associations and\n        associated transient session keys so that the correct\
    \ set of\n        transient session keys can be identified for processing a given\n\
    \        packet.  The phase 2 Secure Association Protocol also MUST\n        support\
    \ transient session key activation and SHOULD support\n        deletion so that\
    \ establishment and re-establishment of transient\n        session keys can be\
    \ synchronized between the parties.\n   (e)  Generation of fresh transient session\
    \ keys (TSKs).  Where the\n        lower layer supports caching of keying material,\
    \ the EAP peer\n        lower layer can initiate a new session using keying material\n\
    \        that was derived in a previous session.  Were the TSKs to be\n      \
    \  derived solely from a portion of the exported EAP keying\n        material,\
    \ this would result in reuse of the session keys that\n        could expose the\
    \ underlying ciphersuite to attack.\n        In lower layers where caching of\
    \ keying material is supported,\n        the Secure Association Protocol phase\
    \ is REQUIRED, and MUST\n        support the derivation of fresh unicast and multicast\
    \ TSKs, even\n        when the transported keying material provided by the backend\n\
    \        authentication server is not fresh.  This is typically supported\n  \
    \      via the exchange of nonces or counters, which are then mixed\n        with\
    \ the keying material in order to generate fresh unicast\n        (phase 2a) and\
    \ possibly multicast (phase 2b) session keys.  By\n        not using exported\
    \ EAP keying material directly to protect data,\n        the Secure Association\
    \ Protocol protects it against compromise.\n   (f)  Key lifetime management. \
    \ This includes explicit key lifetime\n        negotiation or seamless re-key.\
    \  EAP does not support the\n        re-keying of EAP keying material without\
    \ re-authentication, and\n        existing EAP methods do not support key lifetime\
    \ negotiation.\n        As a result, the Secure Association Protocol MAY handle\
    \ the\n        re-key and determination of the key lifetime.  Where key caching\n\
    \        is supported, secure negotiation of key lifetimes is\n        RECOMMENDED.\
    \  Lower layers that support re-key, but not key\n        caching, may not require\
    \ key lifetime negotiation.  For example,\n        a difference between IKEv1\
    \ [RFC2409] and IKEv2 [RFC4306] is that\n        in IKEv1 SA lifetimes were negotiated;\
    \ in IKEv2, each end of the\n        SA is responsible for enforcing its own lifetime\
    \ policy on the\n        SA and re-keying the SA when necessary.\n   (g)  Key\
    \ state resynchronization.  It is possible for the peer or\n        authenticator\
    \ to reboot or reclaim resources, clearing portions\n        or all of the key\
    \ cache.  Therefore, key lifetime negotiation\n        cannot guarantee that the\
    \ key cache will remain synchronized,\n        and it may not be possible for\
    \ the peer to determine before\n        attempting to use a key whether it exists\
    \ within the\n        authenticator cache.  It is therefore RECOMMENDED for the\
    \ EAP\n        lower layer to provide a mechanism for key state\n        resynchronization,\
    \ either via the SAP or using a lower layer\n        indication (see [RFC3748]\
    \ Section 3.4).  Where the peer and\n        authenticator do not jointly possess\
    \ a key with which to protect\n        the resynchronization exchange, secure\
    \ resynchronization is not\n        possible, and alternatives (such as an initiation\
    \ of EAP\n        re-authentication after expiration of a timer) are needed to\n\
    \        ensure timely resynchronization.\n   (h)  Key scope synchronization.\
    \  To support key scope determination,\n        the Secure Association Protocol\
    \ SHOULD provide a mechanism by\n        which the peer can determine the scope\
    \ of the key cache on each\n        authenticator and by which the authenticator\
    \ can determine the\n        scope of the key cache on a peer.  This includes\
    \ negotiation of\n        restrictions on key usage.\n   (i)  Traffic profile\
    \ negotiation.  The traffic to be protected by a\n        lower-layer security\
    \ association will not necessarily have the\n        same lower-layer source or\
    \ destination address as the EAP peer\n        and authenticator, and it is possible\
    \ for the peer and\n        authenticator to negotiate multiple security associations,\
    \ each\n        with a different traffic profile.  Where this is the case, the\n\
    \        profile of protected traffic SHOULD be explicitly negotiated.\n     \
    \   For example, in IKEv2 it is possible for an Initiator and\n        Responder\
    \ to utilize EAP for authentication, then negotiate a\n        Tunnel Mode Security\
    \ Association (SA), which permits passing of\n        traffic originating from\
    \ hosts other than the Initiator and\n        Responder.  Similarly, in IEEE 802.16e,\
    \ a Subscriber Station\n        (SS) can forward traffic to the Base Station (BS),\
    \ which\n        originates from the Local Area Network (LAN) to which it is\n\
    \        attached.  To enable this, Security Associations within IEEE\n      \
    \  802.16e are identified by the Connection Identifier (CID), not\n        by\
    \ the EAP peer and authenticator MAC addresses.  In both IKEv2\n        and IEEE\
    \ 802.16e, multiple security associations can exist\n        between the EAP peer\
    \ and authenticator, each with their own\n        traffic profile and quality\
    \ of service parameters.\n   (j)  Direct operation.  Since the phase 2 Secure\
    \ Association Protocol\n        is concerned with the establishment of security\
    \ associations\n        between the EAP peer and authenticator, including the\
    \ derivation\n        of transient session keys, only those parties have \"a need\
    \ to\n        know\" the transient session keys.  The Secure Association\n   \
    \     Protocol MUST operate directly between the peer and\n        authenticator\
    \ and MUST NOT be passed-through to the backend\n        authentication server\
    \ or include additional parties.\n   (k)  Bi-directional operation.  While some\
    \ ciphersuites only require\n        a single set of transient session keys to\
    \ protect traffic in\n        both directions, other ciphersuites require a unique\
    \ set of\n        transient session keys in each direction.  The phase 2 Secure\n\
    \        Association Protocol SHOULD provide for the derivation of\n        unicast\
    \ and multicast keys in each direction, so as not to\n        require two separate\
    \ phase 2 exchanges in order to create a\n        bi-directional phase 2 security\
    \ association.  See [RFC3748]\n        Section 2.4 for more discussion.\n"
- title: 3.2.  Key Scope
  contents:
  - "3.2.  Key Scope\n   Absent explicit specification within the lower layer, after\
    \ the\n   completion of phase 1b, transported keying material, and parameters\n\
    \   are bound to the EAP peer and authenticator, but are not bound to a\n   specific\
    \ peer or authenticator port.\n   While EAP keying material passed down to the\
    \ lower layer is not\n   intrinsically bound to particular authenticator and peer\
    \ ports, TSKs\n   MAY be bound to particular authenticator and peer ports by the\
    \ Secure\n   Association Protocol.  However, a lower layer MAY also permit TSKs\
    \ to\n   be used on multiple peer and/or authenticator ports, provided that\n\
    \   TSK freshness is guaranteed (such as by keeping replay counter state\n   within\
    \ the authenticator).\n   In order to further limit the key scope, the following\
    \ measures are\n   suggested:\n   (a)  The lower layer MAY specify additional\
    \ restrictions on key\n        usage, such as limiting the use of EAP keying material\
    \ and\n        parameters on the EAP peer to the port over which the EAP\n   \
    \     conversation was conducted.\n   (b)  The backend authentication server and\
    \ authenticator MAY\n        implement additional attributes in order to further\
    \ restrict the\n        scope of keying material.  For example, in IEEE 802.11,\
    \ the\n        backend authentication server can provide the authenticator with\n\
    \        a list of authorized Called or Calling-Station-Ids and/or SSIDs\n   \
    \     for which keying material is valid.\n   (c)  Where the backend authentication\
    \ server provides attributes\n        restricting the key scope, it is RECOMMENDED\
    \ that restrictions\n        be securely communicated by the authenticator to\
    \ the peer.  This\n        can be accomplished using the Secure Association Protocol,\
    \ but\n        also can be accomplished via the EAP method or the lower layer.\n"
- title: 3.3.  Parent-Child Relationships
  contents:
  - "3.3.  Parent-Child Relationships\n   When an EAP re-authentication takes place,\
    \ new EAP keying material is\n   exported by the EAP method.  In EAP lower layers\
    \ where EAP\n   re-authentication eventually results in TSK replacement, the maximum\n\
    \   lifetime of derived keying material (including TSKs) can be less than\n  \
    \ or equal to that of EAP keying material (MSK/EMSK), but it cannot be\n   greater.\n\
    \   Where TSKs are derived from or are wrapped by exported EAP keying\n   material,\
    \ compromise of that exported EAP keying material implies\n   compromise of TSKs.\
    \  Therefore, if EAP keying material is considered\n   stale, not only SHOULD\
    \ EAP re-authentication be initiated, but also\n   replacement of child keys,\
    \ including TSKs.\n   Where EAP keying material is used only for entity authentication\
    \ but\n   not for TSK derivation (as in IKEv2), compromise of exported EAP\n \
    \  keying material does not imply compromise of the TSKs.  Nevertheless,\n   the\
    \ compromise of EAP keying material could enable an attacker to\n   impersonate\
    \ an authenticator, so that EAP re-authentication and TSK\n   re-key are RECOMMENDED.\n\
    \   With respect to IKEv2, Section 5.2 of [RFC4718], \"IKEv2\n   Clarifications\
    \ and Implementation Guidelines\", states:\n      Rekeying the IKE_SA and reauthentication\
    \ are different concepts in\n      IKEv2.  Rekeying the IKE_SA establishes new\
    \ keys for the IKE_SA\n      and resets the Message ID counters, but it does not\
    \ authenticate\n      the parties again (no AUTH or EAP payloads are involved)...\
    \  This\n      means that reauthentication also establishes new keys for the\n\
    \      IKE_SA and CHILD_SAs.  Therefore while rekeying can be performed\n    \
    \  more often than reauthentication, the situation where\n      \"authentication\
    \ lifetime\" is shorter than \"key lifetime\" does not\n      make sense.\n  \
    \ Child keys that are used frequently (such as TSKs that are used for\n   traffic\
    \ protection) can expire sooner than the exported EAP keying\n   material on which\
    \ they are dependent, so that it is advantageous to\n   support re-key of child\
    \ keys prior to EAP re-authentication.  Note\n   that deletion of the MSK/EMSK\
    \ does not necessarily imply deletion of\n   TSKs or child keys.\n   Failure to\
    \ mutually prove possession of exported EAP keying material\n   during the Secure\
    \ Association Protocol exchange need not be grounds\n   for deletion of keying\
    \ material by both parties; rate-limiting Secure\n   Association Protocol exchanges\
    \ could be used to prevent a brute force\n   attack.\n"
- title: 3.4.  Local Key Lifetimes
  contents:
  - "3.4.  Local Key Lifetimes\n   The Transient EAP Keys (TEKs) are session keys\
    \ used to protect the\n   EAP conversation.  The TEKs are internal to the EAP\
    \ method and are\n   not exported.  TEKs are typically created during an EAP conversation,\n\
    \   used until the end of the conversation and then discarded.  However,\n   methods\
    \ can re-key TEKs during an EAP conversation.\n   When using TEKs within an EAP\
    \ conversation or across conversations,\n   it is necessary to ensure that replay\
    \ protection and key separation\n   requirements are fulfilled.  For instance,\
    \ if a replay counter is\n   used, TEK re-key MUST occur prior to wrapping of\
    \ the counter.\n   Similarly, TSKs MUST remain cryptographically separate from\
    \ TEKs\n   despite TEK re-keying or caching.  This prevents TEK compromise from\n\
    \   leading directly to compromise of the TSKs and vice versa.\n   EAP methods\
    \ MAY cache local EAP keying material (TEKs) that can\n   persist for multiple\
    \ EAP conversations when fast reconnect is used\n   [RFC3748].  For example, EAP\
    \ methods based on TLS (such as EAP-TLS\n   [RFC5216]) derive and cache the TLS\
    \ Master Secret, typically for\n   substantial time periods.  The lifetime of\
    \ other local EAP keying\n   material calculated within the EAP method is defined\
    \ by the method.\n   Note that in general, when using fast reconnect, there is\
    \ no\n   guarantee that the original long-term credentials are still in the\n\
    \   possession of the peer.  For instance, a smart-card holding the\n   private\
    \ key for EAP-TLS may have been removed.  EAP servers SHOULD\n   also verify that\
    \ the long-term credentials are still valid, such as\n   by checking that certificate\
    \ used in the original authentication has\n   not yet expired.\n"
- title: 3.5.  Exported and Calculated Key Lifetimes
  contents:
  - "3.5.  Exported and Calculated Key Lifetimes\n   The following mechanisms are\
    \ available for communicating the lifetime\n   of keying material between the\
    \ EAP peer, server, and authenticator:\n      AAA protocols  (backend authentication\
    \ server and authenticator)\n      Lower-layer mechanisms (authenticator and peer)\n\
    \      EAP method-specific negotiation (peer and server)\n   Where the EAP method\
    \ does not support the negotiation of the lifetime\n   of exported EAP keying\
    \ material, and a key lifetime negotiation\n   mechanism is not provided by the\
    \ lower layer, it is possible that\n   there will not be a way for the peer to\
    \ learn the lifetime of keying\n   material.  This can leave the peer uncertain\
    \ of how long the\n   authenticator will maintain keying material within the key\
    \ cache.  In\n   this case the lifetime of keying material can be managed as a\
    \ system\n   parameter on the peer and authenticator; a default lifetime of 8\n\
    \   hours is RECOMMENDED.\n"
- title: 3.5.1.  AAA Protocols
  contents:
  - "3.5.1.  AAA Protocols\n   AAA protocols such as RADIUS [RFC2865] and Diameter\
    \ [RFC4072] can be\n   used to communicate the maximum key lifetime from the backend\n\
    \   authentication server to the authenticator.\n   The Session-Timeout Attribute\
    \ is defined for RADIUS in [RFC2865] and\n   for Diameter in [RFC4005].  Where\
    \ EAP is used for authentication,\n   [RFC3580] Section 3.17, indicates that a\
    \ Session-Timeout Attribute\n   sent in an Access-Accept along with a Termination-Action\
    \ value of\n   RADIUS-Request specifies the maximum number of seconds of service\n\
    \   provided prior to EAP re-authentication.\n   However, there is also a need\
    \ to be able to specify the maximum\n   lifetime of cached keying material.  Where\
    \ EAP pre-authentication is\n   supported, cached keying material can be pre-established\
    \ on the\n   authenticator prior to session start and will remain there until\n\
    \   expiration.  EAP lower layers supporting caching of keying material\n   MAY\
    \ also persist that material after the end of a session, enabling\n   the peer\
    \ to subsequently resume communication utilizing the cached\n   keying material.\
    \  In these situations it can be desirable for the\n   backend authentication\
    \ server to specify the maximum lifetime of\n   cached keying material.\n   To\
    \ accomplish this, [IEEE-802.11] overloads the Session-Timeout\n   Attribute,\
    \ assuming that it represents the maximum time after which\n   transported keying\
    \ material will expire on the authenticator,\n   regardless of whether transported\
    \ keying material is cached.\n   An IEEE 802.11 authenticator receiving transported\
    \ keying material is\n   expected to initialize a timer to the Session-Timeout\
    \ value, and once\n   the timer expires, the transported keying material expires.\
    \  Whether\n   this results in session termination or EAP re-authentication is\n\
    \   controlled by the value of the Termination-Action Attribute.  Where\n   EAP\
    \ re-authentication occurs, the transported keying material is\n   replaced, and\
    \ with it, new calculated keys are put in place.  Where\n   session termination\
    \ occurs, transported and derived keying material\n   is deleted.\n   Overloading\
    \ the Session-Timeout Attribute is problematic in\n   situations where it is necessary\
    \ to control the maximum session time\n   and key lifetime independently.  For\
    \ example, it might be desirable\n   to limit the lifetime of cached keying material\
    \ to 5 minutes while\n   permitting a user once authenticated to remain connected\
    \ for up to an\n   hour without re-authenticating.  As a result, in the future,\n\
    \   additional attributes can be specified to control the lifetime of\n   cached\
    \ keys; these attributes MAY modify the meaning of the\n   Session-Timeout Attribute\
    \ in specific circumstances.\n   Since the TSK lifetime is often determined by\
    \ authenticator\n   resources, and the backend authentication server has no insight\
    \ into\n   the TSK derivation process by the principle of ciphersuite\n   independence,\
    \ it is not appropriate for the backend authentication\n   server to manage any\
    \ aspect of the TSK derivation process, including\n   the TSK lifetime.\n"
- title: 3.5.2.  Lower-Layer Mechanisms
  contents:
  - "3.5.2.  Lower-Layer Mechanisms\n   Lower-layer mechanisms can be used to enable\
    \ the lifetime of keying\n   material to be negotiated between the peer and authenticator.\
    \  This\n   can be accomplished either using the Secure Association Protocol or\n\
    \   within the lower-layer transport.\n   Where TSKs are established as the result\
    \ of a Secure Association\n   Protocol exchange, it is RECOMMENDED that the Secure\
    \ Association\n   Protocol include support for TSK re-key.  Where the TSK is taken\n\
    \   directly from the MSK, there is no need to manage the TSK lifetime as\n  \
    \ a separate parameter, since the TSK lifetime and MSK lifetime are\n   identical.\n"
- title: 3.5.3.  EAP Method-Specific Negotiation
  contents:
  - "3.5.3.  EAP Method-Specific Negotiation\n   As noted in [RFC3748] Section 7.10:\n\
    \      In order to provide keying material for use in a subsequently\n      negotiated\
    \ ciphersuite, an EAP method supporting key derivation\n      MUST export a Master\
    \ Session Key (MSK) of at least 64 octets, and\n      an Extended Master Session\
    \ Key (EMSK) of at least 64 octets.  EAP\n      Methods deriving keys MUST provide\
    \ for mutual authentication\n      between the EAP peer and the EAP Server.\n\
    \   However, EAP does not itself support the negotiation of lifetimes for\n  \
    \ exported EAP keying material such as the MSK, EMSK, and IV.\n   While EAP itself\
    \ does not support lifetime negotiation, it would be\n   possible to specify methods\
    \ that do.  However, systems that rely on\n   key lifetime negotiation within\
    \ EAP methods would only function with\n   these methods.  Also, there is no guarantee\
    \ that the key lifetime\n   negotiated within the EAP method would be compatible\
    \ with backend\n   authentication server policy.  In the interest of method independence\n\
    \   and compatibility with backend authentication server implementations,\n  \
    \ management of the lifetime of keying material SHOULD NOT be provided\n   within\
    \ EAP methods.\n"
- title: 3.6.  Key Cache Synchronization
  contents:
  - "3.6.  Key Cache Synchronization\n   Key lifetime negotiation alone cannot guarantee\
    \ key cache\n   synchronization.  Even where a lower-layer exchange is run\n \
    \  immediately after EAP in order to determine the lifetime of keying\n   material,\
    \ it is still possible for the authenticator to purge all or\n   part of the key\
    \ cache prematurely (e.g., due to reboot or need to\n   reclaim memory).\n   The\
    \ lower layer can utilize the Discovery phase 0 to improve key\n   cache synchronization.\
    \  For example, if the authenticator manages the\n   key cache by deleting the\
    \ oldest key first, the relative creation\n   time of the last key to be deleted\
    \ could be advertised within the\n   Discovery phase, enabling the peer to determine\
    \ whether keying\n   material had been prematurely expired from the authenticator\
    \ key\n   cache.\n"
- title: 3.7.  Key Strength
  contents:
  - "3.7.  Key Strength\n   As noted in Section 2.1, EAP lower layers determine TSKs\
    \ in different\n   ways.  Where exported EAP keying material is utilized in the\n\
    \   derivation, encryption or authentication of TSKs, it is possible for\n   EAP\
    \ key generation to represent the weakest link.\n   In order to ensure that methods\
    \ produce EAP keying material of an\n   appropriate symmetric key strength, it\
    \ is RECOMMENDED that EAP\n   methods utilizing public key cryptography choose\
    \ a public key that\n   has a cryptographic strength providing the required level\
    \ of attack\n   resistance.  This is typically provided by configuring EAP methods,\n\
    \   since there is no coordination between the lower layer and EAP method\n  \
    \ with respect to minimum required symmetric key strength.\n   Section 5 of BCP\
    \ 86 [RFC3766] offers advice on the required RSA or DH\n   module and DSA subgroup\
    \ size in bits, for a given level of attack\n   resistance in bits.  The National\
    \ Institute for Standards and\n   Technology (NIST) also offers advice on appropriate\
    \ key sizes in\n   [SP800-57].\n"
- title: 3.8.  Key Wrap
  contents:
  - "3.8.  Key Wrap\n   The key wrap specified in [RFC2548], which is based on an\
    \ MD5-based\n   stream cipher, has known problems, as described in [RFC3579] Section\n\
    \   4.3.  RADIUS uses the shared secret for multiple purposes, including\n   per-packet\
    \ authentication and attribute hiding, considerable\n   information is exposed\
    \ about the shared secret with each packet.\n   This exposes the shared secret\
    \ to dictionary attacks.  MD5 is used\n   both to compute the RADIUS Response\
    \ Authenticator and the\n   Message-Authenticator Attribute, and concerns exist\
    \ relating to the\n   security of this hash [MD5Collision].\n   As discussed in\
    \ [RFC3579] Section 4.3, the security vulnerabilities\n   of RADIUS are extensive,\
    \ and therefore development of an alternative\n   key wrap technique based on\
    \ the RADIUS shared secret would not\n   substantially improve security.  As a\
    \ result, [RFC3579] Section 4.2\n   recommends running RADIUS over IPsec.  The\
    \ same approach is taken in\n   Diameter EAP [RFC4072], which in Section 4.1.3\
    \ defines the\n   EAP-Master-Session-Key Attribute-Value Pair (AVP) in clear-text,\
    \ to\n   be protected by IPsec or TLS.\n"
- title: 4.  Handoff Vulnerabilities
  contents:
  - "4.  Handoff Vulnerabilities\n   A handoff occurs when an EAP peer moves to a\
    \ new authenticator.\n   Several mechanisms have been proposed for reducing handoff\
    \ latency\n   within networks utilizing EAP.  These include:\n   EAP pre-authentication\n\
    \      In EAP pre-authentication, an EAP peer pre-establishes EAP keying\n   \
    \   material with an authenticator prior to arrival.  EAP\n      pre-authentication\
    \ only affects the timing of EAP authentication,\n      but does not shorten or\
    \ eliminate EAP (phase 1a) or AAA (phase 1b)\n      exchanges;  Discovery (phase\
    \ 0) and Secure Association Protocol\n      (phase 2) exchanges occur as described\
    \ in Section 1.3.  As a\n      result, the primary benefit is to enable EAP authentication\
    \ to be\n      removed from the handoff critical path, thereby reducing latency.\n\
    \      Use of EAP pre-authentication within IEEE 802.11 is described in\n    \
    \  [IEEE-802.11] and [8021XPreAuth].\n   Proactive key distribution\n      In\
    \ proactive key distribution, keying material and authorizations\n      are transported\
    \ from the backend authentication server to a\n      candidate authenticator in\
    \ advance of a handoff.  As a result, EAP\n      (phase 1a) is not needed, but\
    \ the Discovery (phase 0), and Secure\n      Association Protocol exchanges (phase\
    \ 2) are still necessary.\n      Within the AAA exchange (phase 1b), authorization\
    \ and key\n      distribution functions are typically supported, but not\n   \
    \   authentication.  Proactive key distribution is described in\n      [MishraPro],\
    \ [IEEE-03-084], and [HANDOFF].\n   Key caching\n      Caching of EAP keying material\
    \ enables an EAP peer to re-attach to\n      an authenticator without requiring\
    \ EAP (phase 1a) or AAA (phase\n      1b) exchanges.  However, Discovery (phase\
    \ 0) and Secure\n      Association Protocol (phase 2) exchanges are still needed.\
    \  Use of\n      key caching within IEEE 802.11 is described in [IEEE-802.11].\n\
    \   Context transfer\n      In context transfer schemes, keying material and authorizations\n\
    \      are transferred between a previous authenticator and a new\n      authenticator.\
    \  This can occur in response to a handoff request by\n      the EAP peer, or\
    \ in advance, as in proactive key distribution.  As\n      a result, EAP (phase\
    \ 1a) is eliminated, but not the Discovery\n      (phase 0) or Secure Association\
    \ Protocol exchanges (phase 2).  If\n      a secure channel can be established\
    \ between the new and previous\n      authenticator without assistance from the\
    \ backend authentication\n      server, then the AAA exchange (phase 1b) can be\
    \ eliminated;\n      otherwise, it is still needed, although it can be shortened.\n\
    \      Context transfer protocols are described in [IEEE-802.11F] (now\n     \
    \ deprecated) and \"Context Transfer Protocol (CXTP)\" [RFC4067].\n      \"Fast\
    \ Authentication Methods for Handovers between IEEE 802.11\n      Wireless LANs\"\
    \ [Bargh] analyzes fast handoff techniques, including\n      context transfer\
    \ mechanisms.\n   Token distribution\n      In token distribution schemes, the\
    \ EAP peer is provided with a\n      credential, subsequently enabling it to authenticate\
    \ with one or\n      more additional authenticators.  During the subsequent\n\
    \      authentications, EAP (phase 1a) is eliminated or shortened; the\n     \
    \ Discovery (phase 0) and Secure Association Protocol exchanges\n      (phase\
    \ 2) still occur, although the latter can be shortened.  If\n      the token includes\
    \ authorizations and can be validated by an\n      authenticator without assistance\
    \ from the backend authentication\n      server, then the AAA exchange (phase\
    \ 1b) can be eliminated;\n      otherwise, it is still needed, although it can\
    \ be shortened.\n      Token-based schemes, initially proposed in early versions\
    \ of IEEE\n      802.11i [IEEE-802.11i], are described in [Token], [Tokenk], and\n\
    \      [SHORT-TERM].\n   The sections that follow discuss the security vulnerabilities\n\
    \   introduced by the above schemes.\n"
- title: 4.1.  EAP Pre-Authentication
  contents:
  - "4.1.  EAP Pre-Authentication\n   EAP pre-authentication differs from a normal\
    \ EAP conversation\n   primarily with respect to the lower-layer encapsulation.\
    \  For\n   example, in [IEEE-802.11], EAP pre-authentication frames utilize a\n\
    \   distinct Ethertype, but otherwise conforms to the encapsulation\n   described\
    \ in [IEEE-802.1X].  As a result, an EAP pre-authentication\n   conversation differs\
    \ little from the model described in Section 1.3,\n   other than the introduction\
    \ of a delay between phase 1 and phase 2.\n   EAP pre-authentication relies on\
    \ lower-layer mechanisms for discovery\n   of candidate authenticators.  Where\
    \ discovery can provide information\n   on candidate authenticators outside the\
    \ immediate listening range,\n   and the peer can determine whether it already\
    \ possesses valid EAP\n   keying material with candidate authenticators, the peer\
    \ can avoid\n   unnecessary EAP pre-authentications and can establish EAP keying\n\
    \   material well in advance, regardless of the coverage overlap between\n   authenticators.\
    \  However, if the peer can only discover candidate\n   authenticators within\
    \ listening range and cannot determine whether it\n   can reuse existing EAP keying\
    \ material, then it is possible that the\n   peer will not be able to complete\
    \ EAP pre-authentication prior to\n   connectivity loss or that it can pre-authenticate\
    \ multiple times with\n   the same authenticator, increasing backend authentication\
    \ server\n   load.\n   Since a peer can complete EAP pre-authentication with an\n\
    \   authenticator without eventually attaching to it, it is possible that\n  \
    \ phase 2 will not occur.  In this case, an Accounting-Request\n   signifying\
    \ the start of service will not be sent, or will only be\n   sent with a substantial\
    \ delay after the completion of authentication.\n   As noted in \"IEEE 802.1X\
    \ RADIUS Usage Guidelines\" [RFC3580], the AAA\n   exchange resulting from EAP\
    \ pre-authentication differs little from an\n   ordinary exchange described in\
    \ \"RADIUS Support for EAP\" [RFC3579].\n   For example, since in IEEE 802.11\
    \ [IEEE-802.11] an Association\n   exchange does not occur prior to EAP pre-authentication,\
    \ the SSID is\n   not known by the authenticator at authentication time, so that\
    \ an\n   Access-Request cannot include the SSID within the Called-Station-Id\n\
    \   attribute as described in [RFC3580] Section 3.20.\n   Since only the absence\
    \ of an SSID in the Called-Station-Id attribute\n   distinguishes an EAP pre-authentication\
    \ attempt, if the authenticator\n   does not always include the SSID for a normal\
    \ EAP authentication\n   attempt, it is possible that the backend authentication\
    \ server will\n   not be able to determine whether a session constitutes an EAP\n\
    \   pre-authentication attempt, potentially resulting in authorization or\n  \
    \ accounting problems.  Where the number of simultaneous sessions is\n   limited,\
    \ the backend authentication server can refuse to authorize a\n   valid EAP pre-authentication\
    \ attempt or can enable the peer to engage\n   in more simultaneous sessions than\
    \ they are authorized for.  Where\n   EAP pre-authentication occurs with an authenticator\
    \ which the peer\n   never attaches to, it is possible that the backend accounting\
    \ server\n   will not be able to determine whether the absence of an\n   Accounting-Request\
    \ was due to packet loss or a session that never\n   started.\n   In order to\
    \ enable pre-authentication requests to be handled more\n   reliably, it is RECOMMENDED\
    \ that AAA protocols explicitly identify\n   EAP pre-authentication.  In order\
    \ to suppress unnecessary EAP\n   pre-authentication exchanges, it is RECOMMENDED\
    \ that authenticators\n   unambiguously identify themselves as described in Section\
    \ 2.3.\n"
- title: 4.2.  Proactive Key Distribution
  contents:
  - "4.2.  Proactive Key Distribution\n   In proactive key distribution schemes, the\
    \ backend authentication\n   server transports keying material and authorizations\
    \ to an\n   authenticator in advance of the arrival of the peer.  The\n   authenticators\
    \ selected to receive the transported key material are\n   selected based on past\
    \ patterns of peer movement between\n   authenticators known as the \"neighbor\
    \ graph\".  In order to reduce\n   handoff latency, proactive key distribution\
    \ schemes typically only\n   demonstrate proof of possession of transported keying\
    \ material\n   between the EAP peer and authenticator.  During a handoff, the\n\
    \   backend authentication server is not provided with proof that the\n   peer\
    \ successfully authenticated to an authenticator; instead, the\n   authenticator\
    \ generates a stream of accounting messages without a\n   corresponding set of\
    \ authentication exchanges.  As described in\n   [MishraPro], knowledge of the\
    \ neighbor graph can be established via\n   static configuration or analysis of\
    \ authentication exchanges.  In\n   order to prevent corruption of the neighbor\
    \ graph, new neighbor graph\n   entries can only be created as the result of a\
    \ successful EAP\n   exchange, and accounting packets with no corresponding authentication\n\
    \   exchange need to be verified to correspond to neighbor graph entries\n   (e.g.,\
    \ corresponding to handoffs between neighbors).\n   In order to prevent compromise\
    \ of one authenticator from resulting in\n   compromise of other authenticators,\
    \ cryptographic separation needs to\n   be maintained between the keying material\
    \ transported to each\n   authenticator.  However, even where cryptographic separation\
    \ is\n   maintained, an attacker compromising an authenticator can still\n   disrupt\
    \ the operation of other authenticators.  As noted in [RFC3579]\n   Section 4.3.7,\
    \ in the absence of spoofing detection within the AAA\n   infrastructure, it is\
    \ possible for EAP authenticators to impersonate\n   each other.  By forging NAS\
    \ identification attributes within\n   authentication messages, an attacker compromising\
    \ one authenticator\n   could corrupt the neighbor graph, tricking the backend\
    \ authentication\n   server into transporting keying material to arbitrary authenticators.\n\
    \   While this would not enable recovery of EAP keying material without\n   breaking\
    \ fundamental cryptographic assumptions, it could enable\n   subsequent fraudulent\
    \ accounting messages, or allow an attacker to\n   disrupt service by increasing\
    \ load on the backend authentication\n   server or thrashing the authenticator\
    \ key cache.\n   Since proactive key distribution requires the distribution of\
    \ derived\n   keying material to candidate authenticators, the effectiveness of\n\
    \   this scheme depends on the ability of backend authentication server\n   to\
    \ anticipate the movement of the EAP peer.  Since proactive key\n   distribution\
    \ relies on backend authentication server knowledge of the\n   neighbor graph,\
    \ it is most applicable to intra-domain handoff\n   scenarios.  However, in inter-domain\
    \ handoff, where there can be many\n   authenticators, peers can frequently connect\
    \ to authenticators that\n   have not been previously encountered, making it difficult\
    \ for the\n   backend authentication server to derive a complete neighbor graph.\n\
    \   Since proactive key distribution schemes typically require\n   introduction\
    \ of server-initiated messages as described in [RFC5176]\n   and [HANDOFF], security\
    \ issues described in [RFC5176] Section 6 are\n   applicable, including authorization\
    \ (Section 6.1) and replay\n   detection (Section 6.3) problems.\n"
- title: 4.3.  AAA Bypass
  contents:
  - "4.3.  AAA Bypass\n   Fast handoff techniques that enable elimination of the AAA\
    \ exchange\n   (phase 1b) differ fundamentally from typical network access scenarios\n\
    \   (dial-up, wired LAN, etc.) that include user authentication as well\n   as\
    \ authorization for the offered service.  Where the AAA exchange\n   (phase 1b)\
    \ is omitted, authorizations and keying material are not\n   provided by the backend\
    \ authentication server, and as a result, they\n   need to be supplied by other\
    \ means.  This section describes some of\n   the implications.\n"
- title: 4.3.1.  Key Transport
  contents:
  - "4.3.1.  Key Transport\n   Where transported keying material is not supplied by\
    \ the backend\n   authentication server, it needs to be provided by another party\n\
    \   authorized to access that keying material.  As noted in Section 1.5,\n   only\
    \ the EAP peer, authenticator, and server are authorized to\n   possess transported\
    \ keying material.  Since EAP peers do not trust\n   each other, if the backend\
    \ authentication server does not supply\n   transported keying material to a new\
    \ authenticator, it can only be\n   provided by a previous authenticator.\n  \
    \ As noted in Section 1.5, the goal of the EAP conversation is to\n   derive session\
    \ keys known only to the peer and the authenticator.  If\n   keying material is\
    \ replicated between a previous authenticator and a\n   new authenticator, then\
    \ the previous authenticator can possess\n   session keys used between the peer\
    \ and new authenticator.  Also, the\n   new authenticator can possess session\
    \ keys used between the peer and\n   the previous authenticator.\n   If a one-way\
    \ function is used to derive the keying material to be\n   transported to the\
    \ new authenticator, then the new authenticator\n   cannot possess previous session\
    \ keys without breaking a fundamental\n   cryptographic assumption.\n"
- title: 4.3.2.  Authorization
  contents:
  - "4.3.2.  Authorization\n   As a part of the authentication process, the backend\
    \ authentication\n   server determines the user's authorization profile and transmits\
    \ the\n   authorizations to the authenticator along with the transported keying\n\
    \   material.  Typically, the profile is determined based on the user\n   identity,\
    \ but a certificate presented by the user can also provide\n   authorization information.\n\
    \   The backend authentication server is responsible for making a user\n   authorization\
    \ decision, which requires answering the following\n   questions:\n   (a)  Is\
    \ this a legitimate user of this network?\n   (b)  Is the user allowed to access\
    \ this network?\n   (c)  Is the user permitted to access this network on this\
    \ day and at\n        this time?\n   (d)  Is the user within the concurrent session\
    \ limit?\n   (e)  Are there any fraud, credit limit, or other concerns that could\n\
    \        lead to access denial?\n   (f)  If access is to be granted, what are\
    \ the service parameters\n        (mandatory tunneling, bandwidth, filters, and\
    \ so on) to be\n        provisioned for the user?\n   While the authorization\
    \ decision is, in principle, simple, the\n   distributed decision making process\
    \ can add complexity.  Where\n   brokers or proxies are involved, all of the AAA\
    \ entities in the chain\n   from the authenticator to the home backend authentication\
    \ server are\n   involved in the decision.  For example, a broker can deny access\
    \ even\n   if the home backend authentication server would allow it, or a proxy\n\
    \   can add authorizations (e.g., bandwidth limits).\n   Decisions can be based\
    \ on static policy definitions and profiles as\n   well as dynamic state (e.g.,\
    \ time of day or concurrent session\n   limits).  In addition to the Accept/Reject\
    \ decisions made by AAA\n   entities, service parameters or constraints can be\
    \ communicated to\n   the authenticator.\n   The criteria for Accept/Reject decisions\
    \ or the reasons for choosing\n   particular authorizations are typically not\
    \ communicated to the\n   authenticator, only the final result is.  As a result,\
    \ the\n   authenticator has no way to know on what the decision was based.  Was\n\
    \   a set of authorization parameters sent because this service is always\n  \
    \ provided to the user, or was the decision based on the time of day\n   and the\
    \ capabilities of the authenticator?\n"
- title: 4.3.3.  Correctness
  contents:
  - "4.3.3.  Correctness\n   When the AAA exchange (phase 1b) is bypassed, several\
    \ challenges\n   arise in ensuring correct authorization:\n   Theft of service\n\
    \      Bypassing the AAA exchange (phase 1b) SHOULD NOT enable a user to\n   \
    \   extend their network access or gain access to services they are\n      not\
    \ entitled to.\n   Consideration of network-wide state\n      Handoff techniques\
    \ SHOULD NOT render the backend authentication\n      server incapable of keeping\
    \ track of network-wide state.  For\n      example, a backend authentication server\
    \ can need to keep track of\n      simultaneous user sessions.\n   Elevation of\
    \ privilege\n      Backend authentication servers often perform conditional\n\
    \      evaluation, in which the authorizations returned in an\n      Access-Accept\
    \ message are contingent on the authenticator or on\n      dynamic state such\
    \ as the time of day.  In this situation,\n      bypassing the AAA exchange could\
    \ enable unauthorized access unless\n      the restrictions are explicitly encoded\
    \ within the authorizations\n      provided by the backend authentication server.\n\
    \   A handoff mechanism that provides proper authorization is said to be\n   \"\
    correct\".  One condition for correctness is as follows:\n      For a handoff\
    \ to be \"correct\" it MUST establish on the new\n      authenticator the same\
    \ authorizations as would have been created\n      had the new authenticator completed\
    \ a AAA conversation with the\n      backend authentication server.\n   A properly\
    \ designed handoff scheme will only succeed if it is\n   \"correct\" in this way.\
    \  If a successful handoff would establish\n   \"incorrect\" authorizations, it\
    \ is preferable for it to fail.  Where\n   the supported services differ between\
    \ authenticators, a handoff that\n   bypasses the backend authentication server\
    \ is likely to fail.\n   Section 1.1 of [RFC2865] states:\n      A authenticator\
    \ that does not implement a given service MUST NOT\n      implement the RADIUS\
    \ attributes for that service.  For example, a\n      authenticator that is unable\
    \ to offer ARAP service MUST NOT\n      implement the RADIUS attributes for ARAP.\
    \  A authenticator MUST\n      treat a RADIUS access-accept authorizing an unavailable\
    \ service as\n      an access-reject instead.\n   This behavior applies to attributes\
    \ that are known, but not\n   implemented.  For attributes that are unknown, Section\
    \ 5 of [RFC2865]\n   states:\n      A RADIUS server MAY ignore Attributes with\
    \ an unknown Type.  A\n      RADIUS client MAY ignore Attributes with an unknown\
    \ Type.\n   In order to perform a correct handoff, if a new authenticator is\n\
    \   provided with RADIUS authorizations for a known but unavailable\n   service,\
    \ then it MUST process these authorizations the same way it\n   would handle a\
    \ RADIUS Access-Accept requesting an unavailable\n   service;  this MUST cause\
    \ the handoff to fail.  However, if a new\n   authenticator is provided with authorizations\
    \ including unknown\n   attributes, then these attributes MAY be ignored.  The\
    \ definition of\n   a \"known but unsupported service\" MUST encompass requests\
    \ for\n   unavailable security services.  This includes vendor-specific\n   attributes\
    \ related to security, such as those described in [RFC2548].\n   Although it can\
    \ seem somewhat counter-intuitive, failure is indeed\n   the \"correct\" result\
    \ where a known but unsupported service is\n   requested.\n   Presumably, a correctly\
    \ configured backend authentication server\n   would not request that an authenticator\
    \ provide a service that it\n   does not implement.  This implies that if the\
    \ new authenticator were\n   to complete a AAA conversation, it would be likely\
    \ to receive\n   different service instructions.  Failure of the handoff is the\n\
    \   desired result since it will cause the new authenticator to go back\n   to\
    \ the backend server in order to receive the appropriate service\n   definition.\n\
    \   Handoff mechanisms that bypass the backend authentication server are\n   most\
    \ likely to be successful when employed in a homogeneous\n   deployment within\
    \ a single administrative domain.  In a heterogeneous\n   deployment, the backend\
    \ authentication server can return different\n   authorizations depending on the\
    \ authenticator making the request in\n   order to make sure that the requested\
    \ service is consistent with the\n   authenticator capabilities.  Where a backend\
    \ authentication server\n   would send different authorizations to the new authenticator\
    \ than\n   were sent to a previous authenticator, transferring authorizations\n\
    \   between the previous authenticator and the new authenticator will\n   result\
    \ in incorrect authorization.\n   Virtual LAN (VLAN) support is defined in [IEEE-802.1Q];\
    \ RADIUS\n   support for dynamic VLANs is described in [RFC3580] and [RFC4675].\n\
    \   If some authenticators support dynamic VLANs while others do not,\n   then\
    \ attributes present in the Access-Request (such as the\n   NAS-Port-Type, NAS-IP-Address,\
    \ NAS-IPv6-Address, and NAS-Identifier)\n   could be examined by the backend authentication\
    \ server to determine\n   when VLAN attributes will be returned, and if so, which\
    \ ones.\n   However, if the backend authenticator is bypassed, then a handoff\n\
    \   occurring between authenticators supporting different VLAN\n   capabilities\
    \ could result in a user obtaining access to an\n   unauthorized VLAN (e.g., a\
    \ user with access to a guest VLAN being\n   given unrestricted access to the\
    \ network).\n   Similarly, it is preferable for a handoff between an authenticator\n\
    \   providing confidentiality and another that does not to fail, since if\n  \
    \ the handoff were successful, the user would be moved from a secure to\n   an\
    \ insecure channel without permission from the backend\n   authentication server.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   The EAP threat model is described in [RFC3748]\
    \ Section 7.1.  The\n   security properties of EAP methods (known as \"security\
    \ claims\") are\n   described in [RFC3748] Section 7.2.1.  EAP method requirements\
    \ for\n   applications such as Wireless LAN authentication are described in\n\
    \   [RFC4017].  The RADIUS threat model is described in [RFC3579] Section\n  \
    \ 4.1, and responses to these threats are described in [RFC3579],\n   Sections\
    \ 4.2 and 4.3.\n   However, in addition to threats against EAP and AAA, there\
    \ are other\n   system level threats.  In developing the threat model, it is assumed\n\
    \   that:\n      All traffic is visible to the attacker.\n      The attacker can\
    \ alter, forge, or replay messages.\n      The attacker can reroute messages to\
    \ another principal.\n      The attacker can be a principal or an outsider.\n\
    \      The attacker can compromise any key that is sufficiently old.\n   Threats\
    \ arising from these assumptions include:\n   (a)  An attacker can compromise\
    \ or steal an EAP peer or\n        authenticator, in an attempt to gain access\
    \ to other EAP peers\n        or authenticators or to obtain long-term secrets.\n\
    \   (b)  An attacker can attempt a downgrade attack in order to exploit\n    \
    \    known weaknesses in an authentication method or cryptographic\n        algorithm.\n\
    \   (c)  An attacker can try to modify or spoof packets, including\n        Discovery\
    \ or Secure Association Protocol frames, EAP or AAA\n        packets.\n   (d)\
    \  An attacker can attempt to induce an EAP peer, authenticator, or\n        server\
    \ to disclose keying material to an unauthorized party, or\n        utilize keying\
    \ material outside the context that it was intended\n        for.\n   (e)  An\
    \ attacker can alter, forge, or replay packets.\n   (f)  An attacker can cause\
    \ an EAP peer, authenticator, or server to\n        reuse a stale key.  Use of\
    \ stale keys can also occur\n        unintentionally.  For example, a poorly implemented\
    \ backend\n        authentication server can provide stale keying material to\
    \ an\n        authenticator, or a poorly implemented authenticator can reuse\n\
    \        nonces.\n   (g)  An authenticated attacker can attempt to obtain elevated\n\
    \        privilege in order to access information that it does not have\n    \
    \    rights to.\n   (h)  An attacker can attempt a man-in-the-middle attack in\
    \ order to\n        gain access to the network.\n   (i)  An attacker can compromise\
    \ an EAP authenticator in an effort to\n        commit fraud.  For example, a\
    \ compromised authenticator can\n        provide incorrect information to the\
    \ EAP peer and/or server via\n        out-of-band mechanisms (such as via a AAA\
    \ or lower-layer\n        protocol).  This includes impersonating another authenticator,\n\
    \        or providing inconsistent information to the peer and EAP\n        server.\n\
    \   (j)  An attacker can launch a denial-of-service attack against the\n     \
    \   EAP peer, authenticator, or backend authentication server.\n   In order to\
    \ address these threats, [RFC4962] Section 3 describes\n   required and recommended\
    \ security properties.  The sections that\n   follow analyze the compliance of\
    \ EAP methods, AAA protocols, and\n   Secure Association Protocols with those\
    \ guidelines.\n"
- title: 5.1.  Peer and Authenticator Compromise
  contents:
  - "5.1.  Peer and Authenticator Compromise\n   Requirement: In the event that an\
    \ authenticator is compromised or\n   stolen, an attacker can gain access to the\
    \ network through that\n   authenticator, or can obtain the credentials needed\
    \ for the\n   authenticator/AAA client to communicate with one or more backend\n\
    \   authentication servers.  Similarly, if a peer is compromised or\n   stolen,\
    \ an attacker can obtain credentials needed to communicate with\n   one or more\
    \ authenticators.  A mandatory requirement from [RFC4962]\n   Section 3:\n   \
    \   Prevent the Domino effect\n      Compromise of a single peer MUST NOT compromise\
    \ keying material\n      held by any other peer within the system, including session\
    \ keys\n      and long-term keys.  Likewise, compromise of a single\n      authenticator\
    \ MUST NOT compromise keying material held by any\n      other authenticator within\
    \ the system.  In the context of a key\n      hierarchy, this means that the compromise\
    \ of one node in the key\n      hierarchy must not disclose the information necessary\
    \ to\n      compromise other branches in the key hierarchy.  Obviously, the\n\
    \      compromise of the root of the key hierarchy will compromise all of\n  \
    \    the keys; however, a compromise in one branch MUST NOT result in\n      the\
    \ compromise of other branches.  There are many implications of\n      this requirement;\
    \ however, two implications deserve highlighting.\n      First, the scope of the\
    \ keying material must be defined and\n      understood by all parties that communicate\
    \ with a party that holds\n      that keying material.  Second, a party that holds\
    \ keying material\n      in a key hierarchy must not share that keying material\
    \ with\n      parties that are associated with other branches in the key\n   \
    \   hierarchy.\n      Group keys are an obvious exception.  Since all members\
    \ of the\n      group have a copy of the same key, compromise of any one of the\n\
    \      group members will result in the disclosure of the group key.\n   Some\
    \ of the implications of the requirement are as follows:\n   Key Sharing\n   \
    \     In order to be able to determine whether keying material has\n        been\
    \ shared, it is necessary for the identity of the EAP\n        authenticator (NAS-Identifier)\
    \ to be defined and understood by\n        all parties that communicate with it.\
    \  EAP lower-layer\n        specifications such as [IEEE-802.11], [IEEE-802.16e],\n\
    \        [IEEE-802.1X], IKEv2 [RFC4306], and PPP [RFC1661] do not involve\n  \
    \      key sharing.\n   AAA Credential Sharing\n        AAA credentials (such\
    \ as RADIUS shared secrets, IPsec pre-shared\n        keys or certificates) MUST\
    \ NOT be shared between AAA clients,\n        since if one AAA client were compromised,\
    \ this would enable an\n        attacker to impersonate other AAA clients to the\
    \ backend\n        authentication server, or even to impersonate a backend\n \
    \       authentication server to other AAA clients.\n   Compromise of Long-Term\
    \ Credentials\n        An attacker obtaining keying material (such as TSKs, TEKs,\
    \ or\n        the MSK) MUST NOT be able to obtain long-term user credentials\n\
    \        such as pre-shared keys, passwords, or private-keys without\n       \
    \ breaking a fundamental cryptographic assumption.  The mandatory\n        requirements\
    \ of [RFC4017] Section 2.2 include generation of EAP\n        keying material,\
    \ capability to generate EAP keying material with\n        128 bits of effective\
    \ strength, resistance to dictionary\n        attacks, shared state equivalence,\
    \ and protection against\n        man-in-the-middle attacks.\n"
- title: 5.2.  Cryptographic Negotiation
  contents:
  - "5.2.  Cryptographic Negotiation\n   Mandatory requirements from [RFC4962] Section\
    \ 3:\n      Cryptographic algorithm independent\n      The AAA key management\
    \ protocol MUST be cryptographic algorithm\n      independent.  However, an EAP\
    \ method MAY depend on a specific\n      cryptographic algorithm.  The ability\
    \ to negotiate the use of a\n      particular cryptographic algorithm provides\
    \ resilience against\n      compromise of a particular cryptographic algorithm.\
    \  Algorithm\n      independence is also REQUIRED with a Secure Association Protocol\n\
    \      if one is defined.  This is usually accomplished by including an\n    \
    \  algorithm identifier and parameters in the protocol, and by\n      specifying\
    \ the algorithm requirements in the protocol\n      specification.  While highly\
    \ desirable, the ability to negotiate\n      key derivation functions (KDFs) is\
    \ not required.  For\n      interoperability, at least one suite of mandatory-to-implement\n\
    \      algorithms MUST be selected.  Note that without protection by\n      IPsec\
    \ as described in [RFC3579] Section 4.2, RADIUS [RFC2865] does\n      not meet\
    \ this requirement, since the integrity protection\n      algorithm cannot be\
    \ negotiated.\n      This requirement does not mean that a protocol must support\
    \ both\n      public-key and symmetric-key cryptographic algorithms.  It means\n\
    \      that the protocol needs to be structured in such a way that\n      multiple\
    \ public-key algorithms can be used whenever a public-key\n      algorithm is\
    \ employed.  Likewise, it means that the protocol needs\n      to be structured\
    \ in such a way that multiple symmetric-key\n      algorithms can be used whenever\
    \ a symmetric-key algorithm is\n      employed.\n      Confirm ciphersuite selection\n\
    \      The selection of the \"best\" ciphersuite SHOULD be securely\n      confirmed.\
    \  The mechanism SHOULD detect attempted roll-back\n      attacks.\n   EAP methods\
    \ satisfying [RFC4017] Section 2.2 mandatory requirements\n   and AAA protocols\
    \ utilizing transmission-layer security are capable\n   of addressing downgrade\
    \ attacks.  [RFC3748] Section 7.2.1 describes\n   the \"protected ciphersuite\
    \ negotiation\" security claim that refers to\n   the ability of an EAP method\
    \ to negotiate the ciphersuite used to\n   protect the EAP method conversation,\
    \ as well as to integrity protect\n   the ciphersuite negotiation.  [RFC4017]\
    \ Section 2.2 requires EAP\n   methods satisfying this security claim.  Since\
    \ TLS v1.2 [RFC5246] and\n   IKEv2 [RFC4306] support negotiation of Key Derivation\
    \ Functions\n   (KDFs), EAP methods based on TLS or IKEv2 will, if properly designed,\n\
    \   inherit this capability.  However, negotiation of KDFs is not\n   required\
    \ by RFC 4962 [RFC4962], and EAP methods based on neither TLS\n   nor IKEv2 typically\
    \ do not support KDF negotiation.\n   When AAA protocols utilize TLS [RFC5246]\
    \ or IPsec [RFC4301] for\n   transmission layer security, they can leverage the\
    \ cryptographic\n   algorithm negotiation support provided by IKEv2 [RFC4306]\
    \ or TLS\n   [RFC5246].  RADIUS [RFC3579] by itself does not support cryptographic\n\
    \   algorithm negotiation and relies on MD5 for integrity protection,\n   authentication,\
    \ and confidentiality.  Given the known weaknesses in\n   MD5 [MD5Collision],\
    \ this is undesirable, and can be addressed via use\n   of RADIUS over IPsec,\
    \ as described in [RFC3579] Section 4.2.\n   To ensure against downgrade attacks\
    \ within lower-layer protocols,\n   algorithm independence is REQUIRED with lower\
    \ layers using EAP for\n   key derivation.  For interoperability, at least one\
    \ suite of\n   mandatory-to-implement algorithms MUST be selected.  Lower-layer\n\
    \   protocols supporting EAP for key derivation SHOULD also support\n   secure\
    \ ciphersuite negotiation as well as KDF negotiation.\n   As described in [RFC1968],\
    \ PPP ECP does not support secure\n   ciphersuite negotiation.  While [IEEE-802.16e]\
    \ and [IEEE-802.11]\n   support ciphersuite negotiation for protection of data,\
    \ they do not\n   support negotiation of the cryptographic primitives used within\
    \ the\n   Secure Association Protocol, such as message integrity checks (MICs)\n\
    \   and KDFs.\n"
- title: 5.3.  Confidentiality and Authentication
  contents:
  - "5.3.  Confidentiality and Authentication\n   Mandatory requirements from [RFC4962]\
    \ Section 3:\n      Authenticate all parties\n      Each party in the AAA key\
    \ management protocol MUST be\n      authenticated to the other parties with whom\
    \ they communicate.\n      Authentication mechanisms MUST maintain the confidentiality\
    \ of any\n      secret values used in the authentication process.  When a secure\n\
    \      association protocol is used to establish session keys, the\n      parties\
    \ involved in the secure association protocol MUST identify\n      themselves\
    \ using identities that are meaningful in the lower-layer\n      protocol environment\
    \ that will employ the session keys.  In this\n      situation, the authenticator\
    \ and peer may be known by different\n      identifiers in the AAA protocol environment\
    \ and the lower-layer\n      protocol environment, making authorization decisions\
    \ difficult\n      without a clear key scope.  If the lower-layer identifier of\
    \ the\n      peer will be used to make authorization decisions, then the pair\n\
    \      of identifiers associated with the peer MUST be authorized by the\n   \
    \   authenticator and/or the AAA server.\n      AAA protocols, such as RADIUS\
    \ [RFC2865] and Diameter [RFC3588],\n      provide a mechanism for the identification\
    \ of AAA clients; since\n      the EAP authenticator and AAA client are always\
    \ co-resident, this\n      mechanism is applicable to the identification of EAP\n\
    \      authenticators.\n      When multiple base stations and a \"controller\"\
    \ (such as a WLAN\n      switch) comprise a single EAP authenticator, the \"base\
    \ station\n      identity\" is not relevant; the EAP method conversation takes\
    \ place\n      between the EAP peer and the EAP server.  Also, many base stations\n\
    \      can share the same authenticator identity.  The authenticator\n      identity\
    \ is important in the AAA protocol exchange and the secure\n      association\
    \ protocol conversation.\n      Authentication mechanisms MUST NOT employ plaintext\
    \ passwords.\n      Passwords may be used provided that they are not sent to another\n\
    \      party without confidentiality protection.\n      Keying material confidentiality\
    \ and integrity\n      While preserving algorithm independence, confidentiality\
    \ and\n      integrity of all keying material MUST be maintained.\n   Conformance\
    \ to these requirements is analyzed in the sections that\n   follow.\n"
- title: 5.3.1.  Spoofing
  contents:
  - "5.3.1.  Spoofing\n   Per-packet authentication and integrity protection provides\n\
    \   protection against spoofing attacks.\n   Diameter [RFC3588] provides support\
    \ for per-packet authentication and\n   integrity protection via use of IPsec\
    \ or TLS.  RADIUS/EAP [RFC3579]\n   provides for per-packet authentication and\
    \ integrity protection via\n   use of the Message-Authenticator Attribute.\n \
    \  [RFC3748] Section 7.2.1 describes the \"integrity protection\" security\n \
    \  claim and [RFC4017] Section 2.2 requires EAP methods supporting this\n   claim.\n\
    \   In order to prevent forgery of Secure Association Protocol frames,\n   per-frame\
    \ authentication and integrity protection is RECOMMENDED on\n   all messages.\
    \  IKEv2 [RFC4306] supports per-frame integrity\n   protection and authentication,\
    \ as does the Secure Association\n   Protocol defined in [IEEE-802.16e].  [IEEE-802.11]\
    \ supports per-frame\n   integrity protection and authentication on all messages\
    \ within the\n   4-way handshake except the first message.  An attack leveraging\
    \ this\n   omission is described in [Analysis].\n"
- title: 5.3.2.  Impersonation
  contents:
  - "5.3.2.  Impersonation\n   Both RADIUS [RFC2865] and Diameter [RFC3588] implementations\
    \ are\n   potentially vulnerable to a rogue authenticator impersonating another\n\
    \   authenticator.  While both protocols support mutual authentication\n   between\
    \ the AAA client/authenticator and the backend authentication\n   server, the\
    \ security mechanisms vary.\n   In RADIUS, the shared secret used for authentication\
    \ is determined by\n   the source address of the RADIUS packet.  However, when\
    \ RADIUS\n   Access-Requests are forwarded by a proxy, the NAS-IP-Address,\n \
    \  NAS-Identifier, or NAS-IPv6-Address attributes received by the RADIUS\n   server\
    \ will not correspond to the source address.  As noted in\n   [RFC3579] Section\
    \ 4.3.7, if the first-hop proxy does not check the\n   NAS identification attributes\
    \ against the source address in the\n   Access-Request packet, it is possible\
    \ for a rogue authenticator to\n   forge NAS-IP-Address [RFC2865], NAS-IPv6-Address\
    \ [RFC3162], or\n   NAS-Identifier [RFC2865] attributes in order to impersonate\
    \ another\n   authenticator; attributes such as the Called-Station-Id [RFC2865]\
    \ and\n   Calling-Station-Id [RFC2865] can be forged as well.  Among other\n \
    \  things, this can result in messages (and transported keying material)\n   being\
    \ sent to the wrong authenticator.\n   While [RFC3588] requires use of the Route-Record\
    \ AVP, this utilizes\n   Fully Qualified Domain Names (FQDNs), so that impersonation\
    \ detection\n   requires DNS A, AAAA, and PTR Resource Records (RRs) to be properly\n\
    \   configured.  As a result, Diameter is as vulnerable to this attack as\n  \
    \ RADIUS, if not more so.  [RFC3579] Section 4.3.7 recommends\n   mechanisms for\
    \ impersonation detection; to prevent access to keying\n   material by proxies\
    \ without a \"need to know\", it is necessary to\n   allow the backend authentication\
    \ server to communicate with the\n   authenticator directly, such as via the redirect\
    \ functionality\n   supported in [RFC3588].\n"
- title: 5.3.3.  Channel Binding
  contents:
  - "5.3.3.  Channel Binding\n   It is possible for a compromised or poorly implemented\
    \ EAP\n   authenticator to communicate incorrect information to the EAP peer\n\
    \   and/or server.  This can enable an authenticator to impersonate\n   another\
    \ authenticator or communicate incorrect information via\n   out-of-band mechanisms\
    \ (such as via AAA or the lower layer).\n   Where EAP is used in pass-through\
    \ mode, the EAP peer does not verify\n   the identity of the pass-through authenticator\
    \ within the EAP\n   conversation.  Within the Secure Association Protocol, the\
    \ EAP peer\n   and authenticator only demonstrate mutual possession of the\n \
    \  transported keying material; they do not mutually authenticate.  This\n   creates\
    \ a potential security vulnerability, described in [RFC3748]\n   Section 7.15.\n\
    \   As described in [RFC3579] Section 4.3.7, it is possible for a\n   first-hop\
    \ AAA proxy to detect a AAA client attempting to impersonate\n   another authenticator.\
    \  However, it is possible for a pass-through\n   authenticator acting as a AAA\
    \ client to provide correct information\n   to the backend authentication server\
    \ while communicating misleading\n   information to the EAP peer via the lower\
    \ layer.\n   For example, a compromised authenticator can utilize another\n  \
    \ authenticator's Called-Station-Id or NAS-Identifier in communicating\n   with\
    \ the EAP peer via the lower layer.  Also, a pass-through\n   authenticator acting\
    \ as a AAA client can provide an incorrect peer\n   Calling-Station-Id [RFC2865]\
    \ [RFC3580] to the backend authentication\n   server via the AAA protocol.\n \
    \  As noted in [RFC3748] Section 7.15, this vulnerability can be\n   addressed\
    \ by EAP methods that support a protected exchange of channel\n   properties such\
    \ as endpoint identifiers, including (but not limited\n   to): Called-Station-Id\
    \ [RFC2865] [RFC3580], Calling-Station-Id\n   [RFC2865] [RFC3580], NAS-Identifier\
    \ [RFC2865], NAS-IP-Address\n   [RFC2865], and NAS-IPv6-Address [RFC3162].\n \
    \  Using such a protected exchange, it is possible to match the channel\n   properties\
    \ provided by the authenticator via out-of-band mechanisms\n   against those exchanged\
    \ within the EAP method.  Typically, the EAP\n   method imports channel binding\
    \ parameters from the lower layer on the\n   peer, and transmits them securely\
    \ to the EAP server, which exports\n   them to the lower layer or AAA layer. \
    \ However, transport can occur\n   from EAP server to peer, or can be bi-directional.\
    \  On the side of\n   the exchange (peer or server) where channel binding is verified,\
    \ the\n   lower layer or AAA layer passes the result of the verification (TRUE\n\
    \   or FALSE) up to the EAP method.  While the verification can be done\n   either\
    \ by the peer or the server, typically only the server has the\n   knowledge to\
    \ determine the correctness of the values, as opposed to\n   merely verifying\
    \ their equality.  For further discussion, see\n   [EAP-SERVICE].\n   It is also\
    \ possible to perform channel binding without transporting\n   data over EAP,\
    \ as described in [EAP-CHANNEL].  In this approach the\n   EAP method includes\
    \ channel binding parameters in the calculation of\n   exported EAP keying material,\
    \ making it impossible for the peer and\n   authenticator to complete the Secure\
    \ Association Protocol if there is\n   a mismatch in the channel binding parameters.\
    \  However, this approach\n   can only be applied where methods generating EAP\
    \ keying material are\n   used along with lower layers that utilize EAP keying\
    \ material.  For\n   example, this mechanism would not enable verification of\
    \ channel\n   binding on wired IEEE 802 networks using [IEEE-802.1X].\n"
- title: 5.3.4.  Mutual Authentication
  contents:
  - "5.3.4.  Mutual Authentication\n   [RFC3748] Section 7.2.1 describes the \"mutual\
    \ authentication\" and\n   \"dictionary attack resistance\" claims, and [RFC4017]\
    \ requires EAP\n   methods satisfying these claims.  EAP methods complying with\n\
    \   [RFC4017] therefore provide for mutual authentication between the EAP\n  \
    \ peer and server.\n   [RFC3748] Section 7.2.1 also describes the \"Cryptographic\
    \ binding\"\n   security claim, and [RFC4017] Section 2.2 requires support for\
    \ this\n   claim.  As described in [EAP-BINDING], EAP method sequences and\n \
    \  compound authentication mechanisms can be subject to\n   man-in-the-middle\
    \ attacks.  When such attacks are successfully\n   carried out, the attacker acts\
    \ as an intermediary between a victim\n   and a legitimate authenticator.  This\
    \ allows the attacker to\n   authenticate successfully to the authenticator, as\
    \ well as to obtain\n   access to the network.\n   In order to prevent these attacks,\
    \ [EAP-BINDING] recommends\n   derivation of a compound key by which the EAP peer\
    \ and server can\n   prove that they have participated in the entire EAP exchange.\
    \  Since\n   the compound key MUST NOT be known to an attacker posing as an\n\
    \   authenticator, and yet must be derived from EAP keying material, it\n   MAY\
    \ be desirable to derive the compound key from a portion of the\n   EMSK.  Where\
    \ this is done, in order to provide proper key hygiene, it\n   is RECOMMENDED\
    \ that the compound key used for man-in-the-middle\n   protection be cryptographically\
    \ separate from other keys derived from\n   the EMSK.\n   Diameter [RFC3588] provides\
    \ for per-packet authentication and\n   integrity protection via IPsec or TLS,\
    \ and RADIUS/EAP [RFC3579] also\n   provides for per-packet authentication and\
    \ integrity protection.\n   Where the authenticator/AAA client and backend authentication\
    \ server\n   communicate directly and credible key wrap is used (see Section 3.8),\n\
    \   this ensures that the AAA Key Transport (phase 1b) achieves its\n   security\
    \ objectives: mutually authenticating the AAA\n   client/authenticator and backend\
    \ authentication server and providing\n   transported keying material to the EAP\
    \ authenticator and to no other\n   party.\n   [RFC2607] Section 7 describes the\
    \ security issues occurring when the\n   authenticator/AAA client and backend\
    \ authentication server do not\n   communicate directly.  Where a AAA intermediary\
    \ is present (such as a\n   RADIUS proxy or a Diameter agent), and data object\
    \ security is not\n   used, transported keying material can be recovered by an\
    \ attacker in\n   control of the intermediary.  As discussed in Section 2.1, unless\
    \ the\n   TSKs are derived independently from EAP keying material (as in\n   IKEv2),\
    \ possession of transported keying material enables decryption\n   of data traffic\
    \ sent between the peer and the authenticator to whom\n   the keying material\
    \ was transported.  It also allows the AAA\n   intermediary to impersonate the\
    \ authenticator or the peer.  Since the\n   peer does not authenticate to a AAA\
    \ intermediary, it has no ability\n   to determine whether it is authentic or\
    \ authorized to obtain keying\n   material.\n   However, as long as transported\
    \ keying material or keys derived from\n   it are only utilized by a single authenticator,\
    \ compromise of the\n   transported keying material does not enable an attacker\
    \ to\n   impersonate the peer to another authenticator.  Vulnerability to\n  \
    \ compromise of a AAA intermediary can be mitigated by implementation\n   of redirect\
    \ functionality, as described in [RFC3588] and [RFC4072].\n   The Secure Association\
    \ Protocol does not provide for mutual\n   authentication between the EAP peer\
    \ and authenticator, only mutual\n   proof of possession of transported keying\
    \ material.  In order for the\n   peer to verify the identity of the authenticator,\
    \ mutual proof of\n   possession needs to be combined with impersonation prevention\
    \ and\n   channel binding.  Impersonation prevention (described in Section\n \
    \  5.3.2) enables the backend authentication server to determine that\n   the\
    \ transported keying material has been provided to the correct\n   authenticator.\
    \  When utilized along with impersonation prevention,\n   channel binding (described\
    \ in Section 5.3.3) enables the EAP peer to\n   verify that the EAP server has\
    \ authorized the authenticator to\n   possess the transported keying material.\
    \  Completion of the Secure\n   Association Protocol exchange demonstrates that\
    \ the EAP peer and the\n   authenticator possess the transported keying material.\n"
- title: 5.4.  Key Binding
  contents:
  - "5.4.  Key Binding\n   Mandatory requirement from [RFC4962] Section 3:\n     \
    \ Bind key to its context\n      Keying material MUST be bound to the appropriate\
    \ context.  The\n      context includes the following:\n      o  The manner in\
    \ which the keying material is expected to be used.\n      o  The other parties\
    \ that are expected to have access to the\n         keying material.\n      o\
    \  The expected lifetime of the keying material.  Lifetime of a\n         child\
    \ key SHOULD NOT be greater than the lifetime of its parent\n         in the key\
    \ hierarchy.\n      Any party with legitimate access to keying material can determine\n\
    \      its context.  In addition, the protocol MUST ensure that all\n      parties\
    \ with legitimate access to keying material have the same\n      context for the\
    \ keying material.  This requires that the parties\n      are properly identified\
    \ and authenticated, so that all of the\n      parties that have access to the\
    \ keying material can be determined.\n      The context will include the peer\
    \ and NAS identities in more than\n      one form.  One (or more) name form is\
    \ needed to identify these\n      parties in the authentication exchange and the\
    \ AAA protocol.\n      Another name form may be needed to identify these parties\
    \ within\n      the lower layer that will employ the session key.\n   Within EAP,\
    \ exported keying material (MSK, EMSK,IV) is bound to the\n   Peer-Id(s) and Server-Id(s),\
    \ which are exported along with the keying\n   material.  However, not all EAP\
    \ methods support authenticated server\n   identities (see Appendix A).\n   Within\
    \ the AAA protocol, transported keying material is destined for\n   the EAP authenticator\
    \ identified by the NAS-Identifier Attribute\n   within the request, and is for\
    \ use by the EAP peer identified by the\n   Peer-Id(s), User-Name [RFC2865], or\
    \ Chargeable User Identity (CUI)\n   [RFC4372] attributes.  The maximum lifetime\
    \ of the transported keying\n   material can be provided, as discussed in Section\
    \ 3.5.1.  Key usage\n   restrictions can also be included as described in Section\
    \ 3.2.  Key\n   lifetime issues are discussed in Sections 3.3, 3.4, and 3.5.\n"
- title: 5.5.  Authorization
  contents:
  - "5.5.  Authorization\n   Requirement: The Secure Association Protocol (phase 2)\
    \ conversation\n   may utilize different identifiers from the EAP conversation\
    \ (phase\n   1a), so that binding between the EAP and Secure Association Protocol\n\
    \   identities is REQUIRED.\n   Mandatory requirement from [RFC4962] Section 3:\n\
    \      Peer and authenticator authorization\n      Peer and authenticator authorization\
    \ MUST be performed.  These\n      entities MUST demonstrate possession of the\
    \ appropriate keying\n      material, without disclosing it.  Authorization is\
    \ REQUIRED\n      whenever a peer associates with a new authenticator.  The\n\
    \      authorization checking prevents an elevation of privilege attack,\n   \
    \   and it ensures that an unauthorized authenticator is detected.\n      Authorizations\
    \ SHOULD be synchronized between the peer, NAS, and\n      backend authentication\
    \ server.  Once the AAA key management\n      protocol exchanges are complete,\
    \ all of these parties should hold\n      a common view of the authorizations\
    \ associated with the other\n      parties.\n      In addition to authenticating\
    \ all parties, key management\n      protocols need to demonstrate that the parties\
    \ are authorized to\n      possess keying material.  Note that proof of possession\
    \ of keying\n      material does not necessarily prove authorization to hold that\n\
    \      keying material.  For example, within an IEEE 802.11, the 4-way\n     \
    \ handshake demonstrates that both the peer and authenticator\n      possess the\
    \ same EAP keying material.  However, by itself, this\n      possession proof\
    \ does not demonstrate that the authenticator was\n      authorized by the backend\
    \ authentication server to possess that\n      keying material.  As noted in [RFC3579]\
    \ in Section 4.3.7, where\n      AAA proxies are present, it is possible for one\
    \ authenticator to\n      impersonate another, unless each link in the AAA chain\
    \ implements\n      checks against impersonation.  Even with these checks in place,\
    \ an\n      authenticator may still claim different identities to the peer and\n\
    \      the backend authentication server.  As described in [RFC3748]\n      Section\
    \ 7.15, channel binding is required to enable the peer to\n      verify that the\
    \ authenticator claim of identity is both consistent\n      and correct.\n   Recommendation\
    \ from [RFC4962] Section 3:\n      Authorization restriction\n      If peer authorization\
    \ is restricted, then the peer SHOULD be made\n      aware of the restriction.\
    \  Otherwise, the peer may inadvertently\n      attempt to circumvent the restriction.\
    \  For example, authorization\n      restrictions in an IEEE 802.11 environment\
    \ include:\n      o  Key lifetimes, where the keying material can only be used\
    \ for a\n         certain period of time;\n      o  SSID restrictions, where the\
    \ keying material can only be used\n         with a specific IEEE 802.11 SSID;\n\
    \      o  Called-Station-ID restrictions, where the keying material can\n    \
    \     only be used with a single IEEE 802.11 BSSID; and\n      o  Calling-Station-ID\
    \ restrictions, where the keying material can\n         only be used with a single\
    \ peer IEEE 802 MAC address.\n   As described in Section 2.3, consistent identification\
    \ of the EAP\n   authenticator enables the EAP peer to determine the scope of\
    \ keying\n   material provided to an authenticator, as well as to confirm with\
    \ the\n   backend authentication server that an EAP authenticator proving\n  \
    \ possession of EAP keying material during the Secure Association\n   Protocol\
    \ was authorized to obtain it.\n   Within the AAA protocol, the authorization\
    \ attributes are bound to\n   the transported keying material.  While the AAA\
    \ exchange provides the\n   AAA client/authenticator with authorizations relating\
    \ to the EAP\n   peer, neither the EAP nor AAA exchanges provide authorizations\
    \ to the\n   EAP peer.  In order to ensure that all parties hold the same view\
    \ of\n   the authorizations, it is RECOMMENDED that the Secure Association\n \
    \  Protocol enable communication of authorizations between the EAP\n   authenticator\
    \ and peer.\n   In lower layers where the authenticator consistently identifies\n\
    \   itself to the peer and backend authentication server and the EAP peer\n  \
    \ completes the Secure Association Protocol exchange with the same\n   authenticator\
    \ through which it completed the EAP conversation,\n   authorization of the authenticator\
    \ is demonstrated to the peer by\n   mutual authentication between the peer and\
    \ authenticator as discussed\n   in the previous section.  Identification issues\
    \ are discussed in\n   Sections 2.3, 2.4, and 2.5 and key scope issues are discussed\
    \ in\n   Section 3.2.\n   Where the EAP peer utilizes different identifiers within\
    \ the EAP\n   method and Secure Association Protocol conversations, peer\n   authorization\
    \ can be difficult to demonstrate to the authenticator\n   without additional\
    \ restrictions.  This problem does not exist in\n   IKEv2 where the Identity Payload\
    \ is used for peer identification both\n   within IKEv2 and EAP, and where the\
    \ EAP conversation is\n   cryptographically protected within IKEv2 binding the\
    \ EAP and IKEv2\n   exchanges.  However, within [IEEE-802.11], the EAP peer identity\
    \ is\n   not used within the 4-way handshake, so that it is necessary for the\n\
    \   authenticator to require that the EAP peer utilize the same MAC\n   address\
    \ for EAP authentication as for the 4-way handshake.\n"
- title: 5.6.  Replay Protection
  contents:
  - "5.6.  Replay Protection\n   Mandatory requirement from [RFC4962] Section 3:\n\
    \      Replay detection mechanism\n      The AAA key management protocol exchanges\
    \ MUST be replay\n      protected, including AAA, EAP and Secure Association Protocol\n\
    \      exchanges.  Replay protection allows a protocol message recipient\n   \
    \   to discard any message that was recorded during a previous\n      legitimate\
    \ dialogue and presented as though it belonged to the\n      current dialogue.\n\
    \   [RFC3748] Section 7.2.1 describes the \"replay protection\" security\n   claim,\
    \ and [RFC4017] Section 2.2 requires use of EAP methods\n   supporting this claim.\n\
    \   Diameter [RFC3588] provides support for replay protection via use of\n   IPsec\
    \ or TLS.  \"RADIUS Support for EAP\" [RFC3579] protects against\n   replay of\
    \ keying material via the Request Authenticator.  According\n   to [RFC2865] Section\
    \ 3:\n      In Access-Request Packets, the Authenticator value is a 16 octet\n\
    \      random number, called the Request Authenticator.\n   However, some RADIUS\
    \ packets are not replay protected.  In\n   Accounting, Disconnect, and Care-of\
    \ Address (CoA)-Request packets,\n   the Request Authenticator contains a keyed\
    \ Message Integrity Code\n   (MIC) rather than a nonce.  The Response Authenticator\
    \ in Accounting,\n   Disconnect, and CoA-Response packets also contains a keyed\
    \ MIC whose\n   calculation does not depend on a nonce in either the Request or\n\
    \   Response packets.  Therefore, unless an Event-Timestamp attribute is\n   included\
    \ or IPsec is used, it is possible that the recipient will not\n   be able to\
    \ determine whether these packets have been replayed.  This\n   issue is discussed\
    \ further in [RFC5176] Section 6.3.\n   In order to prevent replay of Secure Association\
    \ Protocol frames,\n   replay protection is REQUIRED on all messages.  [IEEE-802.11]\n\
    \   supports replay protection on all messages within the 4-way\n   handshake;\
    \ IKEv2 [RFC4306] also supports this.\n"
- title: 5.7.  Key Freshness
  contents:
  - "5.7.  Key Freshness\n   Requirement: A session key SHOULD be considered compromised\
    \ if it\n   remains in use beyond its authorized lifetime.  Mandatory requirement\n\
    \   from [RFC4962] Section 3:\n      Strong, fresh session keys\n      While preserving\
    \ algorithm independence, session keys MUST be\n      strong and fresh.  Each\
    \ session deserves an independent session\n      key.  Fresh keys are required\
    \ even when a long replay counter\n      (that is, one that \"will never wrap\"\
    ) is used to ensure that loss\n      of state does not cause the same counter\
    \ value to be used more\n      than once with the same session key.\n      Some\
    \ EAP methods are capable of deriving keys of varying strength,\n      and these\
    \ EAP methods MUST permit the generation of keys meeting a\n      minimum equivalent\
    \ key strength.  BCP 86 [RFC3766] offers advice\n      on appropriate key sizes.\
    \  The National Institute for Standards\n      and Technology (NIST) also offers\
    \ advice on appropriate key sizes\n      in [SP800-57].\n      A fresh cryptographic\
    \ key is one that is generated specifically\n      for the intended use.  In this\
    \ situation, a secure association\n      protocol is used to establish session\
    \ keys.  The AAA protocol and\n      EAP method MUST ensure that the keying material\
    \ supplied as an\n      input to session key derivation is fresh, and the secure\n\
    \      association protocol MUST generate a separate session key for each\n  \
    \    session, even if the keying material provided by EAP is cached.  A\n    \
    \  cached key persists after the authentication exchange has\n      completed.\
    \  For the AAA/EAP server, key caching can happen when\n      state is kept on\
    \ the server.  For the NAS or client, key caching\n      can happen when the NAS\
    \ or client does not destroy keying material\n      immediately following the\
    \ derivation of session keys.\n      Session keys MUST NOT be dependent on one\
    \ another.  Multiple\n      session keys may be derived from a higher-level shared\
    \ secret as\n      long as a one-time value, usually called a nonce, is used to\n\
    \      ensure that each session key is fresh.  The mechanism used to\n      generate\
    \ session keys MUST ensure that the disclosure of one\n      session key does\
    \ not aid the attacker in discovering any other\n      session keys.\n   EAP,\
    \ AAA, and the lower layer each bear responsibility for ensuring\n   the use of\
    \ fresh, strong session keys.  EAP methods need to ensure\n   the freshness and\
    \ strength of EAP keying material provided as an\n   input to session key derivation.\
    \  [RFC3748] Section 7.10 states:\n      EAP methods SHOULD ensure the freshness\
    \ of the MSK and EMSK, even\n      in cases where one party may not have a high\
    \ quality random number\n      generator.  A RECOMMENDED method is for each party\
    \ to provide a\n      nonce of at least 128 bits, used in the derivation of the\
    \ MSK and\n      EMSK.\n   The contribution of nonces enables the EAP peer and\
    \ server to ensure\n   that exported EAP keying material is fresh.\n   [RFC3748]\
    \ Section 7.2.1 describes the \"key strength\" and \"session\n   independence\"\
    \ security claims, and [RFC4017] requires EAP methods\n   supporting these claims\
    \ as well as methods capable of providing\n   equivalent key strength of 128 bits\
    \ or greater.  See Section 3.7 for\n   more information on key strength.\n   The\
    \ AAA protocol needs to ensure that transported keying material is\n   fresh and\
    \ is not utilized outside its recommended lifetime.  Replay\n   protection is\
    \ necessary for key freshness, but an attacker can\n   deliver a stale (and therefore\
    \ potentially compromised) key in a\n   replay-protected message, so replay protection\
    \ is not sufficient.  As\n   discussed in Section 3.5, the Session-Timeout Attribute\
    \ enables the\n   backend authentication server to limit the exposure of transported\n\
    \   keying material.\n   The EAP Session-Id, described in Section 1.4, enables\
    \ the EAP peer,\n   authenticator, and server to distinguish EAP conversations.\
    \  However,\n   unless the authenticator keeps track of EAP Session-Ids, the\n\
    \   authenticator cannot use the Session-Id to guarantee the freshness of\n  \
    \ keying material.\n   The Secure Association Protocol, described in Section 3.1,\
    \ MUST\n   generate a fresh session key for each session, even if the EAP keying\n\
    \   material and parameters provided by methods are cached, or either the\n  \
    \ peer or authenticator lack a high entropy random number generator.  A\n   RECOMMENDED\
    \ method is for the peer and authenticator to each provide\n   a nonce or counter\
    \ used in session key derivation.  If a nonce is\n   used, it is RECOMMENDED that\
    \ it be at least 128 bits.  While\n   [IEEE-802.11] and IKEv2 [RFC4306] satisfy\
    \ this requirement,\n   [IEEE-802.16e] does not, since randomness is only contributed\
    \ from\n   the Base Station.\n"
- title: 5.8.  Key Scope Limitation
  contents:
  - "5.8.  Key Scope Limitation\n   Mandatory requirement from [RFC4962] Section 3:\n\
    \      Limit key scope\n      Following the principle of least privilege, parties\
    \ MUST NOT have\n      access to keying material that is not needed to perform\
    \ their\n      role.  A party has access to a particular key if it has access\
    \ to\n      all of the secret information needed to derive it.\n      Any protocol\
    \ that is used to establish session keys MUST specify\n      the scope for session\
    \ keys, clearly identifying the parties to\n      whom the session key is available.\n\
    \   Transported keying material is permitted to be accessed by the EAP\n   peer,\
    \ authenticator and server.  The EAP peer and server derive EAP\n   keying material\
    \ during the process of mutually authenticating each\n   other using the selected\
    \ EAP method.  During the Secure Association\n   Protocol exchange, the EAP peer\
    \ utilizes keying material to\n   demonstrate to the authenticator that it is\
    \ the same party that\n   authenticated to the EAP server and was authorized by\
    \ it.  The EAP\n   authenticator utilizes the transported keying material to prove\
    \ to\n   the peer not only that the EAP conversation was transported through\n\
    \   it (this could be demonstrated by a man-in-the-middle), but that it\n   was\
    \ uniquely authorized by the EAP server to provide the peer with\n   access to\
    \ the network.  Unique authorization can only be demonstrated\n   if the EAP authenticator\
    \ does not share the transported keying\n   material with a party other than the\
    \ EAP peer and server.  TSKs are\n   permitted to be accessed only by the EAP\
    \ peer and authenticator (see\n   Section 1.5); TSK derivation is discussed in\
    \ Section 2.1.  Since\n   demonstration of authorization within the Secure Association\
    \ Protocol\n   exchange depends on possession of transported keying material,\
    \ the\n   backend authentication server can obtain TSKs unless it deletes the\n\
    \   transported keying material after sending it.\n"
- title: 5.9.  Key Naming
  contents:
  - "5.9.  Key Naming\n   Mandatory requirement from [RFC4962] Section 3:\n      Uniquely\
    \ named keys\n      AAA key management proposals require a robust key naming scheme,\n\
    \      particularly where key caching is supported.  The key name\n      provides\
    \ a way to refer to a key in a protocol so that it is clear\n      to all parties\
    \ which key is being referenced.  Objects that cannot\n      be named cannot be\
    \ managed.  All keys MUST be uniquely named, and\n      the key name MUST NOT\
    \ directly or indirectly disclose the keying\n      material.  If the key name\
    \ is not based on the keying material,\n      then one can be sure that it cannot\
    \ be used to assist in a search\n      for the key value.\n   EAP key names (defined\
    \ in Section 1.4.1), along with the Peer-Id(s)\n   and Server-Id(s), uniquely\
    \ identify EAP keying material, and do not\n   directly or indirectly expose EAP\
    \ keying material.\n   Existing AAA server implementations do not distribute key\
    \ names along\n   with the transported keying material.  However, Diameter EAP\n\
    \   [RFC4072] Section 4.1.4 defines the EAP-Key-Name AVP for the purpose\n   of\
    \ transporting the EAP Session-Id.  Since the EAP-Key-Name AVP is\n   defined\
    \ within the RADIUS attribute space, it can be used either with\n   RADIUS or\
    \ Diameter.\n   Since the authenticator is not provided with the name of the\n\
    \   transported keying material by existing backend authentication server\n  \
    \ implementations, existing Secure Association Protocols do not utilize\n   EAP\
    \ key names.  For example, [IEEE-802.11] supports PMK caching; to\n   enable the\
    \ peer and authenticator to determine the cached PMK to\n   utilize within the\
    \ 4-way handshake, the PMK needs to be named.  For\n   this purpose, [IEEE-802.11]\
    \ utilizes a PMK naming scheme that is\n   based on the key.  Since IKEv2 [RFC4306]\
    \ does not cache transported\n   keying material, it does not need to refer to\
    \ transported keying\n   material.\n"
- title: 5.10.  Denial-of-Service Attacks
  contents:
  - "5.10.  Denial-of-Service Attacks\n   Key caching can result in vulnerability\
    \ to denial-of-service attacks.\n   For example, EAP methods that create persistent\
    \ state can be\n   vulnerable to denial-of-service attacks on the EAP server by\
    \ a rogue\n   EAP peer.\n   To address this vulnerability, EAP methods creating\
    \ persistent state\n   can limit the persistent state created by an EAP peer.\
    \  For example,\n   for each peer an EAP server can choose to limit persistent\
    \ state to a\n   few EAP conversations, distinguished by the EAP Session-Id. \
    \ This\n   prevents a rogue peer from denying access to other peers.\n   Similarly,\
    \ to conserve resources an authenticator can choose to limit\n   the persistent\
    \ state corresponding to each peer.  This can be\n   accomplished by limiting\
    \ each peer to persistent state corresponding\n   to a few EAP conversations,\
    \ distinguished by the EAP Session-Id.\n   Whether creation of new TSKs implies\
    \ deletion of previously derived\n   TSKs depends on the EAP lower layer.  Where\
    \ there is no implied\n   deletion, the authenticator can choose to limit the\
    \ number of TSKs\n   and associated state that can be stored for each peer.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC3748]      Aboba, B., Blunk, L., Vollbrecht, J., Carlson,\
    \ J., and\n                  H. Levkowetz, Ed., \"Extensible Authentication Protocol\n\
    \                  (EAP)\", RFC 3748, June 2004.\n   [RFC4962]      Housley, R.\
    \ and B. Aboba, \"Guidance for\n                  Authentication, Authorization,\
    \ and Accounting (AAA)\n                  Key Management\", BCP 132, RFC 4962,\
    \ July 2007.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [8021XPreAuth] Pack, S. and Y. Choi, \"Pre-Authenticated\
    \ Fast Handoff\n                  in a Public Wireless LAN Based on IEEE 802.1x\
    \ Model\",\n                  Proceedings of the IFIP TC6/WG6.8 Working Conference\n\
    \                  on Personal Wireless Communications, p.175-182,\n         \
    \         October 23-25, 2002.\n   [Analysis]     He, C. and J. Mitchell, \"Analysis\
    \ of the 802.11i 4-Way\n                  Handshake\", Proceedings of the 2004\
    \ ACM Workshop on\n                  Wireless Security, pp. 43-50, ISBN: 1-58113-925-X.\n\
    \   [Bargh]        Bargh, M., Hulsebosch, R., Eertink, E., Prasad, A.,\n     \
    \             Wang, H. and P. Schoo, \"Fast Authentication Methods\n         \
    \         for Handovers between IEEE 802.11 Wireless LANs\",\n               \
    \   Proceedings of the 2nd ACM international workshop on\n                  Wireless\
    \ mobile applications and services on WLAN\n                  hotspots, October,\
    \ 2004.\n   [GKDP]         Dondeti, L., Xiang, J., and S. Rowles, \"GKDP: Group\n\
    \                  Key Distribution Protocol\", Work in Progress, March\n    \
    \              2006.\n   [He]           He, C., Sundararajan, M., Datta, A. Derek,\
    \ A. and J.\n                  C.  Mitchell, \"A Modular Correctness Proof of\
    \ TLS and\n                  IEEE 802.11i\", ACM Conference on Computer and\n\
    \                  Communications Security (CCS '05), November, 2005.\n   [IEEE-802.11]\
    \  Institute of Electrical and Electronics Engineers,\n                  \"Information\
    \ technology - Telecommunications and\n                  information exchange\
    \ between systems - Local and\n                  metropolitan area networks -\
    \ Specific Requirements\n                  Part 11:  Wireless LAN Medium Access\
    \ Control (MAC) and\n                  Physical Layer (PHY) Specifications\",\
    \ IEEE Standard\n                  802.11-2007, 2007.\n   [IEEE-802.1X]  Institute\
    \ of Electrical and Electronics Engineers,\n                  \"Local and Metropolitan\
    \ Area Networks: Port-Based\n                  Network Access Control\", IEEE\
    \ Standard 802.1X-2004,\n                  December 2004.\n   [IEEE-802.1Q]  IEEE\
    \ Standards for Local and Metropolitan Area\n                  Networks:  Draft\
    \ Standard for Virtual Bridged Local\n                  Area Networks, P802.1Q-2003,\
    \ January 2003.\n   [IEEE-802.11i] Institute of Electrical and Electronics Engineers,\n\
    \                  \"Supplement to Standard for Telecommunications and\n     \
    \             Information Exchange Between Systems - LAN/MAN\n               \
    \   Specific Requirements - Part 11: Wireless LAN Medium\n                  Access\
    \ Control (MAC) and Physical Layer (PHY)\n                  Specifications:  Specification\
    \ for Enhanced Security\",\n                  IEEE 802.11i/D1, 2001.\n   [IEEE-802.11F]\
    \ Institute of Electrical and Electronics Engineers,\n                  \"Recommended\
    \ Practice for Multi-Vendor Access Point\n                  Interoperability via\
    \ an Inter-Access Point Protocol\n                  Across Distribution Systems\
    \ Supporting IEEE 802.11\n                  Operation\", IEEE 802.11F, July 2003\
    \ (now deprecated).\n   [IEEE-802.16e] Institute of Electrical and Electronics\
    \ Engineers,\n                  \"IEEE Standard for Local and Metropolitan Area\n\
    \                  Networks: Part 16: Air Interface for Fixed and Mobile\n   \
    \               Broadband Wireless Access Systems: Amendment for\n           \
    \       Physical and Medium Access Control Layers for Combined\n             \
    \     Fixed and Mobile Operations in Licensed Bands\" IEEE\n                 \
    \ 802.16e, August 2005.\n   [IEEE-03-084]  Mishra, A., Shin, M., Arbaugh, W.,\
    \ Lee, I. and K.\n                  Jang, \"Proactive Key Distribution to support\
    \ fast and\n                  secure roaming\", IEEE 802.11 Working Group, IEEE-03-\n\
    \                  084r1-I, http://www.ieee802.org/11/Documents/\n           \
    \       DocumentHolder/3-084.zip, January 2003.\n   [EAP-SERVICE]  Arkko, J. and\
    \ P. Eronen, \"Authenticated Service\n                  Information for the Extensible\
    \ Authentication Protocol\n                  (EAP)\", Work in Progress, October\
    \ 2005.\n   [SHORT-TERM]   Friedman, A., Sheffer, Y., and A. Shaqed, \"Short-Term\n\
    \                  Certificates\", Work in Progress, June 2007.\n   [HANDOFF]\
    \      Arbaugh, W. and B. Aboba, \"Handoff Extension to\n                  RADIUS\"\
    , Work in Progress, October 2003.\n   [EAP-CHANNEL]  Ohba, Y., Parthasrathy, M.,\
    \ and M. Yanagiya, \"Channel\n                  Binding Mechanism Based on Parameter\
    \ Binding in Key\n                  Derivation\", Work in Progress, June 2007.\n\
    \   [EAP-BINDING]  Puthenkulam, J., Lortz, V., Palekar, A., and D. Simon,\n  \
    \                \"The Compound Authentication Binding Problem\", Work in\n  \
    \                Progress, October 2003.\n   [MD5Collision] Klima, V., \"Tunnels\
    \ in Hash Functions: MD5 Collisions\n                  Within a Minute\", Cryptology\
    \ ePrint Archive, March\n                  2006, http://eprint.iacr.org/2006/105.pdf\n\
    \   [MishraPro]    Mishra, A., Shin, M. and W. Arbaugh, \"Pro-active Key\n   \
    \               Distribution using Neighbor Graphs\", IEEE Wireless\n        \
    \          Communications, vol. 11, February 2004.\n   [RFC1661]      Simpson,\
    \ W., Ed., \"The Point-to-Point Protocol (PPP)\",\n                  STD 51, RFC\
    \ 1661, July 1994.\n   [RFC1968]      Meyer, G., \"The PPP Encryption Control\
    \ Protocol\n                  (ECP)\", RFC 1968, June 1996.\n   [RFC2230]    \
    \  Atkinson, R., \"Key Exchange Delegation Record for the\n                  DNS\"\
    , RFC 2230, November 1997.\n   [RFC2409]      Harkins, D. and D. Carrel, \"The\
    \ Internet Key Exchange\n                  (IKE)\", RFC 2409, November 1998.\n\
    \   [RFC2516]      Mamakos, L., Lidl, K., Evarts, J., Carrel, D., Simone,\n  \
    \                D., and R. Wheeler, \"A Method for Transmitting PPP\n       \
    \           Over Ethernet (PPPoE)\", RFC 2516, February 1999.\n   [RFC2548]  \
    \    Zorn, G., \"Microsoft Vendor-specific RADIUS\n                  Attributes\"\
    , RFC 2548, March 1999.\n   [RFC2607]      Aboba, B. and J. Vollbrecht, \"Proxy\
    \ Chaining and\n                  Policy Implementation in Roaming\", RFC 2607,\
    \ June\n                  1999.\n   [RFC2716]      Aboba, B. and D. Simon, \"\
    PPP EAP TLS Authentication\n                  Protocol\", RFC 2716, October 1999.\n\
    \   [RFC2782]      Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR\n   \
    \               for specifying the location of services (DNS SRV)\",\n       \
    \           RFC 2782, February 2000.\n   [RFC2845]      Vixie, P., Gudmundsson,\
    \ O., Eastlake 3rd, D., and B.\n                  Wellington, \"Secret Key Transaction\
    \ Authentication for\n                  DNS (TSIG)\", RFC 2845, May 2000.\n  \
    \ [RFC2865]      Rigney, C., Willens, S., Rubens, A., and W. Simpson,\n      \
    \            \"Remote Authentication Dial In User Service (RADIUS)\",\n      \
    \            RFC 2865, June 2000.\n   [RFC3007]      Wellington, B., \"Secure\
    \ Domain Name System (DNS)\n                  Dynamic Update\", RFC 3007, November\
    \ 2000.\n   [RFC3162]      Aboba, B., Zorn, G., and D. Mitton, \"RADIUS and IPv6\"\
    ,\n                  RFC 3162, August 2001.\n   [RFC3547]      Baugher, M., Weis,\
    \ B., Hardjono, T., and H. Harney,\n                  \"The Group Domain of Interpretation\"\
    , RFC 3547, July\n                  2003.\n   [RFC3579]      Aboba, B. and P.\
    \ Calhoun, \"RADIUS (Remote\n                  Authentication Dial In User Service)\
    \ Support For\n                  Extensible Authentication Protocol (EAP)\", RFC\
    \ 3579,\n                  September 2003.\n   [RFC3580]      Congdon, P., Aboba,\
    \ B., Smith, A., Zorn, G., and J.\n                  Roese, \"IEEE 802.1X Remote\
    \ Authentication Dial In User\n                  Service (RADIUS) Usage Guidelines\"\
    , RFC 3580,\n                  September 2003.\n   [RFC3588]      Calhoun, P.,\
    \ Loughney, J., Guttman, E., Zorn, G., and\n                  J. Arkko, \"Diameter\
    \ Base Protocol\", RFC 3588,\n                  September 2003.\n   [RFC3766]\
    \      Orman, H. and P. Hoffman, \"Determining Strengths For\n               \
    \   Public Keys Used For Exchanging Symmetric Keys\", BCP\n                  86,\
    \ RFC 3766, April 2004.\n   [RFC3830]      Arkko, J., Carrara, E., Lindholm, F.,\
    \ Naslund, M., and\n                  K. Norrman, \"MIKEY: Multimedia Internet\
    \ KEYing\", RFC\n                  3830, August 2004.\n   [RFC4005]      Calhoun,\
    \ P., Zorn, G., Spence, D., and D. Mitton,\n                  \"Diameter Network\
    \ Access Server Application\", RFC\n                  4005, August 2005.\n   [RFC4017]\
    \      Stanley, D., Walker, J., and B. Aboba, \"Extensible\n                 \
    \ Authentication Protocol (EAP) Method Requirements for\n                  Wireless\
    \ LANs\", RFC 4017, March 2005.\n   [RFC4033]      Arends, R., Austein, R., Larson,\
    \ M., Massey, D., and\n                  S. Rose, \"DNS Security Introduction\
    \ and Requirements\",\n                  RFC 4033, March 2005.\n   [RFC4035] \
    \     Arends, R., Austein, R., Larson, M., Massey, D., and\n                 \
    \ S. Rose, \"Protocol Modifications for the DNS Security\n                  Extensions\"\
    , RFC 4035, March 2005.\n   [RFC4067]      Loughney, J., Ed., Nakhjiri, M., Perkins,\
    \ C., and R.\n                  Koodli, \"Context Transfer Protocol (CXTP)\",\
    \ RFC 4067,\n                  July 2005.\n   [RFC4072]      Eronen, P., Ed.,\
    \ Hiller, T., and G. Zorn, \"Diameter\n                  Extensible Authentication\
    \ Protocol (EAP) Application\",\n                  RFC 4072, August 2005.\n  \
    \ [RFC4118]      Yang, L., Zerfos, P., and E. Sadot, \"Architecture\n        \
    \          Taxonomy for Control and Provisioning of Wireless\n               \
    \   Access Points (CAPWAP)\", RFC 4118, June 2005.\n   [RFC4186]      Haverinen,\
    \ H., Ed., and J. Salowey, Ed., \"Extensible\n                  Authentication\
    \ Protocol Method for Global System for\n                  Mobile Communications\
    \ (GSM) Subscriber Identity\n                  Modules (EAP-SIM)\", RFC 4186,\
    \ January 2006.\n   [RFC4187]      Arkko, J. and H. Haverinen, \"Extensible Authentication\n\
    \                  Protocol Method for 3rd Generation Authentication and\n   \
    \               Key Agreement (EAP-AKA)\", RFC 4187, January 2006.\n   [RFC4282]\
    \      Aboba, B., Beadles, M., Arkko, J., and P. Eronen, \"The\n             \
    \     Network Access Identifier\", RFC 4282, December 2005.\n   [RFC4284]    \
    \  Adrangi, F., Lortz, V., Bari, F., and P. Eronen,\n                  \"Identity\
    \ Selection Hints for the Extensible\n                  Authentication Protocol\
    \ (EAP)\", RFC 4284, January\n                  2006.\n   [RFC4301]      Kent,\
    \ S. and K. Seo, \"Security Architecture for the\n                  Internet Protocol\"\
    , RFC 4301, December 2005.\n   [RFC4306]      Kaufman, C., Ed., \"Internet Key\
    \ Exchange (IKEv2)\n                  Protocol\", RFC 4306, December 2005.\n \
    \  [RFC4372]      Adrangi, F., Lior, A., Korhonen, J., and J. Loughney,\n    \
    \              \"Chargeable User Identity\", RFC 4372, January 2006.\n   [RFC4334]\
    \      Housley, R. and T. Moore, \"Certificate Extensions and\n              \
    \    Attributes Supporting Authentication in Point-to-Point\n                \
    \  Protocol (PPP) and Wireless Local Area Networks\n                  (WLAN)\"\
    , RFC 4334, February 2006.\n   [RFC4535]      Harney, H., Meth, U., Colegrove,\
    \ A., and G. Gross,\n                  \"GSAKMP: Group Secure Association Key\
    \ Management\n                  Protocol\", RFC 4535, June 2006.\n   [RFC4763]\
    \      Vanderveen, M. and H. Soliman, \"Extensible\n                  Authentication\
    \ Protocol Method for Shared-secret\n                  Authentication and Key\
    \ Establishment (EAP-SAKE)\", RFC\n                  4763, November 2006.\n  \
    \ [RFC4675]      Congdon, P., Sanchez, M., and B. Aboba, \"RADIUS\n          \
    \        Attributes for Virtual LAN and Priority Support\", RFC\n            \
    \      4675, September 2006.\n   [RFC4718]      Eronen, P. and P. Hoffman, \"\
    IKEv2 Clarifications and\n                  Implementation Guidelines\", RFC 4718,\
    \ October 2006.\n   [RFC4764]      Bersani, F. and H. Tschofenig, \"The EAP-PSK\
    \ Protocol:\n                  A Pre-Shared Key Extensible Authentication Protocol\n\
    \                  (EAP) Method\", RFC 4764, January 2007.\n   [RFC5176]     \
    \ Chiba, M., Dommety, G., Eklund, M., Mitton, D., and B.\n                  Aboba,\
    \ \"Dynamic Authorization Extensions to Remote\n                  Authentication\
    \ Dial In User Service (RADIUS)\", RFC\n                  5176, January 2008.\n\
    \   [RFC5216]      Simon, D., Aboba, B., and R. Hurst, \"The EAP-TLS\n       \
    \           Authentication Protocol\", RFC 5216, March 2008.\n   [RFC5246]   \
    \   Dierks, T. and E. Rescorla, \"The Transport Layer\n                  Security\
    \ (TLS) Protocol Version 1.2\", RFC 5246, August\n                  2008.\n  \
    \ [SP800-57]     National Institute of Standards and Technology,\n           \
    \       \"Recommendation for Key Management\", Special\n                  Publication\
    \ 800-57, May 2006.\n   [Token]        Fantacci, R., Maccari, L., Pecorella, T.,\
    \ and F.\n                  Frosali, \"A secure and performant token-based\n \
    \                 authentication for infrastructure and mesh 802.1X\n        \
    \          networks\", IEEE Conference on Computer Communications,\n         \
    \         June 2006.\n   [Tokenk]       Ohba, Y., Das, S., and A. Duttak, \"Kerberized\
    \ Handover\n                  Keying: A Media-Independent Handover Key Management\n\
    \                  Architecture\", Mobiarch 2007.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Thanks to Ashwin Palekar, Charlie Kaufman, and Tim Moore\
    \ of\n   Microsoft, Jari Arkko of Ericsson, Dorothy Stanley of Aruba Networks,\n\
    \   Bob Moskowitz of TruSecure, Jesse Walker of Intel, Joe Salowey of\n   Cisco,\
    \ and Russ Housley of Vigil Security for useful feedback.\n"
- title: Appendix A - Exported Parameters in Existing Methods
  contents:
  - "Appendix A - Exported Parameters in Existing Methods\n   This Appendix specifies\
    \ Session-Id, Peer-Id, Server-Id and\n   Key-Lifetime for EAP methods that have\
    \ been published prior to this\n   specification.  Future EAP method specifications\
    \ MUST include a\n   definition of the Session-Id, Peer-Id and Server-Id (could\
    \ be the\n   null string).  In the descriptions that follow, all fields comprising\n\
    \   the Session-Id are assumed to be in network byte order.\n   EAP-Identity\n\
    \      The EAP-Identity method is defined in [RFC3748].  It does not\n      derive\
    \ keys, and therefore does not define the Session-Id.  The\n      Peer-Id and\
    \ Server-Id are the null string (zero length).\n   EAP-Notification\n      The\
    \ EAP-Notification method is defined in [RFC3748].  It does not\n      derive\
    \ keys and therefore does not define the Session-Id.  The\n      Peer-Id and Server-Id\
    \ are the null string (zero length).\n   EAP-MD5-Challenge\n      The EAP-MD5-Challenge\
    \ method is defined in [RFC3748].  It does not\n      derive keys and therefore\
    \ does not define the Session-Id.  The\n      Peer-Id and Server-Id are the null\
    \ string (zero length).\n   EAP-GTC\n      The EAP-GTC method is defined in [RFC3748].\
    \  It does not derive\n      keys and therefore does not define the Session-Id.\
    \  The Peer-Id\n      and Server-Id are the null string (zero length).\n   EAP-OTP\n\
    \      The EAP-OTP method is defined in [RFC3748].  It does not derive\n     \
    \ keys and therefore does not define the Session-Id.  The Peer-Id\n      and Server-Id\
    \ are the null string (zero length).\n   EAP-AKA\n      EAP-AKA is defined in\
    \ [RFC4187].  The EAP-AKA Session-Id is the\n      concatenation of the EAP Type\
    \ Code (0x17) with the contents of the\n      RAND field from the AT_RAND attribute,\
    \ followed by the contents of\n      the AUTN field in the AT_AUTN attribute:\n\
    \      Session-Id = 0x17 || RAND || AUTN\n      The Peer-Id is the contents of\
    \ the Identity field from the\n      AT_IDENTITY attribute, using only the Actual\
    \ Identity Length\n      octets from the beginning, however.  Note that the contents\
    \ are\n      used as they are transmitted, regardless of whether the\n      transmitted\
    \ identity was a permanent, pseudonym, or fast EAP\n      re-authentication identity.\
    \  The Server-Id is the null string\n      (zero length).\n   EAP-SIM\n      EAP-SIM\
    \ is defined in [RFC4186].  The EAP-SIM Session-Id is the\n      concatenation\
    \ of the EAP Type Code (0x12) with the contents of the\n      RAND field from\
    \ the AT_RAND attribute, followed by the contents of\n      the NONCE_MT field\
    \ in the AT_NONCE_MT attribute:\n      Session-Id = 0x12 || RAND || NONCE_MT\n\
    \      The Peer-Id is the contents of the Identity field from the\n      AT_IDENTITY\
    \ attribute, using only the Actual Identity Length\n      octets from the beginning,\
    \ however.  Note that the contents are\n      used as they are transmitted, regardless\
    \ of whether the\n      transmitted identity was a permanent, pseudonym, or fast\
    \ EAP\n      re-authentication identity.  The Server-Id is the null string\n \
    \     (zero length).\n   EAP-PSK\n      EAP-PSK is defined in [RFC4764].  The\
    \ EAP-PSK Session-Id is the\n      concatenation of the EAP Type Code (0x2F) with\
    \ the peer (RAND_P)\n      and server (RAND_S) nonces:\n      Session-Id = 0x2F\
    \ || RAND_P || RAND_S\n      The Peer-Id is the contents of the ID_P field and\
    \ the Server-Id is\n      the contents of the ID_S field.\n   EAP-SAKE\n     \
    \ EAP-SAKE is defined in [RFC4763].  The EAP-SAKE Session-Id is the\n      concatenation\
    \ of the EAP Type Code (0x30) with the contents of the\n      RAND_S field from\
    \ the AT_RAND_S attribute, followed by the\n      contents of the RAND_P field\
    \ in the AT_RAND_P attribute:\n      Session-Id = 0x30 || RAND_S || RAND_P\n \
    \     Note that the EAP-SAKE Session-Id is not the same as the \"Session\n   \
    \   ID\" parameter chosen by the Server, which is sent in the first\n      message,\
    \ and replicated in subsequent messages.  The Peer-Id is\n      contained within\
    \ the value field of the AT_PEERID attribute and\n      the Server-Id, if available,\
    \ is contained in the value field of\n      the AT_SERVERID attribute.\n   EAP-TLS\n\
    \      For EAP-TLS, the Peer-Id, Server-Id and Session-Id are defined in\n   \
    \   [RFC5216].\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n    Bernard Aboba\n    Microsoft Corporation\n    One Microsoft\
    \ Way\n    Redmond, WA 98052\n    EMail: bernarda@microsoft.com\n    Phone: +1\
    \ 425 706 6605\n    Fax:   +1 425 936 7329\n    Dan Simon\n    Microsoft Research\n\
    \    Microsoft Corporation\n    One Microsoft Way\n    Redmond, WA 98052\n   \
    \ EMail: dansimon@microsoft.com\n    Phone: +1 425 706 6711\n    Fax:   +1 425\
    \ 936 7329\n    Pasi Eronen\n    Nokia Research Center\n    P.O. Box 407\n   \
    \ FIN-00045 Nokia Group\n    Finland\n    EMail: pasi.eronen@nokia.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
