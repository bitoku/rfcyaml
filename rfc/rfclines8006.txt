Abstract The Content Delivery Network Interconnection (CDNI)
Metadata interface enables interconnected Content Delivery Networks (CDNs) to exchange content distribution metadata in order to enable content acquisition and delivery.
The CDNI Metadata associated with a piece of content provides a downstream CDN with sufficient information for the downstream CDN to service content requests on behalf of an upstream CDN.
This document describes both a base set of CDNI Metadata and the protocol for exchanging that metadata.
Introduction Content Delivery Network Interconnection (CDNI)
[RFC6707] enables a downstream Content Delivery Network (dCDN) to service content requests on behalf of an upstream CDN (uCDN).
The CDNI Metadata interface (MI) is discussed in [RFC7336] along with four other interfaces that can be used to compose a CDNI solution (the CDNI Control interface, the CDNI Request Routing Redirection interface, the CDNI Footprint & Capabilities Advertisement interface (FCI), and the CDNI Logging interface).
[RFC7336] describes each interface and the relationships between them.
The requirements for the CDNI
Metadata interface are specified in [RFC7337].
The CDNI Metadata associated with a piece of content (or with a set of content) provides a dCDN with sufficient information for servicing content requests on behalf of a uCDN, in accordance with the policies defined by the uCDN.
This document defines a CDNI Metadata interface that enables a dCDN to obtain CDNI Metadata from a uCDN so that the dCDN can properly process and respond to:  Redirection requests received over the CDNI Request Routing Redirection interface [RFC7975].
Content requests received directly from User Agents.
A data structure for mapping content requests and redirection requests to CDNI Metadata objects (Sections 3 and 4.1).
An initial set of CDNI GenericMetadata objects (Section 4.2).
An HTTP web service for the transfer of CDNI Metadata (Section 6).
This document reuses the terminology defined in [RFC6707].
Additionally, the following terms are used throughout this document and are defined as follows:
Object a collection of properties.
Property a key and value pair where the key is a property name and the value is the property value or another object.
This document uses the phrase "[Object]
A contains [Object] B" for simplicity when a strictly accurate phrase would be "[Object]
A contains or references (via a Link object)
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
Supported Metadata Capabilities Only the metadata for a small set of initial capabilities is specified in this document.
This set provides the minimum amount of metadata for basic CDN interoperability while still meeting the requirements set forth by [RFC7337].
The following high level functionality can be configured via the CDNI
Metadata objects specified in Section 4:  Acquisition Source: Metadata for allowing a dCDN to fetch content from a uCDN.
Time window    Delivery protocol  Delivery Authorization:
Metadata for authorizing dCDN User Agent requests.
Metadata for controlling cache behavior of the dCDN.
The metadata encoding described by this document is extensible in order to allow for future additions to this list.
The set of metadata specified in this document covers the initial capabilities above.
It is only intended to support CDNI for the delivery of content by a dCDN using HTTP/1.1 [RFC7230] and for a dCDN to be able to acquire content from a uCDN using either HTTP/1.1 or HTTP/1.1 over Transport Layer Security (TLS) [RFC2818].
Supporting CDNI for the delivery of content using unencrypted HTTP/2
[RFC7540] (as well as for a dCDN to acquire content using unencrypted HTTP/2 or HTTP/2 over TLS) requires the registration of these protocol names in the "CDNI Metadata Protocol Types" registry (Section 7.3).
Delivery of content using HTTP/1.1 over TLS or HTTP/2 over TLS SHOULD follow the guidelines set forth in [RFC7525].
Offline configuration of TLS parameters between CDNs is beyond the scope of this document.
Metadata interface was designed to achieve the following objectives: 1.
Cacheability of CDNI Metadata objects; 2.
Deterministic mapping from redirection requests and content requests to CDNI Metadata properties; 3.  Support for DNS redirection as well as application specific redirection (for example, HTTP redirection); 4.
Minimal duplication of CDNI Metadata; and 5.
Cacheability can decrease the latency of acquiring metadata while maintaining its freshness and can therefore decrease the latency of serving content requests and redirection requests, without sacrificing accuracy.
Metadata interface uses HTTP and its existing caching mechanisms to achieve CDNI Metadata cacheability.
Deterministic mapping from content to metadata properties eliminates ambiguity and ensures that policies are applied consistently by all dCDNs.
Support for both HTTP and DNS redirection ensures that the CDNI Metadata meets the same design principles for both HTTP based and DNS based redirection schemes.
Minimal duplication of CDNI Metadata improves storage efficiency in the CDNs.
Leveraging existing protocols avoids reinventing common mechanisms such as data structure encoding (by leveraging I JSON (Internet JSON)
[RFC7493]) and data transport (by leveraging HTTP [RFC7230]).
The CDNI Metadata object model describes a data structure for mapping redirection requests and content requests to metadata properties.
Metadata properties describe how to acquire content from a uCDN, authorize access to content, and deliver content from a dCDN.
The object model relies on the assumption that these metadata properties can be grouped based on the hostname of the content and subsequently on the resource path (URI) of the content.
The object model associates a set of CDNI Metadata properties with a hostname to form a default set of metadata properties for content delivered on behalf of that hostname.
That default set of metadata properties can be overridden by properties that apply to specific paths within a URI.
Different hostnames and URI paths will be associated with different sets of CDNI Metadata properties in order to describe the required behavior when a dCDN Surrogate or request router is processing User Agent requests for content at that hostname and URI path.
As a result of this structure, significant commonality could exist between the CDNI
Metadata properties specified for different hostnames, different URI paths within a hostname, and different URI paths on different hostnames.
For example, the definition of which User Agent IP addresses should be grouped together into a single network or geographic location is likely to be common for a number of different hostnames; although a uCDN is likely to have several different policies configured to express geo blocking rules, it is likely that a single geo blocking policy could be applied to multiple hostnames delivered through the CDN.
In order to enable the CDNI Metadata for a given hostname and URI path to be decomposed into reusable sets of CDNI Metadata properties, the CDNI Metadata interface splits the CDNI Metadata into separate objects.
Efficiency is improved by enabling a single CDNI Metadata object (that is shared across hostnames and/or URI paths) to be retrieved and stored by a dCDN once, even if it is referenced by the CDNI Metadata for multiple hostnames and/or URI paths.
Any CDNI Metadata object A that contains another CDNI
Metadata object B can include a Link object specifying a URI that can be used to retrieve object B, instead of embedding object B within object A.
The remainder of this document uses the phrase "[Object]
A contains [Object] B" for simplicity when a strictly accurate phrase would be "[Object]
A contains or references (via a Link object)
It is generally a deployment choice for the uCDN implementation to decide when to embed CDNI Metadata objects and when to reference separate resources via Link objects.
Section 3.1 introduces a high level description of the HostIndex, HostMatch, HostMetadata, PathMatch, PatternMatch, and PathMetadata objects, and describes the relationships between them.
Section 3.2 introduces a high level description of the CDNI GenericMetadata object, which represents the level at which CDNI Metadata override occurs between HostMetadata and PathMetadata objects.
Section 4 describes in detail
the specific CDNI Metadata objects and properties specified by this document that can be contained within a CDNI GenericMetadata object.
HostIndex, HostMatch, HostMetadata, PathMatch, PatternMatch, and PathMetadata Objects
The relationships between the HostIndex, HostMatch, HostMetadata, PathMatch, PatternMatch, and PathMetadata objects are described in Figure 1.
(1) One and only one
Relationships between CDNI Metadata Objects (Diagram Representation)
A HostIndex object (see Section 4.1.1) contains an array of HostMatch objects (see Section 4.1.2) that contain hostnames (and/or IP addresses) for which content requests might be delegated to the dCDN.
The HostIndex is the starting point for accessing the uCDN CDNI Metadata data store.
It enables the dCDN to deterministically discover which CDNI Metadata objects it requires in order to deliver a given piece of content.
The HostIndex links hostnames (and/or IP addresses) to HostMetadata objects (see Section 4.1.3) via HostMatch objects.
A HostMatch object defines a hostname (or IP address) to match against a requested host and contains a HostMetadata object.
HostMetadata objects contain the default GenericMetadata objects (see Section 4.1.7) required to serve content for that host.
When looking up CDNI Metadata, the dCDN looks up the requested hostname (or IP address) against the HostMatch entries in the HostIndex; from there, it can find HostMetadata, which describes the default metadata properties for each host as well as PathMetadata objects (see Section 4.1.6), via PathMatch objects (see Section 4.1.4).
PathMatch objects define patterns, contained inside PatternMatch objects (see Section 4.1.5), to match against the requested URI path.
PatternMatch objects contain the pattern strings and flags that describe the URI path to which a PathMatch applies.
PathMetadata objects contain the GenericMetadata objects that apply to content requests matching the defined URI path pattern.
PathMetadata properties override properties previously defined in HostMetadata or less specific PathMatch paths.
PathMetadata objects can contain additional PathMatch objects to recursively define more specific URI paths to which GenericMetadata properties might be applied.
A GenericMetadata object contains individual CDNI Metadata objects that define the specific policies and attributes needed to properly deliver the associated content.
For example, a GenericMetadata object could describe the source from which a CDN can acquire a piece of content.
The GenericMetadata object is an atomic unit that can be referenced by HostMetadata or PathMetadata objects.
For example, if "example.com" is a content provider, a HostMatch object could include an entry for "example.com" with the URI of the associated HostMetadata object.
The PathMetadata object for "example.com/movies/ " describes the properties that apply to that URI path.
The relationships in Figure 1 are also represented in tabular format in Table 1 below.
Data Object    Objects it contains or references
HostMetadata   0 or more PathMatch objects.
PatternMatch   Does not contain or reference any other objects.
PathMetadata   0 or more PathMatch objects.
Relationships between CDNI Metadata Objects (Table Representation)
The HostMetadata and PathMetadata objects contain other CDNI Metadata objects that contain properties that describe how User Agent requests for content should be processed   for example, where to acquire the content from, authorization rules that should be applied, geo blocking restrictions, and so on.
Each such CDNI Metadata object is a specialization of a CDNI GenericMetadata object.
The GenericMetadata object abstracts the basic information required for metadata override and metadata distribution, from the specifics of any given property (i.e., property semantics, enforcement options, etc.).
The GenericMetadata object defines the properties contained within it as well as whether or not the properties are "mandatory to enforce".
If the dCDN does not understand or support a mandatory to enforce property, the dCDN MUST NOT serve the content.
If the property is not mandatory to enforce, then that GenericMetadata object can be safely ignored and the content request can be processed in accordance with the rest of the CDNI Metadata.
Although a CDN MUST NOT serve content to a User Agent if a mandatory to enforce property cannot be enforced, it could still be safe to redistribute that metadata (the "safe to redistribute" property) to another CDN without modification.
For example, in the cascaded CDN case, a transit CDN (tCDN) could convey mandatory to enforce metadata to a dCDN.
For metadata that does not require customization or translation (i.e., metadata that is safe to redistribute), the data representation received off the wire MAY be stored and redistributed without being understood or supported by the tCDN.
However, for metadata that requires translation, transparent redistribution of the uCDN metadata values might not be appropriate.
Certain metadata can be safely, though perhaps not optimally, redistributed unmodified.
For example, a source acquisition address might not be optimal if transparently redistributed, but it might still work.
Redistribution safety MUST be specified for each GenericMetadata property.
If a CDN does not understand or support a given GenericMetadata property that is not safe to redistribute, the CDN MUST set the "incomprehensible" flag to true for that GenericMetadata object before redistributing the metadata.
The "incomprehensible" flag signals to a dCDN that the metadata was not properly transformed by the tCDN.
A CDN MUST NOT attempt to use metadata that has been marked as "incomprehensible" by a uCDN.
tCDNs MUST NOT change the value of mandatory to enforce or safe to redistribute when propagating metadata to a dCDN.
Although a tCDN can set the value of "incomprehensible" to true, a tCDN MUST NOT change the value of "incomprehensible" from true to false.
Action to Be Taken by a tCDN for the Different Combinations of MtE and StR Properties Table 3 describes the action to be taken by a dCDN for the different combinations of mandatory to enforce and
Action to Be Taken by a dCDN for the Different Combinations of MtE and Incomp Properties 3.3.
In the metadata object model, a HostMetadata object can contain multiple PathMetadata objects (via PathMatch objects).
Each PathMetadata object can in turn contain other PathMetadata objects.
HostMetadata and PathMetadata objects form an inheritance tree where each node in the tree inherits or overrides the property values set by its parent.
GenericMetadata objects of a given type override all GenericMetadata objects of the same type previously defined by any parent object in the tree.
GenericMetadata objects of a given type previously defined by a parent object in the tree are inherited when no object of the same type is defined by the child object.
For example, if HostMetadata for the host "example.com" contains GenericMetadata objects of types LocationACL and TimeWindowACL (where "ACL" means "Access Control List") while a PathMetadata object that applies to "example.com/movies/ " defines an alternate GenericMetadata object of type TimeWindowACL, then:
The TimeWindowACL defined in the PathMetadata would override the TimeWindowACL defined in the HostMetadata for all User Agent requests for content under "example.com/movies/", and  The LocationACL defined in the HostMetadata would be inherited for all User Agent requests for content under "example.com/movies/".
A single HostMetadata or PathMetadata object MUST NOT contain multiple GenericMetadata objects of the same type.
If an array of GenericMetadata contains objects of duplicate types, the receiver MUST ignore all but the first object of each type.
CDNI Metadata Objects Section 4.1 provides the definitions of each metadata object type introduced in Section 3.
These metadata objects are described as structural metadata objects, as they provide the structure for host and URI path based inheritance and identify which GenericMetadata objects apply to a given User Agent content request.
Section 4.2 provides the definitions for a base set of core metadata objects that can be contained within a GenericMetadata object.
These metadata objects govern how User Agent requests for content are handled.
GenericMetadata objects can contain other GenericMetadata objects as properties; these can be referred to as sub objects.
As with all CDNI Metadata objects, the value of the GenericMetadata sub objects can be either a complete serialized representation of the sub object or a Link object that contains a URI that can be dereferenced to retrieve the complete serialized representation of the property sub object.
Section 6.5 discusses the ability to extend the base set of GenericMetadata objects specified in this document with additional standards based or vendor specific GenericMetadata objects that might be defined in the future in separate documents.
dCDNs and tCDNs MUST support the parsing of all CDNI Metadata objects specified in this document.
A dCDN does not have to implement the underlying functionality represented by non structural GenericMetadata objects (though that might restrict the content that a given dCDN will be able to serve).
uCDNs as generators of CDNI Metadata only need to support generating the CDNI Metadata that they need in order to express the policies required by the content they are describing.
See Section 6.4 for more details on the specific encoding rules for CDNI Metadata objects.
Note: In the following sections, the term "mandatory to specify" is used to convey which properties MUST be included for a given structural or GenericMetadata object.
When mandatory to specify is specified as "Yes" for an individual property, it means that if the object containing that property is included in a metadata response, then the mandatory to specify property MUST also be included (directly or by reference) in the response.
For example, a HostMatch property object without a host to match against does not make sense; therefore, the "host" property is mandatory to specify inside a HostMatch object.
The subsections below describe the structural objects introduced in Section 3.1.
The HostIndex object is the entry point into the CDNI Metadata hierarchy.
It contains an array of HostMatch objects.
An incoming content request is checked against the hostname (or IP address) specified by each of the listed HostMatch objects to find the HostMatch object that applies to the request.
hosts Description: Array of HostMatch objects.
Hosts (HostMatch objects) MUST be evaluated in the order they appear, and the first HostMatch object that matches the content request being processed MUST be used.
Array of HostMatch objects Mandatory to Specify:
The HostMatch object contains a hostname or IP address to match against content requests.
The HostMatch object also contains a HostMetadata object to apply if a match is found.
Property: host Description: Hostname or IP address and optional port to match against the requested host, i.e., the host and port as described in [RFC3986].
In order for a hostname or IP address in a content request to match the hostname or IP address in the "host" property, the value from the content request when converted to lowercase MUST be identical to the value of the "host" property when converted to lowercase.
All implementations MUST support IPv4 addresses encoded as specified by the "IPv4address" rule in Section 3.2.2 of [RFC3986].
IPv6 addresses MUST be encoded in one of the IPv6 address formats specified in [RFC5952], although receivers MUST support all IPv6 address formats specified in [RFC4291].
Hostnames MUST conform to the Domain Name System (DNS) syntax defined in [RFC1034] and [RFC1123].
Internationalized Domain Names (IDNs) must first be transformed to the A label form [RFC5890] as per [RFC5891].
CDNI Metadata to apply when delivering content that matches this host.
Type: HostMetadata Mandatory to Specify:
} Example HostMatch object referencing (via a Link object; see Section 4.3.1)
HostMetadata A HostMetadata object contains the CDNI Metadata properties for content served for a particular host (defined in the HostMatch object) and possibly child PathMatch objects.
metadata Description: Array of host related metadata.
Array of GenericMetadata objects Mandatory to Specify:
Path patterns (PathMatch objects) MUST be evaluated in the order they appear, and the first (and only the first) PathMatch object that matches the content request being processed MUST be used.
Array of PathMatch objects Mandatory to Specify:
Default is that there are no more specific paths to evaluate (i.e., an empty list).
PathMatch A PathMatch object contains a PatternMatch object with a path to match against a resource's URI path, as well as how to handle URI query parameters.
The PathMatch object also contains a PathMetadata object with GenericMetadata to apply if the resource's URI matches the pattern within the PatternMatch object.
path pattern Description: Pattern to match against the requested resource's URI.
Type: PatternMatch Mandatory to Specify:
CDNI Metadata to apply when delivering content that matches the associated PatternMatch.
Type: PathMetadata Mandatory to Specify:
PatternMatch A PatternMatch object contains the pattern string and flags that describe the pattern expression.
A pattern for matching against the URI path, i.e., against the path absolute [RFC3986].
" matches exactly one pchar character.
All other characters are treated as literals.
Flag indicating whether or not case sensitive matching should be used.
Case insensitivity applies to ALPHA characters in the URI path prior to percent decoding [RFC3986].
Type: Boolean Mandatory to Specify:
Default is case insensitive match (i.e., a value of False).
A PathMetadata object contains the CDNI Metadata properties for content requests that match against the associated URI path (defined in a PathMatch object).
Note that if DNS based redirection is employed, then a dCDN will be unable to evaluate any metadata at the PathMetadata level or below because only the hostname of the content request is available at Request Routing time.
SHOULD still process all PathMetadata for the host before responding to the redirection request to detect if any unsupported metadata is specified.
If any metadata not supported by the dCDN is marked as mandatory to enforce, the dCDN SHOULD NOT accept the content redirection request, in order to avoid receiving content requests that it will not be able to satisfy/serve.
metadata Description: Array of path related metadata.
Array of GenericMetadata objects Mandatory to Specify:
Path patterns (PathMatch objects) MUST be evaluated in the order they appear, and the first (and only the first) PathMatch object that matches the content request being processed MUST be used.
Array of PathMatch objects Mandatory to Specify:
Default is that there are no more specific paths to evaluate (i.e., an empty list).
Example PathMetadata object containing a number of embedded GenericMetadata objects that describe the metadata to apply for the URI path defined in the parent PathMatch object, as well as a more specific PathMatch object.
GenericMetadata A GenericMetadata object is a wrapper for managing individual CDNI Metadata properties in an opaque manner.
Property: generic metadata type Description:
Case insensitive CDNI Metadata object type.
Type: String containing the CDNI Payload Type [RFC7736] of the object contained in the generic metadata value property (see Table 4).
Format/Type is defined by the value of the generic metadata type property above.
generic metadata values MUST NOT name any properties "href" (see Section 4.3.1).
: Flag identifying whether or not the enforcement of the property metadata is required.
Type: Boolean Mandatory to Specify:
Default is to treat metadata as mandatory to enforce (i.e., a value of True).
: Flag identifying whether or not the property metadata can be safely redistributed without modification.
Type: Boolean Mandatory to Specify:
Default is to allow transparent redistribution (i.e., a value of True).
incomprehensible Description: Flag identifying whether or not any CDN in the chain of delegation has failed to understand and/or failed to properly transform this metadata object.
Note: This flag only applies to metadata objects whose safe to redistribute property
has a value of False.
Type: Boolean Mandatory to Specify:
Default is comprehensible (i.e., a value of False).
Definitions of the Initial Set of CDNI GenericMetadata Objects
The objects defined below are intended to be used in the GenericMetadata object's generic metadata value field as defined in Section 4.1.7, and their generic metadata type property MUST be set to the appropriate CDNI Payload Type as defined in Table 4.
SourceMetadata Source metadata provides the dCDN with information about content acquisition, i.e., how to contact a uCDN Surrogate or an origin server to obtain the content to be served.
The sources are not necessarily the actual origin servers operated by the Content Service Provider (CSP) but might be a set of Surrogates in the uCDN.
Property: sources Description: Sources from which the dCDN can acquire content, listed in order of preference.
Type: Array of Source objects (see Section 4.2.1.1)
Default is to use static configuration, out of band from the CDNI Metadata interface.
Example SourceMetadata object (which contains two Source objects)
Source A Source object describes the source to be used by the dCDN for content acquisition (e.g., a Surrogate within the uCDN or an alternate origin server), the protocol to be used, and any authentication method to be used when contacting that source.
Endpoints within a Source object MUST be treated as equivalent/equal.
A uCDN can specify an array of sources, ordered by preference, within a SourceMetadata object.
Then, for each Source object ranked by preference, a uCDN
can specify an array of endpoints that are equivalent (e.g., a pool of servers that are not behind a load balancer).
Authentication method to use when requesting content from this source.
Type: Auth (see Section 4.2.7)
Default is no authentication required.
Property: endpoints Description: Origins from which the dCDN can acquire content.
If multiple endpoints are specified, they are all equal, i.e., the list is not ordered by preference.
Type: Array of Endpoint objects (see Section 4.3.3)
Network retrieval protocol to use when requesting content from this source.
Type: Protocol (see Section 4.3.2)
Example Source object that describes a pair of endpoints (servers)
Metadata LocationACL metadata defines which locations
a User Agent needs to be in, in order to be able to receive the associated content.
A LocationACL that does not include a "locations" property results in an action of "allow all", meaning that delivery can be performed regardless of the User Agent's location; otherwise, a CDN MUST take the action from the first footprint to match against the User Agent's location.
If two or more footprints overlap, the first footprint that matches against the User Agent's location determines the action a CDN MUST take.
If the "locations" property is included but is empty or if none of the listed footprints match the User Agent's location, then the result is an action of "deny".
Although the LocationACL, TimeWindowACL (see Section 4.2.3), and ProtocolACL (see Section 4.2.4) are independent GenericMetadata objects, they can provide conflicting information to a dCDN, e.g., a content request that is simultaneously allowed based on the LocationACL and denied based on the TimeWindowACL.
The dCDN MUST use the logical AND of all ACLs (where "allow" is true and "deny" is false) to determine whether or not a request should be allowed.
: locations Description: ACL that allows or denies (blocks) delivery based on the User Agent's location.
Type: Array of LocationRule objects (see Section 4.2.2.1)
Default is to allow all locations.
LocationRule A LocationRule contains or references an array of Footprint objects and the corresponding action.
Description: Array of footprints to which the rule applies.
Type: Array of Footprint objects (see Section 4.2.2.2)
Defines whether the rule specifies locations to allow or deny.
Type: Enumeration [allow deny] encoded as a lowercase string Mandatory to Specify: No.
Example LocationRule object (which contains a Footprint object)
Footprint A Footprint object describes the footprint to which a LocationRule can be applied, e.g., an IPv4 address range or a geographic location.
footprint type Description: Registered footprint type (see Section 7.2).
The footprint types specified by this document are "ipv4cidr" (IPv4CIDR; see Section 4.3.5), "ipv6cidr" (IPv6CIDR; see Section 4.3.6), "asn" (Autonomous System Number; see Section 4.3.7), and "countrycode" (Country Code; see Section 4.3.8).
Type: Lowercase string Mandatory to Specify:
footprint value Description: Array of footprint values conforming to the specification associated with the registered footprint type.
Footprint values can be simple strings (e.g., IPv4CIDR, IPv6CIDR, ASN, and Country Code); however, other Footprint objects can be defined in the future, along with a more complex encoding (e.g., GPS coordinate tuples).
Type: Array of footprints Mandatory to Specify:
Example Footprint object describing a footprint covering the IP address
metadata defines time based restrictions.
A TimeWindowACL that does not include a "times" property results in an action of "allow all", meaning that delivery can be performed regardless of the time of the User Agent's request; otherwise, a CDN MUST take the action from the first window to match against the current time.
If two or more windows overlap, the first window that matches against the current time determines the action a CDN MUST take.
If the "times" property is included but is empty or if none of the listed windows match the current time, then the result is an action of "deny".
Although the LocationACL (see Section 4.2.2), TimeWindowACL, and ProtocolACL (see Section 4.2.4) are independent GenericMetadata objects, they can provide conflicting information to a dCDN, e.g., a content request that is simultaneously allowed based on the LocationACL and denied based on the TimeWindowACL.
The dCDN MUST use the logical AND of all ACLs (where "allow" is true and "deny" is false) to determine whether or not a request should be allowed.
Description: ACL that allows or denies (blocks) delivery based on the time of a User Agent's request.
Type: Array of TimeWindowRule objects (see Section 4.2.3.1)
Default is to allow all time windows.
Example TimeWindowACL object (which contains a TimeWindowRule object that in turn contains a TimeWindow object)
that only allows the dCDN to deliver content to clients between 09:00 01/01/2000 UTC and
TimeWindowRule A TimeWindowRule contains or references an array of TimeWindow objects and the corresponding action.
windows Description: Array of time windows to which the rule applies.
Type: Array of TimeWindow objects (see Section 4.2.3.2)
Defines whether the rule specifies time windows to allow or deny.
Type: Enumeration [allow deny] encoded as a lowercase string Mandatory to Specify: No.
Example TimeWindowRule object (which contains a TimeWindow object) that only allows the dCDN to deliver content to clients between 09:00 01/01/2000 UTC and
TimeWindow A TimeWindow object describes a time range that can be applied by a TimeWindowACL, e.g., start 946717200 (
, end: 946746000 (i.e., 17:00 01/01/2000 UTC).
The start time of the window.
Type: Time (see Section 4.3.4)
The end time of the window.
Type: Time (see Section 4.3.4)
Metadata ProtocolACL metadata defines delivery protocol restrictions.
A ProtocolACL that does not include a protocol acl property results in an action of "allow all", meaning that delivery can be performed regardless of the protocol in the User Agent's request; otherwise, a CDN MUST take the action from the first protocol to match against the request protocol.
If two or more request protocols overlap, the first protocol that matches the request protocol determines the action a CDN MUST take.
If the protocol acl property is included but is empty or if none of the listed protocols match the request protocol, then the result is an action of "deny".
Although the LocationACL (see Section 4.2.2), TimeWindowACL (see Section 4.2.3), and ProtocolACL are independent GenericMetadata objects, they can provide conflicting information to a dCDN, e.g., a content request that is simultaneously allowed based on the ProtocolACL and denied based on the TimeWindowACL.
The dCDN MUST use the logical AND of all ACLs (where "allow" is true and "deny" is false) to determine whether or not a request should be allowed.
protocol acl Description: ACL that allows or denies (blocks) delivery based on delivery protocol.
Type: Array of ProtocolRule objects (see Section 4.2.4.1)
Default is to allow all protocols.
ProtocolRule A ProtocolRule contains or references an array of Protocol objects and the corresponding action.
protocols Description: Array of protocols to which the rule applies.
Type: Array of Protocol objects (see Section 4.3.2)
Defines whether the rule specifies protocols to allow or deny.
Type: Enumeration [allow deny] encoded as a lowercase string Mandatory to Specify: No.
DeliveryAuthorization Metadata Delivery authorization defines authorization methods for the delivery of content to User Agents.
Options for authorizing content requests.
Delivery for a content request is authorized if any one of the authorization methods in the list is satisfied for that request.
Type: Array of Auth objects (see Section 4.2.7)
Default is no authorization required.
Cache A Cache object describes the cache control parameters to be applied to the content by intermediate caches.
Cache keys are generated from the URI of the content request [RFC7234].
In some cases, a CDN or content provider might want certain path segments or query parameters to be excluded from the cache key generation.
The Cache object provides guidance on what parts of the path and query string to include.
Property: exclude path pattern Description: A pattern for matching against the URI path, i.e., against the path absolute [RFC3986].
" matches exactly one pchar character.
All other characters are treated as literals.
Cache key generation MUST only include the portion of the path absolute that matches the wildcard portions of the pattern.
Inconsistency between the PatternMatch pattern (Section 4.1.5) and the exclude path pattern can result in inefficient caching.
Type: String Mandatory to Specify:
Default is to use the full URI path absolute to generate the cache key.
Property: include query strings Description: Allows a Surrogate to specify the URI query string parameters [RFC3986] to include when comparing the requested URI against the URIs in its cache for equivalence.
Matching query parameters MUST be case insensitive.
If all query parameters should be ignored, then the list MUST be specified and MUST be empty.
If a query parameter appears multiple times in the query string, each instance value MUST be aggregated prior to comparison.
For consistent cache key generation, query parameters SHOULD be evaluated in the order specified in this array.
Type: Array of strings Mandatory to Specify: No.
Default is to consider all query string parameters when comparing URIs.
An Auth object defines authentication and authorization methods to be used during content acquisition and content delivery, respectively.
Note: This document does not define any Auth methods.
Individual Auth methods are being defined separately (e.g., URI Signing [CDNI URI SIGNING]).
The GenericMetadata object that contains Auth objects is defined herein for convenience and so as not to be specific to any particular Auth method.
Auth type (The CDNI Payload Type [RFC7736] of the GenericMetadata object contained in the auth value property).
Type: String Mandatory to Specify:
An object conforming to the specification associated with the Auth type.
GenericMetadata object Mandatory to Specify:
Grouping A Grouping object identifies a group of content to which a given asset belongs.
Content Collection IDentifier for an application  specific purpose such as logging aggregation.
Type: String Mandatory to Specify:
Default is not to apply any grouping.
Metadata Simple Data Type Descriptions
This section describes the simple data types that are used for properties of CDNI Metadata objects.
Link A Link object can be used in place of any of the objects described above.
Link objects can be used to avoid duplication if the same metadata information is repeated within the metadata tree.
When a Link object replaces another object, its "href" property is set to the URI of the resource and its "type" property is set to the CDNI Payload Type of the object it is replacing.
dCDNs can detect the presence of a Link object by detecting the presence of a property named "href" within the object.
This means that GenericMetadata types MUST NOT contain a property named "href" because doing so would conflict with the ability for dCDNs to detect Link objects being used to reference a GenericMetadata object.
The URI of the addressable object being referenced.
The CDNI Payload Type of the object being referenced.
If the container specifies the type (e.g., the HostIndex object contains an array of HostMatch objects, so a Link object in the list of HostMatch objects must reference a HostMatch), then it is not necessary to explicitly specify a type.
When following a link, CDNI Metadata clients SHOULD verify that the CDNI Payload Type of the object retrieved matches the expected CDNI Payload Type, as indicated by the Link object or containing property.
For GenericMetadata objects, type checks will prevent self  references; however, incorrect linking can result in circular references for structural metadata objects, specifically PathMatch and PathMetadata objects (Figure 1).
To prevent circular references, CDNI Metadata clients SHOULD verify that no duplicate links occur for PathMatch or PathMetadata objects.
Protocol Protocol objects are used to specify protocols (from the "CDNI Metadata Protocol Types" registry; see Section 7.3) for content acquisition or delivery.
A hostname (with optional port) or an IP address (with optional port).
All implementations MUST support IPv4 addresses encoded as specified by the "IPv4address" rule in Section 3.2.2 of [RFC3986].
IPv6 addresses MUST be encoded in one of the IPv6 address formats specified in [RFC5952], although receivers MUST support all IPv6 address formats specified in [RFC4291].
Hostnames MUST conform to the Domain Name System (DNS) syntax defined in [RFC1034] and [RFC1123].
Internationalized Domain Names (IDNs) must first be transformed to the A label form [RFC5890] as per [RFC5891].
metadata.ucdn.example" Example IPv4 address: "
Time A time value expressed in seconds since the UNIX epoch (i.e., zero hours, zero minutes, zero seconds, on January 1, 1970)
Coordinated Universal Time (UTC) [POSIX].
Integer Example time representing 09:00:00 01/01/2000
Single IP addresses can be expressed as /32.
String Example IPv4CIDR: "192.0.2.0/24" 4.3.6.
Single IP addresses can be expressed as /128.
String Example IPv6CIDR: "2001:db8::/32" 4.3.7.
An ASN value encoded as a string consisting of the characters "as" (in lowercase) followed by the ASN [RFC6793].
String Example ASN: "as64496" 4.3.8.
An ISO 3166 1 alpha 2 code [ISO3166 1] in lowercase.
String Example Country Code representing the USA: "us" 5.
CDNI Metadata is used to convey information pertaining to content delivery from the uCDN to the dCDN.
For optional metadata, it can be useful for the uCDN to know, prior to delegating any content requests to a given dCDN, if that dCDN supports the underlying functionality described by the metadata.
If some metadata is mandatory to enforce and the dCDN does not support it, any delegated requests for content that requires that metadata will fail.
The uCDN will likely want to avoid delegating those requests to that dCDN.
Likewise, for any metadata that might be assigned optional values, it could be useful for the uCDN to know, prior to delegating any content requests to a given dCDN, which values that dCDN supports.
If the optional value assigned to a given piece of content's metadata is not supported by the dCDN, any delegated requests for that content can fail, so again the uCDN is likely to want to avoid delegating those requests to that dCDN.
The CDNI Footprint & Capabilities Advertisement interface (FCI) provides a means of advertising capabilities from the dCDN to the uCDN [RFC8008].
Support for optional metadata types and values can be advertised using the FCI.
This section specifies an interface to enable a dCDN to retrieve CDNI Metadata objects from a uCDN.
The interface can be used by a dCDN to retrieve CDNI Metadata objects in either of two ways:
Dynamically, as required by the dCDN to process received requests   for example, in response to a query from a uCDN over the CDNI Request Routing Redirection interface (RI) [RFC7975] or in response to receiving a request for content from a User Agent.
In advance of being required   for example, in the case of pre positioned CDNI Metadata acquisition, initiated through the "CDNI Control interface / Triggers" (CI/T) interface [RFC8007].
The CDNI Metadata interface is built on the principles of HTTP web services.
In particular, this means that requests and responses over the interface are built around the transfer of representations of hyperlinked resources.
A resource in the context of the CDNI
Metadata interface is any object in the object model (as described in Sections 3 and 4).
CDNI Metadata servers (i.e., servers in the uCDN) are free to assign whatever structure they desire to the URIs for CDNI Metadata objects, and CDNI Metadata clients MUST NOT make any assumptions regarding the structure of CDNI Metadata URIs or the mapping between CDNI Metadata objects and their associated URIs.
Any URIs present in the examples in this document are purely illustrative and are not intended to impose a definitive structure on CDNI Metadata interface implementations.
Metadata interface uses HTTP as the underlying protocol transport [RFC7230].
The HTTP method in the request defines the operation the request would like to perform.
A server implementation of the CDNI
Metadata interface MUST support the HTTP GET and HEAD methods.
The corresponding HTTP response returns the status of the operation in the HTTP status code and returns the current representation of the resource (if appropriate) in the response body.
HTTP responses that contain a response body SHOULD include an entity tag (ETag) to enable validation of cached versions of returned resources.
As the CDNI Metadata interface builds on top of HTTP, CDNI Metadata server implementations MAY make use of any HTTP feature when implementing the CDNI Metadata interface; for example, a CDNI Metadata server MAY make use of HTTP's caching mechanisms to indicate that the returned response/representation can be reused without re contacting the CDNI Metadata server.
Retrieval of CDNI Metadata Resources
In the general case, a CDNI Metadata server makes CDNI Metadata objects available via unique URIs; thus, in order to retrieve CDNI Metadata, a CDNI Metadata client (i.e., a client in the dCDN) first makes an HTTP GET request for the URI of the HostIndex, which provides an array of hostnames for which the uCDN can delegate content delivery to the dCDN.
In order to retrieve the CDNI Metadata for a particular request, the CDNI Metadata client processes the received HostIndex object and finds the corresponding HostMetadata entry (by matching the hostname in the request against the hostnames listed in the HostMatch objects).
If the HostMetadata is linked (rather than embedded), the CDNI Metadata client then makes an HTTP GET request for the URI specified in the "href" property of the Link object, which points to the HostMetadata object itself.
In order to retrieve the most specific metadata for a particular request, the CDNI Metadata client inspects the HostMetadata for references to more specific PathMetadata objects (by matching the URI path in the request against the path pattern property items in any PathMatch objects listed in the HostMetadata object).
If a PathMetadata object is found to match (and is linked rather than embedded), the CDNI Metadata client makes another HTTP GET request for the PathMetadata.
Each PathMetadata object can also include references to additional more specific metadata.
If this is the case, the CDNI Metadata client continues requesting PathMatch and PathMetadata objects recursively.
The CDNI Metadata client repeats this approach of processing metadata objects and retrieving (via HTTP GETs)
any linked objects until it has all the metadata objects it requires in order to process the redirection request from the uCDN or the content request from a User Agent.
In cases where a dCDN is not able to retrieve the entire set of CDNI Metadata associated with a User Agent request, or it has retrieved that metadata
but it is stale according to standard HTTP caching rules and cannot be revalidated   for example, because the uCDN is unreachable or returns an HTTP 4xx or 5xx status in response to some or all of the dCDN's CDNI
the dCDN MUST NOT serve the requested content.
Where a dCDN is interconnected with multiple uCDNs, the dCDN needs to determine which uCDN's CDNI Metadata interface should be used to handle a particular User Agent request.
When HTTP redirection (e.g., HTTP 302 redirects) is being used between CDNs, it is expected that the dCDN will be able to determine the uCDN that redirected a particular request from information contained in the received request (e.g., via the URI).
With knowledge of which uCDN routed the request, the dCDN can choose the correct uCDN from which to obtain the HostIndex.
Note that the HostIndexes served by each uCDN can be unique.
In the case of DNS redirection, there is not always sufficient information carried in the DNS request from User Agents to determine the uCDN that redirected a particular request (e.g., when content from a given host is redirected to a given dCDN by more than one uCDN); therefore, dCDNs will have to apply local policy when deciding which uCDN
's CDNI Metadata interface to use.
Bootstrapping The URI for the HostIndex object of a given uCDN needs to be configured in the dCDN.
All other objects/resources are then discoverable from the HostIndex object by following any links in the HostIndex object, and through the referenced HostMetadata and PathMetadata objects and their GenericMetadata sub objects.
Manual configuration of the URI for the HostIndex object is outside the scope of this document.
Metadata objects MUST be encoded as I JSON objects
[RFC7493] containing a dictionary of (key,value) pairs where the keys are the property names and the values are the associated property values.
The keys of the dictionary are the names of the properties associated with the object and are therefore dependent on the specific object being encoded (i.e., dependent on the CDNI Payload Type of the returned resource).
Likewise, the values associated with each property (dictionary key) are dependent on the specific object being encoded (i.e., dependent on the CDNI Payload Type of the returned resource).
Dictionary keys (properties) in I JSON are case sensitive.
By convention, any dictionary key (property) defined by this document (for example, the names of CDNI Metadata object properties) MUST be lowercase.
The set of GenericMetadata objects can be extended with additional (standards based or vendor specific)
metadata objects through the specification of new GenericMetadata objects.
The GenericMetadata object defined in Section 4.1.7 specifies a type field and a type  specific value field that allow any metadata to be included in either the HostMetadata or PathMetadata arrays.
As with the initial GenericMetadata types defined in Section 4.2, future GenericMetadata types MUST specify the information necessary for constructing and decoding the GenericMetadata object.
Any document that defines a new GenericMetadata type MUST:
Register the CDNI Payload Type [RFC7736] used to identify the new GenericMetadata type being specified.
the set of properties associated with the new GenericMetadata object.
GenericMetadata MUST NOT contain a property named "href" because doing so would conflict with the ability to detect Link objects (see Section 4.3.1).
For each property, define a name, description, type, and whether or not the property is mandatory to specify.
Describe the semantics of the new type, including its purpose, and provide a use case to which it applies, including an example encoded in I JSON.
Describe the security and privacy consequences, for both the User Agent and the CDNs, of the new GenericMetadata object.
Describe any relation to, conflict with, or obsolescence of other existing CDNI Metadata objects.
Note: In the case of vendor specific extensions, vendor identifying CDNI Payload Type names will decrease the possibility of GenericMetadata type collisions.
It is RECOMMENDED that any vendor specific extensions use vendor identifying CDNI Payload Type names.
At any given time, the set of GenericMetadata types supported by the uCDN might not match the set of GenericMetadata types supported by the dCDN.
In cases where a uCDN sends metadata containing a GenericMetadata type that a dCDN does not support, the dCDN MUST enforce the semantics of the mandatory to enforce property.
If a dCDN does not understand or is unable to perform the functions associated with any mandatory to enforce metadata, the dCDN MUST NOT service any requests for the corresponding content.
Note: Ideally, uCDNs would not delegate content requests to a dCDN that does not support the mandatory to enforce metadata associated with the content being requested.
However, even if the uCDN has a priori knowledge of the metadata supported by the dCDN
(e.g., via the FCI or through out of band negotiation between CDN operators), metadata support can fluctuate or be inconsistent (e.g., due to miscommunication, misconfiguration, or temporary outage).
Thus, the dCDN MUST always evaluate all metadata associated with redirection and content requests and reject any requests where mandatory to enforce metadata associated with the content cannot be enforced.
It is possible that new metadata definitions will obsolete or conflict with existing GenericMetadata (e.g., a future revision of the CDNI
Metadata interface could redefine the Auth GenericMetadata object or a custom vendor extension could implement an alternate Auth metadata option).
If multiple metadata (e.g., MI.Auth.v2, vendor1.Auth, and vendor2.Auth) all conflict with an existing GenericMetadata object (i.e., MI.Auth) and all are marked as mandatory to enforce, it could be ambiguous as to which metadata should be applied, especially in the case of overlapping functionality.
As described in Section 3.3, metadata override only applies to metadata objects of the same exact type found in HostMetadata and nested PathMetadata structures.
Metadata interface does not support enforcement of dependencies between different GenericMetadata types.
It is the responsibility of the CSP and the CDN operators to ensure that metadata assigned to a given piece of content do not conflict.
Note: Because metadata is inherently ordered in HostMetadata and PathMetadata arrays, as well as in the PathMatch hierarchy, multiple conflicting metadata types MAY be used; however, metadata hierarchies SHOULD ensure that independent PathMatch root objects are used to prevent ambiguous or conflicting metadata definitions.
The version of CDNI Metadata objects is conveyed inside the CDNI Payload Type that is included in either (1)
the HTTP Content Type header (for example, "Content Type: application/cdni; ptype MI.HostIndex" when retrieved via a link) or (2) in the link type (Section 4.3.1), generic metadata type (Section 4.1.7), or auth type (Section 4.2.7) properties in the JSON payload.
The CDNI Payload Type uniquely identifies the specification defining that object, including any relation to, conflicts with, or obsolescence of other metadata.
There is no explicit version mapping requirement; however, for ease of understanding, metadata creators SHOULD make new versions of metadata easily visible via the CDNI Payload Type, e.g., by appending a version string.
: A version string is optional on the first version (e.g., MI.HostIndex) but could be added for subsequent versions (MI.HostIndex.v2, MI.HostIndex.v3, etc.).
Except when referenced by a Link object, nested metadata objects (i.e., structural metadata below the HostIndex; and Source, LocationRule, TimeWindowRule, ProtocolRule, Footprint, and TimeWindow objects) can be serialized into a JSON payload without explicit CDNI Payload Type information.
The type is inferred from the outer structural metadata, GenericMetadata, or Auth object CDNI Payload Type.
To avoid ambiguity when revising nestable metadata objects, any outer metadata object(s) MUST be reversioned and allocated new CDNI Payload Type(s) at the same time.
For example, the MI.HostIndex object defined in this document contains an array of MI.HostMatch objects, each of which in turn contains a MI.HostMetadata object.
If a new MI.HostMetadata.v2 object were required, the outer MI.HostIndex and MI.HostMatch objects would need to be revised, e.g., to MI.HostIndex.v2 and MI.HostMatch.v2, respectively.
Similarly, if a new MI.TimeWindowRule.v2 object were required, the outer MI.TimeWindowACL object would need to be revised, e.g., to MI.TimeWindowACL.v2; however, the MI.TimeWindowRule.v2 object could still contain MI.TimeWindow objects, if so specified.
HTTP requests sent to a metadata server SHOULD include an Accept header with the CDNI Payload Type of the expected object.
Metadata clients can specify multiple CDNI Payload Types in the Accept header; for example, if a metadata client is capable of processing two different versions of the same type of object (defined by different CDNI Payload Types), it might decide to include both in the Accept header.
Metadata objects use the media type "application/cdni".
The CDNI Payload Type for each object then contains the object name of that object as defined by this document, prefixed with "MI.".
Table 4 lists the CDNI
Payload Types for the metadata objects (resources) specified in this document.
CDNI Payload Types for CDNI Metadata Objects 6.10.
If the incoming request has a Host header with "video.example.com
The final set of metadata that applies to the requested resource includes a SourceMetadata, a LocationACL, a ProtocolACL, and a TimeWindowACL.
MI HostIndex Payload Type Purpose:
The purpose of this Payload Type is to distinguish HostIndex MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.1.1 7.1.2.
MI HostMatch Payload Type Purpose:
The purpose of this Payload Type is to distinguish HostMatch MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.1.2 7.1.3.
MI HostMetadata Payload Type Purpose:
The purpose of this Payload Type is to distinguish HostMetadata MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.1.3 7.1.4.
MI PathMatch Payload Type Purpose:
The purpose of this Payload Type is to distinguish PathMatch MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.1.4 7.1.5.
MI PatternMatch Payload Type Purpose:
The purpose of this Payload Type is to distinguish PatternMatch MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.1.5 7.1.6.
MI PathMetadata Payload Type Purpose:
The purpose of this Payload Type is to distinguish PathMetadata MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.1.6 7.1.7.
MI SourceMetadata Payload Type Purpose:
The purpose of this Payload Type is to distinguish SourceMetadata MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.1 7.1.8.
MI Source Payload Type Purpose:
The purpose of this Payload Type is to distinguish Source MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.1.1 7.1.9.
The purpose of this Payload Type is to distinguish LocationACL
MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.2 7.1.10.
MI LocationRule Payload Type Purpose:
The purpose of this Payload Type is to distinguish LocationRule MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.2.1 7.1.11.
MI Footprint Payload Type Purpose:
The purpose of this Payload Type is to distinguish Footprint MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.2.2 7.1.12.
MI TimeWindowACL Payload Type Purpose
: The purpose of this Payload Type is to distinguish TimeWindowACL MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.3 7.1.13.
MI TimeWindowRule Payload Type Purpose:
The purpose of this Payload Type is to distinguish TimeWindowRule MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.3.1 7.1.14.
MI TimeWindow Payload Type Purpose:
The purpose of this Payload Type is to distinguish TimeWindow MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.3.2 7.1.15.
MI ProtocolACL Payload Type Purpose
: The purpose of this Payload Type is to distinguish ProtocolACL
MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.4 7.1.16.
MI ProtocolRule Payload Type Purpose:
The purpose of this Payload Type is to distinguish ProtocolRule MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.4.1 7.1.17.
MI DeliveryAuthorization Payload Type Purpose:
The purpose of this Payload Type is to distinguish DeliveryAuthorization MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.5 7.1.18.
MI Cache Payload Type Purpose:
The purpose of this Payload Type is to distinguish Cache MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.6 7.1.19.
MI Auth Payload Type Purpose:
The purpose of this Payload Type is to distinguish Auth MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.7 7.1.20.
MI Grouping Payload Type Purpose
: The purpose of this Payload Type is to distinguish Grouping MI objects (and any associated capability advertisement)
Interface: MI/FCI Encoding: see Section 4.2.8 7.2.
"CDNI Metadata Footprint Types" Registry IANA has created a new "CDNI Metadata Footprint Types" subregistry in the "Content Delivery Network Interconnection (CDNI) Parameters" registry.
The "CDNI Metadata Footprint Types" namespace defines the valid Footprint object type values used by the Footprint object described in Section 4.2.2.2.
Additions to the "CDNI Metadata Footprint Types" namespace conform to the Specification Required policy as defined in [RFC5226].
The Designated Expert will verify that new type definitions do not duplicate existing type definitions and prevent gratuitous additions to the namespace.
New registrations are required to provide a clear description of how to interpret new footprint types.
The following table defines the initial values for the "CDNI Metadata Footprint Types" registry:
Registry IANA has created a new "CDNI Metadata Protocol Types" subregistry in the "Content Delivery Network Interconnection (CDNI) Parameters" registry.
The "CDNI Metadata Protocol Types" namespace defines the valid Protocol object values (Section 4.3.2) used by the SourceMetadata and ProtocolACL objects.
Additions to the Protocol namespace conform to the Specification Required policy as defined in [RFC5226], where the specification defines the Protocol Type and the protocol to which it is associated.
The Designated Expert will verify that new protocol definitions do not duplicate existing protocol definitions and prevent gratuitous additions to the namespace.
The following table defines the initial Protocol values corresponding to the HTTP and HTTPS protocols:
Authentication and Integrity A malicious metadata server, proxy server, or attacker impersonating an authentic uCDN CDNI Metadata interface without being detected could provide false metadata to a dCDN
that either:  Denies service for one or more pieces of content to one or more User Agents;  Directs dCDNs to contact malicious origin servers instead of the actual origin servers, so that malware or slanderous alternate content may be substituted for legitimate content; or  Removes delivery restrictions (e.g., LocationACL, TimeWindowACL, ProtocolACL, or Auth metadata), allowing access to content that would otherwise be denied and thus possibly violating license restrictions and incurring unwarranted delivery costs.
Unauthorized access to metadata could also enable a malicious metadata client to continuously issue metadata requests in order to overload a uCDN's metadata server or servers.
Unauthorized access to metadata could further result in leakage of private information.
A malicious metadata client could request metadata in order to gain access to origin servers, as well as information pertaining to content restrictions.
An implementation of the CDNI
Metadata interface MUST use mutual authentication and message authentication codes to prevent unauthorized access to, and undetected modification of, metadata (see Section 8.3).
8.2.  Confidentiality and Privacy Unauthorized viewing of metadata could result in leakage of private information.
Content provider origin and policy information is conveyed through the CDNI Metadata interface.
A third party could intercept metadata transactions in order to gain access to origin servers, as well as information pertaining to content restrictions and usage patterns.
Note: The distribution of metadata by a uCDN to dCDNs could introduce privacy concerns for some content providers, e.g., dCDNs accepting content requests for a content provider's content might be able to obtain additional information and usage patterns relating to the users of a content provider's services.
Content providers with concerns about divulging information to dCDNs can instruct their uCDN partners not to use CDNI when delivering their content.
An implementation of the CDNI
Metadata interface MUST use strong encryption to prevent unauthorized interception or monitoring of metadata (see Section 8.3).
Securing the CDNI Metadata Interface
An implementation of the CDNI
Metadata interface MUST support TLS transport as per [RFC2818] and [RFC7230].
TLS MUST be used by the server side (uCDN) and the client side (dCDN) of the CDNI Metadata interface, including authentication of the remote end, unless alternate methods are used for ensuring the security of the information in the CDNI Metadata interface requests and responses (such as setting up an IPsec tunnel between the two CDNs or using a physically secured internal network between two CDNs that are owned by the same corporate entity).
The use of TLS for transport of the CDNI
Metadata interface messages allows the dCDN and uCDN to authenticate each other.
Once the dCDN and uCDN have mutually authenticated each other, TLS allows:  The dCDN and uCDN to authorize each other (to ensure that they are transmitting/receiving CDNI
Metadata requests and responses from an authorized CDN);  CDNI Metadata interface requests and responses to be transmitted with confidentiality; and
The integrity of the CDNI Metadata interface requests and responses to be protected during the exchange.
When TLS is used, the general TLS usage guidance in [RFC7525] MUST be followed.
The authors would also like to thank Grant Watson and Kent Leung for their contributions to this document.
