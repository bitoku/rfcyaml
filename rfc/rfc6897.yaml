- title: __initial_text__
  contents:
  - '       Multipath TCP (MPTCP) Application Interface Considerations

    '
- title: Abstract
  contents:
  - "Abstract\n   Multipath TCP (MPTCP) adds the capability of using multiple paths\
    \ to\n   a regular TCP session.  Even though it is designed to be totally\n  \
    \ backward compatible to applications, the data transport differs\n   compared\
    \ to regular TCP, and there are several additional degrees of\n   freedom that\
    \ applications may wish to exploit.  This document\n   summarizes the impact that\
    \ MPTCP may have on applications, such as\n   changes in performance.  Furthermore,\
    \ it discusses compatibility\n   issues of MPTCP in combination with non-MPTCP-aware\
    \ applications.\n   Finally, the document describes a basic application interface\
    \ that is\n   a simple extension of TCP's interface for MPTCP-aware applications.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6897.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................4\n  \
    \ 3. Comparison of MPTCP and Regular TCP .............................5\n    \
    \  3.1. Effect on Performance ......................................5\n      \
    \     3.1.1. Throughput ..........................................5\n        \
    \   3.1.2. Delay ...............................................6\n          \
    \ 3.1.3. Resilience ..........................................7\n      3.2. Potential\
    \ Problems .........................................8\n           3.2.1. Impact\
    \ of Middleboxes ...............................8\n           3.2.2. Dealing with\
    \ Multiple Addresses inside\n                  Applications ........................................9\n\
    \           3.2.3. Security Implications ..............................10\n  \
    \ 4. Operation of MPTCP with Legacy Applications ....................10\n    \
    \  4.1. Overview of the MPTCP Network Stack .......................10\n      4.2.\
    \ Address Issues ............................................11\n           4.2.1.\
    \ Specification of Addresses by Applications .........11\n           4.2.2. Querying\
    \ of Addresses by Applications ..............12\n      4.3. MPTCP Connection Management\
    \ ...............................13\n           4.3.1. Reaction to Close Call\
    \ by Application ..............13\n           4.3.2. Other Connection Management\
    \ Functions ..............13\n      4.4. Socket Option Issues ......................................13\n\
    \           4.4.1. General Guideline ..................................13\n  \
    \         4.4.2. Disabling of the Nagle Algorithm ...................13\n    \
    \       4.4.3. Buffer Sizing ......................................14\n      \
    \     4.4.4. Other Socket Options ...............................14\n      4.5.\
    \ Default Enabling of MPTCP .................................14\n      4.6. Summary\
    \ of Advice to Application Developers ...............15\n   5. Basic API for MPTCP-Aware\
    \ Applications .........................15\n      5.1. Design Considerations .....................................15\n\
    \      5.2. Requirements on the Basic MPTCP API .......................16\n  \
    \    5.3. Sockets Interface Extensions by the Basic MPTCP API .......17\n    \
    \       5.3.1. Overview ...........................................17\n      \
    \     5.3.2. Enabling and Disabling of MPTCP ....................19\n        \
    \   5.3.3. Binding MPTCP to Specified Addresses ...............19\n          \
    \ 5.3.4. Querying the MPTCP Subflow Addresses ...............20\n           5.3.5.\
    \ Getting a Unique Connection Identifier .............20\n   6. Other Compatibility\
    \ Issues .....................................21\n      6.1. Usage of TLS over\
    \ MPTCP ...................................21\n      6.2. Usage of the SCTP Sockets\
    \ API .............................21\n      6.3. Incompatibilities with Other\
    \ Multihoming Solutions ........21\n      6.4. Interactions with DNS .....................................22\n\
    \   7. Security Considerations ........................................22\n  \
    \ 8. Conclusion .....................................................23\n   9.\
    \ Acknowledgments ................................................23\n   10. References\
    \ ....................................................24\n      10.1. Normative\
    \ References .....................................24\n      10.2. Informative\
    \ References ...................................24\n   Appendix A. Requirements\
    \ on a Future Advanced MPTCP API ...........26\n     A.1. Design Considerations\
    \ ......................................26\n     A.2. MPTCP Usage Scenarios and\
    \ Application Requirements .........27\n     A.3. Potential Requirements on an\
    \ Advanced MPTCP API ............29\n     A.4. Integration with the SCTP Sockets\
    \ API ......................30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Multipath TCP adds the capability of using multiple paths\
    \ to a\n   regular TCP session [1].  The motivations for this extension include\n\
    \   increasing throughput, overall resource utilization, and resilience\n   to\
    \ network failure, and these motivations are discussed, along with\n   high-level\
    \ design decisions, as part of the multipath TCP\n   architecture [4].  MPTCP\
    \ [5] offers the same reliable, in-order,\n   byte-stream transport as TCP and\
    \ is designed to be backward\n   compatible with both applications and the network\
    \ layer.  It requires\n   support inside the network stack of both endpoints.\n\
    \   This document first presents the effects that MPTCP may have on\n   applications,\
    \ such as performance changes compared to regular TCP.\n   Second, it defines\
    \ the interoperation of MPTCP and applications that\n   are unaware of the multipath\
    \ transport.  MPTCP is designed to be\n   usable without any application changes,\
    \ but some compatibility issues\n   have to be taken into account.  Third, this\
    \ memo specifies a basic\n   Application Programming Interface (API) for MPTCP-aware\
    \ applications.\n   The API presented here is an extension to the regular TCP\
    \ API to\n   allow an MPTCP-aware application the equivalent level of control\
    \ and\n   access to information of an MPTCP connection that would be possible\n\
    \   with the standard TCP API on a regular TCP connection.\n   The de facto standard\
    \ API for TCP/IP applications is the \"sockets\"\n   interface [8].  This document\
    \ provides an abstract definition of\n   MPTCP-specific extensions to this interface.\
    \  These are operations\n   that can be used by an application to get or set additional\
    \ MPTCP-\n   specific information on a socket, in order to provide an equivalent\n\
    \   level of information and control over MPTCP as exists for an\n   application\
    \ using regular TCP.  It is up to the applications, high-\n   level programming\
    \ languages, or libraries to decide whether to use\n   these optional extensions.\
    \  For instance, an application may want to\n   turn on or off the MPTCP mechanism\
    \ for certain data transfers or\n   limit its use to certain interfaces.  The\
    \ abstract specification is\n   in line with the Portable Operating System Interface\
    \ (POSIX) standard\n   [8] as much as possible.\n   An advanced API for MPTCP\
    \ is outside the scope of this document.\n   Such an advanced API could offer\
    \ a more fine-grained control over\n   multipath transport functions and policies.\
    \  The appendix includes\n   a brief, non-compulsory list of potential features\
    \ of such an\n   advanced API.\n   There can be interactions or incompatibilities\
    \ of MPTCP with other\n   APIs or sockets interface extensions, which are discussed\
    \ later in\n   this document.  Some network stack implementations, especially\
    \ on\n   mobile devices, have centralized connection managers or other\n   higher-level\
    \ APIs to solve multi-interface issues, as surveyed in\n   [15].  Their interaction\
    \ with MPTCP is outside the scope of this\n   document.\n   The target readers\
    \ of this document are application developers whose\n   software may benefit significantly\
    \ from MPTCP.  This document also\n   provides the necessary information for developers\
    \ of MPTCP to\n   implement the API in a TCP/IP network stack.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [3].\n\
    \   This document uses the MPTCP terminology introduced in [5].\n   Concerning\
    \ the API towards applications, the following terms are\n   distinguished:\n \
    \  o  Legacy API: The interface towards TCP that is currently used by\n      applications.\
    \  This document explains the effect of MPTCP for such\n      applications, as\
    \ well as resulting issues.\n   o  Basic API: A simple extension of TCP's interface\
    \ for applications\n      that are aware of MPTCP.  This document abstractly describes\
    \ this\n      interface, which provides access to multipath address information\n\
    \      and a level of control equivalent to regular TCP.\n   o  Advanced API:\
    \ An API that offers more fine-grained control over\n      the behavior of MPTCP.\
    \  Its specification is outside the scope of\n      this document.\n"
- title: 3.  Comparison of MPTCP and Regular TCP
  contents:
  - "3.  Comparison of MPTCP and Regular TCP\n   This section discusses the effect\
    \ of MPTCP on performance as seen by\n   an application, in comparison to what\
    \ may be expected from the use of\n   regular TCP.\n"
- title: 3.1.  Effect on Performance
  contents:
  - "3.1.  Effect on Performance\n   One of the key goals of adding multipath capability\
    \ to TCP is to\n   improve the performance of a transport connection by load\n\
    \   distribution over separate subflows across potentially disjoint\n   paths.\
    \  Furthermore, it is an explicit goal of MPTCP that it provides\n   a connection\
    \ that performs at least as well as one using single-path\n   TCP.  A corresponding\
    \ congestion control algorithm is described in\n   [7].  The following sections\
    \ summarize the performance effect of\n   MPTCP as seen by an application.\n"
- title: 3.1.1.  Throughput
  contents:
  - "3.1.1.  Throughput\n   The most obvious performance improvement that can be expected\
    \ from\n   the use of MPTCP is an increase in throughput, since MPTCP will pool\n\
    \   more than one path (where available) between two endpoints.  This\n   will\
    \ usually provide as great or greater bandwidth for an\n   application, even though\
    \ exceptions may exist, e.g., due to\n   differences in the congestion control\
    \ dynamics.  For instance, if a\n   new subflow is started, the short-term throughput\
    \ can be smaller than\n   the theoretical optimum.  If there are shared bottlenecks\
    \ between the\n   flows, then the congestion control algorithms will in most cases\n\
    \   ensure that load is evenly spread amongst regular and multipath TCP\n   sessions,\
    \ so that no end user receives worse performance than if all\n   were using single-path\
    \ TCP.  There are some known corner cases in\n   which an upgrade to MPTCP can\
    \ affect other users [21].\n   This performance increase additionally means that\
    \ an MPTCP session\n   could achieve throughput that is greater than the capacity\
    \ of a\n   single interface on the device.  If any applications make assumptions\n\
    \   about interfaces due to throughput, they must take this into account\n   (although\
    \ an MPTCP implementation must always respect an\n   application's request for\
    \ a particular interface).\n   Furthermore, the flexibility of MPTCP to add and\
    \ remove subflows as\n   paths change availability could lead to a greater variation,\
    \ and more\n   frequent change, in connection bandwidth.  Applications that adapt\
    \ to\n   available bandwidth (such as video and audio streaming) may need to\n\
    \   adjust some of their assumptions to most effectively take this into\n   account.\n\
    \   The transport of MPTCP signaling information results in a small\n   overhead.\
    \  The use of MPTCP instead of a single TCP connection\n   therefore results in\
    \ a smaller goodput.  Also, if multiple subflows\n   share a same bottleneck,\
    \ this overhead slightly reduces the capacity\n   that is available for data transport.\
    \  Yet, this potential reduction\n   of throughput will be negligible in many\
    \ usage scenarios, and the\n   protocol contains optimizations in its design so\
    \ that this overhead\n   is minimal.\n"
- title: 3.1.2.  Delay
  contents:
  - "3.1.2.  Delay\n   The benefits of MPTCP regarding throughput and resilience may\
    \ come at\n   some cost regarding data delivery delay and delay jitter.\n   If\
    \ the delays on the constituent subflows of an MPTCP connection\n   differ, the\
    \ jitter perceivable to an application may appear higher as\n   the data are spread\
    \ across the subflows.  Although MPTCP will ensure\n   in-order delivery to the\
    \ application, the data delivery could be more\n   bursty than may be usual with\
    \ single-path TCP, in particular on\n   highly asymmetric paths.\n   Applications\
    \ with high real-time requirements might be affected by\n   such a scenario. \
    \ One possible remedy is to disable MPTCP for such\n   jitter-sensitive applications,\
    \ either by using the basic API defined\n   in this document, or by other means,\
    \ such as system policies.\n   However, the actual delay and jitter of data transport\
    \ over MPTCP\n   depend on the scheduling and congestion control algorithms used\
    \ for\n   sending data, as well as the heuristics to establish and shut down\n\
    \   subflows.  A sender can implement strategies to minimize the delay\n   jitter\
    \ seen by applications, but this requires an accurate estimation\n   of the path\
    \ characteristics.  If the scheduling decisions are\n   suboptimal or if assumptions\
    \ about the path characteristics turn out\n   to be wrong, delay jitter may be\
    \ increased and affect delay-sensitive\n   applications.  In general, for a delay-sensitive\
    \ application, it\n   would be desirable to select an appropriate congestion control\n\
    \   algorithm for its traffic needs.\n   Alternatively, MPTCP could be used in\
    \ high-reliability, rather than\n   high-throughput, modes of operation, such\
    \ as by mirroring traffic on\n   subflows, or by only using additional subflows\
    \ for hot standby.\n   These methods of traffic scheduling would not cause delay\
    \ variation\n   in the same way.  These additional modes, and the selection of\n\
    \   alternative scheduling algorithms, would need to be indicated by an\n   advanced\
    \ API, the specification of which requires further analysis\n   and is outside\
    \ the scope of this document.\n   If data transport on one subflow fails, the\
    \ retransmissions inside\n   MPTCP could affect the delivery delay to the application.\
    \  Yet,\n   without MPTCP that data or the whole connection might have been lost,\n\
    \   and other reliability mechanisms (e.g., application-level recovery)\n   would\
    \ likely have an even larger delay impact.\n   In addition, applications that\
    \ make round-trip time (RTT) estimates\n   at the application level may have some\
    \ issues.  Whilst the average\n   delay calculated will be accurate, whether this\
    \ is useful for an\n   application will depend on what it requires this information\
    \ for.  If\n   a new application wishes to derive such information, it should\n\
    \   consider how multiple subflows may affect its measurements and thus\n   how\
    \ it may wish to respond.  In such a case, an application may wish\n   to express\
    \ its scheduling preferences, as described later in this\n   document.\n"
- title: 3.1.3.  Resilience
  contents:
  - "3.1.3.  Resilience\n   Another performance improvement through the use of MPTCP\
    \ is better\n   resilience.  The use of multiple subflows simultaneously means\
    \ that\n   if one should fail, all traffic will move to the remaining\n   subflow(s),\
    \ and additionally any lost packets can be retransmitted on\n   these subflows.\n\
    \   As one special case, MPTCP can be used with only one active subflow\n   at\
    \ a given point in time.  In that case, resilience compared to\n   single-path\
    \ TCP is improved.  MPTCP also supports make-before-break\n   and break-before-make\
    \ handovers between subflows.  In both cases, the\n   MPTCP connection can survive\
    \ an unavailability or change of an IP\n   address (e.g., due to shutdown of an\
    \ interface or handover).  MPTCP\n   closes or resets the MPTCP connection separately\
    \ from the individual\n   subflows, as described in [5].\n   Subflow failure may\
    \ be caused by issues within the network, which an\n   application would be unaware\
    \ of, or interface failure on the node.\n   An application may, under certain\
    \ circumstances, be in a position to\n   be aware of such failure (e.g., by radio\
    \ signal strength, or simply\n   an interface enabled flag), and so must not make\
    \ assumptions of an\n   MPTCP flow's stability based on this.  An MPTCP implementation\
    \ must\n   never override an application's request for a given interface,\n  \
    \ however, so the cases where this issue may be applicable are limited.\n"
- title: 3.2.  Potential Problems
  contents:
  - '3.2.  Potential Problems

    '
- title: 3.2.1.  Impact of Middleboxes
  contents:
  - "3.2.1.  Impact of Middleboxes\n   MPTCP has been designed to pass through the\
    \ majority of middleboxes.\n   Empirical evidence suggests that new TCP options\
    \ can successfully be\n   used on most paths in the Internet [22].  Nevertheless,\
    \ some\n   middleboxes may still refuse to pass MPTCP messages due to the\n  \
    \ presence of TCP options, or they may strip TCP options.  If this is\n   the\
    \ case, MPTCP falls back to regular TCP.  Although this will not\n   create a\
    \ problem for the application (its communication will be set\n   up either way),\
    \ there may be additional (and indeed, user-\n   perceivable) delay while the\
    \ first handshake fails.  Therefore, an\n   alternative approach could be to try\
    \ both MPTCP and regular TCP\n   connection attempts at the same time and respond\
    \ to whichever replies\n   first, in a fashion similar to the \"Happy Eyeballs\"\
    \ mechanism for\n   IPv6 [16].  One could also apply a shorter timeout on the\
    \ MPTCP\n   attempt and thus reduce the setup delay if fallback to regular TCP\
    \ is\n   needed.\n   An MPTCP implementation can learn the rate of MPTCP connection\n\
    \   attempt successes or failures to particular hosts or networks, and on\n  \
    \ particular interfaces, and could therefore learn heuristics of when\n   and\
    \ when not to use MPTCP.  A detailed discussion of the various\n   fallback mechanisms,\
    \ for failures occurring at different points in\n   the connection, is presented\
    \ in [5].  It must be emphasized that all\n   such heuristics could also fail,\
    \ and learning can be difficult in\n   certain environments, e.g., if the host\
    \ is mobile.\n   There may also be middleboxes that transparently change the length\
    \ of\n   content.  If such middleboxes are present, MPTCP's reassembly of the\n\
    \   byte stream in the receiver is difficult.  Still, MPTCP can detect\n   such\
    \ middleboxes and then fall back to regular TCP.  An overview of\n   the impact\
    \ of middleboxes is presented in [4], and MPTCP's mechanisms\n   to work around\
    \ these issues are presented and discussed in [5].\n   MPTCP can also have other\
    \ unexpected implications.  For instance,\n   intrusion detection systems could\
    \ be triggered.  A full analysis of\n   MPTCP's impact on such middleboxes is\
    \ for further study after\n   deployment experiments.\n"
- title: 3.2.2.  Dealing with Multiple Addresses inside Applications
  contents:
  - "3.2.2.  Dealing with Multiple Addresses inside Applications\n   In regular TCP,\
    \ there is a one-to-one mapping of the sockets\n   interface to a flow through\
    \ a network.  Since MPTCP can make use of\n   multiple subflows, applications\
    \ cannot implicitly rely on this\n   one-to-one mapping any more.\n   Whilst this\
    \ doesn't matter for most applications, some applications\n   may need to adapt\
    \ to the presence of multiple addresses, because\n   implicit assumptions are\
    \ outdated.  In this section, selected\n   examples for resulting issues are discussed.\
    \  The question of whether\n   such implicit assumptions matter is an application-level\
    \ decision,\n   and this document only provides general guidance and a basic API\
    \ to\n   retrieve relevant information.\n   A few applications require the transport\
    \ to be along a single path;\n   they can disable the use of MPTCP as described\
    \ later in this\n   document.  Examples include monitoring tools that want to\
    \ measure the\n   available bandwidth on a path, or routing protocols such as\
    \ BGP that\n   require the use of a specific link.\n   Certain applications store\
    \ the IP addresses of TCP connections, e.g.,\n   by logging mechanisms.  Such\
    \ logging mechanisms will continue to work\n   with MPTCP, but two important aspects\
    \ have to be mentioned: First, if\n   the application is not aware of MPTCP, it\
    \ will use the existing\n   interface to the network stack.  This implies that\
    \ an MPTCP-unaware\n   application will track the IP addresses of the first subflow\
    \ only.\n   IP addresses used by follow-up subflows will be ignored.  Second,\
    \ an\n   MPTCP-aware application can use the basic API described in this\n   document\
    \ to monitor the IP addresses of all subflows, e.g., for\n   logging mechanisms.\
    \  If an MPTCP connection uses several subflows,\n   this will possibly imply\
    \ that data structures have to be adapted and\n   that the amount of data that\
    \ has to be logged and stored per\n   connection will increase.\n   An MPTCP implementation\
    \ may choose to maintain an MPTCP connection\n   even if the IP address of the\
    \ original subflow is no longer allocated\n   to a host, depending on the policy\
    \ concerning the first subflow\n   (fate-sharing; see Section 4.2.2).  In this\
    \ case, the IP address\n   exposed to an MPTCP-unaware application can differ\
    \ from the addresses\n   actually being used by MPTCP.  It is even possible that\
    \ the IP\n   address gets assigned to another host during the lifetime of an MPTCP\n\
    \   connection.  As further discussed below, this could be an issue if\n   the\
    \ IP addresses are exchanged by applications, e.g., inside the\n   application\
    \ protocol.  This issue can be addressed by enabling fate-\n   sharing, at the\
    \ cost of resilience, because the MPTCP connection then\n   cannot close the initial\
    \ subflow.\n"
- title: 3.2.3.  Security Implications
  contents:
  - "3.2.3.  Security Implications\n   The support for multiple IP addresses within\
    \ one MPTCP connection can\n   result in additional security vulnerabilities,\
    \ such as possibilities\n   for attackers to hijack connections.  The protocol\
    \ design of MPTCP\n   minimizes this risk.  An attacker on one of the paths can\
    \ cause harm,\n   but this is hardly an additional security risk compared to single-\n\
    \   path TCP, which is vulnerable to man-in-the-middle attacks as well.\n   A\
    \ detailed threat analysis of MPTCP is published in [6].\n   Impact on Transport\
    \ Layer Security (TLS) is discussed in Section 6.1.\n"
- title: 4.  Operation of MPTCP with Legacy Applications
  contents:
  - '4.  Operation of MPTCP with Legacy Applications

    '
- title: 4.1.  Overview of the MPTCP Network Stack
  contents:
  - "4.1.  Overview of the MPTCP Network Stack\n   MPTCP is an extension of TCP, but\
    \ it is designed to be backward\n   compatible for legacy (MPTCP-unaware) applications.\
    \  TCP interacts\n   with other parts of the network stack via different interfaces.\
    \  The\n   de facto standard API between TCP and applications is the sockets\n\
    \   interface.  The position of MPTCP in the protocol stack is\n   illustrated\
    \ in Figure 1.\n                     +-------------------------------+\n     \
    \                |           Application         |\n                     +-------------------------------+\n\
    \                            ^                  |\n                  ~~~~~~~~~~|~Sockets\
    \ Interface|~~~~~~~~~\n                            |                  v\n    \
    \                 +-------------------------------+\n                     |  \
    \           MPTCP             |\n                     + - - - - - - - + - - -\
    \ - - - - +\n                     | Subflow (TCP) | Subflow (TCP) |\n        \
    \             +-------------------------------+\n                     |      \
    \ IP      |      IP       |\n                     +-------------------------------+\n\
    \                      Figure 1: MPTCP Protocol Stack\n   In general, MPTCP can\
    \ affect all interfaces that make assumptions\n   about the coupling of a TCP\
    \ connection to a single IP address and TCP\n   port pair, to one socket endpoint,\
    \ to one network interface, or to a\n   given path through the network.\n   This\
    \ means that there are two classes of applications:\n   o  Legacy applications:\
    \ These applications are unaware of MPTCP and\n      use the existing API towards\
    \ TCP without any changes.  This is the\n      default case.\n   o  MPTCP-aware\
    \ applications: These applications indicate support for\n      an enhanced MPTCP\
    \ interface.  This document specifies a minimum\n      set of API extensions for\
    \ such applications.\n   In the following sections, it is discussed to what extent\
    \ MPTCP\n   affects legacy applications using the existing sockets API.  The\n\
    \   existing sockets API implies that applications deal with data\n   structures\
    \ that store, amongst others, the IP addresses and TCP port\n   numbers of a TCP\
    \ connection.  A design objective of MPTCP is that\n   legacy applications can\
    \ continue to use the established sockets API\n   without any changes.  However,\
    \ in MPTCP there is a one-to-many\n   mapping between the socket endpoint and\
    \ the subflows.  This has\n   several subtle implications for legacy applications\
    \ using sockets API\n   functions.\n"
- title: 4.2.  Address Issues
  contents:
  - '4.2.  Address Issues

    '
- title: 4.2.1.  Specification of Addresses by Applications
  contents:
  - "4.2.1.  Specification of Addresses by Applications\n   During binding, an application\
    \ can either select a specific address\n   or bind to INADDR_ANY.  Furthermore,\
    \ on some systems other socket\n   options (e.g., SO_BINDTODEVICE) can be used\
    \ to bind to a specific\n   interface.  If an application uses a specific address\
    \ or binds to a\n   specific interface, then MPTCP MUST respect this and not interfere\
    \ in\n   the application's choices.  The binding to a specific address or\n  \
    \ interface implies that the application is not aware of MPTCP and will\n   disable\
    \ the use of MPTCP on this connection.  An application that\n   wishes to bind\
    \ to a specific set of addresses with MPTCP must use\n   multipath-aware calls\
    \ to achieve this (as described in\n   Section 5.3.3).\n   If an application binds\
    \ to INADDR_ANY, it is assumed that the\n   application does not care which addresses\
    \ are used locally.  In this\n   case, a local policy MAY allow MPTCP to automatically\
    \ set up multiple\n   subflows on such a connection.\n   The basic sockets API\
    \ of MPTCP-aware applications allows the\n   expression of further preferences\
    \ in an MPTCP-compatible way (e.g.,\n   binding to a subset of interfaces only).\n"
- title: 4.2.2.  Querying of Addresses by Applications
  contents:
  - "4.2.2.  Querying of Addresses by Applications\n   Applications can use the getpeername()\
    \ or getsockname() functions in\n   order to retrieve the IP address of the peer\
    \ or of the local socket.\n   These functions can be used for various purposes,\
    \ including security\n   mechanisms, geo-location, or interface checks.  The sockets\
    \ API was\n   designed with an assumption that a socket is using just one address,\n\
    \   and since this address is visible to the application, the application\n  \
    \ may assume that the information provided by the functions is the same\n   during\
    \ the lifetime of a connection.  However, in MPTCP, unlike in\n   TCP, there is\
    \ a one-to-many mapping of a connection to subflows, and\n   subflows can be added\
    \ and removed while the connection continues to\n   exist.  Since the subflow\
    \ addresses can change, MPTCP cannot expose\n   addresses by getpeername() or\
    \ getsockname() that are both valid and\n   constant during the connection's lifetime.\n\
    \   This problem is addressed as follows: If used by a legacy\n   application,\
    \ the MPTCP stack MUST always return the addresses and\n   port numbers of the\
    \ first subflow of an MPTCP connection, in all\n   circumstances, even if that\
    \ particular subflow is no longer in use.\n   As the addresses may not be valid\
    \ any more if the first subflow is\n   closed, the MPTCP stack MAY close the whole\
    \ MPTCP connection if the\n   first subflow is closed (i.e., fate-sharing between\
    \ the initial\n   subflow and the MPTCP connection as a whole).  This fate-sharing\n\
    \   avoids the reuse of the pair of IP addresses and ports while an MPTCP\n  \
    \ connection is still in progress, but at the cost of reducing the\n   utility\
    \ of MPTCP if IP addresses of the first subflow are not\n   available any more\
    \ (e.g., mobility events).  Whether to close the\n   whole MPTCP connection by\
    \ default SHOULD be controlled by a local\n   policy.  Further experiments are\
    \ needed to investigate its\n   implications.\n   The functions getpeername()\
    \ and getsockname() SHOULD also always\n   return the addresses of the first subflow\
    \ if the socket is used by an\n   MPTCP-aware application, in order to be consistent\
    \ with MPTCP-unaware\n   applications, and, e.g., also with the Stream Control\
    \ Transmission\n   Protocol (SCTP).  Instead of getpeername() or getsockname(),\n\
    \   MPTCP-aware applications can use new API calls, described in\n   Section 5.3,\
    \ in order to retrieve the full list of address pairs for\n   the subflows in\
    \ use.\n"
- title: 4.3.  MPTCP Connection Management
  contents:
  - '4.3.  MPTCP Connection Management

    '
- title: 4.3.1.  Reaction to Close Call by Application
  contents:
  - "4.3.1.  Reaction to Close Call by Application\n   As described in [5], MPTCP\
    \ distinguishes between the closing of\n   subflows (by TCP FIN) and closing the\
    \ whole MPTCP connection\n   (by Data FIN).\n   When an application closes a socket,\
    \ e.g., by calling the close()\n   function, this indicates that the application\
    \ has no more data to\n   send, like for single-path TCP.  MPTCP will then close\
    \ the MPTCP\n   connection via Data FIN messages.  This is completely transparent\
    \ for\n   an application.\n   In summary, the semantics of the close() interface\
    \ for applications\n   are not changed compared to TCP.\n"
- title: 4.3.2.  Other Connection Management Functions
  contents:
  - "4.3.2.  Other Connection Management Functions\n   In general, an MPTCP connection\
    \ is maintained separately from\n   individual subflows.  MPTCP therefore has\
    \ internal mechanisms to\n   establish, close, or reset the MPTCP connection [5].\
    \  These\n   mechanisms provide equivalent functions like single-path TCP and\
    \ can\n   be mapped accordingly.  Therefore, these MPTCP internals do not\n  \
    \ affect the application interface.\n"
- title: 4.4.  Socket Option Issues
  contents:
  - '4.4.  Socket Option Issues

    '
- title: 4.4.1.  General Guideline
  contents:
  - "4.4.1.  General Guideline\n   The existing sockets API includes options that\
    \ modify the behavior of\n   sockets and their underlying communications protocols.\
    \  Various\n   socket options exist on the socket, TCP, and IP level.  The value\
    \ of\n   an option can usually be set by the setsockopt() system function.\n \
    \  The getsockopt() function gets information.  In general, the existing\n   sockets\
    \ interface functions cannot configure each MPTCP subflow\n   individually.  In\
    \ order to be backward compatible, existing APIs\n   therefore SHOULD apply to\
    \ all subflows within one connection, as far\n   as possible.\n"
- title: 4.4.2.  Disabling of the Nagle Algorithm
  contents:
  - "4.4.2.  Disabling of the Nagle Algorithm\n   One commonly used TCP socket option\
    \ (TCP_NODELAY) disables the Nagle\n   algorithm as described in [2].  This option\
    \ is also specified in the\n   POSIX standard [8].  Applications can use this\
    \ option in combination\n   with MPTCP in exactly the same way.  It then SHOULD\
    \ disable the Nagle\n   algorithm for the MPTCP connection, i.e., all subflows.\n\
    \   In addition, the MPTCP protocol instance MAY use a different path\n   scheduler\
    \ algorithm if TCP_NODELAY is present.  For instance, it\n   could use an algorithm\
    \ that is optimized for latency-sensitive\n   traffic (for instance, only transmitting\
    \ on one path).  Specific\n   algorithms are outside the scope of this document.\n"
- title: 4.4.3.  Buffer Sizing
  contents:
  - "4.4.3.  Buffer Sizing\n   Applications can explicitly configure send and receive\
    \ buffer sizes\n   via the sockets API (SO_SNDBUF, SO_RCVBUF).  These socket options\
    \ can\n   also be used in combination with MPTCP and then affect the buffer\n\
    \   size of the MPTCP connection.  However, when defining buffer sizes,\n   application\
    \ programmers should take into account that the transport\n   over several subflows\
    \ requires a certain amount of buffer for\n   resequencing in the receiver.  MPTCP\
    \ may also require more storage\n   space in the sender, in particular, if retransmissions\
    \ are sent over\n   more than one path.  In addition, very small send buffers\
    \ may prevent\n   MPTCP from efficiently scheduling data over different subflows.\n\
    \   Therefore, it does not make sense to use MPTCP in combination with\n   small\
    \ send or receive buffers.\n   An MPTCP implementation MAY set a lower bound for\
    \ send and receive\n   buffers and treat a small buffer size request as an implicit\
    \ request\n   not to use MPTCP.\n"
- title: 4.4.4.  Other Socket Options
  contents:
  - "4.4.4.  Other Socket Options\n   TCP features the ability to send \"Urgent\"\
    \ data, but its use is not\n   recommended in general, and specifically not with\
    \ MPTCP [4].\n   Some network stacks may provide additional implementation-specific\n\
    \   socket options or interfaces that affect TCP's behavior.  In such\n   cases,\
    \ implementers must ensure that these options do not interfere\n   with the MPTCP\
    \ interface.\n"
- title: 4.5.  Default Enabling of MPTCP
  contents:
  - "4.5.  Default Enabling of MPTCP\n   It is up to a local policy at the end system\
    \ whether a network stack\n   should automatically enable MPTCP for sockets even\
    \ if there is no\n   explicit sign of MPTCP awareness of the corresponding application.\n\
    \   Such a choice may be under the control of the user through system\n   preferences.\n\
    \   The enabling of MPTCP, either by application or by system defaults,\n   does\
    \ not necessarily mean that MPTCP will always be used.  Both\n   endpoints must\
    \ support MPTCP, and there must be multiple addresses at\n   at least one endpoint,\
    \ for MPTCP to be used.  Even if those\n   requirements are met, however, MPTCP\
    \ may not be immediately used on a\n   connection.  It may make sense for multiple\
    \ paths to be brought into\n   operation only after a given period of time, or\
    \ if the connection is\n   saturated.\n"
- title: 4.6.  Summary of Advice to Application Developers
  contents:
  - "4.6.  Summary of Advice to Application Developers\n   o  Using the default MPTCP\
    \ configuration: Like TCP, MPTCP is designed\n      to be efficient and robust\
    \ in the default configuration.\n      Application developers should not explicitly\
    \ configure TCP (or\n      MPTCP) features unless this is really needed.\n   o\
    \  Socket buffer dimensioning: Multipath transport requires larger\n      buffers\
    \ in the receiver for resequencing, as already explained.\n      Applications\
    \ should use reasonable buffer sizes (such as the\n      operating system default\
    \ values) in order to fully benefit from\n      MPTCP.  A full discussion of buffer\
    \ sizing issues is given in [5].\n   o  Facilitating stack-internal heuristics:\
    \ The path management and\n      data scheduling by MPTCP is realized by stack-internal\
    \ algorithms\n      that may implicitly try to self-optimize their behavior according\n\
    \      to assumed application needs.  For instance, an MPTCP\n      implementation\
    \ may use heuristics to determine whether an\n      application requires delay-sensitive\
    \ or bulk data transport,\n      using, for instance, port numbers, the TCP_NODELAY\
    \ socket options,\n      or the application's read/write patterns as input parameters.\
    \  An\n      application developer can facilitate the operation of such\n    \
    \  heuristics by avoiding atypical interface use cases.  For\n      instance,\
    \ for long bulk data transfers, it does not make sense to\n      enable the TCP_NODELAY\
    \ socket option, nor is it reasonable to use\n      many small socket send() calls\
    \ each with small amounts of data\n      only.\n"
- title: 5.  Basic API for MPTCP-Aware Applications
  contents:
  - '5.  Basic API for MPTCP-Aware Applications

    '
- title: 5.1.  Design Considerations
  contents:
  - "5.1.  Design Considerations\n   While applications can use MPTCP with the unmodified\
    \ sockets API,\n   multipath transport results in many degrees of freedom.  MPTCP\n\
    \   manages the data transport over different subflows automatically.  By\n  \
    \ default, this is transparent to the application, but an application\n   could\
    \ use an additional API to interface with the MPTCP layer and to\n   control important\
    \ aspects of the MPTCP implementation's behavior.\n   This document describes\
    \ a basic MPTCP API.  The API contains a\n   minimum set of functions that provide\
    \ an equivalent level of control\n   and information as exists for regular TCP.\
    \  It maintains backward\n   compatibility with legacy applications.\n   An advanced\
    \ MPTCP API is outside the scope of this document.  The\n   basic API does not\
    \ allow a sender or a receiver to express\n   preferences about the management\
    \ of paths or the scheduling of data,\n   even if this can have a significant\
    \ performance impact and if an\n   MPTCP implementation could benefit from additional\
    \ guidance by\n   applications.  A list of potential further API extensions is\
    \ provided\n   in the appendix.  The specification of such an advanced API is\
    \ for\n   further study and may partly be implementation-specific.\n   MPTCP mainly\
    \ affects the sending of data.  But a receiver may also\n   have preferences about\
    \ data transfer choices, and it may have\n   performance requirements as well.\
    \  Yet, the configuration of such\n   preferences is outside of the scope of the\
    \ basic API.\n"
- title: 5.2.  Requirements on the Basic MPTCP API
  contents:
  - "5.2.  Requirements on the Basic MPTCP API\n   Because of the importance of the\
    \ sockets interface there are several\n   fundamental design objectives for the\
    \ basic interface between MPTCP\n   and applications:\n   o  Consistency with\
    \ existing sockets APIs must be maintained as far\n      as possible.  In order\
    \ to support the large base of applications\n      using the original API, a legacy\
    \ application must be able to\n      continue to use standard sockets interface\
    \ functions when run on a\n      system supporting MPTCP.  Also, MPTCP-aware applications\
    \ should be\n      able to access the socket without any major changes.\n   o\
    \  Sockets API extensions must be minimized and independent of an\n      implementation.\n\
    \   o  The interface should handle both IPv4 and IPv6.\n   The following is a\
    \ list of the core requirements for the basic API:\n   REQ1:  Turn on/off MPTCP:\
    \ An application should be able to request to\n          turn on or turn off the\
    \ usage of MPTCP.  This means that an\n          application should be able to\
    \ explicitly request the use of\n          MPTCP if this is possible.  Applications\
    \ should also be able\n          to request not to enable MPTCP and to use regular\
    \ TCP\n          transport instead.  This can be implicit in many cases, since\n\
    \          MPTCP must be disabled by the use of binding to a specific\n      \
    \    address.  MPTCP may also be enabled if an application uses a\n          dedicated\
    \ multipath address family (such as AF_MULTIPATH\n          [20]).\n   REQ2: \
    \ An application should be able to restrict MPTCP to binding to\n          a given\
    \ set of addresses.\n   REQ3:  An application should be able to obtain information\
    \ on the\n          pairs of addresses used by the MPTCP subflows.\n   REQ4: \
    \ An application should be able to extract a unique identifier\n          for\
    \ the connection (per endpoint).\n   The first requirement is the most important\
    \ one, since some\n   applications could benefit a lot from MPTCP, but there are\
    \ also cases\n   in which it hardly makes sense.  The existing sockets API provides\n\
    \   similar mechanisms to enable or disable advanced TCP features.  The\n   second\
    \ requirement corresponds to the binding of addresses with the\n   bind() socket\
    \ call, or, e.g., explicit device bindings with a\n   SO_BINDTODEVICE option.\
    \  The third requirement ensures that there is\n   an equivalent to getpeername()\
    \ or getsockname() that is able to deal\n   with more than one subflow.  Finally,\
    \ it should be possible for the\n   application to retrieve a unique connection\
    \ identifier (local to the\n   endpoint on which it is running) for the MPTCP\
    \ connection.  This\n   replaces the (address, port) pair for a connection identifier\
    \ in\n   single-path TCP, which is no longer static in MPTCP.\n   An application\
    \ can continue to use getpeername() or getsockname() in\n   addition to the basic\
    \ MPTCP API.  Both functions return the\n   corresponding addresses of the first\
    \ subflow, as already explained.\n"
- title: 5.3.  Sockets Interface Extensions by the Basic MPTCP API
  contents:
  - '5.3.  Sockets Interface Extensions by the Basic MPTCP API

    '
- title: 5.3.1.  Overview
  contents:
  - "5.3.1.  Overview\n   The abstract, basic MPTCP API consists of a set of new values\
    \ that\n   are associated with an MPTCP socket.  Such values may be used for\n\
    \   changing properties of an MPTCP connection or retrieving information.\n  \
    \ These values could be accessed by new symbols on existing calls such\n   as\
    \ setsockopt() and getsockopt() or could be implemented as entirely\n   new function\
    \ calls.  This implementation decision is out of scope for\n   this document.\
    \  The following list presents symbolic names for these\n   MPTCP socket settings.\n\
    \   o  TCP_MULTIPATH_ENABLE: Enable/disable MPTCP\n   o  TCP_MULTIPATH_ADD: Bind\
    \ MPTCP to a set of given local addresses,\n      or add a set of new local addresses\
    \ to an existing MPTCP\n      connection\n   o  TCP_MULTIPATH_REMOVE: Remove a\
    \ local address from an MPTCP\n      connection\n   o  TCP_MULTIPATH_SUBFLOWS:\
    \ Get the pairs of addresses currently used\n      by the MPTCP subflows\n   o\
    \  TCP_MULTIPATH_CONNID: Get the local connection identifier for this\n      MPTCP\
    \ connection\n   Table 1 shows a list of the abstract socket operations for the\
    \ basic\n   configuration of MPTCP.  The first column gives the symbolic name\
    \ of\n   the operation.  The second and third columns indicate whether the\n \
    \  operation provides values to be read (\"Get\") or takes values to\n   configure\
    \ (\"Set\").  The fourth column lists the type of data\n   associated with this\
    \ operation.  The data types are listed for\n   information only.  In addition\
    \ to IP addresses, an application MAY\n   also indicate TCP port numbers, as further\
    \ detailed below.\n   +------------------------+-----+-----+------------------------------+\n\
    \   | Name                   | Get | Set |           Data type          |\n  \
    \ +------------------------+-----+-----+------------------------------+\n   |\
    \ TCP_MULTIPATH_ENABLE   |  o  |  o  |           boolean            |\n   | TCP_MULTIPATH_ADD\
    \      |     |  o  |      list of addresses       |\n   |                    \
    \    |     |     |         (and ports)          |\n   | TCP_MULTIPATH_REMOVE \
    \  |     |  o  |      list of addresses       |\n   |                        |\
    \     |     |         (and ports)          |\n   | TCP_MULTIPATH_SUBFLOWS |  o\
    \  |     |  list of pairs of addresses  |\n   |                        |     |\
    \     |         (and ports)          |\n   | TCP_MULTIPATH_CONNID   |  o  |  \
    \   |           integer            |\n   +------------------------+-----+-----+------------------------------+\n\
    \                     Table 1: MPTCP Socket Operations\n   There are restrictions\
    \ on when these new socket operations can be\n   used:\n   o  TCP_MULTIPATH_ENABLE:\
    \ This value should only be set before the\n      establishment of a TCP connection.\
    \  Its value should only be read\n      after the establishment of a connection.\n\
    \   o  TCP_MULTIPATH_ADD: This operation can be applied both before\n      connection\
    \ setup and during a connection.  If used before, it\n      controls the local\
    \ addresses that an MPTCP connection can use.  In\n      the latter case, it allows\
    \ MPTCP to use an additional local\n      address, if there has been a restriction\
    \ before connection setup.\n   o  TCP_MULTIPATH_REMOVE: This operation can be\
    \ applied both before\n      connection setup and during a connection.  In both\
    \ cases, it\n      removes an address from the list of local addresses that may\
    \ be\n      used by subflows.\n   o  TCP_MULTIPATH_SUBFLOWS: This value is read-only\
    \ and can only be\n      used after connection setup.\n   o  TCP_MULTIPATH_CONNID:\
    \ This value is read-only and should only be\n      used after connection setup.\n"
- title: 5.3.2.  Enabling and Disabling of MPTCP
  contents:
  - "5.3.2.  Enabling and Disabling of MPTCP\n   An application can explicitly indicate\
    \ multipath capability by\n   setting TCP_MULTIPATH_ENABLE to the value \"true\"\
    .  In this case, the\n   MPTCP implementation SHOULD try to negotiate MPTCP for\
    \ that\n   connection.  Note that multipath transport will not necessarily be\n\
    \   enabled, as it requires support at both end systems, no middleboxes\n   on\
    \ the path that would prevent any additional signaling, and at least\n   one endpoint\
    \ with multiple addresses.\n   Building on the backward compatibility specified\
    \ in Section 4.2.1, if\n   an application enables MPTCP but binds to a specific\
    \ address or\n   interface, MPTCP MUST be enabled, but MPTCP MUST respect the\n\
    \   application's choice and only use addresses that are explicitly\n   provided\
    \ by the application.  Note that it would be possible for an\n   application to\
    \ use the legacy bindings and then expand on them by\n   using TCP_MULTIPATH_ADD.\
    \  Note also that it is possible for more than\n   one local address to be initially\
    \ available to MPTCP in this case, if\n   an application has bound to a specific\
    \ interface with multiple\n   addresses.\n   An application can disable MPTCP\
    \ by setting TCP_MULTIPATH_ENABLE to a\n   value of \"false\".  In that case,\
    \ MPTCP MUST NOT be used on that\n   connection.\n   After connection establishment,\
    \ an application can get the value of\n   TCP_MULTIPATH_ENABLE.  A value of \"\
    false\" then means lack of MPTCP\n   support.  A value of \"true\" means that\
    \ MPTCP is supported.\n"
- title: 5.3.3.  Binding MPTCP to Specified Addresses
  contents:
  - "5.3.3.  Binding MPTCP to Specified Addresses\n   Before connection establishment,\
    \ an application can use the\n   TCP_MULTIPATH_ADD function to indicate a set\
    \ of local IP addresses\n   that MPTCP may bind to.  The parameter of the function\
    \ is a list of\n   addresses in a corresponding data structure.  By extension,\
    \ this\n   operation will also control the list of addresses that can be\n   advertised\
    \ to the peer via MPTCP signaling.\n   If an application binds to a specific address\
    \ or interface, it is not\n   required to use the TCP_MULTIPATH_ADD operation\
    \ for that address.  As\n   explained in Section 5.3.2, MPTCP MUST only use the\
    \ explicitly\n   specified addresses in that case.\n   An application MAY also\
    \ indicate a TCP port number that, if\n   specified, MPTCP MUST attempt to bind\
    \ to.  The port number MAY be\n   different than the one used by existing subflows.\
    \  If no port number\n   is provided by the application, the port number is automatically\n\
    \   selected by the MPTCP implementation, and it is RECOMMENDED that it\n   is\
    \ the same across all subflows.\n   This operation can also be used to modify\
    \ the address list in use\n   during the lifetime of an MPTCP connection.  In\
    \ this case, it is used\n   to indicate a set of additional local addresses that\
    \ the MPTCP\n   connection can make use of and that can be signaled to the peer.\
    \  It\n   should be noted that this signal is only a hint, and an MPTCP\n   implementation\
    \ MAY select only a subset of the addresses.\n   The TCP_MULTIPATH_REMOVE operation\
    \ can be used to remove a local\n   address, or a set of local addresses, from\
    \ an MPTCP connection.\n   MPTCP MUST close any corresponding subflows (i.e.,\
    \ those using the\n   local address that is no longer present) and signal the\
    \ removal of\n   the address to the peer.  If alternative paths are available\
    \ using\n   the supplied address list but MPTCP is not currently using them, an\n\
    \   MPTCP implementation SHOULD establish alternative subflows before\n   undertaking\
    \ the address removal.\n   It should be remembered that these operations SHOULD\
    \ support both\n   IPv4 and IPv6 addresses, potentially in the same call.\n"
- title: 5.3.4.  Querying the MPTCP Subflow Addresses
  contents:
  - "5.3.4.  Querying the MPTCP Subflow Addresses\n   An application can get a list\
    \ of the addresses used by the currently\n   established subflows in an MPTCP\
    \ connection by means of the read-only\n   TCP_MULTIPATH_SUBFLOWS operation.\n\
    \   The return value is a list of pairs of tuples of IP address and TCP\n   port\
    \ number.  In one pair, the first tuple refers to the local IP\n   address and\
    \ the local TCP port, and the second one to the remote IP\n   address and remote\
    \ TCP port used by the subflow.  The list MUST only\n   include established subflows.\
    \  Both addresses in each pair MUST be\n   either IPv4 or IPv6.\n"
- title: 5.3.5.  Getting a Unique Connection Identifier
  contents:
  - "5.3.5.  Getting a Unique Connection Identifier\n   An application that wants\
    \ a unique identifier for the connection,\n   analogous to an (address, port)\
    \ pair in regular TCP, can query the\n   TCP_MULTIPATH_CONNID value to get a local\
    \ connection identifier for\n   the MPTCP connection.\n   This SHOULD be an integer\
    \ number and SHOULD be locally unique (e.g.,\n   the MPTCP token).\n"
- title: 6.  Other Compatibility Issues
  contents:
  - '6.  Other Compatibility Issues

    '
- title: 6.1.  Usage of TLS over MPTCP
  contents:
  - "6.1.  Usage of TLS over MPTCP\n   Transport Layer Security (TLS) [17] may be\
    \ used over MPTCP's basic\n   API.  When TLS compares any addresses used by MPTCP\
    \ against names or\n   addresses present in X.509 certificates [18] [19], it MUST\
    \ only\n   compare them with the address that MPTCP used to start the initial\n\
    \   subflow as presented to TLS.  The addresses used for subsequent\n   subflows\
    \ need not to be compared against any TLS certificate\n   information.  Finer-grained\
    \ control would require an advanced API or\n   proactive subflow management via\
    \ the basic API.\n"
- title: 6.2.  Usage of the SCTP Sockets API
  contents:
  - "6.2.  Usage of the SCTP Sockets API\n   For dealing with multihoming, several\
    \ sockets API extensions have\n   been defined for SCTP [13].  As MPTCP realizes\
    \ multipath transport\n   from and to multihomed end systems, some of these interface\
    \ function\n   calls are actually applicable to MPTCP in a similar way.\n   API\
    \ developers may wish to integrate SCTP and MPTCP calls to provide\n   a consistent\
    \ interface to the application.  Yet, it must be\n   emphasized that the transport\
    \ service provided by MPTCP is different\n   than that of SCTP, and this is why\
    \ not all SCTP API functions can be\n   mapped directly to MPTCP.  Furthermore,\
    \ a network stack implementing\n   MPTCP does not necessarily support SCTP and\
    \ its specific sockets\n   interface extensions.  This is why the basic API of\
    \ MPTCP defines\n   additional socket options only, which are a backward-compatible\n\
    \   extension of TCP's application interface.  Integration with the SCTP\n   API\
    \ is outside the scope of the basic API.\n"
- title: 6.3.  Incompatibilities with Other Multihoming Solutions
  contents:
  - "6.3.  Incompatibilities with Other Multihoming Solutions\n   The use of MPTCP\
    \ can interact with various related sockets API\n   extensions.  The use of a\
    \ multihoming shim layer conflicts with\n   multipath transport such as MPTCP\
    \ or SCTP [11].  Care should be taken\n   that the use of MPTCP not conflict with\
    \ the overlapping features of\n   other APIs:\n   o  SHIM API [11]: This API specifies\
    \ sockets API extensions for the\n      multihoming shim layer.\n   o  HIP API\
    \ [12]: The Host Identity Protocol (HIP) also results in a\n      new API.\n \
    \  o  API for Mobile IPv6 [10]: For Mobile IPv6, a significantly\n      extended\
    \ sockets API exists as well (in addition to API extensions\n      for IPv6 [9]).\n\
    \   In order to avoid any conflict, multiaddressed MPTCP SHOULD NOT be\n   enabled\
    \ if a network stack uses SHIM6, HIP, or Mobile IPv6.\n   Furthermore, applications\
    \ should not try to use both the MPTCP API\n   and another multihoming or mobility\
    \ layer API.\n   It is possible, however, that some of the MPTCP functionality,\
    \ such\n   as congestion control, could be used in a SHIM6 or HIP environment.\n\
    \   Such operation is for further study.\n"
- title: 6.4.  Interactions with DNS
  contents:
  - "6.4.  Interactions with DNS\n   In multihomed or multiaddressed environments,\
    \ there are various\n   issues that are not specific to MPTCP but have to be considered\
    \ as\n   well.  These problems are summarized in [14].\n   Specifically, there\
    \ can be interactions with DNS.  Whilst it is\n   expected that an application\
    \ will iterate over the list of addresses\n   returned from a call such as getaddrinfo(),\
    \ MPTCP itself MUST NOT\n   make any assumptions about multiple A or AAAA records\
    \ from the same\n   DNS query referring to the same host, as it is possible that\
    \ multiple\n   addresses refer to multiple servers for load-balancing purposes.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document first defines the behavior of the\
    \ standard TCP/IP API\n   for MPTCP-unaware applications.  In general, enabling\
    \ MPTCP has some\n   security implications for applications, which are introduced\
    \ in\n   Section 5.3.3, and these threats are further detailed in [6].  The\n\
    \   protocol specification of MPTCP [5] defines several mechanisms to\n   protect\
    \ MPTCP against those attacks.\n   The syntax and semantics of the API for MPTCP-unaware\
    \ applications\n   does not change.  However, assumptions that non-MPTCP-aware\n\
    \   applications may make on the data retrieved by the backward-\n   compatible\
    \ API are discussed in Section 4.2.2.  System administrators\n   may wish to disable\
    \ MPTCP for certain applications that signal\n   addresses, or make security decisions\
    \ (e.g., opening firewall holes),\n   based on responses to such queries.\n  \
    \ In addition, the basic MPTCP API for MPTCP-aware applications defines\n   functions\
    \ that provide an equivalent level of control and information\n   as exists for\
    \ regular TCP.  This document does not mandate a specific\n   implementation of\
    \ the basic MPTCP API.  The implementation should be\n   designed not to affect\
    \ memory management assumptions in existing\n   code.  Implementors should take\
    \ into account that data structures\n   will be more complex than for standard\
    \ TCP, e.g., when multiple\n   subflow addresses have to be stored.  When dealing\
    \ with such data\n   structures, care is needed not to add security vulnerabilities\
    \ to\n   applications.\n   New functions enable adding and removing local addresses\
    \ from an\n   MPTCP connection (TCP_MULTIPATH_ADD and TCP_MULTIPATH_REMOVE). \
    \ These\n   functions don't add security threats if the MPTCP stack verifies that\n\
    \   the addresses provided by the application are indeed available as\n   source\
    \ addresses for subflows.\n   However, applications should use the TCP_MULTIPATH_ADD\
    \ function with\n   care, as new subflows might get established to those addresses.\n\
    \   Furthermore, it could result in some form of information leakage\n   since\
    \ MPTCP might advertise those addresses to the other connection\n   endpoint,\
    \ which could learn IP addresses of interfaces that are not\n   visible otherwise.\n\
    \   Use of different addresses should not be assumed to lead to use of\n   different\
    \ paths, especially for security purposes.\n   MPTCP-aware applications should\
    \ also take care when querying and\n   using information about the addresses used\
    \ by subflows\n   (TCP_MULTIPATH_SUBFLOWS).  As MPTCP can dynamically open and\
    \ close\n   subflows, a list of addresses queried once can get outdated during\n\
    \   the lifetime of an MPTCP connection.  Then, the list may contain\n   invalid\
    \ entries, i.e., addresses that are not used any more or that\n   might not even\
    \ be assigned to that host any more.  Applications that\n   want to ensure that\
    \ MPTCP only uses a certain set of addresses should\n   explicitly bind to those\
    \ addresses.\n   One specific example is the use TLS on top of MPTCP.  Corresponding\n\
    \   guidance can be found in Section 6.1.\n"
- title: 8.  Conclusion
  contents:
  - "8.  Conclusion\n   This document discusses MPTCP's implications and its performance\n\
    \   impact on applications.  In addition, it specifies a basic MPTCP API.\n  \
    \ For legacy applications, it is ensured that the existing sockets API\n   continues\
    \ to work.  MPTCP-aware applications can use the basic MPTCP\n   API that provides\
    \ some control over the transport layer equivalent to\n   regular TCP.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   The authors sincerely thank the following people for\
    \ their helpful\n   comments and reviews of the document: Philip Eardley, Lavkesh\n\
    \   Lahngir, John Leslie, Costin Raiciu, Michael Tuexen, and Javier\n   Ubillos.\n\
    \   Michael Scharf is supported by the German-Lab project\n   (http://www.german-lab.de/)\
    \ funded by the German Federal Ministry of\n   Education and Research (BMBF).\
    \  Alan Ford was previously supported by\n   Roke Manor Research and by Trilogy\
    \ (http://www.trilogy-project.org/),\n   a research project (ICT-216372) partially\
    \ funded by the European\n   Community under its Seventh Framework Program.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [1]   Postel, J., \"Transmission Control Protocol\"\
    , STD 7, RFC 793,\n         September 1981.\n   [2]   Braden, R., \"Requirements\
    \ for Internet Hosts - Communication\n         Layers\", STD 3, RFC 1122, October\
    \ 1989.\n   [3]   Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n\
    \         Levels\", BCP 14, RFC 2119, March 1997.\n   [4]   Ford, A., Raiciu,\
    \ C., Handley, M., Barre, S., and J. Iyengar,\n         \"Architectural Guidelines\
    \ for Multipath TCP Development\",\n         RFC 6182, March 2011.\n   [5]   Ford,\
    \ A., Raiciu, C., Handley, M., and O. Bonaventure, \"TCP\n         Extensions\
    \ for Multipath Operation with Multiple Addresses\",\n         RFC 6824, January\
    \ 2013.\n   [6]   Bagnulo, M., \"Threat Analysis for TCP Extensions for Multipath\n\
    \         Operation with Multiple Addresses\", RFC 6181, March 2011.\n   [7] \
    \  Raiciu, C., Handley, M., and D. Wischik, \"Coupled Congestion\n         Control\
    \ for Multipath Transport Protocols\", RFC 6356,\n         October 2011.\n   [8]\
    \   \"IEEE Standard for Information Technology -- Portable Operating\n       \
    \  System Interface (POSIX) Base Specifications, Issue 7\", IEEE\n         Std.\
    \ 1003.1-2008, 2008.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [9]   Stevens, W., Thomas, M., Nordmark, E.,\
    \ and T. Jinmei, \"Advanced\n         Sockets Application Program Interface (API)\
    \ for IPv6\",\n         RFC 3542, May 2003.\n   [10]  Chakrabarti, S. and E. Nordmark,\
    \ \"Extension to Sockets API for\n         Mobile IPv6\", RFC 4584, July 2006.\n\
    \   [11]  Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, \"Sockets\n    \
    \     Application Program Interface (API) for Multihoming Shim\",\n         RFC\
    \ 6316, July 2011.\n   [12]  Komu, M. and T. Henderson, \"Basic Socket Interface\
    \ Extensions\n         for the Host Identity Protocol (HIP)\", RFC 6317, July\
    \ 2011.\n   [13]  Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich,\n\
    \         \"Sockets API Extensions for the Stream Control Transmission\n     \
    \    Protocol (SCTP)\", RFC 6458, December 2011.\n   [14]  Blanchet, M. and P.\
    \ Seite, \"Multiple Interfaces and\n         Provisioning Domains Problem Statement\"\
    , RFC 6418,\n         November 2011.\n   [15]  Wasserman, M. and P. Seite, \"\
    Current Practices for Multiple-\n         Interface Hosts\", RFC 6419, November\
    \ 2011.\n   [16]  Wing, D. and A. Yourtchenko, \"Happy Eyeballs: Success with\n\
    \         Dual-Stack Hosts\", RFC 6555, April 2012.\n   [17]  Dierks, T. and E.\
    \ Rescorla, \"The Transport Layer Security (TLS)\n         Protocol Version 1.2\"\
    , RFC 5246, August 2008.\n   [18]  Cooper, D., Santesson, S., Farrell, S., Boeyen,\
    \ S., Housley,\n         R., and W. Polk, \"Internet X.509 Public Key Infrastructure\n\
    \         Certificate and Certificate Revocation List (CRL) Profile\",\n     \
    \    RFC 5280, May 2008.\n   [19]  Saint-Andre, P. and J. Hodges, \"Representation\
    \ and Verification\n         of Domain-Based Application Service Identity within\
    \ Internet\n         Public Key Infrastructure Using X.509 (PKIX) Certificates\
    \ in\n         the Context of Transport Layer Security (TLS)\", RFC 6125,\n  \
    \       March 2011.\n   [20]  Sarolahti, P., \"Multi-address Interface in the\
    \ Socket API\",\n         Work in Progress, March 2010.\n   [21]  Khalili, R.,\
    \ Gast, N., Popovic, M., and J. Le Boudec,\n         \"Performance Issues with\
    \ MPTCP\", Work in Progress,\n         February 2013.\n   [22]  Honda, M., Nishida,\
    \ Y., Raiciu, C., Greenhalgh, A., Handley,\n         M., and H. Tokuda, \"Is it\
    \ Still Possible to Extend TCP?\", Proc.\n         ACM Internet Measurement Conference\
    \ (IMC), November 2011.\n"
- title: Appendix A.  Requirements on a Future Advanced MPTCP API
  contents:
  - 'Appendix A.  Requirements on a Future Advanced MPTCP API

    '
- title: A.1.  Design Considerations
  contents:
  - "A.1.  Design Considerations\n   Multipath transport results in many degrees of\
    \ freedom.  The basic\n   MPTCP API only defines a minimum set of the API extensions\
    \ for the\n   interface between the MPTCP layer and applications, which does not\n\
    \   offer much control of the MPTCP implementation's behavior.  A future,\n  \
    \ advanced API could address further features of MPTCP and provide more\n   control.\n\
    \   Applications that use TCP may have different requirements on the\n   transport\
    \ layer.  While developers have become used to the\n   characteristics of regular\
    \ TCP, new opportunities created by MPTCP\n   could allow the service provided\
    \ to be optimized further.  An\n   advanced API could enable MPTCP-aware applications\
    \ to specify\n   preferences and control certain aspects of the behavior, in addition\n\
    \   to the simple control provided by the basic interface.  An advanced\n   API\
    \ could also address aspects that are completely out of scope of\n   the basic\
    \ API, for example, the question of whether a receiving\n   application could\
    \ influence the sending policy.  A better integration\n   with TLS could be another\
    \ relevant objective (cf. Section 6.1) that\n   requires further work.\n   Furthermore,\
    \ an advanced MPTCP API could be part of a new overall\n   interface between the\
    \ network stack and applications that addresses\n   other issues as well, such\
    \ as the split between identifiers and\n   locators.  An API that does not use\
    \ IP addresses (but instead uses,\n   e.g., the connectbyname() function) would\
    \ be useful for numerous\n   purposes, independent of MPTCP.\n   It has also been\
    \ suggested that a separate address family called\n   AF_MULTIPATH [20] be used.\
    \  This separate address family could be\n   used to exchange multiple addresses\
    \ between an application and the\n   standard sockets API, but it would be a more\
    \ fundamental change\n   compared to the basic API described in this document.\n\
    \   This appendix documents a list of potential usage scenarios and\n   requirements\
    \ for the advanced API.  The specification and\n   implementation of a corresponding\
    \ API are outside the scope of this\n   document.\n"
- title: A.2.  MPTCP Usage Scenarios and Application Requirements
  contents:
  - "A.2.  MPTCP Usage Scenarios and Application Requirements\n   There are different\
    \ MPTCP usage scenarios.  An application that\n   wishes to transmit bulk data\
    \ will want MPTCP to provide a high-\n   throughput service immediately, through\
    \ creating and maximizing\n   utilization of all available subflows.  This is\
    \ the default MPTCP use\n   case.\n   But at the other extreme, there are applications\
    \ that are highly\n   interactive but require only a small amount of throughput,\
    \ and these\n   are optimally served by low latency and jitter stability.  In\
    \ such a\n   situation, it would be preferable for the traffic to use only the\n\
    \   lowest-latency subflow (assuming it has sufficient capacity), maybe\n   with\
    \ one or two additional subflows for resilience and recovery\n   purposes.  The\
    \ key challenge for such a strategy is that the delay on\n   a path may fluctuate\
    \ significantly and that just always selecting the\n   path with the smallest\
    \ delay might result in instability.\n   The choice between bulk data transport\
    \ and latency-sensitive\n   transport affects the scheduler in terms of whether\
    \ traffic should\n   be, by default, sent on one subflow or across several subflows.\
    \  Even\n   if the total bandwidth required is less than that available on an\n\
    \   individual path, it is desirable to spread this load to reduce stress\n  \
    \ on potential bottlenecks, and this is why this method should be the\n   default\
    \ for bulk data transport.  However, that may not be optimal\n   for applications\
    \ that require latency/jitter stability.\n   In the case of the latter option,\
    \ a further question arises: Should\n   additional subflows be used whenever the\
    \ primary subflow is\n   overloaded, or only when the primary path fails (hot\
    \ standby)?  In\n   other words, is latency stability or bandwidth more important\
    \ to the\n   application?  This results in two different options: Firstly, there\n\
    \   is the single path that can overflow into an additional subflow; and\n   secondly,\
    \ there is the single path with hot standby, whereby an\n   application may want\
    \ an alternative backup subflow in order to\n   improve resilience.  In case data\
    \ delivery on the first subflow\n   fails, the data transport could immediately\
    \ be continued on the\n   second subflow, which is idle otherwise.\n   Yet another\
    \ complication is introduced with the potential that MPTCP\n   introduces for\
    \ changes in available bandwidth as the number of\n   available subflows changes.\
    \  Such jitter in bandwidth may prove\n   confusing for some applications, such\
    \ as video or audio streaming,\n   that dynamically adapt codecs based on available\
    \ bandwidth.  Such\n   applications may prefer MPTCP to attempt to provide a consistent\n\
    \   bandwidth as far as is possible and avoid maximizing the use of all\n   subflows.\n\
    \   A further, mostly orthogonal question is whether data should be\n   duplicated\
    \ over the different subflows, in particular if there is\n   spare capacity. \
    \ This could improve both the timeliness and\n   reliability of data delivery.\n\
    \   In summary, there are at least three possible performance objectives\n   for\
    \ multipath transport:\n   1.  High bandwidth\n   2.  Low latency and jitter stability\n\
    \   3.  High reliability\n   These are not necessarily disjoint, since there are\
    \ also broadband\n   interactive applications that require both high-speed bulk\
    \ data\n   traffic and a low latency and jitter.\n   In an advanced API, applications\
    \ could provide high-level guidance to\n   the MPTCP implementation concerning\
    \ these performance requirements,\n   for instance, which requirement is considered\
    \ to be the most\n   important.  The MPTCP stack would then use internal mechanisms\
    \ to\n   fulfill this abstract indication of a desired service, as far as\n  \
    \ possible.  This would affect the assignment of data (including\n   retransmissions)\
    \ to existing subflows (e.g., 'use all in parallel',\n   'use as overflow', 'hot\
    \ standby', 'duplicate traffic') as well as the\n   decisions regarding when to\
    \ set up additional subflows to which\n   addresses.  In both cases, different\
    \ policies can exist, which can be\n   expected to be implementation-specific.\n\
    \   Therefore, an advanced API could provide a mechanism for how\n   applications\
    \ can specify their high-level requirements in an\n   implementation-independent\
    \ way.  One possibility would be to select\n   one \"application profile\" out\
    \ of a number of choices that\n   characterize typical applications.  Yet, as\
    \ applications today do not\n   have to inform TCP about their communication requirements,\
    \ it\n   requires further studies as to whether such an approach would be\n  \
    \ realistic.\n   Of course, independent of an advanced API, such functionality\
    \ could\n   also partly be achieved by MPTCP-internal heuristics that infer some\n\
    \   application preferences, e.g., from existing socket options, such as\n   TCP_NODELAY.\
    \  Whether this would be reliable, and indeed appropriate,\n   is for further\
    \ study.\n"
- title: A.3.  Potential Requirements on an Advanced MPTCP API
  contents:
  - "A.3.  Potential Requirements on an Advanced MPTCP API\n   The following is a\
    \ list of potential requirements for an advanced\n   MPTCP API beyond the features\
    \ of the basic API.  It is included here\n   for information only:\n   REQ5: \
    \  An application should be able to establish MPTCP connections\n           without\
    \ using IP addresses as locators.\n   REQ6:   An application should be able to\
    \ obtain usage information and\n           statistics about all subflows (e.g.,\
    \ ratio of traffic sent\n           via this subflow).\n   REQ7:   An application\
    \ should be able to request a change in the\n           number of subflows in\
    \ use, thus triggering removal or\n           addition of subflows.  An even finer\
    \ control granularity\n           would be a request for the establishment of\
    \ a specific\n           subflow to a provided destination or a request for the\n\
    \           termination of a specified, existing subflow.\n   REQ8:   An application\
    \ should be able to inform the MPTCP\n           implementation about its high-level\
    \ performance requirements,\n           e.g., in the form of a profile.\n   REQ9:\
    \   An application should be able to indicate communication\n           characteristics,\
    \ e.g., the expected amount of data to be\n           sent, the expected duration\
    \ of the connection, or the\n           expected rate at which data is provided.\
    \  Applications may in\n           some cases be able to forecast such properties.\
    \  If so, such\n           information could be an additional input parameter\
    \ for\n           heuristics inside the MPTCP implementation, which could be\n\
    \           useful, for example, to decide when to set up additional\n       \
    \    subflows.\n   REQ10:  An application should be able to control the automatic\n\
    \           establishment/termination of subflows.  This would imply a\n     \
    \      selection among different heuristics of the path manager,\n           e.g.,\
    \ 'try as soon as possible', 'wait until there is a bunch\n           of data',\
    \ etc.\n   REQ11:  An application should be able to set preferred subflows or\n\
    \           subflow usage policies.  This would result in a selection\n      \
    \     among different configurations of the multipath scheduler.\n           For\
    \ instance, an application might want to use certain\n           subflows as backup\
    \ only.\n   REQ12:  An application should be able to control the level of\n  \
    \         redundancy by telling whether segments should be sent on more\n    \
    \       than one path in parallel.\n   REQ13:  An application should be able to\
    \ control the use of fate-\n           sharing of the MPTCP connection and the\
    \ initial subflow,\n           e.g., to overwrite system policies.\n   REQ14:\
    \  An application should be able to register for callbacks to be\n           informed\
    \ of changes to subflows on an MPTCP connection.  This\n           \"push\" interface\
    \ would allow the application to make timely\n           logging and configuration\
    \ changes, if required, and would\n           avoid frequent polling of information.\n\
    \   An advanced API fulfilling these requirements would allow application\n  \
    \ developers to more specifically configure MPTCP.  It could avoid\n   suboptimal\
    \ decisions of internal, implicit heuristics.  However, it\n   is unclear whether\
    \ all of these requirements would have a significant\n   benefit to applications,\
    \ since they are going above and beyond what\n   the existing API to regular TCP\
    \ provides.\n   A subset of these functions might also be implemented system-wide\
    \ or\n   by other configuration mechanisms.  These implementation details are\n\
    \   left for further study.\n"
- title: A.4.  Integration with the SCTP Sockets API
  contents:
  - "A.4.  Integration with the SCTP Sockets API\n   The advanced API may also integrate\
    \ or use the SCTP sockets API.  The\n   following functions that are defined for\
    \ SCTP have functionality\n   similar to the basic MPTCP API:\n   o  sctp_bindx()\n\
    \   o  sctp_connectx()\n   o  sctp_getladdrs()\n   o  sctp_getpaddrs()\n   o \
    \ sctp_freeladdrs()\n   o  sctp_freepaddrs()\n   The syntax and semantics of these\
    \ functions are described in [13].\n   A potential objective for the advanced\
    \ API is to provide a consistent\n   MPTCP and SCTP interface to the application.\
    \  This is left for\n   further study.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Michael Scharf\n   Alcatel-Lucent Bell Labs\n   Lorenzstrasse\
    \ 10\n   70435 Stuttgart\n   Germany\n   EMail: michael.scharf@alcatel-lucent.com\n\
    \   Alan Ford\n   Cisco\n   Ruscombe Business Park\n   Ruscombe, Berkshire  RG10\
    \ 9NN\n   UK\n   EMail: alanford@cisco.com\n"
