- title: __initial_text__
  contents:
  - "              Dynamic Delegation Discovery System (DDDS)\n           Part Four:\
    \ The Uniform Resource Identifiers (URI)\n                         Resolution\
    \ Application\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a specification for taking Uniform Resource\n\
    \   Identifiers (URI) and locating an authoritative server for\n   information\
    \ about that URI.  The method used to locate that\n   authoritative server is\
    \ the Dynamic Delegation Discovery System.\n   This document is part of a series\
    \ that is specified in \"Dynamic\n   Delegation Discovery System (DDDS) Part One:\
    \ The Comprehensive DDDS\"\n   (RFC 3401).  It is very important to note that\
    \ it is impossible to\n   read and understand any document in this series without\
    \ reading the\n   others.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.    Introduction . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.    Terminology  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.    The Distinction between URNs and URIs  . . . . . . .\
    \ . . . .  3\n   4.    The URI and URN Resolution Application Specifications \
    \ . . .  4\n   4.1   Application Unique String  . . . . . . . . . . . . . . .\
    \ . .  4\n   4.2   First Well Known Rule  . . . . . . . . . . . . . . . . . .\
    \ .  4\n   4.3   Flags  . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \  4\n   4.4   Services Parameters  . . . . . . . . . . . . . . . . . . . .  5\n\
    \   4.4.1 Services . . . . . . . . . . . . . . . . . . . . . . . . . .  6\n  \
    \ 4.4.2 protocols  . . . . . . . . . . . . . . . . . . . . . . . . .  6\n   4.4.3\
    \ Applicability of Services  . . . . . . . . . . . . . . . . .  7\n   4.5   Valid\
    \ Databases  . . . . . . . . . . . . . . . . . . . . . .  7\n   5.    Examples\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . .  8\n   5.1   An example\
    \ using a URN . . . . . . . . . . . . . . . . . . .  8\n   5.2   CID URI Scheme\
    \ Example . . . . . . . . . . . . . . . . . . .  9\n   5.3   Resolving an HTTP\
    \ URI Scheme . . . . . . . . . . . . . . . . 11\n   6.    Notes  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . 12\n   7.    IANA Considerations  .\
    \ . . . . . . . . . . . . . . . . . . . 12\n   8.    Security Considerations \
    \ . . . . . . . . . . . . . . . . . . 12\n   9.    Acknowledgments  . . . . .\
    \ . . . . . . . . . . . . . . . . . 13\n         References . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 13\n         Appendix A: Pseudo Code  . . .\
    \ . . . . . . . . . . . . . . . 15\n         Author's Address . . . . . . . .\
    \ . . . . . . . . . . . . . . 17\n         Full Copyright Statement . . . . .\
    \ . . . . . . . . . . . . . 18\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The Dynamic Delegation Discovery System (DDDS) is used to\
    \ implement\n   lazy binding of strings to data, in order to support dynamically\n\
    \   configured delegation systems.  The DDDS functions by mapping some\n   unique\
    \ string to data stored within a DDDS Database by iteratively\n   applying string\
    \ transformation rules until a terminal condition is\n   reached.\n   This document\
    \ describes a DDDS Application for resolving Uniform\n   Resource Identifiers\
    \ (URI).  It does not define the DDDS Algorithm or\n   a Database.  The entire\
    \ series of documents that do so are specified\n   in \"Dynamic Delegation Discovery\
    \ System (DDDS) Part One: The\n   Comprehensive DDDS\" (RFC 3401) [1].  It is\
    \ very important to note\n   that it is impossible to read and understand any\
    \ document in that\n   series without reading the related documents.\n   Uniform\
    \ Resource Identifiers (URI) have been a significant advance in\n   retrieving\
    \ Internet-accessible resources.  However, their brittle\n   nature over time\
    \ has been recognized for several years.  The Uniform\n   Resource Identifier\
    \ working group proposed the development of Uniform\n   Resource Names (URN) [8]\
    \ to serve as persistent, location-independent\n   identifiers for Internet resources\
    \ in order to overcome most of the\n   problems with URIs.  RFC 1737 [6] sets\
    \ forth requirements on URNs.\n   During the lifetime of the URI-WG, a number\
    \ of URN proposals were\n   generated.  The developers of several of those proposals\
    \ met in a\n   series of meetings, resulting in a compromise known as the Knoxville\n\
    \   framework.  The major principle behind the Knoxville framework is\n   that\
    \ the resolution system must be separate from the way names are\n   assigned.\
    \  This is in marked contrast to most URIs, which identify\n   the host to contact\
    \ and the protocol to use.  Readers are referred to\n   [7] for background on\
    \ the Knoxville framework and for additional\n   information on the context and\
    \ purpose of this proposal.\n   Separating the way names are resolved from the\
    \ way they are\n   constructed provides several benefits.  It allows multiple\
    \ naming\n   approaches and resolution approaches to compete, as it allows\n \
    \  different protocols and resolvers to be used.  There is just one\n   problem\
    \ with such a separation - how do we resolve a name when it\n   can't give us\
    \ directions to its resolver?\n   For the short term, the Domain Name System (DNS)\
    \ is the obvious\n   candidate for the resolution framework, since it is widely\
    \ deployed\n   and understood.  However, it is not appropriate to use DNS to\n\
    \   maintain information on a per-resource basis.  First of all, DNS was\n   never\
    \ intended to handle that many records.  Second, the limited\n   record size is\
    \ inappropriate for catalog information.  Third, domain\n   names are not appropriate\
    \ as URNs.\n   Therefore our approach is to use the DDDS to locate \"resolvers\"\
    \ that\n   can provide information on individual resources, potentially\n   including\
    \ the resource itself.  To accomplish this, we \"rewrite\" the\n   URI into a\
    \ Key following the rules found in the DDDS.  This document\n   describes URI\
    \ Resolution as an application of the DDDS and specifies\n   the use of at least\
    \ one Database based on DNS.\n"
- title: 2. Terminology
  contents:
  - "2. Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119.\n   All capitalized terms are taken from the vocabulary found in the DDDS\n\
    \   algorithm specification found in RFC 3403 [3].\n"
- title: 3. The Distinction Between URNs and URIs
  contents:
  - "3. The Distinction Between URNs and URIs\n   From the point of view of this system,\
    \ there is no theoretical\n   difference between resolving URIs in the general\
    \ case and URNs in the\n   specific case.  Operationally however, there is a difference\
    \ that\n   stems from URI resolution possibly not becoming of widespread use.\n\
    \   If URN resolution is collapsed into generic URI resolution, URNs may\n   suffer\
    \ by the lack of adoption of URI resolution.\n   The solution is to allow for\
    \ shortcutting for URN resolution.  In the\n   following specification generic\
    \ URI resolution starts by inserting\n   rules for known URI schemes into the\
    \ 'uri.arpa.' registry.  For the\n   'URN:' URI scheme, one of the rules found\
    \ in 'uri.arpa.' would be for\n   the 'urn' URI scheme.  This rule would simply\
    \ delegate to the\n   'urn.arpa.' zone for additional NAPTRs based on the URN\
    \ namespace.\n   Essentially, the URI Resolution Rewrite Rule for 'URN:' is the\
    \ URN\n   Resolution Application's First Well Known Rule.\n   Therefore, this\
    \ document specifies two DDDS Applications.  One is for\n   URI Resolution and\
    \ the other is for URN Resolution.  Both are\n   technically identical but by\
    \ separating the two URN Resolution can\n   still proceed without the dependency.\n"
- title: 4. The URI and URN Resolution Application Specifications
  contents:
  - "4. The URI and URN Resolution Application Specifications\n   This template defines\
    \ the URI and URN Resolution DDDS Application\n   according to the rules and requirements\
    \ found in [3].  The DDDS\n   database used by this Application is found in [4]\
    \ which is the\n   document that defines the Naming Authority Pointer (NAPTR)\
    \ DNS\n   Resource Record (RR) type.\n"
- title: 4.1 Application Unique String
  contents:
  - "4.1 Application Unique String\n   The Application Unique String is the URI or\
    \ URN for which an\n   authoritative server is being located.  This URI or URN\
    \ MUST be\n   canonicalized and hex encoded according to the \"absolute-uri\"\n\
    \   production found in the Collected ABNF from RFC 2396 [15].\n"
- title: 4.2 First Well Known Rule
  contents:
  - "4.2 First Well Known Rule\n   In the URI case, the first known key is created\
    \ by taking the URI\n   scheme.  In the URN case, the first known key is the Namespace\n\
    \   Identifier.  For example, the URI 'http://www.example.com/' would\n   have\
    \ a 'http' as its Key.  The URN 'urn:foo:foospace' would have\n   'foo' as its\
    \ first Key.\n"
- title: 4.3 Flags
  contents:
  - "4.3 Flags\n   At this time only four flags, \"S\", \"A\", \"U\", and \"P\", are\
    \ defined.\n   The \"S\", \"A\" and \"U\" flags are for a terminal lookup.  This\
    \ means\n   that the Rule is the last one and that the flag determines what the\n\
    \   next stage should be.  The \"S\" flag means that the output of this\n   Rule\
    \ is a domain-name for which one or more SRV [9] records exist.\n   See Section\
    \ 5 for additional information on how URI and URN\n   Resolution use the SRV record\
    \ type.  \"A\" means that the output of the\n   Rule is a domain-name and should\
    \ be used to lookup either A, AAAA, or\n   A6 records for that domain.  The \"\
    U\" flag means that the output of\n   the Rule is a URI [15].\n   The \"P\" flag\
    \ says that the remainder of the DDDS Algorithm is ignored\n   and that the rest\
    \ of the process is application specific and outside\n   the scope of this document.\
    \  An application can use the Protocol part\n   found in the Services field to\
    \ identify which Application specific\n   set of rules that should be followed\
    \ next.  The record that contains\n   the 'P' flag is the last record that is\
    \ interpreted by the rules in\n   this document.  One might think that this would\
    \ also make the \"P\"\n   flag an indicator of a terminal lookup but this would\
    \ be incorrect\n   since a \"terminal\" Rule is a DDDS concept and this flag indicates\n\
    \   that anything after this rule does not adhere to DDDS concepts at\n   all.\n\
    \   The remaining alphabetic flags are reserved for future versions of\n   this\
    \ specification.  The numeric flags may be used for local\n   experimentation.\
    \  The S, A, U and P flags are all mutually exclusive,\n   and resolution libraries\
    \ MAY signal an error if more than one is\n   given.  (Experimental code and code\
    \ for assisting in the creation of\n   Rewrite Rules would be more likely to signal\
    \ such an error than a\n   client such as a browser.)  It is anticipated that\
    \ multiple flags\n   will be allowed in the future, so implementers MUST NOT assume\
    \ that\n   the flags field can only contain 0 or 1 characters.  Finally, if a\n\
    \   client encounters a record with an unknown flag, it MUST ignore it\n   and\
    \ move to the next Rule.  This test takes precedence over any\n   ordering since\
    \ flags can control the interpretation placed on fields.\n   A novel flag might\
    \ change the interpretation of the regexp and/or\n   replacement fields such that\
    \ it is impossible to determine if a\n   record matched a given target.\n   The\
    \ \"S\", \"A\", and \"U\" flags are called 'terminal' flags since they\n   halt\
    \ the looping DDDS algorithm.  If those flags are not present,\n   clients may\
    \ assume that another Rule exists at the Key produced by\n   the current Rewrite\
    \ Rule.\n"
- title: 4.4 Services Parameters
  contents:
  - "4.4 Services Parameters\n   Service Parameters for this Application take the\
    \ form of a string of\n   characters that follow this ABNF:\n      service_field\
    \ = [ [protocol] *(\"+\" rs)]\n      protocol      = ALPHA *31ALPHANUM\n     \
    \ rs            = ALPHA *31ALPHANUM\n      ; The protocol and rs fields are limited\
    \ to 32\n      ; characters and must start with an alphabetic.\n   In other words,\
    \ an optional protocol specification followed by 0 or\n   more resolution services.\
    \  Each resolution service is indicated by an\n   initial '+' character.\n   The\
    \ empty string is also valid.  This will typically be seen at the\n   beginning\
    \ of a series of Rules, when it is impossible to know what\n   services and protocols\
    \ will be offered at the end of a particular\n   delegation path.\n"
- title: 4.4.1 Services
  contents:
  - "4.4.1 Services\n   The service identifiers that make up the 'rs' production are\
    \ generic\n   for both URI and URN resolution since the input value types itself\n\
    \   based on the URI scheme.  The list of valid services are defined in\n   [11].\n\
    \   Examples of some of these services are:\n   I2L:  given a URI return one URI\
    \ that identifies a location where the\n         original URI can be found.\n\
    \   I2Ls: given a URI return one or more URIs that identify multiple\n       \
    \  locations where the original URI can be found.\n   I2R:  given a URI return\
    \ one instance of the resource identified by\n         that URI.\n   I2Rs: given\
    \ a URI return one or more instances of the resources\n         identified by\
    \ that URI.\n   I2C:  given a URI return one instance of a description of that\n\
    \         resource.\n   I2N:  given a URI return one URN that names the resource\
    \ (Caution:\n         equality with respect to URNs is non-trivial.  See [6] for\n\
    \         examples of why.)\n"
- title: 4.4.2 Protocols
  contents:
  - "4.4.2 Protocols\n   The protocol identifiers that are valid for the 'protocol'\
    \ production\n   MUST be defined by documents that are specific to URI resolution.\
    \  At\n   present the THTTP [10] protocol is the only such specification.\n  \
    \ It is extremely important to realize that simply specifying any\n   protocol\
    \ in the services field is insufficient since there are\n   additional semantics\
    \ surrounding URI resolution that are not defined\n   within the protocols.  For\
    \ example, if Z39.50 were to be specified as\n   a valid protocol it would have\
    \ to additionally define how it would\n   encode requests for specific services,\
    \ how the URI is encoded, and\n   what information is returned.\n"
- title: 4.4.3 Applicability of Services
  contents:
  - "4.4.3 Applicability of Services\n   Since it is possible for there to be a complex\
    \ set of possible\n   protocols and services a client application may often need\
    \ to apply a\n   more complex decision making process to a set of records than\
    \ simply\n   matching on an ordered list of protocols.  For example, if there\
    \ are\n   4 rules that are applicable the last one may have a more desirable\n\
    \   Service field than the first.  But since the client may be satisfied\n   by\
    \ the first it will never know about the 4th one which may be\n   'better'.\n\
    \   To mitigate this the client may want to slightly modify the DDDS\n   algorithm\
    \ (for this application only!) in order to determine if more\n   applicable protocols/services\
    \ exist.  This can safely be done for\n   this application by using a more complex\
    \ interaction between steps 3\n   and 4 of the DDDS algorithm in order to find\
    \ the optimal path to\n   follow.  For example, once a client has found a rule\
    \ who's\n   Substitution Expression produces a result and who's Service\n   description\
    \ is acceptable, it may make note of this but continue to\n   look at further\
    \ rules that apply (all the while adhering to the\n   Order!) in order to find\
    \ a better one.  If none are found it can use\n   the one it made note of.\n \
    \  Keep in mind that in order for this to remain safe, the input to step\n   3\
    \ and the output of step 4 MUST be identical to the basic algorithm.\n   The client\
    \ software MUST NOT attempt to do this optimization outside\n   a specific set\
    \ of Rewrite Rules (i.e., across delegation paths).\n"
- title: 4.5 Valid Databases
  contents:
  - "4.5 Valid Databases\n   At present only one DDDS Database is specified for this\
    \ Application.\n   \"Dynamic Delegation Discovery System (DDDS) Part Three: The\
    \ Domain\n   Name System (DNS) Database\" (RFC 3403) [4] specifies a DDDS Database\n\
    \   that uses the NAPTR DNS resource record to contain the rewrite rules.\n  \
    \ The Keys for this database are encoded as domain-names.\n   The output of the\
    \ First Well Known Rule for the URI Resolution\n   Application is the URI's scheme.\
    \  In order to convert this to a\n   unique key in this Database the string '.uri.arpa.'\
    \ is appended to\n   the end.  This domain-name is used to request NAPTR records\
    \ which\n   produces new keys in the form of domain-names.\n   The output of the\
    \ First Well Known Rule of the URN Resolution\n   Application is the URN's namespace\
    \ id.  In order to convert this to a\n   unique key in this Database the string\
    \ '.urn.arpa.' is appended to\n   the end.  This domain-name is used to request\
    \ NAPTR records which\n   produces new keys in the form of domain-names.\n   DNS\
    \ servers MAY interpret Flag values and use that information to\n   include appropriate\
    \ SRV and A records in the Additional Information\n   portion of the DNS packet.\
    \  Clients are encouraged to check for\n   additional information but are not\
    \ required to do so.  See the\n   Additional Information Processing section of\
    \ RFC 3404 for more\n   information on NAPTR records and the Additional Information\
    \ section\n   of a DNS response packet.\n   The character set used to encode the\
    \ substitution expression is\n   UTF-8.  The allowed input characters are all\
    \ those characters that\n   are allowed anywhere in a URI.  The characters allowed\
    \ to be in a Key\n   are those that are currently defined for DNS domain-names.\
    \  The \"i\"\n   flag to the substitution expression is used to denote that, where\n\
    \   appropriate for the code points in question, any matches should be\n   done\
    \ in a case-insensitive way.\n"
- title: 5. Examples
  contents:
  - '5. Examples

    '
- title: 5.1 An Example Using a URN
  contents:
  - "5.1 An Example Using a URN\n   Consider a URN that uses the hypothetical FOO\
    \ namespace.  FOO numbers\n   are identifiers for approximately 30 million registered\
    \ businesses\n   around the world, assigned and maintained by Fred, Otto and Orvil,\n\
    \   Inc.  The URN might look like:\n      urn:foo:002372413:annual-report-1997\n\
    \   The first step in the resolution process is to find out about the FOO\n  \
    \ namespace.  The namespace identifier [8], \"foo\", is extracted from\n   the\
    \ URN and prepended to '.urn.arpa.', producing 'foo.urn.arpa.'.\n   The DNS is\
    \ queried for NAPTR records for this domain which produces\n   the following results:\n"
- title: foo.urn.arpa.
  contents:
  - 'foo.urn.arpa.

    '
- title: ;;      order pref flags service          regexp        replacement
  contents:
  - ';;      order pref flags service          regexp        replacement

    '
- title: IN NAPTR 100  10  "s" "foolink+I2L+I2C"  ""   foolink.udp.example.com.
  contents:
  - 'IN NAPTR 100  10  "s" "foolink+I2L+I2C"  ""   foolink.udp.example.com.

    '
- title: IN NAPTR 100  20  "s" "rcds+I2C"          ""  rcds.udp.example.com.
  contents:
  - 'IN NAPTR 100  20  "s" "rcds+I2C"          ""  rcds.udp.example.com.

    '
- title: IN NAPTR 100  30  "s" "thttp+I2L+I2C+I2R" ""  thttp.tcp.example.com.
  contents:
  - "IN NAPTR 100  30  \"s\" \"thttp+I2L+I2C+I2R\" \"\"  thttp.tcp.example.com.\n\
    \   The order field contains equal values, indicating that no order has\n   to\
    \ be followed.  The preference field indicates that the provider\n   would like\
    \ clients to use the special 'foolink' protocol, followed by\n   the RCDS protocol,\
    \ and that THTTP is offered as a last resort.  All\n   the records specify the\
    \ \"s\" flag which means that the record is\n   terminal and that the next step\
    \ is to retrieve an SRV record from DNS\n   for the given domain-name.\n   The\
    \ service fields say that if we speak of foolink, we will be able\n   to issue\
    \ either the I2L, I2C or I2R requests to obtain a URI or ask\n   some complicated\
    \ questions about the resource.  The Resource\n   Cataloging and Distribution\
    \ Service  (RCDS) [12] could be used to get\n   some metadata for the resource,\
    \ while THTTP could be used to get a\n   URI for the current location of the resource.\n\
    \   Assuming our client does not know the foolink protocol but does know\n   the\
    \ RCDS protocol, our next action is to lookup SRV RRs for\n   rcds.udp.example.com,\
    \ which will tell us hosts that can provide the\n   necessary resolution service.\
    \  That lookup might return:\n      ;;                          Pref Weight Port\
    \ Target\n      rcds.udp.example.com  IN SRV 0    0    1000 deffoo.example.com.\n\
    \                            IN SRV 0    0    1000 dbexample.com.au.\n       \
    \                     IN SRV 0    0    1000 ukexample.com.uk.\n   telling us three\
    \ hosts that could actually do the resolution, and\n   giving us the port we should\
    \ use to talk to their RCDS server.  (The\n   reader is referred to the SRV specification\
    \ [9] for the\n   interpretation of the fields above.)\n   There is opportunity\
    \ for significant optimization here.  RFC 3404\n   defines that Additional Information\
    \ section may be available.  In\n   this case the the SRV records may be returned\
    \ as additional\n   information for terminal NAPTRs lookups (as well as the A\
    \ records for\n   those SRVs).  This is a significant optimization.  In conjunction\n\
    \   with a long TTL for *.urn.arpa. records, the average number of probes\n  \
    \ to DNS for resolving most URIs would approach one.\n   Note that the example\
    \ NAPTR records above are intended to represent\n   the result of a NAPTR lookup\
    \ using some client software like\n   nslookup; zone administrators should consult\
    \ the documentation\n   accompanying their domain name servers to verify the precise\
    \ syntax\n   they should use for zone files.\n   Also note that there could have\
    \ been an additional first step where\n   the URN was resolved as a generic URI\
    \ by looking up urn.uri.arpa.\n   The resulting rule would have specified that\
    \ the NID be extracted\n   from the URN and '.urn.arpa.' appended to it resulting\
    \ in the new key\n   'foo.urn.arpa.' which is the first step from above.\n"
- title: 5.2 CID URI Scheme Example
  contents:
  - "5.2 CID URI Scheme Example\n   Consider a URI scheme based on MIME Content-Ids.\
    \  The URI might look\n   like this:\n      cid:199606121851.1@bar.example.com\n\
    \   (Note that this example is chosen for pedagogical purposes, and does\n   not\
    \ conform to the CID URI scheme.)\n   The first step in the resolution process\
    \ is to find out about the CID\n   scheme.  The scheme is extracted from the URI,\
    \ prepended to\n   '.uri.arpa.', and the NAPTR for 'cid.uri.arpa.' looked up in\
    \ the DNS.\n   It might return records of the form:\n"
- title: cid.uri.arpa.
  contents:
  - 'cid.uri.arpa.

    '
- title: ;;       order pref flags service        regexp           replacement
  contents:
  - ';;       order pref flags service        regexp           replacement

    '
- title: IN NAPTR 100   10   ""    ""  "!^cid:.+@([^\.]+\.)(.*)$!\2!i"    .
  contents:
  - "IN NAPTR 100   10   \"\"    \"\"  \"!^cid:.+@([^\\.]+\\.)(.*)$!\\2!i\"    .\n\
    \   Since there is only one record, ordering the responses is not a\n   problem.\
    \  The replacement field is empty, so the pattern provided in\n   the regexp field\
    \ is used.  We apply that regexp to the entire URI to\n   see if it matches, which\
    \ it does.  The \\2 part of the substitution\n   expression returns the string\
    \ \"example.com\".  Since the flags field\n   is empty, the lookup is not terminal\
    \ and our next probe to DNS is for\n   more NAPTR records where the new domain\
    \ is 'example.com'.\n   Note that the rule does not extract the full domain name\
    \ from the\n   CID, instead it assumes the CID comes from a host and extracts\
    \ its\n   domain.  While all hosts, such as 'bar', could have their very own\n\
    \   NAPTR, maintaining those records for all the machines at a site could\n  \
    \ be an intolerable burden.  Wildcards are not appropriate here since\n   they\
    \ only return results when there is no exactly matching names\n   already in the\
    \ system.\n   The record returned from the query on \"example.com\" might look\
    \ like:\n"
- title: example.com.
  contents:
  - 'example.com.

    '
- title: ;;      order pref flags service           regexp  replacement
  contents:
  - ';;      order pref flags service           regexp  replacement

    '
- title: IN NAPTR 100 50 "s" "z3950+I2L+I2C"     ""    z3950.tcp.example.com.
  contents:
  - 'IN NAPTR 100 50 "s" "z3950+I2L+I2C"     ""    z3950.tcp.example.com.

    '
- title: IN NAPTR 100 50 "s" "rescap+I2C"        ""    rescap.udp.example.com.
  contents:
  - 'IN NAPTR 100 50 "s" "rescap+I2C"        ""    rescap.udp.example.com.

    '
- title: IN NAPTR 100 50 "s" "thttp+I2L+I2C+I2R" ""    thttp.tcp.example.com.
  contents:
  - "IN NAPTR 100 50 \"s\" \"thttp+I2L+I2C+I2R\" \"\"    thttp.tcp.example.com.\n\
    \   Continuing with the example, note that the values of the order fields\n  \
    \ are equal for all records, so the client is free to pick any record.\n   The\
    \ Application defines the flag 's' to mean a terminal lookup and\n   that the\
    \ output of the rewrite will be a domain-name for which an SRV\n   record should\
    \ be queried.  Once the client has done that, it has the\n   following information:\
    \ the host, port, the protocol, and the services\n   available via that protocol.\
    \  Given these bits of information the\n   client has enough to be able to contact\
    \ that server and ask it\n   questions about the cid URI.\n   Recall that the\
    \ regular expression used \\2 to extract a domain name\n   from the CID, and \\\
    .  for matching the literal '.' characters\n   separating the domain name components.\
    \  Since '\\' is the escape\n   character, literal occurrences of a backslash\
    \ must be escaped by\n   another backslash.  For the case of the cid.uri.arpa\
    \ record above,\n   the regular expression entered into the master file should\
    \ be\n   \"!^cid:.+@([^\\\\.]+\\\\.)(.*)$!\\\\2!i\".  When the client code actually\n\
    \   receives the record, the pattern will have been converted to\n   \"!^cid:.+@([^\\\
    .]+\\.)(.*)$!\\2!i\".\n"
- title: 5.3 Resolving an HTTP URI Scheme
  contents:
  - "5.3 Resolving an HTTP URI Scheme\n   Even if URN systems were in place now, there\
    \ would still be a\n   tremendous number of host based URIs.  It should be possible\
    \ to\n   develop a URI resolution system that can also provide location\n   independence\
    \ for those URIs.\n   Assume we have the URI for a very popular piece of software\
    \ that the\n   publisher wishes to mirror at multiple sites around the world:\n\
    \   http://www.example.com/software/latest-beta.exe\n   We extract the prefix,\
    \ \"http\", and lookup NAPTR records for\n   'http.uri.arpa.'.  This might return\
    \ a record of the form:\n   http.uri.arpa. IN NAPTR\n   ;;  order   pref flags\
    \ service      regexp             replacement\n        100     90   \"\"     \
    \ \"\"   \"!^http://([^/:]+)!1!i\"       .\n   This expression returns everything\
    \ after the first double slash and\n   before the next slash or colon.  (We use\
    \ the '!' character to delimit\n   the parts of the substitution expression. \
    \ Otherwise we would have to\n   use backslashes to escape the forward slashes,\
    \ and would have a\n   regexp in the zone file that looked like this:\n   \"/^http:\\\
    \\/\\\\/([^\\\\/:]+)/\\\\1/i\").\n   Applying this pattern to the URI extracts\
    \ \"www.example.com\".  Looking\n   up NAPTR records for that might return:\n\
    \   www.example.com.\n   ;;       order pref flags   service  regexp     replacement\n\
    \    IN NAPTR 100  100  \"s\"   \"thttp+L2R\"   \"\"    thttp.example.com.\n \
    \   IN NAPTR 100  100  \"s\"   \"ftp+L2R\"    \"\"     ftp.example.com.\n   Looking\
    \ up SRV records for thttp.example.com would return information\n   on the hosts\
    \ that example.com has designated to be its mirror sites.\n   The client can then\
    \ pick one for the user.\n"
- title: 6. Notes
  contents:
  - "6. Notes\n   o  Registration procedures for the 'urn.arpa.' and 'uri.arpa.' DNS\n\
    \      zones are specified in \"Dynamic Delegation Discovery System (DDDS)\n \
    \     Part Five: URI.ARPA Assignment Procedures\" (RFC 3405 [5].\n   o  If a record\
    \ at a particular order matches the URI, but the client\n      doesn't know the\
    \ specified protocol and service, the client SHOULD\n      continue to examine\
    \ records that have the same order.  The client\n      MUST NOT consider records\
    \ with a higher value of order.  This is\n      necessary to make delegation of\
    \ portions of the namespace work.\n      The order field is what lets site administrators\
    \ say \"all requests\n      for URIs matching pattern x go to server 1, all others\
    \ go to\n      server 2\".\n   o  Note that SRV RRs impose additional requirements\
    \ on clients.\n"
- title: 7. IANA Considerations
  contents:
  - "7. IANA Considerations\n   The use of the \"urn.arpa.\" and \"uri.arpa.\" zones\
    \ requires\n   registration policies and procedures to be followed and for the\n\
    \   operation of those DNS zones to be maintained.  These policies and\n   procedures\
    \ are spelled out in a \"Dynamic Delegation Discovery System\n   (DDDS) Part Five:\
    \ URI.ARPA Assignment Procedures (RFC 3405)\" [5].\n   The operation of those\
    \ zones imposes operational and administrative\n   responsibilities on the IANA.\n\
    \   The registration method used for values in the Services and Flags\n   fields\
    \ is for a specification to be approved by the IESG and\n   published as either\
    \ an Informational or standards track RFC.\n   The registration policies for URIs\
    \ is found in RFC 2717 [17].  URN\n   NID registration policies are found in RFC\
    \ 2611 [16].\n"
- title: 8. Security Considerations
  contents:
  - "8. Security Considerations\n   The use of \"urn.arpa.\" and \"uri.arpa.\" as\
    \ the registry for namespaces\n   is subject to denial of service attacks, as\
    \ well as other DNS\n   spoofing attacks.  The interactions with DNSSEC are currently\
    \ being\n   studied.  It is expected that NAPTR records will be signed with SIG\n\
    \   records once the DNSSEC work is deployed.\n   The rewrite rules make identifiers\
    \ from other namespaces subject to\n   the same attacks as normal domain names.\
    \  Since they have not been\n   easily resolvable before, this may or may not\
    \ be considered a\n   problem.\n   Regular expressions should be checked for sanity,\
    \ not blindly passed\n   to something like PERL.\n   This document has discussed\
    \ a way of locating a resolver, but has not\n   discussed any detail of how the\
    \ communication with the resolver takes\n   place.  There are significant security\
    \ considerations attached to the\n   communication with a resolver.  Those considerations\
    \ are outside the\n   scope of this document, and must be addressed by the specifications\n\
    \   for particular resolver communication protocols.\n"
- title: 9. Acknowledgments
  contents:
  - "9. Acknowledgments\n   The editors would like to thank Keith Moore for all his\
    \ consultations\n   during the development of this document.  We would also like\
    \ to thank\n   Paul Vixie for his assistance in debugging our implementation,\
    \ and\n   his answers on our questions.  Finally, we would like to acknowledge\n\
    \   our enormous intellectual debt to the participants in the Knoxville\n   series\
    \ of meetings, as well as to the participants in the URI and URN\n   working groups.\n\
    \   Specific recognition is given to Ron Daniel who was co-author on the\n   original\
    \ versions of these documents.  His early implementations and\n   clarity of thinking\
    \ was invaluable in clearing up many of the\n   potential boundary cases.\n"
- title: References
  contents:
  - "References\n   [1]  Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\
    \ Part\n        One: The Comprehensive DDDS\", RFC 3401, October 2002.\n   [2]\
    \  Mealling, M., \"Dynamic Delegation Discovery System (DDDS) Part\n        Two:\
    \ The Algorithm\", RFC 3402, October 2002.\n   [3]  Mealling, M., \"Dynamic Delegation\
    \ Discovery System (DDDS) Part\n        Three: The Domain Name System (DNS) Database\"\
    , RFC 3403, October\n        2002.\n   [4]  Mealling, M., \"Dynamic Delegation\
    \ Discovery System (DDDS) Part\n        Four: The Uniform Resource Identifiers\
    \ (URI) Resolution\n        Application\", RFC 3404, October 2002.\n   [5]  Mealling,\
    \ M., \"Dynamic Delegation Discovery System (DDDS) Part\n        Five: URI.ARPA\
    \ Assignment Procedures\", RFC 3405y, October 2002.\n   [6]  Sollins, K. and L.\
    \ Masinter, \"Functional Requirements for\n        Uniform Resource Names\", RFC\
    \ 1737, December 1994.\n   [7]  Arms, B., \"The URN Implementors, Uniform Resource\
    \ Names: A\n        Progress Report\", D-Lib Magazine, February 1996.\n   [8]\
    \  Moats, R., \"URN Syntax\", RFC 2141, May 1997.\n   [9]  Gulbrandsen, A., Vixie,\
    \ P. and L. Esibov, \"A DNS RR for\n        specifying the location of services\
    \ (DNS SRV)\", RFC 2782,\n        February 2000.\n   [10] Daniel, R., \"A Trivial\
    \ Convention for using HTTP in URN\n        Resolution\", RFC 2169, June 1997.\n\
    \   [11] Mealling, M., \"URI Resolution Services Necessary for URN\n        Resolution\"\
    , RFC 2483, January 1999.\n   [12] Moore, K., Browne, S., Cox, J. and J. Gettler,\
    \ \"Resource\n        Cataloging and Distribution System\", Technical Report CS-97-346,\n\
    \        December 1996.\n   [13] Sollins, K., \"Architectural Principles of Uniform\
    \ Resource Name\n        Resolution\", RFC 2276, January 1998.\n   [14] Daniel,\
    \ R. and M. Mealling, \"Resolution of Uniform Resource\n        Identifiers using\
    \ the Domain Name System\", RFC 2168, June 1997.\n   [15] Berners-Lee, T., Fielding,\
    \ R. and L. Masinter, \"Uniform Resource\n        Identifiers (URI): Generic Syntax\"\
    , RFC 2396, August 1998.\n   [16] Daigle, L., van Gulik, D., Iannella, R. and\
    \ P. Falstrom, \"URN\n        Namespace Definition Mechanisms\", RFC 2611, BCP\
    \ 33, June 1999.\n   [17] Petke, R. and I. King, \"Registration Procedures for\
    \ URL Scheme\n        Names\", RFC 2717, BCP 35, November 1999.\n   [18] Mealling,\
    \ M. and R. Daniel, \"The Naming Authority Pointer\n        (NAPTR) DNS Resource\
    \ Record\", RFC 2915, August 2000.\n"
- title: Appendix A. Pseudo Code
  contents:
  - "Appendix A. Pseudo Code\n   For the edification of implementers, pseudocode for\
    \ a client routine\n   using NAPTRs is given below.  This code is provided merely\
    \ as a\n   convenience, it does not have any weight as a standard way to process\n\
    \   NAPTR records.  Also, as is the case with pseudocode, it has never\n   been\
    \ executed and may contain logical errors.  You have been warned.\n   //\n   //\
    \ findResolver(URN)\n   // Given a URN, find a host that can resolve it.\n   //\n\
    \   findResolver(string URN) {\n     // prepend prefix to \".urn.arpa.\"\n   \
    \  sprintf(key, \"%s.urn.arpa.\", extractNS(URN));\n     do {\n       rewrite_flag\
    \ = false;\n       terminal = false;\n       if (key has been seen) {\n      \
    \   quit with a loop detected error\n       }\n       add key to list of \"seens\"\
    \n       records = lookup(type=NAPTR, key); // get all NAPTR RRs for 'key'\n \
    \      discard any records with an unknown value in the \"flags\" field.\n   \
    \    sort NAPTR records by \"order\" field and \"preference\" field\n        \
    \   (with \"order\" being more significant than \"preference\").\n       n_naptrs\
    \ = number of NAPTR records in response.\n       curr_order = records[0].order;\n\
    \       max_order = records[n_naptrs-1].order;\n       // Process current batch\
    \ of NAPTRs according to \"order\" field.\n       for (j=0; j < n_naptrs && records[j].order\
    \ <= max_order; j++) {\n         if (unknown_flag) // skip this record and go\
    \ to next one\n            continue;\n         newkey = rewrite(URN, naptr[j].replacement,\
    \ naptr[j].regexp);\n         if (!newkey) // Skip to next record if the rewrite\
    \ didn't\n            match continue;\n         // We did do a rewrite, shrink\
    \ max_order to current value\n         // so that delegation works properly\n\
    \         max_order = naptr[j].order;\n         // Will we know what to do with\
    \ the protocol and services\n         // specified in the NAPTR? If not, try next\
    \ record.\n         if(!isKnownProto(naptr[j].services)) {\n           continue;\n\
    \         }\n         if(!isKnownService(naptr[j].services)) {\n           continue;\n\
    \         }\n         // At this point we have a successful rewrite and we will\n\
    \         // know how to speak the protocol and request a known\n         // resolution\
    \ service. Before we do the next lookup, check\n         // the flags to see if\
    \ we're done.\n         // Note: it is possible to rewrite this so that this valid\n\
    \         // record could be noted as such but continue on in order\n        \
    \        // to find a 'better' record. But that code would be to\n         //\
    \ voluminous and application specific to be illustrative.\n         if (strcasecmp(flags,\
    \ \"S\")\n          || strcasecmp(flags, \"P\"))\n          || strcasecmp(flags,\
    \ \"A\")) {\n            terminal = true;\n            services = naptr[j].services;\n\
    \            addnl = any SRV and/or A records returned as additional\n       \
    \             info for naptr[j].\n         }\n         key = newkey;\n       \
    \  rewriteflag = true;\n         break;\n       }\n     } while (rewriteflag &&\
    \ !terminal);\n     // Did we not find our way to a resolver?\n     if (!rewrite_flag)\
    \ {\n        report an error\n        return NULL;\n     }\n     // Leave rest\
    \ to another protocol?\n     if (strcasecmp(flags, \"P\")) {\n        return key\
    \ as host to talk to;\n     }\n     // If not, keep plugging\n     if (!addnl)\
    \ { // No SRVs came in as additional info, look them up\n       srvs = lookup(type=SRV,\
    \ key);\n     }\n     sort SRV records by preference, weight, ...\n     for each\
    \ (SRV record) { // in order of preference\n       try contacting srv[j].target\
    \ using the protocol and one of the\n           resolution service requests from\
    \ the \"services\" field of the\n           last NAPTR record.\n       if (successful)\n\
    \         return (target, protocol, service);\n         // Actually we would probably\
    \ return a result, but this\n         // code was supposed to just tell us a good\
    \ host to talk to.\n     }\n     die with an \"unable to find a host\" error;\n\
    \   }\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Michael Mealling\n   VeriSign\n   21345 Ridgetop Circle\n\
    \   Sterling, VA  20166\n   US\n   EMail: michael@neonym.net\n   URI:   http://www.verisignlabs.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
