- title: __initial_text__
  contents:
  - '              The Constrained Application Protocol (CoAP)

    '
- title: Abstract
  contents:
  - "Abstract\n   The Constrained Application Protocol (CoAP) is a specialized web\n\
    \   transfer protocol for use with constrained nodes and constrained\n   (e.g.,\
    \ low-power, lossy) networks.  The nodes often have 8-bit\n   microcontrollers\
    \ with small amounts of ROM and RAM, while constrained\n   networks such as IPv6\
    \ over Low-Power Wireless Personal Area Networks\n   (6LoWPANs) often have high\
    \ packet error rates and a typical\n   throughput of 10s of kbit/s.  The protocol\
    \ is designed for machine-\n   to-machine (M2M) applications such as smart energy\
    \ and building\n   automation.\n   CoAP provides a request/response interaction\
    \ model between\n   application endpoints, supports built-in discovery of services\
    \ and\n   resources, and includes key concepts of the Web such as URIs and\n \
    \  Internet media types.  CoAP is designed to easily interface with HTTP\n   for\
    \ integration with the Web while meeting specialized requirements\n   such as\
    \ multicast support, very low overhead, and simplicity for\n   constrained environments.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7252.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   5\n     1.1.  Features  . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n     1.2.  Terminology . . . . . . . . . . . . . . . . . . . .\
    \ . . .   6\n   2.  Constrained Application Protocol  . . . . . . . . . . . .\
    \ . .  10\n     2.1.  Messaging Model . . . . . . . . . . . . . . . . . . . .\
    \ .  11\n     2.2.  Request/Response Model  . . . . . . . . . . . . . . . . .\
    \  12\n     2.3.  Intermediaries and Caching  . . . . . . . . . . . . . . .  15\n\
    \     2.4.  Resource Discovery  . . . . . . . . . . . . . . . . . . .  15\n  \
    \ 3.  Message Format  . . . . . . . . . . . . . . . . . . . . . . .  15\n    \
    \ 3.1.  Option Format . . . . . . . . . . . . . . . . . . . . . .  17\n     3.2.\
    \  Option Value Formats  . . . . . . . . . . . . . . . . . .  19\n   4.  Message\
    \ Transmission  . . . . . . . . . . . . . . . . . . . .  20\n     4.1.  Messages\
    \ and Endpoints  . . . . . . . . . . . . . . . . .  20\n     4.2.  Messages Transmitted\
    \ Reliably . . . . . . . . . . . . . .  21\n     4.3.  Messages Transmitted without\
    \ Reliability  . . . . . . . .  23\n     4.4.  Message Correlation . . . . . .\
    \ . . . . . . . . . . . . .  24\n     4.5.  Message Deduplication . . . . . .\
    \ . . . . . . . . . . . .  24\n     4.6.  Message Size  . . . . . . . . . . .\
    \ . . . . . . . . . . .  25\n     4.7.  Congestion Control  . . . . . . . . .\
    \ . . . . . . . . . .  26\n     4.8.  Transmission Parameters . . . . . . . .\
    \ . . . . . . . . .  27\n       4.8.1.  Changing the Parameters . . . . . . .\
    \ . . . . . . . .  27\n       4.8.2.  Time Values Derived from Transmission Parameters\
    \  . .  28\n   5.  Request/Response Semantics  . . . . . . . . . . . . . . . .\
    \ .  31\n     5.1.  Requests  . . . . . . . . . . . . . . . . . . . . . . . .\
    \  31\n     5.2.  Responses . . . . . . . . . . . . . . . . . . . . . . . .  31\n\
    \       5.2.1.  Piggybacked . . . . . . . . . . . . . . . . . . . . .  33\n  \
    \     5.2.2.  Separate  . . . . . . . . . . . . . . . . . . . . . .  33\n    \
    \   5.2.3.  Non-confirmable . . . . . . . . . . . . . . . . . . .  34\n     5.3.\
    \  Request/Response Matching . . . . . . . . . . . . . . . .  34\n       5.3.1.\
    \  Token . . . . . . . . . . . . . . . . . . . . . . . .  34\n       5.3.2.  Request/Response\
    \ Matching Rules . . . . . . . . . . .  35\n     5.4.  Options . . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  36\n       5.4.1.  Critical/Elective . .\
    \ . . . . . . . . . . . . . . . .  37\n       5.4.2.  Proxy Unsafe or Safe-to-Forward\
    \ and NoCacheKey  . . .  38\n       5.4.3.  Length  . . . . . . . . . . . . .\
    \ . . . . . . . . . .  38\n       5.4.4.  Default Values  . . . . . . . . . .\
    \ . . . . . . . . .  38\n       5.4.5.  Repeatable Options  . . . . . . . . .\
    \ . . . . . . . .  39\n       5.4.6.  Option Numbers  . . . . . . . . . . . .\
    \ . . . . . . .  39\n     5.5.  Payloads and Representations  . . . . . . . .\
    \ . . . . . .  40\n       5.5.1.  Representation  . . . . . . . . . . . . . .\
    \ . . . . .  40\n       5.5.2.  Diagnostic Payload  . . . . . . . . . . . . .\
    \ . . . .  41\n       5.5.3.  Selected Representation . . . . . . . . . . . .\
    \ . . .  41\n       5.5.4.  Content Negotiation . . . . . . . . . . . . . . .\
    \ . .  41\n     5.6.  Caching . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  42\n       5.6.1.  Freshness Model . . . . . . . . . . . . . . . . . . .\
    \  43\n       5.6.2.  Validation Model  . . . . . . . . . . . . . . . . . .  43\n\
    \     5.7.  Proxying  . . . . . . . . . . . . . . . . . . . . . . . .  44\n  \
    \     5.7.1.  Proxy Operation . . . . . . . . . . . . . . . . . . .  44\n    \
    \   5.7.2.  Forward-Proxies . . . . . . . . . . . . . . . . . . .  46\n      \
    \ 5.7.3.  Reverse-Proxies . . . . . . . . . . . . . . . . . . .  46\n     5.8.\
    \  Method Definitions  . . . . . . . . . . . . . . . . . . .  47\n       5.8.1.\
    \  GET . . . . . . . . . . . . . . . . . . . . . . . . .  47\n       5.8.2.  POST\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  47\n       5.8.3.  PUT . .\
    \ . . . . . . . . . . . . . . . . . . . . . . .  48\n       5.8.4.  DELETE  .\
    \ . . . . . . . . . . . . . . . . . . . . . .  48\n     5.9.  Response Code Definitions\
    \ . . . . . . . . . . . . . . . .  48\n       5.9.1.  Success 2.xx  . . . . .\
    \ . . . . . . . . . . . . . . .  48\n       5.9.2.  Client Error 4.xx . . . .\
    \ . . . . . . . . . . . . . .  50\n       5.9.3.  Server Error 5.xx . . . . .\
    \ . . . . . . . . . . . . .  51\n     5.10. Option Definitions  . . . . . . .\
    \ . . . . . . . . . . . .  52\n       5.10.1.  Uri-Host, Uri-Port, Uri-Path, and\
    \ Uri-Query  . . . .  53\n       5.10.2.  Proxy-Uri and Proxy-Scheme . . . . .\
    \ . . . . . . . .  54\n       5.10.3.  Content-Format . . . . . . . . . . . .\
    \ . . . . . . .  55\n       5.10.4.  Accept . . . . . . . . . . . . . . . . .\
    \ . . . . . .  55\n       5.10.5.  Max-Age  . . . . . . . . . . . . . . . . .\
    \ . . . . .  55\n       5.10.6.  ETag . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  56\n       5.10.7.  Location-Path and Location-Query . . . . . . .\
    \ . . .  57\n       5.10.8.  Conditional Request Options  . . . . . . . . . .\
    \ . .  57\n       5.10.9.  Size1 Option . . . . . . . . . . . . . . . . . . .\
    \ .  59\n   6.  CoAP URIs . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \  59\n     6.1.  coap URI Scheme . . . . . . . . . . . . . . . . . . . . .  59\n\
    \     6.2.  coaps URI Scheme  . . . . . . . . . . . . . . . . . . . .  60\n  \
    \   6.3.  Normalization and Comparison Rules  . . . . . . . . . . .  61\n    \
    \ 6.4.  Decomposing URIs into Options . . . . . . . . . . . . . .  61\n     6.5.\
    \  Composing URIs from Options . . . . . . . . . . . . . . .  62\n   7.  Discovery\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . .  64\n     7.1.  Service\
    \ Discovery . . . . . . . . . . . . . . . . . . . .  64\n     7.2.  Resource Discovery\
    \  . . . . . . . . . . . . . . . . . . .  64\n       7.2.1.  'ct' Attribute  .\
    \ . . . . . . . . . . . . . . . . . .  64\n   8.  Multicast CoAP  . . . . . .\
    \ . . . . . . . . . . . . . . . . .  65\n     8.1.  Messaging Layer . . . . .\
    \ . . . . . . . . . . . . . . . .  65\n     8.2.  Request/Response Layer  . .\
    \ . . . . . . . . . . . . . . .  66\n       8.2.1.  Caching . . . . . . . . .\
    \ . . . . . . . . . . . . . .  67\n       8.2.2.  Proxying  . . . . . . . . .\
    \ . . . . . . . . . . . . .  67\n   9.  Securing CoAP . . . . . . . . . . . .\
    \ . . . . . . . . . . . .  68\n     9.1.  DTLS-Secured CoAP . . . . . . . . .\
    \ . . . . . . . . . . .  69\n       9.1.1.  Messaging Layer . . . . . . . . .\
    \ . . . . . . . . . .  70\n       9.1.2.  Request/Response Layer  . . . . . .\
    \ . . . . . . . . .  71\n       9.1.3.  Endpoint Identity . . . . . . . . . .\
    \ . . . . . . . .  71\n   10. Cross-Protocol Proxying between CoAP and HTTP .\
    \ . . . . . . .  74\n     10.1.  CoAP-HTTP Proxying . . . . . . . . . . . . .\
    \ . . . . . .  75\n       10.1.1.  GET  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  76\n       10.1.2.  PUT  . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  77\n       10.1.3.  DELETE . . . . . . . . . . . . . . . . . . . .\
    \ . . .  77\n       10.1.4.  POST . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  77\n     10.2.  HTTP-CoAP Proxying . . . . . . . . . . . . . . . . . .\
    \ .  77\n       10.2.1.  OPTIONS and TRACE  . . . . . . . . . . . . . . . . .\
    \  78\n       10.2.2.  GET  . . . . . . . . . . . . . . . . . . . . . . . .  78\n\
    \       10.2.3.  HEAD . . . . . . . . . . . . . . . . . . . . . . . .  79\n  \
    \     10.2.4.  POST . . . . . . . . . . . . . . . . . . . . . . . .  79\n    \
    \   10.2.5.  PUT  . . . . . . . . . . . . . . . . . . . . . . . .  79\n      \
    \ 10.2.6.  DELETE . . . . . . . . . . . . . . . . . . . . . . .  80\n       10.2.7.\
    \  CONNECT  . . . . . . . . . . . . . . . . . . . . . .  80\n   11. Security Considerations\
    \ . . . . . . . . . . . . . . . . . . .  80\n     11.1.  Parsing the Protocol\
    \ and Processing URIs . . . . . . . .  80\n     11.2.  Proxying and Caching .\
    \ . . . . . . . . . . . . . . . . .  81\n     11.3.  Risk of Amplification  .\
    \ . . . . . . . . . . . . . . . .  81\n     11.4.  IP Address Spoofing Attacks\
    \  . . . . . . . . . . . . . .  83\n     11.5.  Cross-Protocol Attacks . . . .\
    \ . . . . . . . . . . . . .  84\n     11.6.  Constrained-Node Considerations \
    \ . . . . . . . . . . . .  86\n   12. IANA Considerations . . . . . . . . . .\
    \ . . . . . . . . . . .  86\n     12.1.  CoAP Code Registries . . . . . . . .\
    \ . . . . . . . . . .  86\n       12.1.1.  Method Codes . . . . . . . . . . .\
    \ . . . . . . . . .  87\n       12.1.2.  Response Codes . . . . . . . . . . .\
    \ . . . . . . . .  88\n     12.2.  CoAP Option Numbers Registry . . . . . . .\
    \ . . . . . . .  89\n     12.3.  CoAP Content-Formats Registry  . . . . . . .\
    \ . . . . . .  91\n     12.4.  URI Scheme Registration  . . . . . . . . . . .\
    \ . . . . .  93\n     12.5.  Secure URI Scheme Registration . . . . . . . . .\
    \ . . . .  94\n     12.6.  Service Name and Port Number Registration  . . . .\
    \ . . .  95\n     12.7.  Secure Service Name and Port Number Registration . .\
    \ . .  96\n     12.8.  Multicast Address Registration . . . . . . . . . . . .\
    \ .  97\n   13. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .\
    \  97\n   14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  98\n\
    \     14.1.  Normative References . . . . . . . . . . . . . . . . . .  98\n  \
    \   14.2.  Informative References . . . . . . . . . . . . . . . . . 100\n   Appendix\
    \ A.  Examples . . . . . . . . . . . . . . . . . . . . . . 104\n   Appendix B.\
    \  URI Examples . . . . . . . . . . . . . . . . . . . . 110\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The use of web services (web APIs) on the Internet has become\n\
    \   ubiquitous in most applications and depends on the fundamental\n   Representational\
    \ State Transfer [REST] architecture of the Web.\n   The work on Constrained RESTful\
    \ Environments (CoRE) aims at realizing\n   the REST architecture in a suitable\
    \ form for the most constrained\n   nodes (e.g., 8-bit microcontrollers with limited\
    \ RAM and ROM) and\n   networks (e.g., 6LoWPAN, [RFC4944]).  Constrained networks\
    \ such as\n   6LoWPAN support the fragmentation of IPv6 packets into small link-\n\
    \   layer frames; however, this causes significant reduction in packet\n   delivery\
    \ probability.  One design goal of CoAP has been to keep\n   message overhead\
    \ small, thus limiting the need for fragmentation.\n   One of the main goals of\
    \ CoAP is to design a generic web protocol for\n   the special requirements of\
    \ this constrained environment, especially\n   considering energy, building automation,\
    \ and other machine-to-machine\n   (M2M) applications.  The goal of CoAP is not\
    \ to blindly compress HTTP\n   [RFC2616], but rather to realize a subset of REST\
    \ common with HTTP\n   but optimized for M2M applications.  Although CoAP could\
    \ be used for\n   refashioning simple HTTP interfaces into a more compact protocol,\n\
    \   more importantly it also offers features for M2M such as built-in\n   discovery,\
    \ multicast support, and asynchronous message exchanges.\n   This document specifies\
    \ the Constrained Application Protocol (CoAP),\n   which easily translates to\
    \ HTTP for integration with the existing Web\n   while meeting specialized requirements\
    \ such as multicast support,\n   very low overhead, and simplicity for constrained\
    \ environments and\n   M2M applications.\n"
- title: 1.1.  Features
  contents:
  - "1.1.  Features\n   CoAP has the following main features:\n   o  Web protocol\
    \ fulfilling M2M requirements in constrained\n      environments\n   o  UDP [RFC0768]\
    \ binding with optional reliability supporting unicast\n      and multicast requests.\n\
    \   o  Asynchronous message exchanges.\n   o  Low header overhead and parsing\
    \ complexity.\n   o  URI and Content-type support.\n   o  Simple proxy and caching\
    \ capabilities.\n   o  A stateless HTTP mapping, allowing proxies to be built\
    \ providing\n      access to CoAP resources via HTTP in a uniform way or for HTTP\n\
    \      simple interfaces to be realized alternatively over CoAP.\n   o  Security\
    \ binding to Datagram Transport Layer Security (DTLS)\n      [RFC6347].\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT\
    \ RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   [RFC2119] when they appear in ALL CAPS.  These words may\
    \ also appear\n   in this document in lowercase, absent their normative meanings.\n\
    \   This specification requires readers to be familiar with all the terms\n  \
    \ and concepts that are discussed in [RFC2616], including \"resource\",\n   \"\
    representation\", \"cache\", and \"fresh\".  (Having been completed\n   before\
    \ the updated set of HTTP RFCs, RFC 7230 to RFC 7235, became\n   available, this\
    \ specification specifically references the predecessor\n   version -- RFC 2616.)\
    \  In addition, this specification defines the\n   following terminology:\n  \
    \ Endpoint\n      An entity participating in the CoAP protocol.  Colloquially,\
    \ an\n      endpoint lives on a \"Node\", although \"Host\" would be more\n  \
    \    consistent with Internet standards usage, and is further\n      identified\
    \ by transport-layer multiplexing information that can\n      include a UDP port\
    \ number and a security association\n      (Section 4.1).\n   Sender\n      The\
    \ originating endpoint of a message.  When the aspect of\n      identification\
    \ of the specific sender is in focus, also \"source\n      endpoint\".\n   Recipient\n\
    \      The destination endpoint of a message.  When the aspect of\n      identification\
    \ of the specific recipient is in focus, also\n      \"destination endpoint\"\
    .\n   Client\n      The originating endpoint of a request; the destination endpoint\
    \ of\n      a response.\n   Server\n      The destination endpoint of a request;\
    \ the originating endpoint of\n      a response.\n   Origin Server\n      The\
    \ server on which a given resource resides or is to be created.\n   Intermediary\n\
    \      A CoAP endpoint that acts both as a server and as a client towards\n  \
    \    an origin server (possibly via further intermediaries).  A common\n     \
    \ form of an intermediary is a proxy; several classes of such\n      proxies are\
    \ discussed in this specification.\n   Proxy\n      An intermediary that mainly\
    \ is concerned with forwarding requests\n      and relaying back responses, possibly\
    \ performing caching,\n      namespace translation, or protocol translation in\
    \ the process.  As\n      opposed to intermediaries in the general sense, proxies\
    \ generally\n      do not implement specific application semantics.  Based on\
    \ the\n      position in the overall structure of the request forwarding, there\n\
    \      are two common forms of proxy: forward-proxy and reverse-proxy.\n     \
    \ In some cases, a single endpoint might act as an origin server,\n      forward-proxy,\
    \ or reverse-proxy, switching behavior based on the\n      nature of each request.\n\
    \   Forward-Proxy\n      An endpoint selected by a client, usually via local configuration\n\
    \      rules, to perform requests on behalf of the client, doing any\n      necessary\
    \ translations.  Some translations are minimal, such as\n      for proxy requests\
    \ for \"coap\" URIs, whereas other requests might\n      require translation to\
    \ and from entirely different application-\n      layer protocols.\n   Reverse-Proxy\n\
    \      An endpoint that stands in for one or more other server(s) and\n      satisfies\
    \ requests on behalf of these, doing any necessary\n      translations.  Unlike\
    \ a forward-proxy, the client may not be aware\n      that it is communicating\
    \ with a reverse-proxy; a reverse-proxy\n      receives requests as if it were\
    \ the origin server for the target\n      resource.\n   CoAP-to-CoAP Proxy\n \
    \     A proxy that maps from a CoAP request to a CoAP request, i.e.,\n      uses\
    \ the CoAP protocol both on the server and the client side.\n      Contrast to\
    \ cross-proxy.\n   Cross-Proxy\n      A cross-protocol proxy, or \"cross-proxy\"\
    \ for short, is a proxy\n      that translates between different protocols, such\
    \ as a CoAP-to-\n      HTTP proxy or an HTTP-to-CoAP proxy.  While this specification\n\
    \      makes very specific demands of CoAP-to-CoAP proxies, there is more\n  \
    \    variation possible in cross-proxies.\n   Confirmable Message\n      Some\
    \ messages require an acknowledgement.  These messages are\n      called \"Confirmable\"\
    .  When no packets are lost, each Confirmable\n      message elicits exactly one\
    \ return message of type Acknowledgement\n      or type Reset.\n   Non-confirmable\
    \ Message\n      Some other messages do not require an acknowledgement.  This\
    \ is\n      particularly true for messages that are repeated regularly for\n \
    \     application requirements, such as repeated readings from a sensor.\n   Acknowledgement\
    \ Message\n      An Acknowledgement message acknowledges that a specific\n   \
    \   Confirmable message arrived.  By itself, an Acknowledgement\n      message\
    \ does not indicate success or failure of any request\n      encapsulated in the\
    \ Confirmable message, but the Acknowledgement\n      message may also carry a\
    \ Piggybacked Response (see below).\n   Reset Message\n      A Reset message indicates\
    \ that a specific message (Confirmable or\n      Non-confirmable) was received,\
    \ but some context is missing to\n      properly process it.  This condition is\
    \ usually caused when the\n      receiving node has rebooted and has forgotten\
    \ some state that\n      would be required to interpret the message.  Provoking\
    \ a Reset\n      message (e.g., by sending an Empty Confirmable message) is also\n\
    \      useful as an inexpensive check of the liveness of an endpoint\n      (\"\
    CoAP ping\").\n   Piggybacked Response\n      A piggybacked Response is included\
    \ right in a CoAP Acknowledgement\n      (ACK) message that is sent to acknowledge\
    \ receipt of the Request\n      for this Response (Section 5.2.1).\n   Separate\
    \ Response\n      When a Confirmable message carrying a request is acknowledged\
    \ with\n      an Empty message (e.g., because the server doesn't have the answer\n\
    \      right away), a Separate Response is sent in a separate message\n      exchange\
    \ (Section 5.2.2).\n   Empty Message\n      A message with a Code of 0.00; neither\
    \ a request nor a response.\n      An Empty message only contains the 4-byte header.\n\
    \   Critical Option\n      An option that would need to be understood by the endpoint\n\
    \      ultimately receiving the message in order to properly process the\n   \
    \   message (Section 5.4.1).  Note that the implementation of critical\n     \
    \ options is, as the name \"Option\" implies, generally optional:\n      unsupported\
    \ critical options lead to an error response or summary\n      rejection of the\
    \ message.\n   Elective Option\n      An option that is intended to be ignored\
    \ by an endpoint that does\n      not understand it.  Processing the message even\
    \ without\n      understanding the option is acceptable (Section 5.4.1).\n   Unsafe\
    \ Option\n      An option that would need to be understood by a proxy receiving\n\
    \      the message in order to safely forward the message\n      (Section 5.4.2).\
    \  Not every critical option is an unsafe option.\n   Safe-to-Forward Option\n\
    \      An option that is intended to be safe for forwarding by a proxy\n     \
    \ that does not understand it.  Forwarding the message even without\n      understanding\
    \ the option is acceptable (Section 5.4.2).\n   Resource Discovery\n      The\
    \ process where a CoAP client queries a server for its list of\n      hosted resources\
    \ (i.e., links as defined in Section 7).\n   Content-Format\n      The combination\
    \ of an Internet media type, potentially with\n      specific parameters given,\
    \ and a content-coding (which is often\n      the identity content-coding), identified\
    \ by a numeric identifier\n      defined by the \"CoAP Content-Formats\" registry.\
    \  When the focus is\n      less on the numeric identifier than on the combination\
    \ of these\n      characteristics of a resource representation, this is also called\n\
    \      \"representation format\".\n   Additional terminology for constrained nodes\
    \ and constrained-node\n   networks can be found in [RFC7228].\n   In this specification,\
    \ the term \"byte\" is used in its now customary\n   sense as a synonym for \"\
    octet\".\n   All multi-byte integers in this protocol are interpreted in network\n\
    \   byte order.\n   Where arithmetic is used, this specification uses the notation\n\
    \   familiar from the programming language C, except that the operator\n   \"\
    **\" stands for exponentiation.\n"
- title: 2.  Constrained Application Protocol
  contents:
  - "2.  Constrained Application Protocol\n   The interaction model of CoAP is similar\
    \ to the client/server model\n   of HTTP.  However, machine-to-machine interactions\
    \ typically result\n   in a CoAP implementation acting in both client and server\
    \ roles.  A\n   CoAP request is equivalent to that of HTTP and is sent by a client\
    \ to\n   request an action (using a Method Code) on a resource (identified by\n\
    \   a URI) on a server.  The server then sends a response with a Response\n  \
    \ Code; this response may include a resource representation.\n   Unlike HTTP,\
    \ CoAP deals with these interchanges asynchronously over a\n   datagram-oriented\
    \ transport such as UDP.  This is done logically\n   using a layer of messages\
    \ that supports optional reliability (with\n   exponential back-off).  CoAP defines\
    \ four types of messages:\n   Confirmable, Non-confirmable, Acknowledgement, Reset.\
    \  Method Codes\n   and Response Codes included in some of these messages make\
    \ them carry\n   requests or responses.  The basic exchanges of the four types\
    \ of\n   messages are somewhat orthogonal to the request/response\n   interactions;\
    \ requests can be carried in Confirmable and Non-\n   confirmable messages, and\
    \ responses can be carried in these as well\n   as piggybacked in Acknowledgement\
    \ messages.\n   One could think of CoAP logically as using a two-layer approach,\
    \ a\n   CoAP messaging layer used to deal with UDP and the asynchronous\n   nature\
    \ of the interactions, and the request/response interactions\n   using Method\
    \ and Response Codes (see Figure 1).  CoAP is however a\n   single protocol, with\
    \ messaging and request/response as just features\n   of the CoAP header.\n  \
    \                      +----------------------+\n                        |   \
    \   Application     |\n                        +----------------------+\n    \
    \                    +----------------------+  \\\n                        | \
    \ Requests/Responses  |  |\n                        |----------------------| \
    \ | CoAP\n                        |       Messages       |  |\n              \
    \          +----------------------+  /\n                        +----------------------+\n\
    \                        |          UDP         |\n                        +----------------------+\n\
    \                    Figure 1: Abstract Layering of CoAP\n"
- title: 2.1.  Messaging Model
  contents:
  - "2.1.  Messaging Model\n   The CoAP messaging model is based on the exchange of\
    \ messages over\n   UDP between endpoints.\n   CoAP uses a short fixed-length\
    \ binary header (4 bytes) that may be\n   followed by compact binary options and\
    \ a payload.  This message\n   format is shared by requests and responses.  The\
    \ CoAP message format\n   is specified in Section 3.  Each message contains a\
    \ Message ID used\n   to detect duplicates and for optional reliability.  (The\
    \ Message ID\n   is compact; its 16-bit size enables up to about 250 messages\
    \ per\n   second from one endpoint to another with default protocol\n   parameters.)\n\
    \   Reliability is provided by marking a message as Confirmable (CON).  A\n  \
    \ Confirmable message is retransmitted using a default timeout and\n   exponential\
    \ back-off between retransmissions, until the recipient\n   sends an Acknowledgement\
    \ message (ACK) with the same Message ID (in\n   this example, 0x7d34) from the\
    \ corresponding endpoint; see Figure 2.\n   When a recipient is not at all able\
    \ to process a Confirmable message\n   (i.e., not even able to provide a suitable\
    \ error response), it\n   replies with a Reset message (RST) instead of an Acknowledgement\n\
    \   (ACK).\n                        Client              Server\n             \
    \              |                  |\n                           |   CON [0x7d34]\
    \   |\n                           +----------------->|\n                     \
    \      |                  |\n                           |   ACK [0x7d34]   |\n\
    \                           |<-----------------+\n                           |\
    \                  |\n                  Figure 2: Reliable Message Transmission\n\
    \   A message that does not require reliable transmission (for example,\n   each\
    \ single measurement out of a stream of sensor data) can be sent\n   as a Non-confirmable\
    \ message (NON).  These are not acknowledged, but\n   still have a Message ID\
    \ for duplicate detection (in this example,\n   0x01a0); see Figure 3.  When a\
    \ recipient is not able to process a\n   Non-confirmable message, it may reply\
    \ with a Reset message (RST).\n                        Client              Server\n\
    \                           |                  |\n                           |\
    \   NON [0x01a0]   |\n                           +----------------->|\n      \
    \                     |                  |\n                 Figure 3: Unreliable\
    \ Message Transmission\n   See Section 4 for details of CoAP messages.\n   As\
    \ CoAP runs over UDP, it also supports the use of multicast IP\n   destination\
    \ addresses, enabling multicast CoAP requests.  Section 8\n   discusses the proper\
    \ use of CoAP messages with multicast addresses\n   and precautions for avoiding\
    \ response congestion.\n   Several security modes are defined for CoAP in Section\
    \ 9 ranging from\n   no security to certificate-based security.  This document\
    \ specifies a\n   binding to DTLS for securing the protocol; the use of IPsec\
    \ with CoAP\n   is discussed in [IPsec-CoAP].\n"
- title: 2.2.  Request/Response Model
  contents:
  - "2.2.  Request/Response Model\n   CoAP request and response semantics are carried\
    \ in CoAP messages,\n   which include either a Method Code or Response Code, respectively.\n\
    \   Optional (or default) request and response information, such as the\n   URI\
    \ and payload media type are carried as CoAP options.  A Token is\n   used to\
    \ match responses to requests independently from the underlying\n   messages (Section\
    \ 5.3).  (Note that the Token is a concept separate\n   from the Message ID.)\n\
    \   A request is carried in a Confirmable (CON) or Non-confirmable (NON)\n   message,\
    \ and, if immediately available, the response to a request\n   carried in a Confirmable\
    \ message is carried in the resulting\n   Acknowledgement (ACK) message.  This\
    \ is called a piggybacked\n   response, detailed in Section 5.2.1.  (There is\
    \ no need for\n   separately acknowledging a piggybacked response, as the client\
    \ will\n   retransmit the request if the Acknowledgement message carrying the\n\
    \   piggybacked response is lost.)  Two examples for a basic GET request\n   with\
    \ piggybacked response are shown in Figure 4, one successful, one\n   resulting\
    \ in a 4.04 (Not Found) response.\n        Client              Server       Client\
    \              Server\n           |                  |             |         \
    \         |\n           |   CON [0xbc90]   |             |   CON [0xbc91]   |\n\
    \           | GET /temperature |             | GET /temperature |\n          \
    \ |   (Token 0x71)   |             |   (Token 0x72)   |\n           +----------------->|\
    \             +----------------->|\n           |                  |          \
    \   |                  |\n           |   ACK [0xbc90]   |             |   ACK\
    \ [0xbc91]   |\n           |   2.05 Content   |             |  4.04 Not Found\
    \  |\n           |   (Token 0x71)   |             |   (Token 0x72)   |\n     \
    \      |     \"22.5 C\"     |             |   \"Not found\"    |\n           |<-----------------+\
    \             |<-----------------+\n           |                  |          \
    \   |                  |\n           Figure 4: Two GET Requests with Piggybacked\
    \ Responses\n   If the server is not able to respond immediately to a request\
    \ carried\n   in a Confirmable message, it simply responds with an Empty\n   Acknowledgement\
    \ message so that the client can stop retransmitting\n   the request.  When the\
    \ response is ready, the server sends it in a\n   new Confirmable message (which\
    \ then in turn needs to be acknowledged\n   by the client).  This is called a\
    \ \"separate response\", as illustrated\n   in Figure 5 and described in more\
    \ detail in Section 5.2.2.\n                        Client              Server\n\
    \                           |                  |\n                           |\
    \   CON [0x7a10]   |\n                           | GET /temperature |\n      \
    \                     |   (Token 0x73)   |\n                           +----------------->|\n\
    \                           |                  |\n                           |\
    \   ACK [0x7a10]   |\n                           |<-----------------+\n      \
    \                     |                  |\n                           ... Time\
    \ Passes  ...\n                           |                  |\n             \
    \              |   CON [0x23bb]   |\n                           |   2.05 Content\
    \   |\n                           |   (Token 0x73)   |\n                     \
    \      |     \"22.5 C\"     |\n                           |<-----------------+\n\
    \                           |                  |\n                           |\
    \   ACK [0x23bb]   |\n                           +----------------->|\n      \
    \                     |                  |\n             Figure 5: A GET Request\
    \ with a Separate Response\n   If a request is sent in a Non-confirmable message,\
    \ then the response\n   is sent using a new Non-confirmable message, although\
    \ the server may\n   instead send a Confirmable message.  This type of exchange\
    \ is\n   illustrated in Figure 6.\n                        Client            \
    \  Server\n                           |                  |\n                 \
    \          |   NON [0x7a11]   |\n                           | GET /temperature\
    \ |\n                           |   (Token 0x74)   |\n                       \
    \    +----------------->|\n                           |                  |\n \
    \                          |   NON [0x23bc]   |\n                           |\
    \   2.05 Content   |\n                           |   (Token 0x74)   |\n      \
    \                     |     \"22.5 C\"     |\n                           |<-----------------+\n\
    \                           |                  |\n       Figure 6: A Request and\
    \ a Response Carried in Non-confirmable\n                                 Messages\n\
    \   CoAP makes use of GET, PUT, POST, and DELETE methods in a similar\n   manner\
    \ to HTTP, with the semantics specified in Section 5.8.  (Note\n   that the detailed\
    \ semantics of CoAP methods are \"almost, but not\n   entirely unlike\" [HHGTTG]\
    \ those of HTTP methods: intuition taken from\n   HTTP experience generally does\
    \ apply well, but there are enough\n   differences that make it worthwhile to\
    \ actually read the present\n   specification.)\n   Methods beyond the basic four\
    \ can be added to CoAP in separate\n   specifications.  New methods do not necessarily\
    \ have to use requests\n   and responses in pairs.  Even for existing methods,\
    \ a single request\n   may yield multiple responses, e.g., for a multicast request\n\
    \   (Section 8) or with the Observe option [OBSERVE].\n   URI support in a server\
    \ is simplified as the client already parses\n   the URI and splits it into host,\
    \ port, path, and query components,\n   making use of default values for efficiency.\
    \  Response Codes relate\n   to a small subset of HTTP status codes with a few\
    \ CoAP-specific codes\n   added, as defined in Section 5.9.\n"
- title: 2.3.  Intermediaries and Caching
  contents:
  - "2.3.  Intermediaries and Caching\n   The protocol supports the caching of responses\
    \ in order to\n   efficiently fulfill requests.  Simple caching is enabled using\n\
    \   freshness and validity information carried with CoAP responses.  A\n   cache\
    \ could be located in an endpoint or an intermediary.  Caching\n   functionality\
    \ is specified in Section 5.6.\n   Proxying is useful in constrained networks\
    \ for several reasons,\n   including to limit network traffic, to improve performance,\
    \ to access\n   resources of sleeping devices, and for security reasons.  The\n\
    \   proxying of requests on behalf of another CoAP endpoint is supported\n   in\
    \ the protocol.  When using a proxy, the URI of the resource to\n   request is\
    \ included in the request, while the destination IP address\n   is set to the\
    \ address of the proxy.  See Section 5.7 for more\n   information on proxy functionality.\n\
    \   As CoAP was designed according to the REST architecture [REST], and\n   thus\
    \ exhibits functionality similar to that of the HTTP protocol, it\n   is quite\
    \ straightforward to map from CoAP to HTTP and from HTTP to\n   CoAP.  Such a\
    \ mapping may be used to realize an HTTP REST interface\n   using CoAP or to convert\
    \ between HTTP and CoAP.  This conversion can\n   be carried out by a cross-protocol\
    \ proxy (\"cross-proxy\"), which\n   converts the Method or Response Code, media\
    \ type, and options to the\n   corresponding HTTP feature.  Section 10 provides\
    \ more detail about\n   HTTP mapping.\n"
- title: 2.4.  Resource Discovery
  contents:
  - "2.4.  Resource Discovery\n   Resource discovery is important for machine-to-machine\
    \ interactions\n   and is supported using the CoRE Link Format [RFC6690] as discussed\
    \ in\n   Section 7.\n"
- title: 3.  Message Format
  contents:
  - "3.  Message Format\n   CoAP is based on the exchange of compact messages that,\
    \ by default,\n   are transported over UDP (i.e., each CoAP message occupies the\
    \ data\n   section of one UDP datagram).  CoAP may also be used over Datagram\n\
    \   Transport Layer Security (DTLS) (see Section 9.1).  It could also be\n   used\
    \ over other transports such as SMS, TCP, or SCTP, the\n   specification of which\
    \ is out of this document's scope.  (UDP-lite\n   [RFC3828] and UDP zero checksum\
    \ [RFC6936] are not supported by CoAP.)\n   CoAP messages are encoded in a simple\
    \ binary format.  The message\n   format starts with a fixed-size 4-byte header.\
    \  This is followed by a\n   variable-length Token value, which can be between\
    \ 0 and 8 bytes long.\n   Following the Token value comes a sequence of zero or\
    \ more CoAP\n   Options in Type-Length-Value (TLV) format, optionally followed\
    \ by a\n   payload that takes up the rest of the datagram.\n    0            \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Ver| T |  TKL  |      Code     |          Message ID           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Token (if any, TKL bytes) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Options (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 1 1 1 1 1 1 1|    Payload (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 7: Message Format\n   The fields in the header\
    \ are defined as follows:\n   Version (Ver):  2-bit unsigned integer.  Indicates\
    \ the CoAP version\n      number.  Implementations of this specification MUST\
    \ set this field\n      to 1 (01 binary).  Other values are reserved for future\
    \ versions.\n      Messages with unknown version numbers MUST be silently ignored.\n\
    \   Type (T):  2-bit unsigned integer.  Indicates if this message is of\n    \
    \  type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or\n      Reset\
    \ (3).  The semantics of these message types are defined in\n      Section 4.\n\
    \   Token Length (TKL):  4-bit unsigned integer.  Indicates the length of\n  \
    \    the variable-length Token field (0-8 bytes).  Lengths 9-15 are\n      reserved,\
    \ MUST NOT be sent, and MUST be processed as a message\n      format error.\n\
    \   Code:  8-bit unsigned integer, split into a 3-bit class (most\n      significant\
    \ bits) and a 5-bit detail (least significant bits),\n      documented as \"c.dd\"\
    \ where \"c\" is a digit from 0 to 7 for the\n      3-bit subfield and \"dd\"\
    \ are two digits from 00 to 31 for the 5-bit\n      subfield.  The class can indicate\
    \ a request (0), a success\n      response (2), a client error response (4), or\
    \ a server error\n      response (5).  (All other class values are reserved.)\
    \  As a\n      special case, Code 0.00 indicates an Empty message.  In case of\
    \ a\n      request, the Code field indicates the Request Method; in case of a\n\
    \      response, a Response Code.  Possible values are maintained in the\n   \
    \   CoAP Code Registries (Section 12.1).  The semantics of requests\n      and\
    \ responses are defined in Section 5.\n   Message ID:  16-bit unsigned integer\
    \ in network byte order.  Used to\n      detect message duplication and to match\
    \ messages of type\n      Acknowledgement/Reset to messages of type Confirmable/Non-\n\
    \      confirmable.  The rules for generating a Message ID and matching\n    \
    \  messages are defined in Section 4.\n   The header is followed by the Token\
    \ value, which may be 0 to 8 bytes,\n   as given by the Token Length field.  The\
    \ Token value is used to\n   correlate requests and responses.  The rules for\
    \ generating a Token\n   and correlating requests and responses are defined in\
    \ Section 5.3.1.\n   Header and Token are followed by zero or more Options (Section\
    \ 3.1).\n   An Option can be followed by the end of the message, by another\n\
    \   Option, or by the Payload Marker and the payload.\n   Following the header,\
    \ token, and options, if any, comes the optional\n   payload.  If present and\
    \ of non-zero length, it is prefixed by a\n   fixed, one-byte Payload Marker (0xFF),\
    \ which indicates the end of\n   options and the start of the payload.  The payload\
    \ data extends from\n   after the marker to the end of the UDP datagram, i.e.,\
    \ the Payload\n   Length is calculated from the datagram size.  The absence of\
    \ the\n   Payload Marker denotes a zero-length payload.  The presence of a\n \
    \  marker followed by a zero-length payload MUST be processed as a\n   message\
    \ format error.\n   Implementation Note:  The byte value 0xFF may also occur within\
    \ an\n      option length or value, so simple byte-wise scanning for 0xFF is\n\
    \      not a viable technique for finding the payload marker.  The byte\n    \
    \  0xFF has the meaning of a payload marker only where the beginning\n      of\
    \ another option could occur.\n"
- title: 3.1.  Option Format
  contents:
  - "3.1.  Option Format\n   CoAP defines a number of options that can be included\
    \ in a message.\n   Each option instance in a message specifies the Option Number\
    \ of the\n   defined CoAP option, the length of the Option Value, and the Option\n\
    \   Value itself.\n   Instead of specifying the Option Number directly, the instances\
    \ MUST\n   appear in order of their Option Numbers and a delta encoding is used\n\
    \   between them: the Option Number for each instance is calculated as\n   the\
    \ sum of its delta and the Option Number of the preceding instance\n   in the\
    \ message.  For the first instance in a message, a preceding\n   option instance\
    \ with Option Number zero is assumed.  Multiple\n   instances of the same option\
    \ can be included by using a delta of\n   zero.\n   Option Numbers are maintained\
    \ in the \"CoAP Option Numbers\" registry\n   (Section 12.2).  See Section 5.4\
    \ for the semantics of the options\n   defined in this document.\n     0   1 \
    \  2   3   4   5   6   7\n   +---------------+---------------+\n   |         \
    \      |               |\n   |  Option Delta | Option Length |   1 byte\n   |\
    \               |               |\n   +---------------+---------------+\n   \\\
    \                               \\\n   /         Option Delta          /   0-2\
    \ bytes\n   \\          (extended)           \\\n   +-------------------------------+\n\
    \   \\                               \\\n   /         Option Length         /\
    \   0-2 bytes\n   \\          (extended)           \\\n   +-------------------------------+\n\
    \   \\                               \\\n   /                               /\n\
    \   \\                               \\\n   /         Option Value          /\
    \   0 or more bytes\n   \\                               \\\n   /            \
    \                   /\n   \\                               \\\n   +-------------------------------+\n\
    \                          Figure 8: Option Format\n   The fields in an option\
    \ are defined as follows:\n   Option Delta:  4-bit unsigned integer.  A value\
    \ between 0 and 12\n      indicates the Option Delta.  Three values are reserved\
    \ for special\n      constructs:\n      13:  An 8-bit unsigned integer follows\
    \ the initial byte and\n         indicates the Option Delta minus 13.\n      14:\
    \  A 16-bit unsigned integer in network byte order follows the\n         initial\
    \ byte and indicates the Option Delta minus 269.\n      15:  Reserved for the\
    \ Payload Marker.  If the field is set to this\n         value but the entire\
    \ byte is not the payload marker, this MUST\n         be processed as a message\
    \ format error.\n      The resulting Option Delta is used as the difference between\
    \ the\n      Option Number of this option and that of the previous option (or\n\
    \      zero for the first option).  In other words, the Option Number is\n   \
    \   calculated by simply summing the Option Delta values of this and\n      all\
    \ previous options before it.\n   Option Length:  4-bit unsigned integer.  A value\
    \ between 0 and 12\n      indicates the length of the Option Value, in bytes.\
    \  Three values\n      are reserved for special constructs:\n      13:  An 8-bit\
    \ unsigned integer precedes the Option Value and\n         indicates the Option\
    \ Length minus 13.\n      14:  A 16-bit unsigned integer in network byte order\
    \ precedes the\n         Option Value and indicates the Option Length minus 269.\n\
    \      15:  Reserved for future use.  If the field is set to this value,\n   \
    \      it MUST be processed as a message format error.\n   Value:  A sequence\
    \ of exactly Option Length bytes.  The length and\n      format of the Option\
    \ Value depend on the respective option, which\n      MAY define variable-length\
    \ values.  See Section 3.2 for the\n      formats used in this document; options\
    \ defined in other documents\n      MAY make use of other option value formats.\n"
- title: 3.2.  Option Value Formats
  contents:
  - "3.2.  Option Value Formats\n   The options defined in this document make use\
    \ of the following option\n   value formats.\n   empty:    A zero-length sequence\
    \ of bytes.\n   opaque:   An opaque sequence of bytes.\n   uint:     A non-negative\
    \ integer that is represented in network byte\n             order using the number\
    \ of bytes given by the Option Length\n             field.\n             An option\
    \ definition may specify a range of permissible\n             numbers of bytes;\
    \ if it has a choice, a sender SHOULD\n             represent the integer with\
    \ as few bytes as possible, i.e.,\n             without leading zero bytes.  For\
    \ example, the number 0 is\n             represented with an empty option value\
    \ (a zero-length\n             sequence of bytes) and the number 1 by a single\
    \ byte with\n             the numerical value of 1 (bit combination 00000001 in\
    \ most\n             significant bit first notation).  A recipient MUST be\n \
    \            prepared to process values with leading zero bytes.\n           \
    \  Implementation Note:  The exceptional behavior permitted\n                for\
    \ the sender is intended for highly constrained,\n                templated implementations\
    \ (e.g., hardware\n                implementations) that use fixed-size options\
    \ in the\n                templates.\n   string:   A Unicode string that is encoded\
    \ using UTF-8 [RFC3629] in\n             Net-Unicode form [RFC5198].\n       \
    \      Note that here, and in all other places where UTF-8\n             encoding\
    \ is used in the CoAP protocol, the intention is\n             that the encoded\
    \ strings can be directly used and compared\n             as opaque byte strings\
    \ by CoAP protocol implementations.\n             There is no expectation and\
    \ no need to perform\n             normalization within a CoAP implementation\
    \ (except where\n             Unicode strings that are not known to be normalized\
    \ are\n             imported from sources outside the CoAP protocol).  Note\n\
    \             also that ASCII strings (that do not make use of special\n     \
    \        control characters) are always valid UTF-8 Net-Unicode\n            \
    \ strings.\n"
- title: 4.  Message Transmission
  contents:
  - "4.  Message Transmission\n   CoAP messages are exchanged asynchronously between\
    \ CoAP endpoints.\n   They are used to transport CoAP requests and responses,\
    \ the semantics\n   of which are defined in Section 5.\n   As CoAP is bound to\
    \ unreliable transports such as UDP, CoAP messages\n   may arrive out of order,\
    \ appear duplicated, or go missing without\n   notice.  For this reason, CoAP\
    \ implements a lightweight reliability\n   mechanism, without trying to re-create\
    \ the full feature set of a\n   transport like TCP.  It has the following features:\n\
    \   o  Simple stop-and-wait retransmission reliability with exponential\n    \
    \  back-off for Confirmable messages.\n   o  Duplicate detection for both Confirmable\
    \ and Non-confirmable\n      messages.\n"
- title: 4.1.  Messages and Endpoints
  contents:
  - "4.1.  Messages and Endpoints\n   A CoAP endpoint is the source or destination\
    \ of a CoAP message.  The\n   specific definition of an endpoint depends on the\
    \ transport being\n   used for CoAP.  For the transports defined in this specification,\
    \ the\n   endpoint is identified depending on the security mode used (see\n  \
    \ Section 9): With no security, the endpoint is solely identified by an\n   IP\
    \ address and a UDP port number.  With other security modes, the\n   endpoint\
    \ is identified as defined by the security mode.\n   There are different types\
    \ of messages.  The type of a message is\n   specified by the Type field of the\
    \ CoAP Header.\n   Separate from the message type, a message may carry a request,\
    \ a\n   response, or be Empty.  This is signaled by the Request/Response Code\n\
    \   field in the CoAP Header and is relevant to the request/response\n   model.\
    \  Possible values for the field are maintained in the CoAP Code\n   Registries\
    \ (Section 12.1).\n   An Empty message has the Code field set to 0.00.  The Token\
    \ Length\n   field MUST be set to 0 and bytes of data MUST NOT be present after\n\
    \   the Message ID field.  If there are any bytes, they MUST be processed\n  \
    \ as a message format error.\n"
- title: 4.2.  Messages Transmitted Reliably
  contents:
  - "4.2.  Messages Transmitted Reliably\n   The reliable transmission of a message\
    \ is initiated by marking the\n   message as Confirmable in the CoAP header. \
    \ A Confirmable message\n   always carries either a request or response, unless\
    \ it is used only\n   to elicit a Reset message, in which case it is Empty.  A\
    \ recipient\n   MUST either (a) acknowledge a Confirmable message with an\n  \
    \ Acknowledgement message or (b) reject the message if the recipient\n   lacks\
    \ context to process the message properly, including situations\n   where the\
    \ message is Empty, uses a code with a reserved class (1, 6,\n   or 7), or has\
    \ a message format error.  Rejecting a Confirmable\n   message is effected by\
    \ sending a matching Reset message and otherwise\n   ignoring it.  The Acknowledgement\
    \ message MUST echo the Message ID of\n   the Confirmable message and MUST carry\
    \ a response or be Empty (see\n   Sections 5.2.1 and 5.2.2).  The Reset message\
    \ MUST echo the Message\n   ID of the Confirmable message and MUST be Empty. \
    \ Rejecting an\n   Acknowledgement or Reset message (including the case where\
    \ the\n   Acknowledgement carries a request or a code with a reserved class, or\n\
    \   the Reset message is not Empty) is effected by silently ignoring it.\n   More\
    \ generally, recipients of Acknowledgement and Reset messages MUST\n   NOT respond\
    \ with either Acknowledgement or Reset messages.\n   The sender retransmits the\
    \ Confirmable message at exponentially\n   increasing intervals, until it receives\
    \ an acknowledgement (or Reset\n   message) or runs out of attempts.\n   Retransmission\
    \ is controlled by two things that a CoAP endpoint MUST\n   keep track of for\
    \ each Confirmable message it sends while waiting for\n   an acknowledgement (or\
    \ reset): a timeout and a retransmission\n   counter.  For a new Confirmable message,\
    \ the initial timeout is set\n   to a random duration (often not an integral number\
    \ of seconds)\n   between ACK_TIMEOUT and (ACK_TIMEOUT * ACK_RANDOM_FACTOR) (see\n\
    \   Section 4.8), and the retransmission counter is set to 0.  When the\n   timeout\
    \ is triggered and the retransmission counter is less than\n   MAX_RETRANSMIT,\
    \ the message is retransmitted, the retransmission\n   counter is incremented,\
    \ and the timeout is doubled.  If the\n   retransmission counter reaches MAX_RETRANSMIT\
    \ on a timeout, or if the\n   endpoint receives a Reset message, then the attempt\
    \ to transmit the\n   message is canceled and the application process informed\
    \ of failure.\n   On the other hand, if the endpoint receives an acknowledgement\
    \ in\n   time, transmission is considered successful.\n   This specification makes\
    \ no strong requirements on the accuracy of\n   the clocks used to implement the\
    \ above binary exponential back-off\n   algorithm.  In particular, an endpoint\
    \ may be late for a specific\n   retransmission due to its sleep schedule and\
    \ may catch up on the next\n   one.  However, the minimum spacing before another\
    \ retransmission is\n   ACK_TIMEOUT, and the entire sequence of (re-)transmissions\
    \ MUST stay\n   in the envelope of MAX_TRANSMIT_SPAN (see Section 4.8.2), even\
    \ if\n   that means a sender may miss an opportunity to transmit.\n   A CoAP endpoint\
    \ that sent a Confirmable message MAY give up in\n   attempting to obtain an ACK\
    \ even before the MAX_RETRANSMIT counter\n   value is reached.  For example, the\
    \ application has canceled the\n   request as it no longer needs a response, or\
    \ there is some other\n   indication that the CON message did arrive.  In particular,\
    \ a CoAP\n   request message may have elicited a separate response, in which case\n\
    \   it is clear to the requester that only the ACK was lost and a\n   retransmission\
    \ of the request would serve no purpose.  However, a\n   responder MUST NOT in\
    \ turn rely on this cross-layer behavior from a\n   requester, i.e., it MUST retain\
    \ the state to create the ACK for the\n   request, if needed, even if a Confirmable\
    \ response was already\n   acknowledged by the requester.\n   Another reason for\
    \ giving up retransmission MAY be the receipt of\n   ICMP errors.  If it is desired\
    \ to take account of ICMP errors, to\n   mitigate potential spoofing attacks,\
    \ implementations SHOULD take care\n   to check the information about the original\
    \ datagram in the ICMP\n   message, including port numbers and CoAP header information\
    \ such as\n   message type and code, Message ID, and Token; if this is not possible\n\
    \   due to limitations of the UDP service API, ICMP errors SHOULD be\n   ignored.\
    \  Packet Too Big errors [RFC4443] (\"fragmentation needed and\n   DF set\" for\
    \ IPv4 [RFC0792]) cannot properly occur and SHOULD be\n   ignored if the implementation\
    \ note in Section 4.6 is followed;\n   otherwise, they SHOULD feed into a path\
    \ MTU discovery algorithm\n   [RFC4821].  Source Quench and Time Exceeded ICMP\
    \ messages SHOULD be\n   ignored.  Host, network, port, or protocol unreachable\
    \ errors or\n   parameter problem errors MAY, after appropriate vetting, be used\
    \ to\n   inform the application of a failure in sending.\n"
- title: 4.3.  Messages Transmitted without Reliability
  contents:
  - "4.3.  Messages Transmitted without Reliability\n   Some messages do not require\
    \ an acknowledgement.  This is\n   particularly true for messages that are repeated\
    \ regularly for\n   application requirements, such as repeated readings from a\
    \ sensor\n   where eventual success is sufficient.\n   As a more lightweight alternative,\
    \ a message can be transmitted less\n   reliably by marking the message as Non-confirmable.\
    \  A Non-\n   confirmable message always carries either a request or response\
    \ and\n   MUST NOT be Empty.  A Non-confirmable message MUST NOT be\n   acknowledged\
    \ by the recipient.  A recipient MUST reject the message\n   if it lacks context\
    \ to process the message properly, including the\n   case where the message is\
    \ Empty, uses a code with a reserved class\n   (1, 6, or 7), or has a message\
    \ format error.  Rejecting a Non-\n   confirmable message MAY involve sending\
    \ a matching Reset message, and\n   apart from the Reset message the rejected\
    \ message MUST be silently\n   ignored.\n   At the CoAP level, there is no way\
    \ for the sender to detect if a Non-\n   confirmable message was received or not.\
    \  A sender MAY choose to\n   transmit multiple copies of a Non-confirmable message\
    \ within\n   MAX_TRANSMIT_SPAN (limited by the provisions of Section 4.7, in\n\
    \   particular, by PROBING_RATE if no response is received), or the\n   network\
    \ may duplicate the message in transit.  To enable the receiver\n   to act only\
    \ once on the message, Non-confirmable messages specify a\n   Message ID as well.\
    \  (This Message ID is drawn from the same number\n   space as the Message IDs\
    \ for Confirmable messages.)\n   Summarizing Sections 4.2 and 4.3, the four message\
    \ types can be used\n   as in Table 1.  \"*\" means that the combination is not\
    \ used in normal\n   operation but only to elicit a Reset message (\"CoAP ping\"\
    ).\n                   +----------+-----+-----+-----+-----+\n                \
    \   |          | CON | NON | ACK | RST |\n                   +----------+-----+-----+-----+-----+\n\
    \                   | Request  | X   | X   | -   | -   |\n                   |\
    \ Response | X   | X   | X   | -   |\n                   | Empty    | *   | -\
    \   | X   | X   |\n                   +----------+-----+-----+-----+-----+\n \
    \                     Table 1: Usage of Message Types\n"
- title: 4.4.  Message Correlation
  contents:
  - "4.4.  Message Correlation\n   An Acknowledgement or Reset message is related\
    \ to a Confirmable\n   message or Non-confirmable message by means of a Message\
    \ ID along\n   with additional address information of the corresponding endpoint.\n\
    \   The Message ID is a 16-bit unsigned integer that is generated by the\n   sender\
    \ of a Confirmable or Non-confirmable message and included in\n   the CoAP header.\
    \  The Message ID MUST be echoed in the\n   Acknowledgement or Reset message by\
    \ the recipient.\n   The same Message ID MUST NOT be reused (in communicating\
    \ with the\n   same endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2).\n\
    \   Implementation Note:  Several implementation strategies can be\n      employed\
    \ for generating Message IDs.  In the simplest case, a CoAP\n      endpoint generates\
    \ Message IDs by keeping a single Message ID\n      variable, which is changed\
    \ each time a new Confirmable or Non-\n      confirmable message is sent, regardless\
    \ of the destination address\n      or port.  Endpoints dealing with large numbers\
    \ of transactions\n      could keep multiple Message ID variables, for example,\
    \ per prefix\n      or destination address.  (Note that some receiving endpoints\
    \ may\n      not be able to distinguish unicast and multicast packets addressed\n\
    \      to it, so endpoints generating Message IDs need to make sure these\n  \
    \    do not overlap.)  It is strongly recommended that the initial\n      value\
    \ of the variable (e.g., on startup) be randomized, in order\n      to make successful\
    \ off-path attacks on the protocol less likely.\n   For an Acknowledgement or\
    \ Reset message to match a Confirmable or\n   Non-confirmable message, the Message\
    \ ID and source endpoint of the\n   Acknowledgement or Reset message MUST match\
    \ the Message ID and\n   destination endpoint of the Confirmable or Non-confirmable\
    \ message.\n"
- title: 4.5.  Message Deduplication
  contents:
  - "4.5.  Message Deduplication\n   A recipient might receive the same Confirmable\
    \ message (as indicated\n   by the Message ID and source endpoint) multiple times\
    \ within the\n   EXCHANGE_LIFETIME (Section 4.8.2), for example, when its\n  \
    \ Acknowledgement went missing or didn't reach the original sender\n   before\
    \ the first timeout.  The recipient SHOULD acknowledge each\n   duplicate copy\
    \ of a Confirmable message using the same\n   Acknowledgement or Reset message\
    \ but SHOULD process any request or\n   response in the message only once.  This\
    \ rule MAY be relaxed in case\n   the Confirmable message transports a request\
    \ that is idempotent (see\n   Section 5.1) or can be handled in an idempotent\
    \ fashion.  Examples\n   for relaxed message deduplication:\n   o  A server might\
    \ relax the requirement to answer all retransmissions\n      of an idempotent\
    \ request with the same response (Section 4.2), so\n      that it does not have\
    \ to maintain state for Message IDs.  For\n      example, an implementation might\
    \ want to process duplicate\n      transmissions of a GET, PUT, or DELETE request\
    \ as separate\n      requests if the effort incurred by duplicate processing is\
    \ less\n      expensive than keeping track of previous responses would be.\n \
    \  o  A constrained server might even want to relax this requirement for\n   \
    \   certain non-idempotent requests if the application semantics make\n      this\
    \ trade-off favorable.  For example, if the result of a POST\n      request is\
    \ just the creation of some short-lived state at the\n      server, it may be\
    \ less expensive to incur this effort multiple\n      times for a request than\
    \ keeping track of whether a previous\n      transmission of the same request\
    \ already was processed.\n   A recipient might receive the same Non-confirmable\
    \ message (as\n   indicated by the Message ID and source endpoint) multiple times\n\
    \   within NON_LIFETIME (Section 4.8.2).  As a general rule that MAY be\n   relaxed\
    \ based on the specific semantics of a message, the recipient\n   SHOULD silently\
    \ ignore any duplicated Non-confirmable message and\n   SHOULD process any request\
    \ or response in the message only once.\n"
- title: 4.6.  Message Size
  contents:
  - "4.6.  Message Size\n   While specific link layers make it beneficial to keep\
    \ CoAP messages\n   small enough to fit into their link-layer packets (see Section\
    \ 1),\n   this is a matter of implementation quality.  The CoAP specification\n\
    \   itself provides only an upper bound to the message size.  Messages\n   larger\
    \ than an IP packet result in undesirable packet fragmentation.\n   A CoAP message,\
    \ appropriately encapsulated, SHOULD fit within a\n   single IP packet (i.e.,\
    \ avoid IP fragmentation) and (by fitting into\n   one UDP payload) obviously\
    \ needs to fit within a single IP datagram.\n   If the Path MTU is not known for\
    \ a destination, an IP MTU of 1280\n   bytes SHOULD be assumed; if nothing is\
    \ known about the size of the\n   headers, good upper bounds are 1152 bytes for\
    \ the message size and\n   1024 bytes for the payload size.\n   Implementation\
    \ Note:  CoAP's choice of message size parameters works\n      well with IPv6\
    \ and with most of today's IPv4 paths.  (However,\n      with IPv4, it is harder\
    \ to absolutely ensure that there is no IP\n      fragmentation.  If IPv4 support\
    \ on unusual networks is a\n      consideration, implementations may want to limit\
    \ themselves to\n      more conservative IPv4 datagram sizes such as 576 bytes;\
    \ per\n      [RFC0791], the absolute minimum value of the IP MTU for IPv4 is as\n\
    \      low as 68 bytes, which would leave only 40 bytes minus security\n     \
    \ overhead for a UDP payload.  Implementations extremely focused on\n      this\
    \ problem set might also set the IPv4 DF bit and perform some\n      form of path\
    \ MTU discovery [RFC4821]; this should generally be\n      unnecessary in realistic\
    \ use cases for CoAP, however.)  A more\n      important kind of fragmentation\
    \ in many constrained networks is\n      that on the adaptation layer (e.g., 6LoWPAN\
    \ L2 packets are limited\n      to 127 bytes including various overheads); this\
    \ may motivate\n      implementations to be frugal in their packet sizes and to\
    \ move to\n      block-wise transfers [BLOCK] when approaching three-digit message\n\
    \      sizes.\n      Message sizes are also of considerable importance to\n  \
    \    implementations on constrained nodes.  Many implementations will\n      need\
    \ to allocate a buffer for incoming messages.  If an\n      implementation is\
    \ too constrained to allow for allocating the\n      above-mentioned upper bound,\
    \ it could apply the following\n      implementation strategy for messages not\
    \ using DTLS security:\n      Implementations receiving a datagram into a buffer\
    \ that is too\n      small are usually able to determine if the trailing portion\
    \ of a\n      datagram was discarded and to retrieve the initial portion.  So,\n\
    \      at least the CoAP header and options, if not all of the payload,\n    \
    \  are likely to fit within the buffer.  A server can thus fully\n      interpret\
    \ a request and return a 4.13 (Request Entity Too Large;\n      see Section 5.9.2.9)\
    \ Response Code if the payload was truncated.\n      A client sending an idempotent\
    \ request and receiving a response\n      larger than would fit in the buffer\
    \ can repeat the request with a\n      suitable value for the Block Option [BLOCK].\n"
- title: 4.7.  Congestion Control
  contents:
  - "4.7.  Congestion Control\n   Basic congestion control for CoAP is provided by\
    \ the exponential\n   back-off mechanism in Section 4.2.\n   In order not to cause\
    \ congestion, clients (including proxies) MUST\n   strictly limit the number of\
    \ simultaneous outstanding interactions\n   that they maintain to a given server\
    \ (including proxies) to NSTART.\n   An outstanding interaction is either a CON\
    \ for which an ACK has not\n   yet been received but is still expected (message\
    \ layer) or a request\n   for which neither a response nor an Acknowledgment message\
    \ has yet\n   been received but is still expected (which may both occur at the\
    \ same\n   time, counting as one outstanding interaction).  The default value\
    \ of\n   NSTART for this specification is 1.\n   Further congestion control optimizations\
    \ and considerations are\n   expected in the future, may for example provide automatic\n\
    \   initialization of the CoAP transmission parameters defined in\n   Section\
    \ 4.8, and thus may allow a value for NSTART greater than one.\n   After EXCHANGE_LIFETIME,\
    \ a client stops expecting a response to a\n   Confirmable request for which no\
    \ acknowledgment message was received.\n   The specific algorithm by which a client\
    \ stops to \"expect\" a response\n   to a Confirmable request that was acknowledged,\
    \ or to a Non-\n   confirmable request, is not defined.  Unless this is modified\
    \ by\n   additional congestion control optimizations, it MUST be chosen in\n \
    \  such a way that an endpoint does not exceed an average data rate of\n   PROBING_RATE\
    \ in sending to another endpoint that does not respond.\n   Note:  CoAP places\
    \ the onus of congestion control mostly on the\n      clients.  However, clients\
    \ may malfunction or actually be\n      attackers, e.g., to perform amplification\
    \ attacks (Section 11.3).\n      To limit the damage (to the network and to its\
    \ own energy\n      resources), a server SHOULD implement some rate limiting for\
    \ its\n      response transmission based on reasonable assumptions about\n   \
    \   application requirements.  This is most helpful if the rate limit\n      can\
    \ be made effective for the misbehaving endpoints, only.\n"
- title: 4.8.  Transmission Parameters
  contents:
  - "4.8.  Transmission Parameters\n   Message transmission is controlled by the following\
    \ parameters:\n                   +-------------------+---------------+\n    \
    \               | name              | default value |\n                   +-------------------+---------------+\n\
    \                   | ACK_TIMEOUT       | 2 seconds     |\n                  \
    \ | ACK_RANDOM_FACTOR | 1.5           |\n                   | MAX_RETRANSMIT \
    \   | 4             |\n                   | NSTART            | 1            \
    \ |\n                   | DEFAULT_LEISURE   | 5 seconds     |\n              \
    \     | PROBING_RATE      | 1 byte/second |\n                   +-------------------+---------------+\n\
    \                     Table 2: CoAP Protocol Parameters\n"
- title: 4.8.1.  Changing the Parameters
  contents:
  - "4.8.1.  Changing the Parameters\n   The values for ACK_TIMEOUT, ACK_RANDOM_FACTOR,\
    \ MAX_RETRANSMIT,\n   NSTART, DEFAULT_LEISURE (Section 8.2), and PROBING_RATE\
    \ may be\n   configured to values specific to the application environment\n  \
    \ (including dynamically adjusted values); however, the configuration\n   method\
    \ is out of scope of this document.  It is RECOMMENDED that an\n   application\
    \ environment use consistent values for these parameters;\n   the specific effects\
    \ of operating with inconsistent values in an\n   application environment are\
    \ outside the scope of the present\n   specification.\n   The transmission parameters\
    \ have been chosen to achieve a behavior in\n   the presence of congestion that\
    \ is safe in the Internet.  If a\n   configuration desires to use different values,\
    \ the onus is on the\n   configuration to ensure these congestion control properties\
    \ are not\n   violated.  In particular, a decrease of ACK_TIMEOUT below 1 second\n\
    \   would violate the guidelines of [RFC5405].  ([RTO-CONSIDER] provides\n   some\
    \ additional background.)  CoAP was designed to enable\n   implementations that\
    \ do not maintain round-trip-time (RTT)\n   measurements.  However, where it is\
    \ desired to decrease the\n   ACK_TIMEOUT significantly or increase NSTART, this\
    \ can only be done\n   safely when maintaining such measurements.  Configurations\
    \ MUST NOT\n   decrease ACK_TIMEOUT or increase NSTART without using mechanisms\
    \ that\n   ensure congestion control safety, either defined in the configuration\n\
    \   or in future standards documents.\n   ACK_RANDOM_FACTOR MUST NOT be decreased\
    \ below 1.0, and it SHOULD have\n   a value that is sufficiently different from\
    \ 1.0 to provide some\n   protection from synchronization effects.\n   MAX_RETRANSMIT\
    \ can be freely adjusted, but a value that is too small\n   will reduce the probability\
    \ that a Confirmable message is actually\n   received, while a larger value than\
    \ given here will require further\n   adjustments in the time values (see Section\
    \ 4.8.2).\n   If the choice of transmission parameters leads to an increase of\n\
    \   derived time values (see Section 4.8.2), the configuration mechanism\n   MUST\
    \ ensure the adjusted value is also available to all the endpoints\n   with which\
    \ these adjusted values are to be used to communicate.\n"
- title: 4.8.2.  Time Values Derived from Transmission Parameters
  contents:
  - "4.8.2.  Time Values Derived from Transmission Parameters\n   The combination\
    \ of ACK_TIMEOUT, ACK_RANDOM_FACTOR, and MAX_RETRANSMIT\n   influences the timing\
    \ of retransmissions, which in turn influences\n   how long certain information\
    \ items need to be kept by an\n   implementation.  To be able to unambiguously\
    \ reference these derived\n   time values, we give them names as follows:\n  \
    \ o  MAX_TRANSMIT_SPAN is the maximum time from the first transmission\n     \
    \ of a Confirmable message to its last retransmission.  For the\n      default\
    \ transmission parameters, the value is (2+4+8+16)*1.5 = 45\n      seconds, or\
    \ more generally:\n         ACK_TIMEOUT * ((2 ** MAX_RETRANSMIT) - 1) * ACK_RANDOM_FACTOR\n\
    \   o  MAX_TRANSMIT_WAIT is the maximum time from the first transmission\n   \
    \   of a Confirmable message to the time when the sender gives up on\n      receiving\
    \ an acknowledgement or reset.  For the default\n      transmission parameters,\
    \ the value is (2+4+8+16+32)*1.5 = 93\n      seconds, or more generally:\n   \
    \      ACK_TIMEOUT * ((2 ** (MAX_RETRANSMIT + 1)) - 1) *\n         ACK_RANDOM_FACTOR\n\
    \   In addition, some assumptions need to be made on the characteristics\n   of\
    \ the network and the nodes.\n   o  MAX_LATENCY is the maximum time a datagram\
    \ is expected to take\n      from the start of its transmission to the completion\
    \ of its\n      reception.  This constant is related to the MSL (Maximum Segment\n\
    \      Lifetime) of [RFC0793], which is \"arbitrarily defined to be 2\n      minutes\"\
    \ ([RFC0793] glossary, page 81).  Note that this is not\n      necessarily smaller\
    \ than MAX_TRANSMIT_WAIT, as MAX_LATENCY is not\n      intended to describe a\
    \ situation when the protocol works well, but\n      the worst-case situation\
    \ against which the protocol has to guard.\n      We, also arbitrarily, define\
    \ MAX_LATENCY to be 100 seconds.  Apart\n      from being reasonably realistic\
    \ for the bulk of configurations as\n      well as close to the historic choice\
    \ for TCP, this value also\n      allows Message ID lifetime timers to be represented\
    \ in 8 bits\n      (when measured in seconds).  In these calculations, there is\
    \ no\n      assumption that the direction of the transmission is irrelevant\n\
    \      (i.e., that the network is symmetric); there is just the\n      assumption\
    \ that the same value can reasonably be used as a maximum\n      value for both\
    \ directions.  If that is not the case, the following\n      calculations become\
    \ only slightly more complex.\n   o  PROCESSING_DELAY is the time a node takes\
    \ to turn around a\n      Confirmable message into an acknowledgement.  We assume\
    \ the node\n      will attempt to send an ACK before having the sender time out,\
    \ so\n      as a conservative assumption we set it equal to ACK_TIMEOUT.\n   o\
    \  MAX_RTT is the maximum round-trip time, or:\n         (2 * MAX_LATENCY) + PROCESSING_DELAY\n\
    \   From these values, we can derive the following values relevant to the\n  \
    \ protocol operation:\n   o  EXCHANGE_LIFETIME is the time from starting to send\
    \ a Confirmable\n      message to the time when an acknowledgement is no longer\
    \ expected,\n      i.e., message-layer information about the message exchange\
    \ can be\n      purged.  EXCHANGE_LIFETIME includes a MAX_TRANSMIT_SPAN, a\n \
    \     MAX_LATENCY forward, PROCESSING_DELAY, and a MAX_LATENCY for the\n     \
    \ way back.  Note that there is no need to consider\n      MAX_TRANSMIT_WAIT if\
    \ the configuration is chosen such that the\n      last waiting period (ACK_TIMEOUT\
    \ * (2 ** MAX_RETRANSMIT) or the\n      difference between MAX_TRANSMIT_SPAN and\
    \ MAX_TRANSMIT_WAIT) is\n      less than MAX_LATENCY -- which is a likely choice,\
    \ as MAX_LATENCY\n      is a worst-case value unlikely to be met in the real world.\
    \  In\n      this case, EXCHANGE_LIFETIME simplifies to:\n         MAX_TRANSMIT_SPAN\
    \ + (2 * MAX_LATENCY) + PROCESSING_DELAY\n      or 247 seconds with the default\
    \ transmission parameters.\n   o  NON_LIFETIME is the time from sending a Non-confirmable\
    \ message to\n      the time its Message ID can be safely reused.  If multiple\n\
    \      transmission of a NON message is not used, its value is\n      MAX_LATENCY,\
    \ or 100 seconds.  However, a CoAP sender might send a\n      NON message multiple\
    \ times, in particular for multicast\n      applications.  While the period of\
    \ reuse is not bounded by the\n      specification, an expectation of reliable\
    \ detection of duplication\n      at the receiver is on the timescales of MAX_TRANSMIT_SPAN.\n\
    \      Therefore, for this purpose, it is safer to use the value:\n         MAX_TRANSMIT_SPAN\
    \ + MAX_LATENCY\n      or 145 seconds with the default transmission parameters;\
    \ however,\n      an implementation that just wants to use a single timeout value\n\
    \      for retiring Message IDs can safely use the larger value for\n      EXCHANGE_LIFETIME.\n\
    \   Table 3 lists the derived parameters introduced in this subsection\n   with\
    \ their default values.\n                   +-------------------+---------------+\n\
    \                   | name              | default value |\n                  \
    \ +-------------------+---------------+\n                   | MAX_TRANSMIT_SPAN\
    \ |          45 s |\n                   | MAX_TRANSMIT_WAIT |          93 s |\n\
    \                   | MAX_LATENCY       |         100 s |\n                  \
    \ | PROCESSING_DELAY  |           2 s |\n                   | MAX_RTT        \
    \   |         202 s |\n                   | EXCHANGE_LIFETIME |         247 s\
    \ |\n                   | NON_LIFETIME      |         145 s |\n              \
    \     +-------------------+---------------+\n                   Table 3: Derived\
    \ Protocol Parameters\n"
- title: 5.  Request/Response Semantics
  contents:
  - "5.  Request/Response Semantics\n   CoAP operates under a similar request/response\
    \ model as HTTP: a CoAP\n   endpoint in the role of a \"client\" sends one or\
    \ more CoAP requests to\n   a \"server\", which services the requests by sending\
    \ CoAP responses.\n   Unlike HTTP, requests and responses are not sent over a\
    \ previously\n   established connection but are exchanged asynchronously over\
    \ CoAP\n   messages.\n"
- title: 5.1.  Requests
  contents:
  - "5.1.  Requests\n   A CoAP request consists of the method to be applied to the\
    \ resource,\n   the identifier of the resource, a payload and Internet media type\
    \ (if\n   any), and optional metadata about the request.\n   CoAP supports the\
    \ basic methods of GET, POST, PUT, and DELETE, which\n   are easily mapped to\
    \ HTTP.  They have the same properties of safe\n   (only retrieval) and idempotent\
    \ (you can invoke it multiple times\n   with the same effects) as HTTP (see Section\
    \ 9.1 of [RFC2616]).  The\n   GET method is safe; therefore, it MUST NOT take\
    \ any other action on a\n   resource other than retrieval.  The GET, PUT, and\
    \ DELETE methods MUST\n   be performed in such a way that they are idempotent.\
    \  POST is not\n   idempotent, because its effect is determined by the origin\
    \ server and\n   dependent on the target resource; it usually results in a new\n\
    \   resource being created or the target resource being updated.\n   A request\
    \ is initiated by setting the Code field in the CoAP header\n   of a Confirmable\
    \ or a Non-confirmable message to a Method Code and\n   including request information.\n\
    \   The methods used in requests are described in detail in Section 5.8.\n"
- title: 5.2.  Responses
  contents:
  - "5.2.  Responses\n   After receiving and interpreting a request, a server responds\
    \ with a\n   CoAP response that is matched to the request by means of a client-\n\
    \   generated token (Section 5.3); note that this is different from the\n   Message\
    \ ID that matches a Confirmable message to its Acknowledgement.\n   A response\
    \ is identified by the Code field in the CoAP header being\n   set to a Response\
    \ Code.  Similar to the HTTP Status Code, the CoAP\n   Response Code indicates\
    \ the result of the attempt to understand and\n   satisfy the request.  These\
    \ codes are fully defined in Section 5.9.\n   The Response Code numbers to be\
    \ set in the Code field of the CoAP\n   header are maintained in the CoAP Response\
    \ Code Registry\n   (Section 12.1.2).\n                              0\n     \
    \                         0 1 2 3 4 5 6 7\n                             +-+-+-+-+-+-+-+-+\n\
    \                             |class|  detail |\n                            \
    \ +-+-+-+-+-+-+-+-+\n                  Figure 9: Structure of a Response Code\n\
    \   The upper three bits of the 8-bit Response Code number define the\n   class\
    \ of response.  The lower five bits do not have any\n   categorization role; they\
    \ give additional detail to the overall class\n   (Figure 9).\n   As a human-readable\
    \ notation for specifications and protocol\n   diagnostics, CoAP code numbers\
    \ including the Response Code are\n   documented in the format \"c.dd\", where\
    \ \"c\" is the class in decimal,\n   and \"dd\" is the detail as a two-digit decimal.\
    \  For example,\n   \"Forbidden\" is written as 4.03 -- indicating an 8-bit code\
    \ value of\n   hexadecimal 0x83 (4*0x20+3) or decimal 131 (4*32+3).\n   There\
    \ are 3 classes of Response Codes:\n   2 - Success:  The request was successfully\
    \ received, understood, and\n      accepted.\n   4 - Client Error:  The request\
    \ contains bad syntax or cannot be\n      fulfilled.\n   5 - Server Error:  The\
    \ server failed to fulfill an apparently valid\n      request.\n   The Response\
    \ Codes are designed to be extensible: Response Codes in\n   the Client Error\
    \ or Server Error class that are unrecognized by an\n   endpoint are treated as\
    \ being equivalent to the generic Response Code\n   of that class (4.00 and 5.00,\
    \ respectively).  However, there is no\n   generic Response Code indicating success,\
    \ so a Response Code in the\n   Success class that is unrecognized by an endpoint\
    \ can only be used to\n   determine that the request was successful without any\
    \ further\n   details.\n   The possible Response Codes are described in detail\
    \ in Section 5.9.\n   Responses can be sent in multiple ways, which are defined\
    \ in the\n   following subsections.\n"
- title: 5.2.1.  Piggybacked
  contents:
  - "5.2.1.  Piggybacked\n   In the most basic case, the response is carried directly\
    \ in the\n   Acknowledgement message that acknowledges the request (which requires\n\
    \   that the request was carried in a Confirmable message).  This is\n   called\
    \ a \"Piggybacked Response\".\n   The response is returned in the Acknowledgement\
    \ message, independent\n   of whether the response indicates success or failure.\
    \  In effect, the\n   response is piggybacked on the Acknowledgement message,\
    \ and no\n   separate message is required to return the response.\n   Implementation\
    \ Note:  The protocol leaves the decision whether to\n      piggyback a response\
    \ or not (i.e., send a separate response) to\n      the server.  The client MUST\
    \ be prepared to receive either.  On\n      the quality-of-implementation level,\
    \ there is a strong expectation\n      that servers will implement code to piggyback\
    \ whenever possible --\n      saving resources in the network and both at the\
    \ client and at the\n      server.\n"
- title: 5.2.2.  Separate
  contents:
  - "5.2.2.  Separate\n   It may not be possible to return a piggybacked response\
    \ in all cases.\n   For example, a server might need longer to obtain the representation\n\
    \   of the resource requested than it can wait to send back the\n   Acknowledgement\
    \ message, without risking the client repeatedly\n   retransmitting the request\
    \ message (see also the discussion of\n   PROCESSING_DELAY in Section 4.8.2).\
    \  The response to a request\n   carried in a Non-confirmable message is always\
    \ sent separately (as\n   there is no Acknowledgement message).\n   One way to\
    \ implement this in a server is to initiate the attempt to\n   obtain the resource\
    \ representation and, while that is in progress,\n   time out an acknowledgement\
    \ timer.  A server may also immediately\n   send an acknowledgement if it knows\
    \ in advance that there will be no\n   piggybacked response.  In both cases, the\
    \ acknowledgement effectively\n   is a promise that the request will be acted\
    \ upon later.\n   When the server finally has obtained the resource representation,\
    \ it\n   sends the response.  When it is desired that this message is not\n  \
    \ lost, it is sent as a Confirmable message from the server to the\n   client\
    \ and answered by the client with an Acknowledgement, echoing\n   the new Message\
    \ ID chosen by the server.  (It may also be sent as a\n   Non-confirmable message;\
    \ see Section 5.2.3.)\n   When the server chooses to use a separate response,\
    \ it sends the\n   Acknowledgement to the Confirmable request as an Empty message.\
    \  Once\n   the server sends back an Empty Acknowledgement, it MUST NOT send back\n\
    \   the response in another Acknowledgement, even if the client\n   retransmits\
    \ another identical request.  If a retransmitted request is\n   received (perhaps\
    \ because the original Acknowledgement was delayed),\n   another Empty Acknowledgement\
    \ is sent, and any response MUST be sent\n   as a separate response.\n   If the\
    \ server then sends a Confirmable response, the client's\n   Acknowledgement to\
    \ that response MUST also be an Empty message (one\n   that carries neither a\
    \ request nor a response).  The server MUST stop\n   retransmitting its response\
    \ on any matching Acknowledgement (silently\n   ignoring any Response Code or\
    \ payload) or Reset message.\n   Implementation Notes:  Note that, as the underlying\
    \ datagram\n      transport may not be sequence-preserving, the Confirmable message\n\
    \      carrying the response may actually arrive before or after the\n      Acknowledgement\
    \ message for the request; for the purposes of\n      terminating the retransmission\
    \ sequence, this also serves as an\n      acknowledgement.  Note also that, while\
    \ the CoAP protocol itself\n      does not make any specific demands here, there\
    \ is an expectation\n      that the response will come within a time frame that\
    \ is reasonable\n      from an application point of view.  As there is no underlying\n\
    \      transport protocol that could be instructed to run a keep-alive\n     \
    \ mechanism, the requester may want to set up a timeout that is\n      unrelated\
    \ to CoAP's retransmission timers in case the server is\n      destroyed or otherwise\
    \ unable to send the response.\n"
- title: 5.2.3.  Non-confirmable
  contents:
  - "5.2.3.  Non-confirmable\n   If the request message is Non-confirmable, then the\
    \ response SHOULD\n   be returned in a Non-confirmable message as well.  However,\
    \ an\n   endpoint MUST be prepared to receive a Non-confirmable response\n   (preceded\
    \ or followed by an Empty Acknowledgement message) in reply\n   to a Confirmable\
    \ request, or a Confirmable response in reply to a\n   Non-confirmable request.\n"
- title: 5.3.  Request/Response Matching
  contents:
  - "5.3.  Request/Response Matching\n   Regardless of how a response is sent, it\
    \ is matched to the request by\n   means of a token that is included by the client\
    \ in the request, along\n   with additional address information of the corresponding\
    \ endpoint.\n"
- title: 5.3.1.  Token
  contents:
  - "5.3.1.  Token\n   The Token is used to match a response with a request.  The\
    \ token\n   value is a sequence of 0 to 8 bytes.  (Note that every message\n \
    \  carries a token, even if it is of zero length.)  Every request\n   carries\
    \ a client-generated token that the server MUST echo (without\n   modification)\
    \ in any resulting response.\n   A token is intended for use as a client-local\
    \ identifier for\n   differentiating between concurrent requests (see Section\
    \ 5.3); it\n   could have been called a \"request ID\".\n   The client SHOULD\
    \ generate tokens in such a way that tokens currently\n   in use for a given source/destination\
    \ endpoint pair are unique.\n   (Note that a client implementation can use the\
    \ same token for any\n   request if it uses a different endpoint each time, e.g.,\
    \ a different\n   source port number.)  An empty token value is appropriate e.g.,\
    \ when\n   no other tokens are in use to a destination, or when requests are\n\
    \   made serially per destination and receive piggybacked responses.\n   There\
    \ are, however, multiple possible implementation strategies to\n   fulfill this.\n\
    \   A client sending a request without using Transport Layer Security\n   (Section\
    \ 9) SHOULD use a nontrivial, randomized token to guard\n   against spoofing of\
    \ responses (Section 11.4).  This protective use of\n   tokens is the reason they\
    \ are allowed to be up to 8 bytes in size.\n   The actual size of the random component\
    \ to be used for the Token\n   depends on the security requirements of the client\
    \ and the level of\n   threat posed by spoofing of responses.  A client that is\
    \ connected to\n   the general Internet SHOULD use at least 32 bits of randomness,\n\
    \   keeping in mind that not being directly connected to the Internet is\n   not\
    \ necessarily sufficient protection against spoofing.  (Note that\n   the Message\
    \ ID adds little in protection as it is usually\n   sequentially assigned, i.e.,\
    \ guessable, and can be circumvented by\n   spoofing a separate response.)  Clients\
    \ that want to optimize the\n   Token length may further want to detect the level\
    \ of ongoing attacks\n   (e.g., by tallying recent Token mismatches in incoming\
    \ messages) and\n   adjust the Token length upwards appropriately.  [RFC4086]\
    \ discusses\n   randomness requirements for security.\n   An endpoint receiving\
    \ a token it did not generate MUST treat the\n   token as opaque and make no assumptions\
    \ about its content or\n   structure.\n"
- title: 5.3.2.  Request/Response Matching Rules
  contents:
  - "5.3.2.  Request/Response Matching Rules\n   The exact rules for matching a response\
    \ to a request are as follows:\n   1.  The source endpoint of the response MUST\
    \ be the same as the\n       destination endpoint of the original request.\n \
    \  2.  In a piggybacked response, the Message ID of the Confirmable\n       request\
    \ and the Acknowledgement MUST match, and the tokens of the\n       response and\
    \ original request MUST match.  In a separate\n       response, just the tokens\
    \ of the response and original request\n       MUST match.\n   In case a message\
    \ carrying a response is unexpected (the client is\n   not waiting for a response\
    \ from the identified endpoint, at the\n   endpoint addressed, and/or with the\
    \ given token), the response is\n   rejected (Sections 4.2 and 4.3).\n   Implementation\
    \ Note:  A client that receives a response in a CON\n      message may want to\
    \ clean up the message state right after sending\n      the ACK.  If that ACK\
    \ is lost and the server retransmits the CON,\n      the client may no longer\
    \ have any state to which to correlate this\n      response, making the retransmission\
    \ an unexpected message; the\n      client will likely send a Reset message so\
    \ it does not receive any\n      more retransmissions.  This behavior is normal\
    \ and not an\n      indication of an error.  (Clients that are not aggressively\n\
    \      optimized in their state memory usage will still have message\n      state\
    \ that will identify the second CON as a retransmission.\n      Clients that actually\
    \ expect more messages from the server\n      [OBSERVE] will have to keep state\
    \ in any case.)\n"
- title: 5.4.  Options
  contents:
  - "5.4.  Options\n   Both requests and responses may include a list of one or more\n\
    \   options.  For example, the URI in a request is transported in several\n  \
    \ options, and metadata that would be carried in an HTTP header in HTTP\n   is\
    \ supplied as options as well.\n   CoAP defines a single set of options that are\
    \ used in both requests\n   and responses:\n   o  Content-Format\n   o  ETag\n\
    \   o  Location-Path\n   o  Location-Query\n   o  Max-Age\n   o  Proxy-Uri\n \
    \  o  Proxy-Scheme\n   o  Uri-Host\n   o  Uri-Path\n   o  Uri-Port\n   o  Uri-Query\n\
    \   o  Accept\n   o  If-Match\n   o  If-None-Match\n   o  Size1\n   The semantics\
    \ of these options along with their properties are\n   defined in detail in Section\
    \ 5.10.\n   Not all options are defined for use with all methods and Response\n\
    \   Codes.  The possible options for methods and Response Codes are\n   defined\
    \ in Sections 5.8 and 5.9, respectively.  In case an option is\n   not defined\
    \ for a Method or Response Code, it MUST NOT be included by\n   a sender and MUST\
    \ be treated like an unrecognized option by a\n   recipient.\n"
- title: 5.4.1.  Critical/Elective
  contents:
  - "5.4.1.  Critical/Elective\n   Options fall into one of two classes: \"critical\"\
    \ or \"elective\".  The\n   difference between these is how an option unrecognized\
    \ by an endpoint\n   is handled:\n   o  Upon reception, unrecognized options of\
    \ class \"elective\" MUST be\n      silently ignored.\n   o  Unrecognized options\
    \ of class \"critical\" that occur in a\n      Confirmable request MUST cause\
    \ the return of a 4.02 (Bad Option)\n      response.  This response SHOULD include\
    \ a diagnostic payload\n      describing the unrecognized option(s) (see Section\
    \ 5.5.2).\n   o  Unrecognized options of class \"critical\" that occur in a\n\
    \      Confirmable response, or piggybacked in an Acknowledgement, MUST\n    \
    \  cause the response to be rejected (Section 4.2).\n   o  Unrecognized options\
    \ of class \"critical\" that occur in a Non-\n      confirmable message MUST cause\
    \ the message to be rejected\n      (Section 4.3).\n   Note that, whether critical\
    \ or elective, an option is never\n   \"mandatory\" (it is always optional): these\
    \ rules are defined in order\n   to enable implementations to stop processing\
    \ options they do not\n   understand or implement.\n   Critical/elective rules\
    \ apply to non-proxying endpoints.  A proxy\n   processes options based on Unsafe/Safe-to-Forward\
    \ classes as defined\n   in Section 5.7.\n"
- title: 5.4.2.  Proxy Unsafe or Safe-to-Forward and NoCacheKey
  contents:
  - "5.4.2.  Proxy Unsafe or Safe-to-Forward and NoCacheKey\n   In addition to an\
    \ option being marked as critical or elective,\n   options are also classified\
    \ based on how a proxy is to deal with the\n   option if it does not recognize\
    \ it.  For this purpose, an option can\n   either be considered Unsafe to forward\
    \ (UnSafe is set) or Safe-to-\n   Forward (UnSafe is clear).\n   In addition,\
    \ for an option that is marked Safe-to-Forward, the option\n   number indicates\
    \ whether or not it is intended to be part of the\n   Cache-Key (Section 5.6)\
    \ in a request.  If some of the NoCacheKey bits\n   are 0, it is; if all NoCacheKey\
    \ bits are 1, it is not (see\n   Section 5.4.6).\n   Note:  The Cache-Key indication\
    \ is relevant only for proxies that do\n      not implement the given option as\
    \ a request option and instead\n      rely on the Unsafe/Safe-to-Forward indication\
    \ only.  For example,\n      for ETag, actually using the request option as a\
    \ part of the\n      Cache-Key is grossly inefficient, but it is the best thing\
    \ one can\n      do if ETag is not implemented by a proxy, as the response is\
    \ going\n      to differ based on the presence of the request option.  A more\n\
    \      useful proxy that does implement the ETag request option is not\n     \
    \ using ETag as a part of the Cache-Key.\n      NoCacheKey is indicated in three\
    \ bits so that only one out of\n      eight codepoints is qualified as NoCacheKey,\
    \ leaving seven out of\n      eight codepoints for what appears to be the more\
    \ likely case.\n   Proxy behavior with regard to these classes is defined in\n\
    \   Section 5.7.\n"
- title: 5.4.3.  Length
  contents:
  - "5.4.3.  Length\n   Option values are defined to have a specific length, often\
    \ in the\n   form of an upper and lower bound.  If the length of an option value\n\
    \   in a request is outside the defined range, that option MUST be\n   treated\
    \ like an unrecognized option (see Section 5.4.1).\n"
- title: 5.4.4.  Default Values
  contents:
  - "5.4.4.  Default Values\n   Options may be defined to have a default value.  If\
    \ the value of an\n   option is intended to be this default value, the option\
    \ SHOULD NOT be\n   included in the message.  If the option is not present, the\
    \ default\n   value MUST be assumed.\n   Where a critical option has a default\
    \ value, this is chosen in such a\n   way that the absence of the option in a\
    \ message can be processed\n   properly both by implementations unaware of the\
    \ critical option and\n   by implementations that interpret this absence as the\
    \ presence of the\n   default value for the option.\n"
- title: 5.4.5.  Repeatable Options
  contents:
  - "5.4.5.  Repeatable Options\n   The definition of some options specifies that\
    \ those options are\n   repeatable.  An option that is repeatable MAY be included\
    \ one or more\n   times in a message.  An option that is not repeatable MUST NOT\
    \ be\n   included more than once in a message.\n   If a message includes an option\
    \ with more occurrences than the option\n   is defined for, each supernumerary\
    \ option occurrence that appears\n   subsequently in the message MUST be treated\
    \ like an unrecognized\n   option (see Section 5.4.1).\n"
- title: 5.4.6.  Option Numbers
  contents:
  - "5.4.6.  Option Numbers\n   An Option is identified by an option number, which\
    \ also provides some\n   additional semantics information, e.g., odd numbers indicate\
    \ a\n   critical option, while even numbers indicate an elective option.\n   Note\
    \ that this is not just a convention, it is a feature of the\n   protocol: Whether\
    \ an option is elective or critical is entirely\n   determined by whether its\
    \ option number is even or odd.\n   More generally speaking, an Option number\
    \ is constructed with a bit\n   mask to indicate if an option is Critical or Elective,\
    \ Unsafe or\n   Safe-to-Forward, and, in the case of Safe-to-Forward, to provide\
    \ a\n   Cache-Key indication as shown by the following figure.  In the\n   following\
    \ text, the bit mask is expressed as a single byte that is\n   applied to the\
    \ least significant byte of the option number in\n   unsigned integer representation.\
    \  When bit 7 (the least significant\n   bit) is 1, an option is Critical (and\
    \ likewise Elective when 0).\n   When bit 6 is 1, an option is Unsafe (and likewise\
    \ Safe-to-Forward\n   when 0).  When bit 6 is 0, i.e., the option is not Unsafe,\
    \ it is not\n   a Cache-Key (NoCacheKey) if and only if bits 3-5 are all set to\
    \ 1;\n   all other bit combinations mean that it indeed is a Cache-Key.  These\n\
    \   classes of options are explained in the next sections.\n                 \
    \      0   1   2   3   4   5   6   7\n                     +---+---+---+---+---+---+---+---+\n\
    \                     |           | NoCacheKey| U | C |\n                    \
    \ +---+---+---+---+---+---+---+---+\n          Figure 10: Option Number Mask (Least\
    \ Significant Byte)\n   An endpoint may use an equivalent of the C code in Figure\
    \ 11 to\n   derive the characteristics of an option number \"onum\".\n   Critical\
    \ = (onum & 1);\n   UnSafe = (onum & 2);\n   NoCacheKey = ((onum & 0x1e) == 0x1c);\n\
    \       Figure 11: Determining Characteristics from an Option Number\n   The option\
    \ numbers for the options defined in this document are\n   listed in the \"CoAP\
    \ Option Numbers\" registry (Section 12.2).\n"
- title: 5.5.  Payloads and Representations
  contents:
  - "5.5.  Payloads and Representations\n   Both requests and responses may include\
    \ a payload, depending on the\n   Method or Response Code, respectively.  If a\
    \ Method or Response Code\n   is not defined to have a payload, then a sender\
    \ MUST NOT include one,\n   and a recipient MUST ignore it.\n"
- title: 5.5.1.  Representation
  contents:
  - "5.5.1.  Representation\n   The payload of requests or of responses indicating\
    \ success is\n   typically a representation of a resource (\"resource representation\"\
    )\n   or the result of the requested action (\"action result\").  Its format\n\
    \   is specified by the Internet media type and content coding given by\n   the\
    \ Content-Format Option.  In the absence of this option, no default\n   value\
    \ is assumed, and the format will need to be inferred by the\n   application (e.g.,\
    \ from the application context).  Payload \"sniffing\"\n   SHOULD only be attempted\
    \ if no content type is given.\n   Implementation Note:  On a quality-of-implementation\
    \ level, there is\n      a strong expectation that a Content-Format indication\
    \ will be\n      provided with resource representations whenever possible.  This\
    \ is\n      not a \"SHOULD\" level requirement solely because it is not a\n  \
    \    protocol requirement, and it also would be difficult to outline\n      exactly\
    \ in what cases this expectation can be violated.\n   For responses indicating\
    \ a client or server error, the payload is\n   considered a representation of\
    \ the result of the requested action\n   only if a Content-Format Option is given.\
    \  In the absence of this\n   option, the payload is a Diagnostic Payload (Section\
    \ 5.5.2).\n"
- title: 5.5.2.  Diagnostic Payload
  contents:
  - "5.5.2.  Diagnostic Payload\n   If no Content-Format option is given, the payload\
    \ of responses\n   indicating a client or server error is a brief human-readable\n\
    \   diagnostic message, explaining the error situation.  This diagnostic\n   message\
    \ MUST be encoded using UTF-8 [RFC3629], more specifically\n   using Net-Unicode\
    \ form [RFC5198].\n   The message is similar to the Reason-Phrase on an HTTP status\
    \ line.\n   It is not intended for end users but for software engineers that\n\
    \   during debugging need to interpret it in the context of the present,\n   English-language\
    \ specification; therefore, no mechanism for language\n   tagging is needed or\
    \ provided.  In contrast to what is usual in HTTP,\n   the payload SHOULD be empty\
    \ if there is no additional information\n   beyond the Response Code.\n"
- title: 5.5.3.  Selected Representation
  contents:
  - "5.5.3.  Selected Representation\n   Not all responses carry a payload that provides\
    \ a representation of\n   the resource addressed by the request.  It is, however,\
    \ sometimes\n   useful to be able to refer to such a representation in relation\
    \ to a\n   response, independent of whether it actually was enclosed.\n   We use\
    \ the term \"selected representation\" to refer to the current\n   representation\
    \ of a target resource that would have been selected in\n   a successful response\
    \ if the corresponding request had used the\n   method GET and excluded any conditional\
    \ request options\n   (Section 5.10.8).\n   Certain response options provide metadata\
    \ about the selected\n   representation, which might differ from the representation\
    \ included\n   in the message for responses to some state-changing methods.  Of\
    \ the\n   response options defined in this specification, only the ETag\n   response\
    \ option (Section 5.10.6) is defined as metadata about the\n   selected representation.\n"
- title: 5.5.4.  Content Negotiation
  contents:
  - "5.5.4.  Content Negotiation\n   A server may be able to supply a representation\
    \ for a resource in one\n   of multiple representation formats.  Without further\
    \ information from\n   the client, it will provide the representation in the format\
    \ it\n   prefers.\n   By using the Accept Option (Section 5.10.4) in a request,\
    \ the client\n   can indicate which content-format it prefers to receive.\n"
- title: 5.6.  Caching
  contents:
  - "5.6.  Caching\n   CoAP endpoints MAY cache responses in order to reduce the response\n\
    \   time and network bandwidth consumption on future, equivalent\n   requests.\n\
    \   The goal of caching in CoAP is to reuse a prior response message to\n   satisfy\
    \ a current request.  In some cases, a stored response can be\n   reused without\
    \ the need for a network request, reducing latency and\n   network round-trips;\
    \ a \"freshness\" mechanism is used for this purpose\n   (see Section 5.6.1).\
    \  Even when a new request is required, it is\n   often possible to reuse the\
    \ payload of a prior response to satisfy\n   the request, thereby reducing network\
    \ bandwidth usage; a \"validation\"\n   mechanism is used for this purpose (see\
    \ Section 5.6.2).\n   Unlike HTTP, the cacheability of CoAP responses does not\
    \ depend on\n   the request method, but it depends on the Response Code.  The\n\
    \   cacheability of each Response Code is defined along the Response Code\n  \
    \ definitions in Section 5.9.  Response Codes that indicate success and\n   are\
    \ unrecognized by an endpoint MUST NOT be cached.\n   For a presented request,\
    \ a CoAP endpoint MUST NOT use a stored\n   response, unless:\n   o  the presented\
    \ request method and that used to obtain the stored\n      response match,\n \
    \  o  all options match between those in the presented request and those\n   \
    \   of the request used to obtain the stored response (which includes\n      the\
    \ request URI), except that there is no need for a match of any\n      request\
    \ options marked as NoCacheKey (Section 5.4) or recognized\n      by the Cache\
    \ and fully interpreted with respect to its specified\n      cache behavior (such\
    \ as the ETag request option described in\n      Section 5.10.6; see also Section\
    \ 5.4.2), and\n   o  the stored response is either fresh or successfully validated\
    \ as\n      defined below.\n   The set of request options that is used for matching\
    \ the cache entry\n   is also collectively referred to as the \"Cache-Key\". \
    \ For URI schemes\n   other than coap and coaps, matching of those options that\
    \ constitute\n   the request URI may be performed under rules specific to the\
    \ URI\n   scheme.\n"
- title: 5.6.1.  Freshness Model
  contents:
  - "5.6.1.  Freshness Model\n   When a response is \"fresh\" in the cache, it can\
    \ be used to satisfy\n   subsequent requests without contacting the origin server,\
    \ thereby\n   improving efficiency.\n   The mechanism for determining freshness\
    \ is for an origin server to\n   provide an explicit expiration time in the future,\
    \ using the Max-Age\n   Option (see Section 5.10.5).  The Max-Age Option indicates\
    \ that the\n   response is to be considered not fresh after its age is greater\
    \ than\n   the specified number of seconds.\n   The Max-Age Option defaults to\
    \ a value of 60.  Thus, if it is not\n   present in a cacheable response, then\
    \ the response is considered not\n   fresh after its age is greater than 60 seconds.\
    \  If an origin server\n   wishes to prevent caching, it MUST explicitly include\
    \ a Max-Age\n   Option with a value of zero seconds.\n   If a client has a fresh\
    \ stored response and makes a new request\n   matching the request for that stored\
    \ response, the new response\n   invalidates the old response.\n"
- title: 5.6.2.  Validation Model
  contents:
  - "5.6.2.  Validation Model\n   When an endpoint has one or more stored responses\
    \ for a GET request,\n   but cannot use any of them (e.g., because they are not\
    \ fresh), it can\n   use the ETag Option (Section 5.10.6) in the GET request to\
    \ give the\n   origin server an opportunity both to select a stored response to\
    \ be\n   used, and to update its freshness.  This process is known as\n   \"validating\"\
    \ or \"revalidating\" the stored response.\n   When sending such a request, the\
    \ endpoint SHOULD add an ETag Option\n   specifying the entity-tag of each stored\
    \ response that is applicable.\n   A 2.03 (Valid) response indicates the stored\
    \ response identified by\n   the entity-tag given in the response's ETag Option\
    \ can be reused\n   after updating it as described in Section 5.9.1.3.\n   Any\
    \ other Response Code indicates that none of the stored responses\n   nominated\
    \ in the request is suitable.  Instead, the response SHOULD\n   be used to satisfy\
    \ the request and MAY replace the stored response.\n"
- title: 5.7.  Proxying
  contents:
  - "5.7.  Proxying\n   A proxy is a CoAP endpoint that can be tasked by CoAP clients\
    \ to\n   perform requests on their behalf.  This may be useful, for example,\n\
    \   when the request could otherwise not be made, or to service the\n   response\
    \ from a cache in order to reduce response time and network\n   bandwidth or energy\
    \ consumption.\n   In an overall architecture for a Constrained RESTful Environment,\n\
    \   proxies can serve quite different purposes.  Proxies can be\n   explicitly\
    \ selected by clients, a role that we term \"forward-proxy\".\n   Proxies can\
    \ also be inserted to stand in for origin servers, a role\n   that we term \"\
    reverse-proxy\".  Orthogonal to this distinction, a\n   proxy can map from a CoAP\
    \ request to a CoAP request (CoAP-to-CoAP\n   proxy) or translate from or to a\
    \ different protocol (\"cross-proxy\").\n   Full definitions of these terms are\
    \ provided in Section 1.2.\n   Notes:  The terminology in this specification has\
    \ been selected to be\n      culturally compatible with the terminology used in\
    \ the wider web\n      application environments, without necessarily matching\
    \ it in every\n      detail (which may not even be relevant to Constrained RESTful\n\
    \      Environments).  Not too much semantics should be ascribed to the\n    \
    \  components of the terms (such as \"forward\", \"reverse\", or\n      \"cross\"\
    ).\n      HTTP proxies, besides acting as HTTP proxies, often offer a\n      transport-protocol\
    \ proxying function (\"CONNECT\") to enable end-to-\n      end transport layer\
    \ security through the proxy.  No such function\n      is defined for CoAP-to-CoAP\
    \ proxies in this specification, as\n      forwarding of UDP packets is unlikely\
    \ to be of much value in\n      Constrained RESTful Environments.  See also Section\
    \ 10.2.7 for the\n      cross-proxy case.\n   When a client uses a proxy to make\
    \ a request that will use a secure\n   URI scheme (e.g., \"coaps\" or \"https\"\
    ), the request towards the proxy\n   SHOULD be sent using DTLS except where equivalent\
    \ lower-layer\n   security is used for the leg between the client and the proxy.\n"
- title: 5.7.1.  Proxy Operation
  contents:
  - "5.7.1.  Proxy Operation\n   A proxy generally needs a way to determine potential\
    \ request\n   parameters for a request it places to a destination, based on the\n\
    \   request it received from its client.  This way is fully specified for\n  \
    \ a forward-proxy but may depend on the specific configuration for a\n   reverse-proxy.\
    \  In particular, the client of a reverse-proxy\n   generally does not indicate\
    \ a locator for the destination,\n   necessitating some form of namespace translation\
    \ in the reverse-\n   proxy.  However, some aspects of the operation of proxies\
    \ are common\n   to all its forms.\n   If a proxy does not employ a cache, then\
    \ it simply forwards the\n   translated request to the determined destination.\
    \  Otherwise, if it\n   does employ a cache but does not have a stored response\
    \ that matches\n   the translated request and is considered fresh, then it needs\
    \ to\n   refresh its cache according to Section 5.6.  For options in the\n   request\
    \ that the proxy recognizes, it knows whether the option is\n   intended to act\
    \ as part of the key used in looking up the cached\n   value or not.  For example,\
    \ since requests for different Uri-Path\n   values address different resources,\
    \ Uri-Path values are always part\n   of the Cache-Key, while, e.g., Token values\
    \ are never part of the\n   Cache-Key.  For options that the proxy does not recognize\
    \ but that\n   are marked Safe-to-Forward in the option number, the option also\n\
    \   indicates whether it is to be included in the Cache-Key (NoCacheKey\n   is\
    \ not all set) or not (NoCacheKey is all set).  (Options that are\n   unrecognized\
    \ and marked Unsafe lead to 4.02 Bad Option.)\n   If the request to the destination\
    \ times out, then a 5.04 (Gateway\n   Timeout) response MUST be returned.  If\
    \ the request to the\n   destination returns a response that cannot be processed\
    \ by the proxy\n   (e.g, due to unrecognized critical options or message format\
    \ errors),\n   then a 5.02 (Bad Gateway) response MUST be returned.  Otherwise,\
    \ the\n   proxy returns the response to the client.\n   If a response is generated\
    \ out of a cache, the generated (or implied)\n   Max-Age Option MUST NOT extend\
    \ the max-age originally set by the\n   server, considering the time the resource\
    \ representation spent in the\n   cache.  For example, the Max-Age Option could\
    \ be adjusted by the\n   proxy for each response using the formula:\n      proxy-max-age\
    \ = original-max-age - cache-age\n   For example, if a request is made to a proxied\
    \ resource that was\n   refreshed 20 seconds ago and had an original Max-Age of\
    \ 60 seconds,\n   then that resource's proxied max-age is now 40 seconds.  Considering\n\
    \   potential network delays on the way from the origin server, a proxy\n   should\
    \ be conservative in the max-age values offered.\n   All options present in a\
    \ proxy request MUST be processed at the\n   proxy.  Unsafe options in a request\
    \ that are not recognized by the\n   proxy MUST lead to a 4.02 (Bad Option) response\
    \ being returned by the\n   proxy.  A CoAP-to-CoAP proxy MUST forward to the origin\
    \ server all\n   Safe-to-Forward options that it does not recognize.  Similarly,\n\
    \   Unsafe options in a response that are not recognized by the CoAP-to-\n   CoAP\
    \ proxy server MUST lead to a 5.02 (Bad Gateway) response.  Again,\n   Safe-to-Forward\
    \ options that are not recognized MUST be forwarded.\n   Additional considerations\
    \ for cross-protocol proxying between CoAP\n   and HTTP are discussed in Section\
    \ 10.\n"
- title: 5.7.2.  Forward-Proxies
  contents:
  - "5.7.2.  Forward-Proxies\n   CoAP distinguishes between requests made (as if)\
    \ to an origin server\n   and requests made through a forward-proxy.  CoAP requests\
    \ to a\n   forward-proxy are made as normal Confirmable or Non-confirmable\n \
    \  requests to the forward-proxy endpoint, but they specify the request\n   URI\
    \ in a different way: The request URI in a proxy request is\n   specified as a\
    \ string in the Proxy-Uri Option (see Section 5.10.2),\n   while the request URI\
    \ in a request to an origin server is split into\n   the Uri-Host, Uri-Port, Uri-Path,\
    \ and Uri-Query Options (see\n   Section 5.10.1).  Alternatively, the URI in a\
    \ proxy request can be\n   assembled from a Proxy-Scheme option and the split\
    \ options mentioned.\n   When a proxy request is made to an endpoint and the endpoint\
    \ is\n   unwilling or unable to act as proxy for the request URI, it MUST\n  \
    \ return a 5.05 (Proxying Not Supported) response.  If the authority\n   (host\
    \ and port) is recognized as identifying the proxy endpoint\n   itself (see Section\
    \ 5.10.2), then the request MUST be treated as a\n   local (non-proxied) request.\n\
    \   Unless a proxy is configured to forward the proxy request to another\n   proxy,\
    \ it MUST translate the request as follows: the scheme of the\n   request URI\
    \ defines the outgoing protocol and its details (e.g., CoAP\n   is used over UDP\
    \ for the \"coap\" scheme and over DTLS for the \"coaps\"\n   scheme.)  For a\
    \ CoAP-to-CoAP proxy, the origin server's IP address\n   and port are determined\
    \ by the authority component of the request\n   URI, and the request URI is decoded\
    \ and split into the Uri-Host, Uri-\n   Port, Uri-Path and Uri-Query Options.\
    \  This consumes the Proxy-Uri or\n   Proxy-Scheme option, which is therefore\
    \ not forwarded to the origin\n   server.\n"
- title: 5.7.3.  Reverse-Proxies
  contents:
  - "5.7.3.  Reverse-Proxies\n   Reverse-proxies do not make use of the Proxy-Uri\
    \ or Proxy-Scheme\n   options but need to determine the destination (next hop)\
    \ of a request\n   from information in the request and information in their\n\
    \   configuration.  For example, a reverse-proxy might offer various\n   resources\
    \ as if they were its own resources, after having learned of\n   their existence\
    \ through resource discovery.  The reverse-proxy is\n   free to build a namespace\
    \ for the URIs that identify these resources.\n   A reverse-proxy may also build\
    \ a namespace that gives the client more\n   control over where the request goes,\
    \ e.g., by embedding host\n   identifiers and port numbers into the URI path of\
    \ the resources\n   offered.\n   In processing the response, a reverse-proxy has\
    \ to be careful that\n   ETag option values from different sources are not mixed\
    \ up on one\n   resource offered to its clients.  In many cases, the ETag can\
    \ be\n   forwarded unchanged.  If the mapping from a resource offered by the\n\
    \   reverse-proxy to resources offered by its various origin servers is\n   not\
    \ unique, the reverse-proxy may need to generate a new ETag, making\n   sure the\
    \ semantics of this option are properly preserved.\n"
- title: 5.8.  Method Definitions
  contents:
  - "5.8.  Method Definitions\n   In this section, each method is defined along with\
    \ its behavior.  A\n   request with an unrecognized or unsupported Method Code\
    \ MUST generate\n   a 4.05 (Method Not Allowed) piggybacked response.\n"
- title: 5.8.1.  GET
  contents:
  - "5.8.1.  GET\n   The GET method retrieves a representation for the information\
    \ that\n   currently corresponds to the resource identified by the request URI.\n\
    \   If the request includes an Accept Option, that indicates the\n   preferred\
    \ content-format of a response.  If the request includes an\n   ETag Option, the\
    \ GET method requests that ETag be validated and that\n   the representation be\
    \ transferred only if validation failed.  Upon\n   success, a 2.05 (Content) or\
    \ 2.03 (Valid) Response Code SHOULD be\n   present in the response.\n   The GET\
    \ method is safe and idempotent.\n"
- title: 5.8.2.  POST
  contents:
  - "5.8.2.  POST\n   The POST method requests that the representation enclosed in\
    \ the\n   request be processed.  The actual function performed by the POST\n \
    \  method is determined by the origin server and dependent on the target\n   resource.\
    \  It usually results in a new resource being created or the\n   target resource\
    \ being updated.\n   If a resource has been created on the server, the response\
    \ returned\n   by the server SHOULD have a 2.01 (Created) Response Code and SHOULD\n\
    \   include the URI of the new resource in a sequence of one or more\n   Location-Path\
    \ and/or Location-Query Options (Section 5.10.7).  If the\n   POST succeeds but\
    \ does not result in a new resource being created on\n   the server, the response\
    \ SHOULD have a 2.04 (Changed) Response Code.\n   If the POST succeeds and results\
    \ in the target resource being\n   deleted, the response SHOULD have a 2.02 (Deleted)\
    \ Response Code.\n   POST is neither safe nor idempotent.\n"
- title: 5.8.3.  PUT
  contents:
  - "5.8.3.  PUT\n   The PUT method requests that the resource identified by the request\n\
    \   URI be updated or created with the enclosed representation.  The\n   representation\
    \ format is specified by the media type and content\n   coding given in the Content-Format\
    \ Option, if provided.\n   If a resource exists at the request URI, the enclosed\
    \ representation\n   SHOULD be considered a modified version of that resource,\
    \ and a 2.04\n   (Changed) Response Code SHOULD be returned.  If no resource exists,\n\
    \   then the server MAY create a new resource with that URI, resulting in\n  \
    \ a 2.01 (Created) Response Code.  If the resource could not be created\n   or\
    \ modified, then an appropriate error Response Code SHOULD be sent.\n   Further\
    \ restrictions to a PUT can be made by including the If-Match\n   (see Section\
    \ 5.10.8.1) or If-None-Match (see Section 5.10.8.2)\n   options in the request.\n\
    \   PUT is not safe but is idempotent.\n"
- title: 5.8.4.  DELETE
  contents:
  - "5.8.4.  DELETE\n   The DELETE method requests that the resource identified by\
    \ the\n   request URI be deleted.  A 2.02 (Deleted) Response Code SHOULD be\n\
    \   used on success or in case the resource did not exist before the\n   request.\n\
    \   DELETE is not safe but is idempotent.\n"
- title: 5.9.  Response Code Definitions
  contents:
  - "5.9.  Response Code Definitions\n   Each Response Code is described below, including\
    \ any options required\n   in the response.  Where appropriate, some of the codes\
    \ will be\n   specified in regards to related Response Codes in HTTP [RFC2616];\n\
    \   this does not mean that any such relationship modifies the HTTP\n   mapping\
    \ specified in Section 10.\n"
- title: 5.9.1.  Success 2.xx
  contents:
  - "5.9.1.  Success 2.xx\n   This class of Response Code indicates that the clients\
    \ request was\n   successfully received, understood, and accepted.\n"
- title: 5.9.1.1.  2.01 Created
  contents:
  - "5.9.1.1.  2.01 Created\n   Like HTTP 201 \"Created\", but only used in response\
    \ to POST and PUT\n   requests.  The payload returned with the response, if any,\
    \ is a\n   representation of the action result.\n   If the response includes one\
    \ or more Location-Path and/or Location-\n   Query Options, the values of these\
    \ options specify the location at\n   which the resource was created.  Otherwise,\
    \ the resource was created\n   at the request URI.  A cache receiving this response\
    \ MUST mark any\n   stored response for the created resource as not fresh.\n \
    \  This response is not cacheable.\n"
- title: 5.9.1.2.  2.02 Deleted
  contents:
  - "5.9.1.2.  2.02 Deleted\n   This Response Code is like HTTP 204 \"No Content\"\
    \ but only used in\n   response to requests that cause the resource to cease being\n\
    \   available, such as DELETE and, in certain circumstances, POST.  The\n   payload\
    \ returned with the response, if any, is a representation of\n   the action result.\n\
    \   This response is not cacheable.  However, a cache MUST mark any\n   stored\
    \ response for the deleted resource as not fresh.\n"
- title: 5.9.1.3.  2.03 Valid
  contents:
  - "5.9.1.3.  2.03 Valid\n   This Response Code is related to HTTP 304 \"Not Modified\"\
    \ but only\n   used to indicate that the response identified by the entity-tag\n\
    \   identified by the included ETag Option is valid.  Accordingly, the\n   response\
    \ MUST include an ETag Option and MUST NOT include a payload.\n   When a cache\
    \ that recognizes and processes the ETag response option\n   receives a 2.03 (Valid)\
    \ response, it MUST update the stored response\n   with the value of the Max-Age\
    \ Option included in the response\n   (explicitly, or implicitly as a default\
    \ value; see also\n   Section 5.6.2).  For each type of Safe-to-Forward option\
    \ present in\n   the response, the (possibly empty) set of options of this type\
    \ that\n   are present in the stored response MUST be replaced with the set of\n\
    \   options of this type in the response received.  (Unsafe options may\n   trigger\
    \ similar option-specific processing as defined by the option.)\n"
- title: 5.9.1.4.  2.04 Changed
  contents:
  - "5.9.1.4.  2.04 Changed\n   This Response Code is like HTTP 204 \"No Content\"\
    \ but only used in\n   response to POST and PUT requests.  The payload returned\
    \ with the\n   response, if any, is a representation of the action result.\n \
    \  This response is not cacheable.  However, a cache MUST mark any\n   stored\
    \ response for the changed resource as not fresh.\n"
- title: 5.9.1.5.  2.05 Content
  contents:
  - "5.9.1.5.  2.05 Content\n   This Response Code is like HTTP 200 \"OK\" but only\
    \ used in response to\n   GET requests.\n   The payload returned with the response\
    \ is a representation of the\n   target resource.\n   This response is cacheable:\
    \ Caches can use the Max-Age Option to\n   determine freshness (see Section 5.6.1)\
    \ and (if present) the ETag\n   Option for validation (see Section 5.6.2).\n"
- title: 5.9.2.  Client Error 4.xx
  contents:
  - "5.9.2.  Client Error 4.xx\n   This class of Response Code is intended for cases\
    \ in which the client\n   seems to have erred.  These Response Codes are applicable\
    \ to any\n   request method.\n   The server SHOULD include a diagnostic payload\
    \ under the conditions\n   detailed in Section 5.5.2.\n   Responses of this class\
    \ are cacheable: Caches can use the Max-Age\n   Option to determine freshness\
    \ (see Section 5.6.1).  They cannot be\n   validated.\n"
- title: 5.9.2.1.  4.00 Bad Request
  contents:
  - "5.9.2.1.  4.00 Bad Request\n   This Response Code is Like HTTP 400 \"Bad Request\"\
    .\n"
- title: 5.9.2.2.  4.01 Unauthorized
  contents:
  - "5.9.2.2.  4.01 Unauthorized\n   The client is not authorized to perform the requested\
    \ action.  The\n   client SHOULD NOT repeat the request without first improving\
    \ its\n   authentication status to the server.  Which specific mechanism can be\n\
    \   used for this is outside this document's scope; see also Section 9.\n"
- title: 5.9.2.3.  4.02 Bad Option
  contents:
  - "5.9.2.3.  4.02 Bad Option\n   The request could not be understood by the server\
    \ due to one or more\n   unrecognized or malformed options.  The client SHOULD\
    \ NOT repeat the\n   request without modification.\n"
- title: 5.9.2.4.  4.03 Forbidden
  contents:
  - "5.9.2.4.  4.03 Forbidden\n   This Response Code is like HTTP 403 \"Forbidden\"\
    .\n"
- title: 5.9.2.5.  4.04 Not Found
  contents:
  - "5.9.2.5.  4.04 Not Found\n   This Response Code is like HTTP 404 \"Not Found\"\
    .\n"
- title: 5.9.2.6.  4.05 Method Not Allowed
  contents:
  - "5.9.2.6.  4.05 Method Not Allowed\n   This Response Code is like HTTP 405 \"\
    Method Not Allowed\" but with no\n   parallel to the \"Allow\" header field.\n"
- title: 5.9.2.7.  4.06 Not Acceptable
  contents:
  - "5.9.2.7.  4.06 Not Acceptable\n   This Response Code is like HTTP 406 \"Not Acceptable\"\
    , but with no\n   response entity.\n"
- title: 5.9.2.8.  4.12 Precondition Failed
  contents:
  - "5.9.2.8.  4.12 Precondition Failed\n   This Response Code is like HTTP 412 \"\
    Precondition Failed\".\n"
- title: 5.9.2.9.  4.13 Request Entity Too Large
  contents:
  - "5.9.2.9.  4.13 Request Entity Too Large\n   This Response Code is like HTTP 413\
    \ \"Request Entity Too Large\".\n   The response SHOULD include a Size1 Option\
    \ (Section 5.10.9) to\n   indicate the maximum size of request entity the server\
    \ is able and\n   willing to handle, unless the server is not in a position to\
    \ make\n   this information available.\n"
- title: 5.9.2.10.  4.15 Unsupported Content-Format
  contents:
  - "5.9.2.10.  4.15 Unsupported Content-Format\n   This Response Code is like HTTP\
    \ 415 \"Unsupported Media Type\".\n"
- title: 5.9.3.  Server Error 5.xx
  contents:
  - "5.9.3.  Server Error 5.xx\n   This class of Response Code indicates cases in\
    \ which the server is\n   aware that it has erred or is incapable of performing\
    \ the request.\n   These Response Codes are applicable to any request method.\n\
    \   The server SHOULD include a diagnostic payload under the conditions\n   detailed\
    \ in Section 5.5.2.\n   Responses of this class are cacheable: Caches can use\
    \ the Max-Age\n   Option to determine freshness (see Section 5.6.1).  They cannot\
    \ be\n   validated.\n"
- title: 5.9.3.1.  5.00 Internal Server Error
  contents:
  - "5.9.3.1.  5.00 Internal Server Error\n   This Response Code is like HTTP 500\
    \ \"Internal Server Error\".\n"
- title: 5.9.3.2.  5.01 Not Implemented
  contents:
  - "5.9.3.2.  5.01 Not Implemented\n   This Response Code is like HTTP 501 \"Not\
    \ Implemented\".\n"
- title: 5.9.3.3.  5.02 Bad Gateway
  contents:
  - "5.9.3.3.  5.02 Bad Gateway\n   This Response Code is like HTTP 502 \"Bad Gateway\"\
    .\n"
- title: 5.9.3.4.  5.03 Service Unavailable
  contents:
  - "5.9.3.4.  5.03 Service Unavailable\n   This Response Code is like HTTP 503 \"\
    Service Unavailable\" but uses\n   the Max-Age Option in place of the \"Retry-After\"\
    \ header field to\n   indicate the number of seconds after which to retry.\n"
- title: 5.9.3.5.  5.04 Gateway Timeout
  contents:
  - "5.9.3.5.  5.04 Gateway Timeout\n   This Response Code is like HTTP 504 \"Gateway\
    \ Timeout\".\n"
- title: 5.9.3.6.  5.05 Proxying Not Supported
  contents:
  - "5.9.3.6.  5.05 Proxying Not Supported\n   The server is unable or unwilling to\
    \ act as a forward-proxy for the\n   URI specified in the Proxy-Uri Option or\
    \ using Proxy-Scheme (see\n   Section 5.10.2).\n"
- title: 5.10.  Option Definitions
  contents:
  - "5.10.  Option Definitions\n   The individual CoAP options are summarized in Table\
    \ 4 and explained\n   in the subsections of this section.\n   In this table, the\
    \ C, U, and N columns indicate the properties\n   Critical, UnSafe, and NoCacheKey,\
    \ respectively.  Since NoCacheKey\n   only has a meaning for options that are\
    \ Safe-to-Forward (not marked\n   Unsafe), the column is filled with a dash for\
    \ UnSafe options.\n   +-----+---+---+---+---+----------------+--------+--------+----------+\n\
    \   | No. | C | U | N | R | Name           | Format | Length | Default  |\n  \
    \ +-----+---+---+---+---+----------------+--------+--------+----------+\n   |\
    \   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |\n   |  \
    \ 3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |\n   |    \
    \ |   |   |   |   |                |        |        | below)   |\n   |   4 |\
    \   |   |   | x | ETag           | opaque | 1-8    | (none)   |\n   |   5 | x\
    \ |   |   |   | If-None-Match  | empty  | 0      | (none)   |\n   |   7 | x |\
    \ x | - |   | Uri-Port       | uint   | 0-2    | (see     |\n   |     |   |  \
    \ |   |   |                |        |        | below)   |\n   |   8 |   |   |\
    \   | x | Location-Path  | string | 0-255  | (none)   |\n   |  11 | x | x | -\
    \ | x | Uri-Path       | string | 0-255  | (none)   |\n   |  12 |   |   |   |\
    \   | Content-Format | uint   | 0-2    | (none)   |\n   |  14 |   | x | - |  \
    \ | Max-Age        | uint   | 0-4    | 60       |\n   |  15 | x | x | - | x |\
    \ Uri-Query      | string | 0-255  | (none)   |\n   |  17 | x |   |   |   | Accept\
    \         | uint   | 0-2    | (none)   |\n   |  20 |   |   |   | x | Location-Query\
    \ | string | 0-255  | (none)   |\n   |  35 | x | x | - |   | Proxy-Uri      |\
    \ string | 1-1034 | (none)   |\n   |  39 | x | x | - |   | Proxy-Scheme   | string\
    \ | 1-255  | (none)   |\n   |  60 |   |   | x |   | Size1          | uint   |\
    \ 0-4    | (none)   |\n   +-----+---+---+---+---+----------------+--------+--------+----------+\n\
    \             C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable\n             \
    \                Table 4: Options\n"
- title: 5.10.1.  Uri-Host, Uri-Port, Uri-Path, and Uri-Query
  contents:
  - "5.10.1.  Uri-Host, Uri-Port, Uri-Path, and Uri-Query\n   The Uri-Host, Uri-Port,\
    \ Uri-Path, and Uri-Query Options are used to\n   specify the target resource\
    \ of a request to a CoAP origin server.\n   The options encode the different components\
    \ of the request URI in a\n   way that no percent-encoding is visible in the option\
    \ values and that\n   the full URI can be reconstructed at any involved endpoint.\
    \  The\n   syntax of CoAP URIs is defined in Section 6.\n   The steps for parsing\
    \ URIs into options is defined in Section 6.4.\n   These steps result in zero\
    \ or more Uri-Host, Uri-Port, Uri-Path, and\n   Uri-Query Options being included\
    \ in a request, where each option\n   holds the following values:\n   o  the Uri-Host\
    \ Option specifies the Internet host of the resource\n      being requested,\n\
    \   o  the Uri-Port Option specifies the transport-layer port number of\n    \
    \  the resource,\n   o  each Uri-Path Option specifies one segment of the absolute\
    \ path to\n      the resource, and\n   o  each Uri-Query Option specifies one\
    \ argument parameterizing the\n      resource.\n   Note: Fragments ([RFC3986],\
    \ Section 3.5) are not part of the request\n   URI and thus will not be transmitted\
    \ in a CoAP request.\n   The default value of the Uri-Host Option is the IP literal\n\
    \   representing the destination IP address of the request message.\n   Likewise,\
    \ the default value of the Uri-Port Option is the destination\n   UDP port.  The\
    \ default values for the Uri-Host and Uri-Port Options\n   are sufficient for\
    \ requests to most servers.  Explicit Uri-Host and\n   Uri-Port Options are typically\
    \ used when an endpoint hosts multiple\n   virtual servers.\n   The Uri-Path and\
    \ Uri-Query Option can contain any character sequence.\n   No percent-encoding\
    \ is performed.  The value of a Uri-Path Option\n   MUST NOT be \".\" or \"..\"\
    \ (as the request URI must be resolved before\n   parsing it into options).\n\
    \   The steps for constructing the request URI from the options are\n   defined\
    \ in Section 6.5.  Note that an implementation does not\n   necessarily have to\
    \ construct the URI; it can simply look up the\n   target resource by examining\
    \ the individual options.\n   Examples can be found in Appendix B.\n"
- title: 5.10.2.  Proxy-Uri and Proxy-Scheme
  contents:
  - "5.10.2.  Proxy-Uri and Proxy-Scheme\n   The Proxy-Uri Option is used to make\
    \ a request to a forward-proxy\n   (see Section 5.7).  The forward-proxy is requested\
    \ to forward the\n   request or service it from a valid cache and return the response.\n\
    \   The option value is an absolute-URI ([RFC3986], Section 4.3).\n   Note that\
    \ the forward-proxy MAY forward the request on to another\n   proxy or directly\
    \ to the server specified by the absolute-URI.  In\n   order to avoid request\
    \ loops, a proxy MUST be able to recognize all\n   of its server names, including\
    \ any aliases, local variations, and the\n   numeric IP addresses.\n   An endpoint\
    \ receiving a request with a Proxy-Uri Option that is\n   unable or unwilling\
    \ to act as a forward-proxy for the request MUST\n   cause the return of a 5.05\
    \ (Proxying Not Supported) response.\n   The Proxy-Uri Option MUST take precedence\
    \ over any of the Uri-Host,\n   Uri-Port, Uri-Path or Uri-Query options (each\
    \ of which MUST NOT be\n   included in a request containing the Proxy-Uri Option).\n\
    \   As a special case to simplify many proxy clients, the absolute-URI\n   can\
    \ be constructed from the Uri-* options.  When a Proxy-Scheme\n   Option is present,\
    \ the absolute-URI is constructed as follows: a CoAP\n   URI is constructed from\
    \ the Uri-* options as defined in Section 6.5.\n   In the resulting URI, the initial\
    \ scheme up to, but not including,\n   the following colon is then replaced by\
    \ the content of the Proxy-\n   Scheme Option.  Note that this case is only applicable\
    \ if the\n   components of the desired URI other than the scheme component\n \
    \  actually can be expressed using Uri-* options; for example, to\n   represent\
    \ a URI with a userinfo component in the authority, only\n   Proxy-Uri can be\
    \ used.\n"
- title: 5.10.3.  Content-Format
  contents:
  - "5.10.3.  Content-Format\n   The Content-Format Option indicates the representation\
    \ format of the\n   message payload.  The representation format is given as a\
    \ numeric\n   Content-Format identifier that is defined in the \"CoAP Content-\n\
    \   Formats\" registry (Section 12.3).  In the absence of the option, no\n   default\
    \ value is assumed, i.e., the representation format of any\n   representation\
    \ message payload is indeterminate (Section 5.5).\n"
- title: 5.10.4.  Accept
  contents:
  - "5.10.4.  Accept\n   The CoAP Accept option can be used to indicate which Content-Format\n\
    \   is acceptable to the client.  The representation format is given as a\n  \
    \ numeric Content-Format identifier that is defined in the \"CoAP\n   Content-Formats\"\
    \ registry (Section 12.3).  If no Accept option is\n   given, the client does\
    \ not express a preference (thus no default\n   value is assumed).  The client\
    \ prefers the representation returned by\n   the server to be in the Content-Format\
    \ indicated.  The server returns\n   the preferred Content-Format if available.\
    \  If the preferred Content-\n   Format cannot be returned, then a 4.06 \"Not\
    \ Acceptable\" MUST be sent\n   as a response, unless another error code takes\
    \ precedence for this\n   response.\n"
- title: 5.10.5.  Max-Age
  contents:
  - "5.10.5.  Max-Age\n   The Max-Age Option indicates the maximum time a response\
    \ may be\n   cached before it is considered not fresh (see Section 5.6.1).\n \
    \  The option value is an integer number of seconds between 0 and\n   2**32-1\
    \ inclusive (about 136.1 years).  A default value of 60 seconds\n   is assumed\
    \ in the absence of the option in a response.\n   The value is intended to be\
    \ current at the time of transmission.\n   Servers that provide resources with\
    \ strict tolerances on the value of\n   Max-Age SHOULD update the value before\
    \ each retransmission.  (See\n   also Section 5.7.1.)\n"
- title: 5.10.6.  ETag
  contents:
  - "5.10.6.  ETag\n   An entity-tag is intended for use as a resource-local identifier\
    \ for\n   differentiating between representations of the same resource that\n\
    \   vary over time.  It is generated by the server providing the\n   resource,\
    \ which may generate it in any number of ways including a\n   version, checksum,\
    \ hash, or time.  An endpoint receiving an entity-\n   tag MUST treat it as opaque\
    \ and make no assumptions about its content\n   or structure.  (Endpoints that\
    \ generate an entity-tag are encouraged\n   to use the most compact representation\
    \ possible, in particular in\n   regards to clients and intermediaries that may\
    \ want to store multiple\n   ETag values.)\n"
- title: 5.10.6.1.  ETag as a Response Option
  contents:
  - "5.10.6.1.  ETag as a Response Option\n   The ETag Option in a response provides\
    \ the current value (i.e., after\n   the request was processed) of the entity-tag\
    \ for the \"tagged\n   representation\".  If no Location-* options are present,\
    \ the tagged\n   representation is the selected representation (Section 5.5.3)\
    \ of the\n   target resource.  If one or more Location-* options are present and\n\
    \   thus a location URI is indicated (Section 5.10.7), the tagged\n   representation\
    \ is the representation that would be retrieved by a GET\n   request to the location\
    \ URI.\n   An ETag response option can be included with any response for which\n\
    \   there is a tagged representation (e.g., it would not be meaningful in\n  \
    \ a 4.04 or 4.00 response).  The ETag Option MUST NOT occur more than\n   once\
    \ in a response.\n   There is no default value for the ETag Option; if it is not\
    \ present\n   in a response, the server makes no statement about the entity-tag\
    \ for\n   the tagged representation.\n"
- title: 5.10.6.2.  ETag as a Request Option
  contents:
  - "5.10.6.2.  ETag as a Request Option\n   In a GET request, an endpoint that has\
    \ one or more representations\n   previously obtained from the resource, and has\
    \ obtained ETag response\n   options with these, can specify an instance of the\
    \ ETag Option for\n   one or more of these stored responses.\n   A server can\
    \ issue a 2.03 Valid response (Section 5.9.1.3) in place\n   of a 2.05 Content\
    \ response if one of the ETags given is the entity-\n   tag for the current representation,\
    \ i.e., is valid; the 2.03 Valid\n   response then echoes this specific ETag in\
    \ a response option.\n   In effect, a client can determine if any of the stored\n\
    \   representations is current (see Section 5.6.2) without needing to\n   transfer\
    \ them again.\n   The ETag Option MAY occur zero, one, or multiple times in a\
    \ request.\n"
- title: 5.10.7.  Location-Path and Location-Query
  contents:
  - "5.10.7.  Location-Path and Location-Query\n   The Location-Path and Location-Query\
    \ Options together indicate a\n   relative URI that consists either of an absolute\
    \ path, a query\n   string, or both.  A combination of these options is included\
    \ in a\n   2.01 (Created) response to indicate the location of the resource\n\
    \   created as the result of a POST request (see Section 5.8.2).  The\n   location\
    \ is resolved relative to the request URI.\n   If a response with one or more\
    \ Location-Path and/or Location-Query\n   Options passes through a cache that\
    \ interprets these options and the\n   implied URI identifies one or more currently\
    \ stored responses, those\n   entries MUST be marked as not fresh.\n   Each Location-Path\
    \ Option specifies one segment of the absolute path\n   to the resource, and each\
    \ Location-Query Option specifies one\n   argument parameterizing the resource.\
    \  The Location-Path and\n   Location-Query Option can contain any character sequence.\
    \  No\n   percent-encoding is performed.  The value of a Location-Path Option\n\
    \   MUST NOT be \".\" or \"..\".\n   The steps for constructing the location URI\
    \ from the options are\n   analogous to Section 6.5, except that the first five\
    \ steps are\n   skipped and the result is a relative URI-reference, which is then\n\
    \   interpreted relative to the request URI.  Note that the relative URI-\n  \
    \ reference constructed this way always includes an absolute path\n   (e.g., leaving\
    \ out Location-Path but supplying Location-Query means\n   the path component\
    \ in the URI is \"/\").\n   The options that are used to compute the relative\
    \ URI-reference are\n   collectively called Location-* options.  Beyond Location-Path\
    \ and\n   Location-Query, more Location-* options may be defined in the future\n\
    \   and have been reserved option numbers 128, 132, 136, and 140.  If any\n  \
    \ of these reserved option numbers occurs in addition to Location-Path\n   and/or\
    \ Location-Query and are not supported, then a 4.02 (Bad Option)\n   error MUST\
    \ be returned.\n"
- title: 5.10.8.  Conditional Request Options
  contents:
  - "5.10.8.  Conditional Request Options\n   Conditional request options enable a\
    \ client to ask the server to\n   perform the request only if certain conditions\
    \ specified by the\n   option are fulfilled.\n   For each of these options, if\
    \ the condition given is not fulfilled,\n   then the server MUST NOT perform the\
    \ requested method.  Instead, the\n   server MUST respond with the 4.12 (Precondition\
    \ Failed) Response\n   Code.\n   If the condition is fulfilled, the server performs\
    \ the request method\n   as if the conditional request options were not present.\n\
    \   If the request would, without the conditional request options, result\n  \
    \ in anything other than a 2.xx or 4.12 Response Code, then any\n   conditional\
    \ request options MAY be ignored.\n"
- title: 5.10.8.1.  If-Match
  contents:
  - "5.10.8.1.  If-Match\n   The If-Match Option MAY be used to make a request conditional\
    \ on the\n   current existence or value of an ETag for one or more representations\n\
    \   of the target resource.  If-Match is generally useful for resource\n   update\
    \ requests, such as PUT requests, as a means for protecting\n   against accidental\
    \ overwrites when multiple clients are acting in\n   parallel on the same resource\
    \ (i.e., the \"lost update\" problem).\n   The value of an If-Match option is\
    \ either an ETag or the empty\n   string.  An If-Match option with an ETag matches\
    \ a representation\n   with that exact ETag.  An If-Match option with an empty\
    \ value matches\n   any existing representation (i.e., it places the precondition\
    \ on the\n   existence of any current representation for the target resource).\n\
    \   The If-Match Option can occur multiple times.  If any of the options\n   match,\
    \ then the condition is fulfilled.\n   If there is one or more If-Match Options,\
    \ but none of the options\n   match, then the condition is not fulfilled.\n"
- title: 5.10.8.2.  If-None-Match
  contents:
  - "5.10.8.2.  If-None-Match\n   The If-None-Match Option MAY be used to make a request\
    \ conditional on\n   the nonexistence of the target resource.  If-None-Match is\
    \ useful for\n   resource creation requests, such as PUT requests, as a means\
    \ for\n   protecting against accidental overwrites when multiple clients are\n\
    \   acting in parallel on the same resource.  The If-None-Match Option\n   carries\
    \ no value.\n   If the target resource does exist, then the condition is not\n\
    \   fulfilled.\n   (It is not very useful to combine If-Match and If-None-Match\
    \ options\n   in one request, because the condition will then never be fulfilled.)\n"
- title: 5.10.9.  Size1 Option
  contents:
  - "5.10.9.  Size1 Option\n   The Size1 option provides size information about the\
    \ resource\n   representation in a request.  The option value is an integer number\n\
    \   of bytes.  Its main use is with block-wise transfers [BLOCK].  In the\n  \
    \ present specification, it is used in 4.13 responses (Section 5.9.2.9)\n   to\
    \ indicate the maximum size of request entity that the server is\n   able and\
    \ willing to handle.\n"
- title: 6.  CoAP URIs
  contents:
  - "6.  CoAP URIs\n   CoAP uses the \"coap\" and \"coaps\" URI schemes for identifying\
    \ CoAP\n   resources and providing a means of locating the resource.  Resources\n\
    \   are organized hierarchically and governed by a potential CoAP origin\n   server\
    \ listening for CoAP requests (\"coap\") or DTLS-secured CoAP\n   requests (\"\
    coaps\") on a given UDP port.  The CoAP server is\n   identified via the generic\
    \ syntax's authority component, which\n   includes a host component and optional\
    \ UDP port number.  The\n   remainder of the URI is considered to be identifying\
    \ a resource that\n   can be operated on by the methods defined by the CoAP protocol.\
    \  The\n   \"coap\" and \"coaps\" URI schemes can thus be compared to the \"http\"\
    \ and\n   \"https\" URI schemes, respectively.\n   The syntax of the \"coap\"\
    \ and \"coaps\" URI schemes is specified in this\n   section in Augmented Backus-Naur\
    \ Form (ABNF) [RFC5234].  The\n   definitions of \"host\", \"port\", \"path-abempty\"\
    , \"query\", \"segment\",\n   \"IP-literal\", \"IPv4address\", and \"reg-name\"\
    \ are adopted from\n   [RFC3986].\n   Implementation Note:  Unfortunately, over\
    \ time, the URI format has\n      acquired significant complexity.  Implementers\
    \ are encouraged to\n      examine [RFC3986] closely.  For example, the ABNF for\
    \ IPv6\n      addresses is more complicated than maybe expected.  Also,\n    \
    \  implementers should take care to perform the processing of\n      percent-decoding\
    \ or percent-encoding exactly once on the way from\n      a URI to its decoded\
    \ components or back.  Percent-encoding is\n      crucial for data transparency\
    \ but may lead to unusual results such\n      as a slash character in a path component.\n"
- title: 6.1.  coap URI Scheme
  contents:
  - "6.1.  coap URI Scheme\n   coap-URI = \"coap:\" \"//\" host [ \":\" port ] path-abempty\
    \ [ \"?\" query ]\n   If the host component is provided as an IP-literal or IPv4address,\n\
    \   then the CoAP server can be reached at that IP address.  If host is a\n  \
    \ registered name, then that name is considered an indirect identifier\n   and\
    \ the endpoint might use a name resolution service, such as DNS, to\n   find the\
    \ address of that host.  The host MUST NOT be empty; if a URI\n   is received\
    \ with a missing authority or an empty host, then it MUST\n   be considered invalid.\
    \  The port subcomponent indicates the UDP port\n   at which the CoAP server is\
    \ located.  If it is empty or not given,\n   then the default port 5683 is assumed.\n\
    \   The path identifies a resource within the scope of the host and port.\n  \
    \ It consists of a sequence of path segments separated by a slash\n   character\
    \ (U+002F SOLIDUS \"/\").\n   The query serves to further parameterize the resource.\
    \  It consists\n   of a sequence of arguments separated by an ampersand character\n\
    \   (U+0026 AMPERSAND \"&\").  An argument is often in the form of a\n   \"key=value\"\
    \ pair.\n   The \"coap\" URI scheme supports the path prefix \"/.well-known/\"\
    \n   defined by [RFC5785] for \"well-known locations\" in the namespace of a\n\
    \   host.  This enables discovery of policy or other information about a\n   host\
    \ (\"site-wide metadata\"), such as hosted resources (see\n   Section 7).\n  \
    \ Application designers are encouraged to make use of short but\n   descriptive\
    \ URIs.  As the environments that CoAP is used in are\n   usually constrained\
    \ for bandwidth and energy, the trade-off between\n   these two qualities should\
    \ lean towards the shortness, without\n   ignoring descriptiveness.\n"
- title: 6.2.  coaps URI Scheme
  contents:
  - "6.2.  coaps URI Scheme\n   coaps-URI = \"coaps:\" \"//\" host [ \":\" port ]\
    \ path-abempty\n               [ \"?\" query ]\n   All of the requirements listed\
    \ above for the \"coap\" scheme are also\n   requirements for the \"coaps\" scheme,\
    \ except that a default UDP port\n   of 5684 is assumed if the port subcomponent\
    \ is empty or not given,\n   and the UDP datagrams MUST be secured through the\
    \ use of DTLS as\n   described in Section 9.1.\n   Considerations for caching\
    \ of responses to \"coaps\" identified\n   requests are discussed in Section 11.2.\n\
    \   Resources made available via the \"coaps\" scheme have no shared\n   identity\
    \ with the \"coap\" scheme even if their resource identifiers\n   indicate the\
    \ same authority (the same host listening to the same UDP\n   port).  They are\
    \ distinct namespaces and are considered to be\n   distinct origin servers.\n"
- title: 6.3.  Normalization and Comparison Rules
  contents:
  - "6.3.  Normalization and Comparison Rules\n   Since the \"coap\" and \"coaps\"\
    \ schemes conform to the URI generic\n   syntax, such URIs are normalized and\
    \ compared according to the\n   algorithm defined in [RFC3986], Section 6, using\
    \ the defaults\n   described above for each scheme.\n   If the port is equal to\
    \ the default port for a scheme, the normal\n   form is to elide the port subcomponent.\
    \  Likewise, an empty path\n   component is equivalent to an absolute path of\
    \ \"/\", so the normal\n   form is to provide a path of \"/\" instead.  The scheme\
    \ and host are\n   case insensitive and normally provided in lowercase; IP-literals\
    \ are\n   in recommended form [RFC5952]; all other components are compared in\
    \ a\n   case-sensitive manner.  Characters other than those in the \"reserved\"\
    \n   set are equivalent to their percent-encoded bytes (see [RFC3986],\n   Section\
    \ 2.1): the normal form is to not encode them.\n   For example, the following\
    \ three URIs are equivalent and cause the\n   same options and option values to\
    \ appear in the CoAP messages:\n   coap://example.com:5683/~sensors/temp.xml\n\
    \   coap://EXAMPLE.com/%7Esensors/temp.xml\n   coap://EXAMPLE.com:/%7esensors/temp.xml\n"
- title: 6.4.  Decomposing URIs into Options
  contents:
  - "6.4.  Decomposing URIs into Options\n   The steps to parse a request's options\
    \ from a string |url| are as\n   follows.  These steps either result in zero or\
    \ more of the Uri-Host,\n   Uri-Port, Uri-Path, and Uri-Query Options being included\
    \ in the\n   request or they fail.\n   1.  If the |url| string is not an absolute\
    \ URI ([RFC3986]), then fail\n       this algorithm.\n   2.  Resolve the |url|\
    \ string using the process of reference\n       resolution defined by [RFC3986].\
    \  At this stage, the URL is in\n       ASCII encoding [RFC0020], even though\
    \ the decoded components will\n       be interpreted in UTF-8 [RFC3629] after\
    \ steps 5, 8, and 9.\n       NOTE: It doesn't matter what it is resolved relative\
    \ to, since we\n       already know it is an absolute URL at this point.\n   3.\
    \  If |url| does not have a <scheme> component whose value, when\n       converted\
    \ to ASCII lowercase, is \"coap\" or \"coaps\", then fail\n       this algorithm.\n\
    \   4.  If |url| has a <fragment> component, then fail this algorithm.\n   5.\
    \  If the <host> component of |url| does not represent the request's\n       destination\
    \ IP address as an IP-literal or IPv4address, include a\n       Uri-Host Option\
    \ and let that option's value be the value of the\n       <host> component of\
    \ |url|, converted to ASCII lowercase, and then\n       convert all percent-encodings\
    \ (\"%\" followed by two hexadecimal\n       digits) to the corresponding characters.\n\
    \       NOTE: In the usual case where the request's destination IP\n       address\
    \ is derived from the host part, this ensures that a Uri-\n       Host Option\
    \ is only used for a <host> component of the form reg-\n       name.\n   6.  If\
    \ |url| has a <port> component, then let |port| be that\n       component's value\
    \ interpreted as a decimal integer; otherwise,\n       let |port| be the default\
    \ port for the scheme.\n   7.  If |port| does not equal the request's destination\
    \ UDP port,\n       include a Uri-Port Option and let that option's value be |port|.\n\
    \   8.  If the value of the <path> component of |url| is empty or\n       consists\
    \ of a single slash character (U+002F SOLIDUS \"/\"), then\n       move to the\
    \ next step.\n       Otherwise, for each segment in the <path> component, include\
    \ a\n       Uri-Path Option and let that option's value be the segment (not\n\
    \       including the delimiting slash characters) after converting each\n   \
    \    percent-encoding (\"%\" followed by two hexadecimal digits) to the\n    \
    \   corresponding byte.\n   9.  If |url| has a <query> component, then, for each\
    \ argument in the\n       <query> component, include a Uri-Query Option and let\
    \ that\n       option's value be the argument (not including the question mark\n\
    \       and the delimiting ampersand characters) after converting each\n     \
    \  percent-encoding to the corresponding byte.\n   Note that these rules completely\
    \ resolve any percent-encoding.\n"
- title: 6.5.  Composing URIs from Options
  contents:
  - "6.5.  Composing URIs from Options\n   The steps to construct a URI from a request's\
    \ options are as follows.\n   These steps either result in a URI or they fail.\
    \  In these steps,\n   percent-encoding a character means replacing each of its\n\
    \   (UTF-8-encoded) bytes by a \"%\" character followed by two hexadecimal\n \
    \  digits representing the byte, where the digits A-F are in uppercase\n   (as\
    \ defined in Section 2.1 of [RFC3986]; to reduce variability, the\n   hexadecimal\
    \ notation for percent-encoding in CoAP URIs MUST use\n   uppercase letters).\
    \  The definitions of \"unreserved\" and \"sub-delims\"\n   are adopted from [RFC3986].\n\
    \   1.   If the request is secured using DTLS, let |url| be the string\n     \
    \   \"coaps://\".  Otherwise, let |url| be the string \"coap://\".\n   2.   If\
    \ the request includes a Uri-Host Option, let |host| be that\n        option's\
    \ value, where any non-ASCII characters are replaced by\n        their corresponding\
    \ percent-encoding.  If |host| is not a valid\n        reg-name or IP-literal\
    \ or IPv4address, fail the algorithm.  If\n        the request does not include\
    \ a Uri-Host Option, let |host| be\n        the IP-literal (making use of the\
    \ conventions of [RFC5952]) or\n        IPv4address representing the request's\
    \ destination IP address.\n   3.   Append |host| to |url|.\n   4.   If the request\
    \ includes a Uri-Port Option, let |port| be that\n        option's value.  Otherwise,\
    \ let |port| be the request's\n        destination UDP port.\n   5.   If |port|\
    \ is not the default port for the scheme, then append a\n        single U+003A\
    \ COLON character (:) followed by the decimal\n        representation of |port|\
    \ to |url|.\n   6.   Let |resource name| be the empty string.  For each Uri-Path\n\
    \        Option in the request, append a single character U+002F SOLIDUS\n   \
    \     (/) followed by the option's value to |resource name|, after\n        converting\
    \ any character that is not either in the \"unreserved\"\n        set, in the\
    \ \"sub-delims\" set, a U+003A COLON (:) character, or a\n        U+0040 COMMERCIAL\
    \ AT (@) character to its percent-encoded form.\n   7.   If |resource name| is\
    \ the empty string, set it to a single\n        character U+002F SOLIDUS (/).\n\
    \   8.   For each Uri-Query Option in the request, append a single\n        character\
    \ U+003F QUESTION MARK (?) (first option) or U+0026\n        AMPERSAND (&) (subsequent\
    \ options) followed by the option's\n        value to |resource name|, after converting\
    \ any character that is\n        not either in the \"unreserved\" set, in the\
    \ \"sub-delims\" set\n        (except U+0026 AMPERSAND (&)), a U+003A COLON (:),\
    \ a U+0040\n        COMMERCIAL AT (@), a U+002F SOLIDUS (/), or a U+003F QUESTION\n\
    \        MARK (?) character to its percent-encoded form.\n   9.   Append |resource\
    \ name| to |url|.\n   10.  Return |url|.\n   Note that these steps have been designed\
    \ to lead to a URI in normal\n   form (see Section 6.3).\n"
- title: 7.  Discovery
  contents:
  - '7.  Discovery

    '
- title: 7.1.  Service Discovery
  contents:
  - "7.1.  Service Discovery\n   As a part of discovering the services offered by\
    \ a CoAP server, a\n   client has to learn about the endpoint used by a server.\n\
    \   A server is discovered by a client (knowing or) learning a URI that\n   references\
    \ a resource in the namespace of the server.  Alternatively,\n   clients can use\
    \ multicast CoAP (see Section 8) and the \"All CoAP\n   Nodes\" multicast address\
    \ to find CoAP servers.\n   Unless the port subcomponent in a \"coap\" or \"coaps\"\
    \ URI indicates the\n   UDP port at which the CoAP server is located, the server\
    \ is assumed\n   to be reachable at the default port.\n   The CoAP default port\
    \ number 5683 MUST be supported by a server that\n   offers resources for resource\
    \ discovery (see Section 7.2 below) and\n   SHOULD be supported for providing\
    \ access to other resources.  The\n   default port number 5684 for DTLS-secured\
    \ CoAP MAY be supported by a\n   server for resource discovery and for providing\
    \ access to other\n   resources.  In addition, other endpoints may be hosted at\
    \ other\n   ports, e.g., in the dynamic port space.\n   Implementation Note: \
    \ When a CoAP server is hosted by a 6LoWPAN node,\n      header compression efficiency\
    \ is improved when it also supports a\n      port number in the 61616-61631 compressed\
    \ UDP port space defined\n      in [RFC4944] and [RFC6282].  (Note that, as its\
    \ UDP port differs\n      from the default port, it is a different endpoint from\
    \ the server\n      at the default port.)\n"
- title: 7.2.  Resource Discovery
  contents:
  - "7.2.  Resource Discovery\n   The discovery of resources offered by a CoAP endpoint\
    \ is extremely\n   important in machine-to-machine applications where there are\
    \ no\n   humans in the loop and static interfaces result in fragility.  To\n \
    \  maximize interoperability in a CoRE environment, a CoAP endpoint\n   SHOULD\
    \ support the CoRE Link Format of discoverable resources as\n   described in [RFC6690],\
    \ except where fully manual configuration is\n   desired.  It is up to the server\
    \ which resources are made\n   discoverable (if any).\n"
- title: 7.2.1.  'ct' Attribute
  contents:
  - "7.2.1.  'ct' Attribute\n   This section defines a new Web Linking [RFC5988] attribute\
    \ for use\n   with [RFC6690].  The Content-Format code \"ct\" attribute provides\
    \ a\n   hint about the Content-Formats this resource returns.  Note that this\n\
    \   is only a hint, and it does not override the Content-Format Option of\n  \
    \ a CoAP response obtained by actually requesting the representation of\n   the\
    \ resource.  The value is in the CoAP identifier code format as a\n   decimal\
    \ ASCII integer and MUST be in the range of 0-65535 (16-bit\n   unsigned integer).\
    \  For example, \"application/xml\" would be indicated\n   as \"ct=41\".  If no\
    \ Content-Format code attribute is present, then\n   nothing about the type can\
    \ be assumed.  The Content-Format code\n   attribute MAY include a space-separated\
    \ sequence of Content-Format\n   codes, indicating that multiple content-formats\
    \ are available.  The\n   syntax of the attribute value is summarized in the production\
    \ \"ct-\n   value\" in Figure 12, where \"cardinal\", \"SP\", and \"DQUOTE\" are\
    \ defined\n   as in [RFC6690].\n      ct-value =  cardinal\n               / \
    \ DQUOTE cardinal *( 1*SP cardinal ) DQUOTE\n                                \
    \ Figure 12\n"
- title: 8.  Multicast CoAP
  contents:
  - "8.  Multicast CoAP\n   CoAP supports making requests to an IP multicast group.\
    \  This is\n   defined by a series of deltas to unicast CoAP.  A more general\n\
    \   discussion of group communication with CoAP is in [GROUPCOMM].\n   CoAP endpoints\
    \ that offer services that they want other endpoints to\n   be able to find using\
    \ multicast service discovery join one or more of\n   the appropriate all-CoAP-node\
    \ multicast addresses (Section 12.8) and\n   listen on the default CoAP port.\
    \  Note that an endpoint might receive\n   multicast requests on other multicast\
    \ addresses, including the all-\n   nodes IPv6 address (or via broadcast on IPv4);\
    \ an endpoint MUST\n   therefore be prepared to receive such messages but MAY\
    \ ignore them if\n   multicast service discovery is not desired.\n"
- title: 8.1.  Messaging Layer
  contents:
  - "8.1.  Messaging Layer\n   A multicast request is characterized by being transported\
    \ in a CoAP\n   message that is addressed to an IP multicast address instead of\
    \ a\n   CoAP endpoint.  Such multicast requests MUST be Non-confirmable.\n   A\
    \ server SHOULD be aware that a request arrived via multicast, e.g.,\n   by making\
    \ use of modern APIs such as IPV6_RECVPKTINFO [RFC3542], if\n   available.\n \
    \  To avoid an implosion of error responses, when a server is aware that\n   a\
    \ request arrived via multicast, it MUST NOT return a Reset message\n   in reply\
    \ to a Non-confirmable message.  If it is not aware, it MAY\n   return a Reset\
    \ message in reply to a Non-confirmable message as\n   usual.  Because such a\
    \ Reset message will look identical to one for a\n   unicast message from the\
    \ sender, the sender MUST avoid using a\n   Message ID that is also still active\
    \ from this endpoint with any\n   unicast endpoint that might receive the multicast\
    \ message.\n   At the time of writing, multicast messages can only be carried\
    \ in UDP\n   not in DTLS.  This means that the security modes defined for CoAP\
    \ in\n   this document are not applicable to multicast.\n"
- title: 8.2.  Request/Response Layer
  contents:
  - "8.2.  Request/Response Layer\n   When a server is aware that a request arrived\
    \ via multicast, the\n   server MAY always ignore the request, in particular if\
    \ it doesn't\n   have anything useful to respond (e.g., if it only has an empty\n\
    \   payload or an error response).  The decision for this may depend on\n   the\
    \ application.  (For example, in query filtering as described in\n   [RFC6690],\
    \ a server should not respond to a multicast request if the\n   filter does not\
    \ match.  More examples are in [GROUPCOMM].)\n   If a server does decide to respond\
    \ to a multicast request, it should\n   not respond immediately.  Instead, it\
    \ should pick a duration for the\n   period of time during which it intends to\
    \ respond.  For the purposes\n   of this exposition, we call the length of this\
    \ period the Leisure.\n   The specific value of this Leisure may depend on the\
    \ application or\n   MAY be derived as described below.  The server SHOULD then\
    \ pick a\n   random point of time within the chosen leisure period to send back\n\
    \   the unicast response to the multicast request.  If further responses\n   need\
    \ to be sent based on the same multicast address membership, a new\n   leisure\
    \ period starts at the earliest after the previous one\n   finishes.\n   To compute\
    \ a value for Leisure, the server should have a group size\n   estimate G, a target\
    \ data transfer rate R (which both should be\n   chosen conservatively), and an\
    \ estimated response size S; a rough\n   lower bound for Leisure can then be computed\
    \ as\n                          lb_Leisure = S * G / R\n   For example, for a\
    \ multicast request with link-local scope on a 2.4\n   GHz IEEE 802.15.4 (6LoWPAN)\
    \ network, G could be (relatively\n   conservatively) set to 100, S to 100 bytes,\
    \ and the target rate to 8\n   kbit/s = 1 kB/s.  The resulting lower bound for\
    \ the Leisure is 10\n   seconds.\n   If a CoAP endpoint does not have suitable\
    \ data to compute a value for\n   Leisure, it MAY resort to DEFAULT_LEISURE.\n\
    \   When matching a response to a multicast request, only the token MUST\n   match;\
    \ the source endpoint of the response does not need to (and will\n   not) be the\
    \ same as the destination endpoint of the original request.\n   For the purposes\
    \ of interpreting the Location-* options and any links\n   embedded in the representation,\
    \ the request URI (i.e., the base URI\n   relative to which the response is interpreted)\
    \ is formed by replacing\n   the multicast address in the Host component of the\
    \ original request\n   URI by the literal IP address of the endpoint actually\
    \ responding.\n"
- title: 8.2.1.  Caching
  contents:
  - "8.2.1.  Caching\n   When a client makes a multicast request, it always makes\
    \ a new\n   request to the multicast group (since there may be new group members\n\
    \   that joined meanwhile or ones that did not get the previous request).\n  \
    \ It MAY update a cache with the received responses.  Then, it uses\n   both cached-still-fresh\
    \ and new responses as the result of the\n   request.\n   A response received\
    \ in reply to a GET request to a multicast group\n   MAY be used to satisfy a\
    \ subsequent request on the related unicast\n   request URI.  The unicast request\
    \ URI is obtained by replacing the\n   authority part of the request URI with\
    \ the transport-layer source\n   address of the response message.\n   A cache\
    \ MAY revalidate a response by making a GET request on the\n   related unicast\
    \ request URI.\n   A GET request to a multicast group MUST NOT contain an ETag\
    \ option.\n   A mechanism to suppress responses the client already has is left\
    \ for\n   further study.\n"
- title: 8.2.2.  Proxying
  contents:
  - "8.2.2.  Proxying\n   When a forward-proxy receives a request with a Proxy-Uri\
    \ or URI\n   constructed from Proxy-Scheme that indicates a multicast address,\
    \ the\n   proxy obtains a set of responses as described above and sends all\n\
    \   responses (both cached-still-fresh and new) back to the original\n   client.\n\
    \   This specification does not provide a way to indicate the unicast-\n   modified\
    \ request URI (base URI) in responses thus forwarded.\n   Proxying multicast requests\
    \ is discussed in more detail in\n   [GROUPCOMM]; one proposal to address the\
    \ base URI issue can be found\n   in Section 3 of [CoAP-MISC].\n"
- title: 9.  Securing CoAP
  contents:
  - "9.  Securing CoAP\n   This section defines the DTLS binding for CoAP.\n   During\
    \ the provisioning phase, a CoAP device is provided with the\n   security information\
    \ that it needs, including keying materials and\n   access control lists.  This\
    \ specification defines provisioning for\n   the RawPublicKey mode in Section\
    \ 9.1.3.2.1.  At the end of the\n   provisioning phase, the device will be in\
    \ one of four security modes\n   with the following information for the given\
    \ mode.  The NoSec and\n   RawPublicKey modes are mandatory to implement for this\
    \ specification.\n   NoSec:  There is no protocol-level security (DTLS is disabled).\n\
    \      Alternative techniques to provide lower-layer security SHOULD be\n    \
    \  used when appropriate.  The use of IPsec is discussed in\n      [IPsec-CoAP].\
    \  Certain link layers in use with constrained nodes\n      also provide link-layer\
    \ security, which may be appropriate with\n      proper key management.\n   PreSharedKey:\
    \  DTLS is enabled, there is a list of pre-shared keys\n      [RFC4279], and each\
    \ key includes a list of which nodes it can be\n      used to communicate with\
    \ as described in Section 9.1.3.1.  At the\n      extreme, there may be one key\
    \ for each node this CoAP node needs\n      to communicate with (1:1 node/key\
    \ ratio).  Conversely, if more\n      than two entities share a specific pre-shared\
    \ key, this key only\n      enables the entities to authenticate as a member of\
    \ that group and\n      not as a specific peer.\n   RawPublicKey:  DTLS is enabled\
    \ and the device has an asymmetric key\n      pair without a certificate (a raw\
    \ public key) that is validated\n      using an out-of-band mechanism [RFC7250]\
    \ as described in\n      Section 9.1.3.2.  The device also has an identity calculated\
    \ from\n      the public key and a list of identities of the nodes it can\n  \
    \    communicate with.\n   Certificate:  DTLS is enabled and the device has an\
    \ asymmetric key\n      pair with an X.509 certificate [RFC5280] that binds it\
    \ to its\n      subject and is signed by some common trust root as described in\n\
    \      Section 9.1.3.3.  The device also has a list of root trust anchors\n  \
    \    that can be used for validating a certificate.\n   In the \"NoSec\" mode,\
    \ the system simply sends the packets over normal\n   UDP over IP and is indicated\
    \ by the \"coap\" scheme and the CoAP\n   default port.  The system is secured\
    \ only by keeping attackers from\n   being able to send or receive packets from\
    \ the network with the CoAP\n   nodes; see Section 11.5 for an additional complication\
    \ with this\n   approach.\n   The other three security modes are achieved using\
    \ DTLS and are\n   indicated by the \"coaps\" scheme and DTLS-secured CoAP default\
    \ port.\n   The result is a security association that can be used to authenticate\n\
    \   (within the limits of the security model) and, based on this\n   authentication,\
    \ authorize the communication partner.  CoAP itself\n   does not provide protocol\
    \ primitives for authentication or\n   authorization; where this is required,\
    \ it can either be provided by\n   communication security (i.e., IPsec or DTLS)\
    \ or by object security\n   (within the payload).  Devices that require authorization\
    \ for certain\n   operations are expected to require one of these two forms of\n\
    \   security.  Necessarily, where an intermediary is involved,\n   communication\
    \ security only works when that intermediary is part of\n   the trust relationships.\
    \  CoAP does not provide a way to forward\n   different levels of authorization\
    \ that clients may have with an\n   intermediary to further intermediaries or\
    \ origin servers -- it\n   therefore may be required to perform all authorization\
    \ at the first\n   intermediary.\n"
- title: 9.1.  DTLS-Secured CoAP
  contents:
  - "9.1.  DTLS-Secured CoAP\n   Just as HTTP is secured using Transport Layer Security\
    \ (TLS) over\n   TCP, CoAP is secured using Datagram TLS (DTLS) [RFC6347] over\
    \ UDP\n   (see Figure 13).  This section defines the CoAP binding to DTLS,\n \
    \  along with the minimal mandatory-to-implement configurations\n   appropriate\
    \ for constrained environments.  The binding is defined by\n   a series of deltas\
    \ to unicast CoAP.  In practice, DTLS is TLS with\n   added features to deal with\
    \ the unreliable nature of the UDP\n   transport.\n                         +----------------------+\n\
    \                         |      Application     |\n                         +----------------------+\n\
    \                         +----------------------+\n                         |\
    \  Requests/Responses  |\n                         |----------------------|  CoAP\n\
    \                         |       Messages       |\n                         +----------------------+\n\
    \                         +----------------------+\n                         |\
    \         DTLS         |\n                         +----------------------+\n\
    \                         +----------------------+\n                         |\
    \          UDP         |\n                         +----------------------+\n\
    \             Figure 13: Abstract Layering of DTLS-Secured CoAP\n   In some constrained\
    \ nodes (limited flash and/or RAM) and networks\n   (limited bandwidth or high\
    \ scalability requirements), and depending\n   on the specific cipher suites in\
    \ use, all modes of DTLS may not be\n   applicable.  Some DTLS cipher suites can\
    \ add significant\n   implementation complexity as well as some initial handshake\
    \ overhead\n   needed when setting up the security association.  Once the initial\n\
    \   handshake is completed, DTLS adds a limited per-datagram overhead of\n   approximately\
    \ 13 bytes, not including any initialization vectors/\n   nonces (e.g., 8 bytes\
    \ with TLS_PSK_WITH_AES_128_CCM_8 [RFC6655]),\n   integrity check values (e.g.,\
    \ 8 bytes with TLS_PSK_WITH_AES_128_CCM_8\n   [RFC6655]), and padding required\
    \ by the cipher suite.  Whether the\n   use of a given mode of DTLS is applicable\
    \ for a CoAP-based\n   application should be carefully weighed considering the\
    \ specific\n   cipher suites that may be applicable, whether the session maintenance\n\
    \   makes it compatible with application flows, and whether sufficient\n   resources\
    \ are available on the constrained nodes and for the added\n   network overhead.\
    \  (For some modes of using DTLS, this specification\n   identifies a mandatory-to-implement\
    \ cipher suite.  This is an\n   implementation requirement to maximize interoperability\
    \ in those\n   cases where these cipher suites are indeed appropriate.  The specific\n\
    \   security policies of an application may determine the actual set of\n   cipher\
    \ suites that can be used.)  DTLS is not applicable to group\n   keying (multicast\
    \ communication); however, it may be a component in a\n   future group key management\
    \ protocol.\n"
- title: 9.1.1.  Messaging Layer
  contents:
  - "9.1.1.  Messaging Layer\n   The endpoint acting as the CoAP client should also\
    \ act as the DTLS\n   client.  It should initiate a session to the server on the\n\
    \   appropriate port.  When the DTLS handshake has finished, the client\n   may\
    \ initiate the first CoAP request.  All CoAP messages MUST be sent\n   as DTLS\
    \ \"application data\".\n   The following rules are added for matching an Acknowledgement\
    \ message\n   or Reset message to a Confirmable message, or a Reset message to\
    \ a\n   Non-confirmable message: The DTLS session MUST be the same, and the\n\
    \   epoch MUST be the same.\n   A message is the same when it is sent within the\
    \ same DTLS session\n   and same epoch and has the same Message ID.\n   Note:\
    \ When a Confirmable message is retransmitted, a new DTLS\n   sequence_number\
    \ is used for each attempt, even though the CoAP\n   Message ID stays the same.\
    \  So a recipient still has to perform\n   deduplication as described in Section\
    \ 4.5.  Retransmissions MUST NOT\n   be performed across epochs.\n   DTLS connections\
    \ in RawPublicKey and Certificate mode are set up\n   using mutual authentication\
    \ so they can remain up and be reused for\n   future message exchanges in either\
    \ direction.  Devices can close a\n   DTLS connection when they need to recover\
    \ resources, but in general\n   they should keep the connection up for as long\
    \ as possible.  Closing\n   the DTLS connection after every CoAP message exchange\
    \ is very\n   inefficient.\n"
- title: 9.1.2.  Request/Response Layer
  contents:
  - "9.1.2.  Request/Response Layer\n   The following rules are added for matching\
    \ a response to a request:\n   The DTLS session MUST be the same, and the epoch\
    \ MUST be the same.\n   This means the response to a DTLS secured request MUST\
    \ always be DTLS\n   secured using the same security session and epoch.  Any attempt\
    \ to\n   supply a NoSec response to a DTLS request simply does not match the\n\
    \   request and therefore MUST be rejected (unless it does match an\n   unrelated\
    \ NoSec request).\n"
- title: 9.1.3.  Endpoint Identity
  contents:
  - "9.1.3.  Endpoint Identity\n   Devices SHOULD support the Server Name Indication\
    \ (SNI) to indicate\n   their authority in the SNI HostName field as defined in\
    \ Section 3 of\n   [RFC6066].  This is needed so that when a host that acts as\
    \ a virtual\n   server for multiple Authorities receives a new DTLS connection,\
    \ it\n   knows which keys to use for the DTLS session.\n"
- title: 9.1.3.1.  Pre-Shared Keys
  contents:
  - "9.1.3.1.  Pre-Shared Keys\n   When forming a connection to a new node, the system\
    \ selects an\n   appropriate key based on which nodes it is trying to reach and\
    \ then\n   forms a DTLS session using a PSK (Pre-Shared Key) mode of DTLS.\n \
    \  Implementations in these modes MUST support the mandatory-to-\n   implement\
    \ cipher suite TLS_PSK_WITH_AES_128_CCM_8 as specified in\n   [RFC6655].\n   Depending\
    \ on the commissioning model, applications may need to define\n   an application\
    \ profile for identity hints (as required and detailed\n   in Section 5.2 of [RFC4279])\
    \ to enable the use of PSK identity hints.\n   The security considerations of\
    \ Section 7 of [RFC4279] apply.  In\n   particular, applications should carefully\
    \ weigh whether or not they\n   need Perfect Forward Secrecy (PFS) and select\
    \ an appropriate cipher\n   suite (Section 7.1 of [RFC4279]).  The entropy of\
    \ the PSK must be\n   sufficient to mitigate against brute-force and (where the\
    \ PSK is not\n   chosen randomly but by a human) dictionary attacks (Section 7.2\
    \ of\n   [RFC4279]).  The cleartext communication of client identities may\n \
    \  leak data or compromise privacy (Section 7.3 of [RFC4279]).\n"
- title: 9.1.3.2.  Raw Public Key Certificates
  contents:
  - "9.1.3.2.  Raw Public Key Certificates\n   In this mode, the device has an asymmetric\
    \ key pair but without an\n   X.509 certificate (called a raw public key); for\
    \ example, the\n   asymmetric key pair is generated by the manufacturer and installed\
    \ on\n   the device (see also Section 11.6).  A device MAY be configured with\n\
    \   multiple raw public keys.  The type and length of the raw public key\n   depends\
    \ on the cipher suite used.  Implementations in RawPublicKey\n   mode MUST support\
    \ the mandatory-to-implement cipher suite\n   TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\
    \ as specified in [RFC7251],\n   [RFC5246], and [RFC4492].  The key used MUST\
    \ be ECDSA capable.  The\n   curve secp256r1 MUST be supported [RFC4492]; this\
    \ curve is equivalent\n   to the NIST P-256 curve.  The hash algorithm is SHA-256.\n\
    \   Implementations MUST use the Supported Elliptic Curves and Supported\n   Point\
    \ Formats Extensions [RFC4492]; the uncompressed point format\n   MUST be supported;\
    \ [RFC6090] can be used as an implementation method.\n   Some guidance relevant\
    \ to the implementation of this cipher suite can\n   be found in [W3CXMLSEC].\
    \  The mechanism for using raw public keys\n   with TLS is specified in [RFC7250].\n\
    \   Implementation Note:  Specifically, this means the extensions listed\n   \
    \   in Figure 14 with at least the values listed will be present in\n      the\
    \ DTLS handshake.\n   Extension: elliptic_curves\n    Type: elliptic_curves (0x000a)\n\
    \    Length: 4\n    Elliptic Curves Length: 2\n    Elliptic curves (1 curve)\n\
    \      Elliptic curve: secp256r1 (0x0017)\n   Extension: ec_point_formats\n  \
    \  Type: ec_point_formats (0x000b)\n    Length: 2\n    EC point formats Length:\
    \ 1\n    Elliptic curves point formats (1)\n      EC point format: uncompressed\
    \ (0)\n   Extension: signature_algorithms\n    Type: signature_algorithms (0x000d)\n\
    \    Length: 4\n    Data (4 bytes): 00 02 04 03\n      HashAlgorithm: sha256 (4)\n\
    \      SignatureAlgorithm: ecdsa (3)\n                  Figure 14: DTLS Extensions\
    \ Present for\n                    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\n"
- title: 9.1.3.2.1.  Provisioning
  contents:
  - "9.1.3.2.1.  Provisioning\n   The RawPublicKey mode was designed to be easily\
    \ provisioned in M2M\n   deployments.  It is assumed that each device has an appropriate\n\
    \   asymmetric public key pair installed.  An identifier is calculated by\n  \
    \ the endpoint from the public key as described in Section 2 of\n   [RFC6920].\
    \  All implementations that support checking RawPublicKey\n   identities MUST\
    \ support at least the sha-256-120 mode (SHA-256\n   truncated to 120 bits). \
    \ Implementations SHOULD also support longer\n   length identifiers and MAY support\
    \ shorter lengths.  Note that the\n   shorter lengths provide less security against\
    \ attacks, and their use\n   is NOT RECOMMENDED.\n   Depending on how identifiers\
    \ are given to the system that verifies\n   them, support for URI, binary, and/or\
    \ human-speakable format\n   [RFC6920] needs to be implemented.  All implementations\
    \ SHOULD\n   support the binary mode, and implementations that have a user\n \
    \  interface SHOULD also support the human-speakable format.\n   During provisioning,\
    \ the identifier of each node is collected, for\n   example, by reading a barcode\
    \ on the outside of the device or by\n   obtaining a pre-compiled list of the\
    \ identifiers.  These identifiers\n   are then installed in the corresponding\
    \ endpoint, for example, an M2M\n   data collection server.  The identifier is\
    \ used for two purposes, to\n   associate the endpoint with further device information\
    \ and to perform\n   access control.  During (initial and ongoing) provisioning,\
    \ an access\n   control list of identifiers with which the device may start DTLS\n\
    \   sessions SHOULD also be installed and maintained.\n"
- title: 9.1.3.3.  X.509 Certificates
  contents:
  - "9.1.3.3.  X.509 Certificates\n   Implementations in Certificate Mode MUST support\
    \ the mandatory-to-\n   implement cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\
    \ as\n   specified in [RFC7251], [RFC5246], and [RFC4492].  Namely, the\n   certificate\
    \ includes a SubjectPublicKeyInfo that indicates an\n   algorithm of id-ecPublicKey\
    \ with namedCurves secp256r1 [RFC5480]; the\n   public key format is uncompressed\
    \ [RFC5480]; the hash algorithm is\n   SHA-256; if included, the key usage extension\
    \ indicates\n   digitalSignature.  Certificates MUST be signed with ECDSA using\n\
    \   secp256r1, and the signature MUST use SHA-256.  The key used MUST be\n   ECDSA\
    \ capable.  The curve secp256r1 MUST be supported [RFC4492]; this\n   curve is\
    \ equivalent to the NIST P-256 curve.  The hash algorithm is\n   SHA-256.  Implementations\
    \ MUST use the Supported Elliptic Curves and\n   Supported Point Formats Extensions\
    \ [RFC4492]; the uncompressed point\n   format MUST be supported; [RFC6090] can\
    \ be used as an implementation\n   method.\n   The subject in the certificate\
    \ would be built out of a long-term\n   unique identifier for the device such\
    \ as the EUI-64 [EUI64].  The\n   subject could also be based on the Fully Qualified\
    \ Domain Name (FQDN)\n   that was used as the Host part of the CoAP URI.  However,\
    \ the\n   device's IP address should not typically be used as the subject, as\n\
    \   it would change over time.  The discovery process used in the system\n   would\
    \ build up the mapping between IP addresses of the given devices\n   and the subject\
    \ for each device.  Some devices could have more than\n   one subject and would\
    \ need more than a single certificate.\n   When a new connection is formed, the\
    \ certificate from the remote\n   device needs to be verified.  If the CoAP node\
    \ has a source of\n   absolute time, then the node SHOULD check that the validity\
    \ dates of\n   the certificate are within range.  The certificate MUST be validated\n\
    \   as appropriate for the security requirements, using functionality\n   equivalent\
    \ to the algorithm specified in Section 6 of [RFC5280].  If\n   the certificate\
    \ contains a SubjectAltName, then the authority of the\n   request URI MUST match\
    \ at least one of the authorities of any CoAP\n   URI found in a field of URI\
    \ type in the SubjectAltName set.  If there\n   is no SubjectAltName in the certificate,\
    \ then the authority of the\n   request URI MUST match the Common Name (CN) found\
    \ in the certificate\n   using the matching rules defined in [RFC3280] with the\
    \ exception that\n   certificates with wildcards are not allowed.\n   CoRE support\
    \ for certificate status checking requires further study.\n   As a mapping of\
    \ the Online Certificate Status Protocol (OCSP)\n   [RFC6960] onto CoAP is not\
    \ currently defined and OCSP may also not be\n   easily applicable in all environments,\
    \ an alternative approach may be\n   using the TLS Certificate Status Request\
    \ extension (Section 8 of\n   [RFC6066]; also known as \"OCSP stapling\") or preferably\
    \ the Multiple\n   Certificate Status Extension ([RFC6961]), if available.\n \
    \  If the system has a shared key in addition to the certificate, then a\n   cipher\
    \ suite that includes the shared key such as\n   TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\
    \ [RFC5489] SHOULD be used.\n"
- title: 10.  Cross-Protocol Proxying between CoAP and HTTP
  contents:
  - "10.  Cross-Protocol Proxying between CoAP and HTTP\n   CoAP supports a limited\
    \ subset of HTTP functionality, and thus cross-\n   protocol proxying to HTTP\
    \ is straightforward.  There might be several\n   reasons for proxying between\
    \ CoAP and HTTP, for example, when\n   designing a web interface for use over\
    \ either protocol or when\n   realizing a CoAP-HTTP proxy.  Likewise, CoAP could\
    \ equally be proxied\n   to other protocols such as XMPP [RFC6120] or SIP [RFC3264];\
    \ the\n   definition of these mechanisms is out of scope for this\n   specification.\n\
    \   There are two possible directions to access a resource via a forward-\n  \
    \ proxy:\n   CoAP-HTTP Proxying:  Enables CoAP clients to access resources on\
    \ HTTP\n      servers through an intermediary.  This is initiated by including\n\
    \      the Proxy-Uri or Proxy-Scheme Option with an \"http\" or \"https\" URI\n\
    \      in a CoAP request to a CoAP-HTTP proxy.\n   HTTP-CoAP Proxying:  Enables\
    \ HTTP clients to access resources on CoAP\n      servers through an intermediary.\
    \  This is initiated by specifying\n      a \"coap\" or \"coaps\" URI in the Request-Line\
    \ of an HTTP request to\n      an HTTP-CoAP proxy.\n   Either way, only the request/response\
    \ model of CoAP is mapped to\n   HTTP.  The underlying model of Confirmable or\
    \ Non-confirmable\n   messages, etc., is invisible and MUST have no effect on\
    \ a proxy\n   function.  The following sections describe the handling of requests\n\
    \   to a forward-proxy.  Reverse-proxies are not specified, as the proxy\n   function\
    \ is transparent to the client with the proxy acting as if it\n   were the origin\
    \ server.  However, similar considerations apply to\n   reverse-proxies as to\
    \ forward-proxies, and there generally will be an\n   expectation that reverse-proxies\
    \ operate in a similar way forward-\n   proxies would.  As an implementation note,\
    \ HTTP client libraries may\n   make it hard to operate an HTTP-CoAP forward-proxy\
    \ by not providing a\n   way to put a CoAP URI on the HTTP Request-Line; reverse-proxying\
    \ may\n   therefore lead to wider applicability of a proxy.  A separate\n   specification\
    \ may define a convention for URIs operating such an\n   HTTP-CoAP reverse-proxy\
    \ [MAPPING].\n"
- title: 10.1.  CoAP-HTTP Proxying
  contents:
  - "10.1.  CoAP-HTTP Proxying\n   If a request contains a Proxy-Uri or Proxy-Scheme\
    \ Option with an\n   'http' or 'https' URI [RFC2616], then the receiving CoAP\
    \ endpoint\n   (called \"the proxy\" henceforth) is requested to perform the operation\n\
    \   specified by the request method on the indicated HTTP resource and\n   return\
    \ the result to the client.  (See also Section 5.7 for how the\n   request to\
    \ the proxy is formulated, including security requirements.)\n   This section\
    \ specifies for any CoAP request the CoAP response that\n   the proxy should return\
    \ to the client.  How the proxy actually\n   satisfies the request is an implementation\
    \ detail, although the\n   typical case is expected to be that the proxy translates\
    \ and forwards\n   the request to an HTTP origin server.\n   Since HTTP and CoAP\
    \ share the basic set of request methods,\n   performing a CoAP request on an\
    \ HTTP resource is not so different\n   from performing it on a CoAP resource.\
    \  The meanings of the\n   individual CoAP methods when performed on HTTP resources\
    \ are\n   explained in the subsections of this section.\n   If the proxy is unable\
    \ or unwilling to service a request with an HTTP\n   URI, a 5.05 (Proxying Not\
    \ Supported) response is returned to the\n   client.  If the proxy services the\
    \ request by interacting with a\n   third party (such as the HTTP origin server)\
    \ and is unable to obtain\n   a result within a reasonable time frame, a 5.04\
    \ (Gateway Timeout)\n   response is returned; if a result can be obtained but\
    \ is not\n   understood, a 5.02 (Bad Gateway) response is returned.\n"
- title: 10.1.1.  GET
  contents:
  - "10.1.1.  GET\n   The GET method requests the proxy to return a representation\
    \ of the\n   HTTP resource identified by the request URI.\n   Upon success, a\
    \ 2.05 (Content) Response Code SHOULD be returned.  The\n   payload of the response\
    \ MUST be a representation of the target HTTP\n   resource, and the Content-Format\
    \ Option MUST be set accordingly.  The\n   response MUST indicate a Max-Age value\
    \ that is no greater than the\n   remaining time the representation can be considered\
    \ fresh.  If the\n   HTTP entity has an entity-tag, the proxy SHOULD include an\
    \ ETag\n   Option in the response and process ETag Options in requests as\n  \
    \ described below.\n   A client can influence the processing of a GET request\
    \ by including\n   the following option:\n   Accept:  The request MAY include\
    \ an Accept Option, identifying the\n      preferred response content-format.\n\
    \   ETag:  The request MAY include one or more ETag Options, identifying\n   \
    \   responses that the client has stored.  This requests the proxy to\n      send\
    \ a 2.03 (Valid) response whenever it would send a 2.05\n      (Content) response\
    \ with an entity-tag in the requested set\n      otherwise.  Note that CoAP ETags\
    \ are always strong ETags in the\n      HTTP sense; CoAP does not have the equivalent\
    \ of HTTP weak ETags,\n      and there is no good way to make use of these in\
    \ a cross-proxy.\n"
- title: 10.1.2.  PUT
  contents:
  - "10.1.2.  PUT\n   The PUT method requests the proxy to update or create the HTTP\n\
    \   resource identified by the request URI with the enclosed\n   representation.\n\
    \   If a new resource is created at the request URI, a 2.01 (Created)\n   response\
    \ MUST be returned to the client.  If an existing resource is\n   modified, a\
    \ 2.04 (Changed) response MUST be returned to indicate\n   successful completion\
    \ of the request.\n"
- title: 10.1.3.  DELETE
  contents:
  - "10.1.3.  DELETE\n   The DELETE method requests the proxy to delete the HTTP resource\n\
    \   identified by the request URI at the HTTP origin server.\n   A 2.02 (Deleted)\
    \ response MUST be returned to the client upon success\n   or if the resource\
    \ does not exist at the time of the request.\n"
- title: 10.1.4.  POST
  contents:
  - "10.1.4.  POST\n   The POST method requests the proxy to have the representation\n\
    \   enclosed in the request be processed by the HTTP origin server.  The\n   actual\
    \ function performed by the POST method is determined by the\n   origin server\
    \ and dependent on the resource identified by the request\n   URI.\n   If the\
    \ action performed by the POST method does not result in a\n   resource that can\
    \ be identified by a URI, a 2.04 (Changed) response\n   MUST be returned to the\
    \ client.  If a resource has been created on\n   the origin server, a 2.01 (Created)\
    \ response MUST be returned.\n"
- title: 10.2.  HTTP-CoAP Proxying
  contents:
  - "10.2.  HTTP-CoAP Proxying\n   If an HTTP request contains a Request-URI with\
    \ a \"coap\" or \"coaps\"\n   URI, then the receiving HTTP endpoint (called \"\
    the proxy\" henceforth)\n   is requested to perform the operation specified by\
    \ the request method\n   on the indicated CoAP resource and return the result\
    \ to the client.\n   This section specifies for any HTTP request the HTTP response\
    \ that\n   the proxy should return to the client.  Unless otherwise specified,\n\
    \   all the statements made are RECOMMENDED behavior; some highly\n   constrained\
    \ implementations may need to resort to shortcuts.  How the\n   proxy actually\
    \ satisfies the request is an implementation detail,\n   although the typical\
    \ case is expected to be that the proxy translates\n   and forwards the request\
    \ to a CoAP origin server.  The meanings of\n   the individual HTTP methods when\
    \ performed on CoAP resources are\n   explained in the subsections of this section.\n\
    \   If the proxy is unable or unwilling to service a request with a CoAP\n   URI,\
    \ a 501 (Not Implemented) response is returned to the client.  If\n   the proxy\
    \ services the request by interacting with a third party\n   (such as the CoAP\
    \ origin server) and is unable to obtain a result\n   within a reasonable time\
    \ frame, a 504 (Gateway Timeout) response is\n   returned; if a result can be\
    \ obtained but is not understood, a 502\n   (Bad Gateway) response is returned.\n"
- title: 10.2.1.  OPTIONS and TRACE
  contents:
  - "10.2.1.  OPTIONS and TRACE\n   As the OPTIONS and TRACE methods are not supported\
    \ in CoAP, a 501\n   (Not Implemented) error MUST be returned to the client.\n"
- title: 10.2.2.  GET
  contents:
  - "10.2.2.  GET\n   The GET method requests the proxy to return a representation\
    \ of the\n   CoAP resource identified by the Request-URI.\n   Upon success, a\
    \ 200 (OK) response is returned.  The payload of the\n   response MUST be a representation\
    \ of the target CoAP resource, and\n   the Content-Type and Content-Encoding header\
    \ fields MUST be set\n   accordingly.  The response MUST indicate a max-age directive\
    \ that\n   indicates a value no greater than the remaining time the\n   representation\
    \ can be considered fresh.  If the CoAP response has an\n   ETag option, the proxy\
    \ should include an ETag header field in the\n   response.\n   A client can influence\
    \ the processing of a GET request by including\n   the following options:\n  \
    \ Accept:  The most-preferred media type of the HTTP Accept header\n      field\
    \ in a request is mapped to a CoAP Accept option.  HTTP Accept\n      media-type\
    \ ranges, parameters, and extensions are not supported by\n      the CoAP Accept\
    \ option.  If the proxy cannot send a response that\n      is acceptable according\
    \ to the combined Accept field value, then\n      the proxy sends a 406 (Not Acceptable)\
    \ response.  The proxy MAY\n      then retry the request with further media types\
    \ from the HTTP\n      Accept header field.\n   Conditional GETs:  Conditional\
    \ HTTP GET requests that include an \"If-\n      Match\" or \"If-None-Match\"\
    \ request-header field can be mapped to a\n      corresponding CoAP request. \
    \ The \"If-Modified-Since\" and \"If-\n      Unmodified-Since\" request-header\
    \ fields are not directly supported\n      by CoAP but are implemented locally\
    \ by a caching proxy.\n"
- title: 10.2.3.  HEAD
  contents:
  - "10.2.3.  HEAD\n   The HEAD method is identical to GET except that the server\
    \ MUST NOT\n   return a message-body in the response.\n   Although there is no\
    \ direct equivalent of HTTP's HEAD method in CoAP,\n   an HTTP-CoAP proxy responds\
    \ to HEAD requests for CoAP resources, and\n   the HTTP headers are returned without\
    \ a message-body.\n   Implementation Note:  An HTTP-CoAP proxy may want to try\
    \ using a\n      block-wise transfer option [BLOCK] to minimize the amount of\
    \ data\n      actually transferred, but it needs to be prepared for the case\n\
    \      that the origin server does not support block-wise transfers.\n"
- title: 10.2.4.  POST
  contents:
  - "10.2.4.  POST\n   The POST method requests the proxy to have the representation\n\
    \   enclosed in the request be processed by the CoAP origin server.  The\n   actual\
    \ function performed by the POST method is determined by the\n   origin server\
    \ and dependent on the resource identified by the request\n   URI.\n   If the\
    \ action performed by the POST method does not result in a\n   resource that can\
    \ be identified by a URI, a 200 (OK) or 204 (No\n   Content) response MUST be\
    \ returned to the client.  If a resource has\n   been created on the origin server,\
    \ a 201 (Created) response MUST be\n   returned.\n   If any of the Location-*\
    \ Options are present in the CoAP response, a\n   Location header field constructed\
    \ from the values of these options is\n   returned.\n"
- title: 10.2.5.  PUT
  contents:
  - "10.2.5.  PUT\n   The PUT method requests the proxy to update or create the CoAP\n\
    \   resource identified by the Request-URI with the enclosed\n   representation.\n\
    \   If a new resource is created at the Request-URI, a 201 (Created)\n   response\
    \ is returned to the client.  If an existing resource is\n   modified, either\
    \ the 200 (OK) or 204 (No Content) Response Codes is\n   sent to indicate successful\
    \ completion of the request.\n"
- title: 10.2.6.  DELETE
  contents:
  - "10.2.6.  DELETE\n   The DELETE method requests the proxy to delete the CoAP resource\n\
    \   identified by the Request-URI at the CoAP origin server.\n   A successful\
    \ response is 200 (OK) if the response includes an entity\n   describing the status\
    \ or 204 (No Content) if the action has been\n   enacted but the response does\
    \ not include an entity.\n"
- title: 10.2.7.  CONNECT
  contents:
  - "10.2.7.  CONNECT\n   This method cannot currently be satisfied by an HTTP-CoAP\
    \ proxy\n   function, as TLS to DTLS tunneling has not yet been specified.  For\n\
    \   now, a 501 (Not Implemented) error is returned to the client.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   This section analyzes the possible threats to\
    \ the protocol.  It is\n   meant to inform protocol and application developers\
    \ about the\n   security limitations of CoAP as described in this document.  As\
    \ CoAP\n   realizes a subset of the features in HTTP/1.1, the security\n   considerations\
    \ in Section 15 of [RFC2616] are also pertinent to CoAP.\n   This section concentrates\
    \ on describing limitations specific to CoAP.\n"
- title: 11.1.  Parsing the Protocol and Processing URIs
  contents:
  - "11.1.  Parsing the Protocol and Processing URIs\n   A network-facing application\
    \ can exhibit vulnerabilities in its\n   processing logic for incoming packets.\
    \  Complex parsers are well-\n   known as a likely source of such vulnerabilities,\
    \ such as the ability\n   to remotely crash a node, or even remotely execute arbitrary\
    \ code on\n   it.  CoAP attempts to narrow the opportunities for introducing such\n\
    \   vulnerabilities by reducing parser complexity, by giving the entire\n   range\
    \ of encodable values a meaning where possible, and by\n   aggressively reducing\
    \ complexity that is often caused by unnecessary\n   choice between multiple representations\
    \ that mean the same thing.\n   Much of the URI processing has been moved to the\
    \ clients, further\n   reducing the opportunities for introducing vulnerabilities\
    \ into the\n   servers.  Even so, the URI processing code in CoAP implementations\
    \ is\n   likely to be a large source of remaining vulnerabilities and should\n\
    \   be implemented with special care.  CoAP access control\n   implementations\
    \ need to ensure they don't introduce vulnerabilities\n   through discrepancies\
    \ between the code deriving access control\n   decisions from a URI and the code\
    \ finally serving up the resource\n   addressed by the URI.  The most complex\
    \ parser remaining could be the\n   one for the CoRE Link Format, although this\
    \ also has been designed\n   with a goal of reduced implementation complexity\
    \ [RFC6690].  (See\n   also Section 15.2 of [RFC2616].)\n"
- title: 11.2.  Proxying and Caching
  contents:
  - "11.2.  Proxying and Caching\n   As mentioned in Section 15.7 of [RFC2616], proxies\
    \ are by their very\n   nature men-in-the-middle, breaking any IPsec or DTLS protection\
    \ that\n   a direct CoAP message exchange might have.  They are therefore\n  \
    \ interesting targets for breaking confidentiality or integrity of CoAP\n   message\
    \ exchanges.  As noted in [RFC2616], they are also interesting\n   targets for\
    \ breaking availability.\n   The threat to confidentiality and integrity of request/response\
    \ data\n   is amplified where proxies also cache.  Note that CoAP does not\n \
    \  define any of the cache-suppressing Cache-Control options that\n   HTTP/1.1\
    \ provides to better protect sensitive data.\n   For a caching implementation,\
    \ any access control considerations that\n   would apply to making the request\
    \ that generated the cache entry also\n   need to be applied to the value in the\
    \ cache.  This is relevant for\n   clients that implement multiple security domains,\
    \ as well as for\n   proxies that may serve multiple clients.  Also, a caching\
    \ proxy MUST\n   NOT make cached values available to requests that have lesser\n\
    \   transport-security properties than those the proxy would require to\n   perform\
    \ request forwarding in the first place.\n   Unlike the \"coap\" scheme, responses\
    \ to \"coaps\" identified requests\n   are never \"public\" and thus MUST NOT\
    \ be reused for shared caching,\n   unless the cache is able to make equivalent\
    \ access control decisions\n   to the ones that led to the cached entry.  They\
    \ can, however, be\n   reused in a private cache if the message is cacheable by\
    \ default in\n   CoAP.\n   Finally, a proxy that fans out Separate Responses (as\
    \ opposed to\n   piggybacked Responses) to multiple original requesters may provide\n\
    \   additional amplification (see Section 11.3).\n"
- title: 11.3.  Risk of Amplification
  contents:
  - "11.3.  Risk of Amplification\n   CoAP servers generally reply to a request packet\
    \ with a response\n   packet.  This response packet may be significantly larger\
    \ than the\n   request packet.  An attacker might use CoAP nodes to turn a small\n\
    \   attack packet into a larger attack packet, an approach known as\n   amplification.\
    \  There is therefore a danger that CoAP nodes could\n   become implicated in\
    \ denial-of-service (DoS) attacks by using the\n   amplifying properties of the\
    \ protocol: an attacker that is attempting\n   to overload a victim but is limited\
    \ in the amount of traffic it can\n   generate can use amplification to generate\
    \ a larger amount of\n   traffic.\n   This is particularly a problem in nodes\
    \ that enable NoSec access, are\n   accessible from an attacker, and can access\
    \ potential victims (e.g.,\n   on the general Internet), as the UDP protocol provides\
    \ no way to\n   verify the source address given in the request packet.  An attacker\n\
    \   need only place the IP address of the victim in the source address of\n  \
    \ a suitable request packet to generate a larger packet directed at the\n   victim.\n\
    \   As a mitigating factor, many constrained networks will only be able\n   to\
    \ generate a small amount of traffic, which may make CoAP nodes less\n   attractive\
    \ for this attack.  However, the limited capacity of the\n   constrained network\
    \ makes the network itself a likely victim of an\n   amplification attack.\n \
    \  Therefore, large amplification factors SHOULD NOT be provided in the\n   response\
    \ if the request is not authenticated.  A CoAP server can\n   reduce the amount\
    \ of amplification it provides to an attacker by\n   using slicing/blocking modes\
    \ of CoAP [BLOCK] and offering large\n   resource representations only in relatively\
    \ small slices.  For\n   example, for a 1000-byte resource, a 10-byte request\
    \ might result in\n   an 80-byte response (with a 64-byte block) instead of a\
    \ 1016-byte\n   response, considerably reducing the amplification provided.\n\
    \   CoAP also supports the use of multicast IP addresses in requests, an\n   important\
    \ requirement for M2M.  Multicast CoAP requests may be the\n   source of accidental\
    \ or deliberate DoS attacks, especially over\n   constrained networks.  This specification\
    \ attempts to reduce the\n   amplification effects of multicast requests by limiting\
    \ when a\n   response is returned.  To limit the possibility of malicious use,\n\
    \   CoAP servers SHOULD NOT accept multicast requests that can not be\n   authenticated\
    \ in some way, cryptographically or by some multicast\n   boundary limiting the\
    \ potential sources.  If possible, a CoAP server\n   SHOULD limit the support\
    \ for multicast requests to the specific\n   resources where the feature is required.\n\
    \   On some general-purpose operating systems providing a POSIX-style API\n  \
    \ [IEEE1003.1], it is not straightforward to find out whether a packet\n   received\
    \ was addressed to a multicast address.  While many\n   implementations will know\
    \ whether they have joined a multicast group,\n   this creates a problem for packets\
    \ addressed to multicast addresses\n   of the form FF0x::1, which are received\
    \ by every IPv6 node.\n   Implementations SHOULD make use of modern APIs such\
    \ as\n   IPV6_RECVPKTINFO [RFC3542], if available, to make this determination.\n"
- title: 11.4.  IP Address Spoofing Attacks
  contents:
  - "11.4.  IP Address Spoofing Attacks\n   Due to the lack of a handshake in UDP,\
    \ a rogue endpoint that is free\n   to read and write messages carried by the\
    \ constrained network (i.e.,\n   NoSec or PreSharedKey deployments with a nodes/key\
    \ ratio > 1:1), may\n   easily attack a single endpoint, a group of endpoints,\
    \ as well as the\n   whole network, e.g., by:\n   1.  spoofing a Reset message\
    \ in response to a Confirmable message or\n       Non-confirmable message, thus\
    \ making an endpoint \"deaf\"; or\n   2.  spoofing an ACK in response to a CON\
    \ message, thus potentially\n       preventing the sender of the CON message from\
    \ retransmitting, and\n       drowning out the actual response; or\n   3.  spoofing\
    \ the entire response with forged payload/options (this\n       has different\
    \ levels of impact: from single-response disruption,\n       to much bolder attacks\
    \ on the supporting infrastructure, e.g.,\n       poisoning proxy caches, or tricking\
    \ validation/lookup interfaces\n       in resource directories and, more generally,\
    \ any component that\n       stores global network state and uses CoAP as the\
    \ messaging\n       facility to handle setting or updating state is a potential\n\
    \       target.); or\n   4.  spoofing a multicast request for a target node; this\
    \ may result\n       in network congestion/collapse, a DoS attack on the victim,\
    \ or\n       forced wake-up from sleeping; or\n   5.  spoofing observe messages,\
    \ etc.\n   Response spoofing by off-path attackers can be detected and mitigated\n\
    \   even without transport layer security by choosing a nontrivial,\n   randomized\
    \ token in the request (Section 5.3.1).  [RFC4086] discusses\n   randomness requirements\
    \ for security.\n   In principle, other kinds of spoofing can be detected by CoAP\
    \ only in\n   case Confirmable message semantics is used, because of unexpected\n\
    \   Acknowledgement or Reset messages coming from the deceived endpoint.\n   But\
    \ this imposes keeping track of the used Message IDs, which is not\n   always\
    \ possible, and moreover detection becomes available usually\n   after the damage\
    \ is already done.  This kind of attack can be\n   prevented using security modes\
    \ other than NoSec.\n   With or without source address spoofing, a client can\
    \ attempt to\n   overload a server by sending requests, preferably complex ones,\
    \ to a\n   server; address spoofing makes tracing back, and blocking, this\n \
    \  attack harder.  Given that the cost of a CON request is small, this\n   attack\
    \ can easily be executed.  Under this attack, a constrained node\n   with limited\
    \ total energy available may exhaust that energy much more\n   quickly than planned\
    \ (battery depletion attack).  Also, if the client\n   uses a Confirmable message\
    \ and the server responds with a Confirmable\n   separate response to a (possibly\
    \ spoofed) address that does not\n   respond, the server will have to allocate\
    \ buffer and retransmission\n   logic for each response up to the exhaustion of\
    \ MAX_TRANSMIT_SPAN,\n   making it more likely that it runs out of resources for\
    \ processing\n   legitimate traffic.  The latter problem can be mitigated somewhat\
    \ by\n   limiting the rate of responses as discussed in Section 4.7.  An\n   attacker\
    \ could also spoof the address of a legitimate client; this\n   might cause the\
    \ server, if it uses separate responses, to block\n   legitimate responses to\
    \ that client because of NSTART=1.  All these\n   attacks can be prevented using\
    \ a security mode other than NoSec, thus\n   leaving only attacks on the security\
    \ protocol.\n"
- title: 11.5.  Cross-Protocol Attacks
  contents:
  - "11.5.  Cross-Protocol Attacks\n   The ability to incite a CoAP endpoint to send\
    \ packets to a fake\n   source address can be used not only for amplification,\
    \ but also for\n   cross-protocol attacks against a victim listening to UDP packets\
    \ at a\n   given address (IP address and port).  This would occur as follows:\n\
    \   o  The attacker sends a message to a CoAP endpoint with the given\n      address\
    \ as the fake source address.\n   o  The CoAP endpoint replies with a message\
    \ to the given source\n      address.\n   o  The victim at the given address receives\
    \ a UDP packet that it\n      interprets according to the rules of a different\
    \ protocol.\n   This may be used to circumvent firewall rules that prevent direct\n\
    \   communication from the attacker to the victim but happen to allow\n   communication\
    \ from the CoAP endpoint (which may also host a valid\n   role in the other protocol)\
    \ to the victim.\n   Also, CoAP endpoints may be the victim of a cross-protocol\
    \ attack\n   generated through an endpoint of another UDP-based protocol such\
    \ as\n   DNS.  In both cases, attacks are possible if the security properties\n\
    \   of the endpoints rely on checking IP addresses (and firewalling off\n   direct\
    \ attacks sent from outside using fake IP addresses).  In\n   general, because\
    \ of their lack of context, UDP-based protocols are\n   relatively easy targets\
    \ for cross-protocol attacks.\n   Finally, CoAP URIs transported by other means\
    \ could be used to incite\n   clients to send messages to endpoints of other protocols.\n\
    \   One mitigation against cross-protocol attacks is strict checking of\n   the\
    \ syntax of packets received, combined with sufficient difference\n   in syntax.\
    \  As an example, it might help if it were difficult to\n   incite a DNS server\
    \ to send a DNS response that would pass the checks\n   of a CoAP endpoint.  Unfortunately,\
    \ the first two bytes of a DNS\n   reply are an ID that can be chosen by the attacker\
    \ and that map into\n   the interesting part of the CoAP header, and the next\
    \ two bytes are\n   then interpreted as CoAP's Message ID (i.e., any value is\n\
    \   acceptable).  The DNS count words may be interpreted as multiple\n   instances\
    \ of a (nonexistent but elective) CoAP option 0, or possibly\n   as a Token. \
    \ The echoed query finally may be manufactured by the\n   attacker to achieve\
    \ a desired effect on the CoAP endpoint; the\n   response added by the server\
    \ (if any) might then just be interpreted\n   as added payload.\n            \
    \                       1  1  1  1  1  1\n     0  1  2  3  4  5  6  7  8  9  0\
    \  1  2  3  4  5\n   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   | \
    \                     ID                       | T, TKL, code\n   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \   |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   | Message ID\n   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \   |                    QDCOUNT                    | (options 0)\n   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \   |                    ANCOUNT                    | (options 0)\n   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \   |                    NSCOUNT                    | (options 0)\n   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \   |                    ARCOUNT                    | (options 0)\n   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\
    \     Figure 15: DNS Header ([RFC1035], Section 4.1.1) vs. CoAP Message\n   In\
    \ general, for any pair of protocols, one of the protocols can very\n   well have\
    \ been designed in a way that enables an attacker to cause\n   the generation\
    \ of replies that look like messages of the other\n   protocol.  It is often much\
    \ harder to ensure or prove the absence of\n   viable attacks than to generate\
    \ examples that may not yet completely\n   enable an attack but might be further\
    \ developed by more creative\n   minds.  Cross-protocol attacks can therefore\
    \ only be completely\n   mitigated if endpoints don't authorize actions desired\
    \ by an attacker\n   just based on trusting the source IP address of a packet.\n\
    \   Conversely, a NoSec environment that completely relies on a firewall\n   for\
    \ CoAP security not only needs to firewall off the CoAP endpoints\n   but also\
    \ all other endpoints that might be incited to send UDP\n   messages to CoAP endpoints\
    \ using some other UDP-based protocol.\n   In addition to the considerations above,\
    \ the security considerations\n   for DTLS with respect to cross-protocol attacks\
    \ apply.  For example,\n   if the same DTLS security association (\"connection\"\
    ) is used to carry\n   data of multiple protocols, DTLS no longer provides protection\n\
    \   against cross-protocol attacks between these protocols.\n"
- title: 11.6.  Constrained-Node Considerations
  contents:
  - "11.6.  Constrained-Node Considerations\n   Implementers on constrained nodes\
    \ often find themselves without a\n   good source of entropy [RFC4086].  If that\
    \ is the case, the node MUST\n   NOT be used for processes that require good entropy,\
    \ such as key\n   generation.  Instead, keys should be generated externally and\
    \ added\n   to the device during manufacturing or commissioning.\n   Due to their\
    \ low processing power, constrained nodes are particularly\n   susceptible to\
    \ timing attacks.  Special care must be taken in\n   implementation of cryptographic\
    \ primitives.\n   Large numbers of constrained nodes will be installed in exposed\n\
    \   environments and will have little resistance to tampering, including\n   recovery\
    \ of keying materials.  This needs to be considered when\n   defining the scope\
    \ of credentials assigned to them.  In particular,\n   assigning a shared key\
    \ to a group of nodes may make any single\n   constrained node a target for subverting\
    \ the entire group.\n"
- title: 12.  IANA Considerations
  contents:
  - '12.  IANA Considerations

    '
- title: 12.1.  CoAP Code Registries
  contents:
  - "12.1.  CoAP Code Registries\n   This document defines two sub-registries for\
    \ the values of the Code\n   field in the CoAP header within the \"Constrained\
    \ RESTful Environments\n   (CoRE) Parameters\" registry, hereafter referred to\
    \ as the \"CoRE\n   Parameters\" registry.\n   Values in the two sub-registries\
    \ are eight-bit values notated as\n   three decimal digits c.dd separated by a\
    \ period between the first and\n   the second digit; the first digit c is between\
    \ 0 and 7 and denotes\n   the code class; the second and third digits dd denote\
    \ a decimal\n   number between 00 and 31 for the detail.\n   All Code values are\
    \ assigned by sub-registries according to the\n   following ranges:\n   0.00 \
    \     Indicates an Empty message (see Section 4.1).\n   0.01-0.31 Indicates a\
    \ request.  Values in this range are assigned by\n             the \"CoAP Method\
    \ Codes\" sub-registry (see Section 12.1.1).\n   1.00-1.31 Reserved\n   2.00-5.31\
    \ Indicates a response.  Values in this range are assigned by\n             the\
    \ \"CoAP Response Codes\" sub-registry (see\n             Section 12.1.2).\n \
    \  6.00-7.31 Reserved\n"
- title: 12.1.1.  Method Codes
  contents:
  - "12.1.1.  Method Codes\n   The name of the sub-registry is \"CoAP Method Codes\"\
    .\n   Each entry in the sub-registry must include the Method Code in the\n   range\
    \ 0.01-0.31, the name of the method, and a reference to the\n   method's documentation.\n\
    \   Initial entries in this sub-registry are as follows:\n                   \
    \    +------+--------+-----------+\n                       | Code | Name   | Reference\
    \ |\n                       +------+--------+-----------+\n                  \
    \     | 0.01 | GET    | [RFC7252] |\n                       | 0.02 | POST   |\
    \ [RFC7252] |\n                       | 0.03 | PUT    | [RFC7252] |\n        \
    \               | 0.04 | DELETE | [RFC7252] |\n                       +------+--------+-----------+\n\
    \                        Table 5: CoAP Method Codes\n   All other Method Codes\
    \ are Unassigned.\n   The IANA policy for future additions to this sub-registry\
    \ is \"IETF\n   Review or IESG Approval\" as described in [RFC5226].\n   The documentation\
    \ of a Method Code should specify the semantics of a\n   request with that code,\
    \ including the following properties:\n   o  The Response Codes the method returns\
    \ in the success case.\n   o  Whether the method is idempotent, safe, or both.\n"
- title: 12.1.2.  Response Codes
  contents:
  - "12.1.2.  Response Codes\n   The name of the sub-registry is \"CoAP Response Codes\"\
    .\n   Each entry in the sub-registry must include the Response Code in the\n \
    \  range 2.00-5.31, a description of the Response Code, and a reference\n   to\
    \ the Response Code's documentation.\n   Initial entries in this sub-registry\
    \ are as follows:\n            +------+------------------------------+-----------+\n\
    \            | Code | Description                  | Reference |\n           \
    \ +------+------------------------------+-----------+\n            | 2.01 | Created\
    \                      | [RFC7252] |\n            | 2.02 | Deleted           \
    \           | [RFC7252] |\n            | 2.03 | Valid                        |\
    \ [RFC7252] |\n            | 2.04 | Changed                      | [RFC7252] |\n\
    \            | 2.05 | Content                      | [RFC7252] |\n           \
    \ | 4.00 | Bad Request                  | [RFC7252] |\n            | 4.01 | Unauthorized\
    \                 | [RFC7252] |\n            | 4.02 | Bad Option             \
    \      | [RFC7252] |\n            | 4.03 | Forbidden                    | [RFC7252]\
    \ |\n            | 4.04 | Not Found                    | [RFC7252] |\n       \
    \     | 4.05 | Method Not Allowed           | [RFC7252] |\n            | 4.06\
    \ | Not Acceptable               | [RFC7252] |\n            | 4.12 | Precondition\
    \ Failed          | [RFC7252] |\n            | 4.13 | Request Entity Too Large\
    \     | [RFC7252] |\n            | 4.15 | Unsupported Content-Format   | [RFC7252]\
    \ |\n            | 5.00 | Internal Server Error        | [RFC7252] |\n       \
    \     | 5.01 | Not Implemented              | [RFC7252] |\n            | 5.02\
    \ | Bad Gateway                  | [RFC7252] |\n            | 5.03 | Service Unavailable\
    \          | [RFC7252] |\n            | 5.04 | Gateway Timeout              |\
    \ [RFC7252] |\n            | 5.05 | Proxying Not Supported       | [RFC7252] |\n\
    \            +------+------------------------------+-----------+\n           \
    \            Table 6: CoAP Response Codes\n   The Response Codes 3.00-3.31 are\
    \ Reserved for future use.  All other\n   Response Codes are Unassigned.\n   The\
    \ IANA policy for future additions to this sub-registry is \"IETF\n   Review or\
    \ IESG Approval\" as described in [RFC5226].\n   The documentation of a Response\
    \ Code should specify the semantics of\n   a response with that code, including\
    \ the following properties:\n   o  The methods the Response Code applies to.\n\
    \   o  Whether payload is required, optional, or not allowed.\n   o  The semantics\
    \ of the payload.  For example, the payload of a 2.05\n      (Content) response\
    \ is a representation of the target resource; the\n      payload in an error response\
    \ is a human-readable diagnostic\n      payload.\n   o  The format of the payload.\
    \  For example, the format in a 2.05\n      (Content) response is indicated by\
    \ the Content-Format Option; the\n      format of the payload in an error response\
    \ is always Net-Unicode\n      text.\n   o  Whether the response is cacheable\
    \ according to the freshness\n      model.\n   o  Whether the response is validatable\
    \ according to the validation\n      model.\n   o  Whether the response causes\
    \ a cache to mark responses stored for\n      the request URI as not fresh.\n"
- title: 12.2.  CoAP Option Numbers Registry
  contents:
  - "12.2.  CoAP Option Numbers Registry\n   This document defines a sub-registry\
    \ for the Option Numbers used in\n   CoAP options within the \"CoRE Parameters\"\
    \ registry.  The name of the\n   sub-registry is \"CoAP Option Numbers\".\n  \
    \ Each entry in the sub-registry must include the Option Number, the\n   name\
    \ of the option, and a reference to the option's documentation.\n   Initial entries\
    \ in this sub-registry are as follows:\n                 +--------+------------------+-----------+\n\
    \                 | Number | Name             | Reference |\n                \
    \ +--------+------------------+-----------+\n                 |      0 | (Reserved)\
    \       | [RFC7252] |\n                 |      1 | If-Match         | [RFC7252]\
    \ |\n                 |      3 | Uri-Host         | [RFC7252] |\n            \
    \     |      4 | ETag             | [RFC7252] |\n                 |      5 | If-None-Match\
    \    | [RFC7252] |\n                 |      7 | Uri-Port         | [RFC7252] |\n\
    \                 |      8 | Location-Path    | [RFC7252] |\n                \
    \ |     11 | Uri-Path         | [RFC7252] |\n                 |     12 | Content-Format\
    \   | [RFC7252] |\n                 |     14 | Max-Age          | [RFC7252] |\n\
    \                 |     15 | Uri-Query        | [RFC7252] |\n                \
    \ |     17 | Accept           | [RFC7252] |\n                 |     20 | Location-Query\
    \   | [RFC7252] |\n                 |     35 | Proxy-Uri        | [RFC7252] |\n\
    \                 |     39 | Proxy-Scheme     | [RFC7252] |\n                \
    \ |     60 | Size1            | [RFC7252] |\n                 |    128 | (Reserved)\
    \       | [RFC7252] |\n                 |    132 | (Reserved)       | [RFC7252]\
    \ |\n                 |    136 | (Reserved)       | [RFC7252] |\n            \
    \     |    140 | (Reserved)       | [RFC7252] |\n                 +--------+------------------+-----------+\n\
    \                       Table 7: CoAP Option Numbers\n   The IANA policy for future\
    \ additions to this sub-registry is split\n   into three tiers as follows.  The\
    \ range of 0..255 is reserved for\n   options defined by the IETF (IETF Review\
    \ or IESG Approval).  The\n   range of 256..2047 is reserved for commonly used\
    \ options with public\n   specifications (Specification Required).  The range\
    \ of 2048..64999 is\n   for all other options including private or vendor-specific\
    \ ones,\n   which undergo a Designated Expert review to help ensure that the\n\
    \   option semantics are defined correctly.  The option numbers between\n   65000\
    \ and 65535 inclusive are reserved for experiments.  They are not\n   meant for\
    \ vendor-specific use of any kind and MUST NOT be used in\n   operational deployments.\n\
    \          +-------------+---------------------------------------+\n         \
    \ |       Range | Registration Procedures               |\n          +-------------+---------------------------------------+\n\
    \          |       0-255 | IETF Review or IESG Approval          |\n         \
    \ |    256-2047 | Specification Required                |\n          |  2048-64999\
    \ | Expert Review                         |\n          | 65000-65535 | Experimental\
    \ use (no operational use) |\n          +-------------+---------------------------------------+\n\
    \           Table 8: CoAP Option Numbers: Registration Procedures\n   The documentation\
    \ of an Option Number should specify the semantics of\n   an option with that\
    \ number, including the following properties:\n   o  The meaning of the option\
    \ in a request.\n   o  The meaning of the option in a response.\n   o  Whether\
    \ the option is critical or elective, as determined by the\n      Option Number.\n\
    \   o  Whether the option is Safe-to-Forward, and, if yes, whether it is\n   \
    \   part of the Cache-Key, as determined by the Option Number (see\n      Section\
    \ 5.4.2).\n   o  The format and length of the option's value.\n   o  Whether the\
    \ option must occur at most once or whether it can occur\n      multiple times.\n\
    \   o  The default value, if any.  For a critical option with a default\n    \
    \  value, a discussion on how the default value enables processing by\n      implementations\
    \ that do not support the critical option\n      (Section 5.4.4).\n"
- title: 12.3.  CoAP Content-Formats Registry
  contents:
  - "12.3.  CoAP Content-Formats Registry\n   Internet media types are identified\
    \ by a string, such as\n   \"application/xml\" [RFC2046].  In order to minimize\
    \ the overhead of\n   using these media types to indicate the format of payloads,\
    \ this\n   document defines a sub-registry for a subset of Internet media types\n\
    \   to be used in CoAP and assigns each, in combination with a content-\n   coding,\
    \ a numeric identifier.  The name of the sub-registry is \"CoAP\n   Content-Formats\"\
    , within the \"CoRE Parameters\" registry.\n   Each entry in the sub-registry\
    \ must include the media type registered\n   with IANA, the numeric identifier\
    \ in the range 0-65535 to be used for\n   that media type in CoAP, the content-coding\
    \ associated with this\n   identifier, and a reference to a document describing\
    \ what a payload\n   with that media type means semantically.\n   CoAP does not\
    \ include a separate way to convey content-encoding\n   information with a request\
    \ or response, and for that reason the\n   content-encoding is also specified\
    \ for each identifier (if any).  If\n   multiple content-encodings will be used\
    \ with a media type, then a\n   separate Content-Format identifier for each is\
    \ to be registered.\n   Similarly, other parameters related to an Internet media\
    \ type, such\n   as level, can be defined for a CoAP Content-Format entry.\n \
    \  Initial entries in this sub-registry are as follows:\n   +--------------------------+----------+----+------------------------+\n\
    \   | Media type               | Encoding | ID | Reference              |\n  \
    \ +--------------------------+----------+----+------------------------+\n   |\
    \ text/plain;              | -        |  0 | [RFC2046] [RFC3676]    |\n   | charset=utf-8\
    \            |          |    | [RFC5147]              |\n   | application/link-format\
    \  | -        | 40 | [RFC6690]              |\n   | application/xml          |\
    \ -        | 41 | [RFC3023]              |\n   | application/octet-stream | -\
    \        | 42 | [RFC2045] [RFC2046]    |\n   | application/exi          | -  \
    \      | 47 | [REC-exi-20140211]     |\n   | application/json         | -    \
    \    | 50 | [RFC7159]              |\n   +--------------------------+----------+----+------------------------+\n\
    \                       Table 9: CoAP Content-Formats\n   The identifiers between\
    \ 65000 and 65535 inclusive are reserved for\n   experiments.  They are not meant\
    \ for vendor-specific use of any kind\n   and MUST NOT be used in operational\
    \ deployments.  The identifiers\n   between 256 and 9999 are reserved for future\
    \ use in IETF\n   specifications (IETF Review or IESG Approval).  All other identifiers\n\
    \   are Unassigned.\n   Because the namespace of single-byte identifiers is so\
    \ small, the\n   IANA policy for future additions in the range 0-255 inclusive\
    \ to the\n   sub-registry is \"Expert Review\" as described in [RFC5226].  The\
    \ IANA\n   policy for additions in the range 10000-64999 inclusive is \"First\n\
    \   Come First Served\" as described in [RFC5226].  This is summarized in\n  \
    \ the following table.\n          +-------------+---------------------------------------+\n\
    \          |       Range | Registration Procedures               |\n         \
    \ +-------------+---------------------------------------+\n          |       0-255\
    \ | Expert Review                         |\n          |    256-9999 | IETF Review\
    \ or IESG Approval          |\n          | 10000-64999 | First Come First Served\
    \               |\n          | 65000-65535 | Experimental use (no operational\
    \ use) |\n          +-------------+---------------------------------------+\n\
    \          Table 10: CoAP Content-Formats: Registration Procedures\n   In machine-to-machine\
    \ applications, it is not expected that generic\n   Internet media types such\
    \ as text/plain, application/xml or\n   application/octet-stream are useful for\
    \ real applications in the long\n   term.  It is recommended that M2M applications\
    \ making use of CoAP\n   request new Internet media types from IANA indicating\
    \ semantic\n   information about how to create or parse a payload.  For example,\
    \ a\n   Smart Energy application payload carried as XML might request a more\n\
    \   specific type like application/se+xml or application/se-exi.\n"
- title: 12.4.  URI Scheme Registration
  contents:
  - "12.4.  URI Scheme Registration\n   This document contains the request for the\
    \ registration of the\n   Uniform Resource Identifier (URI) scheme \"coap\". \
    \ The registration\n   request complies with [RFC4395].\n   URI scheme name.\n\
    \      coap\n   Status.\n      Permanent.\n   URI scheme syntax.\n      Defined\
    \ in Section 6.1 of [RFC7252].\n   URI scheme semantics.\n      The \"coap\" URI\
    \ scheme provides a way to identify resources that\n      are potentially accessible\
    \ over the Constrained Application\n      Protocol (CoAP).  The resources can\
    \ be located by contacting the\n      governing CoAP server and operated on by\
    \ sending CoAP requests to\n      the server.  This scheme can thus be compared\
    \ to the \"http\" URI\n      scheme [RFC2616].  See Section 6 of [RFC7252] for\
    \ the details of\n      operation.\n   Encoding considerations.\n      The scheme\
    \ encoding conforms to the encoding rules established for\n      URIs in [RFC3986],\
    \ i.e., internationalized and reserved characters\n      are expressed using UTF-8-based\
    \ percent-encoding.\n   Applications/protocols that use this URI scheme name.\n\
    \      The scheme is used by CoAP endpoints to access CoAP resources.\n   Interoperability\
    \ considerations.\n      None.\n   Security considerations.\n      See Section\
    \ 11.1 of [RFC7252].\n   Contact.\n      IETF Chair <chair@ietf.org>\n   Author/Change\
    \ controller.\n      IESG <iesg@ietf.org>\n   References.\n      [RFC7252]\n"
- title: 12.5.  Secure URI Scheme Registration
  contents:
  - "12.5.  Secure URI Scheme Registration\n   This document contains the request\
    \ for the registration of the\n   Uniform Resource Identifier (URI) scheme \"\
    coaps\".  The registration\n   request complies with [RFC4395].\n   URI scheme\
    \ name.\n      coaps\n   Status.\n      Permanent.\n   URI scheme syntax.\n  \
    \    Defined in Section 6.2 of [RFC7252].\n   URI scheme semantics.\n      The\
    \ \"coaps\" URI scheme provides a way to identify resources that\n      are potentially\
    \ accessible over the Constrained Application\n      Protocol (CoAP) using Datagram\
    \ Transport Layer Security (DTLS) for\n      transport security.  The resources\
    \ can be located by contacting\n      the governing CoAP server and operated on\
    \ by sending CoAP requests\n      to the server.  This scheme can thus be compared\
    \ to the \"https\"\n      URI scheme [RFC2616].  See Section 6 of [RFC7252] for\
    \ the details\n      of operation.\n   Encoding considerations.\n      The scheme\
    \ encoding conforms to the encoding rules established for\n      URIs in [RFC3986],\
    \ i.e., internationalized and reserved characters\n      are expressed using UTF-8-based\
    \ percent-encoding.\n   Applications/protocols that use this URI scheme name.\n\
    \      The scheme is used by CoAP endpoints to access CoAP resources\n      using\
    \ DTLS.\n   Interoperability considerations.\n      None.\n   Security considerations.\n\
    \      See Section 11.1 of [RFC7252].\n   Contact.\n      IETF Chair <chair@ietf.org>\n\
    \   Author/Change controller.\n      IESG <iesg@ietf.org>\n   References.\n  \
    \    [RFC7252]\n"
- title: 12.6.  Service Name and Port Number Registration
  contents:
  - "12.6.  Service Name and Port Number Registration\n   One of the functions of\
    \ CoAP is resource discovery: a CoAP client can\n   ask a CoAP server about the\
    \ resources offered by it (see Section 7).\n   To enable resource discovery just\
    \ based on the knowledge of an IP\n   address, the CoAP port for resource discovery\
    \ needs to be\n   standardized.\n   IANA has assigned the port number 5683 and\
    \ the service name \"coap\",\n   in accordance with [RFC6335].\n   Besides unicast,\
    \ CoAP can be used with both multicast and anycast.\n   Service Name.\n      coap\n\
    \   Transport Protocol.\n      udp\n   Assignee.\n      IESG <iesg@ietf.org>\n\
    \   Contact.\n      IETF Chair <chair@ietf.org>\n   Description.\n      Constrained\
    \ Application Protocol (CoAP)\n   Reference.\n      [RFC7252]\n   Port Number.\n\
    \      5683\n"
- title: 12.7.  Secure Service Name and Port Number Registration
  contents:
  - "12.7.  Secure Service Name and Port Number Registration\n   CoAP resource discovery\
    \ may also be provided using the DTLS-secured\n   CoAP \"coaps\" scheme.  Thus,\
    \ the CoAP port for secure resource\n   discovery needs to be standardized.\n\
    \   IANA has assigned the port number 5684 and the service name \"coaps\",\n \
    \  in accordance with [RFC6335].\n   Besides unicast, DTLS-secured CoAP can be\
    \ used with anycast.\n   Service Name.\n      coaps\n   Transport Protocol.\n\
    \      udp\n   Assignee.\n      IESG <iesg@ietf.org>\n   Contact.\n      IETF\
    \ Chair <chair@ietf.org>\n   Description.\n      DTLS-secured CoAP\n   Reference.\n\
    \      [RFC7252]\n   Port Number.\n      5684\n"
- title: 12.8.  Multicast Address Registration
  contents:
  - "12.8.  Multicast Address Registration\n   Section 8, \"Multicast CoAP\", defines\
    \ the use of multicast.  IANA has\n   assigned the following multicast addresses\
    \ for use by CoAP nodes:\n   IPv4  -- \"All CoAP Nodes\" address 224.0.1.187,\
    \ from the \"IPv4\n      Multicast Address Space Registry\".  As the address is\
    \ used for\n      discovery that may span beyond a single network, it has come\
    \ from\n      the Internetwork Control Block (224.0.1.x, RFC 5771).\n   IPv6 \
    \ -- \"All CoAP Nodes\" address FF0X::FD, from the \"IPv6 Multicast\n      Address\
    \ Space Registry\", in the \"Variable Scope Multicast\n      Addresses\" space\
    \ (RFC 3307).  Note that there is a distinct\n      multicast address for each\
    \ scope that interested CoAP nodes should\n      listen to; CoAP needs the Link-Local\
    \ and Site-Local scopes only.\n"
- title: 13.  Acknowledgements
  contents:
  - "13.  Acknowledgements\n   Brian Frank was a contributor to and coauthor of early\
    \ versions of\n   this specification.\n   Special thanks to Peter Bigot, Esko\
    \ Dijk, and Cullen Jennings for\n   substantial contributions to the ideas and\
    \ text in the document,\n   along with countless detailed reviews and discussions.\n\
    \   Thanks to Floris Van den Abeele, Anthony Baire, Ed Beroset, Berta\n   Carballido,\
    \ Angelo P. Castellani, Gilbert Clark, Robert Cragie,\n   Pierre David, Esko Dijk,\
    \ Lisa Dusseault, Mehmet Ersue, Thomas\n   Fossati, Tobias Gondrom, Bert Greevenbosch,\
    \ Tom Herbst, Jeroen\n   Hoebeke, Richard Kelsey, Sye Loong Keoh, Ari Keranen,\
    \ Matthias\n   Kovatsch, Avi Lior, Stephan Lohse, Salvatore Loreto, Kerry Lynn,\n\
    \   Andrew McGregor, Alexey Melnikov, Guido Moritz, Petri Mutka, Colin\n   O'Flynn,\
    \ Charles Palmer, Adriano Pezzuto, Thomas Poetsch, Robert\n   Quattlebaum, Akbar\
    \ Rahman, Eric Rescorla, Dan Romascanu, David Ryan,\n   Peter Saint-Andre, Szymon\
    \ Sasin, Michael Scharf, Dale Seed, Robby\n   Simpson, Peter van der Stok, Michael\
    \ Stuber, Linyi Tian, Gilman\n   Tolle, Matthieu Vial, Maciej Wasilak, Fan Xianyou,\
    \ and Alper Yegin\n   for helpful comments and discussions that have shaped the\
    \ document.\n   Special thanks also to the responsible IETF area director at the\
    \ time\n   of completion, Barry Leiba, and the IESG reviewers, Adrian Farrel,\n\
    \   Martin Stiemerling, Pete Resnick, Richard Barnes, Sean Turner,\n   Spencer\
    \ Dawkins, Stephen Farrell, and Ted Lemon, who contributed in-\n   depth reviews.\n\
    \   Some of the text has been borrowed from the working documents of the\n   IETF\
    \ HTTPBIS working group.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC0768]  Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n              August 1980.\n   [RFC2045]  Freed, N. and N.\
    \ Borenstein, \"Multipurpose Internet Mail\n              Extensions (MIME) Part\
    \ One: Format of Internet Message\n              Bodies\", RFC 2045, November\
    \ 1996.\n   [RFC2046]  Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n\
    \              Extensions (MIME) Part Two: Media Types\", RFC 2046,\n        \
    \      November 1996.\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n           \
    \   Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer\
    \ Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC3023]  Murata, M., St.\
    \ Laurent, S., and D. Kohn, \"XML Media\n              Types\", RFC 3023, January\
    \ 2001.\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n\
    \              10646\", STD 63, RFC 3629, November 2003.\n   [RFC3676]  Gellens,\
    \ R., \"The Text/Plain Format and DelSp Parameters\",\n              RFC 3676,\
    \ February 2004.\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter,\
    \ \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\
    \ RFC\n              3986, January 2005.\n   [RFC4279]  Eronen, P. and H. Tschofenig,\
    \ \"Pre-Shared Key Ciphersuites\n              for Transport Layer Security (TLS)\"\
    , RFC 4279, December\n              2005.\n   [RFC4395]  Hansen, T., Hardie, T.,\
    \ and L. Masinter, \"Guidelines and\n              Registration Procedures for\
    \ New URI Schemes\", BCP 35, RFC\n              4395, February 2006.\n   [RFC5147]\
    \  Wilde, E. and M. Duerst, \"URI Fragment Identifiers for the\n             \
    \ text/plain Media Type\", RFC 5147, April 2008.\n   [RFC5198]  Klensin, J. and\
    \ M. Padlipsky, \"Unicode Format for Network\n              Interchange\", RFC\
    \ 5198, March 2008.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 5226,\n              May 2008.\n   [RFC5234]  Crocker, D. and P. Overell,\
    \ \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC\
    \ 5234, January 2008.\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport\
    \ Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August\
    \ 2008.\n   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n \
    \             Housley, R., and W. Polk, \"Internet X.509 Public Key\n        \
    \      Infrastructure Certificate and Certificate Revocation List\n          \
    \    (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5480]  Turner, S., Brown, D.,\
    \ Yiu, K., Housley, R., and T. Polk,\n              \"Elliptic Curve Cryptography\
    \ Subject Public Key\n              Information\", RFC 5480, March 2009.\n   [RFC5785]\
    \  Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known\n              Uniform\
    \ Resource Identifiers (URIs)\", RFC 5785, April\n              2010.\n   [RFC5952]\
    \  Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6\n              Address\
    \ Text Representation\", RFC 5952, August 2010.\n   [RFC5988]  Nottingham, M.,\
    \ \"Web Linking\", RFC 5988, October 2010.\n   [RFC6066]  Eastlake, D., \"Transport\
    \ Layer Security (TLS) Extensions:\n              Extension Definitions\", RFC\
    \ 6066, January 2011.\n   [RFC6347]  Rescorla, E. and N. Modadugu, \"Datagram\
    \ Transport Layer\n              Security Version 1.2\", RFC 6347, January 2012.\n\
    \   [RFC6690]  Shelby, Z., \"Constrained RESTful Environments (CoRE) Link\n  \
    \            Format\", RFC 6690, August 2012.\n   [RFC6920]  Farrell, S., Kutscher,\
    \ D., Dannewitz, C., Ohlman, B.,\n              Keranen, A., and P. Hallam-Baker,\
    \ \"Naming Things with\n              Hashes\", RFC 6920, April 2013.\n   [RFC7250]\
    \  Wouters, P., Tschofenig, H., Gilmore, J., Weiler, S., and\n              T.\
    \ Kivinen, \"Using Raw Public Keys in Transport Layer\n              Security\
    \ (TLS) and Datagram Transport Layer Security\n              (DTLS)\", RFC 7250,\
    \ June 2014.\n   [RFC7251]  McGrew, D., Bailey, D., Campagna, M., and R. Dugal,\
    \ \"AES-\n              CCM Elliptic Curve Cryptography (ECC) Cipher Suites for\n\
    \              Transport Layer Security (TLS)\", RFC 7251, June 2014.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [BLOCK]    Bormann, C. and Z. Shelby, \"Blockwise\
    \ transfers in CoAP\",\n              Work in Progress, October 2013.\n   [CoAP-MISC]\n\
    \              Bormann, C. and K. Hartke, \"Miscellaneous additions to\n     \
    \         CoAP\", Work in Progress, December 2013.\n   [EUI64]    IEEE Standards\
    \ Association, \"Guidelines for 64-bit Global\n              Identifier (EUI-64\
    \ (TM))\", Registration Authority\n              Tutorials, April 2010, <http://standards.ieee.org/regauth/\n\
    \              oui/tutorials/EUI64.html>.\n   [GROUPCOMM]\n              Rahman,\
    \ A. and E. Dijk, \"Group Communication for CoAP\",\n              Work in Progress,\
    \ December 2013.\n   [HHGTTG]   Adams, D., \"The Hitchhiker's Guide to the Galaxy\"\
    , Pan\n              Books ISBN 3320258648, 1979.\n   [IEEE1003.1]\n         \
    \     IEEE and The Open Group, \"Portable Operating System\n              Interface\
    \ (POSIX)\", The Open Group Base Specifications\n              Issue 7, IEEE 1003.1,\
    \ 2013 Edition,\n              <http://pubs.opengroup.org/onlinepubs/9699919799/>.\n\
    \   [IPsec-CoAP]\n              Bormann, C., \"Using CoAP with IPsec\", Work in\
    \ Progress,\n              December 2012.\n   [MAPPING]  Castellani, A., Loreto,\
    \ S., Rahman, A., Fossati, T., and\n              E. Dijk, \"Guidelines for HTTP-CoAP\
    \ Mapping\n              Implementations\", Work in Progress, February 2014.\n\
    \   [OBSERVE]  Hartke, K., \"Observing Resources in CoAP\", Work in\n        \
    \      Progress, April 2014.\n   [REC-exi-20140211]\n              Schneider,\
    \ J., Kamiya, T., Peintner, D., and R. Kyusakov,\n              \"Efficient XML\
    \ Interchange (EXI) Format 1.0 (Second\n              Edition)\", W3C Recommendation\
    \ REC-exi-20140211, February\n              2014, <http://www.w3.org/TR/2014/REC-exi-20140211/>.\n\
    \   [REST]     Fielding, R., \"Architectural Styles and the Design of\n      \
    \        Network-based Software Architectures\", Ph.D. Dissertation,\n       \
    \       University of California, Irvine, 2000,\n              <http://www.ics.uci.edu/~fielding/pubs/dissertation/\n\
    \              fielding_dissertation.pdf>.\n   [RFC0020]  Cerf, V., \"ASCII format\
    \ for network interchange\", RFC 20,\n              October 1969.\n   [RFC0791]\
    \  Postel, J., \"Internet Protocol\", STD 5, RFC 791, September\n            \
    \  1981.\n   [RFC0792]  Postel, J., \"Internet Control Message Protocol\", STD\
    \ 5,\n              RFC 792, September 1981.\n   [RFC0793]  Postel, J., \"Transmission\
    \ Control Protocol\", STD 7, RFC\n              793, September 1981.\n   [RFC1035]\
    \  Mockapetris, P., \"Domain names - implementation and\n              specification\"\
    , STD 13, RFC 1035, November 1987.\n   [RFC3264]  Rosenberg, J. and H. Schulzrinne,\
    \ \"An Offer/Answer Model\n              with Session Description Protocol (SDP)\"\
    , RFC 3264, June\n              2002.\n   [RFC3280]  Housley, R., Polk, W., Ford,\
    \ W., and D. Solo, \"Internet\n              X.509 Public Key Infrastructure Certificate\
    \ and\n              Certificate Revocation List (CRL) Profile\", RFC 3280,\n\
    \              April 2002.\n   [RFC3542]  Stevens, W., Thomas, M., Nordmark, E.,\
    \ and T. Jinmei,\n              \"Advanced Sockets Application Program Interface\
    \ (API) for\n              IPv6\", RFC 3542, May 2003.\n   [RFC3828]  Larzon,\
    \ L-A., Degermark, M., Pink, S., Jonsson, L-E., and\n              G. Fairhurst,\
    \ \"The Lightweight User Datagram Protocol\n              (UDP-Lite)\", RFC 3828,\
    \ July 2004.\n   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n\
    \              Requirements for Security\", BCP 106, RFC 4086, June 2005.\n  \
    \ [RFC4443]  Conta, A., Deering, S., and M. Gupta, \"Internet Control\n      \
    \        Message Protocol (ICMPv6) for the Internet Protocol\n              Version\
    \ 6 (IPv6) Specification\", RFC 4443, March 2006.\n   [RFC4492]  Blake-Wilson,\
    \ S., Bolyard, N., Gupta, V., Hawk, C., and B.\n              Moeller, \"Elliptic\
    \ Curve Cryptography (ECC) Cipher Suites\n              for Transport Layer Security\
    \ (TLS)\", RFC 4492, May 2006.\n   [RFC4821]  Mathis, M. and J. Heffner, \"Packetization\
    \ Layer Path MTU\n              Discovery\", RFC 4821, March 2007.\n   [RFC4944]\
    \  Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler,\n              \"\
    Transmission of IPv6 Packets over IEEE 802.15.4\n              Networks\", RFC\
    \ 4944, September 2007.\n   [RFC5405]  Eggert, L. and G. Fairhurst, \"Unicast\
    \ UDP Usage Guidelines\n              for Application Designers\", BCP 145, RFC\
    \ 5405, November\n              2008.\n   [RFC5489]  Badra, M. and I. Hajjeh,\
    \ \"ECDHE_PSK Cipher Suites for\n              Transport Layer Security (TLS)\"\
    , RFC 5489, March 2009.\n   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"\
    Fundamental Elliptic\n              Curve Cryptography Algorithms\", RFC 6090,\
    \ February 2011.\n   [RFC6120]  Saint-Andre, P., \"Extensible Messaging and Presence\n\
    \              Protocol (XMPP): Core\", RFC 6120, March 2011.\n   [RFC6282]  Hui,\
    \ J. and P. Thubert, \"Compression Format for IPv6\n              Datagrams over\
    \ IEEE 802.15.4-Based Networks\", RFC 6282,\n              September 2011.\n \
    \  [RFC6335]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.\n    \
    \          Cheshire, \"Internet Assigned Numbers Authority (IANA)\n          \
    \    Procedures for the Management of the Service Name and\n              Transport\
    \ Protocol Port Number Registry\", BCP 165, RFC\n              6335, August 2011.\n\
    \   [RFC6655]  McGrew, D. and D. Bailey, \"AES-CCM Cipher Suites for\n       \
    \       Transport Layer Security (TLS)\", RFC 6655, July 2012.\n   [RFC6936] \
    \ Fairhurst, G. and M. Westerlund, \"Applicability Statement\n              for\
    \ the Use of IPv6 UDP Datagrams with Zero Checksums\",\n              RFC 6936,\
    \ April 2013.\n   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,\n\
    \              Galperin, S., and C. Adams, \"X.509 Internet Public Key\n     \
    \         Infrastructure Online Certificate Status Protocol - OCSP\",\n      \
    \        RFC 6960, June 2013.\n   [RFC6961]  Pettersen, Y., \"The Transport Layer\
    \ Security (TLS)\n              Multiple Certificate Status Request Extension\"\
    , RFC 6961,\n              June 2013.\n   [RFC7159]  Bray, T., \"The JavaScript\
    \ Object Notation (JSON) Data\n              Interchange Format\", RFC 7159, March\
    \ 2014.\n   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n\
    \              Constrained-Node Networks\", RFC 7228, May 2014.\n   [RTO-CONSIDER]\n\
    \              Allman, M., \"Retransmission Timeout Considerations\", Work\n \
    \             in Progress, May 2012.\n   [W3CXMLSEC]\n              Wenning, R.,\
    \ \"Report of the XML Security PAG\", W3C XML\n              Security PAG, October\
    \ 2012,\n              <http://www.w3.org/2011/xmlsec-pag/pagreport.html>.\n"
- title: Appendix A.  Examples
  contents:
  - "Appendix A.  Examples\n   This section gives a number of short examples with\
    \ message flows for\n   GET requests.  These examples demonstrate the basic operation,\
    \ the\n   operation in the presence of retransmissions, and multicast.\n   Figure\
    \ 16 shows a basic GET request causing a piggybacked response:\n   The client\
    \ sends a Confirmable GET request for the resource\n   coap://server/temperature\
    \ to the server with a Message ID of 0x7d34.\n   The request includes one Uri-Path\
    \ Option (Delta 0 + 11 = 11, Length\n   11, Value \"temperature\"); the Token\
    \ is left empty.  This request is a\n   total of 16 bytes long.  A 2.05 (Content)\
    \ response is returned in the\n   Acknowledgement message that acknowledges the\
    \ Confirmable request,\n   echoing both the Message ID 0x7d34 and the empty Token\
    \ value.  The\n   response includes a Payload of \"22.3 C\" and is 11 bytes long.\n\
    \   Client  Server\n      |      |\n      |      |\n      +----->|     Header:\
    \ GET (T=CON, Code=0.01, MID=0x7d34)\n      | GET  |   Uri-Path: \"temperature\"\
    \n      |      |\n      |      |\n      |<-----+     Header: 2.05 Content (T=ACK,\
    \ Code=2.05, MID=0x7d34)\n      | 2.05 |    Payload: \"22.3 C\"\n      |     \
    \ |\n    0                   1                   2                   3\n    0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 1 | 0 |   0   |     GET=1     |          MID=0x7d34           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  11   |  11   |      \"temperature\" (11 B) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 1 | 2 |   0   |    2.05=69    |          MID=0x7d34           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 1 1 1 1 1 1 1|      \"22.3 C\" (6 B) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           Figure 16: Confirmable Request; Piggybacked Response\n   Figure 17\
    \ shows a similar example, but with the inclusion of an non-\n   empty Token (Value\
    \ 0x20) in the request and the response, increasing\n   the sizes to 17 and 12\
    \ bytes, respectively.\n   Client  Server\n      |      |\n      |      |\n  \
    \    +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d35)\n      | GET  | \
    \     Token: 0x20\n      |      |   Uri-Path: \"temperature\"\n      |      |\n\
    \      |      |\n      |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d35)\n\
    \      | 2.05 |      Token: 0x20\n      |      |    Payload: \"22.3 C\"\n    \
    \  |      |\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 1 | 0 |   1   |     GET=1     |          MID=0x7d35           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     0x20      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  11   |  11   |      \"temperature\" (11 B) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | 1 | 2 |   1   |    2.05=69    |          MID=0x7d35           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     0x20      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |1 1 1 1 1 1 1 1| \"22.3 C\" (6 B) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           Figure 17: Confirmable Request; Piggybacked Response\n   In Figure\
    \ 18, the Confirmable GET request is lost.  After ACK_TIMEOUT\n   seconds, the\
    \ client retransmits the request, resulting in a\n   piggybacked response as in\
    \ the previous example.\n   Client  Server\n      |      |\n      |      |\n \
    \     +----X |     Header: GET (T=CON, Code=0.01, MID=0x7d36)\n      | GET  |\
    \      Token: 0x31\n      |      |   Uri-Path: \"temperature\"\n   TIMEOUT   |\n\
    \      |      |\n      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d36)\n\
    \      | GET  |      Token: 0x31\n      |      |   Uri-Path: \"temperature\"\n\
    \      |      |\n      |      |\n      |<-----+     Header: 2.05 Content (T=ACK,\
    \ Code=2.05, MID=0x7d36)\n      | 2.05 |      Token: 0x31\n      |      |    Payload:\
    \ \"22.3 C\"\n      |      |\n   Figure 18: Confirmable Request (Retransmitted);\
    \ Piggybacked Response\n   In Figure 19, the first Acknowledgement message from\
    \ the server to\n   the client is lost.  After ACK_TIMEOUT seconds, the client\n\
    \   retransmits the request.\n   Client  Server\n      |      |\n      |     \
    \ |\n      +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d37)\n      | GET\
    \  |      Token: 0x42\n      |      |   Uri-Path: \"temperature\"\n      |   \
    \   |\n      |      |\n      | X----+     Header: 2.05 Content (T=ACK, Code=2.05,\
    \ MID=0x7d37)\n      | 2.05 |      Token: 0x42\n      |      |    Payload: \"\
    22.3 C\"\n   TIMEOUT   |\n      |      |\n      +----->|     Header: GET (T=CON,\
    \ Code=0.01, MID=0x7d37)\n      | GET  |      Token: 0x42\n      |      |   Uri-Path:\
    \ \"temperature\"\n      |      |\n      |      |\n      |<-----+     Header:\
    \ 2.05 Content (T=ACK, Code=2.05, MID=0x7d37)\n      | 2.05 |      Token: 0x42\n\
    \      |      |    Payload: \"22.3 C\"\n      |      |\n   Figure 19: Confirmable\
    \ Request; Piggybacked Response (Retransmitted)\n   In Figure 20, the server acknowledges\
    \ the Confirmable request and\n   sends a 2.05 (Content) response separately in\
    \ a Confirmable message.\n   Note that the Acknowledgement message and the Confirmable\
    \ response do\n   not necessarily arrive in the same order as they were sent.\
    \  The\n   client acknowledges the Confirmable response.\n   Client  Server\n\
    \      |      |\n      |      |\n      +----->|     Header: GET (T=CON, Code=0.01,\
    \ MID=0x7d38)\n      | GET  |      Token: 0x53\n      |      |   Uri-Path: \"\
    temperature\"\n      |      |\n      |      |\n      |<- - -+     Header: (T=ACK,\
    \ Code=0.00, MID=0x7d38)\n      |      |\n      |      |\n      |<-----+     Header:\
    \ 2.05 Content (T=CON, Code=2.05, MID=0xad7b)\n      | 2.05 |      Token: 0x53\n\
    \      |      |    Payload: \"22.3 C\"\n      |      |\n      |      |\n     \
    \ +- - ->|     Header: (T=ACK, Code=0.00, MID=0xad7b)\n      |      |\n      \
    \       Figure 20: Confirmable Request; Separate Response\n   Figure 21 shows\
    \ an example where the client loses its state (e.g.,\n   crashes and is rebooted)\
    \ right after sending a Confirmable request,\n   so the separate response arriving\
    \ some time later comes unexpected.\n   In this case, the client rejects the Confirmable\
    \ response with a\n   Reset message.  Note that the unexpected ACK is silently\
    \ ignored.\n   Client  Server\n      |      |\n      |      |\n      +----->|\
    \     Header: GET (T=CON, Code=0.01, MID=0x7d39)\n      | GET  |      Token: 0x64\n\
    \      |      |   Uri-Path: \"temperature\"\n    CRASH    |\n      |      |\n\
    \      |<- - -+     Header: (T=ACK, Code=0.00, MID=0x7d39)\n      |      |\n \
    \     |      |\n      |<-----+     Header: 2.05 Content (T=CON, Code=2.05, MID=0xad7c)\n\
    \      | 2.05 |      Token: 0x64\n      |      |    Payload: \"22.3 C\"\n    \
    \  |      |\n      |      |\n      +- - ->|     Header: (T=RST, Code=0.00, MID=0xad7c)\n\
    \      |      |\n      Figure 21: Confirmable Request; Separate Response (Unexpected)\n\
    \   Figure 22 shows a basic GET request where the request and the\n   response\
    \ are Non-confirmable, so both may be lost without notice.\n   Client  Server\n\
    \      |      |\n      |      |\n      +----->|     Header: GET (T=NON, Code=0.01,\
    \ MID=0x7d40)\n      | GET  |      Token: 0x75\n      |      |   Uri-Path: \"\
    temperature\"\n      |      |\n      |      |\n      |<-----+     Header: 2.05\
    \ Content (T=NON, Code=2.05, MID=0xad7d)\n      | 2.05 |      Token: 0x75\n  \
    \    |      |    Payload: \"22.3 C\"\n      |      |\n       Figure 22: Non-confirmable\
    \ Request; Non-confirmable Response\n   In Figure 23, the client sends a Non-confirmable\
    \ GET request to a\n   multicast address: all nodes in link-local scope.  There\
    \ are 3\n   servers on the link: A, B and C.  Servers A and B have a matching\n\
    \   resource, therefore they send back a Non-confirmable 2.05 (Content)\n   response.\
    \  The response sent by B is lost.  C does not have matching\n   response, therefore\
    \ it sends a Non-confirmable 4.04 (Not Found)\n   response.\n   Client  ff02::1\
    \  A  B  C\n      |       |     |  |  |\n      |       |     |  |  |\n      +------>|\
    \     |  |  |  Header: GET (T=NON, Code=0.01, MID=0x7d41)\n      |  GET  |   \
    \  |  |  |   Token: 0x86\n      |             |  |  |   Uri-Path: \"temperature\"\
    \n      |             |  |  |\n      |             |  |  |\n      |<------------+\
    \  |  |  Header: 2.05 (T=NON, Code=2.05, MID=0x60b1)\n      |      2.05   |  |\
    \  |   Token: 0x86\n      |             |  |  |   Payload: \"22.3 C\"\n      |\
    \             |  |  |\n      |             |  |  |\n      |   X------------+ \
    \ |  Header: 2.05 (T=NON, Code=2.05, MID=0x01a0)\n      |      2.05   |  |  |\
    \   Token: 0x86\n      |             |  |  |   Payload: \"20.9 C\"\n      |  \
    \           |  |  |\n      |             |  |  |\n      |<------------------+\
    \  Header: 4.04 (T=NON, Code=4.04, MID=0x952a)\n      |      4.04   |  |  |  \
    \ Token: 0x86\n      |             |  |  |\n      Figure 23: Non-confirmable Request\
    \ (Multicast); Non-confirmable\n                                 Response\n"
- title: Appendix B.  URI Examples
  contents:
  - "Appendix B.  URI Examples\n   The following examples demonstrate different sets\
    \ of Uri options, and\n   the result after constructing an URI from them.  In\
    \ addition to the\n   options, Section 6.5 refers to the destination IP address\
    \ and port,\n   but not all paths of the algorithm cause the destination IP address\n\
    \   and port to be included in the URI.\n   o  Input:\n         Destination IP\
    \ Address = [2001:db8::2:1]\n         Destination UDP Port = 5683\n      Output:\n\
    \         coap://[2001:db8::2:1]/\n   o  Input:\n         Destination IP Address\
    \ = [2001:db8::2:1]\n         Destination UDP Port = 5683\n         Uri-Host =\
    \ \"example.net\"\n      Output:\n         coap://example.net/\n   o  Input:\n\
    \         Destination IP Address = [2001:db8::2:1]\n         Destination UDP Port\
    \ = 5683\n         Uri-Host = \"example.net\"\n         Uri-Path = \".well-known\"\
    \n         Uri-Path = \"core\"\n      Output:\n         coap://example.net/.well-known/core\n\
    \   o  Input:\n         Destination IP Address = [2001:db8::2:1]\n         Destination\
    \ UDP Port = 5683\n         Uri-Host = \"xn--18j4d.example\"\n         Uri-Path\
    \ = the string composed of the Unicode characters U+3053\n         U+3093 U+306b\
    \ U+3061 U+306f, usually represented in UTF-8 as\n         E38193E38293E381ABE381A1E381AF\
    \ hexadecimal\n      Output:\n         coap://xn--18j4d.example/\n         %E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF\n\
    \         (The line break has been inserted for readability; it is not\n     \
    \    part of the URI.)\n   o  Input:\n         Destination IP Address = 198.51.100.1\n\
    \         Destination UDP Port = 61616\n         Uri-Path = \"\"\n         Uri-Path\
    \ = \"/\"\n         Uri-Path = \"\"\n         Uri-Path = \"\"\n         Uri-Query\
    \ = \"//\"\n         Uri-Query = \"?&\"\n      Output:\n         coap://198.51.100.1:61616//%2F//?%2F%2F&?%26\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Zach Shelby\n   ARM\n   150 Rose Orchard\n   San Jose,\
    \ CA  95134\n   USA\n   Phone: +1-408-203-9434\n   EMail: zach.shelby@arm.com\n\
    \   Klaus Hartke\n   Universitaet Bremen TZI\n   Postfach 330440\n   Bremen  D-28359\n\
    \   Germany\n   Phone: +49-421-218-63905\n   EMail: hartke@tzi.org\n   Carsten\
    \ Bormann\n   Universitaet Bremen TZI\n   Postfach 330440\n   Bremen  D-28359\n\
    \   Germany\n   Phone: +49-421-218-63921\n   EMail: cabo@tzi.org\n"
