- title: __initial_text__
  contents:
  - "       Independent Data Unit Protection Generic Security Service\n          \
    \    Application Program Interface (IDUP-GSS-API)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: ABSTRACT
  contents:
  - "ABSTRACT\n   The IDUP-GSS-API extends the GSS-API [RFC-2078] for applications\n\
    \   requiring protection of a generic data unit (such as a file or\n   message)\
    \ in a way which is independent of the protection of any other\n   data unit and\
    \ independent of any concurrent contact with designated\n   \"receivers\" of the\
    \ data unit.  Thus, it is suitable for applications\n   such as secure electronic\
    \ mail where data needs to be protected\n   without any on-line connection with\
    \ the intended recipient(s) of that\n   data.  The protection offered by IDUP\
    \ includes services such as data\n   origin authentication with data integrity,\
    \ data confidentiality with\n   data integrity, and support for non-repudiation\
    \ services.  Subsequent\n   to being protected, the data unit can be transferred\
    \ to the\n   recipient(s) - or to an archive - perhaps to be processed\n   (\"\
    unprotected\") only days or years later.\n   Throughout the remainder of this\
    \ document, the \"unit\" of data\n   described in the above paragraph will be\
    \ referred to as an IDU\n   (Independent Data Unit).  The IDU can be of any size\
    \ (the application\n   may, if it wishes, split the IDU into pieces and have the\
    \ protection\n   computed a piece at a time, but the resulting protection token\n\
    \   applies to the entire IDU).  However, the primary characteristic of\n   an\
    \ IDU is that it represents a stand-alone unit of data whose\n   protection is\
    \ entirely independent of any other unit of data.  If an\n   application protects\
    \ several IDUs and sends them all to a single\n   receiver, the IDUs may be unprotected\
    \ by that receiver in any order\n   over any time span; no logical connection\
    \ of any kind is implied by\n   the protection process itself.\n   As with RFC-2078,\
    \ this IDUP-GSS-API definition provides security\n   services to callers in a\
    \ generic fashion, supportable with a range of\n   underlying mechanisms and technologies\
    \ and hence allowing source-\n   level portability of applications to different\
    \ environments. This\n   specification defines IDUP-GSS-API services and primitives\
    \ at a level\n   independent of underlying mechanism and programming language\n\
    \   environment, and is to be complemented by other, related\n   specifications:\n\
    \      - documents defining specific parameter bindings for particular\n     \
    \   language environments;\n      - documents defining token formats, protocols,\
    \ and procedures to\n        be implemented in order to realize IDUP-GSS-API services\
    \ atop\n        particular security mechanisms.\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   1.  IDUP-GSS-API Characteristics and Concepts ..................\
    \    3\n   1.1.  IDUP-GSS-API Constructs ..................................  \
    \  5\n   1.1.1.  Credentials ............................................    5\n\
    \   1.1.2.  Tokens .................................................    5\n  \
    \ 1.1.3.  Security Environment ...................................    6\n   1.1.4.\
    \  Mechanism Types ........................................    6\n   1.1.5.  Naming\
    \ .................................................    6\n   1.1.6.  Channel Bindings\
    \ .......................................    6\n   1.2.  IDUP-GSS-API Features\
    \ and Issues .........................    6\n   1.2.1.  Status Reporting .......................................\
    \    6\n   1.2.2.  Per-IDU Security Service Availability ..................  \
    \  9\n   1.2.3.  Per-IDU Replay Detection and Sequencing ................    9\n\
    \   1.2.4.  Quality of Protection ..................................    9\n  \
    \ 1.2.5.  The Provision of Time ..................................   12\n   2.\
    \  Interface Descriptions .....................................   13\n   2.1.\
    \  Credential management calls ..............................   14\n   2.1.1.\
    \  Relationship to GSS-API ................................   14\n   2.2.  Environment-level\
    \ calls ..................................   15\n   2.2.1.  Relationship to GSS-API\
    \ ................................   15\n   2.2.2.  IDUP_Establish_Env call ................................\
    \   15\n   2.2.3.  IDUP_Abolish_Env call ..................................  \
    \ 19\n   2.2.4.  IDUP_Inquire_Env call ..................................   19\n\
    \   2.3.  Per-IDU protection/unprotection calls ....................   20\n  \
    \ 2.3.1.  Relationship to GSS-API ................................   20\n   2.3.2.\
    \  The \"SE\" Calls .........................................   21\n   2.3.3.\
    \  The \"EV\" Calls .........................................   27\n   2.3.4.\
    \  The \"GP\" Calls .........................................   36\n   2.4.  Special-Purpose\
    \ calls ....................................   47\n   2.4.1.  Relationship to\
    \ GSS-API ................................   47\n   2.4.2.  IDUP_Form_Complete_PIDU\
    \ ................................   48\n   2.5.  Support calls ............................................\
    \   49\n   2.5.1.  Relationship to GSS-API ................................  \
    \ 49\n   2.5.2.  IDUP_Acquire_Cred_With_Auth ............................   49\n\
    \   2.5.3.  IDUP_Get_Token_Details .................................   50\n  \
    \ 2.5.4.  IDUP_Get_Policy_Info ...................................   53\n   2.5.5.\
    \  IDUP_Cancel_Multibuffer_Op .............................   55\n   3.  Related\
    \ Activities .........................................   55\n   4.  Acknowledgments\
    \ ............................................   56\n   5.  Security Considerations\
    \ ....................................   56\n   6.  References       ...........................................\
    \   56\n   7.  Author's Address ...........................................  \
    \ 56\n   Appendix  A Mechanism-Independent Token Format .................   57\n\
    \   Appendix  B Examples of IDUP Use ...............................   58\n  \
    \ Full Copyright Statement .......................................   70\n"
- title: 1. IDUP-GSS-API Characteristics and Concepts
  contents:
  - "1. IDUP-GSS-API Characteristics and Concepts\n   The paradigm within which IDUP-GSS-API\
    \ operates is as follows.  An\n   IDUP-GSS-API caller is any application that\
    \ works with IDUs, calling\n   on IDUP-GSS-API in order to protect its IDUs with\
    \ services such as\n   data origin authentication with integrity (DOA), confidentiality\
    \ with\n   integrity (CONF), and/or support for non-repudiation (e.g., evidence\n\
    \   generation, where \"evidence\" is information that either by itself, or\n\
    \   when used in conjunction with other information, is used to establish\n  \
    \ proof about an event or action (note:  the evidence itself does not\n   necessarily\
    \ prove truth or existence of something, but contributes to\n   establish proof)\
    \ -- see [ISO/IEC] for fuller discussion regarding\n   evidence and its role in\
    \ various types of non-repudiation).  An\n   IDUP-GSS-API caller passes an IDU\
    \ to, and accepts a token from, its\n   local IDUP-GSS-API implementation, transferring\
    \ the resulting\n   protected IDU (P-IDU) to a peer or to any storage medium.\
    \  When a P-\n   IDU is to be \"unprotected\", it is passed to an IDUP-GSS-API\n\
    \   implementation for processing.  The security services available\n   through\
    \ IDUP-GSS-API in this fashion are implementable over a range\n   of underlying\
    \ mechanisms based on secret-key and/or public-key\n   cryptographic technologies.\n\
    \   During the protection operation, the input IDU buffers may be\n   modified\
    \ (for example, the data may be encrypted or encoded in some\n   way) or may remain\
    \ unchanged.  In any case, the result is termed a\n   \"M-IDU\" (Modified IDU)\
    \ in order to distinguish it from the original\n   IDU.  Depending on the desire\
    \ of the calling application and the\n   capabilities of the underlying IDUP mechanism,\
    \ the output produced by\n   the protection processing may or may not encapsulate\
    \ the M-IDU. Thus,\n   the P-IDU may be the contents of a single output parameter\
    \ (if\n   encapsulation is done) or may be the logical concatenation of an\n \
    \  unencapsulated token parameter and a M-IDU parameter (if\n   encapsulation\
    \ is not done).  In the latter case, the protecting\n   application may choose\
    \ whatever method it wishes to concatenate or\n   combine the unencapsulated token\
    \ and the M-IDU into a P-IDU, provided\n   the unprotecting application knows\
    \ how to de-couple the P-IDU back\n   into its component parts prior to calling\
    \ the IDUP unprotection set\n   of functions.\n   It is expected that any output\
    \ buffer returned by IDUP (i.e., P-IDU\n   or portion thereof) is ready for immediate\
    \ transmission to the\n   intended receiver(s) by the calling application, if\
    \ this is desired.\n   In other words, an application wishing to transmit data\
    \ buffers as\n   they appear from IDUP should not be unduly restricted from doing\
    \ so\n   by the underlying mechanism.\n   The IDUP-GSS-API separates the operation\
    \ of initializing a security\n   environment (the IDUP_Establish_Env() call) from\
    \ the operations of\n   providing per-IDU protection, for IDUs subsequently protected\
    \ in\n   conjunction with that environment. Per-IDU protection and\n   unprotection\
    \ calls provide DOA, CONF, evidence, and other services,\n   as requested by the\
    \ calling application and as supported by the\n   underlying mechanism.\n   The\
    \ following paragraphs provide an example illustrating the\n   dataflows involved\
    \ in the use of the IDUP-GSS-API by the sender and\n   receiver of a P-IDU in\
    \ a mechanism-independent fashion.  The example\n   assumes that credential acquisition\
    \ has already been completed by\n   both sides.  Furthermore, the example does\
    \ not cover all possible\n   options available in the protection/unprotection\
    \ calls.\n      The sender first calls IDUP_Establish_Env() to establish a\n \
    \     security environment.  Then, for the IDU to be protected the\n      sender\
    \ calls the appropriate protection calls (SE, EV, or GP) to\n      perform the\
    \ IDU protection.  The resulting P-IDU, which may\n      (depending on whether\
    \ or not encapsulation was chosen/available)\n      be either the token itself\
    \ or the logical concatenation of the\n      token and the M-IDU, is now ready\
    \ to be sent to the target.  The\n      sender then calls IDUP_Abolish_Env() to\
    \ flush all environment-\n      specific information.\n      The receiver first\
    \ calls IDUP_Establish_Env() to establish a\n      security environment in order\
    \ to unprotect the P-IDU.  Then, for\n      the received P-IDU the receiver calls\
    \ the appropriate unprotection\n      calls (SE, EV, or GP (known a priori, or\
    \ possibly determined\n      through the use of the IDUP_Get_token_details call))\
    \ to perform\n      the P-IDU unprotection.  The receiver then calls\n      IDUP_Abolish_Env()\
    \ to flush all environment-specific information.\n   It is important to note that\
    \ absolutely no synchronization is implied\n   or expected between the data buffer\
    \ size used by the sender as input\n   to the protection calls, the data buffer\
    \ size used by the receiver as\n   input to the unprotection calls, and the block\
    \ sizes required by the\n   underlying protection algorithms (integrity and confidentiality).\
    \ All\n   these sizes are meant to be independent; furthermore, the data buffer\n\
    \   sizes used for the protection and unprotection calls are purely a\n   function\
    \ of the local environment where the calls are made.\n   The IDUP-GSS-API design\
    \ assumes and addresses several basic goals,\n   including the following.\n  \
    \    Mechanism independence:  The IDUP-GSS-API defines an interface to\n     \
    \ cryptographically implemented security services at a generic level\n      which\
    \ is independent of particular underlying mechanisms. For\n      example, IDUP-GSS-API-provided\
    \ services can be implemented by\n      secret-key technologies or public-key\
    \ approaches.\n      Protocol environment independence: The IDUP-GSS-API is independent\n\
    \      of the communications protocol suites which may be used to\n      transfer\
    \ P-IDUs, permitting use in a broad range of protocol\n      environments.\n \
    \     Protocol association independence: The IDUP-GSS-API's security\n      environment\
    \ construct has nothing whatever to do with\n      communications protocol association\
    \ constructs, so that IDUP-GSS-\n      API services can be invoked by applications,\
    \ wholly independent of\n      protocol associations.\n      Suitability for a\
    \ range of implementation placements: IDUP-GSS-API\n      clients are not constrained\
    \ to reside within any Trusted Computing\n      Base (TCB) perimeter defined on\
    \ a system where the IDUP-GSS-API is\n      implemented; security services are\
    \ specified in a manner suitable\n      for both intra-TCB and extra-TCB callers.\n"
- title: 1.1. IDUP-GSS-API Constructs
  contents:
  - "1.1. IDUP-GSS-API Constructs\n   This section describes the basic elements comprising\
    \ the IDUP-GSS-\n   API.\n"
- title: 1.1.1.  Credentials
  contents:
  - "1.1.1.  Credentials\n   Credentials in IDUP-GSS-API are to be understood and\
    \ used as\n   described in GSS-API [RFC-2078].\n"
- title: 1.1.2. Tokens
  contents:
  - "1.1.2. Tokens\n   Tokens in IDUP-GSS-API are to be understood and used as described\
    \ in\n   GSS-API [RFC-2078] with the exception that there are no context-level\n\
    \   tokens generated by IDUP-GSS-API.  The IDUP-GSS-API token may\n   (depending\
    \ on the underlying mechanism) encapsulate the M-IDU or may\n   be logically concatenated\
    \ with the M-IDU prior to transfer to a\n   target; furthermore, for some evidence\
    \ services the token may be sent\n   independently of any other data transfer.\n"
- title: 1.1.3.  Security Environment
  contents:
  - "1.1.3.  Security Environment\n   The \"security environment\" in IDUP-GSS-API\
    \ is entirely different from\n   the concept of security contexts used in GSS-API\
    \ [RFC-2078].  Here, a\n   security environment exists within a calling application\
    \ (that is, it\n   is purely local to the caller) for the purpose of protecting\
    \ or\n   unprotecting one or more IDUs using a particular caller credential or\n\
    \   set of credentials.  In GSS-API, on the other hand, a security\n   context\
    \ exists between peers (the initiator and the target) for the\n   purpose of protecting,\
    \ in real time, the data that is exchanged\n   between them.  Although they are\
    \ different concepts, the env_handle\n   in IDUP-GSS-API is similar to the context_handle\
    \ in GSS-API in that\n   it is a convenient way of tying together the entire process\
    \ of\n   protecting or unprotecting one or more IDUs using a particular\n   underlying\
    \ mechanism.  As with the GSS-API security contexts, a\n   caller can initiate\
    \ and maintain multiple environments using the same\n   or different credentials.\n"
- title: 1.1.4.  Mechanism Types
  contents:
  - "1.1.4.  Mechanism Types\n   Mechanism types in IDUP-GSS-API are to be understood\
    \ and used as\n   described in GSS-API [RFC-2078].\n"
- title: 1.1.5.  Naming
  contents:
  - "1.1.5.  Naming\n   Naming in IDUP-GSS-API is to be understood and used as described\
    \ in\n   GSS-API [RFC-2078].\n"
- title: 1.1.6.  Channel Bindings
  contents:
  - "1.1.6.  Channel Bindings\n   The concept of channel bindings discussed in GSS-API\
    \ [RFC-2078] is\n   not relevant to the IDUP-GSS-API.\n"
- title: 1.2.  IDUP-GSS-API Features and Issues
  contents:
  - "1.2.  IDUP-GSS-API Features and Issues\n   This section describes aspects of\
    \ IDUP-GSS-API operations and of the\n   security services which the IDUP-GSS-API\
    \ provides.  It also provides\n   commentary on design issues.\n"
- title: 1.2.1.  Status Reporting
  contents:
  - "1.2.1.  Status Reporting\n   Status reporting in IDUP-GSS-API is to be understood\
    \ and used as\n   described in GSS-API [RFC-2078], with the addition of a number\
    \ of\n   IDUP-specific status codes.  Descriptions of the major_status codes\n\
    \   used in IDUP are provided in Table 1.  Codes that are informatory\n   (i.e.,\
    \ that do not cause the requested operation to fail) are\n   indicated with the\
    \ symbol \"(I)\".\n   As with GSS-API, minor_status codes, which provide more\
    \ detailed\n   status information than major_status codes, and which may include\n\
    \   status codes specific to the underlying security mechanism, are not\n   specified\
    \ in this document.\n    Table 1: IDUP-GSS-API Major Status Codes\n      GSS_S_BAD_MECH\
    \ indicates that a mech_type unsupported by the\n      IDUP_GSS-API implementation\
    \ was requested, causing the environment\n      establishment operation to fail.\n\
    \      GSS_S_BAD_QOP indicates that the provided qop_alg value is not\n      recognized\
    \ or supported for the environment.\n      GSS_S_BAD_MIC indicates that the received\
    \ P-IDU contains an\n      incorrect integrity field (e.g., signature or MAC)\
    \ for the data.\n      GSS_S_COMPLETE indicates that the requested operation was\n\
    \      successful.\n      GSS_S_CREDENTIALS_EXPIRED indicates that the credentials\n\
    \      associated with this operation have expired, so that the requested\n  \
    \    operation cannot be performed.\n      GSS_S_DEFECTIVE_CREDENTIAL indicates\
    \ that consistency checks\n      performed on the credential structure referenced\
    \ by\n      claimant_cred_handle failed, preventing further processing from\n\
    \      being performed using that credential structure.\n      GSS_S_DEFECTIVE_TOKEN\
    \ indicates that consistency checks performed\n      on the received P-IDU failed,\
    \ preventing further processing from\n      being performed.\n      GSS_S_FAILURE\
    \ indicates that the requested operation could not be\n      accomplished for\
    \ reasons unspecified at the IDUP-GSS-API level,\n      and that no interface-defined\
    \ recovery action is available.\n      GSS_S_NO_CRED indicates that no environment\
    \ was established,\n      either because the input cred_handle was invalid or\
    \ because the\n      caller lacks authorization to access the referenced credentials.\n\
    \      IDUP_S_BAD_DOA_KEY indicates that the key used to provide IDU data\n  \
    \    origin auth. / integ. has either expired or been revoked.\n      IDUP_S_BAD_ENC_IDU\
    \ indicates that decryption of the received IDU\n      cannot be completed because\
    \ the encrypted IDU was\n      invalid/defective (e.g., the final block was short\
    \ or had\n      incorrect padding).\n      IDUP_S_BAD_KE_KEY indicates that the\
    \ key used to establish a key\n      for confidentiality purposes between originator\
    \ and target has\n      either expired or been revoked.\n      IDUP_S_BAD_TARG_INFO\
    \ indicates that the full set of supplied\n      information regarding the target(s)\
    \ is invalid or is insufficient\n      for the protection of an IDU, so P-IDU\
    \ cannot be created.\n      IDUP_S_DEFECTIVE_VERIF indicates that consistency\
    \ checks performed\n      on Service_Verification_Info failed, preventing further\
    \ processing\n      from being performed with that parameter.\n      IDUP_S_ENCAPSULATION_UNAVAIL\
    \ (I) indicates that the underlying\n      mechanism does not support encapsulation\
    \ of the M-IDU into the\n      token.\n      IDUP_S_INAPPROPRIATE_CRED indicates\
    \ that the credentials supplied\n      do not contain the information necessary\
    \ for P-IDU unprotection.\n      IDUP_S_INCOMPLETE (I) indicates that the unprotection\
    \ of the P-IDU\n      is not yet complete (i.e., a determination cannot yet be\
    \ made on\n      the validity of the P-IDU).  The application should call\n  \
    \    IDUP_Form_Complete_PIDU and then should call this function again\n      with\
    \ the complete P-IDU.\n      IDUP_S_INCONSISTENT_PARAMS indicates that the supplied\
    \ parameters\n      are inconsistent (e.g., only one or the other of two parameters\n\
    \      may be supplied, but both have been input).\n      IDUP_S_MORE_OUTBUFFER_NEEDED\
    \ (I) indicates that the output buffer\n      supplied is too small to hold the\
    \ generated data.  The application\n      should continue calling this routine\
    \ (until GSS_S_COMPLETE is\n      returned) in order to get all remaining output\
    \ data.\n      IDUP_S_MORE_PIDU_NEEDED (I) indicates that not enough of the P-IDU\n\
    \      has been input yet for the completion of StartUnprotect.  The\n      application\
    \ should call this routine again with another buffer of\n      P-IDU in partial(initial)_pidu_buffer.\n\
    \      IDUP_S_NO_ENV indicates that no valid environment was recognized\n    \
    \  for the env_handle provided.\n      IDUP_S_NO_MATCH indicates that Service_Verification_Info\
    \ (or\n      evidence_check) and the P-IDU to be verified do not match.\n    \
    \  IDUP_S_REQ_TIME_SERVICE_UNAVAIL indicates that the time service\n      requested\
    \ (TTIME or UTIME) is not available in the environment.\n      IDUP_S_SERVICE_UNAVAIL\
    \ indicates that the underlying mechanism\n      does not support the service\
    \ requested.\n      IDUP_S_SERV_VERIF_INFO_NEEDED (I) indicates that the\n   \
    \   Service_Verification_Info parameter bundle must be input in order\n      for\
    \ service verification to proceed.  The output parameter\n      service_verification_info_id\
    \ contains an identifier which may be\n      used by the calling application to\
    \ locate the necessary\n      information.\n      IDUP_S_UNKNOWN_OPER_ID indicates\
    \ that the input prot_oper_id value\n      is not recognized or supported in the\
    \ underlying mechanism.\n"
- title: 1.2.2. Per-IDU Security Service Availability
  contents:
  - "1.2.2. Per-IDU Security Service Availability\n   Per-IDU security service availability\
    \ in IDUP-GSS-API is to be\n   understood and used as described in GSS-API [RFC-2078],\
    \ with the\n   exception that combinations of services requested by the calling\n\
    \   application and supported by the underlying mechanism may be applied\n   simultaneously\
    \ to any IDU (true for both the SE and the EV calls, but\n   true in the fullest\
    \ sense for the GP calls).\n   GSS-API callers desiring per-message security services\
    \ should check\n   the relevant service OBJECT IDs at environment establishment\
    \ time to\n   ensure that what is available in the established environment is\n\
    \   suitable for their security needs.\n"
- title: 1.2.3. Per-IDU Replay Detection and Sequencing
  contents:
  - "1.2.3. Per-IDU Replay Detection and Sequencing\n   The concept of per-IDU replay\
    \ detection and sequencing discussed in\n   GSS-API [RFC-2078] is not relevant\
    \ to the IDUP-GSS-API.\n"
- title: 1.2.4.  Quality of Protection
  contents:
  - "1.2.4.  Quality of Protection\n   The concept of QOP control in IDUP-GSS-API\
    \ is to be understood\n   essentially as described in GSS-API [RFC-2078].  However,\
    \ the actual\n   description and use of the QOP parameter is given as follows.\n\
    \   The qop_algs parameter for IDUP is defined to be a 32-bit unsigned\n   integer\
    \ with the following bit-field assignments:\n            31 (MSB)            \
    \                   (LSB) 0\n            ----------------------------------------------\n\
    \            |        U(19)       | TS(5) | IA(4) | MA(4) |\n            ----------------------------------------------\n\
    \   where\n      U is a 19-bit Unspecified field (available for future\n     \
    \ use/expansion) -- must be set to zero;\n      TS is a 5-bit Type Specifier (a\
    \ semantic qualifier whose value\n      specifies the type of algorithm which\
    \ may be used to protect the\n      corresponding IDU -- see below for details);\n\
    \      IA is a 4-bit field enumerating Implementation-specific\n      Algorithms;\
    \ and\n      MA is a 4-bit field enumerating Mechanism-defined Algorithms.\n \
    \  The interpretation of the qop_algs parameter is as follows.  The MA\n   field\
    \ is examined first.  If it is non-zero then the algorithm used\n   to protect\
    \ the IDU is the mechanism-specified algorithm corresponding\n   to that integer\
    \ value.\n   If MA is zero then IA is examined.  If this field value is non-zero\n\
    \   then the algorithm used to protect the IDU is the implementation-\n   specified\
    \ algorithm corresponding to that integer value.  Note that\n   use of this field\
    \ may hinder portability since a particular value may\n   specify one algorithm\
    \ in one implementation of the mechanism and may\n   not be supported or may specify\
    \ a completely different algorithm in\n   another implementation of the mechanism.\n\
    \   Finally, if both MA and IA are zero then TS is examined.  A value of\n   zero\
    \ for TS specifies the default algorithm for the established\n   mechanism.  A\
    \ non-zero value for TS corresponds to a particular\n   algorithm qualifier and\
    \ selects any algorithm from the mechanism\n   specification which satisfies that\
    \ qualifier (which actual algorithm\n   is selected is an implementation choice;\
    \ the calling application need\n   not be aware of the choice made).\n   The following\
    \ TS values (i.e., algorithm qualifiers) are specified;\n   other values may be\
    \ added in the future.\n   When qop_algs is used to select a confidentiality algorithm:\n\
    \      00000  (0) = default confidentiality algorithm\n      00001  (1) = IDUP_SYM_ALG_STRENGTH_STRONG\n\
    \      00010  (2) = IDUP_SYM_ALG_STRENGTH_MEDIUM\n      00011  (3) = IDUP_SYM_ALG_STRENGTH_WEAK\n\
    \      11111 (31) = IDUP_NO_CONFIDENTIALITY\n   When qop_algs is used to select\
    \ a DOA/integrity algorithm:\n      00000  (0) = default integrity algorithm\n\
    \      00001  (1) = IDUP_INT_ALG_DIG_SIGNATURE\n                   (integrity\
    \ provided through a digital signature)\n      00010  (2) = IDUP_INT_ALG_NON_DIG_SIGNATURE\n\
    \                   (integrity without a dig. sig. (e.g., with a MAC))\n     \
    \ 11111 (31) = IDUP_NO_INTEGRITY\n   Clearly, qualifiers such as strong, medium,\
    \ and weak are debatable\n   and likely to change with time, but for the purposes\
    \ of this version\n   of the specification we define these terms as follows. \
    \ A\n   confidentiality algorithm is \"weak\" if the effective key length of\n\
    \   the cipher is 40 bits or less; it is \"medium-strength\" if the\n   effective\
    \ key length is strictly between 40 and 80 bits; and it is\n   \"strong\" if the\
    \ effective key length is 80 bits or greater.\n   (\"Effective key length\" describes\
    \ the computational effort required\n   to break a cipher using the best-known\
    \ cryptanalytic attack against\n   that cipher.)\n   A five-bit TS field allows\
    \ up to 30 qualifiers for each of\n   confidentiality and integrity (since \"\
    0\" is reserved for \"default\"\n   and \"31\" is reserved for \"none\", as shown\
    \ above).  This document\n   specifies three for confidentiality and two for integrity,\
    \ leaving a\n   lot of room for future specification.  Suggestions of qualifiers\
    \ such\n   as \"fast\", \"medium-speed\", and \"slow\" have been made, but such\
    \ terms\n   are difficult to quantify (and in any case are platform- and\n   processor-dependent),\
    \ and so have been left out of this initial\n   specification.  The intention\
    \ is that the TS terms be quantitative,\n   environment-independent qualifiers\
    \ of algorithms, as much as this is\n   possible.\n   Use of the qop_algs parameter\
    \ as defined above is ultimately meant to\n   be as follows.\n    - TS values\
    \ are specified at the IDUP-GSS-API level and are\n      therefore portable across\
    \ mechanisms.  Applications which know\n      nothing about algorithms are still\
    \ able to choose \"quality\" of\n      protection for their message tokens.\n\
    \    - MA values are specified at the mechanism level and are therefore\n    \
    \  portable across implementations of a mechanism.\n    - IA values are specified\
    \ at the implementation level (in user\n      documentation, for example) and\
    \ are therefore typically non-\n      portable.  An application which is aware\
    \ of its own mechanism\n      implementation and the mechanism implementation\
    \ of its intended\n      P-IDU recipient, however, is free to use these values\
    \ since they\n      will be perfectly valid and meaningful for protecting IDUs\
    \ between\n      those entities.\n   The receiver of a P-IDU must pass back to\
    \ its calling application (in\n   IDUP_Start_Unprotect()) a qop_algs parameter\
    \ with all relevant fields\n   set.  For example, if triple-DES has been specified\
    \ by a mechanism as\n   algorithm 8, then a receiver of a triple-DES-protected\
    \ P-IDU must\n   pass to its application (TS=1, IA=0, MA=8).  In this way, the\n\
    \   application is free to read whatever part of the qop_algs parameter\n   it\
    \ understands (TS or IA/MA).\n"
- title: 1.2.5.  The Provision of Time
  contents:
  - "1.2.5.  The Provision of Time\n   IDUP mechanisms should make provision in their\
    \ protocols for the\n   carrying of time information from originator to target(s).\
    \  That is,\n   a target (a legitimate recipient) should get some indication during\n\
    \   unprotection regarding the time at which the protection operation\n   took\
    \ place.  This is particularly important if the mechanism offers\n   non-repudiation\
    \ services because in some cases evidence verification\n   may only be achievable\
    \ if the time at which the evidence was\n   generated is known.\n   Depending\
    \ upon the platform and resources available to the\n   implementation, an IDUP\
    \ environment may have access to a source of\n   trusted (secure) time, untrusted\
    \ (local) time, both kinds of time, or\n   no time.  OBJECT IDs indicating such\
    \ availability are returned by the\n   IDUP_Establish_Env() call.  When starting\
    \ a protection operation, an\n   application may specify which time services it\
    \ wishes to have applied\n   to the IDU.  Similarly, for unprotection, an application\
    \ may specify\n   which kind of time (if any) to consult when the validity of\
    \ the P-IDU\n   is to be established.  Specifying both kinds of time is interpreted\n\
    \   to mean that the calling application does not care which kind of time\n  \
    \ is used.\n   The IDUP calls which use a time parameter specify the type of that\n\
    \   parameter to be INTEGER.  This INTEGER is defined in all cases to be\n   the\
    \ number of seconds which have elapsed since midnight, January 1,\n   1970, coordinated\
    \ universal time.\n"
- title: 2.  Interface Descriptions
  contents:
  - "2.  Interface Descriptions\n   This section describes the IDUP-GSS-API's operational\
    \ interface,\n   dividing the set of calls offered into five groups.  Credential\n\
    \   management calls are related to the acquisition and release of\n   credentials\
    \ by API callers. Environment-level calls are related to\n   the management of\
    \ the security environment by an API caller.  Per-IDU\n   calls are related to\
    \ the protection or unprotection of individual\n   IDUs in established security\
    \ environments.  Special-purpose calls\n   deal with unusual or auxiliary evidence\
    \ generation/verification\n   requirements.  Support calls provide extra functions\
    \ useful to IDUP-\n   GSS-API callers.  Table 2 groups and summarizes the calls\
    \ in tabular\n   fashion.\n    Table 2:  IDUP-GSS-API Calls\n      CREDENTIAL\
    \ MANAGEMENT\n      (see the calls given in Section 2.1 of GSS-API [RFC-2078])\n\
    \      ENVIRONMENT-LEVEL CALLS\n      IDUP_Establish_Env\n      IDUP_Abolish_Env\n\
    \      IDUP_Inquire_Env\n      PER-IDU CALLS\n      SE (SIGN,ENCRYPT) CALLS\n\
    \         IDUP_SE_SingleBuffer_Protect\n         IDUP_SE_SingleBuffer_Unprotect\n\
    \         IDUP_SE_MultiBuffer_StartProtect\n         IDUP_SE_MultiBuffer_EndProtect\n\
    \         IDUP_SE_MultiBuffer_StartUnprotect\n         IDUP_SE_MultiBuffer_EndUnprotect\n\
    \         IDUP_SE_Process_Buffer\n      EV (EVIDENCE) CALLS\n         IDUP_EV_SingleBuffer_Generate\n\
    \         IDUP_EV_SingleBuffer_Verify\n         IDUP_EV_MultiBuffer_StartGenerate\n\
    \         IDUP_EV_MultiBuffer_EndGenerate\n         IDUP_EV_MultiBuffer_StartVerify\n\
    \         IDUP_EV_MultiBuffer_EndVerify\n         IDUP_EV_Process_Buffer\n   \
    \   GP (GENERAL PROTECTION) CALLS\n         IDUP_Start_Protect\n         IDUP_Protect\n\
    \         IDUP_End_Protect\n         IDUP_Start_Unprotect\n         IDUP_Unprotect\n\
    \         IDUP_End_Unprotect\n      SPECIAL-PURPOSE CALLS  (might not be supported\
    \ by all mechanisms)\n      IDUP_Form_Complete_PIDU\n      SUPPORT CALLS\n   \
    \   IDUP_Acquire_cred_with_auth\n      IDUP_Get_Token_Details\n      IDUP_Get_Policy_Info\n\
    \      IDUP_Cancel_Multibuffer_Op\n      (see also the calls given in Section\
    \ 2.4 of GSS-API [RFC-2078])\n   In terms of conformance to this specification,\
    \ IDUP-GSS-API\n   implementations must support the credential management calls,\
    \ the\n   environment-level calls, some subset of the per-IDU calls, and the\n\
    \   support calls (except where explicitly stated otherwise in Section\n   2.5).\
    \  The subset of per-IDU calls supported will depend upon the\n   underlying mechanisms\
    \ supported and will typically be the SE calls,\n   or the EV calls, or both.\
    \  As stated in Section 2.3.2.1,\n   implementations are encouraged to support\
    \ the more powerful GP calls\n   to anticipate the future needs of applications\
    \ developers, but this\n   is not required for conformance.\n"
- title: 2.1.  Credential management calls
  contents:
  - '2.1.  Credential management calls

    '
- title: 2.1.1.  Relationship to GSS-API
  contents:
  - "2.1.1.  Relationship to GSS-API\n   Credential management in IDUP-GSS-API is\
    \ to be understood and used as\n   described in GSS-API [RFC-2078].  The calls\
    \ given in Section 2.1 of\n   GSS-API (including all associated parameters) are\
    \ unchanged, although\n   the interpretation of the cred_usage parameter in the\
    \ GSS-API calls\n   for IDUP purposes is as follows.\n      ENCRYPT_ONLY    8\n\
    \      DECRYPT_ONLY   16\n      SIGN_ONLY      32\n      VERIFY_ONLY    64\n \
    \  The values above may be logically OR'ed together in any desired\n   combination\
    \ to restrict credential usage (where OR'ing all values\n   results in NO_RESTRICTION).\
    \  Future possible values for this\n   parameter are for further study.\n   The\
    \ call IDUP_Acquire_cred_with_auth has been added as a support call\n   in this\
    \ specification to permit authenticated credential acquirement;\n   see Section\
    \ 2.5.2 for details.\n"
- title: 2.2.  Environment-level calls
  contents:
  - "2.2.  Environment-level calls\n   This group of calls is devoted to the establishment\
    \ and management of\n   an environment for the purpose of IDU protection and unprotection.\n\
    \   Before protecting or unprotecting any IDU, an application must call\n   IDUP_Establish_Env()\
    \ to initialize environment information and select\n   the underlying IDUP-GSS\
    \ mechanism to be used.  A series of protection\n   or unprotection calls is made\
    \ to process each IDU, the protection\n   calls resulting in a P-IDU for each.\
    \  Finally, IDUP_Abolish_Env() is\n   called to flush all environment information.\n\
    \   Semantically, acquiring credentials and establishing an environment\n   is\
    \ (in many cases) analogous to logging in to a system -- it\n   authenticates\
    \ a local user to the system and gives that user access\n   to a set of operations\
    \ which can be performed.\n"
- title: 2.2.1.  Relationship to GSS-API
  contents:
  - "2.2.1.  Relationship to GSS-API\n   The set of calls described in this section\
    \ is used in place of the\n   calls described in Section 2.2 of GSS-API [RFC-2078],\
    \ since those\n   calls are specific to a session-oriented environment.\n"
- title: 2.2.2.  IDUP_Establish_Env call
  contents:
  - "2.2.2.  IDUP_Establish_Env call\n   Inputs: o  claimant_cred_handle CREDENTIAL\
    \ HANDLE,\n      -- NULL parameter specifies \"use default\"\n   o  req_mech_type\
    \ OBJECT IDENTIFIER,\n      -- NULL parameter specifies \"use default\"\n   o\
    \  req_environmentPolicies EnvironmentPolicies,\n      -- NULL parameter specifies\
    \ \"use default\"\n   o  req_services SET OF OBJECT IDENTIFIER,\n      -- GSS_C_NO_OID_SET\
    \ requests full set of services available\n      -- for req_mech_type\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  env_handle ENVIRONMENT\
    \ HANDLE,\n   o  actual_mech_type OBJECT IDENTIFIER,\n      -- actual mechanism\
    \ always indicated, never NULL\n   o  actual_environmentPolicies EnvironmentPolicies,\n\
    \      -- actual values always indicated, never NULL\n   o  ret_services SET OF\
    \ OBJECT IDENTIFIER,\n   Return major_status codes:\n   o  GSS_S_COMPLETE\n  \
    \    -- environment-level information was successfully initialized,\n      --\
    \ and IDU / P-IDU processing can begin.\n   o  GSS_S_DEFECTIVE_CREDENTIAL\n  \
    \ o  GSS_S_NO_CRED\n   o  GSS_S_CREDENTIALS_EXPIRED\n      -- the credentials\
    \ provided through claimant_cred_handle are\n      -- no longer valid, so environment\
    \ cannot be established.\n   o  GSS_S_BAD_MECH\n   o  GSS_S_FAILURE\n   The following\
    \ structures are defined to facilitate environment policy\n   input and output:\n\
    \   EnvironmentPolicies ::= SEQUENCE {\n      confPolicy     [0] PolicyAndTime\
    \ OPTIONAL,\n      -- NULL parameter (on input) specifies \"use default\"\n  \
    \    integPolicy    [1] PolicyAndTime OPTIONAL,\n      -- NULL parameter (on input)\
    \ specifies \"use default\"\n      evidencePolicy [2] PolicyAndTime OPTIONAL }\n\
    \      -- NULL parameter (on input) specifies \"use default\"\n   PolicyAndTime\
    \ ::= SEQUENCE {\n      policy             OBJECT IDENTIFIER,\n      -- this environment-level\
    \ policy identifier is separate from\n      -- the policy provisions connected\
    \ with credentials, if they exist\n      time               INTEGER\n      --\
    \ on input:  the policy rules available at the specified time\n      -- on output:\
    \ the time at which the policy rules came into effect\n      -- (defined to be\
    \ the number of seconds elapsed since midnight,\n      -- January 1, 1970, coordinated\
    \ universal time)\n      endTime            INTEGER OPTIONAL }\n      -- on input:\
    \  unused\n      -- on output: the expiration time of the given policy rules\n\
    \   This routine is used by an application which protects or unprotects\n   IDUs.\
    \  Using information in the credentials structure referenced by\n   claimant_cred_handle,\
    \ IDUP_Establish_Env() initializes the data\n   structures required to protect\
    \ or unprotect IDUs.  The\n   claimant_cred_handle, if non-NULL, must correspond\
    \ to a valid\n   credentials structure.\n   This routine returns an env_handle\
    \ for all future references to this\n   environment; when protection, unprotection,\
    \ or IDUP_Abolish_Env()\n   calls are made, this handle value will be used as\
    \ the input\n   env_handle argument.  It is the caller's responsibility to establish\n\
    \   a communications path to the intended recipients of the P-IDU, and to\n  \
    \ transmit the P-IDU to those recipients over that path.  This may\n   occur subsequent\
    \ to the IDUP_Abolish_Env() call.\n   The req_services parameter may be used by\
    \ the calling application to\n   request that data origin authentication with\
    \ integrity,\n   confidentiality with integrity, evidence generation, and/or evidence\n\
    \   verification services be available in the established environment.\n   Requests\
    \ can also be made for \"trusted\" or \"untrusted\" time services.\n   Requesting\
    \ evidence generation or verification indicates that the\n   calling application\
    \ may wish to generate or verify evidence\n   information for non-repudiation\
    \ purposes (note:  an IDU protector may\n   request that a flag be inserted into\
    \ a P-IDU asking a recipient to\n   provide an evidence of the type \"non-repudiation\
    \ of delivery\";\n   however, the IDUP-GSS-API cannot by itself guarantee that\
    \ the\n   evidence will be sent because there is no way to force a target to\n\
    \   send an evidence_token back to the IDU protector).\n   Not all features will\
    \ be available in all underlying mech_types; the\n   returned value of ret_services\
    \ indicates, as a function of mech_type\n   processing capabilities and the initiator-provided\
    \ input OBJECT IDs,\n   the set of features which will be available in the environment.\
    \ The\n   value of this parameter is undefined unless the routine's\n   major_status\
    \ indicates COMPLETE.  Failure to provide the precise set\n   of services desired\
    \ by the caller does not cause environment\n   establishment to fail; it is the\
    \ caller's choice to abolish the\n   environment if the service set provided is\
    \ unsuitable for the\n   caller's use.  The returned mech_type value indicates\
    \ the specific\n   mechanism employed in the environment and will never indicate\
    \ the\n   value for \"default\".\n   The following OBJECT IDs are defined for\
    \ protection and unprotection\n   services (the OBJECT ID iso.org.dod.internet.security.services,\n\
    \   1.3.6.1.5.7, has been assigned by IANA, and some of the security\n   services\
    \ under that node are assigned as shown below).  It is\n   recognized that this\
    \ list may grow over time.\n      PER_CONF = { 1.3.6.1.5.7.1.1 }\n         --\
    \ perform data confidentiality (i.e., encrypt data)\n      PER_CONF_FULL = { 1.3.6.1.5.7.1.3\
    \ }\n         -- perform full confidentiality (i.e., encrypt data and sig)\n \
    \        -- (may be used only when PER_DOA is requested simultaneously)\n    \
    \  PER_DOA  = { 1.3.6.1.5.7.3.1 }\n         -- perform data origin authentication\
    \ with data integrity\n      PER_DOA_CIPH  = { 1.3.6.1.5.7.3.3 }\n         --\
    \ perform DOA with DI over ciphertext (rather than plaintext)\n         -- (may\
    \ be used only when PER_CONF is requested simultaneously)\n      PER_POO  = {\
    \ 1.3.6.1.5.7.4.1 }\n         -- perform (i.e., create) non-repudiable \"proof\
    \ of origin\"\n      PER_POD  = { 1.3.6.1.5.7.4.3 }\n         -- perform (i.e.,\
    \ create) non-repudiable \"proof of delivery\"\n      REC_CONF = { 1.3.6.1.5.7.1.2\
    \ }\n         -- receive data confidentiality (i.e., decrypt data)\n      REC_CONF_FULL\
    \ = { 1.3.6.1.5.7.1.4 }\n         -- receive full confidentiality (i.e., decrypt\
    \ data and sig)\n         -- (may be used only when REC_DOA is received simultaneously)\n\
    \      REC_DOA  = { 1.3.6.1.5.7.3.2 }\n         -- receive / verify DOA with data\
    \ integrity\n      REC_DOA_CIPH  = { 1.3.6.1.5.7.3.4 }\n         -- verify DOA\
    \ with DI over ciphertext (rather than plaintext)\n         -- (may be used only\
    \ when PER_CONF is received simultaneously)\n      REC_POO  = { 1.3.6.1.5.7.4.2\
    \ }\n         -- receive / verify \"proof of origin\"\n      REC_POD  = { 1.3.6.1.5.7.4.4\
    \ }\n         -- receive / verify \"proof of delivery\"\n      TTIME    = { 1.3.6.1.5.7.7.1\
    \ }\n         -- trusted time availability\n      UTIME    = { 1.3.6.1.5.7.7.2\
    \ }\n         -- untrusted time availability\n   The PER_CONF return value (in\
    \ the ret_services paramater) indicates\n   whether the environment supports confidentiality\
    \ services, and so\n   informs the caller whether or not a request for encryption\
    \ can be\n   honored.  In similar fashion, the PER_DOA return value indicates\n\
    \   whether DOA services are available in the established environment,\n   and\
    \ the PER_POO and PER_POD return values indicate whether evidence\n   generation\
    \ services are available.  The TTIME and UTIME values\n   indicate whether trusted\
    \ time and untrusted time are available for\n   protection / unprotection services.\n\
    \   Note that, unlike a GSS \"context\", an IDUP environment does not have\n \
    \  an explicit lifetime associated with it.  Instead, it relies on the\n   lifetime\
    \ of the calling entity's credential (set by the caller in the\n   GSS_Acquire_cred()\
    \ call).  When the credential expires (or is\n   explicitly deleted in any other\
    \ way), no new operations are allowed\n   in the IDUP environment (although operations\
    \ which have begun, such\n   as the Protection set of calls, can be taken to completion).\n"
- title: 2.2.3. IDUP_Abolish_Env call
  contents:
  - "2.2.3. IDUP_Abolish_Env call\n   Input:\n   o  env_handle ENVIRONMENT HANDLE\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE\n      -- the relevant environment-specific\
    \ information was flushed.\n   o  IDUP_S_NO_ENV\n   o  GSS_S_FAILURE\n   This\
    \ call is made to flush environment-specific information. (Once an\n   environment\
    \ is established, cached credential and environment-related\n   info. is expected\
    \ to be retained until an IDUP_Abolish_Env() call is\n   made or until the cred.\
    \ lifetime expires.)  Attempts to perform IDU\n   processing on a deleted environment\
    \ will result in error returns.\n"
- title: 2.2.4. IDUP_Inquire_Env call
  contents:
  - "2.2.4. IDUP_Inquire_Env call\n   Input:\n   o  env_handle ENVIRONMENT HANDLE,\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ mech_type OBJECT IDENTIFIER,\n      -- the mechanism supporting this environment\n\
    \   o  environmentPolicies EnvironmentPolicies,\n      -- the environment policies\
    \ in effect\n   o  ret_services SET OF OBJECT IDENTIFIER,\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE\n      -- referenced environment is valid and mech_type\
    \ and other return\n      -- values describe the characteristics of the environment.\n\
    \   o  GSS_S_CREDENTIALS_EXPIRED\n   o  IDUP_S_NO_ENV\n   o  GSS_S_FAILURE\n \
    \  This routine provides environment-related information to the caller.\n"
- title: 2.3.  Per-IDU calls
  contents:
  - "2.3.  Per-IDU calls\n   This group of calls is used to perform IDU protection\
    \ and\n   unprotection processing on an established IDUP environment. Some of\n\
    \   these calls may block pending network interactions (depending on the\n   underlying\
    \ mechanism in use).  These calls may be invoked by an IDU's\n   protector or\
    \ by the P-IDU's recipient.  Members of this group form\n   pairs; the output\
    \ from the protection types of calls is typically\n   meant to be input to the\
    \ unprotection types of calls.\n   The per-IDU calls can support caller-requested\
    \ data origin\n   authentication with data integrity, confidentiality with data\n\
    \   integrity, evidence, and evidence-requested-from-target services.\n   The\
    \ protection operations output a token which encapsulates all the\n   information\
    \ required to unprotect the IDU.  The token is passed to\n   the target (possibly\
    \ separate from the M-IDU) and is processed by the\n   unprotection calls at that\
    \ system.  Unprotection performs\n   decipherment, DOA verification, evidence\
    \ verification, or\n   notification of evidence requested, as required.\n   Each\
    \ of the two main operations (protection and unprotection) may be\n   separated\
    \ into three parts:  \"Start_Operation\"; \"Operation\" (which\n   may be called\
    \ once for each buffer of input data); and\n   \"End_Operation\".  This separation\
    \ is available for the case where the\n   IDU or P-IDU is to be processed one\
    \ buffer at a time.\n   \"Start_Operation\" allows the caller to specify or retrieve\
    \ the\n   appropriate \"Quality\" used during the processing.  \"Operation\" is\n\
    \   concerned with the processing itself, receiving a buffer of input\n   data\
    \ and potentially returning a buffer of output data.\n   \"End_Operation\" performs\
    \ any required clean-up and creates the\n   appropriate token or states whether\
    \ the input token was verified.\n   If the IDU or P-IDU is wholly contained in\
    \ a single buffer, the\n   three-part protection/unprotection processing need\
    \ not be done.\n   Instead, protection or unprotection can be accomplished using\
    \ only a\n   single call, simplifying application code.\n"
- title: 2.3.1.  Relationship to GSS-API
  contents:
  - "2.3.1.  Relationship to GSS-API\n   The set of calls described in this section\
    \ is used in place of the\n   calls GSS_GetMIC(), GSS_VerifyMIC, GSS_Wrap(), and\
    \ GSS_Unwrap() which\n   are specified in [RFC-2078], since those calls are specific\
    \ to a\n   session-oriented environment.\n"
- title: 2.3.2.  The "SE" Calls
  contents:
  - '2.3.2.  The "SE" Calls

    '
- title: 2.3.2.1. IDUP_SE Purpose
  contents:
  - "2.3.2.1. IDUP_SE Purpose\n   The \"SE\" group of calls provides a very simple,\
    \ high-level interface\n   to underlying IDUP mechanisms when application developers\
    \ need access\n   only to signature and encryption protection/unprotection services.\n\
    \   It includes both the single-buffer and multiple-buffer IDU cases and\n   can\
    \ be used for signing only, encrypting only, signing and encrypting\n   (in either\
    \ order, and with or without visibility of the resulting\n   signature), and \"\
    clear signing\" (where the data is not modified in\n   any way and the signature\
    \ itself is returned as a separate item).\n   [Note that encapsulation occurs\
    \ in all cases except for clear\n   signing, so that these calls provide functionality\
    \ similar to the\n   GSS_Wrap call.]\n   Note that the term \"signing\" is used\
    \ in its most generic sense, not\n   necessarily implying the use of public-key\
    \ techniques.  This concept\n   has also been called \"sealing\" in other contexts\
    \ (e.g., in other\n   standardization efforts).\n   The SE calls may be viewed\
    \ by mechanism implementors as an \"API\" to\n   the more powerful GP calls defined\
    \ later and so may be implemented as\n   simple mapping functions to those calls\
    \ (when those optional calls\n   are supported).  Application callers, on the\
    \ other hand, may find\n   that the SE calls are all they currently need for many\
    \ environments.\n   At some time in the future when they have need of non-repudiation\
    \ or\n   \"directed receipts\" types of services, they may consider using the\
    \ EV\n   calls (or the GP calls -- when these are supported -- if complex and\n\
    \   sophisticated combinations of services are required).  To assist in\n   this\
    \ migration path, mechanism implementors are encouraged to support\n   the full\
    \ set of IDUP calls (i.e., the SE, EV, and GP calls) even\n   though some calling\
    \ applications will only use the SE calls in the\n   short term.\n"
- title: 2.3.2.2. IDUP_SE Parameter Bundles
  contents:
  - "2.3.2.2. IDUP_SE Parameter Bundles\n   The concept of \"parameter bundles\" is\
    \ used in the calls presented in\n   the following subsections in order to simplify\
    \ their presentation and\n   clarify their intended purpose and use.  See Section\
    \ 2.3.4.1 for a\n   more complete description of parameter bundles.\n   The following\
    \ parameter bundles are used in the \"SE\" protection and\n   unprotection sets\
    \ of calls.\n   o  Protect_Options PARAMETER BUNDLE\n      o  protect_operation\
    \  INTEGER {\n            sign_only              (0),\n            encrypt_only\
    \           (1),\n            sign_and_encrypt       (2),\n            -- let\
    \ mechanism choose order (and readability of signature)\n            sign_then_encrypt_data\
    \ (3),\n            -- sign, then encrypt plaintext (leaving signature in clear)\n\
    \            sign_then_encrypt_full (4),\n            -- sign, then encrypt everything\
    \ (including signature)\n            encrypt_then_sign      (5),\n           \
    \ -- encrypt, then sign the ciphertext\n            clear_sign_only        (6)\n\
    \         } OPTIONAL,\n      o  protect_oper_oid   OBJECT IDENTIFIER OPTIONAL,\n\
    \         -- may be used in place of above parameter if OID is known\n      o\
    \  sign_qop_alg      UNSIGNED INTEGER,\n      o  sign_qop_algID    AlgorithmIdentifier,\
    \ --overrides sign_qop_alg\n      o  enc_qop_alg       UNSIGNED INTEGER,\n   \
    \   o  enc_qop_algID     AlgorithmIdentifier, --overrides enc_qop_alg\n      o\
    \  idu_type_string    OCTET STRING,\n         -- type of the IDU (\"data\", \"\
    e-mail doc\", MIME type, etc.)\n      o  pidu_type_string   OCTET STRING,\n  \
    \    o  mech_indep_encap_req BOOLEAN -- (see Appendix A)\n   o  PIDU_Information\
    \ PARAMETER BUNDLE\n      o  protect_options    Protect_Options,\n      o  originator_name\
    \    INTERNAL NAME,\n      o  originator_role    Originator_Role, -- (see Section\
    \ 2.3.4.1)\n      o  protection_time    INTEGER,\n   o  Bad_Target_Name PARAMETER\
    \ BUNDLE,  -- same as in Section 2.3.3.2\n      o  bad_targ_name     INTERNAL\
    \ NAME,\n      o  bad_targ_status   INTEGER,\n         -- a status flag giving\
    \ the reason for rejection of the name\n         -- in bad_targ_name.  Specified\
    \ reasons include:\n         --  SYNTAX_INVALID        (0) the syntax of the name\
    \ is invalid;\n         --  NAME_UNRECOGNIZED     (1) the name is not recognized;\n\
    \         --  NAME_AMBIGUOUS        (2) the name cannot be resolved;\n       \
    \  --  ACCESS_DENIED         (3) access to this target is denied;\n         --\
    \  CERTIFICATE_NOT_FOUND (4) the encryption certificate of the\n             \
    \                         target could not be found.\n   o  Target_Info PARAMETER\
    \ BUNDLE,      -- same as in Section 2.3.3.2\n      o  targ_names        SET OF\
    \ INTERNAL NAME,\n      o  bad_targ_count    INTEGER,\n      o  bad_target_names\
    \  SET OF Bad_Target_Name,\n"
- title: 2.3.2.3. IDUP_SE major_status codes
  contents:
  - "2.3.2.3. IDUP_SE major_status codes\n   The following major_status return codes\
    \ are defined for the \"SE\"\n   calls in this section:\n   o  GSS_S_COMPLETE\n\
    \   o  IDUP_S_MORE_OUTBUFFER_NEEDED\n      -- returned (by any SE call) to indicate\
    \ that there is more output\n      -- data than can fit into the supplied buffers.\
    \  The application\n      -- should save the returned data and call again to retrieve\
    \ the\n      -- remaining output.\n   o  IDUP_S_MORE_PIDU_NEEDED\n      -- indicates\
    \ that more PIDU data is needed for the StartUnprotect\n      -- operation (e.g.,\
    \ so that PIDU_Information or initial_idu_buffer\n      -- may be returned).\n\
    \   o  IDUP_S_INCONSISTENT_PARAMS\n   o  GSS_S_CREDENTIALS_EXPIRED\n   o  IDUP_S_NO_ENV\n\
    \   o  GSS_S_BAD_QOP\n   o  GSS_S_FAILURE\n   If Target_Info is used as an input\
    \ parameter (e.g., if an encryption\n   operation is being performed), the following\
    \ major_status return code\n   is also defined:\n   o  IDUP_S_BAD_TARG_INFO\n\
    \   Note for this return code that if one or more of the targets in\n   targ_names\
    \ cannot be used as a valid recipient of the P-IDU, these\n   names will be returned\
    \ in bad_targ_names (with associated status\n   codes in bad_targ_status).  As\
    \ long as at least one of the targets\n   can be used, however, this does not\
    \ cause this call to fail (i.e.,\n   the failure code IDUP_S_BAD_TARG_INFO is\
    \ not returned); it is the\n   caller's choice to discontinue IDU protection if\
    \ the target set which\n   can be used is unsuitable for the caller's purposes.\n"
- title: 2.3.2.4. IDUP_SE_SingleBuffer_Protect call
  contents:
  - "2.3.2.4. IDUP_SE_SingleBuffer_Protect call\n   Inputs:\n   o  env_handle ENVIRONMENT\
    \ HANDLE,\n   o  Protect_Options PARAMETER BUNDLE,\n   o  Target_Info PARAMETER\
    \ BUNDLE,\n   o  idu_buffer OCTET STRING\n   o  additional_protection BOOLEAN\n\
    \      -- TRUE if idu_buffer is the output of a previous protection\n      --\
    \ operation (i.e., if this is the second (or higher) in a\n      -- series of\
    \ SE/EV protection calls)\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  pidu_buffer OCTET STRING,\n   o  sig_token OCTET STRING\n  \
    \    -- used if Protect_Options is clear_sign_only\n   Using the security environment\
    \ referenced by env_handle, encrypt\n   and/or sign the supplied IDU.  If \"clear\
    \ signing\" is performed, the\n   signature will be returned in sig_token and\
    \ pidu_buffer may be empty\n   (depends on underlying mechanism).\n"
- title: 2.3.2.5. IDUP_SE_SingleBuffer_Unprotect call
  contents:
  - "2.3.2.5. IDUP_SE_SingleBuffer_Unprotect call\n   Inputs:\n   o  env_handle ENVIRONMENT\
    \ HANDLE,\n   o  pidu_buffer OCTET STRING,\n      -- may contain an IDU if sig_token\
    \ is non-NULL (i.e., if\n      -- clear_sign_only protection was applied)\n  \
    \ o  sig_token OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  idu_buffer OCTET STRING,\n      -- may be empty if clear_sign_only\
    \ protection was applied (depends\n      -- on underlying mechanism)\n   o  PIDU_Information\
    \ PARAMETER BUNDLE\n   o  additional_unprotection BOOLEAN\n      -- TRUE if idu_buffer\
    \ should be input to another unprotection\n      -- operation (i.e., if this should\
    \ not be the last in a series\n      -- of SE/EV unprotection calls)\n   Using\
    \ the security environment referenced by env_handle, decrypt\n   and/or verify\
    \ the supplied PIDU and return the contained IDU along\n   with all available\
    \ PIDU_Information.\n"
- title: 2.3.2.6. IDUP_SE_MultiBuffer_StartProtect call
  contents:
  - "2.3.2.6. IDUP_SE_MultiBuffer_StartProtect call\n   Inputs:\n   o  env_handle\
    \ ENVIRONMENT HANDLE,\n   o  Protect_Options PARAMETER BUNDLE,\n   o  Target_Info\
    \ PARAMETER BUNDLE,\n   o  additional_protection BOOLEAN, -- (see Section 2.3.2.4)\n\
    \   o  idu_size INTEGER               -- (see Section 2.3.4.2)\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  initial_pidu_buffer\
    \ OCTET STRING\n      -- may be empty (depends on underlying mechanism)\n   Using\
    \ the security environment referenced by env_handle, initialize\n   the data structures\
    \ required to begin the process of signing and/or\n   encrypting the IDU (which\
    \ will be supplied in multiple buffers to the\n   Process_Buffer call).\n"
- title: 2.3.2.7. IDUP_SE_MultiBuffer_EndProtect call
  contents:
  - "2.3.2.7. IDUP_SE_MultiBuffer_EndProtect call\n   Inputs:\n   o  env_handle ENVIRONMENT\
    \ HANDLE\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  final_pidu_buffer OCTET STRING,\n   o  sig_token OCTET STRING\n      --\
    \ used if Protect_Options was clear_sign_only\n   Using the security environment\
    \ referenced by env_handle, complete the\n   protection processing on the data\
    \ and place the computed output in\n   final_pidu_buffer and/or sig_token. Successful\
    \ application of\n   IDUP_SE_MultiBuffer_EndProtect() does not guarantee that\
    \ unprotection\n   can necessarily be performed successfully when the P-IDU arrives\
    \ at\n   the target (for example, it may be damaged in transit).\n"
- title: 2.3.2.8. IDUP_SE_MultiBuffer_StartUnprotect call
  contents:
  - "2.3.2.8. IDUP_SE_MultiBuffer_StartUnprotect call\n   Inputs:\n   o  env_handle\
    \ ENVIRONMENT HANDLE,\n   o  initial_pidu_buffer OCTET STRING,\n   o  sign_qop_alg_in\
    \ UNSIGNED INTEGER,\n      -- used if Protect_Options was clear_sign_only (and\
    \ calling\n      -- application has prior knowledge of signing alg. applied);\n\
    \      -- if NULL, then sig_token must be supplied\n   o  sig_token OCTET STRING\n\
    \      -- used if Protect_Options was clear_sign_only;\n      -- if NULL, then\
    \ sign_qop_alg_in must be supplied\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  PIDU_Information PARAMETER BUNDLE,\n     \
    \ -- returns all available information\n   o  initial_idu_buffer OCTET STRING\n\
    \      -- may be empty\n   Using the security environment referenced by env_handle,\
    \ initialize\n   the data structures required to begin the process of decrypting\n\
    \   and/or verifying the PIDU (which will be supplied in multiple buffers\n  \
    \ to the Process_Buffer call).\n   The parameters sign_qop_alg_in and sig_token\
    \ should not both be\n   supplied (i.e., they should not both be non-NULL).  If\
    \ they are both\n   non-NULL, however, sig_token is taken to be authoritative\
    \ since this\n   is the token created at protection time and therefore is guaranteed\n\
    \   to carry the information needed to unprotect.\n"
- title: 2.3.2.9. IDUP_SE_MultiBuffer_EndUnprotect call
  contents:
  - "2.3.2.9. IDUP_SE_MultiBuffer_EndUnprotect call\n   Inputs:\n   o  env_handle\
    \ ENVIRONMENT HANDLE,\n   o  sig_token OCTET STRING  OPTIONAL\n      -- used if\
    \ Protect_Options was clear_sign_only and sig_token was\n      -- not available\
    \ when StartUnprotect was called\n   Outputs:\n   o  major_status INTEGER,\n \
    \  o  minor_status INTEGER,\n   o  PIDU_Information PARAMETER BUNDLE,\n      --\
    \ returns all available information\n   o  final_idu_buffer OCTET STRING   --\
    \ may be empty\n   o  additional_unprotection BOOLEAN -- (see Section 2.3.2.5)\n\
    \   Using the security environment referenced by env_handle, complete the\n  \
    \ decryption and/or verification processing on the data and place any\n   residual\
    \ output in final_idu_buffer.\n"
- title: 2.3.2.10. IDUP_SE_Process_Buffer call
  contents:
  - "2.3.2.10. IDUP_SE_Process_Buffer call\n   Inputs:\n   o  env_handle ENVIRONMENT\
    \ HANDLE,\n   o  input_buffer OCTET STRING,\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_buffer OCTET STRING\n      -- may be\
    \ zero length (depends on underlying mechanism and\n      -- corresponding Start()\
    \ call and Protect_Options value)\n   Using the security environment referenced\
    \ by env_handle, continue the\n   processing on the data in input_buffer and,\
    \ if it is available, put\n   any resulting output data in output_buffer.  The\
    \ application calls\n   this routine over and over again with new buffers of data\
    \ until it\n   has processed all the data buffers of the IDU/PIDU. It then calls\
    \ the\n   appropriate End() call to complete the processing.\n"
- title: 2.3.3.  The "EV" Calls
  contents:
  - '2.3.3.  The "EV" Calls

    '
- title: 2.3.3.1. IDUP_EV Purpose
  contents:
  - "2.3.3.1. IDUP_EV Purpose\n   The \"EV\" group of calls provides a simple, high-level\
    \ interface to\n   underlying IDUP mechanisms when application developers need\
    \ to deal\n   only with evidence but not with encryption or integrity services.\
    \ It\n   includes both the single-buffer and multiple-buffer IDU cases and can\n\
    \   be used for the generation and verification of evidence tokens\n   embodying\
    \ several different types of evidences.\n   The following list of evidence types\
    \ is supported. This list is by no\n   means exhaustive and it is anticipated\
    \ that it may be extended in\n   future versions of this specification.\n    \
    \  \"Non-repudiation of Origin\" prevents a message creator's false\n      denial\
    \ of creating and sending a message.\n      \"Non-repudiation of Creation\" prevents\
    \ a message creator's false\n      denial of creating a message.\n      \"Non-repudiation\
    \ of Sender\" prevents a message creator's false\n      denial of sending a message\
    \ (that was not necessarily created by\n      the sender).\n      \"Non-repudiation\
    \ of Delivery\" prevents a message recipient's false\n      denial of having received\
    \ and looked at the content of a message.\n      \"Non-repudiation of Receipt\"\
    \ prevents a message recipient's false\n      denial of having received a message\
    \ (whose content was not\n      necessarily looked at by the recipient).\n   \
    \   \"Non-repudiation of Approval\" prevents a message recipient's false\n   \
    \   denial of having approved the content of a received message.\n   An evidence\
    \ is provided in the form of a evidence token. Two forms of\n   evidence tokens\
    \ are supported:\n      o  Tokens including the associated data,\n      o  Tokens\
    \ without included data (but with a unique reference to\n         the associated\
    \ data).\n   Evidence tokens may be freely distributed. Any possessor of an\n\
    \   evidence token (and of the associated data, if not included in the\n   token)\
    \ can verify the evidence if it has the appropriate credentials\n   which include\
    \ the definition of security policies (i.e., keys alone\n   do not permit the\
    \ verification of evidence tokens). Any holder of an\n   evidence token may store\
    \ it (along with the associated data, if not\n   included in the token) for later\
    \ verification.\n   Calls that are specific to the support of evidence include:\n\
    \   * Generate_token, which generates a non-repudiation token using the\n    \
    \ current environment. The generated token may consist of:\n      1 - an evidence\
    \ token\n      2 - a token containing a request for an evidence, which carries\n\
    \          information describing which evidence type should be generated\n  \
    \        by the recipient(s) and sent back to some entities (that may\n      \
    \    or may not include the sender).\n      3 - a token containing an evidence\
    \ token which is an answer to an\n          evidence that has been previously\
    \ requested.\n      4 - a token including both an evidence and a request for another\n\
    \          evidence to be provided.\n   * Verify_evidence, which verifies the\
    \ evidence token using the\n     current environment. This operation returns a\
    \ major_status code\n     which can be used to determine whether the evidence\
    \ contained in a\n     token is complete (i.e., can be successfully verified (perhaps\n\
    \     years) later). If a token's evidence is not complete, the token can\n  \
    \   be passed to form_complete_pidu to complete it.\n   Additional useful calls\
    \ for evidence services include:\n   * IDUP_Get_token_details (see Section 2.5.3);\n\
    \   * IDUP_Form_Complete_PIDU (see Section 2.4.2).\n"
- title: 2.3.3.2. IDUP_EV Parameters
  contents:
  - "2.3.3.2. IDUP_EV Parameters\n   The following parameter bundles are used in the\
    \ \"EV\" protection and\n   unprotection sets of calls.\n   o  Nr_Options PARAMETER\
    \ BUNDLE\n      o  evidence_type  INTEGER {\n                   no_evidence  \
    \       (0)\n                   -- used when request-only token desired\n    \
    \               proof_of_receipt    (1),\n                   proof_of_delivery\
    \   (2),\n                   proof_of_approval   (3),\n                   proof_of_creation\
    \   (4),\n                   proof_of_sender     (5),\n                   proof_of_origin\
    \     (6)\n         } OPTIONAL,\n      o  evidence_type_oid  OBJECT IDENTIFIER\
    \ OPTIONAL,\n         -- may be used in place of above parameter if OID is known\n\
    \      o  evidence_validity_duration     INTEGER,\n         -- duration_in_minutes\n\
    \         -- DURATION_HOUR  = 60;\n         -- DURATION_DAY   = 1440;\n      \
    \   -- DURATION_WEEK  = 10080;\n         -- DURATION_MONTH = 43200;// 30 days\n\
    \         -- DURATION_YEAR  = 525600;//365 days\n      o  mech_indep_encap_req\
    \ BOOLEAN -- (see Appendix A)\n   o  Originator_Information PARAMETER BUNDLE\n\
    \      o  token_generator_name INTERNAL NAME,\n         -- obtained from the credentials\
    \ of the originator\n         -- (e.g., from its public key certificate)\n   \
    \   o  token_generator_role Originator_Role OPTIONAL,\n         -- (see Section\
    \ 2.3.4.1)\n      o  protection_time      INTEGER OPTIONAL\n   o  Bad_Target_Name\
    \  PARAMETER BUNDLE  -- (see Section 2.3.2.2)\n      o  bad_targ_name        \
    \  INTERNAL NAME,\n      o  bad_targ_status        INTEGER\n         -- a status\
    \ flag giving the reason for rejection of the\n         -- name in bad_targ_name\n\
    \   o  Target_Info PARAMETER BUNDLE       -- same as in Section 2.3.2.2\n    \
    \  o  targ_names           SET OF INTERNAL NAME,\n      o  bad_targ_count    \
    \   INTEGER,\n      o  bad_target_names     SET OF Bad_Target_Name\n   o  Request_Features\
    \ PARAMETER BUNDLE\n      o  requested_evidence_type  INTEGER {\n            \
    \     no_evidence         (0), - used when no token desired\n                \
    \ proof_of_receipt    (1),\n                 proof_of_delivery   (2),\n      \
    \           proof_of_approval   (3), },\n      o  nr_req_policy              \
    \          OBJECT IDENTIFIER,\n      o  evidence_from                        Target_Info,\n\
    \      o  evidence_to                          Target_Info,\n      o  include_received_token_in_evidence\
    \   BOOLEAN\n   The following data_type is used in the \"EV\" protection calls.\n\
    \   o  Nr_Operation  INTEGER {\n            evidence_and_or_evidence_request \
    \ (1),\n            returned_evidence                 (2) }\n"
- title: 2.3.3.3. IDUP_EV major_status codes
  contents:
  - "2.3.3.3. IDUP_EV major_status codes\n   The following major_status return codes\
    \ are defined for the \"EV\"\n   calls in this section:\n   o  GSS_S_COMPLETE\n\
    \      -- indicates that the evidence is complete\n   o  IDUP_S_INCOMPLETE\n \
    \  o  IDUP_S_MORE_OUTBUFFER_NEEDED\n      -- returned (by any EV call) to indicate\
    \ that there is more output\n      -- data than can fit into the supplied buffers.\
    \  The application\n      -- should save the returned data and call again to retrieve\
    \ the\n      -- remaining output.\n   o  IDUP_S_INCONSISTENT_PARAMS\n   o  GSS_S_CREDENTIALS_EXPIRED\n\
    \   o  IDUP_S_NO_MATCH\n   o  IDUP_S_NO_ENV\n   o  GSS_S_FAILURE\n   If Target_Info\
    \ is used as an input parameter (i.e., if an evidence is\n   being requested ),\
    \ the following major_status return code is also\n   defined:\n   o  IDUP_S_BAD_TARG_INFO\n\
    \   Note for this return code that if one or more of the targets in\n   targ_names\
    \ cannot be used as a valid recipient of the P-IDU, these\n   names will be returned\
    \ in bad_targ_names (with associated status\n   codes in bad_targ_status).  As\
    \ long as at least one of the targets\n   can be used, however, this does not\
    \ cause this call to fail (i.e.,\n   the failure code IDUP_S_BAD_TARG_INFO is\
    \ not returned); it is the\n   caller's choice to discontinue IDU protection if\
    \ the target set which\n   can be used is unsuitable for the caller's purposes.\n"
- title: 2.3.3.4. IDUP_EV_SingleBuffer_Generate call
  contents:
  - "2.3.3.4. IDUP_EV_SingleBuffer_Generate call\n   Inputs:\n   o  env_handle   \
    \              ENVIRONMENT HANDLE,\n   o  nr_operation               Nr_Operation,\n\
    \   o  Nr_Options                 PARAMETER BUNDLE,\n   o  idu_buffer        \
    \         OCTET STRING,\n   o  form_complete_pidu         BOOLEAN,\n      -- if\
    \ TRUE the implementation will attempt to form a complete PIDU\n   o  include_data_in_token\
    \      BOOLEAN,\n      -- if TRUE, data provided in idu_buffer will be included\
    \ in the\n      -- generated token; if FALSE, the data will not be included\n\
    \   o  Request_Features           PARAMETER BUNDLE\n      -- the type of the evidence\
    \ that is requested;\n      -- policy under which the returned evidence should\
    \ be generated;\n      -- the recipients that are supposed to send back an evidence;\n\
    \      -- the recipients that should receive the requested evidence;\n      --\
    \ an indicator include_received_token_in_evidence:\n      --   if TRUE, the evidence\
    \ token incorporating the request will be\n      --   included in the data for\
    \ which recipients will generate\n      --   evidence; if FALSE, evidence will\
    \ be generated using only\n      --   the data (and not the token incorporating\
    \ the request).\n   o  additional_protection BOOLEAN -- (see Section 2.3.2.4)\n\
    \   Outputs:\n   o  major_status               INTEGER,\n   o  minor_status  \
    \             INTEGER,\n   o  token                      OCTET STRING,\n   o \
    \ evidence_check             OCTET STRING,\n      -- present only if an evidence\
    \ is requested.  Consists of data to\n      -- be used to verify the requested\
    \ token(s) (if any) when they are\n      -- received.\n   Description:\n   This\
    \ operation generates a non-repudiation token associated with the\n   data passed\
    \ in an input buffer. Two kinds of operations can be\n   performed (using the\
    \ Nr_Operation parameter):\n   a) generating a token that includes either an evidence\
    \ only, or\n      an evidence request only, or both an evidence and an evidence\n\
    \      request;\n   b) generating a response token for some recipients that includes\
    \ an\n      evidence generated as a response to a request (in this case the\n\
    \      idu_buffer is used to enter the request token that was received).\n   It\
    \ is possible to request the generation of complete evidence. This\n   may succeed\
    \ or fail; if it fails, a subsequent call to\n   Form_Complete_PIDU can be made.\n"
- title: 2.3.3.5. IDUP_EV_SingleBuffer_Verify call
  contents:
  - "2.3.3.5. IDUP_EV_SingleBuffer_Verify call\n   Inputs:\n   o  env_handle     \
    \                ENVIRONMENT HANDLE,\n   o  token                          OCTET\
    \ STRING,\n   o  external_idu_buffer            OCTET STRING,\n      -- if not\
    \ present within the token\n   o  evidence_check                 OCTET STRING,\n\
    \      -- present only if the input token is a response to a previous\n      --\
    \ request for evidence (this parameter is used to validate that\n      -- evidence).\n\
    \   Outputs:\n   o  major_status                   INTEGER,\n   o  minor_status\
    \                   INTEGER,\n   o  Nr_Options                     PARAMETER BUNDLE,\n\
    \   o  Originator_Information         PARAMETER BUNDLE,\n   o  Request_Features\
    \               PARAMETER BUNDLE,\n   o  trusted_time_stamping_time     INTEGER\
    \ OPTIONAL,\n      -- present for informational purposes only\n   o  complete_evidence_before\
    \       INTEGER OPTIONAL,\n      -- if the major status code that is returned\
    \ is\n      -- IDUP_S_INCOMPLETE, IDUP_Form_Complete_PIDU should be called\n \
    \     -- with the same token before this time.\n      --    This may be required,\
    \ for example, in order to insure that\n      --    the time skew between the\
    \ evidence generation time and\n      --    the trusted time service's countersignature\
    \ on the evidence\n      --    falls within the interval allowed by the current\
    \ NR policy.\n   o  complete_evidence_after        INTEGER OPTIONAL,\n      --\
    \ if the major status code that is returned is\n      -- IDUP_S_INCOMPLETE, IDUP_Form_Complete_PIDU\
    \ should be called\n      -- with the same token after this time.\n      --  \
    \  This may be required, for example, to insure that all\n      --    authorities\
    \ involved in generating the evidence have passed\n      --    the last time at\
    \ which the current NR policy allows them to\n      --    repudiate their keys.\n\
    \   o  encapsulated_idu_buffer         OCTET STRING\n      -- if the IDU was present\
    \ within the token\n   o  additional_unprotection BOOLEAN -- (see Section 2.3.2.5)\n\
    \   Description:\n   Verifies the validity and discloses the content of a nr_token.\n\
    \   If the token containing the evidence to be verified was provided to\n   the\
    \ calling application by a partner responding to the calling\n   application's\
    \ request, then the calling application must pass the\n   evidence check it received\
    \ when it generated the request as a\n   parameter along with the token it received\
    \ from the partner.\n   Output indicators are provided which give guidance about\
    \ the time or\n   times at which form_complete_pidu should be called; see the\
    \ parameter\n   descriptions for explanations of these indicators and their use.\
    \ Note\n   that the time specified by complete_evidence_before may be earlier\n\
    \   than that specified by complete_evidence_after; in this case it will\n   be\
    \ necessary to call form_complete_pidu twice.\n   Because keys can be revoked\
    \ or declared compromised, the return from\n   verify_evidence cannot in all cases\
    \ be a definitive \"valid\" or\n   \"invalid\"; sometimes \"conditionally valid\"\
    \ may be returned, depending\n   upon the policy in use. IDUP_S_INCOMPLETE will\
    \ be returned, for\n   example, if:\n    - the interval during which the generator\
    \ of the evidence may\n      permissibly declare his key invalid has not yet expired\
    \ (and\n      therefore it is possible that the evidence may be declared invalid\n\
    \      in the future), or\n    - trusted time is required for verification, and\
    \ the time obtained\n      from the token is not trusted.\n"
- title: 2.3.3.6. IDUP_EV_MultiBuffer_StartGenerate call
  contents:
  - "2.3.3.6. IDUP_EV_MultiBuffer_StartGenerate call\n   Inputs:\n   o  env_handle\
    \                 ENVIRONMENT HANDLE,\n   o  nr_operation               Nr_Operation,\n\
    \   o  Nr_Options                 PARAMETER BUNDLE,\n   o  form_complete_pidu\
    \         BOOLEAN,\n   o  include_data_in_token      BOOLEAN,\n   o  idu_size\
    \                   INTEGER, -- (see Section 2.3.4.2)\n   o  Request_Features\
    \           PARAMETER BUNDLE\n   o  additional_protection BOOLEAN -- (see Section\
    \ 2.3.2.4)\n   Outputs:\n   o  major_status               INTEGER,\n   o  minor_status\
    \               INTEGER,\n   o  initial_pidu_buffer        OCTET STRING\n    \
    \  -- may be empty (depends on underlying mechanism)\n   Description:\n   Using\
    \ the security environment referenced by env_handle, initialize\n   the data structures\
    \ required to begin the generation of a token. The\n   IDU will be supplied in\
    \ multiple buffers to the\n   IDUP_EV_Process_Buffer call). Two kinds of operations\
    \ can be\n   performed (using the Nr_Operation parameter) :\n     a) generating\
    \ a token that includes either an evidence only, or\n        an evidence request\
    \ only, or both an evidence and an evidence\n        request.\n     b) generating\
    \ a return token for some recipients that includes an\n        evidence generated\
    \ as a response to a request. In that case the\n        received token will be\
    \ passed into the subsequent\n        IDUP_EV_Process_Buffer calls. The boolean\
    \ include_data_in_token\n        is ignored as the output will always be contained\
    \ in a single\n        token. The Request_Features are ignored in that case at\
    \ this\n        time in order to keep things simple and to avoid the piggy-\n\
    \        backing that is theoretically possible.\n   It is possible to request\
    \ the generation of complete evidence. This\n   may succeed or fail; if it fails,\
    \ a subsequent call to\n   Form_Complete_PIDU can be made.\n"
- title: 2.3.3.7. IDUP_EV_MultiBuffer_EndGenerate call
  contents:
  - "2.3.3.7. IDUP_EV_MultiBuffer_EndGenerate call\n   Inputs:\n   o  env_handle \
    \                ENVIRONMENT HANDLE\n   Outputs:\n   o  major_status         \
    \      INTEGER,\n   o  minor_status               INTEGER,\n   o  final_pidu \
    \                OCTET STRING,\n   o  token                      OCTET STRING,\n\
    \   o  evidence_check             OCTET STRING\n      -- present only if an evidence\
    \ is requested.\n   Description:\n   Using the security environment referenced\
    \ by env_handle, provide the\n   requested token or the final P-IDU. A token will\
    \ be generated if\n   encapsulation was not requested; otherwise, the final P-IDU\
    \ is\n   provided.\n"
- title: 2.3.3.8. IDUP_EV_MultiBuffer_StartVerify call
  contents:
  - "2.3.3.8. IDUP_EV_MultiBuffer_StartVerify call\n   Inputs:\n   o  env_handle \
    \                    ENVIRONMENT HANDLE,\n   o  token                        \
    \  OCTET STRING,\n   o  evidence_check                 OCTET STRING,\n      --\
    \ present only if an evidence has been previously requested.\n   Outputs:\n  \
    \ o  major_status INTEGER,\n   o  minor_status INTEGER\n   Description:\n   Using\
    \ the security environment referenced by env_handle, initialize\n   the data structures\
    \ required to begin the process of verifying the\n   token.  The P-IDU will be\
    \ supplied in multiple buffers to the\n   IDUP_EV_Process_Buffer call.\n"
- title: 2.3.3.9. IDUP_EV_MultiBuffer_EndVerify call
  contents:
  - "2.3.3.9. IDUP_EV_MultiBuffer_EndVerify call\n   Input:\n   o  env_handle    \
    \                 ENVIRONMENT HANDLE\n   Outputs:\n   o  major_status        \
    \           INTEGER,\n   o  minor_status                   INTEGER,\n   o  Nr_Options\
    \                     PARAMETER BUNDLE,\n   o  Originator_Information        \
    \ PARAMETER BUNDLE,\n   o  Request_Features               PARAMETER BUNDLE,\n\
    \   o  trusted_time_stamping_time     INTEGER OPTIONAL,\n   o  complete_evidence_before\
    \       INTEGER OPTIONAL,\n   o  complete_evidence_after        INTEGER OPTIONAL,\n\
    \   o  idu_buffer                     OCTET STRING\n      -- if the IDU was present\
    \ within the token\n   o  additional_unprotection BOOLEAN -- (see Section 2.3.2.5)\n\
    \   Description:\n   Using the security environment referenced by env_handle,\
    \ complete the\n   verification processing on the data and provide verified output\n\
    \   parameters to the caller when the major status code is either:\n   o GSS_S_COMPLETE\
    \ or\n   o IDUP_S_INCOMPLETE\n"
- title: 2.3.3.10. IDUP_EV_Process_Buffer call
  contents:
  - "2.3.3.10. IDUP_EV_Process_Buffer call\n   Inputs:\n   o  env_handle         ENVIRONMENT\
    \ HANDLE,\n   o  input_buffer       OCTET STRING\n   Outputs:\n   o  major_status\
    \       INTEGER,\n   o  minor_status       INTEGER,\n   o  output_buffer     \
    \ OCTET STRING\n      -- may be zero length (depends on underlying mechanism and\n\
    \      -- corresponding Generate () call and options\n      -- (e.g., data_included_in_token)\n\
    \   Description:\n   Using the security environment referenced by env_handle,\
    \ continue the\n   processing on the data in input_buffer and, if it is available,\
    \ put\n   any resulting output data in output_buffer. The application calls\n\
    \   this routine over and over again with new buffers of data until it\n   has\
    \ processed all the data buffers of the IDU/PIDU. It then calls the\n   appropriate\
    \ End() call to complete the processing.\n"
- title: 2.3.4. The "GP" Calls
  contents:
  - "2.3.4. The \"GP\" Calls\n   The \"GP\" group of calls provides a powerful interface\
    \ to flexible and\n   sophisticated combinations of protection and unprotection\
    \ services.\n   This power and flexibility, however, necessitates a more complex\n\
    \   interface than either the SE or the EV calls. Furthermore, such\n   combinations\
    \ of services are not needed in many of the security\n   mechanisms in common\
    \ use today (although this is likely to change as\n   time goes on).  The GP calls\
    \ are therefore specified to be OPTIONAL\n   and need not be supported by IDUP-conformant\
    \ implementations.  Note,\n   however, that the structure of IDUP tokens should\
    \ be such that the\n   SE/EV and GP calls may be used interchangably by the receiver.\n"
- title: 2.3.4.1. Parameter Bundles
  contents:
  - "2.3.4.1. Parameter Bundles\n   The concept of \"parameter bundles\" is used in\
    \ the calls presented in\n   the following subsections in order to simplify their\
    \ presentation and\n   clarify their intended purpose and use (note that specific\
    \ language\n   bindings may or may not use parameter bundles for its actual calling\n\
    \   conventions).  A parameter bundle is simply a set of closely-related\n   parameters\
    \ of a call which are either all used by / available to the\n   calling application\
    \ or all not used by / unavailable to the calling\n   application.  These parameters\
    \ may be all input parameters, all\n   output parameters, or any combination of\
    \ the two.\n   An example use envisioned for parameter bundles in a language such\
    \ as\n   C would be as a structure, where individual parameters in the bundle\n\
    \   are structure members.  The calling application wishing to use a\n   particular\
    \ bundle would then allocate the appropriate structure\n   variable, assign the\
    \ desired input values to the appropriate members,\n   and pass the address of\
    \ the structure as the bundle \"parameter\".  On\n   output, the values of the\
    \ appropriate output members may be read.  An\n   application not wishing to use\
    \ a particular bundle (or one which is\n   satisfied with default values for all\
    \ input parameters of the bundle\n   and which doesn't care about output values),\
    \ can pass NULL as the\n   bundle \"parameter\".  From the mechanism implementor's\
    \ perspective, if\n   a parameter bundle is not supported (for example, if it\
    \ represents a\n   security service which is not supported by the implementation),\
    \ then\n   any non-NULL value passed as the bundle parameter will generate an\n\
    \   error status return code.\n   [Note that the parameter bundles given below,\
    \ except where explicitly\n   referenced by the SE and EV calls, are specific\
    \ to the (optional) GP\n   calls.  Thus, these bundles need not be supported by\
    \ IDUP-conformant\n   implementations if the GP calls are not supported.]\n  \
    \ The following parameter bundles are used in the subsequent protection\n   and\
    \ unprotection sets of calls.  A parameter preceded by \"(I)\" is an\n   input\
    \ parameter; one preceded by \"(O)\" is an output parameter; one\n   preceded\
    \ by neither is an input if the bundle itself is an input and\n   is an output\
    \ if the bundle itself is an output; one preceded by \"(X)\"\n   is the opposite:\
    \  an output if the bundle itself is an input and an\n   input if the bundle itself\
    \ is an output.\n      o Mech_Specific_Info PARAMETER BUNDLE\n        -- actual\
    \ parameters included in this bundle are defined by (and\n        -- specific\
    \ to) the underlying mechanism\n      o Sensitivity PARAMETER BUNDLE,\n      \
    \  -- actual parameters included in this bundle are defined by (and\n        --\
    \ specific to) the underlying mechanism, but may include\n        -- codified\
    \ values for \"Unclassified\", \"Secret\", \"Top Secret\",\n        -- and so\
    \ on\n      o Service_Creation_Info PARAMETER BUNDLE\n        -- actual parameters\
    \ included in this bundle are defined by (and\n        -- specific to) the underlying\
    \ mechanism, but it is mandatory\n        -- that they include at least service_id\
    \ and Quality\n      o Service_Verification_Info PARAMETER BUNDLE\n        --\
    \ actual parameters included in this bundle are defined by (and\n        -- specific\
    \ to) the underlying mechanism, but it is mandatory\n        -- that they include\
    \ at least service_id and Quality\n      o  Quality PARAMETER BUNDLE\n       \
    \  o  qop_algs  UNSIGNED INTEGER,\n         o  qop_algID AlgorithmIdentifier,\
    \ --overrides qop_algs\n         o  validity  UNSIGNED INTEGER,\n            --\
    \ protection guaranteed to be valid until time specified\n         o  policy_id\
    \ OBJECT IDENTIFIER,\n            -- security policy under which protection is/was\
    \ carried out\n         o  allow_policy_mapping BOOLEAN,\n            -- determines\
    \ whether mapping between policy IDs is allowed\n         o  actual_policy_time\
    \ INTEGER\n            -- time at which the above policy rules came into effect\n\
    \      o  Idu_Information PARAMETER BUNDLE,\n         o  idu_type_oid OBJECT IDENTIFIER,\n\
    \         o  idu_type_string OCTET STRING,\n         o  idu_title OCTET STRING,\n\
    \         o  idu_sensitivity Sensitivity,\n         o  pidu_type_oid OBJECT IDENTIFIER,\n\
    \         o  pidu_type_string OCTET STRING,\n         o  pidu_title OCTET STRING,\n\
    \         o  pidu_sensitivity Sensitivity,\n      o  Prot_Information PARAMETER\
    \ BUNDLE,\n         o  originator_name INTERNAL NAME,\n         o  originator_role\
    \ Originator_Role,\n         o  idu_information Idu_Information,\n         o \
    \ protection_time INTEGER,\n      o  Originator_Role PARAMETER BUNDLE, -- role\
    \ in organization\n         o  domain_name                 INTERNAL NAME OPTIONAL,\n\
    \         o  role                        PRINTABLE STRING,\n         o  role_info_is_authenticated\
    \  BOOLEAN\n            -- TRUE if info. is authenticated (e.g., inside a cert.)\n\
    \      o  Special_Conditions PARAMETER BUNDLE,\n         o  prot_oper_id INTEGER,\n\
    \         o  form_complete_pidu BOOLEAN,\n            -- input to protection operations\
    \ for evidence generation\n         o  pidu_in_solic_service BOOLEAN,\n      \
    \      -- in protection operations, used as input for service\n            --\
    \ solicitation to request that receiver include the\n            -- received PIDU\
    \ when generating the response.  In unprot.\n            -- operations, used as\
    \ output to inform receiver that PIDU\n            -- should be included when\
    \ generating the response.\n         o  use_trusted_time BOOLEAN,\n         o\
    \  use_untrusted_time BOOLEAN,\n         o  mech_indep_encap_req BOOLEAN -- (see\
    \ Appendix A)\n      o  Bad_Target_Name PARAMETER BUNDLE,\n         o  (O) bad_targ_name\
    \ INTERNAL NAME,\n         o  (O) bad_targ_status INTEGER,\n                --\
    \ a status flag giving the reason for rejection of\n                -- the name\
    \ in bad_targ_name. Specified reasons include:\n                --    SYNTAX_INVALID\
    \        (0)\n                --       the syntax of the name is invalid;\n  \
    \              --    NAME_UNRECOGNIZED     (1)\n                --       the name\
    \ is not recognized;\n                --    NAME_AMBIGUOUS        (2)\n      \
    \          --       the name cannot be resolved;\n                --    ACCESS_DENIED\
    \         (3)\n                --       access to this target is denied;\n   \
    \             --    CERTIFICATE_NOT_FOUND (4)\n                --       the encryption\
    \ certificate of the target could\n                --       not be found.\n  \
    \    o  Target_Info PARAMETER BUNDLE,\n         o      targ_names       SET OF\
    \ INTERNAL NAME,\n         o  (O) bad_targ_count   INTEGER,\n         o  (O) bad_target_names\
    \ SET OF Bad_Target_Name,\n      o  General_Service_Data PARAMETER BUNDLE,\n \
    \        o      target_info Target_Info,\n         o  (X) unencapsulated_token\
    \ OCTET STRING,\n                -- zero length if encapsulation_request is TRUE\n\
    \         o  (O) minor_status INTEGER,\n   Three types of protection services\
    \ are defined in IDUP.  These are:\n      1. perform unsolicited service (i.e.,\
    \ act on a locally-generated\n         service request),\n      2. perform solicited\
    \ service (i.e., act on a remotely-generated\n         service request), and\n\
    \      3. perform service solicitation (i.e., send a service request to\n    \
    \     the remote end).\n   As an originator, applying data confidentiality with\
    \ data integrity,\n   or data origin authentication with data integrity, or proof\
    \ of origin\n   evidence is an example of service type 1.  As a target, creating\
    \ a\n   proof of delivery (i.e., receipt) evidence token as the result of a\n\
    \   request received from the originator is an example of service type 2.\n  \
    \ Finally, as an originator, submitting a request that one or more\n   targets\
    \ return a receipt for the data sent is an example of service\n   type 3.\n  \
    \ The first four parameters in the Prot_Service parameter bundle\n   pertain to\
    \ all service types; the fifth parameter is used if and only\n   if service type\
    \ 2 is desired; parameters 6-8 are used if and only if\n   service type 3 is desired.\n\
    \      o  Prot_Service PARAMETER BUNDLE\n         o  (I) prot_service_type INTEGER,\n\
    \         o  (I) service_id OBJECT IDENTIFIER,\n         o  (I) quality Quality,\
    \ -- NULL specifies default Quality\n         o  (I) general_service_data General_Service_Data,\n\
    \         o  (I) service_creation_info Service_Creation_Info,\n         o  (I)\
    \ service_to SET OF INTERNAL NAME,\n         o  (O) service_verification_info\
    \ Service_Verification_Info,\n         o  (O) service_verification_info_id INTEGER,\n\
    \   Also, three types of unprotection services are defined.  These are:\n    \
    \  1. receive unsolicited service (i.e., process unrequested\n         remotely-generated\
    \ service),\n      2. receive solicited service (i.e., process remotely-generated\n\
    \         response to locally-generated request), and\n      3. receive service\
    \ solicitation (i.e., process req. from rem. end)\n   As a target, unprotecting\
    \ an encrypted message, or verifying the\n   originator's proof of origin is an\
    \ example of service type 1.  As an\n   originator, verifying a proof of delivery\
    \ which you requested from a\n   target is an example of service type 2.  Finally,\
    \ as a target,\n   receiving a request from an originator for a proof of delivery\
    \ is an\n   example of service type 3.\n   The first four parameters in the Unprot_Service\
    \ parameter bundle\n   pertain to all service types; parameters 5-6 are used if\
    \ and only if\n   service type 2 is required; parameters 7-8 are used only if\
    \ service\n   type 3 is required.\n      o  Unprot_Service PARAMETER BUNDLE\n\
    \         o  (O) unprot_service_type INTEGER,\n         o  (O) service_id OBJECT\
    \ IDENTIFIER,\n         o  (O) quality Quality,\n                -- actual Quality\
    \ specified (never NULL)\n         o  (O) general_service_data General_Service_Data,\n\
    \         o  (O) service_verification_info_id INTEGER,\n         o  (I) service_verification_info\
    \ Service_Verification_Info,\n         o  (O) service_to SET OF INTERNAL NAME,\n\
    \         o  (O) service_creation_info Service_Creation_Info,\n"
- title: 2.3.4.2. IDUP_Start_Protect call
  contents:
  - "2.3.4.2. IDUP_Start_Protect call\n   Inputs:\n   o  env_handle ENVIRONMENT HANDLE,\n\
    \   o  Mech_Specific_Info PARAMETER BUNDLE,\n      -- NULL selects the mechanism-defined\
    \ default values\n   o  Idu_Information PARAMETER BUNDLE,\n   o  Special_Conditions\
    \ PARAMETER BUNDLE,\n   o  encapsulation_request BOOLEAN,\n   o  single_idu_buffer\
    \ OCTET STRING,\n      -- non-zero length for this buffer means that Protect/End_Protect\n\
    \      -- won't be called (i.e., entire IDU is contained in this buffer)\n   o\
    \  idu_size INTEGER,\n      -- size (in bytes) of the IDU to be protected;\n \
    \     -- may be \"-1\" signifying \"UNKNOWN\" (note that some mechanisms\n   \
    \   -- may not support encapsulation in such a case)\n   o  Target_Info PARAMETER\
    \ BUNDLE,\n   o  Services_to_Perform SET OF Prot_Service,\n   Outputs:\n   o \
    \ major_status INTEGER,\n   o  minor_status INTEGER,\n   o  midu_buffer OCTET\
    \ STRING,\n      -- zero length if encapsulation_request is TRUE;\n      -- may\
    \ be zero length otherwise (depends on underlying mechanism)\n   o  pidu_buffer\
    \ OCTET STRING,\n      -- zero length if encapsulation_request is FALSE;\n   \
    \   -- may be zero length otherwise (depends on underlying mechanism)\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE\n      -- the protection process can\
    \ begin (or has completed, if\n      -- single_idu_buffer has non-zero length).\n\
    \   o  IDUP_S_MORE_OUTBUFFER_NEEDED\n   o  GSS_S_CREDENTIALS_EXPIRED\n   o  IDUP_S_NO_ENV\n\
    \   o  IDUP_S_ENCAPSULATION_UNAVAIL\n   o  IDUP_S_SERVICE_UNAVAIL\n   o  IDUP_S_REQ_TIME_SERVICE_UNAVAIL\n\
    \   o  IDUP_S_UNKNOWN_OPER_ID\n   o  GSS_S_BAD_QOP\n   o  IDUP_S_BAD_TARG_INFO\n\
    \   o  GSS_S_FAILURE\n   Using the security environment referenced by env_handle,\
    \ initialize\n   the data structures required to begin the process of protecting\
    \ the\n   IDU buffers.  The caller requests specific protection services by\n\
    \   supplying the appropriate Prot_Service parameter bundles in\n   Services_to_Perform.\
    \  Each service is able to return a minor status\n   code to the calling application,\
    \ if necessary.\n   The calling application, knowing the size of the IDU it wishes\
    \ to\n   protect and the buffer size which it has available to it, can choose\n\
    \   to input the entire IDU in a single buffer and omit the subsequent\n   IDUP_Protect()\
    \ and IDUP_End_Protect() calls.  Furthermore, the\n   application can request\
    \ that the resulting M-IDU be encapsulated in\n   the token -- so that the token\
    \ contains the entire P-IDU -- rather\n   than having it be returned separately\
    \ in midu_buffer.  Encapsulation,\n   however, may not be supported by all underlying\
    \ mechanisms or\n   implementations; if this is the case, the\n   IDUP_S_ENCAPSULATION_UNAVAIL\
    \ major status code will be returned and\n   M-IDU will be returned in midu_buffer.\n\
    \   For those mechanisms which allow or require multiple stages of\n   processing,\
    \ each producing a different aspect of protection for the\n   IDU, the operation\
    \ identifier prot_oper_id is used to specify which\n   stage is currently being\
    \ requested by the application.  An example\n   where this would be useful is\
    \ a mechanism which implements the signed\n   Message Security Protocol [MSP].\
    \  As another example, a mechanism may\n   choose to do a digital signature in\
    \ two stages:  one for the hashing\n   of the message and another for the signature\
    \ on the hash.  The\n   calling application would therefore use the protection\
    \ set of calls\n   on the IDU in stage 1 and then use the protection set of calls\
    \ on the\n   token (from stage 1) in stage 2.\n   Note that prot_oper_id is simply\
    \ an integer (1, 2, 3, ..., n, where\n   \"n\" is the number of stages as defined\
    \ by the mechanism (typically 1\n   or 2)).  The calling application uses this\
    \ parameter to indicate to\n   the underlying mechanism whether it wishes to do\
    \ stage 1 of\n   protection / unprotection processing, or stage 2, and so on.\
    \ Portable\n   applications may pass \"0\" to let the mechanism choose the stage\
    \ (note\n   that mechanism implementers may still iterate when prot_oper_id =\
    \ 0\n   (e.g., use output as next input, et cetera).\n   If one or more of the\
    \ targets in targ_names cannot be used as a valid\n   recipient of the P-IDU,\
    \ these names will be returned in\n   bad_targ_names (with associated status codes\
    \ in bad_targ_status).  As\n   long as at least one of the targets can be used,\
    \ this does not cause\n   this call to fail; it is the caller's choice to discontinue\
    \ IDU\n   protection if the target set which can be used is unsuitable for the\n\
    \   caller's purposes.  Note that each Prot_Service parameter bundle can\n   also\
    \ input a list of targ_names; this is used if a separate list is\n   to be used\
    \ for that service only (the general list of targets is to\n   be used for all\
    \ services unless overridden in this way).\n"
- title: 2.3.4.3. IDUP_Protect call
  contents:
  - "2.3.4.3. IDUP_Protect call\n   Inputs:\n   o  env_handle ENVIRONMENT HANDLE,\n\
    \   o  input_buffer OCTET STRING,\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_buffer OCTET STRING\n      -- may be\
    \ zero length if encapsulation_request was set to TRUE in\n      -- IDUP_Start_Protect()\
    \ (depends on underlying mechanism)\n   Return major_status codes:\n   o  GSS_S_COMPLETE\n\
    \   o  IDUP_S_NO_ENV\n   o  GSS_S_FAILURE\n   Using the security environment referenced\
    \ by env_handle, continue the\n   protection processing on the data in input_buffer\
    \ and, if the\n   underlying mechanism defines this, put any resulting P-IDU/M-IDU\
    \ data\n   in output_buffer.  The application calls this routine over and over\n\
    \   again with new buffers of data until it has protected all the data\n   buffers\
    \ of the IDU.  It then calls IDUP_End_Protect() to complete the\n   protection\
    \ processing.\n"
- title: 2.3.4.4. IDUP_End_Protect call
  contents:
  - "2.3.4.4. IDUP_End_Protect call\n   Inputs:\n   o  env_handle ENVIRONMENT HANDLE,\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ Services_to_Perform SET OF Prot_Service,\n   o  final_midu_buffer OCTET STRING,\n\
    \      -- zero length if encapsulation_request was set to TRUE in\n      -- IDUP_Start_Protect(),\
    \ in which case pidu is used\n   o  final_pidu_buffer OCTET STRING,\n      --\
    \ zero length if encapsulation_request was set to FALSE in\n      -- IDUP_Start_Protect(),\
    \ in which case token and midu are used\n   Return major_status codes:\n   o \
    \ GSS_S_COMPLETE\n      -- protection has successfully completed and the resulting\
    \ P-IDU\n      -- is ready for transfer.  If defined by the underlying mechanism,\n\
    \      -- final_midu_buffer will contain any residual M-IDU data.\n   o  IDUP_S_MORE_OUTBUFFER_NEEDED\n\
    \   o  IDUP_S_NO_ENV\n   o  GSS_S_FAILURE\n   Using the security environment referenced\
    \ by env_handle, complete the\n   protection processing on the data and place\
    \ the computed output in\n   final_pidu_buffer (or final_midu_buffer and the unencapsulated_token\n\
    \   parameter for each Prot_Service).  If a service was requested from\n   one\
    \ or more targets in Start_Protect() - and if this is supported by\n   the underlying\
    \ mechanism - Service_Verification_Info will hold\n   whatever data is necessary\
    \ for the mechanism to verify a service\n   returned by a target (unprotector)\
    \ of the P-IDU.  Successful\n   application of IDUP_End_Protect() does not guarantee\
    \ that the\n   corresponding unprotection set of calls can necessarily be performed\n\
    \   successfully when the P-IDU arrives at the target (for example, it\n   may\
    \ be damaged in transit).\n"
- title: 2.3.4.5. IDUP_Start_Unprotect call
  contents:
  - "2.3.4.5. IDUP_Start_Unprotect call\n   Inputs:\n   o  env_handle ENVIRONMENT\
    \ HANDLE,\n   o  Mech_Specific_Info PARAMETER BUNDLE,\n      -- NULL selects the\
    \ mechanism-defined default values\n   o  single_pidu_buffer OCTET STRING,\n \
    \     -- non-zero length for this buffer means that IDUP_Unprotect() and\n   \
    \   -- IDUP_End_Unprotect() will not be called (i.e., the entire P-IDU\n     \
    \ -- (if encapsulation is used) or M-IDU (if encap. is not used)\n      -- is\
    \ contained in this buffer)\n   o  partial_pidu_buffer OCTET STRING,\n      --\
    \ may be an arbitrary-sized piece of the full pidu (if the\n      -- application's\
    \ buffer isn't large enough to hold entire pidu).\n      -- Used if pidu_buffer\
    \ will be input a buffer at a time (except\n      -- that the final buffer must\
    \ be passed in final_pidu_buffer\n      -- rather than partial_pidu_buffer). \
    \ Only one of\n      -- single_pidu_buffer and partial(final)_pidu_buffer can\
    \ have\n      -- nonzero length.\n   o  final_pidu_buffer OCTET STRING,\n   o\
    \  Special_Conditions PARAMETER BUNDLE,\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  Services_to_Receive SET OF Unprot_Service,\n\
    \   o  Prot_Information PARAMETER BUNDLE,\n   o  single_idu_buffer OCTET STRING,\n\
    \      -- if this buffer has non-zero length, then service processing has\n  \
    \    -- been completed on the data in single_pidu_buffer\n   o  initial_idu_buffer\
    \ OCTET STRING,\n      -- holds any data from partial(final)_pidu_buffer which\
    \ has been\n      -- unprotected; remaining data will be returned by Unprotect\
    \ and\n      -- End_Unprotect as they are called with successive buffers of\n\
    \      -- pidu\n   o  Service_Verification_Info PARAMETER BUNDLE,\n      -- used\
    \ only if target is on \"service_to\" list in Unprot_Service\n   o  service_verification_info_id\
    \ INTEGER,\n      -- used only if target is on \"service_to\" list in Unprot_Service\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE\n      -- unprotection processing\
    \ can begin (or has completed, if\n      -- single_idu_buffer has non-zero length).\n\
    \   o  IDUP_S_INCOMPLETE\n      -- used only if single_idu_buffer has non-zero\
    \ length.\n   o  IDUP_S_MORE_OUTBUFFER_NEEDED\n   o  IDUP_S_MORE_PIDU_NEEDED\n\
    \   o  GSS_S_DEFECTIVE_TOKEN\n   o  IDUP_S_INAPPROPRIATE_CRED\n   o  IDUP_S_INCONSISTENT_PARAMS\n\
    \   o  IDUP_S_DEFECTIVE_VERIF\n   o  IDUP_S_NO_MATCH\n   o  IDUP_S_SERVICE_UNAVAIL\n\
    \   o  IDUP_S_REQ_TIME_SERVICE_UNAVAIL\n   o  IDUP_S_SERV_VERIF_INFO_NEEDED\n\
    \   o  GSS_S_CREDENTIALS_EXPIRED\n   o  IDUP_S_NO_ENV\n   o  IDUP_S_UNKNOWN_OPER_ID\n\
    \   o  GSS_S_BAD_QOP\n      -- the qop_algs value specified in P-IDU for at least\
    \ one of the\n      -- services is unavailable in the local mechanism, so processing\n\
    \      -- cannot continue.\n   o  GSS_S_BAD_MIC\n   o  IDUP_S_BAD_DOA_KEY\n  \
    \ o  IDUP_S_BAD_KE_KEY\n   o  IDUP_S_BAD_ENC_IDU\n   o  GSS_S_FAILURE\n   Using\
    \ the security environment referenced by env_handle, initialize\n   the data structures\
    \ required to begin the process of unprotecting a\n   P-IDU.  The caller will\
    \ be alerted as to which services were applied\n   to the P-IDU in the returned\
    \ Services_to_Receive set of parameters.\n   If encapsulation was not used by\
    \ the originator, it is the receiving\n   application's responsibility to separate\
    \ the received P-IDU into a\n   M-IDU and one or more unencapsulated_token buffers\
    \ (the latter being\n   input in separate Unprot_Service bundles in the Services_to_Receive\n\
    \   parameter).  These unencapsulated_token buffers should be input\n   before\
    \ the M-IDU (i.e., in IDUP_Start_Unprotect) or after the M-IDU\n   (i.e., in IDUP_End_Unprotect)\
    \ as appropriate; this order may be\n   dictated, for example, by their placement\
    \ in the in-coming message.\n   If unprotection will be applied more than once\
    \ to a given P-IDU, it\n   is the responsibility of the calling application to\
    \ remember if a\n   service solicitation has been responded to previously (i.e.,\
    \ if the\n   requested service has already been generated / sent for that P-IDU)\n\
    \   and thus ignore subsequent solicitations on unprotect.\n   The time flags\
    \ indicate whether to consult trusted, untrusted, or no\n   time (if both flags\
    \ are FALSE) during the unprotection operation.  If\n   the current time is not\
    \ to be checked, then unprotection may be\n   successful even if the protector's\
    \ key has expired since the P-IDU\n   was generated (that is, if the Validity\
    \ period -- as specified in the\n   Quality parameter bundle -- has expired).\n\
    \   If the underlying mechanism supports it and if this information is\n   contained\
    \ in the P-IDU, information regarding the originator (that\n   is, the entity\
    \ which used the protection set of calls to generate\n   this P-IDU) is returned\
    \ in the Prot_Information parameter bundle.\n"
- title: 2.3.4.6. IDUP_Unprotect call
  contents:
  - "2.3.4.6. IDUP_Unprotect call\n   Inputs:\n   o  env_handle ENVIRONMENT HANDLE,\n\
    \   o  input_buffer OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n \
    \  o  minor_status INTEGER,\n   o  output_buffer OCTET STRING\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE\n   o  IDUP_S_NO_ENV\n   o  GSS_S_FAILURE\n   Using\
    \ the security environment referenced by env_handle, continue the\n   unprotection\
    \ processing on the data in input_buffer, putting any\n   resulting IDU data in\
    \ output_buffer (if required).\n"
- title: 2.3.4.7. IDUP_End_Unprotect call
  contents:
  - "2.3.4.7. IDUP_End_Unprotect call\n   Inputs:\n   o  env_handle ENVIRONMENT HANDLE,\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ Prot_Information PARAMETER BUNDLE,\n   o  Services_to_Receive SET OF Unprot_Service,\n\
    \   o  final_idu_buffer OCTET STRING,\n   o  Service_Verification_Info PARAMETER\
    \ BUNDLE,\n      -- used only if target is on \"service_to\" list in Unprot_Service\n\
    \   o  service_verification_info_id INTEGER,\n      -- used only if target is\
    \ on \"service_to\" list in Unprot_Service\n   Return major_status codes:\n  \
    \ o  GSS_S_COMPLETE\n      -- residual IDU data will be returned in final_idu_buffer.\n\
    \   o  IDUP_S_INCOMPLETE\n   o  IDUP_S_MORE_OUTBUFFER_NEEDED\n   o  GSS_S_BAD_MIC\n\
    \   o  IDUP_S_BAD_DOA_KEY\n   o  IDUP_S_BAD_KE_KEY\n   o  IDUP_S_BAD_ENC_IDU\n\
    \   o  IDUP_S_NO_ENV\n   o  GSS_S_FAILURE\n   Using the security environment referenced\
    \ by env_handle, complete the\n   unprotection processing on the data and return\
    \ the appropriate status\n   code.  If there is any residual IDU data it will\
    \ be returned in\n   final_idu_buffer.\n   If the IDUP_S_INCOMPLETE major status\
    \ value is returned, all output\n   parameters are conditionally valid; the unprotection\
    \ set of functions\n   will have to be called again (perhaps with a complete P-IDU,\
    \ as\n   produced by IDUP_Form_Complete_PIDU) in order to get valid values for\n\
    \   all parameters.  \"Conditional validity\" may arise, for example, if\n   all\
    \ relevant certificates verify correctly, but it is not yet past\n   the time\
    \ up to which the current policy allows the authorities\n   involved to repudiate\
    \ their keys.\n   If the underlying mechanism supports it and if this information\
    \ is\n   contained in the token, information regarding the originator (that\n\
    \   is, the entity which used the protection set of calls to generate\n   this\
    \ token) is returned in the Prot_Information parameter bundle.\n   This information\
    \ may or may not be omitted if it was returned by the\n   IDUP_Start_Unprotect()\
    \ call.\n   Note that, unlike GSS-API, IDUP-GSS-API does not incorporate the\n\
    \   concept of error tokens transferred between sender and recipient\n   since\
    \ the protection and unprotection of an IDU may be separated by\n   an indefinite\
    \ amount of time and may or may not be performed by the\n   same entity.\n"
- title: 2.4. Special-Purpose Calls
  contents:
  - '2.4. Special-Purpose Calls

    '
- title: 2.4.1.  Relationship to GSS-API
  contents:
  - "2.4.1.  Relationship to GSS-API\n   The special-purpose call described in this\
    \ section has no analog in\n   GSS-API [RFC-2078].  This call is used to complete\
    \ a P-IDU (that is,\n   to generate a P-IDU which can be unprotected successfully\
    \ with no\n   additional data at any time during its validity period).  This call\n\
    \   may not be supported by all underlying IDUP mechanisms or\n   implementations.\n"
- title: 2.4.2. IDUP_Form_Complete_PIDU call
  contents:
  - "2.4.2. IDUP_Form_Complete_PIDU call\n   Inputs:\n   o  env_handle ENVIRONMENT\
    \ HANDLE,\n   o  single_pidu_buffer OCTET STRING,\n   o  partial_pidu_buffer OCTET\
    \ STRING,\n      -- an arbitrary-sized piece of the full pidu token.  Used if\
    \ pidu\n      -- will be input a buffer at a time (except that the final buffer\n\
    \      -- must be passed in final_pidu_buffer rather than\n      -- partial_pidu_buffer).\
    \  Only one of single_pidu_buffer and\n      -- partial(final)_pidu_buffer can\
    \ have nonzero length.\n   o  final_pidu_buffer OCTET STRING,\n   Outputs:\n \
    \  o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  pidu_token_out\
    \ OCTET STRING -- the augmented PIDU; may be complete\n   o  call_again_before\
    \ INTEGER,\n   o  call_again_after INTEGER,\n   o  trusted_time_stamping_time\
    \ INTEGER  -- for information only\n   Return major_status codes:\n   o  GSS_S_COMPLETE\n\
    \   o  IDUP_S_MORE_OUTBUFFER_NEEDED\n   o  IDUP_S_INCOMPLETE\n      -- generation\
    \ of the P-IDU is not yet complete.  The application\n      -- should call this\
    \ function again before the time given in\n      -- call_again_before (if not\
    \ NULL), or after the time given in\n      -- call_again_after (if not NULL),\
    \ or both (if neither are NULL).\n   o  IDUP_S_INCONSISTENT_PARAMS\n   o  IDUP_S_SERVICE_UNAVAIL\n\
    \   o  GSS_S_DEFECTIVE_TOKEN\n   o  GSS_S_FAILURE\n   Form_Complete_PIDU is used\
    \ primarily by the evidence services; in\n   particular, when the evidence token\
    \ itself does not contain all the\n   data required for its verification and it\
    \ is anticipated that some of\n   the data not stored in the token may become\
    \ unavailable during the\n   interval between generation of the evidence token\
    \ and verification\n   unless it is stored in the token. The Form_Complete_PIDU\
    \ operation\n   gathers the missing information and includes it in the token so\
    \ that\n   verification can be guaranteed to be possible at any future time.\n\
    \   This call generates a PIDU which can be unprotected successfully with\n  \
    \ no additional data at any time during its validity period.  [For\n   background\
    \ information on the notion of \"complete\" evidence, see\n   \"CORBA Security\
    \ Service v1.2 Draft D02\", 18 June 1997.]\n   Using the security environment\
    \ referenced by env_handle, complete the\n   generation of a P-IDU token and return\
    \ the appropriate status value\n   along with the completed token (if available).\
    \  Such a call may be\n   used, for example, for the purpose of batch evidence\
    \ generation on an\n   \"evidence server\".  A local machine may be able to use\
    \ the protection\n   set of calls to fill out most of an evidence token and then\
    \ send a\n   number of these to a batch processor which forms the complete\n \
    \  evidence tokens (perhaps by adding a certification path, or a\n   timestamp\
    \ and signature from a timestamping authority).  As another\n   example, on the\
    \ receiving end an application may make such a call in\n   order to collect all\
    \ the information necessary to unprotect a P-IDU\n   (such as all relevant certificates\
    \ and Certificate Revocation Lists);\n   this will ensure that the calls to the\
    \ unprotection set of operations\n   will be entirely local (i.e., can be performed\
    \ off-line) and fast.\n   Note that the complete P-IDU generated will be formed\
    \ using trusted\n   time if this is available in the environment referenced by\
    \ env_handle\n   and will use untrusted time or no time otherwise (depending on\
    \ what\n   is available).\n"
- title: 2.5.  Support calls
  contents:
  - '2.5.  Support calls

    '
- title: 2.5.1.  Relationship to GSS-API
  contents:
  - "2.5.1.  Relationship to GSS-API\n   Support calls in IDUP-GSS-API are to be understood\
    \ and used as\n   described in GSS-API [RFC-2078].  The calls described in Section\
    \ 2.4\n   of GSS-API (including all associated parameters) are unchanged.  The\n\
    \   following additional calls are specified for IDUP-GSS-API.\n"
- title: '2.5.2:  IDUP_Acquire_cred_with_auth call'
  contents:
  - "2.5.2:  IDUP_Acquire_cred_with_auth call\n   Inputs:\n   o  desired_name INTERNAL\
    \ NAME,\n      -- NULL requests locally-determined default\n   o  authenticator\
    \ OCTET STRING\n      -- string which authenticates the caller claiming to be\n\
    \      -- desired_name\n   o  lifetime_req INTEGER,\n      -- in seconds; 0 requests\
    \ default\n   o  desired_mechs SET OF OBJECT IDENTIFIER,\n      -- empty set requests\
    \ system-selected default\n   o  cred_usage BIT STRING\n      -- actual values\
    \ which can be used currently correspond to those\n      -- given in Section 2.1.1\
    \ (i.e.,\n      --    ENCRYPT_ONLY    8\n      --    DECRYPT_ONLY   16\n     \
    \ --    SIGN_ONLY      32\n      --    VERIFY_ONLY    64\n      -- with the values\
    \ logically OR'ed together in any desired\n      -- combination to restrict credential\
    \ usage; OR'ing all values\n      -- results in NO_RESTRICTION).\n      -- Future\
    \ possible values for this parameter are for further\n      -- study (note that\
    \ the type of this parameter is BIT STRING\n      -- (rather than INTEGER as in\
    \ GSS_Acquire_cred) to facilitate\n      -- such future expansion).\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  output_cred_handle\
    \  CREDENTIAL HANDLE,\n   o  actual_mechs SET OF OBJECT IDENTIFIER,\n   o  actual_cred_usage\
    \   BIT STRING,\n   o  lifetime_rec INTEGER\n      -- in seconds, or reserved\
    \ value for INDEFINITE\n   This call (which need not be supported by all underlying\
    \ mechanisms\n   or implementations) is identical to the GSS_Acquire_cred call,\
    \ with\n   the exception of the added input parameter \"authenticator\" and the\n\
    \   added output parameter \"actual_cred_usage\". The authenticator\n   (typically\
    \ a password, pass-phrase, or PIN) is used to authenticate\n   the caller claiming\
    \ to be desired_name to the underlying GSS (or\n   mechanism) code.  The actual_cred_usage\
    \ specifies the actual uses\n   available for these credentials; it is up to the\
    \ caller to determine\n   if this is sufficient for its purposes.\n   Implementations\
    \ that are able to authenticate the caller in some\n   other way are encouraged\
    \ to use the GSS_Acquire_cred call; those\n   having no other means available\
    \ to them, or wishing to explicitly\n   authenticate the caller at the time of\
    \ credential acquisition, should\n   use the IDUP_Acquire_cred_with_auth call\
    \ (if supported).\n   Note that the return major status codes for this call are\
    \ identical\n   to those given for the GSS_Acquire_cred call.  If the authentication\n\
    \   fails (e.g., the wrong authenticator is supplied for the given\n   desired_name),\
    \ the major status GSS_S_FAILURE is returned (along with\n   an appropriate minor\
    \ status code).\n"
- title: 2.5.3. IDUP_Get_token_details call
  contents:
  - "2.5.3. IDUP_Get_token_details call\n   Inputs:\n   o  token                 \
    \ OCTET STRING,\n   -- all the data to be returned shall be within the first 4\
    \ KB of\n   -- the token; hence, a single call is needed. It is not necessary\n\
    \   -- to provide the entire token when the token includes the IDU.\n   o  mech_type\
    \              SET OF OBJECT IDENTIFIER\n   -- input if known (typically SET will\
    \ contain a single member)\n   Outputs:\n   o  major_status                  \
    \     INTEGER,\n   o  minor_status                       INTEGER,\n   o  actual_mech_type\
    \                   OBJECT IDENTIFIER,\n   o  data_included_in_token         \
    \    BOOLEAN,\n      -- true if the data is encapsulated\n   o  idu_size     \
    \                      INTEGER,\n   o  has_SE_protection                  BOOLEAN,\n\
    \   o  has_EV_protection                  BOOLEAN,\n   o  PIDU_Information   \
    \                PARAMETER BUNDLE,\n   o  nr_policy                          OBJECT\
    \ IDENTIFIER,\n      -- this and subsequent parameters pertain only to evidence\
    \ tokens\n   o  Nr_Options                         PARAMETER BUNDLE,\n   o  Originator_Information\
    \             PARAMETER BUNDLE,\n   o  time_stamping_time                 INTEGER\
    \  OPTIONAL\n   o  Request_Features                   PARAMETER BUNDLE,\n    \
    \  -- describes the included request, if any.\n   o  requested_evidence_back \
    \           BOOLEAN,\n      -- true if this is an evidence generated in response\
    \ to a\n      -- previously-sent request\n   o  evidence_check               \
    \      OCTET STRING,\n      -- meaningful if the boolean above is true\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE\n      -- input_token could be parsed\
    \ for all relevant fields.\n   o  GSS_S_CREDENTIALS_EXPIRED\n   o  GSS_S_DEFECTIVE_TOKEN\n\
    \      -- the mechanism type could be parsed, but either the other fields\n  \
    \    -- could not be determined from the input_token, or their values\n      --\
    \ did not correspond to valid values for that mechanism.\n   o  GSS_S_FAILURE\n\
    \      -- the mechanism type was missing or corrupted.\n   IDUP_Get_token_details()\
    \ is used to return to an application the\n   attributes that correspond to a\
    \ given input token.  Since IDUP-GSS-\n   API tokens are meant to be opaque to\
    \ the calling application, this\n   function allows the application to determine\
    \ information about the\n   token without having to violate the opaqueness intention\
    \ of IDUP. Of\n   primary importance is the mechanism type, which the application\
    \ can\n   then use as input to the IDUP_Establish_Env() call in order to\n   establish\
    \ the correct environment in which to have the token\n   processed.\n   If all\
    \ tokens are framed as suggested in Section 3.1 of [RFC-2078]\n   (mandated in\
    \ the Kerberos V5 GSS mechanism [RFC 1964] and in the SPKM\n   GSS Mechanism [RFC\
    \ 2025]), then any mechanism implementation should\n   be able to return the mech_type\
    \ parameter for any uncorrupted input\n   token. If the mechanism implementation\
    \ whose IDUP_Get_token_details()\n   function is being called does recognize the\
    \ token, it can return any\n   further relevant information in the other token\
    \ attributes, as\n   specified.  In particular, this function can set has_SE_protection\
    \ if\n   the SE calls may be used to unprotect it, or has_EV_protection if the\n\
    \   EV calls may be used to unprotect it, or both if both kinds of\n   protection\
    \ have been applied (so that SE or EV calls may be used in\n   any order for unprotection)\
    \ [note that GP calls, when supported,\n   should be usable for unprotection of\
    \ any IDUP token].\n   IDUP_Get_token_details (which need not be supported by\
    \ all underlying\n   mechanisms or implementations) gives only a hint about the\
    \ content of\n   the token, there is no integrity check of any kind performed.\n\
    \   Regardless of the token type, it is possible to check that this\n   information\
    \ is correct only by doing a proper unprotection of the\n   token.  It is recommended\
    \ that IDUP callers supply a token buffer at\n   least 4 KB in length in order\
    \ to ensure that the desired data can\n   easily flow across this interface.\n\
    \   The OID of the mechanism and whether the token contains the\n   associated\
    \ data is returned. In addition the size of the associated\n   data, whether inside\
    \ or outside the token, is included if known.\n   [Note:  data size will typically\
    \ be unknown if the data was protected\n   using multibuffer calls.  A value of\
    \ \"-1\" may be used to indicate\n   \"UNKNOWN\".]\n   When the input token contains\
    \ only an evidence generated\n   spontaneously, the following is returned:\n \
    \   - the evidence type;\n    - the Non-Repudiation policy under which the evidence\
    \ was generated;\n    - the name of the generator of the evidence;\n    - the\
    \ date and time when the evidence was generated (if available);\n    - the date\
    \ and time when it was time stamped (if available).\n   When the input token contains\
    \ only an evidence generated in response\n   to  a request from another entity,\
    \ the following additional\n   information is returned:\n    - an indicator to\
    \ state that this evidence relates to a request;\n    - a string significant for\
    \ the requester that will allow him to\n      check whether the answer corresponds\
    \ to the requested evidence.\n   When the input token only contains a request,\
    \ the following is\n   returned:\n    - the name of the requestor of the evidence,\n\
    \    - the date and time when the request was made,\n    - the evidence type to\
    \ send back,\n    - the non-repudiation policy under which the evidence to send\
    \ back\n      should be generated,\n    - the names of the recipients which should\
    \ generate and distribute\n      the requested evidence,\n    - the names of the\
    \ recipients to whom the requested evidence should\n      be sent after it has\
    \ been generated.\n   When the input token contains both evidence and a request,\
    \ an\n   indicator is returned describing whether the new evidence should be\n\
    \   generated using only the data in the input token, or using both the\n   data\
    \ and the evidence in the input token.\n   When the input token contains only\
    \ CONF and DOA services, the\n   PIDU_Information bundle is returned.  Other relevant\
    \ parameters (such\n   as idu_size and time_stamping_time) may also be returned\
    \ if this data\n   is available.\n"
- title: 2.5.4. IDUP_Get_policy_info call
  contents:
  - "2.5.4. IDUP_Get_policy_info call\n   Inputs:\n   o  policy_id OBJECT IDENTIFIER\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ policy_version INTEGER,\n   o  policy_effective_time INTEGER,\n   o  policy_expiry_time\
    \ INTEGER,\n   o  supported_services SET OF Service_Descriptor,\n      -- services\
    \ supported by this particular policy_id (equal to the\n      -- intersection\
    \ of the services supported by the mechanisms\n      -- listed in supported_mechanisms)\n\
    \   o  supported_mechanisms SET OF Mechanism_Descriptor\n      -- mechanisms supported\
    \ by this particular policy_id\n   Return major_status codes:\n   o  GSS_S_COMPLETE\n\
    \      -- policy_id recognized; all relevant fields have been returned.\n   o\
    \  GSS_S_FAILURE\n      -- the policy_id was not recognized.\n   This call (which\
    \ need not be supported by all underlying mechanisms\n   or implementations) allows\
    \ the application to retrieve information\n   pertaining to a given policy_id.\
    \  Policies define the following:\n      -  rules for the protection of IDUs,\
    \ such as trusted third\n         parties which may be involved in P-IDU generation,\
    \ the roles in\n         which they may be involved, and the duration for which\
    \ the\n         generated P-IDU is valid;\n      -  rules for the unprotection\
    \ of P-IDUs, such as the interval\n         during which a trusted third party\
    \ may legitimately declare its\n         key to have been compromised or revoked;\
    \ and\n      -  rules for adjudication, such as which authorities may be used\n\
    \         to adjudicate disputes.\n   The policy itself may be used by an adjudicator\
    \ when resolving a\n   dispute.  For example, the adjudicator might refer to the\
    \ policy to\n   determine whether the rules for generation of the P-IDU have been\n\
    \   followed.\n   The following parameter bundles are associated with this call.\n\
    \      o  Service_Descriptor PARAMETER BUNDLE,\n         o  service_type OBJECT\
    \ IDENTIFIER,\n         o  service_validity_duration INTEGER,\n         o  must_use_trusted_time\
    \ BOOLEAN\n      o  Mechanism_Descriptor PARAMETER BUNDLE,\n         o  mechanism_type\
    \ OBJECT IDENTIFIER,\n         o  Authority_List PARAMETER BUNDLE,\n         o\
    \  maximum_time_skew INTEGER\n            -- maximum permissible difference between\
    \ P-IDU generation\n            -- time and the time of countersignature from\
    \ a time\n            -- service (if required).  This parameter is unused if\n\
    \            -- trusted time is not required.\n      o  Authority_List PARAMETER\
    \ BUNDLE,\n         o  authority_name INTERNAL NAME,\n         o  authority_role\
    \ OCTET STRING,\n         o  last_revocation_check_offset INTEGER\n          \
    \  -- may be 0, greater than 0, or less than 0.  The value of\n            --\
    \ this parameter is added to P-IDU generation time to\n            -- get latest\
    \ time at which the mechanism will check to\n            -- see if this authority's\
    \ key has been revoked.\n   An example of the use of the last parameter in Authority_List\
    \ is as\n   follows.  If an authority has a defined last_revocation_check_offset\n\
    \   of negative one hour, then all revocations taking effect earlier than\n  \
    \ one hour before the generation of a P-IDU will render that P-IDU\n   invalid;\
    \ no revocation taking place later than one hour before the\n   generation of\
    \ the P-IDU will affect the P-IDU's validity.\n   Note that both the maximum_time_skew\
    \ and the\n   last_revocation_check_offset values are given in minutes.\n"
- title: 2.5.5. IDUP_Cancel_multibuffer_op call
  contents:
  - "2.5.5. IDUP_Cancel_multibuffer_op call\n   Inputs:\n   o  env_handle ENVIRONMENT\
    \ HANDLE,\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE\n      -- operation cancelled;\
    \ state purged.\n   o  GSS_S_FAILURE\n      -- unable to cancel operation; state\
    \ retained.\n   This call (which need not be supported by all underlying mechanisms\n\
    \   or implementations) allows the application to cancel a multibuffer\n   operation\
    \ prior to normal completion (e.g., subsequent to calling\n   Start_operation\
    \ and zero or more Process_operation, but prior to\n   calling End_operation).\
    \  When successful, this call purges any\n   internal state information which\
    \ would have been used to continue\n   processing for the full set of multibuffer\
    \ calls.\n"
- title: 3.  Related Activities
  contents:
  - "3.  Related Activities\n   In order to implement the IDUP-GSS-API atop existing,\
    \ emerging, and\n   future security mechanisms, the following is necessary:\n\
    \    - object identifiers must be assigned to candidate IDUP-GSS-API\n      mechanisms\
    \ and the name types which they support; and\n    - concrete data element (i.e.,\
    \ token and parameter bundle) formats\n      must be defined for candidate mechanisms.\n\
    \   Calling applications must implement formatting conventions which will\n  \
    \ enable them to distinguish IDUP-GSS-API P-IDUs from other IDUs in\n   their\
    \ environment.\n   Concrete language bindings are required for the programming\n\
    \   environments in which the IDUP-GSS-API is to be employed.\n"
- title: 4.  Acknowledgments
  contents:
  - "4.  Acknowledgments\n   Many thanks are due to Tim Moses and Dhanya Thakkar of\
    \ Entrust\n   Technologies, Denis Pinkas of Bull, and David Kurn of Tandem\n \
    \  Computers for a number of helpful comments and contributions.\n"
- title: 5. Security Considerations
  contents:
  - "5. Security Considerations\n   Security issues are discussed throughout this\
    \ memo.\n"
- title: 6. REFERENCES
  contents:
  - "6. REFERENCES\n   [MSP]       U.S. National Security Agency, \"Message Security\n\
    \               Protocol\", Secure Data Network System SDN.701, March\n      \
    \         1994.\n   [RFC-1421]  Linn, J., \"Privacy Enhancement for Internet Electronic\n\
    \               Mail:  Part I: Message Encryption and Authentication\n       \
    \        Procedures\", RFC 1421, February 1993.\n   [RFC-2078]  Linn, J., \"Generic\
    \ Security Service Application Program\n               Interface, Version 2\"\
    , RFC 2078, January 1997..\n   [RFC 1964]  Linn, J, \"The Kerberos Version 5 GSS-API\
    \ Mechanism\", RFC\n               1964, June 1996.\n   [RFC 2025]  Adams, C.,\
    \ \"The Simple Public-Key GSS-API Mechanism\n               (SPKM)\", RFC 2025,\
    \ October 1996.\n   [ISO/IEC]   2nd ISO/IEC CD 13888-1, \"Information technology\
    \ -\n               Security techniques - Non-repudiation - Part 1:  General\n\
    \               Model\", ISO/IEC JTC 1/SC 27, May 30, 1995\n"
- title: 7. Author's Address
  contents:
  - "7. Author's Address\n   Carlisle Adams\n   Entrust Technologies\n   750 Heron\
    \ Road, Suite E08,\n   Ottawa, Ontario, CANADA  K1V 1A7\n   Phone:  +1 613.247.3180\n\
    \   EMail: cadams@entrust.com\n"
- title: 'APPENDIX  A:  MECHANISM-INDEPENDENT TOKEN FORMAT'
  contents:
  - "APPENDIX  A:  MECHANISM-INDEPENDENT TOKEN FORMAT\n   This appendix specifies\
    \ the use, for IDUP-GSS-API tokens, of the\n   mechanism-independent level of\
    \ encapsulating representation for\n   tokens given in Section 3.1 of GSS-API\
    \ [RFC-2078].  The\n   representation given there incorporates an identifier of\
    \ the\n   mechanism type to be used when processing the associated tokens. Use\n\
    \   of that octet format is recommended to the designers of IDUP-GSS-API\n   implementations\
    \ based on various mechanisms so that tokens can be\n   interpreted unambiguously\
    \ at IDUP-GSS-API peers. It is recognized,\n   however, that for interoperability\
    \ purposes with peers not using IDUP\n   for specific IDU protection/unprotection\
    \ protocols, the encapsulating\n   representation may need to be omitted.  (In\
    \ such a case it is\n   necessary that the underlying mechanism provides some\
    \ sort of\n   internal or external identification that allows it to recognize\
    \ its\n   own tokens.)  When the mechanism-independent level of encapsulating\n\
    \   representation is not desired, callers SHOULD set\n   mech_indep_encap_req\
    \ to FALSE (note that some underlying mechanisms\n   may default this parameter\
    \ to FALSE).\n   For purely descriptive purposes, the following simple ASN.1 structure\n\
    \   is used to illustrate the structural relationships among token and\n   tag\
    \ objects.  For interoperability purposes, token and tag encoding\n   shall be\
    \ performed using the concrete encoding procedures described\n   in Section 3.1\
    \ of GSS-API [RFC-2078].\n          -- top-level token definition to frame different\
    \ mechanisms\n          IDUP-GSS-API DEFINITIONS ::=\n          BEGIN\n      \
    \    MechType ::= OBJECT IDENTIFIER\n          Token ::= [APPLICATION 0] IMPLICIT\
    \ SEQUENCE {\n                  thisMech MechType,\n                  token ANY\
    \ DEFINED BY thisMech\n                     -- contents mechanism-specific\n \
    \                 }\n          END\n"
- title: 'APPENDIX  B:  EXAMPLES OF IDUP USE'
  contents:
  - "APPENDIX  B:  EXAMPLES OF IDUP USE\n   This appendix provides examples of the\
    \ use of IDUP to do IDU\n   protection and unprotection.  It should not be regarded\
    \ as\n   constrictive to implementations or as defining the only means through\n\
    \   which IDUP-GSS-API functions can be realized with particular\n   underlying\
    \ technology, and does not demonstrate all IDUP-GSS-API\n   features.\n   Most\
    \ of the examples below only illustrate the use of CONF/DOA\n   protection services.\
    \  Note that when both CONF/DOA and Evidence\n   services are required, calling\
    \ applications may use a series of SE\n   and EV calls, or may use the GP calls\
    \ (when these are supported).\n   Using the former approach implies multiple calls\
    \ (e.g., the SE calls\n   are used to protect some data and the resulting token\
    \ is then input\n   to the EV calls to add evidence information), but some callers\
    \ may\n   find this to be more attractive than coding to the GP calls because\n\
    \   of the simpler SE/EV interface.  Depending upon the underlying\n   mechanism,\
    \ the series of SE/EV calls may result in a single token\n   that can be unprotected\
    \ using the SE and EV calls in any order (for\n   example, because it is a single\
    \ ASN.1 SEQUENCE that incorporates all\n   the specified protection services at\
    \ one level), or the series may\n   result in a token that can only be unprotected\
    \ in the reverse order\n   of protection (for example, because each SE/EV output\
    \ token was\n   effectively embedded in the token of the subsequent call). The\n\
    \   IDUP_Get_token_details call can assist callers in determining how to\n   unprotect\
    \ any received token.\n"
- title: B.1.  Simple Mechanism, Single Buffer
  contents:
  - "B.1.  Simple Mechanism, Single Buffer\n   To illustrate the simplest possible\
    \ case, consider an underlying IDUP\n   mechanism which does straightforward encryption/decryption\
    \ and\n   signing/verification only using public-key techniques; none of the\n\
    \   other possible services, such as creation of proof-of-origin\n   evidence,\
    \ requests for proof-of-delivery evidence, or use of trusted\n   time, are supported.\
    \  PEM[RFC-1421] is one example of a mechanism\n   which fits this description.\
    \  Furthermore (again for simplicity),\n   assume that encapsulation is chosen\
    \ by the calling application during\n   IDU protection.\n   Such a mechanism would\
    \ likely use the \"SE\" set of IDUP-GSS-API calls.\n   The following parameter\
    \ bundle uses and defaults would therefore be\n   specified in the relevant IDUP\
    \ mechanism document.\n   SENDER:\n   Set\n      env_handle                = environment\
    \ handle in use;\n      idu_buffer                = data buffer;\n      Target_Info.targ_names\
    \    = receiver names;\n      Protect_Options           = as necessary;\n   Call\n\
    \      IDUP_SE_SingleBuffer_Protect() with above input parameters\n   Check\n\
    \      major_status.  If not GSS_S_COMPLETE, check\n         minor_status,\n \
    \        Target_Info.Bad_Targ_Name,\n      (as required) for more detailed information.\n\
    \   Send\n      Output parameter pidu_buffer to receiver.\n   RECEIVER (any parameters\
    \ not listed below are given the value NULL):\n   Set\n      env_handle      \
    \   = environment handle in use;\n      pidu_buffer        = received data buffer;\n\
    \   Call\n      IDUP_SE_SingleBuffer_Unprotect() with above input parameters\n\
    \   Check\n      major_status.  If not GSS_S_COMPLETE, check\n         minor_status,\n\
    \      (as required) for more detailed information\n   Utilize\n      PIDU_Information.Protect_Options.Protect_Operation,\n\
    \         (to determine which services were applied by the originator)\n     \
    \ PIDU_Information.Protect_Options.sign_qop_alg / enc_qop_alg,\n         (to determine\
    \ the corresponding qualities of the services)\n      Prot_Information.originator_name,\n\
    \         (to determine the name of the originator)\n      Prot_Information.protection_time,\n\
    \         (to determine when the IDU was protected)\n      idu_buffer\n      \
    \   (to retrieve the unprotected data).\n"
- title: B.2.  Simple Mechanism, Single Buffer (Again)
  contents:
  - "B.2.  Simple Mechanism, Single Buffer (Again)\n   To illustrate a slight variation\
    \ on the simplest possible case,\n   assume that everything is as in the previous\
    \ scenario except that the\n   \"GP\" calls are used.\n   The following parameter\
    \ bundle uses and defaults would therefore be\n   specified in the relevant IDUP\
    \ mechanism document.\n   Mech_Specific_Info\n      - NOT USED (the only acceptable\
    \ input, therefore, is NULL)\n   Idu_Sensitivity\n      - NOT USED (the only acceptable\
    \ input, therefore, is NULL)\n   Service_Creation_Info\n      - NOT USED (the\
    \ only acceptable input, therefore, is NULL)\n   Service_Verification_Info\n \
    \     - NOT USED (the only acceptable input, therefore, is NULL)\n   Quality\n\
    \      - the qop_algs parameter must be supported, with a suitable\n        DEFAULT\
    \ value specified;\n      - suitable DEFAULT values for validity, policy_id, and\n\
    \        allow_policy_mapping must be specified (it may be an\n        implementation\
    \ option as to whether these parameters are\n        explicitly modifiable by\
    \ the calling application, or whether\n        NULLs are the only acceptable input)\n\
    \    Idu_Information\n      - the idu_type parameter must have a value representing\
    \ a suitable\n        IDU type (for example, in PEM a value representing the string\n\
    \        \"RFC822\" or some other valid \"Content-Domain\" would be used),\n \
    \       with a suitable DEFAULT value specified;\n      - the idu_title parameter\
    \ is NOT USED (the only acceptable input,\n        therefore, is NULL)\n   Prot_Information\n\
    \      - the originator_name and idu_type (in Idu_Information) parameters\n  \
    \      are read from the encapsulating information and output by\n        IDUP_Start_Unprotect;\n\
    \      - all other parameters are NOT USED (and therefore NULL)\n   Special_Conditions\n\
    \      - NOT USED (the only acceptable input, therefore, is NULL)\n   Target_Info\n\
    \      - this bundle is used as described in IDUP; no DEFAULT values are\n   \
    \     specified\n   General_Service_Data\n      - the unencapsulated_token parameter\
    \ is used if\n        encapsulation_request is FALSE;\n      - the minor_status\
    \ parameter is used to return minor status values\n        as specified by the\
    \ mechanism document\n   Prot_Service\n      - the prot_service_type parameter\
    \ may have a value of \"1\"\n        (\"perform unsolicited service\") or NULL\
    \ (which specifies the\n        DEFAULT value of \"1\");\n      - the service_id\
    \ parameter must have a value representing\n        \"PER_CONF\" or \"PER_DOA\"\
    ;\n      - the parameters Service_Creation_Info, service_to,\n        Service_Verification_Info,\
    \ and service_verification_info_id are\n        NOT USED (and therefore NULL)\n\
    \   Unprot_Service\n      - the unprot_service_type parameter will always have\
    \ a value of\n        \"1\" (\"receive unsolicited service\");\n      - the service_id\
    \ parameter will have a value representing\n        \"REC_CONF\" or \"REC_DOA\"\
    ;\n      - the parameters service_verification_info_id,\n        Service_Verification_Info,\
    \ service_to, and\n        Service_Creation_Info, are NOT USED (and therefore\
    \ NULL)\n   Assuming that the calling application has only a single buffer of\n\
    \   data to protect/unprotect, the following sequence of operations must\n   be\
    \ performed by the sender and receivers (subsequent to environment\n   establishment).\n\
    \   SENDER (any parameters not listed below are given the value NULL):\n   Set\n\
    \      env_handle                           = environment handle in use;\n   \
    \   encapsulation_request                = TRUE;\n      single_idu_buffer    \
    \                = data buffer;\n      Target_Info.targ_names               =\
    \ receiver names;\n      P_Services.Prot_Service_1.service_id = PER_CONF;\n  \
    \    P_Services.Prot_Service_2.service_id = PER_DOA;\n   Call\n      IDUP_Start_Protect()\
    \ with above input parameters\n   Check\n      major_status.  If not GSS_S_COMPLETE,\
    \ check\n         minor_status,\n         Target_Info.bad_targ_names / Target_Info.bad_targ_status,\n\
    \         P_Services.Prot_Service_1.General_Service_Data.minor_status,\n     \
    \    P_Services.Prot_Service_2.General_Service_Data.minor_status\n      (as required)\
    \ for more detailed information.\n   Send\n      Output parameter pidu_buffer\
    \ to receiver.\n   RECEIVER (any parameters not listed below are given the value\
    \ NULL):\n   Set\n      env_handle         = environment handle in use;\n    \
    \  single_pidu_buffer = received data buffer;\n   Call\n      IDUP_Start_Unprotect()\
    \ with above input parameters\n   Check\n      major_status.  If not GSS_S_COMPLETE,\
    \ check\n         minor_status,\n         R_Services.Unprot_Service_1.General_Service_Data.minor_status,\n\
    \         R_Services.Unprot_Service_2.General_Service_Data.minor_status\n    \
    \  (as required) for more detailed information\n   Utilize\n      R_Services.Unprot_Service_1/2.service_id,\n\
    \         (to determine which services were applied by the originator)\n     \
    \ R_Services.Unprot_Service_1/2.Quality,\n         (to determine the corresponding\
    \ qualities of the services)\n      Prot_Information.originator_name,\n      \
    \   (to determine the name of the originator)\n      single_idu_buffer\n     \
    \    (to retrieve the unprotected data).\n"
- title: B.3.  Simple Mechanism, Multiple Buffers
  contents:
  - "B.3.  Simple Mechanism, Multiple Buffers\n   To illustrate the next step up in\
    \ complexity, consider the use of the\n   simple IDUP mechanism described in B.2\
    \ above with multiple data\n   buffers.  In particular, consider the case in which\
    \ a large data file\n   is to be signed.  For this example, assume that the calling\n\
    \   application does not wish to use encapsulation.\n   Note that the parameter\
    \ bundle uses and defaults are as specified in\n   B.2. above.\n   SENDER (any\
    \ parameters not listed below are given the value NULL):\n   Set\n      env_handle\
    \                           = environment handle in use;\n      encapsulation_request\
    \                = FALSE;\n      P_Services.Prot_Service.service_id   = PER_DOA;\n\
    \   Call\n      IDUP_Start_Protect() with above input parameters\n   Check\n \
    \     major_status.  If not GSS_S_COMPLETE, check\n         minor_status,\n  \
    \       P_Services.Prot_Service.General_Service_Data.minor_status\n      (as required)\
    \ for more detailed information.\n   For each buffer of input data:\n      Set\n\
    \         input_buffer = buffer\n      Call\n         IDUP_Protect() with above\
    \ input parameter\n      Check\n         major_status.  If not GSS_S_COMPLETE,\
    \ check\n            minor_status\n   Call\n      IDUP_End_Protect()\n   Check\n\
    \      major_status.  If not GSS_S_COMPLETE, check\n         minor_status,\n \
    \        P_Services.Prot_Service.General_Service_Data.minor_status\n      (as\
    \ required) for more detailed information.\n   Send\n      P_Services.Prot_Service.General_Service_Data.unencapsulated_token,\n\
    \      and the file for which the signature was calculated (if required),\n  \
    \    to receiver.\n   RECEIVER (any parameters not listed below are given the\
    \ value NULL):\n   Set\n      env_handle            = environment handle in use;\n\
    \      R_Services.Unprot_Service_1.General_Service_Data.\n      unencapsulated_token\
    \  = received unencapsulated token;\n   Call\n      IDUP_Start_Unprotect() with\
    \ above input parameters\n   Check\n      major_status.  If not GSS_S_COMPLETE,\
    \ check\n         minor_status,\n         R_Services.Unprot_Service_1.General_Service_Data.minor_status,\n\
    \      (as required) for more detailed information\n   For each buffer of input\
    \ data:\n      Set\n         input_buffer = buffer\n      Call\n         IDUP_Unprotect()\
    \ with above input parameter\n      Check\n         major_status.  If not GSS_S_COMPLETE,\
    \ check\n            minor_status\n   Call\n      IDUP_End_Unprotect()\n   Check\n\
    \      major_status.  If not GSS_S_COMPLETE, check\n         minor_status,\n \
    \        R_Services.Unprot_Service_1.General_Service_Data.minor_status,\n    \
    \  (as required) for more detailed information.\n   Utilize\n      R_Services.Unprot_Service_1.service_id,\n\
    \         (to determine which service was applied by the originator; note\n  \
    \        that Unprot_Service_2 will have NULL in unprot_service_type\n       \
    \   to indicate that it is not used)\n      R_Services.Unprot_Service_1.Quality,\n\
    \         (to determine the corresponding quality of the service)\n      Prot_Information.originator_name,\
    \ (from IDUP_Start_Unprotect)\n         (to determine the name of the signer)\n\
    \      major_status (from IDUP_End_Unprotect)\n         (to determine pass/fail\
    \ status of signature verification).\n"
- title: B.4.  More Sophisticated Mechanism, Small Application Buffers
  contents:
  - "B.4.  More Sophisticated Mechanism, Small Application Buffers\n   To illustrate\
    \ a higher level of complexity, consider the use of a\n   more sophisticated IDUP\
    \ mechanism and a calling application with\n   small data buffers.  In particular,\
    \ consider the case in which a very\n   small e-mail message is to be encrypted\
    \ for a relatively large\n   receiver list (R), some subset of whom (r) will be\
    \ asked to send\n   proofs of receipt of the message to some other subset (L)\
    \ (which\n   includes the originator).  So that the example is not unnecessarily\n\
    \   complicated, assume again that the originating application uses\n   encapsulation.\n\
    \   The uses and defaults for the various parameter bundles for this\n   mechanism\
    \ would be specified in the relevant IDUP mechanism document\n   as follows.\n\
    \   Mech_Specific_Info\n      - NOT USED (the only acceptable input, therefore,\
    \ is NULL)\n   Idu_Sensitivity\n      - NOT USED (the only acceptable input, therefore,\
    \ is NULL)\n   Service_Creation_Info\n      - used to create \"proof of delivery\"\
    \ evidence (but actual\n        structure is opaque to calling application)\n\
    \   Service_Verification_Info\n      - used to verify \"proof of delivery\" evidence\
    \ (but actual\n        structure is opaque to calling application)\n   Quality\n\
    \      - the qop_algs parameter must be supported, with a suitable\n        DEFAULT\
    \ value specified;\n      - suitable DEFAULT values for validity, policy_id, and\n\
    \        allow_policy_mapping must be specified (it may be an\n        implementation\
    \ option as to whether these parameters are\n        explicitly modifiable by\
    \ the calling application, or whether\n        NULLs are the only acceptable input)\n\
    \   Idu_Information\n      - the idu_type parameter must have a value representing\
    \ a suitable\n        IDU type, with a suitable DEFAULT value specified;\n   \
    \   - the idu_title parameter must have a value representing a\n        suitable\
    \ IDU title, with a suitable DEFAULT value specified\n   Prot_Information\n  \
    \    - the originator_name, protection_time, and idu_type / idu_title\n      \
    \  (in Idu_Information) parameters are read from the contained\n        header\
    \ information and output by IDUP_Start_Unprotect;\n   Special_Conditions\n   \
    \   - the parameter prot_oper_id is NOT USED (the only acceptable\n        input,\
    \ therefore, is NULL);\n      - trusted or untrusted time may be selected by the\
    \ calling\n        application, with a suitable DEFAULT value specified\n   Target_Info\n\
    \      - this bundle is used as described in IDUP; no DEFAULT values are\n   \
    \     specified\n   General_Service_Data\n      - the unencapsulated_token parameter\
    \ is used if\n        encapsulation_request is FALSE;\n      - the minor_status\
    \ parameter is used to return minor status values\n        as specified by the\
    \ mechanism document\n   Prot_Service\n      - the prot_service_type parameter\
    \ may have a value of \"1\"\n        (\"perform unsolicited service\"), \"2\"\
    \ (\"perform solicited\n        service\"), \"3\" (perform service solicitation),\
    \ or NULL (which\n        specifies the DEFAULT value of \"1\");\n      - the\
    \ service_id parameter must have a value representing\n        \"PER_CONF\", \"\
    PER_DOA\", \"PER_POO\", or \"PER_POD\";\n      - the parameters Service_Creation_Info,\
    \ service_to,\n        Service_Verification_Info, and service_verification_info_id\
    \ are\n        used when required by the IDUP operation\n   Unprot_Service\n \
    \     - the unprot_service_type parameter may have a value of \"1\"\n        (\"\
    receive unsolicited service\"), \"2\" (\"receive solicited\n        service\"\
    ), or \"3\" (receive service solicitation);\n      - the service_id parameter\
    \ will have a value representing\n        \"REC_CONF\", \"REC_DOA\", \"REC_POO\"\
    , or \"REC_POD\";\n      - the parameters service_verification_info_id,\n    \
    \    Service_Verification_Info, service_to, and\n        Service_Creation_Info,\
    \ are used when required by the IDUP\n        operation\n   SENDER (any parameters\
    \ not listed below are given the value NULL):\n   Set\n      env_handle      \
    \                    = environment handle in use;\n      Idu_Information.idu_type\
    \            = value for \"e-mail document\";\n      Idu_Information.idu_title\
    \           = \"Contract 1234\";\n      Special_Conditions.use_trusted_time =\
    \ TRUE;\n      encapsulation_request               = TRUE;\n      single_idu_buffer\
    \                   = very small e-mail message;\n      Target_Info.targ_names\
    \              = receiver names (R);\n      Prot_Service_1.prot_service_type \
    \   = \"1\";\n      Prot_Service_1.service_id           = PER_CONF;\n      Prot_Service_2.prot_service_type\
    \    = \"3\";\n      Prot_Service_2.service_id           = PER_POD;\n      Prot_Service_2.General_Service_Data.Target_Info.targ_names\n\
    \                                          = \"receipts from\" list (r);\n   \
    \   Prot_Service_2.service_to           = \"receipts to\" list (L);\n      P_Services.Prot_Service_1\
    \           = Prot_Service_1;\n      P_Services.Prot_Service_2           = Prot_Service_2;\n\
    \   Call\n      IDUP_Start_Protect() with above input parameters\n   Check\n \
    \     major_status.  If not GSS_S_COMPLETE,\n         while major_status == IDUP_S_MORE_OUTBUFFER_NEEDED\n\
    \            Save\n               pidu_buffer,\n            Call\n           \
    \    IDUP_Start_Protect() (to get next portion of pidu_buffer)\n         Check\n\
    \            major_status,\n            minor_status,\n            Target_Info.bad_targ_names\
    \ / Target_Info.bad_targ_status,\n            P_Services.Prot_Service_1.General_Service_Data.minor_status,\n\
    \            P_Services.Prot_Service_2.General_Service_Data.minor_status\n   \
    \      (as required) for more detailed information.\n   Save\n      Prot_Service_2.Service_Verification_Info,\n\
    \      Prot_Service_2.service_verification_info_id\n   Send\n      All saved buffers\
    \ of pidu_buffer to receiver list (R).\n   RECEIVER (ON RECEIVER LIST (R)):\n\
    \      (any parameters not listed below are given the value NULL)\n   Set\n  \
    \    env_handle          = environment handle in use;\n      partial_pidu_buffer\
    \ = initial buffer of received p-idu;\n   Call\n      IDUP_Start_Unprotect() with\
    \ above input parameters\n   While major_status == IDUP_S_MORE_PIDU_NEEDED,\n\
    \      Set\n         partial_pidu_buffer = next buffer of p-idu\n      Call\n\
    \         IDUP_Start_Unprotect()\n   Check\n      major_status,\n      minor_status,\n\
    \      R_Services.Unprot_Service_1.General_Service_Data.minor_status,\n      R_Services.Unprot_Service_2.General_Service_Data.minor_status,\n\
    \   (as required) for more detailed information\n   Save\n      initial_idu_buffer\
    \ (if non-empty)\n   Set\n      input_buffer = remaining p-idu buffer\n   Call\n\
    \      IDUP_Unprotect() with above input parameter\n   Check\n      major_status.\
    \  If not GSS_S_COMPLETE, check\n         minor_status\n   Save\n      output_buffer\n\
    \   Call\n      IDUP_End_Unprotect()\n   Check\n      major_status.  If not GSS_S_COMPLETE,\
    \ check\n         minor_status,\n         R_Services.Unprot_Service_1.General_Service_Data.minor_status,\n\
    \         R_Services.Unprot_Service_2.General_Service_Data.minor_status,\n   \
    \   (as required) for more detailed information.\n   Utilize\n      R_Services.Unprot_Service_1/2.service_id,\n\
    \         (to determine which services were applied by the originator)\n     \
    \ R_Services.Unprot_Service_1/2.Quality,\n         (to determine the corresponding\
    \ qualities of the service)\n      Prot_Information.originator_name/protection_time\
    \ and\n         Prot_Information.Idu_Information.idu_type/idu_title,\n       \
    \  (from IDUP_Start_Unprotect) (to determine originator info.)\n      R_Services.Unprot_Service_2.General_Service_Data.Target_Info.\n\
    \         targ.names, (to determine if rec. is in \"receipts from\" (r))\n   \
    \   Service_Verification_Info/service_verification_info_id\n         (to determine\
    \ if receiver is in \"receipts to\" list (L))\n   If receiver is in \"receipts\
    \ from\" list (r)\n      Save\n         R_Services.Unprot_Service_2.service_to,\n\
    \         R_Services.Unprot_Service_2.Service_Creation_Info\n   If receiver is\
    \ in \"receipts to\" list (L)\n      Save\n         Service_Verification_Info,\n\
    \         service_verification_info_id\n   RECEIVER (ON \"RECEIPTS FROM\" LIST\
    \ (r)):\n      (procedure to generate receipt)\n   Set\n      env_handle     \
    \                      = environment handle in use;\n      Target_Info.targ_names\
    \               = service_to\n      Prot_Service_1.prot_service_type     = \"\
    2\";\n      Prot_Service_1.service_id            = \"PER_POD\";\n      Prot_Service_1.Service_Creation_Info\
    \ = Service_Creation_Info;\n      P_Services.Prot_Service_1            = Prot_Service_1\n\
    \   Call\n      IDUP_Start_Protect() with above input parameters\n   Check\n \
    \     major_status.  If not GSS_S_COMPLETE, check\n         minor_status,\n  \
    \       P_Services.Prot_Service_1.General_Service_Data.minor_status\n      (as\
    \ required) for more detailed information.\n   Send\n      pidu_buffer to \"receipts\
    \ to\" list (L)\n   RECEIVER (ON \"RECEIPTS TO\" LIST (L)):\n      (procedure\
    \ to process received receipt)\n   Set\n      env_handle         = environment\
    \ handle in use;\n      single_pidu_buffer = received p-idu buffer (if it fits\
    \ in a single\n         buffer; otherwise use partial_pidu_buffer and make multiple\n\
    \         calls, as above)\n   Call\n      IDUP_Start_Unprotect() with above input\
    \ parameters\n   If major_status == IDUP_S_SERV_VERIF_INFO_NEEDED\n      Utilize\n\
    \         R_Services.Unprot_Service_1.service_verification_info.id\n         (to\
    \ assist in locating necessary Service_Verification_Info)\n      Set\n       \
    \  R_Services.Unprot_Service_1.Service_Verification_Info\n            = Service_Verification_Info\n\
    \      Call\n         IDUP_Start_Unprotect() with above input parameters\n   Check\n\
    \      major_status,\n      minor_status,\n      R_Services.Unprot_Service_1.General_Service_Data.minor_status\n\
    \   (as required) for more detailed information.\n   Utilize\n      R_Services.Unprot_Service_1.service_id,\n\
    \         (to determine that this is a \"proof of delivery\" evidence)\n     \
    \ R_Services.Unprot_Service_1.Quality,\n      Prot_Information.originator_name,\
    \ (for evidence generator info.)\n      major_status (to determine pass/fail status\
    \ of evi. verif.).\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
