- title: __initial_text__
  contents:
  - '                Traffic Flow Measurement:  Architecture

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  This memo does not specify an Internet standard of any\n   kind.\
    \  Discussion and suggestions for improvement are requested.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes an architecture for the measurement and\n\
    \   reporting of network traffic flows, discusses how this relates to an\n   overall\
    \ network traffic flow architecture, and describes how it can\n   be used within\
    \ the Internet.  It is intended to provide a starting\n   point for the Realtime\
    \ Traffic Flow Measurement Working Group.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n 1 Statement of Purpose and Scope                        \
    \             2\n 2 Traffic Flow Measurement Architecture                    \
    \          4\n   2.1 Meters and Traffic Flows . . . . . . . . . . . . . . . .\
    \ . .   4\n   2.2 Interaction Between METER and METER READER . . . . . . . . .\
    \   6\n   2.3 Interaction Between MANAGER and METER  . . . . . . . . . . .   6\n\
    \   2.4 Interaction Between MANAGER and METER READER . . . . . . . .   7\n   2.5\
    \ Multiple METERs or METER READERs . . . . . . . . . . . . . .   7\n   2.6 Interaction\
    \ Between MANAGERs (MANAGER - MANAGER) . . . . . .   8\n   2.7 METER READERs and\
    \ APPLICATIONs . . . . . . . . . . . . . . .   8\n 3 Traffic Flows and Reporting\
    \ Granularity                            9\n   3.1 Flows and their Attributes\
    \ . . . . . . . . . . . . . . . . .   9\n   3.2 Granularity of Flow Measurements\
    \ . . . . . . . . . . . . . .  11\n   3.3 Rolling Counters, Timestamps, Report-in-One-Bucket-Only\
    \  . .  13\n 4 Meters                                                        \
    \    15\n   4.1 Meter Structure  . . . . . . . . . . . . . . . . . . . . . . \
    \ 15\n   4.2 Flow Table . . . . . . . . . . . . . . . . . . . . . . . . .  17\n\
    \   4.3 Packet Handling, Packet Matching . . . . . . . . . . . . . .  17\n   4.4\
    \ Rules and Rule Sets  . . . . . . . . . . . . . . . . . . . .  21\n   4.5 Maintaining\
    \ the Flow Table . . . . . . . . . . . . . . . . .  24\n   4.6 Handling Increasing\
    \ Traffic Levels . . . . . . . . . . . . .  25\n 5 Meter Readers             \
    \                                        26\n   5.1 Identifying Flows in Flow\
    \ Records  . . . . . . . . . . . . .  26\n   5.2 Usage Records, Flow Data Files\
    \ . . . . . . . . . . . . . . .  27\n   5.3 Meter to Meter Reader:  Usage Record\
    \ Transmission. . . . . .  27\n 6 Managers                                   \
    \                       28\n   6.1 Between Manager and Meter:  Control Functions\
    \  . . . . . . .  28\n   6.2 Between Manager and Meter Reader:  Control Functions\
    \   . . .  29\n   6.3 Exception Conditions . . . . . . . . . . . . . . . . . .\
    \ . .  31\n   6.4 Standard Rule Sets   . . . . . . . . . . . . . . . . . . . .\
    \  32\n 7 APPENDICES                                                        33\n\
    \   7.1 Appendix A: Network Characterisation . . . . . . . . . . . .  33\n   7.2\
    \ Appendix B: Recommended Traffic Flow Measurement Capabilities 34\n   7.3 Appendix\
    \ C: List of Defined Flow Attributes  . . . . . . . .  35\n   7.4 Appendix D:\
    \ List of Meter Control Variables  . . . . . . . .  36\n 8 Acknowledgments   \
    \                                                36\n 9 References           \
    \                                             37\n"
- title: 10 Security Considerations                                           37
  contents:
  - '10 Security Considerations                                           37

    '
- title: 11 Authors' Addresses                                                37
  contents:
  - '11 Authors'' Addresses                                                37

    '
- title: 1 Statement of Purpose and Scope
  contents:
  - "1 Statement of Purpose and Scope\n   This document describes an architecture\
    \ for traffic flow measurement\n   and reporting for data networks which has the\
    \ following\n   characteristics:\n     - The traffic flow model can be consistently\
    \ applied to any\n       protocol/application at any network layer (e.g.  network,\n\
    \       transport, application layers).\n     - Traffic flow attributes are defined\
    \ in such a way that they are\n       valid for multiple networking protocol stacks,\
    \ and that traffic\n       flow measurement implementations are useful in MULTI-PROTOCOL\n\
    \       environments.\n     - Users may specify their traffic flow measurement\
    \ requirements\n       in a simple manner, allowing them to collect the flow data\
    \ they\n       need while ignoring other traffic.\n     - The data reduction effort\
    \ to produce requested traffic flow\n       information is placed as near as possible\
    \ to the network\n       measurement point.  This reduces the volume of data to\
    \ be\n       obtained (and transmitted across the network for storage),\n    \
    \   and minimises the amount of processing required in traffic\n       flow analysis\
    \ applications.\n   The architecture specifies common metrics for measuring traffic\n\
    \   flows.  By using the same metrics, traffic flow data can be exchanged\n  \
    \ and compared across multiple platforms.  Such data is useful for:\n     - Understanding\
    \ the behaviour of existing networks,\n     - Planning for network development\
    \ and expansion,\n     - Quantification of network performance,\n     - Verifying\
    \ the quality of network service, and\n     - Attribution of network usage to\
    \ users.\n   The traffic flow measurement architecture is deliberately structured\n\
    \   so that specific protocol implementations may extend coverage to\n   multi-protocol\
    \ environments and to other protocol layers, such as\n   usage measurement for\
    \ application-level services.  Use of the same\n   model for both network- and\
    \ application-level measurement may\n   simplify the development of generic analysis\
    \ applications which\n   process and/or correlate any or all levels of traffic\
    \ and usage\n   information.  Within this docuemt the term 'usage data' is used\
    \ as a\n   generic term for the data obtained using the traffic flow measurement\n\
    \   architecture.\n   This document is not a protocol specification.  It specifies\
    \ and\n   structures the information that a traffic flow measurement system\n\
    \   needs to collect, describes requirements that such a system must\n   meet,\
    \ and outlines tradeoffs which may be made by an implementor.\n   For performance\
    \ reasons, it may be desirable to use traffic\n   information gathered through\
    \ traffic flow measurement in lieu of\n   network statistics obtained in other\
    \ ways.  Although the\n   quantification of network performance is not the primary\
    \ purpose of\n   this architecture, the measured traffic flow data may be used\
    \ as an\n   indication of network performance.\n   A cost recovery structure decides\
    \ \"who pays for what.\" The major\n   issue here is how to construct a tariff\
    \ (who gets billed, how much,\n   for which things, based on what information,\
    \ etc).  Tariff issues\n   include fairness, predictability (how well can subscribers\
    \ forecast\n   their network charges), practicality (of gathering the data and\n\
    \   administering the tariff), incentives (e.g.  encouraging off-peak\n   use),\
    \ and cost recovery goals (100% recovery, subsidisation, profit\n   making). \
    \ Issues such as these are not covered here.\n   Background information explaining\
    \ why this approach was selected is\n   provided by 'Traffic Flow Measurement:\
    \  Background' RFC [1].\n"
- title: 2 Traffic Flow Measurement Architecture
  contents:
  - "2 Traffic Flow Measurement Architecture\n   A traffic flow measurement system\
    \ is used by network Operations\n   personnel for managing and developing a network.\
    \  It provides a tool\n   for measuring and understanding the network's traffic\
    \ flows.  This\n   information is useful for many purposes, as mentioned in section\
    \ 1\n   (above).\n   The following sections outline a model for traffic flow measurement,\n\
    \   which draws from working drafts of the OSI accounting model [2].\n   Future\
    \ extensions are anticipated as the model is refined to address\n   additional\
    \ protocol layers.\n"
- title: 2.1 Meters and Traffic Flows
  contents:
  - "2.1 Meters and Traffic Flows\n   At the heart of the traffic measurement model\
    \ are network entities\n   called traffic METERS. Meters count certain attributes\
    \ (such as\n   numbers of packets and bytes) and classify them as belonging to\n\
    \   ACCOUNTABLE ENTITIES using other attributes (such as source and\n   destination\
    \ addresses).  An accountable entity is someone who (or\n   something which) is\
    \ responsible for some activitiy on the network.\n   It may be a user, a host\
    \ system, a network, a group of networks, etc,\n   depending on the granularity\
    \ specified by the meter's configuration.\n   We assume that routers or traffic\
    \ monitors throughout a network are\n   instrumented with meters to measure traffic.\
    \  Issues surrounding the\n   choice of meter placement are discussed in the 'Traffic\
    \ Flow\n   Measurement:  Background' RFC [1].  An important aspect of meters is\n\
    \   that they provide a way of succinctly aggregating entity usage\n   information.\n\
    \   For the purpose of traffic flow measurement we define the concept of\n   a\
    \ TRAFFIC FLOW, which is an artificial logical equivalent to a call\n   or connection.\
    \  A flow is a portion of traffic, delimited by a start\n   and stop time, that\
    \ was generated by a particular accountable entity.\n   Attribute values (source/destination\
    \ addresses, packet counts, byte\n   counts, etc.)  associated with a flow are\
    \ aggregate quantities\n   reflecting events which take place in the DURATION\
    \ between the start\n   and stop times.  The start time of a flow is fixed for\
    \ a given flow;\n   the end time may increase with the age of the flow.\n   For\
    \ connectionless network protocols such as IP there is by\n   definition no way\
    \ to tell whether a packet with a particular\n   source/destination combination\
    \ is part of a stream of packets or not\n   - each packet is completely independent.\
    \  A traffic meter has, as\n   part of its configuration, a set of 'rules' which\
    \ specify the flows\n   of interest, in terms of the values of their attributes.\
    \  It derives\n   attribute values from each observed packet, and uses these to\
    \ decide\n   which flow they belong to.  Classifying packets into 'flows' in this\n\
    \   way provides an economical and practical way to measure network\n   traffic\
    \ and ascribe it to accountable entities.\n   Usage information which is not deriveable\
    \ from traffic flows may also\n   be of interest.  For example, an application\
    \ may wish to record\n   accesses to various different information resources or\
    \ a host may\n   wish to record the username (subscriber id) for a particular\
    \ network\n   session.  Provision is made in the traffic flow architecture to\
    \ do\n   this.  In the future the measurement model will be extended to gather\n\
    \   such information from applications and hosts so as to provide values\n   for\
    \ higher-layer flow attributes.\n   As well as FLOWS and METERS, the traffic flow\
    \ measurement model\n   includes MANAGERS, METER READERS and ANALYSIS APPLICAIONS,\
    \ which are\n   explained in following sections.  The relationships between them\
    \ are\n   shown by the diagram below.  Numbers on the diagram refer to sections\n\
    \   in this document.\n                    MANAGER\n                   /     \
    \  \\\n              2.3 /         \\ 2.4\n                 /           \\\n \
    \               /             \\                       ANALYSIS\n           METER\
    \   <----->   METER READER  <----->   APPLICATION\n                     2.2  \
    \                   2.7\n  - MANAGER: A traffic measurement manager is an application\
    \ which\n    configures 'meter' entities and controls 'meter reader' entities.\n\
    \    It uses the data requirements of analysis applications to determine\n   \
    \ the appropriate configurations for each meter, and the proper\n    operation\
    \ of each meter reader.  It may well be convenient to\n    combine the functions\
    \ of meter reader and manager within a single\n    network entity.\n  - METER:\
    \ Meters are placed at measurement points determined by\n    network Operations\
    \ personnel.  Each meter selectively records\n    network activity as directed\
    \ by its configuration settings.  It can\n    also aggregate, transform and further\
    \ process the recorded activity\n    before the data is stored.  The processed\
    \ and stored results are\n    called the 'usage data.'\n  - METER READER: A meter\
    \ reader reliably transports usage data from\n    meters so that it is available\
    \ to analysis applications.\n  - ANALYSIS APPLICATION: An analysis application\
    \ processes the usage\n    data so as to provide information and reports which\
    \ are useful for\n    network engineering and management purposes.  Examples include:\n\
    \      -  TRAFFIC FLOW MATRICES, showing the total flow rates for\n         many\
    \ of the possible paths within an internet.\n      -  FLOW RATE FREQUENCY DISTRIBUTIONS,\
    \ indicating how flow\n         rates vary with time.\n      -  USAGE DATA showing\
    \ the total traffic volumes sent and\n         received by particular hosts.\n\
    \   The operation of the traffic measurement system as a whole is best\n   understood\
    \ by considering the interactions between its components.\n   These are described\
    \ in the following sections.\n"
- title: 2.2 Interaction Between METER and METER READER
  contents:
  - "2.2 Interaction Between METER and METER READER\n   The information which travels\
    \ along this path is the usage data\n   itself.  A meter holds usage data in an\
    \ array of flow data records\n   known as the FLOW TABLE. A meter reader may collect\
    \ the data in any\n   suitable manner.  For example it might upload a copy of\
    \ the whole\n   flow table using a file transfer protocol, or read the records\
    \ in the\n   current flow set one at a time using a suitable data transfer\n \
    \  protocol.  Note that the meter reader need not read complete flow\n   data\
    \ records, a subset of their attribute values may well be\n   sufficient.\n  \
    \ A meter reader may collect usage data from one or more meters.  Data\n   may\
    \ be collected from the meters at any time.  There is no\n   requirement for collections\
    \ to be synchronized in any way.\n"
- title: 2.3 Interaction Between MANAGER and METER
  contents:
  - "2.3 Interaction Between MANAGER and METER\n   A manager is responsible for configuring\
    \ and controlling one or more\n   meters.  At the time of writing a meter can\
    \ only be controlled by a\n   single manager; in the future this restriction may\
    \ be relaxed.  Each\n   meter's configuration includes information such as:\n\
    \  - Flow specifications, e.g.  which traffic flows are to be measured,\n    how\
    \ they are to be aggregated, and any data the meter is required\n    to compute\
    \ for each flow being measured.\n  - Meter control parameters, e.g.  the maximum\
    \ size of its flow table,\n    the 'inactivity' time for flows (if no packets\
    \ belonging to a flow\n    are seen for this time the flow is considered to have\
    \ ended, i.e.\n    to have become idle).\n  - Sampling rate.  Normally every packet\
    \ will be observed.  It may\n    sometimes be necessary to use sampling techniques\
    \ to observe only\n    some of the packets.  (Sampling algorithms are not prescribed\
    \ by\n    the architecture; it should be noted that before using sampling one\n\
    \    should verify the statistical validity of the algorithm used).\n    Current\
    \ experience with the measurement architecture shows that a\n    carefully-designed\
    \ and implemented meter compresses the data such\n    that in normal LANs and\
    \ WANs of today sampling is really not\n    needed.\n"
- title: 2.4 Interaction Between MANAGER and METER READER
  contents:
  - "2.4 Interaction Between MANAGER and METER READER\n   A manager is responsible\
    \ for configuring and controlling one or more\n   meter readers.  A meter reader\
    \ may only be controlled by a single\n   manager.  A meter reader needs to know\
    \ at least the following for\n   every meter is is collecting usage data from:\n\
    \  - The meter's unique identity, i.e.  its network name or address.\n  - How\
    \ often usage data is to be collected from the meter.\n  - Which flow records\
    \ are to be collected (e.g.  all active flows, the\n    whole flow table, flows\
    \ seen since a given time, etc.).\n  - Which attribute values are to be collected\
    \ for the required flow\n    records (e.g.  all attributes, or a small subset\
    \ of them)\n   Since redundant reporting may be used in order to increase the\n\
    \   reliability of usage data, exchanges among multiple entities must be\n   considered\
    \ as well.  These are discussed below.\n"
- title: 2.5 Multiple METERs or METER READERs
  contents:
  - "2.5 Multiple METERs or METER READERs\n                 -- METER READER A --\n\
    \                /         |          \\\n               /          |        \
    \   \\\n       =====METER 1     METER 2=====METER 3    METER 4=====\n        \
    \                   \\           |          /\n                            \\\
    \          |         /\n                             -- METER READER B --\n  \
    \ Several uniquely identified meters may report to one or more meter\n   readers.\
    \  The diagram above gives an example of how multiple meters\n   and meter readers\
    \ could be used.\n   In the diagram above meter 1 is read by meter reader A, and\
    \ meter 4\n   is read by meter reader B. Meters 1 and 4 have no redundancy; if\n\
    \   either fails, usage data for their network segments will be lost.\n   Meters\
    \ 2 and 3, however, measure traffic on the same network segment.\n   One of them\
    \ may fail leaving the other collecting the segment's usage\n   data.  Meters\
    \ 2 and 3 are read by meter reader A and by meter reader\n   B.  If one meter\
    \ reader fails, the other will continue collecting\n   usage data.\n   The architecture\
    \ does not require multiple meter readers to be\n   synchronized.  In the situation\
    \ above meter readers A and B could\n   both collect usage data at the same intervals,\
    \ but not neccesarily at\n   the same times.  Note that because collections are\
    \ asynchronous it is\n   unlikely that usage records from two different meter\
    \ readers will\n   agree exactly.\n   If precisely synchronized collections are\
    \ required this can be\n   achieved by having one manager request each meter to\
    \ begin collecting\n   a new set of flows, then allowing all meter readers to\
    \ collect the\n   usage data from the old sets of flows.\n   If there is only\
    \ one meter reader and it fails, the meters continue\n   to run.  When the meter\
    \ reader is restarted it can collect all of the\n   accumulated flow data.  Should\
    \ this happen, time resolution will be\n   lost (because of the missed collections)\
    \ but overall traffic flow\n   information will not.  The only exception to this\
    \ would occur if the\n   traffic volume was sufficient to 'roll over' counters\
    \ for some flows\n   during the failure; this is addressed in the section on 'Rolling\n\
    \   Counters.'\n"
- title: 2.6 Interaction Between MANAGERs (MANAGER - MANAGER)
  contents:
  - "2.6 Interaction Between MANAGERs (MANAGER - MANAGER)\n   Synchronization between\
    \ multiple management systems is the province\n   of network management protocols.\
    \  This traffic flow measurement\n   architecture specifies only the network management\
    \ controls necessary\n   to perform the traffic flow measurement function and\
    \ does not address\n   the more global issues of simultaneous or interleaved (possibly\n\
    \   conflicting) commands from multiple network management stations or\n   the\
    \ process of transferring control from one network management\n   station to another.\n"
- title: 2.7 METER READERs and APPLICATIONs
  contents:
  - "2.7 METER READERs and APPLICATIONs\n   Once a collection of usage data has been\
    \ assembled by a meter reader\n   it can be processed by an analysis application.\
    \  Details of analysis\n   applications - such as the reports they produce and\
    \ the data they\n   require - are outside the scope of this architecture.\n  \
    \ It should be noted, however, that analysis applications will often\n   require\
    \ considerable amounts of input data.  An important part of\n   running a traffic\
    \ flow measurement system is the storage and regular\n   reduction of flow data\
    \ so as to produce daily, weekly or monthly\n   summary files for further analysis.\
    \  Again, details of such data\n   handling are outside the scope of this architecture.\n"
- title: 3 Traffic Flows and Reporting Granularity
  contents:
  - "3 Traffic Flows and Reporting Granularity\n   A flow was defined in section 2.1\
    \ above in abstract terms as follows:\n    \"A TRAFFIC FLOW is an artifical logical\
    \ equivalent to a call or\n    connection, belonging to an ACCOUNTABLE ENTITY.\"\
    \n   In practical terms, a flow is a stream of packets passing across a\n   network\
    \ between two end points (or being sent from a single end\n   point), which have\
    \ been summarized by a traffic meter for analysis\n   purposes.\n"
- title: 3.1 Flows and their Attributes
  contents:
  - "3.1 Flows and their Attributes\n   Every traffic meter maintains a table of 'flow\
    \ records' for flows\n   seen by the meter.  A flow record holds the values of\
    \ the ATTRIBUTES\n   of interest for its flow.  These attributes might include:\n\
    \  - ADDRESSES for the flow's source and destination.  These comprise\n    the\
    \ protocol type, the source and destination addresses at various\n    network\
    \ layers (extracted from the packet), and the number of the\n    interface on\
    \ which the packet was observed.\n  - First and last TIMES when packets were seen\
    \ for this flow, i.e.\n    the 'creation' and 'last activity' times for the flow.\n\
    \  - COUNTS for 'forward' (source to destination) and 'backward'\n    (destination\
    \ to source) components (e.g.  packets and bytes) of the\n    flow's traffic.\
    \  The specifying of 'source' and 'destination' for\n    flows is discussed in\
    \ the section on packet matching below.\n  - OTHER attributes, e.g.  information\
    \ computed by the meter.\n   A flow's ACCOUNTABLE ENTITY is specified by the values\
    \ of its ADDRESS\n   attributes.  For example, if a flow's address attributes\
    \ specified\n   only that \"source address = IP address 10.1.0.1,\" then all IP\
    \ packets\n   from and to that address would be counted in that flow.  If a flow's\n\
    \   address list were specified as \"source address = IP address 10.1.0.1,\n \
    \  destination address = IP address 26.1.0.1\" then only IP packets\n   between\
    \ 10.1.0.1 and 26.1.0.1 would be counted in that flow.\n   The addresses specifying\
    \ a flow's address attributes may include one\n   or more of the following types:\n\
    \  - The INTERFACE NUMBER for the flow, i.e.  the interface on which the\n   \
    \ meter measured the traffic.  Together with a unique address for the\n    meter\
    \ this uniquely identifies a particular physical-level port.\n  - The ADJACENT\
    \ ADDRESS, i.e.  the [n-1] layer address of the\n    immediate source or destination\
    \ on the path of the packet.  For\n    example, if flow measurement is being performed\
    \ at the IP layer on\n    an Ethernet LAN [3], an adjacent address is a six-octet\
    \ Media\n    Access Control (MAC) address.  For a host connected to the same LAN\n\
    \    segment as the meter the adjacent address will be the MAC address\n    of\
    \ that host.  For hosts on other LAN segments it will be the MAC\n    address\
    \ of the adjacent (upstream or downstream) router carrying\n    the traffic flow.\n\
    \  - The PEER ADDRESS, which identifies the source or destination of the\n   \
    \ PEER-LEVEL packet.  The form of a peer address will depend on the\n    network-layer\
    \ protocol in use, and the network layer [n] at which\n    traffic measurement\
    \ is being performed.\n  - The TRANSPORT ADDRESS, which identifies the source\
    \ or destination\n    port for the packet, i.e.  its [n+1] layer address.  For\
    \ example,\n    if flow measurement is being performed at the IP layer a transport\n\
    \    address is a two-octet UDP or TCP port number.\n   The four definitions above\
    \ specify addresses for each of the four\n   lowest layers of the OSI reference\
    \ model, i.e.  Physical layer, Link\n   layer, Network layer and Transport layer.\
    \  A FLOW RECORD stores both\n   the VALUE for each of its addresses (as described\
    \ above) and a MASK\n   specifying which bits of the address value are being used\
    \ and which\n   are ignored.  Note that if address bits are being ignored the\
    \ meter\n   will set them to zero, however their actual values are undefined.\n\
    \   One of the key features of the traffic measurement architecture is\n   that\
    \ attributes have essentially the same meaning for different\n   protocols, so\
    \ that analysis applications can use the same reporting\n   formats for all protocols.\
    \  This is straightforward for peer\n   addresses; although the form of addresses\
    \ differs for the various\n   protocols, the meaning of a 'peer address' remains\
    \ the same.  It\n   becomes harder to maintain this correspondence at higher layers\
    \ - for\n   example, at the Network layer IP, Novell IPX and AppleTalk all use\n\
    \   port numbers as a 'transport address,' but CLNP and DECnet have no\n   notion\
    \ of ports.  Further work is needed here, particularly in\n   selecting attributes\
    \ which will be suitable for the higher layers of\n   the OSI reference model.\n\
    \   Reporting by adjacent intermediate sources and destinations or simply\n  \
    \ by meter interface (most useful when the meter is embedded in a\n   router)\
    \ supports hierarchical Internet reporting schemes as described\n   in the 'Traffic\
    \ Flow Measurement:  Background' RFC [1].  That is, it\n   allows backbone and\
    \ regional networks to measure usage to just the\n   next lower level of granularity\
    \ (i.e.  to the regional and\n   stub/enterprise levels, respectively), with the\
    \ final breakdown\n   according to end user (e.g.  to source IP address) performed\
    \ by the\n   stub/enterprise networks.\n   In cases where network addresses are\
    \ dynamically allocated (e.g.\n   mobile subscribers), further subscriber identification\
    \ will be\n   necessary if flows are to ascribed to individual users.  Provision\
    \ is\n   made to further specify the accountable entity through the use of an\n\
    \   optional SUBSCRIBER ID as part of the flow id.  A subscriber ID may\n   be\
    \ associated with a particular flow either through the current rule\n   set or\
    \ by proprietary means within a meter, for example via protocol\n   exchanges\
    \ with one or more (multi-user) hosts.  At this time a\n   subscriber ID is an\
    \ arbitrary text string; later versions of the\n   architecture may specify its\
    \ contents on more detail.\n"
- title: 3.2 Granularity of Flow Measurements
  contents:
  - "3.2 Granularity of Flow Measurements\n   GRANULARITY is the 'control knob' by\
    \ which an application and/or the\n   meter can trade off the overhead associated\
    \ with performing usage\n   reporting against the level of detail supplied.  A\
    \ coarser\n   granularity means a greater level of aggregation; finer granularity\n\
    \   means a greater level of detail.  Thus, the number of flows measured\n   (and\
    \ stored) at a meter can be regulated by changing the granularity\n   of the accountable\
    \ entity, the attributes, or the time intervals.\n   Flows are like an adjustable\
    \ pipe - many fine-granularity streams can\n   carry the data with each stream\
    \ measured individually, or data can be\n   bundled in one coarse-granularity\
    \ pipe.\n   Flow granularity is controlled by adjusting the level of detail at\n\
    \   which the following are reported:\n  - The accountable entity (address attributes,\
    \ discussed above).\n  - The categorisation of packets (other attributes, discussed\
    \ below).\n  - The lifetime/duration of flows (the reporting interval needs to\
    \ be\n    short enough to measure them with sufficient precision).\n   The set\
    \ of rules controlling the determination of each packet's\n   accountable entity\
    \ is known as the meter's CURRENT RULE SET. As will\n   be shown, the meter's\
    \ current rule set forms an integral part of the\n   reported information, i.e.\
    \  the recorded usage information cannot be\n   properly interpreted without a\
    \ definition of the rules used to\n   collect that information.\n   Settings for\
    \ these granularity factors may vary from meter to meter.\n   They are determined\
    \ by the meter's current rule set, so they will\n   change if network Operations\
    \ personnel reconfigure the meter to use a\n   new rule set.  It is expected that\
    \ the collection rules will change\n   rather infrequently; nonetheless, the rule\
    \ set in effect at any time\n   must be identifiable via a RULE SET ID. Granularity\
    \ of accountable\n   entities is further specified by additional ATTRIBUTES. These\n\
    \   attributes include:\n     - Meter variables such as the index of the flow's\
    \ record in the flow\n       table and the rule set id for the rules which the\
    \ meter was running\n       while the flow was observed.  The values of these\
    \ attributes\n       provide a way of distinguishing flows observed by a meter\
    \ at\n       different times.\n     - Attributes which record information derived\
    \ from other attribute\n       values.  Six of these are defined (SourceClass,\
    \ DestClass,\n       FlowClass, SourceKind, DestKind, FlowKind), and their meaning\
    \ is\n       determined by the meter's rule set.  For example, one could have\
    \ a\n       subroutine in the rule set which determined whether a source or\n\
    \       destination peer address was a member of an arbitrary list of\n      \
    \ networks, and set SourceClass/DestClass to one if the source/dest\n       peer\
    \ address was in the list or to zero otherwise.\n     - Administratively specified\
    \ attributes such as Quality Of Service\n       and Priority, etc.  These are\
    \ not defined at this time.\n     - Higher-layer (especially application-level)\
    \ attributes.  These are\n       not defined at this time.\n   Settings for these\
    \ granularity factors may vary from meter to meter.\n   They are determined by\
    \ the meter's current rule set, so they will\n   change if network Operations\
    \ personnel reconfigure the meter to use a\n   new rule set.\n   The LIFETIME\
    \ of a flow is the time interval which began when the\n   meter observed the first\
    \ packet belonging to the flow and ended when\n   it saw the last packet.  Flow\
    \ lifetimes are very variable, but many -\n   if not most - are rather short.\
    \  A meter cannot measure lifetimes\n   directly; instead a meter reader collects\
    \ usage data for flows which\n   have been active since the last collection, and\
    \ an analysis\n   application may compare the data from each collection so as\
    \ to\n   determine when each flow actually stopped.\n   The meter does, however,\
    \ need to reclaim memory (i.e.  records in the\n   flow table) being held by idle\
    \ flows.  The meter configuration\n   includes a variable called InactivityTimeout,\
    \ which specifies the\n   minimum time a meter must wait before recovering the\
    \ flow's record.\n   In addition, before recovering a flow record the meter must\
    \ be sure\n   that the flow's data has been collected by at least one meter reader.\n\
    \   These 'lifetime' issues are considered further in the section on\n   meter\
    \ readers (below).  A complete list of the attributes currently\n   defined is\
    \ given in Appendix C later in this document.\n"
- title: 3.3 Rolling Counters, Timestamps, Report-in-One-Bucket-Only
  contents:
  - "3.3 Rolling Counters, Timestamps, Report-in-One-Bucket-Only\n   Once an usage\
    \ record is sent, the decision needs to be made whether\n   to clear any existing\
    \ flow records or to maintain them and add to\n   their counts when recording\
    \ subsequent traffic on the same flow.  The\n   second method, called rolling\
    \ counters, is recommended and has\n   several advantages.  Its primary advantage\
    \ is that it provides\n   greater reliability - the system can now often survive\
    \ the loss of\n   some usage records, such as might occur if a meter reader failed\
    \ and\n   later restarted.  The next usage record will very often contain yet\n\
    \   another reading of many of the same flow buckets which were in the\n   lost\
    \ usage record.  The 'continuity' of data provided by rolling\n   counters can\
    \ also supply information used for \"sanity\" checks on the\n   data itself, to\
    \ guard against errors in calculations.\n   The use of rolling counters does introduce\
    \ a new problem:  how to\n   distinguish a follow-on flow record from a new flow\
    \ record.  Consider\n   the following example.\n                         CONTINUING\
    \ FLOW        OLD FLOW, then NEW FLOW\n                         start time = 1\
    \            start time = 1\n   Usage record N:       flow count = 2000      flow\
    \ count = 2000 (done)\n                         start time = 1            start\
    \ time = 5\n   Usage record N+1:     flow count = 3000      new flow count = 1000\n\
    \   Total count:                 3000                    3000\n   In the continuing\
    \ flow case, the same flow was reported when its\n   count was 2000, and again\
    \ at 3000:  the total count to date is 3000.\n   In the OLD/NEW case, the old\
    \ flow had a count of 2000.  Its record\n   was then stopped (perhaps because\
    \ of temporary idleness, or MAX\n   LIFETIME policy), but then more traffic with\
    \ the same characteristics\n   arrived so a new flow record was started and it\
    \ quickly reached a\n   count of 1000.  The total flow count from both the old\
    \ and new\n   records is 3000.\n   The flow START TIMESTAMP attribute is sufficient\
    \ to resolve this.  In\n   the example above, the CONTINUING FLOW flow record\
    \ in the second\n   usage record has an old FLOW START timestamp, while the NEW\
    \ FLOW\n   contains a recent FLOW START timestamp.\n   Each packet is counted\
    \ in one and only one flow, so as to avoid\n   multiple counting of a single packet.\
    \  The record of a single flow is\n   informally called a \"bucket.\" If multiple,\
    \ sometimes overlapping,\n   records of usage information are required (aggregate,\
    \ individual,\n   etc), the network manager should collect the counts in sufficiently\n\
    \   detailed granularity so that aggregate and combination counts can be\n   reconstructed\
    \ in post-processing of the raw usage data.\n   For example, consider a meter\
    \ from which it is required to record\n   both 'total packets coming in interface\
    \ #1' and 'total packets\n   arriving from any interface sourced by IP address\
    \ = a.b.c.d.'\n   Although a bucket can be declared for each case, it is not clear\
    \ how\n   to handle a packet which satisfies both criteria.  It must only be\n\
    \   counted once.  By default it will be counted in the first bucket for\n   which\
    \ it qualifies, and not in the other bucket.  Further, it is not\n   possible\
    \ to reconstruct this information by post-processing.  The\n   solution in this\
    \ case is to define not two, but THREE buckets, each\n   one collecting a unique\
    \ combination of the two criteria:\n        Bucket 1:  Packets which came in interface\
    \ 1,\n                   AND were sourced by IP address a.b.c.d\n        Bucket\
    \ 2:  Packets which came in interface 1,\n                   AND were NOT sourced\
    \ by IP address a.b.c.d\n        Bucket 3:  Packets which did NOT come in interface\
    \ 1,\n                   AND were sourced by IP address a.b.c.d\n       (Bucket\
    \ 4:  Packets which did NOT come in interface 1,\n                   AND NOT sourced\
    \ by IP address a.b.c.d)\n   The desired information can now be reconstructed\
    \ by post-processing.\n   \"Total packets coming in interface 1\" can be found\
    \ by adding buckets\n   1 & 2, and \"Total packets sourced by IP address a.b.c.d\"\
    \ can be found\n   by adding buckets 1 & 3.  Note that in this case bucket 4 is\
    \ not\n   explicitly required since its information is not of interest, but it\n\
    \   is supplied here in parentheses for completeness.\n"
- title: 4 Meters
  contents:
  - "4 Meters\n   A traffic flow meter is a device for collecting data about traffic\n\
    \   flows at a given point within a network; we will call this the\n   METERING\
    \ POINT.  The header of every packet passing the network\n   metering point is\
    \ offered to the traffic meter program.\n   A meter could be implemented in various\
    \ ways, including:\n  - A dedicated small host, connected to a LAN (so that it\
    \ can see all\n    packets as they pass by) and running a 'traffic meter' program.\n\
    \    The metering point is the LAN segment to which the meter is\n    attached.\n\
    \  - A multiprocessing system with one or more network interfaces, with\n    drivers\
    \ enabling a traffic meter program to see packets.  In this\n    case the system\
    \ provides multiple metering points - traffic flows\n    on any subset of its\
    \ network interfaces can be measured.\n  - A packet-forwarding device such as\
    \ a router or switch.  This is\n    similar to (b) except that every received\
    \ packet should also be\n    forwarded, usually on a different interface.\n  \
    \ The discussion in the following sections assumes that a meter may\n   only run\
    \ a single rule set.  It is, however, possible for a meter to\n   run several\
    \ rule sets concurrently, matching each packet against\n   every active rule set\
    \ and producing a single flow table with flows\n   from all the active rule sets.\
    \  The overall effect of doing this\n   would be similar to running several independent\
    \ meters, one for each\n   rule set.\n"
- title: 4.1 Meter Structure
  contents:
  - "4.1 Meter Structure\n   An outline of the meter's structure is given in the following\n\
    \   diagram.\n   Briefly, the meter works as follows:\n  - Incoming packet headers\
    \ arrive at the top left of the diagram and\n    are passed to the PACKET PROCESSOR.\n\
    \  - The packet processor passes them to the Packet Matching Engine\n    (PME)\
    \ where they are classified.\n  - The PME is a Virtual Machine running a pattern\
    \ matching program\n    contained in the CURRENT RULE SET. It is invoked by the\
    \ Packet\n    Processor, and returns instructions on what to do with the packet.\n\
    \  - Some packets are classified as 'to be ignored.'  They are discarded\n   \
    \ by the Packet Processor.\n  - Other packets are matched by the PME, which returns\
    \ a FLOW KEY\n    describing the flow to which the packet belongs.\n  - The flow\
    \ key is used to locate the flow's entry in the FLOW TABLE;\n    a new entry is\
    \ created when a flow is first seen.  The entry's\n    packet and byte counters\
    \ are updated.\n  - A meter reader may collect data from the flow table at any\
    \ time.\n    It may use the 'collect' index to locate the flows to be collected\n\
    \    within the flow table.\n                  packet                +------------------+\n\
    \                  header                | Current Rule Set |\n              \
    \      |                   +--------+---------+\n                    |       \
    \                     |\n           +--------*---------+       +----------*-------------+\n\
    \           | Packet Processor |<----->| Packet Matching Engine |\n          \
    \ +--+------------+--+       +------------------------+\n              |     \
    \       |\n       Ignore *            | Count via flow key\n                 \
    \          |\n                        +--*--------------+\n                  \
    \      | 'Search' index  |\n                        +--------+--------+\n    \
    \                             |\n                        +--------*--------+\n\
    \                        |                 |\n                        |   Flow\
    \ Table    |\n                        |                 |\n                  \
    \      +--------+--------+\n                                 |\n             \
    \           +--------*--------+\n                        | 'Collect' index |\n\
    \                        +--------+--------+\n                               \
    \  |\n                                 *\n                            Meter Reader\n"
- title: 4.2 Flow Table
  contents:
  - "4.2 Flow Table\n   Every traffic meter maintains a table of TRAFFIC FLOW RECORDS\
    \ for\n   flows seen by the meter.  A flow record contains attribute values for\n\
    \   its flow, including:\n  - Addresses for the flow's source and destination.\
    \  These include\n    addresses and masks for various network layers (extracted\
    \ from the\n    packet), and the number of the interface on which the packet was\n\
    \    observed.\n  - First and last times when packets were seen for this flow.\n\
    \  - Counts for 'forward' (source to destination) and 'backward'\n    (destination\
    \ to source) components of the flow's traffic.\n  - Other attributes, e.g.  state\
    \ of the flow record (discussed below).\n   The state of a flow record may be:\n\
    \  - INACTIVE: The flow record is not being used by the meter.\n  - CURRENT: The\
    \ record is in use and describes a flow which belongs to\n    the 'current flow\
    \ set,' i.e.  the set of flows recently seen by the\n    meter.\n  - IDLE: The\
    \ record is in use and the flow which it describes is part\n    of the current\
    \ flow set.  In addition, no packets belonging to this\n    flow have been seen\
    \ for a period specified by the meter's\n    InactivityTime variable.\n"
- title: 4.3 Packet Handling, Packet Matching
  contents:
  - "4.3 Packet Handling, Packet Matching\n   Each packet header received by the traffic\
    \ meter program is processed\n   as follows:\n  - Extract attribute values from\
    \ the packet header and use them to\n    create a MATCH KEY for the packet.\n\
    \  - Match the packet's key against the current rule set, as explained\n    in\
    \ detail below.\n   The rule set specifies whether the packet is to be counted\
    \ or\n   ignored.  If it is to be counted the matching process produces a FLOW\n\
    \   KEY for the flow to which the packet belongs.  This flow key is used\n   to\
    \ find the flow's record in the flow table; if a record does not yet\n   exist\
    \ for this flow, a new flow record may be created.  The counts\n   for the matching\
    \ flow record can then be incremented.\n   For example, the rule set could specify\
    \ that packets to or from any\n   host in IP network 130.216 are to be counted.\
    \  It could also specify\n   that flow records are to be created for every pair\
    \ of 24-bit (Class\n   C) subnets within network 130.216.\n   Each packet's match\
    \ key is passed to the meter's PATTERN MATCHING\n   ENGINE (PME) for matching.\
    \  The PME is a Virtual Machine which uses a\n   set of instructions called RULES,\
    \ i.e.  a RULE SET is a program for\n   the PME. A packet's match key contains\
    \ an interface number, source\n   address (S) and destination address (D) values.\
    \  It does not,\n   however, contain any attribute masks for its attributes, only\
    \ their\n   values.\n   If measured flows were unidirectional, i.e.  only counted\
    \ packets\n   travelling in one direction, the matching process would be simple.\n\
    \   The PME would be called once to match the packet.  Any flow key\n   produced\
    \ by a successful match would be used to find the flow's\n   record in the flow\
    \ table, and that flow's counters would be updated.\n   Flows are, however, bidirectional,\
    \ reflecting the forward and reverse\n   packets of a protocol interchange or\
    \ 'session.'  Maintaining two sets\n   of counters in the meter's flow record\
    \ makes the resulting flow data\n   much simpler to handle, since analysis programs\
    \ do not have to gather\n   together the 'forward' and 'reverse' components of\
    \ sessions.\n   Implementing bi-directional flows is, of course, more difficult\
    \ for\n   the meter, since it must decide whether a packet is a 'forward'\n  \
    \ packet or a 'reverse' one.  To make this decision the meter will\n   often need\
    \ to invoke the PME twice, once for each possible packet\n   direction.\n   The\
    \ diagram below describes the algorithm used by the traffic meter\n   to process\
    \ each packet.  Flow through the diagram is from left to\n   right and top to\
    \ bottom, i.e.  from the top left corner to the bottom\n   right corner.  S indicates\
    \ the flow's source address (i.e.  its set\n   of source address attribute values)\
    \ from the packet, and D indicates\n   its destination address.\n   There are\
    \ several cases to consider.  These are:\n  - The packet is recognised as one\
    \ which is TO BE IGNORED.\n  - The packet MATCHES IN BOTH DIRECTIONS. One situation\
    \ in which this\n    could happen would be a rule set which matches flows within\
    \ network\n    X (Source = X, Dest = X) but specifies that flows are to be created\n\
    \    for each subnet within network X, say subnets y and z.  If, for\n    example\
    \ a packet is seen for y->z, the meter must check that flow\n    z->y is not already\
    \ current before creating y->z.\n  - The packet MATCHES IN ONE DIRECTION ONLY.\
    \ If its flow is already\n    current, its forward or reverse counters are incremented.\n\
    \    Otherwise it is added to the flow table and then counted.\n   The algorithm\
    \ uses four functions, as follows:\n"
- title: match(A->B) implements the PME.  It uses the meter's current rule set
  contents:
  - "match(A->B) implements the PME.  It uses the meter's current rule set\n   to\
    \ match the attribute values in the packet's match key.  A->B means\n   that the\
    \ assumed source address is A and destination address B, i.e.\n   that the packet\
    \ was travelling from A to B.  match() returns one of\n   three results:\n   'Ignore'\
    \ means that the packet was matched but this flow is not\n            to be counted.\n\
    \   'Fail' means that the packet did not match.  It might, however\n         \
    \   match with its direction reversed, i.e. from B to A.\n   'Suc'  means that\
    \ the packet did match, i.e. it belongs to a flow\n            which is to be\
    \ counted.\n"
- title: current(A->B) succeeds if the flow A-to-B is current - i.e. has
  contents:
  - "current(A->B) succeeds if the flow A-to-B is current - i.e. has\n   a record\
    \ in the flow table whose state is Current - and fails\n   otherwise.\n"
- title: create(A->B) adds the flow A-to-B to the flow table, setting the
  contents:
  - "create(A->B) adds the flow A-to-B to the flow table, setting the\n   value for\
    \ attributes - such as addresses - which remain constant,\n   and zeroing the\
    \ flow's counters.\n"
- title: count(A->B,f) increments the 'forward' counters for flow A-to-B.
  contents:
  - 'count(A->B,f) increments the ''forward'' counters for flow A-to-B.

    '
- title: count(A->B,r) increments the 'reverse' counters for flow A-to-B.
  contents:
  - "count(A->B,r) increments the 'reverse' counters for flow A-to-B.\n   'Forward'\
    \ here means the counters for packets travelling from\n   A to B.  Note that count(A->B,f)\
    \ is identical to count(B->A,r).\n                    Ignore\n    --- match(S->D)\
    \ -------------------------------------------------+\n         | Suc   | Fail\
    \                                              |\n         |       |         \
    \ Ignore                                   |\n         |      match(D->S) -----------------------------------------+\n\
    \         |       | Suc   | Fail                                      |\n    \
    \     |       |       |                                           |\n        \
    \ |       |       +-------------------------------------------+\n         |  \
    \     |                                                   |\n         |      \
    \ |             Suc                                   |\n         |      current(D->S)\
    \ ---------- count(D->S,r) --------------+\n         |       | Fail          \
    \                                    |\n         |       |                   \
    \                                |\n         |      create(D->S) ----------- count(D->S,r)\
    \ --------------+\n         |                                                \
    \           |\n         |             Suc                                    \
    \       |\n        current(S->D) ------------------ count(S->D,f) --------------+\n\
    \         | Fail                                                      |\n    \
    \     |             Suc                                           |\n        current(D->S)\
    \ ------------------ count(D->S,r) --------------+\n         | Fail          \
    \                                            |\n         |                   \
    \                                        |\n        create(S->D) -------------------\
    \ count(S->D,f) --------------+\n                                            \
    \                         |\n                                                \
    \                     *\n   When writing rule sets one must remember that the\
    \ meter will normally\n   try to match each packet in both directions.  It is\
    \ particularly\n   important that the rule set does not contain inconsistencies\
    \ which\n   will upset this process.\n   Consider, for example, a rule set which\
    \ counts packets from source\n   network A to destination network B, but which\
    \ ignores packets from\n   source network B. This is an obvious example of an\
    \ inconsistent rule\n   set, since packets from network B should be counted as\
    \ reverse\n   packets for the A-to-B flow.\n   This problem could be avoided by\
    \ devising a language for specifying\n   rule files and writing a compiler for\
    \ it, thus making it much easier\n   to produce correct rule sets.  Another approach\
    \ would be to write a\n   'rule set consistency checker' program, which could\
    \ detect problems\n   in hand-written rule sets.\n   In the short term the best\
    \ way to avoid these problems is to write\n   rule sets which only clasify flows\
    \ in the forward direction, and rely\n   on the meter to handle reverse-travelling\
    \ packets.\n"
- title: 4.4 Rules and Rule Sets
  contents:
  - "4.4 Rules and Rule Sets\n   A rule set is an array of rules.  Rule sets are held\
    \ within a meter\n   as entries in an array of rule sets.  One member of this\
    \ array is the\n   CURRENT RULE SET, in that it is the one which is currently\
    \ being used\n   by the meter to classify incoming packets.\n   Rule set 1 is\
    \ built in to the meter and cannot be changed.  It is run\n   when the meter is\
    \ started up, and provides a very coarse reporting\n   granularity; it is mainly\
    \ useful for verifying that the meter is\n   running, before a 'useful' rule set\
    \ is downloaded to it.\n   If the meter is instructed to use rule set 0, it will\
    \ cease\n   measuring; all packets will be ignored until another (non-zero) rule\n\
    \   set is made current.\n   Each rule in a rule set is structured as follows:\n\
    \   +-------- test ---------+    +---- action -----+\n   attribute & mask = value:\
    \    opcode,  parameter;\n   Opcodes contain two flags:  'goto' and 'test.'  The\
    \ PME maintains a\n   Boolean indicator called the 'test indicator,' which is\
    \ initially set\n   (on).  Execution begins with rule 1, the first in the rule\
    \ set.  It\n   proceeds as follows:\n   If the test indicator is on:\n      Perform\
    \ the test, i.e. AND the attribute value with the\n         mask and compare it\
    \ with the value.\n      If these are equal the test has succeeded; perform the\n\
    \         rule's action (below).\n      If the test fails execute the next rule\
    \ in the rule set.\n      If there are no more rules in the rule set, return from\
    \ the\n         match() function indicating failure.\n   If the test indicator\
    \ is off, or the test (above) succeeded:\n      Set the test indicator to this\
    \ rule's test flag value.\n      Determine the next rule to execute.\n       \
    \  If the opcode has its goto flag set, its parameter value\n            specifies\
    \ the number of the next rule.\n         Opcodes which don't have their goto flags\
    \ set either\n            determine the next rule in special ways (Return),\n\
    \            or they terminate execution (Ignore, Fail, Count,\n            CountPkt).\n\
    \      Perform the action.\n   The PME maintains two 'history' data structures.\
    \  The first, the\n   'return' stack, simply records the index (i.e.  1-origin\
    \ rule number)\n   of each Gosub rule as it is executed; Return rules pop their\
    \ Gosub\n   rule index.  The second, the 'pattern' queue, is used to save\n  \
    \ information for later use in building a flow key.  A flow key is\n   built by\
    \ zeroing all its attribute values, then copying attribute and\n   mask information\
    \ from the pattern stack in the order it was enqueued.\n   The opcodes are:\n\
    \         opcode         goto    test\n      1  Ignore           0       -\n \
    \     2  Fail             0       -\n      3  Count            0       -\n   \
    \   4  CountPkt         0       -\n      5  Return           0       0\n     \
    \ 6  Gosub            1       1\n      7  GosubAct         1       0\n      8\
    \  Assign           1       1\n      9  AssignAct        1       0\n     10  Goto\
    \             1       1\n     11  GotoAct          1       0\n     12  PushRuleTo\
    \       1       1\n     13  PushRuleToAct    1       0\n     14  PushPktTo   \
    \     1       1\n     15  PushPktToAct     1       0\n   The actions they perform\
    \ are:\n   Ignore:         Stop matching, return from the match() function\n \
    \                  indicating that the packet is to be ignored.\n   Fail:    \
    \       Stop matching, return from the match() function\n                   indicating\
    \ failure.\n   Count:          Stop matching.  Save this rule's attribute name,\n\
    \                   mask and value in the PME's pattern queue, then\n        \
    \           construct a flow key for the flow to which this\n                \
    \   this packet belongs.  Return from the match()\n                   function\
    \ indicating success.  The meter will use\n                   the flow key to\
    \ locate the flow record for this\n                   packet's flow.\n   CountPkt:\
    \       As for Count, except that the masked value from\n                   the\
    \ packet is saved in the PME's pattern queue\n                   instead of the\
    \ rule's value.\n   Gosub:          Call a rule-matching subroutine.  Push the\
    \ current\n                   rule number on the PME's return stack, set the\n\
    \                   test indicator then goto the specified rule.\n   GosubAct:\
    \       Same as Gosub, except that the test indicator is\n                   cleared\
    \ before going to the specified rule.\n   Return:         Return from a rule-matching\
    \ subroutine.  Pop the\n                   number of the calling gosub rule from\
    \ the PME's\n                   'return' stack and add this rule's parameter value\n\
    \                   to it to determine the 'target' rule.  Clear the\n       \
    \            test indicator then goto the target rule.\n                   A subroutine\
    \ call appears in a rule set as a Gosub\n                   rule followed by a\
    \ small group of following rules.\n                   Since a Return action clears\
    \ the test flag, the\n                   action of one of these 'following' rules\
    \ will be\n                   executed; this allows the subroutine to return a\n\
    \                   result (in addition to any information it may save\n     \
    \              in the PME's pattern queue).\n   Assign:         Set the attribute\
    \ specified in this rule to the\n                   value specified in this rule.\
    \  Set the test\n                   indicator then goto the specified rule.\n\
    \   AssignAct:      Same as Assign, except that the test indicator\n         \
    \          is cleared before going to the specified rule.\n   Goto:          \
    \ Set the test indicator then goto the\n                   specified rule.\n \
    \  GotoAct:        Clear the test indicator then goto the specified\n        \
    \           rule.\n   PushRuleTo:     Save this rule's attribute name, mask and\
    \ value\n                   in the PME's pattern queue. Set the test\n       \
    \            indicator then goto the specified rule.\n   PushRuleToAct:  Same\
    \ as PushRuleTo, except that the test indicator\n                   is cleared\
    \ before going to the specified rule.\n                   PushRuleTo actions may\
    \ be used to save the value\n                   and mask used in a test, or (if\
    \ the test is not\n                   performed) to save an arbitrary value and\
    \ mask.\n   PushPktTo:      Save this rule's attribute name, mask, together\n\
    \                   with the masked value from the packet, in the\n          \
    \         PME's pattern queue.  SET the test indicator then\n                \
    \   goto the specified rule.\n   PushPktToAct:   Same as PushPktTo, except that\
    \ the test indicator\n                   is cleared before going to the specified\
    \ rule.\n                   PushPktTo actions may be used to save a value from\n\
    \                   the packet using a specified mask.  The test in\n        \
    \           PushPktTo rules will almost never be executed.\n   As well as the\
    \ attributes applying directly to packets (such as\n   SourcePeerAddress, DestTransAddress,\
    \ etc.)  the PME implements\n   several further attribtes.  These are:\n   Null:\
    \       Tests performed on the Null attribute always succeed.\n   v1 .. v5:  \
    \ v1, v2, v3, v4 and v5 are 'meter variables.'  They\n               provide a\
    \ way to pass parameters into rule-matching\n               subroutines.  Each\
    \ may hold the name of a normal\n               attribute; its value is set by\
    \ an Assign action.\n               When a meter variable appears as the attribute\
    \ of a\n               rule, its value specifies the actual attribute to be\n\
    \               tested.  For example, if v1 had been assigned\n              \
    \ SourcePeerAddress as its value, a rule with v1 as its\n               attribute\
    \ would actually test SourcePeerAddress.\n   SourceClass, DestClass, FlowClass,\n\
    \   SourceKind, DestKind, FlowKind:\n               These six attributes may be\
    \ set by executing PushRuleto\n               actions.  They allow the PME to\
    \ save (in flow records)\n               information which has been built up during\
    \ matching.\n               Since their values are only defined when matching\
    \ is\n               complete (and the flow key is built) their values may\n \
    \              not be tested in rules.\n"
- title: 4.5 Maintaining the Flow Table
  contents:
  - "4.5 Maintaining the Flow Table\n   The flow table may be thought of as a 1-origin\
    \ array of flow records.\n   (A particular implementation may, of course, use\
    \ whatever data\n   structure is most suitable).  When the meter starts up there\
    \ are no\n   known flows; all the flow records are in the 'inactive' state.\n\
    \   Each time a packet is seen for a flow which is not in the current\n   flow\
    \ set a flow record is set up for it; the state of such a record\n   is 'current.'\
    \  When selecting a record for the new flow the meter\n   searches the flow table\
    \ for a 'inactive' record - there is no\n   particular significance in the ordering\
    \ of records within the table.\n   Flow data may be collected by a 'meter reader'\
    \ at any time.  There is\n   no requirement for collections to be synchronized.\
    \  The reader may\n   collect the data in any suitable manner, for example it\
    \ could upload\n   a copy of the whole flow table using a file transfer protocol,\
    \ or it\n   could read the records in the current flow set row by row using a\n\
    \   suitable data transfer protocol.\n   The meter keeps information about collections,\
    \ in particular it\n   maintains a LastCollectTime variable which remembers the\
    \ time the\n   last collection was made.  A second variable, InactivityTime,\n\
    \   specifies the minimum time the meter will wait before considering\n   that\
    \ a flow is idle.\n   The meter must recover records used for idle flows, if only\
    \ to\n   prevent it running out of flow records.  Recovered flow records are\n\
    \   returned to the 'inactive' state.  A variety of recovery strategies\n   are\
    \ possible, including the following:\n   One possible recovery strategy is to\
    \ recover idle flow records as\n   soon as possible after their data has been\
    \ collected.  To implement\n   this the meter could run a background process which\
    \ scans the flow\n   table looking for 'current' flows whose 'last packet' time\
    \ is earlier\n   than the meter's LastCollectTime.  This would be suitable for\
    \ use\n   when one was interested in measuring flow lifetimes.\n   Another recovery\
    \ strategy is to leave idle flows alone as long as\n   possible, which would be\
    \ suitable if one was only interested in\n   measuring total traffic volumes.\
    \  It could be implemented by having\n   the meter search for collected idle flows\
    \ only when it ran out of\n   'inactive' flow records.\n   One further factor\
    \ a meter should consider before recovering a flow\n   is the number of meter\
    \ readers which have collected the flow's data.\n   If there are multiple meter\
    \ readers operating, network Operations\n   personnel should be able to specify\
    \ the minimum number of meters - or\n   perhaps a specific list of meters - which\
    \ should collect a flow's\n   data before its memory can be recovered.  This issue\
    \ will be further\n   developed in the future.\n"
- title: 4.6 Handling Increasing Traffic Levels
  contents:
  - "4.6 Handling Increasing Traffic Levels\n   Under normal conditions the meter\
    \ reader specifies which set of usage\n   records it wants to collect, and the\
    \ meter provides them.\n   If memory usage rises above the high-water mark the\
    \ meter should\n   switch to a STANDBY RULE SET so as to increase the granularity\
    \ of\n   flow collection and decrease the rate at which new flows are created.\n\
    \   When the manager, usually as part of a regular poll, becomes aware\n   that\
    \ the meter is using its standby rule set, it could decrease the\n   interval\
    \ between collections.  The meter should also increase its\n   efforts to recover\
    \ flow memory so as to reduce the number of idle\n   flows in memory.  When the\
    \ situation returns to normal, the manager\n   may request the meter to switch\
    \ back to its normal rule set.\n"
- title: 5 Meter Readers
  contents:
  - "5 Meter Readers\n   Usage data is accumulated by a meter (e.g.  in a router)\
    \ as memory\n   permits.  It is collected at regular reporting intervals by meter\n\
    \   readers, as specified by a manager.  The collected data is recorded\n   in\
    \ a disk file called a FLOW DATA FILE, as a sequence of USAGE\n   RECORDS.\n \
    \  The following sections describe the contents of usage records and\n   flow\
    \ data files.  Note, however, that at this stage the details of\n   such records\
    \ and files is not specified in the architecture.\n   Specifying a common format\
    \ for them would be a worthwhile future\n   development.\n"
- title: 5.1 Identifying Flows in Flow Records
  contents:
  - "5.1 Identifying Flows in Flow Records\n   Once a packet has been classified and\
    \ is ready to be counted, an\n   appropriate flow data record must already exist\
    \ in the flow table;\n   otherwise one must be created.  The flow record has a\
    \ flexible format\n   where unnecessary identification attributes may be omitted.\
    \  The\n   determination of which attributes of the flow record to use, and of\n\
    \   what values to put in them, is specified by the current rule set.\n   Note\
    \ that the combination of start time, rule set id and subscript\n   (row number\
    \ in the flow table) provide a unique flow identifier,\n   regardless of the values\
    \ of its other attributes.\n   The current rule set may specify additional information,\
    \ e.g.  a\n   computed attribute value such as FlowKind, which is to be placed\
    \ in\n   the attribute section of the usage record.  That is, if a particular\n\
    \   flow is matched by the rule set, then the corresponding flow record\n   should\
    \ be marked not only with the qualifying identification\n   attributes, but also\
    \ with the additional information.  Using this\n   feature, several flows may\
    \ each carry the same FlowKind value, so\n   that the resulting usage records\
    \ can be used in post-processing or\n   between meter reader and meter as a criterion\
    \ for collection.\n"
- title: 5.2 Usage Records, Flow Data Files
  contents:
  - "5.2 Usage Records, Flow Data Files\n   The collected usage data will be stored\
    \ in flow data files on the\n   meter reader, one file for each meter.  As well\
    \ as containing the\n   measured usage data, flow data files must contain information\n\
    \   uniquely identifiying the meter from which it was collected.\n   A USAGE RECORD\
    \ contains the descriptions of and values for one or\n   more flows.  Quantities\
    \ are counted in terms of number of packets and\n   number of bytes per flow.\
    \  Each usage record contains the entity\n   identifier of the meter (a network\
    \ address), a time stamp and a list\n   of reported flows (FLOW DATA RECORDS).\
    \ A meter reader will build up a\n   file of usage records by regularly collecting\
    \ flow data from a meter,\n   using this data to build usage records and concatenating\
    \ them to the\n   tail of a file.  Such a file is called a FLOW DATA FILE.\n \
    \  A usage record contains the following information in some form:\n   +-------------------------------------------------------------------+\n\
    \   |    RECORD IDENTIFIERS:                                            |\n  \
    \ |      Meter Id (& digital signature if required)                   |\n   |\
    \      Timestamp                                                    |\n   |  \
    \    Collection Rules ID                                          |\n   +-------------------------------------------------------------------+\n\
    \   |    FLOW IDENTIFIERS:            |    COUNTERS                     |\n  \
    \ |      Address List               |       Packet Count              |\n   |\
    \      Subscriber ID (Optional)   |       Byte Count                |\n   |  \
    \    Attributes (Optional)      |    Flow Start/Stop Time         |\n   +-------------------------------------------------------------------+\n"
- title: '5.3 Meter to Meter Reader:  Usage Record Transmission'
  contents:
  - "5.3 Meter to Meter Reader:  Usage Record Transmission\n   The usage record contents\
    \ are the raison d'etre of the system.  The\n   accuracy, reliability, and security\
    \ of transmission are the primary\n   concerns of the meter/meter reader exchange.\
    \  Since errors may occur\n   on networks, and Internet packets may be dropped,\
    \ some mechanism for\n   ensuring that the usage information is transmitted intact\
    \ is needed.\n   Flow data is moved from meter to meter reader via a series of\n\
    \   protocol exchanges between them.  This may be carried out in various\n   ways,\
    \ moving individual attribute values, complete flows, or the\n   entire flow table\
    \ (i.e.  all the active flows).  One possible method\n   of achieving this transfer\
    \ is to use SNMP; the 'Traffic Flow\n   Measurement:  Meter MIB' document [4]\
    \ gives details.  Note that this\n   is simply one example; the transfer of flow\
    \ data from meter to meter\n   reader is not specified in this document.\n   The\
    \ reliability of the data transfer method under light, normal, and\n   extreme\
    \ network loads should be understood before selecting among\n   collection methods.\n\
    \   In normal operation the meter will be running a rule file which\n   provides\
    \ the required degree of flow reporting granularity, and the\n   meter reader(s)\
    \ will collect the flow data often enough to allow the\n   meter's garbage collection\
    \ mechanism to maintain a stable level of\n   memory usage.\n   In the worst case\
    \ traffic may increase to the point where the meter\n   is in danger of running\
    \ completely out of flow memory.  The meter\n   implementor must decide how to\
    \ handle this, for example by switching\n   to a default (extremely coarse granularity)\
    \ rule set, by sending a\n   trap to the manager, or by attempting to dump flow\
    \ data to the meter\n   reader.\n   Users of the Traffic Flow Measurement system\
    \ should analyse their\n   requirements carefully and assess for themselves whether\
    \ it is more\n   important to attempt to collect flow data at normal granularity\n\
    \   (increasing the collection frequency as needed to keep up with\n   traffic\
    \ volumes), or to accept flow data with a coarser granularity.\n   Similarly,\
    \ it may be acceptable to lose flow data for a short time in\n   return for being\
    \ sure that the meter keeps running properly, i.e.  is\n   not overwhelmed by\
    \ rising traffic levels.\n"
- title: 6 Managers
  contents:
  - "6 Managers\n   A manager configures meters and controls meter readers.  It does\
    \ this\n   via the interactions described below.\n"
- title: '6.1 Between Manager and Meter:  Control Functions'
  contents:
  - "6.1 Between Manager and Meter:  Control Functions\n  - DOWNLOAD RULE SET: A meter\
    \ may hold an array of rule sets.  One of\n    these, the 'default' rule set,\
    \ is built in to the meter and cannot\n    be changed; the others must be downloaded\
    \ by the manager.  A\n    manager may use any suitable protocol exchange to achieve\
    \ this, for\n    example an FTP file transfer or a series of SNMP SETs, one for\
    \ each\n    row of the rule set.\n  - SWITCH TO SPECIFIED RULE SET: Once the rule\
    \ sets have been\n    downloaded, the manager must instruct the meter which rule\
    \ set it\n    is to actually run (i.e.  which is to be the current rule set),\
    \ and\n    which is to be the standby rule set.\n  - SET HIGH WATER MARK: A percentage\
    \ value interpreted by the meter\n    which tells the meter when to switch to\
    \ its standby rule set, so as\n    to increase the granularity of the flows and\
    \ conserve the meter's\n    flow memory.  Once this has happened, the manager\
    \ may also change\n    the polling frequency or the meter's control parameters\
    \ (so as to\n    increase the rate at which the meter can recover memory from\
    \ idle\n    flows).\n    If the high traffic levels persist, the meter's normal\
    \ rule set may\n    have to be rewritten to permanently reduce the reporting\n\
    \    granularity.\n  - SET FLOW TERMINATION PARAMETERS: The meter should have\
    \ the good\n    sense in situations where lack of resources may cause data loss\
    \ to\n    purge flow records from its tables.  Such records may include:\n   \
    \   -  Flows that have already been reported to at least one meter\n         reader,\
    \ and show no activity since the last report,\n      -  Oldest flows, or\n   \
    \   -  Flows with the smallest number of unreported packets.\n  - SET INACTIVITY\
    \ TIMEOUT: This is a time in seconds since the last\n    packet was seen for a\
    \ flow.  Flow records may be reclaimed if they\n    have been idle for at least\
    \ this amount of time, and have been\n    collected in accordance with the current\
    \ collection criteria.\n"
- title: '6.2 Between Manager and Meter Reader:  Control Functions'
  contents:
  - "6.2 Between Manager and Meter Reader:  Control Functions\n   Because there are\
    \ a number of parameters that must be set for traffic\n   flow measurement to\
    \ function properly, and viable settings may change\n   as a result of network\
    \ traffic characteristics, it is desirable to\n   have dynamic network management\
    \ as opposed to static meter\n   configurations.  Many of these operations have\
    \ to do with space\n   tradeoffs - if memory at the meter is exhausted, either\
    \ the reporting\n   interval must be decreased or a coarser granularity of aggregation\n\
    \   must be used so that more data fits into less space.\n   Increasing the reporting\
    \ interval effectively stores data in the\n   meter; usage data in transit is\
    \ limited by the effective bandwidth of\n   the virtual link between the meter\
    \ and the meter reader, and since\n   these limited network resources are usually\
    \ also used to carry user\n   data (the purpose of the network), the level of\
    \ traffic flow\n   measurement traffic should be kept to an affordable fraction\
    \ of the\n   bandwidth.  (\"Affordable\" is a policy decision made by the network\n\
    \   Operations personnel).  At any rate, it must be understood that the\n   operations\
    \ below do not represent the setting of independent\n   variables; on the contrary,\
    \ each of the values set has a direct and\n   measurable effect on the behaviour\
    \ of the other variables.\n   Network management operations follow:\n  - MANAGER\
    \ and METER READER IDENTIFICATION: The manager should ensure\n    that meters\
    \ report to the correct set of collection stations, and\n    take steps to prevent\
    \ unauthorised access to usage information.\n    The collection stations so identified\
    \ should be prepared to poll if\n    necessary and accept data from the appropriate\
    \ meters.  Alternate\n    collection stations may be identified in case both the\
    \ primary\n    manager and the primary collection station are unavailable.\n \
    \   Similarly, alternate managers may be identified.\n  - REPORTING INTERVAL CONTROL:\
    \ The usual reporting interval should be\n    selected to cope with normal traffic\
    \ patterns.  However, it may be\n    possible for a meter to exhaust its memory\
    \ during traffic spikes\n    even with a correctly set reporting interval.  Some\
    \ mechanism must\n    be available for the meter to tell the manager that it is\
    \ in danger\n    of exhausting its memory (by declaring a 'high water' condition),\n\
    \    and for the manager to arbitrate (by decreasing the polling\n    interval,\
    \ letting nature take its course, or by telling the meter\n    to ask for help\
    \ sooner next time).\n  - GRANULARITY CONTROL: Granularity control is a catch-all\
    \ for all the\n    parameters that can be tuned and traded to optimise the system's\n\
    \    ability to reliably measure and store information on all the\n    traffic\
    \ (or as close to all the traffic as an administration\n    requires).  Granularity\n\
    \      -  Controls flow-id granularities for each interface, and\n      -  Determines\
    \ the number of buckets into which user traffic will\n         be lumped together.\n\
    \    Since granularity is controlled by the meter's current rule set,\n    the\
    \ manager can only change it by requesting the meter to switch to\n    a different\
    \ rule set.  The new rule set could be downloaded when\n    required, or it could\
    \ have been downloaded as part of the meter's\n    initial configuration.\n  -\
    \ FLOW LIFETIME CONTROL: Flow termination parameters include timeout\n    parameters\
    \ for obsoleting inactive flows and removing them from\n    tables and maximum\
    \ flow lifetimes.  This is intertwined with\n    reporting interval and granularity,\
    \ and must be set in accordance\n    with the other parameters.\n"
- title: 6.3 Exception Conditions
  contents:
  - "6.3 Exception Conditions\n   Exception conditions must be handled, particularly\
    \ occasions when the\n   meter runs out of buffer space.  Since, to prevent counting\
    \ any\n   packet twice, packets can only be counted in a single flow at any\n\
    \   given time, discarding records will result in the loss of\n   information.\
    \  The mechanisms to deal with this are as follows:\n  - METER OUTAGES: In case\
    \ of impending meter outages (controlled\n    crashes, etc.)  the meter could\
    \ send a trap to the manager.  The\n    manager could then request one or more\
    \ meter readers to pick up the\n    usage record from the meter.\n    Following\
    \ an uncontrolled meter outage such as a power failure, the\n    meter could send\
    \ a trap to the manager indicating that it has\n    restarted.  The manager could\
    \ then download the meter's correct\n    rule set and advise the meter reader(s)\
    \ that the meter is running\n    again.  Alternatively, the meter reader may discover\
    \ from its\n    regular poll that a meter has failed and restarted.  It could\
    \ then\n    advise the manager of this, instead of relying on a trap from the\n\
    \    meter.\n  - METER READER OUTAGES: If the collection system is down or isolated,\n\
    \    the meter should try to inform the manager of its failure to\n    communicate\
    \ with the collection system.  Usage data is maintained\n    in the flows' rolling\
    \ counters, and can be recovered when the meter\n    reader is restarted.\n  -\
    \ MANAGER OUTAGES: If the manager fails for any reason, the meter\n    should\
    \ continue measuring and the meter reader(s) should keep\n    gathering usage\
    \ records.\n  - BUFFER PROBLEMS: The network manager may realise that there is\
    \ a\n    'low memory' condition in the meter.  This can usually be\n    attributed\
    \ to the interaction between the following controls:\n      -  The reporting interval\
    \ is too infrequent,\n      -  The reporting granularity is too fine, or\n   \
    \   -  The throughput/bandwidth of circuits carrying the usage\n         data\
    \ is too low.\n    The manager may change any of these parameters in response\
    \ to the\n    meter (or meter reader's) plea for help.\n"
- title: 6.4 Standard Rule Sets
  contents:
  - "6.4 Standard Rule Sets\n   Although the rule table is a flexible tool, it can\
    \ also become very\n   complex.  It may be helpful to develop some rule sets for\
    \ common\n   applications:\n  - PROTOCOL TYPE: The meter records packets by protocol\
    \ type.  This\n    will be the default rule table for Traffic Flow Meters.\n \
    \ - ADJACENT SYSTEMS: The meter records packets by the MAC address of\n    the\
    \ Adjacent Systems (neighbouring originator or next-hop).\n    (Variants on this\
    \ table are \"report source\" or \"report sink\" only.)\n    This strategy might\
    \ be used by a regional or backbone network which\n    wants to know how much\
    \ aggregate traffic flows to or from its\n    subscriber networks.\n  - END SYSTEMS:\
    \ The meter records packets by the IP address pair\n    contained in the packet.\
    \  (Variants on this table are \"report\n    source\" or \"report sink\" only.)\
    \  This strategy might be used by an\n    End System network to get detailed host\
    \ traffic matrix usage data.\n  - TRANSPORT TYPE: The meter records packets by\
    \ transport address; for\n    IP packets this provides usage information for the\
    \ various IP\n    services.\n  - HYBRID SYSTEMS: Combinations of the above, e.g.\
    \  for one interface\n    report End Systems, for another interface report Adjacent\
    \ Systems.\n    This strategy might be used by an enterprise network to learn\n\
    \    detail about local usage and use an aggregate count for the shared\n    regional\
    \ network.\n"
- title: 7 APPENDICES
  contents:
  - '7 APPENDICES

    '
- title: '7.1 Appendix A: Network Characterisation'
  contents:
  - "7.1 Appendix A: Network Characterisation\n   Internet users have extraordinarily\
    \ diverse requirements.  Networks\n   differ in size, speed, throughput, and processing\
    \ power, among other\n   factors.  There is a range of traffic flow measurement\
    \ capabilities\n   and requirements.  For traffic flow measurement purposes, the\n\
    \   Internet may be viewed as a continuum which changes in character as\n   traffic\
    \ passes through the following representative levels:\n        International \
    \                   |\n        Backbones/National        ---------------\n   \
    \                              /              \\\n        Regional/MidLevel  \
    \   ----------   ----------\n                             /   \\     \\  /   /\
    \     \\\n        Stub/Enterprise     ---   ---   ---   ----   ----\n        \
    \                    |||   |||   |||   ||||   ||||\n        End-Systems/Hosts\
    \   xxx   xxx   xxx   xxxx   xxxx\n   Note that mesh architectures can also be\
    \ built out of these\n   components, and that these are merely descriptive terms.\
    \  The nature\n   of a single network may encompass any or all of the descriptions\n\
    \   below, although some networks can be clearly identified as a single\n   type.\n\
    \   BACKBONE networks are typically bulk carriers that connect other\n   networks.\
    \  Individual hosts (with the exception of network management\n   devices and\
    \ backbone service hosts) typically are not directly\n   connected to backbones.\n\
    \   REGIONAL networks are closely related to backbones, and differ only\n   in\
    \ size, the number of networks connected via each port, and\n   geographical coverage.\
    \  Regionals may have directly connected hosts,\n   acting as hybrid backbone/stub\
    \ networks.  A regional network is a\n   SUBSCRIBER to the backbone.\n   STUB/ENTERPRISE\
    \ networks connect hosts and local area networks.\n   STUB/ENTERPRISE networks\
    \ are SUBSCRIBERS to regional and backbone\n   networks.\n   END SYSTEMS, colloquially\
    \ HOSTS, are SUBSCRIBERS to any of the above\n   networks.\n   Providing a uniform\
    \ identification of the SUBSCRIBER in finer\n   granularity than that of end-system,\
    \ (e.g.  user/account), is beyond\n   the scope of the current architecture, although\
    \ an optional attribute\n   in the traffic flow measurement record may carry system-specific\n\
    \   \"accountable (billable) party\" labels so that meters can implement\n   proprietary\
    \ or non-standard schemes for the attribution of network\n   traffic to responsible\
    \ parties.\n"
- title: '7.2 Appendix B: Recommended Traffic Flow Measurement Capabilities'
  contents:
  - "7.2 Appendix B: Recommended Traffic Flow Measurement Capabilities\n   Initial\
    \ recommended traffic flow measurement conventions are outlined\n   here according\
    \ to the following Internet building blocks.  It is\n   important to understand\
    \ what complexity reporting introduces at each\n   network level.  Whereas the\
    \ hierarchy is described top-down in the\n   previous section, reporting requirements\
    \ are more easily addressed\n   bottom-up.\n        End-Systems\n        Stub\
    \ Networks\n        Enterprise Networks\n        Regional Networks\n        Backbone\
    \ Networks\n   END-SYSTEMS are currently responsible for allocating network usage\
    \ to\n   end-users, if this capability is desired.  From the Internet Protocol\n\
    \   perspective, end-systems are the finest granularity that can be\n   identified\
    \ without protocol modifications.  Even if a meter violated\n   protocol boundaries\
    \ and tracked higher-level protocols, not all\n   packets could be correctly allocated\
    \ by user, and the definition of\n   user itself varies too widely from operating\
    \ system to operating\n   system (e.g.  how to trace network usage back to users\
    \ from shared\n   processes).\n   STUB and ENTERPRISE networks will usually collect\
    \ traffic data either\n   by end- system network address or network address pair\
    \ if detailed\n   reporting is required in the local area network.  If no local\n\
    \   reporting is required, they may record usage information in the exit\n   router\
    \ to track external traffic only.  (These are the only networks\n   which routinely\
    \ use attributes to perform reporting at granularities\n   finer than end-system\
    \ or intermediate-system network address.)\n   REGIONAL networks are intermediate\
    \ networks.  In some cases,\n   subscribers will be enterprise networks, in which\
    \ case the\n   intermediate system network address is sufficient to identify the\n\
    \   regional's immediate subscriber.  In other cases, individual hosts or\n  \
    \ a disjoint group of hosts may constitute a subscriber.  Then end-\n   system\
    \ network address pairs need to be tracked for those\n   subscribers.  When the\
    \ source may be an aggregate entity (such as a\n   network, or adjacent router\
    \ representing traffic from a world of\n   hosts beyond) and the destination is\
    \ a singular entity (or vice\n   versa), the meter is said to be operating as\
    \ a HYBRID system.\n   At the regional level, if the overhead is tolerable it\
    \ may be\n   advantageous to report usage both by intermediate system network\n\
    \   address (e.g.  adjacent router address) and by end-system network\n   address\
    \ or end-system network address pair.\n   BACKBONE networks are the highest level\
    \ networks operating at higher\n   link speeds and traffic levels.  The high volume\
    \ of traffic will in\n   most cases preclude detailed traffic flow measurement.\
    \  Backbone\n   networks will usually account for traffic by adjacent routers'\n\
    \   network addresses.\n"
- title: '7.3 Appendix C: List of Defined Flow Attributes'
  contents:
  - "7.3 Appendix C: List of Defined Flow Attributes\n   This Appendix provides a\
    \ checklist of the attributes defined to date;\n   others will be added later\
    \ as the Traffic Measurement Architecture is\n   further developed.\n   0  Null\n\
    \   1  Flow Subscript                Integer    Flow table info\n   2  Flow Status\
    \                   Integer\n   4  Source Interface              Integer    Source\
    \ Address\n   5  Source Adjacent Type          Integer\n   6  Source Adjacent\
    \ Address       String\n   7  Source Adjacent Mask          String\n   8  Source\
    \ Peer Type              Integer\n   9  Source Peer Address           String\n\
    \  10  Source Peer Mask              String\n  11  Source Trans Type         \
    \    Integer\n  12  Source Trans Address          String\n  13  Source Trans Mask\
    \             String\n  14  Destination Interface         Integer    Destination\
    \ Address\n  15  Destination Adjacent Type     Integer\n  16  Destination Adjacent\
    \ Address  String\n  17  Destination AdjacentMask      String\n  18  Destination\
    \ PeerType          Integer\n  19  Destination PeerAddress       String\n  20\
    \  Destination PeerMask          String\n  21  Destination TransType         Integer\n\
    \  22  Destination TransAddress      String\n  23  Destination TransMask     \
    \    String\n  24  Packet Scale Factor           Integer    'Other' attributes\n\
    \  25  Byte Scale Factor             Integer\n  26  Rule Set Number          \
    \     Integer\n  27  Forward Bytes                 Counter    Source-to-Dest counters\n\
    \  28  Forward Packets               Counter\n  29  Reverse Bytes            \
    \     Counter    Dest-to-Source counters\n  30  Reverse Packets              \
    \ Counter\n  31  First Time                    TimeTicks  Activity times\n  32\
    \  Last Active Time              TimeTicks\n  33  Source Subscriber ID       \
    \   String     Session attributes\n  34  Destination Subscriber ID     String\n\
    \  35  Session ID                    String\n  36  Source Class              \
    \    Integer    'Computed' attributes\n  37  Destination Class             Integer\n\
    \  38  Flow Class                    Integer\n  39  Source Kind              \
    \     Integer\n  40  Destination Kind              Integer\n  41  Flow Kind  \
    \                   Integer\n  51  V1                            Integer    Meter\
    \ variables\n  52  V2                            Integer\n  53  V3           \
    \                 Integer\n  54  V4                            Integer\n  55 \
    \ V5                            Integer\n"
- title: '7.4 Appendix D: List of Meter Control Variables'
  contents:
  - "7.4 Appendix D: List of Meter Control Variables\n      Current Rule Set Number\
    \       Integer\n      Standby Rule Set Number       Integer\n      High Water\
    \ Mark               Percentage\n      Flood Mark                    Percentage\n\
    \      Inactivity Timeout (seconds)  Integer\n      Last Collect Time        \
    \     TimeTicks\n"
- title: 8 Acknowledgments
  contents:
  - "8 Acknowledgments\n   This document was initially produced under the auspices\
    \ of the IETF's\n   Internet Accounting Working Group with assistance from SNMP,\
    \ RMON and\n   SAAG working groups.  This version documents the implementation\
    \ work\n   done by the Internet Accounting Working Group, and is intended to\n\
    \   provide a starting point for the Realtime Traffic Flow Measurement\n   Working\
    \ Group.  Particular thanks are due to Stephen Stibler (IBM\n   Research) for\
    \ his patient and careful comments during the preparation\n   of this memo.\n"
- title: 9 References
  contents:
  - "9 References\n   [1] Mills, C., Hirsch, G. and G. Ruth, \"Internet Accounting\n\
    \   Background\", RFC 1272, Bolt Beranek and Newman Inc., Meridian\n   Technology\
    \ Corporation, November 1991.\n   [2] International Standards Organisation (ISO),\
    \ \"Management\n   Framework,\" Part 4 of Information Processing Systems Open\n\
    \   Systems Interconnection Basic Reference Model, ISO 7498-4,\n   1994.\n   [3]\
    \ IEEE 802.3/ISO 8802-3 Information Processing Systems -\n   Local Area Networks\
    \ - Part 3:  Carrier sense multiple access\n   with collision detection (CSMA/CD)\
    \ access method and physical\n   layer specifications, 2nd edition, September\
    \ 21, 1990.\n   [4] Brownlee, N., \"Traffic Flow Measurement:  Meter MIB\",\n\
    \   RFC 2064, The University of Auckland, January 1997.\n"
- title: 10 Security Considerations
  contents:
  - "10 Security Considerations\n   Security issues are not discussed in detail in\
    \ this document.  The\n   meter's management and collection protocols are responsible\
    \ for\n   providing sufficient data integrity and confidentiality.\n"
- title: 11 Authors' Addresses
  contents:
  - "11 Authors' Addresses\n   Nevil Brownlee\n   Information Technology Systems &\
    \ Services\n   The University of Auckland\n   Phone: +64 9 373 7599 x8941\n  \
    \ EMail: n.brownlee @auckland.ac.nz\n   Cyndi Mills\n   BBN Systems and Technologies\n\
    \   Phone: +1 617 873 4143\n   EMail: cmills@bbn.com\n   Greg Ruth\n   GTE Laboratories,\
    \ Inc\n   Phone: +1 617 466 2448\n   EMail: gruth@gte.com\n"
