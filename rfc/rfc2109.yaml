- title: __initial_text__
  contents:
  - '                    HTTP State Management Mechanism

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: 1.  ABSTRACT
  contents:
  - "1.  ABSTRACT\n   This document specifies a way to create a stateful session with\
    \ HTTP\n   requests and responses.  It describes two new headers, Cookie and\n\
    \   Set-Cookie, which carry state information between participating\n   origin\
    \ servers and user agents.  The method described here differs\n   from Netscape's\
    \ Cookie proposal, but it can interoperate with\n   HTTP/1.0 user agents that\
    \ use Netscape's method.  (See the HISTORICAL\n   section.)\n"
- title: 2.  TERMINOLOGY
  contents:
  - "2.  TERMINOLOGY\n   The terms user agent, client, server, proxy, and origin server\
    \ have\n   the same meaning as in the HTTP/1.0 specification.\n   Fully-qualified\
    \ host name (FQHN) means either the fully-qualified\n   domain name (FQDN) of\
    \ a host (i.e., a completely specified domain\n   name ending in a top-level domain\
    \ such as .com or .uk), or the\n   numeric Internet Protocol (IP) address of a\
    \ host.  The fully\n   qualified domain name is preferred; use of numeric IP addresses\
    \ is\n   strongly discouraged.\n   The terms request-host and request-URI refer\
    \ to the values the client\n   would send to the server as, respectively, the\
    \ host (but not port)\n   and abs_path portions of the absoluteURI (http_URL)\
    \ of the HTTP\n   request line.  Note that request-host must be a FQHN.\n   Hosts\
    \ names can be specified either as an IP address or a FQHN\n   string.  Sometimes\
    \ we compare one host name with another.  Host A's\n   name domain-matches host\
    \ B's if\n   * both host names are IP addresses and their host name strings match\n\
    \     exactly; or\n   * both host names are FQDN strings and their host name strings\
    \ match\n     exactly; or\n   * A is a FQDN string and has the form NB, where\
    \ N is a non-empty name\n     string, B has the form .B', and B' is a FQDN string.\
    \  (So, x.y.com\n     domain-matches .y.com but not y.com.)\n   Note that domain-match\
    \ is not a commutative operation: a.b.c.com\n   domain-matches .c.com, but not\
    \ the reverse.\n   Because it was used in Netscape's original implementation of\
    \ state\n   management, we will use the term cookie to refer to the state\n  \
    \ information that passes between an origin server and user agent, and\n   that\
    \ gets stored by the user agent.\n"
- title: 3.  STATE AND SESSIONS
  contents:
  - "3.  STATE AND SESSIONS\n   This document describes a way to create stateful sessions\
    \ with HTTP\n   requests and responses.  Currently, HTTP servers respond to each\n\
    \   client request without relating that request to previous or\n   subsequent\
    \ requests; the technique allows clients and servers that\n   wish to exchange\
    \ state information to place HTTP requests and\n   responses within a larger context,\
    \ which we term a \"session\".  This\n   context might be used to create, for\
    \ example, a \"shopping cart\", in\n   which user selections can be aggregated\
    \ before purchase, or a\n   magazine browsing system, in which a user's previous\
    \ reading affects\n   which offerings are presented.\n   There are, of course,\
    \ many different potential contexts and thus many\n   different potential types\
    \ of session.  The designers' paradigm for\n   sessions created by the exchange\
    \ of cookies has these key attributes:\n      1.  Each session has a beginning\
    \ and an end.\n      2.  Each session is relatively short-lived.\n      3.  Either\
    \ the user agent or the origin server may terminate a\n          session.\n  \
    \    4.  The session is implicit in the exchange of state information.\n"
- title: 4.  OUTLINE
  contents:
  - "4.  OUTLINE\n   We outline here a way for an origin server to send state information\n\
    \   to the user agent, and for the user agent to return the state\n   information\
    \ to the origin server.  The goal is to have a minimal\n   impact on HTTP and\
    \ user agents.  Only origin servers that need to\n   maintain sessions would suffer\
    \ any significant impact, and that\n   impact can largely be confined to Common\
    \ Gateway Interface (CGI)\n   programs, unless the server provides more sophisticated\
    \ state\n   management support.  (See Implementation Considerations, below.)\n"
- title: '4.1  Syntax:  General'
  contents:
  - "4.1  Syntax:  General\n   The two state management headers, Set-Cookie and Cookie,\
    \ have common\n   syntactic properties involving attribute-value pairs.  The following\n\
    \   grammar uses the notation, and tokens DIGIT (decimal digits) and\n   token\
    \ (informally, a sequence of non-special, non-white space\n   characters) from\
    \ the HTTP/1.1 specification [RFC 2068] to describe\n   their syntax.\n   av-pairs\
    \        =       av-pair *(\";\" av-pair)\n   av-pair         =       attr [\"\
    =\" value]        ; optional value\n   attr            =       token\n   value\
    \           =       word\n   word            =       token | quoted-string\n \
    \  Attributes (names) (attr) are case-insensitive.  White space is\n   permitted\
    \ between tokens.  Note that while the above syntax\n   description shows value\
    \ as optional, most attrs require them.\n   NOTE: The syntax above allows whitespace\
    \ between the attribute and\n   the = sign.\n"
- title: 4.2  Origin Server Role
  contents:
  - '4.2  Origin Server Role

    '
- title: 4.2.1  General
  contents:
  - "4.2.1  General\n   The origin server initiates a session, if it so desires. \
    \ (Note that\n   \"session\" here does not refer to a persistent network connection\
    \ but\n   to a logical session created from HTTP requests and responses.  The\n\
    \   presence or absence of a persistent connection should have no effect\n   on\
    \ the use of cookie-derived sessions).  To initiate a session, the\n   origin\
    \ server returns an extra response header to the client, Set-\n   Cookie.  (The\
    \ details follow later.)\n   A user agent returns a Cookie request header (see\
    \ below) to the\n   origin server if it chooses to continue a session.  The origin\
    \ server\n   may ignore it or use it to determine the current state of the\n \
    \  session.  It may send back to the client a Set-Cookie response header\n   with\
    \ the same or different information, or it may send no Set-Cookie\n   header at\
    \ all.  The origin server effectively ends a session by\n   sending the client\
    \ a Set-Cookie header with Max-Age=0.\n   Servers may return a Set-Cookie response\
    \ headers with any response.\n   User agents should send Cookie request headers,\
    \ subject to other\n   rules detailed below, with every request.\n   An origin\
    \ server may include multiple Set-Cookie headers in a\n   response.  Note that\
    \ an intervening gateway could fold multiple such\n   headers into a single header.\n"
- title: 4.2.2  Set-Cookie Syntax
  contents:
  - "4.2.2  Set-Cookie Syntax\n   The syntax for the Set-Cookie response header is\n\
    \   set-cookie      =       \"Set-Cookie:\" cookies\n   cookies         =    \
    \   1#cookie\n   cookie          =       NAME \"=\" VALUE *(\";\" cookie-av)\n\
    \   NAME            =       attr\n   VALUE           =       value\n   cookie-av\
    \       =       \"Comment\" \"=\" value\n                   |       \"Domain\"\
    \ \"=\" value\n                   |       \"Max-Age\" \"=\" value\n          \
    \         |       \"Path\" \"=\" value\n                   |       \"Secure\"\n\
    \                   |       \"Version\" \"=\" 1*DIGIT\n   Informally, the Set-Cookie\
    \ response header comprises the token Set-\n   Cookie:, followed by a comma-separated\
    \ list of one or more cookies.\n   Each cookie begins with a NAME=VALUE pair,\
    \ followed by zero or more\n   semi-colon-separated attribute-value pairs.  The\
    \ syntax for\n   attribute-value pairs was shown earlier.  The specific attributes\
    \ and\n   the semantics of their values follows.  The NAME=VALUE attribute-\n\
    \   value pair must come first in each cookie.  The others, if present,\n   can\
    \ occur in any order.  If an attribute appears more than once in a\n   cookie,\
    \ the behavior is undefined.\n   NAME=VALUE\n      Required.  The name of the\
    \ state information (\"cookie\") is NAME,\n      and its value is VALUE.  NAMEs\
    \ that begin with $ are reserved for\n      other uses and must not be used by\
    \ applications.\n      The VALUE is opaque to the user agent and may be anything\
    \ the\n      origin server chooses to send, possibly in a server-selected\n  \
    \    printable ASCII encoding.  \"Opaque\" implies that the content is of\n  \
    \    interest and relevance only to the origin server.  The content\n      may,\
    \ in fact, be readable by anyone that examines the Set-Cookie\n      header.\n\
    \   Comment=comment\n      Optional.  Because cookies can contain private information\
    \ about a\n      user, the Cookie attribute allows an origin server to document\
    \ its\n      intended use of a cookie.  The user can inspect the information to\n\
    \      decide whether to initiate or continue a session with this cookie.\n  \
    \ Domain=domain\n      Optional.  The Domain attribute specifies the domain for\
    \ which the\n      cookie is valid.  An explicitly specified domain must always\
    \ start\n      with a dot.\n   Max-Age=delta-seconds\n      Optional.  The Max-Age\
    \ attribute defines the lifetime of the\n      cookie, in seconds.  The delta-seconds\
    \ value is a decimal non-\n      negative integer.  After delta-seconds seconds\
    \ elapse, the client\n      should discard the cookie.  A value of zero means\
    \ the cookie\n      should be discarded immediately.\n   Path=path\n      Optional.\
    \  The Path attribute specifies the subset of URLs to\n      which this cookie\
    \ applies.\n   Secure\n      Optional.  The Secure attribute (with no value) directs\
    \ the user\n      agent to use only (unspecified) secure means to contact the\
    \ origin\n      server whenever it sends back this cookie.\n      The user agent\
    \ (possibly under the user's control) may determine\n      what level of security\
    \ it considers appropriate for \"secure\"\n      cookies.  The Secure attribute\
    \ should be considered security\n      advice from the server to the user agent,\
    \ indicating that it is in\n      the session's interest to protect the cookie\
    \ contents.\n   Version=version\n      Required.  The Version attribute, a decimal\
    \ integer, identifies to\n      which version of the state management specification\
    \ the cookie\n      conforms.  For this specification, Version=1 applies.\n"
- title: 4.2.3  Controlling Caching
  contents:
  - "4.2.3  Controlling Caching\n   An origin server must be cognizant of the effect\
    \ of possible caching\n   of both the returned resource and the Set-Cookie header.\
    \  Caching\n   \"public\" documents is desirable.  For example, if the origin\
    \ server\n   wants to use a public document such as a \"front door\" page as a\n\
    \   sentinel to indicate the beginning of a session for which a Set-\n   Cookie\
    \ response header must be generated, the page should be stored\n   in caches \"\
    pre-expired\" so that the origin server will see further\n   requests.  \"Private\
    \ documents\", for example those that contain\n   information strictly private\
    \ to a session, should not be cached in\n   shared caches.\n   If the cookie is\
    \ intended for use by a single user, the Set-cookie\n   header should not be cached.\
    \  A Set-cookie header that is intended to\n   be shared by multiple users may\
    \ be cached.\n   The origin server should send the following additional HTTP/1.1\n\
    \   response headers, depending on circumstances:\n   * To suppress caching of\
    \ the Set-Cookie header: Cache-control: no-\n     cache=\"set-cookie\".\n   and\
    \ one of the following:\n   * To suppress caching of a private document in shared\
    \ caches: Cache-\n     control: private.\n   * To allow caching of a document\
    \ and require that it be validated\n     before returning it to the client: Cache-control:\
    \ must-revalidate.\n   * To allow caching of a document, but to require that proxy\
    \ caches\n     (not user agent caches) validate it before returning it to the\n\
    \     client: Cache-control: proxy-revalidate.\n   * To allow caching of a document\
    \ and request that it be validated\n     before returning it to the client (by\
    \ \"pre-expiring\" it):\n     Cache-control: max-age=0.  Not all caches will revalidate\
    \ the\n     document in every case.\n   HTTP/1.1 servers must send Expires: old-date\
    \ (where old-date is a\n   date long in the past) on responses containing Set-Cookie\
    \ response\n   headers unless they know for certain (by out of band means) that\n\
    \   there are no downsteam HTTP/1.0 proxies.  HTTP/1.1 servers may send\n   other\
    \ Cache-Control directives that permit caching by HTTP/1.1\n   proxies in addition\
    \ to the Expires: old-date directive; the Cache-\n   Control directive will override\
    \ the Expires: old-date for HTTP/1.1\n   proxies.\n"
- title: 4.3  User Agent Role
  contents:
  - '4.3  User Agent Role

    '
- title: 4.3.1  Interpreting Set-Cookie
  contents:
  - "4.3.1  Interpreting Set-Cookie\n   The user agent keeps separate track of state\
    \ information that arrives\n   via Set-Cookie response headers from each origin\
    \ server (as\n   distinguished by name or IP address and port).  The user agent\n\
    \   applies these defaults for optional attributes that are missing:\n   VersionDefaults\
    \ to \"old cookie\" behavior as originally specified by\n          Netscape. \
    \ See the HISTORICAL section.\n   Domain Defaults to the request-host.  (Note\
    \ that there is no dot at\n          the beginning of request-host.)\n   Max-AgeThe\
    \ default behavior is to discard the cookie when the user\n          agent exits.\n\
    \   Path   Defaults to the path of the request URL that generated the\n      \
    \    Set-Cookie response, up to, but not including, the\n          right-most\
    \ /.\n   Secure If absent, the user agent may send the cookie over an\n      \
    \    insecure channel.\n"
- title: 4.3.2  Rejecting Cookies
  contents:
  - "4.3.2  Rejecting Cookies\n   To prevent possible security or privacy violations,\
    \ a user agent\n   rejects a cookie (shall not store its information) if any of\
    \ the\n   following is true:\n   * The value for the Path attribute is not a prefix\
    \ of the request-\n     URI.\n   * The value for the Domain attribute contains\
    \ no embedded dots or\n     does not start with a dot.\n   * The value for the\
    \ request-host does not domain-match the Domain\n     attribute.\n   * The request-host\
    \ is a FQDN (not IP address) and has the form HD,\n     where D is the value of\
    \ the Domain attribute, and H is a string\n     that contains one or more dots.\n\
    \   Examples:\n   * A Set-Cookie from request-host y.x.foo.com for Domain=.foo.com\n\
    \     would be rejected, because H is y.x and contains a dot.\n   * A Set-Cookie\
    \ from request-host x.foo.com for Domain=.foo.com would\n     be accepted.\n \
    \  * A Set-Cookie with Domain=.com or Domain=.com., will always be\n     rejected,\
    \ because there is no embedded dot.\n   * A Set-Cookie with Domain=ajax.com will\
    \ be rejected because the\n     value for Domain does not begin with a dot.\n"
- title: 4.3.3  Cookie Management
  contents:
  - "4.3.3  Cookie Management\n   If a user agent receives a Set-Cookie response header\
    \ whose NAME is\n   the same as a pre-existing cookie, and whose Domain and Path\n\
    \   attribute values exactly (string) match those of a pre-existing\n   cookie,\
    \ the new cookie supersedes the old.  However, if the Set-\n   Cookie has a value\
    \ for Max-Age of zero, the (old and new) cookie is\n   discarded.  Otherwise cookies\
    \ accumulate until they expire (resources\n   permitting), at which time they\
    \ are discarded.\n   Because user agents have finite space in which to store cookies,\
    \ they\n   may also discard older cookies to make space for newer ones, using,\n\
    \   for example, a least-recently-used algorithm, along with constraints\n   on\
    \ the maximum number of cookies that each origin server may set.\n   If a Set-Cookie\
    \ response header includes a Comment attribute, the\n   user agent should store\
    \ that information in a human-readable form\n   with the cookie and should display\
    \ the comment text as part of a\n   cookie inspection user interface.\n   User\
    \ agents should allow the user to control cookie destruction.  An\n   infrequently-used\
    \ cookie may function as a \"preferences file\" for\n   network applications,\
    \ and a user may wish to keep it even if it is\n   the least-recently-used cookie.\
    \  One possible implementation would be\n   an interface that allows the permanent\
    \ storage of a cookie through a\n   checkbox (or, conversely, its immediate destruction).\n\
    \   Privacy considerations dictate that the user have considerable\n   control\
    \ over cookie management.  The PRIVACY section contains more\n   information.\n"
- title: 4.3.4  Sending Cookies to the Origin Server
  contents:
  - "4.3.4  Sending Cookies to the Origin Server\n   When it sends a request to an\
    \ origin server, the user agent sends a\n   Cookie request header to the origin\
    \ server if it has cookies that are\n   applicable to the request, based on\n\
    \   * the request-host;\n   * the request-URI;\n   * the cookie's age.\n   The\
    \ syntax for the header is:\n   cookie          =       \"Cookie:\" cookie-version\n\
    \                           1*((\";\" | \",\") cookie-value)\n   cookie-value\
    \    =       NAME \"=\" VALUE [\";\" path] [\";\" domain]\n   cookie-version \
    \ =       \"$Version\" \"=\" value\n   NAME            =       attr\n   VALUE\
    \           =       value\n   path            =       \"$Path\" \"=\" value\n\
    \   domain          =       \"$Domain\" \"=\" value\n   The value of the cookie-version\
    \ attribute must be the value from the\n   Version attribute, if any, of the corresponding\
    \ Set-Cookie response\n   header.  Otherwise the value for cookie-version is 0.\
    \  The value for\n   the path attribute must be the value from the Path attribute,\
    \ if any,\n   of the corresponding Set-Cookie response header.  Otherwise the\n\
    \   attribute should be omitted from the Cookie request header.  The\n   value\
    \ for the domain attribute must be the value from the Domain\n   attribute, if\
    \ any, of the corresponding Set-Cookie response header.\n   Otherwise the attribute\
    \ should be omitted from the Cookie request\n   header.\n   Note that there is\
    \ no Comment attribute in the Cookie request header\n   corresponding to the one\
    \ in the Set-Cookie response header.  The user\n   agent does not return the comment\
    \ information to the origin server.\n   The following rules apply to choosing\
    \ applicable cookie-values from\n   among all the cookies the user agent has.\n\
    \   Domain Selection\n        The origin server's fully-qualified host name must\
    \ domain-match\n        the Domain attribute of the cookie.\n   Path Selection\n\
    \        The Path attribute of the cookie must match a prefix of the\n       \
    \ request-URI.\n   Max-Age Selection\n        Cookies that have expired should\
    \ have been discarded and thus\n        are not forwarded to an origin server.\n\
    \   If multiple cookies satisfy the criteria above, they are ordered in\n   the\
    \ Cookie header such that those with more specific Path attributes\n   precede\
    \ those with less specific.  Ordering with respect to other\n   attributes (e.g.,\
    \ Domain) is unspecified.\n   Note: For backward compatibility, the separator\
    \ in the Cookie header\n   is semi-colon (;) everywhere.  A server should also\
    \ accept comma (,)\n   as the separator between cookie-values for future compatibility.\n"
- title: 4.3.5  Sending Cookies in Unverifiable Transactions
  contents:
  - "4.3.5  Sending Cookies in Unverifiable Transactions\n   Users must have control\
    \ over sessions in order to ensure privacy.\n   (See PRIVACY section below.) \
    \ To simplify implementation and to\n   prevent an additional layer of complexity\
    \ where adequate safeguards\n   exist, however, this document distinguishes between\
    \ transactions that\n   are verifiable and those that are unverifiable.  A transaction\
    \ is\n   verifiable if the user has the option to review the request-URI prior\n\
    \   to its use in the transaction.  A transaction is unverifiable if the\n   user\
    \ does not have that option.  Unverifiable transactions typically\n   arise when\
    \ a user agent automatically requests inlined or embedded\n   entities or when\
    \ it resolves redirection (3xx) responses from an\n   origin server.  Typically\
    \ the origin transaction, the transaction\n   that the user initiates, is verifiable,\
    \ and that transaction may\n   directly or indirectly induce the user agent to\
    \ make unverifiable\n   transactions.\n   When it makes an unverifiable transaction,\
    \ a user agent must enable a\n   session only if a cookie with a domain attribute\
    \ D was sent or\n   received in its origin transaction, such that the host name\
    \ in the\n   Request-URI of the unverifiable transaction domain-matches D.\n \
    \  This restriction prevents a malicious service author from using\n   unverifiable\
    \ transactions to induce a user agent to start or continue\n   a session with\
    \ a server in a different domain.  The starting or\n   continuation of such sessions\
    \ could be contrary to the privacy\n   expectations of the user, and could also\
    \ be a security problem.\n   User agents may offer configurable options that allow\
    \ the user agent,\n   or any autonomous programs that the user agent executes,\
    \ to ignore\n   the above rule, so long as these override options default to \"\
    off\".\n   Many current user agents already provide a review option that would\n\
    \   render many links verifiable.  For instance, some user agents display\n  \
    \ the URL that would be referenced for a particular link when the mouse\n   pointer\
    \ is placed over that link.  The user can therefore determine\n   whether to visit\
    \ that site before causing the browser to do so.\n   (Though not implemented on\
    \ current user agents, a similar technique\n   could be used for a button used\
    \ to submit a form -- the user agent\n   could display the action to be taken\
    \ if the user were to select that\n   button.) However, even this would not make\
    \ all links verifiable; for\n   example, links to automatically loaded images\
    \ would not normally be\n   subject to \"mouse pointer\" verification.\n   Many\
    \ user agents also provide the option for a user to view the HTML\n   source of\
    \ a document, or to save the source to an external file where\n   it can be viewed\
    \ by another application.  While such an option does\n   provide a crude review\
    \ mechanism, some users might not consider it\n   acceptable for this purpose.\n"
- title: 4.4  How an Origin Server Interprets the Cookie Header
  contents:
  - "4.4  How an Origin Server Interprets the Cookie Header\n   A user agent returns\
    \ much of the information in the Set-Cookie header\n   to the origin server when\
    \ the Path attribute matches that of a new\n   request.  When it receives a Cookie\
    \ header, the origin server should\n   treat cookies with NAMEs whose prefix is\
    \ $ specially, as an attribute\n   for the adjacent cookie.  The value for such\
    \ a NAME is to be\n   interpreted as applying to the lexically (left-to-right)\
    \ most recent\n   cookie whose name does not have the $ prefix.  If there is no\n\
    \   previous cookie, the value applies to the cookie mechanism as a\n   whole.\
    \  For example, consider the cookie\n   Cookie: $Version=\"1\"; Customer=\"WILE_E_COYOTE\"\
    ;\n           $Path=\"/acme\"\n   $Version applies to the cookie mechanism as\
    \ a whole (and gives the\n   version number for the cookie mechanism).  $Path\
    \ is an attribute\n   whose value (/acme) defines the Path attribute that was\
    \ used when the\n   Customer cookie was defined in a Set-Cookie response header.\n"
- title: 4.5  Caching Proxy Role
  contents:
  - "4.5  Caching Proxy Role\n   One reason for separating state information from\
    \ both a URL and\n   document content is to facilitate the scaling that caching\
    \ permits.\n   To support cookies, a caching proxy must obey these rules already\
    \ in\n   the HTTP specification:\n   * Honor requests from the cache, if possible,\
    \ based on cache validity\n     rules.\n   * Pass along a Cookie request header\
    \ in any request that the proxy\n     must make of another server.\n   * Return\
    \ the response to the client.  Include any Set-Cookie response\n     header.\n\
    \   * Cache the received response subject to the control of the usual\n     headers,\
    \ such as Expires, Cache-control: no-cache, and Cache-\n     control: private,\n\
    \   * Cache the Set-Cookie subject to the control of the usual header,\n     Cache-control:\
    \ no-cache=\"set-cookie\".  (The Set-Cookie header\n     should usually not be\
    \ cached.)\n   Proxies must not introduce Set-Cookie (Cookie) headers of their\
    \ own\n   in proxy responses (requests).\n"
- title: 5.  EXAMPLES
  contents:
  - '5.  EXAMPLES

    '
- title: 5.1  Example 1
  contents:
  - "5.1  Example 1\n   Most detail of request and response headers has been omitted.\
    \  Assume\n   the user agent has no stored cookies.\n     1.  User Agent -> Server\n\
    \         POST /acme/login HTTP/1.1\n         [form data]\n         User identifies\
    \ self via a form.\n     2.  Server -> User Agent\n         HTTP/1.1 200 OK\n\
    \         Set-Cookie: Customer=\"WILE_E_COYOTE\"; Version=\"1\"; Path=\"/acme\"\
    \n         Cookie reflects user's identity.\n     3.  User Agent -> Server\n \
    \        POST /acme/pickitem HTTP/1.1\n         Cookie: $Version=\"1\"; Customer=\"\
    WILE_E_COYOTE\"; $Path=\"/acme\"\n         [form data]\n         User selects\
    \ an item for \"shopping basket.\"\n     4.  Server -> User Agent\n         HTTP/1.1\
    \ 200 OK\n         Set-Cookie: Part_Number=\"Rocket_Launcher_0001\"; Version=\"\
    1\";\n                 Path=\"/acme\"\n         Shopping basket contains an item.\n\
    \     5.  User Agent -> Server\n         POST /acme/shipping HTTP/1.1\n      \
    \   Cookie: $Version=\"1\";\n                 Customer=\"WILE_E_COYOTE\"; $Path=\"\
    /acme\";\n                 Part_Number=\"Rocket_Launcher_0001\"; $Path=\"/acme\"\
    \n         [form data]\n         User selects shipping method from form.\n   \
    \  6.  Server -> User Agent\n         HTTP/1.1 200 OK\n         Set-Cookie: Shipping=\"\
    FedEx\"; Version=\"1\"; Path=\"/acme\"\n         New cookie reflects shipping\
    \ method.\n     7.  User Agent -> Server\n         POST /acme/process HTTP/1.1\n\
    \         Cookie: $Version=\"1\";\n                 Customer=\"WILE_E_COYOTE\"\
    ; $Path=\"/acme\";\n                 Part_Number=\"Rocket_Launcher_0001\"; $Path=\"\
    /acme\";\n                 Shipping=\"FedEx\"; $Path=\"/acme\"\n         [form\
    \ data]\n         User chooses to process order.\n     8.  Server -> User Agent\n\
    \         HTTP/1.1 200 OK\n         Transaction is complete.\n   The user agent\
    \ makes a series of requests on the origin server, after\n   each of which it\
    \ receives a new cookie.  All the cookies have the\n   same Path attribute and\
    \ (default) domain.  Because the request URLs\n   all have /acme as a prefix,\
    \ and that matches the Path attribute, each\n   request contains all the cookies\
    \ received so far.\n"
- title: 5.2  Example 2
  contents:
  - "5.2  Example 2\n   This example illustrates the effect of the Path attribute.\
    \  All\n   detail of request and response headers has been omitted.  Assume the\n\
    \   user agent has no stored cookies.\n   Imagine the user agent has received,\
    \ in response to earlier requests,\n   the response headers\n   Set-Cookie: Part_Number=\"\
    Rocket_Launcher_0001\"; Version=\"1\";\n           Path=\"/acme\"\n   and\n  \
    \ Set-Cookie: Part_Number=\"Riding_Rocket_0023\"; Version=\"1\";\n           Path=\"\
    /acme/ammo\"\n   A subsequent request by the user agent to the (same) server for\
    \ URLs\n   of the form /acme/ammo/...  would include the following request\n \
    \  header:\n   Cookie: $Version=\"1\";\n           Part_Number=\"Riding_Rocket_0023\"\
    ; $Path=\"/acme/ammo\";\n           Part_Number=\"Rocket_Launcher_0001\"; $Path=\"\
    /acme\"\n   Note that the NAME=VALUE pair for the cookie with the more specific\n\
    \   Path attribute, /acme/ammo, comes before the one with the less\n   specific\
    \ Path attribute, /acme.  Further note that the same cookie\n   name appears more\
    \ than once.\n   A subsequent request by the user agent to the (same) server for\
    \ a URL\n   of the form /acme/parts/ would include the following request header:\n\
    \   Cookie: $Version=\"1\"; Part_Number=\"Rocket_Launcher_0001\"; $Path=\"/acme\"\
    \n   Here, the second cookie's Path attribute /acme/ammo is not a prefix\n   of\
    \ the request URL, /acme/parts/, so the cookie does not get\n   forwarded to the\
    \ server.\n"
- title: 6.  IMPLEMENTATION CONSIDERATIONS
  contents:
  - "6.  IMPLEMENTATION CONSIDERATIONS\n   Here we speculate on likely or desirable\
    \ details for an origin server\n   that implements state management.\n"
- title: 6.1  Set-Cookie Content
  contents:
  - "6.1  Set-Cookie Content\n   An origin server's content should probably be divided\
    \ into disjoint\n   application areas, some of which require the use of state\n\
    \   information.  The application areas can be distinguished by their\n   request\
    \ URLs.  The Set-Cookie header can incorporate information\n   about the application\
    \ areas by setting the Path attribute for each\n   one.\n   The session information\
    \ can obviously be clear or encoded text that\n   describes state.  However, if\
    \ it grows too large, it can become\n   unwieldy.  Therefore, an implementor might\
    \ choose for the session\n   information to be a key to a server-side resource.\
    \  Of course, using\n   a database creates some problems that this state management\n\
    \   specification was meant to avoid, namely:\n     1.  keeping real state on\
    \ the server side;\n     2.  how and when to garbage-collect the database entry,\
    \ in case the\n         user agent terminates the session by, for example, exiting.\n"
- title: 6.2  Stateless Pages
  contents:
  - "6.2  Stateless Pages\n   Caching benefits the scalability of WWW.  Therefore\
    \ it is important\n   to reduce the number of documents that have state embedded\
    \ in them\n   inherently.  For example, if a shopping-basket-style application\n\
    \   always displays a user's current basket contents on each page, those\n   pages\
    \ cannot be cached, because each user's basket's contents would\n   be different.\
    \  On the other hand, if each page contains just a link\n   that allows the user\
    \ to \"Look at My Shopping Basket\", the page can be\n   cached.\n"
- title: 6.3  Implementation Limits
  contents:
  - "6.3  Implementation Limits\n   Practical user agent implementations have limits\
    \ on the number and\n   size of cookies that they can store.  In general, user\
    \ agents' cookie\n   support should have no fixed limits.  They should strive\
    \ to store as\n   many frequently-used cookies as possible.  Furthermore, general-use\n\
    \   user agents should provide each of the following minimum capabilities\n  \
    \ individually, although not necessarily simultaneously:\n      * at least 300\
    \ cookies\n      * at least 4096 bytes per cookie (as measured by the size of\
    \ the\n        characters that comprise the cookie non-terminal in the syntax\n\
    \        description of the Set-Cookie header)\n      * at least 20 cookies per\
    \ unique host or domain name\n   User agents created for specific purposes or\
    \ for limited-capacity\n   devices should provide at least 20 cookies of 4096\
    \ bytes, to ensure\n   that the user can interact with a session-based origin\
    \ server.\n   The information in a Set-Cookie response header must be retained\
    \ in\n   its entirety.  If for some reason there is inadequate space to store\n\
    \   the cookie, it must be discarded, not truncated.\n   Applications should use\
    \ as few and as small cookies as possible, and\n   they should cope gracefully\
    \ with the loss of a cookie.\n"
- title: 6.3.1  Denial of Service Attacks
  contents:
  - "6.3.1  Denial of Service Attacks\n   User agents may choose to set an upper bound\
    \ on the number of cookies\n   to be stored from a given host or domain name or\
    \ on the size of the\n   cookie information.  Otherwise a malicious server could\
    \ attempt to\n   flood a user agent with many cookies, or large cookies, on successive\n\
    \   responses, which would force out cookies the user agent had received\n   from\
    \ other servers.  However, the minima specified above should still\n   be supported.\n"
- title: 7.  PRIVACY
  contents:
  - '7.  PRIVACY

    '
- title: 7.1  User Agent Control
  contents:
  - "7.1  User Agent Control\n   An origin server could create a Set-Cookie header\
    \ to track the path\n   of a user through the server.  Users may object to this\
    \ behavior as\n   an intrusive accumulation of information, even if their identity\
    \ is\n   not evident.  (Identity might become evident if a user subsequently\n\
    \   fills out a form that contains identifying information.)  This state\n   management\
    \ specification therefore requires that a user agent give\n   the user control\
    \ over such a possible intrusion, although the\n   interface through which the\
    \ user is given this control is left\n   unspecified.  However, the control mechanisms\
    \ provided shall at least\n   allow the user\n      * to completely disable the\
    \ sending and saving of cookies.\n      * to determine whether a stateful session\
    \ is in progress.\n      * to control the saving of a cookie on the basis of the\
    \ cookie's\n        Domain attribute.\n   Such control could be provided by, for\
    \ example, mechanisms\n      * to notify the user when the user agent is about\
    \ to send a cookie\n        to the origin server, offering the option not to begin\
    \ a session.\n      * to display a visual indication that a stateful session is\
    \ in\n        progress.\n      * to let the user decide which cookies, if any,\
    \ should be saved\n        when the user concludes a window or user agent session.\n\
    \      * to let the user examine the contents of a cookie at any time.\n   A user\
    \ agent usually begins execution with no remembered state\n   information.  It\
    \ should be possible to configure a user agent never\n   to send Cookie headers,\
    \ in which case it can never sustain state with\n   an origin server.  (The user\
    \ agent would then behave like one that is\n   unaware of how to handle Set-Cookie\
    \ response headers.)\n   When the user agent terminates execution, it should let\
    \ the user\n   discard all state information.  Alternatively, the user agent may\
    \ ask\n   the user whether state information should be retained; the default\n\
    \   should be \"no\".  If the user chooses to retain state information, it\n \
    \  would be restored the next time the user agent runs.\n   NOTE: User agents\
    \ should probably be cautious about using files to\n   store cookies long-term.\
    \  If a user runs more than one instance of\n   the user agent, the cookies could\
    \ be commingled or otherwise messed\n   up.\n"
- title: 7.2  Protocol Design
  contents:
  - "7.2  Protocol Design\n   The restrictions on the value of the Domain attribute,\
    \ and the rules\n   concerning unverifiable transactions, are meant to reduce\
    \ the ways\n   that cookies can \"leak\" to the \"wrong\" site.  The intent is\
    \ to\n   restrict cookies to one, or a closely related set of hosts.\n   Therefore\
    \ a request-host is limited as to what values it can set for\n   Domain.  We consider\
    \ it acceptable for hosts host1.foo.com and\n   host2.foo.com to share cookies,\
    \ but not a.com and b.com.\n   Similarly, a server can only set a Path for cookies\
    \ that are related\n   to the request-URI.\n"
- title: 8.  SECURITY CONSIDERATIONS
  contents:
  - '8.  SECURITY CONSIDERATIONS

    '
- title: 8.1  Clear Text
  contents:
  - "8.1  Clear Text\n   The information in the Set-Cookie and Cookie headers is unprotected.\n\
    \   Two consequences are:\n   1.  Any sensitive information that is conveyed in\
    \ them is exposed\n       to intruders.\n   2.  A malicious intermediary could\
    \ alter the headers as they travel\n       in either direction, with unpredictable\
    \ results.\n   These facts imply that information of a personal and/or financial\n\
    \   nature should only be sent over a secure channel.  For less sensitive\n  \
    \ information, or when the content of the header is a database key, an\n   origin\
    \ server should be vigilant to prevent a bad Cookie value from\n   causing failures.\n"
- title: 8.2  Cookie Spoofing
  contents:
  - "8.2  Cookie Spoofing\n   Proper application design can avoid spoofing attacks\
    \ from related\n   domains.  Consider:\n     1.  User agent makes request to victim.cracker.edu,\
    \ gets back\n         cookie session_id=\"1234\" and sets the default domain\n\
    \         victim.cracker.edu.\n     2.  User agent makes request to spoof.cracker.edu,\
    \ gets back\n         cookie session-id=\"1111\", with Domain=\".cracker.edu\"\
    .\n     3.  User agent makes request to victim.cracker.edu again, and\n      \
    \   passes\n         Cookie: $Version=\"1\";\n                         session_id=\"\
    1234\";\n                         session_id=\"1111\"; $Domain=\".cracker.edu\"\
    \n         The server at victim.cracker.edu should detect that the second\n  \
    \       cookie was not one it originated by noticing that the Domain\n       \
    \  attribute is not for itself and ignore it.\n"
- title: 8.3  Unexpected Cookie Sharing
  contents:
  - "8.3  Unexpected Cookie Sharing\n   A user agent should make every attempt to\
    \ prevent the sharing of\n   session information between hosts that are in different\
    \ domains.\n   Embedded or inlined objects may cause particularly severe privacy\n\
    \   problems if they can be used to share cookies between disparate\n   hosts.\
    \  For example, a malicious server could embed cookie\n   information for host\
    \ a.com in a URI for a CGI on host b.com.  User\n   agent implementors are strongly\
    \ encouraged to prevent this sort of\n   exchange whenever possible.\n"
- title: 9.  OTHER, SIMILAR, PROPOSALS
  contents:
  - "9.  OTHER, SIMILAR, PROPOSALS\n   Three other proposals have been made to accomplish\
    \ similar goals.\n   This specification is an amalgam of Kristol's State-Info\
    \ proposal and\n   Netscape's Cookie proposal.\n   Brian Behlendorf proposed a\
    \ Session-ID header that would be user-\n   agent-initiated and could be used\
    \ by an origin server to track\n   \"clicktrails\".  It would not carry any origin-server-defined\
    \ state,\n   however.  Phillip Hallam-Baker has proposed another client-defined\n\
    \   session ID mechanism for similar purposes.\n   While both session IDs and\
    \ cookies can provide a way to sustain\n   stateful sessions, their intended purpose\
    \ is different, and,\n   consequently, the privacy requirements for them are different.\
    \  A\n   user initiates session IDs to allow servers to track progress through\n\
    \   them, or to distinguish multiple users on a shared machine.  Cookies\n   are\
    \ server-initiated, so the cookie mechanism described here gives\n   users control\
    \ over something that would otherwise take place without\n   the users' awareness.\
    \  Furthermore, cookies convey rich, server-\n   selected information, whereas\
    \ session IDs comprise user-selected,\n   simple information.\n"
- title: 10.  HISTORICAL
  contents:
  - '10.  HISTORICAL

    '
- title: 10.1  Compatibility With Netscape's Implementation
  contents:
  - "10.1  Compatibility With Netscape's Implementation\n   HTTP/1.0 clients and servers\
    \ may use Set-Cookie and Cookie headers\n   that reflect Netscape's original cookie\
    \ proposal.  These notes cover\n   inter-operation between \"old\" and \"new\"\
    \ cookies.\n"
- title: 10.1.1  Extended Cookie Header
  contents:
  - "10.1.1  Extended Cookie Header\n   This proposal adds attribute-value pairs to\
    \ the Cookie request header\n   in a compatible way.  An \"old\" client that receives\
    \ a \"new\" cookie\n   will ignore attributes it does not understand; it returns\
    \ what it\n   does understand to the origin server.  A \"new\" client always sends\n\
    \   cookies in the new form.\n   An \"old\" server that receives a \"new\" cookie\
    \ will see what it thinks\n   are many cookies with names that begin with a $,\
    \ and it will ignore\n   them.  (The \"old\" server expects these cookies to be\
    \ separated by\n   semi-colon, not comma.)  A \"new\" server can detect cookies\
    \ that have\n   passed through an \"old\" client, because they lack a $Version\n\
    \   attribute.\n"
- title: 10.1.2  Expires and Max-Age
  contents:
  - "10.1.2  Expires and Max-Age\n   Netscape's original proposal defined an Expires\
    \ header that took a\n   date value in a fixed-length variant format in place\
    \ of Max-Age:\n   Wdy, DD-Mon-YY HH:MM:SS GMT\n   Note that the Expires date format\
    \ contains embedded spaces, and that\n   \"old\" cookies did not have quotes around\
    \ values.  Clients that\n   implement to this specification should be aware of\
    \ \"old\" cookies and\n   Expires.\n"
- title: 10.1.3  Punctuation
  contents:
  - "10.1.3  Punctuation\n   In Netscape's original proposal, the values in attribute-value\
    \ pairs\n   did not accept \"-quoted strings.  Origin servers should be cautious\n\
    \   about sending values that require quotes unless they know the\n   receiving\
    \ user agent understands them (i.e., \"new\" cookies).  A\n   (\"new\") user agent\
    \ should only use quotes around values in Cookie\n   headers when the cookie's\
    \ version(s) is (are) all compliant with this\n   specification or later.\n  \
    \ In Netscape's original proposal, no whitespace was permitted around\n   the\
    \ = that separates attribute-value pairs.  Therefore such\n   whitespace should\
    \ be used with caution in new implementations.\n"
- title: 10.2  Caching and HTTP/1.0
  contents:
  - "10.2  Caching and HTTP/1.0\n   Some caches, such as those conforming to HTTP/1.0,\
    \ will inevitably\n   cache the Set-Cookie header, because there was no mechanism\
    \ to\n   suppress caching of headers prior to HTTP/1.1.  This caching can lead\n\
    \   to security problems.  Documents transmitted by an origin server\n   along\
    \ with Set-Cookie headers will usually either be uncachable, or\n   will be \"\
    pre-expired\".  As long as caches obey instructions not to\n   cache documents\
    \ (following Expires: <a date in the past> or Pragma:\n   no-cache (HTTP/1.0),\
    \ or Cache-control: no-cache (HTTP/1.1))\n   uncachable documents present no problem.\
    \  However, pre-expired\n   documents may be stored in caches.  They require validation\
    \ (a\n   conditional GET) on each new request, but some cache operators loosen\n\
    \   the rules for their caches, and sometimes serve expired documents\n   without\
    \ first validating them.  This combination of factors can lead\n   to cookies\
    \ meant for one user later being sent to another user.  The\n   Set-Cookie header\
    \ is stored in the cache, and, although the document\n   is stale (expired), the\
    \ cache returns the document in response to\n   later requests, including cached\
    \ headers.\n"
- title: 11.  ACKNOWLEDGEMENTS
  contents:
  - "11.  ACKNOWLEDGEMENTS\n   This document really represents the collective efforts\
    \ of the\n   following people, in addition to the authors: Roy Fielding, Marc\n\
    \   Hedlund, Ted Hardie, Koen Holtman, Shel Kaphan, Rohit Khare.\n"
- title: 12.  AUTHORS' ADDRESSES
  contents:
  - "12.  AUTHORS' ADDRESSES\n   David M. Kristol\n   Bell Laboratories, Lucent Technologies\n\
    \   600 Mountain Ave.  Room 2A-227\n   Murray Hill, NJ  07974\n   Phone: (908)\
    \ 582-2250\n   Fax: (908) 582-5809\n   EMail: dmk@bell-labs.com\n   Lou Montulli\n\
    \   Netscape Communications Corp.\n   501 E. Middlefield Rd.\n   Mountain View,\
    \ CA  94043\n   Phone: (415) 528-2600\n   EMail: montulli@netscape.com\n"
