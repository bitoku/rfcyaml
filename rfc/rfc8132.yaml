- contents:
  - ''
  title: __initial_text__
- contents:
  - 'PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)

    '
  title: PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)
- contents:
  - "Abstract\n   The methods defined in RFC 7252 for the Constrained Application\n
    \  Protocol (CoAP) only allow access to a complete resource, not to\n   parts
    of a resource.  In case of resources with larger or complex\n   data, or in situations
    where resource continuity is required,\n   replacing or requesting the whole resource
    is undesirable.  Several\n   applications using CoAP need to access parts of the
    resources.\n   This specification defines the new CoAP methods, FETCH, PATCH,
    and\n   iPATCH, which are used to access and update parts of a resource.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8132.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n     1.1.  FETCH . . . . . . . . . . . . . . . . . . . . . . .
    . . .   3\n     1.2.  PATCH and iPATCH  . . . . . . . . . . . . . . . . . . .
    .   4\n     1.3.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n
    \    1.4.  Terminology and Acronyms  . . . . . . . . . . . . . . . .   5\n   2.
    \ FETCH Method  . . . . . . . . . . . . . . . . . . . . . . . .   5\n     2.1.
    \ Response Codes  . . . . . . . . . . . . . . . . . . . . .   6\n     2.2.  Error
    Handling  . . . . . . . . . . . . . . . . . . . . .   6\n     2.3.  Option Numbers
    \ . . . . . . . . . . . . . . . . . . . . .   7\n       2.3.1.  The Content-Format
    Option . . . . . . . . . . . . . .   7\n       2.3.2.  The ETag Option . . . .
    . . . . . . . . . . . . . . .   8\n     2.4.  Working with Observe  . . . . .
    . . . . . . . . . . . . .   8\n     2.5.  Working with Block  . . . . . . . .
    . . . . . . . . . . .   8\n     2.6.  Building FETCH Requests . . . . . . . .
    . . . . . . . . .   8\n     2.7.  A Simple Example for FETCH  . . . . . . . .
    . . . . . . .   8\n   3.  PATCH and iPATCH Methods  . . . . . . . . . . . . .
    . . . . .   9\n     3.1.  Simple Examples for PATCH and iPATCH  . . . . . . .
    . . .  12\n     3.2.  Response Codes  . . . . . . . . . . . . . . . . . . . .
    .  14\n     3.3.  Option Numbers  . . . . . . . . . . . . . . . . . . . . .  14\n
    \    3.4.  Error Handling  . . . . . . . . . . . . . . . . . . . . .  15\n   4.
    \ The New Set of CoAP Methods . . . . . . . . . . . . . . . . .  16\n   5.  Security
    Considerations . . . . . . . . . . . . . . . . . . .  17\n   6.  IANA Considerations
    . . . . . . . . . . . . . . . . . . . . .  18\n   7.  References  . . . . . .
    . . . . . . . . . . . . . . . . . . .  19\n     7.1.  Normative References  .
    . . . . . . . . . . . . . . . . .  19\n     7.2.  Informative References  . .
    . . . . . . . . . . . . . . .  19\n   Acknowledgements  . . . . . . . . . . .
    . . . . . . . . . . . . .  20\n   Authors' Addresses  . . . . . . . . . . . .
    . . . . . . . . . . .  21\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Similar to HTTP, the GET method defined in [RFC7252] for
    the\n   Constrained Application Protocol (CoAP) only allows the specification\n
    \  of a URI and request parameters in CoAP options, not the transfer of\n   a
    request payload detailing the request.  This leads some\n   applications to use
    POST where a cacheable, idempotent, safe request\n   is actually desired.\n   Again,
    similar to the original specification of HTTP, the PUT method\n   defined in [RFC7252]
    only allows a complete resource to be replaced.\n   This also leads applications
    to use POST where a cacheable, possibly\n   idempotent request is actually desired.\n
    \  The present specification adds new CoAP methods: FETCH, to perform\n   the
    equivalent of a GET with a request body; and the twin methods,\n   PATCH and iPATCH,
    to modify parts of a CoAP resource.\n"
  - contents:
    - "1.1.  FETCH\n   The CoAP GET method [RFC7252] is used to obtain the representation
      of\n   a resource, where the resource is specified by a URI and additional\n
      \  request parameters can also shape the representation.  This has been\n   modeled
      after the HTTP GET operation and the REST model in general.\n   In HTTP, a resource
      is often used to search for information, and\n   existing systems varyingly
      use the HTTP GET and POST methods to\n   perform a search.  Often, a POST method
      is used solely so that a\n   larger set of parameters to the search can be supplied
      in the request\n   body than can comfortably be transferred in the URI with
      a GET\n   request.  [HTTP-SEARCH] proposes a SEARCH method that is similar to\n
      \  GET in most properties but enables sending a request body, as is done\n   with
      POST.  The FETCH method defined in the present specification is\n   inspired
      by [HTTP-SEARCH], which updates the definition and semantics\n   of the HTTP
      SEARCH request method previously defined by [RFC5323].\n   However, there is
      no intention to limit FETCH to search-type\n   operations, and the resulting
      properties may not be the same as those\n   of HTTP SEARCH.\n   A major problem
      with GET is that the information that controls the\n   request needs to be bundled
      up in some unspecified way into the URI.\n   Using the request body for this
      information has a number of\n   advantages:\n   o  The client can specify a
      media type (and a content coding) that\n      enables the server to unambiguously
      interpret the request\n      parameters in the context of that media type.  Also,
      the request\n      body is not limited by the character set limitations of URIs,\n
      \     which enables a more natural (and more efficient) representation\n      of
      certain domain-specific parameters.\n   o  The request parameters are not limited
      by the maximum size of the\n      URI.  In HTTP, that is a problem, as the practical
      limit for this\n      size varies.  In CoAP, another problem is that the block-wise\n
      \     transfer is not available for transferring large URI options in\n      multiple
      rounds.\n   As an alternative to using GET, many implementations make use of
      the\n   POST method to perform extended requests (even if they are\n   semantically
      idempotent, safe, and even cacheable) to be able to pass\n   along the input
      parameters within the request payload as opposed to\n   using the request URI.\n
      \  The FETCH method provides a solution that spans the gap between the\n   use
      of GET and POST.  As with POST, the input to the FETCH operation\n   is passed
      along within the payload of the request rather than as part\n   of the request
      URI.  Unlike POST, however, the semantics of the FETCH\n   method are more specifically
      defined.\n"
    title: 1.1.  FETCH
  - contents:
    - "1.2.  PATCH and iPATCH\n   PATCH is also specified for HTTP in [RFC5789].  Most
      of the\n   motivation for PATCH described in [RFC5789] also applies here. iPATCH\n
      \  is the idempotent version of PATCH.\n   The PUT method exists to overwrite
      a resource with completely new\n   contents and cannot be used to perform partial
      changes.  When using\n   PUT for partial changes, proxies and caches, and even
      clients and\n   servers, may get confused as to the result of the operation.
      \ PATCH\n   was not adopted in an early design stage of CoAP; however, it has\n
      \  become necessary with the arrival of applications that require\n   partial
      updates to resources (e.g., [COAP-MGMNT]).  Using PATCH\n   avoids transferring
      all data associated with a resource in case of\n   modifications, thereby not
      burdening the constrained communication\n   medium.\n   This document relies
      on knowledge of the PATCH specification for HTTP\n   [RFC5789].  This document
      provides extracts from [RFC5789] to make\n   independent reading possible.\n"
    title: 1.2.  PATCH and iPATCH
  - contents:
    - "1.3.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   [RFC2119].\n"
    title: 1.3.  Requirements Language
  - contents:
    - "1.4.  Terminology and Acronyms\n   This document uses terminology defined in
      [RFC5789] and [RFC7252].\n   Specifically, it uses the terms \"safe\" and \"idempotent\"
      as defined in\n   Section 5.1 of [RFC7252].  (Further discussion of safe and
      idempotent\n   methods can now be found in Sections 4.2.1 and 4.2.2 of [RFC7231],\n
      \  respectively; the implications of idempotence of methods on server\n   implementations
      are also discussed in Section 4.5 of [RFC7252].)\n"
    title: 1.4.  Terminology and Acronyms
  title: 1.  Introduction
- contents:
  - "2.  FETCH Method\n   The CoAP FETCH method is used to obtain a representation
    of a\n   resource, specified by a number of request parameters.  Unlike the\n
    \  CoAP GET method, which requests that a server return a representation\n   of
    the resource identified by the effective request URI (as defined\n   by [RFC7252]),
    the FETCH method is used by a client to ask the server\n   to produce a representation
    as described by the request parameters\n   (including the request options and
    the payload) based on the resource\n   specified by the effective request URI.
    \ The payload returned in\n   response to a FETCH cannot be assumed to be a complete
    representation\n   of the resource identified by the effective request URI, i.e.,
    it\n   cannot be used by a cache as a payload to be returned by a GET\n   request.\n
    \  Together with the request options, the body of the request (which may\n   be
    constructed from multiple payloads using the block protocol\n   [RFC7959]) defines
    the request parameters.  With the FETCH method,\n   implementations may submit
    a request body of any media type that is\n   defined with the semantics of selecting
    information from a resource\n   in such a FETCH request; it is outside the scope
    of this document how\n   information about media types admissible for the specific
    resource is\n   obtained by the client (although we can hint that form relations\n
    \  [CORE-APP] might be a preferred way).  It is RECOMMENDED that any\n   discovery
    method that allows a client to find out that the server\n   supports FETCH also
    provides information regarding what FETCH payload\n   media types are applicable.\n
    \  FETCH requests are both safe and idempotent with regards to the\n   resource
    identified by the request URI.  That is, the performance of\n   a FETCH is not
    intended to alter the state of the targeted resource.\n   (However, while processing
    a FETCH request, a server can be expected\n   to allocate computing and memory
    resources or even create additional\n   server resources through which the response
    to the search can be\n   retrieved.)\n   A successful response to a FETCH request
    is expected to provide some\n   indication as to the final disposition of the
    requested operation.\n   If a successful response includes a body payload, the
    payload is\n   expected to describe the results of the FETCH operation.\n   Depending
    on the response code as defined by [RFC7252], the response\n   to a FETCH request
    is cacheable; the request body is part of the\n   cache key.  Specifically, 2.05
    (Content) response codes (the\n   responses for which are cacheable) are a typical
    way to respond to a\n   FETCH request.  (Note that this aspect differs markedly
    from\n   [HTTP-SEARCH] and also that caches that cannot use the request\n   payload
    as part of the cache key will not be able to cache responses\n   to FETCH requests
    at all.)  The Max-Age option in the response has\n   equivalent semantics to its
    use in a GET.\n   The semantics of the FETCH method change to a \"conditional
    FETCH\" if\n   the request message includes an If-Match or If-None-Match option\n
    \  [RFC7252].  A conditional FETCH requests that the query be performed\n   only
    under the circumstances described by the conditional option(s).\n   It is important
    to note, however, that such conditions are evaluated\n   against the state of
    the target resource itself as opposed to the\n   results of the FETCH operation.\n"
  - contents:
    - "2.1.  Response Codes\n   FETCH for CoAP adopts the response codes as specified
      in Sections 5.9\n   and 12.1.2 of [RFC7252] as well as the additional response
      codes\n   mentioned in Section 2.2.\n"
    title: 2.1.  Response Codes
  - contents:
    - "2.2.  Error Handling\n   A FETCH request may fail under certain known conditions.
      \ Beyond the\n   conditions already defined in [RFC7252] for GET, noteworthy
      ones are:\n   Malformed FETCH payload:  If a server determines that the payload\n
      \     provided with a FETCH request is not properly formatted, it can\n      return
      a 4.00 (Bad Request) CoAP error.  The definition of a\n      malformed payload
      depends upon the CoAP Content-Format specified\n      with the request.\n   Unsupported
      FETCH payload:  In case a client sends a payload that is\n      inappropriate
      for the resource identified by the Request-URI, the\n      server can return
      a 4.15 (Unsupported Content-Format) CoAP error.\n      The server can determine
      if the payload is supported by checking\n      the CoAP Content-Format specified
      with the request.\n   Unprocessable request:  This situation occurs when the
      payload of a\n      FETCH request is determined to be valid (i.e., well-formed
      and\n      supported) but the server is unable to or is incapable of\n      processing
      the request.  The server can return a 4.22\n      (Unprocessable Entity) CoAP
      error.  In situations when the server\n      has insufficient computing resources
      to complete the request\n      successfully, it can return a 4.13 (Request Entity
      Too Large) CoAP\n      error (see also below).  If there are more specific errors
      that\n      provide additional insight into the problem, then those should be\n
      \     used.\n   Request too large:  If the payload of the FETCH request is larger\n
      \     than a CoAP server can process, then it can return the 4.13\n      (Request
      Entity Too Large) CoAP error.\n   It is possible that other error situations
      not mentioned here are\n   encountered by a CoAP server while processing the
      FETCH request.  In\n   these situations, other appropriate CoAP response codes
      can also be\n   returned.\n"
    title: 2.2.  Error Handling
  - contents:
    - "2.3.  Option Numbers\n   FETCH for CoAP adopts the option numbers as specified
      in Sections\n   5.10 and 12.2 of [RFC7252].\n   Generally, options defined for
      GET act in an analogous way for FETCH.\n   Two specific cases are called out
      in the rest of this section.\n"
    - contents:
      - "2.3.1.  The Content-Format Option\n   A FETCH request MUST include a Content-Format
        option (see\n   Section 5.10.3 of [RFC7252]) to specify the media type and
        content\n   coding of the request body.  (Typically, the media type will have\n
        \  been specifically designed to specify details for a selection or a\n   search
        on a resource.)\n"
      title: 2.3.1.  The Content-Format Option
    - contents:
      - "2.3.2.  The ETag Option\n   The ETag option on a FETCH result has the same
        semantics as defined\n   in Section 5.10.6 of [RFC7252].  In particular, its
        use as a response\n   option describes the \"tagged representation\", which
        for FETCH is the\n   same as the \"selected representation\".  The FETCH payload
        is input to\n   that selection process and therefore needs to be part of the
        cache\n   key.  Similarly, the use of ETag as a request option can elicit
        a\n   2.03 (Valid) response if the representation associated with the ETag\n
        \  would still be selected by the FETCH request (including its payload).\n"
      title: 2.3.2.  The ETag Option
    title: 2.3.  Option Numbers
  - contents:
    - "2.4.  Working with Observe\n   The Observe option [RFC7641] can be used with
      a FETCH request as it\n   can be used with a GET request.\n"
    title: 2.4.  Working with Observe
  - contents:
    - "2.5.  Working with Block\n   The Block1 option [RFC7959] can be used with a
      FETCH request as it\n   would be used with a POST request; the Block2 option
      can then be used\n   as it would with GET or POST.\n"
    title: 2.5.  Working with Block
  - contents:
    - "2.6.  Building FETCH Requests\n   One property of FETCH that may be non-obvious
      is that a FETCH request\n   cannot be generated from a link alone; the client
      also needs a way to\n   generate the request payload.  Again, form relations
      [CORE-APP] may\n   be able to fill parts of this gap.\n"
    title: 2.6.  Building FETCH Requests
  - contents:
    - "2.7.  A Simple Example for FETCH\n   The FETCH method needs a media type for
      its payload (as expressed by\n   the Content-Format request option) that specifies
      the search query in\n   similar detail as is shown for the PATCH payload in
      the PATCH example\n   in Section 3.1.  ([HTTP-SEARCH] invents a \"text/query\"
      format based\n   on some hypothetical SQL dialect for its examples.)\n   The
      example below illustrates retrieval of a subset of a JSON\n   [RFC7159] object
      (the same object as used in Section 3.1).  Using a\n   hypothetical media type
      \"application/example-map-keys+json\" (with a\n   Content-Format ID of NNN,
      which is not defined as this is just an\n   example), the client specifies the
      items in the object that it wants:\n   it supplies a JSON array that gives the
      map keys for these items.  A\n   resource located at <coap://www.example.com/object>
      can be\n   represented by a JSON document that we will consider as the target
      of\n   the FETCH.  The client wants to learn the contents of the single map\n
      \  key \"foo\" within this target:\n   {\n     \"x-coord\": 256,\n     \"y-coord\":
      45,\n     \"foo\": [\"bar\",\"baz\"]\n   }\n               FETCH Example: JSON
      Document Returned by GET\n   The example FETCH request specifies a single top-level
      member desired\n   by giving its map key as the sole element of the \"example-map-keys\"\n
      \  payload:\n   FETCH CoAP://www.example.com/object\n   Content-Format: NNN
      (application/example-map-keys+json)\n   Accept: application/json\n   [\n     \"foo\"\n
      \  ]\n                          FETCH Example: Request\n   The server returns
      a subset document with just the selected member:\n   2.05 Content\n   Content-Format:
      50 (application/json)\n   {\n     \"foo\": [\"bar\",\"baz\"]\n   }\n             FETCH
      Example: Response with Subset JSON Document\n   By the logic of this example,
      the requester could have entered more\n   than one map key into the request
      payload array and would have\n   received a more complete subset of the top-level
      JSON object that is\n   representing the resource.\n"
    title: 2.7.  A Simple Example for FETCH
  title: 2.  FETCH Method
- contents:
  - "3.  PATCH and iPATCH Methods\n   The PATCH and iPATCH methods request that a
    set of changes described\n   in the request payload be applied to the target resource
    of the\n   request.  The set of changes is represented in a format identified
    by\n   a media type.  If the Request-URI does not point to an existing\n   resource,
    the server MAY create a new resource with that URI,\n   depending on the PATCH
    document type (whether it can logically modify\n   a null resource) and permissions,
    as well as other conditions such as\n   the degree of control the server gives
    clients in creating new\n   entries in its URI space (see also Section 3.4).  Creation
    of a new\n   resource would result in a 2.01 (Created) response code dependent
    on\n   the PATCH document type.\n   Restrictions to a PATCH or iPATCH request
    can be made by including\n   the If-Match or If-None-Match options in the request
    (see Sections\n   5.10.8.1 and 5.10.8.2 of [RFC7252]).  If the resource could
    not be\n   created or modified, then an appropriate error response code SHOULD\n
    \  be sent.\n   The difference between the PUT and PATCH requests is documented
    in\n   [RFC5789].  When a request is intended to effect a partial update of\n
    \  a given resource, clients cannot use PUT while supplying just the\n   update,
    but they might be able to use PATCH or iPATCH.\n   The PATCH method is \"not safe\"
    and \"not idempotent\", as is the HTTP\n   PATCH method specified in [RFC5789].\n
    \  The iPATCH method is not safe but idempotent, as with the CoAP PUT\n   method
    specified in Section 5.8.3 of [RFC7252].\n   A client can mark a request as idempotent
    by using the iPATCH method\n   instead of the PATCH method.  This is the only
    difference between the\n   two.  The indication of idempotence may enable the
    server to keep\n   less state about the interaction; some constrained servers
    may only\n   implement the iPATCH variant for this reason.\n   PATCH and iPATCH
    are both atomic.  The server MUST apply the entire\n   set of changes atomically
    and never provide a partially modified\n   representation to a concurrently executed
    GET request.  Given the\n   constrained nature of the servers, most servers will
    only execute\n   CoAP requests consecutively, thus preventing a concurrent partial\n
    \  overlapping of request modifications.  In other words, modifications\n   MUST
    NOT be applied to the server state when an error occurs or when\n   only a partial
    execution is possible on the resources present in the\n   server.\n   The atomicity
    applies to a single server.  When a PATCH or iPATCH\n   request is multicast to
    a set of servers, each server can either\n   execute all required modifications
    or not.  It is not required that\n   all servers execute all modifications or
    none.  An Atomic Commit\n   protocol that provides multiple server atomicity is
    out of scope.\n   A PATCH or iPATCH response can invalidate a cache in a similar
    manner\n   to the PUT response.  For the successful (2.xx) response codes, PATCH\n
    \  or iPATCH have the following caching behavior:\n   o  A 2.01 (Created) response
    invalidates any cache entry for the\n      resource indicated by the Location-*
    options; the payload is a\n      representation of the action result.\n   o  A
    2.04 (Changed) response invalidates any cache entry for the\n      target resource;
    the payload is a representation of the action\n      result.\n   There is no guarantee
    that a resource can be modified with PATCH or\n   iPATCH.  Servers MUST ensure
    that a received PATCH body is\n   appropriate for the type of resource identified
    by the target\n   resource of the request.\n   It is RECOMMENDED that any discovery
    method that allows a client to\n   find out that the server supports one of PATCH
    and iPATCH also\n   provide information regarding what PATCH payload media types
    are\n   applicable and which of the two methods are implemented by the server\n
    \  for each of these media types.\n   Servers that do not rely on the idempotence
    of iPATCH can easily\n   support both PATCH and iPATCH, and it is RECOMMENDED
    they do so.\n   This is inexpensive to do, as, for iPATCH, there is no requirement
    on\n   the server to check that the client's intention that the request be\n   idempotent
    is fulfilled (although there is diagnostic value in that\n   check, so a less-constrained
    implementation may want to perform it).\n"
  - contents:
    - "3.1.  Simple Examples for PATCH and iPATCH\n   The example is taken over from
      [RFC6902], which specifies a JSON\n   notation for PATCH operations.  A resource
      located at\n   <coap://www.example.com/object> contains a target JSON document.\n
      \  JSON document original state:\n       {\n         \"x-coord\": 256,\n         \"y-coord\":
      45,\n         \"foo\": [\"bar\",\"baz\"]\n       }\n   REQ: iPATCH CoAP://www.example.com/object\n
      \  Content-Format: 51 (application/json-patch+json)\n       [\n         { \"op\":\"replace\",
      \"path\":\"x-coord\", \"value\":45}\n       ]\n   RET: CoAP 2.04 Changed\n   JSON
      document final state:\n       {\n         \"x-coord\": 45,\n         \"y-coord\":
      45,\n         \"foo\": [\"bar\",\"baz\"]\n       }\n   This example illustrates
      use of an idempotent modification to the\n   x-coord member of the existing
      resource \"object\".  The 2.04 (Changed)\n   response code conforms with the
      CoAP PUT method.\n   The same example using the Content-Format application/merge-\n
      \  patch+json from [RFC7396] looks like the following:\n   JSON document original
      state:\n       {\n         \"x-coord\": 256,\n         \"y-coord\": 45,\n         \"foo\":
      [\"bar\",\"baz\"]\n       }\n   REQ: iPATCH CoAP://www.example.com/object\n
      \  Content-Format: 52 (application/merge-patch+json)\n        { \"x-coord\":45}\n
      \  RET: CoAP 2.04 Changed\n   JSON document final state:\n       {\n         \"x-coord\":
      45,\n         \"y-coord\": 45,\n         \"foo\": [\"bar\",\"baz\"]\n       }\n
      \  The examples show the use of the iPATCH method, but the use of the\n   PATCH
      method would have led to the same result.  Below, a non-\n   idempotent modification
      is shown.  Because the action is non-\n   idempotent, iPATCH returns an error,
      while PATCH executes the action.\n   JSON document original state:\n       {\n
      \        \"x-coord\": 256,\n         \"y-coord\": 45,\n         \"foo\": [\"bar\",\"baz\"]\n
      \      }\n   REQ: iPATCH CoAP://www.example.com/object\n   Content-Format: 51
      (application/json-patch+json)\n       [\n         { \"op\":\"add\",\"path\":\"foo/1\",\"value\":\"bar\"}\n
      \      ]\n   RET: CoAP 4.00 Bad Request\n   Diagnostic payload: Patch format
      not idempotent\n   JSON document final state is unchanged\n   REQ: PATCH CoAP://www.example.com/object\n
      \  Content-Format: 51 (application/json-patch+json)\n       [\n         { \"op\":\"add\",\"path\":\"foo/1\",\"value\":\"bar\"}\n
      \      ]\n   RET: CoAP 2.04 Changed\n   JSON document final state:\n       {\n
      \        \"x-coord\": 45,\n         \"y-coord\": 45,\n         \"foo\": [\"bar\",\"bar\",\"baz\"]\n
      \      }\n"
    title: 3.1.  Simple Examples for PATCH and iPATCH
  - contents:
    - "3.2.  Response Codes\n   PATCH and iPATCH for CoAP adopt the response codes
      as specified in\n   Sections 5.9 and 12.1.2 of [RFC7252] and add 4.09 (Conflict)
      and 4.22\n   (Unprocessable Entity) with the semantics specified in Section
      3.4 of\n   the present specification.\n"
    title: 3.2.  Response Codes
  - contents:
    - "3.3.  Option Numbers\n   PATCH and iPATCH for CoAP adopt the option numbers
      as specified in\n   Sections 5.10 and 12.2 of [RFC7252].\n"
    title: 3.3.  Option Numbers
  - contents:
    - "3.4.  Error Handling\n   A PATCH or iPATCH request may fail under certain known
      conditions.\n   These situations should be dealt with as expressed below.\n
      \  Malformed PATCH or iPATCH payload:  If a server determines that the\n      payload
      provided with a PATCH or iPATCH request is not properly\n      formatted, it
      can return a 4.00 (Bad Request) CoAP error.  The\n      definition of a malformed
      payload depends upon the CoAP Content-\n      Format specified with the request.\n
      \  Unsupported PATCH or iPATCH payload:  In case a client sends a\n      payload
      that is inappropriate for the resource identified by the\n      Request-URI,
      the server can return a 4.15 (Unsupported Content-\n      Format) CoAP error.
      \ The server can determine if the payload is\n      supported by checking the
      CoAP Content-Format specified with the\n      request.\n   Unprocessable request:
      \ This situation occurs when the payload of a\n      PATCH request is determined
      to be valid (i.e., well-formed and\n      supported) but the server is unable
      to or is incapable of\n      processing the request.  The server can return
      a 4.22\n      (Unprocessable Entity) CoAP error.  More specific scenarios might\n
      \     include situations such as:\n      *  the server has insufficient computing
      resources to complete the\n         request successfully -- 4.13 (Request Entity
      Too Large) CoAP\n         response code (see below); or\n      *  the resource
      specified in the request becomes invalid by\n         applying the payload --
      4.09 (Conflict) CoAP response code (see\n         \"Conflicting state\" below)).\n
      \     In case there are more specific errors that provide additional\n      insight
      into the problem, then those should be used.\n   Resource not found:  The 4.04
      (Not Found) error should be returned if\n      the payload of a PATCH request
      cannot be applied to a non-existent\n      resource.\n   Failed precondition:
      \ In case the client uses the conditional\n      If-Match or If-None-Match option
      to define a precondition for the\n      PATCH request, and that precondition
      fails, then the server can\n      return the 4.12 (Precondition Failed) CoAP
      error.\n   Request too large:  If the payload of the PATCH request is larger\n
      \     than a CoAP server can process, then it can return the 4.13\n      (Request
      Entity Too Large) CoAP error.\n   Conflicting state:  If the modification specified
      by a PATCH or\n      iPATCH request causes the resource to enter an inconsistent
      state\n      that the server cannot resolve, the server can return the 4.09\n
      \     (Conflict) CoAP response.  The server SHOULD generate a payload\n      that
      includes enough information for a user to recognize the\n      source of the
      conflict.  The server MAY return the actual resource\n      state to provide
      the client with the means to create a new\n      consistent resource state.
      \ Such a situation might be encountered\n      when a structural modification
      is applied to a configuration data\n      store but the structures being modified
      do not exist.\n   Concurrent modification:  Resource-constrained devices might
      need to\n      process requests in the order they are received.  In case requests\n
      \     are received concurrently to modify the same resource but they\n      cannot
      be queued, the server can return a 5.03 (Service\n      Unavailable) CoAP response
      code.\n   Conflict handling failure:  If the modification implies the\n      reservation
      of resources or the wait time for conditions to become\n      true leads to
      a too-long request execution time, the server can\n      return a 5.03 (Service
      Unavailable) response code.\n   It is possible that other error situations not
      mentioned here are\n   encountered by a CoAP server while processing the PATCH
      request.  In\n   these situations, other appropriate CoAP status codes can also
      be\n   returned.\n"
    title: 3.4.  Error Handling
  title: 3.  PATCH and iPATCH Methods
- contents:
  - "4.  The New Set of CoAP Methods\n   Adding three new methods to CoAP's existing
    four may seem like a\n   major change.  However, FETCH and the two PATCH variants
    fit well\n   into the REST paradigm and have been anticipated on the HTTP side.\n
    \  Adding both a non-idempotent and an idempotent PATCH variant allows\n   interoperability
    with HTTP's PATCH method to be kept and allows the\n   use/indication of an idempotent
    PATCH when that is possible, which\n   saves significant effort on the server
    side.\n   Interestingly, the three new methods fit into the old table of\n   methods
    with a surprising similarity in the idempotence and safety\n   attributes:\n           +------+--------+------+--------+------+------------+\n
    \          | Code | Name   | Code | Name   | safe | idempotent |\n           +------+--------+------+--------+------+------------+\n
    \          | 0.01 | GET    | 0.05 | FETCH  | yes  | yes        |\n           |
    0.02 | POST   | 0.06 | PATCH  | no   | no         |\n           | 0.03 | PUT    |
    0.07 | iPATCH | no   | yes        |\n           | 0.04 | DELETE |      |        |
    no   | yes        |\n           +------+--------+------+--------+------+------------+\n"
  title: 4.  The New Set of CoAP Methods
- contents:
  - "5.  Security Considerations\n   This section analyzes the possible threats to
    the CoAP FETCH and\n   PATCH or iPATCH methods.  It is meant to inform protocol
    and\n   application developers about the security limitations of CoAP FETCH\n
    \  and PATCH or iPATCH as described in this document.\n   The FETCH method is
    subject to the same general security\n   considerations as all CoAP methods as
    described in Section 11 of\n   [RFC7252].  Specifically, the security considerations
    for FETCH are\n   closest to those of GET, except that the FETCH request carries
    a\n   payload that may need additional protection.  The payload of a FETCH\n   request
    may reveal more detailed information about the specific\n   portions of a resource
    of interest to the requester than a GET\n   request for the entire resource would;
    this may mean that\n   confidentiality protection of the request by Datagram Transport
    Layer\n   Security (DTLS) or other means is needed for FETCH where it wouldn't\n
    \  be needed for GET.\n   The PATCH and iPATCH methods are subject to the same
    general security\n   considerations as all CoAP methods as described in Section
    11 of\n   [RFC7252].  The specific security considerations for PATCH or iPATCH\n
    \  are nearly identical to the security considerations for PUT\n   [RFC7252];
    the security considerations of Section 5 of [RFC5789] also\n   apply to PATCH
    and iPATCH.  Specifically, there is likely to be a\n   need for authorizing requests
    (possibly through access control and/or\n   authentication) and for ensuring that
    data is not corrupted through\n   transport errors or through accidental overwrites.
    \ The mechanisms\n   used for PUT can be used for PATCH or iPATCH as well.\n   The
    new methods defined in the present specification are secured\n   following the
    CoAP recommendations for the existing methods as\n   specified in Section 9 of
    [RFC7252].  When additional security\n   techniques are standardized for CoAP
    (e.g., Object Security), these\n   techniques are then also available for securing
    the new methods.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  IANA Considerations\n   IANA has added the following entries to the subregistry
    \"CoAP Method\n   Codes\":\n                       +------+--------+-----------+\n
    \                      | Code | Name   | Reference |\n                       +------+--------+-----------+\n
    \                      | 0.05 | FETCH  | RFC 8132  |\n                       |
    0.06 | PATCH  | RFC 8132  |\n                       | 0.07 | iPATCH | RFC 8132
    \ |\n                       +------+--------+-----------+\n   The FETCH method
    is idempotent and safe, and it returns the same\n   response codes that GET can
    return, plus 4.13 (Request Entity Too\n   Large), 4.15 (Unsupported Content-Format),
    and 4.22 (Unprocessable\n   Entity) with the semantics specified in Section 2.2.\n
    \  The PATCH method is neither idempotent nor safe.  It returns the same\n   response
    codes that POST can return, plus 4.09 (Conflict) and 4.22\n   (Unprocessable Entity)
    with the semantics specified in Section 3.4.\n   The iPATCH method is identical
    to the PATCH method, except that it is\n   idempotent.\n   IANA has added the
    following code to the subregistry \"CoAP Response\n   Codes\":\n                +------+----------------------+-----------+\n
    \               | Code | Name                 | Reference |\n                +------+----------------------+-----------+\n
    \               | 4.09 | Conflict             | RFC 8132  |\n                |
    4.22 | Unprocessable Entity | RFC 8132  |\n                +------+----------------------+-----------+\n
    \  IANA has added entries to the subregistry \"CoAP Content-Formats\":\n    +------------------------------+----------------+----+-----------+\n
    \   | Media Type                   | Content Coding | ID | Reference |\n    +------------------------------+----------------+----+-----------+\n
    \   | application/json-patch+json  | identity       | 51 | [RFC6902] |\n    |
    application/merge-patch+json | identity       | 52 | [RFC7396] |\n    +------------------------------+----------------+----+-----------+\n"
  title: 6.  IANA Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC5789]  Dusseault, L. and J. Snell, \"PATCH Method for HTTP\",\n              RFC
      5789, DOI 10.17487/RFC5789, March 2010,\n              <http://www.rfc-editor.org/info/rfc5789>.\n
      \  [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n              DOI
      10.17487/RFC7231, June 2014,\n              <http://www.rfc-editor.org/info/rfc7231>.\n
      \  [RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n              Application
      Protocol (CoAP)\", RFC 7252,\n              DOI 10.17487/RFC7252, June 2014,\n
      \             <http://www.rfc-editor.org/info/rfc7252>.\n   [RFC7641]  Hartke,
      K., \"Observing Resources in the Constrained\n              Application Protocol
      (CoAP)\", RFC 7641,\n              DOI 10.17487/RFC7641, September 2015,\n              <http://www.rfc-editor.org/info/rfc7641>.\n
      \  [RFC7959]  Bormann, C. and Z. Shelby, Ed., \"Block-Wise Transfers in\n              the
      Constrained Application Protocol (CoAP)\", RFC 7959,\n              DOI 10.17487/RFC7959,
      August 2016,\n              <http://www.rfc-editor.org/info/rfc7959>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [RFC5323]  Reschke, J., Ed., Reddy, S., Davis,
      J., and A. Babich,\n              \"Web Distributed Authoring and Versioning
      (WebDAV)\n              SEARCH\", RFC 5323, DOI 10.17487/RFC5323, November 2008,\n
      \             <http://www.rfc-editor.org/info/rfc5323>.\n   [RFC6902]  Bryan,
      P., Ed. and M. Nottingham, Ed., \"JavaScript Object\n              Notation
      (JSON) Patch\", RFC 6902, DOI 10.17487/RFC6902,\n              April 2013, <http://www.rfc-editor.org/info/rfc6902>.\n
      \  [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n
      \             Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n
      \             2014, <http://www.rfc-editor.org/info/rfc7159>.\n   [RFC7396]
      \ Hoffman, P. and J. Snell, \"JSON Merge Patch\", RFC 7396,\n              DOI
      10.17487/RFC7396, October 2014,\n              <http://www.rfc-editor.org/info/rfc7396>.\n
      \  [COAP-MGMNT]\n              Stok, P., Bierman, A., Veillette, M., and A.
      Pelov, \"CoAP\n              Management Interface\", Work in Progress,\n              draft-ietf-core-comi-00,
      January 2017.\n   [CORE-APP] Hartke, K., \"CoRE Application Descriptions\",
      Work in\n              Progress, draft-hartke-core-apps-07, February 2017.\n
      \  [HTTP-SEARCH]\n              Reschke, J., Malhotra, A., and J. Snell, \"HTTP
      SEARCH\n              Method\", Work in Progress, draft-snell-search-method-00,\n
      \             April 2015.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Acknowledgements\n   Klaus Hartke has pointed out some essential differences
    between CoAP\n   and HTTP concerning PATCH and found a number of problems in an\n
    \  earlier draft version of Section 2.  We are grateful for discussions\n   with
    Christian Amsuss, Andy Bierman, Timothy Carey, Paul Duffy,\n   Matthias Kovatsch,
    Michel Veillette, Michael Verschoor, Thomas\n   Watteyne, and Gengyu Wei.  Christian
    Groves provided detailed\n   comments during the Working Group Last Call, and
    Christer Holmberg's\n   Gen-ART review provided some further editorial improvement.
    \ Further\n   Last Call reviews were provided by Sheng Jiang and Phillip Hallam-\n
    \  Baker.  As usual, the IESG had some very good reviews, and we would\n   like
    to specifically call out those by Alexey Melnikov (responsible\n   AD) and Alissa
    Cooper.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Peter van der Stok\n   Consultant\n   Email: consultancy@vanderstok.org\n
    \  Carsten Bormann\n   Universitaet Bremen TZI\n   Postfach 330440\n   Bremen
    \ D-28359\n   Germany\n   Phone: +49-421-218-63921\n   Email: cabo@tzi.org\n   Anuj
    Sehgal\n   NAVOMI, Inc.\n   Email: anuj.sehgal@navomi.com\n"
  title: Authors' Addresses
