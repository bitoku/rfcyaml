- title: __initial_text__
  contents:
  - "                 A Quick Crash Detection Method for the\n                  Internet\
    \ Key Exchange Protocol (IKE)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes an extension to the Internet Key Exchange\n\
    \   Protocol version 2 (IKEv2) that allows for faster detection of\n   Security\
    \ Association (SA) desynchronization using a saved token.\n   When an IPsec tunnel\
    \ between two IKEv2 peers is disconnected due to a\n   restart of one peer, it\
    \ can take as much as several minutes for the\n   other peer to discover that\
    \ the reboot has occurred, thus delaying\n   recovery.  In this text, we propose\
    \ an extension to the protocol that\n   allows for recovery immediately following\
    \ the restart.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6290.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Conventions Used in This Document  . . . . . . .\
    \ . . . . .  3\n   2.  RFC 5996 Crash Recovery  . . . . . . . . . . . . . . .\
    \ . . . .  4\n   3.  Protocol Outline . . . . . . . . . . . . . . . . . . . .\
    \ . . .  5\n   4.  Formats and Exchanges  . . . . . . . . . . . . . . . . . .\
    \ . .  6\n     4.1.  Notification Format  . . . . . . . . . . . . . . . . . .\
    \ .  6\n     4.2.  Passing a Token in the AUTH Exchange . . . . . . . . . . .\
    \  7\n     4.3.  Replacing Tokens after Rekey or Resumption . . . . . . . .  8\n\
    \     4.4.  Replacing the Token for an Existing SA . . . . . . . . . .  9\n  \
    \   4.5.  Presenting the Token in an Unprotected Message . . . . . .  9\n   5.\
    \  Token Generation and Verification  . . . . . . . . . . . . . . 10\n     5.1.\
    \  A Stateless Method of Token Generation . . . . . . . . . . 11\n     5.2.  A\
    \ Stateless Method with IP Addresses . . . . . . . . . . . 11\n     5.3.  Token\
    \ Lifetime . . . . . . . . . . . . . . . . . . . . . . 12\n   6.  Backup Gateways\
    \  . . . . . . . . . . . . . . . . . . . . . . . 12\n   7.  Interaction with Session\
    \ Resumption  . . . . . . . . . . . . . 13\n   8.  Operational Considerations\
    \ . . . . . . . . . . . . . . . . . . 14\n     8.1.  Who Should Implement This\
    \ Specification  . . . . . . . . . 14\n     8.2.  Response to Unknown Child SPI\
    \  . . . . . . . . . . . . . . 15\n   9.  Security Considerations  . . . . . .\
    \ . . . . . . . . . . . . . 16\n     9.1.  QCD Token Generation and Handling \
    \ . . . . . . . . . . . . 16\n     9.2.  QCD Token Transmission . . . . . . .\
    \ . . . . . . . . . . . 17\n     9.3.  QCD Token Enumeration  . . . . . . . .\
    \ . . . . . . . . . . 18\n   10. IANA Considerations  . . . . . . . . . . . .\
    \ . . . . . . . . . 18\n   11. Acknowledgements . . . . . . . . . . . . . . .\
    \ . . . . . . . . 18\n   12. References . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 19\n     12.1. Normative References . . . . . . . . . . . . .\
    \ . . . . . . 19\n     12.2. Informative References . . . . . . . . . . . . .\
    \ . . . . . 19\n   Appendix A.  The Path Not Taken  . . . . . . . . . . . . .\
    \ . . . . 20\n     A.1.  Initiating a New IKE SA  . . . . . . . . . . . . . .\
    \ . . . 20\n     A.2.  SIR  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 20\n     A.3.  Birth Certificates . . . . . . . . . . . . . . . . . . .\
    \ . 20\n     A.4.  Reducing Liveness Check Length . . . . . . . . . . . . . .\
    \ 21\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IKEv2, as described in [RFC5996] and its predecessor RFC\
    \ 4306, has a\n   method for recovering from a reboot of one peer.  As long as\
    \ traffic\n   flows in both directions, the rebooted peer should re-establish\
    \ the\n   tunnels immediately.  However, in many cases, the rebooted peer is a\n\
    \   VPN gateway that protects only servers, so all traffic is inbound.\n   In\
    \ other cases, the non-rebooted peer has a dynamic IP address, so\n   the rebooted\
    \ peer cannot initiate IKE because its current IP address\n   is unknown.  In\
    \ such cases, the rebooted peer will not be able to\n   re-establish the tunnels.\
    \  Section 2 describes how recovery works\n   under RFC 5996, and explains why\
    \ it may take several minutes.\n   The method proposed here is to send an octet\
    \ string, called a \"QCD\n   token\", in the IKE_AUTH exchange that establishes\
    \ the tunnel.  That\n   token can be stored on the peer as part of the IKE SA.\
    \  After a\n   reboot, the rebooted implementation can re-generate the token and\n\
    \   send it to the peer, so as to delete the IKE SA.  Deleting the IKE SA\n  \
    \ results in a quick establishment of new IPsec tunnels.  This is\n   described\
    \ in Section 3.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n   The term \"token\" refers to an octet string that an implementation\
    \ can\n   generate using only the properties of a protected IKE message (such\n\
    \   as IKE Security Parameter Indexes (SPIs)) as input.  A conforming\n   implementation\
    \ MUST be able to generate the same token from the same\n   input even after rebooting.\n\
    \   The term \"token maker\" refers to an implementation that generates a\n  \
    \ token and sends it to the peer as specified in this document.\n   The term \"\
    token taker\" refers to an implementation that stores such a\n   token or a digest\
    \ thereof, in order to verify that a new token it\n   receives is identical to\
    \ the old token it has stored.\n   The term \"non-volatile storage\" in this document\
    \ refers to a data\n   storage module that persists across restarts of the token\
    \ maker.\n   Examples of such a storage module include an internal disk, an\n\
    \   internal flash memory module, an external disk, and an external\n   database.\
    \  A small non-volatile storage module is required for a\n   token maker, but\
    \ a larger one can be used to enhance performance, as\n   described in Section\
    \ 8.2.\n"
- title: 2.  RFC 5996 Crash Recovery
  contents:
  - "2.  RFC 5996 Crash Recovery\n   When one peer loses state or reboots, the other\
    \ peer does not get any\n   notification, so unidirectional IPsec traffic can\
    \ still flow.  The\n   rebooted peer will not be able to decrypt it, however,\
    \ and the only\n   remedy is to send an unprotected INVALID_SPI notification as\n\
    \   described in Section 3.10.1 of [RFC5996].  That section also\n   describes\
    \ the processing of such a notification:\n      If this Informational Message\
    \ is sent outside the context of an\n      IKE_SA, it should be used by the recipient\
    \ only as a \"hint\" that\n      something might be wrong (because it could easily\
    \ be forged).\n   Since the INVALID_SPI can only be used as a hint, the non-rebooted\n\
    \   peer has to determine whether the IPsec SA and indeed the parent IKE\n   SA\
    \ are still valid.  The method of doing this is described in Section\n   2.4 of\
    \ [RFC5996].  This method, called \"liveness check\", involves\n   sending a protected\
    \ empty INFORMATIONAL message, and awaiting a\n   response.  This procedure is\
    \ sometimes referred to as \"Dead Peer\n   Detection\" or DPD.\n   Section 2.4\
    \ does not mandate how many times the liveness check\n   message should be retransmitted,\
    \ or for how long, but does recommend\n   the following:\n      It is suggested\
    \ that messages be retransmitted at least a dozen\n      times over a period of\
    \ at least several minutes before giving up\n      on an SA...\n   Those \"at\
    \ least several minutes\" are a time during part of which both\n   peers are active,\
    \ but IPsec cannot be used.\n   Especially in the case of a reboot (rather than\
    \ fail-over or\n   administrative clearing of state), the peer does not recover\n\
    \   immediately.  Reboot, depending on the system, may take from a few\n   seconds\
    \ to a few minutes.  This means that at first the peer just\n   goes silent, i.e.,\
    \ does not send or respond to any messages.  IKEv2\n   implementations can detect\
    \ this situation and follow the rules given\n   in Section 2.4:\n      If there\
    \ has only been outgoing traffic on all of the SAs\n      associated with an IKE\
    \ SA, it is essential to confirm liveness of\n      the other endpoint to avoid\
    \ black holes.  If no cryptographically\n      protected messages have been received\
    \ on an IKE SA or any of its\n      Child SAs recently, the system needs to perform\
    \ a liveness check\n      in order to prevent sending messages to a dead peer.\n\
    \   [RFC5996] does not mandate any time limits, but it is possible that\n   the\
    \ peer will start liveness checks even before the other end is\n   sending INVALID_SPI\
    \ notification, as it detected that the other end\n   is not sending any packets\
    \ anymore while it is still rebooting or\n   recovering from the situation.\n\
    \   This means that the several minutes recovery period is overlapping\n   the\
    \ actual recover time of the other peer; i.e., if the security\n   gateway requires\
    \ several minutes to boot up from the crash, then the\n   other peers have already\
    \ finished their liveness checks before the\n   crashing peer even has a chance\
    \ to send INVALID_SPI notifications.\n   There are cases where the peer loses\
    \ state and is able to recover\n   immediately; in those cases it might take several\
    \ minutes to recreate\n   the IPsec SAs.\n   Note that the IKEv2 specification\
    \ specifically gives no guidance for\n   the number of retries or the length of\
    \ timeouts, as these do not\n   affect interoperability.  This means that implementations\
    \ are allowed\n   to use the hints provided by the INVALID_SPI messages to shorten\n\
    \   those timeouts (i.e., a different environment and situation requiring\n  \
    \ different rules).\n   Some existing IKEv2 implementations already do that (i.e.,\
    \ shorten\n   timeouts or limit number of retries) based on these kinds of hints\n\
    \   and also start liveness checks quickly after the other end goes\n   silent.\
    \  However, see Appendix A.4 for a discussion of why this may\n   not be enough.\n"
- title: 3.  Protocol Outline
  contents:
  - "3.  Protocol Outline\n   Supporting implementations will send a notification,\
    \ called a \"QCD\n   token\", as described in Section 4.1 in the first IKE_AUTH\
    \ exchange\n   messages.  These are the first IKE_AUTH request and final IKE_AUTH\n\
    \   response that contain the AUTH payloads.  The generation of these\n   tokens\
    \ is a local matter for implementations, but considerations are\n   described\
    \ in Section 5.  Implementations that send such a token will\n   be called \"\
    token makers\".\n   A supporting implementation receiving such a token MUST store\
    \ it (or\n   a digest thereof) along with the IKE SA.  Implementations that\n\
    \   support this part of the protocol will be called \"token takers\".\n   Section\
    \ 8.1 has considerations for which implementations need to be\n   token takers,\
    \ and which should be token makers.  Implementations that\n   are not token takers\
    \ will silently ignore QCD tokens.\n   When a token maker receives a protected\
    \ IKE request message with\n   unknown IKE SPIs, it SHOULD generate a new token\
    \ that is identical to\n   the previous token, and send it to the requesting peer\
    \ in an\n   unprotected IKE message as described in Section 4.5.\n   When a token\
    \ taker receives the QCD token in an unprotected\n   notification, it MUST verify\
    \ that the TOKEN_SECRET_DATA matches the\n   token stored with the matching IKE\
    \ SA.  If the verification fails, or\n   if the IKE SPIs in the message do not\
    \ match any existing IKE SA, it\n   SHOULD log the event.  If it succeeds, it\
    \ MUST silently delete the\n   IKE SA associated with the IKE_SPI fields and all\
    \ dependent child\n   SAs.  This event MAY also be logged.  The token taker MUST\
    \ accept\n   such tokens from any IP address and port combination, so as to allow\n\
    \   different kinds of high-availability configurations of the token\n   maker.\n\
    \   A supporting token taker MAY immediately create new SAs using an\n   Initial\
    \ exchange, or it may wait for subsequent traffic to trigger\n   the creation\
    \ of new SAs.\n   See Section 7 for a short discussion about this extension's\n\
    \   interaction with IKEv2 Session Resumption ([RFC5723]).\n"
- title: 4.  Formats and Exchanges
  contents:
  - '4.  Formats and Exchanges

    '
- title: 4.1.  Notification Format
  contents:
  - "4.1.  Notification Format\n   The notification payload called \"QCD token\" is\
    \ formatted as follows:\n                            1                   2   \
    \                3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       ! Next Payload  !C!  RESERVED   !         Payload Length        !\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   !  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       !\
    \                                                               !\n       ~  \
    \                     TOKEN_SECRET_DATA                       ~\n       !    \
    \                                                           !\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o  Protocol ID (1 octet) MUST be 1, as this message is related to an\n   \
    \   IKE SA.\n   o  SPI Size (1 octet) MUST be zero, in conformance with Section\
    \ 3.10\n      of [RFC5996].\n   o  QCD Token Notify Message Type (2 octets) -\
    \ MUST be 16419, the\n      value assigned for QCD token notifications.\n   o\
    \  TOKEN_SECRET_DATA (variable) contains a generated token as\n      described\
    \ in Section 5.\n"
- title: 4.2.  Passing a Token in the AUTH Exchange
  contents:
  - "4.2.  Passing a Token in the AUTH Exchange\n   For brevity, only the Extensible\
    \ Authentication Protocol (EAP)\n   version of an AUTH exchange will be presented\
    \ here.  The non-EAP\n   version is very similar.  The figures below are based\
    \ on Appendix C.3\n   of [RFC5996].\n    first request       --> IDi,\n      \
    \                      [N(INITIAL_CONTACT)],\n                            [[N(HTTP_CERT_LOOKUP_SUPPORTED)],\
    \ CERTREQ+],\n                            [IDr],\n                           \
    \ [N(QCD_TOKEN)]\n                            [CP(CFG_REQUEST)],\n           \
    \                 [N(IPCOMP_SUPPORTED)+],\n                            [N(USE_TRANSPORT_MODE)],\n\
    \                            [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n           \
    \                 [N(NON_FIRST_FRAGMENTS_ALSO)],\n                           \
    \ SA, TSi, TSr,\n                            [V+]\n    first response      <--\
    \ IDr, [CERT+], AUTH,\n                            EAP,\n                    \
    \        [V+]\n                      / --> EAP\n    repeat 1..N times |\n    \
    \                  \\ <-- EAP\n    last request        --> AUTH\n    last response\
    \       <-- AUTH,\n                            [N(QCD_TOKEN)]\n              \
    \              [CP(CFG_REPLY)],\n                            [N(IPCOMP_SUPPORTED)],\n\
    \                            [N(USE_TRANSPORT_MODE)],\n                      \
    \      [N(ESP_TFC_PADDING_NOT_SUPPORTED)],\n                            [N(NON_FIRST_FRAGMENTS_ALSO)],\n\
    \                            SA, TSi, TSr,\n                            [N(ADDITIONAL_TS_POSSIBLE)],\n\
    \                            [V+]\n   Note that the QCD_TOKEN notification is\
    \ marked as optional because it\n   is not required by this specification that\
    \ every implementation be\n   both token maker and token taker.  If only one peer\
    \ sends the QCD\n   token, then a reboot of the other peer will not be recoverable\
    \ by\n   this method.  This may be acceptable if traffic typically originates\n\
    \   from the other peer.\n   In any case, the lack of a QCD_TOKEN notification\
    \ MUST NOT be taken\n   as an indication that the peer does not support this standard.\n\
    \   Conversely, if a peer does not understand this notification, it will\n   simply\
    \ ignore it.  Therefore, a peer may send this notification\n   freely, even if\
    \ it does not know whether the other side supports it.\n   The QCD_TOKEN notification\
    \ is related to the IKE SA and should follow\n   the AUTH payload and precede\
    \ the Configuration payload and all\n   payloads related to the child SA.\n"
- title: 4.3.  Replacing Tokens after Rekey or Resumption
  contents:
  - "4.3.  Replacing Tokens after Rekey or Resumption\n   After rekeying an IKE SA,\
    \ the IKE SPIs are replaced, so the new SA\n   also needs to have a token.  If\
    \ only the responder in the rekey\n   exchange is the token maker, this can be\
    \ done within the\n   CREATE_CHILD_SA exchange.  If the initiator is a token maker,\
    \ then we\n   need an extra informational exchange.\n   The following figure shows\
    \ the CREATE_CHILD_SA exchange for rekeying\n   the IKE SA.  Only the responder\
    \ sends a QCD token.\n      request             --> SA, Ni, [KEi]\n      response\
    \            <-- SA, Nr, [KEr], N(QCD_TOKEN)\n   If the initiator is also a token\
    \ maker, it SHOULD initiate an\n   INFORMATIONAL exchange immediately after the\
    \ CREATE_CHILD_SA exchange\n   as follows:\n      request             --> N(QCD_TOKEN)\n\
    \      response            <--\n   For session resumption, as specified in [RFC5723],\
    \ the situation is\n   similar.  The responder, which is necessarily the peer\
    \ that has\n   crashed, SHOULD send a new ticket within the protected payload\
    \ of the\n   IKE_SESSION_RESUME exchange.  If the Initiator is also a token maker,\n\
    \   it needs to send a QCD_TOKEN in a separate INFORMATIONAL exchange.\n   The\
    \ INFORMATIONAL exchange described in this section can also be used\n   if QCD\
    \ tokens need to be replaced due to a key rollover.  However,\n   since token\
    \ takers are required to verify at least 4 QCD tokens, this\n   is only necessary\
    \ if secret QCD keys are rolled over more than four\n   times as often as IKE\
    \ SAs are rekeyed.  See Section 5.1 for an\n   example method that uses secret\
    \ keys that may require rollover.\n"
- title: 4.4.  Replacing the Token for an Existing SA
  contents:
  - "4.4.  Replacing the Token for an Existing SA\n   With some token generation methods,\
    \ such as that described in\n   Section 5.2, a QCD token may sometimes become\
    \ invalid, although the\n   IKE SA is still perfectly valid.\n   In such a case,\
    \ the token maker MUST send the new token in a\n   protected message under that\
    \ IKE SA.  That exchange could be a simple\n   INFORMATIONAL, such as in the last\
    \ figure in the previous section, or\n   else it can be part of a MOBIKE INFORMATIONAL\
    \ exchange such as in the\n   following figure taken from Section 2.2 of [RFC4555]\
    \ and modified by\n   adding a QCD_TOKEN notification:\n     (IP_I2:4500 -> IP_R1:4500)\n\
    \     HDR, SK { N(UPDATE_SA_ADDRESSES),\n               N(NAT_DETECTION_SOURCE_IP),\n\
    \               N(NAT_DETECTION_DESTINATION_IP) }  -->\n                     \
    \      <-- (IP_R1:4500 -> IP_I2:4500)\n                               HDR, SK\
    \ { N(NAT_DETECTION_SOURCE_IP),\n                                    N(NAT_DETECTION_DESTINATION_IP)\
    \ }\n                           <-- (IP_R1:4500 -> IP_I2:4500)\n             \
    \                  HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }\n     (IP_I2:4500 ->\
    \ IP_R1:4500)\n     HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }  -->\n   A token taker\
    \ MUST accept such gratuitous QCD_TOKEN notifications as\n   long as they are\
    \ carried in protected exchanges.  A token maker\n   SHOULD NOT generate them\
    \ unless it is no longer able to generate the\n   old QCD_TOKEN.\n"
- title: 4.5.  Presenting the Token in an Unprotected Message
  contents:
  - "4.5.  Presenting the Token in an Unprotected Message\n   This QCD_TOKEN notification\
    \ is unprotected, and is sent as a response\n   to a protected IKE request, which\
    \ uses an IKE SA that is unknown.\n            message             --> N(INVALID_IKE_SPI),\
    \ N(QCD_TOKEN)+\n   If child SPIs are persistently mapped to IKE SPIs as described\
    \ in\n   Section 8.2, a token taker may get the following unprotected message\n\
    \   in response to an Encapsulating Security Payload (ESP) or\n   Authentication\
    \ Header (AH) packet.\n            message             --> N(INVALID_SPI), N(QCD_TOKEN)+\n\
    \   The QCD_TOKEN and INVALID_IKE_SPI notifications are sent together to\n   support\
    \ both implementations that conform to this specification and\n   implementations\
    \ that don't.  Similar to the description in Section\n   2.21 of [RFC5996], the\
    \ IKE SPI and message ID fields in the packet\n   headers are taken from the protected\
    \ IKE request.\n   To support a periodic rollover of the secret used for token\n\
    \   generation, the token taker MUST support at least four QCD_TOKEN\n   notifications\
    \ in a single packet.  The token is considered verified\n   if any of the QCD_TOKEN\
    \ notifications matches.  The token maker MAY\n   generate up to four QCD_TOKEN\
    \ notifications, based on several\n   generations of keys.\n   If the QCD_TOKEN\
    \ verifies OK, the receiver MUST silently discard the\n   IKE SA and all associated\
    \ child SAs.  If the QCD_TOKEN cannot be\n   validated, a response MUST NOT be\
    \ sent, and the event may be logged.\n   Section 5 defines token verification.\n"
- title: 5.  Token Generation and Verification
  contents:
  - "5.  Token Generation and Verification\n   No token generation method is mandated\
    \ by this document.  Two methods\n   are documented in the following sub-sections,\
    \ but they only serve as\n   examples.\n   The following lists the requirements\
    \ for a token generation\n   mechanism:\n   o  Tokens MUST be at least 16 octets\
    \ long, and no more than 128\n      octets long, to facilitate storage and transmission.\
    \  Tokens\n      SHOULD be indistinguishable from random data.\n   o  It should\
    \ not be possible for an external attacker to guess the\n      QCD token generated\
    \ by an implementation.  Cryptographic\n      mechanisms such as a pseudo-random\
    \ number generator (PRNG) and\n      hash functions are RECOMMENDED.\n   o  The\
    \ token maker MUST be able to re-generate or retrieve the token\n      based on\
    \ the IKE SPIs even after it reboots.\n   o  The method of token generation MUST\
    \ be such that a collision of\n      QCD tokens between different pairs of IKE\
    \ SPI will be highly\n      unlikely.\n   For verification, the token taker makes\
    \ a bitwise comparison of the\n   token stored along with the IKE SA with the\
    \ token sent in the\n   unprotected message.  Multihomed takers might flip back-and-forth\n\
    \   between several addresses, and have their tokens replaced as\n   described\
    \ in Section 4.4.  To help avoid the case where the latest\n   stored token does\
    \ not match the address used after the maker lost\n   state, the token taker MAY\
    \ store several earlier tokens associated\n   with the IKE SA, and silently discard\
    \ the SA if any of them matches.\n"
- title: 5.1.  A Stateless Method of Token Generation
  contents:
  - "5.1.  A Stateless Method of Token Generation\n   The following describes a stateless\
    \ method of generating a token.  In\n   this case, 'stateless' means not maintaining\
    \ any per-tunnel state,\n   although there is a small amount of non-volatile storage\
    \ required.\n   o  At installation or immediately after the first boot of the\
    \ token\n      maker, 32 random octets are generated using a secure random number\n\
    \      generator or a PRNG.\n   o  Those 32 bytes, called the \"QCD_SECRET\",\
    \ are stored in non-\n      volatile storage on the machine, and kept indefinitely.\n\
    \   o  If key rollover is required by policy, the implementation MAY\n      periodically\
    \ generate a new QCD_SECRET and keep up to 3 previous\n      generations.  When\
    \ sending an unprotected QCD_TOKEN, as many as 4\n      notification payloads\
    \ may be sent, each from a different\n      QCD_SECRET.\n   o  The TOKEN_SECRET_DATA\
    \ is calculated as follows:\n            TOKEN_SECRET_DATA = HASH(QCD_SECRET |\
    \ SPI-I | SPI-R)\n"
- title: 5.2.  A Stateless Method with IP Addresses
  contents:
  - "5.2.  A Stateless Method with IP Addresses\n   This method is similar to the\
    \ one in the previous section, except\n   that the IP address of the token taker\
    \ is also added to the block\n   being hashed.  This has the disadvantage that\
    \ the token needs to be\n   replaced (as described in Section 4.4) whenever the\
    \ token taker\n   changes its address.\n   See Section 9.2 for a discussion of\
    \ a use-case for this method.  When\n   using this method, the TOKEN_SECRET_DATA\
    \ field is calculated as\n   follows:\n         TOKEN_SECRET_DATA = HASH(QCD_SECRET\
    \ | SPI-I | SPI-R | IPaddr-T)\n   The IPaddr-T field specifies the IP address\
    \ of the token taker.\n   Secret rollover considerations are similar to those\
    \ in the previous\n   section.\n   Note that with a multihomed token taker, the\
    \ QCD token matches just\n   one of the token taker IP addresses.  Usually this\
    \ is not a problem,\n   as packets sent to the token maker come out the same IP\
    \ address.  If\n   for some reason this changes, then the token maker can replace\
    \ the\n   token as described in Section 4.4.  If IKEv2 Mobility and Multihoming\n\
    \   (MOBIKE) is used, replacing the tokens SHOULD be piggybacked on the\n   INFORMATIONAL\
    \ exchange with the UPDATE_SA_ADDRESSES notifications.\n   There is a corner case\
    \ where the token taker begins using a new IP\n   address (because of multihoming,\
    \ roaming, or normal network\n   operations) and the token maker loses state before\
    \ replacing the\n   token.  In that case, it will send a correct QCD token, but\
    \ the token\n   taker will still have the old token.  In that case, the extension\n\
    \   will not work, and the peers will revert to RFC 5996 recovery.\n"
- title: 5.3.  Token Lifetime
  contents:
  - "5.3.  Token Lifetime\n   The token is associated with a single IKE SA and SHOULD\
    \ be deleted by\n   the token taker when the SA is deleted or expires.  More formally,\n\
    \   the token is associated with the pair (SPI-I, SPI-R).\n"
- title: 6.  Backup Gateways
  contents:
  - "6.  Backup Gateways\n   Making crash detection and recovery quick is a worthy\
    \ goal, but since\n   rebooting a gateway takes a non-zero amount of time, many\n\
    \   implementations choose to have a standby gateway ready to take over\n   as\
    \ soon as the primary gateway fails for any reason.  [RFC6027]\n   describes considerations\
    \ for such clusters of gateways with\n   synchronized state, but the rest of this\
    \ section is relevant even\n   when there is no synchronized state.\n   If such\
    \ a configuration is available, it is RECOMMENDED that the\n   standby gateway\
    \ be able to generate the same token as the active\n   gateway.  If the method\
    \ described in Section 5.1 is used, this means\n   that the QCD_SECRET field is\
    \ identical in both gateways.  This has\n   the effect of having the crash recovery\
    \ available immediately.\n   Note that this refers to \"high-availability\" configurations,\
    \ where\n   only one gateway is active at any given moment.  This is different\n\
    \   from \"load sharing\" configurations where more than one gateway is\n   active\
    \ at the same time.  For load sharing configurations, please see\n   Section 9.2\
    \ for security considerations.\n"
- title: 7.  Interaction with Session Resumption
  contents:
  - "7.  Interaction with Session Resumption\n   Session resumption, specified in\
    \ [RFC5723], allows the setting up of\n   a new IKE SA to consume less computing\
    \ resources.  This is\n   particularly useful in the case of a remote access gateway\
    \ that has\n   many tunnels.  A failure of such a gateway requires all these many\n\
    \   remote access clients to establish an IKE SA either with the rebooted\n  \
    \ gateway or with a backup.  This tunnel re-establishment occurs within\n   a\
    \ short period of time, creating a burden on the remote access\n   gateway.  Session\
    \ resumption addresses this problem by having the\n   clients store an encrypted\
    \ derivative of the IKE SA for quick\n   re-establishment.\n   What Session Resumption\
    \ does not help is the problem of detecting\n   that the peer gateway has failed.\
    \  A failed gateway may go undetected\n   for an arbitrarily long time, because\
    \ IPsec does not have packet\n   acknowledgement, and applications cannot signal\
    \ the IPsec layer that\n   the tunnel \"does not work\".  Section 2.4 of RFC 5996\
    \ does not specify\n   how long an implementation needs to wait before beginning\
    \ a liveness\n   check, and only says \"not recently\" (see full quote in Section\
    \ 2).\n   In practice, some mobile devices wait a very long time before\n   beginning\
    \ a liveness check, in order to extend battery life by\n   allowing parts of the\
    \ device to remain in low-power modes.\n   QCD tokens provide a way to detect\
    \ the failure of the peer in the\n   case where a liveness check has not yet ended\
    \ (or begun).\n   A remote access client conforming to both specifications will\
    \ store\n   QCD tokens, as well as the Session Resumption ticket, if provided\
    \ by\n   the gateway.  A remote access gateway conforming to both\n   specifications\
    \ will generate a QCD token for the client.  When the\n   gateway reboots, the\
    \ client will discover this in either of two ways:\n   1.  The client does regular\
    \ liveness checks, or else the time for\n       some other IKE exchange has come.\
    \  Since the gateway is still\n       down, the IKE exchange times out after several\
    \ minutes.  In this\n       case, QCD does not help.\n   2.  Either the primary\
    \ gateway or a backup gateway (see Section 6) is\n       ready and sends a QCD\
    \ token to the client.  In that case, the\n       client will quickly re-establish\
    \ the IPsec tunnel, either with\n       the rebooted primary gateway or the backup\
    \ gateway as described\n       in this document.\n   The full combined protocol\
    \ looks like this:\n        Initiator                Responder\n        -----------\
    \              -----------\n       HDR, SAi1, KEi, Ni  -->\n                 \
    \          <--    HDR, SAr1, KEr, Nr, [CERTREQ]\n       HDR, SK {IDi, [CERT,]\n\
    \       [CERTREQ,] [IDr,]\n       AUTH, N(QCD_TOKEN)\n       SAi2, TSi, TSr,\n\
    \       N(TICKET_REQUEST)}  -->\n                           <--    HDR, SK {IDr,\
    \ [CERT,] AUTH,\n                                  N(QCD_TOKEN), SAr2, TSi, TSr,\n\
    \                                  N(TICKET_LT_OPAQUE) }\n                ----\
    \ Reboot -----\n       HDR, {}             -->\n                           <--\
    \  HDR, N(QCD_TOKEN)\n       HDR, [N(COOKIE),]\n       Ni, N(TICKET_OPAQUE)\n\
    \       [,N+]               -->\n                           <--  HDR, Nr [,N+]\n"
- title: 8.  Operational Considerations
  contents:
  - '8.  Operational Considerations

    '
- title: 8.1.  Who Should Implement This Specification
  contents:
  - "8.1.  Who Should Implement This Specification\n   Throughout this document, we\
    \ have referred to reboot time\n   alternatingly as the time that the implementation\
    \ crashes and the\n   time when it is ready to process IPsec packets and IKE exchanges.\n\
    \   Depending on the hardware and software platforms and the cause of the\n  \
    \ reboot, rebooting may take anywhere from a few seconds to several\n   minutes.\
    \  If the implementation is down for a long time, the benefit\n   of this protocol\
    \ extension is reduced.  For this reason, critical\n   systems should implement\
    \ backup gateways as described in Section 6.\n   Implementing the \"token maker\"\
    \ side of QCD makes sense for IKE\n   implementation where protected connections\
    \ originate from the peer,\n   such as inter-domain VPNs and remote access gateways.\
    \  Implementing\n   the \"token taker\" side of QCD makes sense for IKE implementations\n\
    \   where protected connections originate, such as inter-domain VPNs and\n   remote\
    \ access clients.\n   To clarify this discussion:\n   o  For remote-access clients\
    \ it makes sense to implement the token\n      taker role.\n   o  For remote-access\
    \ gateways it makes sense to implement the token\n      maker role.\n   o  For\
    \ inter-domain VPN gateways it makes sense to implement both\n      roles, because\
    \ it can't be known in advance where the traffic\n      originates.\n   o  It\
    \ is perfectly valid to implement both roles in any case, for\n      example,\
    \ when using a single library or a single gateway to\n      perform several roles.\n\
    \   In order to limit the effects of Denial-of-Service (DoS) attacks, a\n   token\
    \ taker SHOULD limit the rate of QCD_TOKENs verified from a\n   particular source.\n\
    \   If excessive amounts of IKE requests protected with unknown IKE SPIs\n   arrive\
    \ at a token maker, the IKE module SHOULD revert to the behavior\n   described\
    \ in Section 2.21 of [RFC5996] and either send an\n   INVALID_IKE_SPI notification\
    \ or ignore it entirely.\n   Section 9.2 requires that token makers never send\
    \ a QCD token in the\n   clear for a valid IKE SA and describes some configurations\
    \ where this\n   could occur.  Implementations that may be installed in such\n\
    \   configurations SHOULD automatically detect this and disable this\n   extension\
    \ in unsafe configurations and MUST allow the user to control\n   whether the\
    \ extension is enabled or disabled.\n"
- title: 8.2.  Response to Unknown Child SPI
  contents:
  - "8.2.  Response to Unknown Child SPI\n   After a reboot, it is more likely that\
    \ an implementation will receive\n   IPsec packets than IKE packets.  In that\
    \ case, the rebooted\n   implementation will send an INVALID_SPI notification,\
    \ triggering a\n   liveness check.  The token will only be sent in a response\
    \ to the\n   liveness check, thus requiring an extra round trip.\n   To avoid\
    \ this, an implementation that has access to enough non-\n   volatile storage\
    \ MAY store a mapping of child SPIs to owning IKE\n   SPIs, or to generated tokens.\
    \  If such a mapping is available and\n   persistent across reboots, the rebooted\
    \ implementation SHOULD respond\n   to the IPsec packet with an INVALID_SPI notification,\
    \ along with the\n   appropriate QCD_TOKEN notifications.  A token taker SHOULD\
    \ verify the\n   QCD token that arrives with an INVALID_SPI notification the same\
    \ as\n   if it arrived with the IKE SPIs of the parent IKE SA.\n   However, a\
    \ persistent storage module might not be updated in a timely\n   manner and could\
    \ be populated with tokens relating to IKE SPIs that\n   have already been rekeyed.\
    \  A token taker MUST NOT take an invalid\n   QCD token sent along with an INVALID_SPI\
    \ notification as evidence\n   that the peer is either malfunctioning or attacking,\
    \ but it SHOULD\n   limit the rate at which such notifications are processed.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   The extension described in this document must\
    \ not reduce the security\n   of IKEv2 or IPsec.  Specifically, an eavesdropper\
    \ must not learn any\n   non-public information about the peers.\n   The proposed\
    \ mechanism should be secure against attacks by a passive\n   man in the middle\
    \ (MITM) (eavesdropper).  Such an attacker must not\n   be able to disrupt an\
    \ existing IKE session, either by resetting the\n   session or by introducing\
    \ significant delays.  This requirement is\n   especially significant, because\
    \ this document introduces a new way to\n   reset an IKE SA.\n   The mechanism\
    \ need not be similarly secure against an active MITM,\n   since this type of\
    \ attacker is already able to disrupt IKE sessions.\n"
- title: 9.1.  QCD Token Generation and Handling
  contents:
  - "9.1.  QCD Token Generation and Handling\n   Tokens MUST be hard to guess.  This\
    \ is critical, because if an\n   attacker can guess the token associated with\
    \ an IKE SA, they can tear\n   down the IKE SA and associated tunnels at will.\
    \  When the token is\n   delivered in the IKE_AUTH exchange, it is encrypted.\
    \  When it is sent\n   again in an unprotected notification, it is not, but that\
    \ is the last\n   time this token is ever used.\n   An aggregation of some tokens\
    \ generated by one maker together with\n   the related IKE SPIs MUST NOT give\
    \ an attacker the ability to guess\n   other tokens.  Specifically, if one taker\
    \ does not properly secure\n   the QCD tokens and an attacker gains access to\
    \ them, this attacker\n   MUST NOT be able to guess other tokens generated by\
    \ the same maker.\n   This is the reason that the QCD_SECRET in Section 5.1 needs\
    \ to be\n   sufficiently long.\n   The token taker MUST store the token in a secure\
    \ manner.  No attacker\n   should be able to gain access to a stored token.\n\
    \   The QCD_SECRET MUST be protected from access by other parties.\n   Anyone\
    \ gaining access to this value will be able to delete all the\n   IKE SAs for\
    \ this token maker.\n   The QCD token is sent by the rebooted peer in an unprotected\
    \ message.\n   A message like that is subject to modification, deletion, and replay\n\
    \   by an attacker.  However, these attacks will not compromise the\n   security\
    \ of either side.  Modification is meaningless because a\n   modified token is\
    \ simply an invalid token.  Deletion will only cause\n   the protocol not to work,\
    \ resulting in a delay in tunnel\n   re-establishment as described in Section\
    \ 2.  Replay is also\n   meaningless, because the IKE SA has been deleted after\
    \ the first\n   transmission.\n"
- title: 9.2.  QCD Token Transmission
  contents:
  - "9.2.  QCD Token Transmission\n   A token maker MUST NOT send a valid QCD token\
    \ in an unprotected\n   message for an existing IKE SA.\n   This requirement is\
    \ obvious and easy in the case of a single gateway.\n   However, some implementations\
    \ use a load balancer to divide the load\n   between several physical gateways.\
    \  It MUST NOT be possible even in\n   such a configuration to trick one gateway\
    \ into sending a valid QCD\n   token for an IKE SA that is valid on another gateway.\
    \  This is true\n   whether the attempt to trick the gateway uses the token taker's\
    \ IP\n   address or a different IP address.\n   IPsec failure detection is not\
    \ applicable to deployments where the\n   QCD secret is shared by multiple gateways\
    \ and the gateways cannot\n   assess whether the token can be legitimately sent\
    \ in the clear while\n   another gateway may actually still own the SA's.  Load\
    \ balancing\n   configurations typically fall in this category.  In order for\
    \ a load\n   balancing configuration of IPsec gateways to support this\n   specification,\
    \ all members MUST be able to tell whether a particular\n   IKE SA is active anywhere\
    \ in the cluster.  One way to do this is to\n   synchronize a list of active IKE\
    \ SPIs among all the cluster members.\n   Because it includes the token taker's\
    \ IP address in the token\n   generation, the method in Section 5.2 can (under\
    \ certain conditions)\n   prevent revealing the QCD token for an existing pair\
    \ of IKE SPIs to\n   an attacker who is using a different IP address, even in\
    \ a load-\n   sharing cluster without state synchronization.  That method does\
    \ not\n   prevent revealing the QCD token to an active attacker who is spoofing\n\
    \   the token taker's IP address.  Such an attacker may attempt to direct\n  \
    \ messages to a cluster member other than the member responsible for\n   the IKE\
    \ SA in an attempt to trick that gateway into sending a QCD\n   token for a valid\
    \ IKE SA.  That method should not be used unless the\n   load balancer guarantees\
    \ that IKE packets from the same source IP\n   address always go to the same cluster\
    \ member.\n"
- title: 9.3.  QCD Token Enumeration
  contents:
  - "9.3.  QCD Token Enumeration\n   An attacker may try to attack QCD if the generation\
    \ algorithm\n   described in Section 5.1 is used.  The attacker will send several\n\
    \   fake IKE requests to the gateway under attack, receiving and\n   recording\
    \ the QCD tokens in the responses.  This will allow the\n   attacker to create\
    \ a dictionary of IKE SPIs to QCD tokens, which can\n   later be used to tear\
    \ down any IKE SA.\n   Three factors mitigate this threat:\n   o  The space of\
    \ all possible IKE SPI pairs is huge: 2^128, so making\n      such a dictionary\
    \ is impractical.  Even if we assume that one\n      implementation always generates\
    \ predictable IKE SPIs, the space is\n      still at least 2^64 entries, so making\
    \ the dictionary is extremely\n      hard.  To ensure this, token makers MUST\
    \ generate unpredictable\n      IKE SPIs by using a cryptographically strong pseudo-random\
    \ number\n      generator.\n   o  Throttling the amount of QCD_TOKEN notifications\
    \ sent out, as\n      discussed in Section 8.1, especially when not soon after\
    \ a crash\n      will limit the attacker's ability to construct a dictionary.\n\
    \   o  The methods in Section 5.1 and Section 5.2 allow for a periodic\n     \
    \ change of the QCD_SECRET.  Any such change invalidates the entire\n      dictionary.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   IANA has assigned a notify message type (16419)\
    \ from the status types\n   range (16406-40959) of the \"IKEv2 Notify Message\
    \ Types\" registry with\n   the name \"QUICK_CRASH_DETECTION\".\n"
- title: 11.  Acknowledgements
  contents:
  - "11.  Acknowledgements\n   We would like to thank Hannes Tschofenig and Yaron\
    \ Sheffer for their\n   comments about Session Resumption.\n   Others who have\
    \ contributed valuable comments are, in alphabetical\n   order, Lakshminath Dondeti,\
    \ Paul Hoffman, Tero Kivinen, Scott C\n   Moonen, Magnus Nystrom, and Keith Welter.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC4555]   Eronen, P., \"IKEv2 Mobility and Multihoming Protocol\n\
    \               (MOBIKE)\", RFC 4555, June 2006.\n   [RFC5996]   Kaufman, C.,\
    \ Hoffman, P., Nir, Y., and P. Eronen,\n               \"Internet Key Exchange\
    \ Protocol Version 2 (IKEv2)\",\n               RFC 5996, September 2010.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [RFC5723]   Sheffer, Y. and H. Tschofenig,\
    \ \"Internet Key Exchange\n               Protocol Version 2 (IKEv2) Session Resumption\"\
    , RFC 5723,\n               January 2010.\n   [RFC6027]   Nir, Y., \"IPsec Cluster\
    \ Problem Statement\", RFC 6027,\n               October 2010.\n   [recovery]\
    \  Detienne, F., Sethi, P., and Y. Nir, \"Safe IKE Recovery\",\n             \
    \  Work in Progress, July 2009.\n"
- title: Appendix A.  The Path Not Taken
  contents:
  - 'Appendix A.  The Path Not Taken

    '
- title: A.1.  Initiating a New IKE SA
  contents:
  - "A.1.  Initiating a New IKE SA\n   Instead of sending a QCD token, we could have\
    \ the rebooted\n   implementation start an Initial exchange with the peer, including\
    \ the\n   INITIAL_CONTACT notification.  This would have the same effect,\n  \
    \ instructing the peer to erase the old IKE SA, as well as establishing\n   a\
    \ new IKE SA with fewer rounds.\n   The disadvantage here is that in IKEv2, an\
    \ authentication exchange\n   MUST have a piggybacked Child SA set up.  Since\
    \ our use-case is such\n   that the rebooted implementation does not have traffic\
    \ flowing to the\n   peer, there are no good selectors for such a Child SA.\n\
    \   Additionally, when authentication is asymmetric, such as when EAP is\n   used,\
    \ it is not possible for the rebooted implementation to initiate\n   IKE.\n"
- title: A.2.  SIR
  contents:
  - "A.2.  SIR\n   Another proposal that was considered for this work item is the\
    \ SIR\n   extension, which is described in [recovery].  Under that proposal,\n\
    \   the non-rebooted peer sends a non-protected query to the possibly\n   rebooted\
    \ peer, asking whether the IKE SA exists.  The peer replies\n   with either a\
    \ positive or negative response, and the absence of a\n   positive response, along\
    \ with the existence of a negative response,\n   is taken as proof that the IKE\
    \ SA has really been lost.\n   The working group preferred the QCD proposal to\
    \ this one.\n"
- title: A.3.  Birth Certificates
  contents:
  - "A.3.  Birth Certificates\n   Birth Certificates is a method of crash detection\
    \ that has never been\n   formally defined.  Bill Sommerfeld suggested this idea\
    \ in a mail to\n   the IPsec mailing list on August 7, 2000, in a thread discussing\n\
    \   methods of crash detection:\n       If we have the system sign a \"birth certificate\"\
    \ when it\n       reboots (including a reboot time or boot sequence number),\n\
    \       we could include that with a \"bad spi\" ICMP error and in\n       the\
    \ negotiation of the IKE SA.\n   We believe that this method would have some problems.\
    \  First, it\n   requires Alice to store the certificate, so as to be able to\
    \ compare\n   the public keys.  That requires more storage than does a QCD token.\n\
    \   Additionally, the public key operations needed to verify the self-\n   signed\
    \ certificates are more expensive for Alice.\n   We believe that a symmetric-key\
    \ operation such as proposed here is\n   more light-weight and simple than that\
    \ implied by the Birth\n   Certificate idea.\n"
- title: A.4.  Reducing Liveness Check Length
  contents:
  - "A.4.  Reducing Liveness Check Length\n   Some implementations require fewer retransmissions\
    \ over a shorter\n   period of time for cases of liveness check started because\
    \ of an\n   INVALID_SPI or INVALID_IKE_SPI notification.\n   We believe that the\
    \ default retransmission policy should represent a\n   good balance between the\
    \ need for a timely discovery of a dead peer,\n   and a low probability of false\
    \ detection.  We expect the policy to be\n   set to take the shortest time such\
    \ that this probability achieves a\n   certain target.  Therefore, we believe\
    \ that reducing the elapsed time\n   and retransmission count may create an unacceptably\
    \ high probability\n   of false detection, and this can be triggered by a single\n\
    \   INVALID_IKE_SPI notification.\n   Additionally, even if the retransmission\
    \ policy is reduced to, say,\n   one minute, it is still a very noticeable delay\
    \ from a human\n   perspective, from the time that the gateway has come up (i.e.,\
    \ is\n   able to respond with an INVALID_SPI or INVALID_IKE_SPI notification)\n\
    \   and until the tunnels are active, or from the time the backup gateway\n  \
    \ has taken over until the tunnels are active.  The use of QCD tokens\n   can\
    \ reduce this delay.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Yoav Nir (editor)\n   Check Point Software Technologies,\
    \ Ltd.\n   5 Hasolelim st.\n   Tel Aviv  67897\n   Israel\n   EMail: ynir@checkpoint.com\n\
    \   David Wierbowski\n   International Business Machines\n   1701 North Street\n\
    \   Endicott, New York  13760\n   United States\n   EMail: wierbows@us.ibm.com\n\
    \   Frederic Detienne\n   Cisco Systems, Inc.\n   De Kleetlaan, 7\n   Diegem \
    \ B-1831\n   Belgium\n   Phone: +32 2 704 5681\n   EMail: fd@cisco.com\n   Pratima\
    \ Sethi\n   Cisco Systems, Inc.\n   O'Shaugnessy Road, 11\n   Bangalore, Karnataka\
    \  560027\n   India\n   Phone: +91 80 4154 1654\n   EMail: psethi@cisco.com\n"
