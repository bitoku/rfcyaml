Abstract This document specifies C language bindings for Version 2, Update 1 of the Generic Security Service Application Program Interface (GSS  API), which is described at a language independent conceptual level in RFC 2743
It obsoletes RFC 1509, making specific incremental changes in response to implementation experience and liaison requests.
It is intended, therefore, that this memo or a successor version thereof will become the basis for subsequent progression of the GSS API specification on the standards track.
The Generic Security Service Application Programming Interface provides security services to its callers, and is intended for implementation atop a variety of underlying cryptographic mechanisms.
Typically, GSS API callers will be application protocols into which security enhancements are integrated through invocation of services provided by the GSS API.
The GSS API allows a caller application to authenticate a principal identity associated with a peer application, to delegate rights to a peer, and to apply security services such as confidentiality and integrity on a per message basis.
The Generic Security Service Application Programming Interface [GSSAPI] provides security services to calling applications.
It allows a communicating application to authenticate the user associated with another application, to delegate rights to another application, and to apply security services such as confidentiality and integrity on a per message basis.
There are four stages to using the GSS API: a)
The application acquires a set of credentials with which it may prove its identity to other processes.
The application's credentials vouch for its global identity, which may or may not be related to any local username under which it may be running.
A pair of communicating applications establish a joint security context using their credentials.
The security context is a pair of GSS API data structures that contain shared state information, which is required in order that per message security services may be provided.
Examples of state that might be shared between applications as part of a security context are cryptographic keys, and message sequence numbers.
As part of the establishment of a security context, the context initiator is authenticated to the responder, and may require that the responder is authenticated in turn.
The initiator may optionally give the responder the right to initiate further security contexts, acting as an agent or delegate of the initiator.
This transfer of rights is termed delegation, and is achieved by creating a set of credentials, similar to those used by the initiating application, but which may be used by the responder.
To establish and maintain the shared information that makes up the security context, certain GSS API calls will return a token data structure, which is an opaque data type that may contain cryptographically protected data.
The caller of such a GSS API routine is responsible for transferring the token to the peer application, encapsulated if necessary in an application  application protocol.
On receipt of such a token, the peer application should pass it to a corresponding GSS API routine which will decode the token and extract the information, updating the security context state information accordingly.
Per message services are invoked to apply either: integrity and data origin authentication, or confidentiality, integrity and data origin authentication to application data, which are treated by GSS API as arbitrary octet strings.
An application transmitting a message that it wishes to protect will call the appropriate GSS API routine (gss get mic or gss wrap) to apply protection, specifying the appropriate security context, and send the resulting token to the receiving application.
The receiver will pass the received token (and, in the case of data protected by gss get mic, the accompanying message data) to the corresponding decoding routine (gss verify mic or gss unwrap) to remove the protection and validate the data.
At the completion of a communications session (which may extend across several transport connections), each application calls a GSS API routine to delete the security context.
Multiple contexts may also be used (either successively or simultaneously) within a single communications association, at the option of the applications.
This section lists the routines that make up the GSS API, and offers a brief description of the purpose of each routine.
Detailed descriptions of each routine are listed in alphabetical order in section 5.
Assume a global identity; Obtain a GSS API credential handle for pre existing credentials.
Discard a security context gss process context token
5.15 Calculate a cryptographic message integrity code (MIC) for a message
verify integrity of a received message gss
5.31 Verify a message with attached MIC, and decrypt message content if necessary.
Compare two internal form names gss release name
5.28 Discard an internal form name gss inquire names for mech 5.24 List
the name types supported by the specified mechanism gss inquire mechs for name 5.23 List mechanisms that support
5.12 Create a copy of an internal name Table 2 5  GSS API Miscellaneous Routines
gss create empty oid set
5.8  Create a set containing no object identifiers gss test oid set member
5.30 Determines whether an object identifier is a member of a set.
Individual GSS API implementations may augment these routines by providing additional mechanism specific routines if required functionality is not available from the generic forms.
Applications are encouraged to use the generic routines wherever possible on portability grounds.
Data Types and Calling Conventions
The following conventions are used by the GSS API C language bindings: 3.1.
Integer types GSS API uses the following integer data type: OM uint32    32 bit unsigned integer Where guaranteed minimum bit count is important, this portable data type is used by the GSS API routine definitions.
Individual GSS API implementations will include appropriate typedef definitions to map this type onto a built in data type.
If the platform supports the X/Open xom.h header file, the OM uint32 definition contained therein should be used; the GSS API header file in Appendix A contains logic that will detect the prior inclusion of xom.h, and will not attempt to re declare OM uint32.
If the X/Open header file is not available on the platform, the GSS API implementation should use the smallest natural unsigned integer type that provides at least 32 bits of precision.
String and similar data Many of the GSS API routines take arguments and return values that describe contiguous octet strings.
All such data is passed between the GSS API and the caller using the gss buffer t data type.
This data type is a pointer to a buffer descriptor, which consists of a length field that contains the total number of bytes in the datum, and a value field which contains a pointer to the actual datum:
; Storage for data returned to the application by a GSS API routine using the gss buffer t conventions is allocated by the GSS API routine.
The application may free this storage by invoking the gss release buffer routine.
Allocation of the gss buffer desc object is always the responsibility of the application;  unused gss buffer desc objects may be initialized to the value GSS C EMPTY BUFFER.
Certain multiple word data items are considered opaque data types at the GSS API, because their internal structure has no significance either to the GSS API or to the caller.
Examples of such opaque data types are the input token parameter to gss init sec context (which is opaque to the caller), and the input message parameter to gss wrap (which is opaque to the GSS API).
Opaque data is passed between the GSS API and the application using the gss buffer t datatype.
Certain multiple word data items may be regarded as simple ISO Latin 1 character strings.
Examples are the printable strings passed to gss import name via the input name buffer parameter.
Some GSS API routines also return character strings.
All such character strings are passed between the application and the GSS API implementation using the gss buffer t datatype, which is a pointer to a gss buffer desc object.
When a gss buffer desc object describes a printable string, the length field of the gss buffer desc should only count printable characters within the string.
In particular, a trailing NUL character should NOT be included in the length count, nor should either the GSS API implementation or the application assume the presence of an uncounted trailing NUL.
Object Identifiers Certain GSS API procedures take parameters of the type gss OID, or Object identifier.
This is a type containing
ISO defined tree  structured values, and is used by the GSS API caller to select an underlying security mechanism and to specify namespaces.
A value of type gss OID has the following structure: typedef struct gss OID desc struct { OM uint32   length;
The length field contains the number of bytes in this value.
For example, the gss OID value corresponding to {iso(1) identified organization(3) icd  ecma(12) member company(2)
dec(1011) cryptoAlgorithms(7) DASS(5)}, meaning the DASS X.509 authentication mechanism, has a length field of 7 and an elements field pointing to seven octets containing the following octal values: 53,14,2,207,163,7,5.
GSS API implementations should provide constant gss OID values to allow applications to request any supported mechanism, although applications are encouraged on portability grounds to accept the default mechanism.
gss OID values should also be provided to allow applications to specify particular name types (see section 3.10).
Applications should treat gss OID desc values returned by GSS API routines as read only.
In particular, the application should not attempt to deallocate them with free().
The gss OID desc datatype is equivalent to the X/Open OM object identifier datatype[XOM].
Object Identifier Sets Certain GSS API procedures take parameters of the type gss OID set.
This type represents one or more object identifiers (section 2.3).
A gss OID set object has the following structure:
typedef struct gss OID set desc struct { size t    count; gss OID   elements; } gss OID set desc,  gss OID set; The count field contains the number of OIDs within the set.
The elements field is a pointer to an array of gss OID desc objects, each of which describes a single OID.
gss OID set values are used to name the available mechanisms supported by the GSS API, to request the use of specific mechanisms, and to indicate which mechanisms a given credential supports.
All OID sets returned to the application by GSS API are dynamic objects
(the gss OID set desc, the "elements" array of the set, and the "elements" array of each member OID are all dynamically allocated), and this storage must be deallocated by the application using the gss release oid set() routine.
Credentials A credential handle is a caller opaque atomic datum that identifies a GSS API credential data structure.
It is represented by the caller
opaque type gss cred id t, which should be implemented as a pointer or arithmetic type.
If a pointer implementation is chosen, care must be taken to ensure that two gss cred i
t values may be compared with the   operator.
GSS API credentials can contain mechanism specific principal authentication data for multiple mechanisms.
A GSS API credential is composed of a set of credential elements, each of which is applicable to a single mechanism.
A credential may contain at most one credential element for each supported mechanism.
A credential element identifies the data needed by a single mechanism to authenticate a single principal, and conceptually contains two credential references that describe the actual mechanism specific authentication data, one to be used by GSS API for initiating contexts,  and one to be used for accepting contexts.
For mechanisms that do not distinguish between acceptor and initiator credentials, both references would point to the same underlying mechanism specific authentication data.
Credentials describe a set of mechanism specific principals, and give their holder the ability to act as any of those principals.
All principal identities asserted by a single GSS API credential should belong to the same entity, although enforcement of this property is an implementation specific matter.
The GSS API does not make the actual credentials available to applications; instead a credential handle is used to identify a particular credential, held internally by GSS API.
The combination of GSS API credential handle and mechanism identifies the principal whose identity will be asserted by the credential when used with that mechanism.
The gss init sec context and gss accept sec context routines allow the value GSS C NO CREDENTIAL to be specified as their credential handle parameter.
This special credential handle indicates a desire by the application to act as a default principal.
While individual GSS API implementations are free to determine such default behavior as appropriate to the mechanism, the following default behavior by these routines is recommended for portability: gss init sec context 1)
If there is only a single principal capable of initiating security contexts for the chosen mechanism that the application is authorized to act on behalf of, then that principal shall be used, otherwise 2)
If the platform maintains a concept of a default network  identity for the chosen mechanism, and if the application is authorized to act on behalf of that identity for the purpose of initiating security contexts, then the principal corresponding to that identity shall be used, otherwise 3)
If the platform maintains a concept of a default local identity, and provides a means to map local identities into network identities for the chosen mechanism, and if the application is authorized to act on behalf of the network  identity image of the default local identity for the purpose of initiating security contexts using the chosen mechanism, then the principal corresponding to that identity shall be used, otherwise 4)
A user configurable default identity should be used.
gss accept sec context 1)
If there is only a single authorized principal identity capable of accepting security contexts for the chosen mechanism, then that principal shall be used, otherwise 2)
If the mechanism can determine the identity of the target principal by examining the context establishment token, and if the accepting application is authorized to act as that principal for the purpose of accepting security contexts using the chosen mechanism, then that principal identity shall be used, otherwise 3) If the mechanism supports context acceptance by any principal, and if mutual authentication was not requested, any principal that the application is authorized to accept security contexts under using the chosen mechanism may be used, otherwise 4)A user configurable default identity shall be used.
The purpose of the above rules is to allow security contexts to be established by both initiator and acceptor using the default behavior wherever possible.
Applications requesting default behavior are likely to be more portable across mechanisms and platforms than ones that use gss acquire cred to request a specific identity.
t data type contains a caller opaque atomic value that identifies one end of a GSS API security context.
It should be implemented as a pointer or arithmetic type.
If a pointer type is chosen, care should be taken to ensure that two gss ctx
t values may be compared with the   operator.
The security context holds state information about each end of a peer communication, including cryptographic state information.
A token is a caller opaque type that GSS API uses to maintain synchronization between the context data structures at each end of a GSS API security context.
The token is a cryptographically protected octet string, generated by the underlying mechanism at one end of a GSS API security context for use by the peer mechanism at the other end.
Encapsulation (if required) and transfer of the token are the responsibility of the peer applications.
A token is passed between the GSS API and the application using the gss buffer t conventions.
Interprocess tokens Certain GSS API routines are intended to transfer data between processes in multi process programs.
These routines use a caller  opaque octet string, generated by the GSS API in one process for use by the GSS API in another process.
The calling application is responsible for transferring such tokens between processes in an OS  specific manner.
Note that, while GSS API implementors are encouraged to avoid placing sensitive information within interprocess tokens, or to cryptographically protect them, many implementations will be unable to avoid placing key material or other sensitive data within them.
It is the application's responsibility to ensure that interprocess tokens are protected in transit, and transferred only to processes that are trustworthy.
An interprocess token is passed between the GSS API and the application using the gss buffer t conventions.
Every GSS API routine returns two distinct values to report status information to the caller: GSS status codes and Mechanism status codes.
GSS status codes GSS API routines return GSS status codes as their OM uint32 function value.
These codes indicate errors that are independent of the underlying mechanism(s) used to provide the security service.
The errors that can be indicated via a GSS status code are either generic API routine errors (errors that are defined in the GSS API specification) or calling errors (errors that are specific to these language bindings).
A GSS status code can indicate a single fatal generic API error from the routine and a single calling error.
In addition, supplementary status information may be indicated via the setting of bits in the supplementary info field of a GSS status code.
These errors are encoded into the 32 bit GSS status code as follows:
if a GSS API routine returns a GSS status code whose upper 16 bits contain a non zero value, the call failed.
If the calling error field is non zero, the invoking application's call of the routine was erroneous.
Calling errors are defined in table 5 1.
If the routine error field is non zero,
the routine failed for one of the routine  specific reasons listed below in table 5 2.
Whether or not the upper 16 bits indicate a failure or a success, the routine may indicate additional information by setting bits in the supplementary info field of the status code.
The meaning of individual bits is listed below in table 5 3.
A required output parameter could not be written.
GSS S CALL BAD STRUCTURE
A supplied name was of an unsupported type GSS S BAD BINDINGS
An invalid status code was supplied GSS S BAD MIC GSS S BAD SIG
No credentials were supplied, or the credentials were unavailable or inaccessible.
No context has been established
A token was invalid GSS S DEFECTIVE CREDENTIAL
The referenced credentials have expired GSS S CONTEXT EXPIRED
The operation is forbidden by local security policy GSS S
The requested credential element already exists GSS S NAME
Returned only by gss init sec context or gss
The routine must be called again to complete its function.
See routine documentation for detailed description GSS S DUPLICATE TOKEN
The token's validity period has expired GSS S UNSEQ
An expected per message token was not received The routine documentation also uses the name GSS S COMPLETE, which is a zero value, to indicate an absence of any API errors or supplementary information bits.
All GSS S xxx symbols equate to complete OM uint32 status codes, rather than to bitfield values.
For example, the actual value of the symbol GSS S BAD NAMETYPE (value 3 in the routine error field) is 3<<16.
The macros GSS CALLING ERROR(), GSS ROUTINE ERROR() and GSS SUPPLEMENTARY INFO() are provided, each of which takes a GSS status code and removes all but the relevant field.
For example, the value obtained by applying GSS ROUTINE ERROR to a status code removes the calling errors and supplementary info fields, leaving only the routine errors field.
The values delivered by these macros may be directly compared with a GSS S xxx symbol of the appropriate type.
The macro GSS ERROR() is also provided, which when applied to a GSS status code returns a non zero value if the status code indicated a calling or routine error, and a zero value otherwise.
All macros defined by GSS API evaluate their argument(s) exactly once.
A GSS API implementation may choose to signal calling errors in a platform specific manner instead of, or in addition to the routine value;  routine errors and supplementary info should be returned via major status values only.
The GSS major status code GSS S FAILURE is used to indicate that the underlying mechanism detected an error for which no specific GSS status code is defined.
The mechanism specific status code will provide more details about the error.
Mechanism specific status codes GSS API routines return a minor status parameter, which is used to indicate specialized errors from the underlying security mechanism.
This parameter may contain a single mechanism specific error, indicated by a OM uint32 value.
The minor status parameter will always be set by a GSS API routine, even if it returns a calling error or one of the generic API errors indicated above as fatal, although most other output parameters may remain unset in such cases.
However, output parameters that are expected to return pointers to storage allocated by a routine must always be set by the routine, even in the event of an error, although in such cases the GSS API routine may elect to set the returned parameter value to NULL to indicate that no storage was actually allocated.
Any length field associated with such pointers (as in a gss buffer desc structure) should also be set to zero in such cases.
A name is used to identify a person or entity.
GSS API authenticates the relationship between a name and the entity claiming the name.
Since different authentication mechanisms may employ different namespaces for identifying their principals, GSSAPI's naming support is necessarily complex in multi mechanism environments (or even in some single mechanism environments where the underlying mechanism supports multiple namespaces).
Two distinct representations are defined for names: An internal form.
This is the GSS API "native" format for names, represented by the implementation specific gss name t type.
It is opaque to GSS API callers.
A single gss name t object may contain multiple names from different namespaces, but all names should refer to the same entity.
An example of such an internal name would be the name returned from a call to the gss inquire cred routine, when applied to a credential containing credential elements for multiple authentication mechanisms employing different namespaces.
This gss name t object will contain a distinct name for the entity for each authentication mechanism.
For GSS API implementations supporting multiple namespaces, objects of type gss name t must contain sufficient information to determine the namespace to which each primitive name belongs.
Mechanism specific contiguous octet string forms.
A format capable of containing a single name (from a single namespace).
Contiguous string names are always accompanied by an object identifier specifying the namespace to which the name belongs, and their format is dependent on the authentication mechanism that employs the name.
Many, but not all, contiguous string names will be printable, and may therefore be used by GSS API applications for communication with their users.
Routines (gss import name and gss display name) are provided to convert names between contiguous string representations and the internal gss name t type.
gss import name may support multiple syntaxes for each supported namespace, allowing users the freedom to choose a preferred name representation.
gss display name should use an implementation chosen printable syntax for each supported name  type.
If an application calls gss display name(), passing the internal name resulting from a call to gss import name(), there is no guarantee
the the resulting contiguous string name will be the same as the original imported string name.
Nor do name space identifiers necessarily survive unchanged after a journey through the internal name form.
An example of this might be a mechanism that authenticates X.500 names, but provides an algorithmic mapping of Internet DNS names into X.500.
That mechanism's implementation of gss import name() might, when presented with a DNS name, generate an internal name that contained both the original DNS name and the equivalent X.500 name.
Alternatively, it might only store the X.500 name.
In the latter case, gss display name() would most likely generate a printable X.500 name, rather than the original DNS name.
The process of authentication delivers to the context acceptor an internal name.
Since this name has been authenticated by a single mechanism, it contains only a single name (even if the internal name presented by the context initiator to gss init sec context had multiple components).
Such names are termed internal mechanism names, or "MN"s and the names emitted by gss accept sec context() are always of this type.
Since some applications may require MNs without wanting to incur the overhead of an authentication operation, a second function, gss canonicalize name(), is provided to convert a general internal name into an MN.
Comparison of internal form names may be accomplished via the gss compare name() routine, which returns true if the two names being compared refer to the same entity.
This removes the need for the application program to understand the syntaxes of the various printable names that a given GSS API implementation may support.
Since GSS API assumes that all primitive names contained within a given internal name refer to the same entity, gss compare name() can return true if the two names have at least one primitive name in common.
If the implementation embodies knowledge of equivalence relationships between names taken from different namespaces, this knowledge may also allow successful comparison of internal names containing no overlapping primitive elements.
When used in large access control lists, the overhead of invoking gss import name() and gss compare name() on each name from the ACL may be prohibitive.
As an alternative way of supporting this case, GSS API defines a special form of the contiguous string name which may be compared directly (e.g. with memcmp()).
Contiguous names suitable for comparison are generated by the gss export name() routine, which requires an MN as input.
Exported names may be re  imported by the gss import name() routine, and the resulting internal name will also be an MN.
The gss OID constant GSS C NT EXPORT NAME indentifies the "export name" type, and
the value of this constant is given in Appendix A.
Structurally, an exported name object consists of a header containing an OID identifying the mechanism that authenticated the name, and a trailer containing the name itself, where the syntax of the trailer is defined by the individual mechanism specification.
The precise format of an export name is defined in the language independent GSS API specification [GSSAPI].
Note that the results obtained by using gss compare name() will in general be different from those obtained by invoking gss
canonicalize name() and gss export name(), and then comparing the exported names.
The first series of operation determines whether two (unauthenticated) names identify the same principal; the second whether a particular mechanism would authenticate them as the same principal.
These two operations will in general give the same results only for MNs.
The gss name t datatype should be implemented as a pointer type.
To allow the compiler to aid the application programmer by performing type checking, the use of (void  ) is discouraged.
A pointer to an implementation defined type is the preferred choice.
Storage is allocated by routines that return gss name t values.
A procedure, gss release name, is provided to free storage associated with an internal form name.
Channel Bindings GSS API supports the use of user specified tags to identify a given context to the peer application.
These tags are intended to be used to identify the particular communications channel that carries the context.
Channel bindings are communicated to the GSS API using the following structure:
NS address type GSS C AF
AppleTalk address type GSS C AF BSC
X.25 GSS C AF NULLADDR
No address specified Note that these symbols name address families rather than specific addressing formats.
For address families that contain several alternative address forms, the initiator address and acceptor address fields must contain sufficient information to determine which address form is used.
When not otherwise specified, addresses should be specified in network byte order (that is, native byte ordering for the address family).
Conceptually, the GSS API concatenates the initiator addrtype, initiator address, acceptor addrtype, acceptor address and application data to form an octet string.
The mechanism calculates a MIC over this octet string, and binds the MIC to the context establishment token emitted by gss init sec context.
The same bindings are presented by the context acceptor to gss accept sec context, and a MIC is calculated in the same way.
The calculated MIC is compared with that found in the token, and if the MICs differ, gss accept sec context will return a GSS S BAD BINDINGS error, and the context will not be established.
Some mechanisms may include the actual channel binding data in the token (rather than just a MIC); applications should therefore not use confidential data as channel binding components.
Individual mechanisms may impose additional constraints on addresses and address types that may appear in channel bindings.
For example, a mechanism may verify that the initiator address field of the channel bindings presented to gss init sec context contains the correct network address of the host system.
Portable applications should therefore ensure that they either provide correct information for the address fields, or omit addressing information, specifying GSS C AF NULLADDR as the address types.
Optional parameters Various parameters are described as optional.
This means that they follow a convention whereby a default value may be requested.
The following conventions are used for omitted parameters.
These conventions apply only to those parameters that are explicitly documented as optional.
gss buffer t types Specify GSS C NO BUFFER as a value.
For an input parameter this signifies that default behavior is requested, while for an output parameter it indicates that the information that would be returned via the parameter is not required by the application.
Individual parameter documentation lists values to be used to indicate default actions.
Integer types (output) Specify NULL as the value for the pointer.
Pointer types Specify NULL as the value.
Object IDs Specify GSS C
NO OID as the value.
Object ID Sets Specify GSS C
NO OID SET as the value.
GSS C NO CHANNEL BINDINGS to indicate that channel bindings are not to be used.
This section discusses the optional services that a context initiator may request of the GSS API at context establishment.
Each of these services is requested by setting a flag in the req flags input parameter to gss init sec context.
The optional services currently defined are:
Delegation The (usually temporary) transfer of rights from initiator to acceptor, enabling the acceptor to authenticate itself as an agent of the initiator.
In addition to the initiator authenticating its identity to the context acceptor, the context acceptor should also authenticate itself to the initiator.
In addition to providing message integrity services, gss get mic and gss wrap should include message numbering information to enable gss verify mic and gss
unwrap to detect if a message has been duplicated.
In addition to providing message integrity services, gss get mic and gss wrap should include message sequencing information to enable gss verify mic and gss
unwrap to detect if a message has been received out of sequence.
The establishment of the security context should not reveal the initiator's identity to the context acceptor.
Any currently undefined bits within such flag arguments should be ignored by GSS API implementations when presented by an application, and should be set to zero when returned to the application by the GSS API implementation.
Some mechanisms may not support all optional services, and some mechanisms may only support some services in conjunction with others.
Both gss init sec context and gss accept sec context inform the applications which services will be available from the context when the establishment phase is complete, via the ret flags output parameter.
In general, if the security mechanism is capable of providing a requested service, it should do so, even if additional services must be enabled in order to provide the requested service.
If the mechanism is incapable of providing a requested service, it should proceed without the service, leaving the application to abort the context establishment process if it considers the requested service to be mandatory.
Some mechanisms may specify that support for some services is optional, and that implementors of the mechanism need not provide it.
This is most commonly true of the confidentiality service, often because of legal restrictions on the use of data encryption, but may apply to any of the services.
Such mechanisms are required to send at least one token from acceptor to initiator during context establishment when the initiator indicates a desire to use such a service, so that the initiating GSS API can correctly indicate whether the service is supported by the acceptor's GSS API.
Delegation The GSS API allows delegation to be controlled by the initiating application via a boolean parameter to gss init sec context(), the routine that establishes a security context.
Some mechanisms do not support delegation, and for such mechanisms attempts by an application to enable delegation are ignored.
The acceptor of a security context for which the initiator enabled delegation will receive (via the delegated cred handle parameter of gss accept sec context)
a credential handle that contains the delegated identity, and this credential handle may be used to initiate subsequent GSS API security contexts as an agent or delegate of the initiator.
If the original initiator's identity is "A" and the delegate's identity is "B", then, depending on the underlying mechanism, the identity embodied by the delegated credential may be either "A" or
For many mechanisms that support delegation, a simple boolean does not provide enough control.
Examples of additional aspects of delegation control that a mechanism might provide to an application are duration of delegation, network addresses from which delegation is valid, and constraints on the tasks that may be performed by a delegate.
Such controls are presently outside the scope of the GSS  API.
GSS API implementations supporting mechanisms offering additional controls should provide extension routines that allow these controls to be exercised (perhaps by modifying the initiator's GSS API credential prior to its use in establishing a context).
However, the simple delegation control provided by GSS API should always be able to over ride other mechanism specific delegation controls
If the application instructs gss init sec context() that delegation is not desired, then the implementation must not permit delegation to occur.
This is an exception to the general rule that a mechanism may enable services even if they are not requested delegation may only be provided at the explicit request of the application.
Usually, a context acceptor will require that a context initiator authenticate itself so that the acceptor may make an access control decision prior to performing a service for the initiator.
In some cases, the initiator may also request that the acceptor authenticate itself.
GSS API allows the initiating application to request this mutual authentication service by setting a flag when calling gss init sec context.
The initiating application is informed as to whether or not the context acceptor has authenticated itself.
Note that some mechanisms may not support mutual authentication, and other mechanisms may always perform mutual authentication, whether or not the initiating application requests it.
In particular, mutual authentication my be required by some mechanisms in order to support replay or out of  sequence message detection, and for such mechanisms a request for either of these services will automatically enable mutual authentication.
Replay and out of sequence detection
The GSS API may provide detection of mis ordered message once a security context has been established.
Protection may be applied to messages by either application, by calling either gss get mic or gss wrap, and verified by the peer application by calling gss verify mic or gss unwrap.
gss get mic calculates a cryptographic MIC over an application message, and returns that MIC in a token.
The application should pass both the token and the message to the peer application, which presents them to gss verify mic.
gss wrap calculates a cryptographic MIC of an application message, and places both the MIC and the message inside a single token.
The Application should pass the token to the peer application, which presents it to gss unwrap to extract the message and verify the MIC.
Either pair of routines may be capable of detecting out of sequence message delivery, or duplication of messages.
Details of such mis  ordered messages are indicated through supplementary status bits in the major status code returned by gss verify mic or gss unwrap.
The relevant supplementary bits are: GSS S DUPLICATE TOKEN
The token is a duplicate of one that has already been received and processed.
Only contexts that claim to provide replay detection may set this bit.
The token is too old to determine whether or not it is a duplicate.
Contexts supporting out of sequence detection but not replay detection should always set this bit if GSS S UNSEQ TOKEN is set; contexts that support replay detection should only set this bit if the token is so old that it cannot be checked for duplication.
TOKEN A later token has already been processed.
An earlier token has not yet been received.
A mechanism need not maintain a list of all tokens that have been processed in order to support these status codes.
A typical mechanism might retain information about only the most recent "N" tokens processed, allowing it to distinguish duplicates and missing tokens within the most recent "N" messages; the receipt of a token older than the most recent "N" would result in a GSS S OLD TOKEN status.
In certain situations, an application may wish to initiate the authentication process to authenticate a peer, without revealing its own identity.
As an example, consider an application providing access to a database containing medical information, and offering unrestricted access to the service.
A client of such a service might wish to authenticate the service (in order to establish trust in any information retrieved from it), but might not wish the service to be able to obtain the client's identity (perhaps due to privacy concerns about the specific inquiries, or perhaps simply to avoid being placed on mailing lists).
In normal use of the GSS API, the initiator's identity is made available to the acceptor as a result of the context establishment process.
However, context initiators may request that their identity not be revealed to the context acceptor.
Many mechanisms do not support anonymous authentication, and for such mechanisms the request will not be honored.
An authentication token will be still be generated, but the application is always informed if a requested service is unavailable, and has the option to abort context establishment if anonymity is valued above the other security services that would require a context to be established.
In addition to informing the application that a context is established anonymously (via the ret flags outputs from gss init sec context and gss accept sec context), the optional src name output from gss accept sec context and gss inquire context will, for such contexts, return a reserved internal form name, defined by the implementation.
When presented to gss display name, this reserved internal form name will result in a printable name that is syntactically distinguishable from any valid principal name supported by the implementation, associated with a name type object identifier with the value GSS C NT ANONYMOUS, whose value us given in Appendix A.
The printable form of an anonymous name should be chosen such that it implies anonymity, since this name may appear in, for example, audit logs.
For example, the string "<anonymous>
If a context supports the confidentiality service, gss wrap may be used to encrypt application messages.
Messages are selectively encrypted, under the control of the conf req flag input parameter to gss wrap.
Inter process context transfer GSS API V2 provides routines (gss export sec context and gss import sec context) which allow a security context to be transferred between processes on a single machine.
The most common use for such a feature is a client server design where the server is implemented as a single process that accepts incoming security contexts, which then launches child processes to deal with the data on these contexts.
In such a design, the child processes must have access to the security context data structure created within the parent by its call to gss accept sec context so that they can use per message protection services and delete the security context when the communication session ends.
Since the security context data structure is expected to contain sequencing information, it is impractical in general to share a context between processes.
Thus GSS API provides a call (gss export sec context) that the process which currently owns the context can call to declare that it has no intention to use the context subsequently, and to create an inter process token containing information needed by the adopting process to successfully import the context.
After successful completion of gss export sec context, the original security context is made inaccessible to the calling process by GSS API, and any context handles referring to this context are no longer valid.
The originating process transfers the inter process token to the adopting process, which passes it to gss import sec context, and a fresh gss ctx
id t is created such that it is functionally identical to the original context.
The inter process token may contain sensitive data from the original security context (including cryptographic keys).
Applications using inter process tokens to transfer security contexts must take appropriate steps to protect these tokens in transit.
Implementations are not required to support the inter process transfer of security contexts.
The ability to transfer a security context is indicated when the context is created, by gss init sec context or gss accept sec context setting the GSS C TRANS FLAG bit in their ret flags parameter.
The use of incomplete contexts Some mechanisms may allow the per message services to be used before the context establishment process is complete.
For example, a mechanism may include sufficient information in its initial context  level token for the context acceptor to immediately decode messages protected with gss wrap or gss get mic.
For such a mechanism, the initiating application need not wait until subsequent context level tokens have been sent and received before invoking the per message protection services.
The ability of a context to provide per message services in advance of complete context establishment is indicated by the setting of the GSS C PROT READY FLAG bit in the ret flags parameter from gss init sec context and gss accept sec context.
Applications wishing to use per message protection services on partially established contexts should check this flag before attempting to invoke gss wrap or gss get mic.
In addition to the explicit major status codes documented here, the code GSS S FAILURE may be returned by any routine, indicating an implementation specific or mechanism specific error condition, further details of which are reported via the minor status parameter.
id t acceptor cred handle, const gss buffer t  input token buffer,
: Allows a remotely initiated security context between the application and a remote peer to be established.
The routine may return a output token which should be transferred to the peer application, where the peer application will present it to gss init sec context.
If no token need be sent, gss accept sec context will indicate this by setting the length field of the output token argument to zero.
To complete the context establishment, one or more reply tokens may be required from the peer application; if so, gss accept sec context will return a status flag of GSS S CONTINUE NEEDED, in which case it should be called again when the reply token is received from the peer application, passing the token to gss accept sec context via the input token parameters.
Portable applications should be constructed to use the token length and return status to determine whether a token needs to be sent or waited for.
Thus a typical portable caller should always invoke
gss accept sec context within a loop:
{ receive token from peer(input token); maj stat
gss delete sec context(&min stat, &context hdl,
The values of the GSS C DELEG FLAG, GSS C MUTUAL FLAG,GSS C REPLAY FLAG, GSS C SEQUENCE FLAG, GSS C CONF FLAG,GSS C INTEG FLAG and GSS C
ANON FLAG bits returned via the ret flags parameter should contain the values that the implementation expects would be valid if context establishment were to succeed.
The values of the GSS C PROT READY FLAG and GSS C TRANS FLAG bits within ret flags
should indicate the actual state at the time gss accept sec context returns, whether or not the context is fully established.
Although this requires that GSS API implementations set the GSS C PROT READY FLAG in the final ret flags returned to a caller (i.e. when accompanied by a GSS S COMPLETE status code), applications should not rely on this behavior as the flag was not defined in Version 1 of the GSS API.
Instead, applications should be prepared to use per message services after a successful context establishment, according to the GSS C INTEG FLAG and GSS C CONF FLAG values.
All other bits within the ret flags argument should be set to zero.
While the routine returns GSS S CONTINUE NEEDED, the values returned via the ret flags argument indicate the services that the implementation expects to be available from the established context.
If the initial call of gss accept sec context() fails, the implementation should not create a context object, and should leave the value of the context handle parameter set to GSS C NO CONTEXT to indicate this.
In the event of a failure on a subsequent call, the implementation is permitted to delete the "half built" security context (in which case it should set the context handle parameter to GSS C NO CONTEXT), but the preferred behavior is to leave the security context (and the context handle parameter) untouched for the application to delete (using gss delete sec context).
During context establishment, the informational status bits GSS S OLD TOKEN and GSS S DUPLICATE TOKEN indicate fatal errors, and GSS API mechanisms should always return them in association with a routine error of GSS S FAILURE.
This requirement for pairing did not exist in version 1 of the GSS API specification, so applications that wish to run over version 1 implementations must special case these codes.
t, read/modify context handle for new context.
NO CONTEXT for first call;
use value returned in subsequent calls.
Once gss accept sec context() has returned a value via this parameter, resources have been assigned to the corresponding context, and must be freed by the application after use with a call to gss delete sec context().
gss cred id t, read Credential handle claimed by context acceptor.
C NO CREDENTIAL to accept the context as a default principal.
If GSS C NO CREDENTIAL is specified, but no default acceptor principal is defined, GSS S NO CRED will be returned.
input token buffer   buffer, opaque, read token obtained from remote application.
input chan bindings  channel bindings, read, optional Application  specified bindings.
Allows application to securely bind channel identification information to the security context.
If channel bindings are not used, specify GSS C NO CHANNEL BINDINGS.
After use, this name should be deallocated by passing it to gss release name().
If not required, specify NULL.
The returned OID value will be a pointer into static storage, and should be treated as read only by the caller (in particular, it does not need to be freed).
If not required, specify NULL.
modify Token to be passed to peer application.
If the length field of the returned token buffer is 0, then no token need be passed to the peer application.
If a non  zero length field is returned, the associated storage must be freed after use by the application with a call to gss release buffer().
If not needed, specify NULL.
Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically ANDed with the ret flags value to test whether a given option is supported by the context.
The flags are: GSS C DELEG FLAG
True Delegated credentials are available via the delegated cred handle parameter False
No credentials were delegated GSS C MUTUAL FLAG
True Remote peer asked for mutual authentication False Remote peer did not ask for mutual authentication GSS C REPLAY FLAG True replay of protected messages will be detected False replayed messages will not be detected GSS C SEQUENCE FLAG True out of sequence
protected messages will be detected False out of sequence messages will not be detected GSS C CONF FLAG True Confidentiality service may be invoked by calling the gss wrap routine False No confidentiality service (via gss wrap) available.
gss wrap will provide message encapsulation, data origin authentication and integrity services only.
True Integrity service may be invoked by calling either gss get mic or gss wrap routines.
False Per message integrity service unavailable.
The initiator does not wish to be authenticated; the src name parameter (if requested) contains an anonymous internal name.
False The initiator has been authenticated normally.
GSS C PROT READY FLAG True Protection services (as specified by the states of the GSS C CONF FLAG and GSS C INTEG FLAG) are available if the accompanying major status return value is either GSS S COMPLETE or GSS S CONTINUE NEEDED.
False Protection services (as specified by the states of the GSS C CONF FLAG and GSS C INTEG FLAG) are available only if the accompanying major status return value is GSS S COMPLETE.
The resultant security context may be transferred to other processes via a call to gss export sec context().
False The security context is not transferable.
All other bits should be set to zero.
delegated cred handle gss cred
t, modify, optional credential handle for credentials received from context initiator.
Only valid if deleg flag in ret flags is true, in which case an explicit credential handle (i.e. not GSS C NO CREDENTIAL) will be returned; if deleg flag is false, gss accept context
() will set this parameter to
If a credential handle is returned, the associated resources must be released by the application after use with a call to gss release cred().
Specify NULL if not required.
GSS S CONTINUE NEEDED Indicates that a token from the peer application is required to complete the context, and that gss accept sec context must be called again with that token.
GSS S DEFECTIVE TOKEN Indicates that consistency checks performed on the input token failed.
GSS S DEFECTIVE CREDENTIAL Indicates that consistency checks performed on the credential failed.
The supplied credentials were not valid for context acceptance, or the credential handle did not reference any credentials.
GSS S CREDENTIALS EXPIRED The referenced credentials have expired.
The input token contains different channel bindings to those specified via the input chan bindings parameter.
Indicates that the supplied context handle did not refer to a valid context.
The input token contains an invalid MIC.
The input token was too old.
This is a fatal error during context establishment.
The input token is valid, but is a duplicate of a token already processed.
This is a fatal error during context establishment.
The received token specified a mechanism that is not supported by the implementation or the provided credential.
: Allows an application to acquire a handle for a pre existing credential by name.
GSS API implementations must impose a local access control policy on callers of this routine to prevent unauthorized callers from acquiring credentials to which they are not entitled.
This routine is not intended to provide a "login to the network" function, as such a function would involve the creation of new credentials rather than merely acquiring a handle to existing credentials.
Such functions, if required, should be defined in implementation specific extensions to the API.
If desired name is GSS C
, the call is interpreted as a request for a credential handle that will invoke default behavior when passed to gss init sec context() (if cred usage is GSS C INITIATE or GSS C BOTH) or gss accept sec context() (if cred usage is GSS C ACCEPT or GSS C BOTH).
Mechanisms should honor the desired mechs parameter, and return a credential that is suitable to use only with the requested mechanisms.
An exception to this is the case where one underlying credential element can be shared by multiple mechanisms; in this case it is permissible for an implementation to indicate all mechanisms with which the credential element may be used.
If desired mechs is an empty set, behavior is undefined.
This routine is expected to be used primarily by context acceptors, since implementations are likely to provide mechanism specific ways of obtaining GSS API initiator credentials from the system login process.
Some implementations may therefore not support the acquisition of GSS C INITIATE or GSS C
BOTH credentials via gss acquire cred for any name other than GSS C NO NAME, or a name produced by applying either gss inquire cred to a valid credential, or gss inquire context to an active context.
If credential acquisition is time consuming for a mechanism, the mechanism may choose to delay the actual acquisition until the credential is required (e.g. by gss init sec context or gss accept sec context).
Such mechanism specific implementation decisions should be invisible to the calling application; thus a call of gss inquire cred immediately following the call of gss acquire cred must return valid credential data, and may therefore incur the overhead of a deferred credential acquisition.
Specify GSS C INDEFINITE to request that the credentials have the maximum permitted lifetime.
NO OID SET may be used to obtain an implementation specific default.
BOTH Credentials may be used either to initiate or accept security contexts.
GSS C INITIATE Credentials will only be used to initiate security contexts.
GSS C ACCEPT Credentials will only be used to accept security contexts.
gss cred id t, modify The returned credential handle.
Resources associated with this credential handle must be released by the application after use with a call to gss release cred().
The set of mechanisms for which the credential is valid.
Storage associated with the returned OID set must be released by the application after use with a call to gss release oid set().
Specify NULL if not required.
If the implementation does not support expiration of credentials, the value GSS C INDEFINITE will be returned.
Function value:  GSS status code GSS S COMPLETE
Successful completion GSS S BAD MECH    Unavailable mechanism requested
GSS S BAD NAMETYPE Type contained within desired name parameter is not supported
GSS S BAD NAME    Value supplied for desired name parameter is ill formed.
The credentials could not be acquired Because they have expired.
No credentials were found for the specified name.
id t input cred handle, const gss name t
Adds a credential element to a credential.
The credential element is identified by the name of the principal to which it refers.
GSS API implementations must impose a local access control policy on callers of this routine to prevent unauthorized callers from acquiring credential elements to which they are not entitled.
This routine is not intended to provide a "login to the network" function, as such a function would involve the creation of new mechanism specific authentication data, rather than merely acquiring a GSS API handle to existing data.
Such functions, if required, should be defined in implementation specific extensions to the API.
If desired name is GSS C
, the call is interpreted as a request to add a credential element that will invoke default behavior when passed to gss init sec context() (if cred usage is GSS C INITIATE or GSS C BOTH) or gss accept sec context() (if cred usage is GSS C ACCEPT or GSS C BOTH).
This routine is expected to be used primarily by context acceptors, since implementations are likely to provide mechanism specific ways of obtaining GSS API initiator credentials from the system login process.
Some implementations may therefore not support the acquisition of GSS C INITIATE or GSS C
BOTH credentials via gss acquire cred for any name other than GSS C NO NAME, or a name produced by applying either gss inquire cred to a valid credential, or gss inquire context to an active context.
If credential acquisition is time consuming for a mechanism, the mechanism may choose to delay the actual acquisition until the credential is required (e.g. by gss init sec context or gss accept sec context).
Such mechanism specific implementation decisions should be invisible to the calling application; thus a call of gss inquire cred immediately following the call of gss add cred must return valid credential data, and may therefore incur the overhead of a deferred credential acquisition.
This routine can be used to either compose a new credential containing all credential elements of the original in addition to the newly acquire credential element, or to add the new credential  element to an existing credential.
If NULL is specified for the output cred handle parameter argument, the new credential element will be added to the credential identified by input cred handle; if a valid pointer is specified for the output cred handle parameter, a new credential handle will be created.
If GSS C NO CREDENTIAL is specified as the input cred handle, gss add cred will compose a credential (and set the output cred handle parameter accordingly) based on default behavior.
That is, the call will have the same effect as if the application had first made a call to gss acquire cred(), specifying the same usage and passing GSS C NO NAME as the desired name parameter to obtain an explicit credential handle embodying default behavior, passed this credential handle to gss add cred(), and finally called gss release cred() on the first credential handle.
If GSS C NO CREDENTIAL is specified as the input cred handle parameter, a non NULL output cred handle must be supplied.
input cred handle gss cred id t, read,
optional The credential to which a credential element will be added.
If GSS C NO CREDENTIAL is specified, the routine will compose the new credential based on default behavior (see description above).
Note that, while the credential handle is not modified by gss add cred(), the underlying credential will be modified if output credential handle is NULL.
Name of principal whose credential should be acquired.
BOTH Credential may be used either to initiate or accept security contexts.
GSS C INITIATE Credential will only be used to initiate security contexts.
GSS C ACCEPT Credential will only be used to accept security contexts.
initiator time req Integer, read, optional number of seconds that the credential should remain valid for initiating security contexts.
This argument is ignored if the composed credentials are of type GSS C ACCEPT.
Specify GSS C INDEFINITE to request that the credentials have the maximum permitted initiator lifetime.
acceptor time req Integer, read, optional number of seconds that the credential should remain valid for accepting security contexts.
This argument is ignored if the composed credentials are of type GSS C INITIATE.
Specify GSS C INDEFINITE to request that the credentials have the maximum permitted initiator lifetime.
output cred handle gss cred
The returned credential handle, containing the new credential element and all the credential elements from input cred handle.
If a valid pointer to a gss cred id t is supplied for this parameter, gss add cred creates a new credential handle containing all credential elements from the input cred handle and the newly acquired credential element; if NULL is specified for this parameter, the newly acquired credential element will be added to the credential identified by input cred handle.
The resources associated with any credential handle returned via this parameter must be released by the application after use with a call to gss release cred().
Storage for the returned OID set must be freed by the application after use with a call to gss release oid set().
Specify NULL if not required.
initiator time rec Integer, modify, optional Actual number of seconds for which the returned credentials will remain valid for initiating contexts using the specified mechanism.
If the implementation or mechanism does not support expiration of credentials, the value GSS C INDEFINITE will be returned.
if not required acceptor time rec Integer, modify, optional Actual number of seconds for which the returned credentials will remain valid for accepting security contexts using the specified mechanism.
If the implementation or mechanism does not support expiration of credentials, the value GSS C INDEFINITE will be returned.
if not required Function value:   GSS status code GSS S COMPLETE
Successful completion GSS S BAD MECH    Unavailable mechanism requested
GSS S BAD NAMETYPE Type contained within desired name parameter is not supported
GSS S BAD NAME    Value supplied for desired name parameter is ill formed.
The credential already contains an element for the requested mechanism with overlapping usage and validity period.
The required credentials could not be added because they have expired.
No credentials were found for the specified name.
Purpose: Add an Object Identifier to an Object Identifier set.
This routine is intended for use in conjunction with gss create empty oid set when constructing a set of mechanism OIDs for input to gss acquire cred.
The oid set parameter must refer to an OID set that was created by GSS API (e.g. a set returned by gss create empty oid set()).
GSS API creates a copy of the member oid and inserts this copy into the set, expanding the storage allocated to the OID set's elements array if necessary.
The routine may add the new member OID anywhere within the elements array, and implementations should verify that the new member oid is not already contained within the elements array; if the member oid is already present, the oid set should remain unchanged.
Function value:   GSS status code GSS S
const gss name t input name, const gss OID    mech type,
: Generate a canonical mechanism name (MN) from an arbitrary internal name.
The mechanism name is the name that would be returned to a context acceptor on successful authentication of a context where the initiator used the input name in a successful call to gss acquire cred, specifying an OID set containing <mech type> as its only member, followed by a call to gss init sec context, specifying <mech type> as the authentication mechanism.
The desired mechanism must be specified explicitly; no default is provided.
Storage associated with this name must be freed by the application after use with a call to gss release name().
Function value:   GSS status code GSS S COMPLETE
The identified mechanism is not supported.
The provided internal name contains no elements that could be processed by the specified mechanism.
The provided internal name was ill formed.
Purpose: Allows an application to compare two internal form names to determine whether they refer to the same entity.
If either name presented to gss compare name denotes an anonymous principal, the routines should indicate that the two names do not refer to the same identity.
boolean, modify non zero names refer to same entity zero names refer to different entities (strictly, the names are not known to refer to the same identity).
Function value:   GSS status code GSS S
The two names were of incomparable types.
One or both of name1 or name2 was ill formed.
Determines the number of seconds for which the specified context will remain valid.
id t, read Identifies the context to be interrogated.
If the context has already expired, zero will be returned.
Function value:   GSS status code GSS S
The context has already expired GSS S
The context handle parameter did not identify a valid context 5.8.
gss create empty oid set OM
: Create an object identifier set containing no object identifiers, to which members may be subsequently added using the gss add oid set member() routine.
These routines are intended to be used to construct sets of mechanism object identifiers, for input to gss acquire cred.
The routine will allocate the gss OID set desc object, which the application must free after use with a call to gss release oid set().
Function value:   GSS status code GSS S
delete sec context OM uint32
t  context handle, gss buffer t output token)
gss delete sec context will delete the local data structures associated with the specified security context, and may generate an output token, which when passed to the peer gss process context token will instruct it to do likewise.
If no token is required by the mechanism, the GSS API should set the length field of the output token (if provided) to zero.
No further security services may be obtained using the context specified by context handle.
In addition to deleting established security contexts, gss delete sec context must also be able to delete "half built" security contexts resulting from an incomplete sequence of gss init sec context()/gss
The output token parameter is retained for compatibility with version 1 of the GSS API.
It is recommended that both peer applications invoke gss delete sec context passing the value GSS C
NO BUFFER for the output token parameter, indicating that no token is required, and that gss delete sec context should simply delete local context data structures.
If the application does pass a valid buffer to gss delete sec context, mechanisms are encouraged to return a zero  length token, indicating that no peer action is necessary, and that no token should be transferred by the application.
, modify context handle identifying context to delete.
After deleting the context, the GSS API will set this context handle to GSS C NO CONTEXT.
It is recommended that applications specify GSS C
NO BUFFER for this parameter, requesting local deletion only.
If a buffer parameter is provided by the application, the mechanism may return a token in it;  mechanisms that implement only local deletion should set the length field of this token to zero to indicate to the application that no token is to be sent to the peer.
Function value:   GSS status code GSS S
Purpose: Allows an application to obtain a textual representation of an opaque internal form  name for display purposes.
The syntax of a printable name is defined by the GSS API implementation.
If input name denotes an anonymous principal, the implementation should return the gss OID value GSS C NT ANONYMOUS as the output name type, and a textual name that is syntactically distinct from all valid supported printable names in output name buffer.
If input name was created by a call to gss import name, specifying GSS C
NO OID as the name type,
implementations that employ lazy conversion between name types may return GSS C
NO OID via the output name type parameter.
modify buffer to receive textual name string.
The application must free storage associated with this name after use with a call to gss release buffer().
output name type  Object ID, modify, optional
The type of the returned name.
The returned gss OID will be a pointer into static storage, and should be treated as read only by the caller
(in particular, the application should not attempt to free it).
Specify NULL if not required.
Function value:   GSS status code GSS S
Purpose: Allows an application to obtain a textual representation of a GSS API status code, for display to the user or for logging purposes.
Since some status values may indicate multiple conditions, applications may need to call gss display status multiple times, each call generating a single text string.
The message context parameter is used by gss display status to store state information about which error messages have already been extracted from a given status value; message context must be initialized to 0 by the application prior to the first call, and gss display status will return a non zero value in this parameter if there are further messages to extract.
The message context parameter contains all state information required by gss display status in order to extract further messages from the status value;  even when a non zero value is returned in this parameter, the application is not required to call gss display status again unless subsequent messages are desired.
; do { maj status   gss display status ( &min status, status code, GSS C GSS CODE, GSS C NO OID, &message context, &status string)
NO OID to obtain the system default.
Integer, read/modify Should be initialized to zero by the application prior to the first call.
On return from gss display status(), a non zero status value parameter indicates that additional messages may be extracted from the status code via subsequent calls to gss display status(), passing the same status value, status type, mech type, and message context parameters.
Storage associated with this parameter must be freed by the application after use with a call to gss release buffer().
Function value:   GSS status code GSS S
Successful completion GSS S BAD MECH    Indicates that translation in accordance with an unsupported mechanism type was requested
The status value was not recognized, or the status type was neither GSS C GSS CODE nor GSS C MECH CODE.
: Create an exact duplicate of the existing internal name src name.
The new dest name will be independent of src name (i.e. src name and dest name must both be released, and the release of one shall not affect the validity of the other).
Storage associated with this name must be freed by the application after use with a call to gss release name().
Function value:   GSS status code GSS S
Successful completion GSS S BAD NAME
The src name parameter was ill formed.
The <input name> parameter must specify a valid MN (
i.e. an internal name generated by gss accept sec context or by gss canonicalize name).
Storage associated with this string must freed by the application after use with gss release buffer().
Function value:   GSS status code GSS S
Successful completion GSS S NAME
The provided internal name was not a mechanism name.
The provided internal name was ill formed.
The internal name was of a type not supported by the GSS API implementation.
t  context handle, gss buffer t interprocess token)
Provided to support the sharing of work between multiple processes.
This routine will typically be used by the context acceptor, in an application where a single process receives incoming connection requests and accepts security contexts over them, then passes the established context to one or more other processes for message exchange.
gss export sec context() deactivates the security context for the calling process and creates an interprocess token which, when passed to gss import sec context in another process, will re activate the context in the second process.
Only a single instantiation of a given context may be active at any one time; a subsequent attempt by a context exporter to access the exported security context will fail.
The implementation may constrain the set of processes by which the interprocess token may be imported, either as a function of local security policy, or as a result of implementation decisions.
For example, some implementations may constrain contexts to be passed only between processes that run under the same account, or which are part of the same process group.
The interprocess token may contain security sensitive information (for example cryptographic keys).
While mechanisms are encouraged to either avoid placing such sensitive information within interprocess tokens, or to encrypt the token before returning it to the application, in a typical object library GSS API implementation this may not be possible.
Thus the application must take care to protect the interprocess token, and ensure that any process to which the token is transferred is trustworthy.
If creation of the interprocess token is successful, the implementation shall deallocate all process wide resources associated with the security context, and set the context handle to GSS C NO CONTEXT.
In the event of an error that makes it impossible to complete the export of the security context, the implementation must not return an interprocess token, and should strive to leave the security context referenced by the context handle parameter untouched.
If this is impossible, it is permissible for the implementation to delete the security context, providing it also sets the context handle parameter to GSS C NO CONTEXT.
t, modify context handle identifying the context to transfer.
interprocess token   buffer, opaque, modify token to be transferred to target process.
Storage associated with this token must be freed by the application after use with a call to gss release buffer().
Function value:   GSS status code GSS S
The context has expired GSS S
invalid GSS S UNAVAILABLE The operation is not supported.
const gss buffer t message buffer
Purpose: Generates a cryptographic MIC for the supplied message, and places the MIC in a token for transfer to the peer application.
The qop req parameter allows a choice between several cryptographic algorithms, if supported by the chosen mechanism.
Since some application level protocols may wish to use tokens emitted by gss wrap() to provide "secure framing", implementations must support derivation of MICs from zero length messages.
Callers are encouraged, on portability grounds, to accept the default quality of protection offered by the chosen mechanism, which may be requested by specifying GSS C QOP DEFAULT for this parameter.
If an unsupported protection strength is requested, gss get mic will return a major status of GSS S BAD QOP.
The application must free storage associated with this buffer after use with a call to gss release buffer().
Function value:   GSS status code GSS S
The context has already expired GSS S
parameter did not identify a valid context GSS S
The specified QOP is not supported by the mechanism.
Convert a contiguous string name to internal form.
In general, the internal name returned (via the <output name> parameter) will not be an MN; the exception to this is if the <input name type
> indicates that the contiguous string provided via the <input name buffer> parameter is of type GSS C NT EXPORT NAME, in which case the returned internal name will be an MN for the mechanism that exported the name.
modify Mechanism specific status code input name buffer  buffer, octet string, read buffer containing contiguous string name to convert input name type   Object ID, read, optional Object ID specifying type of printable name.
Applications may specify either GSS C
NO OID to use a mechanism specific default printable syntax, or an OID recognized by the GSS API implementation to name a specific namespace.
, modify returned name in internal form.
Storage associated with this name must be freed by the application after use with a call to gss release name().
Function value:   GSS status code GSS S
The input name type was unrecognized GSS S BAD NAME
The input name parameter could not be interpreted as a name of the specified type GSS S BAD MECH
The input name type was GSS C NT EXPORT NAME, but the mechanism contained within the input name is not supported 5.17.
const gss buffer t interprocess token,
Purpose: Allows a process to import a security context established by another process.
A given interprocess token may be imported only once.
See gss export sec context.
token  buffer, opaque, modify token received from exporting process context handle
, modify context handle of newly reactivated context.
Resources associated with this context handle must be released by the application after use with a call to gss delete sec context().
Function value:   GSS status code GSS S COMPLETE
The token did not contain a valid context reference.
GSS S UNAVAILABLE The operation is unavailable.
GSS S UNAUTHORIZED Local policy prevents the import of this context by the current process.
gss indicate mechs OM uint32 gss indicate mechs ( OM uint32    minor status, gss OID set  mech set)
Purpose: Allows an application to determine which underlying security mechanisms are available.
The returned gss OID set value will be a dynamically allocated OID set, that should be released by the caller after use with a call to gss release oid set().
Function value:   GSS status code GSS S
initiator cred handle, gss ctx
: Initiates the establishment of a security context between the application and a remote peer.
Initially, the input token parameter should be specified either as GSS C NO BUFFER, or as a pointer to a gss buffer desc object whose length field contains the value zero.
The routine may return a output token which should be transferred to the peer application, where the peer application will present it to gss accept sec context.
If no token need be sent, gss init sec context will indicate this by setting the length field of the output token argument to zero.
To complete the context establishment, one or more reply tokens may be required from the peer application; if so, gss init sec context will return a status containing the supplementary information bit GSS S CONTINUE NEEDED.
In this case, gss init sec context should be called again when the reply token is received from the peer application, passing the reply token to gss init sec context via the input token parameters.
Portable applications should be constructed to use the token length and return status to determine whether a token needs to be sent or waited for.
Thus a typical portable caller should always invoke gss init sec context within a loop:
gss init sec context(&min stat, cred hdl, &context hdl, target name, desired mech, desired services, desired time, input bindings, input token, &actual mech, output token, &actual services, &actual time); if (GSS ERROR(maj stat))
gss delete sec context(&min stat, &context hdl,
; Whenever the routine returns a major status that includes the value GSS S CONTINUE NEEDED, the context is not fully established and the following restrictions apply to the output parameters: The value returned via the time rec parameter is undefined Unless the accompanying ret flags parameter contains the bit GSS C PROT READY FLAG, indicating that per message services may be applied in advance of a successful completion status, the value returned via the actual mech type parameter is undefined until the routine returns a major status value of GSS S COMPLETE.
The values of the GSS C DELEG FLAG, GSS C MUTUAL FLAG, GSS C REPLAY FLAG, GSS C SEQUENCE FLAG, GSS C CONF FLAG, GSS C INTEG FLAG and GSS C
ANON FLAG bits returned via the ret flags parameter should contain the values that the implementation expects would be valid if context establishment were to succeed.
In particular, if the application has requested a service such as delegation or anonymous authentication via the req flags argument, and such a service is unavailable from the underlying mechanism, gss init sec context should generate a token that will not provide the service, and indicate via the ret flags argument that the service will not be supported.
The application may choose to abort the context establishment by calling gss delete sec context (if it cannot continue in the absence of the service), or it may choose to transmit the token and continue context establishment (if the service was merely desired but not mandatory).
The values of the GSS C PROT READY FLAG and GSS C TRANS FLAG bits within ret flags
should indicate the actual state at the time gss init sec context returns, whether or not the context is fully established.
GSS API implementations that support per message protection are encouraged to set the GSS C PROT READY FLAG in the final ret flags returned to a caller (i.e. when accompanied by a GSS S COMPLETE status code).
However, applications should not rely on this behavior as the flag was not defined in Version 1 of the GSS API.
Instead, applications should determine what per message services are available after a successful context establishment according to the GSS C INTEG FLAG and GSS C CONF FLAG values.
All other bits within the ret flags argument should be set to zero.
If the initial call of gss init sec context() fails, the implementation should not create a context object, and should leave the value of the context handle parameter set to GSS C NO CONTEXT to indicate this.
In the event of a failure on a subsequent call, the implementation is permitted to delete the "half built" security context (in which case it should set the context handle parameter to GSS C NO CONTEXT), but the preferred behavior is to leave the security context untouched for the application to delete (using gss delete sec context).
During context establishment, the informational status bits GSS S OLD TOKEN and GSS S DUPLICATE TOKEN indicate fatal errors, and GSS API mechanisms should always return them in association with a routine error of GSS S FAILURE.
This requirement for pairing did not exist in version 1 of the GSS API specification, so applications that wish to run over version 1 implementations must special case these codes.
gss cred id t, read, optional handle for credentials claimed.
Supply GSS C NO CREDENTIAL to act as a default initiator principal.
If no default initiator is defined, the function will return GSS S NO CRED.
t, read/modify context handle for new context.
NO CONTEXT for first call;
use value returned by first call in continuation calls.
Resources associated with this context handle must be released by the application after use with a call to gss delete sec context().
Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically ORed together to form the bit mask value.
The flags are: GSS C DELEG FLAG True Delegate credentials to remote peer False
Don't delegate GSS C MUTUAL FLAG True Request that remote peer authenticate itself False Authenticate self to remote peer
only GSS C REPLAY FLAG
True Enable replay detection for messages protected with gss wrap or gss get mic False Don't attempt to detect replayed messages GSS C SEQUENCE FLAG
True Enable detection of out of sequence protected messages False
Don't attempt to detect out of sequence messages GSS C CONF FLAG True Request that confidentiality service be made available (via gss wrap)
No per message confidentiality service is required.
GSS C INTEG FLAG True Request that integrity service be made available (via gss wrap or gss
No per message integrity service is required.
Do not reveal the initiator's identity to the acceptor.
Supply 0 to request a default validity period.
input chan bindings  channel bindings, read, optional Application specified bindings.
Allows application to securely bind channel identification information to the security context.
NO CHANNEL BINDINGS if channel bindings are not used.
Token received from peer application.
NO BUFFER, or a pointer to a buffer containing the value GSS C EMPTY BUFFER on initial call.
actual mech type  OID, modify, optional Actual mechanism used.
The OID returned via this parameter will be a pointer to static storage that should be treated as read only; In particular the application should not attempt to free it.
Specify NULL if not required.
If the length field of the returned buffer is zero, no token need be sent to the peer application.
Storage associated with this buffer must be freed by the application after use with a call to gss release buffer().
Specify NULL if not required.
Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically ANDed with the ret flags value to test whether a given option is supported by the context.
The flags are: GSS C DELEG FLAG True Credentials were delegated to the remote peer False
No credentials were delegated GSS C MUTUAL FLAG True
The remote peer has authenticated itself.
False Remote peer has not authenticated itself.
GSS C REPLAY FLAG True replay of protected messages will be detected False replayed messages will not be detected GSS C SEQUENCE FLAG True out of sequence
protected messages will be detected False out of sequence messages will not be detected GSS C CONF FLAG True Confidentiality service may be invoked by calling gss wrap routine False No confidentiality service (via gss wrap) available.
gss wrap will provide message encapsulation, data origin authentication and integrity services only.
True Integrity service may be invoked by calling either gss get mic or gss wrap routines.
False Per message integrity service unavailable.
The initiator's identity has not been revealed, and will not be revealed if any emitted token is passed to the acceptor.
False The initiator's identity has been or will be authenticated normally.
GSS C PROT READY FLAG True Protection services (as specified by the states of the GSS C CONF FLAG and GSS C INTEG FLAG) are available for use if the accompanying major status return value is either GSS S COMPLETE or GSS S CONTINUE NEEDED.
False Protection services (as specified by the states of the GSS C CONF FLAG and GSS C INTEG FLAG) are available only if the accompanying major status return value is GSS S COMPLETE.
The resultant security context may be transferred to other processes via a call to gss export sec context().
False The security context is not transferable.
All other bits should be set to zero.
If the implementation does not support context expiration, the value GSS C INDEFINITE will be returned.
Specify NULL if not required.
Function value:   GSS status code GSS S
NEEDED Indicates that a token from the peer application is required to complete the context, and that gss init sec context must be called again with that token.
GSS S DEFECTIVE TOKEN Indicates that consistency checks performed on the input token failed GSS S DEFECTIVE CREDENTIAL
Indicates that consistency checks performed on the credential failed.
The supplied credentials were not valid for context initiation, or the credential handle did not reference any credentials.
GSS S CREDENTIALS EXPIRED The referenced credentials have expired GSS S BAD BINDINGS
The input token contains different channel bindings to those specified via the input chan bindings parameter GSS S BAD SIG
The input token contains an invalid MIC, or a MIC that could not be verified GSS S OLD TOKEN
The input token was too old.
This is a fatal error during context establishment GSS S DUPLICATE TOKEN
The input token is valid, but is a duplicate of a token already processed.
This is a fatal error during context establishment.
Indicates that the supplied context handle did not refer to a valid context GSS S BAD NAMETYPE
The provided target name parameter contained an invalid or unsupported type of name GSS S BAD NAME
The provided target name parameter was ill formed.
The specified mechanism is not supported by the provided credential, or is unrecognized by the implementation.
Obtains information about a security context.
The caller must already have obtained a handle that refers to the context, although the context need not be fully established.
, read A handle that refers to the security context.
The name of the context initiator.
If the context was established using anonymous authentication, and if the application invoking gss inquire context is the context acceptor, an anonymous name will be returned.
Storage associated with this name must be freed by the application after use with a call to gss release name().
Specify NULL if not required.
The name of the context acceptor.
Storage associated with this name must be freed by the application after use with a call to gss release name().
If the context acceptor did not authenticate itself, and if the initiator did not specify a target name in its call to gss init sec context(), the value GSS C
NO NAME will be returned.
Specify NULL if not required.
The number of seconds for which the context will remain valid.
If the context has expired, this parameter will be set to zero.
If the implementation does not support context expiration, the value GSS C INDEFINITE will be returned.
Specify NULL if not required.
The returned OID will be a pointer to static storage that should be treated as read only by the application; in particular the application should not attempt to free it.
Specify NULL if not required.
optional Contains various independent flags, each of which indicates that the context supports (or is expected to support
, if ctx open is false) a specific service option.
If not needed, specify NULL.
Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically ANDed with the ret flags value to test whether a given option is supported by the context.
The flags are: GSS C DELEG FLAG True Credentials were delegated from the initiator to the acceptor.
False No credentials were delegated
The acceptor was authenticated to the initiator False
The acceptor did not authenticate itself.
GSS C REPLAY FLAG True replay of protected messages will be detected False replayed messages will not be detected GSS C SEQUENCE FLAG True out of sequence
protected messages will be detected False out of sequence messages will not be detected GSS C CONF FLAG True Confidentiality service may be invoked by calling gss wrap routine False No confidentiality service (via gss wrap) available.
gss wrap will provide message encapsulation, data origin authentication and integrity services only.
True Integrity service may be invoked by calling either gss get mic or gss wrap routines.
False Per message integrity service unavailable.
The initiator's identity will not be revealed to the acceptor.
The src name parameter (if requested) contains an anonymous internal name.
False The initiator has been authenticated normally.
GSS C PROT READY FLAG True Protection services (as specified by the states of the GSS C CONF FLAG and GSS C INTEG FLAG) are available for use.
False Protection services (as specified by the states of the GSS C CONF FLAG and GSS C INTEG FLAG) are available only if the context is fully established (i.e. if the open parameter is non zero).
The resultant security context may be transferred to other processes via a call to gss export sec context().
False The security context is not transferable.
if the invoking application is the context initiator.
if the context is fully established; Zero if a context establishment token is expected from the peer application.
Specify NULL if not required.
Function value:   GSS status code GSS S
The referenced context could not be accessed.
Obtains information about a credential.
cred id t, read A handle that refers to the target credential.
C NO CREDENTIAL to inquire about the default initiator principal.
The name whose identity the credential asserts.
Storage associated with this name should be freed by the application after use with a call to gss release name().
Specify NULL if not required.
The number of seconds for which the credential will remain valid.
If the credential has expired, this parameter will be set to zero.
If the implementation does not support credential expiration, the value GSS C INDEFINITE will be returned.
Specify NULL if not required.
GSS C INITIATE GSS C ACCEPT GSS C
BOTH Specify NULL if not required.
Storage associated with this OID set must be freed by the application after use with a call to gss release oid set().
Specify NULL if not required.
Function value:   GSS status code GSS S
The referenced credentials could not be accessed.
The referenced credentials were invalid.
GSS S CREDENTIALS EXPIRED The referenced credentials have expired.
If the lifetime parameter was not passed as NULL, it will be set to 0.
Obtains per mechanism information about a credential.
cred id t, read A handle that refers to the target credential.
C NO CREDENTIAL to inquire about the default initiator principal.
Storage associated with this name must be freed by the application after use with a call to gss release name().
Specify NULL if not required.
initiator lifetime  Integer, modify, optional
The number of seconds for which the credential will remain capable of initiating security contexts under the specified mechanism.
If the credential can no longer be used to initiate contexts, or if the credential usage for this mechanism is GSS C ACCEPT, this parameter will be set to zero.
If the implementation does not support expiration of initiator credentials, the value GSS C INDEFINITE will be returned.
Specify NULL if not required.
acceptor lifetime Integer, modify, optional
The number of seconds for which the credential will remain capable of accepting security contexts under the specified mechanism.
If the credential can no longer be used to accept contexts, or if the credential usage for this mechanism is GSS C INITIATE, this parameter will be set to zero.
If the implementation does not support expiration of acceptor credentials, the value GSS C INDEFINITE will be returned.
Specify NULL if not required.
GSS C INITIATE GSS C ACCEPT GSS C
BOTH Specify NULL if not required.
Function value:   GSS status code GSS S
The referenced credentials could not be accessed.
The referenced credentials were invalid.
GSS S CREDENTIALS EXPIRED The referenced credentials have expired.
If the lifetime parameter was not passed as NULL, it will be set to 0.
gss inquire mechs for name
Purpose: Returns the set of mechanisms supported by the GSS API implementation that may be able to process the specified name.
Each mechanism returned will recognize at least one element within the name.
It is permissible for this routine to be implemented within a mechanism independent GSS API layer, using the type information contained within the presented name, and based on registration information provided by individual mechanism implementations.
This means that the returned mech types set may indicate that a particular mechanism will understand the name when in fact it would refuse to accept the name as input to gss canonicalize name, gss init sec context, gss acquire cred or gss add cred (due to some property of the specific name, as opposed to the name type).
Thus this routine should be used only as a pre  filter for a call to a subsequent mechanism specific routine.
The returned OID set must be freed by the caller after use with a call to gss release oid set().
Function value:   GSS status code GSS S
Successful completion GSS S BAD NAME
The input name parameter was ill formed.
The input name parameter contained an invalid or unsupported type of name 5.24.
gss inquire names for mech OM
, gss OID set    name types)
Purpose: Returns the set of nametypes supported by the specified mechanism.
modify Set of name types supported by the specified mechanism.
The returned OID set must be freed by the application after use with a call to gss release oid set().
Function value:   GSS status code GSS S COMPLETE
id t context handle, const gss buffer t token buffer)
: Provides a way to pass an asynchronous token to the security service.
Most context level tokens are emitted and processed synchronously by gss init sec context and gss accept sec context, and the application is informed as to whether further tokens are expected by the GSS C CONTINUE NEEDED major status bit.
Occasionally, a mechanism may need to emit a context level token at a point when the peer entity is not expecting a token.
For example, the initiator's final call to gss init sec context may emit a token and return a status of GSS S COMPLETE, but the acceptor's call to gss accept sec context may fail.
The acceptor's mechanism may wish to send a token containing an error indication to the initiator, but the initiator is not expecting a token at this point, believing that the context is fully established.
Gss process context token provides a way to pass such a token to the mechanism at any time.
GSS status code GSS S COMPLETE
Successful completion GSS S DEFECTIVE TOKEN Indicates that consistency checks performed on the token failed GSS S
The context handle did not refer to a valid context 5.26.
Free storage associated with a buffer.
The storage must have been allocated by a GSS API routine.
In addition to freeing the associated storage, the routine will zero the length field in the descriptor to which the buffer parameter refers, and implementations are encouraged to additionally set the pointer field in the descriptor to NULL.
Any buffer object returned by a GSS API routine may be passed to gss release buffer (even if there is no storage associated with the buffer).
The storage associated with the buffer will be deleted.
The gss buffer desc object will not be freed, but its length field will be zeroed.
GSS status code GSS S COMPLETE
Informs GSS API that the specified credential handle is no longer required by the application, and frees associated resources.
Implementations are encouraged to set the cred handle to GSS C
NO CREDENTIAL on successful completion of this call.
t, modify, optional Opaque handle identifying credential to be released.
If GSS C NO CREDENTIAL is supplied, the routine will complete successfully, but will do nothing.
Function value:   GSS status code GSS S
Credentials could not be accessed.
gss release name OM uint32 gss release name ( OM uint32   minor status, gss name t  name)
Free GSSAPI allocated storage associated with an internal form name.
Implementations are encouraged to set the name to GSS C
NO NAME on successful completion of this call.
GSS status code GSS S COMPLETE
Successful completion GSS S BAD NAME
The name parameter did not contain a valid name 5.29.
gss release oid set OM uint32
gss release oid set ( OM uint32    minor status,
Free storage associated with a GSSAPI generated gss OID set object.
The set parameter must refer to an OID set that was returned from a GSS API routine.
gss release oid set() will free the storage associated with each individual member OID, the OID set's elements array, and the gss OID set desc.
Implementations are encouraged to set the gss OID set parameter to GSS C
NO OID SET on successful completion of this routine.
The storage associated with the gss OID set will be deleted.
Function value:   GSS status code GSS S
gss test oid set member OM uint32 gss test oid set member
Interrogate an Object Identifier set to determine whether a specified Object Identifier is a member.
This routine is intended to be used with OID sets returned by gss indicate mechs(), gss acquire cred(), and gss inquire cred(), but will also work with user generated sets.
Boolean, modify non zero if the specified OID is a member of the set, zero
Function value:   GSS status code GSS S
id t context handle, const gss buffer t input message buffer
Converts a message previously protected by gss wrap back to a usable form, verifying the embedded MIC.
The conf state parameter indicates whether the message was encrypted; the qop state parameter indicates the strength of protection that was used to provide the confidentiality and integrity services.
Since some application level protocols may wish to use tokens emitted by gss wrap() to provide "secure framing", implementations must support the wrapping and unwrapping of zero length messages.
id t, read Identifies the context on which the message arrived input message buffer  buffer, opaque, read protected message output message buffer  buffer, opaque,
modify Buffer to receive unwrapped message.
Storage associated with this buffer must be freed by the application after use use with a call to gss release buffer().
if not required Function value:   GSS status code GSS S COMPLETE
Successful completion GSS S DEFECTIVE TOKEN
The token failed consistency checks GSS S BAD SIG
The MIC was incorrect GSS S DUPLICATE TOKEN
The token was valid, and contained a correct MIC for the message, but it had already been processed GSS S OLD TOKEN
The token was valid, and contained a correct MIC for the message, but it is too old to check for duplication.
The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; a later token has already been received.
The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; an earlier expected token has not yet been received.
The context has already expired GSS S
The context handle parameter did not identify a valid context 5.32.
Verifies that a cryptographic MIC, contained in the token parameter, fits the supplied message.
The qop state parameter allows a message recipient to determine the strength of protection that was applied to the message.
Since some application level protocols may wish to use tokens emitted by gss wrap() to provide "secure framing", implementations must support the calculation and verification of MICs over zero length messages.
The token failed consistency checks GSS S BAD SIG
The MIC was incorrect GSS S DUPLICATE TOKEN
The token was valid, and contained a correct MIC for the message, but it had already been processed GSS S OLD TOKEN
The token was valid, and contained a correct MIC for the message, but it is too old to check for duplication.
The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; a later token has already been received.
The token was valid, and contained a correct MIC for the message, but has been verified out of sequence; an earlier expected token has not yet been received.
The context has already expired GSS S
The context handle parameter did not identify a valid context 5.33.
Attaches a cryptographic MIC and optionally encrypts the specified input message.
The output message contains both the MIC and the message.
The qop req parameter allows a choice between several cryptographic algorithms, if supported by the chosen mechanism.
Since some application level protocols may wish to use tokens emitted by gss wrap() to provide "secure framing", implementations must support the wrapping of zero length messages.
A mechanism specific default may be requested by setting qop req to GSS C QOP DEFAULT.
If an unsupported protection strength is requested, gss wrap will return a major status of GSS S BAD QOP.
, data origin authentication and integrity services have been applied Zero Integrity and data origin services only has been applied.
if not required output message buffer  buffer, opaque,
modify Buffer to receive protected message.
Storage associated with this message must be freed by the application after use with a call to gss release buffer().
Function value:   GSS status code GSS S
The context has already expired GSS S
parameter did not identify a valid context GSS S
The specified QOP is not supported by the mechanism.
Purpose: Allows an application to determine the maximum message size that, if presented to gss wrap with the same conf req flag and qop req parameters, will result in an output token containing no more than req output size bytes.
This call is intended for use by applications that communicate over protocols that impose a maximum message size.
It enables the application to fragment messages prior to applying protection.
GSS API implementations are recommended but not required to detect invalid QOP values when gss wrap size limit() is called.
This routine guarantees only a maximum message size, not the availability of specific QOP values for message protection.
Successful completion of this call does not guarantee that gss wrap will be able to protect a message of length max input size bytes, since this ability may depend on the availability of system resources at the time that gss wrap is called.
However, if the implementation itself imposes an upper limit on the length of messages that may be processed by gss wrap, the implementation should not return a value via max input bytes that is greater than this length.
, read A handle that refers to the security over which the messages will be sent.
See the routine description for gss wrap for more details.
See the routine description for gss wrap for more details.
req output size   Integer, read The desired maximum size for tokens emitted by gss wrap.
max input size    Integer, modify The maximum input message size that may be presented to gss wrap in order to guarantee that the emitted token shall be no larger than req output size bytes.
Function value:   GSS status code GSS S
The referenced context could not be accessed.
The specified QOP is not supported by the mechanism.
This document specifies a service interface for security facilities and services; as such, security considerations appear throughout the specification.
Nonetheless, it is appropriate to summarize certain specific points relevant to GSS API implementors and calling applications.
Usage of the GSS API interface does not in itself provide security services or assurance; instead, these attributes are dependent on the underlying mechanism(s) which support a GSS API implementation.
Callers must be attentive to the requests made to GSS API calls and to the status indicators returned by GSS API, as these specify the security service characteristics which GSS API will provide.
When the interprocess context transfer facility is used, appropriate local controls should be applied to constrain access to interprocess tokens and to the sensitive data which they contain.
Appendix A. GSS API C header file gssapi.h
C language GSS API implementations should include a copy of the following header file.
If the platform supports the xom.h header file, it should be   included here.
Now define the three implementation dependent types.
id t; typedef <platform specific>
/ typedef <platform specific> gss uint32; #ifdef OM STRING /
We have included the xom.h header file.
Verify that OM uint32   is defined correctly.
/ #if sizeof(gss uint32) !
/ typedef gss uint32 OM uint32
For now, define a QOP type as an OM uint32
#define GSS C INITIATE 1
define GSS C GSS CODE
define GSS C MECH CODE 2
The constant definitions for channel bindings address families  /
#define GSS C AF IMPLINK    3
define GSS C AF DATAKIT
#define GSS C AF DECnet
16 #define GSS C AF
NO NAME ((gss name t)
NO OID ((gss OID) 0)
#define GSS C EMPTY BUFFER {0, NULL}
Some alternate names for a couple of the above   values.
These are defined for V1 compatibility.
define GSS C NULL OID GSS C
NO OID #define GSS C NULL OID SET GSS C
Note that an implementation that offers multiple   levels of QOP may define GSS C QOP DEFAULT to be either zero
(as done here) to mean "default protection", or to a specific   explicit QOP value.
However, a value of 0 should always be   interpreted by a GSS API implementation as a request for the   default protection level.
The constant   GSS C NT USER NAME should be initialized to point   to that gss OID desc.
/ extern gss OID GSS C NT USER NAME; /
gssapi(2) generic(1) machine uid name(2)}.
The constant GSS C NT MACHINE UID NAME should be   initialized to point to that gss OID desc.
/ extern gss OID GSS C NT MACHINE UID NAME; /
) generic(1) string uid name(3)}.
The constant GSS C NT STRING UID NAME should be   initialized to point to that gss OID desc.
/ extern gss OID GSS C NT STRING UID NAME; /
The constant   GSS C NT HOSTBASED SERVICE
X should be initialized to point   to that gss OID desc.
This is a deprecated OID value, and
implementations wishing to support hostbased service names   should instead use the GSS C NT HOSTBASED SERVICE OID,   defined below, to identify such names;   GSS C NT HOSTBASED SERVICE
The constant   GSS C NT HOSTBASED SERVICE should be initialized   to point to that gss OID desc.
/ extern gss OID GSS C NT HOSTBASED SERVICE
The constant   and GSS C NT ANONYMOUS should be initialized to point   to that gss OID desc.
/ extern gss OID GSS C NT ANONYMOUS
The constant   GSS C NT EXPORT NAME should be initialized to point   to that gss OID desc.
define GSS C ROUTINE ERROR
#define GSS C CALLING ERROR MASK 0377ul #
define GSS C ROUTINE ERROR
MASK 0377ul #define GSS C SUPPLEMENTARY MASK 0177777ul /
The macros that test status codes for error conditions.
Note that the GSS ERROR() macro has changed slightly from   the V1 GSS API so that it now evaluates its argument   only once.
(x & (GSS C CALLING
< GSS C CALLING ERROR OFFSET))
(GSS C ROUTINE ERROR MASK <<
GSS C ROUTINE ERROR OFFSET))
(x & (GSS C SUPPLEMENTARY MASK << GSS C SUPPLEMENTARY OFFSET))
< GSS C CALLING ERROR OFFSET)
(GSS C ROUTINE ERROR MASK <<
GSS C ROUTINE ERROR OFFSET)))
Now the actual status code definitions
(1ul << GSS C CALLING ERROR OFFSET)
(2ul << GSS C CALLING ERROR OFFSET)
(3ul << GSS C CALLING ERROR OFFSET)
<< GSS C ROUTINE ERROR OFFSET)
(2ul << GSS C ROUTINE ERROR OFFSET)
(3ul << GSS C ROUTINE ERROR OFFSET)
<< GSS C ROUTINE ERROR OFFSET)
(5ul << GSS C ROUTINE ERROR OFFSET)
(6ul << GSS C ROUTINE ERROR OFFSET)
BAD SIG #define GSS S
(8ul << GSS C ROUTINE ERROR OFFSET)
(9ul << GSS C ROUTINE ERROR OFFSET)
#define GSS S DEFECTIVE CREDENTIAL
<< GSS C ROUTINE ERROR OFFSET)
(11ul << GSS C ROUTINE ERROR OFFSET)
< GSS C ROUTINE ERROR OFFSET)
< GSS C ROUTINE ERROR OFFSET)
< GSS C ROUTINE ERROR OFFSET)
(15ul << GSS C ROUTINE ERROR OFFSET)
<< GSS C ROUTINE ERROR OFFSET)
define GSS S DUPLICATE ELEMENT
(17ul << GSS C ROUTINE ERROR OFFSET)
#define GSS S NAME NOT MN
(18ul << GSS C ROUTINE ERROR OFFSET)
#define GSS S CONTINUE NEEDED \
#define GSS S DUPLICATE TOKEN \
#define GSS S OLD TOKEN \
#define GSS S GAP TOKEN \
cred usage  / gss cred
/ const gss buffer t,
time rec  / gss cred i
conf state  / gss buffer t
/ const gss name t
/ const gss name t
/ const gss name t
/ const gss name t
gss verify mic, gss wrap and gss unwrap.
They should be   provided by GSS API V2 implementations for backwards   compatibility with V1 applications.
(as opposed to #defines) should be provided, both to allow   GSS API V1 applications to link against GSS API V2 implementations,   and to retain the slight parameter type differences between the   obsolete versions of these routines and their current forms.
Appendix B. Additional constraints for application binary portability
The purpose of this C bindings document is to encourage source level portability of applications across GSS API implementations on different platforms and atop different mechanisms.
Additional goals that have not been explicitly addressed by this document are link  time and run time portability.
Link time portability provides the ability to compile an application against one implementation of GSS API, and then link it against a different implementation on the same platform.
It is a stricter requirement than source level portability.
Run time portability differs from link time portability only on those platforms that implement dynamically loadable GSS API implementations, but do not offer load time symbol resolution.
On such platforms, run time portability is a stricter requirement than link time portability, and will typically include the precise placement of the various GSS API routines within library entrypoint vectors.
Individual platforms will impose their own rules that must be followed to achieve link time (and run time, if different) portability.
In order to ensure either form of binary portability, an ABI specification must be written for GSS API implementations on that platform.
However, it is recognized that there are some issues that are likely to be common to all such ABI specifications.
This appendix is intended to be a repository for such common issues, and contains some suggestions that individual ABI specifications may choose to reference.
Since machine architectures vary greatly, it may not be possible or desirable to follow these suggestions on all platforms.
Pointers While ANSI C provides a single pointer type for each declared type, plus a single (void  ) type, some platforms (notably those using segmented memory architectures) augment this with various modified pointer types (e.g. far pointers, near pointers).
These language bindings assume ANSI C, and thus do not address such non standard implementations.
GSS API implementations for such platforms must choose an appropriate memory model, and should use it consistently throughout.
For example, if a memory model is chosen that requires the use of far pointers when passing routine parameters, then far pointers should also be used within the structures defined by GSS  API.
Internal structure alignment GSS API defines several data structures containing differently sized fields.
An ABI specification should include a detailed description of how the fields of such structures are aligned, and if there is any internal padding in these data structures.
The use of compiler defaults for the platform is recommended.
The C bindings specify that the gss cred id t and gss ctx
id t types should be implemented as either pointer or arithmetic types, and that if pointer types are used, care should be taken to ensure that two handles may be compared with the   operator.
Note that ANSI C does not guarantee that two pointer values may be compared with the   operator unless either the two pointers point to members of a single array, or at least one of the pointers contains a NULL value.
For binary portability, additional constraints are required.
The following is an attempt at defining platform independent constraints.
The   operator for the chosen type must be a simple bit wise comparison.
That is, for two in memory handle objects h1 and h2, the boolean value of the expression (h1   h2)
The actual use of the type (void  ) for handle types is discouraged, not for binary portability reasons, but since it effectively disables much of the compile time type checking that the compiler can otherwise perform, and is therefore not "programmer friendly".
If a pointer implementation is desired, and if the platform's implementation of pointers permits, the handles should be implemented as pointers to distinct implementation defined types.
The gss name t type
The gss name t type, representing the internal name object, should be implemented as a pointer type.
The use of the (void  ) type is discouraged as it does not allow the compiler to perform strong type checking.
However, the pointer type chosen should be of the same size as the (void  ) type.
Provided this rule is obeyed, ABI specifications need not further constrain the implementation of gss name t objects.
The int and size t types
Some platforms may support differently sized implementations of the "int" and "size t" types, perhaps chosen through compiler switches, and perhaps dependent on memory model.
An ABI specification for such a platform should include required implementations for these types.
It is recommended that the default implementation (for the chosen memory model, if appropriate) is chosen.
Some platforms support a variety of different binary conventions for calling procedures.
Such conventions cover things like the format of the stack frame, the order in which the routine parameters are pushed onto the stack, whether or not a parameter count is pushed onto the stack, whether some argument(s) or return values are to be passed in registers, and whether the called routine or the caller is responsible for removing the stack frame on return.
For such platforms, an ABI specification should specify which calling convention is to be used for GSS API implementations.
