- contents:
  - '            Simple Hit-Metering and Usage-Limiting for HTTP

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1997).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "ABSTRACT\n   This document proposes a simple extension to HTTP, using a new\n
    \  \"Meter\" header, which permits a limited form of demographic\n   information
    (colloquially called \"hit-counts\") to be reported by\n   caches to origin servers,
    in a more efficient manner than the\n   \"cache-busting\" techniques currently
    used.  It also permits an origin\n   server to control the number of times a cache
    uses a cached response,\n   and outlines a technique that origin servers can use
    to capture\n   referral information without \"cache-busting.\"\n"
  title: ABSTRACT
- contents:
  - "TABLE OF CONTENTS\n   1 Introduction                                                      2\n
    \       1.1 Goals, non-goals, and limitations                          3\n        1.2
    Brief summary of the design                                4\n        1.3 Terminology
    \                                               5\n   2 Overview                                                          5\n
    \       2.1 Discussion                                                 7\n   3
    Design concepts                                                   8\n        3.1
    Implementation of the \"metering subtree\"                   8\n        3.2 Format
    of the Meter header                                10\n        3.3 Negotiation
    of hit-metering and usage-limiting            10\n        3.4 Transmission of
    usage reports                             14\n        3.5 When to send usage reports
    \                               15\n        3.6 Subdivision of usage-limits                               16\n
    \  4 Analysis                                                         17\n        4.1
    Approximation accuracy for counting users                 18\n        4.2 What
    about \"Network Computers\"?                           19\n        4.3 Critical-path
    delay analysis                              19\n   5 Specification                                                    20\n
    \       5.1 Specification of Meter header and directives              20\n        5.2
    Abbreviations for Meter directives                        23\n        5.3 Counting
    rules                                            24\n             5.3.1 Counting
    rules for hit-metering                    24\n             5.3.2 Counting rules
    for usage-limiting                  25\n             5.3.3 Equivalent algorithms
    are allowed                  26\n        5.4 Counting rules: interaction with
    Range requests           27\n        5.5 Implementation by non-caching proxies
    \                    27\n        5.6 Implementation by cooperating caches                      28\n
    \  6 Examples                                                         28\n        6.1
    Example of a complete set of exchanges                    28\n        6.2 Protecting
    against HTTP/1.0 proxies                       30\n        6.3 More elaborate
    examples                                   30\n   7 Interactions with content
    negotiation                            31\n        7.1 Treatment of responses
    carrying a Vary header             31\n        7.2 Interaction with Transparent
    Content Negotiation          32\n   8 A Note on Capturing Referrals                                    32\n
    \  9 Alternative proposals                                            33\n   10
    Security Considerations                                         34\n   11 Acknowledgments
    \                                                35\n   12 References                                                      35\n
    \  13 Authors' Addresses                                              36\n   14
    Full Copyright Statement                                        37\n"
  title: TABLE OF CONTENTS
- contents:
  - "1 Introduction\n   For a variety of reasons, content providers want to be able
    to\n   collect information on the frequency with which their content is\n   accessed.
    This desire leads to some of the \"cache-busting\" done by\n   existing servers.
    \ (\"Cache-busting\" is the use by servers of\n   techniques intended to prevent
    caching of responses; it is unknown\n   exactly how common this is.)  This kind
    of cache-busting is done not\n   for the purpose of maintaining transparency or
    security properties,\n   but simply to collect demographic information.  Some
    cache-busting is\n   also done to provide different advertising images to appear
    on the\n   same page (i.e., each retrieval of the page sees a different ad).\n
    \  This proposal supports a model similar to that of publishers of\n   hard-copy
    publications: such publishers (try to) report to their\n   advertisers how many
    people read an issue of a publication at least\n   once; they don't (try to) report
    how many times a reader re-reads an\n   issue. They do this by counting copies
    published, and then try to\n   estimate, for their publication, on average how
    many people read a\n   single copy at least once. The key point is that the results
    aren't\n   exact, but are still useful. Another model is that of coding\n   inquiries
    in such a way that the advertiser can tell which\n   publication produced the
    inquiry.\n"
  - contents:
    - "1.1 Goals, non-goals, and limitations\n   HTTP/1.1 already allows origin servers
      to prevent caching of\n   responses, and evidence exists [9] that at least some
      of the time,\n   this is being done for the sole purpose of collecting counts
      of the\n   number of accesses of specific pages.  Some of this evidence is\n
      \  inferred from the study of proxy traces; some is based on explicit\n   statements
      of the intention of the operators of Web servers.\n   Information collected
      this way might or might not be of actual use to\n   the people who collect it;
      the fact is that they want to collect it,\n   or already do so.\n   The goal
      of this proposal is to provide an optional performance\n   optimization for
      this use of HTTP/1.1.\n   This specification is:\n      - Optional: no server
      or proxy is required to implement it.\n      - Proxy-centered: there is no involvement
      on the part of\n        end-client implementations.\n      - Solely a performance
      optimization: it provides no\n        information or functionality that is not
      already available\n        in HTTP/1.1.  The intent is to improve performance
      overall,\n        and reduce latency for almost all interactions; latency\n
      \       might be increased for a small fraction of HTTP\n        interactions.\n
      \     - Best-efforts: it does not guarantee the accuracy of the\n        reported
      information, although it does provide accurate\n        results in the absence
      of persistent network failures or\n        host crashes.\n      - Neutral with
      respect to privacy: it reveals to servers no\n        information about clients
      that is not already available\n        through the existing features of HTTP/1.1.\n
      \  The goals of this specification do not include:\n      - Solving the entire
      problem of efficiently obtaining\n        extensive information about requests
      made via proxies.\n      - Improving the protection of user privacy (although
      our\n        proposal may reduce the transfer of user-specific\n        information
      to servers, it does not prevent it).\n      - Preventing or encouraging the
      use of log-exchange\n        mechanisms.\n      - Avoiding all forms of \"cache-busting\",
      or even all\n        cache-busting done for gathering counts.\n   This design
      has certain potential limitations:\n      - If it is not deployed widely in
      both proxies and servers,\n        it will provide little benefit.\n      -
      It may, by partially solving the hit-counting problem,\n        reduce the pressure
      to adopt more complete solutions, if\n        any become available.\n      -
      Even if widely deployed, it might not be widely used, and\n        so might
      not significantly improve performance.\n   These potential limitations might
      not be problems in actual practice.\n"
    title: 1.1 Goals, non-goals, and limitations
  - contents:
    - "1.2 Brief summary of the design\n   This section is included for people not
      wishing to read the entire\n   document; it is not a specification for the proposed
      design, and\n   over-simplifies many aspects of the design.\n   The goal of
      this design is to eliminate the need for origin servers\n   to use \"cache-busting\"
      techniques, when this is done just for the\n   purpose of counting the number
      of users of a resource.  (Cache-\n   busting includes techniques such as setting
      immediate Expiration\n   dates, or sending \"Cache-control:  private\" in each
      response.)\n   The design adds a new \"Meter\" header to HTTP; the header is
      always\n   protected by the \"Connection\" header, and so is always hop-by-hop.\n
      \  This mechanism allows the construction of a \"metering subtree\", which\n
      \  is a connected subtree of proxies, rooted at an origin server.  Only\n   those
      proxies that explicitly volunteer to join in the metering\n   subtree for a
      resource participate in hit-metering, but those proxies\n   that do volunteer
      are required to make their best effort to provide\n   accurate counts.  When
      a hit-metered response is forwarded outside of\n   the metering subtree, the
      forwarding proxy adds \"Cache-control: s-\n   maxage=0\", so that other proxies
      (outside the metering subtree) are\n   forced to forward all requests to a server
      in the metering subtree.\n      NOTE: the HTTP/1.1 specification does not currently
      define a \"s-\n      maxage\" Cache-control directive.  The HTTP working group
      has\n      decided to add such a directive to the next revision of the\n      HTTP/1.1
      specification [7].\n   The Meter header carries zero or more directives, similar
      to the way\n   that the Cache-control header carries directives.  Proxies may
      use\n   certain Meter directives to volunteer to do hit-metering for a\n   resource.
      \ If a proxy does volunteer, the server may use certain\n   directives to require
      that a response be hit-metered.  Finally,\n   proxies use a \"count\" Meter
      directive to report the accumulated hit\n   counts.\n   The Meter mechanism
      can also be used by a server to limit the number\n   of uses that a cache may
      make of a cached response, before\n   revalidating it.\n   The full specification
      includes complete rules for counting \"uses\" of\n   a response (e.g., non-conditional
      GETs) and \"reuses\" (conditional\n   GETs).  These rules ensure that the results
      are entirely consistent\n   in all cases, except when systems or networks fail.\n"
    title: 1.2 Brief summary of the design
  - contents:
    - "1.3 Terminology\n   This document uses terms defined and explained in the HTTP/1.1\n
      \  specification [4], including \"origin server,\" \"resource,\" \"hop-by-\n
      \  hop,\" \"unconditional GET,\" and \"conditional GET.\"  The reader is\n   expected
      to be familiar with the HTTP/1.1 specification and its\n   terminology.\n   The
      key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", SHOULD NOT\",\n
      \  \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be\n   interpreted
      as described in RFC 2119 [1].\n"
    title: 1.3 Terminology
  title: 1 Introduction
- contents:
  - "2 Overview\n   The design described in this document introduces several new features\n
    \  to HTTP:\n      - Hit-metering: allows an origin server to obtain reasonably\n
    \       accurate counts of the number of clients using a resource\n        instance
    via a proxy cache, or a hierarchy of proxy caches.\n      - Usage-limiting: allows
    an origin server to control the\n        number of times a cached response may
    be used by a proxy\n        cache, or a hierarchy of proxy caches, before revalidation\n
    \       with the origin server.\n   These new non-mandatory features require minimal
    new protocol\n   support, no change in protocol version, relatively little overhead
    in\n   message headers.  The design adds no additional network round-trips\n   in
    any critical path that directly affects user-perceived latency\n   (see section
    4.3 for an analysis).\n   The primary goal of hit-metering and usage-limiting
    is to obviate the\n   need for an origin server to send \"Cache-control: s-maxage=0\"
    with\n   responses for resources whose value is not likely to change\n   immediately.
    \ In other words, in cases where the only reason for\n   contacting the origin
    server on every request that might otherwise be\n   satisfied by a proxy cache
    entry is to allow the server to collect\n   demographic information or to control
    the number of times a cache\n   entry is used, the extension proposed here will
    avoid a significant\n   amount of unnecessary network traffic and latency.\n   This
    design introduces one new \"Meter\" header, which is used both in\n   HTTP request
    messages and HTTP response messages.  The Meter header\n   is used to transmit
    a number of directives and reports.  In\n   particular, all negotiation of the
    use of hit-metering and usage\n   limits is done using this header.  No other
    changes to the existing\n   HTTP/1.1 specification [4] are proposed in this document.\n
    \  This design also introduces several new concepts:\n      1. The concepts of
    a \"use\" of a cache entry, which is when a\n         proxy returns its entity-body
    in response to a conditional\n         or non-conditional request, and the \"reuse\"
    of a cache\n         entry, which is when a proxy returns a 304 (Not Modified)\n
    \        response to a conditional request which is satisfied by\n         that
    cache entry.\n      2. The concept of a hit-metered resource, for which proxy\n
    \        caches make a best-effort attempt to report accurate\n         counts
    of uses and/or reuses to the origin server.\n      3. The concept of a usage-limited
    resource, for which the\n         origin server expects proxy caches to limit
    the number of\n         uses and/or reuses.\n   The new Meter directives and reports
    interact to allow proxy caches\n   and servers to cooperate in the collection
    of demographic data.  The\n   goal is a best-efforts approximation of the true
    number of uses\n   and/or reuses, not a guaranteed exact count.\n   The new Meter
    directives also allow a server to bound the inaccuracy\n   of a particular hit-count,
    by bounding the number of uses between\n   reports.  It can also, for example,
    bound the number of times the\n   same ad is shown because of caching.\n   Section
    7.1 describes a way to use server-driven content negotiation\n   (the Vary header)
    that allows an HTTP origin server to flexibly\n   separate requests into categories
    and count requests by category.\n   Implementation of such a categorized hit counting
    is likely to be a\n   very small modification to most implementations of Vary;
    some\n   implementations may not require any modification at all.\n"
  - contents:
    - "2.1 Discussion\n   Mapping this onto the publishing model, a proxy cache would
      increment\n   the use-count for a cache entry once for each unconditional GET
      done\n   for the entry, and once for each conditional GET that results in\n
      \  sending a copy of the entry to update a client's invalid cached copy.\n   Conditional
      GETs that result in 304 (Not Modified) are not included\n   in the use-count,
      because they do not result in a new user seeing the\n   page, but instead signify
      a repeat view by a user that had seen it\n   before.  However, 304 responses
      are counted in the reuse-count.\n   HEADs are not counted at all, because their
      responses do not contain\n   an entity-body.\n   The Meter directives apply
      only to shared proxy caches, not to end-\n   client (or other single-user) caches.
      \ Single user caches should not\n   use Meter, because their hits will be automatically
      counted as a\n   result of the unconditional GET with which they first fetch
      the page,\n   from either the origin-server or from a proxy cache.  Their\n
      \  subsequent conditional GETs do not result in a new user seeing the\n   page.\n
      \  The mechanism specified here counts GETs; other methods either do not\n   result
      in a page for the user to read, aren't cached, or are\n   \"written-through\"
      and so can be directly counted by the origin\n   server. (If, in the future,
      a \"cachable POST\" came into existence,\n   whereby the entity-body in the
      POST request was used to select a\n   cached response, then such POSTs would
      have to be treated just like\n   GETs.)  The applicability of hit-metering to
      any new HTTP methods\n   that might be defined in the future is currently unspecifiable.\n
      \  In the case of multiple caches along a path, a proxy cache does the\n   obvious
      summation when it receives a use-count or reuse-count in a\n   request from
      another cache.\n"
    title: 2.1 Discussion
  title: 2 Overview
- contents:
  - "3 Design concepts\n   In order to allow the introduction of hit-metering and
    usage-limiting\n   without requiring a protocol revision, and to ensure a reasonably\n
    \  close approximation of accurate counts, the negotiation of metering\n   and
    usage-limiting is done hop-by-hop, not end-to-end.  If one\n   considers the \"tree\"
    of proxies that receive, store, and forward a\n   specific response, the intent
    of this design is that within some\n   (possibly null) \"metering subtree\", rooted
    at the origin server, all\n   proxies are using the hit-metering and/or usage-limiting
    requested by\n   the origin server.\n   Proxies at the leaves of this subtree
    will insert a \"Cache-control:\n   s-maxage=0\" directive, which forces all other
    proxies (below this\n   subtree) to check with a leaf of the metering subtree
    on every\n   request.  However, it does not prevent them from storing and using\n
    \  the response, if the revalidation succeeds.\n   No proxy is required to implement
    hit-metering or usage-limiting.\n   However, any proxy that transmits the Meter
    header in a request MUST\n   implement every unconditional requirement of this
    specification,\n   without exception or amendment.\n   This is a conservative
    design, which may sometimes fail to take\n   advantage of hit-metering support
    in proxies outside the metering\n   subtree.  However, it is likely that without
    the reliability offered\n   by a conservative design, managers of origin servers
    with\n   requirements for accurate approximations will not take advantage of\n
    \  any hit-metering proposal.\n   The hit-metering/usage-limiting mechanism is
    designed to avoid any\n   extra network round-trips in the critical path of any
    client request,\n   and (as much as possible) to avoid excessively lengthening
    HTTP\n   messages.\n   The Meter header is used to transmit both negotiation information
    and\n   numeric information.\n   A formal specification for the Meter header appears
    in section 5; the\n   following discussion uses an informal approach to improve
    clarity.\n"
  - contents:
    - "3.1 Implementation of the \"metering subtree\"\n   The \"metering subtree\"
      approach is implemented in a simple,\n   straightforward way by defining the
      new \"Meter\" header as one that\n   MUST always be protected by a Connection
      header in every request or\n   response.  I.e., if the Meter header is present
      in an HTTP message,\n   that message:\n      1. MUST contain \"Connection: meter\",
      and MUST be handled\n         according to the HTTP/1.1 specification of the
      Connection\n         header.\n      2. MUST NOT be sent in response to a request
      from a client\n         whose version number is less than HTTP/1.1.\n      3.
      MUST NOT be accepted from a client whose version number is\n         less than
      HTTP/1.1.\n   The reason for the latter two restrictions is to protect against\n
      \  proxies that might not properly implement the Connection header.\n   Otherwise,
      a subtree that includes an HTTP/1.0 proxy might\n   erroneously appear to be
      a metering subtree.\n      Note: It appears that for the Connection header mechanism
      to\n      function correctly, a system receiving an HTTP/1.0 (or lower-\n      version)
      message that includes a Connection header must act as if\n      this header,
      and all of the headers it protects, ought to have\n      been removed from the
      message by an intermediate proxy.\n      Although RFC2068 does not specifically
      require this behavior, it\n      appears to be implied.  Otherwise, one could
      not depend on the\n      stated property (section 14.10) that the protected
      options \"MUST\n      NOT be communicated by proxies over further connections.\"
      \ This\n      should probably be clarified in a subsequent draft of the HTTP/1.1\n
      \     specification.\n      This specification does not, in any way, propose
      a modification of\n      the specification of the Connection header.\n   From
      the point of view of an origin server, the proxies in a metering\n   subtree
      work together to obey usage limits and to maintain accurate\n   usage counts.
      \ When an origin server specifies a usage limit, a proxy\n   in the metering
      subtree may subdivide this limit among its children\n   in the subtree as it
      sees fit.  Similarly, when a proxy in the\n   subtree receives a usage report,
      it ensures that the hits represented\n   by this report are summed properly
      and reported to the origin server.\n   When a proxy forwards a hit-metered or
      usage-limited response to a\n   client (proxy or end-client) not in the metering
      subtree, it MUST\n   omit the Meter header, and it MUST add \"Cache-control:
      s-maxage=0\" to\n   the response.\n"
    title: 3.1 Implementation of the "metering subtree"
  - contents:
    - "3.2 Format of the Meter header\n   The Meter header is used to carry zero or
      more directives.  Multiple\n   Meter headers may occur in an HTTP message, but
      according to the\n   rules in section 4.2 of the HTTP/1.1 specification [4],
      they may be\n   combined into a single header (and should be so combined, to
      reduce\n   overhead).\n   For example, the following sequence of Meter headers\n
      \      Meter: max-uses=3\n       Meter: max-reuses=10\n       Meter: do-report\n
      \  may be expressed as\n       Meter: max-uses=3, max-reuses=10, do-report\n"
    title: 3.2 Format of the Meter header
  - contents:
    - "3.3 Negotiation of hit-metering and usage-limiting\n   An origin server that
      wants to collect hit counts for a resource, by\n   simply forcing all requests
      to bypass any proxy caches, would respond\n   to requests on the resource with
      \"Cache-control: s-maxage=0\".  (An\n   origin server wishing to prevent HTTP/1.0
      proxies from improperly\n   caching the response could also send both \"Expires:
      <now>\", to\n   prevent such caching, and \"Cache-control: max-age=NNNN\", to
      allow\n   newer proxies to cache the response).\n   The purpose of the Meter
      header is to obviate the need for \"Cache-\n   control: s-maxage=0\" within
      a metering subtree.  Thus, any proxy may\n   negotiate the use of hit-metering
      and/or usage-limiting with the\n   next-hop server.  If this server is the origin
      server, or is already\n   part of a metering subtree (rooted at the origin server),
      then it may\n   complete the negotiation, thereby extending the metering subtree
      to\n   include the new proxy.\n   To start the negotiation, a proxy sends its
      request with one of the\n   following Meter directives:\n   will-report-and-limit\n
      \                  indicates that the proxy is willing and able to\n                   return
      usage reports and will obey any usage-limits.\n   wont-report     indicates
      that the proxy will obey usage-limits but\n                   will not send
      usage reports.\n   wont-limit      indicates that the proxy will not obey usage-limits\n
      \                  but will send usage reports.\n   A proxy willing to neither
      obey usage-limits nor send usage reports\n   MUST NOT transmit a Meter header
      in the request.\n   By definition, an empty Meter header:\n       Meter:\n   is
      equivalent to \"Meter: will-report-and-limit\", and so, by the\n   definition
      of the Connection header (see section 14.10 of the\n   HTTP/1.1 specification
      [4]), a request that contains\n       Connection: Meter\n   and no explicit
      Meter header is equivalent to a request that contains\n       Connection: Meter\n
      \      Meter: will-report-and-limit\n   This makes the default case more efficient.\n
      \  An origin server that is not interested in metering or usage-limiting\n   the
      requested resource simply ignores the Meter header.\n   If the server wants
      the proxy to do hit-metering and/or usage-\n   limiting, its response should
      include one or more of the following\n   Meter directives:\n   For hit-metering:\n
      \  do-report       specifies that the proxy MUST send usage reports to\n                   the
      server.\n   dont-report     specifies that the proxy SHOULD NOT send usage\n
      \                  reports to the server.\n   timeout=NNN     sets a metering
      timeout of NNN minutes, from the time\n                   that this response
      was originated, for the reporting\n                   of a hit-count.  If the
      proxy has a non-zero hit\n                   count for this response when the
      timeout expires, it\n                   MUST send a report to the server at
      or before that\n                   time.  Implies \"do-report\".\n   By definition,
      an empty Meter header in a response, or any Meter\n   header that does not contain
      \"dont-report\", means \"Meter: do-report\";\n   this makes a common case more
      efficient.\n      Note: an origin server using the metering timeout mechanism
      to\n      bound the collection period over which hit-counts are obtained\n      should
      adjust the timeout values in the responses it sends so that\n      all responses
      generated within that period reach their metering\n      timeouts at or before
      the end of that period.\n      If the origin server simply sends a constant
      metering timeout T\n      with each response for a resource, the reports that
      it receives\n      will reflect activity over a period whose duration is between
      T\n      and N*T (in the worst case), where N is the maximum depth of the\n
      \     metering subtree.\n   For usage-limiting\n   max-uses=NNN    sets an upper
      limit of NNN \"uses\" of the response,\n                   not counting its
      immediate forwarding to the\n                   requesting end-client, for all
      proxies in the\n                   following subtree taken together.\n   max-reuses=NNN
      \ sets an upper limit of NNN \"reuses\" of the response\n                   for
      all proxies in the following subtree taken\n                   together.\n   When
      a proxy has exhausted its allocation of \"uses\" or \"reuses\" for a\n   cache
      entry, it MUST revalidate the cache entry (using a conditional\n   request)
      before returning it in a response.  (The proxy SHOULD use\n   this revalidation
      message to send a usage report, if one was\n   requested and it is time to send
      it.  See sections 3.4 and 3.5.)\n   These Meter response-directives apply only
      to the specific response\n   that they are attached to.\n      Note that the
      limit on \"uses\" set by the max-uses directive does\n      not include the
      use of the response to satisfy the end-client\n      request that caused the
      proxy's request to the server.  This\n      counting rule supports the notion
      of a cache-initiated prefetch: a\n      cache may issue a prefetch request,
      receive a max-uses=0 response,\n      store that response, and then return that
      response (without\n      revalidation) when a client makes an actual request
      for the\n      resource.  However, each such response may be used at most once
      in\n      this way, so the origin server maintains precise control over the\n
      \     number of actual uses.\n   A server MUST NOT send a Meter header that
      would require a proxy to\n   do something that it has not yet offered to do.
      \ A proxy receiving a\n   Meter response-directive asking the proxy to do something
      it did not\n   volunteer to do SHOULD ignore that directive.\n   A proxy receiving
      a Meter header in a response MUST either obey it,\n   or it MUST revalidate
      the corresponding cache entry on every access.\n   (I.e., if it chooses not
      to obey the Meter header in a response, it\n   MUST act as if the response included
      \"Cache-control:  s-maxage=0\".)\n      Note: a proxy that has not sent the
      Meter header in a request for\n      the given resource, and which has therefore
      not volunteered to\n      honor Meter directives in a response, is not required
      to honor\n      them.  If, in this situation, the server does send a Meter header\n
      \     in a response, this is a protocol error.  However, based on the\n      robustness
      principle, the proxy may choose to interpret the Meter\n      header as an implicit
      request to include \"Cache-control: s-\n      maxage=0\" when it forwards the
      response, since this preserves the\n      apparent intention of the server.\n
      \  A proxy that receives the Meter header in a request may ignore it\n   only
      to the extent that this is consistent with its own duty to the\n   next-hop
      server.  If the received Meter request header is\n   inconsistent with that
      duty, or if no Meter request header is\n   received and the response from the
      next-hop server requests any form\n   of metering or limiting, then the proxy
      MUST add \"Cache-control: s-\n   maxage=0\" to any response it forwards for
      that request.  (A proxy\n   SHOULD NOT add or change the Expires header or max-age
      Cache-control\n   directive.)\n      For example, if proxy A receives a GET
      request from proxy B for\n      URL X with \"Connection: Meter\", but proxy
      A's cached response for\n      URL does not include any Meter directives, then
      proxy A may ignore\n      the metering offer from proxy B.\n      However, if
      proxy A has previously told the origin server \"Meter:\n      wont-limit\" (implying
      will-report), and the cached response\n      contains \"Meter: do-report\",
      and proxy B's request includes\n      \"Meter:  wont-report\", then proxy B's
      offer is inconsistent with\n      proxy A's duty to the origin server.  Therefore,
      in this case\n      proxy A must add \"Cache-control: s-maxage=0\" when it returns
      the\n      cached response to proxy B, and must not include a Meter header in\n
      \     this response.\n   If a server does not want to use the Meter mechanism,
      and will not\n   want to use it any time soon, it may send this directive:\n
      \  wont-ask        recommends that the proxy SHOULD NOT send any Meter\n                   directives
      to this server.\n   The proxy SHOULD remember this fact for up to 24 hours.
      \ This avoids\n   virtually all unnecessary overheads for servers that do not
      wish to\n   use or support the Meter header.  (This directive also implies\n
      \  \"dont-report\".)\n"
    title: 3.3 Negotiation of hit-metering and usage-limiting
  - contents:
    - "3.4 Transmission of usage reports\n   To transmit a usage report, a proxy sends
      the following Meter header\n   in a request on the appropriate resource:\n       Meter:
      count=NNN/MMM\n   The first integer indicates the count of uses of the cache
      entry\n   since the last report; the second integer indicates the count of\n
      \  reuses of the entry (see section 5.3 for rules on counting uses and\n   reuses).
      \ The transmission of a \"count\" directive in a request with\n   no other Meter
      directive is also defined as an implicit transmission\n   of a \"will-report-and-limit\"
      directive, to optimize the common case.\n   (A proxy not willing to honor usage-limits
      would send \"Meter:\n   count=NNN/MMM, wont-limit\" for its reports.)\n   Note
      that when a proxy forwards a client's request and receives a\n   response, the
      response that the proxy sends immediately to the\n   requesting client is not
      counted as a \"use\".  I.e., the reported\n   count is the number of times the
      cache entry was used, and not the\n   number of times that the response was
      used.\n   A proxy SHOULD NOT transmit \"Meter: count=0/0\", since this conveys
      no\n   useful information.\n   Usage reports MUST always be transmitted as part
      of a conditional\n   request (such as a GET or HEAD), since the information
      in the\n   conditional header (e.g., If-Modified-Since or If-None-Match) is\n
      \  required for the origin server to know which instance of a resource\n   is
      being counted.  Proxys forwarding usage reports up the metering\n   subtree
      MUST NOT change the contents of the conditional header, since\n   otherwise
      this would result in incorrect counting.\n   A usage report MUST NOT be transmitted
      as part of a forwarded request\n   that includes multiple entity tags in an
      If-None-Match or If-Match\n   header.\n      Note: a proxy that offers its willingness
      to do hit-metering\n      (report usage) must count both uses and reuses.  It
      is not\n      possible to negotiate the reporting of one but not the other.\n"
    title: 3.4 Transmission of usage reports
  - contents:
    - "3.5 When to send usage reports\n   A proxy that has offered to send usage reports
      to its parent in the\n   metering subtree MUST send a usage report in each of
      these\n   situations:\n      1. When it forwards a conditional GET on the resource\n
      \        instance on behalf of one of its clients (if the GET is\n         conditional
      on at most one entity-tag).\n      2. When it forwards a conditional HEAD on
      the resource\n         instance on behalf of one of its clients.\n      3. When
      it must generate a conditional GET to satisfy a\n         client request because
      the max-uses limit has been\n         exceeded.\n      4. Upon expiration of
      a metering timeout associated with a\n         cache entry that has a non-zero
      hit-count.\n      5. When it removes the corresponding non-zero hit-count entry\n
      \        from its storage for any reason including:\n            - the proxy
      needs the storage space for another\n              hit-count entry.\n            -
      the proxy is not able to store more than one response\n              per resource,
      and a request forwarded on behalf of a\n              client has resulted in
      the receipt of a new response\n              (one with a different entity-tag
      or last-modified\n              time).\n         Note that a cache might continue
      to store hit-count information\n         even after having deleted the body
      of the response, so it is\n         not necessary to report the hit-count when
      deleting the body;\n         it is only necessary to report it if the proxy
      is about to\n         \"forget\" a non-zero value.\n   (Section 5.3 explains
      how hit-counts become zero or non-zero.)\n   If the usage report is being sent
      because the proxy is about to\n   remove the hit-count entry from its storage,
      or because of an expired\n   metering timeout:\n      - The proxy MUST send
      the report as part of a conditional\n        HEAD request on the resource instance.\n
      \     - The proxy is not required to retry the HEAD request if it\n        fails
      (this is a best-efforts design).  To improve\n        accuracy, however, the
      proxy SHOULD retry failed HEAD\n        requests, subject to resource constraints.\n
      \     - The proxy is not required to serialize any other operation\n        on
      the completion of this request.\n      Note: proxy implementors are strongly
      encouraged to batch several\n      HEAD-based reports to the same server, when
      possible, over a\n      single persistent connection, to reduce network overhead
      as much\n      as possible.  This may involve a non-naive algorithm for\n      scheduling
      the deletion of hit-count entries.\n   If the usage count is sent because of
      an arriving request that also\n   carries a \"count\" directive, the proxy MUST
      combine its own (possibly\n   zero) use and reuse counts with the arriving counts,
      and then attempt\n   to forward the request.\n   However, the proxy is not required
      to forward an arriving request\n   with a \"count\" directive, provided that:\n
      \     - it can reply to the request using a cached response, in\n        compliance
      with other requirements of the HTTP\n        specification.\n      - such a
      response does not exceed a max-uses limit.\n      - it is not required to forward
      the request because of an\n        expired metering timeout.\n   If an arriving
      request carries a \"count\" directive, and the proxy no\n   longer has a cache
      entry for the resource, the proxy MUST forward the\n   \"count\" directive.
      \ (This is, in any case, what a proxy without a\n   suitable cache entry would
      normally do for any valid request it\n   receives.)\n"
    title: 3.5 When to send usage reports
  - contents:
    - "3.6 Subdivision of usage-limits\n   When an origin server specifies a usage
      limit, a proxy in the\n   metering subtree may subdivide this limit among its
      children in the\n   subtree as it sees fit.\n   For example, consider the situation
      with two proxies P1 and P2, each\n   of which uses proxy P3 as a way to reach
      origin server S. Imagine\n   that S sends P3 a response with\n       Meter:
      max-uses=10\n   The proxies use that response to satisfy the current requesting
      end-\n   client.  The max-uses directive in this example allows the\n   combination
      of P1, P2, and P3 together to satisfy 10 additional end-\n   client uses (unconditional
      GETs) for the resource.\n   This specification does not constrain how P3 divides
      up that\n   allocation among itself and the other proxies.  For example, P3
      could\n   retain all of max-use allocation for itself.  In that case, it would\n
      \  forward the response to P1 and/or P2 with\n       Meter: max-uses=0\n   P3
      might also divide the allocation equally among P1 and P2,\n   retaining none
      for itself (which may be the right choice if P3 has\n   few or no other clients).
      \ In this case, it could send\n       Meter: max-uses=5\n   to the proxy (P1
      or P2) that made the initial request, and then\n   record in some internal data
      structure that it \"owes\" the other proxy\n   the rest of the allocation.\n
      \  Note that this freedom to choose the max-uses value applies to the\n   origin
      server, as well.  There is no requirement that an origin\n   server send the
      same max-uses value to all caches.  For example, it\n   might make sense to
      send \"max-uses=2\" the first time one hears from a\n   cache, and then double
      the value (up to some maximum limit) each time\n   one gets a \"use-count\"
      from that cache.  The idea is that the faster\n   a cache is using up its max-use
      quota, the more likely it will be to\n   report a use-count value before removing
      the cache entry.  Also, high\n   and frequent use-counts imply a corresponding
      high efficiency benefit\n   from allowing caching.\n   Again, the details of
      such heuristics would be outside the scope of\n   this specification.\n"
    title: 3.6 Subdivision of usage-limits
  title: 3 Design concepts
- contents:
  - "4 Analysis\n   This section includes informal analyses of several aspects of
    hit-\n   metering:\n      1. the accuracy of results when applied to counting
    users\n         (section 4.1).\n      2. the problem of counting users whose browsers
    do not\n         include caches, such as Network Computers (section 4.2).\n      3.
    delays imposed on \"critical paths\" for HTTP operations\n         (section 4.3).\n"
  - contents:
    - "4.1 Approximation accuracy for counting users\n   For many (but not all) service
      operators, the single most important\n   aspect of the request stream is the
      number of distinct users who have\n   retrieved a particular entity within a
      given period (e.g., during a\n   given day).  The hit-metering mechanism is
      designed to provide an\n   origin server with an approximation of the number
      of users that\n   reference a given resource.  The intent of the design is that
      the\n   precision of this approximation is consistent with the goals of\n   simplicity
      and optional implementation.\n   Almost all Web users use client software that
      maintains local caches,\n   and the state of the art of local-caching technology
      is quite\n   effective.  (Section 4.2 discusses the case where end-client caches\n
      \  are small or non-existent.)  Therefore, assuming an effective and\n   persistent
      end-client cache, each individual user who retrieves an\n   entity does exactly
      one GET request that results in a 200 or 203\n   response, or a 206 response
      that includes the first byte of the\n   entity. If a proxy cache maintains and
      reports an accurate use-count\n   of such retrievals, then its reported use-count
      will closely\n   approximate the number of distinct users who have retrieved
      the\n   entity.\n   There are some circumstances under which this approximation
      can break\n   down.  For example, if an entity stays in a proxy cache for much\n
      \  longer than it persists in the typical client cache, and users often\n   re-reference
      the entity, then this scheme will tend to over-count the\n   number of users.
      Or, if the cache-management policy implemented in\n   typical client caches
      is biased against retaining certain kinds of\n   frequently re-referenced entities
      (such as very large images), the\n   use-counts reported will tend to overestimate
      the user-counts for\n   such entities.\n   Browser log analysis has shown that
      when a user revisits a resource,\n   this is almost always done very soon after
      the previous visit, almost\n   always with fewer than eight intervening references
      [11].  Although\n   this result might not apply universally, it implies that
      almost all\n   reuses will hit in the end-client cache, and will not be seen
      as\n   unconditional GETs by a proxy cache.\n   The existing (HTTP/1.0) \"cache-busting\"
      mechanisms for counting\n   distinct users will certainly overestimate the number
      of users behind\n   a proxy, since it provides no reliable way to distinguish
      between a\n   user's initial request and subsequent repeat requests that might
      have\n   been conditional GETs, had not cache-busting been employed.  The\n
      \  \"Cache-control: s-maxage=0\" feature of HTTP/1.1 does allow the\n   separation
      of use-counts and reuse-counts, provided that no HTTP/1.0\n   proxy caches intervene.\n
      \  Note that if there is doubt about the validity of the results of\n   hit-metering
      a given set of resources, the server can employ cache-\n   busting techniques
      for short periods, to establish a baseline for\n   validating the hit-metering
      results.  Various approaches to this\n   problem are discussed in a paper by
      James Pitkow [9].\n"
    title: 4.1 Approximation accuracy for counting users
  - contents:
    - "4.2 What about \"Network Computers\"?\n   The analysis in section 4.1 assumed
      that \"almost all Web users\" have\n   client caches.  If the Network Computers
      (NC) model becomes popular,\n   however, then this assumption may be faulty:
      most proposed NCs have\n   no disk storage, and relatively little RAM.  Many
      Personal Digital\n   Assistants (PDAs), which sometimes have network access,
      have similar\n   constraints.  Such client systems may do little or no caching
      of HTTP\n   responses.  This means that a single user might well generate many\n
      \  unconditional GETs that yield the same response from a proxy cache.\n   First
      note that the hit-metering design in this document, even with\n   such clients,
      provides an approximation no worse than available with\n   unmodified HTTP/1.1:
      the counts that a proxy would return to an\n   origin server would represent
      exactly the number of requests that the\n   proxy would forward to the server,
      if the server simply specifies\n   \"Cache-control:  s-maxage=0\".\n   However,
      it may be possible to improve the accuracy of these hit-\n   counts by use of
      some heuristics at the proxy.  For example, the\n   proxy might note the IP
      address of the client, and count only one GET\n   per client address per response.
      \ This is not perfect: for example,\n   it fails to distinguish between NCs
      and certain other kinds of hosts.\n   The proxy might also use the heuristic
      that only those clients that\n   never send a conditional GET should be treated
      this way, although we\n   are not at all certain that NCs will never send conditional
      GETs.\n   Since the solution to this problem appears to require heuristics\n
      \  based on the actual behavior of NCs (or perhaps a new HTTP protocol\n   feature
      that allows unambiguous detection of cacheless clients), it\n   appears to be
      premature to specify a solution.\n"
    title: 4.2 What about "Network Computers"?
  - contents:
    - "4.3 Critical-path delay analysis\n   In systems (such as the Web) where latency
      is at issue, there is\n   usually a tree of steps which depend on one another,
      in such a way\n   that the final result cannot be accomplished until all of
      its\n   predecessors have been.  Since the tree structure admits some\n   parallelism,
      it is not necessary to add up the timings for each step\n   to discover the
      latency for the entire process.  But any single path\n   through this dependency
      tree cannot be parallelized, and the longest\n   such path is the one whose
      length (in units of seconds) determines\n   the overall latency.  This is the
      \"critical path\", because no matter\n   how much shorter one makes any other
      path, that cannot change the\n   overall latency for the final result.\n   If
      one views the final result, for a Web request, as rendering a page\n   at a
      browser, or otherwise acting on the result of a request, clearly\n   some network
      round trips (e.g., exchanging TCP SYN packets if the\n   connection doesn't
      already exist) are on the critical path.  This\n   hit-metering design does
      add some round-trips for reporting non-zero\n   counts when a cache entry is
      removed, but, by design, these are off\n   any critical path:  they may be done
      in parallel with any other\n   operation, and require only \"best efforts\",
      so a proxy does not have\n   to serialize other operations with their success
      or failure.\n   Clearly, anything that changes network utilization (either increasing\n
      \  or decreasing it) can indirectly affect user-perceived latency.  Our\n   expectation
      is that hit-metering, on average, will reduce loading and\n   so even its indirect
      effects should not add network round-trips in\n   any critical path.  But there
      might be a few specific instances where\n   the added non-critical-path operations
      (specifically, usage reports\n   upon cache-entry removal) delay an operation
      on a critical path.\n   This is an unavoidable problem in datagram networks.\n"
    title: 4.3 Critical-path delay analysis
  title: 4 Analysis
- contents:
  - '5 Specification

    '
  - contents:
    - "5.1 Specification of Meter header and directives\n   The Meter general-header
      field is used to:\n      - Negotiate the use of hit-metering and usage-limiting
      among\n        origin servers and proxy caches.\n      - Report use counts and
      reuse counts.\n   Implementation of the Meter header is optional for both proxies
      and\n   origin servers.  However, any proxy that transmits the Meter header\n
      \  in a request MUST implement every requirement of this specification,\n   without
      exception or amendment.\n   The Meter header MUST always be protected by a Connection
      header.  A\n   proxy that does not implement the Meter header MUST NOT pass
      it\n   through to another system (see section 5.5 for how a non-caching\n   proxy
      may comply with this specification).  If a Meter header is\n   received in a
      message whose version is less than HTTP/1.1, it MUST be\n   ignored (because
      it has clearly flowed through a proxy that does not\n   implement Meter).\n
      \  A proxy that has received a response with a version less than\n   HTTP/1.1,
      and therefore from a server (or another proxy) that does\n   not implement the
      Meter header, SHOULD NOT send Meter request\n   directives to that server, because
      these would simply waste\n   bandwidth.  This recommendation does not apply
      if the proxy is\n   currently hit-metering or usage-limiting any responses from
      that\n   server.  If the proxy receives a HTTP/1.1 or higher response from\n
      \  such a server, it should cease its suppression of the Meter\n   directives.\n
      \  All proxies sending the Meter header MUST adhere to the \"metering\n   subtree\"
      design described in section 3.\n       Meter = \"Meter\" \":\" 0#meter-directive\n
      \      meter-directive = meter-request-directive\n                       | meter-response-directive\n
      \                      | meter-report-directive\n       meter-request-directive
      =\n                         \"will-report-and-limit\"\n                       |
      \"wont-report\"\n                       | \"wont-limit\"\n       meter-report-directive
      =\n                       | \"count\" \"=\" 1*DIGIT \"/\" 1*DIGIT\n       meter-response-directive
      =\n                         \"max-uses\" \"=\" 1*DIGIT\n                       |
      \"max-reuses\" \"=\" 1*DIGIT\n                       | \"do-report\"\n                       |
      \"dont-report\"\n                       | \"timeout\" \"=\" 1*DIGIT\n                       |
      \"wont-ask\"\n   A meter-request-directive or meter-report-directive may only
      appear\n   in an HTTP request message.  A meter-response-directive may only\n
      \  appear in an HTTP response directive.\n   An empty Meter header in a request
      means \"Meter: will-report-and-\n   limit\".  An empty Meter header in a response,
      or any other response\n   including one or more Meter headers without the \"dont-report\"
      or\n   \"wont-ask\" directive, implies \"Meter:  do-report\".\n   The meaning
      of the meter-request-directives are as follows:\n   will-report-and-limit\n
      \                  indicates that the proxy is willing and able to\n                   return
      usage reports and will obey any usage-limits.\n   wont-report     indicates
      that the proxy will obey usage-limits but\n                   will not send
      usage reports.\n   wont-limit      indicates that the proxy will not obey usage-limits\n
      \                  but will send usage reports.\n   A proxy willing neither
      to obey usage-limits nor to send usage\n   reports MUST NOT transmit a Meter
      header in the request.\n   The meaning of the meter-report-directives are as
      follows:\n   count \"=\" 1*DIGIT \"/\" 1*DIGIT\n                   Both digit
      strings encode decimal integers.  The\n                   first integer indicates
      the count of uses of the\n                   cache entry since the last report;
      the second integer\n                   indicates the count of reuses of the
      entry.\n   Section 5.3 specifies the counting rules.\n   The meaning of the
      meter-response-directives are as follows:\n   max-uses \"=\" 1*DIGIT\n                   sets
      an upper limit on the number of \"uses\" of the\n                   response,
      not counting its immediate forwarding to\n                   the requesting
      end-client, for all proxies in the\n                   following subtree taken
      together.\n   max-reuses \"=\" 1*DIGIT\n                   sets an upper limit
      on the number of \"reuses\" of the\n                   response for all proxies
      in the following subtree\n                   taken together.\n   do-report       specifies
      that the proxy MUST send usage reports to\n                   the server.\n
      \  dont-report     specifies that the proxy SHOULD NOT send usage\n                   reports
      to the server.\n   timeout \"=\" 1*DIGIT\n                   sets a metering
      timeout of the specified number of\n                   minutes (not seconds)
      after the origination of this\n                   response (as indicated by
      its \"Date\" header).  If the\n                   proxy has a non-zero hit count
      for this response when\n                   the timeout expires, it MUST send
      a report to the\n                   server at or before that time.  Timeouts
      should be\n                   implemented with an accuracy of plus or minus
      one\n                   minute.  Implies \"do-report\".\n   wont-ask        specifies
      that the proxy SHOULD NOT send any Meter\n                   headers to the
      server.  The proxy should forget this\n                   advice after a period
      of no more than 24 hours.\n   Section 5.3 specifies the counting rules, and
      in particular specifies\n   a somewhat non-obvious interpretation of the max-uses
      value.\n"
    title: 5.1 Specification of Meter header and directives
  - contents:
    - "5.2 Abbreviations for Meter directives\n   To allow for the most efficient
      possible encoding of Meter headers,\n   we define abbreviated forms of all Meter
      directives.  These are\n   exactly semantically equivalent to their non-abbreviated\n
      \  counterparts.  All systems implementing the Meter header MUST\n   implement
      both the abbreviated and non-abbreviated forms.\n   Implementations SHOULD use
      the abbreviated forms in normal use.\n   The abbreviated forms of Meter directive
      are shown below, with the\n   corresponding non-abbreviated literals in the
      comments:\n       Abb-Meter = \"Meter\" \":\" 0#abb-meter-directive\n       abb-meter-directive
      = abb-meter-request-directive\n                       | abb-meter-response-directive\n
      \                      | abb-meter-report-directive\n       abb-meter-request-directive
      =\n                         \"w\"           ; \"will-report-and-limit\"\n                       |
      \"x\"           ; \"wont-report\"\n                       | \"y\"           ;
      \"wont-limit\"\n       abb-meter-report-directive =\n                       |
      \"c\" \"=\" 1*DIGIT \"/\" 1*DIGIT   ; \"count\"\n       abb-meter-response-directive
      =\n                         \"u\" \"=\" 1*DIGIT       ; \"max-uses\"\n                       |
      \"r\" \"=\" 1*DIGIT       ; \"max-reuses\"\n                       | \"d\"                   ;
      \"do-report\"\n                       | \"e\"                   ; \"dont-report\"\n
      \                      | \"t\" \"=\" 1*DIGIT       ; \"timeout\"\n                       |
      \"n\"                   ; \"wont-ask\"\n      Note: although the Abb-Meter BNF
      rule is defined separately from\n      the Meter rule, one may freely mix abbreviated
      and non-abbreviated\n      Meter directives in the same header.\n"
    title: 5.2 Abbreviations for Meter directives
  - contents:
    - "5.3 Counting rules\n      Note: please remember that hit-counts and usage-counts
      are\n      associated with individual responses, not with resources.  A cache\n
      \     entry that, over its lifetime, holds more than one response is\n      also
      not a \"response\", in this particular sense.\n   Let R be a cached response,
      and V be the value of the Request-URI and\n   selecting request-headers (if
      any, see section 14.43 of the HTTP/1.1\n   specification [4]) that would select
      R if contained in a request.  We\n   define a \"use\" of R as occurring when
      the proxy returns its stored\n   copy of R in a response with any of the following
      status codes: a 200\n   (OK) status; a 203 (Non-Authoritative Information) status;
      or a 206\n   (Partial Content) status when the response contains byte #0 of
      the\n   entity (see section 5.4 for a discussion of Range requests).\n      Note:
      when a proxy forwards a client's request and receives a\n      response, the
      response that the proxy sends immediately to the\n      requesting client is
      not counted as a \"use\".  I.e., the reported\n      count is the number of
      times the cache entry was used, and not the\n      number of times that the
      response was used.\n   We define a \"reuse\" of R as as occurring when the proxy
      responds to a\n   request selecting R with a 304 (Not Modified) status, unless
      that\n   request is a Range request that does not specify byte #0 of the\n   entity.\n"
    - contents:
      - "5.3.1 Counting rules for hit-metering\n   A proxy participating in hit-metering
        for a cache response R\n   maintains two counters, CU and CR, associated with
        R. When a proxy\n   first stores R in its cache, it sets both CU and CR to
        0 (zero).\n   When a subsequent client request results in a \"use\" of R,
        the proxy\n   increments CU.  When a subsequent client request results in
        a \"reuse\"\n   of R, the proxy increments CR.  When a subsequent client request\n
        \  selecting R (i.e., including V) includes a \"count\" Meter directive,\n
        \  the proxy increments CU and CR using the corresponding values in the\n
        \  directive.\n   When the proxy sends a request selecting R (i.e., including
        V) to the\n   inbound server, it includes a \"count\" Meter directive with
        the\n   current CU and CR as the parameter values.  If this request was\n
        \  caused by the proxy's receipt of a request from a client, upon\n   receipt
        of the server's response, the proxy sets CU and CR to the\n   number of uses
        and reuses, respectively, that may have occurred while\n   the request was
        in progress.  (These numbers are likely, but not\n   certain, to be zero.)
        \ If the proxy's request was a final HEAD-based\n   report, it need no longer
        maintain the CU and CR values, but it may\n   also set them to the number
        of intervening uses and reuses and retain\n   them.\n"
      title: 5.3.1 Counting rules for hit-metering
    - contents:
      - "5.3.2 Counting rules for usage-limiting\n   A proxy participating in usage-limiting
        for a response R maintains\n   either or both of two counters TU and TR, as
        appropriate, for that\n   resource.  TU and TR are incremented in just the
        same way as CU and\n   CR, respectively.  However, TU is zeroed only upon
        receipt of a\n   \"max-uses\" Meter directive for that response (including
        the initial\n   receipt).  Similarly, TR is zeroed only upon receipt of a
        \"max-\n   reuses\" Meter directive for that response.\n   A proxy participating
        in usage-limiting for a response R also stores\n   values MU and/or MR associated
        with R. When it receives a response\n   including only a max-uses value, it
        sets MU to that value and MR to\n   infinity.  When it receives a response
        including only a max-reuses\n   value, it sets MR to that value and MU to
        infinity.  When it receives\n   a response including both max-reuses and max-reuses
        values, it sets\n   MU and MR to those values, respectively.  When it receives
        a\n   subsequent response including neither max-reuses nor max-reuses\n   values,
        it sets both MU and MR to infinity.\n   If a proxy participating in usage-limiting
        for a response R receives\n   a request that would cause a \"use\" of R, and
        TU >= MU, it MUST\n   forward the request to the server.  If it receives a
        request that\n   would cause a \"reuse\" of R, and TR >= MR, it MUST forward
        the request\n   to the server.  If (in either case) the proxy has already
        forwarded a\n   previous request to the server and is waiting for the response,
        it\n   should delay further handling of the new request until the response\n
        \  arrives (or times out); it SHOULD NOT have two revalidation requests\n
        \  pending at once that select the same response, unless these are Range\n
        \  requests selecting different subranges.\n   There is a special case of
        this rule for the \"max-uses\" directive: if\n   the proxy receives a response
        with \"max-uses=0\" and does not forward\n   it to a requesting client, the
        proxy should set a flag PF associated\n   with R. If R is true, then when
        a request arrives while if TU >= MU,\n   if the PF flag is set, then the request
        need not be forwarded to the\n   server (provided that this is not required
        by other caching rules).\n   However, the PF flag MUST be cleared on any use
        of the response.\n      Note: the \"PF\" flag is so named because this feature
        is useful\n      only for caches that could issue a \"prefetch\" request before
        an\n      actual client request for the response.  A proxy not implementing\n
        \     prefetching need not implement the PF flag.\n"
      title: 5.3.2 Counting rules for usage-limiting
    - contents:
      - "5.3.3 Equivalent algorithms are allowed\n   Any other algorithm that exhibits
        the same external behavior (i.e.,\n   generates exactly the same requests
        from the proxy to the server) as\n   the one in this section is explicitly
        allowed.\n      Note: in most cases, TU will be equal to CU, and TR will be\n
        \     equal to CR.  The only two cases where they could differ are:\n         1.
        The proxy issues a non-conditional request for the\n            resource using
        V, while TU and/or TR are non-zero, and\n            the server's response
        includes a new \"max-uses\" and/or\n            \"max-reuses\" directive (thus
        zeroing TU and/or TR, but\n            not CU and CR).\n         2. The proxy
        issues a conditional request reporting the\n            hit-counts (and thus
        zeroing CU and CR, but not TU or\n            TR), but the server's response
        does not include a new\n            \"max-uses\" and/or \"max-reuses\" directive.\n
        \     To solve the first case, the proxy has several implementation\n      options\n
        \        - Always store TU and TR separately from CU and CR.\n         - Create
        \"shadow\" copies of TU and TR when this situation\n           arises (analogous
        to \"copy on write\").\n         - Generate a HEAD-based usage report when
        the\n           non-conditional request is sent (or when the\n           \"max-uses=0\"
        is received), causing CU and CR to be\n           zeroed (analogous in some
        ways to a \"memory barrier\"\n           instruction).\n      In the second
        case, the server implicitly has removed the\n      usage-limit(s) on the response
        (by setting MU and/or MR to\n      infinity), and so the fact that, say, TU
        is different from CU\n      is not significant.\n      Note: It may also be
        possible to eliminate the PF flag by\n      sending extra HEAD-based usage-report
        requests, but we\n      recommend against this; it is better to allocate an
        extra bit\n      per entry than to transmit extra requests.\n"
      title: 5.3.3 Equivalent algorithms are allowed
    title: 5.3 Counting rules
  - contents:
    - "5.4 Counting rules: interaction with Range requests\n   HTTP/1.1 allows a client
      to request sub-ranges of a resource.  A\n   client might end up issuing several
      requests with the net effect of\n   receiving one copy of the resource.  For
      uniformity of the results\n   seen by origin servers, proxies need to observe
      a rule for counting\n   these references, although it is not clear that one
      rule generates\n   accurate results in every case.\n   The rule established
      in this specification is that proxies count as a\n   \"use\" or \"reuse\" only
      those Range requests that result in the return\n   of byte #0 of the resource.
      \ The rationale for this rule is that in\n   almost every case, an end-client
      will retrieve the beginning of any\n   resource that it references at all, and
      that it will seldom retrieve\n   any portion more than once.  Therefore, this
      rule appears to meet the\n   goal of a \"best-efforts\" approximation.\n"
    title: '5.4 Counting rules: interaction with Range requests'
  - contents:
    - "5.5 Implementation by non-caching proxies\n   A non-caching proxy may participate
      in the metering subtree; this is\n   strongly recommended.\n   A non-caching
      proxy (HTTP/1.1 or higher) that participates in the\n   metering subtree SHOULD
      forward Meter headers on both requests and\n   responses, with the appropriate
      Connection headers.\n   If a non-caching proxy forwards Meter headers, it MUST
      comply with\n   these restrictions:\n      1. If the proxy forwards Meter headers
      in responses, such a\n         response MUST NOT be returned to any request
      except the\n         one that elicited it.\n      2. Once a non-caching proxy
      starts forwarding Meter headers,\n         it should not arbitrarily stop forwarding
      them (or else\n         reports may be lost).\n   A proxy that caches some responses
      and not others, for whatever\n   reason, may choose to implement the Meter header
      as a caching proxy\n   for the responses that it caches, and as a non-caching
      proxy for the\n   responses that it does not cache, as long as its external
      behavior\n   with respect to any particularly response is fully consistent with\n
      \  this specification.\n"
    title: 5.5 Implementation by non-caching proxies
  - contents:
    - "5.6 Implementation by cooperating caches\n   Several HTTP cache implementations,
      most notably the Harvest/Squid\n   cache [2], create cooperative arrangements
      between several caches.\n   If such caches use a protocol other than HTTP to
      communicate between\n   themselves, such as the Internet Cache Protocol (ICP)
      [12], and if\n   they implement the Meter header, then they MUST act to ensure
      that\n   their cooperation does not violate the intention of this\n   specification.\n
      \  In particular, if one member of a group of cooperating caches agrees\n   with
      a server to hit-meter a particular response, and then passes\n   this response
      via a non-HTTP protocol to a second cache in the group,\n   the caches MUST
      ensure that the server which requested the metering\n   receives reports that
      appropriately account for any uses or resues\n   made by the second cache.  Similarly,
      if the first cache agreed to\n   usage-limit the response, the total number
      of uses by the group of\n   caches MUST be limited to the agreed-upon number.\n"
    title: 5.6 Implementation by cooperating caches
  title: 5 Specification
- contents:
  - '6 Examples

    '
  - contents:
    - "6.1 Example of a complete set of exchanges\n   This example shows how the protocol
      is intended to be used most of\n   the time: for hit-metering without usage-limiting.
      \ Entity bodies are\n   omitted.\n   A client sends request to a proxy:\n       GET
      http://foo.com/bar.html HTTP/1.1\n   The proxy forwards request to the origin
      server:\n       GET /bar.html HTTP/1.1\n       Host: foo.com\n       Connection:
      Meter\n   thus offering (implicitly) \"will-report-and-limit\".\n   The server
      responds to the proxy:\n       HTTP/1.1 200 OK\n       Date: Fri, 06 Dec 1996
      18:44:29 GMT\n       Cache-control: max-age=3600\n       Connection: meter\n
      \      Etag: \"abcde\"\n   thus (implicitly) requiring \"do-report\" (but not
      requiring\n   usage-limiting).\n   The proxy responds to the client:\n       HTTP/1.1
      200 OK\n       Date: Fri, 06 Dec 1996 18:44:29 GMT\n       Etag: \"abcde\"\n
      \      Cache-control: max-age=3600, proxy-mustcheck\n       Age: 1\n   Since
      the proxy does not know if its client is an end-system, or a\n   proxy that
      doesn't do metering, it adds the \"proxy-mustcheck\"\n   directive.\n   Another
      client soon asks for the resource:\n       GET http://foo.com/bar.html HTTP/1.1\n
      \  and the proxy sends the same response as it sent to the other client,\n   except
      (perhaps) for the Age value.\n   After an hour has passed, a third client asks
      for the response:\n       GET http://foo.com/bar.html HTTP/1.1\n   But now the
      response's max-age has been exceeded, so the proxy\n   revalidates the response
      with the origin server:\n       GET /bar.html HTTP/1.1\n       If-None-Match:
      \"abcde\"\n       Host: foo.com\n       Connection: Meter\n       Meter: count=1/0\n
      \  thus simultaneously fulfilling its duties to validate the response\n   and
      to report the one \"use\" that wasn't forwarded.\n   The origin server responds:\n
      \      HTTP/1.1 304 Not Modified\n       Date: Fri, 06 Dec 1996 19:44:29 GMT\n
      \      Cache-control: max-age=3600\n       Etag: \"abcde\"\n   so the proxy
      can use the original response to reply to the new\n   client; the proxy also
      zeros the use-count it associates with that\n   response.\n   Another client
      soon asks for the resource:\n       GET http://foo.com/bar.html HTTP/1.1\n   and
      the proxy sends the appropriate response.\n   After another few hours, the proxy
      decides to remove the cache entry.\n   When it does so, it sends to the origin
      server:\n       HEAD /bar.html HTTP/1.1\n       If-None-Match: \"abcde\"\n       Host:
      foo.com\n       Connection: Meter\n       Meter: count=1/0\n   reporting that
      one more use of the response was satisfied from the\n   cache.\n"
    title: 6.1 Example of a complete set of exchanges
  - contents:
    - "6.2 Protecting against HTTP/1.0 proxies\n   An origin server that does not
      want HTTP/1.0 caches to store the\n   response at all, and is willing to have
      HTTP/1.0 end-system clients\n   generate excess GETs (which will be forwarded
      by HTTP/1.0 proxies)\n   could send this for its reply:\n       HTTP/1.1 200
      OK\n       Cache-control: max-age=3600\n       Connection: meter\n       Etag:
      \"abcde\"\n       Expires: Sun, 06 Nov 1994 08:49:37 GMT\n   HTTP/1.0 caches
      will see the ancient Expires header, but HTTP/1.1\n   caches will see the max-age
      directive and will ignore Expires.\n      Note: although most major HTTP/1.0
      proxy implementations observe\n      the Expires header, it is possible that
      some are in use that do\n      not.  Use of the Expires header to prevent caching
      by HTTP/1.0\n      proxies might not be entirely reliable.\n"
    title: 6.2 Protecting against HTTP/1.0 proxies
  - contents:
    - "6.3 More elaborate examples\n   Here is a request from a proxy that is willing
      to hit-meter but is\n   not willing to usage-limit:\n       GET /bar.html HTTP/1.1\n
      \      Host: foo.com\n       Connection: Meter\n       Meter: wont-limit\n   Here
      is a response from an origin server that does not want hit\n   counting, but
      does want \"uses\" limited to 3, and \"reuses\" limited to\n   6:\n       HTTP/1.1
      200 OK\n       Cache-control: max-age=3600\n       Connection: meter\n       Etag:
      \"abcde\"\n       Expires: Sun, 06 Nov 1994 08:49:37 GMT\n       Meter: max-uses=3,
      max-reuses=6, dont-report\n   Here is the same example with abbreviated Meter
      directive names:\n       HTTP/1.1 200 OK\n       Cache-control: max-age=3600\n
      \      Connection: meter\n       Etag: \"abcde\"\n       Expires: Sun, 06 Nov
      1994 08:49:37 GMT\n       Meter:u=3,r=6,e\n"
    title: 6.3 More elaborate examples
  title: 6 Examples
- contents:
  - "7 Interactions with content negotiation\n   This section describes two aspects
    of the interaction between hit-\n   metering and \"content-negotiated\" resources:\n
    \     1. treatment of responses carrying a Vary header (section\n         7.1).\n
    \     2. treatment of responses that use the proposed Transparent\n         Content
    Negotiation mechanism (section 7.2).\n"
  - contents:
    - "7.1 Treatment of responses carrying a Vary header\n   Separate counts should
      be kept for each combination of the headers\n   named in the Vary header for
      the Request-URI (what [4] calls \"the\n   selecting request-headers\"), even
      if they map to the same entity-tag.\n   This rule has the effect of counting
      hits on each variant, if there\n   are multiple variants of a page available.\n
      \     Note: This interaction between Vary and the hit-counting\n      directives
      allows the origin server a lot of flexibility in\n      specifying how hits
      should be counted.  In essence, the origin\n      server uses the Vary mechanism
      to divide the requests for a\n      resource into arbitrary categories, based
      on the request- headers.\n      (We will call these categories \"request-patterns\".)
      Since a proxy\n      keeps its hit-counts for each request-pattern, rather than
      for\n      each resource, the origin server can obtain separate statistics\n
      \     for many aspects of an HTTP request.\n   For example, if a page varied
      based on the value of the User-Agent\n   header in the requests, then hit counts
      would be kept for each\n   different flavor of browser. But it is in fact more
      general than\n   that; because multiple header combinations can map to the same\n
      \  variant, it also enables the origin server to count the number of\n   times
      (e.g.) the Swahili version of a page was requested, even though\n   it is only
      available in English.\n   If a proxy does not support the Vary mechanism, then
      [4] says that it\n   MUST NOT cache any response that carries a Vary header,
      and hence\n   need not implement any aspect of this hit-counting or usage-limiting\n
      \  design for varying resources.\n       Note: this also implies that if a proxy
      supports the Vary\n       mechanism but is not willing to maintain independent
      hit-counts\n       for each variant response in its cache, then it must follow
      at\n       least one of these rules:\n          1. It must not use the Meter
      header in a request to offer\n             to hit-meter or usage-limit responses.\n
      \         2. If it does offer to hit-meter or usage-limit responses,\n             and
      then receives a response that includes both a Vary\n             header and
      a Meter header with a directive that it\n             cannot satisfy, then the
      proxy must not cache the\n             response.\n       In other words, a proxy
      is allowed to partially implement the\n       Vary mechanism with respect to
      hit-metering, as long as this has\n       no externally visible effect on its
      ability to comply with the\n       Meter specification.\n   This approach works
      for counting almost any aspect of the request\n   stream, without embedding
      any specific list of countable aspects in\n   the specification or proxy implementation.\n"
    title: 7.1 Treatment of responses carrying a Vary header
  - contents:
    - "7.2 Interaction with Transparent Content Negotiation\n   [A description of
      the interaction between this design and the\n   proposed Transparent Content
      Negotiation (TCN) design [6] will be\n   made available in a later document.]\n"
    title: 7.2 Interaction with Transparent Content Negotiation
  title: 7 Interactions with content negotiation
- contents:
  - "8 A Note on Capturing Referrals\n   It is alleged that some advertisers want
    to pay content providers,\n   not by the \"hit\", but by the \"nibble\" -- the
    number of people who\n   actually click on the ad to get more information.\n   Now,
    HTTP already has a mechanism for doing this: the \"Referer\"\n   header. However,
    perhaps it ought to be disabled for privacy reasons\n   -- according the HTTP/1.1
    spec:\n       \"Because the source of the link may be private information or may\n
    \      reveal an otherwise private information source, it is strongly\n       recommended
    that the user be able to select whether or not the\n       Referer field is sent.\"\n
    \  However, in the case of ads, the source of the link actually wants to\n   let
    the referred-to page know where the reference came from.\n   This does not require
    the addition of any extra mechanism, but rather\n   can use schemes that embed
    the referrer in the URI in a manner\n   similar to this:\n          http://www.blah.com/ad-reference?from=site1\n
    \  Such a URI should point to a resource (perhaps a CGI script) which\n   returns
    a 302 redirect to the real page\n          http://www.blah.com/ad-reference.html\n
    \  Proxies which do not cache 302s will cause one hit on the redirection\n   page
    per use, but the real page will get cached. Proxies which do\n   cache 302s and
    report hits on the cached 302s will behave optimally.\n   This approach has the
    advantage that it works whether or not the\n   end-client has disabled the use
    of Referer.  Combined with the rest\n   of the hit-metering proposal in this design,
    this approach allows,\n   for example, an advertiser to know how often a reference
    to an\n   advertisement was made from a particular page.\n"
  title: 8 A Note on Capturing Referrals
- contents:
  - "9 Alternative proposals\n   There might be a number of other ways of gathering
    demographic and\n   usage information; other mechanisms might respond to a different
    set\n   of needs than this proposal does.  This proposal certainly does not\n
    \  preclude the proposal or deployment of other such mechanisms, and\n   many
    of them may be complementary to and compatible with the\n   mechanism proposed
    here.\n   There has been some speculation that statistical sampling methods\n
    \  might be used to gather reasonably accurate data.  One such proposal\n   is
    to manipulate cache expiration times so that selected resources\n   are uncachable
    for carefully chosen periods, allowing servers to\n   accurately count accesses
    during those periods.  The hit-metering\n   mechanism proposed here is entirely
    complementary to that approach,\n   since it could be used to reduce the cost
    of gathering those counts.\n   James Pitkow has written a paper comparing an earlier
    draft of this\n   hit-metering proposal with sampling approaches [9].\n   Phillip
    Hallam-Baker has proposed using a log-exchange protocol [5],\n   by which a server
    could request a proxy's logs by making an HTTP\n   request to the proxy.  This
    proposal asserts that it is \"believed to\n   operate correctly in configurations
    involving multiple proxies\", but\n   it is not clear that this is true if an
    outer proxy is used as a\n   (one-way) firewall.  The proposal also leaves a number
    of open\n   issues, such as how an origin server can be sure that all of the\n
    \  proxies in the request subtree actually support log-exchange.  It is\n   also
    not clear how this proposal couples a proxy's support of log-\n   exchange to
    a server's permission to cache a response.\n   For general background on the topic
    of Web measurement standards, see\n   the discussion by Thomas P. Novak and Donna
    L. Hoffman [8].  Also see\n   the \"Privacy and Demographics Overview\" page maintained
    by by the\n   World Wide Web Consortium [10], which includes a pointer to some\n
    \  tentative proposals for gathering consumer demographics (not just\n   counting
    references) [3].\n"
  title: 9 Alternative proposals
- contents:
  - "10 Security Considerations\n   Which outbound clients should a server (proxy
    or origin) trust to\n   report hit counts?  A malicious proxy could easily report
    a large\n   number of hits on some page, and thus perhaps cause a large payment\n
    \  to a content provider from an advertiser.  To help avoid this\n   possibility,
    a proxy may choose to only relay usage counts received\n   from its outbound proxies
    to its inbound servers when the proxies\n   have authenticated themselves using
    Proxy-Authorization and/or they\n   are on a list of approved proxies.\n   It
    is not possible to enforce usage limits if a proxy is willing to\n   cheat (i.e.,
    it offers to limit usage but then ignores a server's\n   Meter directive).\n   Regarding
    privacy:  it appears that the design in this document does\n   not reveal any
    more information about individual users than would\n   already be revealed by
    implementation of the existing HTTP/1.1\n   support for \"Cache-control: max-age=0,
    proxy-revalidate\" or \"Cache-\n   control: s-maxage=0\".  It may, in fact, help
    to conceal certain\n   aspects of the organizational structure on the outbound
    side of a\n   proxy.  In any case, the conflict between user requirements for\n
    \  anonymity and origin server requirements for demographic information\n   cannot
    be resolved by purely technical means.\n"
  title: 10 Security Considerations
- contents:
  - "11 Acknowledgments\n   We gratefully acknowledge the constructive comments received
    from\n   Anselm Baird-Smith, Ted Hardie, Koen Holtman (who suggested the\n   technique
    described in section 8), Dave Kristol, Ari Luotonen,\n   Patrick R. McManus, Ingrid
    Melve, and James Pitkow.\n"
  title: 11 Acknowledgments
- contents:
  - "12 References\n   1.  Bradner, S.,  \"Key words for use in RFCs to Indicate Requirement\n
    \      Levels\", BCP 14, RFC 2119, March 1997.\n   2.  Anwat Chankhunthod, Peter
    B. Danzig, Chuck Neerdaels, Michael\n       F. Schwartz, and Kurt J. Worrell.
    \ A Hierarchical Internet Object\n       Cache.  Proc. 1996 USENIX Technical Conf.,
    San Diego, January,\n       1996, pp. 153-163.\n   3.  Daniel W. Connolly.  Proposals
    for Gathering Consumer\n       Demographics.\n       http://www.w3.org/pub/WWW/Demographics/Proposals.html.\n
    \  4.  Fielding, R., Gettys, J., Mogul, J., Nielsen, H. and T.\n       Berners-Lee,
    \"Hypertext Transfer Protocol -- HTTP/1.1,\" RFC 2068,\n       January, 1997.\n
    \  5.  Phillip M. Hallam-Baker.  Notification for Proxy Caches.  W3C\n       Working
    Draft WD-proxy-960221, World Wide Web Consortium,\n       February, 1996. http://www.w3.org/pub/WWW/TR/WD-proxy.html.\n
    \  6.  Holtman, K., and A. Mutz, \"Transparent Content Negotiation in\n       HTTP\",
    Work in Progress.\n   7.  Mogul, J., \"Forcing HTTP/1.1 proxies to revalidate
    responses\",\n       Work in Progress.\n   8.  Thomas P. Novak and Donna L. Hoffman.
    \ New Metrics for New Media:\n       Toward the Development of Web Measurement
    Standards.  This is a\n       draft paper, currently available at http://\n       www2000.ogsm.vanderbilt.edu/novak/web.standards/webstand.html.\n
    \      Cited by permission of the author; do not quote or cite without\n       permission.\n
    \  9.  James Pitkow.  In search of reliable usage data on the WWW.\n       Proc.
    Sixth International World Wide Web Conference, Santa Clara,\n       CA, April,
    1997.\n   10. Joseph Reagle, Rohit Khare, Dan Connolly, and Tim Berners-Lee.\n
    \      Privacy and Demographics Overview.\n       http://www.w3.org/pub/WWW/Demographics/.\n
    \  11. Linda Tauscher and Saul Greenberg.  Revisitation Patterns in\n       World
    Wide Web Navigation.  Research Report 96/587/07, Department\n       of Computer
    Science, University of Calgary, March, 1996.\n       http://www.cpsc.ucalgary.ca/projects/grouplab/\n
    \      papers/96WebReuse/TechReport96.html.\n   12. Wessels, D., and K. Claffy
    \"Internet Cache Protocol (ICP),\n       version 2\", RFC 2186, September 1997.\n"
  title: 12 References
- contents:
  - "13 Authors' Addresses\n   Jeffrey C. Mogul\n   Western Research Laboratory\n
    \  Digital Equipment Corporation\n   250 University Avenue\n   Palo Alto, California,
    94305, U.S.A.\n   EMail: mogul@wrl.dec.com\n   Phone: 1 415 617 3304 (email preferred)\n
    \  Paul J. Leach\n   Microsoft\n   1 Microsoft Way\n   Redmond, Washington, 98052,
    U.S.A.\n   EMail: paulle@microsoft.com\n"
  title: 13 Authors' Addresses
- contents:
  - "14 Full Copyright Statement\n   Copyright (C) The Internet Society (1997).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implmentation may be prepared, copied, published\n   andand
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 14 Full Copyright Statement
