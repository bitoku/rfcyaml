- contents:
  - '             The Simple Public-Key GSS-API Mechanism (SPKM)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Abstract\n   This specification defines protocols, procedures, and conventions
    to\n   be employed by peers implementing the Generic Security Service\n   Application
    Program Interface (as specified in RFCs 1508 and 1509)\n   when using the Simple
    Public-Key Mechanism.\n"
  title: Abstract
- contents:
  - "Background\n   Although the Kerberos Version 5 GSS-API mechanism [KRB5] is becoming\n
    \  well-established in many environments, it is important in some\n   applications
    to have a GSS-API mechanism which is based on a public-\n   key, rather than a
    symmetric-key, infrastructure.  The mechanism\n   described in this document has
    been proposed to meet this need and to\n   provide the following features.\n     1)
    \ The SPKM allows both unilateral and mutual authentication\n         to be accomplished
    without the use of secure timestamps.  This\n         enables environments which
    do not have access to secure time\n         to nevertheless have access to secure
    authentication.\n     2)  The SPKM uses Algorithm Identifiers to specify various\n
    \        algorithms to be used by the communicating peers.  This allows\n         maximum
    flexibility for a variety of environments, for future\n         enhancements,
    and for alternative algorithms.\n     3)  The SPKM allows the option of a true,
    asymmetric algorithm-\n         based, digital signature in the gss_sign() and
    gss_seal()\n         operations (now called gss_getMIC() and gss_wrap() in\n         [GSSv2]),
    rather than an integrity checksum based on a MAC\n         computed with a symmetric
    algorithm (e.g., DES).  For some\n         environments, the availability of true
    digital signatures\n         supporting non-repudiation is a necessity.\n     4)
    \ SPKM data formats and procedures are designed to be as similar\n         to
    those of the Kerberos mechanism as is practical.  This is\n         done for ease
    of implementation in those environments where\n         Kerberos has already been
    implemented.\n   For the above reasons, it is felt that the SPKM will offer\n
    \  flexibility and functionality, without undue complexity or overhead.\n"
  title: Background
- contents:
  - "Key Management\n   The key management employed in SPKM is intended to be as compatible\n
    \  as possible with both X.509 [X.509] and PEM [RFC-1422], since these\n   represent
    large communities of interest and show relative maturity in\n   standards.\n"
  title: Key Management
- contents:
  - "Acknowledgments\n   Much of the material in this document is based on the Kerberos\n
    \  Version 5 GSS-API mechanism [KRB5], and is intended to be as\n   compatible
    with it as possible.  This document also owes a great debt\n   to Warwick Ford
    and Paul Van Oorschot of Bell-Northern Research for\n   many fruitful discussions,
    to Kelvin Desplanque for implementation-\n   related clarifications, to John Linn
    of OpenVision Technologies for\n   helpful comments, and to Bancroft Scott of
    OSS for ASN.1 assistance.\n"
  title: Acknowledgments
- contents:
  - "1. Overview\n   The goal of the Generic Security Service Application Program\n
    \  Interface (GSS-API) is stated in the abstract of [RFC-1508] as\n   follows:\n
    \    \"This Generic Security Service Application Program Interface (GSS-\n     API)
    definition provides security services to callers in a generic\n     fashion, supportable
    with a range of underlying mechanisms and\n     technologies and hence allowing
    source-level portability of\n     applications to different environments. This
    specification defines\n     GSS-API services and primitives at a level independent
    of\n     underlying mechanism and programming language environment, and is\n     to
    be complemented by other, related specifications:\n       - documents defining
    specific parameter bindings for particular\n         language environments;\n
    \      - documents defining token formats, protocols, and procedures to\n         be
    implemented in order to realize GSS-API services atop\n         particular security
    mechanisms.\"\n   The SPKM is an instance of the latter type of document and is\n
    \  therefore termed a \"GSS-API Mechanism\".  This mechanism provides\n   authentication,
    key establishment, data integrity, and data\n   confidentiality in an on-line
    distributed application environment\n   using a public-key infrastructure.  Because
    it conforms to the\n   interface defined by [RFC-1508], SPKM can be used as a
    drop-in\n   replacement by any application which makes use of security services\n
    \  through GSS-API calls (for example, any application which already\n   uses
    the Kerberos GSS-API for security).  The use of a public-key\n   infrastructure
    allows digital signatures supporting non-repudiation\n   to be employed for message
    exchanges, and provides other benefits\n   such as scalability to large user populations.\n
    \  The tokens defined in SPKM are intended to be used by application\n   programs
    according to the GSS API \"operational paradigm\" (see [RFC-\n   1508] for further
    details):\n     The operational paradigm in which GSS-API operates is as follows.\n
    \    A typical GSS-API caller is itself a communications protocol [or is\n     an
    application program which uses a communications protocol],\n     calling on GSS-API
    in order to protect its communications with\n     authentication, integrity, and/or
    confidentiality security\n     services.  A GSS-API caller accepts tokens provided
    to it by its\n     local GSS-API implementation [i.e., its GSS-API mechanism]
    and\n     transfers the tokens to a peer on a remote system; that peer passes\n
    \    the received tokens to its local GSS-API implementation for\n     processing.\n
    \    This document defines two separate GSS-API mechanisms, SPKM-1 and\n     SPKM-2,
    whose primary difference is that SPKM-2 requires the\n     presence of secure
    timestamps for the purpose of replay detection\n     during context establishment
    and SPKM-1 does not.  This allows\n     greater flexibility for applications since
    secure timestamps cannot\n     always be guaranteed to be available in a given
    environment.\n"
  title: 1. Overview
- contents:
  - "2. Algorithms\n   A number of algorithm types are employed in SPKM.  Each type,
    along\n   with its purpose and a set of specific examples, is described in this\n
    \  section.  In order to ensure at least a minimum level of\n   interoperability
    among various implementations of SPKM, one of the\n   integrity algorithms is
    specified as MANDATORY; all remaining\n   examples (and any other algorithms)
    may optionally be supported by a\n   given SPKM implementation (note that a GSS-conformant
    mechanism need\n   not support confidentiality).  Making a confidentiality algorithm\n
    \  mandatory may preclude exportability of the mechanism implementation;\n   this
    document therefore specifies certain algorithms as RECOMMENDED\n   (that is, interoperability
    will be enhanced if these algorithms are\n   included in all SPKM implementations
    for which exportability is not a\n   concern).\n"
  title: 2. Algorithms
- contents:
  - "2.1 Integrity Algorithm (I-ALG):\n         Purpose:\n         This algorithm
    is used to ensure that a message has not been\n         altered in any way after
    being constructed by the legitimate\n         sender.  Depending on the algorithm
    used, the application of\n         this algorithm may also provide authenticity
    and support non-\n         repudiation for the message.\n       Examples:\n         md5WithRSAEncryption
    OBJECT IDENTIFIER ::= {\n           iso(1) member-body(2) US(840) rsadsi(113549)
    pkcs(1)\n           pkcs-1(1) 4        -- imported from [PKCS1]\n         }\n
    \           This algorithm (MANDATORY) provides data integrity and\n            authenticity
    and supports non-repudiation by computing an\n            RSA signature on the
    MD5 hash of that data.  This is\n            essentially equivalent to md5WithRSA
    {1 3 14 3 2 3},\n            which is defined by OIW (the Open Systems Environment\n
    \           Implementors' Workshop).\n            Note that since this is the
    only integrity/authenticity\n            algorithm specified to be mandatory at
    this time, for\n            interoperability reasons it is also stipulated that\n
    \           md5WithRSA be the algorithm used to sign all context\n            establishment
    tokens which are signed rather than MACed --\n            see Section 3.1.1 for
    details.  In future versions of this\n            document, alternate or additional
    algorithms may be\n            specified to be mandatory and so this stipulation
    on the\n            context establishment tokens may be removed.\n         DES-MAC
    OBJECT IDENTIFIER ::= {\n            iso(1) identified-organization(3) oiw(14)
    secsig(3)\n            algorithm(2) 10  -- carries length in bits of the MAC as\n
    \        }                   -- an INTEGER parameter, constrained to\n                             --
    multiples of eight from 16 to 64\n            This algorithm (RECOMMENDED) provides
    integrity by computing\n            a DES MAC (as specified by [FIPS-113]) on
    that data.\n         md5-DES-CBC OBJECT IDENTIFIER ::= {\n            iso(1) identified-organization(3)
    dod(6) internet(1)\n            security(5) integrity(3) md5-DES-CBC(1)\n         }\n
    \           This algorithm provides data integrity by encrypting, using\n            DES
    CBC, the \"confounded\" MD5 hash of that data (see Section\n            3.2.2.1
    for the definition and purpose of confounding).\n            This will typically
    be faster in practice than computing a\n            DES MAC unless the input data
    is extremely short (e.g., a\n            few bytes).  Note that without the confounder
    the strength\n            of this integrity mechanism is (at most) equal to the\n
    \           strength of DES under a known-plaintext attack.\n         sum64-DES-CBC
    OBJECT IDENTIFIER ::= {\n            iso(1) identified-organization(3) dod(6)
    internet(1)\n            security(5) integrity(3) sum64-DES-CBC(2)\n         }\n
    \           This algorithm provides data integrity by encrypting, using\n            DES
    CBC, the concatenation of the confounded data and the\n            sum of all
    the input data blocks (the sum computed using\n            addition modulo 2**64
    - 1).  Thus, in this algorithm,\n            encryption is a requirement for the
    integrity to be secure.\n            For comments regarding the security of this
    integrity\n            algorithm, see [Juen84, Davi89].\n"
  title: '2.1 Integrity Algorithm (I-ALG):'
- contents:
  - "2.2 Confidentiality Algorithm (C-ALG):\n       Purpose:\n         This symmetric
    algorithm is used to generate the encrypted\n         data for gss_seal() / gss_wrap().\n
    \      Example:\n         DES-CBC OBJECT IDENTIFIER ::= {\n            iso(1)
    identified-organization(3) oiw(14) secsig(3)\n            algorithm(2) 7 -- carries
    IV (OCTET STRING) as a parameter;\n         }                 -- this (optional)
    parameter is unused in\n                           -- SPKM due to the use of confounding\n
    \           This algorithm is RECOMMENDED.\n"
  title: '2.2 Confidentiality Algorithm (C-ALG):'
- contents:
  - "2.3 Key Establishment Algorithm (K-ALG):\n       Purpose:\n         This algorithm
    is used to establish a symmetric key for use\n         by both the initiator and
    the target over the established\n         context.  The keys used for C-ALG and
    any keyed I-ALGs (for\n         example, DES-MAC) are derived from this context
    key.  As will\n         be seen in Section 3.1, key establishment is done within
    the\n         X.509 authentication exchange and so the resulting shared\n         symmetric
    key is authenticated.\n       Examples:\n         RSAEncryption OBJECT IDENTIFIER
    ::= {\n           iso(1) member-body(2) US(840) rsadsi(113549) pkcs(1)\n           pkcs-1(1)
    1        -- imported from [PKCS1] and [RFC-1423]\n         }\n            In this
    algorithm (MANDATORY), the context key is generated\n            by the initiator,
    encrypted with the RSA public key of the\n            target, and sent to the
    target.  The target need not respond\n            to the initiator for the key
    to be established.\n         id-rsa-key-transport OBJECT IDENTIFIER ::= {\n            iso(1)
    identified-organization(3) oiw(14) secsig(3)\n            algorithm(2) 22   --
    imported from [X9.44]\n         }\n            Similar to RSAEncryption, but source
    authenticating info.\n            is also encrypted with the target's RSA public
    key.\n        dhKeyAgreement OBJECT IDENTIFIER ::= {\n           iso(1) member-body(2)
    US(840) rsadsi(113549) pkcs(1)\n           pkcs-3(3) 1\n        }\n            In
    this algorithm, the context key is generated jointly by\n            the initiator
    and the target using the Diffie-Hellman key\n            establishment algorithm.
    \ The target must therefore respond\n            to the initiator for the key
    to be established (so this\n            K-ALG cannot be used with unilateral authentication
    in\n            SPKM-2 (see Section 3.1)).\n"
  title: '2.3 Key Establishment Algorithm (K-ALG):'
- contents:
  - "2.4 One-Way Function (O-ALG) for Subkey Derivation Algorithm:\n       Purpose:\n
    \        Having established a context key using the negotiated K-ALG,\n         both
    initiator and target must be able to derive a set of\n         subkeys for the
    various C-ALGs and keyed I-ALGs supported over\n         the context.  Let the
    (ordered) list of agreed C-ALGs be\n         numbered consecutively, so that the
    first algorithm (the\n         \"default\") is numbered \"0\", the next is numbered
    \"1\", and so\n         on.  Let the numbering for the (ordered) list of agreed
    I-ALGs\n         be identical.  Finally, let the context key be a binary string\n
    \        of arbitrary length \"M\", subject to the following constraint:\n         L
    <= M <= U  (where the lower limit \"L\" is the bit length of\n         the longest
    key needed by any agreed C-ALG or keyed I-ALG, and\n         the upper limit \"U\"
    is the largest bit size which will fit\n         within the K-ALG parameters).\n
    \        For example, if DES and two-key-triple-DES are the negotiated\n         confidentiality
    algorithms and DES-MAC is the negotiated keyed\n         integrity algorithm (note
    that digital signatures do not use a\n         context key), then the context
    key must be at least 112 bits\n         long.  If 512-bit RSAEncryption is the
    K-ALG in use then the\n         originator can randomly generate a context key
    of any greater\n         length up to 424 bits (the longest allowable RSA input\n
    \        specified in [PKCS-1]) -- the target can determine the length\n         which
    was chosen by removing the padding bytes during the RSA\n         decryption operation.
    \ On the other hand, if dhKeyAgreement is\n         the K-ALG in use then the
    context key is the result of the\n         Diffie-Hellman computation (with the
    exception of the high-\n         order byte, which is discarded for security reasons),
    so that\n         its length is that of the Diffie-Hellman modulus, p, minus 8\n
    \        bits.\n         The derivation algorithm for a k-bit subkey is specified
    as\n         follows:\n      rightmost_k_bits (OWF(context_key || x || n || s
    || context_key))\n         where\n          - \"x\" is the ASCII character \"C\"
    (0x43) if the subkey is\n            for a confidentiality algorithm or the ASCII
    character \"I\"\n            (0x49) if the subkey is for a keyed integrity algorithm;\n
    \         - \"n\" is the number of the algorithm in the appropriate agreed\n            list
    for the context (the ASCII character \"0\" (0x30), \"1\"\n            (0x31),
    and so on);\n          - \"s\" is the \"stage\" of processing -- always the ASCII\n
    \           character \"0\" (0x30), unless \"k\" is greater than the output\n
    \           size of OWF, in which case the OWF is computed repeatedly\n            with
    increasing ASCII values of \"stage\" (each OWF output\n            being concatenated
    to the end of previous OWF outputs),\n            until \"k\" bits have been generated;\n
    \         - \"||\" is the concatenation operation; and\n          - \"OWF\" is
    any appropriate One-Way Function.\n       Examples:\n         MD5 OBJECT IDENTIFIER
    ::= {\n           iso(1) member-body(2) US(840) rsadsi(113549)\n           digestAlgorithm(2)
    5\n         }\n           This algorithm is MANDATORY.\n         SHA OBJECT IDENTIFIER
    ::= {\n            iso(1) identified-organization(3) oiw(14) secsig(3)\n            algorithm(2)
    18\n         }\n         It is recognized that existing hash functions may not
    satisfy\n         all required properties of OWFs.  This is the reason for\n         allowing
    negotiation of the O-ALG OWF during the context\n         establishment process
    (see Section 2.5), since in this way\n         future improvements in OWF design
    can easily be accommodated.\n         For example, in some environments a preferred
    OWF technique\n         might be an encryption algorithm which encrypts the input\n
    \        specified above using the context_key as the encryption key.\n"
  title: '2.4 One-Way Function (O-ALG) for Subkey Derivation Algorithm:'
- contents:
  - "2.5 Negotiation:\n   During context establishment in SPKM, the initiator offers
    a set of\n   possible confidentiality algorithms and a set of possible integrity\n
    \  algorithms to the target (note that the term \"integrity algorithms\"\n   includes
    digital signature algorithms).  The confidentiality\n   algorithms selected by
    the target become ones that may be used for\n   C-ALG over the established context,
    and the integrity algorithms\n   selected by the target become ones that may be
    used for I-ALG over\n   the established context (the target \"selects\" algorithms
    by\n   returning, in the same relative order, the subset of each offered\n   list
    that it supports).  Note that any C-ALG and I-ALG may be used\n   for any message
    over the context and that the first confidentiality\n   algorithm and the first
    integrity algorithm in the agreed sets become\n   the default algorithms for that
    context.\n   The agreed confidentiality and integrity algorithms for a specific\n
    \  context define the valid values of the Quality of Protection (QOP)\n   parameter
    used in the gss_getMIC() and gss_wrap() calls -- see\n   Section 5.2 for further
    details.  If no response is expected from the\n   target (unilateral authentication
    in SPKM-2) then the algorithms\n   offered by the initiator are the ones that
    may be used over the\n   context (if this is unacceptable to the target then a
    delete token\n   must be sent to the initiator so that the context is never\n
    \  established).\n   Furthermore, in the first context establishment token the
    initiator\n   offers a set of possible K-ALGs, along with the key (or key half)\n
    \  corresponding to the first algorithm in the set (its preferred\n   algorithm).
    \ If this K-ALG is unacceptable to the target then the\n   target must choose
    one of the other K-ALGs in the set and send this\n   choice along with the key
    (or key half) corresponding to this choice\n   in its response (otherwise a delete
    token must be sent so that the\n   context is never established).  If necessary
    (that is, if the target\n   chooses a 2-pass K-ALG such as dhKeyAgreement), the
    initiator will\n   send its key half in a response to the target.\n   Finally,
    in the first context establishment token the initiator\n   offers a set of possible
    O-ALGs (only a single O-ALG if no response\n   is expected).  The (single) O-ALG
    chosen by the target becomes the\n   subkey derivation algorithm OWF to be used
    over the context.\n   In future versions of SPKM, other algorithms may be specified
    for any\n   or all of I-ALG, C-ALG, K-ALG, and O-ALG.\n"
  title: '2.5 Negotiation:'
- contents:
  - "3. Token Formats\n   This section discusses protocol-visible characteristics
    of the SPKM;\n   it defines elements of protocol for interoperability and is\n
    \  independent of language bindings per [RFC-1509].\n   The SPKM GSS-API mechanism
    will be identified by an Object Identifier\n   representing \"SPKM-1\" or \"SPKM-2\",
    having the value {spkm spkm-1(1)}\n   or {spkm spkm-2(2)}, where spkm has the
    value {iso(1) identified-\n   organization(3) dod(6) internet(1) security(5) mechanisms(5)\n
    \  spkm(1)}.  SPKM-1 uses random numbers for replay detection during\n   context
    establishment and SPKM-2 uses timestamps (note that for both\n   mechanisms, sequence
    numbers are used to provide replay and out-of-\n   sequence detection during the
    context, if this has been requested by\n   the application).\n   Tokens transferred
    between GSS-API peers (for security context\n   management and per-message protection
    purposes) are defined.\n"
  title: 3. Token Formats
- contents:
  - "3.1. Context Establishment Tokens\n   Three classes of tokens are defined in
    this section:  \"Initiator\"\n   tokens, emitted by calls to gss_init_sec_context()
    and consumed by\n   calls to gss_accept_sec_context(); \"Target\" tokens, emitted
    by calls\n   to gss_accept_sec_context() and consumed by calls to\n   gss_init_sec_context();
    and \"Error\" tokens, potentially emitted by\n   calls to gss_init_sec_context()
    or gss_accept_sec_context(), and\n   potentially consumed by calls to gss_init_sec_context()
    or\n   gss_accept_sec_context().\n   Per RFC-1508, Appendix B, the initial context
    establishment token\n   will be enclosed within framing as follows:\n   InitialContextToken
    ::= [APPLICATION 0] IMPLICIT SEQUENCE {\n           thisMech           MechType,\n
    \                  -- MechType is OBJECT IDENTIFIER\n                   -- representing
    \"SPKM-1\" or \"SPKM-2\"\n           innerContextToken  ANY DEFINED BY thisMech\n
    \  }               -- contents mechanism-specific\n   When thisMech is SPKM-1
    or SPKM-2, innerContextToken is defined as\n   follows:\n      SPKMInnerContextToken
    ::= CHOICE {\n         req    [0] SPKM-REQ,\n         rep-ti [1] SPKM-REP-TI,\n
    \        rep-it [2] SPKM-REP-IT,\n         error  [3] SPKM-ERROR,\n         mic
    \   [4] SPKM-MIC,\n         wrap   [5] SPKM-WRAP,\n         del    [6] SPKM-DEL\n
    \     }\n   The above GSS-API framing shall be applied to all tokens emitted by\n
    \  the SPKM GSS-API mechanism, including SPKM-REP-TI (the response from\n   the
    Target to the Initiator), SPKM-REP-IT (the response from the\n   Initiator to
    the Target), SPKM-ERROR, context-deletion, and per-\n   message tokens, not just
    to the initial token in a context\n   establishment exchange.  While not required
    by RFC-1508, this enables\n   implementations to perform enhanced error-checking.
    \ The tag values\n   provided in SPKMInnerContextToken (\"[0]\" through \"[6]\")
    specify a\n   token-id for each token; similar information is contained in each\n
    \  token's tok-id field.  While seemingly redundant, the tag value and\n   tok-id
    actually perform different tasks:  the tag ensures that\n   InitialContextToken
    can be properly decoded; tok-id ensures, among\n   other things, that data associated
    with the per-message tokens is\n   cryptographically linked to the intended token
    type.  Every\n   innerContextToken also includes a context-id field; see Section
    6 for\n   a discussion of both token-id and context-id information and their\n
    \  use in an SPKM support function).\n   The innerContextToken field of context
    establishment tokens for the\n   SPKM GSS-API mechanism will contain one of the
    following messages:\n   SPKM-REQ; SPKM-REP-TI; SPKM-REP-IT; and SPKM-ERROR.  Furthermore,
    all\n   innerContextTokens are encoded using ASN.1 BER (constrained, in the\n
    \  interests of parsing simplicity, to the DER subset defined in\n   [X.509],
    clause 8.7).\n   The SPKM context establishment tokens are defined according to\n
    \  [X.509] Section 10 and are compatible with [9798].  SPKM-1 (random\n   numbers)
    uses Section 10.3, \"Two-way Authentication\", when performing\n   unilateral
    authentication of the target to the initiator and uses\n   Section 10.4, \"Three-way
    Authentication\", when mutual authentication\n   is requested by the initiator.
    \ SPKM-2 (timestamps) uses Section\n   10.2, \"One-way Authentication\", when
    performing unilateral\n   authentication of the initiator to the target and uses
    Section 10.3,\n   \"Two-way Authentication\", when mutual authentication is requested
    by\n   the initiator.\n   The implication of the previous paragraph is that for
    SPKM-2\n   unilateral authentication no negotiation of K-ALG can be done (the\n
    \  target either accepts the K-ALG and context key given by the\n   initiator
    or disallows the context).  For SPKM-2 mutual or SPKM-1\n   unilateral authentication
    some negotiation is possible, but the\n   target can only choose among the one-pass
    K-ALGs offered by the\n   initiator (or disallow the context).  Alternatively,
    the initiator\n   can request that the target generate and transmit the context
    key.\n   For SPKM-1 mutual authentication the target can choose any one- or\n
    \  two-pass K-ALG offered by the initiator and, again, can be requested\n   to
    generate and transmit the context key.\n   It is envisioned that typical use of
    SPKM-1 or SPKM-2 will involve\n   mutual authentication.  Although unilateral
    authentication is\n   available for both mechanisms, its use is not generally
    recommended.\n"
  title: 3.1. Context Establishment Tokens
- contents:
  - "3.1.1. Context Establishment Tokens - Initiator (first token)\n   In order to
    accomplish context establishment, it may be necessary\n   that both the initiator
    and the target have access to the other\n   partys public-key certificate(s).
    \ In some environments the initiator\n   may choose to acquire all certificates
    and send the relevant ones to\n   the target in the first token.  In other environments
    the initiator\n   may request that the target send certificate data in its response\n
    \  token, or each side may individually obtain the certificate data it\n   needs.
    \ In any case, however, the SPKM implementation must have the\n   ability to obtain
    certificates which correspond to a supplied Name.\n   The actual mechanism to
    be used to achieve this is a local\n   implementation matter and is therefore
    outside the scope of this\n   specification.\n   Relevant SPKM-REQ syntax is as
    follows (note that imports from other\n   documents are given in Appendix A):\n
    \  SPKM-REQ ::= SEQUENCE {\n           requestToken      REQ-TOKEN,\n           certif-data
    [0]   CertificationData OPTIONAL,\n           auth-data [1]     AuthorizationData
    OPTIONAL\n              -- see [RFC-1510] for a discussion of auth-data\n   }\n
    \  CertificationData ::= SEQUENCE {\n           certificationPath [0]          CertificationPath
    OPTIONAL,\n           certificateRevocationList [1]  CertificateList OPTIONAL\n
    \  }  -- at least one of the above shall be present\n   CertificationPath ::=
    SEQUENCE {\n           userKeyId [0]         OCTET STRING OPTIONAL,\n              --
    identifier for user's public key\n           userCertif [1]        Certificate
    OPTIONAL,\n              -- certificate containing user's public key\n           verifKeyId
    [2]        OCTET STRING OPTIONAL,\n              -- identifier for user's public
    verification key\n           userVerifCertif [3]   Certificate OPTIONAL,\n              --
    certificate containing user's public verification key\n           theCACertificates
    [4] SEQUENCE OF CertificatePair OPTIONAL\n   }          -- certification path
    from target to source\n   Having separate verification fields allows different
    key pairs\n   (possibly corresponding to different algorithms) to be used for\n
    \  encryption/decryption and signing/verification.  Presence of [0] or\n   [1]
    and absence of [2] and [3] implies that the same key pair is to\n   be used for
    enc/dec and verif/signing (note that this practice is not\n   typically recommended).
    \ Presence of [2] or [3] implies that a\n   separate key pair is to be used for
    verif/signing, and so [0] or [1]\n   must also be present.  Presence of [4] implies
    that at least one of\n   [0], [1], [2], and [3] must also be present.\n      REQ-TOKEN
    ::= SEQUENCE {\n              req-contents     Req-contents,\n              algId
    \           AlgorithmIdentifier,\n              req-integrity    Integrity  --
    \"token\" is Req-contents\n      }\n      Integrity ::= BIT STRING\n        --
    If corresponding algId specifies a signing algorithm,\n        -- \"Integrity\"
    holds the result of applying the signing procedure\n        -- specified in algId
    to the BER-encoded octet string which results\n        -- from applying the hashing
    procedure (also specified in algId) to\n        -- the DER-encoded octets of \"token\".\n
    \       -- Alternatively, if corresponding algId specifies a MACing\n        --
    algorithm, \"Integrity\" holds the result of applying the MACing\n        -- procedure
    specified in algId to the DER-encoded octets of\n        -- \"token\" (note that
    for MAC, algId must be one of the integrity\n        -- algorithms offered by
    the initiator with the appropriate subkey\n        -- derived from the context
    key (see Section 2.4) used as the key\n        -- input)\n   It is envisioned
    that typical use of the Integrity field for each of\n   REQ-TOKEN, REP-TI-TOKEN,
    and REP-IT-TOKEN will be a true digital\n   signature, providing unilateral or
    mutual authentication along with\n   replay protection, as required.  However,
    there are situations in\n   which the MAC choice will be appropriate.  One example
    is the case in\n   which the initiator wishes to remain anonymous (so that the
    first, or\n   first and third, token(s) will be MACed and the second token will
    be\n   signed).  Another example is the case in which a previously\n   authenticated,
    established, and cached context is being re-\n   established at some later time
    (here all exchanged tokens will be\n   MACed).\n   The primary advantage of the
    MAC choice is that it reduces processing\n   overhead for cases in which either
    authentication is not required\n   (e.g., anonymity) or authentication is established
    by some other\n   means (e.g., ability to form the correct MAC on a \"fresh\"
    token in\n   context re-establishment).\n   Req-contents ::= SEQUENCE {\n           tok-id
    \          INTEGER (256),    -- shall contain 0100(hex)\n           context-id
    \      Random-Integer,   -- see Section 6.3\n           pvno             BIT STRING,
    \      -- protocol version number\n           timestamp        UTCTime OPTIONAL,
    -- mandatory for SPKM-2\n           randSrc          Random-Integer,\n           targ-name
    \       Name,\n           src-name [0]     Name OPTIONAL,\n              -- must
    be supplied unless originator is \"anonymous\"\n           req-data         Context-Data,\n
    \          validity [1]     Validity OPTIONAL,\n              -- validity interval
    for key (may be used in the\n              -- computation of security context
    lifetime)\n           key-estb-set     Key-Estb-Algs,\n              -- specifies
    set of key establishment algorithms\n           key-estb-req      BIT STRING OPTIONAL,\n
    \             -- key estb. parameter corresponding to first K-ALG in set\n              --
    (not used if initiator is unable or unwilling to\n              -- generate and
    securely transmit key material to target).\n              -- Established key must
    satisfy the key length constraints\n              -- specified in Section 2.4.\n
    \          key-src-bind      OCTET STRING OPTIONAL\n              -- Used to bind
    the source name to the symmetric key.\n              -- This field must be present
    for the case of SPKM-2\n              -- unilateral authen. if the K-ALG in use
    does not provide\n              -- such a binding (but is optional for all other
    cases).\n              -- The octet string holds the result of applying the\n
    \             -- mandatory hashing procedure MD5 (in MANDATORY I-ALG;\n              --
    see Section 2.1) as follows:  MD5(src || context_key),\n              -- where
    \"src\" is the DER-encoded octets of src-name,\n              -- \"context-key\"
    is the symmetric key (i.e., the\n              -- unprotected version of what
    is transmitted in\n              -- key-estb-req), and \"||\" is the concatenation
    operation.\n           }\n   -- The protocol version number (pvno) parameter is
    a BIT STRING which\n   -- uses as many bits as necessary to specify all the SPKM
    protocol\n   -- versions supported by the initiator (one bit per protocol\n   --
    version).  The protocol specified by this document is version 0.\n   -- Bit 0
    of pvno is therefore set if this version is supported;\n   -- similarly, bit 1
    is set if version 1 (if defined in the future) is\n   -- supported, and so on.
    \ Note that for unilateral authentication\n   -- using SPKM-2, no response token
    is expected during context\n   -- establishment, so no protocol negotiation can
    take place; in this\n   -- case, the initiator must set exactly one bit of pvno.
    \ The version\n   -- of REQ-TOKEN must correspond to the highest bit set in pvno.\n
    \  -- The \"validity\" parameter above is the only way within SPKM for\n   --
    the initiator to transmit desired context lifetime to the target.\n   -- Since
    it cannot be guaranteed that the initiator and target have\n   -- synchronized
    time, the span of time specified by \"validity\" is to\n   -- be taken as definitive
    (rather than the actual times given in this\n   -- parameter).\n   Random-Integer
    ::= BIT STRING\n   -- Each SPKM implementation is responsible for generating a
    \"fresh\"\n   -- random number for the purpose of context establishment; that
    is,\n   -- one which (with high probability) has not been used previously.\n   --
    There are no cryptographic requirements on this random number\n   -- (i.e., it
    need not be unpredictable, it simply needs to be fresh).\n   Context-Data ::=
    SEQUENCE {\n           channelId       ChannelId OPTIONAL, -- channel bindings\n
    \          seq-number      INTEGER OPTIONAL,   -- sequence number\n           options
    \        Options,\n           conf-alg        Conf-Algs,          -- confidentiality.
    algs.\n           intg-alg        Intg-Algs,          -- integrity algorithm\n
    \          owf-alg         OWF-Algs            -- for subkey derivation\n   }\n
    \  ChannelId ::= OCTET STRING\n   Options ::= BIT STRING {\n           delegation-state
    (0),\n           mutual-state (1),\n           replay-det-state (2), -- used for
    replay det. during context\n           sequence-state (3),   -- used for sequencing
    during context\n           conf-avail (4),\n           integ-avail (5),\n           target-certif-data-required
    (6)\n                                 -- used to request targ's certif. data\n
    \  }\n   Conf-Algs ::= CHOICE {\n           algs [0]        SEQUENCE OF AlgorithmIdentifier,\n
    \          null [1]        NULL\n            -- used when conf. is not available
    over context\n   } -- for C-ALG (see Section 5.2 for discussion of QOP)\n   Intg-Algs
    ::= SEQUENCE OF AlgorithmIdentifier\n       -- for I-ALG (see Section 5.2 for
    discussion of QOP)\n   OWF-Algs ::= SEQUENCE OF AlgorithmIdentifier\n       --
    Contains exactly one algorithm in REQ-TOKEN for SPKM-2\n       -- unilateral,
    and contains at least one algorithm otherwise.\n       -- Always contains exactly
    one algorithm in REP-TOKEN.\n   Key-Estb-Algs ::= SEQUENCE OF AlgorithmIdentifier\n
    \      -- to allow negotiation of K-ALG\n   A context establishment sequence based
    on the SPKM will perform\n   unilateral authentication if the mutual-req bit is
    not set in the\n   application's call to gss_init_sec_context().  SPKM-2 accomplishes\n
    \  this using only SPKM-REQ (thereby authenticating the initiator to the\n   target),
    while SPKM-1 accomplishes this using both SPKM-REQ and\n   SPKM-REP-TI (thereby
    authenticating the target to the initiator).\n   Applications requiring authentication
    of both peers (initiator as\n   well as target) must request mutual authentication,
    resulting in\n   \"mutual-state\" being set within SPKM-REQ Options.  In response
    to\n   such a request, the context target will reply to the initiator with\n   an
    SPKM-REP-TI token.  If mechanism SPKM-2 has been chosen, this\n   completes the
    (timestamp-based) mutual authentication context\n   establishment exchange.  If
    mechanism SPKM-1 has been chosen and\n   SPKM-REP-TI is sent, the initiator will
    then reply to the target with\n   an SPKM-REP-IT token, completing the (random-number-based)
    mutual\n   authentication context establishment exchange.\n   Other bits in the
    Options field of Context-Data are explained in\n   RFC-1508, with the exception
    of target-certif-data-required, which\n   the initiator sets to TRUE to request
    that the target return its\n   certification data in the SPKM-REP-TI token.  For
    unilateral\n   authentication in SPKM-2 (in which no SPKM-REP-TI token is\n   constructed),
    this option bit is ignored by both initiator and\n   target.\n"
  title: 3.1.1. Context Establishment Tokens - Initiator (first token)
- contents:
  - "3.1.2. Context Establishment Tokens - Target\n   SPKM-REP-TI ::= SEQUENCE {\n
    \          responseToken    REP-TI-TOKEN,\n           certif-data      CertificationData
    OPTIONAL\n             -- included if target-certif-data-required option was\n
    \            -- set to TRUE in SPKM-REQ\n   }\n   REP-TI-TOKEN ::= SEQUENCE {\n
    \          rep-ti-contents Rep-ti-contents,\n           algId           AlgorithmIdentifier,\n
    \          rep-ti-integ    Integrity  -- \"token\" is Rep-ti-contents\n   }\n
    \  Rep-ti-contents ::= SEQUENCE {\n           tok-id           INTEGER (512),
    \  -- shall contain 0200 (hex)\n           context-id       Random-Integer,  --
    see Section 6.3\n           pvno [0]         BIT STRING OPTIONAL, -- prot. version
    number\n           timestamp        UTCTime OPTIONAL, -- mandatory for SPKM-2\n
    \          randTarg         Random-Integer,\n           src-name [1]     Name
    OPTIONAL,\n             -- must contain whatever value was supplied in REQ-TOKEN\n
    \          targ-name        Name,\n           randSrc          Random-Integer,\n
    \          rep-data         Context-Data,\n           validity [2]     Validity
    \ OPTIONAL,\n             -- validity interval for key (used if the target can
    only\n             -- support a shorter context lifetime than was offered in\n
    \            -- REQ-TOKEN)\n           key-estb-id      AlgorithmIdentifier OPTIONAL,\n
    \            -- used if target is changing key estb. algorithm (must be\n             --
    a member of initiators key-estb-set)\n           key-estb-str      BIT STRING
    OPTIONAL\n             -- contains (1) the response to the initiators\n             --
    key-estb-req (if init. used a 2-pass K-ALG), or (2) the\n             -- key-estb-req
    corresponding to the K-ALG supplied in\n             -- above key-estb-id, or
    (3) the key-estb-req corresponding\n             -- to the first K-ALG supplied
    in initiator's key-estb-id,\n             -- if initiator's (OPTIONAL) key-estb-req
    was not used\n             -- (target's key-estb-str must be present in this case).\n
    \            -- Established key must satisfy the key length constraints\n             --
    specified in Section 2.4.\n           }\n   The protocol version number (pvno)
    parameter is a BIT STRING which\n   uses as many bits as necessary to specify
    a single SPKM protocol\n   version offered by the initiator which is supported
    by the target\n   (one bit per protocol version); that is, the target sets exactly
    one\n   bit of pvno.  If none of the versions offered by the initiator are\n   supported
    by the target, a delete token must be returned so that the\n   context is never
    established.  If the initiator's pvno has only one\n   bit set and the target
    happens to support this protocol version, then\n   this version is used over the
    context and the pvno parameter of REP-\n   TOKEN can be omitted.  Finally, if
    the initiator and target do have\n   one or more versions in common but the version
    of the REQ-TOKEN\n   received is not supported by the target, a REP-TOKEN must
    be sent\n   with a desired version bit set in pvno (and dummy values used for
    all\n   subsequent token fields).  The initiator can then respond with a new\n
    \  REQ-TOKEN of the proper version (essentially starting context\n   establishment
    anew).\n"
  title: 3.1.2. Context Establishment Tokens - Target
- contents:
  - "3.1.3. Context Establishment Tokens - Initiator (second token)\n   Relevant SPKM-REP-IT
    syntax is as follows:\n   SPKM-REP-IT ::= SEQUENCE {\n           responseToken
    \   REP-IT-TOKEN,\n           algId            AlgorithmIdentifier,\n           rep-it-integ
    \    Integrity  -- \"token\" is REP-IT-TOKEN\n   }\n   REP-IT-TOKEN ::= SEQUENCE
    {\n           tok-id           INTEGER (768), -- shall contain 0300 (hex)\n           context-id
    \      Random-Integer,\n           randSrc          Random-Integer,\n           randTarg
    \        Random-Integer,\n           targ-name        Name,  -- the targ-name
    specified in REP-TI\n           src-name         Name OPTIONAL,\n             --
    must contain whatever value was supplied in REQ-TOKEN\n           key-estb-rep
    \    BIT STRING OPTIONAL\n                 -- contains the response to targets
    key-estb-str\n                 -- (if target selected a 2-pass K-ALG)\n           }\n"
  title: 3.1.3. Context Establishment Tokens - Initiator (second token)
- contents:
  - "3.1.4. Error Token\n   The syntax of SPKM-ERROR is as follows:\n   SPKM-ERROR
    ::= SEQUENCE {\n           error-token      ERROR-TOKEN,\n           algId            AlgorithmIdentifier,\n
    \          integrity        Integrity  -- \"token\" is ERROR-TOKEN\n   }\n   ERROR-TOKRN
    ::=   SEQUENCE {\n           tok-id           INTEGER (1024), -- shall contain
    0400 (hex)\n           context-id       Random-Integer\n           }\n   The SPKM-ERROR
    token is used only during the context establishment\n   process.  If an SPKM-REQ
    or SPKM-REP-TI token is received in error,\n   the receiving function (either
    gss_init_sec_context() or\n   gss_accept_sec_context()) will generate an SPKM-ERROR
    token to be\n   sent to the peer (if the peer is still in the context establishment\n
    \  process) and will return GSS_S_CONTINUE_NEEDED.  If, on the other\n   hand,
    no context establishment response is expected from the peer\n   (i.e., the peer
    has completed context establishment), the function\n   will return the appropriate
    major status code (e.g., GSS_S_BAD_SIG)\n   along with a minor status of GSS_SPKM_S_SG_CONTEXT_ESTB_ABORT
    and all\n   context-relevant information will be deleted.  The output token will\n
    \  not be an SPKM-ERROR token but will instead be an SPKM-DEL token\n   which
    will be processed by the peer's gss_process_context_token().\n   If gss_init_sec_context()
    receives an error token (whether valid or\n   invalid), it will regenerate SPKM-REQ
    as its output token and return\n   a major status code of GSS_S_CONTINUE_NEEDED.
    \ (Note that if the\n   peer's gss_accept_sec_context() receives SPKM-REQ token
    when it is\n   expecting a SPKM-REP-IT token, it will ignore SPKM-REQ and return
    a\n   zero-length output token with a major status of\n   GSS_S_CONTINUE_NEEDED.)\n
    \  Similarly, if gss_accept_sec_context() receives an error token\n   (whether
    valid or invalid), it will regenerate SPKM-REP-TI as its\n   output token and
    return a major status code of GSS_S_CONTINUE_NEEDED.\n   md5WithRsa is currently
    stipulated for the signing of context\n   establishment tokens.  Discrepancies
    involving modulus bitlength can\n   be resolved through judicious use of the SPKM-ERROR
    token.  The\n   context initiator signs REQ-TOKEN using the strongest RSA it supports\n
    \  (e.g., 1024 bits).  If the target is unable to verify signatures of\n   this
    length, it sends SPKM-ERROR signed with the strongest RSA that\n   it supports
    (e.g. 512).\n   At the completion of this exchange, both sides know what RSA\n
    \  bitlength the other supports, since the size of the signature is\n   equal
    to the size of the modulus.  Further exchanges can be made\n   (using successively
    smaller supported bitlengths) until either an\n   agreement is reached or context
    establishment is aborted because no\n   agreement is possible.\n"
  title: 3.1.4. Error Token
- contents:
  - "3.2. Per-Message and Context Deletion Tokens\n   Three classes of tokens are
    defined in this section: \"MIC\" tokens,\n   emitted by calls to gss_getMIC()
    and consumed by calls to\n   gss_verifyMIC(); \"Wrap\" tokens, emitted by calls
    to gss_wrap() and\n   consumed by calls to gss_unwrap(); and context deletion
    tokens,\n   emitted by calls to gss_init_sec_context(), gss_accept_sec_context(),\n
    \  or gss_delete_sec_context() and consumed by calls to\n   gss_process_context_token().\n"
  title: 3.2. Per-Message and Context Deletion Tokens
- contents:
  - "3.2.1. Per-message Tokens - Sign / MIC\n   Use of the gss_sign() / gss_getMIC()
    call yields a token, separate\n   from the user data being protected, which can
    be used to verify the\n   integrity of that data as received.  The token and the
    data may be\n   sent separately by the sending application and it is the receiving\n
    \  application's responsibility to associate the received data with the\n   received
    token.\n   The SPKM-MIC token has the following format:\n   SPKM-MIC ::= SEQUENCE
    {\n           mic-header       Mic-Header,\n           int-cksum        BIT STRING\n
    \                               -- Checksum over header and data,\n                                --
    calculated according to algorithm\n                                -- specified
    in int-alg field.\n   }\n   Mic-Header ::= SEQUENCE {\n           tok-id           INTEGER
    (257),\n                                -- shall contain 0101 (hex)\n           context-id
    \      Random-Integer,\n           int-alg [0]      AlgorithmIdentifier OPTIONAL,\n
    \                               -- Integrity algorithm indicator (must\n                                --
    be one of the agreed integrity\n                                -- algorithms
    for this context).\n                                -- field not present = default
    id.\n           snd-seq [1]      SeqNum OPTIONAL  -- sequence number field.\n
    \  }\n   SeqNum ::= SEQUENCE {\n           num      INTEGER, -- the sequence number
    itself\n           dir-ind  BOOLEAN  -- a direction indicator\n   }\n"
  title: 3.2.1. Per-message Tokens - Sign / MIC
- contents:
  - "3.2.1.1. Checksum\n   Checksum calculation procedure (common to all algorithms
    -- note that\n   for SPKM the term \"checksum\" includes digital signatures as
    well as\n   hashes and MACs): Checksums are calculated over the data field,\n
    \  logically prepended by the bytes of the plaintext token header (mic-\n   header).
    \ The result binds the data to the entire plaintext header,\n   so as to minimize
    the possibility of malicious splicing.\n   For example, if the int-alg specifies
    the md5WithRSA algorithm, then\n   the checksum is formed by computing an MD5
    [RFC-1321] hash over the\n   plaintext data (prepended by the header), and then
    computing an RSA\n   signature [PKCS1] on the 16-byte MD5 result.  The signature
    is\n   computed using the RSA private key retrieved from the credentials\n   structure
    and the result (whose length is implied by the \"modulus\"\n   parameter in the
    private key) is stored in the int-cksum field.\n   If the int-alg specifies a
    keyed hashing algorithm (for example,\n   DES-MAC or md5-DES-CBC), then the key
    to be used is the appropriate\n   subkey derived from the context key (see Section
    2.4).  Again, the\n   result (whose length is implied by int-alg) is stored in
    the int-\n   cksum field.\n"
  title: 3.2.1.1. Checksum
- contents:
  - "3.2.1.2. Sequence Number\n   It is assumed that the underlying transport layers
    (of whatever\n   protocol stack is being used by the application) will provide\n
    \  adequate communications reliability (that is, non-malicious loss,\n   re-ordering,
    etc., of data packets will be handled correctly).\n   Therefore, sequence numbers
    are used in SPKM purely for security, as\n   opposed to reliability, reasons (that
    is, to avoid malicious loss,\n   replay, or re-ordering of SPKM tokens) -- it
    is therefore recommended\n   that applications request sequencing and replay detection
    over all\n   contexts.  Note that sequence numbers are used so that there is no\n
    \  requirement for secure timestamps in the message tokens.  The\n   initiator's
    initial sequence number for the current context may be\n   explicitly given in
    the Context-Data field of SPKM-REQ and the\n   target's initial sequence number
    may be explicitly given in the\n   Context-Data field of SPKM-REP-TI; if either
    of these is not given\n   then the default value of 00 is to be used.\n   Sequence
    number field: The sequence number field is formed from the\n   sender's four-byte
    sequence number and a Boolean direction-indicator\n   (FALSE - sender is the context
    initiator, TRUE - sender is the\n   context acceptor).  After constructing a gss_sign/getMIC()
    or\n   gss_seal/wrap() token, the sender's seq. number is incremented by 1.\n"
  title: 3.2.1.2. Sequence Number
- contents:
  - "3.2.1.3. Sequence Number Processing\n   The receiver of the token will verify
    the sequence number field by\n   comparing the sequence number with the expected
    sequence number and\n   the direction indicator with the expected direction indicator.
    \ If\n   the sequence number in the token is higher than the expected number,\n
    \  then the expected sequence number is adjusted and GSS_S_GAP_TOKEN is\n   returned.
    \ If the token sequence number is lower than the expected\n   number, then the
    expected sequence number is not adjusted and\n   GSS_S_DUPLICATE_TOKEN, GSS_S_UNSEQ_TOKEN,
    or GSS_S_OLD_TOKEN is\n   returned, whichever is appropriate.  If the direction
    indicator is\n   wrong, then the expected sequence number is not adjusted and\n
    \  GSS_S_UNSEQ_TOKEN is returned.\n   Since the sequence number is used as part
    of the input to the\n   integrity checksum, sequence numbers need not be encrypted,
    and\n   attempts to splice a checksum and sequence number from different\n   messages
    will be detected.  The direction indicator will detect\n   tokens which have been
    maliciously reflected.\n"
  title: 3.2.1.3. Sequence Number Processing
- contents:
  - "3.2.2. Per-message Tokens - Seal / Wrap\n   Use of the gss_seal() / gss_wrap()
    call yields a token which\n   encapsulates the input user data (optionally encrypted)
    along with\n   associated integrity check quantities. The token emitted by\n   gss_seal()
    / gss_wrap() consists of an integrity header followed by a\n   body portion that
    contains either the plaintext data (if conf-alg =\n   NULL) or encrypted data
    (using the appropriate subkey specified in\n   Section 2.4 for one of the agreed
    C-ALGs for this context).\n   The SPKM-WRAP token has the following format:\n
    \  SPKM-WRAP ::= SEQUENCE {\n           wrap-header       Wrap-Header,\n           wrap-body
    \        Wrap-Body\n   }\n   Wrap-Header ::= SEQUENCE {\n           tok-id           INTEGER
    (513),\n                                -- shall contain 0201 (hex)\n           context-id
    \      Random-Integer,\n           int-alg [0]      AlgorithmIdentifier OPTIONAL,\n
    \                               -- Integrity algorithm indicator (must\n                                --
    be one of the agreed integrity\n                                -- algorithms
    for this context).\n                                -- field not present = default
    id.\n           conf-alg [1]     Conf-Alg OPTIONAL,\n                                --
    Confidentiality algorithm indicator\n                                -- (must
    be NULL or one of the agreed\n                                -- confidentiality
    algorithms for this\n                                -- context).\n                                --
    field not present = default id.\n                                -- NULL = none
    (no conf. applied).\n           snd-seq [2]      SeqNum OPTIONAL\n                                --
    sequence number field.\n   }\n   Wrap-Body ::= SEQUENCE {\n           int-cksum
    \       BIT STRING,\n                                -- Checksum of header and
    data,\n                                -- calculated according to algorithm\n
    \                               -- specified in int-alg field.\n           data
    \            BIT STRING\n                                -- encrypted or plaintext
    data.\n   }\n   Conf-Alg ::= CHOICE {\n           algId [0]        AlgorithmIdentifier,\n
    \          null [1]         NULL\n   }\n"
  title: 3.2.2. Per-message Tokens - Seal / Wrap
- contents:
  - "3.2.2.1: Confounding\n   As in [KRB5], an 8-byte random confounder is prepended
    to the data to\n   compensate for the fact that an IV of zero is used for encryption.\n
    \  The result is referred to as the \"confounded\" data field.\n"
  title: '3.2.2.1: Confounding'
- contents:
  - "3.2.2.2. Checksum\n   Checksum calculation procedure (common to all algorithms):
    Checksums\n   are calculated over the plaintext data field, logically prepended
    by\n   the bytes of the plaintext token header (wrap-header).  As with\n   gss_sign()
    / gss_getMIC(), the result binds the data to the entire\n   plaintext header,
    so as to minimize the possibility of malicious\n   splicing.\n   The examples
    for md5WithRSA and DES-MAC are exactly as specified in\n   3.2.1.1.\n   If int-alg
    specifies md5-DES-CBC and conf-alg specifies anything\n   other than DES-CBC,
    then the checksum is computed according to\n   3.2.1.1 and the result is stored
    in int-cksum.  However, if conf-alg\n   specifies DES-CBC then the encryption
    and the integrity are done as\n   follows.  An MD5 [RFC-1321] hash is computed
    over the plaintext data\n   (prepended by the header).  This 16-byte value is
    appended to the\n   concatenation of the \"confounded\" data and 1-8 padding bytes
    (the\n   padding is as specified in [KRB5] for DES-CBC).  The result is then\n
    \  CBC encrypted using the DES-CBC subkey (see Section 2.4) and placed\n   in
    the \"data\" field of Wrap-Body.  The final two blocks of ciphertext\n   (i.e.,
    the encrypted MD5 hash) are also placed in the int-cksum field\n   of Wrap-Body
    as the integrity checksum.\n   If int-alg specifies sum64-DES-CBC then conf-alg
    must specify DES-CBC\n   (i.e., confidentiality must be requested by the calling
    application\n   or SPKM will return an error).  Encryption and integrity are done
    in\n   a single pass using the DES-CBC subkey as follows.  The sum (modulo\n   2**64
    - 1) of all plaintext data blocks (prepended by the header) is\n   computed.  This
    8-byte value is appended to the concatenation of the\n   \"confounded\" data and
    1-8 padding bytes (the padding is as specified\n   in [KRB5] for DES-CBC).  As
    above, the result is then CBC encrypted\n   and placed in the \"data\" field of
    Wrap-Body. The final block of\n   ciphertext (i.e., the encrypted sum) is also
    placed in the int-cksum\n   field of Wrap-Body as the integrity checksum.\n"
  title: 3.2.2.2. Checksum
- contents:
  - "3.2.2.3 Sequence Number\n   Sequence numbers are computed and processed for gss_wrap()
    exactly as\n   specified in 3.2.1.2 and 3.2.1.3.\n"
  title: 3.2.2.3 Sequence Number
- contents:
  - "3.2.2.4: Data Encryption\n   The following procedure is followed unless (a) conf-alg
    is NULL (no\n   encryption), or (b) conf-alg is DES-CBC and int-alg is md5-DES-CBC\n
    \  (encryption as specified in 3.2.2.2), or (c) int-alg is sum64-DES-CBC\n   (encryption
    as specified in 3.2.2.2):\n   The \"confounded\" data is padded and encrypted
    according to the\n   algorithm specified in the conf-alg field.  The data is encrypted\n
    \  using CBC with an IV of zero.  The key used is the appropriate subkey\n   derived
    from the established context key using the subkey derivation\n   algorithm described
    in Section 2.4 (this ensures that the subkey used\n   for encryption and the subkey
    used for a separate, keyed integrity\n   algorithm -- for example DES-MAC, but
    not sum64-DES-CBC -- are\n   different).\n"
  title: '3.2.2.4: Data Encryption'
- contents:
  - "3.2.3. Context deletion token\n   The token emitted by gss_delete_sec_context()
    is based on the format\n   for tokens emitted by gss_sign() / gss_getMIC().\n
    \  The SPKM-DEL token has the following format:\n   SPKM-DEL ::= SEQUENCE {\n
    \          del-header       Del-Header,\n           int-cksum        BIT STRING\n
    \                               -- Checksum of header, calculated\n                                --
    according to algorithm specified\n                                -- in int-alg
    field.\n   }\n   Del-Header ::= SEQUENCE {\n           tok-id           INTEGER
    (769),\n                                -- shall contain 0301 (hex)\n           context-id
    \      Random-Integer,\n           int-alg [0]      AlgorithmIdentifier OPTIONAL,\n
    \                               -- Integrity algorithm indicator (must\n                                --
    be one of the agreed integrity\n                                -- algorithms
    for this context).\n                                -- field not present = default
    id.\n           snd-seq [1]      SeqNum OPTIONAL\n                                --
    sequence number field.\n   }\n   The field snd-seq will be calculated as for tokens
    emitted by\n   gss_sign() / gss_getMIC().  The field int-cksum will be calculated
    as\n   for tokens emitted by gss_sign() / gss_getMIC(), except that the\n   user-data
    component of the checksum data will be a zero-length\n   string.\n   If a valid
    delete token is received, then the SPKM implementation\n   will delete the context
    and gss_process_context_token() will return a\n   major status of GSS_S_COMPLETE
    and a minor status of\n   GSS_SPKM_S_SG_CONTEXT_DELETED.  If, on the other hand,
    the delete\n   token is invalid, the context will not be deleted and\n   gss_process_context_token()
    will return the appropriate major status\n   (GSS_S_BAD_SIG, for example) and
    a minor status of\n   GSS_SPKM_S_SG_BAD_DELETE_TOKEN_RECD.  The application may
    wish to\n   take some action at this point to check the context status (such as\n
    \  sending a sealed/wrapped test message to its peer and waiting for a\n   sealed/wrapped
    response).\n"
  title: 3.2.3. Context deletion token
- contents:
  - "4. Name Types and Object Identifiers\n   No mandatory name forms have yet been
    defined for SPKM.  This section\n   is for further study.\n"
  title: 4. Name Types and Object Identifiers
- contents:
  - "4.1. Optional Name Forms\n   This section discusses name forms which may optionally
    be supported\n   by implementations of the SPKM GSS-API mechanism.  It is recognized\n
    \  that OS-specific functions outside GSS-API are likely to exist in\n   order
    to perform translations among these forms, and that GSS-API\n   implementations
    supporting these forms may themselves be layered atop\n   such OS-specific functions.
    \ Inclusion of this support within GSS-API\n   implementations is intended as
    a convenience to applications.\n"
  title: 4.1. Optional Name Forms
- contents:
  - "4.1.1. User Name Form\n   This name form shall be represented by the Object Identifier
    {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n
    \  generic(1) user_name(1)}.  The recommended symbolic name for this\n   type
    is \"GSS_SPKM_NT_USER_NAME\".\n   This name type is used to indicate a named user
    on a local system.\n   Its interpretation is OS-specific.  This name form is constructed
    as:\n      username\n"
  title: 4.1.1. User Name Form
- contents:
  - "4.1.2. Machine UID Form\n   This name form shall be represented by the Object
    Identifier {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1)
    gssapi(2)\n   generic(1) machine_uid_name(2)}.  The recommended symbolic name
    for\n   this type is \"GSS_SPKM_NT_MACHINE_UID_NAME\".\n   This name type is used
    to indicate a numeric user identifier\n   corresponding to a user on a local system.
    \ Its interpretation is\n   OS-specific.  The gss_buffer_desc representing a name
    of this type\n   should contain a locally-significant uid_t, represented in host
    byte\n   order.  The gss_import_name() operation resolves this uid into a\n   username,
    which is then treated as the User Name Form.\n"
  title: 4.1.2. Machine UID Form
- contents:
  - "4.1.3. String UID Form\n   This name form shall be represented by the Object
    Identifier {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1)
    gssapi(2)\n   generic(1) string_uid_name(3)}.  The recommended symbolic name for\n
    \  this type is \"GSS_SPKM_NT_STRING_UID_NAME\".\n   This name type is used to
    indicate a string of digits representing\n   the numeric user identifier of a
    user on a local system.  Its\n   interpretation is OS-specific. This name type
    is similar to the\n   Machine UID Form, except that the buffer contains a string\n
    \  representing the uid_t.\n"
  title: 4.1.3. String UID Form
- contents:
  - "5. Parameter Definitions\n   This section defines parameter values used by the
    SPKM GSS-API\n   mechanism.  It defines interface elements in support of portability.\n"
  title: 5. Parameter Definitions
- contents:
  - "5.1. Minor Status Codes\n   This section recommends common symbolic names for
    minor_status values\n   to be returned by the SPKM GSS-API mechanism.  Use of
    these\n   definitions will enable independent implementors to enhance\n   application
    portability across different implementations of the\n   mechanism defined in this
    specification.  (In all cases,\n   implementations of gss_display_status() will
    enable callers to\n   convert minor_status indicators to text representations.)
    Each\n   implementation must make available, through include files or other\n
    \  means, a facility to translate these symbolic names into the concrete\n   values
    which a particular GSS-API implementation uses to represent\n   the minor_status
    values specified in this section.  It is recognized\n   that this list may grow
    over time, and that the need for additional\n   minor_status codes specific to
    particular implementations may arise.\n"
  title: 5.1. Minor Status Codes
- contents:
  - '5.1.1. Non-SPKM-specific codes (Minor Status Code MSB, bit 31, SET)

    '
  title: 5.1.1. Non-SPKM-specific codes (Minor Status Code MSB, bit 31, SET)
- contents:
  - "5.1.1.1. GSS-Related codes (Minor Status Code bit 30 SET)\n   GSS_S_G_VALIDATE_FAILED\n
    \      /* \"Validation error\" */\n   GSS_S_G_BUFFER_ALLOC\n       /* \"Couldn't
    allocate gss_buffer_t data\" */\n   GSS_S_G_BAD_MSG_CTX\n       /* \"Message context
    invalid\" */\n   GSS_S_G_WRONG_SIZE\n       /* \"Buffer is the wrong size\" */\n
    \  GSS_S_G_BAD_USAGE\n       /* \"Credential usage type is unknown\" */\n   GSS_S_G_UNAVAIL_QOP\n
    \      /* \"Unavailable quality of protection specified\" */\n"
  title: 5.1.1.1. GSS-Related codes (Minor Status Code bit 30 SET)
- contents:
  - "5.1.1.2. Implementation-Related codes (Minor Status Code bit 30 OFF)\n   GSS_S_G_MEMORY_ALLOC\n
    \      /* \"Couldn't perform requested memory allocation\" */\n"
  title: 5.1.1.2. Implementation-Related codes (Minor Status Code bit 30 OFF)
- contents:
  - "5.1.2. SPKM-specific-codes (Minor Status Code MSB, bit 31, OFF)\n   GSS_SPKM_S_SG_CONTEXT_ESTABLISHED\n
    \      /* \"Context is already fully established\" */\n   GSS_SPKM_S_SG_BAD_INT_ALG_TYPE\n
    \      /* \"Unknown integrity algorithm type in token\" */\n   GSS_SPKM_S_SG_BAD_CONF_ALG_TYPE\n
    \      /* \"Unknown confidentiality algorithm type in token\" */\n   GSS_SPKM_S_SG_BAD_KEY_ESTB_ALG_TYPE\n
    \      /* \"Unknown key establishment algorithm type in token\" */\n   GSS_SPKM_S_SG_CTX_INCOMPLETE\n
    \      /* \"Attempt to use incomplete security context\" */\n   GSS_SPKM_S_SG_BAD_INT_ALG_SET\n
    \      /* \"No integrity algorithm in common from offered set\" */\n   GSS_SPKM_S_SG_BAD_CONF_ALG_SET\n
    \      /* \"No confidentiality algorithm in common from offered set\" */\n   GSS_SPKM_S_SG_BAD_KEY_ESTB_ALG_SET\n
    \      /* \"No key establishment algorithm in common from offered set\" */\n   GSS_SPKM_S_SG_NO_PVNO_IN_COMMON\n
    \      /* \"No protocol version number in common from offered set\" */\n   GSS_SPKM_S_SG_INVALID_TOKEN_DATA\n
    \      /* \"Data is improperly formatted:  cannot encode into token\" */\n   GSS_SPKM_S_SG_INVALID_TOKEN_FORMAT\n
    \      /* \"Received token is improperly formatted:  cannot decode\" */\n   GSS_SPKM_S_SG_CONTEXT_DELETED\n
    \      /* \"Context deleted at peer's request\" */\n   GSS_SPKM_S_SG_BAD_DELETE_TOKEN_RECD\n
    \      /* \"Invalid delete token received -- context not deleted\" */\n   GSS_SPKM_S_SG_CONTEXT_ESTB_ABORT\n
    \     /* \"Unrecoverable context establishment error. Context deleted\" */\n"
  title: 5.1.2. SPKM-specific-codes (Minor Status Code MSB, bit 31, OFF)
- contents:
  - "5.2. Quality of Protection Values\n   The Quality of Protection (QOP) parameter
    is used in the SPKM GSS-API\n   mechanism as input to gss_sign() and gss_seal()
    (gss_getMIC() and\n   gss_wrap()) to select among alternate confidentiality and
    integrity-\n   checking algorithms.  Once these sets of algorithms have been agreed\n
    \  upon by the context initiator and target, the QOP parameter simply\n   selects
    from these ordered sets.\n   More specifically, the SPKM-REQ token sends an ordered
    sequence of\n   Alg. IDs specifying integrity-checking algorithms supported by
    the\n   initiator and an ordered sequence of Alg. IDs specifying\n   confidentiality
    algorithms supported by the initiator.  The target\n   returns the subset of the
    offered integrity-checking Alg. IDs which\n   it supports and the subset of the
    offered confidentiality Alg. IDs\n   which it supports in the SPKM-REP-TI token
    (in the same relative\n   orders as those given by the initiator).  Thus, the
    initiator and\n   target each know the algorithms which they themselves support
    and the\n   algorithms which both sides support (the latter are defined to be\n
    \  those supported over the established context).  The QOP parameter has\n   meaning
    and validity with reference to this knowledge.  For example,\n   an application
    may request integrity algorithm number 3 as defined by\n   the mechanism specification.
    \ If this algorithm is supported over\n   this context then it is used; otherwise,
    GSS_S_FAILURE and an\n   appropriate minor status code are returned.\n   If the
    SPKM-REP-TI token is not used (unilateral authentication using\n   SPKM-2), then
    the \"agreed\" sets of Alg. IDs are simply taken to be\n   the initiator's sets
    (if this is unacceptable to the target then it\n   must return an error token
    so that the context is never established).\n   Note that, in the interest of interoperability,
    the initiator is not\n   required to offer every algorithm it supports; rather,
    it may offer\n   only the mandated/recommended SPKM algorithms since these are
    likely\n   to be supported by the target.\n   The QOP parameter for SPKM is defined
    to be a 32-bit unsigned integer\n   (an OM_uint32) with the following bit-field
    assignments:\n Confidentiality                     Integrity\n 31 (MSB)                         16
    15                         (LSB) 0\n"
  title: 5.2. Quality of Protection Values
- contents:
  - '------------------------------------|-----------------------------------

    '
  title: '------------------------------------|-----------------------------------'
- contents:
  - '|  TS (5)  | U(3) | IA (4) | MA (4) |  TS (5)  | U(3) | IA (4) | MA(4) |

    '
  title: '|  TS (5)  | U(3) | IA (4) | MA (4) |  TS (5)  | U(3) | IA (4) | MA(4) |'
- contents:
  - "------------------------------------|-----------------------------------\n   where\n
    \     TS is a 5-bit Type Specifier (a semantic qualifier whose value\n      specifies
    the type of algorithm which may be used to protect the\n      corresponding token
    -- see below for details);\n      U is a 3-bit Unspecified field (available for
    future\n      use/expansion);\n      IA is a 4-bit field enumerating Implementation-specific\n
    \     Algorithms; and\n      MA is a 4-bit field enumerating Mechanism-defined
    Algorithms.\n   The interpretation of the QOP parameter is as follows (note that
    the\n   same procedure is used for both the confidentiality and the integrity\n
    \  halves of the parameter).  The MA field is examined first.  If it is\n   non-zero
    then the algorithm used to protect the token is the\n   mechanism-specified algorithm
    corresponding to that integer value.\n   If MA is zero then IA is examined.  If
    this field value is non-zero\n   then the algorithm used to protect the token
    is the implementation-\n   specified algorithm corresponding to that integer value
    (if this\n   algorithm is available over the established context).  Note that
    use\n   of this field may hinder portability since a particular value may\n   specify
    one algorithm in one implementation of the mechanism and may\n   not be supported
    or may specify a completely different algorithm in\n   another implementation
    of the mechanism.\n   Finally, if both MA and IA are zero then TS is examined.
    \ A value of\n   zero for TS specifies the default algorithm for the established\n
    \  context, which is defined to be the first algorithm on the\n   initiator's
    list of offered algorithms (confidentiality or integrity,\n   depending on which
    half of QOP is being examined) which is supported\n   over the context.  A non-zero
    value for TS corresponds to a\n   particular algorithm qualifier and selects the
    first algorithm\n   supported over the context which satisfies that qualifier.\n
    \  The following TS values (i.e., algorithm qualifiers) are specified;\n   other
    values may be added in the future.\n      For the Confidentiality TS field:\n
    \        00001 (1) = SPKM_SYM_ALG_STRENGTH_STRONG\n         00010 (2) = SPKM_SYM_ALG_STRENGTH_MEDIUM\n
    \        00011 (3) = SPKM_SYM_ALG_STRENGTH_WEAK\n      For the Integrity TS field:\n
    \        00001 (1) = SPKM_INT_ALG_NON_REP_SUPPORT\n         00010 (2) = SPKM_INT_ALG_REPUDIABLE\n
    \  Clearly, qualifiers such as strong, medium, and weak are debatable\n   and
    likely to change with time, but for the purposes of this version\n   of the specification
    we define these terms as follows.  A\n   confidentiality algorithm is \"weak\"
    if the effective key length of\n   the cipher is 40 bits or less; it is \"medium-strength\"
    if the\n   effective key length is strictly between 40 and 80 bits; and it is\n
    \  \"strong\" if the effective key length is 80 bits or greater.  (Note\n   that
    \"effective key length\" describes the computational effort\n   required to break
    a cipher using the best-known cryptanalytic attack\n   against that cipher.)\n
    \  A five-bit TS field allows up to 31 qualifiers for each of\n   confidentiality
    and integrity (since \"0\" is reserved for \"default\").\n   This document specifies
    three for confidentiality and two for\n   integrity, leaving a lot of room for
    future specification.\n   Suggestions of qualifiers such as \"fast\", \"medium-speed\",
    and \"slow\"\n   have been made, but such terms are difficult to quantify (and
    in any\n   case are platform- and processor-dependent), and so have been left\n
    \  out of this initial specification.  The intention is that the TS\n   terms
    be quantitative, environment-independent qualifiers of\n   algorithms, as much
    as this is possible.\n   Use of the QOP structure as defined above is ultimately
    meant to be\n   as follows.\n    - TS values are specified at the GSS-API level
    and are therefore\n      portable across mechanisms.  Applications which know
    nothing about\n      algorithms are still able to choose \"quality\" of protection
    for\n      their message tokens.\n    - MA values are specified at the mechanism
    level and are therefore\n      portable across implementations of a mechanism.
    \ For example, all\n      implementations of the Kerberos V5 GSS mechanism must
    support\n         GSS_KRB5_INTEG_C_QOP_MD5     (value: 1)\n         GSS_KRB5_INTEG_C_QOP_DES_MD5
    (value: 2)\n         GSS_KRB5_INTEG_C_QOP_DES_MAC (value: 3).\n      (Note that
    these Kerberos-specified integrity QOP values do not\n      conflict with the
    QOP structure defined above.)\n    - IA values are specified at the implementation
    level (in user\n      documentation, for example) and are therefore typically
    non-\n      portable.  An application which is aware of its own mechanism\n      implementation
    and the mechanism implementation of its peer,\n      however, is free to use these
    values since they will be perfectly\n      valid and meaningful over that context
    and between those peers.\n   The receiver of a token must pass back to its calling
    application a\n   QOP parameter with all relevant fields set.  For example, if
    triple-\n   DES has been specified by a mechanism as algorithm 8, then a receiver\n
    \  of a triple-DES-protected token must pass to its application (QOP\n   Confidentiality
    TS=1, IA=0, MA=8).  In this way, the application is\n   free to read whatever
    part of the QOP it understands (TS or IA/MA).\n   To aid in implementation and
    interoperability, the following\n   stipulation is made.  The set of integrity
    Alg. IDs sent by the\n   initiator must contain at least one specifying an algorithm
    which\n   computes a digital signature supporting non-repudiation, and must\n
    \  contain at least one specifying any other (repudiable) integrity\n   algorithm.
    \ The subset of integrity Alg. IDs returned by the target\n   must also contain
    at least one specifying an algorithm which computes\n   a digital signature supporting
    non-repudiation, and at least one\n   specifying a repudiable integrity algorithm.\n
    \  The reason for this stipulation is to ensure that every SPKM\n   implementation
    will provide an integrity service which supports non-\n   repudiation and one
    which does not support non-repudiation.  An\n   application with no knowledge
    of underlying algorithms can choose one\n   or the other by passing (QOP Integrity
    TS=1, IA=MA=0) or (QOP\n   Integrity TS=2, IA=MA=0).  Although an initiator who
    wishes to remain\n   anonymous will never actually use the non-repudiable digital\n
    \  signature, this integrity service must be available over the context\n   so
    that the target can use it if desired.\n   Finally, in accordance with the MANDATORY
    and RECOMMENDED algorithms\n   given in Section 2, the following QOP values are
    specified for SPKM.\n   For the Confidentiality MA field:\n      0001 (1) = DES-CBC\n
    \  For the Integrity MA field:\n      0001 (1) = md5WithRSA\n      0010 (2) =
    DES-MAC\n"
  title: '------------------------------------|-----------------------------------'
- contents:
  - "6. Support Functions\n   This section describes a mandatory support function
    for SPKM-\n   conformant implementations which may, in fact, be of value in all\n
    \  GSS-API mechanisms.  It makes use of the token-id and context-id\n   information
    which is included in SPKM context-establishment, error,\n   context-deletion,
    and per-message tokens.  The function is defined in\n   the following section.\n"
  title: 6. Support Functions
- contents:
  - "6.1. SPKM_Parse_token call\n   Inputs:\n   o  input_token OCTET STRING\n   Outputs:\n
    \  o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  mech_type OBJECT
    IDENTIFIER,\n   o  token_type INTEGER,\n   o  context_handle CONTEXT HANDLE,\n
    \  Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the input_token
    could be parsed for\n      all relevant fields.  The resulting values are stored
    in\n      mech_type, token_type and context_handle, respectively (with NULLs\n
    \     in any parameters which are not relevant).\n   o  GSS_S_DEFECTIVE_TOKEN
    indicates that either the token-id or the\n      context-id (if it was expected)
    information could not be parsed.\n      A non-NULL return value in token_type
    indicates that the latter\n      situation occurred.\n   o  GSS_S_NO_TYPE indicates
    that the token-id information could be\n      parsed, but it did not correspond
    to any valid token_type.\n      (Note that this major status code has not been
    defined for GSS in\n      RFC-1508.  Until such a definition is made (if ever),
    SPKM\n      implementations should instead return GSS_S_DEFECTIVE_TOKEN with\n
    \     both token_type and context_handle set to NULL.  This essentially\n      implies
    that unrecognized token-id information is considered to be\n      equivalent to
    token-id information which could not be parsed.)\n   o  GSS_S_NO_CONTEXT indicates
    that the context-id could be parsed,\n      but it did not correspond to any valid
    context_handle.\n   o  GSS_S_FAILURE indicates that the mechanism type could not
    be\n      parsed (for example, the token may be corrupted).\n   SPKM_Parse_token()
    is used to return to an application the mechanism\n   type, token type, and context
    handle which correspond to a given\n   input token.  Since GSS-API tokens are
    meant to be opaque to the\n   calling application, this function allows the application
    to\n   determine information about the token without having to violate the\n   opaqueness
    intention of GSS.  Of primary importance is the token\n   type, which the application
    can then use to decide which GSS function\n   to call in order to have the token
    processed.\n   If all tokens are framed as suggested in RFC-1508, Appendix B\n
    \  (specified both in the Kerberos V5 GSS mechanism [KRB5] and in this\n   document),
    then any mechanism implementation should be able to return\n   at least the mech_type
    parameter (the other parameters being NULL)\n   for any uncorrupted input token.
    \ If the mechanism implementation\n   whose SPKM_Parse_token() function is being
    called does recognize the\n   token, it can return token_type so that the application
    can\n   subsequently call the correct GSS function.  Finally, if the\n   mechanism
    provides a context-id field in its tokens (as SPKM does),\n   then an implementation
    can map the context-id to a context_handle and\n   return this to the application.
    \ This is necessary for the situation\n   where an application has multiple contexts
    open simultaneously, all\n   using the same mechanism.  When an incoming token
    arrives, the\n   application can use this function to determine not only which
    GSS\n   function to call, but also which context_handle to use for the call.\n
    \  Note that this function does no cryptographic processing to determine\n   the
    validity of tokens; it simply attempts to parse the mech_type,\n   token_type,
    and context-id fields of any token it is given.  Thus, it\n   is conceivable,
    for example, that an arbitrary buffer of data might\n   start with random values
    which look like a valid mech_type and that\n   SPKM_Parse_token() would return
    incorrect information if given this\n   buffer.  While conceivable, however, such
    a situation is unlikely.\n   The SPKM_Parse_token() function is mandatory for
    SPKM-conformant\n   implementations, but it is optional for applications.  That
    is, if an\n   application has only one context open and can guess which GSS\n
    \  function to call (or is willing to put up with some error codes),\n   then
    it need never call SPKM_Parse_token().  Furthermore, if this\n   function ever
    migrates up to the GSS-API level, then\n   SPKM_Parse_token() will be deprecated
    at that time in favour of\n   GSS_Parse_token(), or whatever the new name and
    function\n   specification might be.  Note finally that no minor status return\n
    \  codes have been defined for this function at this time.\n"
  title: 6.1. SPKM_Parse_token call
- contents:
  - "6.2. The token_type Output Parameter\n   The following token types are defined:\n
    \     GSS_INIT_TOKEN   = 1\n      GSS_ACCEPT_TOKEN = 2\n      GSS_ERROR_TOKEN
    \ = 3\n      GSS_SIGN_TOKEN   = GSS_GETMIC_TOKEN = 4\n      GSS_SEAL_TOKEN   =
    GSS_WRAP_TOKEN   = 5\n      GSS_DELETE_TOKEN = 6\n   All SPKM mechanisms shall
    be able to perform the mapping from the\n   token-id information which is included
    in every token (through the\n   tag values in SPKMInnerContextToken or through
    the tok-id field) to\n   one of the above token types.  Applications should be
    able to decide,\n   on the basis of token_type, which GSS function to call (for
    example,\n   if the token is a GSS_INIT_TOKEN then the application will call\n
    \  gss_accept_sec_context(), and if the token is a GSS_WRAP_TOKEN then\n   the
    application will call gss_unwrap()).\n"
  title: 6.2. The token_type Output Parameter
- contents:
  - "6.3. The context_handle Output Parameter\n   The SPKM mechanism implementation
    is responsible for maintaining a\n   mapping between the context-id value which
    is included in every token\n   and a context_handle, thus associating an individual
    token with its\n   proper context.  Clearly the value of context_handle may be
    locally\n   determined and may, in fact, be associated with memory containing\n
    \  sensitive data on the local system, and so having the context-id\n   actually
    be set equal to a computed context_handle will not work in\n   general.  Conversely,
    having the context_handle actually be set equal\n   to a computed context-id will
    not work in general either, because\n   context_handle must be returned to the
    application by the first call\n   to gss_init_sec_context() or gss_accept_sec_context(),
    whereas\n   uniqueness of the context-id (over all contexts at both ends) may\n
    \  require that both initiator and target be involved in the\n   computation.
    \ Consequently, context_handle and context-id must be\n   computed separately
    and the mechanism implementation must be able to\n   map from one to the other
    by the completion of context establishment\n   at the latest.\n   Computation
    of context-id during context establishment is\n   accomplished as follows.  Each
    SPKM implementation is responsible for\n   generating a \"fresh\" random number;
    that is, one which (with high\n   probability) has not been used previously.  Note
    that there are no\n   cryptographic requirements on this random number (i.e.,
    it need not\n   be unpredictable, it simply needs to be fresh).  The initiator
    passes\n   its random number to the target in the context-id field of the SPKM-\n
    \  REQ token.  If no further context establishment tokens are expected\n   (as
    for unilateral authentication in SPKM-2), then this value is\n   taken to be the
    context-id (if this is unacceptable to the target\n   then an error token must
    be generated).  Otherwise, the target\n   generates its random number and concatenates
    it to the end of the\n   initiator's random number.  This concatenated value is
    then taken to\n   be the context-id and is used in SPKM-REP-TI and in all subsequent\n
    \  tokens over that context.\n   Having both peers contribute to the context-id
    assures each peer of\n   freshness and therefore precludes replay attacks between
    contexts\n   (where a token from an old context between two peers is maliciously\n
    \  injected into a new context between the same or different peers).\n   Such
    assurance is not available to the target in the case of\n   unilateral authentication
    using SPKM-2, simply because it has not\n   contributed to the freshness of the
    computed context-id (instead, it\n   must trust the freshness of the initiator's
    random number, or reject\n   the context).  The key-src-bind field in SPKM-REQ
    is required to be\n   present for the case of SPKM-2 unilateral authentication
    precisely to\n   assist the target in trusting the freshness of this token (and
    its\n   proposed context key).\n"
  title: 6.3. The context_handle Output Parameter
- contents:
  - "7. Security Considerations\n   Security issues are discussed throughout this
    memo.\n"
  title: 7. Security Considerations
- contents:
  - "8. References\n   [Davi89]:    D. W. Davies and W. L. Price, \"Security for Computer\n
    \  Networks\", Second Edition, John Wiley and Sons, New York, 1989.\n   [FIPS-113]:
    \ National Bureau of Standards, Federal Information\n   Processing Standard 113,
    \"Computer Data Authentication\", May 1985.\n   [GSSv2]:     Linn, J., \"Generic
    Security Service Application Program\n   Interface Version 2\", Work in Progress.\n
    \  [Juen84]:    R. R. Jueneman, C. H. Meyer and S. M. Matyas, Message\n   Authentication
    with Manipulation Detection Codes, in Proceedings of\n   the 1983 IEEE Symposium
    on Security and Privacy, IEEE Computer\n   Society Press, 1984, pp.33-54.\n   [KRB5]:
    \     Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\",\n   RFC 1964, June
    1996.\n   [PKCS1]:     RSA Encryption Standard, Version 1.5, RSA Data Security,\n
    \  Inc., Nov. 1993.\n   [PKCS3]:     Diffie-Hellman Key-Agreement Standard, Version
    1.4, RSA\n   Data Security, Inc., Nov. 1993.\n   [RFC-1321]:  Rivest, R., \"The
    MD5 Message-Digest Algorithm\", RFC 1321.\n   [RFC-1422]:  Kent, S., \"Privacy
    Enhancement for Internet Electronic\n   Mail:  Part II: Certificate-Based Key
    Management\", RFC 1422.\n   [RFC-1423]:  Balenson, D., \"Privacy Enhancement for
    Internet\n   Elecronic Mail: Part III: Algorithms, Modes, and Identifiers\",\n
    \  RFC 1423.\n   [RFC-1508]:  Linn, J., \"Generic Security Service Application
    Program\n   Interface\", RFC 1508.\n   [RFC-1509]:  Wray, J., \"Generic Security
    Service Application Program\n   Interface: C-bindings\", RFC 1509.\n   [RFC-1510]:
    \ Kohl J., and C. Neuman, \"The Kerberos Network\n   Authentication Service (V5)\",
    RFC 1510.\n   [9798]:      ISO/IEC 9798-3, \"Information technology - Security\n
    \  Techniques - Entity authentication mechanisms - Part 3:  Entitiy\n   authentication
    using a public key algorithm\", ISO/IEC, 1993.\n   [X.501]:     ISO/IEC 9594-2,
    \"Information Technology - Open Systems\n   Interconnection - The Directory:  Models\",
    CCITT/ITU Recommendation\n   X.501, 1993.\n   [X.509]:     ISO/IEC 9594-8, \"Information
    Technology - Open Systems\n   Interconnection - The Directory:  Authentication
    Framework\",\n   CCITT/ITU Recommendation X.509, 1993.\n   [X9.44]:     ANSI,
    \"Public Key Cryptography Using Reversible\n    Algorithms for the Financial Services
    Industry:  Transport of\n   Symmetric Algorithm Keys Using RSA\", X9.44-1993.\n"
  title: 8. References
- contents:
  - "9. Author's Address\n   Carlisle Adams\n   Bell-Northern Research\n   P.O.Box
    3511, Station C\n   Ottawa, Ontario, CANADA  K1Y 4H7\n   Phone: +1 613.763.9008\n
    \  EMail: cadams@bnr.ca\n"
  title: 9. Author's Address
- contents:
  - 'Appendix A:  ASN.1 Module Definition

    '
  - "SpkmGssTokens {iso(1) identified-organization(3) dod(6) internet(1)\n               security(5)
    mechanisms(5) spkm(1) spkmGssTokens(10)}\n"
  - 'DEFINITIONS IMPLICIT TAGS ::=

    '
  - 'BEGIN

    '
  - '-- EXPORTS ALL --

    '
  - "IMPORTS\n   Name\n      FROM InformationFramework {joint-iso-ccitt(2) ds(5) module(1)\n
    \                               informationFramework(1) 2}\n   Certificate, CertificateList,
    CertificatePair, AlgorithmIdentifier,\n   Validity\n      FROM AuthenticationFramework
    {joint-iso-ccitt(2) ds(5) module(1)\n                                   authenticationFramework(7)
    2}  ;\n"
  - "-- types --\n   SPKM-REQ ::= SEQUENCE {\n           requestToken      REQ-TOKEN,\n
    \          certif-data [0]   CertificationData OPTIONAL,\n           auth-data
    [1]     AuthorizationData OPTIONAL\n   }\n   CertificationData ::= SEQUENCE {\n
    \          certificationPath [0]          CertificationPath OPTIONAL,\n           certificateRevocationList
    [1]  CertificateList OPTIONAL\n   } -- at least one of the above shall be present\n
    \  CertificationPath ::= SEQUENCE {\n           userKeyId [0]         OCTET STRING
    OPTIONAL,\n           userCertif [1]        Certificate OPTIONAL,\n           verifKeyId
    [2]        OCTET STRING OPTIONAL,\n           userVerifCertif [3]   Certificate
    OPTIONAL,\n           theCACertificates [4] SEQUENCE OF CertificatePair OPTIONAL\n
    \  } -- Presence of [2] or [3] implies that [0] or [1] must also be\n     -- present.
    \ Presence of [4] implies that at least one of [0], [1],\n     -- [2], and [3]
    must also be present.\n   REQ-TOKEN ::= SEQUENCE {\n           req-contents     Req-contents,\n
    \          algId            AlgorithmIdentifier,\n           req-integrity    Integrity
    \ -- \"token\" is Req-contents\n   }\n  Integrity ::= BIT STRING\n     -- If corresponding
    algId specifies a signing algorithm,\n     -- \"Integrity\" holds the result of
    applying the signing procedure\n     -- specified in algId to the BER-encoded
    octet string which results\n     -- from applying the hashing procedure (also
    specified in algId) to\n     -- the DER-encoded octets of \"token\".\n     --
    Alternatively, if corresponding algId specifies a MACing\n     -- algorithm, \"Integrity\"
    holds the result of applying the MACing\n     -- procedure specified in algId
    to the DER-encoded octets of\n     -- \"token\"\n   Req-contents ::= SEQUENCE
    {\n           tok-id           INTEGER (256),  -- shall contain 0100 (hex)\n           context-id
    \      Random-Integer,\n           pvno             BIT STRING,\n           timestamp
    \       UTCTime OPTIONAL, -- mandatory for SPKM-2\n           randSrc          Random-Integer,\n
    \          targ-name        Name,\n           src-name [0]     Name OPTIONAL,\n
    \          req-data         Context-Data,\n           validity [1]     Validity
    OPTIONAL,\n           key-estb-set     Key-Estb-Algs,\n           key-estb-req
    \    BIT STRING OPTIONAL,\n           key-src-bind     OCTET STRING OPTIONAL\n
    \             -- This field must be present for the case of SPKM-2\n              --
    unilateral authen. if the K-ALG in use does not provide\n              -- such
    a binding (but is optional for all other cases).\n              -- The octet string
    holds the result of applying the\n              -- mandatory hashing procedure
    (in MANDATORY I-ALG;\n              -- see Section 2.1) as follows:  MD5(src ||
    context_key),\n              -- where \"src\" is the DER-encoded octets of src-name,\n
    \             -- \"context-key\" is the symmetric key (i.e., the\n              --
    unprotected version of what is transmitted in\n              -- key-estb-req),
    and \"||\" is the concatenation operation.\n   }\n   Random-Integer ::= BIT STRING\n
    \  Context-Data ::= SEQUENCE {\n           channelId       ChannelId OPTIONAL,\n
    \          seq-number      INTEGER OPTIONAL,\n           options         Options,\n
    \          conf-alg        Conf-Algs,\n           intg-alg        Intg-Algs,\n
    \          owf-alg         OWF-Algs\n   }\n   ChannelId ::= OCTET STRING\n   Options
    ::= BIT STRING {\n           delegation-state (0),\n           mutual-state (1),\n
    \          replay-det-state (2),\n           sequence-state (3),\n           conf-avail
    (4),\n           integ-avail (5),\n           target-certif-data-required (6)\n
    \  }\n   Conf-Algs ::= CHOICE {\n           algs [0]         SEQUENCE OF AlgorithmIdentifier,\n
    \          null [1]         NULL\n   }\n   Intg-Algs ::= SEQUENCE OF AlgorithmIdentifier\n
    \  OWF-Algs ::= SEQUENCE OF AlgorithmIdentifier\n   Key-Estb-Algs ::= SEQUENCE
    OF AlgorithmIdentifier\n   SPKM-REP-TI ::= SEQUENCE {\n           responseToken
    \   REP-TI-TOKEN,\n           certif-data      CertificationData OPTIONAL\n             --
    present if target-certif-data-required option was\n   }         -- set to TRUE
    in SPKM-REQ\n   REP-TI-TOKEN ::= SEQUENCE {\n           rep-ti-contents  Rep-ti-contents,\n
    \          algId            AlgorithmIdentifier,\n           rep-ti-integ     Integrity
    \ -- \"token\" is Rep-ti-contents\n   }\n   Rep-ti-contents ::= SEQUENCE {\n           tok-id
    \          INTEGER (512),   -- shall contain 0200 (hex)\n           context-id
    \      Random-Integer,\n           pvno [0]         BIT STRING OPTIONAL,\n           timestamp
    \       UTCTime OPTIONAL, -- mandatory for SPKM-2\n           randTarg         Random-Integer,\n
    \          src-name [1]     Name OPTIONAL,\n           targ-name        Name,\n
    \          randSrc          Random-Integer,\n           rep-data         Context-Data,\n
    \          validity [2]     Validity  OPTIONAL,\n           key-estb-id      AlgorithmIdentifier
    OPTIONAL,\n           key-estb-str     BIT STRING OPTIONAL\n   }\n   SPKM-REP-IT
    ::= SEQUENCE {\n           responseToken    REP-IT-TOKEN,\n           algId            AlgorithmIdentifier,\n
    \          rep-it-integ     Integrity  -- \"token\" is REP-IT-TOKEN\n   }\n   REP-IT-TOKEN
    ::= SEQUENCE {\n           tok-id           INTEGER (768),  -- shall contain 0300
    (hex)\n           context-id       Random-Integer,\n           randSrc          Random-Integer,\n
    \          randTarg         Random-Integer,\n           targ-name        Name,\n
    \          src-name         Name OPTIONAL,\n           key-estb-rep     BIT STRING
    OPTIONAL\n   }\n   SPKM-ERROR ::= SEQUENCE {\n           errorToken       ERROR-TOKEN,\n
    \          algId            AlgorithmIdentifier,\n           integrity        Integrity
    \ -- \"token\" is ERROR-TOKEN\n   }\n   ERROR-TOKEN ::=   SEQUENCE {\n           tok-id
    \          INTEGER (1024), -- shall contain 0400 (hex)\n           context-id
    \      Random-Integer\n   }\n   SPKM-MIC ::= SEQUENCE {\n           mic-header
    \      Mic-Header,\n           int-cksum        BIT STRING\n   }\n   Mic-Header
    ::= SEQUENCE {\n           tok-id           INTEGER (257), -- shall contain 0101
    (hex)\n           context-id       Random-Integer,\n           int-alg [0]      AlgorithmIdentifier
    OPTIONAL,\n           snd-seq [1]      SeqNum OPTIONAL\n   }\n   SeqNum ::= SEQUENCE
    {\n           num              INTEGER,\n           dir-ind          BOOLEAN\n
    \  }\n   SPKM-WRAP ::= SEQUENCE {\n           wrap-header       Wrap-Header,\n
    \          wrap-body         Wrap-Body\n   }\n   Wrap-Header ::= SEQUENCE {\n
    \          tok-id           INTEGER (513), -- shall contain 0201 (hex)\n           context-id
    \      Random-Integer,\n           int-alg [0]      AlgorithmIdentifier OPTIONAL,\n
    \          conf-alg [1]     Conf-Alg OPTIONAL,\n           snd-seq [2]      SeqNum
    OPTIONAL\n   }\n   Wrap-Body ::= SEQUENCE {\n           int-cksum        BIT STRING,\n
    \          data             BIT STRING\n   }\n   Conf-Alg ::= CHOICE {\n           algId
    [0]        AlgorithmIdentifier,\n           null [1]         NULL\n   }\n   SPKM-DEL
    ::= SEQUENCE {\n           del-header       Del-Header,\n           int-cksum
    \       BIT STRING\n   }\n   Del-Header ::= SEQUENCE {\n           tok-id           INTEGER
    (769), -- shall contain 0301 (hex)\n           context-id       Random-Integer,\n
    \          int-alg [0]      AlgorithmIdentifier OPTIONAL,\n           snd-seq
    [1]      SeqNum OPTIONAL\n   }\n"
  - "-- other types --\n   -- from [RFC-1508] --\n   MechType ::= OBJECT IDENTIFIER\n
    \  InitialContextToken ::= [APPLICATION 0] IMPLICIT SEQUENCE {\n      thisMech
    \             MechType,\n      innerContextToken     SPKMInnerContextToken\n   }
    \    -- when thisMech is SPKM-1 or SPKM-2\n   SPKMInnerContextToken ::= CHOICE
    {\n      req    [0] SPKM-REQ,\n      rep-ti [1] SPKM-REP-TI,\n      rep-it [2]
    SPKM-REP-IT,\n      error  [3] SPKM-ERROR,\n      mic    [4] SPKM-MIC,\n      wrap
    \  [5] SPKM-WRAP,\n      del    [6] SPKM-DEL\n   }\n   -- from [RFC-1510] --\n
    \  AuthorizationData ::= SEQUENCE OF SEQUENCE {\n     ad-type  INTEGER,\n     ad-data
    \ OCTET STRING\n   }\n"
  - "-- object identifier assignments --\n   md5-DES-CBC OBJECT IDENTIFIER ::=\n      {iso(1)
    identified-organization(3) dod(6) internet(1) security(5)\n       integrity(3)
    md5-DES-CBC(1)}\n   sum64-DES-CBC OBJECT IDENTIFIER ::=\n      {iso(1) identified-organization(3)
    dod(6) internet(1) security(5)\n       integrity(3) sum64-DES-CBC(2)}\n   spkm-1
    OBJECT IDENTIFIER ::=\n      {iso(1) identified-organization(3) dod(6) internet(1)
    security(5)\n       mechanisms(5) spkm(1) spkm-1(1)}\n   spkm-2 OBJECT IDENTIFIER
    ::=\n      {iso(1) identified-organization(3) dod(6) internet(1) security(5)\n
    \      mechanisms(5) spkm(1) spkm-2(2)}\n"
  - 'END

    '
  title: 'Appendix A:  ASN.1 Module Definition'
- contents:
  - "Appendix B:  Imported Types\n   This appendix contains, for completeness, the
    relevant ASN.1 types\n   imported from InformationFramework (1993), AuthenticationFramework\n
    \  (1993), and [PKCS3].\n   AttributeType ::= OBJECT IDENTIFIER\n   AttributeValue
    ::= ANY\n   AttributeValueAssertion ::= SEQUENCE {AttributeType,AttributeValue}\n
    \  RelativeDistinguishedName ::= SET OF AttributeValueAssertion\n      -- note
    that the 1993 InformationFramework module uses\n      -- different syntax for
    the above constructs\n   RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n
    \  DistinguishedName ::= RDNSequence\n   Name ::= CHOICE {  -- only one for now\n
    \          rdnSequence       RDNSequence\n   }\n   Certificate ::= SEQUENCE {\n
    \          certContents      CertContents,\n           algID             AlgorithmIdentifier,\n
    \          sig               BIT STRING\n   }  -- sig holds the result of applying
    the signing procedure\n      -- specified in algId to the BER-encoded octet string
    which\n      -- results from applying the hashing procedure (also specified in\n
    \     -- algId) to the DER-encoded octets of CertContents\n   CertContents ::=
    SEQUENCE {\n           version [0]        Version DEFAULT v1,\n           serialNumber
    \      CertificateSerialNumber,\n           signature          AlgorithmIdentifier,\n
    \          issuer             Name,\n           validity           Validity,\n
    \          subject            Name,\n           subjectPublicKeyInfo     SubjectPublicKeyInfo,\n
    \          issuerUID [1]      IMPLICIT UID OPTIONAL,  -- used in v2 only\n           subjectUID
    [2]     IMPLICIT UID OPTIONAL   -- used in v2 only\n   }\n   Version ::= INTEGER
    {v1(0), v2(1)}\n   CertificateSerialNumber ::= INTEGER\n   UID ::= BIT STRING\n
    \  Validity ::= SEQUENCE {\n           notBefore         UTCTime,\n           notAfter
    \         UTCTime\n   }\n   SubjectPublicKeyInfo ::= SEQUENCE {\n           algorithm
    \        AlgorithmIdentifier,\n           subjectPublicKey  BIT STRING\n   }\n
    \  CertificatePair ::= SEQUENCE {\n           forward [0]      Certificate OPTIONAL,\n
    \          reverse [1]      Certificate OPTIONAL\n   }         -- at least one
    of the pair shall be present\n   CertificateList ::= SEQUENCE {\n           certListContents
    \       CertListContents,\n           algId                   AlgorithmIdentifier,\n
    \          sig                     BIT STRING\n   }  -- sig holds the result of
    applying the signing procedure\n      -- specified in algId to the BER-encoded
    octet string which\n      -- results from applying the hashing procedure (also
    specified in\n      -- algId) to the DER-encoded octets of CertListContents\n
    \  CertListContents ::= SEQUENCE {\n           signature               AlgorithmIdentifier,\n
    \          issuer                  Name,\n           thisUpdate              UTCTime,\n
    \          nextUpdate              UTCTime OPTIONAL,\n           revokedCertificates
    \    SEQUENCE OF SEQUENCE {\n                userCertificate       CertificateSerialNumber,\n
    \               revocationDate        UTCTime           } OPTIONAL\n   }\n   AlgorithmIdentifier
    ::= SEQUENCE {\n           algorithm         OBJECT IDENTIFIER,\n           parameter
    \        ANY DEFINED BY algorithm OPTIONAL\n   }  -- note that the 1993 AuthenticationFramework
    module uses\n      -- different syntax for this construct\n   --from [PKCS3] (the
    parameter to be used with dhKeyAgreement) --\n   DHParameter ::= SEQUENCE {\n
    \    prime              INTEGER,  -- p\n     base               INTEGER,  -- g\n
    \    privateValueLength INTEGER OPTIONAL\n   }\n"
  title: 'Appendix B:  Imported Types'
