- title: __initial_text__
  contents:
  - "                Negative-acknowledgment (NACK)-Oriented\n                   Reliable\
    \ Multicast (NORM) Protocol\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the messages and procedures of the Negative-\n\
    \   acknowledgment (NACK) Oriented Reliable Multicast (NORM) protocol.\n   This\
    \ protocol is designed to provide end-to-end reliable transport of\n   bulk data\
    \ objects or streams over generic IP multicast routing and\n   forwarding services.\
    \  NORM uses a selective, negative acknowledgment\n   mechanism for transport\
    \ reliability and offers additional protocol\n   mechanisms to allow for operation\
    \ with minimal \"a priori\"\n   coordination among senders and receivers.  A congestion\
    \ control\n   scheme is specified to allow the NORM protocol to fairly share\n\
    \   available network bandwidth with other transport protocols such as\n   Transmission\
    \ Control Protocol (TCP).  It is capable of operating with\n   both reciprocal\
    \ multicast routing among senders and receivers and\n   with asymmetric connectivity\
    \ (possibly a unicast return path) between\n   the senders and receivers.  The\
    \ protocol offers a number of features\n   to allow different types of applications\
    \ or possibly other higher\n   level transport protocols to utilize its service\
    \ in different ways.\n   The protocol leverages the use of FEC-based repair and\
    \ other IETF\n   reliable multicast transport (RMT) building blocks in its design.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Applicability. . . . . . . . . . .\
    \ . . . . .   3\n       1.1. NORM Delivery Service Model. . . . . . . . . . .\
    \ . . . .   4\n       1.2. NORM Scalability . . . . . . . . . . . . . . . . .\
    \ . . .   6\n       1.3. Environmental Requirements and Considerations. . . .\
    \ . .   7\n   2.  Architecture Definition . . . . . . . . . . . . . . . . . .\
    \ .   7\n       2.1. Protocol Operation Overview. . . . . . . . . . . . . . .\
    \   9\n       2.2. Protocol Building Blocks . . . . . . . . . . . . . . . .  10\n\
    \       2.3. Design Tradeoffs . . . . . . . . . . . . . . . . . . . .  11\n  \
    \ 3.  Conformance Statement . . . . . . . . . . . . . . . . . . . .  12\n   4.\
    \  Message Formats . . . . . . . . . . . . . . . . . . . . . . .  13\n       4.1.\
    \ NORM Common Message Header and Extensions. . . . . . . .  14\n       4.2. Sender\
    \ Messages. . . . . . . . . . . . . . . . . . . . .  16\n            4.2.1. NORM_DATA\
    \ Message . . . . . . . . . . . . . . . .  16\n            4.2.2. NORM_INFO Message\
    \ . . . . . . . . . . . . . . . .  24\n            4.2.3. NORM_CMD Messages .\
    \ . . . . . . . . . . . . . . .  26\n       4.3. Receiver Messages. . . . . .\
    \ . . . . . . . . . . . . . .  43\n            4.3.1. NORM_NACK Message . . .\
    \ . . . . . . . . . . . . .  43\n            4.3.2. NORM_ACK Message. . . . .\
    \ . . . . . . . . . . . .  50\n       4.4. General Purpose Messages . . . . .\
    \ . . . . . . . . . . .  52\n            4.4.1. NORM_REPORT Message . . . . .\
    \ . . . . . . . . . .  52\n   5.  Detailed Protocol Operation . . . . . . . .\
    \ . . . . . . . . .  52\n       5.1. Sender Initialization and Transmission .\
    \ . . . . . . . .  54\n            5.1.1. Object Segmentation Algorithm . . .\
    \ . . . . . . .  55\n       5.2. Receiver Initialization and Reception. . . .\
    \ . . . . . .  57\n       5.3. Receiver NACK Procedure. . . . . . . . . . . .\
    \ . . . . .  57\n       5.4. Sender NACK Processing and Response. . . . . . .\
    \ . . . .  59\n            5.4.1. Sender Repair State Aggregation . . . . . .\
    \ . . .  60\n            5.4.2. Sender FEC Repair Transmission Strategy . . .\
    \ . .  61\n            5.4.3. Sender NORM_CMD(SQUELCH) Generation . . . . . .\
    \ .  62\n            5.4.4. Sender NORM_CMD(REPAIR_ADV) Generation. . . . . .\
    \  62\n       5.5. Additional Protocol Mechanisms . . . . . . . . . . . . .  63\n\
    \            5.5.1. Greatest Round-trip Time Collection . . . . . . .  63\n  \
    \          5.5.2. NORM Congestion Control Operation . . . . . . . .  64\n    \
    \        5.5.3. NORM Positive Acknowledgment Procedure. . . . . .  72\n      \
    \      5.5.4. Group Size Estimate . . . . . . . . . . . . . . .  74\n   6.  Security\
    \ Considerations . . . . . . . . . . . . . . . . . . .  75\n   7.  IANA Considerations\
    \ . . . . . . . . . . . . . . . . . . . . .  75\n   8.  Suggested Use . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  75\n   9.  Acknowledgments . . . .\
    \ . . . . . . . . . . . . . . . . . . .  76\n   10. References. . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  76\n       10.1. Normative References.\
    \ . . . . . . . . . . . . . . . . .  76\n       10.2. Informative References.\
    \ . . . . . . . . . . . . . . . .  77\n   11. Authors' Addresses. . . . . . .\
    \ . . . . . . . . . . . . . . .  79\n       Full Copyright Statement. . . . .\
    \ . . . . . . . . . . . . . .  80\n"
- title: 1.  Introduction and Applicability
  contents:
  - "1.  Introduction and Applicability\n   The Negative-acknowledgment (NACK) Oriented\
    \ Reliable Multicast (NORM)\n   protocol is designed to provide reliable transport\
    \ of data from one\n   or more sender(s) to a group of receivers over an IP multicast\n\
    \   network.  The primary design goals of NORM are to provide efficient,\n   scalable,\
    \ and robust bulk data (e.g., computer files, transmission of\n   persistent data)\
    \ transfer across possibly heterogeneous IP networks\n   and topologies.  The\
    \ NORM protocol design provides support for\n   distributed multicast session\
    \ participation with minimal coordination\n   among senders and receivers.  NORM\
    \ allows senders and receivers to\n   dynamically join and leave multicast sessions\
    \ at will with minimal\n   overhead for control information and timing synchronization\
    \ among\n   participants.  To accommodate this capability, NORM protocol message\n\
    \   headers contain some common information allowing receivers to easily\n   synchronize\
    \ to senders throughout the lifetime of a reliable\n   multicast session.  NORM\
    \ is designed to be self-adapting to a wide\n   range of dynamic network conditions\
    \ with little or no pre-\n   configuration.  The protocol is purposely designed\
    \ to be tolerant of\n   inaccurate timing estimations or lossy conditions that\
    \ may occur in\n   many networks including mobile and wireless.  The protocol\
    \ is also\n   designed to exhibit convergence and efficient operation even in\n\
    \   situations of heavy packet loss and large queuing or transmission\n   delays.\n\
    \   This document is a product of the IETF RMT WG and follows the\n   guidelines\
    \ provided in RFC 3269 [1].  The key words \"MUST\", \"MUST\n   NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\",\n   \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this document are to be\n   interpreted as described\
    \ in BCP 14, RFC 2119 [2].\n"
- title: Statement of Intent
  contents:
  - "Statement of Intent\n   This memo contains part of the definitions necessary\
    \ to fully specify\n   a Reliable Multicast Transport protocol in accordance with\
    \ RFC 2357.\n   As per RFC 2357, the use of any reliable multicast protocol in\
    \ the\n   Internet requires an adequate congestion control scheme.\n   While waiting\
    \ for such a scheme to be available, or for an existing\n   scheme to be proven\
    \ adequate, the Reliable Multicast Transport\n   working group (RMT) publishes\
    \ this Request for Comments in the\n   \"Experimental\" category.\n   It is the\
    \ intent of RMT to re-submit this specification as an IETF\n   Proposed Standard\
    \ as soon as the above condition is met.\n"
- title: 1.1.  NORM Delivery Service Model
  contents:
  - "1.1.  NORM Delivery Service Model\n   A NORM protocol instance (NormSession)\
    \ is defined within the context\n   of participants communicating connectionless\
    \ (e.g., Internet Protocol\n   (IP) or User Datagram Protocol (UDP)) packets over\
    \ a network using\n   pre-determined addresses and host port numbers.  Generally,\
    \ the\n   participants exchange packets using an IP multicast group address,\n\
    \   but unicast transport may also be established or applied as an\n   adjunct\
    \ to multicast delivery.  In the case of multicast, the\n   participating NormNodes\
    \ will communicate using a common IP multicast\n   group address and port number\
    \ that has been chosen via means outside\n   the context of the given NormSession.\
    \  Other IETF data format and\n   protocol standards exist that may be applied\
    \ to describe and convey\n   the required \"a priori\" information for a specific\
    \ NormSession (e.g.,\n   Session Description Protocol (SDP) [7], Session Announcement\
    \ Protocol\n   (SAP) [8], etc.).\n   The NORM protocol design is principally driven\
    \ by the assumption of a\n   single sender transmitting bulk data content to a\
    \ group of receivers.\n   However, the protocol MAY operate with multiple senders\
    \ within the\n   context of a single NormSession.  In initial implementations\
    \ of this\n   protocol, it is anticipated that multiple senders will transmit\n\
    \   independent of one another and receivers will maintain state as\n   necessary\
    \ for each sender.  However, in future versions of NORM, it\n   is possible that\
    \ some aspects of protocol operation (e.g., round-trip\n   time collection) may\
    \ provide for alternate modes allowing more\n   efficient performance for applications\
    \ requiring multiple senders.\n   NORM provides for three types of bulk data content\
    \ objects\n   (NormObjects) to be reliably transported.  These types include:\n\
    \   1) static computer memory data content (NORM_OBJECT_DATA type),\n   2) computer\
    \ storage files (NORM_OBJECT_FILE type), and\n   3) non-finite streams of continuous\
    \ data content (NORM_OBJECT_STREAM\n      type).\n   The distinction between NORM_OBJECT_DATA\
    \ and NORM_OBJECT_FILE is\n   simply to provide a \"hint\" to receivers in NormSessions\
    \ serving\n   multiple types of content as to what type of storage should be\n\
    \   allocated for received content (i.e., memory or file storage).  Other\n  \
    \ than that distinction, the two are identical, providing for reliable\n   transport\
    \ of finite (but potentially very large) units of content.\n   These static data\
    \ and file services are anticipated to be useful for\n   multicast-based cache\
    \ applications with the ability to reliably\n   provide transmission of large\
    \ quantities of static data.  Other types\n   of static data/file delivery services\
    \ might make use of these\n   transport object types, too.  The use of the NORM_OBJECT_STREAM\
    \ type\n   is at the application's discretion and could be used to carry static\n\
    \   data or file content also.  The NORM reliable stream service opens up\n  \
    \ additional possibilities such as serialized reliable messaging or\n   other\
    \ unbounded, perhaps dynamically produced content.  The\n   NORM_OBJECT_STREAM\
    \ provides for reliable transport analogous to that\n   of the Transmission Control\
    \ Protocol (TCP), although NORM receivers\n   will be able to begin receiving\
    \ stream content at any point in time.\n   The applicability of this feature will\
    \ depend upon the application.\n   The NORM protocol also allows for a small amount\
    \ of \"out-of-band\"\n   data (sent as NORM_INFO messages) to be attached to the\
    \ data content\n   objects transmitted by the sender.  This readily-available\
    \ \"out-of-\n   band\" data allows multicast receivers to quickly and efficiently\n\
    \   determine the nature of the corresponding data, file, or stream bulk\n   content\
    \ being transmitted.  This allows application-level control of\n   the receiver\
    \ node's participation in the current transport activity.\n   This also allows\
    \ the protocol to be flexible with minimal pre-\n   coordination among senders\
    \ and receivers.  The NORM_INFO content is\n   designed to be atomic in that its\
    \ size MUST fit into the payload\n   portion of a single NORM message.\n   NORM\
    \ does _not_ provide for global or application-level\n   identification of data\
    \ content within in its message headers.  Note\n   the NORM_INFO out-of-band data\
    \ mechanism could be leveraged by the\n   application for this purpose if desired,\
    \ or identification could\n   alternatively be embedded within the data content.\
    \  NORM does\n   identify transmitted content (NormObjects) with transport identifiers\n\
    \   that are applicable only while the sender is transmitting and/or\n   repairing\
    \ the given object.  These transport data content identifiers\n   (NormTransportIds)\
    \ are assigned in a monotonically increasing fashion\n   by each NORM sender during\
    \ the course of a NormSession.  Each sender\n   maintains its NormTransportId\
    \ assignments independently so that\n   individual NormObjects may be uniquely\
    \ identified during transport\n   with the concatenation of the sender session-unique\
    \ identifier\n   (NormNodeId) and the assigned NormTransportId.  The NormTransportIds\n\
    \   are assigned from a large, but fixed, numeric space in increasing\n   order\
    \ and may be reassigned during long-lived sessions.  The NORM\n   protocol provides\
    \ mechanisms so that the sender application may\n   terminate transmission of\
    \ data content and inform the group of this\n   in an efficient manner.  Other\
    \ similar protocol control mechanisms\n   (e.g., session termination, receiver\
    \ synchronization, etc.) are\n   specified so that reliable multicast application\
    \ variants may\n   construct different, complete bulk transfer communication models\
    \ to\n   meet their goals.\n   To summarize, the NORM protocol provides reliable\
    \ transport of\n   different types of data content (including potentially mixed\
    \ types).\n   The senders enqueue and transmit bulk content in the form of static\n\
    \   data or files and/or non-finite, ongoing stream types.  NORM senders\n   provide\
    \ for repair transmission of data and/or FEC content in\n   response to NACK messages\
    \ received from the receiver group.\n   Mechanisms for \"out-of-band\" information\
    \ and other transport control\n   mechanisms are specified for use by applications\
    \ to form complete\n   reliable multicast solutions for different purposes.\n"
- title: 1.2.  NORM Scalability
  contents:
  - "1.2.  NORM Scalability\n   Group communication scalability requirements lead\
    \ to adaptation of\n   negative acknowledgment (NACK) based protocol schemes when\
    \ feedback\n   for reliability is required [9].  NORM is a protocol centered around\n\
    \   the use of selective NACKs to request repairs of missing data.  NORM\n   provides\
    \ for the use of packet-level forward error correction (FEC)\n   techniques for\
    \ efficient multicast repair and optional proactive\n   transmission robustness\
    \ [10].  FEC-based repair can be used to\n   greatly reduce the quantity of reliable\
    \ multicast repair requests and\n   repair transmissions [11] in a NACK-oriented\
    \ protocol.  The principal\n   factor in NORM scalability is the volume of feedback\
    \ traffic\n   generated by the receiver set to facilitate reliability and\n  \
    \ congestion control.  NORM uses probabilistic suppression of redundant\n   feedback\
    \ based on exponentially distributed random backoff timers.\n   The performance\
    \ of this type of suppression relative to other\n   techniques is described in\
    \ [12].  NORM dynamically measures the\n   group's roundtrip timing status to\
    \ set its suppression and other\n   protocol timers.  This allows NORM to scale\
    \ well while maintaining\n   reliable data delivery transport with low latency\
    \ relative to the\n   network topology over which it is operating.\n   Feedback\
    \ messages can be either multicast to the group at large or\n   sent via unicast\
    \ routing to the sender.  In the case of unicast\n   feedback, the sender \"advertises\"\
    \ the feedback state to the group to\n   facilitate feedback suppression.  In\
    \ typical Internet environments,\n   it is expected that the NORM protocol will\
    \ readily scale to group\n   sizes on the order of tens of thousands of receivers.\
    \  A study of the\n   quantity of feedback for this type of protocol is described\
    \ in [13].\n   NORM is able to operate with a smaller amount of feedback than\
    \ a\n   single TCP connection, even with relatively large numbers of\n   receivers.\
    \  Thus, depending upon the network topology, it is possible\n   that NORM may\
    \ scale to larger group sizes.  With respect to computer\n   resource usage, the\
    \ NORM protocol does _not_ require that state be\n   kept on all receivers in\
    \ the group.  NORM senders maintain state only\n   for receivers providing explicit\
    \ congestion control feedback.  NORM\n   receivers must maintain state for each\
    \ active sender.  This may\n   constrain the number of simultaneous senders in\
    \ some uses of NORM.\n"
- title: 1.3.  Environmental Requirements and Considerations
  contents:
  - "1.3.  Environmental Requirements and Considerations\n   All of the environmental\
    \ requirements and considerations that apply\n   to the RMT NORM Building Block\
    \ [4] and the RMT FEC Building Block [5]\n   also apply to the NORM protocol.\n\
    \   The NORM protocol SHALL be capable of operating in an end-to-end\n   fashion\
    \ with no assistance from intermediate systems beyond basic IP\n   multicast group\
    \ management, routing, and forwarding services.  While\n   the techniques utilized\
    \ in NORM are principally applicable to \"flat\"\n   end-to-end IP multicast topologies,\
    \ they could also be applied in the\n   sub-levels of hierarchical (e.g., tree-based)\
    \ multicast distribution\n   if so desired.  NORM can make use of reciprocal (among\
    \ senders and\n   receivers) multicast communication under the Any-Source Multicast\n\
    \   (ASM) model defined in RFC 1112 [3], but SHALL also be capable of\n   scalable\
    \ operation in asymmetric topologies such as Source Specific\n   Multicast (SSM)\
    \ [14] where there may only be unicast routing service\n   from the receivers\
    \ to the sender(s).\n   NORM is compatible with IPv4 and IPv6.  Additionally,\
    \ NORM may be\n   used with networks employing Network Address Translation (NAT)\n\
    \   providing the NAT device supports IP multicast and/or can cache UDP\n   traffic\
    \ source port numbers for remapping feedback traffic from\n   receivers to the\
    \ sender(s).\n"
- title: 2.  Architecture Definition
  contents:
  - "2.  Architecture Definition\n   A NormSession is comprised of participants (NormNodes)\
    \ acting as\n   senders and/or receivers.  NORM senders transmit data content\
    \ in the\n   form of NormObjects to the session destination address and the NORM\n\
    \   receivers attempt to reliably receive the transmitted content using\n   negative\
    \ acknowledgments to request repair.  Each NormNode within a\n   NormSession is\
    \ assumed to have a preselected unique 32-bit identifier\n   (NormNodeId).  NormNodes\
    \ MUST have uniquely assigned identifiers\n   within a single NormSession to distinguish\
    \  between possible multiple\n   senders and to distinguish feedback information\
    \ from different\n   receivers.  There are two reserved NormNodeId values.  A\
    \ value of\n   0x00000000 is considered an invalid NormNodeId value and a value\
    \ of\n   0xffffffff is a \"wildcard\" NormNodeId.  While the protocol does not\n\
    \   preclude multiple sender nodes concurrently transmitting within the\n   context\
    \ of a single NORM session (i.e., many-to-many operation), any\n   type of interactive\
    \ coordination among NORM senders is assumed to be\n   controlled by the application\
    \ or higher protocol layer.  There are\n   some optional mechanisms specified\
    \ in this document that can be\n   leveraged for such application layer coordination.\n\
    \   As previously noted, NORM allows for reliable transmission of three\n   different\
    \ basic types of data content.  The first type is\n   NORM_OBJECT_DATA, which\
    \ is used for static, persistent blocks of data\n   content maintained in the\
    \ sender's application memory storage.  The\n   second type is NORM_OBJECT_FILE,\
    \ which corresponds to data stored in\n   the sender's non-volatile file system.\
    \  The NORM_OBJECT_DATA and\n   NORM_OBJECT_FILE types both represent \"NormObjects\"\
    \ of finite but\n   potentially very large size.  The third type of data content\
    \ is\n   NORM_OBJECT_STREAM, which corresponds to an ongoing transmission of\n\
    \   undefined length.  This is analogous to the reliable stream service\n   provide\
    \ by TCP for unicast data transport.  The format of the stream\n   content is\
    \ application-defined and may be byte or message oriented.\n   The NORM protocol\
    \ provides for \"flushing\" of the stream to expedite\n   delivery or possibly\
    \ enforce application message boundaries.  NORM\n   protocol implementations may\
    \ offer either (or both) in-order delivery\n   of the stream data to the receive\
    \ application or out-of-order (more\n   immediate) delivery of received segments\
    \ of the stream to the\n   receiver application.  In either case, NORM sender\
    \ and receiver\n   implementations provide buffering to facilitate repair of the\
    \ stream\n   as it is transported.\n   All NormObjects are logically segmented\
    \ into FEC coding blocks and\n   symbols for transmission by the sender.  In NORM,\
    \ an FEC encoding\n   symbol directly corresponds to the payload of NORM_DATA\
    \ messages or\n   \"segment\".  Note that when systematic FEC codes are used,\
    \ the payload\n   of NORM_DATA messages sent for the first portion of a FEC encoding\n\
    \   block are source symbols (actual segments of original user data),\n   while\
    \ the remaining symbols for the block consist of parity symbols\n   generated\
    \ by FEC encoding.  These parity symbols are generally sent\n   in response to\
    \ repair requests, but some number may be sent\n   proactively at the end each\
    \ encoding block to increase the robustness\n   of transmission.  When non-systematic\
    \ FEC codes are used, all symbols\n   sent consist of FEC encoding parity content.\
    \  In this case, the\n   receiver must receive a sufficient number of symbols\
    \ to reconstruct\n   (via FEC decoding) the original user data for the given block.\
    \  In\n   this document, the terms \"symbol\" and \"segment\" are used\n   interchangeably.\n\
    \   Transmitted NormObjects are temporarily yet uniquely identified\n   within\
    \ the NormSession context using the given sender's NormNodeId,\n   NormInstanceId,\
    \ and a temporary NormObjectTransportId.  Depending\n   upon the implementation,\
    \ individual NORM senders may manage their\n   NormInstanceIds independently,\
    \ or a common NormInstanceId may be\n   agreed upon for all participating nodes\
    \ within a session if needed as\n   a session identifier.  NORM NormObjectTransportId\
    \ data content\n   identifiers are sender-assigned and applicable and valid only\
    \ during\n   a NormObject's actual _transport_ (i.e., for as long as the sender\
    \ is\n   transmitting and providing repair of the indicated NormObject).  For\n\
    \   a long-lived session, the NormObjectTransportId field can wrap and\n   previously-used\
    \ identifiers may be re-used.  Note that globally\n   unique identification of\
    \ transported data content is not provided by\n   NORM and, if required, must\
    \ be managed by the NORM application.  The\n   individual segments or symbols\
    \ of the NormObject are further\n   identified with FEC payload identifiers which\
    \ include coding block\n   and symbol identifiers.  These are discussed in detail\
    \ later in this\n   document.\n"
- title: 2.1.  Protocol Operation Overview
  contents:
  - "2.1.  Protocol Operation Overview\n   A NORM sender primarily generates messages\
    \ of type NORM_DATA.  These\n   messages carry original data segments or FEC symbols\
    \ and repair\n   segments/symbols for the bulk data/file or stream NormObjects\
    \ being\n   transferred.  By default, redundant FEC symbols are sent only in\n\
    \   response to receiver repair requests (NACKs) and thus normally little\n  \
    \ or no additional transmission overhead is imposed due to FEC\n   encoding. \
    \ However, the NORM implementation MAY be optionally\n   configured to proactively\
    \ transmit some amount of redundant FEC\n   symbols along with the original content\
    \ to potentially enhance\n   performance (e.g., improved delay) at the cost of\
    \ additional\n   transmission overhead.  This option may be sensible for certain\n\
    \   network conditions and can allow for robust, asymmetric multicast\n   (e.g.,\
    \ unidirectional routing, satellite, cable) [15] with reduced\n   receiver feedback,\
    \ or, in some cases, no feedback.\n   A sender message of type NORM_INFO is also\
    \ defined and is used to\n   carry OPTIONAL \"out-of-band\" context information\
    \ for a given\n   transport object.  A single NORM_INFO message can be associated\
    \ with\n   a NormObject.  Because of its atomic nature, missing NORM_INFO\n  \
    \ messages can be NACKed and repaired with a slightly lower delay\n   process\
    \ than NORM's general FEC-encoded data content.  NORM_INFO may\n   serve special\
    \ purposes for some bulk transfer, reliable multicast\n   applications where receivers\
    \ join the group mid-stream and need to\n   ascertain contextual information on\
    \ the current content being\n   transmitted.  The NACK process for NORM_INFO will\
    \ be described later.\n   When the NORM_INFO message type is used, its transmission\
    \ should\n   precede transmission of any NORM_DATA message for the associated\n\
    \   NormObject.\n   The sender also generates messages of type NORM_CMD to assist\
    \ in\n   certain protocol operations such as congestion control, end-of-\n   transmission\
    \ flushing, round trip time estimation, receiver\n   synchronization, and optional\
    \ positive acknowledgment requests or\n   application defined commands.  The transmission\
    \ of NORM_CMD messages\n   from the sender is accomplished by one of three different\
    \ procedures.\n   These procedures are: single, best effort unreliable transmission\
    \ of\n   the command; repeated redundant transmissions of the command; and\n \
    \  positively-acknowledged commands.  The transmission technique used\n   for\
    \ a given command depends upon the function of the command.\n   Several core commands\
    \ are defined for basic protocol operation.\n   Additionally, implementations\
    \ MAY wish to consider providing the\n   OPTIONAL application-defined commands\
    \ that can take advantage of the\n   transmission methodologies available for\
    \ commands.  This allows for\n   application-level session management mechanisms\
    \ that can make use of\n   information available to the underlying NORM protocol\
    \ engine (e.g.,\n   round-trip timing, transmission rate, etc.).\n   NORM receivers\
    \ generate messages of type NORM_NACK or NORM_ACK in\n   response to transmissions\
    \ of data and commands from a sender.  The\n   NORM_NACK messages are generated\
    \ to request repair of detected data\n   transmission losses.  Receivers generally\
    \ detect losses by tracking\n   the sequence of transmission from a sender.  Sequencing\
    \ information\n   is embedded in the transmitted data packets and end-of-transmission\n\
    \   commands from the sender.  NORM_ACK messages are generated in\n   response\
    \ to certain commands transmitted by the sender.  In the\n   general (and most\
    \ scalable) protocol mode, NORM_ACK messages are sent\n   only in response to\
    \ congestion control commands from the sender.  The\n   feedback volume of these\
    \ congestion control NORM_ACK messages is\n   controlled using the same timer-based\
    \ probabilistic suppression\n   techniques as for NORM_NACK messages to avoid\
    \ feedback implosion.  In\n   order to meet potential application requirements\
    \ for positive\n   acknowledgment from receivers, other NORM_ACK messages are\
    \ defined\n   and available for use.  All sender and receiver transmissions are\n\
    \   subject to rate control governed by a peak transmission rate set for\n   each\
    \ participant by the application.  This can be used to limit the\n   quantity\
    \ of multicast data transmitted by the group.  When NORM's\n   congestion control\
    \ algorithm is enabled the rate for senders is\n   automatically adjusted.  In\
    \ some networks, it may be desirable to\n   establish minimum and maximum bounds\
    \ for the rate adjustment\n   depending upon the application even when dynamic\
    \ congestion control\n   is enabled.  However, in the case of the general Internet,\
    \ congestion\n   control policy SHALL be observed that is compatible with coexistent\n\
    \   TCP flows.\n"
- title: 2.2.  Protocol Building Blocks
  contents:
  - "2.2.  Protocol Building Blocks\n   The operation of the NORM protocol is based\
    \ primarily upon the\n   concepts presented in the Nack-Oriented Reliable Multicast\
    \ (NORM)\n   Building Block document [4].  This includes the basic NORM\n   architecture\
    \ and the data transmission, repair, and feedback\n   strategies discussed in\
    \ that document.  Additional reliable multicast\n   building blocks are applied\
    \ in creating the full NORM protocol\n   instantiation [16].  NORM also makes\
    \ use of Forward Error Correction\n   encoding techniques for repair messaging\
    \ and optional transmission\n   robustness as described in [10].  NORM uses the\
    \ FEC Payload ID as\n   specified by the FEC Building Block Document [5].  Additionally,\
    \ for\n   congestion control, this document includes a baseline congestion\n \
    \  control mechanism (NORM-CC) based on the TCP-Friendly Multicast\n   Congestion\
    \ Control (TFMCC) scheme described in [19].\n"
- title: 2.3.  Design Tradeoffs
  contents:
  - "2.3.  Design Tradeoffs\n   While the various features of NORM are designed to\
    \ provide some\n   measure of general purpose utility, it is important to emphasize\
    \ the\n   understanding that \"no one size fits all\" in the reliable multicast\n\
    \   transport arena.  There are numerous engineering tradeoffs involved\n   in\
    \ reliable multicast transport design and this requires an increased\n   awareness\
    \ of application and network architecture considerations.\n   Performance requirements\
    \ affecting design can include:  group size,\n   heterogeneity (e.g., capacity\
    \ and/or delay), asymmetric delivery,\n   data ordering, delivery delay, group\
    \ dynamics, mobility, congestion\n   control, and transport across low capacity\
    \ connections.  NORM\n   contains various parameters to accommodate many of these\
    \ differing\n   requirements.  The NORM protocol and its mechanisms MAY be applied\
    \ in\n   multicast applications outside of bulk data transfer, but there is an\n\
    \   assumed model of bulk transfer transport service that drives the\n   trade-offs\
    \ that determine the scalability and performance described\n   in this document.\n\
    \   The ability of NORM to provide reliable data delivery is also\n   governed\
    \ by any buffer constraints of the sender and receiver\n   applications.  NORM\
    \ protocol implementations SHOULD be designed to\n   operate with the greatest\
    \ efficiency and robustness possible within\n   application-defined buffer constraints.\
    \  Buffer requirements for\n   reliability, as always, are a function of the delay-bandwidth\
    \ product\n   of the network topology.  NORM performs best when allowed more\n\
    \   buffering resources than typical point-to-point transport protocols.\n   This\
    \ is because NORM feedback suppression is based upon randomly-\n   delayed transmissions\
    \ from the receiver set, rather than immediately\n   transmitted feedback.  There\
    \ are definitive tradeoffs between buffer\n   utilization, group size scalability,\
    \ and efficiency of performance.\n   Large buffer sizes allow the NORM protocol\
    \ to perform most\n   efficiently in large delay-bandwidth topologies and allow\
    \ for longer\n   feedback suppression backoff timeouts.  This yields improved\
    \ group\n   size scalability.  NORM can operate with reduced buffering but at\
    \ a\n   cost of decreased efficiency (lower relative goodput) and reduced\n  \
    \ group size scalability.\n"
- title: 3.  Conformance Statement
  contents:
  - "3.  Conformance Statement\n   This Protocol Instantiation document, in conjunction\
    \ with the RMT\n   Building Block documents of [4] and [5], completely specifies\
    \ a\n   working reliable multicast transport protocol that conforms to the\n \
    \  requirements described in RFC 2357 [17].\n   This document specifies the following\
    \ message types and mechanisms\n   which are REQUIRED in complying NORM protocol\
    \ implementations:\n"
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|    Message Type    |                    Purpose                    |'
  contents:
  - '|    Message Type    |                    Purpose                    |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|NORM_DATA           | Sender message for application data           |'
  contents:
  - '|NORM_DATA           | Sender message for application data           |

    '
- title: '|                    | transmission.  Implementations must support   |'
  contents:
  - '|                    | transmission.  Implementations must support   |

    '
- title: '|                    | at least one of the NORM_OBJECT_DATA,         |'
  contents:
  - '|                    | at least one of the NORM_OBJECT_DATA,         |

    '
- title: '|                    | NORM_OBJECT_FILE, or NORM_OBJECT_STREAM       |'
  contents:
  - '|                    | NORM_OBJECT_FILE, or NORM_OBJECT_STREAM       |

    '
- title: '|                    | delivery services.  The use of the NORM FEC   |'
  contents:
  - '|                    | delivery services.  The use of the NORM FEC   |

    '
- title: '|                    | Object Transmission Information header        |'
  contents:
  - '|                    | Object Transmission Information header        |

    '
- title: '|                    | extension is OPTIONAL with NORM_DATA          |'
  contents:
  - '|                    | extension is OPTIONAL with NORM_DATA          |

    '
- title: '|                    | messages.                                     |'
  contents:
  - '|                    | messages.                                     |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|NORM_CMD(FLUSH)     | Sender command to excite receivers for repair |'
  contents:
  - '|NORM_CMD(FLUSH)     | Sender command to excite receivers for repair |

    '
- title: '|                    | requests in lieu of ongoing NORM_DATA         |'
  contents:
  - '|                    | requests in lieu of ongoing NORM_DATA         |

    '
- title: '|                    | transmissions.  Note the use of the           |'
  contents:
  - '|                    | transmissions.  Note the use of the           |

    '
- title: '|                    | NORM_CMD(FLUSH) for positive acknowledgment   |'
  contents:
  - '|                    | NORM_CMD(FLUSH) for positive acknowledgment   |

    '
- title: '|                    | of data receipt is OPTIONAL.                  |'
  contents:
  - '|                    | of data receipt is OPTIONAL.                  |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|NORM_CMD(SQUELCH)   | Sender command to advertise its current valid |'
  contents:
  - '|NORM_CMD(SQUELCH)   | Sender command to advertise its current valid |

    '
- title: '|                    | repair window in response to invalid requests |'
  contents:
  - '|                    | repair window in response to invalid requests |

    '
- title: '|                    | for repair.                                   |'
  contents:
  - '|                    | for repair.                                   |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|NORM_CMD(REPAIR_ADV)| Sender command to advertise current repair    |'
  contents:
  - '|NORM_CMD(REPAIR_ADV)| Sender command to advertise current repair    |

    '
- title: '|                    | (and congestion control state) to group when  |'
  contents:
  - '|                    | (and congestion control state) to group when  |

    '
- title: '|                    | unicast feedback messages are detected.  Used |'
  contents:
  - '|                    | unicast feedback messages are detected.  Used |

    '
- title: '|                    | to control/suppress excessive receiver        |'
  contents:
  - '|                    | to control/suppress excessive receiver        |

    '
- title: '|                    | feedback in asymmetric multicast topologies.  |'
  contents:
  - '|                    | feedback in asymmetric multicast topologies.  |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|NORM_CMD(CC)        | Sender command used in collection of round    |'
  contents:
  - '|NORM_CMD(CC)        | Sender command used in collection of round    |

    '
- title: '|                    | trip timing and congestion control status     |'
  contents:
  - '|                    | trip timing and congestion control status     |

    '
- title: '|                    | from group (this may be OPTIONAL if           |'
  contents:
  - '|                    | from group (this may be OPTIONAL if           |

    '
- title: '|                    | alternative congestion control mechanism and  |'
  contents:
  - '|                    | alternative congestion control mechanism and  |

    '
- title: '|                    | round trip timing collection is used).        |'
  contents:
  - '|                    | round trip timing collection is used).        |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|NORM_NACK           | Receiver message used to request repair of    |'
  contents:
  - '|NORM_NACK           | Receiver message used to request repair of    |

    '
- title: '|                    | missing transmitted content.                  |'
  contents:
  - '|                    | missing transmitted content.                  |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - '+--------------------+-----------------------------------------------+

    '
- title: '|NORM_ACK            | Receiver message used to proactively provide  |'
  contents:
  - '|NORM_ACK            | Receiver message used to proactively provide  |

    '
- title: '|                    | feedback for congestion control purposes.     |'
  contents:
  - '|                    | feedback for congestion control purposes.     |

    '
- title: '|                    | Also used with the OPTIONAL NORM Positive     |'
  contents:
  - '|                    | Also used with the OPTIONAL NORM Positive     |

    '
- title: '|                    | Acknowledgment Process.                       |'
  contents:
  - '|                    | Acknowledgment Process.                       |

    '
- title: +--------------------+-----------------------------------------------+
  contents:
  - "+--------------------+-----------------------------------------------+\n   This\
    \ document also describes the following message types and\n   associated mechanisms\
    \ which are OPTIONAL for complying NORM protocol\n   implementations:\n"
- title: +----------------------+----------------------------------------------+
  contents:
  - '+----------------------+----------------------------------------------+

    '
- title: '|     Message Type     |                    Purpose                   |'
  contents:
  - '|     Message Type     |                    Purpose                   |

    '
- title: +----------------------+----------------------------------------------+
  contents:
  - '+----------------------+----------------------------------------------+

    '
- title: '|NORM_INFO             | Sender message for providing ancillary       |'
  contents:
  - '|NORM_INFO             | Sender message for providing ancillary       |

    '
- title: '|                      | context information associated with NORM     |'
  contents:
  - '|                      | context information associated with NORM     |

    '
- title: '|                      | transport objects.  The use of the NORM FEC  |'
  contents:
  - '|                      | transport objects.  The use of the NORM FEC  |

    '
- title: '|                      | Object Transmission Information header       |'
  contents:
  - '|                      | Object Transmission Information header       |

    '
- title: '|                      | extension is OPTIONAL with NORM_INFO         |'
  contents:
  - '|                      | extension is OPTIONAL with NORM_INFO         |

    '
- title: '|                      | messages.                                    |'
  contents:
  - '|                      | messages.                                    |

    '
- title: +----------------------+----------------------------------------------+
  contents:
  - '+----------------------+----------------------------------------------+

    '
- title: '|NORM_CMD(EOT)         | Sender command to indicate it has reached    |'
  contents:
  - '|NORM_CMD(EOT)         | Sender command to indicate it has reached    |

    '
- title: '|                      | end-of-transmission and will no longer       |'
  contents:
  - '|                      | end-of-transmission and will no longer       |

    '
- title: '|                      | respond to repair requests.                  |'
  contents:
  - '|                      | respond to repair requests.                  |

    '
- title: +----------------------+----------------------------------------------+
  contents:
  - '+----------------------+----------------------------------------------+

    '
- title: '|NORM_CMD(ACK_REQ)     | Sender command to support application-       |'
  contents:
  - '|NORM_CMD(ACK_REQ)     | Sender command to support application-       |

    '
- title: '|                      | defined, positively acknowledged commands    |'
  contents:
  - '|                      | defined, positively acknowledged commands    |

    '
- title: '|                      | sent outside of the context of the bulk data |'
  contents:
  - '|                      | sent outside of the context of the bulk data |

    '
- title: '|                      | content being transmitted.  The NORM Positive|'
  contents:
  - '|                      | content being transmitted.  The NORM Positive|

    '
- title: '|                      | Acknowledgment Procedure associated with this|'
  contents:
  - '|                      | Acknowledgment Procedure associated with this|

    '
- title: '|                      | message type is OPTIONAL.                    |'
  contents:
  - '|                      | message type is OPTIONAL.                    |

    '
- title: +----------------------+----------------------------------------------+
  contents:
  - '+----------------------+----------------------------------------------+

    '
- title: '|NORM_CMD(APPLICATION) | Sender command containing application-defined|'
  contents:
  - '|NORM_CMD(APPLICATION) | Sender command containing application-defined|

    '
- title: '|                      | commands sent outside of the context of the  |'
  contents:
  - '|                      | commands sent outside of the context of the  |

    '
- title: '|                      | bulk data content being transmitted.         |'
  contents:
  - '|                      | bulk data content being transmitted.         |

    '
- title: +----------------------+----------------------------------------------+
  contents:
  - '+----------------------+----------------------------------------------+

    '
- title: '|NORM_REPORT           | Optional message type reserved for           |'
  contents:
  - '|NORM_REPORT           | Optional message type reserved for           |

    '
- title: '|                      | experimental implementations of the NORM     |'
  contents:
  - '|                      | experimental implementations of the NORM     |

    '
- title: '|                      | protocol.                                    |'
  contents:
  - '|                      | protocol.                                    |

    '
- title: +----------------------+----------------------------------------------+
  contents:
  - '+----------------------+----------------------------------------------+

    '
- title: 4.  Message Formats
  contents:
  - "4.  Message Formats\n   As mentioned in Section 2.1, there are two primary classes\
    \ of NORM\n   messages: sender messages and receiver messages.  NORM_CMD,\n  \
    \ NORM_INFO, and NORM_DATA message types are generated by senders of\n   data\
    \ content, and NORM_NACK and NORM_ACK messages generated by\n   receivers within\
    \ a NormSession.  An auxiliary message type of\n   NORM_REPORT is also provided\
    \ for experimental purposes.  This section\n   describes the message formats used\
    \ by the NORM protocol.  These\n   messages and their fields are referenced in\
    \ the detailed functional\n   description of the NORM protocol given in Section\
    \ 5.  Individual NORM\n   messages are designed to be compatible with the MTU\
    \ limitations of\n   encapsulating Internet protocols including IPv4, IPv6, and\
    \ UDP.  The\n   current NORM protocol specification assumes UDP encapsulation\
    \ and\n   leverages the transport features of UDP.  The NORM messages are\n  \
    \ independent of network addresses and can be used in IPv4 and IPv6\n   networks.\n"
- title: 4.1.  NORM Common Message Header and Extensions
  contents:
  - "4.1.  NORM Common Message Header and Extensions\n   There are some common message\
    \ fields contained in all NORM message\n   types.  Additionally, a header extension\
    \ mechanism is defined to\n   expand the functionality of the NORM protocol without\
    \ revision to\n   this document.  All NORM protocol messages begin with a common\
    \ header\n   with information fields as follows:\n      0                   1\
    \                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version|  type |    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     NORM Common Message Header Format\n   The \"version\" field\
    \ is a 4-bit value indicating the protocol version\n   number.  NORM implementations\
    \ SHOULD ignore received messages with\n   version numbers different from their\
    \ own.  This number is intended to\n   indicate and distinguish upgrades of the\
    \ protocol which may be non-\n   interoperable.  The NORM version number for this\
    \ specification is 1.\n   The message \"type\" field is a 4-bit value indicating\
    \ the NORM\n   protocol message type.  These types are defined as follows:\n \
    \          Message     Value\n         NORM_INFO       1\n         NORM_DATA \
    \      2\n         NORM_CMD        3\n         NORM_NACK       4\n         NORM_ACK\
    \        5\n         NORM_REPORT     6\n   The 8-bit \"hdr_len\" field indicates\
    \ the number of 32-bit words that\n   comprise the given message's header portion.\
    \  This is used to\n   facilitate header extensions that may be applied.  The\
    \ presence of\n   header extensions are implied when the \"hdr_len\" value is\
    \ greater\n   than the base value for the given message \"type\".\n   The \"sequence\"\
    \ field is a 16-bit value that is set by the message\n   originator as a monotonically\
    \ increasing number incremented with each\n   NORM message transmitted to a given\
    \ destination address.  A\n   \"sequence\" field number space SHOULD be maintained\
    \ for messages sent\n   to the NormSession group address.  This value can be monitored\
    \ by\n   receiving nodes to detect packet losses in the transmission from a\n\
    \   sender and used in estimating raw packet loss for congestion control\n   purposes.\
    \  Note that this value is NOT used in the NORM protocol to\n   detect missing\
    \ reliable data content and does NOT identify the\n   application data or FEC\
    \ payload that may be attached.  With message\n   authentication, the \"sequence\"\
    \ field may also be leveraged for\n   protection from message \"replay\" attacks,\
    \ particularly of NORM_NACK\n   or other feedback messages.  In this case, the\
    \ receiver node should\n   maintain a monotonically increasing \"sequence\" field\
    \ space for each\n   destination to which it transmits (this may be multiple destinations\n\
    \   when unicast feedback is used).  The size of this field is intended\n   to\
    \ be sufficient to allow detection of a reasonable range of packet\n   loss within\
    \ the delay-bandwidth product of expected network\n   connections.\n   The \"\
    source_id\" field is a 32-bit value identifying the node that\n   sent the message.\
    \  A participant's NORM node identifier (NormNodeId)\n   can be set according\
    \ to application needs but unique identifiers must\n   be assigned within a single\
    \ NormSession.  In some cases, use of the\n   host IP address or a hash of it\
    \ can suffice, but alternative\n   methodologies for assignment and potential\
    \ collision resolution of\n   node identifiers within a multicast session need\
    \ to be considered.\n   For example, the \"source identifier\" mechanism defined\
    \ in the Real-\n   Time Protocol (RTP) specification [18] may be applicable to\
    \ use for\n   NORM node identifiers.  At this point in time, the protocol makes\
    \ no\n   assumptions about how these unique identifiers are actually assigned.\n\
    \   NORM Header Extensions\n   When header extensions are applied, they follow\
    \ the message type's\n   base header and precede any payload portion.  There are\
    \ two formats\n   for header extensions, both of which begin with an 8-bit \"\
    het\"\n   (header extension type) field.  One format is provided for variable-\n\
    \   length extensions with \"het\" values in the range from 0 through 127.\n \
    \  The other format is for fixed length (one 32-bit word) extensions\n   with\
    \ \"het\" values in the range from 128 through 255.  These formats\n   are given\
    \ here:\n      0                   1                   2                   3\n\
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   het <=127   |      hel      |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                    Header Extension Content\
    \                   |\n   |                              ...                 \
    \             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              NORM Variable Length Header Extension Format\n      0         \
    \          1                   2                   3\n     0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   het >=128   |   reserved    |    Header Extension Content   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           NORM Fixed Length (32-bit) Header Extension Format\n   The \"Header\
    \ Extension Content\" portion of these header extension\n   format is defined\
    \ for each header extension type defined for NORM\n   messages.  Some header extensions\
    \ are defined within this document\n   for NORM baseline FEC and congestion control\
    \ operations.\n"
- title: 4.2.  Sender Messages
  contents:
  - "4.2.  Sender Messages\n   NORM sender messages include the NORM_DATA type, the\
    \ NORM_INFO type,\n   and the NORM_CMD type.  NORM_DATA and NORM_INFO messages\
    \ contain\n   application data content while NORM_CMD messages are used for various\n\
    \   protocol control functions.\n"
- title: 4.2.1.  NORM_DATA Message
  contents:
  - "4.2.1.  NORM_DATA Message\n   The NORM_DATA message is expected to be the predominant\
    \ type\n   transmitted by NORM senders.  These messages are used to encapsulate\n\
    \   segmented data content for objects of type NORM_OBJECT_DATA,\n   NORM_OBJECT_FILE,\
    \ and NORM_OBJECT_STREAM.  NORM_DATA messages may\n   contain original or FEC-encoded\
    \ application data content.\n   The format of NORM_DATA messages is comprised\
    \ of three logical\n   portions:  1) a fixed-format NORM_DATA header portion,\
    \ 2) a FEC\n   Payload ID portion with a format dependent upon the FEC encoding\n\
    \   used, and 3) a payload portion containing source or encoded\n   application\
    \ data content.  Note for objects of type\n   NORM_OBJECT_STREAM, the payload\
    \ portion contains additional fields\n   used to appropriately recover stream\
    \ content.  NORM implementations\n   MAY also extend the NORM_DATA header to include\
    \ a FEC Object\n   Transmission Information (EXT_FTI) header extension.  This\
    \ allows\n   NORM receivers to automatically allocate resources and properly\n\
    \   perform FEC decoding without the need for pre-configuration or out-\n   of-band\
    \ information.\n      0                   1                   2              \
    \     3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |version|\
    \ type=2|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     flags     |    fec_id     |     object_transport_id       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         fec_payload_id                        |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                header_extensions (if applicable)              |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       payload_reserved*       |          payload_len*         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        payload_offset*                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          payload_data*                        |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        NORM_DATA Message Format\n   *NOTE:  The \"payload_reserved\"\
    , \"payload_len\" and \"payload_offset\"\n   fields are present only for objects\
    \ of type NORM_OBJECT_STREAM.  The\n   \"payload_len\" and \"payload_offset\"\
    \ fields allow senders to\n   arbitrarily vary the size of NORM_DATA payload segments\
    \ for streams.\n   This allows applications to flush transmitted streams as needed\
    \ to\n   meet unique streaming requirements.  For objects of types\n   NORM_OBJECT_FILE\
    \ and NORM_OBJECT_DATA, these fields are unnecessary\n   since the receiver can\
    \ calculate the payload length and offset\n   information from the \"fec_payload_id\"\
    \ using the algorithm described\n   in Section 5.1.1.  The \"payload_reserved\"\
    \ field is kept for\n   anticipated future NORM stream control functions.  When\
    \ systematic\n   FEC codes (e.g., \"fec_id\" = 129) are used, the \"payload_len\"\
    \ and\n   \"payload_offset\" fields contain actual length and offset values for\n\
    \   the encapsulated application data segment for those NORM_DATA\n   messages\
    \ containing source data symbols.  In NORM_DATA messages that\n   contain parity\
    \ information, these fields are not actual length or\n   offset values, but instead\
    \ are values computed from FEC encoding the\n   \"payload_len\" and \"payload_offset\"\
    \ fields of the _source_ data\n   symbols of the corresponding applicable coding\
    \ block.\n   The \"version\", \"type\", \"hdr_len\", \"sequence\", and \"source_id\"\
    \ fields\n   form the NORM Common Message Header as described in Section 4.1.\
    \  The\n   value of the NORM_DATA \"type\" field is 2.  The NORM_DATA _base_\n\
    \   \"hdr_len\" value is 4 (32-bit words) plus the size of the\n   \"fec_payload_id\"\
    \ field.  The \"fec_payload_id\" field size depends upon\n   the FEC encoding\
    \ used for the referenced NormObject.  The \"fec_id\"\n   field is used to indicate\
    \ the FEC coding type.  For example, when\n   small block, systematic codes are\
    \ used, a \"fec_id\" value of 129 is\n   indicated and the size of the \"fec_payload_id\"\
    \ is two 32-bit words.\n   In this case the NORM_DATA base \"hdr_len\" value is\
    \ 6.  The cumulative\n   size of any header extensions applied is added into the\
    \ \"hdr_len\"\n   field.\n   The \"instance_id\" field contains a value generated\
    \ by the sender to\n   uniquely identify its current instance of participation\
    \ in the\n   NormSession.  This allows receivers to detect when senders have\n\
    \   perhaps left and rejoined a session in progress.  When a sender\n   (identified\
    \ by its \"source_id\") is detected to have a new\n   \"instance_id\", the NORM\
    \ receivers SHOULD drop their previous state on\n   the sender and begin reception\
    \ anew.\n   The \"grtt\" field contains a non-linear quantized representation\
    \ of\n   the sender's current estimate of group round-trip time (GRTT) (this\n\
    \   is also referred to as R_max in [19]).  This value is used to control\n  \
    \ timing of the NACK repair process and other aspects of protocol\n   operation\
    \ as described in this document.  The algorithm for encoding\n   and decoding\
    \ this field is described in the RMT NORM Building Block\n   document [4].\n \
    \  The \"backoff\" field value is used by receivers to determine the\n   maximum\
    \ backoff timer value used in the timer-based NORM NACK\n   feedback suppression.\
    \  This 4-bit field supports values from 0-15\n   which is multiplied by the sender\
    \ GRTT to determine the maximum\n   backoff timeout.  The \"backoff\" field informs\
    \ the receiver set of the\n   sender's backoff factor parameter \"Ksender\". \
    \ Recommended values and\n   their use are described in the NORM receiver NACK\
    \ procedure\n   description in Section 5.3.  The \"gsize\" field contains a\n\
    \   representation of the sender's current estimate of group size.  This\n   4-bit\
    \ field can roughly represent values from ten to 500 million\n   where the most\
    \ significant bit value of 0 or 1 represents a mantissa\n   of 1 or 5, respectively\
    \ and the three least significant bits\n   incremented by one represent a base\
    \ 10 exponent (order of magnitude).\n   For examples, a field value of \"0x0\"\
    \ represents 1.0e+01 (10), a value\n   of \"0x8\" represents 5.0e+01 (50), a value\
    \ of \"0x1\" represents 1.0e+02\n   (100), and a value of \"0xf\" represents 5.0e+08.\
    \  For NORM feedback\n   suppression purposes, the group size does not need to\
    \ be represented\n   with a high degree of precision.  The group size may even\
    \ be\n   estimated somewhat conservatively (i.e., overestimated) to maintain\n\
    \   low levels of feedback traffic.  A default group size estimate of\n   10,000\
    \ (\"gsize\" = 0x4) is recommended for general purpose reliable\n   multicast\
    \ applications using the NORM protocol.\n   The \"flags\" field contains a number\
    \ of different binary flags\n   providing information and hints regarding how\
    \ the receiver should\n   handle the identified object.  Defined flags in this\
    \ field include:\n"
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|        Flag        | Value |                 Purpose                 |'
  contents:
  - '|        Flag        | Value |                 Purpose                 |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|NORM_FLAG_REPAIR    | 0x01  | Indicates message is a repair           |'
  contents:
  - '|NORM_FLAG_REPAIR    | 0x01  | Indicates message is a repair           |

    '
- title: '|                    |       | transmission                            |'
  contents:
  - '|                    |       | transmission                            |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|NORM_FLAG_EXPLICIT  | 0x02  | Indicates a repair segment intended to  |'
  contents:
  - '|NORM_FLAG_EXPLICIT  | 0x02  | Indicates a repair segment intended to  |

    '
- title: '|                    |       | meet a specific receiver erasure, as    |'
  contents:
  - '|                    |       | meet a specific receiver erasure, as    |

    '
- title: '|                    |       | compared to parity segments provided by |'
  contents:
  - '|                    |       | compared to parity segments provided by |

    '
- title: '|                    |       | the sender for general purpose (with    |'
  contents:
  - '|                    |       | the sender for general purpose (with    |

    '
- title: '|                    |       | respect to an FEC coding block) erasure |'
  contents:
  - '|                    |       | respect to an FEC coding block) erasure |

    '
- title: '|                    |       | filling.                                |'
  contents:
  - '|                    |       | filling.                                |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|NORM_FLAG_INFO      | 0x04  | Indicates availability of NORM_INFO for |'
  contents:
  - '|NORM_FLAG_INFO      | 0x04  | Indicates availability of NORM_INFO for |

    '
- title: '|                    |       | object.                                 |'
  contents:
  - '|                    |       | object.                                 |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|NORM_FLAG_UNRELIABLE| 0x08  | Indicates that repair transmissions for |'
  contents:
  - '|NORM_FLAG_UNRELIABLE| 0x08  | Indicates that repair transmissions for |

    '
- title: '|                    |       | the specified object will be unavailable|'
  contents:
  - '|                    |       | the specified object will be unavailable|

    '
- title: '|                    |       | (One-shot, best effort transmission).   |'
  contents:
  - '|                    |       | (One-shot, best effort transmission).   |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|NORM_FLAG_FILE      | 0x10  | Indicates object is "file-based" data   |'
  contents:
  - '|NORM_FLAG_FILE      | 0x10  | Indicates object is "file-based" data   |

    '
- title: '|                    |       | (hint to use disk storage for           |'
  contents:
  - '|                    |       | (hint to use disk storage for           |

    '
- title: '|                    |       | reception).                             |'
  contents:
  - '|                    |       | reception).                             |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|NORM_FLAG_STREAM    | 0x20  | Indicates object is of type             |'
  contents:
  - '|NORM_FLAG_STREAM    | 0x20  | Indicates object is of type             |

    '
- title: '|                    |       | NORM_OBJECT_STREAM.                     |'
  contents:
  - '|                    |       | NORM_OBJECT_STREAM.                     |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - '+--------------------+-------+-----------------------------------------+

    '
- title: '|NORM_FLAG_MSG_START | 0x40  | Marks the first segment of application  |'
  contents:
  - '|NORM_FLAG_MSG_START | 0x40  | Marks the first segment of application  |

    '
- title: '|                    |       | messages embedded in                    |'
  contents:
  - '|                    |       | messages embedded in                    |

    '
- title: '|                    |       | NORM_OBJECT_STREAMs.                    |'
  contents:
  - '|                    |       | NORM_OBJECT_STREAMs.                    |

    '
- title: +--------------------+-------+-----------------------------------------+
  contents:
  - "+--------------------+-------+-----------------------------------------+\n  \
    \ NORM_FLAG_REPAIR is set when the associated message is a repair\n   transmission.\
    \  This information can be used by receivers to help\n   observe a join policy\
    \ where it is desired that newly joining\n   receivers only begin participating\
    \ in the NACK process upon receipt\n   of new (non-repair) data content.  NORM_FLAG_EXPLICIT\
    \ is used to mark\n   repair messages sent when the data sender has exhausted\
    \ its ability\n   to provide \"fresh\" (previously untransmitted) parity segments\
    \ as\n   repair.  This flag could possibly be used by intermediate systems\n \
    \  implementing functionality to control sub-casting of repair content\n   to\
    \ different legs of a reliable multicast topology with disparate\n   repair needs.\
    \  NORM_FLAG_INFO is set only when optional NORM_INFO\n   content is actually\
    \ available for the associated object.  Thus,\n   receivers will NACK for retransmission\
    \ of NORM_INFO only when it is\n   available for a given object.  NORM_FLAG_UNRELIABLE\
    \ is set when the\n   sender wishes to transmit an object with only \"best effort\"\
    \ delivery\n   and will not supply repair transmissions for the object.  NORM\n\
    \   receivers SHOULD NOT execute repair requests for objects marked with\n   the\
    \ NORM_FLAG_UNRELIABLE flag.  Note that receivers may inadvertently\n   request\
    \ repair of such objects when all segments (or info content)\n   for those objects\
    \ are not received (i.e., a gap in the\n   \"object_transport_id\" sequence is\
    \ noted).  In this case, the sender\n   should invoke the NORM_CMD(SQUELCH) process\
    \ as described in Section\n   4.2.3.  NORM_FLAG_FILE can be set as a \"hint\"\
    \ from the sender that\n   the associated object should be stored in non-volatile\
    \ storage.\n   NORM_FLAG_STREAM is set when the identified object is of type\n\
    \   NORM_OBJECT_STREAM.  When NORM_FLAG_STREAM is set, the\n   NORM_FLAG_MSG_START\
    \ can be optionally used to mark the first data\n   segments of application-layer\
    \ messages transported within the NORM\n   stream.  This allows NORM receiver\
    \ applications to \"synchronize\" with\n   NORM senders and to be able to properly\
    \ interpret application layer\n   data when joining a NORM session already in\
    \ progress.  In practice,\n   the NORM implementation MAY set this flag for the\
    \ segment transmitted\n   following an explicit \"flush\" of the stream by the\
    \ application.\n   The \"fec_id\" field corresponds to the FEC Encoding Identifier\n\
    \   described in the FEC Building Block document [5].  The \"fec_id\" value\n\
    \   implies the format of the \"fec_payload_id\" field and, coupled with\n   FEC\
    \ Object Transmission Information, the procedures to decode FEC\n   encoded content.\
    \  Small block, systematic codes (\"fec_id\" = 129) are\n   expected to be used\
    \ for most NORM purposes and the NORM_OBJECT_STREAM\n   requires systematic FEC\
    \ codes for most efficient performance.\n   The \"object_transport_id\" field\
    \ is a monotonically and incrementally\n   increasing value assigned by the sender\
    \ to NormObjects being\n   transmitted.  Transmissions and repair requests related\
    \ to that\n   object use the same \"object_transport_id\" value.  For sessions\
    \ of\n   very long or indefinite duration, the \"object_transport_id\" field may\n\
    \   be repeated, but it is presumed that the 16-bit field size provides\n   an\
    \ adequate enough sequence space to avoid object confusion amongst\n   receivers\
    \ and sources (i.e., receivers SHOULD re-synchronize with a\n   server when receiving\
    \ object sequence identifiers sufficiently out-\n   of-range with the current\
    \ state kept for a given source).  During the\n   course of its transmission within\
    \ a NORM session, an object is\n   uniquely identified by the concatenation of\
    \ the sender \"source_id\"\n   and the given \"object_transport_id\".  Note that\
    \ NORM_INFO messages\n   associated with the identified object carry the same\n\
    \   \"object_transport_id\" value.\n   The \"fec_payload_id\" identifies the attached\
    \ NORM_DATA \"payload\"\n   content.  The size and format of the \"fec_payload_id\"\
    \ field depends\n   upon the FEC type indicated by the \"fec_id\" field.  These\
    \ formats are\n   given in the FEC Building Block document [5] and any subsequent\n\
    \   extensions of that document.  As an example, the format of the\n   \"fec_payload_id\"\
    \ format small block, systematic codes (\"fec_id\" =\n   129) given here:\n  \
    \    0                   1                   2                   3\n     0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       source_block_number                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        source_block_len       |      encoding_symbol_id       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Small Block, Systematic Code (\"fec_id\" = 129) \"fec_payload_id\" Format\n\
    \   The FEC payload identifier \"source_block_number\", \"source_block_len\",\n\
    \   and \"encoding_symbol_id\" fields correspond to the \"Source Block\n   Number\"\
    , \"Source Block Length, and \"Encoding Symbol ID\" fields of the\n   FEC Payload\
    \ ID format given by the IETF FEC Building Block document\n   [5].  The \"source_block_number\"\
    \ identifies the coding block's\n   relative position with a NormObject.  Note\
    \ that, for NormObjects of\n   type NORM_OBJECT_STREAM, the \"source_block_number\"\
    \ may wrap for very\n   long lived sessions.  The \"source_block_len\" indicates\
    \ the number of\n   user data segments in the identified coding block.  Given\
    \ the\n   \"source_block_len\" information of how many symbols of application\n\
    \   data are contained in the block, the receiver can determine whether\n   the\
    \ attached segment is data or parity content and treat it\n   appropriately. \
    \ The \"encoding_symbol_id\" identifies which specific\n   symbol (segment) within\
    \ the coding block the attached payload\n   conveys.  Depending upon the value\
    \ of the \"encoding_symbol_id\" and\n   the associated \"source_block_len\" parameters\
    \ for the block, the\n   symbol (segment) referenced may be a user data or an\
    \ FEC parity\n   segment.  For systematic codes, encoding symbols numbered less\
    \ than\n   the source_block_len contain original application data while segments\n\
    \   greater than or equal to source_block_len contain parity symbols\n   calculated\
    \ for the block.  The concatenation of\n   object_transport_id::fec_payload_id\
    \ can be viewed as a unique\n   transport protocol data unit identifier for the\
    \ attached segment with\n   respect to the NORM sender's instance within a session.\n\
    \   Additional FEC Object Transmission Information (as described in the\n   FEC\
    \ Building Block document [5]) is required to properly receive and\n   decode\
    \ NORM transport objects.  This information MAY be provided as\n   out-of-band\
    \ session information.  However, in some cases, it may be\n   useful for the sender\
    \ to include this information \"in band\" to\n   facilitate receiver operation\
    \ with minimal preconfiguration.  For\n   this purpose, the NORM FEC Object Transmission\
    \ Information Header\n   Extension (EXT_FTI) is defined.  This header extension\
    \ MAY be applied\n   to NORM_DATA and NORM_INFO messages to provide this necessary\n\
    \   information.  The exact format of the extension depends upon the FEC\n   code\
    \ in use, but in general it SHOULD contain any required details on\n   the FEC\
    \ code in use (e.g., FEC Instance ID, etc.) and the byte size\n   of the associated\
    \ NormObject (For the NORM_OBJECT_STREAM type, this\n   size corresponds to the\
    \ stream buffer size maintained by the NORM\n   sender).  As an example, the format\
    \ of the EXT_FTI for small block\n   systematic codes (\"fec_id\" = 129) is given\
    \ here:\n      0                   1                   2                   3\n\
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    het = 64   |    hel = 4    |      object_length (msb)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      object_length (lsb)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       fec_instance_id         |          segment_size         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       fec_max_block_len       |         fec_num_parity        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   FEC Object Transmission Information Header Extension (EXT_FTI) for\n   Small\
    \ Block Systematic Codes (\"fec_id\" = 129)\n   The header extension type \"het\"\
    \ field value for this header extension\n   is 64.  The header extension length\
    \ \"hel\" depends upon the format of\n   the FTI for FEC code type identified\
    \ by the \"fec_id\" field.  In this\n   example (for \"fec_id\" = 129), the \"\
    hel\" field value is 4.\n   The 48-bit \"object_length\" field indicates the total\
    \ size of the\n   object (in bytes) for the static object types of NORM_OBJECT_FILE\
    \ and\n   NORM_OBJECT_DATA.  This information is used by receivers to determine\n\
    \   storage requirements and/or allocate storage for the received object.\n  \
    \ Receivers with insufficient storage capability may wish to forego\n   reliable\
    \ reception (i.e., not NACK for) of the indicated object.  In\n   the case of\
    \ objects of type NORM_OBJECT_STREAM, the \"object_length\"\n   field is used\
    \ by the sender to indicate the size of its stream buffer\n   to the receiver\
    \ group.  In turn, the receivers SHOULD use this\n   information to allocate a\
    \ stream buffer for reception of\n   corresponding size.\n   The \"fec_instance_id\"\
    \ corresponds to the \"FEC Instance ID\" described\n   in the FEC Building Block\
    \ document [5].  In this case, the\n   \"fec_instance_id\" SHALL be a value corresponding\
    \ to the particular\n   type of Small Block Systematic Code being used (e.g.,\
    \ Reed-Solomon\n   GF(2^8), Reed-Solomon GF(2^16), etc).  The standardized assignment\
    \ of\n   FEC Instance ID values is described in [5].  The \"segment_size\" field\n\
    \   indicates the sender's current setting for maximum message payload\n   content\
    \ (in bytes).  This allows receivers to allocate appropriate\n   buffering resources\
    \ and to determine other information in order to\n   properly process received\
    \ data messaging.\n   The \"fec_max_block_len\" indicates the current maximum\
    \ number of user\n   data segments per FEC coding block to be used by the sender\
    \ during\n   the session.  This allows receivers to allocate appropriate buffer\n\
    \   space for buffering blocks transmitted by the sender.\n   The \"fec_num_parity\"\
    \ corresponds to the \"maximum number of encoding\n   symbols that can be generated\
    \ for any source block\" as described in\n   for FEC Object Transmission Information\
    \ for Small Block Systematic\n   Codes in the FEC Building Block document [5].\
    \  For example, Reed-\n   Solomon codes may be arbitrarily shortened to create\
    \ different code\n   variations for a given block length.  In the case of Reed-Solomon\n\
    \   (GF(2^8) and GF(2^16)) codes, this value indicates the maximum number\n  \
    \ of parity segments available from the sender for the coding blocks.\n   This\
    \ field MAY be interpreted differently for other systematic codes\n   as they\
    \ are defined.\n   The payload portion of NORM_DATA messages includes source data\
    \ or FEC\n   encoded application content.\n   The \"payload_reserved\", \"payload_len\"\
    \ and \"payload_offset\" fields are\n   present ONLY for transport objects of\
    \ type NORM_OBJECT_STREAM.  These\n   fields indicate the size and relative position\
    \ (within the stream) of\n   the application content represented by the message\
    \ payload.  For\n   senders employing systematic FEC encoding, these fields contain\n\
    \   _actual_ length and offset values (in bytes) for the payload of\n   messages\
    \ which contain original data source symbols.  For NORM_DATA\n   messages containing\
    \ calculated parity content, these fields will\n   actually contain values computed\
    \ by FEC encoding of the \"payload_len\"\n   and \"payload_offset\" values of\
    \ the NORM_DATA data segments of the\n   corresponding FEC coding block.  Thus,\
    \ the \"payload_len\" and\n   \"payload_offset\" values of missing data content\
    \ can be determined\n   upon decoding a FEC coding block.  Note that these fields\
    \ do NOT\n   contribute to the value of the NORM_DATA \"hdr_len\" field.  These\n\
    \   fields are NOT present when the \"flags\" portion of the NORM_DATA\n   message\
    \ indicate the transport object if of type NORM_OBJECT_FILE or\n   NORM_OBJECT_DATA.\
    \  In this case, the length and offset information\n   can be calculated from\
    \ the \"fec_payload_id\" using the methodology\n   described in Section 5.1.1.\
    \  Note that for long-lived streams, the\n   \"payload_offset\" field can wrap.\n\
    \   The \"payload_data\" field contains the original application source  or\n\
    \   parity content for the symbol identified by the \"fec_payload_id\".\n   The\
    \ length of this field SHALL be limited to a maximum of the\n   sender's NormSegmentSize\
    \ bytes as given in the FTI for the object.\n   Note the length of this field\
    \ for messages containing parity content\n   will always be of length NormSegmentSize.\
    \  When encoding data\n   segments of varying sizes, the FEC encoder SHALL assume\
    \ ZERO value\n   padding for data segments with length less than the NormSegmentSize.\n\
    \   It is RECOMMENDED that a sender's NormSegmentSize generally be\n   constant\
    \ for the duration of a given sender's term of participation\n   in the session,\
    \ but may possibly vary on a per-object basis.  The\n   NormSegmentSize is expected\
    \ to be configurable by the sender\n   application prior to session participation\
    \ as needed for network\n   topology maximum transmission unit (MTU) considerations.\
    \  For IPv6,\n   MTU discovery may be possibly leveraged at session startup to\
    \ perform\n   this configuration.  The \"payload_data\" content may be delivered\n\
    \   directly to the application for source symbols (when systematic FEC\n   encoding\
    \ is used) or upon decoding of the FEC block.  For\n   NORM_OBJECT_FILE and NORM_OBJECT_STREAM\
    \ objects, the data segment\n   length and offset can be calculated using the\
    \ algorithm described in\n   Section 5.1.1.  For NORM_OBJECT_STREAM objects, the\
    \ length and offset\n   is obtained from the segment's corresponding \"payload_len\"\
    \ and\n   \"payload_offset\" fields.\n"
- title: 4.2.2.  NORM_INFO Message
  contents:
  - "4.2.2.  NORM_INFO Message\n   The NORM_INFO message is used to convey OPTIONAL,\
    \ application-\n   defined, \"out-of-band\" context information for transmitted\n\
    \   NormObjects.  An example NORM_INFO use for bulk file transfer is to\n   place\
    \ MIME type information for the associated file, data, or stream\n   object into\
    \ the NORM_INFO payload.  Receivers may use the NORM_INFO\n   content to make\
    \ a decision as whether to participate in reliable\n   reception of the associated\
    \ object.  Each NormObject can have an\n   independent unit of NORM_INFO associated\
    \ with it.  NORM_DATA messages\n   contain a flag to indicate the availability\
    \ of NORM_INFO for a given\n   NormObject.  NORM receivers may NACK for retransmission\
    \ of NORM_INFO\n   when they have not received it for a given NormObject.  The\
    \ size of\n   the NORM_INFO content is limited to that of a single NormSegmentSize\n\
    \   for the given sender.  This atomic nature allows the NORM_INFO to be\n   rapidly\
    \ and efficiently repaired within the NORM reliable\n   transmission process.\n\
    \   When NORM_INFO content is available for a NormObject, the\n   NORM_FLAG_INFO\
    \ flag SHALL be set in NORM_DATA messages for the\n   corresponding \"object_transport_id\"\
    \ and the NORM_INFO message shall\n   be transmitted as the first message for\
    \ the NormObject.\n      0                   1                   2           \
    \        3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |version| type=1|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     flags     |     fec_id    |     object_transport_id       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                header_extensions (if applicable)              |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         payload_data                          |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        NORM_INFO Message Format\n   The \"version\", \"type\"\
    , \"hdr_len\", \"sequence\", and \"source_id\" fields\n   form the NORM Common\
    \ Message Header as described in Section 4.1.  The\n   value of \"hdr_len\" field\
    \ when no header extensions are present is 4.\n   The \"instance_id\", \"grtt\"\
    , \"backoff\", \"gsize\", \"flags\", \"fec_id\", and\n   \"object_transport_id\"\
    \ fields carry the same information and serve the\n   same purpose as with NORM_DATA\
    \ messages.  These values allow the\n   receiver to prepare appropriate buffering,\
    \ etc, for further\n   transmissions from the sender when NORM_INFO is the first\
    \ message\n   received.\n   As with NORM_DATA messages, the NORM FTI Header Extension\
    \ (EXT_FTI)\n   may be optionally applied to NORM_INFO messages.  To conserve\n\
    \   protocol overhead, some NORM implementations may wish to apply the\n   EXT_FTI\
    \ when used to NORM_INFO messages only and not to NORM_DATA\n   messages.\n  \
    \ The NORM_INFO \"payload_data\" field contains sender application-\n   defined\
    \ content which can be used by receiver applications for\n   various purposes\
    \ as described above.\n"
- title: 4.2.3.  NORM_CMD Messages
  contents:
  - "4.2.3.  NORM_CMD Messages\n   NORM_CMD messages are transmitted by senders to\
    \ perform a number of\n   different protocol functions.  This includes functions\
    \ such as\n   round-trip timing collection, congestion control functions,\n  \
    \ synchronization of sender/receiver repair \"windows\", and notification\n  \
    \ of sender status.  A core set of NORM_CMD messages is enumerated.\n   Additionally,\
    \ a range of command types remain available for potential\n   application-specific\
    \ use.  Some NORM_CMD types may have dynamic\n   content attached.  Any attached\
    \ content will be limited to maximum\n   length of the sender NormSegmentSize\
    \ to retain the atomic nature of\n   commands.  All NORM_CMD messages begin with\
    \ a common set of fields,\n   after the usual NORM message common header.  The\
    \ standard NORM_CMD\n   fields are:\n      0                   1             \
    \      2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=3|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     flavor    |                                               |\n   +-+-+-+-+-+-+-+-+\
    \        NORM_CMD Content                       +\n   |                      \
    \        ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        NORM_CMD Standard Fields\n   The \"version\", \"type\"\
    , \"hdr_len\", \"sequence\", and \"source_id\" fields\n   form the NORM Common\
    \ Message Header as described in Section 4.1.  The\n   value of the \"hdr_len\"\
    \ field for NORM_CMD messages without header\n   extensions present depends upon\
    \ the \"flavor\" field.\n   The \"instance_id\", \"grtt\", \"backoff\", and \"\
    gsize\" fields provide the\n   same information and serve the same purpose as\
    \ with NORM_DATA and\n   NORM_INFO messages.  The \"flavor\" field indicates the\
    \ type of command\n   to follow.  The remainder of the NORM_CMD message is dependent\
    \ upon\n   the command type (\"flavor\").  NORM command flavors include:\n"
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|       Command        |Flavor Value |            Purpose              |'
  contents:
  - '|       Command        |Flavor Value |            Purpose              |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|NORM_CMD(FLUSH)       |      1      | Used to indicate sender         |'
  contents:
  - '|NORM_CMD(FLUSH)       |      1      | Used to indicate sender         |

    '
- title: '|                      |             | temporary end-of-transmission.  |'
  contents:
  - '|                      |             | temporary end-of-transmission.  |

    '
- title: '|                      |             | (Assists in robustly initiating |'
  contents:
  - '|                      |             | (Assists in robustly initiating |

    '
- title: '|                      |             | outstanding repair requests from|'
  contents:
  - '|                      |             | outstanding repair requests from|

    '
- title: '|                      |             | receivers).  May also be        |'
  contents:
  - '|                      |             | receivers).  May also be        |

    '
- title: '|                      |             | optionally used to collect      |'
  contents:
  - '|                      |             | optionally used to collect      |

    '
- title: '|                      |             | positive acknowledgment of      |'
  contents:
  - '|                      |             | positive acknowledgment of      |

    '
- title: '|                      |             | reliable reception from subset  |'
  contents:
  - '|                      |             | reliable reception from subset  |

    '
- title: '|                      |             | of receivers.                   |'
  contents:
  - '|                      |             | of receivers.                   |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|NORM_CMD(EOT)         |      2      | Used to indicate sender         |'
  contents:
  - '|NORM_CMD(EOT)         |      2      | Used to indicate sender         |

    '
- title: '|                      |             | permanent end-of-transmission.  |'
  contents:
  - '|                      |             | permanent end-of-transmission.  |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|NORM_CMD(SQUELCH)     |      3      | Used to advertise sender''s      |'
  contents:
  - '|NORM_CMD(SQUELCH)     |      3      | Used to advertise sender''s      |

    '
- title: '|                      |             | current repair window in        |'
  contents:
  - '|                      |             | current repair window in        |

    '
- title: '|                      |             | response to out-of-range NACKs  |'
  contents:
  - '|                      |             | response to out-of-range NACKs  |

    '
- title: '|                      |             | from receivers.                 |'
  contents:
  - '|                      |             | from receivers.                 |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|NORM_CMD(CC)          |      4      | Used for GRTT measurement and   |'
  contents:
  - '|NORM_CMD(CC)          |      4      | Used for GRTT measurement and   |

    '
- title: '|                      |             | collection of congestion control|'
  contents:
  - '|                      |             | collection of congestion control|

    '
- title: '|                      |             | feedback.                       |'
  contents:
  - '|                      |             | feedback.                       |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|NORM_CMD(REPAIR_ADV)  |      5      | Used to advertise sender''s      |'
  contents:
  - '|NORM_CMD(REPAIR_ADV)  |      5      | Used to advertise sender''s      |

    '
- title: '|                      |             | aggregated repair/feedback state|'
  contents:
  - '|                      |             | aggregated repair/feedback state|

    '
- title: '|                      |             | for suppression of unicast      |'
  contents:
  - '|                      |             | for suppression of unicast      |

    '
- title: '|                      |             | feedback from receivers.        |'
  contents:
  - '|                      |             | feedback from receivers.        |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|NORM_CMD(ACK_REQ)     |      6      | Used to request application-    |'
  contents:
  - '|NORM_CMD(ACK_REQ)     |      6      | Used to request application-    |

    '
- title: '|                      |             | defined positive acknowledgment |'
  contents:
  - '|                      |             | defined positive acknowledgment |

    '
- title: '|                      |             | from a list of receivers        |'
  contents:
  - '|                      |             | from a list of receivers        |

    '
- title: '|                      |             | (OPTIONAL).                     |'
  contents:
  - '|                      |             | (OPTIONAL).                     |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: '|NORM_CMD(APPLICATION) |      7      | Used for application-defined    |'
  contents:
  - '|NORM_CMD(APPLICATION) |      7      | Used for application-defined    |

    '
- title: '|                      |             | purposes which may need to      |'
  contents:
  - '|                      |             | purposes which may need to      |

    '
- title: '|                      |             | temporarily preempt data        |'
  contents:
  - '|                      |             | temporarily preempt data        |

    '
- title: '|                      |             | transmission (OPTIONAL).        |'
  contents:
  - '|                      |             | transmission (OPTIONAL).        |

    '
- title: +----------------------+-------------+---------------------------------+
  contents:
  - '+----------------------+-------------+---------------------------------+

    '
- title: 4.2.3.1.  NORM_CMD(FLUSH) Message
  contents:
  - "4.2.3.1.  NORM_CMD(FLUSH) Message\n   The NORM_CMD(FLUSH) command is sent when\
    \ the sender reaches the end\n   of all data content and pending repairs it has\
    \ queued for\n   transmission.  This may indicate a temporary or permanent end\
    \ of data\n   transmission, but the sender is still willing to respond to repair\n\
    \   requests.  This command is repeated once per 2*GRTT to excite the\n   receiver\
    \ set for any outstanding repair requests up to and including\n   the transmission\
    \ point indicated within the NORM_CMD(FLUSH) message.\n   The number of repeats\
    \ is equal to NORM_ROBUST_FACTOR unless a list of\n   receivers from which explicit\
    \ positive acknowledgment is expected\n   (\"acking_node_list\") is given.  In\
    \ that case, the \"acking_node_list\"\n   is updated as acknowledgments are received\
    \ and the NORM_CMD(FLUSH) is\n   repeated according to the mechanism described\
    \ in Section 5.5.3.  The\n   greater the NORM_ROBUST_FACTOR, the greater the probability\
    \ that all\n   applicable receivers will be excited for acknowledgment or repair\n\
    \   requests (NACKs) _and_ that the corresponding NACKs are delivered to\n   the\
    \ sender.  If a NORM_NACK message interrupts the flush process, the\n   sender\
    \ will re-initiate the flush process after any resulting repair\n   transmissions\
    \ are completed.\n   Note that receivers also employ a timeout mechanism to self-initiate\n\
    \   NACKing (if there are outstanding repair needs) when no messages of\n   any\
    \ type are received from a sender.  This inactivity timeout is\n   related to\
    \ 2*GRTT*NORM_ROBUST_FACTOR and will be discussed more\n   later.  With a sufficient\
    \ NORM_ROBUST_FACTOR value, data content is\n   delivered with a high assurance\
    \ of reliability.  The penalty of a\n   large NORM_ROBUST_FACTOR value is potentially\
    \ excess sender\n   NORM_CMD(FLUSH) transmissions and a longer timeout for receivers\
    \ to\n   self-initiate the terminal NACK process.\n   For finite-size transport\
    \ objects such as NORM_OBJECT_DATA and\n   NORM_OBJECT_FILE, the flush process\
    \ (if there are no further pending\n   objects) occurs at the end of these objects.\
    \  Thus, FEC repair\n   information is always available for repairs in response\
    \ to repair\n   requests elicited by the flush command.  However, for\n   NORM_OBJECT_STREAM,\
    \ the flush may occur at any time, including in the\n   middle of an FEC coding\
    \ block if systematic FEC codes are employed.\n   In this case, the sender will\
    \ not yet be able to provide FEC parity\n   content as repair for the concurrent\
    \ coding block and will be limited\n   to explicitly repairing stream data content\
    \ for that block.\n   Applications that anticipate frequent flushing of stream\
    \ content\n   SHOULD be judicious in the selection of the FEC coding block size\n\
    \   (i.e., do not use a very large coding block size if frequent flushing\n  \
    \ occurs).  For example, a reliable multicast application transmitting\n   an\
    \ on-going series of intermittent, relatively small messaging\n   content will\
    \ need to trade-off using the NORM_OBJECT_DATA paradigm\n   versus the NORM_OBJECT_STREAM\
    \ paradigm with an appropriate FEC coding\n   block size.  This is analogous to\
    \ application trade-offs for other\n   transport protocols such as the selection\
    \ of different TCP modes of\n   operation such as \"no delay\", etc.\n      0\
    \                   1                   2                   3\n     0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=3|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   flavor = 1  |    fec_id     |      object_transport_id      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         fec_payload_id                        |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                acking_node_list (if applicable)               |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     NORM_CMD(FLUSH) Message Format\n   In addition to the NORM\
    \ common message header and standard NORM_CMD\n   fields, the NORM_CMD(FLUSH)\
    \ message contains fields to identify the\n   current status and logical transmit\
    \ position of the sender.\n   The \"fec_id\" field indicates the FEC type used\
    \ for the flushing\n   \"object_transport_id\" and implies the size and format\
    \ of the\n   \"fec_payload_id\" field.  Note the \"hdr_len\" value for the\n \
    \  NORM_CMD(FLUSH) message is 4 plus the size of the \"fec_payload_id\"\n   field\
    \ when no header extensions are present.\n   The \"object_transport_id\" and \"\
    fec_payload_id\" fields indicate the\n   sender's current logical \"transmit position\"\
    .  These fields are\n   interpreted in the same manner as in the NORM_DATA message\
    \ type.\n   Upon receipt of the NORM_CMD(FLUSH), receivers are expected to check\n\
    \   their completion state _through_ (including) this transmission\n   position.\
    \  If receivers have outstanding repair needs in this range,\n   they SHALL initiate\
    \ the NORM NACK Repair Process as described in\n   Section 5.3.  If receivers\
    \ have no outstanding repair needs, no\n   response to the NORM_CMD(FLUSH) is\
    \ generated.\n   For NORM_OBJECT_STREAM objects using systematic FEC codes, receivers\n\
    \   MUST request \"explicit-only\" repair of the identified\n   \"source_block_number\"\
    \ if the given \"encoding_symbol_id\" is less than\n   the \"source_block_len\"\
    .  This condition indicates the sender has not\n   yet completed encoding the\
    \ corresponding FEC block and parity content\n   is not yet available.  An \"\
    explicit-only\" repair request consists of\n   NACK content for the applicable\
    \ \"source_block_number\" which does not\n   include any requests for parity-based\
    \ repair.  This allows NORM\n   sender applications to \"flush\" an ongoing stream\
    \ of transmission when\n   needed, even if in the middle of an FEC block.  Once\
    \ the sender\n   resumes stream transmission and passes the end of the pending\
    \ coding\n   block, subsequent NACKs from receivers SHALL request parity-based\n\
    \   repair as usual.  Note that the use of a systematic FEC code is\n   assumed\
    \ here.  Normal receiver NACK initiation and construction is\n   discussed in\
    \ detail in Section 5.3.  The OPTIONAL \"acking_node_list\"\n   field contains\
    \ a list of NormNodeIds for receivers from which the\n   sender is requesting\
    \ explicit positive acknowledgment of reception up\n   through the transmission\
    \ point identified by the\n   \"object_transport_id\" and \"fec_payload_id\" fields.\
    \  The length of the\n   list can be inferred from the length of the received\
    \ NORM_CMD(FLUSH)\n   message.  When the \"acking_node_list\" is present, the\
    \ lightweight\n   positive acknowledgment process described in Section 5.5.3 SHALL\
    \ be\n   observed.\n"
- title: 4.2.3.2.  NORM_CMD(EOT) Message
  contents:
  - "4.2.3.2.  NORM_CMD(EOT) Message\n   The NORM_CMD(EOT) command is sent when the\
    \ sender reaches permanent\n   end-of-transmission with respect to the NormSession\
    \ and will not\n   respond to further repair requests.  This allows receivers\
    \ to\n   gracefully reach closure of operation with this sender (without\n   requiring\
    \ any timeout) and free any resources that are no longer\n   needed.  The NORM_CMD(EOT)\
    \ command SHOULD be sent with the same\n   robust mechanism as used for NORM_CMD(FLUSH)\
    \ commands to provide a\n   high assurance of reception by the receiver set.\n\
    \      0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=3|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   flavor = 2  |                    reserved                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      NORM_CMD(EOT) Message Format\n   The value of the \"hdr_len\"\
    \ field for NORM_CMD(EOT) messages without\n   header extensions present is 4.\
    \  The \"reserved\" field is reserved for\n   future use and MUST be set to an\
    \ all ZERO value.  Receivers MUST\n   ignore the \"reserved\" field.\n"
- title: 4.2.3.3.  NORM_CMD(SQUELCH) Message
  contents:
  - "4.2.3.3.  NORM_CMD(SQUELCH) Message\n   The NORM_CMD(SQUELCH) command is transmitted\
    \ in response to outdated\n   or invalid NORM_NACK content received by the sender.\
    \  Invalid\n   NORM_NACK content consists of repair requests for NormObjects for\n\
    \   which the sender is unable or unwilling to provide repair.  This\n   includes\
    \ repair requests for outdated objects, aborted objects, or\n   those objects\
    \ which the sender previously transmitted marked with the\n   NORM_FLAG_UNRELIABLE\
    \ flag.  This command indicates to receivers what\n   content is available for\
    \ repair, thus serving as a description of the\n   sender's current \"repair window\"\
    .  Receivers SHALL not generate\n   repair requests for content identified as\
    \ invalid by a\n   NORM_CMD(SQUELCH).\n   The NORM_CMD(SQUELCH) command is sent\
    \ once per 2*GRTT at the most.\n   The NORM_CMD(SQUELCH) advertises the current\
    \ \"repair window\" of the\n   sender by identifying the earliest (lowest) transmission\
    \ point for\n   which it will provide repair, along with an encoded list of objects\n\
    \   from that point forward that are no longer valid for repair.  This\n   mechanism\
    \ allows the sender application to cancel or abort\n   transmission and/or repair\
    \ of specific previously enqueued objects.\n   The list also contains the identifiers\
    \ for any objects within the\n   repair window that were sent with the NORM_FLAG_UNRELIABLE\
    \ flag set.\n   In normal conditions, it is expected the NORM_CMD(SQUELCH) will\
    \ be\n   needed infrequently, and generally only to provide a reference repair\n\
    \   window for receivers who have fallen \"out-of-sync\" with the sender\n   due\
    \ to extremely poor network conditions.\n   The starting point of the invalid\
    \ NormObject list begins with the\n   lowest invalid NormTransportId greater than\
    \ the current \"repair\n   window\" start from the invalid NACK(s) that prompted\
    \ the generation\n   of the squelch.  The length of the list is limited by the\
    \ sender's\n   NormSegmentSize.  This allows the receivers to learn the status\
    \ of\n   the sender's applicable object repair window with minimal\n   transmission\
    \ of NORM_CMD(SQUELCH) commands.  The format of the\n   NORM_CMD(SQUELCH) message\
    \ is:\n      0                   1                   2                   3\n \
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    version    |   type = 3    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  flavor = 3   |     fec_id    |      object_transport_id      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         fec_payload_id                        |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        invalid_object_list                    |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    NORM_CMD(SQUELCH) Message Format\n   In addition to the NORM\
    \ common message header and standard NORM_CMD\n   fields, the NORM_CMD(SQUELCH)\
    \ message contains fields to identify the\n   earliest logical transmit position\
    \ of the sender's current repair\n   window and an \"invalid object list\" beginning\
    \ with the index of the\n   logically earliest invalid repair request from the\
    \ offending NACK\n   message which initiated the squelch transmission.\n   The\
    \ \"object_transport_id\" and \"fec_payload_id\" fields are\n   concatenated to\
    \ indicate the beginning of the sender's current repair\n   window (i.e., the\
    \ logically earliest point in its transmission\n   history for which the sender\
    \ can provide repair).  The \"fec_id\" field\n   implies the size and format of\
    \ the \"fec_payload_id\" field.  This\n   serves as an advertisement of a \"synchronization\
    \ point\" for receivers\n   to request repair.  Note, that while an \"encoding_symbol_id\"\
    \ may be\n   included in the \"fec_payload_id\" field, the sender's repair window\n\
    \   SHOULD be aligned on FEC coding block boundaries and thus the\n   \"encoding_symbol_id\"\
    \ SHOULD be zero.\n   The \"invalid_object_list\" is a list of 16-bit NormTransportIds\
    \ that,\n   although they are within the range of the sender's current repair\n\
    \   window, are no longer available for repair from the sender.  For\n   example,\
    \ a sender application may dequeue an out-of-date object even\n   though it is\
    \ still within the repair window.  The total size of the\n   \"invalid_object_list\"\
    \ content is can be determined from the packet's\n   payload length and is limited\
    \ to a maximum of the NormSegmentSize of\n   the sender.  Thus, for very large\
    \ repair windows, it is possible that\n   a single NORM_CMD(SQUELCH) message may\
    \ not be capable of listing the\n   entire set of invalid objects in the repair\
    \ window.  In this case,\n   the sender SHALL ensure that the list begins with\
    \ a NormObjectId that\n   is greater than or equal to the lowest ordinal invalid\
    \ NormObjectId\n   from the NACK message(s) that prompted the NORM_CMD(SQUELCH)\n\
    \   generation.  The NormObjectIds in the \"invalid_object_list\" MUST be\n  \
    \ greater than the \"object_transport_id\" marking the beginning of the\n   sender's\
    \ repair window.  This insures convergence of the squelch\n   process, even if\
    \ multiple invalid NACK/ squelch iterations are\n   required.  This explicit description\
    \ of invalid content within the\n   sender's current window allows the sender\
    \ application (most notably\n   for discrete \"object\" based transport) to arbitrarily\
    \ invalidate\n   (i.e., dequeue) portions of enqueued content (e.g., certain objects)\n\
    \   for which it no longer wishes to provide reliable transport.\n"
- title: 4.2.3.4.  NORM_CMD(CC) Message
  contents:
  - "4.2.3.4.  NORM_CMD(CC) Message\n   The NORM_CMD(CC) messages contains fields\
    \ to enable sender-to-\n   receiver group greatest round-trip time (GRTT) measurement\
    \ and to\n   excite the group for congestion control feedback.  A baseline NORM\n\
    \   congestion control scheme (NORM-CC), based on the TCP-Friendly\n   Multicast\
    \ Congestion Control (TFMCC) scheme of [19] is described in\n   Section 5.5.2\
    \ of this document.  The NORM_CMD(CC) message is usually\n   transmitted as part\
    \ of NORM-CC congestion control operation.  A NORM\n   header extension is defined\
    \ below to be used with the NORM_CMD(CC)\n   message to support NORM-CC operation.\
    \  Different header extensions\n   may be defined for the NORM_CMD(CC) (and/or\
    \ other NORM messages as\n   needed) to support alternative congestion control\
    \ schemes in the\n   future.  If NORM is operated in a private network with congestion\n\
    \   control operation disabled, the NORM_CMD(CC) message is then used for\n  \
    \ GRTT measurement only and may optionally be sent less frequently than\n   with\
    \ congestion control operation.\n      0                   1                 \
    \  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=3|    hdr_len    |            sequence           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   flavor = 4  |    reserved   |          cc_sequence          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         send_time_sec                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        send_time_usec                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               header extensions (if applicable)               |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  cc_node_list (if applicable)                 |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      NORM_CMD(CC) Message Format\n   The NORM common message\
    \ header and standard NORM_CMD fields serve\n   their usual purposes.\n   The\
    \ \"reserved\" field is for potential future use and should be set to\n   ZERO\
    \ in this version of the NORM protocol.\n   The \"cc_sequence\" field is a sequence\
    \ number applied by the sender.\n   For NORM-CC operation, it is used to provide\
    \ functionality equivalent\n   to the \"feedback round number\" (fb_nr)described\
    \ in [19].  The most\n   recently received \"cc_sequence\" value is recorded by\
    \ receivers and\n   can be fed back to the sender in congestion control feedback\n\
    \   generated by the receivers for that sender.  The \"cc_sequence\" number\n\
    \   can also be used in NORM implementations to assess how recently a\n   receiver\
    \ has received NORM_CMD(CC) probes from the sender.  This can\n   be useful instrumentation\
    \ for complex or experimental multicast\n   routing environments.\n   The \"send_time\"\
    \ field is a timestamp indicating the time that the\n   NORM_CMD(CC) message was\
    \ transmitted.  This consists of a 64-bit\n   field containing 32-bits with the\
    \ time in seconds (\"send_time_sec\")\n   and 32-bits with the time in microseconds\
    \ (\"send_time_usec\") since\n   some reference time the source maintains (usually\
    \ 00:00:00, 1 January\n   1970).  The byte ordering of the fields is \"Big Endian\"\
    \ network\n   order.  Receivers use this timestamp adjusted by the amount of delay\n\
    \   from the time they received the NORM_CMD(CC) message to the time of\n   their\
    \ response as the \"grtt_response\" portion of NORM_ACK and\n   NORM_NACK messages\
    \ generated.  This allows the sender to evaluate\n   round-trip times to different\
    \ receivers for congestion control and\n   other (e.g., GRTT determination) purposes.\n\
    \   To facilitate the baseline NORM-CC scheme described in Section 5.5.2,\n  \
    \ a NORM-CC Rate header extension (EXT_RATE) is defined to inform the\n   group\
    \ of the sender's current transmission rate.  This is used along\n   with the\
    \ loss detection \"sequence\" field of all NORM sender messages\n   and the NORM_CMD(CC)\
    \ GRTT collection process to support NORM-CC\n   congestion control operation.\
    \  The format of this header extension is\n   as follows:\n      0           \
    \        1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    het = 128  |    reserved   |           send_rate           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            NORM-CC Rate Header Extension Format (EXT_RATE)\n   The \"send_rate\"\
    \ field indicates the sender's current transmission\n   rate in bytes per second.\
    \  The 16-bit \"send_rate\" field consists of\n   12 bits of mantissa in the most\
    \ significant portion and 4 bits of\n   base 10 exponent (order of magnitude)\
    \ information in the least\n   significant portion.  The 12-bit mantissa portion\
    \ of the field is\n   scaled such that a floating point value of 0.0 corresponds\
    \ to 0 and a\n   floating point value of 10.0 corresponds to 4096.  Thus:\n  \
    \ send_rate = (((int)(Value_mantissa * 4096.0 / 10.0 + 0.5)) << 4) |\n   Value_exponent;\n\
    \   For example, to represent a transmission rate of 256kbps (3.2e+04\n   bytes\
    \ per second), the lower 4 bits of the 16-bit field contain a\n   value of 0x04\
    \ to represent the exponent while the upper 12 bits\n   contain a value of 0x51f\
    \ as determined from the equation given above:\n"
- title: send_rate = (((int)((3.2 * 4096.0 / 10.0) + 0.5)) << 4) | 4;
  contents:
  - "send_rate = (((int)((3.2 * 4096.0 / 10.0) + 0.5)) << 4) | 4;\n          = (0x51f\
    \ << 4) | 0x4\n          = 0x51f4\n"
- title: 'To decode the "send_rate" field, the following equation can be used:'
  contents:
  - 'To decode the "send_rate" field, the following equation can be used:

    '
- title: value = (send_rate >> 4) * 10.0 / 4096.0 *
  contents:
  - "value = (send_rate >> 4) * 10.0 / 4096.0 *\n        power(10.0, (send_rate &\
    \ x000f))\n   Note the maximum transmission rate that can be represented by this\n\
    \   scheme is approximately 9.99e+15 bytes per second.\n   When this extension\
    \ is present, a \"cc_node_list\" may be attached as\n   the payload of the NORM_CMD(CC)\
    \ message.  The presence of this header\n   extension also implies that NORM receivers\
    \ should respond according\n   to the procedures described in Section 5.5.2. \
    \ The \"cc_node_list\"\n   consists of a list of NormNodeIds and their associated\
    \ congestion\n   control status.  This includes the current limiting receiver\
    \ (CLR)\n   node, any potential limiting receiver (PLR) nodes that have been\n\
    \   identified, and some number of receivers for which congestion control\n  \
    \ status is being provided, most notably including the receivers'\n   current\
    \ RTT measurement.  The maximum length of the \"cc_node_list\"\n   provides for\
    \ at least the CLR and one other receiver, but may be\n   configurable for more\
    \ timely feedback to the group.  The list length\n   can be inferred from the\
    \ length of the NORM_CMD(CC) message.\n   Each item in the \"cc_node_list\" is\
    \ in the following format:\n      0                   1                   2  \
    \                 3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          cc_node_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    cc_flags   |     cc_rtt    |            cc_rate            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Congestion Control Node List Item Format\n   The \"cc_node_id\"\
    \ is the NormNodeId of the receiver which the item\n   represents.\n   The \"\
    cc_flags\" field contains flags indicating the congestion control\n   status of\
    \ the indicated receiver.  The following flags are defined:\n"
- title: +------------------+-------+------------------------------------------+
  contents:
  - '+------------------+-------+------------------------------------------+

    '
- title: '|      Flag        | Value |                 Purpose                  |'
  contents:
  - '|      Flag        | Value |                 Purpose                  |

    '
- title: +------------------+-------+------------------------------------------+
  contents:
  - '+------------------+-------+------------------------------------------+

    '
- title: '|NORM_FLAG_CC_CLR  | 0x01  | Receiver is the current limiting         |'
  contents:
  - '|NORM_FLAG_CC_CLR  | 0x01  | Receiver is the current limiting         |

    '
- title: '|                  |       | receiver (CLR).                          |'
  contents:
  - '|                  |       | receiver (CLR).                          |

    '
- title: +------------------+-------+------------------------------------------+
  contents:
  - '+------------------+-------+------------------------------------------+

    '
- title: '|NORM_FLAG_CC_PLR  | 0x02  | Receiver is a potential limiting         |'
  contents:
  - '|NORM_FLAG_CC_PLR  | 0x02  | Receiver is a potential limiting         |

    '
- title: '|                  |       | receiver (PLR).                          |'
  contents:
  - '|                  |       | receiver (PLR).                          |

    '
- title: +------------------+-------+------------------------------------------+
  contents:
  - '+------------------+-------+------------------------------------------+

    '
- title: '|NORM_FLAG_CC_RTT  | 0x04  | Receiver has measured RTT with respect   |'
  contents:
  - '|NORM_FLAG_CC_RTT  | 0x04  | Receiver has measured RTT with respect   |

    '
- title: '|                  |       | to sender.                               |'
  contents:
  - '|                  |       | to sender.                               |

    '
- title: +------------------+-------+------------------------------------------+
  contents:
  - '+------------------+-------+------------------------------------------+

    '
- title: '|NORM_FLAG_CC_START| 0x08  | Sender/receiver is in "slow start" phase |'
  contents:
  - '|NORM_FLAG_CC_START| 0x08  | Sender/receiver is in "slow start" phase |

    '
- title: '|                  |       | of congestion control operation (i.e.,   |'
  contents:
  - '|                  |       | of congestion control operation (i.e.,   |

    '
- title: '|                  |       | The receiver has not yet detected any    |'
  contents:
  - '|                  |       | The receiver has not yet detected any    |

    '
- title: '|                  |       | packet loss and the "cc_rate" field is   |'
  contents:
  - '|                  |       | packet loss and the "cc_rate" field is   |

    '
- title: '|                  |       | the receiver''s actual measured receive   |'
  contents:
  - '|                  |       | the receiver''s actual measured receive   |

    '
- title: '|                  |       | rate).                                   |'
  contents:
  - '|                  |       | rate).                                   |

    '
- title: +------------------+-------+------------------------------------------+
  contents:
  - '+------------------+-------+------------------------------------------+

    '
- title: '|NORM_FLAG_CC_LEAVE| 0x10  | Receiver is imminently leaving the       |'
  contents:
  - '|NORM_FLAG_CC_LEAVE| 0x10  | Receiver is imminently leaving the       |

    '
- title: '|                  |       | session and its feedback should not be   |'
  contents:
  - '|                  |       | session and its feedback should not be   |

    '
- title: '|                  |       | considered in congestion control         |'
  contents:
  - '|                  |       | considered in congestion control         |

    '
- title: '|                  |       | operation.                               |'
  contents:
  - '|                  |       | operation.                               |

    '
- title: +------------------+-------+------------------------------------------+
  contents:
  - "+------------------+-------+------------------------------------------+\n   The\
    \ \"cc_rtt\" contains a quantized representation of the RTT as\n   measured by\
    \ the sender with respect to the indicated receiver.  This\n   field is valid\
    \ only if the NORM_FLAG_CC_RTT flag is set in the\n   \"cc_flags\" field.  This\
    \ one byte field is a quantized representation\n   of the RTT using the algorithm\
    \ described in the NORM Building Block\n   document [4].  The \"cc_rate\" field\
    \ contains a representation of the\n   receiver's current calculated (during steady-state\
    \ congestion control\n   operation) or twice its measured (during the \"slow start\"\
    \ phase)\n   congestion control rate.  This field is encoded and decoded using\
    \ the\n   same technique as described for the NORM_CMD(CC) \"send_rate\" field.\n"
- title: 4.2.3.5.  NORM_CMD(REPAIR_ADV) Message
  contents:
  - "4.2.3.5.  NORM_CMD(REPAIR_ADV) Message\n   The NORM_CMD(REPAIR_ADV) message is\
    \ used by the sender to \"advertise\"\n   its aggregated repair state from NORM_NACK\
    \ messages accumulated\n   during a repair cycle and/or congestion control feedback\
    \ received.\n   This message is sent only when the sender has received NORM_NACK\n\
    \   and/or NORM_ACK(CC) (when congestion control is enabled) messages via\n  \
    \ unicast transmission instead of multicast.  By \"echoing\" this\n   information\
    \ to the receiver set, suppression of feedback can be\n   achieved even when receivers\
    \ are unicasting that feedback instead of\n   multicasting it among the group\
    \ [13].\n      0                   1                   2                   3\n\
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=3|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  flavor = 5   |     flags     |            reserved           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               header extensions (if applicable)               |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       repair_adv_payload                      |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  NORM_CMD(REPAIR_ADV) Message Format\n   The \"instance_id\"\
    , \"grtt\", \"backoff\", \"gsize\", and \"flavor\" fields\n   serve the same purpose\
    \ as in other NORM_CMD messages.  The value of\n   the \"hdr_len\" field when\
    \ no extensions are present is 4.\n   The \"flags\" field provide information\
    \ on the NORM_CMD(REPAIR_ADV)\n   content.  There is currently one NORM_CMD(REPAIR_ADV)\
    \ flag defined:\n                     NORM_REPAIR_ADV_FLAG_LIMIT = 0x01\n   This\
    \ flag is set by the sender when it is unable to fit its full\n   current repair\
    \ state into a single NormSegmentSize.  If this flag is\n   set, receivers should\
    \ limit their NACK response to generating NACK\n   content only up through the\
    \ maximum ordinal transmission position\n   (objectId::fecPayloadId) included\
    \ in the \"repair_adv_content\".\n   When congestion control operation is enabled,\
    \ a header extension may\n   be applied to the NORM_CMD(REPAIR_ADV) representing\
    \ the most limiting\n   (in terms of congestion control feedback suppression)\
    \ congestion\n   control response.  This allows the NORM_CMD(REPAIR_ADV) message\
    \ to\n   suppress receiver congestion control responses as well as NACK\n   feedback\
    \ messages.  The field is defined as a header extension so\n   that alternative\
    \ congestion control schemes may be used with NORM\n   without revision to this\
    \ document.  A NORM-CC Feedback Header\n   Extension (EXT_CC) is defined to encapsulate\
    \ congestion control\n   feedback within NORM_NACK, NORM_ACK, and NORM_CMD(REPAIR_ADV)\n\
    \   messages.  If another congestion control technique (e.g., Pragmatic\n   General\
    \ Multicast Congestion Control (PGMCC) [20]) is used within a\n   NORM implementation,\
    \ an additional header extension MAY need to be\n   defined to encapsulate any\
    \ required feedback content.  The NORM-CC\n   Feedback Header Extension format\
    \ is:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     het = 3   |    hel = 3    |          cc_sequence          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    cc_flags   |     cc_rtt    |            cc_loss            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            cc_rate            |          cc_reserved          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           NORM-CC Feedback Header Extension (EXT_CC) Format\n   The \"cc_sequence\"\
    \ field contains the current greatest \"cc_sequence\"\n   value receivers have\
    \  received in NORM_CMD(CC) messages from the\n   sender.  This information assists\
    \ the sender in congestion control\n   operation by providing an indicator of\
    \ how current (\"fresh\") the\n   receiver's round-trip measurement reference\
    \ time is and whether the\n   receiver has been successfully receiving recent\
    \ congestion control\n   probes.  For example, if it is apparent the receiver\
    \ has not been\n   receiving recent congestion control probes (and thus possibly\
    \ other\n   messages from the sender), the sender may choose to take congestion\n\
    \   avoidance measures.  For NORM_CMD(REPAIR_ADV) messages, the sender\n   SHALL\
    \ set the \"cc_sequence\" field value to the value set in the last\n   NORM_CMD(CC)\
    \ message sent.\n   The \"cc_flags\" field contains bits representing the receiver's\
    \ state\n   with respect to congestion control operation.  The possible values\n\
    \   for the \"cc_flags\" field are those specified for the NORM_CMD(CC)\n   message\
    \ node list item flags.  These fields are used by receivers in\n   controlling\
    \ (suppressing as necessary) their congestion control\n   feedback.  For NORM_CMD(REPAIR_ADV)\
    \ messages, the NORM_FLAG_CC_RTT\n   should be set only when all feedback messages\
    \ received by the sender\n   have the flag set.  Similarly, the NORM_FLAG_CC_CLR\
    \ or\n   NORM_FLAG_CC_PLR should be set only when no feedback has been\n   received\
    \ from non-CLR or non-PLR receivers.  And the\n   NORM_FLAG_CC_LEAVE should be\
    \ set only when all feedback messages the\n   sender has received have this flag\
    \ set.  These heuristics for setting\n   the flags in NORM_CMD(REPAIR_ADV) ensure\
    \ the most effective\n   suppression of receivers providing unicast feedback messages.\n\
    \   The \"cc_rtt\" field SHALL be set to a default maximum value and the\n   NORM_FLAG_CC_RTT\
    \ flag SHALL be cleared when no receiver has yet\n   received RTT measurement\
    \ information.  When a receiver has received\n   RTT measurement information,\
    \ it shall set the \"cc_rtt\" value\n   accordingly and set the NORM_FLAG_CC_RTT\
    \ flag in the \"cc_flags\"\n   field.\n   For NORM_CMD(REPAIR_ADV) messages, the\
    \ sender SHALL set the \"cc_rtt\"\n   field value to the largest non-CLR/non-PLR\
    \ RTT it has measured from\n   receivers for the current feedback round.\n   The\
    \ \"cc_loss\" field represents the receiver's current packet loss\n   fraction\
    \ estimate for the indicated source.  The loss fraction is a\n   value from 0.0\
    \ to 1.0 corresponding to a range of zero to 100 percent\n   packet loss.  The\
    \ 16-bit \"cc_loss\" value is calculated by the\n   following formula:\n     \
    \           \"cc_loss\" = decimal_loss_fraction * 65535.0\n   For NORM_CMD(REPAIR_ADV)\
    \ messages, the sender SHALL set the \"cc_loss\"\n   field value to the largest\
    \ non-CLR/non-PLR loss estimate it has\n   received from receivers for the current\
    \ feedback round.\n   The \"cc_rate\" field represents the receivers current local\
    \ congestion\n   control rate.  During \"slow start\", when the receiver has detected\
    \ no\n   loss, this value is set to twice the actual rate it has measured from\n\
    \   the corresponding sender and the NORM_FLAG_CC_START is set in the\n   \"cc_flags'\
    \ field.  Otherwise, the receiver calculates a congestion\n   control rate based\
    \ on its loss measurement and RTT measurement\n   information (even if default)\
    \ for the \"cc_rate\" field.  For\n   NORM_CMD(REPAIR_ADV) messages, the sender\
    \ SHALL set the \"cc_loss\"\n   field value to the lowest non-CLR/non-PLR \"cc_rate\"\
    \ report it has\n   received from receivers for the current feedback round.\n\
    \   The \"cc_reserved\" field is reserved for future NORM protocol use.\n   Currently,\
    \ senders SHALL set this field to ZERO, and receivers SHALL\n   ignore the content\
    \ of this field.\n   The \"repair_adv_payload\" is in exactly the same form as\
    \ the\n   \"nack_content\" of NORM_NACK messages and can be processed by\n   receivers\
    \ for suppression purposes in the same manner, with the\n   exception of the condition\
    \ when the NORM_REPAIR_ADV_FLAG_LIMIT is\n   set.\n"
- title: 4.2.3.6.  NORM_CMD(ACK_REQ) Message
  contents:
  - "4.2.3.6.  NORM_CMD(ACK_REQ) Message\n   The NORM_CMD(ACK_REQ) message is used\
    \ by the sender to request\n   acknowledgment from a specified list of receivers.\
    \  This message is\n   used in providing a lightweight positive acknowledgment\
    \ mechanism\n   that is OPTIONAL for use by the reliable multicast application.\
    \  A\n   range of acknowledgment request types is provided for use at the\n  \
    \ application's discretion.  Provision for application-defined,\n   positively-acknowledged\
    \ commands allows the application to\n   automatically take advantage of transmission\
    \ and round-trip timing\n   information available to the NORM protocol.  The details\
    \ of the NORM\n   positive acknowledgment process including transmission of the\n\
    \   NORM_CMD(ACK_REQ) messages and the receiver response (NORM_ACK) are\n   described\
    \ in Section 5.5.3.  The format of the NORM_CMD(ACK_REQ)\n   message is:\n   \
    \   0                   1                   2                   3\n     0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=3|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  flavor = 6   |    reserved   |    ack_type   |    ack_id     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       acking_node_list                        |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    NORM_CMD(ACK_REQ) Message Format\n   The NORM common message\
    \ header and standard NORM_CMD fields serve\n   their usual purposes.  The value\
    \ of the \"hdr_len\" field for\n   NORM_CMD(ACK_REQ) messages with no header extension\
    \ present is 4.\n   The \"ack_type\" field indicates the type of acknowledgment\
    \ being\n   requested and thus implies rules for how the receiver will treat this\n\
    \   request.  The following \"ack_type\" values are defined and are also\n   used\
    \ in NORM_ACK messages described later:\n"
- title: +---------------------+--------+---------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------+

    '
- title: '|      ACK Type       | Value  |            Purpose              |'
  contents:
  - '|      ACK Type       | Value  |            Purpose              |

    '
- title: +---------------------+--------+---------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------+

    '
- title: '|NORM_ACK_CC          |      1 | Used to identify NORM_ACK       |'
  contents:
  - '|NORM_ACK_CC          |      1 | Used to identify NORM_ACK       |

    '
- title: '|                     |        | messages sent in response to    |'
  contents:
  - '|                     |        | messages sent in response to    |

    '
- title: '|                     |        | NORM_CMD(CC) messages.          |'
  contents:
  - '|                     |        | NORM_CMD(CC) messages.          |

    '
- title: +---------------------+--------+---------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------+

    '
- title: '|NORM_ACK_FLUSH       |      2 | Used to identify NORM_ACK       |'
  contents:
  - '|NORM_ACK_FLUSH       |      2 | Used to identify NORM_ACK       |

    '
- title: '|                     |        | messages sent in response to    |'
  contents:
  - '|                     |        | messages sent in response to    |

    '
- title: '|                     |        | NORM_CMD(FLUSH) messages.       |'
  contents:
  - '|                     |        | NORM_CMD(FLUSH) messages.       |

    '
- title: +---------------------+--------+---------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------+

    '
- title: '|NORM_ACK_RESERVED    |   3-15 | Reserved for possible future    |'
  contents:
  - '|NORM_ACK_RESERVED    |   3-15 | Reserved for possible future    |

    '
- title: '|                     |        | NORM protocol use.              |'
  contents:
  - '|                     |        | NORM protocol use.              |

    '
- title: +---------------------+--------+---------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------+

    '
- title: '|NORM_ACK_APPLICATION | 16-255 | Used at application''s           |'
  contents:
  - '|NORM_ACK_APPLICATION | 16-255 | Used at application''s           |

    '
- title: '|                     |        | discretion.                     |'
  contents:
  - '|                     |        | discretion.                     |

    '
- title: +---------------------+--------+---------------------------------+
  contents:
  - "+---------------------+--------+---------------------------------+\n   The NORM_ACK_CC\
    \ value is provided for use only in NORM_ACKs generated\n   in response to the\
    \ NORM_CMD(CC) messages used in congestion control\n   operation.  Similarly,\
    \ the NORM_ACK_FLUSH is provided for use only in\n   NORM_ACKs generated in response\
    \ to applicable NORM_CMD(FLUSH)\n   messages.  NORM_CMD(ACK_REQ) messages with\
    \ \"ack_type\" of NORM_ACK_CC\n   or NORM_ACK_FLUSH SHALL NOT be generated by\
    \ the sender.\n   The NORM_ACK_RESERVED range of \"ack_type\" values is provided\
    \ for\n   possible future NORM protocol use.\n   The NORM_ACK_APPLICATION range\
    \ of \"ack_type\" values is provided so\n   that NORM applications may implement\
    \ application-defined,\n   positively-acknowledged commands that are able to leverage\
    \ internal\n   transmission and round-trip timing information available to the\
    \ NORM\n   protocol implementation.\n   The \"ack_id\" provides a sequenced identifier\
    \ for the given\n   NORM_CMD(ACK_REQ) message.  This \"ack_id\" is returned in\
    \ NORM_ACK\n   messages generated by the receivers so that the sender may associate\n\
    \   the response with its corresponding request.\n   The \"reserved\" field is\
    \ reserved for possible future protocol use and\n   SHALL be set to ZERO by senders\
    \ and ignored by receivers.\n   The \"acking_node_list\" field contains the NormNodeIds\
    \ of the current\n   NORM receivers that are desired to provide positive acknowledge\n\
    \   (NORM_ACK) to this request.  The packet payload length implies the\n   length\
    \ of the \"acking_node_list\" and its length is limited to the\n   sender NormSegmentSize.\
    \  The individual NormNodeId items are listed\n   in network (Big Endian) byte\
    \ order.  If a receiver's NormNodeId is\n   included in the \"acking_node_list\"\
    , it SHALL schedule transmission of\n   a NORM_ACK message as described in Section\
    \ 5.5.3.\n"
- title: 4.2.3.7.  NORM_CMD(APPLICATION) Message
  contents:
  - "4.2.3.7.  NORM_CMD(APPLICATION) Message\n   This command allows the NORM application\
    \ to robustly transmit\n   application-defined commands.  The command message\
    \ preempts any\n   ongoing data transmission and is repeated up to NORM_ROBUST_FACTOR\n\
    \   times at a rate of once per 2*GRTT.  This rate of repetition allows\n   the\
    \ application to observe any response (if that is the application's\n   purpose\
    \ for the command) before it is repeated.  Possible responses\n   may include\
    \ initiation of data transmission, other\n   NORM_CMD(APPLICATION) messages, or\
    \ even application-defined,\n   positively-acknowledge commands from other NormSession\
    \ participants.\n   The transmission of these commands will preempt data transmission\n\
    \   when they are scheduled and may be multiplexed with ongoing data\n   transmission.\
    \  This type of robustly transmitted command allows NORM\n   applications to define\
    \ a complete set of session control mechanisms\n   with less state than the transfer\
    \ of FEC encoded reliable content\n   requires while taking advantage of NORM\
    \ transmission and round-trip\n   timing information.\n      0               \
    \    1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=3|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          instance_id          |     grtt      |backoff| gsize |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  flavor = 7   |                    reserved                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Application-Defined Content                 |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  NORM_CMD(APPLICATION) Message Format\n   The NORM common message\
    \ header and NORM_CMD fields are interpreted as\n   previously described.  The\
    \ value of the NORM_CMD(APPLICATION)\n   \"hdr_len\" field when no header extensions\
    \ are present is 4.\n   The \"Application-Defined Content\" area contains information\
    \ in a\n   format at the discretion of the application.  The size of this\n  \
    \ payload SHALL be limited to a maximum of the sender's NormSegmentSize\n   setting.\n"
- title: 4.3.  Receiver Messages
  contents:
  - "4.3.  Receiver Messages\n   The NORM message types generated by participating\
    \ receivers consist\n   of NORM_NACK and NORM_ACK message types.  NORM_NACK messages\
    \ are sent\n   to request repair of missing data content from sender transmission\n\
    \   and NORM_ACK messages are generated in response to certain sender\n   commands\
    \ including NORM_CMD(CC) and NORM_CMD(ACK_REQ).\n"
- title: 4.3.1.  NORM_NACK Message
  contents:
  - "4.3.1.  NORM_NACK Message\n   The principal purpose of NORM_NACK messages is\
    \ for receivers to\n   request repair of sender content via selective, negative\n\
    \   acknowledgment upon detection of incomplete data.  NORM_NACK messages\n  \
    \ will be transmitted according to the rules of NORM_NACK generation\n   and suppression\
    \ described in Section 5.3.  NORM_NACK messages also\n   contain additional fields\
    \ to provide feedback to the sender(s) for\n   purposes of round-trip timing collection\
    \ and congestion control.\n   The payload of NORM_NACK messages contains one or\
    \ more repair\n   requests for different objects or portions of those objects.\
    \  The\n   NORM_NACK message format is as follows:\n      0                  \
    \ 1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |version| type=4|    hdr_len    |            sequence           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           server_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           instance_id         |            reserved           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       grtt_response_sec                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       grtt_response_usec                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               header extensions (if applicable)               |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          nack_payload                         |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        NORM_NACK Message Format\n   The NORM common message\
    \ header fields serve their usual purposes.\n   The value of the \"hdr_len\" field\
    \ for NORM_NACK messages without\n   header extensions present is 6.\n   The \"\
    server_id\" field identifies the NORM sender to which the\n   NORM_NACK message\
    \ is destined.\n   The \"instance_id\" field contains the current session identifier\
    \ given\n   by the sender identified by the \"server_id\" field in its sender\n\
    \   messages.  The sender SHOULD ignore feedback messages which contain\n   an\
    \ invalid \"instance_id\" value.\n   The \"grtt_response\" fields contain an adjusted\
    \ version of the\n   timestamp from the most recently received NORM_CMD(CC) message\
    \ for\n   the indicated NORM sender.  The format of the \"grtt_response\" is the\n\
    \   same as the \"send_time\" field of the NORM_CMD(CC).  The\n   \"grtt_response\"\
    \ value is _relative_ to the \"send_time\" the source\n   provided with a corresponding\
    \ NORM_CMD(CC) command.  The receiver\n   adjusts the source's NORM_CMD(CC) \"\
    send_time\" timestamp by adding the\n   time differential from  when the receiver\
    \ received the NORM_CMD(CC)\n   to when the NORM_NACK is transmitted to calculate\
    \ the value in the\n   \"grtt_response\" field.  This is the\n   \"receive_to_response_differential\"\
    \ value used in the following\n   formula:\n   \"grtt_response\" = NORM_CMD(CC)\
    \ \"send_time\" +\n   receive_to_response_differential\n   The receiver SHALL\
    \ set the \"grtt_response\" to a ZERO value, to\n   indicate that it has not yet\
    \ received a NORM_CMD(CC) message from the\n   indicated sender and that the sender\
    \ should ignore the\n   \"grtt_response\" in this message.\n   For NORM-CC operation,\
    \ the NORM-CC Feedback Header Extension, as\n   described in the NORM_CMD(REPAIR_ADV}\
    \ message description, is added\n   to NORM_NACK messages to provide feedback\
    \ on the receivers current\n   state with respect to congestion control operation.\
    \  Note that\n   alternative header extensions for congestion control feedback\
    \ may be\n   defined for alternative congestion control schemes for NORM use in\n\
    \   the future.\n   The \"reserved\" field is for potential future NORM use and\
    \ SHALL be\n   set to ZERO for this version of the protocol.\n   The \"nack_content\"\
    \ of the NORM_NACK message specifies the repair\n   needs of the receiver with\
    \ respect to the NORM sender indicated by\n   the \"server_id\" field.  The receiver\
    \ constructs repair requests based\n   on the NORM_DATA and/or NORM_INFO segments\
    \ it requires from the\n   sender in order to complete reliable reception up to\
    \ the sender's\n   transmission position at the moment the receiver initiates\
    \ the NACK\n   Procedure as described in Section 5.3.  A single NORM Repair Request\n\
    \   consists of a list of items, ranges, and/or FEC coding block erasure\n   counts\
    \ for needed NORM_DATA and/or NORM_INFO content.  Multiple\n   repair requests\
    \ may be concatenated within the \"nack_payload\" field\n   of a NORM_NACK message.\
    \  Note that a single NORM Repair Request can\n   possibly include multiple \"\
    items\", \"ranges\", or \"erasure_counts\".  In\n   turn, the \"nack_payload\"\
    \ field may contain multiple repair requests.\n   A single NORM Repair Request\
    \ has the following format:\n      0                   1                   2 \
    \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      form     |     flags     |             length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      repair_request_items                     |\n   |  \
    \                           ...                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       NORM Repair Request Format\n   The \"form\" field indicates\
    \ the type of repair request items given in\n   the \"repair_request_items\" list.\
    \  Possible values for the \"form\"\n   field include:\n                Form \
    \         Value\n         NORM_NACK_ITEMS        1\n         NORM_NACK_RANGES\
    \       2\n         NORM_NACK_ERASURES     3\n   A \"form\" value of NORM_NACK_ITEMS\
    \ indicates each repair request item\n   in the \"repair_request_items\" list\
    \ is to be treated as an individual\n   request.  A value of NORM_NACK_RANGES\
    \ indicates that the\n   \"repair_request_items\" list consists of pairs of repair\
    \ request items\n   that correspond to inclusive ranges of repair needs.  And\
    \ the\n   NORM_NACK_ERASURES \"form\" indicates that the repair request items\
    \ are\n   to be treated individually and that the \"encoding_symbol_id\" portion\n\
    \   of the \"fec_payload_id\" field of the repair request item (see below)\n \
    \  is to be interpreted as an \"erasure count\" for the FEC coding block\n   identified\
    \ by the repair request item's \"source_block_number\".\n   The \"flags\" field\
    \ is currently used to indicate the level of data\n   content for which the repair\
    \ request items apply (i.e., an individual\n   segment, entire FEC coding block,\
    \ or entire transport object).\n   Possible flag values include:\n"
- title: +------------------+-------+-----------------------------------------+
  contents:
  - '+------------------+-------+-----------------------------------------+

    '
- title: '|      Flag        | Value |                 Purpose                 |'
  contents:
  - '|      Flag        | Value |                 Purpose                 |

    '
- title: +------------------+-------+-----------------------------------------+
  contents:
  - '+------------------+-------+-----------------------------------------+

    '
- title: '|NORM_NACK_SEGMENT | 0x01  | Indicates the listed segment(s) or range|'
  contents:
  - '|NORM_NACK_SEGMENT | 0x01  | Indicates the listed segment(s) or range|

    '
- title: '|                  |       | of segments are required as repair.     |'
  contents:
  - '|                  |       | of segments are required as repair.     |

    '
- title: +------------------+-------+-----------------------------------------+
  contents:
  - '+------------------+-------+-----------------------------------------+

    '
- title: '|NORM_NACK_BLOCK   | 0x02  | Indicates the listed block(s) or range  |'
  contents:
  - '|NORM_NACK_BLOCK   | 0x02  | Indicates the listed block(s) or range  |

    '
- title: '|                  |       | of blocks in entirety are required as   |'
  contents:
  - '|                  |       | of blocks in entirety are required as   |

    '
- title: '|                  |       | repair.                                 |'
  contents:
  - '|                  |       | repair.                                 |

    '
- title: +------------------+-------+-----------------------------------------+
  contents:
  - '+------------------+-------+-----------------------------------------+

    '
- title: '|NORM_NACK_INFO    | 0x04  | Indicates that NORM_INFO is required as |'
  contents:
  - '|NORM_NACK_INFO    | 0x04  | Indicates that NORM_INFO is required as |

    '
- title: '|                  |       | repair for the listed object(s).        |'
  contents:
  - '|                  |       | repair for the listed object(s).        |

    '
- title: +------------------+-------+-----------------------------------------+
  contents:
  - '+------------------+-------+-----------------------------------------+

    '
- title: '|NORM_NACK_OBJECT  | 0x08  | Indicates the listed object(s) or range |'
  contents:
  - '|NORM_NACK_OBJECT  | 0x08  | Indicates the listed object(s) or range |

    '
- title: '|                  |       | of objects in entirety are required as  |'
  contents:
  - '|                  |       | of objects in entirety are required as  |

    '
- title: '|                  |       | repair.                                 |'
  contents:
  - '|                  |       | repair.                                 |

    '
- title: +------------------+-------+-----------------------------------------+
  contents:
  - "+------------------+-------+-----------------------------------------+\n   When\
    \ the NORM_NACK_SEGMENT flag is set, the \"object_transport_id\" and\n   \"fec_payload_id\"\
    \ fields are used to determine which sets or ranges of\n   individual NORM_DATA\
    \ segments are needed to repair content at the\n   receiver.  When the NORM_NACK_BLOCK\
    \ flag is set, this indicates the\n   receiver is completely missing the indicated\
    \ coding block(s) and\n   requires transmissions sufficient to repair the indicated\
    \ block(s) in\n   their entirety.  When the NORM_NACK_INFO flag is set, this indicates\n\
    \   the receiver is missing the NORM_INFO segment for the indicated\n   \"object_transport_id\"\
    .  Note the NORM_NACK_INFO may be set in\n   combination with the NORM_NACK_BLOCK\
    \ or NORM_NACK_SEGMENT flags, or\n   may be set alone.  When the NORM_NACK_OBJECT\
    \ flag is set, this\n   indicates the receiver is missing the entire NormTransportObject\n\
    \   referenced by the \"object_transport_id\".  This also implicitly\n   requests\
    \ any available NORM_INFO for the NormObject, if applicable.\n   The \"fec_payload_id\"\
    \ field is ignored when the flag NORM_NACK_OBJECT\n   is set.\n   The \"length\"\
    \ field value is the length in bytes of the\n   \"repair_request_items\" field.\n\
    \   The \"repair_request_items\" field consists of a list of individual or\n \
    \  range pairs of transport data unit identifiers in the following\n   format.\n\
    \      0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     fec_id    |   reserved    |      object_transport_id      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        fec_payload_id                         |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    NORM Repair Request Item Format\n   The \"fec_id\" indicates\
    \ the FEC type and can be used to determine the\n   format of the \"fec_payload_id\"\
    \ field.  The \"reserved\" field is kept\n   for possible future use and SHALL\
    \ be set to a ZERO value and ignored\n   by NORM nodes processing NACK content.\n\
    \   The \"object_transport_id\" corresponds to the NormObject for which\n   repair\
    \ is being requested and the \"fec_payload_id\" identifies the\n   specific FEC\
    \ coding block and/or segment being requested.  When the\n   NORM_NACK_OBJECT\
    \ flag is set, the value of the \"fec_payload_id\" field\n   is ignored.  When\
    \ the NORM_NACK_BLOCK flag is set, only the FEC code\n   block identifier portion\
    \ of the \"fec_payload_id\" is to be\n   interpreted.\n   The format of the \"\
    fec_payload_id\" field depends upon the \"fec_id\"\n   field value.\n   When the\
    \ receiver's repair needs dictate that different forms (mixed\n   ranges and/or\
    \ individual items) or types (mixed specific segments\n   and/or blocks or objects\
    \ in entirety) are required to complete\n   reliable transmission, multiple NORM\
    \ Repair Requests with different\n   \"form\" and or \"flags\" values can be concatenated\
    \ within a single\n   NORM_NACK message.  Additionally, NORM receivers SHALL construct\n\
    \   NORM_NACK messages with their repair requests in ordinal order with\n   respect\
    \ to \"object_transport_id\" and \"fec_payload_id\" values.  The\n   \"nack_payload\"\
    \ size SHALL NOT exceed the NormSegmentSize for the\n   sender to which the NORM_NACK\
    \ is destined.\n   NORM_NACK Content Examples:\n   In these examples, a small\
    \ block, systematic FEC code (\"fec_id\" =\n   129) is assumed with a user data\
    \ block length of 32 segments.  In\n   Example 1, a list of individual NORM_NACK_ITEMS\
    \ repair requests is\n   given.  In Example 2, a list of NORM_NACK_RANGES requests\
    \ _and_ a\n   single NORM_NACK_ITEMS request are concatenated to illustrate the\n\
    \   possible content of a NORM_NACK message.  Note that FEC coding block\n   erasure\
    \ counts could also be provided in each case.  However, the\n   erasure counts\
    \ are not really necessary since the sender can easily\n   determine the erasure\
    \ count while processing the NACK content.\n   However, the erasure count option\
    \ may be useful for operation with\n   other FEC codes or for intermediate system\
    \ purposes.\n   Example 1:  NORM_NACK \"nack_payload\" for: Object 12, Coding\
    \ Block 3,\n   Segments 2,5,8\n    0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   form = 1    | flags = 0x01  |       length  = 36            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  fec_id = 129 |   reserved    |    object_transport_id = 12   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    source_block_number = 3                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    source_block_length = 32   |    encoding_symbol_id = 2     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  fec_id = 129 |   reserved    |    object_transport_id = 12   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    source_block_number = 3                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    source_block_length = 32   |    encoding_symbol_id = 5     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  fec_id = 129 |   reserved    |    object_transport_id = 12   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    source_block_number = 3                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    source_block_length = 32   |    encoding_symbol_id = 8     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Example 2:  NORM_NACK \"nack_payload\" for: Object 18 Coding Block 6,\n  \
    \ Segments 5, 6, 7, 8, 9, 10; and Object 19 NORM_INFO and Coding Block\n   1,\
    \ segment 3\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   form = 2    | flags = 0x01  |       length  = 24            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  fec_id = 129 |   reserved    |    object_transport_id = 18   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    source_block_number = 6                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    source_block_length = 32   |    encoding_symbol_id = 5     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  fec_id = 129 |   reserved    |    object_transport_id = 18   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    source_block_number = 6                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    source_block_length = 32   |    encoding_symbol_id = 10    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   form = 1    | flags = 0x05  |       length  = 12            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  fec_id = 129 |   reserved    |    object_transport_id = 19   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    source_block_number = 1                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    source_block_length = 32   |    encoding_symbol_id = 3     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.2.  NORM_ACK Message
  contents:
  - "4.3.2.  NORM_ACK Message\n   The NORM_ACK message is intended to be used primarily\
    \ as part of NORM\n   congestion control operation and round-trip timing measurement.\
    \  As\n   mentioned in the NORM_CMD(ACK_REQ) message description, the\n   acknowledgment\
    \ type NORM_ACK_CC is provided for this purpose.  The\n   generation of NORM_ACK(CC)\
    \ messages for round-trip timing estimation\n   and congestion-control operation\
    \ is described in Sections 5.5.1 and\n   5.5.2, respectively.  However, some multicast\
    \ applications may\n   benefit from some limited form of positive acknowledgment\
    \ for certain\n   functions.  A simple, scalable positive acknowledgment scheme\
    \ is\n   defined in Section 5.5.3 that can be leveraged by protocol\n   implementations\
    \ when appropriate.  The NORM_CMD(FLUSH) may be used\n   for OPTIONAL collection\
    \ of positive acknowledgment of reliable\n   reception to a certain \"watermark\"\
    \ transmission point from specific\n   receivers using this mechanism.  The NORM_ACK\
    \ type NORM_ACK_FLUSH is\n   provided for this purpose and the format of the \"\
    nack_payload\" for\n   this acknowledgment type is given below.  Beyond that,\
    \ a range of\n   application-defined \"ack_type\" values is provided for use at\
    \ the NORM\n   application's discretion.  Implementations making use of\n   application-defined\
    \ positive acknowledgments may also make use the\n   \"nack_payload\" as needed,\
    \ observing the constraint that the\n   \"nack_payload\" field size be limited\
    \ to a maximum of the\n   NormSegmentSize for the sender to which the NORM_ACK\
    \ is destined.\n      0                   1                   2              \
    \     3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |version|\
    \ type=5|    hdr_len    |          sequence             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           source_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           server_id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           instance_id         |    ack_type  |     ack_id     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       grtt_response_sec                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       grtt_response_usec                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               header extensions (if applicable)               |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   ack_payload (if applicable)                 |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        NORM_ACK Message Format\n   The NORM common message header\
    \ fields serve their usual purposes.\n   The \"server_id\", \"instance_id\", \
    \ and \"grtt_response\" fields serve the\n   same purpose as the corresponding\
    \ fields in NORM_NACK messages.  And\n   header extensions may be applied to support\
    \ congestion control\n   feedback or other functions in the same manner.\n   The\
    \ \"ack_type\" field indicates the nature of the NORM_ACK message.\n   This directly\
    \ corresponds to the \"ack_type\" field of the\n   NORM_CMD(ACK_REQ) message to\
    \ which this acknowledgment applies.\n   The \"ack_id\" field serves as a sequence\
    \ number so that the sender can\n   verify that a NORM_ACK message received actually\
    \ applies to a current\n   acknowledgment request.  The \"ack_id\" field is not\
    \ used in the case\n   of the NORM_ACK_CC and NORM_ACK_FLUSH acknowledgment types.\n\
    \   The \"ack_payload\" format is a function of the \"ack_type\".  The\n   NORM_ACK_CC\
    \ message has no attached content.  Only the NORM_ACK\n   header applies.  In\
    \ the case of NORM_ACK_FLUSH, a specific\n   \"ack_payload\" format is defined:\n\
    \      0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     fec_id    |   reserved    |      object_transport_id      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        fec_payload_id                         |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  NORM_ACK_FLUSH \"ack_payload\" Format\n   The \"object_transport_id\"\
    \ and \"fec_payload_id\" are used by the\n   receiver to acknowledge applicable\
    \ NORM_CMD(FLUSH) messages\n   transmitted by the sender identified by the \"\
    server_id\" field.\n   The \"ack_payload\" of NORM_ACK messages for application-defined\n\
    \   \"ack_type\" values is specific to the application but is limited in\n   size\
    \ to a maximum the NormSegmentSize of the sender referenced by the\n   \"server_id\"\
    .\n"
- title: 4.4.  General Purpose Messages
  contents:
  - "4.4.  General Purpose Messages\n   Some additional message formats are defined\
    \ for general purpose in\n   NORM multicast sessions whether the participant is\
    \ acting as a sender\n   and/or receiver within the group.\n"
- title: 4.4.1.  NORM_REPORT Message
  contents:
  - "4.4.1.  NORM_REPORT Message\n   This is an optional message generated by NORM\
    \ participants.  This\n   message could be used for periodic performance reports\
    \ from receivers\n   in experimental NORM implementations.  The format of this\
    \ message is\n   currently undefined.  Experimental NORM implementations may define\n\
    \   NORM_REPORT formats as needed for test purposes.  These report\n   messages\
    \ SHOULD be disabled for interoperability testing between\n   different NORM implementations.\n"
- title: 5.  Detailed Protocol Operation
  contents:
  - "5.  Detailed Protocol Operation\n   This section describes the detailed interactions\
    \ of senders and\n   receivers participating in a NORM session.  A simple synopsis\
    \ of\n   protocol operation is given here:\n   1) The sender periodically transmits\
    \ NORM_CMD(CC) messages as needed\n      to initialize and collect roundtrip timing\
    \ and congestion control\n      feedback from the receiver set.\n   2) The sender\
    \ transmits an ordinal set of NormObjects segmented in\n      the form of NORM_DATA\
    \ messages labeled with NormTransportIds and\n      logically identified with\
    \ FEC encoding block numbers and symbol\n      identifiers.  NORM_INFO messages\
    \ may optionally precede the\n      transmission of data content for NORM transport\
    \ objects.\n   3) As receivers detect missing content from the sender, they initiate\n\
    \      repair requests with NORM_NACK messages.  Note the receivers track\n  \
    \    the sender's most recent objectId::fecPayloadId transmit position\n     \
    \ and NACK _only_ for content ordinally prior to that transmit\n      position.\
    \  The receivers schedule random backoff timeouts before\n      generating NORM_NACK\
    \ messages and wait an appropriate amount of\n      time before repeating the\
    \ NORM_NACK if their repair request is not\n      satisfied.\n   4) The sender\
    \ aggregates repair requests from the receivers and\n      logically \"rewinds\"\
    \ its transmit position to send appropriate\n      repair messages.  The sender\
    \ sends repairs for the earliest\n      ordinal transmit position first and maintains\
    \ this ordinal repair\n      transmission sequence.  Previously untransmitted\
    \ FEC parity\n      content for the applicable FEC coding block is used for repair\n\
    \      transmissions to the greatest extent possible.  If the sender\n      exhausts\
    \ its available FEC parity content on multiple repair\n      cycles for the same\
    \ coding block, it resorts to an explicit repair\n      strategy (possibly using\
    \ parity content) to complete repairs.\n      (The use of explicit repair is expected\
    \ to be an exception in\n      general protocol operation, but the possibility\
    \ does exist for\n      extreme conditions).  The sender immediately assumes transmission\n\
    \      of new content once it has sent pending repairs.\n   5) The sender transmits\
    \ NORM_CMD(FLUSH) messages when it reaches the\n      end of enqueued transmit\
    \ content and pending repairs.  Receivers\n      respond to the NORM_CMD(FLUSH)\
    \ messages with NORM_NACK\n      transmissions (following the same suppression\
    \ backoff timeout\n      strategy as for data) if they require further repair.\n\
    \   6) The sender transmissions are subject to rate control limits\n      determined\
    \ by congestion control mechanisms.  In the baseline\n      NORM-CC operation,\
    \ each sender in a NormSession maintains its own\n      independent congestion\
    \ control state.  Receivers provide\n      congestion control feedback in NORM_NACK\
    \ and NORM_ACK messages.\n      NORM_ACK feedback for congestion control purposes\
    \ is governed\n      using a suppression mechanism similar to that for NORM_NACK\n\
    \      messages.\n   While this overall concept is relatively simple, there are\
    \ details to\n   each of these aspects that need to be addressed for successful,\n\
    \   efficient, robust, and scalable NORM protocol operation.\n"
- title: 5.1.  Sender Initialization and Transmission
  contents:
  - "5.1.  Sender Initialization and Transmission\n   Upon startup, the NORM sender\
    \ immediately begins sending NORM_CMD(CC)\n   messages to collect round trip timing\
    \ and other information from the\n   potential group.  If NORM-CC congestion control\
    \ operation is enabled,\n   the NORM-CC Rate header extension MUST be included\
    \ in these messages.\n   Congestion control operation SHALL be observed at all\
    \ times when\n   operating in the general Internet.  Even if congestion control\n\
    \   operation is disabled at the sender, it may be desirable to use the\n   NORM_CMD(CC)\
    \ messaging to collect feedback from the group using the\n   baseline NORM-CC\
    \ feedback mechanisms.  This proactive feedback\n   collection can be used to\
    \ establish a GRTT estimate prior to data\n   transmission and potential NACK\
    \ operation.\n   In some cases, applications may wish for the sender to also proceed\n\
    \   with data transmission immediately.  In other cases, the sender may\n   wish\
    \ to defer data transmission until it has received some feedback\n   or request\
    \ from the receiver set indicating that receivers are indeed\n   present.  Note,\
    \ in some applications (e.g., web push), this\n   indication may come out-of-band\
    \ with respect to the multicast session\n   via other means.  As noted, the periodic\
    \ transmission of NORM_CMD(CC)\n   messages may precede actual data transmission\
    \ in order to have an\n   initial GRTT estimate.\n   With inclusion of the OPTIONAL\
    \ NORM FEC Object Transmission\n   Information Header Extension, the NORM protocol\
    \ sender message\n   headers can contain all information necessary to prepare\
    \ receivers\n   for subsequent reliable reception.  This includes FEC coding\n\
    \   parameters, the sender NormSegmentSize, and other information.  If\n   this\
    \ header extension is not used, it is presumed that receivers have\n   received\
    \ the FEC Object Transmission Information via other means.\n   Additionally, applications\
    \ may leverage the use of NORM_INFO messages\n   associated with the session data\
    \ objects in the session to provide\n   application-specific context information\
    \ for the session and data\n   being transmitted.  These mechanisms allow for\
    \ operation with minimal\n   pre-coordination among the senders and receivers.\n\
    \   The NORM sender begins segmenting application-enqueued data into\n   NORM_DATA\
    \ segments and transmitting it to the group.  The\n   segmentation algorithm is\
    \ described in Section 5.1.1.  The rate of\n   transmission is controlled via\
    \ congestion control mechanisms or is a\n   fixed rate if desired for closed network\
    \ operations.  The receivers\n   participating in the multicast group provide\
    \ feedback to the sender\n   as needed.  When the sender reaches the end of data\
    \ it has enqueued\n   for transmission or any pending repairs, it transmits a\
    \ series of\n   NORM_CMD(FLUSH) messages at a rate of one per 2*GRTT.  Receivers\
    \ may\n   respond to these NORM_CMD(FLUSH) messages with additional repair\n \
    \  requests.  A protocol parameter \"NORM_ROBUST_FACTOR\" determines the\n   number\
    \ of flush messages sent.  If receivers request repair, the\n   repair is provided\
    \ and flushing occurs again at the end of repair\n   transmission.  The sender\
    \ may attach an OPTIONAL \"acking_node_list\"\n   to NORM_CMD(FLUSH) containing\
    \ the NormNodeIds for receivers from\n   which it expects explicit positive acknowledgment\
    \ of reception.  The\n   NORM_CMD(FLUSH) message may be also used for this optional\
    \ function\n   any time prior to the end of data enqueued for transmission with\
    \ the\n   NORM_CMD(FLUSH) messages multiplexed with ongoing data transmissions.\n\
    \   The OPTIONAL NORM positive acknowledgment procedure is described in\n   Section\
    \ 5.5.3.\n"
- title: 5.1.1.  Object Segmentation Algorithm
  contents:
  - "5.1.1.  Object Segmentation Algorithm\n   NORM senders and receivers must use\
    \ a common algorithm for logically\n   segmenting transport data into FEC encoding\
    \ blocks and symbols so\n   that appropriate NACKs can be constructed to request\
    \ repair of\n   missing data.  NORM FEC coding blocks are comprised of multi-byte\n\
    \   symbols which are transmitted in the payload of NORM_DATA messages.\n   Each\
    \ NORM_DATA message contains one source or encoding symbol and the\n   NormSegmentSize\
    \ sender parameter defines the maximum symbol size in\n   bytes.  The FEC encoding\
    \ type and associated parameters govern the\n   source block size (number of source\
    \ symbols per coding block).  NORM\n   senders and receivers use these FEC parameters,\
    \ along with the\n   NormSegmentSize and transport object size to compute the\
    \ source block\n   structure for transport objects.  These parameters are provided\
    \ in\n   the FEC Transmission Information for each object.  The algorithm\n  \
    \ given below is used to compute a source block structure such that all\n   source\
    \ blocks are as close to being equal length as possible.  This\n   helps avoid\
    \ the performance disadvantages of \"short\" FEC blocks.\n   Note this algorithm\
    \ applies only to the statically-sized\n   NORM_OBJECT_DATA and NORM_OBJECT_FILE\
    \ transport object types where\n   the object size is fixed and predetermined.\
    \  For NORM_OBJECT_STREAM\n   objects, the object is segmented according to the\
    \ maximum source\n   block length  given in the FEC Transmission Information,\
    \ unless the\n   FEC Payload ID indicates an alternative size for a given block.\n\
    \   The NORM block segmentation algorithm is defined as follows.  For a\n   transport\
    \ object of a given length (L_obj) in bytes, a first number\n   of FEC source\
    \ blocks (N_large) is delineated of a larger block size\n   (B_large), and a second\
    \ number of source blocks (N_small) is\n   delineated of a smaller block size\
    \ (B_small).  Given the maximum FEC\n   source block size (B_max) and the sender's\
    \ NormSegmentSize, the block\n   segmentation for a given NORM transport object\
    \ is determined as\n   follows:\n   Inputs:\n   B_max = Maximum source block length\
    \ (i.e., maximum number of source\n           symbols per source block)\n   L_sym\
    \ = Encoding symbol length in bytes (i.e., NormSegmentSize)\n   L_obj = Object\
    \ length in bytes\n   Outputs:\n   N_total = The total number of source blocks\
    \ into which the transport\n             object is partitioned.\n   N_large =\
    \ Number of larger source blocks (first set of blocks)\n   B_large = Size (in\
    \ encoding symbols) of the larger source blocks\n   N_small = Number of smaller\
    \ source blocks (second set of blocks)\n   B_small = Size (in encoding symbols)\
    \ of the smaller source blocks\n   L_final = Length (in bytes) of the last source\
    \ symbol of the last\n             source block (All other symbols are of length\
    \ L_sym).\n   Algorithm:\n   1) The total number of source symbols in the transport\
    \ object is\n      computed as:  S_total = L_obj/L_sym [rounded up to the nearest\n\
    \      integer]\n   2) The transport object is partitioned into N_total source\
    \ blocks,\n      where:  N_total = S_total/B_max [rounded up to the nearest\n\
    \      integer]\n   3) The average length of a source block is computed as:  B_ave\
    \ =\n      S_total/N_total (this may be non-integer)\n   4) The size of the first\
    \ set of larger blocks is computed as:\n      B_large = B_ave [rounded up to the\
    \ nearest integer] (Note it will\n      always be the case that B_large <= B_max)\n\
    \   5) The size of the second set of smaller blocks is computed as:\n      B_small\
    \ = B_ave [rounded down to the nearest integer] (Note if\n      B_ave is an integer\
    \ B_small = B_large; otherwise B_small = B_large\n      - 1)\n   6) The fractional\
    \ part of B_ave is computed as:  B_fraction = B_ave -\n      B_small\n   7) The\
    \ number of larger source blocks is computed as:  N_large =\n      B_fraction\
    \ * N_total (Note N_large is an integer in the range 0\n      through N_total\
    \ - 1)\n   8) The number of smaller source blocks is computed as:  N_small =\n\
    \      N_total - N_large\n   9) Each of the first N_large source blocks consists\
    \ of B_large source\n      symbols.  Each of the remaining N_small source blocks\
    \ consists of\n      B_small source symbols.  All symbols are L_sym bytes in length\n\
    \      except for the final source symbol of the final source block which\n  \
    \    is of length (in bytes):\n      L_final = L_obj - (N_large*B_large + N_small*B_small\
    \ - 1) * L_sym\n"
- title: 5.2.  Receiver Initialization and Reception
  contents:
  - "5.2.  Receiver Initialization and Reception\n   The NORM protocol is designed\
    \ such that receivers may join and leave\n   the group at will.  However, some\
    \ applications may be constrained\n   such that receivers need to be members of\
    \ the group prior to start of\n   data transmission.  NORM applications may use\
    \ different policies to\n   constrain the impact of new receivers joining the\
    \ group in the middle\n   of a session.  For example, a useful implementation\
    \ policy is for new\n   receivers joining the group to limit or avoid repair requests\
    \ for\n   transport objects already in progress.  The NORM sender\n   implementation\
    \ may wish to impose additional constraints to limit the\n   ability of receivers\
    \ to disrupt reliable multicast performance by\n   joining, leaving, and rejoining\
    \ the group often.  Different receiver\n   \"join policies\" may be appropriate\
    \ for different applications and/or\n   scenarios.  For general purpose operation,\
    \ default policy where\n   receivers are allowed to request repair only for coding\
    \ blocks with a\n   NormTransportId and FEC coding block number greater than or\
    \ equal to\n   the first non-repair NORM_DATA or NORM_INFO message received upon\n\
    \   joining the group is RECOMMENDED.  For objects of type\n   NORM_OBJECT_STREAM\
    \ it is RECOMMENDED that the join policy constrain\n   receivers to start reliable\
    \ reception at the current FEC coding block\n   for which non-repair content is\
    \ received.\n"
- title: 5.3.  Receiver NACK Procedure
  contents:
  - "5.3.  Receiver NACK Procedure\n   When the receiver detects it is missing data\
    \ from a sender's NORM\n   transmissions, it initiates its NACKing procedure.\
    \  The NACKing\n   procedure SHALL be initiated _only_ at FEC coding block boundaries,\n\
    \   NormObject boundaries, and upon receipt of a NORM_CMD(FLUSH) message.\n  \
    \ The NACKing procedure begins with a random backoff timeout.  The\n   duration\
    \ of the backoff timeout is chosen using the \"RandomBackoff\"\n   algorithm described\
    \ in the NORM Building Block document [4] using\n   (Ksender*GRTTsender) for the\
    \ \"maxTime\" parameter and the sender\n   advertised group size (GSIZEsender)\
    \ as the \"groupSize\" parameter.\n   NORM senders provide values for GRTTsender,\
    \ Ksender and GSIZEsender\n   via the \"grtt\", \"backoff\", and \"gsize\" fields\
    \ of transmitted\n   messages.  The GRTTsender value is determined by the sender\
    \ based on\n   feedback it has received from the group while the Ksender and\n\
    \   GSIZEsender values may determined by application requirements and\n   expectations\
    \ or ancillary information.  The backoff factor \"Ksender\"\n   MUST be greater\
    \ than one to provide for effective feedback\n   suppression.  A value of K =\
    \ 4 is RECOMMENDED for the Any Source\n   Multicast (ASM) model while a value\
    \ of K = 6 is RECOMMENDED for\n   Single Source Multicast (SSM) operation.\n \
    \  Thus:\n        T_backoff = RandomBackoff(Ksender*GRTTsender, GSIZEsender)\n\
    \   To avoid the possibility of NACK implosion in the case of sender or\n   network\
    \ failure during SSM operation, the receiver SHALL\n   automatically suppress\
    \ its NACK and immediately enter the \"holdoff\"\n   period described below when\
    \ T_backoff is greater than (Ksender-\n   1)*GRTTsender.  Otherwise, the backoff\
    \ period is entered and the\n   receiver MUST accumulate external pending repair\
    \ state from NORM_NACK\n   messages and NORM_CMD(REPAIR_ADV) messages received.\
    \  At the end of\n   the backoff time, the receiver SHALL generate a NORM_NACK\
    \ message\n   only if the following conditions are met:\n   1) The sender's current\
    \ transmit position (in terms of\n      objectId::fecPayloadId) exceeds the earliest\
    \ repair position of\n      the receiver.\n   2) The repair state accumulated\
    \ from NORM_NACK and\n      NORM_CMD(REPAIR_ADV) messages do not equal or supersede\
    \ the\n      receiver's repair needs up to the sender transmission position at\n\
    \      the time the NACK procedure (backoff timeout) was initiated.\n   If these\
    \ conditions are met, the receiver immediately generates a\n   NORM_NACK message\
    \ when the backoff timeout expires.  Otherwise, the\n   receiver's NACK is considered\
    \ to be \"suppressed\" and the message is\n   not sent.  At this time, the receiver\
    \ begins a \"holdoff\" period\n   during which it constrains itself to not reinitiate\
    \ the NACKing\n   process.  The purpose of this timeout is to allow the sender\
    \ worst-\n   case time to respond to the repair needs before the receiver requests\n\
    \   repair again.  The value of this \"holdoff\" timeout  (T_rcvrHoldoff)\n  \
    \ as described in [4] is:\n                   T_rcvrHoldoff =(Ksender+2)*GRTTsender\n\
    \   The NORM_NACK message contains repair request content beginning with\n   lowest\
    \ ordinal repair position of the receiver up through the coding\n   block prior\
    \ to the most recently heard ordinal transmission position\n   for the sender.\
    \  If the size of the NORM_NACK content exceeds the\n   sender's NormSegmentSize,\
    \ the NACK content is truncated so that the\n   receiver only generates a single\
    \ NORM_NACK message per NACK cycle for\n   a given sender.  In summary, a single\
    \ NACK message is generated\n   containing the receiver's lowest ordinal repair\
    \ needs.\n   For each partially-received FEC coding block requiring repair, the\n\
    \   receiver SHALL, on its _first_ repair attempt for the block, request\n   the\
    \ parity portion of the FEC coding block beginning with the lowest\n   ordinal\
    \ _parity_ \"encoding_symbol_id\" (i.e., \"encoding_symbol_id\" =\n   \"source_block_len\"\
    ) and request the number of FEC symbols\n   corresponding to its data segment\
    \ erasure count for the block.  On\n   _subsequent_ repair cycles for the same\
    \ coding block, the receiver\n   SHALL request only those repair symbols from\
    \ the first set it has not\n   yet received up to the remaining erasure count\
    \ for that applicable\n   coding block.  Note that the sender may have provided\
    \ other\n   different, additional parity segments for other receivers that could\n\
    \   also be used to satisfy the local receiver's erasure-filling needs.\n   In\
    \ the case where the erasure count for a partially-received FEC\n   coding block\
    \ exceeds the maximum number of parity symbols available\n   from the sender for\
    \ the block (as indicated by the NORM_DATA\n   \"fec_num_parity\" field), the\
    \ receiver SHALL request all available\n   parity segments plus the ordinally\
    \ highest missing data segments\n   required to satisfy its total erasure needs\
    \ for the block.  The goal\n   of this strategy is for the overall receiver set\
    \ to request a lowest\n   common denominator set of repair symbols for a given\
    \ FEC coding\n   block.  This allows the sender to construct the most efficient\
    \ repair\n   transmission segment set and enables effective NACK suppression among\n\
    \   the receivers even with uncorrelated packet loss.  This approach also\n  \
    \ requires no synchronization among the receiver set in their repair\n   requests\
    \ for the sender.\n   For FEC coding blocks or NormObjects missed in their entirety,\
    \ the\n   NORM receiver constructs repair requests with NORM_NACK_BLOCK or\n \
    \  NORM_NACK_OBJECT flags set as appropriate.  The request for\n   retransmission\
    \ of NORM_INFO is accomplished by setting the\n   NORM_NACK_INFO flag in a corresponding\
    \ repair request.\n"
- title: 5.4.  Sender NACK Processing and Response
  contents:
  - "5.4.  Sender NACK Processing and Response\n   The principle goal of the sender\
    \ is to make forward progress in the\n   transmission of data its application\
    \ has enqueued.  However, the\n   sender must occasionally \"rewind\" its logical\
    \ transmission point to\n   satisfy the repair needs of receivers who have NACKed.\
    \  Aggregation\n   of multiple NACKs is used to determine an optimal repair strategy\n\
    \   when a NACK event occurs.  Since receivers initiate the NACK process\n   on\
    \ coding block or object boundaries, there is some loose degree of\n   synchronization\
    \ of the repair process even when receivers experience\n   uncorrelated data loss.\n"
- title: 5.4.1.  Sender Repair State Aggregation
  contents:
  - "5.4.1.  Sender Repair State Aggregation\n   When a sender is in its normal state\
    \ of transmitting new data and\n   receives a NACK, it begins a procedure to accumulate\
    \ NACK repair\n   state from NORM_NACK messages before beginning repair transmissions.\n\
    \   Note that this period of aggregating repair state does _not_\n   interfere\
    \ with its ongoing transmission of new data.\n   As described in [4], the period\
    \ of time during which the sender\n   aggregates NORM_NACK messages is equal to:\n\
    \                    T_sndrAggregate = (Ksender+1)*GRTT\n   where \"Ksender\"\
    \ is the same backoff scaling value used by the\n   receivers, and \"GRTT\" is\
    \ the sender's current estimate of the group's\n   greatest round-trip time.\n\
    \   When this period ends, the sender \"rewinds\" by incorporating the\n   accumulated\
    \ repair state into its pending transmission state and\n   begins transmitting\
    \ repair messages.  After pending repair\n   transmissions are completed, the\
    \ sender continues with new\n   transmissions of any enqueued data.  Also, at\
    \ this point in time, the\n   sender begins a \"holdoff\" timeout during which\
    \ time the sender\n   constrains itself from initiating a new repair aggregation\
    \ cycle,\n   even if NORM_NACK messages arrive.  As described in [4], the value\
    \ of\n   this sender \"holdoff\" period is:\n                         T_sndrHoldoff\
    \ = (1*GRTT)\n   If additional NORM_NACK messages are received during this sender\n\
    \   \"holdoff\" period, the sender will immediately incorporate these \"late\n\
    \   messages\" into its pending transmission state ONLY if the NACK\n   content\
    \ is ordinally greater than the sender's current transmission\n   position.  This\
    \ \"holdoff\" time allows worst case time for the sender\n   to propagate its\
    \ current transmission sequence position to the group,\n   thus avoiding redundant\
    \ repair transmissions.  After the holdoff\n   timeout expires, a new NACK accumulation\
    \ period can be begun (upon\n   arrival of a NACK) in concert with the pending\
    \ repair and new data\n   transmission.  Recall that receivers are not to initiate\
    \ the NACK\n   repair process until the sender's logical transmission position\n\
    \   exceeds the lowest ordinal position of their repair needs.  With the\n   new\
    \ NACK aggregation period, the sender repeats the same process of\n   incorporating\
    \ accumulated repair state into its transmission plan and\n   subsequently \"\
    rewinding\" to transmit the lowest ordinal repair data\n   when the aggregation\
    \ period expires.  Again, this is conducted in\n   concert with ongoing new data\
    \ and/or pending repair transmissions.\n"
- title: 5.4.2.  Sender FEC Repair Transmission Strategy
  contents:
  - "5.4.2.  Sender FEC Repair Transmission Strategy\n   The NORM sender should leverage\
    \ transmission of FEC parity content\n   for repair to the greatest extent possible.\
    \  Recall that the\n   receivers use a strategy to request a lowest common denominator\
    \ of\n   explicit repair (including parity content) in the formation of their\n\
    \   NORM_NACK messages.  Before falling back to explicitly satisfying\n   different\
    \ receivers' repair needs, the sender can make use of the\n   general erasure-filling\
    \ capability of FEC-generated parity segments.\n   The sender can determine the\
    \ maximum erasure filling needs for\n   individual FEC coding blocks from the\
    \ NORM_NACK messages received\n   during the repair aggregation period.  Then,\
    \ if the sender has a\n   sufficient number (less than or equal to the maximum\
    \ erasure count)\n   of previously unsent parity segments available for the applicable\n\
    \   coding blocks, the sender can transmit these in lieu of the specific\n   packets\
    \ the receiver set has requested.  Only after exhausting its\n   supply of \"\
    fresh\" (unsent) parity segments for a given coding block\n   should the sender\
    \ resort to explicit transmission of the receiver\n   set's repair needs.  In\
    \ general, if a sufficiently powerful FEC code\n   is used, the need for explicit\
    \ repair will be an exception, and the\n   fulfillment of reliable multicast can\
    \ be accomplished quite\n   efficiently.  However, the ability to resort to explicit\
    \ repair\n   allows the protocol to be reliable under even very extreme\n   circumstances.\n\
    \   NORM_DATA messages sent as repair transmissions SHALL be flagged with\n  \
    \ the NORM_FLAG_REPAIR flag.  This allows receivers to obey any\n   policies that\
    \ limit new receivers from joining the reliable\n   transmission when only repair\
    \ transmissions have been received.\n   Additionally, the sender SHOULD additionally\
    \ flag NORM_DATA\n   transmissions sent as explicit repair with the NORM_FLAG_EXPLICIT\n\
    \   flag.\n   Although NORM end system receivers do not make use of the\n   NORM_FLAG_EXPLICIT\
    \ flag, this message transmission status could be\n   leveraged by intermediate\
    \ systems wishing to \"assist\" NORM protocol\n   performance.  If such systems\
    \ are properly positioned with respect to\n   reciprocal reverse-path multicast\
    \ routing, they need to sub-cast only\n   a sufficient count of non-explicit parity\
    \ repairs to satisfy a\n   multicast routing sub-tree's erasure filling needs\
    \ for a given FEC\n   coding block.  When the sender has resorted to explicit\
    \ repair, then\n   the intermediate systems should sub-cast all of the explicit\
    \ repair\n   packets to those portions of the routing tree still requiring repair\n\
    \   for a given coding block.  Note the intermediate systems will be\n   required\
    \ to conduct repair state accumulation for sub-routes in a\n   manner similar\
    \ to the sender's repair state accumulation in order to\n   have sufficient information\
    \ to perform the sub-casting.\n   Additionally, the intermediate systems could\
    \ perform additional\n   NORM_NACK suppression/aggregation as it conducts this\
    \ repair state\n   accumulation for NORM repair cycles.  The detail of this type\
    \ of\n   operation are beyond the scope of this document, but this information\n\
    \   is provided for possible future consideration.\n"
- title: 5.4.3.  Sender NORM_CMD(SQUELCH) Generation
  contents:
  - "5.4.3.  Sender NORM_CMD(SQUELCH) Generation\n   If the sender receives a NORM_NACK\
    \ message for repair of data it is\n   no longer supporting, the sender generates\
    \ a NORM_CMD(SQUELCH)\n   message to advertise its repair window and squelch any\
    \ receivers from\n   additional NACKing of invalid data.  The transmission rate\
    \ of\n   NORM_CMD(SQUELCH) messages is limited to once per 2*GRTT.  The\n   \"\
    invalid_object_list\" (if applicable) of the NORM_CMD(SQUELCH)\n   message SHALL\
    \ begin with the lowest \"object_transport_id\" from the\n   invalid NORM_NACK\
    \ messages received since the last NORM_CMD(SQUELCH)\n   transmission.  Lower\
    \ ordinal invalid \"object_transport_ids\" should be\n   included only while the\
    \ NORM_CMD(SQUELCH) payload is less than the\n   sender's NormSegmentSize parameter.\n"
- title: 5.4.4.  Sender NORM_CMD(REPAIR_ADV) Generation
  contents:
  - "5.4.4.  Sender NORM_CMD(REPAIR_ADV) Generation\n   When a NORM sender receives\
    \ NORM_NACK messages from receivers via\n   unicast transmission, it uses NORM_CMD(REPAIR_ADV)\
    \ messages to\n   advertise its accumulated repair state to the receiver set since\
    \ the\n   receiver set is not directly sharing their repair needs via multicast\n\
    \   communication.  The NORM_CMD(REPAIR_ADV) message is multicast to the\n   receiver\
    \ set by the sender.  The payload portion of this message has\n   content in the\
    \ same format as the NORM_NACK receiver message payload.\n   Receivers are then\
    \ able to perform feedback suppression in the same\n   manner as with NORM_NACK\
    \ messages directly received from other\n   receivers.  Note the sender does not\
    \ merely retransmit NACK content\n   it receives, but instead transmits a representation\
    \ of its aggregated\n   repair state.  The transmission of NORM_CMD(REPAIR_ADV)\
    \ messages are\n   subject to the sender transmit rate limit and NormSegmentSize\n\
    \   limitation.  When the NORM_CMD(REPAIR_ADV) message is of maximum\n   size,\
    \ receivers SHALL consider the maximum ordinal transmission\n   position value\
    \ embedded in the message as the senders \"current\"\n   transmission position\
    \ and implicitly suppress requests for ordinally\n   higher repair.  For congestion\
    \ control operation, the sender may also\n   need to provide information so that\
    \ dynamic congestion control\n   feedback can be suppressed as needed among receivers.\
    \  This document\n   specifies the NORM-CC Feedback Header Extension that is applied\
    \ for\n   baseline NORM-CC operation.  If other congestion control mechanisms\n\
    \   are used within a NORM implementation, other header extensions may be\n  \
    \ defined.  Whatever content format is used for this purpose should\n   ensure\
    \ that maximum possible suppression state is conveyed to the\n   receiver set.\n"
- title: 5.5.  Additional Protocol Mechanisms
  contents:
  - "5.5.  Additional Protocol Mechanisms\n   In addition to the principal function\
    \ of data content transmission\n   and repair, there are some other protocol mechanisms\
    \ that help NORM\n   to adapt to network conditions and play fairly with other\
    \ coexistent\n   protocols.\n"
- title: 5.5.1.  Greatest Round-trip Time Collection
  contents:
  - "5.5.1.  Greatest Round-trip Time Collection\n   For NORM receivers to appropriately\
    \ scale backoff timeouts and the\n   senders to use proper corresponding timeouts,\
    \ the participants must\n   agree on a common timeout basis.  Each NORM sender\
    \ monitors the\n   round-trip time of active receivers and determines the group\
    \ greatest\n   round-trip time (GRTT).  The sender advertises this GRTT estimate\
    \ in\n   every message it transmits so that receivers have this value\n   available\
    \ for scaling their timers.  To measure the current GRTT, the\n   sender periodically\
    \ sends NORM_CMD(CC) messages that contain a\n   locally generated timestamp.\
    \  Receivers are expected to record this\n   timestamp along with the time the\
    \ NORM_CMD(CC) message is received.\n   Then, when the receivers generate feedback\
    \ messages to the sender, an\n   adjusted version of the sender timestamp is embedded\
    \ in the feedback\n   message (NORM_NACK or NORM_ACK).  The adjustment adds the\
    \ amount of\n   time the receiver held the timestamp before generating its response.\n\
    \   Upon receipt of this adjusted timestamp, the sender is able to\n   calculate\
    \ the round-trip time to that receiver.\n   The round-trip time for each receiver\
    \ is fed into an algorithm that\n   weights and smoothes the values for a conservative\
    \ estimate of the\n   GRTT.  The algorithm and methodology are described in the\
    \ NORM\n   Building Block document [4] in the section entitled \"One-to-Many\n\
    \   Sender GRTT Measurement\".  A conservative estimate helps feedback\n   suppression\
    \ at a small cost in overall protocol repair delay.  The\n   sender's current\
    \ estimate of GRTT is advertised in the \"grtt\" field\n   found in all NORM sender\
    \ messages.  The advertised GRTT is also\n   limited to a minimum of the nominal\
    \ inter-packet transmission time\n   given the sender's current transmission rate\
    \ and system clock\n   granularity.  The reason for this additional limit is to\
    \ keep the\n   receiver somewhat \"event driven\" by making sure the sender has\
    \ had\n   adequate time to generate any response to repair requests from\n   receivers\
    \ given transmit rate limitations due to congestion control\n   or configuration.\n\
    \   When the NORM-CC Rate header extension is present in NORM_CMD(CC)\n   messages,\
    \ the receivers respond to NORM_CMD(CC) messages as described\n   in Section 5.5.2,\
    \ \"NORM Congestion Control Operation\".  The\n   NORM_CMD(CC) messages are periodically\
    \ generated by the sender as\n   described for congestion control operation. \
    \ This provides for\n   proactive, but controlled, feedback from the group in\
    \ the form of\n   NORM_ACK messages.  This provides for GRTT feedback even if\
    \ no\n   NORM_NACK messages are being sent.  If operating without congestion\n\
    \   control in a closed network, the NORM_CMD(CC) messages may be sent\n   periodically\
    \ without the NORM-CC Rate header extension.  In this\n   case, receivers will\
    \ only provide GRTT measurement feedback when\n   NORM_NACK messages are generated\
    \ since no NORM_ACK messages are\n   generated.  In this case, the NORM_CMD(CC)\
    \ messages may be sent less\n   frequently, perhaps as little as once per minute,\
    \ to conserve network\n   capacity.  Note that the NORM-CC Rate header extension\
    \ may also be\n   used proactively solicit RTT feedback from the receiver group\
    \ per\n   congestion control operation even though the sender may not be\n   conducting\
    \ congestion control rate adjustment.  NORM operation\n   without congestion control\
    \ should be considered only in closed\n   networks.\n"
- title: 5.5.2.  NORM Congestion Control Operation
  contents:
  - "5.5.2.  NORM Congestion Control Operation\n   This section describes baseline\
    \ congestion control operation for the\n   NORM protocol (NORM-CC).  The supporting\
    \ NORM message formats and\n   approach described here are an adaptation of the\
    \ equation-based TCP-\n   Friendly Multicast Congestion Control (TFMCC) approach\
    \ described in\n   [19].  This congestion control scheme is REQUIRED for operation\n\
    \   within the general Internet unless the NORM implementation is adapted\n  \
    \ to use another IETF-sanctioned reliable multicast congestion control\n   mechanism\
    \ (e.g., PGMCC [20]).  With this TFMCC-based approach, the\n   transmissions of\
    \ NORM senders are controlled in a rate-based manner\n   as opposed to window-based\
    \ congestion control algorithms as in TCP.\n   However, it is possible that the\
    \ NORM protocol message set may\n   alternatively be used to support a window-based\
    \ multicast congestion\n   control scheme such as PGMCC.  The details of that\
    \ alternative may be\n   described separately or in a future revision of this\
    \ document.  In\n   either case (rate-based TFMCC or window-based PGMCC), successful\n\
    \   control of sender transmission depends upon collection of sender-to-\n   receiver\
    \ packet loss estimates and RTTs to identify the congestion\n   control bottleneck\
    \ path(s) within the multicast topology and adjust\n   the sender rate accordingly.\
    \  The receiver with loss and RTT\n   estimates that correspond to the lowest\
    \ result transmission rate is\n   identified as the \"current limiting receiver\"\
    \ (CLR).\n   As described in [21], a steady-state sender transmission rate, to\
    \ be\n   \"friendly\" with competing TCP flows can be calculated as:\n       \
    \                                S\n"
- title: Rsender = --------------------------------------------------------------
  contents:
  - "Rsender = --------------------------------------------------------------\n  \
    \        tRTT * (sqrt((2/3)*p) + 12 * sqrt((3/8)*p) * p *\n          (1 + 32*(p^2)))\n"
- title: where
  contents:
  - "where\n   S = Nominal transmitted packet size. (In NORM, the \"nominal\"\n  \
    \     packet size can be determined by the sender as an\n       exponentially\
    \ weighted moving average (EWMA) of transmitted\n       packet sizes to account\
    \ for variable message sizes).\n"
- title: tRTT = The RTT estimate of the current "current limiting receiver"
  contents:
  - "tRTT = The RTT estimate of the current \"current limiting receiver\"\n      \
    \ (CLR).\n   p = The loss event fraction of the CLR.\n   To support congestion\
    \ control feedback collection and operation, the\n   NORM sender periodically\
    \ transmits NORM_CMD(CC) command messages.\n   NORM_CMD(CC) messages are multiplexed\
    \ with NORM data and repair\n   transmissions and serve several purposes:\n  \
    \ 1) Stimulate explicit feedback from the general receiver set to\n      collect\
    \ congestion control information.\n   2) Communicate state to the receiver set\
    \ on the sender's current\n      congestion control status including details of\
    \ the CLR.\n   3) Initiate rapid (immediate) feedback from the CLR in order to\n\
    \      closely track the dynamics of congestion control for that current\n   \
    \   \"worst path\" in the group multicast topology.\n   The format of the NORM_CMD(CC)\
    \ message is describe in Section 4.2.3\n   of this document.  The NORM_CMD(CC)\
    \ message contains information to\n   allow measurement of RTTs, to inform the\
    \ group of the congestion\n   control CLR, and to provide feedback of individual\
    \ RTT measurements\n   to the receivers in the group.  The NORM_CMD(CC) also provides\
    \ for\n   exciting feedback from OPTIONAL \"potential limiting receiver\" (PLR)\n\
    \   nodes that may be determined administratively or possibly\n   algorithmically\
    \ based on congestion control feedback.  PLR nodes are\n   receivers that have\
    \ been identified to have potential for (perhaps\n   soon) becoming the CLR and\
    \ thus immediate, up-to-date feedback is\n   beneficial for congestion control\
    \ performance.  The details of PLR\n   selection are not discussed in this document.\n"
- title: 5.5.2.1.  NORM_CMD(CC) Transmission
  contents:
  - "5.5.2.1.  NORM_CMD(CC) Transmission\n   The NORM_CMD(CC) message is transmitted\
    \ periodically by the sender\n   along with its normal data transmission.  Note\
    \ that the repeated\n   transmission of NORM_CMD(CC) messages may be initiated\
    \ some time\n   before transmission of user data content at session startup. \
    \ This\n   may be done to collect some estimation of the current state of the\n\
    \   multicast topology with respect to group and individual RTT and\n   congestion\
    \ control state.\n   A NORM_CMD(CC) message is immediately transmitted at sender\
    \ startup.\n   The interval of subsequent NORM_CMD(CC) message transmission is\n\
    \   determined as follows:\n   1) By default, the interval is set according to\
    \ the current sender\n      GRTT estimate.  A startup GRTT of 0.5 seconds is recommended\
    \ when\n      no feedback has yet been received from the group.\n   2) If a CLR\
    \ has been identified (based on previous receiver\n      feedback), the interval\
    \ is the RTT between the sender and CLR.\n   3) Additionally, if the interval\
    \ of nominal data message transmission\n      is greater than the GRTT or RTT_clr\
    \ interval, the NORM_CMD(CC)\n      interval is set to this greater value.  This\
    \ ensures that the\n      transmission of this control message is not done to\
    \ the exclusion\n      of user data transmission.\n   The NORM_CMD(CC) \"cc_sequence\"\
    \ field is incremented with each\n   transmission of a NORM_CMD(CC) command. \
    \ The greatest \"cc_sequence\"\n   recently received by receivers is included\
    \ in their feedback to the\n   sender.  This allows the sender to determine the\
    \ \"age\" of feedback to\n   assist in congestion avoidance.\n   The NORM-CC Rate\
    \ Header Extension is applied to the NORM_CMD(CC)\n   message and the sender advertises\
    \ its current transmission rate in\n   the \"send_rate\" field.  The rate information\
    \ is used by receivers to\n   initialize loss estimation during congestion control\
    \ startup or\n   restart.\n   The \"cc_node_list\" contains a list of entries\
    \ identifying receivers\n   and their current congestion control state (status\
    \ \"flags\", \"rtt\" and\n   \"loss\" estimates).  The list may be empty if the\
    \ sender has not yet\n   received any feedback from the group.  If the sender\
    \ has received\n   feedback, the list will minimally contain an entry identifying\
    \ the\n   CLR.  A NORM_FLAG_CC_CLR flag value is provided for the \"cc_flags\"\
    \n   field to identify the CLR entry.  It is RECOMMENDED that the CLR\n   entry\
    \ be the first in the list for implementation efficiency.\n   Additional entries\
    \ in the list are used to provide sender-measured\n   individual RTT estimates\
    \ to receivers in the group.  The number of\n   additional entries in this list\
    \ is dependent upon the percentage of\n   control traffic the sender application\
    \ is willing to send with\n   respect to user data message transmissions.  More\
    \ entries in the list\n   may allow the sender to be more responsive to congestion\
    \ control\n   dynamics.  The length of the list may be dynamically determined\n\
    \   according to the current transmission rate and scheduling of\n   NORM_CMD(CC)\
    \ messages.  The maximum length of the list corresponds to\n   the sender's NormSegmentSize\
    \ parameter for the session.  The\n   inclusion of additional entries in the list\
    \ based on receiver\n   feedback are prioritized with following rules:\n   1)\
    \ Receivers that have not yet been provided RTT feedback get first\n      priority.\
    \  Of these, those with the greatest loss fraction receive\n      precedence for\
    \ list inclusion.\n   2) Secondly, receivers that have previously been provided\
    \ RTT are\n      included with receivers yielding the lowest calculated congestion\n\
    \      rate getting precedence.\n   There are \"cc_flag\" values in addition to\
    \ NORM_FLAG_CC_CLR that are\n   used for other congestion control functions. \
    \ The NORM_FLAG_CC_PLR\n   flag value is used to mark additional receivers from\
    \ that the sender\n   would like to have immediate, non-suppressed feedback. \
    \ These may be\n   receivers that the sender algorithmically identified as potential\n\
    \   future CLRs or that have been pre-configured as potential congestion\n   control\
    \ points in the network.  The NORM_FLAG_CC_RTT indicates the\n   validity of the\
    \ \"cc_rtt\" field for the associated receiver node.\n   Normally, this flag will\
    \ be set since the receivers in the list will\n   typically be receivers from\
    \ which the sender has received feedback.\n   However, in the case that the NORM\
    \ sender has been pre-configured\n   with a set of PLR nodes, feedback from those\
    \ receivers may not yet\n   have been collected and thus the \"cc_rtt\" and \"\
    cc_rate\" fields do not\n   contain valid values when this flag is not set.\n"
- title: 5.5.2.2.  NORM_CMD(CC) Feedback Response
  contents:
  - "5.5.2.2.  NORM_CMD(CC) Feedback Response\n   Receivers explicitly respond to\
    \ NORM_CMD(CC) messages in the form of\n   a NORM_ACK(RTT) message.  The goal\
    \ of the congestion control feedback\n   is to determine the receivers with the\
    \ lowest congestion control\n   rates.  Receivers that are marked as CLR or PLR\
    \ nodes in the\n   NORM_CMD(CC) \"cc_node_list\" immediately provide feedback\
    \ in the form\n   of a NORM_ACK to this message.  When a NORM_CMD(CC) is received,\n\
    \   non-CLR or non-PLR nodes initiate random feedback backoff timeouts\n   similar\
    \ to that used when the receiver initiates a repair cycle (see\n   Section 5.3)\
    \ in response to detection of data loss.  The backoff\n   timeout for the congestion\
    \ control response is generated as follows:\n           T_backoff = RandomBackoff(K*GRTTsender,\
    \ GSIZEsender)\n   The \"RandomBackoff()\" algorithm provides a truncated exponentially\n\
    \   distributed random number and is described in the NORM Building Block\n  \
    \ document [4].  The same backoff factor K = Ksender MAY be used as\n   with NORM_NACK\
    \ suppression.  However, in cases where the application\n   purposefully specifies\
    \ a very small Ksender backoff factor to\n   minimize the NACK repair process\
    \ latency (trading off group size\n   scalability), it may still be desirable\
    \ to maintain a larger backoff\n   factor for congestion control feedback, since\
    \ there may often be a\n   larger volume of congestion control feedback than NACKs\
    \ in many cases\n   and congestion control feedback latency may be tolerable where\n\
    \   reliable delivery latency is not.  As previously noted, a backoff\n   factor\
    \ value of K = 4 is generally recommended for ASM operation and\n   K = 6 for\
    \ SSM operation.  A receiver SHALL cancel the backoff timeout\n   and thus its\
    \ pending transmission of a NORM_ACK(RTT) message under\n   the following conditions:\n\
    \   1) The receiver generates another feedback message (NORM_NACK or\n      other\
    \ NORM_ACK) before the congestion control feedback timeout\n      expires,\n \
    \  2) A NORM_CMD(CC) or other receiver feedback with an ordinally\n      greater\
    \ \"cc_sequence\" field value is received before the\n      congestion control\
    \ feedback timeout expires (this is similar to\n      the TFMCC feedback round\
    \ number),\n   3) When the T_backoff is greater than 1*GRTT.  This prevents NACK\n\
    \      implosion in the event of sender or network failure,\n   4) \"Suppressing\"\
    \ congestion control feedback is heard from another\n      receiver (in a NORM_ACK\
    \ or NORM_NACK) or via a\n      NORM_CMD(REPAIR_ADV) message from the sender.\
    \  The local\n      receiver's feedback is \"suppressed\" if the rate of the competing\n\
    \      feedback (Rfb) is sufficiently close to or less than the local\n      receiver's\
    \ calculated rate (Rcalc).  The local receiver's feedback\n      is canceled when:\n\
    \                             Rcalc > (0.9 * Rfb)\n      Also note receivers that\
    \ have not yet received an RTT measurement\n      from the sender are suppressed\
    \ only by other receivers that have\n      not yet measured RTT.  Additionally,\
    \ receivers whose RTT estimate\n      has \"aged\" considerably (i.e., they haven't\
    \ been included in the\n      NORM_CMD(CC) \"cc_node_list\" in a long time) may\
    \ wish to compete as\n      a receiver with no prior RTT measurement after some\
    \ expiration\n      period.\n   When the backoff timer expires, the receiver SHALL\
    \ generate a\n   NORM_ACK(RTT) message to provide feedback to the sender and group.\n\
    \   This message may be multicast to the group for most effective\n   suppression\
    \ in ASM topologies or unicast to the sender depending upon\n   how the NORM protocol\
    \ is deployed and configured.\n   Whenever any feedback is generated (including\
    \ this NORM_ACK(RTT)\n   message), receivers include an adjusted version of the\
    \ sender\n   timestamp from the most recently received NORM_CMD(CC) message and\n\
    \   the \"cc_sequence\" value from that command in the applicable NORM_ACK\n \
    \  or NORM_NACK message fields.  For NORM-CC operation, any generated\n   feedback\
    \ message SHALL also contain the NORM-CC Feedback header\n   extension.  The receiver\
    \ provides its current \"cc_rate\" estimate,\n   \"cc_loss\" estimate, \"cc_rtt\"\
    \ if known, and any applicable \"cc_flags\"\n   via this header extension.\n \
    \  During slow start (when the receiver has not yet detected loss from\n   the\
    \ sender), the receiver uses a value equal to two times its\n   measured rate\
    \ from the sender in the \"cc_rate\" field.  For steady-\n   state congestion\
    \ control operation, the receiver \"cc_rate\" value is\n   from the equation-based\
    \ value using its current loss event estimate\n   and sender<->receiver RTT information.\
    \  (The GRTT is used when the\n   receiver has not yet measured its individual\
    \ RTT).\n   The \"cc_loss\" field value reflects the receiver's current loss event\n\
    \   estimate with respect to the sender in question.\n   When the receiver has\
    \ a valid individual RTT measurement, it SHALL\n   include this value in the \"\
    cc_rtt\" field.  The NORM_FLAG_CC_RTT MUST\n   be set when the \"cc_rtt\" field\
    \ is valid.\n   After a congestion control feedback message is generated or when\
    \ the\n   feedback is suppressed, a non-CLR receiver begins a \"holdoff\" timeout\n\
    \   period during which it will restrain itself from providing congestion\n  \
    \ control feedback, even if NORM_CMD(CC) messages are received from the\n   sender\
    \ (unless the receive becomes marked as a CLR or PLR node).  The\n   value of\
    \ this holdoff timeout (T_ccHoldoff) period is:\n                          T_ccHoldoff\
    \ = (K*GRTT)\n   Thus, non-CLR receivers are constrained to providing explicit\n\
    \   congestion control feedback once per K*GRTT intervals.  Note,\n   however,\
    \ that as the session progresses, different receivers will be\n   responding to\
    \ different NORM_CMD(CC) messages and there will be\n   relatively continuous\
    \ feedback of congestion control information\n   while the sender is active.\n"
- title: 5.5.2.3.  Congestion Control Rate Adjustment
  contents:
  - "5.5.2.3.  Congestion Control Rate Adjustment\n   During steady-state operation,\
    \ the sender will directly adjust its\n   transmission rate to the rate indicated\
    \ by the feedback from its\n   currently selected CLR.  As noted in [19], the\
    \ estimation of\n   parameters (loss and RTT) for the CLR will generally constrain\
    \ the\n   rate changes possible within acceptable bounds.  For rate increases,\n\
    \   the sender SHALL observe a maximum rate of increase of one packet per\n  \
    \ RTT at all times during steady-state operation.\n   The sender processes congestion\
    \ control feedback from the receivers\n   and selects the CLR based on the lowest\
    \ rate receiver.  Receiver\n   rates are either determined directly from the slow\
    \ start \"cc_rate\"\n   provided by the receiver in the NORM-CC Feedback header\
    \ extension or\n   by performing the equation-based calculation using individual\
    \ RTT and\n   loss estimates (\"cc_loss\") as feedback is received.\n   The sender\
    \ can calculate a current RTT for a receiver (RTT_rcvrNew)\n   using the \"grtt_response\"\
    \ timestamp included in feedback messages.\n   When the \"cc_rtt\" value in a\
    \ response is not valid, the sender simply\n   uses this RTT_rcvrNew value as\
    \ the receiver's current RTT (RTT_rcvr).\n   For non-CLR and non-PLR receivers,\
    \ the sender can use the \"cc_rtt\"\n   value provided in the NORM-CC Feedback\
    \ header extension as the\n   receiver's previous RTT measurement (RTT_rcvrPrev)\
    \ to smooth\n   according to:\n             RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5\
    \ * RTT_rcvrNew\n   For CLR receivers where feedback is received more regularly,\
    \ the\n   sender SHOULD maintain a more smoothed RTT estimate upon new feedback\n\
    \   from the CLR where:\n                RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew\n\
    \   \"RTT_clrNew\" is the new RTT calculated from the timestamp in the\n   feedback\
    \ message received from the CLR.  The RTT_clr is initialized\n   to RTT_clrNew\
    \ on the first feedback message received.  Note that the\n   same procedure is\
    \ observed by the sender for PLR receivers and that\n   if a PLR is \"promoted\"\
    \ to CLR status, the smoothed estimate can be\n   continued.\n   There are some\
    \ additional periods besides steady-state operation that\n   need to be considered\
    \ in NORM-CC operation.  These periods are:\n   1) during session startup,\n \
    \  2) when no feedback is received from the CLR, and\n   3) when the sender has\
    \ a break in data transmission.\n   During session startup, the congestion control\
    \ operation SHALL\n   observe a \"slow start\" procedure to quickly approach its\
    \ fair\n   bandwidth share.  An initial sender startup rate is assumed where:\n\
    \   Rinitial = MIN(NormSegmentSize / GRTT, NormSegmentSize) bytes/second.\n  \
    \ The rate is increased only when feedback is received from the\n   receiver set.\
    \  The \"slow start\" phase proceeds until any receiver\n   provides feedback\
    \ indicating that loss has occurred.  Rate increase\n   during slow start is applied\
    \ as:\n                             Rnew = Rrecv_min\n   where \"Rrecv_min\" is\
    \ the minimum reported receiver rate in the\n   \"cc_rate\" field of congestion\
    \ control feedback messages received from\n   the group.  Note that during \"\
    slow start\", receivers use two times\n   their measured rate from the sender\
    \ in the \"cc_rate\" field of their\n   feedback.  Rate increase adjustment is\
    \ limited to once per GRTT\n   during slow start.\n   If the CLR or any receiver\
    \ intends to leave the group, it will set\n   the NORM_FLAG_CC_LEAVE in its congestion\
    \ control feedback message as\n   an indication that the sender should not select\
    \ it as the CLR.  When\n   the CLR changes to a lower rate receiver, the sender\
    \ should\n   immediately adjust to the new lower rate.  The sender is limited\
    \ to\n   increasing its rate at one additional packet per RTT towards any new,\n\
    \   higher CLR rate.\n   The sender should also track the \"age\" of the feedback\
    \ it has\n   received from the CLR by comparing its current \"cc_sequence\" value\n\
    \   (Seq_sender) to the last \"cc_sequence\" value received from the CLR\n   (Seq_clr).\
    \  As the \"age\" of the CLR feedback increases with no new\n   feedback, the\
    \ sender SHALL begin reducing its rate once per RTT_clr\n   as a congestion avoidance\
    \ measure.\n   The following algorithm is used to determine the decrease in sender\n\
    \   rate (Rsender bytes/sec) as the CLR feedback, unexpectedly,\n   excessively\
    \ ages:\n   Age = Seq_sender - Seq_clr;\n   if (Age > 4) Rsender = Rsender * 0.5;\n\
    \   This rate reduction is limited to the lower bound on NORM\n   transmission\
    \ rate.  After NORM_ROBUST_FACTOR consecutive NORM_CMD(CC)\n   rounds without\
    \ any feedback from the CLR, the sender SHOULD assume\n   the CLR has left the\
    \ group and pick the receiver with the next lowest\n   rate as the new CLR.  Note\
    \ this assumes that the sender does not have\n   explicit knowledge that the CLR\
    \ intentionally left the group.  If no\n   receiver feedback is received, the\
    \ sender MAY wish to withhold\n   further transmissions of NORM_DATA segments\
    \ and maintain NORM_CMD(CC)\n   transmissions only until feedback is detected.\
    \  After such a CLR\n   timeout, the sender will be transmitting with a minimal\
    \ rate and\n   should return to slow start as described here for a break in data\n\
    \   transmission.\n   When the sender has a break in its data transmission, it\
    \ can continue\n   to probe the group with NORM_CMD(CC) messages to maintain RTT\n\
    \   collection from the group.  This will enable the sender to quickly\n   determine\
    \ an appropriate CLR upon data transmission restart.\n   However, the sender should\
    \ exponentially reduce its target rate to be\n   used for transmission restart\
    \ as time since the break elapses.  The\n   target rate SHOULD be recalculated\
    \ once per RTT_clr as:\n                         Rsender = Rsender * 0.5;\n  \
    \ If the minimum NORM rate is reached, the sender should set the\n   NORM_FLAG_START\
    \ flag in its NORM_CMD(CC) messages upon restart and\n   the group should observer\
    \ \"slow start\" congestion control procedures\n   until any receiver experiences\
    \ a new loss event.\n"
- title: 5.5.3.  NORM Positive Acknowledgment Procedure
  contents:
  - "5.5.3.  NORM Positive Acknowledgment Procedure\n   NORM provides options for\
    \ the source application to request positive\n   acknowledgment (ACK) of NORM_CMD(FLUSH)\
    \ and NORM_CMD(ACK_REQ)\n   messages from members of the group.  There are some\
    \ specific\n   acknowledgment requests defined for the NORM protocol and a range\
    \ of\n   acknowledgment request types that are left to be defined by the\n   application.\
    \  One predefined acknowledgment type is the\n   NORM_ACK_FLUSH type.  This acknowledgment\
    \ is used to determine if\n   receivers have achieved completion of reliable reception\
    \ up through a\n   specific logical transmission point with respect to the sender's\n\
    \   sequence of transmission.  The NORM_ACK_FLUSH acknowledgment may be\n   used\
    \ to assist in application flow control when the sender has\n   information on\
    \ a portion of the receiver set.  Another predefined\n   acknowledgment type is\
    \ NORM_ACK(CC), which is used to explicitly\n   provide congestion control feedback\
    \ in response to NORM_CMD(CC)\n   messages transmitted by the sender for NORM-CC\
    \ operation.  Note the\n   NORM_ACK(CC) response does NOT follow the positive\
    \ acknowledgment\n   procedure described here.  The NORM_CMD(ACK_REQ) and NORM_ACK\n\
    \   messages contain an \"ack_type\" field to identify the type of\n   acknowledgment\
    \ requested and provided.  A range of \"ack_type\" values\n   is provided for\
    \ application-defined use.  While the application is\n   responsible for initiating\
    \ the acknowledgment request and interprets\n   application-defined \"ack_type\"\
    \ values, the acknowledgment procedure\n   SHOULD be conducted within the protocol\
    \ implementation to take\n   advantage of timing and transmission scheduling information\
    \ available\n   to the NORM transport.\n   The NORM positive acknowledgment procedure\
    \ uses polling by the sender\n   to query the receiver group for response.  Note\
    \ this polling\n   procedure is not intended to scale to very large receiver groups,\
    \ but\n   could be used in large group setting to query a critical subset of\n\
    \   the group.  Either the NORM_CMD(ACK_REQ), or when applicable, the\n   NORM_CMD(FLUSH)\
    \ message is used for polling and contains a list of\n   NormNodeIds for receivers\
    \ that should respond to the command.  The\n   list of receivers providing acknowledgment\
    \ is determined by the\n   source application with \"a priori\" knowledge of participating\
    \ nodes\n   or via some other application-level mechanism.\n   The ACK process\
    \ is initiated by the sender that generates\n   NORM_CMD(FLUSH) or NORM_CMD(ACK_REQ)\
    \ messages in periodic \"rounds\".\n   For NORM_ACK_FLUSH requests, the NORM_CMD(FLUSH)\
    \ contain a\n   \"object_transport_id\" and \"fec_payload_id\" denoting the watermark\n\
    \   transmission point for which acknowledgment is requested.  This\n   watermark\
    \ transmission point is \"echoed\" in the corresponding fields\n   of the NORM_ACK(FLUSH)\
    \ message sent by the receiver in response.\n   NORM_CMD(ACK_REQ) messages contain\
    \ an \"ack_id\" field which is\n   similarly \"echoed\" in response so that the\
    \ sender may match the\n   response to the appropriate request.\n   In response\
    \ to the NORM_CMD(ACK_REQ), the listed receivers randomly\n   spread NORM_ACK\
    \ messages uniformly in time over a window of (1*GRTT).\n   These NORM_ACK messages\
    \ are typically unicast to the sender.  (Note\n   that NORM_ACK(CC) messages SHALL\
    \ be multicast or unicast in the same\n   manner as NORM_NACK messages).\n   The\
    \ ACK process is self-limiting and avoids ACK implosion in that:\n   1) Only a\
    \ single NORM_CMD(ACK_REQ) message is generated once per\n      (2*GRTT), and,\n\
    \   2) The size of the \"acking_node_list\" of NormNodeIds from which\n      acknowledgment\
    \ is requested is limited to a maximum of the sender\n      NormSegmentSize setting\
    \ per round of the positive acknowledgment\n      process.\n   Because the size\
    \ of the included list is limited to the sender's\n   NormSegmentSize setting,\
    \ multiple NORM_CMD(ACK_REQ) rounds may be\n   required to achieve responses from\
    \ all receivers specified.  The\n   content of the attached NormNodeId list will\
    \ be dynamically updated\n   as this process progresses and NORM_ACK responses\
    \ are received from\n   the specified receiver set.  As the sender receives valid\
    \ responses\n   (i.e., matching watermark point or \"ack_id\") from receivers,\
    \ it SHALL\n   eliminate those receivers from the subsequent NORM_CMD(ACK_REQ)\n\
    \   message \"acking_node_list\" and add in any pending receiver\n   NormNodeIds\
    \ while keeping within the NormSegmentSize limitation of\n   the list size.  Each\
    \ receiver is  queried a maximum number of times\n   (NORM_ROBUST_FACTOR, by default).\
    \  Receivers not responding within\n   this number of repeated requests are removed\
    \ from the payload list to\n   make room for other potential receivers pending\
    \ acknowledgment.  The\n   transmission of the NORM_CMD(ACK_REQ) is repeated until\
    \ no further\n   responses are required or until the repeat threshold is exceeded\
    \ for\n   all pending receivers.  The transmission of NORM_CMD(ACK_REQ) or\n \
    \  NORM_CMD(FLUSH) messages to conduct the positive acknowledgment\n   process\
    \ is multiplexed with ongoing sender data transmissions.\n   However, the NORM_CMD(FLUSH)\
    \ positive acknowledgment process may be\n   interrupted in response to negative\
    \ acknowledgment repair requests\n   (NACKs) received from receivers during the\
    \ acknowledgment period.\n   The NORM_CMD(FLUSH) positive acknowledgment process\
    \ is restarted for\n   receivers pending acknowledgment once any the repairs have\
    \ been\n   transmitted.\n   In the case of NORM_CMD(FLUSH) commands with an attached\n\
    \   \"acking_node_list\", receivers will not ACK until they have received\n  \
    \ complete transmission of all data up to and including the given\n   watermark\
    \ transmission point.  All receivers SHALL interpret the\n   watermark point provided\
    \ in the request NACK for repairs if needed as\n   for NORM_CMD(FLUSH) commands\
    \ with no attached \"acking_node_list\".\n"
- title: 5.5.4.  Group Size Estimate
  contents:
  - "5.5.4.  Group Size Estimate\n   NORM sender messages contain a \"gsize\" field\
    \ that is a representation\n   of the group size and is used in scaling random\
    \ backoff timer ranges.\n   The use of the group size estimate within the NORM\
    \ protocol does not\n   require a precise estimation and works reasonably well\
    \ if the\n   estimate is within an order of magnitude of the actual group size.\n\
    \   By default, the NORM sender group size estimate may be\n   administratively\
    \ configured.  Also, given the expected scalability of\n   the NORM protocol for\
    \ general use, a default value of 10,000 is\n   recommended for use as the group\
    \ size estimate.\n   It is possible that group size may be algorithmically approximated\n\
    \   from the volume of congestion control feedback messages which follow\n   the\
    \ exponentially weighted random backoff.  However, the\n   specification of such\
    \ an algorithm is currently beyond the scope of\n   this document.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The same security considerations that apply to\
    \ the NORM, and FEC\n   Building Blocks also apply to the NORM protocol.  In addition\
    \ to\n   vulnerabilities that any IP and IP multicast protocol implementation\n\
    \   may be generally subject to, the NACK-based feedback of NORM may be\n   exploited\
    \ by replay attacks which force the NORM sender to\n   unnecessarily transmit\
    \ repair information.  This MAY be addressed by\n   network layer IP security\
    \ implementations that guard against this\n   potential security exploitation.\
    \  It is RECOMMENDED that such IP\n   security mechanisms be used when available.\
    \  Another possible\n   approach is for NORM senders to use the \"sequence\" field\
    \ from the\n   NORM Common Message Header to detect replay attacks.  This can\
    \ be\n   accomplished if the NORM packets are cryptographically protected and\n\
    \   the sender is willing to maintain state on receivers which are\n   NACKing.\
    \  A cache of receiver state may provide some protection\n   against replay attacks.\
    \  Note that the \"sequence\" field of NORM\n   messages should be incremented\
    \ with independent values for different\n   destinations (e.g., group-addressed\
    \ versus unicast-addressed messages\n   versus \"receiver\" messages).  Thus,\
    \ the congestion control loss\n   estimation function of the \"sequence\" field\
    \ can be preserved for\n   sender messages when receiver messages are unicast\
    \ to the sender.\n   The NORM protocol is compatible with the use of the IP security\n\
    \   (IPsec) architecture described in [22].  It is important to note that\n  \
    \ while NORM does leverage FEC-based repair for scalability, this does\n   not\
    \ alone guarantee integrity of received data.  Application-level\n   integrity-checking\
    \ of data content is highly RECOMMENDED.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   No information in this specification is currently\
    \ subject to IANA\n   registration.  However, several Header Extensions are defined\
    \ within\n   this document.  If/when additional Header Extensions are developed,\n\
    \   the first RFC MUST establish an IANA registry for them, with a\n   \"Specification\
    \ Required\" policy [6] and all Header Extensions,\n   including those in the\
    \ present document, MUST be registered\n   thereafter.  Additionally, building\
    \ blocks components used by NORM\n   may introduce additional IANA considerations.\
    \  In particular, the FEC\n   Building Block used by NORM does require IANA registration\
    \ of the FEC\n   codecs used.  The registration instructions for FEC codecs are\n\
    \   provided in [5].\n"
- title: 8.  Suggested Use
  contents:
  - "8.  Suggested Use\n   The present NORM protocol is seen as useful tool for the\
    \  reliable\n   data transfer over generic IP multicast  services.  It is not\
    \ the\n   intention of the authors to suggest it is suitable for  supporting\n\
    \   all envisioned multicast reliability requirements.  NORM provides a\n   simple\
    \ and flexible framework for multicast applications with a\n   degree of concern\
    \ for network traffic implosion and protocol overhead\n   efficiency.  NORM-like\
    \ protocols have been successfully demonstrated\n   within the MBone for bulk\
    \ data dissemination applications, including\n   weather satellite compressed\
    \ imagery updates servicing a large group\n   of receivers and a generic web content\
    \ reliable \"push\" application.\n   In addition, this framework approach has\
    \ some design features making\n   it attractive for bulk transfer in asymmetric\
    \ and wireless\n   internetwork applications.  NORM is capable of successfully\
    \ operating\n   independent of network structure and in environments with high\
    \ packet\n   loss, delay, and misordering.  Hybrid proactive/reactive FEC-based\n\
    \   repairing improve protocol performance in some multicast scenarios.\n   A\
    \ sender-only repair approach often makes additional engineering\n   sense in\
    \ asymmetric networks.  NORM's unicast feedback capability may\n   be suitable\
    \ for use in asymmetric networks or in networks where only\n   unidirectional\
    \ multicast routing/delivery service exists.  Asymmetric\n   architectures supporting\
    \ multicast delivery are likely to make up an\n   important portion of the future\
    \ Internet structure (e.g.,\n   DBS/cable/PSTN hybrids) and efficient, reliable\
    \ bulk data transfer\n   will be an important capability for servicing large groups\
    \ of\n   subscribed receivers.\n"
- title: 9.  Acknowledgments (and these are not Negative)
  contents:
  - "9.  Acknowledgments (and these are not Negative)\n   The authors would like to\
    \ thank Rick Jones, Vincent Roca, Rod Walsh,\n   Toni Paila, Michael Luby, and\
    \ Joerg Widmer for their valuable input\n   and comments on this document.  The\
    \ authors would also like to thank\n   the RMT working group chairs, Roger Kermode\
    \ and Lorenzo Vicisano, for\n   their support in development of this specification,\
    \ and Sally Floyd\n   for her early input into this document.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [1]  Kermode, R. and L. Vicisano, \"Author Guidelines\
    \ for Reliable\n        Multicast Transport (RMT) Building Blocks and Protocol\n\
    \        Instantiation documents\", RFC 3269, April 2002.\n   [2]  Bradner, S.,\
    \ \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP 14,\
    \ RFC 2119, March 1997.\n   [3]  Deering, S., \"Host Extensions for IP Multicasting\"\
    , STD 5, RFC\n        1112, August 1989.\n   [4]  Adamson, B., Bormann, C., Handley,\
    \ M., and J. Macker,\n        \"Negative-Acknowledgment (NACK)-Oriented Reliable\
    \ Multicast\n        (NORM) Building Blocks\", RFC 3941, November 2004.\n   [5]\
    \  Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and\n        J.\
    \ Crowcroft, \"Forward Error Correction (FEC) Building Block\",\n        RFC 3452,\
    \ December 2002.\n   [6]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an IANA\n        Considerations Section in RFCs\", BCP 26, RFC 2434, October\
    \ 1998.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [7]  Handley, M. and V. Jacobson, \"SDP: Session\
    \ Description\n        Protocol\", RFC 2327, April 1998.\n   [8]  Handley, M.,\
    \ Perkins, C., and E. Whelan, \"Session Announcement\n        Protocol\", RFC\
    \ 2974, October 2000.\n   [9]  S. Pingali, D. Towsley, J. Kurose, \"A Comparison\
    \ of Sender-\n        Initiated and Receiver-Initiated Reliable Multicast Protocols\"\
    ,\n        In Proc. INFOCOM, San Francisco CA, October 1993.\n   [10] Luby, M.,\
    \ Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and\n        J. Crowcroft,\
    \ \"The Use of Forward Error Correction (FEC) in\n        Reliable Multicast\"\
    , RFC 3453, December 2002.\n   [11] Macker, J. and B. Adamson, \"The Multicast\
    \ Dissemination Protocol\n        (MDP) Toolkit\", Proc. IEEE MILCOM 99, October\
    \ 1999.\n   [12] Nonnenmacher, J. and E. Biersack, \"Optimal Multicast Feedback\"\
    ,\n        Proc. IEEE INFOCOMM, p. 964, March/April 1998.\n   [13] J. Macker,\
    \ B. Adamson, \"Quantitative Prediction of Nack Oriented\n        Reliable Multicast\
    \ (NORM) Feedback\", Proc. IEEE MILCOM 2002,\n        October 2002.\n   [14] H.W.\
    \ Holbrook, \"A Channel Model for Multicast\", Ph.D.\n        Dissertation, Stanford\
    \ University, Department of Computer\n        Science, Stanford, California, August\
    \ 2001.\n   [15] D. Gossink, J. Macker, \"Reliable Multicast and Integrated Parity\n\
    \        Retransmission with Channel Estimation\", IEEE GLOBECOMM 98',\n     \
    \   September 1998.\n   [16] Whetten, B., Vicisano, L., Kermode, R., Handley,\
    \ M., Floyd, S.,\n        and M. Luby, \"Reliable Multicast Transport Building\
    \ Blocks for\n        One-to-Many Bulk-Data Transfer\", RFC 3048, January 2001.\n\
    \   [17] Mankin, A., Romanow, A., Bradner, S., and V. Paxson, \"IETF\n       \
    \ Criteria for Evaluating Reliable Multicast Transport and\n        Application\
    \ Protocols\", RFC 2357, June 1998.\n   [18] Schulzrinne, H., Casner, S., Frederick,\
    \ R., and V. Jacobson,\n        \"RTP:  A Transport Protocol for Real-Time Applications\"\
    , STD 64,\n        RFC 3550, July 2003.\n   [19] J. Widmer and M. Handley, \"\
    Extending Equation-Based Congestion\n        Control to Multicast Applications\"\
    , Proc ACM SIGCOMM 2001, San\n        Diego, August 2001.\n   [20] L. Rizzo, \"\
    pgmcc: A TCP-Friendly Single-Rate Multicast\n        Congestion Control Scheme\"\
    , Proc ACM SIGCOMM 2000, Stockholm,\n        August 2000.\n   [21] J. Padhye,\
    \ V. Firoiu, D. Towsley, and J. Kurose, \"Modeling TCP\n        Throughput: A\
    \ Simple Model and its Empirical Validation\", Proc\n        ACM SIGCOMM 1998.\n\
    \   [22] Kent, S. and R. Atkinson, \"Security Architecture for the\n        Internet\
    \ Protocol\", RFC 2401, November 1998.\n"
- title: 11.  Authors' Addresses
  contents:
  - "11.  Authors' Addresses\n   Brian Adamson\n   Naval Research Laboratory\n   Washington,\
    \ DC, USA, 20375\n   EMail: adamson@itd.nrl.navy.mil\n   Carsten Bormann\n   Universitaet\
    \ Bremen TZI\n   Postfach 330440\n   D-28334 Bremen, Germany\n   EMail: cabo@tzi.org\n\
    \   Mark Handley\n   Department of Computer Science\n   University College London\n\
    \   Gower Street\n   London\n   WC1E 6BT\n   UK\n   EMail: M.Handley@cs.ucl.ac.uk\n\
    \   Joe Macker\n   Naval Research Laboratory\n   Washington, DC, USA, 20375\n\
    \   EMail: macker@itd.nrl.navy.mil\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ IETF's procedures with respect to rights in IETF Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
