- title: __initial_text__
  contents:
  - "              A Simple Network Management Protocol (SNMP)\n                 \
    \          Table of Contents\n   1. Status of this Memo ...................................\
    \    2\n   2. Introduction ..........................................    2\n \
    \  3. The SNMP Architecture .................................    4\n   3.1 Goals\
    \ of the Architecture ............................    4\n   3.2 Elements of the\
    \ Architecture .........................    4\n   3.2.1 Scope of Management Information\
    \ ....................    5\n   3.2.2 Representation of Management Information\
    \ ...........    5\n   3.2.3 Operations Supported on Management Information .....\
    \    6\n   3.2.4 Form and Meaning of Protocol Exchanges .............    7\n \
    \  3.2.5 Definition of Administrative Relationships .........    7\n   3.2.6 Form\
    \ and Meaning of References to Managed Objects ..   11\n   3.2.6.1 Resolution\
    \ of Ambiguous MIB References ...........   11\n   3.2.6.2 Resolution of References\
    \ across MIB Versions......   11\n   3.2.6.3 Identification of Object Instances\
    \ ...............   11\n   3.2.6.3.1 ifTable Object Type Names ......................\
    \   12\n   3.2.6.3.2 atTable Object Type Names ......................   12\n \
    \  3.2.6.3.3 ipAddrTable Object Type Names ..................   13\n   3.2.6.3.4\
    \ ipRoutingTable Object Type Names ...............   13\n   3.2.6.3.5 tcpConnTable\
    \ Object Type Names .................   13\n   3.2.6.3.6 egpNeighTable Object\
    \ Type Names ................   14\n   4. Protocol Specification ................................\
    \   15\n   4.1 Elements of Procedure ................................   16\n \
    \  4.1.1 Common Constructs ..................................   18\n   4.1.2 The\
    \ GetRequest-PDU .................................   19\n   4.1.3 The GetNextRequest-PDU\
    \ .............................   20\n   4.1.3.1 Example of Table Traversal .......................\
    \   22\n   4.1.4 The GetResponse-PDU ................................   23\n \
    \  4.1.5 The SetRequest-PDU .................................   24\n   4.1.6 The\
    \ Trap-PDU .......................................   26\n   4.1.6.1 The coldStart\
    \ Trap ...............................   27\n   4.1.6.2 The warmStart Trap ...............................\
    \   27\n   4.1.6.3 The linkDown Trap ................................   27\n \
    \  4.1.6.4 The linkUp Trap ..................................   27\n   4.1.6.5\
    \ The authenticationFailure Trap ...................   27\n   4.1.6.6 The egpNeighborLoss\
    \ Trap .........................   27\n   4.1.6.7 The enterpriseSpecific Trap\
    \ ......................   28\n   5. Definitions ...........................................\
    \   29\n   6. Acknowledgements ......................................   32\n \
    \  7. References ............................................   33\n"
- title: 1.  Status of this Memo
  contents:
  - "1.  Status of this Memo\n   This RFC is a re-release of RFC 1067, with a changed\
    \ \"Status of this\n   Memo\" section.  This memo defines a simple protocol by\
    \ which\n   management information for a network element may be inspected or\n\
    \   altered by logically remote users.  In particular, together with its\n   companion\
    \ memos which describe the structure of management\n   information along with\
    \ the initial management information base, these\n   documents provide a simple,\
    \ workable architecture and system for\n   managing TCP/IP-based internets and\
    \ in particular the Internet.\n   The Internet Activities Board (IAB) has designated\
    \ two different\n   network management protocols with the same status of \"Draft\
    \ Standard\"\n   and \"Recommended\".\n   The two protocols are the Common Management\
    \ Information Services and\n   Protocol over TCP/IP (CMOT) [9], and the Simple\
    \ Network Management\n   Protocol (SNMP) (this memo).\n   The IAB intends each\
    \ of these two protocols to receive the attention\n   of implementers and experimenters.\
    \  The IAB seeks reports of\n   experience with these two protocols from system\
    \ builders and users.\n   By this action, the IAB recommends that all IP and TCP\n\
    \   implementations be network manageable (e.g., implement the Internet\n   MIB\
    \ [3]) and that the implementations that are network manageable are\n   expected\
    \ to adopt and implement at least one of these two Internet\n   Draft Standards.\n\
    \   Distribution of this memo is unlimited.\n"
- title: 2.  Introduction
  contents:
  - "2.  Introduction\n   As reported in RFC 1052, IAB Recommendations for the Development\
    \ of\n   Internet Network Management Standards [1], the Internet Activities\n\
    \   Board has directed the Internet Engineering Task Force (IETF) to\n   create\
    \ two new working groups in the area of network management.  One\n   group is\
    \ charged with the further specification and definition of\n   elements to be\
    \ included in the Management Information Base (MIB).\n   The other is charged\
    \ with defining the modifications to the Simple\n   Network Management Protocol\
    \ (SNMP) to accommodate the short-term\n   needs of the network vendor and operations\
    \ communities, and to align\n   with the output of the MIB working group.\n  \
    \ The MIB working group has produced two memos, one which defines a\n   Structure\
    \ for Management Information (SMI) [2] for use by the managed\n   objects contained\
    \ in the MIB.  A second memo [3] defines the list of\n   managed objects.\n  \
    \ The output of the SNMP Extensions working group is this memo, which\n   incorporates\
    \ changes to the initial SNMP definition [4] required to\n   attain alignment\
    \ with the output of the MIB working group.  The\n   changes should be minimal\
    \ in order to be consistent with the IAB's\n   directive that the working groups\
    \ be \"extremely sensitive to the need\n   to keep the SNMP simple.\"  Although\
    \ considerable care and debate has\n   gone into the changes to the SNMP which\
    \ are reflected in this memo,\n   the resulting protocol is not backwardly-compatible\
    \ with its\n   predecessor, the Simple Gateway Monitoring Protocol (SGMP) [5].\n\
    \   Although the syntax of the protocol has been altered, the original\n   philosophy,\
    \ design decisions, and architecture remain intact.  In\n   order to avoid confusion,\
    \ new UDP ports have been allocated for use\n   by the protocol described in this\
    \ memo.\n"
- title: 3.  The SNMP Architecture
  contents:
  - "3.  The SNMP Architecture\n   Implicit in the SNMP architectural model is a collection\
    \ of network\n   management stations and network elements.  Network management\n\
    \   stations execute management applications which monitor and control\n   network\
    \ elements.  Network elements are devices such as hosts,\n   gateways, terminal\
    \ servers, and the like, which have management\n   agents responsible for performing\
    \ the network management functions\n   requested by the network management stations.\
    \  The Simple Network\n   Management Protocol (SNMP) is used to communicate management\n\
    \   information between the network management stations and the agents in\n  \
    \ the network elements.\n"
- title: 3.1.  Goals of the Architecture
  contents:
  - "3.1.  Goals of the Architecture\n   The SNMP explicitly minimizes the number\
    \ and complexity of management\n   functions realized by the management agent\
    \ itself.  This goal is\n   attractive in at least four respects:\n      (1) \
    \ The development cost for management agent software\n           necessary to\
    \ support the protocol is accordingly reduced.\n      (2)  The degree of management\
    \ function that is remotely\n           supported is accordingly increased, thereby\
    \ admitting\n           fullest use of internet resources in the management task.\n\
    \      (3)  The degree of management function that is remotely\n           supported\
    \ is accordingly increased, thereby imposing the\n           fewest possible restrictions\
    \ on the form and\n           sophistication of management tools.\n      (4) \
    \ Simplified sets of management functions are easily\n           understood and\
    \ used by developers of network management\n           tools.\n   A second goal\
    \ of the protocol is that the functional paradigm for\n   monitoring and control\
    \ be sufficiently extensible to accommodate\n   additional, possibly unanticipated\
    \ aspects of network operation and\n   management.\n   A third goal is that the\
    \ architecture be, as much as possible,\n   independent of the architecture and\
    \ mechanisms of particular hosts or\n   particular gateways.\n"
- title: 3.2.  Elements of the Architecture
  contents:
  - "3.2.  Elements of the Architecture\n   The SNMP architecture articulates a solution\
    \ to the network\n   management problem in terms of:\n      (1)  the scope of\
    \ the management information communicated by\n           the protocol,\n     \
    \ (2)  the representation of the management information\n           communicated\
    \ by the protocol,\n      (3)  operations on management information supported\
    \ by the\n           protocol,\n      (4)  the form and meaning of exchanges among\
    \ management\n           entities,\n      (5)  the definition of administrative\
    \ relationships among\n           management entities, and\n      (6)  the form\
    \ and meaning of references to management\n           information.\n"
- title: 3.2.1.  Scope of Management Information
  contents:
  - "3.2.1.  Scope of Management Information\n   The scope of the management information\
    \ communicated by operation of\n   the SNMP is exactly that represented by instances\
    \ of all non-\n   aggregate object types either defined in Internet-standard MIB\
    \ or\n   defined elsewhere according to the conventions set forth in\n   Internet-standard\
    \ SMI [2].\n   Support for aggregate object types in the MIB is neither required\
    \ for\n   conformance with the SMI nor realized by the SNMP.\n"
- title: 3.2.2.  Representation of Management Information
  contents:
  - "3.2.2.  Representation of Management Information\n   Management information communicated\
    \ by operation of the SNMP is\n   represented according to the subset of the ASN.1\
    \ language [6] that is\n   specified for the definition of non-aggregate types\
    \ in the SMI.\n   The SGMP adopted the convention of using a well-defined subset\
    \ of the\n   ASN.1 language [6].  The SNMP continues and extends this tradition\
    \ by\n   utilizing a moderately more complex subset of ASN.1 for describing\n\
    \   managed objects and for describing the protocol data units used for\n   managing\
    \ those objects.  In addition, the desire to ease eventual\n   transition to OSI-based\
    \ network management protocols led to the\n   definition in the ASN.1 language\
    \ of an Internet-standard Structure of\n   Management Information (SMI) [2] and\
    \ Management Information Base\n   (MIB) [3].  The use of the ASN.1 language, was,\
    \ in part, encouraged\n   by the successful use of ASN.1 in earlier efforts, in\
    \ particular, the\n   SGMP.  The restrictions on the use of ASN.1 that are part\
    \ of the SMI\n   contribute to the simplicity espoused and validated by experience\n\
    \   with the SGMP.\n   Also for the sake of simplicity, the SNMP uses only a subset\
    \ of the\n   basic encoding rules of ASN.1 [7].  Namely, all encodings use the\n\
    \   definite-length form.  Further, whenever permissible, non-constructor\n  \
    \ encodings are used rather than constructor encodings.  This\n   restriction\
    \ applies to all aspects of ASN.1 encoding, both for the\n   top-level protocol\
    \ data units and the data objects they contain.\n"
- title: 3.2.3.  Operations Supported on Management Information
  contents:
  - "3.2.3.  Operations Supported on Management Information\n   The SNMP models all\
    \ management agent functions as alterations or\n   inspections of variables. \
    \ Thus, a protocol entity on a logically\n   remote host (possibly the network\
    \ element itself) interacts with the\n   management agent resident on the network\
    \ element in order to retrieve\n   (get) or alter (set) variables.  This strategy\
    \ has at least two\n   positive consequences:\n      (1)  It has the effect of\
    \ limiting the number of essential\n           management functions realized by\
    \ the management agent to\n           two: one operation to assign a value to\
    \ a specified\n           configuration or other parameter and another to retrieve\n\
    \           such a value.\n      (2)  A second effect of this decision is to avoid\
    \ introducing\n           into the protocol definition support for imperative\n\
    \           management commands:  the number of such commands is in\n        \
    \   practice ever-increasing, and the semantics of such\n           commands are\
    \ in general arbitrarily complex.\n   The strategy implicit in the SNMP is that\
    \ the monitoring of network\n   state at any significant level of detail is accomplished\
    \ primarily by\n   polling for appropriate information on the part of the monitoring\n\
    \   center(s).  A limited number of unsolicited messages (traps) guide\n   the\
    \ timing and focus of the polling.  Limiting the number of\n   unsolicited messages\
    \ is consistent with the goal of simplicity and\n   minimizing the amount of traffic\
    \ generated by the network management\n   function.\n   The exclusion of imperative\
    \ commands from the set of explicitly\n   supported management functions is unlikely\
    \ to preclude any desirable\n   management agent operation.  Currently, most commands\
    \ are requests\n   either to set the value of some parameter or to retrieve such\
    \ a\n   value, and the function of the few imperative commands currently\n   supported\
    \ is easily accommodated in an asynchronous mode by this\n   management model.\
    \  In this scheme, an imperative command might be\n   realized as the setting\
    \ of a parameter value that subsequently\n   triggers the desired action.  For\
    \ example, rather than implementing a\n   \"reboot command,\" this action might\
    \ be invoked by simply setting a\n   parameter indicating the number of seconds\
    \ until system reboot.\n"
- title: 3.2.4.  Form and Meaning of Protocol Exchanges
  contents:
  - "3.2.4.  Form and Meaning of Protocol Exchanges\n   The communication of management\
    \ information among management entities\n   is realized in the SNMP through the\
    \ exchange of protocol messages.\n   The form and meaning of those messages is\
    \ defined below in Section 4.\n   Consistent with the goal of minimizing complexity\
    \ of the management\n   agent, the exchange of SNMP messages requires only an\
    \ unreliable\n   datagram service, and every message is entirely and independently\n\
    \   represented by a single transport datagram.  While this document\n   specifies\
    \ the exchange of messages via the UDP protocol [8], the\n   mechanisms of the\
    \ SNMP are generally suitable for use with a wide\n   variety of transport services.\n"
- title: 3.2.5.  Definition of Administrative Relationships
  contents:
  - "3.2.5.  Definition of Administrative Relationships\n   The SNMP architecture\
    \ admits a variety of administrative\n   relationships among entities that participate\
    \ in the protocol.  The\n   entities residing at management stations and network\
    \ elements which\n   communicate with one another using the SNMP are termed SNMP\n\
    \   application entities.  The peer processes which implement the SNMP,\n   and\
    \ thus support the SNMP application entities, are termed protocol\n   entities.\n\
    \   A pairing of an SNMP agent with some arbitrary set of SNMP\n   application\
    \ entities is called an SNMP community.  Each SNMP\n   community is named by a\
    \ string of octets, that is called the\n   community name for said community.\n\
    \   An SNMP message originated by an SNMP application entity that in fact\n  \
    \ belongs to the SNMP community named by the community component of\n   said message\
    \ is called an authentic SNMP message.  The set of rules\n   by which an SNMP\
    \ message is identified as an authentic SNMP message\n   for a particular SNMP\
    \ community is called an authentication scheme.\n   An implementation of a function\
    \ that identifies authentic SNMP\n   messages according to one or more authentication\
    \ schemes is called an\n   authentication service.\n   Clearly, effective management\
    \ of administrative relationships among\n   SNMP application entities requires\
    \ authentication services that (by\n   the use of encryption or other techniques)\
    \ are able to identify\n   authentic SNMP messages with a high degree of certainty.\
    \  Some SNMP\n   implementations may wish to support only a trivial authentication\n\
    \   service that identifies all SNMP messages as authentic SNMP messages.\n  \
    \ For any network element, a subset of objects in the MIB that pertain\n   to\
    \ that element is called a SNMP MIB view.  Note that the names of\n   the object\
    \ types represented in a SNMP MIB view need not belong to a\n   single sub-tree\
    \ of the object type name space.\n   An element of the set { READ-ONLY, READ-WRITE\
    \ } is called an SNMP\n   access mode.\n   A pairing of a SNMP access mode with\
    \ a SNMP MIB view is called an\n   SNMP community profile.  A SNMP community profile\
    \ represents\n   specified access privileges to variables in a specified MIB view.\
    \ For\n   every variable in the MIB view in a given SNMP community profile,\n\
    \   access to that variable is represented by the profile according to\n   the\
    \ following conventions:\n      (1)  if said variable is defined in the MIB with\
    \ \"Access:\" of\n           \"none,\" it is unavailable as an operand for any\
    \ operator;\n      (2)  if said variable is defined in the MIB with \"Access:\"\
    \ of\n           \"read-write\" or \"write-only\" and the access mode of the\n\
    \           given profile is READ-WRITE, that variable is available\n        \
    \   as an operand for the get, set, and trap operations;\n      (3)  otherwise,\
    \ the variable is available as an operand for\n           the get and trap operations.\n\
    \      (4)  In those cases where a \"write-only\" variable is an\n           operand\
    \ used for the get or trap operations, the value\n           given for the variable\
    \ is implementation-specific.\n   A pairing of a SNMP community with a SNMP community\
    \ profile is called\n   a SNMP access policy. An access policy represents a specified\n\
    \   community profile afforded by the SNMP agent of a specified SNMP\n   community\
    \ to other members of that community.  All administrative\n   relationships among\
    \ SNMP application entities are architecturally\n   defined in terms of SNMP access\
    \ policies.\n   For every SNMP access policy, if the network element on which\
    \ the\n   SNMP agent for the specified SNMP community resides is not that to\n\
    \   which the MIB view for the specified profile pertains, then that\n   policy\
    \ is called a SNMP proxy access policy. The SNMP agent\n   associated with a proxy\
    \ access policy is called a SNMP proxy agent.\n   While careless definition of\
    \ proxy access policies can result in\n   management loops, prudent definition\
    \ of proxy policies is useful in\n   at least two ways:\n      (1)  It permits\
    \ the monitoring and control of network elements\n           which are otherwise\
    \ not addressable using the management\n           protocol and the transport\
    \ protocol.  That is, a proxy\n           agent may provide a protocol conversion\
    \ function allowing\n           a management station to apply a consistent management\n\
    \           framework to all network elements, including devices such\n      \
    \     as modems, multiplexors, and other devices which support\n           different\
    \ management frameworks.\n      (2)  It potentially shields network elements from\
    \ elaborate\n           access control policies.  For example, a proxy agent may\n\
    \           implement sophisticated access control whereby diverse\n         \
    \  subsets of variables within the MIB are made accessible\n           to different\
    \ management stations without increasing the\n           complexity of the network\
    \ element.\n   By way of example, Figure 1 illustrates the relationship between\n\
    \   management stations, proxy agents, and management agents.  In this\n   example,\
    \ the proxy agent is envisioned to be a normal Internet\n   Network Operations\
    \ Center (INOC) of some administrative domain which\n   has a standard managerial\
    \ relationship with a set of management\n   agents.\n   +------------------+ \
    \      +----------------+      +----------------+\n   |  Region #1 INOC  |   \
    \    |Region #2 INOC  |      |PC in Region #3 |\n   |                  |     \
    \  |                |      |                |\n   |Domain=Region #1  |       |Domain=Region\
    \ #2|      |Domain=Region #3|\n   |CPU=super-mini-1  |       |CPU=super-mini-1|\
    \      |CPU=Clone-1     |\n   |PCommunity=pub    |       |PCommunity=pub  |  \
    \    |PCommunity=slate|\n   |                  |       |                |    \
    \  |                |\n   +------------------+       +----------------+      +----------------+\n\
    \          /|\\                      /|\\                     /|\\\n         \
    \  |                        |                       |\n           |          \
    \              |                       |\n           |                       \\\
    |/                      |\n           |               +-----------------+    \
    \          |\n           +-------------->| Region #3 INOC  |<-------------+\n\
    \                           |                 |\n                           |Domain=Region\
    \ #3 |\n                           |CPU=super-mini-2 |\n                     \
    \      |PCommunity=pub,  |\n                           |         slate   |\n \
    \                          |DCommunity=secret|\n           +-------------->| \
    \                |<-------------+\n           |               +-----------------+\
    \              |\n           |                       /|\\                    \
    \  |\n           |                        |                       |\n        \
    \   |                        |                       |\n          \\|/       \
    \               \\|/                     \\|/\n   +-----------------+     +-----------------+\
    \       +-----------------+\n   |Domain=Region#3  |     |Domain=Region#3  |  \
    \     |Domain=Region#3  |\n   |CPU=router-1     |     |CPU=mainframe-1  |    \
    \   |CPU=modem-1      |\n   |DCommunity=secret|     |DCommunity=secret|      \
    \ |DCommunity=secret|\n   +-----------------+     +-----------------+       +-----------------+\n\
    \   Domain:  the administrative domain of the element\n   PCommunity:  the name\
    \ of a community utilizing a proxy agent\n   DCommunity:  the name of a direct\
    \ community\n                                 Figure 1\n                 Example\
    \ Network Management Configuration\n"
- title: 3.2.6.  Form and Meaning of References to Managed Objects
  contents:
  - "3.2.6.  Form and Meaning of References to Managed Objects\n   The SMI requires\
    \ that the definition of a conformant management\n   protocol address:\n     \
    \ (1)  the resolution of ambiguous MIB references,\n      (2)  the resolution\
    \ of MIB references in the presence multiple\n           MIB versions, and\n \
    \     (3)  the identification of particular instances of object\n           types\
    \ defined in the MIB.\n"
- title: 3.2.6.1.  Resolution of Ambiguous MIB References
  contents:
  - "3.2.6.1.  Resolution of Ambiguous MIB References\n   Because the scope of any\
    \ SNMP operation is conceptually confined to\n   objects relevant to a single\
    \ network element, and because all SNMP\n   references to MIB objects are (implicitly\
    \ or explicitly) by unique\n   variable names, there is no possibility that any\
    \ SNMP reference to\n   any object type defined in the MIB could resolve to multiple\n\
    \   instances of that type.\n"
- title: 3.2.6.2.  Resolution of References across MIB Versions
  contents:
  - "3.2.6.2.  Resolution of References across MIB Versions\n   The object instance\
    \ referred to by any SNMP operation is exactly that\n   specified as part of the\
    \ operation request or (in the case of a get-\n   next operation) its immediate\
    \ successor in the MIB as a whole.  In\n   particular, a reference to an object\
    \ as part of some version of the\n   Internet-standard MIB does not resolve to\
    \ any object that is not part\n   of said version of the Internet-standard MIB,\
    \ except in the case that\n   the requested operation is get-next and the specified\
    \ object name is\n   lexicographically last among the names of all objects presented\
    \ as\n   part of said version of the Internet-Standard MIB.\n"
- title: 3.2.6.3.  Identification of Object Instances
  contents:
  - "3.2.6.3.  Identification of Object Instances\n   The names for all object types\
    \ in the MIB are defined explicitly\n   either in the Internet-standard MIB or\
    \ in other documents which\n   conform to the naming conventions of the SMI. \
    \ The SMI requires that\n   conformant management protocols define mechanisms\
    \ for identifying\n   individual instances of those object types for a particular\
    \ network\n   element.\n   Each instance of any object type defined in the MIB\
    \ is identified in\n   SNMP operations by a unique name called its \"variable\
    \ name.\" In\n   general, the name of an SNMP variable is an OBJECT IDENTIFIER\
    \ of the\n   form x.y, where x is the name of a non-aggregate object type defined\n\
    \   in the MIB and y is an OBJECT IDENTIFIER fragment that, in a way\n   specific\
    \ to the named object type, identifies the desired instance.\n   This naming strategy\
    \ admits the fullest exploitation of the semantics\n   of the GetNextRequest-PDU\
    \ (see Section 4), because it assigns names\n   for related variables so as to\
    \ be contiguous in the lexicographical\n   ordering of all variable names known\
    \ in the MIB.\n   The type-specific naming of object instances is defined below\
    \ for a\n   number of classes of object types.  Instances of an object type to\n\
    \   which none of the following naming conventions are applicable are\n   named\
    \ by OBJECT IDENTIFIERs of the form x.0, where x is the name of\n   said object\
    \ type in the MIB definition.\n   For example, suppose one wanted to identify\
    \ an instance of the\n   variable sysDescr The object class for sysDescr is:\n\
    \             iso org dod internet mgmt mib system sysDescr\n              1 \
    \  3   6     1      2    1    1       1\n   Hence, the object type, x, would be\
    \ 1.3.6.1.2.1.1.1 to which is\n   appended an instance sub-identifier of 0.  That\
    \ is, 1.3.6.1.2.1.1.1.0\n   identifies the one and only instance of sysDescr.\n"
- title: 3.2.6.3.1.  ifTable Object Type Names
  contents:
  - "3.2.6.3.1.  ifTable Object Type Names\n   The name of a subnet interface, s,\
    \ is the OBJECT IDENTIFIER value of\n   the form i, where i has the value of that\
    \ instance of the ifIndex\n   object type associated with s.\n   For each object\
    \ type, t, for which the defined name, n, has a prefix\n   of ifEntry, an instance,\
    \ i, of t is named by an OBJECT IDENTIFIER of\n   the form n.s, where s is the\
    \ name of the subnet interface about which\n   i represents information.\n   For\
    \ example, suppose one wanted to identify the instance of the\n   variable ifType\
    \ associated with interface 2.  Accordingly, ifType.2\n   would identify the desired\
    \ instance.\n"
- title: 3.2.6.3.2.  atTable Object Type Names
  contents:
  - "3.2.6.3.2.  atTable Object Type Names\n   The name of an AT-cached network address,\
    \ x, is an OBJECT IDENTIFIER\n   of the form 1.a.b.c.d, where a.b.c.d is the value\
    \ (in the familiar\n   \"dot\" notation) of the atNetAddress object type associated\
    \ with x.\n   The name of an address translation equivalence e is an OBJECT\n\
    \   IDENTIFIER value of the form s.w, such that s is the value of that\n   instance\
    \ of the atIndex object type associated with e and such that w\n   is the name\
    \ of the AT-cached network address associated with e.\n   For each object type,\
    \ t, for which the defined name, n, has a prefix\n   of atEntry, an instance,\
    \ i, of t is named by an OBJECT IDENTIFIER of\n   the form n.y, where y is the\
    \ name of the address translation\n   equivalence about which i represents information.\n\
    \   For example, suppose one wanted to find the physical address of an\n   entry\
    \ in the address translation table (ARP cache) associated with an\n   IP address\
    \ of 89.1.1.42 and interface 3.  Accordingly,\n   atPhysAddress.3.1.89.1.1.42\
    \ would identify the desired instance.\n"
- title: 3.2.6.3.3.  ipAddrTable Object Type Names
  contents:
  - "3.2.6.3.3.  ipAddrTable Object Type Names\n   The name of an IP-addressable network\
    \ element, x, is the OBJECT\n   IDENTIFIER of the form a.b.c.d such that a.b.c.d\
    \ is the value (in the\n   familiar \"dot\" notation) of that instance of the\
    \ ipAdEntAddr object\n   type associated with x.\n   For each object type, t,\
    \ for which the defined name, n, has a prefix\n   of ipAddrEntry, an instance,\
    \ i, of t is named by an OBJECT IDENTIFIER\n   of the form n.y, where y is the\
    \ name of the IP-addressable network\n   element about which i represents information.\n\
    \   For example, suppose one wanted to find the network mask of an entry\n   in\
    \ the IP interface table associated with an IP address of 89.1.1.42.\n   Accordingly,\
    \ ipAdEntNetMask.89.1.1.42 would identify the desired\n   instance.\n"
- title: 3.2.6.3.4.  ipRoutingTable Object Type Names
  contents:
  - "3.2.6.3.4.  ipRoutingTable Object Type Names\n   The name of an IP route, x,\
    \ is the OBJECT IDENTIFIER of the form\n   a.b.c.d such that a.b.c.d is the value\
    \ (in the familiar \"dot\"\n   notation) of that instance of the ipRouteDest object\
    \ type associated\n   with x.\n   For each object type, t, for which the defined\
    \ name, n, has a prefix\n   of ipRoutingEntry, an instance, i, of t is named by\
    \ an OBJECT\n   IDENTIFIER of the form n.y, where y is the name of the IP route\
    \ about\n   which i represents information.\n   For example, suppose one wanted\
    \ to find the next hop of an entry in\n   the IP routing table associated  with\
    \ the destination of 89.1.1.42.\n   Accordingly, ipRouteNextHop.89.1.1.42 would\
    \ identify the desired\n   instance.\n"
- title: 3.2.6.3.5.  tcpConnTable Object Type Names
  contents:
  - "3.2.6.3.5.  tcpConnTable Object Type Names\n   The name of a TCP connection,\
    \ x, is the OBJECT IDENTIFIER of the form\n   a.b.c.d.e.f.g.h.i.j such that a.b.c.d\
    \ is the value (in the familiar\n   \"dot\" notation) of that instance of the\
    \ tcpConnLocalAddress object\n   type associated with x and such that f.g.h.i\
    \ is the value (in the\n   familiar \"dot\" notation) of that instance of the\
    \ tcpConnRemoteAddress\n   object type associated with x and such that e is the\
    \ value of that\n   instance of the tcpConnLocalPort object type associated with\
    \ x and\n   such that j is the value of that instance of the tcpConnRemotePort\n\
    \   object type associated with x.\n   For each object type, t, for which the\
    \ defined name, n, has a prefix\n   of  tcpConnEntry, an instance, i, of t is\
    \ named by an OBJECT\n   IDENTIFIER of the form n.y, where y is the name of the\
    \ TCP connection\n   about which i represents information.\n   For example, suppose\
    \ one wanted to find the state of a TCP connection\n   between the local address\
    \ of 89.1.1.42 on TCP port 21 and the remote\n   address of 10.0.0.51 on TCP port\
    \ 2059.  Accordingly,\n   tcpConnState.89.1.1.42.21.10.0.0.51.2059 would identify\
    \ the desired\n   instance.\n"
- title: 3.2.6.3.6.  egpNeighTable Object Type Names
  contents:
  - "3.2.6.3.6.  egpNeighTable Object Type Names\n   The name of an EGP neighbor,\
    \ x, is the OBJECT IDENTIFIER of the form\n   a.b.c.d such that a.b.c.d is the\
    \ value (in the familiar \"dot\"\n   notation) of that instance of the egpNeighAddr\
    \ object type associated\n   with x.\n   For each object type, t, for which the\
    \ defined name, n, has a prefix\n   of egpNeighEntry, an instance, i, of t is\
    \ named by an OBJECT\n   IDENTIFIER of the form n.y, where y is the name of the\
    \ EGP neighbor\n   about which i represents information.\n   For example, suppose\
    \ one wanted to find the neighbor state for the IP\n   address of 89.1.1.42. \
    \ Accordingly, egpNeighState.89.1.1.42 would\n   identify the desired instance.\n"
- title: 4.  Protocol Specification
  contents:
  - "4.  Protocol Specification\n   The network management protocol is an application\
    \ protocol by which\n   the variables of an agent's MIB may be inspected or altered.\n\
    \   Communication among protocol entities is accomplished by the exchange\n  \
    \ of messages, each of which is entirely and independently represented\n   within\
    \ a single UDP datagram using the basic encoding rules of ASN.1\n   (as discussed\
    \ in Section 3.2.2).  A message consists of a version\n   identifier, an SNMP\
    \ community name, and a protocol data unit (PDU).\n   A protocol entity receives\
    \ messages at UDP port 161 on the host with\n   which it is associated for all\
    \ messages except for those which report\n   traps (i.e., all messages except\
    \ those which contain the Trap-PDU).\n   Messages which report traps should be\
    \ received on UDP port 162 for\n   further processing.  An implementation of this\
    \ protocol need not\n   accept messages whose length exceeds 484 octets.  However,\
    \ it is\n   recommended that implementations support larger datagrams whenever\n\
    \   feasible.\n   It is mandatory that all implementations of the SNMP support\
    \ the five\n   PDUs: GetRequest-PDU, GetNextRequest-PDU, GetResponse-PDU,\n  \
    \ SetRequest-PDU, and Trap-PDU.\n    RFC1098-SNMP DEFINITIONS ::= BEGIN\n    \
    \ IMPORTS\n          ObjectName, ObjectSyntax, NetworkAddress, IpAddress, TimeTicks\n\
    \                  FROM RFC1065-SMI;\n     -- top-level message\n            \
    \ Message ::=\n                     SEQUENCE {\n                          version\
    \        -- version-1 for this RFC\n                             INTEGER {\n \
    \                                version-1(0)\n                             },\n\
    \                         community      -- community name\n                 \
    \            OCTET STRING,\n                         data           -- e.g., PDUs\
    \ if trivial\n                             ANY        -- authentication is being\
    \ used\n                     }\n     -- protocol data units\n             PDUs\
    \ ::=\n                     CHOICE {\n                         get-request\n \
    \                            GetRequest-PDU,\n                         get-next-request\n\
    \                             GetNextRequest-PDU,\n                         get-response\n\
    \                             GetResponse-PDU,\n                         set-request\n\
    \                             SetRequest-PDU,\n                         trap\n\
    \                             Trap-PDU\n                          }\n     -- the\
    \ individual PDUs and commonly used\n     -- data types will be defined later\n\
    \     END\n"
- title: 4.1.  Elements of Procedure
  contents:
  - "4.1.  Elements of Procedure\n   This section describes the actions of a protocol\
    \ entity implementing\n   the SNMP. Note, however, that it is not intended to\
    \ constrain the\n   internal architecture of any conformant implementation.\n\
    \   In the text that follows, the term transport address is used.  In the\n  \
    \ case of the UDP, a transport address consists of an IP address along\n   with\
    \ a UDP port.  Other transport services may be used to support the\n   SNMP. \
    \ In these cases, the definition of a transport address should\n   be made accordingly.\n\
    \   The top-level actions of a protocol entity which generates a message\n   are\
    \ as follows:\n        (1)  It first constructs the appropriate PDU, e.g., the\n\
    \             GetRequest-PDU, as an ASN.1 object.\n        (2)  It then passes\
    \ this ASN.1 object along with a community\n             name its source transport\
    \ address and the destination\n             transport address, to the service\
    \ which implements the\n             desired authentication scheme.  This authentication\n\
    \             service returns another ASN.1 object.\n        (3)  The protocol\
    \ entity then constructs an ASN.1 Message\n             object, using the community\
    \ name and the resulting ASN.1\n             object.\n        (4)  This new ASN.1\
    \ object is then serialized, using the basic\n             encoding rules of ASN.1,\
    \ and then sent using a transport\n             service to the peer protocol entity.\n\
    \   Similarly, the top-level actions of a protocol entity which receives\n   a\
    \ message are as follows:\n        (1)  It performs a rudimentary parse of the\
    \ incoming datagram\n             to build an ASN.1 object corresponding to an\
    \ ASN.1\n             Message object. If the parse fails, it discards the\n  \
    \           datagram and performs no further actions.\n        (2)  It then verifies\
    \ the version number of the SNMP message.\n             If there is a mismatch,\
    \ it discards the datagram and\n             performs no further actions.\n  \
    \      (3)  The protocol entity then passes the community name and\n         \
    \    user data found in the ASN.1 Message object, along with\n             the\
    \ datagram's source and destination transport addresses\n             to the service\
    \ which implements the desired\n             authentication scheme.  This entity\
    \ returns another ASN.1\n             object, or signals an authentication failure.\
    \  In the\n             latter case, the protocol entity notes this failure,\n\
    \             (possibly) generates a trap, and discards the datagram\n       \
    \      and performs no further actions.\n        (4)  The protocol entity then\
    \ performs a rudimentary parse on\n             the ASN.1 object returned from\
    \ the authentication service\n             to build an ASN.1 object corresponding\
    \ to an ASN.1 PDUs\n             object.  If the parse fails, it discards the\
    \ datagram and\n             performs no further actions.  Otherwise, using the\
    \ named\n             SNMP community, the appropriate profile is selected, and\n\
    \             the PDU is processed accordingly.  If, as a result of\n        \
    \     this processing, a message is returned then the source\n             transport\
    \ address that the response message is sent from\n             shall be identical\
    \ to the destination transport address\n             that the original request\
    \ message was sent to.\n"
- title: 4.1.1.  Common Constructs
  contents:
  - "4.1.1.  Common Constructs\n   Before introducing the six PDU types of the protocol,\
    \ it is\n   appropriate to consider some of the ASN.1 constructs used frequently:\n\
    \                  -- request/response information\n                  RequestID\
    \ ::=\n                          INTEGER\n                  ErrorStatus ::=\n\
    \                          INTEGER {\n                              noError(0),\n\
    \                              tooBig(1),\n                              noSuchName(2),\n\
    \                              badValue(3),\n                              readOnly(4)\n\
    \                              genErr(5)\n                          }\n      \
    \            ErrorIndex ::=\n                          INTEGER\n             \
    \     -- variable bindings\n                  VarBind ::=\n                  \
    \        SEQUENCE {\n                              name\n                    \
    \              ObjectName,\n                              value\n            \
    \                      ObjectSyntax\n                          }\n           \
    \       VarBindList ::=\n                          SEQUENCE OF\n             \
    \                 VarBind\n   RequestIDs are used to distinguish among outstanding\
    \ requests.  By\n   use of the RequestID, an SNMP application entity can correlate\n\
    \   incoming responses with outstanding requests.  In cases where an\n   unreliable\
    \ datagram service is being used, the RequestID also\n   provides a simple means\
    \ of identifying messages duplicated by the\n   network.\n   A non-zero instance\
    \ of ErrorStatus is used to indicate that an\n   exception occurred while processing\
    \ a request.  In these cases,\n   ErrorIndex may provide additional information\
    \ by indicating which\n   variable in a list caused the exception.\n   The term\
    \ variable refers to an instance of a managed object.  A\n   variable binding,\
    \ or VarBind, refers to the pairing of the name of a\n   variable to the variable's\
    \ value.  A VarBindList is a simple list of\n   variable names and corresponding\
    \ values.  Some PDUs are concerned\n   only with the name of a variable and not\
    \ its value (e.g., the\n   GetRequest-PDU).  In this case, the value portion of\
    \ the binding is\n   ignored by the protocol entity.  However, the value portion\
    \ must\n   still have valid ASN.1 syntax and encoding.  It is recommended that\n\
    \   the ASN.1 value NULL be used for the value portion of such bindings.\n"
- title: 4.1.2.  The GetRequest-PDU
  contents:
  - "4.1.2.  The GetRequest-PDU\n             The form of the GetRequest-PDU is:\n\
    \                  GetRequest-PDU ::=\n                      [0]\n           \
    \               IMPLICIT SEQUENCE {\n                              request-id\n\
    \                                  RequestID,\n                              error-status\
    \        -- always 0\n                                  ErrorStatus,\n       \
    \                       error-index         -- always 0\n                    \
    \              ErrorIndex,\n                              variable-bindings\n\
    \                                  VarBindList\n                          }\n\
    \   The GetRequest-PDU is generated by a protocol entity only at the\n   request\
    \ of its SNMP application entity.\n   Upon receipt of the GetRequest-PDU, the\
    \ receiving protocol entity\n   responds according to any applicable rule in the\
    \ list below:\n        (1)  If, for any object named in the variable-bindings\
    \ field,\n             the object's name does not exactly match the name of some\n\
    \             object available for get operations in the relevant MIB\n      \
    \       view, then the receiving entity sends to the originator\n            \
    \ of the received message the GetResponse-PDU of identical\n             form,\
    \ except that the value of the error-status field is\n             noSuchName,\
    \ and the value of the error-index field is the\n             index of said object\
    \ name component in the received\n             message.\n        (2)  If, for\
    \ any object named in the variable-bindings field,\n             the object is\
    \ an aggregate type (as defined in the SMI),\n             then the receiving\
    \ entity sends to the originator of the\n             received message the GetResponse-PDU\
    \ of identical form,\n             except that the value of the error-status field\
    \ is\n             noSuchName, and the value of the error-index field is the\n\
    \             index of said object name component in the received\n          \
    \   message.\n        (3)  If the size of the GetResponse-PDU generated as described\n\
    \             below would exceed a local limitation, then the receiving\n    \
    \         entity sends to the originator of the received message\n           \
    \  the GetResponse-PDU of identical form, except that the\n             value\
    \ of the error-status field is tooBig, and the value\n             of the error-index\
    \ field is zero.\n        (4)  If, for any object named in the variable-bindings\
    \ field,\n             the value of the object cannot be retrieved for reasons\n\
    \             not covered by any of the foregoing rules, then the\n          \
    \   receiving entity sends to the originator of the received\n             message\
    \ the GetResponse-PDU of identical form, except\n             that the value of\
    \ the error-status field is genErr and\n             the value of the error-index\
    \ field is the index of said\n             object name component in the received\
    \ message.\n   If none of the foregoing rules apply, then the receiving protocol\n\
    \   entity sends to the originator of the received message the\n   GetResponse-PDU\
    \ such that, for each object named in the variable-\n   bindings field of the\
    \ received message, the corresponding component\n   of the GetResponse-PDU represents\
    \ the name and value of that\n   variable.  The value of the error- status field\
    \ of the GetResponse-\n   PDU is noError and the value of the error-index field\
    \ is zero.  The\n   value of the request-id field of the GetResponse-PDU is that\
    \ of the\n   received message.\n"
- title: 4.1.3.  The GetNextRequest-PDU
  contents:
  - "4.1.3.  The GetNextRequest-PDU\n   The form of the GetNextRequest-PDU is identical\
    \ to that of the\n   GetRequest-PDU except for the indication of the PDU type.\
    \  In the\n   ASN.1 language:\n                  GetNextRequest-PDU ::=\n    \
    \                  [1]\n                          IMPLICIT SEQUENCE {\n      \
    \                        request-id\n                                  RequestID,\n\
    \                              error-status        -- always 0\n             \
    \                     ErrorStatus,\n                              error-index\
    \         -- always 0\n                                  ErrorIndex,\n       \
    \                       variable-bindings\n                                  VarBindList\n\
    \                          }\n   The GetNextRequest-PDU is generated by a protocol\
    \ entity only at the\n   request of its SNMP application entity.\n   Upon receipt\
    \ of the GetNextRequest-PDU, the receiving protocol entity\n   responds according\
    \ to any applicable rule in the list below:\n        (1)  If, for any object name\
    \ in the variable-bindings field,\n             that name does not lexicographically\
    \ precede the name of\n             some object available for get operations in\
    \ the relevant\n             MIB view, then the receiving entity sends to the\n\
    \             originator of the received message the GetResponse-PDU of\n    \
    \         identical form, except that the value of the error-status\n        \
    \     field is noSuchName, and the value of the error-index\n             field\
    \ is the index of said object name component in the\n             received message.\n\
    \        (2)  If the size of the GetResponse-PDU generated as described\n    \
    \         below would exceed a local limitation, then the receiving\n        \
    \     entity sends to the originator of the received message\n             the\
    \ GetResponse-PDU of identical form, except that the\n             value of the\
    \ error-status field is tooBig, and the value\n             of the error-index\
    \ field is zero.\n        (3)  If, for any object named in the variable-bindings\
    \ field,\n             the value of the lexicographical successor to the named\n\
    \             object cannot be retrieved for reasons not covered by any\n    \
    \         of the foregoing rules, then the receiving entity sends\n          \
    \   to the originator of the received message the\n             GetResponse-PDU\
    \ of identical form, except that the value\n             of the error-status field\
    \ is genErr and the value of the\n             error-index field is the index\
    \ of said object name\n             component in the received message.\n   If\
    \ none of the foregoing rules apply, then the receiving protocol\n   entity sends\
    \ to the originator of the received message the\n   GetResponse-PDU such that,\
    \ for each name in the variable-bindings\n   field of the received message, the\
    \ corresponding component of the\n   GetResponse-PDU represents the name and value\
    \ of that object whose\n   name is, in the lexicographical ordering of the names\
    \ of all objects\n   available for get operations in the relevant MIB view, together\
    \ with\n   the value of the name field of the given component, the immediate\n\
    \   successor to that value.  The value of the error-status field of the\n   GetResponse-PDU\
    \ is noError and the value of the errorindex field is\n   zero.  The value of\
    \ the request-id field of the GetResponse-PDU is\n   that of the received message.\n"
- title: 4.1.3.1.  Example of Table Traversal
  contents:
  - "4.1.3.1.  Example of Table Traversal\n   One important use of the GetNextRequest-PDU\
    \ is the traversal of\n   conceptual tables of information within the MIB. The\
    \ semantics of\n   this type of SNMP message, together with the protocol-specific\n\
    \   mechanisms for identifying individual instances of object types in\n   the\
    \ MIB, affords  access to related objects in the MIB as if they\n   enjoyed a\
    \ tabular organization.\n   By the SNMP exchange sketched below, an SNMP application\
    \ entity might\n   extract the destination address and next hop gateway for each\
    \ entry\n   in the routing table of a particular network element. Suppose that\n\
    \   this routing table has three entries:\n         Destination              \
    \       NextHop         Metric\n         10.0.0.99                       89.1.1.42\
    \       5\n         9.1.2.3                         99.0.0.3        3\n      \
    \   10.0.0.51                       89.1.1.42       5\n   The management station\
    \ sends to the SNMP agent a GetNextRequest-PDU\n   containing the indicated OBJECT\
    \ IDENTIFIER values as the requested\n   variable names:\n   GetNextRequest (\
    \ ipRouteDest, ipRouteNextHop, ipRouteMetric1 )\n   The SNMP agent responds with\
    \ a GetResponse-PDU:\n                 GetResponse (( ipRouteDest.9.1.2.3 =  \"\
    9.1.2.3\" ),\n                         ( ipRouteNextHop.9.1.2.3 = \"99.0.0.3\"\
    \ ),\n                         ( ipRouteMetric1.9.1.2.3 = 3 ))\n   The management\
    \ station continues with:\n                 GetNextRequest ( ipRouteDest.9.1.2.3,\n\
    \                         ipRouteNextHop.9.1.2.3,\n                         ipRouteMetric1.9.1.2.3\
    \ )\n   The SNMP agent responds:\n                 GetResponse (( ipRouteDest.10.0.0.51\
    \ = \"10.0.0.51\" ),\n                         ( ipRouteNextHop.10.0.0.51 = \"\
    89.1.1.42\" ),\n                         ( ipRouteMetric1.10.0.0.51 = 5 ))\n \
    \  The management station continues with:\n                 GetNextRequest ( ipRouteDest.10.0.0.51,\n\
    \                         ipRouteNextHop.10.0.0.51,\n                        \
    \ ipRouteMetric1.10.0.0.51 )\n   The SNMP agent responds:\n                 GetResponse\
    \ (( ipRouteDest.10.0.0.99 = \"10.0.0.99\" ),\n                         ( ipRouteNextHop.10.0.0.99\
    \ = \"89.1.1.42\" ),\n                         ( ipRouteMetric1.10.0.0.99 = 5\
    \ ))\n   The management station continues with:\n                 GetNextRequest\
    \ ( ipRouteDest.10.0.0.99,\n                         ipRouteNextHop.10.0.0.99,\n\
    \                         ipRouteMetric1.10.0.0.99 )\n   As there are no further\
    \ entries in the table, the SNMP agent returns\n   those objects that are next\
    \ in the lexicographical ordering of the\n   known object names.  This response\
    \ signals the end of the routing\n   table to the management station.\n"
- title: 4.1.4.  The GetResponse-PDU
  contents:
  - "4.1.4.  The GetResponse-PDU\n   The form of the GetResponse-PDU is identical\
    \ to that of the\n   GetRequest-PDU except for the indication of the PDU type.\
    \  In the\n   ASN.1 language:\n                  GetResponse-PDU ::=\n       \
    \               [2]\n                          IMPLICIT SEQUENCE {\n         \
    \                     request-id\n                                  RequestID,\n\
    \                              error-status\n                                \
    \  ErrorStatus,\n                              error-index\n                 \
    \                 ErrorIndex,\n                              variable-bindings\n\
    \                                  VarBindList\n                          }\n\
    \   The GetResponse-PDU is generated by a protocol entity only upon\n   receipt\
    \ of the GetRequest-PDU, GetNextRequest-PDU, or SetRequest-PDU,\n   as described\
    \ elsewhere in this document.\n   Upon receipt of the GetResponse-PDU, the receiving\
    \ protocol entity\n   presents its contents to its SNMP application entity.\n"
- title: 4.1.5.  The SetRequest-PDU
  contents:
  - "4.1.5.  The SetRequest-PDU\n   The form of the SetRequest-PDU is identical to\
    \ that of the\n   GetRequest-PDU except for the indication of the PDU type.  In\
    \ the\n   ASN.1 language:\n                  SetRequest-PDU ::=\n            \
    \          [3]\n                          IMPLICIT SEQUENCE {\n              \
    \                request-id\n                                  RequestID,\n  \
    \                            error-status        -- always 0\n               \
    \                   ErrorStatus,\n                              error-index  \
    \       -- always 0\n                                  ErrorIndex,\n         \
    \                     variable-bindings\n                                  VarBindList\n\
    \                          }\n   The SetRequest-PDU is generated by a protocol\
    \ entity only at the\n   request of its SNMP application entity.\n   Upon receipt\
    \ of the SetRequest-PDU, the receiving entity responds\n   according to any applicable\
    \ rule in the list below:\n        (1)  If, for any object named in the variable-bindings\
    \ field,\n             the object is not available for set operations in the\n\
    \             relevant MIB view, then the receiving entity sends to the\n    \
    \         originator of the received message the GetResponse-PDU of\n        \
    \     identical form, except that the value of the error-status\n            \
    \ field is noSuchName, and the value of the error-index\n             field is\
    \ the index of said object name component in the\n             received message.\n\
    \        (2)  If, for any object named in the variable-bindings field,\n     \
    \        the contents of the value field does not, according to\n            \
    \ the ASN.1 language, manifest a type, length, and value\n             that is\
    \ consistent with that required for the variable,\n             then the receiving\
    \ entity sends to the originator of the\n             received message the GetResponse-PDU\
    \ of identical form,\n             except that the value of the error-status field\
    \ is\n             badValue, and the value of the error-index field is the\n \
    \            index of said object name in the received message.\n        (3) \
    \ If the size of the Get Response type message generated as\n             described\
    \ below would exceed a local limitation, then the\n             receiving entity\
    \ sends to the originator of the received\n             message the GetResponse-PDU\
    \ of identical form, except\n             that the value of the error-status field\
    \ is tooBig, and\n             the value of the error-index field is zero.\n \
    \       (4)  If, for any object named in the variable-bindings field,\n      \
    \       the value of the named object cannot be altered for\n             reasons\
    \ not covered by any of the foregoing rules, then\n             the receiving\
    \ entity sends to the originator of the\n             received message the GetResponse-PDU\
    \ of identical form,\n             except that the value of the error-status field\
    \ is genErr\n             and the value of the error-index field is the index\
    \ of\n             said object name component in the received message.\n   If\
    \ none of the foregoing rules apply, then for each object named in\n   the variable-bindings\
    \ field of the received message, the\n   corresponding value is assigned to the\
    \ variable.  Each variable\n   assignment specified by the SetRequest-PDU should\
    \ be effected as if\n   simultaneously set with respect to all other assignments\
    \ specified in\n   the same message.\n   The receiving entity then sends to the\
    \ originator of the received\n   message the GetResponse-PDU of identical form\
    \ except that the value\n   of the error-status field of the generated message\
    \ is noError and the\n   value of the error-index field is zero.\n"
- title: 4.1.6.  The Trap-PDU
  contents:
  - "4.1.6.  The Trap-PDU\n   The form of the Trap-PDU is:\n     Trap-PDU ::=\n  \
    \       [4]\n              IMPLICIT SEQUENCE {\n                 enterprise  \
    \        -- type of object generating\n                                     --\
    \ trap, see sysObjectID in [2]\n                     OBJECT IDENTIFIER,\n    \
    \             agent-addr          -- address of object generating\n          \
    \           NetworkAddress, -- trap\n                 generic-trap        -- generic\
    \ trap type\n                     INTEGER {\n                         coldStart(0),\n\
    \                         warmStart(1),\n                         linkDown(2),\n\
    \                         linkUp(3),\n                         authenticationFailure(4),\n\
    \                         egpNeighborLoss(5),\n                         enterpriseSpecific(6)\n\
    \                     },\n                 specific-trap     -- specific code,\
    \ present even\n                     INTEGER,      -- if generic-trap is not\n\
    \                                   -- enterpriseSpecific\n                 time-stamp\
    \        -- time elapsed between the last\n                   TimeTicks,     \
    \ -- (re)initialization of the network\n                                   --\
    \ entity and the generation of the\n                                      trap\n\
    \                 variable-bindings   -- \"interesting\" information\n       \
    \               VarBindList\n             }\n   The Trap-PDU is generated by a\
    \ protocol entity only at the request of\n   the SNMP application entity.  The\
    \ means by which an SNMP application\n   entity selects the destination addresses\
    \ of the SNMP application\n   entities is implementation-specific.\n   Upon receipt\
    \ of the Trap-PDU, the receiving protocol entity presents\n   its contents to\
    \ its SNMP application entity.\n   The significance of the variable-bindings component\
    \ of the Trap-PDU\n   is implementation-specific.\n   Interpretations of the value\
    \ of the generic-trap field are:\n"
- title: 4.1.6.1.  The coldStart Trap
  contents:
  - "4.1.6.1.  The coldStart Trap\n   A coldStart(0) trap signifies that the sending\
    \ protocol entity is\n   reinitializing itself such that the agent's configuration\
    \ or the\n   protocol entity implementation may be altered.\n"
- title: 4.1.6.2.  The warmStart Trap
  contents:
  - "4.1.6.2.  The warmStart Trap\n   A warmStart(1) trap signifies that the sending\
    \ protocol entity is\n   reinitializing itself such that neither the agent configuration\
    \ nor\n   the protocol entity implementation is altered.\n"
- title: 4.1.6.3.  The linkDown Trap
  contents:
  - "4.1.6.3.  The linkDown Trap\n   A linkDown(2) trap signifies that the sending\
    \ protocol entity\n   recognizes a failure in one of the communication links represented\
    \ in\n   the agent's configuration.\n   The Trap-PDU of type linkDown contains\
    \ as the first element of its\n   variable-bindings, the name and value of the\
    \ ifIndex instance for the\n   affected interface.\n"
- title: 4.1.6.4.  The linkUp Trap
  contents:
  - "4.1.6.4.  The linkUp Trap\n   A linkUp(3) trap signifies that the sending protocol\
    \ entity\n   recognizes that one of the communication links represented in the\n\
    \   agent's configuration has come up.\n   The Trap-PDU of type linkUp contains\
    \ as the first element of its\n   variable-bindings, the name and value of the\
    \ ifIndex instance for the\n   affected interface.\n"
- title: 4.1.6.5.  The authenticationFailure Trap
  contents:
  - "4.1.6.5.  The authenticationFailure Trap\n   An authenticationFailure(4) trap\
    \ signifies that the sending protocol\n   entity is the addressee of a protocol\
    \ message that is not properly\n   authenticated.  While implementations of the\
    \ SNMP must be capable of\n   generating this trap, they must also be capable\
    \ of suppressing the\n   emission of such traps via an implementation-specific\
    \ mechanism.\n"
- title: 4.1.6.6.  The egpNeighborLoss Trap
  contents:
  - "4.1.6.6.  The egpNeighborLoss Trap\n   An egpNeighborLoss(5) trap signifies that\
    \ an EGP neighbor for whom\n   the sending protocol entity was an EGP peer has\
    \ been marked down and\n   the peer relationship no longer obtains.\n   The Trap-PDU\
    \ of type egpNeighborLoss contains as the first element of\n   its variable-bindings,\
    \ the name and value of the egpNeighAddr\n   instance for the affected neighbor.\n"
- title: 4.1.6.7.  The enterpriseSpecific Trap
  contents:
  - "4.1.6.7.  The enterpriseSpecific Trap\n   A enterpriseSpecific(6) trap signifies\
    \ that the sending protocol\n   entity recognizes that some enterprise-specific\
    \ event has occurred.\n   The specific-trap field identifies the particular trap\
    \ which\n   occurred.\n"
- title: 5.  Definitions
  contents:
  - "5.  Definitions\n     RFC1098-SNMP DEFINITIONS ::= BEGIN\n      IMPORTS\n   \
    \       ObjectName, ObjectSyntax, NetworkAddress, IpAddress, TimeTicks\n     \
    \         FROM RFC1065-SMI;\n          -- top-level message\n          Message\
    \ ::=\n                  SEQUENCE {\n                      version          --\
    \ version-1 for this RFC\n                          INTEGER {\n              \
    \                version-1(0)\n                          },\n                \
    \      community        -- community name\n                          OCTET STRING,\n\
    \                      data             -- e.g., PDUs if trivial\n           \
    \               ANY          -- authentication is being used\n               \
    \   }\n          -- protocol data units\n          PDUs ::=\n                \
    \  CHOICE {\n                              get-request\n                     \
    \             GetRequest-PDU,\n                              get-next-request\n\
    \                                  GetNextRequest-PDU,\n                     \
    \         get-response\n                                  GetResponse-PDU,\n \
    \                             set-request\n                                  SetRequest-PDU,\n\
    \                              trap\n                                  Trap-PDU\n\
    \                          }\n          -- PDUs\n          GetRequest-PDU ::=\n\
    \              [0]\n                  IMPLICIT PDU\n          GetNextRequest-PDU\
    \ ::=\n              [1]\n                  IMPLICIT PDU\n          GetResponse-PDU\
    \ ::=\n              [2]\n                  IMPLICIT PDU\n          SetRequest-PDU\
    \ ::=\n              [3]\n                  IMPLICIT PDU\n          PDU ::=\n\
    \                  SEQUENCE {\n                     request-id\n             \
    \             INTEGER,\n                      error-status      -- sometimes ignored\n\
    \                          INTEGER {\n                              noError(0),\n\
    \                              tooBig(1),\n                              noSuchName(2),\n\
    \                              badValue(3),\n                              readOnly(4),\n\
    \                              genErr(5)\n                          },\n     \
    \                 error-index       -- sometimes ignored\n                   \
    \      INTEGER,\n                      variable-bindings -- values are sometimes\
    \ ignored\n                          VarBindList\n                  }\n      \
    \    Trap-PDU ::=\n              [4]\n                 IMPLICIT SEQUENCE {\n \
    \                     enterprise        -- type of object generating\n       \
    \                                 -- trap, see sysObjectID in [2]\n          \
    \                OBJECT IDENTIFIER,\n                      agent-addr        --\
    \ address of object generating\n                          NetworkAddress, -- trap\n\
    \                      generic-trap      -- generic trap type\n              \
    \            INTEGER {\n                              coldStart(0),\n        \
    \                      warmStart(1),\n                              linkDown(2),\n\
    \                              linkUp(3),\n                              authenticationFailure(4),\n\
    \                              egpNeighborLoss(5),\n                         \
    \     enterpriseSpecific(6)\n                          },\n                  \
    \    specific-trap  -- specific code, present even\n                         \
    \ INTEGER,   -- if generic-trap is not\n                                     --\
    \ enterpriseSpecific\n                      time-stamp     -- time elapsed between\
    \ the last\n                          TimeTicks, -- (re)initialization of the\n\
    \                                        network\n                           \
    \          -- entity and the generation of the\n                             \
    \           trap\n                       variable-bindings -- \"interesting\"\
    \ information\n                          VarBindList\n                  }\n  \
    \        -- variable bindings\n          VarBind ::=\n                  SEQUENCE\
    \ {\n                      name\n                          ObjectName,\n     \
    \                 value\n                          ObjectSyntax\n            \
    \      }\n         VarBindList ::=\n                  SEQUENCE OF\n          \
    \           VarBind\n         END\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   This memo was influenced by the IETF SNMP Extensions\
    \ working\n   group:\n             Karl Auerbach, Epilogue Technology\n      \
    \       K. Ramesh Babu, Excelan\n             Amatzia Ben-Artzi, 3Com/Bridge\n\
    \             Lawrence Besaw, Hewlett-Packard\n             Jeffrey D. Case, University\
    \ of Tennessee at Knoxville\n             Anthony Chung, Sytek\n             James\
    \ Davidson, The Wollongong Group\n             James R. Davin, MIT Laboratory\
    \ for Computer Science\n             Mark S. Fedor, NYSERNet\n             Phill\
    \ Gross, The MITRE Corporation\n             Satish Joshi, ACC\n             Dan\
    \ Lynch, Advanced Computing Environments\n             Keith McCloghrie, The Wollongong\
    \ Group\n             Marshall T. Rose, The Wollongong Group (chair)\n       \
    \      Greg Satz, cisco\n             Martin Lee Schoffstall, Rensselaer Polytechnic\
    \ Institute\n             Wengyik Yeong, NYSERNet\n"
- title: 7.  References
  contents:
  - "7.  References\n   [1] Cerf, V., \"IAB Recommendations for the Development of\n\
    \       Internet Network Management Standards\", RFC 1052, IAB,\n       April\
    \ 1988.\n   [2] Rose, M., and K. McCloghrie, \"Structure and Identification\n\
    \       of Management Information for TCP/IP-based internets\",\n       RFC 1065,\
    \ TWG, August 1988.\n   [3] McCloghrie, K., and M. Rose, \"Management Information\
    \ Base\n       for Network Management of TCP/IP-based internets\",\n       RFC\
    \ 1066, TWG, August 1988.\n   [4] Case, J., M. Fedor, M. Schoffstall, and J. Davin,\n\
    \       \"A Simple Network Management Protocol\", Internet\n       Engineering\
    \ Task Force working note, Network Information\n       Center, SRI International,\
    \ Menlo Park, California,\n       March 1988.\n   [5] Davin, J., J. Case, M. Fedor,\
    \ and M. Schoffstall,\n       \"A Simple Gateway Monitoring Protocol\", RFC 1028,\n\
    \       Proteon, University of Tennessee at Knoxville,\n       Cornell University,\
    \ and Rensselaer Polytechnic\n       Institute, November 1987.\n   [6] Information\
    \ processing systems - Open Systems\n       Interconnection, \"Specification of\
    \ Abstract Syntax\n       Notation One (ASN.1)\", International Organization for\n\
    \       Standardization, International Standard 8824,\n       December 1987.\n\
    \   [7] Information processing systems - Open Systems\n       Interconnection,\
    \ \"Specification of Basic Encoding Rules\n       for Abstract Notation One (ASN.1)\"\
    , International\n       Organization for Standardization, International Standard\n\
    \       8825, December 1987.\n   [8] Postel, J., \"User Datagram Protocol\", RFC\
    \ 768,\n       USC/Information Sciences Institute, November 1980.\n   [9] Warrier,\
    \ U., and L. Besaw, \"The Common Management Information\n       Services and Protocol\
    \ over TCP/IP\", RFC 1095, Unisys Corporation\n       and Hewlett-Packard, April\
    \ 1989.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n       Jeffrey D. Case\n       University of Tennessee Computing\
    \ Center\n       Associate Driector\n       200 Stokely Management Center\n  \
    \     Knoxville, TN 37996-0520\n       Phone: (615) 974-6721\n       Email: case@UTKUX1.UTK.EDU\n\
    \       Mark Fedor\n       Nysernet, Inc.\n       Rensselaer Technology Park\n\
    \       125 Jordan Road\n       Troy, NY 12180\n       Phone: (518) 283-8860\n\
    \       Email: fedor@patton.NYSER.NET\n       Martin Lee Schoffstall\n       NYSERNET\
    \ Inc.\n       Rensselaer Technology Park\n       165 Jordan Road\n       Troy,\
    \ NY 12180\n       Phone: (518) 283-8860\n       Email: schoff@NISC.NYSER.NET\n\
    \       Chuck Davin\n       MIT Laboratory for Computer Science, NE43-507\n  \
    \     545 Technology Square\n       Cambridge, MA 02139\n       Phone: (617) 253-6020\n\
    \       EMail: jrd@ptt.lcs.mit.edu\n"
