- contents:
  - '   Improved Recursive DNS Server Selection for Multi-Interfaced Nodes

    '
  title: __initial_text__
- contents:
  - "Abstract\n   A multi-interfaced node is connected to multiple networks, some
    of\n   which might be utilizing private DNS namespaces.  A node commonly\n   receives
    recursive DNS server configuration information from all\n   connected networks.
    \ Some of the recursive DNS servers might have\n   information about namespaces
    other servers do not have.  When a\n   multi-interfaced node needs to utilize
    DNS, the node has to choose\n   which of the recursive DNS servers to use.  This
    document describes\n   DHCPv4 and DHCPv6 options that can be used to configure
    nodes with\n   information required to perform informed recursive DNS server\n
    \  selection decisions.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6731.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n     1.1.  Requirements Language  . . . . . . . . . . . . . .
    . . . .  4\n   2.  Private Namespaces and Problems for Multi-Interfaced Nodes
    . .  4\n     2.1.  Fully Qualified Domain Names with Limited Scopes . . . . .
    \ 4\n     2.2.  Network-Interface-Specific IP Addresses  . . . . . . . . .  5\n
    \    2.3.  A Problem Not Fully Solved by the Described Solution . . .  6\n   3.
    \ Deployment Scenarios . . . . . . . . . . . . . . . . . . . . .  7\n     3.1.
    \ CPE Deployment Scenario  . . . . . . . . . . . . . . . . .  7\n     3.2.  Cellular
    Network Scenario  . . . . . . . . . . . . . . . .  7\n     3.3.  VPN Scenario
    . . . . . . . . . . . . . . . . . . . . . . .  8\n     3.4.  Dual-Stack Accesses
    \ . . . . . . . . . . . . . . . . . . .  8\n   4.  Improved RDNSS Selection .
    . . . . . . . . . . . . . . . . . .  8\n     4.1.  Procedure for Prioritizing
    RDNSSes and Handling\n           Responses  . . . . . . . . . . . . . . . . .
    . . . . . . .  9\n     4.2.  RDNSS Selection DHCPv6 Option  . . . . . . . . .
    . . . . . 11\n     4.3.  RDNSS Selection DHCPv4 Option  . . . . . . . . . . .
    . . . 13\n     4.4.  Scalability Considerations . . . . . . . . . . . . . . .
    . 15\n     4.5.  Limitations on Use . . . . . . . . . . . . . . . . . . . . 15\n
    \    4.6.  Coexistence of Various RDNSS Configuration Tools . . . . . 16\n     4.7.
    \ Considerations on Follow-Up Queries  . . . . . . . . . . . 17\n     4.8.  Closing
    Network Interfaces and Local Caches  . . . . . . . 17\n   5.  Example of a Node
    Behavior . . . . . . . . . . . . . . . . . . 17\n   6.  Considerations for Network
    Administrators  . . . . . . . . . . 19\n   7.  IANA Considerations  . . . . .
    . . . . . . . . . . . . . . . . 20\n   8.  Security Considerations  . . . . .
    . . . . . . . . . . . . . . 20\n     8.1.  Attack Vectors . . . . . . . . . .
    . . . . . . . . . . . . 20\n     8.2.  Trust Levels of Network Interfaces . .
    . . . . . . . . . . 21\n     8.3.  Importance of Following the Algorithm  . .
    . . . . . . . . 21\n   9.  References . . . . . . . . . . . . . . . . . . . .
    . . . . . . 21\n     9.1.  Normative References . . . . . . . . . . . . . . .
    . . . . 21\n     9.2.  Informative References . . . . . . . . . . . . . . . .
    . . 22\n   Appendix A.  Possible Alternative Practices for RDNSS Selection  .
    23\n     A.1.  Sending Queries Out on Multiple Interfaces in Parallel . . 23\n
    \    A.2.  Search List Option for DNS Forward Lookup Decisions  . . . 23\n     A.3.
    \ More-Specific Routes for Reverse Lookup Decisions  . . . . 24\n     A.4.  Longest
    Matching Prefix for Reverse Lookup Decisions . . . 24\n   Appendix B.  DNSSEC
    and Multiple Answers Validating with\n                Different Trust Anchors
    . . . . . . . . . . . . . . . 24\n   Appendix C.  Pseudocode for RDNSS Selection
    \ . . . . . . . . . . . 24\n   Appendix D.  Acknowledgements  . . . . . . . .
    . . . . . . . . . . 29\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   A multi-interfaced node (MIF node) faces several problems
    a single-\n   homed node does not encounter, as is described in [RFC6418].  This\n
    \  document studies in detail the problems private namespaces might\n   cause
    for multi-interfaced nodes and provides a solution.  The node\n   might be implemented
    as a host or as a router.\n   We start from the premise that network operators
    sometimes include\n   private, but still globally unique, namespaces in the answers
    they\n   provide from Recursive DNS Servers (RDNSSes) and that those private\n
    \  namespaces are at least as useful to nodes as the answers from the\n   public
    DNS.  When private namespaces are visible for a node, some\n   RDNSSes have information
    other RDNSSes do not have.  The node ought\n   to be able to query the RDNSS that
    can resolve the query regardless\n   of whether the answer comes from the public
    DNS or a private\n   namespace.\n   An example of an application that benefits
    from multi-interfacing is\n   a web browser that commonly accesses many different
    destinations,\n   each of which is available on only one network.  The browser\n
    \  therefore needs to be able to communicate over different network\n   interfaces,
    depending on the destination it is trying to reach.\n   Selection of the correct
    interface and source address is often\n   crucial in the networks using private
    namespaces.  In such\n   deployments, the destination's IP addresses might only
    be reachable\n   on the network interface over which the destination's name was\n
    \  resolved.  Henceforth, the solution described in this document is\n   assumed
    to be commonly used in combination with tools for delivering\n   additional routing
    and source and destination address selection\n   policies (e.g., [RFC4191] and
    [RFC3442].\n   This document is organized in the following manner.  Background\n
    \  information about problem descriptions and example deployment\n   scenarios
    are included in Sections 2 and 3.  Section 4 contains all\n   normative descriptions
    for DHCP options and node behavior.\n   Informative Section 5 illustrates behavior
    of a node implementing\n   functionality described in Section 4.  Section 6 contains
    normative\n   guidelines related to creation of private namespaces.  The IANA\n
    \  considerations are in Section 7.  Informational Section 8 summarizes\n   identified
    security considerations.\n   Appendix A describes best current practices that
    are possible with\n   tools preceding this document and that are possibilities
    on networks\n   not supporting the solution described in this document.  Appendix
    B\n   discusses a scenario where multiple answers are possible to validate,\n
    \  but with different trust anchors.  Appendix C illustrates with\n   pseudocode
    the functionality described in Section 4.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [RFC2119].\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  Private Namespaces and Problems for Multi-Interfaced Nodes\n   This section
    describes two private namespace scenarios related to\n   node multi-interfacing
    for which the procedure described in Section 4\n   provides a solution.  Additionally,
    Section 2.3 describes a problem\n   for which this document provides only a partial
    solution.\n"
  - contents:
    - "2.1.  Fully Qualified Domain Names with Limited Scopes\n   A multi-interfaced
      node can be connected to one or more networks that\n   are using private namespaces.
      \ As an example, the node can\n   simultaneously open a Wireless LAN (WLAN)
      connection to the public\n   Internet, a cellular connection to an operator
      network, and a Virtual\n   Private Network (VPN) connection to an enterprise
      network.  When an\n   application initiates a connection establishment to a
      Fully Qualified\n   Domain Name (FQDN), the node needs to be able to choose
      the right\n   RDNSS for making a successful DNS query.  This is illustrated
      in\n   Figure 1.  An FQDN for a public name can be resolved with any RDNSS,\n
      \  but for an FQDN of the private name of an enterprise's or operator's\n   service,
      the node needs to be able to correctly select the right\n   RDNSS for the DNS
      resolution, i.e., do also network interface\n   selection already before destination's
      IP address is known.\n                            +---------------+\n                            |
      RDNSS with    |    |   Enterprise\n   +------+                 | public +      |----|
      \  Intranet\n   |      |                 | enterprise's  |    |\n   |      |=====
      VPN =======| private names |    |\n   |      |                 +---------------+
      \ +----+\n   | MIF  |                                    | FW |\n   | node |
      \                                   +----+\n   |      |                 +---------------+
      \   |\n   |      |----- WLAN ------| RDNSS with    |----|   Public\n   |      |
      \                | public names  |    |   Internet\n   |      |                 +---------------+
      \ +----+\n   |      |                                    | FW |\n   |      |
      \                +---------------+  +----+\n   |      |---- cellular ---| RDNSS
      with    |    |\n   +------+                 | public +      |    |   Operator\n
      \                           | operator's    |----|   Intranet\n                            |
      private names |    |\n                            +---------------+\n               Figure
      1: Private DNS Namespaces Illustrated\n"
    title: 2.1.  Fully Qualified Domain Names with Limited Scopes
  - contents:
    - "2.2.  Network-Interface-Specific IP Addresses\n   In the second problem, an
      FQDN is valid and resolvable via different\n   network interfaces, but to different
      and not necessarily globally\n   reachable IP addresses, as is illustrated in
      Figure 2.  The node's\n   routing, source, and destination address selection
      mechanism has to\n   ensure the destination's IP address is only used in combination
      with\n   source IP addresses of the network interface on which the name was\n
      \  resolved.\n                            +--------------------|      |\n   +------+
      \  IPv6          | RDNSS A            |------| IPv6\n   |      |-- interface
      1 --| saying Peer is     |      |\n   |      |                 | at: 2001:0db8:0::1
      |      |\n   | MIF  |                 +--------------------+   +------+\n   |
      node |                                          | Peer |\n   |      |                 +--------------------+
      \  +------+\n   |      |   IPv6          | RDNSS B            |      |\n   |
      \     |-- interface 2 --| saying Peer is     |      |\n   +------+                 |
      at: 2001:0db8:1::1 |------| IPv6\n                            +--------------------+
      \     |\n    Figure 2: Private DNS Namespaces and Different IP Addresses for
      an\n                        FQDN on Interfaces 1 and 2\n   A similar situation
      can happen with IPv6 protocol translation and\n   AAAA record synthesis [RFC6147].
      \ A synthetic AAAA record is\n   guaranteed to be valid only on the network
      on which it was\n   synthesized.  Figure 3 illustrates a scenario where the
      peer's IPv4\n   address is synthesized into different IPv6 addresses by RDNSSes
      A and\n   B.\n                            +-------------------|    +-------+\n
      \  +------+   IPv6          | RDNSS A           |----| NAT64 |\n   |      |--
      interface 1 --| saying Peer is    |    +-------+\n   |      |                 |
      at: A_Pref96:IPv4 |       |\n   | MIF  |                 +-------------------+
      \      |   +------+\n   | node |                                        IPv4
      +---| Peer |\n   |      |                 +-------------------+       |   +------+\n
      \  |      |   IPv6          | RDNSS B           |       |\n   |      |-- interface
      2 --| saying Peer is    |    +-------+\n   +------+                 | at: B_Pref96:IPv4
      |----| NAT64 |\n                            +-------------------+    +-------+\n
      \                   Figure 3: AAAA Synthesis Results in\n                 Network-Interface-Specific
      IPv6 Addresses\n   It is worth noting that network-specific IP addresses can
      also cause\n   problems for a single-homed node, if the node retains DNS cache\n
      \  during movement from one network to another.  After the network\n   change,
      a node can have entries in its DNS cache that are no longer\n   correct or appropriate
      for its new network position.\n"
    title: 2.2.  Network-Interface-Specific IP Addresses
  - contents:
    - "2.3.  A Problem Not Fully Solved by the Described Solution\n   A more complex
      scenario is an FQDN, which in addition to possibly\n   resolving into network-interface-specific
      IP addresses, identifies on\n   different network interfaces completely different
      peer entities with\n   potentially different sets of service offerings.  In
      an even more\n   complex scenario, an FQDN identifies a unique peer entity,
      but one\n   that provides different services on its different network interfaces.\n
      \  The solution described in this document is not able to tackle these\n   higher-layer
      issues.  In fact, these problems might be solvable only\n   by manual user intervention.\n
      \  However, when DNS Security (DNSSEC) is used, the DNSSEC validation\n   procedure
      can provide assistance for selecting correct responses for\n   some, but not
      all, use cases.  A node might prefer to use the DNS\n   answer that validates
      with the preferred trust anchor.\n"
    title: 2.3.  A Problem Not Fully Solved by the Described Solution
  title: 2.  Private Namespaces and Problems for Multi-Interfaced Nodes
- contents:
  - "3.  Deployment Scenarios\n   This document has been written with three particular
    deployment\n   scenarios in mind.  The first is a Customer Premises Equipment
    (CPE)\n   with two or more uplink Virtual Local Area Network (VLAN)\n   connections.
    \ The second scenario involves a cellular device with two\n   uplink Internet
    connections: WLAN and cellular.  The third scenario\n   is for VPNs, where use
    of a local RDNSS might be preferred for\n   latency reasons, but the enterprise's
    RDNSS has to be used to resolve\n   private names used by the enterprise.\n   In
    this section, we are referring to the RDNSS preference values\n   defined in Section
    4.  The purpose of that is to illustrate when\n   administrators might choose
    to utilize the different preference\n   values.\n"
  - contents:
    - "3.1.  CPE Deployment Scenario\n   A home gateway can have two uplink connections
      leading to different\n   networks, as described in [WITHOUT-IPV6NAT].  In the
      two-uplink\n   scenario, only one uplink connection leads to the Internet, while
      the\n   other uplink connection leads to a private network utilizing private\n
      \  namespaces.\n   It is desirable that the CPE does not have to send DNS queries
      over\n   both uplink connections, but instead, CPE need only send default\n
      \  queries to the RDNSS of the interface leading to the Internet and\n   queries
      related to the private namespace to the RDNSS of the private\n   network.  This
      can be configured by setting the RDNSS of the private\n   network to know about
      listed domains and networks, but not to be a\n   default RDNSS.\n   In this
      scenario, the legacy hosts can be supported by deploying DNS\n   proxy on the
      CPE and configuring hosts in the LAN to talk to the DNS\n   proxy.  However,
      updated hosts would be able to talk directly to the\n   correct RDNSS of each
      uplink ISP's RDNSS.  It is a deployment\n   decision whether the updated hosts
      would be pointed to a DNS proxy or\n   to actual RDNSSes.\n   Depending on actual
      deployments, all VLAN connections might be\n   considered trusted.\n"
    title: 3.1.  CPE Deployment Scenario
  - contents:
    - "3.2.  Cellular Network Scenario\n   A cellular device can have both WLAN and
      cellular network interfaces\n   up.  In such a case, it is often desirable to
      use WLAN by default,\n   except for the connections that the cellular network
      operator wants\n   to go over the cellular interface.  The use of WLAN for DNS
      queries\n   likely improves the power consumption of cellular devices and often\n
      \  provides lower latency.  The cellular network might utilize private\n   names;
      hence, the cellular device needs to ask for those through the\n   cellular interface.
      \ This can be configured by setting the RDNSS of\n   the cellular network to
      be of low preference and listing the domains\n   and networks related to the
      cellular network's private namespaces as\n   being available via the cellular
      network's RDNSS.  This will cause a\n   node to send DNS queries by default
      to the RDNSS of the WLAN\n   interface (that is, by default, considered to be
      of medium\n   preference) and queries related to private namespaces to the RDNSS
      of\n   the cellular interface.\n   In this scenario, the cellular interface
      can be considered trusted\n   and WLAN oftentimes untrusted.\n"
    title: 3.2.  Cellular Network Scenario
  - contents:
    - "3.3.  VPN Scenario\n   Depending on a deployment, there might be interest in
      using VPN only\n   for the traffic destined to a enterprise network.  The enterprise\n
      \  might be using private namespaces; hence, related DNS queries need to\n   be
      sent over VPN to the enterprise's RDNSS, while by default, the\n   RDNSS of
      a local access network might be used for all other traffic.\n   This can be
      configured by setting the RDNSS of the VPN interface to\n   be of low preference
      and listing the domains and networks related to\n   an enterprise network's
      private namespaces being available via the\n   RDNSS of the VPN interface.  This
      will cause a node to send DNS\n   queries by default directly to the RDNSS of
      the WLAN interface (that\n   is, by default, considered to be of medium preference)
      and queries\n   related to private namespaces to the RDNSS of the VPN interface.\n
      \  In this scenario, the VPN interface can be considered trusted and the\n   local
      access network untrusted.\n"
    title: 3.3.  VPN Scenario
  - contents:
    - "3.4.  Dual-Stack Accesses\n   In all three scenarios, one or more of the connected
      networks can\n   support both IPv4 and IPv6.  In such a case, both or either
      of DHCPv4\n   and DHCPv6 can be used to learn RDNSS selection information.\n"
    title: 3.4.  Dual-Stack Accesses
  title: 3.  Deployment Scenarios
- contents:
  - "4.  Improved RDNSS Selection\n   This section describes DHCP options and a procedure
    that a (stub/\n   proxy) resolver can utilize for improved RDNSS selection in
    the face\n   of private namespaces and multiple simultaneously active network\n
    \  interfaces.  The procedure is subject to limitations of use as\n   described
    in Section 4.5.  The pseudocode in Appendix C illustrates\n   how the improved
    RDNSS selection works.\n"
  - contents:
    - "4.1.  Procedure for Prioritizing RDNSSes and Handling Responses\n   A resolver
      SHALL build a preference list of RDNSSes it will contact\n   depending on the
      query.  To build the list in an optimal way, a node\n   SHALL request for RDNSS
      selection information with the DHCP options\n   defined in Sections 4.2 and
      4.3 before any DNS queries need to be\n   made.  With help of the received RDNSS
      selection information, the\n   node can determine if any of the available RDNSSes
      have special\n   knowledge about specific domains needed for forward DNS lookups
      or\n   network addresses (later referred as \"network\") needed for reverse\n
      \  DNS lookups.\n   A resolver lacking more specific information can assume
      that all\n   information is available from any RDNSS of any network interface.\n
      \  The RDNSSes learned by other RDNSS address configuration methods can\n   be
      considered as default RDNSSes, but preference-wise, they MUST be\n   handled
      as medium preference RDNSSes (see also Section 4.6).\n   When a DNS query needs
      to be made, the resolver MUST give highest\n   preference to the RDNSSes explicitly
      known to serve a matching domain\n   or network.  The resolver MUST take into
      account differences in trust\n   levels (see Section 8.2) of pieces of received
      RDNSS selection\n   information.  The resolver MUST prefer RDNSSes of trusted
      interfaces.\n   The RDNSSes of untrusted interfaces can be of highest preference
      only\n   if the trusted interfaces specifically configures low preference\n
      \  RDNSSes.  The non-exhaustive list of cases in Figure 4 illustrates\n   how
      the different trust levels of received RDNSS selection\n   information influence
      the RDNSS selection logic.  In Figure 4,\n   \"Medium\", \"High\", and \"Low\"
      indicate the explicitly configured\n   RDNSS's preference over other RDNSSes.
      \ The \"Medium\" preference is\n   also used with RDNSSes for which no explicit
      preference configuration\n   information is available.  The \"Specific domains\"
      in Figure 4\n   indicate the explicitly configured \"Domains and networks\"
      private\n   namespace information that a particular RDNSS has.\n   A resolver
      MUST prioritize between equally trusted RDNSSes with the\n   help of the DHCP
      option preference field.  The resolver MUST NOT\n   prioritize less trusted
      RDNSSes higher than trusted, even in the case\n   when a less trusted RDNSS
      would apparently have additional\n   information.  In the case of all other
      things being equal, the\n   resolver can make the prioritization decision based
      on its internal\n   preferences.\n      Information from       | Information
      from       | Resulting RDNSS\n      more trusted           | less trusted           |
      preference\n      interface A            | interface B            | selection\n
      \  --------------------------+------------------------+-----------------\n   1.
      Medium preference      | Medium preference      | Default:\n      default                |
      default                | A, then B\n   --------------------------+------------------------+-----------------\n
      \  2. Medium preference      | High preference default| Default:\n      default
      \               |                        | A, then B\n                             |
      Specific domains       | Specific:\n                             |                        |
      A, then B\n   --------------------------+------------------------+-----------------\n
      \  3. Low preference default | Medium preference      | Default:\n                             |
      default                | B, then A\n   --------------------------+------------------------+-----------------\n
      \  4. Low preference default | Medium preference      | Default:\n                             |
      default                | B, then A\n      Specific domains       |                        |
      Specific:\n                             |                        | A, then B\n
      \  --------------------------+------------------------+-----------------\n      Figure
      4: RDNSS Selection in the Case of Different Trust Levels\n   Because DNSSEC
      provides cryptographic assurance of the integrity of\n   DNS data, it is necessary
      to prefer data that can be validated under\n   DNSSEC over data that cannot.
      \ There are two ways that a node can\n   determine that data is valid under
      DNSSEC.  The first is to perform\n   DNSSEC validation itself.  The second is
      to have a secure connection\n   to an authenticated RDNSS and to rely on that
      RDNSS to perform DNSSEC\n   validation (signaling that it has done so using
      the AD bit).  DNSSEC\n   is necessary to detect forged responses, and without
      it any DNS\n   response could be forged or altered.  Unless the DNS responses
      have\n   been validated with DNSSEC, a node cannot make a decision to prefer\n
      \  data from any interface with any great assurance.\n   A node SHALL send requests
      to RDNSSes in the order defined by the\n   preference list until an acceptable
      reply is received, all replies\n   are received, or a timeout occurs.  In the
      case of a requested name\n   matching to a specific domain or network rule accepted
      from any\n   interface, a DNSSEC-aware resolver MUST NOT proceed with a reply
      that\n   cannot be validated using DNSSEC until all RDNSSes on the preference\n
      \  list have been contacted or timed out.  This protects against\n   possible
      redirection attacks.  In the case of the requested name not\n   matching to
      any specific domain or network, the first received\n   response from any RDNSS
      can be considered acceptable.  A DNSSEC-aware\n   node MAY always contact all
      RDNSSes in an attempt to receive a\n   response that can be validated, but contacting
      all RDNSSes is not\n   mandated for the default case as that would consume excess
      resources\n   in some deployments.\n   In the case of a validated NXDOMAIN response
      being received from an\n   RDNSS that can provide answers for the queried name,
      a node MUST NOT\n   accept non-validated replies from other RDNSSes (see Appendix
      B for\n   considerations related to multiple trust anchors).\n"
    title: 4.1.  Procedure for Prioritizing RDNSSes and Handling Responses
  - contents:
    - "4.2.  RDNSS Selection DHCPv6 Option\n   DHCPv6 option described below can be
      used to inform resolvers what\n   RDNSS can be contacted when initiating forward
      or reverse DNS lookup\n   procedures.  This option is DNS record type agnostic
      and applies, for\n   example, equally to both A and AAAA queries.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |    OPTION_RDNSS_SELECTION     |         option-len            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   |            DNS-recursive-name-server
      (IPv6 address)           |\n   |                                                               |\n
      \  |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Reserved  |prf|                                               |\n   +-+-+-+-+-+-+-+-+
      \         Domains and networks                 |\n   |                          (variable
      length)                    |\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         Figure
      5: DHCPv6 Option for Explicit Domain Configuration\n   option-code:  OPTION_RDNSS_SELECTION
      (74)\n   option-len:  Length of the option in octets\n   DNS-recursive-name-server:
      \ An IPv6 address of RDNSS\n   Reserved:  Field reserved for the future.  MUST
      be set to zero and\n              MUST be ignored on receipt.\n   prf:  RDNSS
      preference:\n         01 High\n         00 Medium\n         11 Low\n         10
      Reserved\n         Reserved preference value (10) MUST NOT be sent.  On receipt,\n
      \        the Reserved value MUST be treated as Medium preference (00).\n   Domains
      and networks:  The list of domains for forward DNS lookup and\n                          networks
      for reverse DNS lookup about which\n                          the RDNSS has
      special knowledge.  Field MUST\n                          be encoded as specified
      in Section 8 of\n                          [RFC3315].  A special domain of \".\"
      is used to\n                          indicate capability to resolve global
      names\n                          and act as a default RDNSS.  Lack of a \".\"\n
      \                         domain on the list indicates that the RDNSS\n                          only
      has information related to listed domains\n                          and networks.
      \ Networks for reverse mapping\n                          are encoded as defined
      for IP6.ARPA [RFC3596]\n                          or IN-ADDR.ARPA [RFC2317].\n
      \  A node SHOULD include the Option Request Option (OPTION_ORO\n   [RFC3315])
      in a DHCPv6 request with the OPTION_RDNSS_SELECTION option\n   code to inform
      the DHCPv6 server about the support for the improved\n   RDNSS selection logic.
      \ The DHCPv6 server receiving this information\n   can then choose to provision
      RDNSS addresses only with\n   OPTION_RDNSS_SELECTION.\n   OPTION_RDNSS_SELECTION
      contains one or more domains of which the\n   related RDNSS has particular knowledge.
      \ The option can occur\n   multiple times in a single DHCPv6 message, if multiple
      RDNSSes are to\n   be configured.  This can be the case, for example, if a network
      link\n   has multiple RDNSSes for reliability purposes.\n   The list of networks
      MUST cover all the domains configured in this\n   option.  The length of the
      included networks SHOULD be as long as\n   possible to avoid potential collision
      with information received on\n   other option instances or with options received
      from DHCP servers of\n   other network interfaces.  Overlapping networks are
      interpreted so\n   that the resolver can use any of the RDNSSes for queries
      matching the\n   networks.\n   If OPTION_RDNSS_SELECTION contains an RDNSS address
      already learned\n   from other DHCPv6 servers of the same network and contains
      new\n   domains or networks, the node SHOULD append the information to the\n
      \  information received earlier.  The node MUST NOT remove previously\n   obtained
      information.  However, the node SHOULD NOT extend the\n   lifetime of earlier
      information either.  When a conflicting RDNSS\n   address is learned from a
      less trusted interface, the node MUST\n   ignore the option.\n   Like the RDNSS
      options of [RFC3646], OPTION_RDNSS_SELECTION MUST NOT\n   appear in any other
      than the following DHCPv6 messages: Solicit,\n   Advertise, Request, Renew,
      Rebind, Information-Request, and Reply.\n   The client SHALL periodically refresh
      information learned with\n   OPTION_RDNSS_SELECTION.  The information SHALL
      be refreshed on link-\n   state changes, such as those caused by node mobility,
      and when\n   renewing lifetimes of IPv6 addresses configured with DHCPv6.\n
      \  Additionally, the DHCPv6 Information Refresh Time Option, as\n   specified
      in [RFC4242], can be used to control the update frequency.\n"
    title: 4.2.  RDNSS Selection DHCPv6 Option
  - contents:
    - "4.3.  RDNSS Selection DHCPv4 Option\n   The DHCPv4 option described below can
      be used to inform resolvers\n   which RDNSS can be contacted when initiating
      forward or reverse DNS\n   lookup procedures.  This option is DNS record type
      agnostic and\n   applies, for example, equally to both A and AAAA queries.\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     CODE      |     Len       | Reserved  |prf|    Primary .. |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | .. DNS-recursive-name-server's IPv4 address   |  Secondary .. |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | .. DNS-recursive-name-server's IPv4 address   |               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \              |\n   |                                                               |\n
      \  +                          Domains and networks                 |\n   |                          (variable
      length)                    |\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         Figure
      6: DHCPv4 Option for Explicit Domain Configuration\n   option-code:  RDNSS Selection
      (146)\n   option-len:  Length of the option in octets\n   Reserved:  Field reserved
      for the future.  MUST be set to zero and\n              MUST be ignored on receipt.\n
      \  prf:  RDNSS preference:\n         01 High\n         00 Medium\n         11
      Low\n         10 Reserved\n         Reserved preference value (10) MUST NOT
      be sent.  On receipt,\n         the Reserved value MUST be treated as Medium
      preference (00).\n   Primary DNS-recursive-name-server's IPv4 address:  Address
      of a\n                                                      primary RDNSS\n
      \  Secondary DNS-recursive-name-server's IPv4 address:  Address of a\n                                                        secondary
      RDNSS\n                                                        or 0.0.0.0 if\n
      \                                                       not configured\n   Domains
      and networks:  The list of domains for forward DNS lookup and\n                          networks
      for reverse DNS lookup about which\n                          the RDNSSes have
      special knowledge.  Field\n                          MUST be encoded as specified
      in Section 8 of\n                          [RFC3315].  A special domain of \".\"
      is used to\n                          indicate capability to resolve global
      names\n                          and act as the default RDNSS.  Lack of a \".\"\n
      \                         domain on the list indicates that RDNSSes only\n                          have
      information related to listed domains and\n                          networks.
      \ Networks for reverse mapping are\n                          encoded as defined
      for IP6.ARPA [RFC3596] or\n                          IN-ADDR.ARPA [RFC2317].\n
      \  The RDNSS Selection option contains one or more domains of which the\n   primary
      and secondary RDNSSes have particular knowledge.  If the\n   length of the domains
      and networks field causes option length to\n   exceed the maximum permissible
      for a single option (255 octets), then\n   multiple options MAY be used, as
      described in \"Encoding Long Options\n   in the Dynamic Host Configuration Protocol
      (DHCPv4)\" [RFC3396].  When\n   multiple options are present, the data portions
      of all option\n   instances are concatenated together.\n   The list of networks
      MUST cover all the domains configured in this\n   option.  The length of the
      included networks SHOULD be as long as\n   possible to avoid potential collision
      with information received on\n   other option instances or with options received
      from DHCP servers of\n   other network interfaces.  Overlapping networks are
      interpreted so\n   that the resolver can use any of the RDNSSes for queries
      matching the\n   networks.\n   If the RDNSS Selection option contains an RDNSS
      address already\n   learned from other DHCPv4 servers of the same network and
      contains\n   new domains or networks, the node SHOULD append the information
      to\n   the information received earlier.  The node MUST NOT remove\n   previously
      obtained information.  However, the node SHOULD NOT extend\n   the lifetime
      of earlier information either.  When a conflicting RDNSS\n   address is learned
      from a less trusted interface, the node MUST\n   ignore the option.\n   The
      client SHALL periodically refresh information learned with the\n   RDNSS Selection
      option.  The information SHALL be refreshed on link-\n   state changes, such
      as those caused by node mobility, and when\n   extending the lease of IPv4 addresses
      configured with DHCPv4.\n"
    title: 4.3.  RDNSS Selection DHCPv4 Option
  - contents:
    - "4.4.  Scalability Considerations\n   The general size limitations of the DHCP
      messages limit the number of\n   domains and networks that can be carried inside
      of these RDNSS\n   selection options.  The DHCP options for RDNSS selection
      are best\n   suited for those deployments where relatively few and carefully\n
      \  selected domains and networks are enough.\n"
    title: 4.4.  Scalability Considerations
  - contents:
    - "4.5.  Limitations on Use\n   The RDNSS selection option SHOULD NOT be enabled
      by default.  (In\n   this section, \"RDNSS selection option\" refers to the
      DHCPv4 RDNSS\n   Selection option and the DHCPv6 OPTION_RDNSS_SELECTION.)  The
      option\n   can be used in the following environments:\n   1.  The RDNSS selection
      option is delivered across a secure, trusted\n       channel.\n   2.  The RDNSS
      selection option is not secured, but the client on a\n       node does DNSSEC
      validation.\n   3.  The RDNSS selection option is not secured, the resolver
      does\n       DNSSEC validation, and the client communicates with the resolver\n
      \      configured with the RDNSS selection option over a secure, trusted\n       channel.\n
      \  4.  The IP address of the RDNSS that is being recommended in the\n       RDNSS
      selection option is known and trusted by the client; that\n       is, the RDNSS
      selection option serves not to introduce the client\n       to a new RDNSS,
      but rather to inform it that the RDNSS it has\n       already been configured
      to trust is available to it for resolving\n       certain domains.\n   As the
      DHCP by itself cannot tell whether it is using a secure,\n   trusted channel,
      or whether the client on a node is performing DNSSEC\n   validation, this option
      cannot be used without being explicitly\n   enabled.  The functionality can
      be enabled for an interface via\n   administrative means, such as by provisioning
      tools or manual\n   configuration.  Furthermore, the functionality can be automatically\n
      \  enabled by a client on a node that knows it is performing DNSSEC\n   validation
      or by a node that is configured or hard-coded to trust\n   certain interfaces
      (see Section 8.2).\n"
    title: 4.5.  Limitations on Use
  - contents:
    - "4.6.  Coexistence of Various RDNSS Configuration Tools\n   The DHCPv4 RDNSS
      Selection option and the DHCPv6\n   OPTION_RDNSS_SELECTION are designed to coexist
      with each other and\n   with other tools used for RDNSS address configuration.\n
      \  For RDNSS selection purposes, information received from all tools\n   MUST
      be combined together into a single list, as discussed in\n   Section 4.1.\n
      \  It can happen that DHCPv4 and DHCPv6 are providing conflicting RDNSS\n   selection
      information on the same or on equally trusted interfaces.\n   In such a case,
      DHCPv6 MUST be preferred unless DHCPv4 is utilizing\n   additional security
      frameworks for protecting the messages.\n   The RDNSSes learned via tools other
      than the DHCPv4 RDNSS Selection\n   option and the DHCPv6 OPTION_RDNSS_SELECTION
      MUST be handled as\n   default RDNSSes, with medium preference, when building
      a list of\n   RDNSSes to talk to (see Section 4.1).\n   The non-exhaustive list
      of possible other sources for RDNSS address\n   configuration are:\n   (1)  DHCPv6
      OPTION_DNS_SERVERS defined in [RFC3646].\n   (2)  DHCPv4 Domain Server option
      defined in [RFC2132].\n   (3)  IPv6 Router Advertisement RDNSS Option defined
      in [RFC6106].\n   When the RDNSS selection option contains a default RDNSS address
      and\n   other sources are providing RNDSS addresses, the resolver MUST make\n
      \  the decision about which one to prefer based on the RDNSS preference\n   field
      value.  If the RDNSS selection option defines medium\n   preference, then the
      RDNSS from the RDNSS selection option SHALL be\n   selected.\n   If multiple
      sources are providing same RDNSS(es) IP address(es), each\n   address MUST be
      added to the RDNSS list only once.\n   If a node had indicated support for OPTION_RDNSS_SELECTION
      in a\n   DHCPv6 request, the DHCPv6 server MAY omit sending of\n   OPTION_DNS_SERVERS.
      \ This enables offloading use case where the\n   network administrator wishes
      to only advertise low preference default\n   RDNSSes.\n"
    title: 4.6.  Coexistence of Various RDNSS Configuration Tools
  - contents:
    - "4.7.  Considerations on Follow-Up Queries\n   Any follow-up queries that are
      performed on the basis of an answer\n   received on an interface MUST continue
      to use the same interface,\n   irrespective of the RDNSS selection settings
      on any other interface.\n   For example, if a node receives a reply with a canonical
      name (CNAME)\n   or delegation name (DNAME), the follow-up queries MUST be sent
      to\n   RDNSS(es) of the same interface, or to the same RDNSS, irrespectively\n
      \  of the FQDN received.  Otherwise, referrals can fail.\n"
    title: 4.7.  Considerations on Follow-Up Queries
  - contents:
    - "4.8.  Closing Network Interfaces and Local Caches\n   Cached information related
      to private namespaces can become obsolete\n   after the network interface over
      which the information was learned is\n   closed (Section 2.2) or a new parallel
      network interface is opened\n   that alters RDNSS selection preferences.  An
      implementation SHOULD\n   ensure obsolete information is not retained in these
      events.  One\n   implementation approach to avoid unwanted/obsolete responses
      from the\n   local cache is to manage per-interface DNS caches or have interface\n
      \  information stored in the DNS cache.  An alternative approach is to\n   perform,
      possibly selective, DNS cache flushing on interface change\n   events.\n"
    title: 4.8.  Closing Network Interfaces and Local Caches
  title: 4.  Improved RDNSS Selection
- contents:
  - "5.  Example of a Node Behavior\n   Figure 7 illustrates node behavior when it
    initializes two network\n   interfaces for parallel usage and learns domain and
    network\n   information from DHCPv6 servers.\n    Application    Node      DHCPv6
    server   DHCPv6 server\n                             on interface 1  on interface
    2\n        |             |                |\n        |         +-----------+        |\n
    \  (1)  |         | open      |        |\n        |         | interface |        |\n
    \       |         +-----------+        |\n        |             |                |\n
    \  (2)  |             |---option REQ-->|\n        |             |<--option RESP--|\n
    \       |             |                |\n        |         +-----------+        |\n
    \  (3)  |         | store     |        |\n        |         | domains   |        |\n
    \       |         +-----------+        |\n        |             |                |\n
    \       |         +-----------+        |\n   (4)  |         | open      |        |\n
    \       |         | interface |        |\n        |         +-----------+        |\n
    \       |             |                |                |\n   (5)  |             |---option
    REQ------------------->|\n        |             |<--option RESP-------------------|\n
    \       |             |                |                |\n        |         +----------+
    \        |                |\n   (6)  |         | store    |         |                |\n
    \       |         | domains  |         |                |\n        |         +----------+
    \        |                |\n        |             |                |                |\n
    \               Figure 7: Illustration of Learning Domains\n   Flow explanations:\n
    \  1.  A node opens its first network interface.\n   2.  The node obtains domain
    'domain1.example.com' and IPv6 network\n       '0.8.b.d.0.1.0.0.2.ip6.arpa' for
    the new interface 1 from the\n       DHCPv6 server.\n   3.  The node stores the
    learned domains and IPv6 networks for later\n       use.\n   4.  The node opens
    its second network interface 2.\n   5.  The node obtains domain 'domain2.example.com'
    and IPv6 network\n       information, say '1.8.b.d.0.1.0.0.2.ip6.arpa' for the
    new\n       interface 2 from the DHCPv6 server.\n   6.  The node stores the learned
    domains and networks for later use.\n   Figure 8 illustrates how a resolver uses
    the learned domain\n   information.  Network information use for reverse lookups
    is not\n   illustrated, but that would be similar to the example in Figure 8.\n
    \   Application     Node     RDNSS             RDNSS\n                             on
    interface 1    on interface 2\n        |             |                |                |\n
    \  (1)  |--Name REQ-->|                |                |\n        |             |
    \               |                |\n        |      +----------------+      |                |\n
    \  (2)  |      | RDNSS          |      |                |\n        |      | prioritization
    |      |                |\n        |      +----------------+      |                |\n
    \       |             |                |                |\n   (3)  |             |------------DNS
    resolution------>|\n        |             |<--------------------------------|\n
    \       |             |                |                |\n   (4)  |<--Name resp-|
    \               |                |\n        |             |                |                |\n
    \         Figure 8: Example on Choosing Interface Based on Domain\n   Flow explanations:\n
    \  1.  An application makes a request for resolving an FQDN, e.g.,\n       'private.domain2.example.com'.\n
    \  2.  A node creates list of RDNSSes to contact and uses configured\n       RDNSS
    selection information and stored domain information on\n       prioritization
    decisions.\n   3.  The node has chosen interface 2, as it was learned earlier
    from\n       DHCPv6 that the interface 2 has domain 'domain2.example.com'.\n       The
    node then resolves the requested name using interface 2's\n       RDNSS to an
    IPv6 address.\n   4.  The node replies to the application with the resolved IPv6\n
    \      address.\n"
  title: 5.  Example of a Node Behavior
- contents:
  - "6.  Considerations for Network Administrators\n   Network administrators deploying
    private namespaces can assist\n   advanced nodes in their RDNSS selection process
    by providing the\n   information described within this document.\n   Private namespaces
    MUST be globally unique in order to keep DNS\n   unambiguous and henceforth avoid
    caching-related issues and\n   destination selection problems (see Section 2.3).
    \ Exceptions to this\n   rule are domains utilized for local name resolution (such
    as .local).\n   Private namespaces MUST only consist of subdomains of domains
    for\n   which the relevant operator provides authoritative name service.\n   Thus,
    subdomains of example.com are permitted in the private\n   namespace served by
    an operator's RDNSSes only if the same operator\n   provides a SOA record for
    example.com.\n   It is RECOMMENDED for administrators utilizing this tool to deploy\n
    \  DNSSEC for their zone in order to counter attacks against private\n   namespaces.\n"
  title: 6.  Considerations for Network Administrators
- contents:
  - "7.  IANA Considerations\n   Per this memo, IANA has assigned two new option codes.\n
    \  The first option code has been assigned for the DHCPv4 RDNSS\n   Selection
    option (146) from the \"BOOTP Vendor Extensions and DHCP\n   Options\" registry
    in the group \"Dynamic Host Configuration Protocol\n   (DHCP) and Bootstrap Protocol
    (BOOTP) Parameters\".\n   The second option code is requested to be assigned for
    the DHCPv6\n   OPTION_RDNSS_SELECTION (74) from the \"DHCP Option Codes\" registry
    in\n   the group \"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\".\n"
  title: 7.  IANA Considerations
- contents:
  - '8.  Security Considerations

    '
  - contents:
    - "8.1.  Attack Vectors\n   It is possible that attackers might try to utilize
      the DHCPv4 RDNSS\n   Selection option or the DHCPv6 OPTION_RDNSS_SELECTION option
      to\n   redirect some or all DNS queries sent by a resolver to undesired\n   destinations.
      \ The purpose of an attack might be denial of service,\n   preparation for man-in-the-middle
      attack, or something akin.\n   Attackers might try to lure specific traffic
      by advertising domains\n   and networks from very small to very large scope
      or simply by trying\n   to place the attacker's RDNSS as the highest preference
      default\n   RDNSS.\n   The best countermeasure for nodes is to implement validating
      DNSSEC-\n   aware resolvers.  Trusting validation done by an RDNSS is a\n   possibility
      only if a node trusts the RDNSS and can use a secure\n   channel for DNS messages.\n"
    title: 8.1.  Attack Vectors
  - contents:
    - "8.2.  Trust Levels of Network Interfaces\n   Trustworthiness of an interface
      and configuration information\n   received over the interface is implementation
      and/or node deployment\n   dependent, and the details of determining that trust
      are beyond the\n   scope of this specification.  Trust might, for example, be
      based on\n   the nature of the interface: an authenticated and encrypted VPN,
      or a\n   layer 2 connection to a trusted home network or to a trusted cellular\n
      \  network, might be considered trusted, while an unauthenticated and\n   unencrypted
      connection to an unknown visited network would likely be\n   considered untrusted.\n
      \  In many cases, an implementation might not be able to determine trust\n   levels
      without explicit configuration provided by the user or the\n   node's administrator.
      \ Therefore, for example, an implementation\n   might not by default trust configuration
      received even over VPN\n   interfaces.  In some occasions, standards defining
      organizations that\n   are specific to access network technology might be able
      to define\n   trust levels as part of the system design work.\n"
    title: 8.2.  Trust Levels of Network Interfaces
  - contents:
    - "8.3.  Importance of Following the Algorithm\n   Section 4 uses normative language
      for describing a node's internal\n   behavior in order to ensure that nodes
      will not open up new attack\n   vectors by accidental use of RDNSS selection
      options.  During the\n   standards work, consensus was that it is safer to not
      always enable\n   this option by default, but only when deemed useful and safe.\n"
    title: 8.3.  Importance of Following the Algorithm
  title: 8.  Security Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC2132]  Alexander, S. and R. Droms, \"DHCP Options and BOOTP Vendor\n
      \             Extensions\", RFC 2132, March 1997.\n   [RFC2317]  Eidnes, H.,
      de Groot, G., and P. Vixie, \"Classless IN-\n              ADDR.ARPA delegation\",
      BCP 20, RFC 2317, March 1998.\n   [RFC3315]  Droms, R., Bound, J., Volz, B.,
      Lemon, T., Perkins, C.,\n              and M. Carney, \"Dynamic Host Configuration
      Protocol for\n              IPv6 (DHCPv6)\", RFC 3315, July 2003.\n   [RFC3396]
      \ Lemon, T. and S. Cheshire, \"Encoding Long Options in the\n              Dynamic
      Host Configuration Protocol (DHCPv4)\", RFC 3396,\n              November 2002.\n
      \  [RFC3596]  Thomson, S., Huitema, C., Ksinant, V., and M. Souissi,\n              \"DNS
      Extensions to Support IP Version 6\", RFC 3596,\n              October 2003.\n
      \  [RFC4242]  Venaas, S., Chown, T., and B. Volz, \"Information Refresh\n              Time
      Option for Dynamic Host Configuration Protocol for\n              IPv6 (DHCPv6)\",
      RFC 4242, November 2005.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [RFC3397]  Aboba, B. and S. Cheshire, \"Dynamic
      Host Configuration\n              Protocol (DHCP) Domain Search Option\", RFC
      3397,\n              November 2002.\n   [RFC3442]  Lemon, T., Cheshire, S.,
      and B. Volz, \"The Classless\n              Static Route Option for Dynamic
      Host Configuration\n              Protocol (DHCP) version 4\", RFC 3442, December
      2002.\n   [RFC3646]  Droms, R., \"DNS Configuration options for Dynamic Host\n
      \             Configuration Protocol for IPv6 (DHCPv6)\", RFC 3646,\n              December
      2003.\n   [RFC4191]  Draves, R. and D. Thaler, \"Default Router Preferences
      and\n              More-Specific Routes\", RFC 4191, November 2005.\n   [RFC4193]
      \ Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast\n              Addresses\",
      RFC 4193, October 2005.\n   [RFC6106]  Jeong, J., Park, S., Beloeil, L., and
      S. Madanapalli,\n              \"IPv6 Router Advertisement Options for DNS Configuration\",\n
      \             RFC 6106, November 2010.\n   [RFC6147]  Bagnulo, M., Sullivan,
      A., Matthews, P., and I. van\n              Beijnum, \"DNS64: DNS Extensions
      for Network Address\n              Translation from IPv6 Clients to IPv4 Servers\",
      RFC 6147,\n              April 2011.\n   [RFC6418]  Blanchet, M. and P. Seite,
      \"Multiple Interfaces and\n              Provisioning Domains Problem Statement\",
      RFC 6418,\n              November 2011.\n   [WITHOUT-IPV6NAT]\n              Troan,
      O., Miles, D., Matsushima, S., Okimoto, T., and D.\n              Wing, \"IPv6
      Multihoming without Network Address\n              Translation\", Work in Progress,
      February 2012.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  Possible Alternative Practices for RDNSS Selection\n   On some private
    namespace deployments, explicit policies for RDNSS\n   selection are not available.
    \ This section describes ways for nodes\n   to mitigate the problem by sending
    wide-spread queries and by\n   utilizing possibly existing indirect information
    elements as hints.\n"
  - contents:
    - "A.1.  Sending Queries Out on Multiple Interfaces in Parallel\n   A possible
      current practice is to send DNS queries out of multiple\n   interfaces and pick
      up the best out of the received responses.  A\n   node can implement DNSSEC
      in order to be able to reject responses\n   that cannot be validated.  Selection
      between legitimate answers is\n   implementation specific, but replies from
      trusted RDNSSes are\n   preferred.\n   A downside of this approach is increased
      consumption of resources,\n   namely, power consumption if an interface, e.g.,
      wireless, has to be\n   brought up just for the DNS query that could have been
      resolved via a\n   cheaper interface.  Also, load on RDNSSes is increased.  However,\n
      \  local caching of results mitigates these problems, and a node might\n   also
      learn interfaces that seem to be able to provide 'better'\n   responses than
      others and prefer those, without forgetting that\n   fallback is required for
      cases when the node is connected to more\n   than one network using private
      namespaces.\n"
    title: A.1.  Sending Queries Out on Multiple Interfaces in Parallel
  - contents:
    - "A.2.  Search List Option for DNS Forward Lookup Decisions\n   A node can learn
      the special domains of attached network interfaces\n   from IPv6 Router Advertisement
      DNS Search List Option [RFC6106] or\n   DHCP search list options -- DHCPv4 Domain
      Search Option number 119\n   [RFC3397] and DHCPv6 Domain Search List Option
      number 24 [RFC3646].\n   The node behavior is very similar to that illustrated
      in the example\n   in Section 5.  While these options are not intended to be
      used in\n   RDNSS selection, they can be used by the nodes as hints for smarter\n
      \  RDNSS prioritization purposes in order to increase likelihood of fast\n   and
      successful DNS queries.\n   Overloading of existing DNS search list options
      is not without\n   problems: resolvers would obviously use the domains learned
      from\n   search lists for name resolution purposes.  This might not be a\n   problem
      in deployments where DNS search list options contain few\n   domains like 'example.com,
      private.example.com' but can become a\n   problem if many domains are configured.\n"
    title: A.2.  Search List Option for DNS Forward Lookup Decisions
  - contents:
    - "A.3.  More-Specific Routes for Reverse Lookup Decisions\n   [RFC4191] defines
      how more-specific routes can be provisioned for\n   nodes.  This information
      is not intended to be used in RDNSS\n   selection, but nevertheless, a node
      can use this information as a\n   hint about which interface would be best to
      try first for reverse\n   lookup procedures.  An RDNSS configured via the same
      interface as\n   more-specific routes is more likely capable to answer reverse
      lookup\n   questions correctly than an RDNSS of another interface.  The\n   likelihood
      of success is possibly higher if an RDNSS address is\n   received in the same
      RA [RFC6106] as the more-specific route\n   information.\n"
    title: A.3.  More-Specific Routes for Reverse Lookup Decisions
  - contents:
    - "A.4.  Longest Matching Prefix for Reverse Lookup Decisions\n   A node can utilize
      the longest matching prefix approach when deciding\n   which RDNSS to contact
      for reverse lookup purposes.  Namely, the node\n   can send a DNS query to an
      RDNSS learned over an interface having a\n   longest matching prefix to the
      address being queried.  This approach\n   can help in cases where Unique Local
      Addressing (ULA) [RFC4193]\n   addresses are used and when the queried address
      belongs to a node or\n   server within the same network (for example, intranet).\n"
    title: A.4.  Longest Matching Prefix for Reverse Lookup Decisions
  title: Appendix A.  Possible Alternative Practices for RDNSS Selection
- contents:
  - "Appendix B.  DNSSEC and Multiple Answers Validating with Different Trust\n             Anchors\n
    \  When validating DNS answers with DNSSEC, a validator might order the\n   list
    of trust anchors it uses to start validation chains, in the\n   order of the node's
    preferences for those trust anchors.  A node\n   could use this ability in order
    to select among alternative DNS\n   results from different interfaces.  Suppose
    that a node has a trust\n   anchor for the public DNS root and also has a special-purpose
    trust\n   anchor for example.com.  An answer is received on interface i1 for\n
    \  www.example.com, and the validation for that succeeds by using the\n   public
    trust anchor.  Also, an answer is received on interface i2 for\n   www.example.com,
    and the validation for that succeeds by using the\n   trust anchor for example.com.
    \ In this case, the node has evidence\n   for relying on i2 for answers in the
    example.com zone.\n"
  title: Appendix B.  DNSSEC and Multiple Answers Validating with Different Trust
- contents:
  - "Appendix C.  Pseudocode for RDNSS Selection\n   This section illustrates the
    RDNSS selection logic in C-style\n   pseudocode.  The code is not intended to
    be usable as such; it is\n   only here for illustration purposes.\n   The beginning
    of the whole procedure is a call to \"dns_query\"\n   function with a query and
    list of RDNSSes given as parameters.\n"
  - '/* This is a structure that holds all information related to an RDNSS.*/

    '
  - '/* Here we include only the information related for this illustration.*/

    '
  - 'struct rdnss

    '
  - "{\n  int prf;        /* Preference of an RDNSS.                          */\n
    \ int interface;  /* Type of an interface RDNSS was learned over.     */\n  struct
    d_and_n; /* Domains and networks information for this RDNSS. */\n"
  - '};

    '
  - "int has_special_knowledge( const struct rdnss *rdnss,\n                           const
    char *query)\n"
  - '{

    '
  - "/* This function matches the query to the domains and networks\n   information
    of the given RDNSS.  The function returns TRUE\n   if the query matches the domains
    and networks; otherwise, FALSE.   */\n"
  - "/* The implementation of this matching function\n   is left for reader, or rather
    writer.                              */\n"
  - '/* return TRUE if query matches rdnss->d_and_n, otherwise FALSE.      */

    '
  - '}

    '
  - "const struct rdnss* compare_rdnss_prf( const struct rdnss *rdnss_1,\n                                       const
    struct rdnss *rdnss_2 )\n"
  - '{

    '
  - "/* This function compares preference values of two RDNSSes and\n   returns the
    more preferred RDNSS.  The function prefers rdnss_1\n   in the case of equal preference
    values.                            */\n  if (rdnss_1->prf == HIGH_PRF) return
    rdnss_1;\n  if (rdnss_2->prf == HIGH_PRF) return rdnss_2;\n  if (rdnss_1->prf
    == MED_PRF) return rdnss_1;\n  if (rdnss_2->prf == MED_PRF) return rdnss_2;\n
    \ return rdnss_1;\n"
  - '}

    '
  - "const struct rdnss* compare_rdnss_trust( const struct rdnss *rdnss_1,\n                                         const
    struct rdnss *rdnss_2 )\n"
  - '{

    '
  - "/* This function compares trust of the two given RDNSSes.  The trust\n   is based
    on the trust on the interface RDNSS was learned on.       */\n"
  - "/* If the interface is the same, the trust is also the same,\n   and hence, function
    will return NULL to indicate lack of\n   difference in trust.                                               */\n
    \ if (rdnss_1->interface == rdnss_2->interface) return NULL;\n"
  - "/* Otherwise, implementation-specific rules define which interface\n   is considered
    more secure than the other.  The rules shown here\n   are only for illustrative
    purposes and must be overwritten by\n   real implementations.                                              */\n
    \ if (rdnss_1->interface == IF_VPN) return rdnss_1;\n  if (rdnss_2->interface
    == IF_VPN) return rdnss_2;\n  if (rdnss_1->interface == IF_CELLULAR) return rdnss_1;\n
    \ if (rdnss_2->interface == IF_CELLULAR) return rdnss_2;\n  if (rdnss_1->interface
    == IF_WLAN) return rdnss_1;\n  if (rdnss_2->interface == IF_WLAN) return rdnss_2;\n"
  - "/* Both RDNSSes are from unknown interfaces, so return NULL as\n   trust-based
    comparison is impossible.                              */\n  return NULL;\n"
  - '}

    '
  - "int compare_rdnsses ( const struct rdnss *rdnss_1,\n                      const
    struct rdnss *rdnss_2,\n                      const char *query)\n"
  - '{

    '
  - "/* This function compares two RDNSSes and decides which one is more\n   preferred
    for resolving the query.  If the rdnss_1 is more\n   preferred, the function returns
    TRUE; otherwise, FALSE.            */\n  const struct rdnss *more_trusted_rdnss
    = NULL;\n  const struct rdnss *less_trusted_rdnss = NULL;\n"
  - "/* Find out if either RDNSS is more trusted.                          */\n  more_trusted_rdnss
    = compare_rdnss_trust( rdnss_1, rdnss_2 );\n"
  - "/* Check if either was more trusted.                                  */\n  if
    (more_trusted_rdnss)\n    {\n"
  - "/* Check which RDNSS was less trusted.                                */\n      less_trusted_rdnss
    =\n          more_trusted_rdnss == rdnss_1 ? rdnss_2 : rdnss_1;\n"
  - "/* If the more trusted interface is not of low preference\n   or has special
    knowledge about the query, or the more\n   trusted is more preferred and the less
    trusted has no special\n   information, prefer more trusted.  Otherwise, prefer
    less trusted. */\n      if (more_trusted_rdnss->prf != LOW_PRF ||\n          has_special_knowledge(
    more_trusted_rdnss, query ) ||\n          (compare_rdnss_prf( more_trusted_rdnss,
    less_trusted_rdnss)\n               == more_trusted_rdnss &&\n           !has_special_knowledge(
    less_trusted_rdnss, query)))\n        {\n"
  - "/* If the more_trusted_rdnss was rdnss_1, return TRUE.                */\n          return
    more_trusted_rdnss == rdnss_1 ? TRUE : FALSE;\n        }\n      else\n        {\n"
  - "/* If the more_trusted_rdnss was rdnss_1, return TRUE.                */\n          return
    less_trusted_rdnss == rdnss_1 ? TRUE : FALSE;\n        }\n    }\n  else\n    {\n"
  - "/* There is no trust difference between RDNSSes; therefore, prefer the\n   RDNSS
    that has special knowledge.  If both have specific knowledge,\n   then prefer
    the rdnss_1.                                           */\n      if (has_special_knowledge(
    rdnss_1, query )) return TRUE;\n      if (has_special_knowledge( rdnss_2, query
    )) return FALSE;\n"
  - "/* Neither had special knowledge.  Therefore, return TRUE if\n   rdnss_1 is more
    preferred; otherwise, return FALSE                 */\n      return compare_rdnss_prf(
    rdnss_1 , rdnss_2 )\n          == rdnss_1 ? TRUE : FALSE;\n    }\n"
  - '}

    '
  - "void bubble_sort_rdnsses( struct rdnss rdnss_list[],\n                          const
    int rdnsses,\n                          const char* query)\n"
  - '{

    '
  - "/* This function implements a bubble sort to arrange\n   RDNSSes in rdnss_list
    into preference order.                       */\n  int i;\n  int swapped = 0;\n
    \ struct rdnss rdnss_swap;\n  do\n    {\n"
  - "/* Clear swapped-indicator.                                           */\n      swapped
    = FALSE;\n"
  - "/* Go through the RDNSS list.                                         */\n      for
    (i = 0; i < rdnsses-1; i++)\n        {\n"
  - "/* Check if the next two items are in the right order, i.e.,\n   more preferred
    before less preferred.                              */\n          if (compare_rdnsses(
    &rdnss_list[i],\n                               &rdnss_list[i+1], query) == FALSE)\n
    \           {\n"
  - "/* The order between two was not right, so swap these two RDNSSes.    */\n              rdnss_swap
    = rdnss_list[i];\n              rdnss_list[i] = rdnss_list[i+1];\n              rdnss_list[i+1]
    = rdnss_swap;\n              swapped = TRUE;\n            }\n        }\n    }
    while (swapped);\n"
  - "/* No more swaps, which means the rdnss_list is now sorted\n   into preference
    order.                                             */\n"
  - '}

    '
  - "struct hostent *dns_query( struct rdnss rdnss_list[],\n                           const
    int rdnsses,\n                           const char* query )\n"
  - '{

    '
  - "/* Perform address resolution for the query.                          */\n  int
    i;\n  struct hostent response;\n"
  - '/* Sort the RDNSSes into preference order.                            */

    '
  - "/* This is the function with which this pseudocode starts.            */\n  bubble_sort_rdnsses(
    &rdnss_list[0], rdnsses, query );\n"
  - "/* Go thourgh all RDNSSes or until valid response is found.           */\n  for
    (i = 0; i < rdnsses; i++)\n    {\n"
  - "/* Use the highest preference RDNSS first.                            */\n      response
    = send_and_validate_dns_query( rndss_list[i], query);\n"
  - "/* Check if DNSSEC validation is in use, and if so, validate the\n   received
    response.                                                 */\n      if (dnssec_in_use)\n
    \       {\n          response = dnssec_validate(response);\n"
  - "/* If response is validated, use that.  Otherwise, proceed to next\n   RDNSS.
    \                                                            */\n          if
    (response) return response;\n          else continue;\n        }\n"
  - "/* If acceptable response has been found, return it.                  */\n      if
    (response) return response;\n    }\n  return NULL;\n"
  - '}

    '
  title: Appendix C.  Pseudocode for RDNSS Selection
- contents:
  - "Appendix D.  Acknowledgements\n   The authors would like to thank the following
    people for their\n   valuable feedback and improvement ideas: Mark Andrews, Jari
    Arkko,\n   Marcelo Bagnulo, Brian Carpenter, Stuart Cheshire, Lars Eggert,\n   Stephan
    Farrell, Tomohiro Fujisaki, Brian Haberman, Peter Koch,\n   Suresh Krishnan, Murray
    Kucherawy, Barry Leiba, Edward Lewis, Kurtis\n   Lindqvist, Arifumi Matsumoto,
    Erik Nordmark, Steve Padgett, Fabien\n   Rapin, Matthew Ryan, Robert Sparks, Dave
    Thaler, Sean Turner,\n   Margaret Wasserman, Dan Wing, and Dec Wojciech.  Ted
    Lemon and Julien\n   Laganier receive special thanks for their contributions to
    security\n   considerations.\n"
  title: Appendix D.  Acknowledgements
- contents:
  - "Authors' Addresses\n   Teemu Savolainen\n   Nokia\n   Hermiankatu 12 D\n   Tampere
    \ FI-33720\n   Finland\n   EMail: teemu.savolainen@nokia.com\n   Jun-ya Kato\n
    \  NTT\n   9-11, Midori-Cho 3-Chome Musashino-Shi\n   Tokyo  180-8585\n   Japan\n
    \  EMail: kato@syce.net\n   Ted Lemon\n   Nominum, Inc.\n   2000 Seaport Boulevard\n
    \  Redwood City, CA  94063\n   USA\n   Phone: +1 650 381 6000\n   EMail: Ted.Lemon@nominum.com\n"
  title: Authors' Addresses
