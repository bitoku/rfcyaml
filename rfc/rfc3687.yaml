- title: __initial_text__
  contents:
  - "             Lightweight Directory Access Protocol (LDAP)\n                 \
    \  and X.500 Component Matching Rules\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The syntaxes of attributes in a Lightweight Directory Access Protocol\n\
    \   (LDAP) or X.500 directory range from simple data types, such as text\n   string,\
    \ integer, or boolean, to complex structured data types, such\n   as the syntaxes\
    \ of the directory schema operational attributes.\n   Matching rules defined for\
    \ the complex syntaxes usually only provide\n   the most immediately useful matching\
    \ capability.  This document\n   defines generic matching rules that can match\
    \ any user selected\n   component parts in an attribute value of any arbitrarily\
    \ complex\n   attribute syntax.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Conventions. . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n   3.  ComponentAssertion . . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n       3.1.  Component Reference. . . . . . . . . . . . . . . .\
    \ . . .  6\n             3.1.1.  Component Type Substitutions . . . . . . . .\
    \ . .  7\n             3.1.2.  Referencing SET, SEQUENCE and CHOICE Components.\
    \  8\n             3.1.3.  Referencing SET OF and SEQUENCE OF Components. .  9\n\
    \             3.1.4.  Referencing Components of Parameterized Types. . 10\n  \
    \           3.1.5.  Component Referencing Example. . . . . . . . . . 10\n    \
    \         3.1.6.  Referencing Components of Open Types . . . . . . 12\n      \
    \               3.1.6.1. Open Type Referencing Example . . . . . 12\n        \
    \     3.1.7.  Referencing Contained Types. . . . . . . . . . . 14\n          \
    \           3.1.7.1. Contained Type Referencing Example. . . 14\n       3.2. \
    \ Matching of Components . . . . . . . . . . . . . . . . . 15\n             3.2.1.\
    \  Applicability of Existing Matching Rules . . . . 17\n                     3.2.1.1.\
    \ String Matching . . . . . . . . . . . . 17\n                     3.2.1.2. Telephone\
    \ Number Matching . . . . . . . 17\n                     3.2.1.3. Distinguished\
    \ Name Matching . . . . . . 18\n             3.2.2.  Additional Useful Matching\
    \ Rules . . . . . . . . 18\n                     3.2.2.1. The rdnMatch Matching\
    \ Rule. . . . . . . 18\n                     3.2.2.2. The presentMatch Matching\
    \ Rule. . . . . 19\n             3.2.3.  Summary of Useful Matching Rules . .\
    \ . . . . . . 20\n   4.  ComponentFilter. . . . . . . . . . . . . . . . . . .\
    \ . . . . . 21\n   5.  The componentFilterMatch Matching Rule . . . . . . . .\
    \ . . . . 22\n   6.  Equality Matching of Complex Components. . . . . . . . .\
    \ . . . 24\n       6.1.  The OpenAssertionType Syntax . . . . . . . . . . . .\
    \ . . 24\n       6.2.  The allComponentsMatch Matching Rule . . . . . . . . .\
    \ . 25\n       6.3.  Deriving Component Equality Matching Rules . . . . . . .\
    \ 27\n       6.4.  The directoryComponentsMatch Matching Rule . . . . . . . 28\n\
    \   7.  Component Matching Examples. . . . . . . . . . . . . . . . . . 30\n  \
    \ 8.  Security Considerations. . . . . . . . . . . . . . . . . . . . 37\n   9.\
    \  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 37\n   10. IANA\
    \ Considerations. . . . . . . . . . . . . . . . . . . . . . 37\n   11. References\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . 38\n       11.1.  Normative\
    \ References. . . . . . . . . . . . . . . . . . 38\n       11.2.  Informative\
    \ References. . . . . . . . . . . . . . . . . 40\n   12. Intellectual Property\
    \ Statement. . . . . . . . . . . . . . . . 40\n   13. Author's Address . . . .\
    \ . . . . . . . . . . . . . . . . . . . 41\n   14. Full Copyright Statement .\
    \ . . . . . . . . . . . . . . . . . . 42\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The structure or data type of data held in an attribute\
    \ of a\n   Lightweight Directory Access Protocol (LDAP) [7] or X.500 [19]\n  \
    \ directory is described by the attribute's syntax.  Attribute syntaxes\n   range\
    \ from simple data types, such as text string, integer, or\n   boolean, to complex\
    \ data types, for example, the syntaxes of the\n   directory schema operational\
    \ attributes.\n   In X.500, the attribute syntaxes are explicitly described by\
    \ Abstract\n   Syntax Notation One (ASN.1) [13] type definitions.  ASN.1 type\n\
    \   notation has a number of simple data types (e.g., PrintableString,\n   INTEGER,\
    \ BOOLEAN), and combining types (i.e., SET, SEQUENCE, SET OF,\n   SEQUENCE OF,\
    \ and CHOICE) for constructing arbitrarily complex data\n   types from simpler\
    \ component types.  In LDAP, the attribute syntaxes\n   are usually described\
    \ in Augmented Backus-Naur Form (ABNF) [2],\n   though there is an implied association\
    \ between the LDAP attribute\n   syntaxes and the X.500 ASN.1 types.  To a large\
    \ extent, the data\n   types of attribute values in either an LDAP or X.500 directory\
    \ are\n   described by ASN.1 types.  This formal description can be exploited\n\
    \   to identify component parts of an attribute value for a variety of\n   purposes.\
    \  This document addresses attribute value matching.\n   With any complex attribute\
    \ syntax there is normally a requirement to\n   partially match an attribute value\
    \ of that syntax by matching only\n   selected components of the value.  Typically,\
    \ matching rules specific\n   to the attribute syntax are defined to fill this\
    \ need.  These highly\n   specific matching rules usually only provide the most\
    \ immediately\n   useful matching capability.  Some complex attribute syntaxes\
    \ don't\n   even have an equality matching rule let alone any additional matching\n\
    \   rules for partial matching.  This document defines a generic way of\n   matching\
    \ user selected components in an attribute value of any\n   arbitrarily complex\
    \ attribute syntax, where that syntax is described\n   using ASN.1 type notation.\
    \  All of the type notations defined in\n   X.680 [13] are supported.\n   Section\
    \ 3 describes the ComponentAssertion, a testable assertion\n   about the value\
    \ of a component of an attribute value of any complex\n   syntax.\n   Section\
    \ 4 introduces the ComponentFilter assertion, which is an\n   expression of ComponentAssertions.\
    \  The ComponentFilter enables more\n   powerful filter matching of components\
    \ in an attribute value.\n   Section 5 defines the componentFilterMatch matching\
    \ rule, which\n   enables a ComponentFilter to be evaluated against attribute\
    \ values.\n   Section 6 defines matching rules for component-wise equality matching\n\
    \   of attribute values of any syntax described by an ASN.1 type\n   definition.\n\
    \   Examples showing the usage of componentFilterMatch are in Section 7.\n   For\
    \ a new attribute syntax, the Generic String Encoding Rules [9] and\n   the specifications\
    \ in sections 3 to 6 of this document make it\n   possible to fully and precisely\
    \ define the LDAP-specific encoding,\n   the LDAP and X.500 binary encoding (and\
    \ possibly other ASN.1\n   encodings in the future), a suitable equality matching\
    \ rule, and a\n   comprehensive collection of component matching capabilities,\
    \ by\n   simply writing down an ASN.1 type definition for the syntax.  These\n\
    \   implicit definitions are also automatically extended if the ASN.1\n   type\
    \ is later extended.  The algorithmic relationship between the\n   ASN.1 type\
    \ definition, the various encodings and the component\n   matching behaviour makes\
    \ directory server implementation support for\n   the component matching rules\
    \ amenable to automatic code generation\n   from ASN.1 type definitions.\n   Schema\
    \ designers have the choice of storing related items of data as\n   a single attribute\
    \ value of a complex syntax in some entry, or as a\n   subordinate entry where\
    \ the related data items are stored as separate\n   attribute values of simpler\
    \ syntaxes.  The inability to search\n   component parts of a complex syntax has\
    \ been used as an argument for\n   favouring the subordinate entries approach.\
    \  The component matching\n   rules provide the analogous matching capability\
    \ on an attribute value\n   of a complex syntax that a search filter has on a\
    \ subordinate entry.\n   Most LDAP syntaxes have corresponding ASN.1 type definitions,\
    \ though\n   they are usually not reproduced or referenced alongside the formal\n\
    \   definition of the LDAP syntax.  Syntaxes defined with only a\n   character\
    \ string encoding, i.e., without an explicit or implied\n   corresponding ASN.1\
    \ type definition, cannot use the component\n   matching capabilities described\
    \ in this document unless and until a\n   semantically equivalent ASN.1 type definition\
    \ is defined for them.\n"
- title: 2.  Conventions
  contents:
  - "2.  Conventions\n   Throughout this document \"type\" shall be taken to mean\
    \ an ASN.1 type\n   unless explicitly qualified as an attribute type, and \"value\"\
    \ shall\n   be taken to mean an ASN.1 value unless explicitly qualified as an\n\
    \   attribute value.\n   Note that \"ASN.1 value\" does not mean a Basic Encoding\
    \ Rules (BER)\n   [17] encoded value.  The ASN.1 value is an abstract concept\
    \ that is\n   independent of any particular encoding.  BER is just one possible\n\
    \   encoding of an ASN.1 value.  The component matching rules operate at\n   the\
    \ abstract level without regard for the possible encodings of a\n   value.\n \
    \  Attribute type and matching rule definitions in this document are\n   provided\
    \ in both the X.500 [10] and LDAP [4] description formats.\n   Note that the LDAP\
    \ descriptions have been rendered with additional\n   white-space and line breaks\
    \ for the sake of readability.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\" and\
    \ \"MAY\" in this document are\n   to be interpreted as described in BCP 14, RFC\
    \ 2119 [1].  The key word\n   \"OPTIONAL\" is exclusively used with its ASN.1\
    \ meaning.\n"
- title: 3.  ComponentAssertion
  contents:
  - "3.  ComponentAssertion\n   A ComponentAssertion is an assertion about the presence,\
    \ or values\n   of, components within an ASN.1 value, i.e., an instance of an\
    \ ASN.1\n   type.  The ASN.1 value is typically an attribute value, where the\n\
    \   ASN.1 type is the syntax of the attribute.  However, a\n   ComponentAssertion\
    \ may also be applied to a component part of an\n   attribute value.  The assertion\
    \ evaluates to either TRUE, FALSE or\n   Undefined for each tested ASN.1 value.\n\
    \   A ComponentAssertion is described by the following ASN.1 type\n   (assumed\
    \ to be defined with \"EXPLICIT TAGS\" in force):\n      ComponentAssertion ::=\
    \ SEQUENCE {\n          component         ComponentReference (SIZE(1..MAX)) OPTIONAL,\n\
    \          useDefaultValues  BOOLEAN DEFAULT TRUE,\n          rule           \
    \   MATCHING-RULE.&id,\n          value             MATCHING-RULE.&AssertionType\
    \ }\n      ComponentReference ::= UTF8String\n   MATCHING-RULE.&id equates to\
    \ the OBJECT IDENTIFIER of a matching\n   rule.  MATCHING-RULE.&AssertionType\
    \ is an open type (formerly known\n   as the ANY type).\n   The \"component\"\
    \ field of a ComponentAssertion identifies which\n   component part of a value\
    \ of some ASN.1 type is to be tested, the\n   \"useDefaultValues\" field indicates\
    \ whether DEFAULT values are to be\n   substituted for absent component values,\
    \ the \"rule\" field indicates\n   how the component is to be tested, and the\
    \ \"value\" field is an\n   asserted ASN.1 value against which the component is\
    \ tested.  The\n   ASN.1 type of the asserted value is determined by the chosen\
    \ rule.\n   The fields of a ComponentAssertion are described in detail in the\n\
    \   following sections.\n"
- title: 3.1.  Component Reference
  contents:
  - "3.1.  Component Reference\n   The component field in a ComponentAssertion is\
    \ a UTF-8 character\n   string [6] whose textual content is a component reference,\n\
    \   identifying a component part of some ASN.1 type or value.  A\n   component\
    \ reference conforms to the following ABNF [2], which extends\n   the notation\
    \ defined in Clause 14 of X.680 [13]:\n      component-reference = ComponentId\
    \ *( \".\" ComponentId )\n      ComponentId         = identifier /\n         \
    \                   from-beginning /\n                            count /\n  \
    \                          from-end /       ; extends Clause 14\n            \
    \                content /        ; extends Clause 14\n                      \
    \      select /         ; extends Clause 14\n                            all\n\
    \      identifier          = lowercase *alphanumeric\n                       \
    \        *(hyphen 1*alphanumeric)\n      alphanumeric        = uppercase / lowercase\
    \ / decimal-digit\n      uppercase           = %x41-5A  ; \"A\" to \"Z\"\n   \
    \   lowercase           = %x61-7A  ; \"a\" to \"z\"\n      hyphen            \
    \  = \"-\"\n      from-beginning      = positive-number\n      count         \
    \      = \"0\"\n      from-end            = \"-\" positive-number\n      content\
    \             = %x63.6F.6E.74.65.6E.74 ; \"content\"\n      select           \
    \   = \"(\" Value *( \",\" Value ) \")\"\n      all                 = \"*\"\n\
    \      positive-number     = non-zero-digit *decimal-digit\n      decimal-digit\
    \       = %x30-39  ; \"0\" to \"9\"\n      non-zero-digit      = %x31-39  ; \"\
    1\" to \"9\"\n   An <identifier> conforms to the definition of an identifier in\
    \ ASN.1\n   notation (Clause 11.3 of X.680 [13]).  It begins with a lowercase\n\
    \   letter and is followed by zero or more letters, digits, and hyphens.\n   A\
    \ hyphen is not permitted to be the last character and a hyphen is\n   not permitted\
    \ to be followed by another hyphen.\n   The <Value> rule is described by the Generic\
    \ String Encoding Rules\n   (GSER) [9].\n   A component reference is a sequence\
    \ of one or more ComponentIds where\n   each successive ComponentId identifies\
    \ either an inner component at\n   the next level of nesting of an ASN.1 combining\
    \ type, i.e., SET,\n   SEQUENCE, SET OF, SEQUENCE OF, or CHOICE, or a specific\
    \ type within\n   an ASN.1 open type.\n   A component reference is always considered\
    \ in the context of a\n   particular complex ASN.1 type.  When applied to the\
    \ ASN.1 type the\n   component reference identifies a specific component type.\
    \  When\n   applied to a value of the ASN.1 type a component reference identifies\n\
    \   zero, one or more component values of that component type.  The\n   component\
    \ values are potentially in a DEFAULT value if\n   useDefaultValues is TRUE. \
    \ The specific component type identified by\n   the component reference determines\
    \ what matching rules are capable of\n   being used to match the component values.\n\
    \   The component field in a ComponentAssertion may also be absent, in\n   which\
    \ case the identified component type is the ASN.1 type to which\n   the ComponentAssertion\
    \ is applied, and the identified component value\n   is the whole ASN.1 value.\n\
    \   A valid component reference for a particular complex ASN.1 type is\n   constructed\
    \ by starting with the outermost combining type and\n   repeatedly selecting one\
    \ of the permissible forms of ComponentId to\n   identify successively deeper\
    \ nested components.  A component\n   reference MAY identify a component with\
    \ a complex ASN.1 type, i.e.,\n   it is not required that the component type identified\
    \ by a component\n   reference be a simple ASN.1 type.\n"
- title: 3.1.1.  Component Type Substitutions
  contents:
  - "3.1.1.  Component Type Substitutions\n   ASN.1 type notation has a number of\
    \ constructs for referencing other\n   defined types, and constructs that are\
    \ irrelevant for matching\n   purposes.  These constructs are not represented\
    \ in a component\n   reference in any way and substitutions of the component type\
    \ are\n   performed to eliminate them from further consideration.  These\n   substitutions\
    \ automatically occur prior to each ComponentId, whether\n   constructing or interpreting\
    \ a component reference, but do not occur\n   after the last ComponentId, except\
    \ as allowed by Section 3.2.\n   If the ASN.1 type is an ASN.1 type reference\
    \ then the component type\n   is taken to be the actual definition on the right\
    \ hand side of the\n   type assignment for the referenced type.\n   If the ASN.1\
    \ type is a tagged type then the component type is taken\n   to be the type without\
    \ the tag.\n   If the ASN.1 type is a constrained type (see X.680 [13] and X.682\n\
    \   [15] for the details of ASN.1 constraint notation) then the component\n  \
    \ type is taken to be the type without the constraint.\n   If the ASN.1 type is\
    \ an ObjectClassFieldType (Clause 14 of X.681\n   [14]) that denotes a specific\
    \ ASN.1 type (e.g., MATCHING-RULE.&id\n   denotes the OBJECT IDENTIFIER type)\
    \ then the component type is taken\n   to be the denoted type.  Section 3.1.6\
    \ describes the case where the\n   ObjectClassFieldType denotes an open type.\n\
    \   If the ASN.1 type is a selection type other than one used in the list\n  \
    \ of components for a SET or SEQUENCE type then the component type is\n   taken\
    \ to be the selected alternative type from the named CHOICE.\n   If the ASN.1\
    \ type is a TypeFromObject (Clause 15 of X.681 [14]) then\n   the component type\
    \ is taken to be the denoted type.\n   If the ASN.1 type is a ValueSetFromObjects\
    \ (Clause 15 of X.681 [14])\n   then the component type is taken to be the governing\
    \ type of the\n   denoted values.\n"
- title: 3.1.2.  Referencing SET, SEQUENCE and CHOICE Components
  contents:
  - "3.1.2.  Referencing SET, SEQUENCE and CHOICE Components\n   If the ASN.1 type\
    \ is a SET or SEQUENCE type then the <identifier>\n   form of ComponentId may\
    \ be used to identify the component type within\n   that SET or SEQUENCE having\
    \ that identifier.  If <identifier>\n   references an OPTIONAL component type\
    \ and that component is not\n   present in a particular value then there are no\
    \ corresponding\n   component values.  If <identifier> references a DEFAULT component\n\
    \   type and useDefaultValues is TRUE (the default setting for\n   useDefaultValues)\
    \ and that component is not present in a particular\n   value then the component\
    \ value is taken to be the default value.  If\n   <identifier> references a DEFAULT\
    \ component type and useDefaultValues\n   is FALSE and that component is not present\
    \ in a particular value then\n   there are no corresponding component values.\n\
    \   If the ASN.1 type is a CHOICE type then the <identifier> form of\n   ComponentId\
    \ may be used to identify the alternative type within that\n   CHOICE having that\
    \ identifier.  If <identifier> references an\n   alternative other than the one\
    \ used in a particular value then there\n   are no corresponding component values.\n\
    \   The COMPONENTS OF notation in Clause 24 of X.680 [13] augments the\n   defined\
    \ list of components in a SET or SEQUENCE type by including all\n   the components\
    \ of another defined SET or SEQUENCE type respectively.\n   These included components\
    \ are referenced directly by identifier as\n   though they were defined in-line\
    \ in the SET or SEQUENCE type\n   containing the COMPONENTS OF notation.\n   The\
    \ SelectionType (Clause 29 of X.680 [13]), when used in the list of\n   components\
    \ for a SET or SEQUENCE type, includes a single component\n   from a defined CHOICE\
    \ type.  This included component is referenced\n   directly by identifier as though\
    \ it was defined in-line in the SET or\n   SEQUENCE type.\n   The REAL type is\
    \ treated as though it is the SEQUENCE type defined in\n   Clause 20.5 of X.680\
    \ [13].\n   The EMBEDDED PDV type is treated as though it is the SEQUENCE type\n\
    \   defined in Clause 33.5 of X.680 [13].\n   The EXTERNAL type is treated as\
    \ though it is the SEQUENCE type\n   defined in Clause 8.18.1 of X.690 [17].\n\
    \   The unrestricted CHARACTER STRING type is treated as though it is the\n  \
    \ SEQUENCE type defined in Clause 40.5 of X.680 [13].\n   The INSTANCE OF type\
    \ is treated as though it is the SEQUENCE type\n   defined in Annex C of X.681\
    \ [14].\n   The <identifier> form MUST NOT be used on any other ASN.1 type.\n"
- title: 3.1.3.  Referencing SET OF and SEQUENCE OF Components
  contents:
  - "3.1.3.  Referencing SET OF and SEQUENCE OF Components\n   If the ASN.1 type is\
    \ a SET OF or SEQUENCE OF type then the\n   <from-beginning>, <from-end>, <count>\
    \ and <all> forms of ComponentId\n   may be used.\n   The <from-beginning> form\
    \ of ComponentId may be used to identify one\n   instance (i.e., value) of the\
    \ component type of the SET OF or\n   SEQUENCE OF type (e.g., if Foo ::= SET OF\
    \ Bar, then Bar is the\n   component type), where the instances are numbered from\
    \ one upwards.\n   If <from-beginning> references a higher numbered instance than\
    \ the\n   last instance in a particular value of the SET OF or SEQUENCE OF type\n\
    \   then there is no corresponding component value.\n   The <from-end> form of\
    \ ComponentId may be used to identify one\n   instance of the component type of\
    \ the SET OF or SEQUENCE OF type,\n   where \"-1\" is the last instance, \"-2\"\
    \ is the second last instance,\n   and so on.  If <from-end> references a lower\
    \ numbered instance than\n   the first instance in a particular value of the SET\
    \ OF or SEQUENCE OF\n   type then there is no corresponding component value.\n\
    \   The <count> form of ComponentId identifies a notional count of the\n   number\
    \ of instances of the component type in a value of the SET OF or\n   SEQUENCE\
    \ OF type.  This count is not explicitly represented but for\n   matching purposes\
    \ it has an assumed ASN.1 type of INTEGER (0..MAX).\n   A ComponentId of the <count>\
    \ form, if used, MUST be the last\n   ComponentId in a component reference.\n\
    \   The <all> form of ComponentId may be used to simultaneously identify\n   all\
    \ instances of the component type of the SET OF or SEQUENCE OF\n   type.  It is\
    \ through the <all> form that a component reference can\n   identify more than\
    \ one component value.  However, if a particular\n   value of the SET OF or SEQUENCE\
    \ OF type is an empty list, then there\n   are no corresponding component values.\n\
    \   Where multiple component values are identified, the remaining\n   ComponentIds\
    \ in the component reference, if any, can identify zero,\n   one or more subcomponent\
    \ values for each of the higher level\n   component values.\n   The corresponding\
    \ ASN.1 type for the <from-beginning>, <from-end>,\n   and <all> forms of ComponentId\
    \ is the component type of the SET OF or\n   SEQUENCE OF type.\n   The <from-beginning>,\
    \ <count>, <from-end> and <all> forms MUST NOT be\n   used on ASN.1 types other\
    \ than SET OF or SEQUENCE OF.\n"
- title: 3.1.4.  Referencing Components of Parameterized Types
  contents:
  - "3.1.4.  Referencing Components of Parameterized Types\n   A component reference\
    \ cannot be formed for a parameterized type\n   unless the type has been used\
    \ with actual parameters, in which case\n   the type is treated as though the\
    \ DummyReferences [16] have been\n   substituted with the actual parameters.\n"
- title: 3.1.5.  Component Referencing Example
  contents:
  - "3.1.5.  Component Referencing Example\n   Consider the following ASN.1 type definitions.\n\
    \      ExampleType ::= SEQUENCE {\n          part1       [0] INTEGER,\n      \
    \    part2       [1] ExampleSet,\n          part3       [2] SET OF OBJECT IDENTIFIER,\n\
    \          part4       [3] ExampleChoice }\n      ExampleSet ::= SET {\n     \
    \     option      PrintableString,\n          setting     BOOLEAN }\n      ExampleChoice\
    \ ::= CHOICE {\n          eeny-meeny  BIT STRING,\n          miney-mo    OCTET\
    \ STRING }\n   Following are component references constructed with respect to\
    \ the\n   type ExampleType.\n   The component reference \"part1\" identifies a\
    \ component of a value of\n   ExampleType having the ASN.1 tagged type [0] INTEGER.\n\
    \   The component reference \"part2\" identifies a component of a value of\n \
    \  ExampleType having the ASN.1 type of [1] ExampleSet\n   The component reference\
    \ \"part2.option\" identifies a component of a\n   value of ExampleType having\
    \ the ASN.1 type of PrintableString.  A\n   ComponentAssertion could also be applied\
    \ to a value of ASN.1 type\n   ExampleSet, in which case the component reference\
    \ \"option\" would\n   identify the same kind of information.\n   The component\
    \ reference \"part3\" identifies a component of a value of\n   ExampleType having\
    \ the ASN.1 type of [2] SET OF OBJECT IDENTIFIER.\n   The component reference\
    \ \"part3.2\" identifies the second instance of\n   the part3 SET OF.  The instance\
    \ has the ASN.1 type of OBJECT\n   IDENTIFIER.\n   The component reference \"\
    part3.0\" identifies the count of the number\n   of instances in the part3 SET\
    \ OF.  The count has the corresponding\n   ASN.1 type of INTEGER (0..MAX).\n \
    \  The component reference \"part3.*\" identifies all the instances in the\n \
    \  part3 SET OF.  Each instance has the ASN.1 type of OBJECT IDENTIFIER.\n   The\
    \ component reference \"part4\" identifies a component of a value of\n   ExampleType\
    \ having the ASN.1 type of [3] ExampleChoice.\n   The component reference \"part4.miney-mo\"\
    \ identifies a component of a\n   value of ExampleType having the ASN.1 type of\
    \ OCTET STRING.\n"
- title: 3.1.6.  Referencing Components of Open Types
  contents:
  - "3.1.6.  Referencing Components of Open Types\n   If a sequence of ComponentIds\
    \ identifies an ObjectClassFieldType\n   denoting an open type (e.g., ATTRIBUTE.&Type\
    \ denotes an open type)\n   then the ASN.1 type of the component varies.  An open\
    \ type is\n   typically constrained by some other component(s) in an outer\n \
    \  enclosing type, either formally through the use of a component\n   relation\
    \ constraint [15], or informally in the accompanying text, so\n   the actual ASN.1\
    \ type of a value of the open type will generally be\n   known.  The constraint\
    \ will also limit the range of permissible\n   types.  The <select> form of ComponentId\
    \ may be used to identify one\n   of these permissible types in an open type.\
    \  Subcomponents of that\n   type can then be identified with further ComponentIds.\n\
    \   The other components constraining the open type are termed the\n   referenced\
    \ components [15].  The <select> form contains a list of one\n   or more values\
    \ which take the place of the value(s) of the referenced\n   component(s) to uniquely\
    \ identify one of the permissible types of the\n   open type.\n   Where the open\
    \ type is constrained by a component relation\n   constraint, there is a <Value>\
    \ in the <select> form for each of the\n   referenced components in the component\
    \ relation constraint, appearing\n   in the same order.  The ASN.1 type of each\
    \ of these values is the\n   same as the ASN.1 type of the corresponding referenced\
    \ component.\n   The type of a referenced component is potentially any ASN.1 type\n\
    \   however it is typically an OBJECT IDENTIFIER or INTEGER, which means\n   that\
    \ the <Value> in the <select> form of ComponentId will nearly\n   always be an\
    \ <ObjectIdentifierValue> or <IntegerValue> [9].\n   Furthermore, component relation\
    \ constraints typically have only one\n   referenced component.\n   Where the\
    \ open type is not constrained by a component relation\n   constraint, the specification\
    \ introducing the syntax containing the\n   open type should explicitly nominate\
    \ the referenced components and\n   their order, so that the <select> form can\
    \ be used.\n   If an instance of <select> contains a value other than the value\
    \ of\n   the referenced component used in a particular value of the outer\n  \
    \ enclosing type then there are no corresponding component values for\n   the\
    \ open type.\n"
- title: 3.1.6.1.  Open Type Referencing Example
  contents:
  - "3.1.6.1.  Open Type Referencing Example\n   The ASN.1 type AttributeTypeAndValue\
    \ [10] describes a single\n   attribute value of a nominated attribute type.\n\
    \      AttributeTypeAndValue ::= SEQUENCE {\n          type    ATTRIBUTE.&id ({SupportedAttributes}),\n\
    \          value   ATTRIBUTE.&Type ({SupportedAttributes}{@type}) }\n   ATTRIBUTE.&id\
    \ denotes an OBJECT IDENTIFIER and\n   ({SupportedAttributes}) constrains the\
    \ OBJECT IDENTIFIER to be a\n   supported attribute type.\n   ATTRIBUTE.&Type\
    \ denotes an open type, in this case an attribute\n   value, and ({SupportedAttributes}{@type})\
    \ is a component relation\n   constraint that constrains the open type to be of\
    \ the attribute\n   syntax for the attribute type.  The component relation constraint\n\
    \   references only the \"type\" component, which has the ASN.1 type of\n   OBJECT\
    \ IDENTIFIER, thus if the <select> form of ComponentId is used\n   to identify\
    \ attribute values of specific attribute types it will\n   contain a single OBJECT\
    \ IDENTIFIER value.\n   The component reference \"value\" on AttributeTypeAndValue\
    \ refers to\n   the open type.\n   One of the X.500 standard attributes is facsimileTelephoneNumber\n\
    \   [12], which is identified with the OBJECT IDENTIFIER 2.5.4.23, and is\n  \
    \ defined to have the following syntax.\n      FacsimileTelephoneNumber ::= SEQUENCE\
    \ {\n          telephoneNumber PrintableString(SIZE(1..ub-telephone-number)),\n\
    \          parameters      G3FacsimileNonBasicParameters OPTIONAL }\n   The component\
    \ reference \"value.(2.5.4.23)\" on AttributeTypeAndValue\n   specifies an attribute\
    \ value with the FacsimileTelephoneNumber\n   syntax.\n   The component reference\
    \ \"value.(2.5.4.23).telephoneNumber\" on\n   AttributeTypeAndValue identifies\
    \ the telephoneNumber component of a\n   facsimileTelephoneNumber attribute value.\
    \  The component reference\n   \"value.(facsimileTelephoneNumber)\" is equivalent\
    \ to\n   \"value.(2.5.4.23)\".\n   If the AttributeTypeAndValue ASN.1 value contains\
    \ an attribute type\n   other than facsimileTelephoneNumber then there are no\
    \ corresponding\n   component values for the component references \"value.(2.5.4.23)\"\
    \ and\n   \"value.(2.5.4.23).telephoneNumber\".\n"
- title: 3.1.7.  Referencing Contained Types
  contents:
  - "3.1.7.  Referencing Contained Types\n   Sometimes the contents of a BIT STRING\
    \ or OCTET STRING value are\n   required to be the encodings of other ASN.1 values\
    \ of specific ASN.1\n   types.  For example, the extnValue component of the Extension\
    \ type\n   component in the Certificate type [11] is an OCTET STRING that is\n\
    \   required to contain a Distinguished Encoding Rules (DER) [17]\n   encoding\
    \ of a certificate extension value.  It is useful to be able\n   to refer to the\
    \ embedded encoded value and its components.  An\n   embedded encoded value is\
    \ here referred to as a contained value and\n   its associated type as the contained\
    \ type.\n   If the ASN.1 type is a BIT STRING or OCTET STRING type containing\n\
    \   encodings of other ASN.1 values then the <content> form of\n   ComponentId\
    \ may be used to identify the contained type.\n   Subcomponents of that type can\
    \ then be identified with further\n   ComponentIds.\n   The contained type may\
    \ be (effectively) an open type, constrained by\n   some other component in an\
    \ outer enclosing type (e.g., in a\n   certificate Extension, extnValue is constrained\
    \ by the chosen\n   extnId).  In these cases the next ComponentId, if any, MUST\
    \ be of the\n   <select> form.\n   For the purpose of building component references,\
    \ the content of the\n   extnValue OCTET STRING in the Extension type is assumed\
    \ to be an open\n   type having a notional component relation constraint with\
    \ the extnId\n   component as the single referenced component, i.e.,\n      EXTENSION.&ExtnType\
    \ ({ExtensionSet}{@extnId})\n   The data-value component of the associated types\
    \ for the EMBEDDED PDV\n   and CHARACTER STRING types is an OCTET STRING containing\
    \ the encoding\n   of a data value described by the identification component.\
    \  For the\n   purpose of building component references, the content of the\n\
    \   data-value OCTET STRING in these types is assumed to be an open type\n   having\
    \ a notional component relation constraint with the\n   identification component\
    \ as the single referenced component.\n"
- title: 3.1.7.1.  Contained Type Referencing Example
  contents:
  - "3.1.7.1.  Contained Type Referencing Example\n   The Extension ASN.1 type [11]\
    \ describes a single certificate\n   extension value of a nominated extension\
    \ type.\n      Extension ::= SEQUENCE {\n          extnId     EXTENSION.&id ({ExtensionSet}),\n\
    \          critical   BOOLEAN DEFAULT FALSE,\n          extnValue  OCTET STRING\n\
    \              -- contains a DER encoding of a value of type &ExtnType\n     \
    \         -- for the extension object identified by extnId -- }\n   EXTENSION.&id\
    \ denotes an OBJECT IDENTIFIER and ({ExtensionSet})\n   constrains the OBJECT\
    \ IDENTIFIER to be the identifier of a supported\n   certificate extension.\n\
    \   The component reference \"extnValue\" on Extension refers to a\n   component\
    \ type of OCTET STRING.  The corresponding component values\n   will be OCTET\
    \ STRING values.  The component reference\n   \"extnValue.content\" on Extension\
    \ refers to the type of the contained\n   type, which in this case is an open\
    \ type.\n   One of the X.509 [11] standard extensions is basicConstraints, which\n\
    \   is identified with the OBJECT IDENTIFIER 2.5.29.19 and is defined to\n   have\
    \ the following syntax.\n      BasicConstraintsSyntax ::= SEQUENCE {\n       \
    \   cA                 BOOLEAN DEFAULT FALSE,\n          pathLenConstraint  INTEGER\
    \ (0..MAX) OPTIONAL }\n   The component reference \"extnValue.content.(2.5.29.19)\"\
    \ on Extension\n   specifies a BasicConstraintsSyntax extension value and the\
    \ component\n   reference \"extnValue.content.(2.5.29.19).cA\" identifies the\
    \ cA\n   component of a BasicConstraintsSyntax extension value.\n"
- title: 3.2.  Matching of Components
  contents:
  - "3.2.  Matching of Components\n   The rule in a ComponentAssertion specifies how\
    \ the zero, one or more\n   component values identified by the component reference\
    \ are tested by\n   the assertion.  Attribute matching rules are used to specify\
    \ the\n   semantics of the test.\n   Each matching rule has a notional set of\
    \ attribute syntaxes\n   (typically one), defined as ASN.1 types, to which it\
    \ may be applied.\n   When used in a ComponentAssertion these matching rules apply\
    \ to the\n   same ASN.1 types, only in this context the corresponding ASN.1 values\n\
    \   are not necessarily complete attribute values.\n   Note that the referenced\
    \ component type may be a tagged and/or\n   constrained version of the expected\
    \ attribute syntax (e.g.,\n   [0] INTEGER, whereas integerMatch would expect simply\
    \ INTEGER), or an\n   open type.  Additional type substitutions of the kind described\
    \ in\n   Section 3.1.1 are performed as required to reduce the component type\n\
    \   to the same type as the attribute syntax expected by the matching\n   rule.\n\
    \   If a matching rule applies to more than one attribute syntax (e.g.,\n   objectIdentifierFirstComponentMatch\
    \ [12]) then the minimum number of\n   substitutions required to conform to any\
    \ one of those syntaxes is\n   performed.  If a matching rule can apply to any\
    \ attribute syntax\n   (e.g., the allComponentsMatch rule defined in Section 6.2)\
    \ then the\n   referenced component type is used as is, with no additional\n \
    \  substitutions.\n   The value in a ComponentAssertion will be of the assertion\
    \ syntax\n   (i.e., ASN.1 type) required by the chosen matching rule.  Note that\n\
    \   the assertion syntax of a matching rule is not necessarily the same\n   as\
    \ the attribute syntax(es) to which the rule may be applied.\n   Some matching\
    \ rules do not have a fixed assertion syntax (e.g.,\n   allComponentsMatch). \
    \ The required assertion syntax is determined in\n   each instance of use by the\
    \ syntax of the attribute type to which the\n   matching rule is applied.  For\
    \ these rules the ASN.1 type of the\n   referenced component is used in place\
    \ of an attribute syntax to\n   decide the required assertion syntax.\n   The\
    \ ComponentAssertion is Undefined if:\n   a) the matching rule in the ComponentAssertion\
    \ is not known to the\n      evaluating procedure,\n   b) the matching rule is\
    \ not applicable to the referenced component\n      type, even with the additional\
    \ type substitutions,\n   c) the value in the ComponentAssertion does not conform\
    \ to the\n      assertion syntax defined for the matching rule,\n   d) some part\
    \ of the component reference identifies an open type in\n      the tested value\
    \ that cannot be decoded, or\n   e) the implementation does not support the particular\
    \ combination of\n      component reference and matching rule.\n   If the ComponentAssertion\
    \ is not Undefined then the\n   ComponentAssertion evaluates to TRUE if there\
    \ is at least one\n   component value for which the matching rule applied to that\
    \ component\n   value returns TRUE, and evaluates to FALSE otherwise (which includes\n\
    \   the case where there are no component values).\n"
- title: 3.2.1.  Applicability of Existing Matching Rules
  contents:
  - '3.2.1.  Applicability of Existing Matching Rules

    '
- title: 3.2.1.1.  String Matching
  contents:
  - "3.2.1.1.  String Matching\n   ASN.1 has a number of built in restricted character\
    \ string types with\n   different character sets and/or different character encodings.\
    \  A\n   directory user generally has little interest in the particular\n   character\
    \ set or encoding used to represent a character string\n   component value, and\
    \ some directory server implementations make no\n   distinction between the different\
    \ string types in their internal\n   representation of values.  So rather than\
    \ define string matching\n   rules for each of the restricted character string\
    \ types, the existing\n   case ignore and case exact string matching rules are\
    \ extended to\n   apply to component values of any of the restricted character\
    \ string\n   types and any ChoiceOfStrings type [9], in addition to component\n\
    \   values of the DirectoryString type.  This extension is only for the\n   purposes\
    \ of component matching described in this document.\n   The relevant string matching\
    \ rules are: caseIgnoreMatch,\n   caseIgnoreOrderingMatch, caseIgnoreSubstringsMatch,\
    \ caseExactMatch,\n   caseExactOrderingMatch and caseExactSubstringsMatch.  The\
    \ relevant\n   restricted character string types are: NumericString,\n   PrintableString,\
    \ VisibleString, IA5String, UTF8String, BMPString,\n   UniversalString, TeletexString,\
    \ VideotexString, GraphicString and\n   GeneralString.  A ChoiceOfStrings type\
    \ is a purely syntactic CHOICE\n   of these ASN.1 string types.  Note that GSER\
    \ [9] declares each and\n   every use of the DirectoryString{} parameterized type\
    \ to be a\n   ChoiceOfStrings type.\n   The assertion syntax of the string matching\
    \ rules is still\n   DirectoryString regardless of the string syntax of the component\n\
    \   being matched.  Thus an implementation will be called upon to compare\n  \
    \ a DirectoryString value to a value of one of the restricted character\n   string\
    \ types, or a ChoiceOfStrings type.  As is the case when\n   comparing two DirectoryStrings\
    \ where the chosen alternatives are of\n   different string types, the comparison\
    \ proceeds so long as the\n   corresponding characters are representable in both\
    \ character sets.\n   Otherwise matching returns FALSE.\n"
- title: 3.2.1.2.  Telephone Number Matching
  contents:
  - "3.2.1.2.  Telephone Number Matching\n   Early editions of X.520 [12] gave the\
    \ syntax of the telephoneNumber\n   attribute as a constrained PrintableString.\
    \  The fourth edition of\n   X.520 equates the ASN.1 type name TelephoneNumber\
    \ to the constrained\n   PrintableString and uses TelephoneNumber as the attribute\
    \ and\n   assertion syntax.  For the purposes of component matching,\n   telephoneNumberMatch\
    \ and telephoneNumberSubstringsMatch are permitted\n   to be applied to any PrintableString\
    \ value, as well as to\n   TelephoneNumber values.\n"
- title: 3.2.1.3.  Distinguished Name Matching
  contents:
  - "3.2.1.3.  Distinguished Name Matching\n   The DistinguishedName type is defined\
    \ by assignment to be the same as\n   the RDNSequence type, however RDNSequence\
    \ is sometimes directly used\n   in other type definitions.  For the purposes\
    \ of component matching,\n   distinguishedNameMatch is also permitted to be applied\
    \ to values of\n   the RDNSequence type.\n"
- title: 3.2.2.  Additional Useful Matching Rules
  contents:
  - "3.2.2.  Additional Useful Matching Rules\n   This section defines additional\
    \ matching rules that may prove useful\n   in ComponentAssertions.  These rules\
    \ may also be used in\n   extensibleMatch search filters [3].\n"
- title: 3.2.2.1.  The rdnMatch Matching Rule
  contents:
  - "3.2.2.1.  The rdnMatch Matching Rule\n   The distinguishedNameMatch matching\
    \ rule can match whole\n   distinguished names but it is sometimes useful to be\
    \ able to match\n   specific Relative Distinguished Names (RDNs) in a Distinguished\
    \ Name\n   (DN) without regard for the other RDNs in the DN.  The rdnMatch\n \
    \  matching rule allows component RDNs of a DN to be tested.\n   The LDAP-style\
    \ definitions for rdnMatch and its assertion syntax are:\n      ( 1.2.36.79672281.1.13.3\
    \ NAME 'rdnMatch'\n          SYNTAX 1.2.36.79672281.1.5.0 )\n      ( 1.2.36.79672281.1.5.0\
    \ DESC 'RDN' )\n   The LDAP-specific encoding for a value of the RDN syntax is\
    \ given by\n   the <RelativeDistinguishedNameValue> rule [9].\n   The X.500-style\
    \ definition for rdnMatch is:\n      rdnMatch MATCHING-RULE ::= {\n          SYNTAX\
    \  RelativeDistinguishedName\n          ID      { 1 2 36 79672281 1 13 3 } }\n\
    \   The rdnMatch rule evaluates to true if the component value and\n   assertion\
    \ value are the same RDN, using the same RDN comparison\n   method as distinguishedNameMatch.\n\
    \   When using rdnMatch to match components of DNs it is important to\n   note\
    \ that the LDAP-specific encoding of a DN [5] reverses the order\n   of the RDNs.\
    \  So for the DN represented in LDAP as\n   \"cn=Steven Legg,o=Adacel,c=AU\",\
    \ the RDN \"cn=Steven Legg\" corresponds\n   to the component reference \"3\"\
    , or alternatively, \"-1\".\n"
- title: 3.2.2.2.  The presentMatch Matching Rule
  contents:
  - "3.2.2.2.  The presentMatch Matching Rule\n   At times it would be useful to test\
    \ not if a specific value of a\n   particular component is present, but whether\
    \ any value of a\n   particular component is present.  The presentMatch matching\
    \ rule\n   allows the presence of a particular component value to be tested.\n\
    \   The LDAP-style definitions for presentMatch and its assertion syntax\n   are:\n\
    \      ( 1.2.36.79672281.1.13.5 NAME 'presentMatch'\n          SYNTAX 1.2.36.79672281.1.5.1\
    \ )\n      ( 1.2.36.79672281.1.5.1 DESC 'NULL' )\n   The LDAP-specific encoding\
    \ for a value of the NULL syntax is given by\n   the <NullValue> rule [9].\n \
    \  The X.500-style definition for presentMatch is:\n      presentMatch MATCHING-RULE\
    \ ::= {\n          SYNTAX  NULL\n          ID      { 1 2 36 79672281 1 13 5 }\
    \ }\n   When used in a extensible match filter item, presentMatch behaves\n  \
    \ like the \"present\" case of a regular search filter.  In a\n   ComponentAssertion,\
    \ presentMatch evaluates to TRUE if and only if the\n   component reference identifies\
    \ one or more component values,\n   regardless of the actual component value contents.\
    \  Note that if\n   useDefaultValues is TRUE then the identified component values\
    \ may be\n   (part of) a DEFAULT value.\n   The notional count referenced by the\
    \ <count> form of ComponentId is\n   taken to be present if the SET OF value is\
    \ present, and absent\n   otherwise.  Note that in ASN.1 notation an absent SET\
    \ OF value is\n   distinctly different from a SET OF value that is present but\
    \ empty.\n   It is up to the specification using the ASN.1 notation to decide\n\
    \   whether the distinction matters.  Often an empty SET OF component and\n  \
    \ an absent SET OF component are treated as semantically equivalent.\n   If a\
    \ SET OF value is present, but empty, a presentMatch on the SET OF\n   component\
    \ SHALL return TRUE and the notional count SHALL be regarded\n   as present and\
    \ equal to zero.\n"
- title: 3.2.3.  Summary of Useful Matching Rules
  contents:
  - "3.2.3.  Summary of Useful Matching Rules\n   The following is a non-exhaustive\
    \ list of useful matching rules and\n   the ASN.1 types to which they can be applied,\
    \ taking account of all\n   the extensions described in Section 3.2.1, and the\
    \ new matching rules\n   defined in Section 3.2.2.\n      +================================+==============================+\n\
    \      | Matching Rule                  | ASN.1 Type                   |\n   \
    \   +================================+==============================+\n      |\
    \ bitStringMatch                 | BIT STRING                   |\n      +--------------------------------+------------------------------+\n\
    \      | booleanMatch                   | BOOLEAN                      |\n   \
    \   +--------------------------------+------------------------------+\n      |\
    \ caseIgnoreMatch                | NumericString                |\n      | caseIgnoreOrderingMatch\
    \        | PrintableString              |\n      | caseIgnoreSubstringsMatch \
    \     | VisibleString (ISO646String) |\n      | caseExactMatch               \
    \  | IA5String                    |\n      | caseExactOrderingMatch         |\
    \ UTF8String                   |\n      | caseExactSubstringsMatch       | BMPString\
    \ (UCS-2, UNICODE)   |\n      |                                | UniversalString\
    \ (UCS-4)      |\n      |                                | TeletexString (T61String)\
    \    |\n      |                                | VideotexString              \
    \ |\n      |                                | GraphicString                |\n\
    \      |                                | GeneralString                |\n   \
    \   |                                | any ChoiceOfStrings type     |\n      +--------------------------------+------------------------------+\n\
    \      | caseIgnoreIA5Match             | IA5String                    |\n   \
    \   | caseExactIA5Match              |                              |\n      +--------------------------------+------------------------------+\n\
    \      | distinguishedNameMatch         | DistinguishedName            |\n   \
    \   |                                | RDNSequence                  |\n      +--------------------------------+------------------------------+\n\
    \      | generalizedTimeMatch           | GeneralizedTime              |\n   \
    \   | generalizedTimeOrderingMatch   |                              |\n      +--------------------------------+------------------------------+\n\
    \      | integerMatch                   | INTEGER                      |\n   \
    \   | integerOrderingMatch           |                              |\n      +--------------------------------+------------------------------+\n\
    \      | numericStringMatch             | NumericString                |\n   \
    \   | numericStringOrderingMatch     |                              |\n      |\
    \ numericStringSubstringsMatch   |                              |\n      +--------------------------------+------------------------------+\n\
    \      | objectIdentifierMatch          | OBJECT IDENTIFIER            |\n   \
    \   +--------------------------------+------------------------------+\n      |\
    \ octetStringMatch               | OCTET STRING                 |\n      | octetStringOrderingMatch\
    \       |                              |\n      | octetStringSubstringsMatch \
    \    |                              |\n      +--------------------------------+------------------------------+\n\
    \      | presentMatch                   | any ASN.1 type               |\n   \
    \   +--------------------------------+------------------------------+\n      |\
    \ rdnMatch                       | RelativeDistinguishedName    |\n      +--------------------------------+------------------------------+\n\
    \      | telephoneNumberMatch           | PrintableString              |\n   \
    \   | telephoneNumberSubstringsMatch | TelephoneNumber              |\n      +--------------------------------+------------------------------+\n\
    \      | uTCTimeMatch                   | UTCTime                      |\n   \
    \   | uTCTimeOrderingMatch           |                              |\n      +--------------------------------+------------------------------+\n\
    \   Note that the allComponentsMatch matching rule defined in Section 6.2\n  \
    \ can be used for equality matching of values of the ENUMERATED, NULL,\n   REAL\
    \ and RELATIVE-OID ASN.1 types, among other things.\n"
- title: 4.  ComponentFilter
  contents:
  - "4.  ComponentFilter\n   The ComponentAssertion allows the value(s) of any one\
    \ component type\n   in a complex ASN.1 type to be matched, but there is often\
    \ a desire to\n   match the values of more than one component type.  A ComponentFilter\n\
    \   is an assertion about the presence, or values of, multiple components\n  \
    \ within an ASN.1 value.\n   The ComponentFilter assertion, an expression of ComponentAssertions,\n\
    \   evaluates to either TRUE, FALSE or Undefined for each tested ASN.1\n   value.\n\
    \   A ComponentFilter is described by the following ASN.1 type (assumed\n   to\
    \ be defined with \"EXPLICIT TAGS\" in force):\n      ComponentFilter ::= CHOICE\
    \ {\n          item  [0] ComponentAssertion,\n          and   [1] SEQUENCE OF\
    \ ComponentFilter,\n          or    [2] SEQUENCE OF ComponentFilter,\n       \
    \   not   [3] ComponentFilter }\n   Note: despite the use of SEQUENCE OF instead\
    \ of SET OF for the \"and\"\n   and \"or\" alternatives in ComponentFilter, the\
    \ order of the component\n   filters is not significant.\n   A ComponentFilter\
    \ that is a ComponentAssertion evaluates to TRUE if\n   the ComponentAssertion\
    \ is TRUE, evaluates to FALSE if the\n   ComponentAssertion is FALSE, and evaluates\
    \ to Undefined otherwise.\n   The \"and\" of a sequence of component filters evaluates\
    \ to TRUE if the\n   sequence is empty or if each component filter evaluates to\
    \ TRUE,\n   evaluates to FALSE if at least one component filter is FALSE, and\n\
    \   evaluates to Undefined otherwise.\n   The \"or\" of a sequence of component\
    \ filters evaluates to FALSE if the\n   sequence is empty or if each component\
    \ filter evaluates to FALSE,\n   evaluates to TRUE if at least one component filter\
    \ is TRUE, and\n   evaluates to Undefined otherwise.\n   The \"not\" of a component\
    \ filter evaluates to TRUE if the component\n   filter is FALSE, evaluates to\
    \ FALSE if the component filter is TRUE,\n   and evaluates to Undefined otherwise.\n"
- title: 5.  The componentFilterMatch Matching Rule
  contents:
  - "5.  The componentFilterMatch Matching Rule\n   The componentFilterMatch matching\
    \ rule allows a ComponentFilter to be\n   applied to an attribute value.  The\
    \ result of the matching rule is\n   the result of applying the ComponentFilter\
    \ to the attribute value.\n   The LDAP-style definitions for componentFilterMatch\
    \ and its assertion\n   syntax are:\n      ( 1.2.36.79672281.1.13.2 NAME 'componentFilterMatch'\n\
    \          SYNTAX 1.2.36.79672281.1.5.2 )\n      ( 1.2.36.79672281.1.5.2 DESC\
    \ 'ComponentFilter' )\n   The LDAP-specific encoding for the ComponentFilter assertion\
    \ syntax\n   is specified by GSER [9].\n   As a convenience to implementors, an\
    \ equivalent ABNF description of\n   the GSER encoding for ComponentFilter is\
    \ provided here.  In the event\n   that there is a discrepancy between this ABNF\
    \ and the encoding\n   determined by GSER, GSER is to be taken as definitive.\
    \  The GSER\n   encoding of a ComponentFilter is described by the following\n\
    \   equivalent ABNF:\n      ComponentFilter = filter-item /\n                \
    \        and-filter /\n                        or-filter /\n                 \
    \       not-filter\n      filter-item     = item-chosen ComponentAssertion\n \
    \     and-filter      = and-chosen  SequenceOfComponentFilter\n      or-filter\
    \       = or-chosen   SequenceOfComponentFilter\n      not-filter      = not-chosen\
    \  ComponentFilter\n      item-chosen     = %x69.74.65.6D.3A  ; \"item:\"\n  \
    \    and-chosen      = %x61.6E.64.3A     ; \"and:\"\n      or-chosen       = %x6F.72.3A\
    \        ; \"or:\"\n      not-chosen      = %x6E.6F.74.3A     ; \"not:\"\n   \
    \   SequenceOfComponentFilter = \"{\" [ sp ComponentFilter\n                 \
    \                    *( \",\" sp ComponentFilter) ] sp \"}\"\n      ComponentAssertion\
    \ = \"{\" [ sp component \",\" ]\n                               [ sp useDefaultValues\
    \ \",\" ]\n                                 sp rule \",\"\n                  \
    \               sp assertion-value sp \"}\"\n      component          = component-label\
    \ msp StringValue\n      useDefaultValues   = use-defaults-label msp BooleanValue\n\
    \      rule               = rule-label msp ObjectIdentifierValue\n      assertion-value\
    \    = value-label msp Value\n      component-label    = %x63.6F.6D.70.6F.6E.65.6E.74\
    \  ; \"component\"\n      use-defaults-label = %x75.73.65.44.65.66.61.75.6C.74.56.61.6C.75\n\
    \                           %x65.73                  ; \"useDefaultValues\"\n\
    \      rule-label         = %x72.75.6C.65            ; \"rule\"\n      value-label\
    \        = %x76.61.6C.75.65         ; \"value\"\n      sp                 =  *%x20\
    \  ; zero, one or more space characters\n      msp                = 1*%x20  ;\
    \ one or more space characters\n   The ABNF for <Value>, <StringValue>, <ObjectIdentifierValue>\
    \ and\n   <BooleanValue> is defined by GSER [9].\n   The ABNF descriptions of\
    \ LDAP-specific encodings for attribute\n   syntaxes typically do not clearly\
    \ or consistently delineate the\n   component parts of an attribute value.  A\
    \ regular and uniform\n   character string encoding for arbitrary component data\
    \ types is\n   needed to encode the assertion value in a ComponentAssertion. \
    \ The\n   <Value> rule from GSER provides a human readable text encoding for a\n\
    \   component value of any arbitrary ASN.1 type.\n   The X.500-style definition\
    \ [10] for componentFilterMatch is:\n      componentFilterMatch MATCHING-RULE\
    \ ::= {\n          SYNTAX  ComponentFilter\n          ID      { 1 2 36 79672281\
    \ 1 13 2 } }\n   A ComponentAssertion can potentially use any matching rule, including\n\
    \   componentFilterMatch, so componentFilterMatch may be nested.  The\n   component\
    \ references in a nested componentFilterMatch are relative to\n   the component\
    \ corresponding to the containing ComponentAssertion.  In\n   Section 7, an example\
    \ search on the seeAlso attribute shows this\n   usage.\n"
- title: 6.  Equality Matching of Complex Components
  contents:
  - "6.  Equality Matching of Complex Components\n   It is possible to test if an\
    \ attribute value of a complex ASN.1\n   syntax is the same as some purported\
    \ (i.e., assertion) value by using\n   a complicated ComponentFilter that tests\
    \ if corresponding components\n   are the same.  However, it would be more convenient\
    \ to be able to\n   present a whole assertion value to a matching rule that could\
    \ do the\n   component-wise comparison of an attribute value with the assertion\n\
    \   value for any arbitrary attribute syntax.  Similarly, the ability to\n   do\
    \ a straightforward equality comparison of a component value that is\n   itself\
    \ of a complex ASN.1 type would also be convenient.\n   It would be difficult\
    \ to define a single matching rule that\n   simultaneously satisfies all notions\
    \ of what the equality matching\n   semantics should be.  For example, in some\
    \ instances a case sensitive\n   comparison of string components may be preferable\
    \ to a case\n   insensitive comparison.  Therefore a basic equality matching rule,\n\
    \   allComponentsMatch, is defined in Section 6.2, and the means to\n   derive\
    \ new matching rules from it with slightly different equality\n   matching semantics\
    \ are described in Section 6.3.\n   The directoryComponentsMatch defined in Section\
    \ 6.4 is a derivation\n   of allComponentsMatch that suits typical uses of the\
    \ directory.\n   Other specifications are free to derive new rules from\n   allComponentsMatch\
    \ or directoryComponentsMatch, that suit their usage\n   of the directory.\n \
    \  The allComponentsMatch rule, the directoryComponentsMatch rule and\n   any\
    \ matching rules derived from them are collectively called\n   component equality\
    \ matching rules.\n"
- title: 6.1.  The OpenAssertionType Syntax
  contents:
  - "6.1.  The OpenAssertionType Syntax\n   The component equality matching rules\
    \ have a variable assertion\n   syntax.  In X.500 this is indicated by omitting\
    \ the optional SYNTAX\n   field in the MATCHING-RULE information object.  The\
    \ assertion syntax\n   then defaults to the target attribute's syntax in actual\
    \ usage,\n   unless the description of the matching rule says otherwise.  The\n\
    \   SYNTAX field in the LDAP-specific encoding of a\n   MatchingRuleDescription\
    \ is mandatory, so the OpenAssertionType syntax\n   is defined to fill the same\
    \ role.  That is, the OpenAssertionType\n   syntax is semantically equivalent\
    \ to an omitted SYNTAX field in an\n   X.500 MATCHING-RULE information object.\
    \  OpenAssertionType MUST NOT\n   be used as the attribute syntax in an attribute\
    \ type definition.\n   Unless explicitly varied by the description of a particular\
    \ matching\n   rule, if an OpenAssertionType assertion value appears in a\n  \
    \ ComponentAssertion its LDAP-specific encoding is described by the\n   <Value>\
    \ rule in GSER [9], otherwise its LDAP-specific encoding is the\n   encoding defined\
    \ for the syntax of the attribute type to which the\n   matching rule with the\
    \ OpenAssertionType assertion syntax is applied.\n   The LDAP definition for the\
    \ OpenAssertionType syntax is:\n      ( 1.2.36.79672281.1.5.3 DESC 'OpenAssertionType'\
    \ )\n"
- title: 6.2.  The allComponentsMatch Matching Rule
  contents:
  - "6.2.  The allComponentsMatch Matching Rule\n   The LDAP-style definition for\
    \ allComponentsMatch is:\n      ( 1.2.36.79672281.1.13.6 NAME 'allComponentsMatch'\n\
    \          SYNTAX 1.2.36.79672281.1.5.3 )\n   The X.500-style definition for allComponentsMatch\
    \ is:\n      allComponentsMatch MATCHING-RULE ::= {\n          ID      { 1 2 36\
    \ 79672281 1 13 6 } }\n   When allComponentsMatch is used in a ComponentAssertion\
    \ the assertion\n   syntax is the same as the ASN.1 type of the identified component.\n\
    \   Otherwise, the assertion syntax of allComponentsMatch is the same as\n   the\
    \ attribute syntax of the attribute to which the matching rule is\n   applied.\n\
    \   Broadly speaking, this matching rule evaluates to true if and only if\n  \
    \ corresponding components of the assertion value and the attribute or\n   component\
    \ value are the same.\n   In detail, equality is determined by the following cases\
    \ applied\n   recursively.\n   a) Two values of a SET or SEQUENCE type are the\
    \ same if and only if,\n      for each component type, the corresponding component\
    \ values are\n      either,\n      1) both absent,\n      2) both present and\
    \ the same, or\n      3) absent or the same as the DEFAULT value for the component,\
    \ if a\n         DEFAULT value is defined.\n         Values of an EMBEDDED PDV,\
    \ EXTERNAL, unrestricted CHARACTER\n         STRING, or INSTANCE OF type are compared\
    \ according to their\n         respective associated SEQUENCE type (see Section\
    \ 3.1.2).\n   b) Two values of a SEQUENCE OF type are the same if and only if,\
    \ the\n      values have the same number of (possibly duplicated) instances and\n\
    \      corresponding instances are the same.\n   c) Two values of a SET OF type\
    \ are the same if and only if, the\n      values have the same number of instances\
    \ and each distinct\n      instance occurs in both values the same number of times,\
    \ i.e.,\n      both values have the same instances, including duplicates, but\
    \ in\n      any order.\n   d) Two values of a CHOICE type are the same if and\
    \ only if, both\n      values are of the same chosen alternative and the component\
    \ values\n      are the same.\n   e) Two BIT STRING values are the same if and\
    \ only if the values have\n      the same number of bits and corresponding bits\
    \ are the same.  If\n      the BIT STRING type is defined with a named bit list\
    \ then trailing\n      zero bits in the values are treated as absent for the purposes\
    \ of\n      this comparison.\n   f) Two BOOLEAN values are the same if and only\
    \ if both are TRUE or\n      both are FALSE.\n   g) Two values of a string type\
    \ are the same if and only if the values\n      have the same number of characters\
    \ and corresponding characters\n      are the same.  Letter case is significant.\
    \  For the purposes of\n      allComponentsMatch, the string types are NumericString,\n\
    \      PrintableString, TeletexString (T61String), VideotexString,\n      IA5String,\
    \ GraphicString, VisibleString (ISO646String),\n      GeneralString, UniversalString,\
    \ BMPString, UTF8String,\n      GeneralizedTime, UTCTime and ObjectDescriptor.\n\
    \   h) Two INTEGER values are the same if and only if the integers are\n     \
    \ equal.\n   i) Two ENUMERATED values are the same if and only if the enumeration\n\
    \      item identifiers are the same (equivalently, if the integer values\n  \
    \    associated with the identifiers are equal).\n   j) Two NULL values are always\
    \ the same, unconditionally.\n   k) Two OBJECT IDENTIFIER values are the same\
    \ if and only if the\n      values have the same number of arcs and corresponding\
    \ arcs are the\n      same.\n   l) Two OCTET STRING values are the same if and\
    \ only if the values\n      have the same number of octets and corresponding octets\
    \ are the\n      same.\n   m) Two REAL values are the same if and only if they\
    \ are both the same\n      special value, or neither is a special value and they\
    \ have the\n      same base and represent the same real number.  The special values\n\
    \      for REAL are zero, PLUS-INFINITY and MINUS-INFINITY.\n   n) Two RELATIVE-OID\
    \ values are the same if and only if the values\n      have the same number of\
    \ arcs and corresponding arcs are the same.\n      The respective starting nodes\
    \ for the RELATIVE-OID values are\n      disregarded in the comparison, i.e.,\
    \ they are assumed to be the\n      same.\n   o) Two values of an open type are\
    \ the same if and only if both are of\n      the same ASN.1 type and are the same\
    \ according to that type.  If\n      the actual ASN.1 type of the values is unknown\
    \ then the\n      allComponentsMatch rule evaluates to Undefined.\n   Tags and\
    \ constraints, being part of the type definition and not part\n   of the abstract\
    \ values, are ignored for matching purposes.\n   The allComponentsMatch rule may\
    \ be used as the defined equality\n   matching rule for an attribute.\n"
- title: 6.3.  Deriving Component Equality Matching Rules
  contents:
  - "6.3.  Deriving Component Equality Matching Rules\n   A new component equality\
    \ matching rule with more refined matching\n   semantics may be derived from allComponentsMatch,\
    \ or any other\n   component equality matching rule, using the convention described\
    \ in\n   this section.\n   The matching behaviour of a derived component equality\
    \ matching rule\n   is specified by nominating, for each of one or more identified\n\
    \   components, a commutative equality matching rule that will be used to\n  \
    \ match values of that component.  This overrides the matching that\n   would\
    \ otherwise occur for values of that component using the base\n   rule for the\
    \ derivation.  These overrides can be conveniently\n   represented as rows in\
    \ a table of the following form.\n      Component   |  Matching Rule\n      ============+===============\n\
    \                  |\n                  |\n   Usually, all component values of\
    \ a particular ASN.1 type are to be\n   matched the same way.  An ASN.1 type reference\
    \ (e.g.,\n   DistinguishedName) or an ASN.1 built-in type name (e.g., INTEGER)\
    \ in\n   the Component column of the table specifies that the nominated\n   equality\
    \ matching rule is to be applied to all values of the named\n   type, regardless\
    \ of context.\n   An ASN.1 type reference with a component reference appended\n\
    \   (separated by a \".\")  specifies that the nominated matching rule\n   applies\
    \ only to the identified components of values of the named\n   type.  Other component\
    \ values that happen to be of the same ASN.1\n   type are not selected.\n   Additional\
    \ type substitutions as described in Section 3.2 are assumed\n   to be performed\
    \ to align the component type with the matching rule\n   assertion syntax.\n \
    \  Conceptually, the rows in a table for the base rule are appended to\n   the\
    \ rows in the table for a derived rule for the purpose of deciding\n   the matching\
    \ semantics of the derived rule.  Notionally,\n   allComponentsMatch has an empty\
    \ table.\n   A row specifying values of an outer containing type (e.g.,\n   DistinguishedName)\
    \ takes precedence over a row specifying values of\n   an inner component type\
    \ (e.g., RelativeDistinguishedName), regardless\n   of their order in the table.\
    \  Specifying a row for component values\n   of an inner type is only useful if\
    \ a value of the type can also\n   appear on its own, or as a component of values\
    \ of a different outer\n   type.  For example, if there is a row for DistinguishedName\
    \ then a\n   row for RelativeDistinguishedName can only ever apply to\n   RelativeDistinguishedName\
    \ component values that are not part of a\n   DistinguishedName.  A row for values\
    \ of an outer type in the table\n   for the base rule takes precedence over a\
    \ row for values of an inner\n   type in the table for the derived rule.\n   Where\
    \ more than one row applies to a particular component value the\n   earlier row\
    \ takes precedence over the later row.  Thus rows in the\n   table for the derived\
    \ rule take precedence over any rows for the same\n   component in the table for\
    \ the base rule.\n"
- title: 6.4.  The directoryComponentsMatch Matching Rule
  contents:
  - "6.4.  The directoryComponentsMatch Matching Rule\n   The directoryComponentsMatch\
    \ matching rule is derived from the\n   allComponentsMatch matching rule.\n  \
    \ The LDAP-style definition for directoryComponentsMatch is:\n      ( 1.2.36.79672281.1.13.7\
    \ NAME 'directoryComponentsMatch'\n          SYNTAX 1.2.36.79672281.1.5.3 )\n\
    \   The X.500-style definition for directoryComponentsMatch is:\n      directoryComponentsMatch\
    \ MATCHING-RULE ::= {\n          ID      { 1 2 36 79672281 1 13 7 } }\n   The\
    \ matching semantics of directoryComponentsMatch are described by\n   the following\
    \ table, using the convention described in Section 6.3.\n      ASN.1 Type    \
    \                           | Matching Rule\n      =========================================+========================\n\
    \      RDNSequence                              | distinguishedNameMatch\n   \
    \   RelativeDistinguishedName                | rdnMatch\n      TelephoneNumber\
    \                          | telephoneNumberMatch\n      FacsimileTelephoneNumber.telephoneNumber\
    \ | telephoneNumberMatch\n      NumericString                            | numericStringMatch\n\
    \      GeneralizedTime                          | generalizedTimeMatch\n     \
    \ UTCTime                                  | uTCTimeMatch\n      DirectoryString{}\
    \                        | caseIgnoreMatch\n      BMPString                  \
    \              | caseIgnoreMatch\n      GeneralString                        \
    \    | caseIgnoreMatch\n      GraphicString                            | caseIgnoreMatch\n\
    \      IA5String                                | caseIgnoreMatch\n      PrintableString\
    \                          | caseIgnoreMatch\n      TeletexString            \
    \                | caseIgnoreMatch\n      UniversalString                    \
    \      | caseIgnoreMatch\n      UTF8String                               | caseIgnoreMatch\n\
    \      VideotexString                           | caseIgnoreMatch\n      VisibleString\
    \                            | caseIgnoreMatch\n   Notes:\n   1) The DistinguishedName\
    \ type is defined by assignment to be the same\n      as the RDNSequence type.\
    \  Some types (e.g., Name and LocalName)\n      directly reference RDNSequence\
    \ rather than DistinguishedName.\n      Specifying RDNSequence captures all these\
    \ DN-like types.\n   2) A RelativeDistinguishedName value is only matched by rdnMatch\
    \ if\n      it is not part of an RDNSequence value.\n   3) The telephone number\
    \ component of the FacsimileTelephoneNumber\n      ASN.1 type [12] is defined\
    \ as a constrained PrintableString.\n      PrintableString component values that\
    \ are part of a\n      FacsimileTelephoneNumber value can be identified separately\
    \ from\n      other components of PrintableString type by the specifier\n    \
    \  FacsimileTelephoneNumber.telephoneNumber, so that\n      telephoneNumberMatch\
    \ can be selectively applied.  The fourth\n      edition of X.520 defines the\
    \ telephoneNumber component of\n      FacsimileTelephoneNumber to be of the type\
    \ TelephoneNumber, making\n      the row for FacsimileTelephoneNumber.telephoneNumber\
    \ components\n      redundant.\n   The directoryComponentsMatch rule may be used\
    \ as the defined equality\n   matching rule for an attribute.\n"
- title: 7.  Component Matching Examples
  contents:
  - "7.  Component Matching Examples\n   This section contains examples of search\
    \ filters using the\n   componentFilterMatch matching rule.  The filters are described\
    \ using\n   the string representation of LDAP search filters [18].  Note that\n\
    \   this representation requires asterisks to be escaped in assertion\n   values\
    \ (in these examples the assertion values are all\n   <ComponentAssertion> encodings).\
    \  The asterisks have not been escaped\n   in these examples for the sake of clarity,\
    \ and to avoid confusing the\n   protocol representation of LDAP search filter\
    \ assertion values, where\n   such escaping does not apply.  Line breaks and indenting\
    \ have been\n   added only as an aid to readability.\n   The example search filters\
    \ using componentFilterMatch are all single\n   extensible match filter items,\
    \ though there is no reason why\n   componentFilterMatch can't be used in more\
    \ complicated search\n   filters.\n   The first examples describe searches over\
    \ the objectClasses schema\n   operational attribute, which has an attribute syntax\
    \ described by the\n   ASN.1 type ObjectClassDescription [10], and holds the definitions\
    \ of\n   the object classes known to a directory server.  The definition of\n\
    \   ObjectClassDescription is as follows:\n      ObjectClassDescription ::= SEQUENCE\
    \ {\n          identifier       OBJECT-CLASS.&id,\n          name            \
    \ SET OF DirectoryString {ub-schema} OPTIONAL,\n          description      DirectoryString\
    \ {ub-schema} OPTIONAL,\n          obsolete         BOOLEAN DEFAULT FALSE,\n \
    \         information  [0] ObjectClassInformation }\n      ObjectClassInformation\
    \ ::= SEQUENCE {\n          subclassOf       SET OF OBJECT-CLASS.&id OPTIONAL,\n\
    \          kind             ObjectClassKind DEFAULT structural,\n          mandatories\
    \  [3] SET OF ATTRIBUTE.&id OPTIONAL,\n          optionals    [4] SET OF ATTRIBUTE.&id\
    \ OPTIONAL }\n      ObjectClassKind ::= ENUMERATED {\n          abstract     (0),\n\
    \          structural   (1),\n          auxiliary    (2) }\n   OBJECT-CLASS.&id\
    \ and ATTRIBUTE.&id are equivalent to the OBJECT\n   IDENTIFIER ASN.1 type.  A\
    \ value of OBJECT-CLASS.&id is an OBJECT\n   IDENTIFIER for an object class. \
    \ A value of ATTRIBUTE.&id is an\n   OBJECT IDENTIFIER for an attribute type.\n\
    \   The following search filter finds the object class definition for the\n  \
    \ object class identified by the OBJECT IDENTIFIER 2.5.6.18:\n      (objectClasses:componentFilterMatch:=\n\
    \           item:{ component \"identifier\",\n                  rule objectIdentifierMatch,\
    \ value 2.5.6.18 })\n   A match on the \"identifier\" component of objectClasses\
    \ values is\n   equivalent to the objectIdentifierFirstComponentMatch matching\
    \ rule\n   applied to attribute values of the objectClasses attribute type.  The\n\
    \   componentFilterMatch matching rule subsumes the functionality of the\n   objectIdentifierFirstComponentMatch,\
    \ integerFirstComponentMatch and\n   directoryStringFirstComponentMatch matching\
    \ rules.\n   The following search filter finds the object class definition for\
    \ the\n   object class called foobar:\n      (objectClasses:componentFilterMatch:=\n\
    \          item:{ component \"name.*\",\n                 rule caseIgnoreMatch,\
    \ value \"foobar\" })\n   An object class definition can have multiple names and\
    \ the above\n   filter will match an objectClasses value if any one of the names\
    \ is\n   \"foobar\".\n   The component reference \"name.0\" identifies the notional\
    \ count of the\n   number of names in an object class definition.  The following\
    \ search\n   filter finds object class definitions with exactly one name:\n  \
    \    (objectClasses:componentFilterMatch:=\n          item:{ component \"name.0\"\
    , rule integerMatch, value 1 })\n   The \"description\" component of an ObjectClassDescription\
    \ is defined\n   to be an OPTIONAL DirectoryString.  The following search filter\
    \ finds\n   object class definitions that have descriptions, regardless of the\n\
    \   contents of the description string:\n      (objectClasses:componentFilterMatch:=\n\
    \          item:{ component \"description\",\n                 rule presentMatch,\
    \ value NULL })\n   The presentMatch returns TRUE if the description component\
    \ is present\n   and FALSE otherwise.\n   The following search filter finds object\
    \ class definitions that don't\n   have descriptions:\n      (objectClasses:componentFilterMatch:=\n\
    \          not:item:{ component \"description\",\n                     rule presentMatch,\
    \ value NULL })\n   The following search filter finds object class definitions\
    \ with the\n   word \"bogus\" in the description:\n      (objectClasses:componentFilterMatch:=\n\
    \          item:{ component \"description\",\n                 rule caseIgnoreSubstringsMatch,\n\
    \                 value { any:\"bogus\" } })\n   The assertion value is of the\
    \ SubstringAssertion syntax, i.e.,\n      SubstringAssertion ::= SEQUENCE OF CHOICE\
    \ {\n          initial      [0] DirectoryString {ub-match},\n          any   \
    \       [1] DirectoryString {ub-match},\n          final        [2] DirectoryString\
    \ {ub-match} }\n   The \"obsolete\" component of an ObjectClassDescription is\
    \ defined to\n   be DEFAULT FALSE.  An object class is obsolete if the \"obsolete\"\
    \n   component is present and set to TRUE.  The following search filter\n   finds\
    \ all obsolete object classes:\n      (objectClasses:componentFilterMatch:=\n\
    \          item:{ component \"obsolete\", rule booleanMatch, value TRUE })\n \
    \  An object class is not obsolete if the \"obsolete\" component is not\n   present,\
    \ in which case it defaults to FALSE, or is present but is\n   explicitly set\
    \ to FALSE.  The following search filter finds all non-\n   obsolete object classes:\n\
    \      (objectClasses:componentFilterMatch:=\n          item:{ component \"obsolete\"\
    , rule booleanMatch, value FALSE })\n   The useDefaultValues flag in the ComponentAssertion\
    \ defaults to TRUE\n   so the componentFilterMatch rule treats an absent \"obsolete\"\
    \n   component as being present and set to FALSE.  The following search\n   filter\
    \ finds only object class definitions where the \"obsolete\"\n   component has\
    \ been explicitly set to FALSE, rather than implicitly\n   defaulting to FALSE:\n\
    \      (objectClasses:componentFilterMatch:=\n          item:{ component \"obsolete\"\
    , useDefaultValues FALSE,\n                 rule booleanMatch, value FALSE })\n\
    \   With the useDefaultValues flag set to FALSE, if the \"obsolete\"\n   component\
    \ is absent the component reference identifies no component\n   value and the\
    \ matching rule will return FALSE.  The matching rule can\n   only return TRUE\
    \ if the component is present and set to FALSE.\n   The \"information.kind\" component\
    \ of the ObjectClassDescription is an\n   ENUMERATED type.  The allComponentsMatch\
    \ matching rule can be used to\n   match values of an ENUMERATED type.  The following\
    \ search filter\n   finds object class definitions for auxiliary object classes:\n\
    \      (objectClasses:componentFilterMatch:=\n          item:{ component \"information.kind\"\
    ,\n                 rule allComponentsMatch, value auxiliary })\n   The following\
    \ search filter finds auxiliary object classes with\n   commonName (cn or 2.5.4.3)\
    \ as a mandatory attribute:\n      (objectClasses:componentFilterMatch:=and:{\n\
    \          item:{ component \"information.kind\",\n                 rule allComponentsMatch,\
    \ value auxiliary },\n          item:{ component \"information.mandatories.*\"\
    ,\n                 rule objectIdentifierMatch, value cn } })\n   The following\
    \ search filter finds auxiliary object classes with\n   commonName as a mandatory\
    \ or optional attribute:\n      (objectClasses:componentFilterMatch:=and:{\n \
    \         item:{ component \"information.kind\",\n                 rule allComponentsMatch,\
    \ value auxiliary },\n          or:{\n              item:{ component \"information.mandatories.*\"\
    ,\n                     rule objectIdentifierMatch, value cn },\n            \
    \  item:{ component \"information.optionals.*\",\n                     rule objectIdentifierMatch,\
    \ value cn } } })\n   Extra care is required when matching optional SEQUENCE OF\
    \ or SET OF\n   components because of the distinction between an absent list of\n\
    \   instances and a present, but empty, list of instances.  The following\n  \
    \ search filter finds object class definitions with less than three\n   names,\
    \ including object class definitions with a present but empty\n   list of names,\
    \ but does not find object class definitions with an\n   absent list of names:\n\
    \      (objectClasses:componentFilterMatch:=\n          item:{ component \"name.0\"\
    ,\n                 rule integerOrderingMatch, value 3 })\n   If the \"name\"\
    \ component is absent the \"name.0\" component is also\n   considered to be absent\
    \ and the ComponentAssertion evaluates to\n   FALSE.  If the \"name\" component\
    \ is present, but empty, the \"name.0\"\n   component is also present and equal\
    \ to zero, so the\n   ComponentAssertion evaluates to TRUE.  To also find the\
    \ object class\n   definitions with an absent list of names the following search\
    \ filter\n   would be used:\n      (objectClasses:componentFilterMatch:=or:{\n\
    \          not:item:{ component \"name\", rule presentMatch, value NULL },\n \
    \         item:{ component \"name.0\",\n                 rule integerOrderingMatch,\
    \ value 3 } })\n   Distinguished names embedded in other syntaxes can be matched\
    \ with a\n   componentFilterMatch.  The uniqueMember attribute type has an\n \
    \  attribute syntax described by the ASN.1 type NameAndOptionalUID.\n      NameAndOptionalUID\
    \ ::= SEQUENCE {\n          dn        DistinguishedName,\n          uid      \
    \ UniqueIdentifier OPTIONAL }\n   The following search filter finds values of\
    \ the uniqueMember\n   attribute containing the author's DN:\n      (uniqueMember:componentFilterMatch:=\n\
    \          item:{ component \"dn\",\n                 rule distinguishedNameMatch,\n\
    \                 value \"cn=Steven Legg,o=Adacel,c=AU\" })\n   The DistinguishedName\
    \ and RelativeDistinguishedName ASN.1 types are\n   also complex ASN.1 types so\
    \ the component matching rules can be\n   applied to their inner components.\n\
    \      DistinguishedName   ::= RDNSequence\n      RDNSequence ::= SEQUENCE OF\
    \ RelativeDistinguishedName\n      RelativeDistinguishedName ::= SET SIZE (1..MAX)\
    \ OF\n          AttributeTypeAndValue\n      AttributeTypeAndValue ::= SEQUENCE\
    \ {\n          type        AttributeType ({SupportedAttributes}),\n          value\
    \       AttributeValue ({SupportedAttributes}{@type}) }\n      AttributeType ::=\
    \ ATTRIBUTE.&id\n      AttributeValue ::= ATTRIBUTE.&Type\n   ATTRIBUTE.&Type\
    \ is an open type.  A value of ATTRIBUTE.&Type is\n   constrained by the type\
    \ component of AttributeTypeAndValue to be of\n   the attribute syntax of the\
    \ nominated attribute type.  Note: the\n   fourth edition of X.500 extends and\
    \ renames the AttributeTypeAndValue\n   SEQUENCE type.\n   The seeAlso attribute\
    \ has the DistinguishedName syntax.  The\n   following search filter finds seeAlso\
    \ attribute values containing the\n   RDN, \"o=Adacel\", anywhere in the DN:\n\
    \      (seeAlso:componentFilterMatch:=\n          item:{ component \"*\", rule\
    \ rdnMatch, value \"o=Adacel\" })\n   The following search filter finds all seeAlso\
    \ attribute values with\n   \"cn=Steven Legg\" as the RDN of the named entry (i.e.,\
    \ the \"first\" RDN\n   in an LDAPDN or the \"last\" RDN in an X.500 DN):\n  \
    \    (seeAlso:componentFilterMatch:=\n          item:{ component \"-1\",\n   \
    \              rule rdnMatch, value \"cn=Steven Legg\" })\n   The following search\
    \ filter finds all seeAlso attribute values naming\n   entries in the DIT subtree\
    \ of \"o=Adacel,c=AU\":\n      (seeAlso:componentFilterMatch:=and:{\n        \
    \  item:{ component \"1\", rule rdnMatch, value \"c=AU\" },\n          item:{\
    \ component \"2\", rule rdnMatch, value \"o=Adacel\" } })\n   The following search\
    \ filter finds all seeAlso attribute values\n   containing the naming attribute\
    \ types commonName (cn) and\n   telephoneNumber in the same RDN:\n      (seeAlso:componentFilterMatch:=\n\
    \          item:{ component \"*\", rule componentFilterMatch,\n              \
    \   value and:{\n                     item:{ component \"*.type\",\n         \
    \                   rule objectIdentifierMatch, value cn },\n                \
    \     item:{ component \"*.type\",\n                            rule objectIdentifierMatch,\n\
    \                            value telephoneNumber } } })\n   The following search\
    \ filter would find all seeAlso attribute values\n   containing the attribute\
    \ types commonName and telephoneNumber, but\n   not necessarily in the same RDN:\n\
    \      (seeAlso:componentFilterMatch:=and:{\n          item:{ component \"*.*.type\"\
    ,\n                 rule objectIdentifierMatch, value cn },\n          item:{\
    \ component \"*.*.type\",\n                 rule objectIdentifierMatch, value\
    \ telephoneNumber } })\n   The following search filter finds all seeAlso attribute\
    \ values\n   containing the word \"Adacel\" in any organizationalUnitName (ou)\n\
    \   attribute value in any AttributeTypeAndValue of any RDN:\n      (seeAlso:componentFilterMatch:=\n\
    \          item:{ component \"*.*.value.(2.5.4.11)\",\n                 rule caseIgnoreSubstringsMatch,\n\
    \                 value { any:\"Adacel\" } })\n   The component reference \"*.*.value\"\
    \ identifies an open type, in this\n   case an attribute value.  In a particular\
    \ AttributeTypeAndValue, if\n   the attribute type is not organizationalUnitName\
    \ then the\n   ComponentAssertion evaluates to FALSE.  Otherwise the substring\n\
    \   assertion is evaluated against the attribute value.\n   Absent component references\
    \ in ComponentAssertions can be exploited\n   to avoid false positive matches\
    \ on multi-valued attributes.  For\n   example, suppose there is a multi-valued\
    \ attribute named\n   productCodes, defined to have the Integer syntax\n   (1.3.6.1.4.1.1466.115.121.1.27).\
    \  Consider the following search\n   filter:\n      (&(!(productCodes:integerOrderingMatch:=3))\n\
    \        (productCodes:integerOrderingMatch:=8))\n   An entry whose productCodes\
    \ attribute contains only the values 1 and\n   10 will match the above filter.\
    \  The first subfilter is satisfied by\n   the value 10 (10 is not less than 3),\
    \ and the second subfilter is\n   satisfied by the value 1 (1 is less than 8).\
    \  The following search\n   filter can be used instead to only match entries that\
    \ have a\n   productCodes value in the range 3 to 7, because the ComponentFilter\n\
    \   is evaluated against each productCodes value in isolation:\n      (productCodes:componentFilterMatch:=\
    \ and:{\n           not:item:{ rule integerOrderingMatch, value 3 },\n       \
    \   item:{ rule integerOrderingMatch, value 8 } })\n   An entry whose productCodes\
    \ attribute contains only the values 1 and\n   10 will not match the above filter.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The component matching rules described in this\
    \ document allow for a\n   compact specification of matching capabilities that\
    \ could otherwise\n   have been defined by a plethora of specific matching rules,\
    \ i.e.,\n   despite their expressiveness and flexibility the component matching\n\
    \   rules do not behave in a way uncharacteristic of other matching\n   rules,\
    \ so the security issues for component matching rules are no\n   different than\
    \ for any other matching rule.  However, because the\n   component matching rules\
    \ are applicable to any attribute syntax,\n   support for them in a directory\
    \ server may allow searching of\n   attributes that were previously unsearchable\
    \ by virtue of there not\n   being a suitable matching rule.  Such attribute types\
    \ ought to be\n   properly protected with appropriate access controls.  A generic,\n\
    \   interoperable access control mechanism has not yet been developed,\n   however,\
    \ and implementors should be aware of the interaction of that\n   lack with the\
    \ increased risk of exposure described above.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   The author would like to thank Tom Gindin for private\
    \ email\n   discussions that clarified and refined the ideas presented in this\n\
    \   document.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) has\
    \ updated the LDAP\n   descriptors registry [8] as indicated by the following\
    \ templates:\n      Subject: Request for LDAP Descriptor Registration\n      Descriptor\
    \ (short name): componentFilterMatch\n      Object Identifier: 1.2.36.79672281.1.13.2\n\
    \      Person & email address to contact for further information:\n        Steven\
    \ Legg <steven.legg@adacel.com.au>\n      Usage: other (matching rule)\n     \
    \ Specification: RFC 3687\n      Author/Change Controller: IESG\n      Subject:\
    \ Request for LDAP Descriptor Registration\n      Descriptor (short name): rdnMatch\n\
    \      Object Identifier: 1.2.36.79672281.1.13.3\n      Person & email address\
    \ to contact for further information:\n        Steven Legg <steven.legg@adacel.com.au>\n\
    \      Usage: other (matching rule)\n      Specification: RFC 3687\n      Author/Change\
    \ Controller: IESG\n      Subject: Request for LDAP Descriptor Registration\n\
    \      Descriptor (short name): presentMatch\n      Object Identifier: 1.2.36.79672281.1.13.5\n\
    \      Person & email address to contact for further information:\n        Steven\
    \ Legg <steven.legg@adacel.com.au>\n      Usage: other (matching rule)\n     \
    \ Specification: RFC 3687\n      Author/Change Controller: IESG\n      Subject:\
    \ Request for LDAP Descriptor Registration\n      Descriptor (short name): allComponentsMatch\n\
    \      Object Identifier: 1.2.36.79672281.1.13.6\n      Person & email address\
    \ to contact for further information:\n        Steven Legg <steven.legg@adacel.com.au>\n\
    \      Usage: other (matching rule)\n      Specification: RFC 3687\n      Author/Change\
    \ Controller: IESG\n      Subject: Request for LDAP Descriptor Registration\n\
    \      Descriptor (short name): directoryComponentsMatch\n      Object Identifier:\
    \ 1.2.36.79672281.1.13.7\n      Person & email address to contact for further\
    \ information:\n        Steven Legg <steven.legg@adacel.com.au>\n      Usage:\
    \ other (matching rule)\n      Specification: RFC 3687\n      Author/Change Controller:\
    \ IESG\n   The object identifiers have been assigned for use in this\n   specification\
    \ by Adacel Technologies, under an arc assigned to Adacel\n   by Standards Australia.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [1]   Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [2]   Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n      \
    \   Specifications: ABNF\", RFC 2234, November 1997.\n   [3]   Wahl, M., Howes,\
    \ T. and S. Kille, \"Lightweight Directory Access\n         Protocol (v3)\", RFC\
    \ 2251, December 1997.\n   [4]   Wahl, M., Coulbeck, A., Howes, T. and S. Kille,\
    \ \"Lightweight\n         Directory Access Protocol (v3): Attribute Syntax Definitions\"\
    ,\n         RFC 2252, December 1997.\n   [5]   Wahl, M., Kille S. and T. Howes.\
    \ \"Lightweight Directory Access\n         Protocol (v3): UTF-8 String Representation\
    \ of Distinguished\n         Names\", RFC 2253, December 1997.\n   [6]   Yergeau,\
    \ F., \"UTF-8, a transformation format of ISO 10646\", STD\n         63, RFC 3629,\
    \ November 2003.\n   [7]   Hodges, J. and R. Morgan, \"Lightweight Directory Access\n\
    \         Protocol (v3): Technical Specification\", RFC 3377, September\n    \
    \     2002.\n   [8]   Zeilenga, K., \"Internet Assigned Numbers Authority (IANA)\n\
    \         Considerations for the Lightweight Directory Access Protocol\n     \
    \    (LDAP)\", BCP 64, RFC 3383, September 2002.\n   [9]   Legg, S., \"Generic\
    \ String Encoding Rules (GSER) for ASN.1\n         Types\", RFC 3641, October\
    \ 2003.\n   [10]  ITU-T Recommendation X.501 (1993) | ISO/IEC 9594-2:1994,\n \
    \        Information Technology - Open Systems Interconnection - The\n       \
    \  Directory: Models\n   [11]  ITU-T Recommendation X.509 (1997) | ISO/IEC 9594-8:1998,\n\
    \         Information Technology - Open Systems Interconnection - The\n      \
    \   Directory: Authentication Framework\n   [12]  ITU-T Recommendation X.520 (1993)\
    \ | ISO/IEC 9594-6:1994,\n         Information technology - Open Systems Interconnection\
    \ - The\n         Directory: Selected attribute types\n   [13]  ITU-T Recommendation\
    \ X.680 (07/02) | ISO/IEC 8824-1:2002,\n         Information technology - Abstract\
    \ Syntax Notation One (ASN.1):\n         Specification of basic notation\n   [14]\
    \  ITU-T Recommendation X.681 (07/02) | ISO/IEC 8824-2:2002,\n         Information\
    \ technology - Abstract Syntax Notation One (ASN.1):\n         Information object\
    \ specification\n   [15]  ITU-T Recommendation X.682 (07/02) | ISO/IEC 8824-3:2002,\n\
    \         Information technology - Abstract Syntax Notation One (ASN.1):\n   \
    \      Constraint specification\n   [16]  ITU-T Recommendation X.683 (07/02) |\
    \ ISO/IEC 8824-4:2002,\n         Information technology - Abstract Syntax Notation\
    \ One (ASN.1):\n         Parameterization of ASN.1 specifications\n   [17]  ITU-T\
    \ Recommendation X.690 (07/02) | ISO/IEC 8825-1,\n         Information technology\
    \ - ASN.1 encoding rules: Specification of\n         Basic Encoding Rules (BER),\
    \ Canonical Encoding Rules (CER) and\n         Distinguished Encoding Rules (DER)\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [18]  Howes, T., \"The String Representation\
    \ of LDAP Search Filters\",\n         RFC 2254, December 1997.\n   [19]  ITU-T\
    \ Recommendation X.500 (1993) | ISO/IEC 9594-1:1994,\n         Information Technology\
    \ - Open Systems Interconnection - The\n         Directory: Overview of concepts,\
    \ models and services\n"
- title: 12.  Intellectual Property Statement
  contents:
  - "12.  Intellectual Property Statement\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11. Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 13.  Author's Address
  contents:
  - "13.  Author's Address\n   Steven Legg\n   Adacel Technologies Ltd.\n   250 Bay\
    \ Street\n   Brighton, Victoria 3186\n   AUSTRALIA\n   Phone: +61 3 8530 7710\n\
    \   Fax:   +61 3 8530 7888\n   EMail: steven.legg@adacel.com.au\n"
- title: 14.  Full Copyright Statement
  contents:
  - "14.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assignees.\n\
    \   This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
