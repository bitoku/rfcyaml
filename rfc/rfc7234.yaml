- title: __initial_text__
  contents:
  - '            Hypertext Transfer Protocol (HTTP/1.1): Caching

    '
- title: Abstract
  contents:
  - "Abstract\n   The Hypertext Transfer Protocol (HTTP) is a stateless application-\n\
    \   level protocol for distributed, collaborative, hypertext information\n   systems.\
    \  This document defines HTTP caches and the associated header\n   fields that\
    \ control cache behavior or indicate cacheable response\n   messages.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7234.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Conformance and Error Handling .............................4\n  \
    \    1.2. Syntax Notation ............................................4\n    \
    \       1.2.1. Delta Seconds .......................................5\n   2. Overview\
    \ of Cache Operation .....................................5\n   3. Storing Responses\
    \ in Caches .....................................6\n      3.1. Storing Incomplete\
    \ Responses ...............................7\n      3.2. Storing Responses to\
    \ Authenticated Requests ................7\n      3.3. Combining Partial Content\
    \ ..................................8\n   4. Constructing Responses from Caches\
    \ ..............................8\n      4.1. Calculating Secondary Keys with\
    \ Vary .......................9\n      4.2. Freshness .................................................11\n\
    \           4.2.1. Calculating Freshness Lifetime .....................12\n  \
    \         4.2.2. Calculating Heuristic Freshness ....................13\n    \
    \       4.2.3. Calculating Age ....................................13\n      \
    \     4.2.4. Serving Stale Responses ............................15\n      4.3.\
    \ Validation ................................................16\n           4.3.1.\
    \ Sending a Validation Request .......................16\n           4.3.2. Handling\
    \ a Received Validation Request .............16\n           4.3.3. Handling a\
    \ Validation Response .....................18\n           4.3.4. Freshening Stored\
    \ Responses upon Validation ........18\n           4.3.5. Freshening Responses\
    \ via HEAD ......................19\n      4.4. Invalidation ..............................................20\n\
    \   5. Header Field Definitions .......................................21\n  \
    \    5.1. Age .......................................................21\n    \
    \  5.2. Cache-Control .............................................21\n      \
    \     5.2.1. Request Cache-Control Directives ...................22\n        \
    \   5.2.2. Response Cache-Control Directives ..................24\n          \
    \ 5.2.3. Cache Control Extensions ...........................27\n      5.3. Expires\
    \ ...................................................28\n      5.4. Pragma ....................................................29\n\
    \      5.5. Warning ...................................................29\n  \
    \         5.5.1. Warning: 110 - \"Response is Stale\" .................31\n  \
    \         5.5.2. Warning: 111 - \"Revalidation Failed\" ...............31\n  \
    \         5.5.3. Warning: 112 - \"Disconnected Operation\" ............31\n  \
    \         5.5.4. Warning: 113 - \"Heuristic Expiration\" ..............31\n  \
    \         5.5.5. Warning: 199 - \"Miscellaneous Warning\" .............32\n  \
    \         5.5.6. Warning: 214 - \"Transformation Applied\" ............32\n  \
    \         5.5.7. Warning: 299 - \"Miscellaneous Persistent Warning\" ..32\n  \
    \ 6. History Lists ..................................................32\n   7.\
    \ IANA Considerations ............................................32\n      7.1.\
    \ Cache Directive Registry ..................................32\n           7.1.1.\
    \ Procedure ..........................................32\n           7.1.2. Considerations\
    \ for New Cache Control Directives ....33\n           7.1.3. Registrations ......................................33\n\
    \      7.2. Warn Code Registry ........................................34\n  \
    \         7.2.1. Procedure ..........................................34\n    \
    \       7.2.2. Registrations ......................................34\n      7.3.\
    \ Header Field Registration .................................34\n   8. Security\
    \ Considerations ........................................35\n   9. Acknowledgments\
    \ ................................................36\n   10. References ....................................................36\n\
    \      10.1. Normative References .....................................36\n  \
    \    10.2. Informative References ...................................37\n   Appendix\
    \ A. Changes from RFC 2616 .................................38\n   Appendix B.\
    \ Imported ABNF .........................................39\n   Appendix C. Collected\
    \ ABNF ........................................39\n   Index .............................................................41\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   HTTP is typically used for distributed information systems,\
    \ where\n   performance can be improved by the use of response caches.  This\n\
    \   document defines aspects of HTTP/1.1 related to caching and reusing\n   response\
    \ messages.\n   An HTTP cache is a local store of response messages and the subsystem\n\
    \   that controls storage, retrieval, and deletion of messages in it.  A\n   cache\
    \ stores cacheable responses in order to reduce the response time\n   and network\
    \ bandwidth consumption on future, equivalent requests.\n   Any client or server\
    \ MAY employ a cache, though a cache cannot be\n   used by a server that is acting\
    \ as a tunnel.\n   A shared cache is a cache that stores responses to be reused\
    \ by more\n   than one user; shared caches are usually (but not always) deployed\
    \ as\n   a part of an intermediary.  A private cache, in contrast, is\n   dedicated\
    \ to a single user; often, they are deployed as a component\n   of a user agent.\n\
    \   The goal of caching in HTTP/1.1 is to significantly improve\n   performance\
    \ by reusing a prior response message to satisfy a current\n   request.  A stored\
    \ response is considered \"fresh\", as defined in\n   Section 4.2, if the response\
    \ can be reused without \"validation\"\n   (checking with the origin server to\
    \ see if the cached response\n   remains valid for this request).  A fresh response\
    \ can therefore\n   reduce both latency and network overhead each time it is reused.\n\
    \   When a cached response is not fresh, it might still be reusable if it\n  \
    \ can be freshened by validation (Section 4.3) or if the origin is\n   unavailable\
    \ (Section 4.2.4).\n"
- title: 1.1.  Conformance and Error Handling
  contents:
  - "1.1.  Conformance and Error Handling\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n   Conformance criteria and considerations regarding error handling\
    \ are\n   defined in Section 2.5 of [RFC7230].\n"
- title: 1.2.  Syntax Notation
  contents:
  - "1.2.  Syntax Notation\n   This specification uses the Augmented Backus-Naur Form\
    \ (ABNF)\n   notation of [RFC5234] with a list extension, defined in Section 7\
    \ of\n   [RFC7230], that allows for compact definition of comma-separated\n  \
    \ lists using a '#' operator (similar to how the '*' operator indicates\n   repetition).\
    \  Appendix B describes rules imported from other\n   documents.  Appendix C shows\
    \ the collected grammar with all list\n   operators expanded to standard ABNF\
    \ notation.\n"
- title: 1.2.1.  Delta Seconds
  contents:
  - "1.2.1.  Delta Seconds\n   The delta-seconds rule specifies a non-negative integer,\
    \ representing\n   time in seconds.\n     delta-seconds  = 1*DIGIT\n   A recipient\
    \ parsing a delta-seconds value and converting it to binary\n   form ought to\
    \ use an arithmetic type of at least 31 bits of\n   non-negative integer range.\
    \  If a cache receives a delta-seconds\n   value greater than the greatest integer\
    \ it can represent, or if any\n   of its subsequent calculations overflows, the\
    \ cache MUST consider the\n   value to be either 2147483648 (2^31) or the greatest\
    \ positive integer\n   it can conveniently represent.\n      Note: The value 2147483648\
    \ is here for historical reasons,\n      effectively represents infinity (over\
    \ 68 years), and does not need\n      to be stored in binary form; an implementation\
    \ could produce it as\n      a canned string if any overflow occurs, even if the\
    \ calculations\n      are performed with an arithmetic type incapable of directly\n\
    \      representing that number.  What matters here is that an overflow\n    \
    \  be detected and not treated as a negative value in later\n      calculations.\n"
- title: 2.  Overview of Cache Operation
  contents:
  - "2.  Overview of Cache Operation\n   Proper cache operation preserves the semantics\
    \ of HTTP transfers\n   ([RFC7231]) while eliminating the transfer of information\
    \ already\n   held in the cache.  Although caching is an entirely OPTIONAL feature\n\
    \   of HTTP, it can be assumed that reusing a cached response is\n   desirable\
    \ and that such reuse is the default behavior when no\n   requirement or local\
    \ configuration prevents it.  Therefore, HTTP\n   cache requirements are focused\
    \ on preventing a cache from either\n   storing a non-reusable response or reusing\
    \ a stored response\n   inappropriately, rather than mandating that caches always\
    \ store and\n   reuse particular responses.\n   Each cache entry consists of a\
    \ cache key and one or more HTTP\n   responses corresponding to prior requests\
    \ that used the same key.\n   The most common form of cache entry is a successful\
    \ result of a\n   retrieval request: i.e., a 200 (OK) response to a GET request,\
    \ which\n   contains a representation of the resource identified by the request\n\
    \   target (Section 4.3.1 of [RFC7231]).  However, it is also possible to\n  \
    \ cache permanent redirects, negative results (e.g., 404 (Not Found)),\n   incomplete\
    \ results (e.g., 206 (Partial Content)), and responses to\n   methods other than\
    \ GET if the method's definition allows such caching\n   and defines something\
    \ suitable for use as a cache key.\n   The primary cache key consists of the request\
    \ method and target URI.\n   However, since HTTP caches in common use today are\
    \ typically limited\n   to caching responses to GET, many caches simply decline\
    \ other methods\n   and use only the URI as the primary cache key.\n   If a request\
    \ target is subject to content negotiation, its cache\n   entry might consist\
    \ of multiple stored responses, each differentiated\n   by a secondary key for\
    \ the values of the original request's selecting\n   header fields (Section 4.1).\n"
- title: 3.  Storing Responses in Caches
  contents:
  - "3.  Storing Responses in Caches\n   A cache MUST NOT store a response to any\
    \ request, unless:\n   o  The request method is understood by the cache and defined\
    \ as being\n      cacheable, and\n   o  the response status code is understood\
    \ by the cache, and\n   o  the \"no-store\" cache directive (see Section 5.2)\
    \ does not appear\n      in request or response header fields, and\n   o  the\
    \ \"private\" response directive (see Section 5.2.2.6) does not\n      appear\
    \ in the response, if the cache is shared, and\n   o  the Authorization header\
    \ field (see Section 4.2 of [RFC7235]) does\n      not appear in the request,\
    \ if the cache is shared, unless the\n      response explicitly allows it (see\
    \ Section 3.2), and\n   o  the response either:\n      *  contains an Expires\
    \ header field (see Section 5.3), or\n      *  contains a max-age response directive\
    \ (see Section 5.2.2.8), or\n      *  contains a s-maxage response directive (see\
    \ Section 5.2.2.9)\n         and the cache is shared, or\n      *  contains a\
    \ Cache Control Extension (see Section 5.2.3) that\n         allows it to be cached,\
    \ or\n      *  has a status code that is defined as cacheable by default (see\n\
    \         Section 4.2.2), or\n      *  contains a public response directive (see\
    \ Section 5.2.2.5).\n   Note that any of the requirements listed above can be\
    \ overridden by a\n   cache-control extension; see Section 5.2.3.\n   In this\
    \ context, a cache has \"understood\" a request method or a\n   response status\
    \ code if it recognizes it and implements all specified\n   caching-related behavior.\n\
    \   Note that, in normal operation, some caches will not store a response\n  \
    \ that has neither a cache validator nor an explicit expiration time,\n   as such\
    \ responses are not usually useful to store.  However, caches\n   are not prohibited\
    \ from storing such responses.\n"
- title: 3.1.  Storing Incomplete Responses
  contents:
  - "3.1.  Storing Incomplete Responses\n   A response message is considered complete\
    \ when all of the octets\n   indicated by the message framing ([RFC7230]) are\
    \ received prior to\n   the connection being closed.  If the request method is\
    \ GET, the\n   response status code is 200 (OK), and the entire response header\n\
    \   section has been received, a cache MAY store an incomplete response\n   message\
    \ body if the cache entry is recorded as incomplete.  Likewise,\n   a 206 (Partial\
    \ Content) response MAY be stored as if it were an\n   incomplete 200 (OK) cache\
    \ entry.  However, a cache MUST NOT store\n   incomplete or partial-content responses\
    \ if it does not support the\n   Range and Content-Range header fields or if it\
    \ does not understand\n   the range units used in those fields.\n   A cache MAY\
    \ complete a stored incomplete response by making a\n   subsequent range request\
    \ ([RFC7233]) and combining the successful\n   response with the stored entry,\
    \ as defined in Section 3.3.  A cache\n   MUST NOT use an incomplete response\
    \ to answer requests unless the\n   response has been made complete or the request\
    \ is partial and\n   specifies a range that is wholly within the incomplete response.\
    \  A\n   cache MUST NOT send a partial response to a client without explicitly\n\
    \   marking it as such using the 206 (Partial Content) status code.\n"
- title: 3.2.  Storing Responses to Authenticated Requests
  contents:
  - "3.2.  Storing Responses to Authenticated Requests\n   A shared cache MUST NOT\
    \ use a cached response to a request with an\n   Authorization header field (Section\
    \ 4.2 of [RFC7235]) to satisfy any\n   subsequent request unless a cache directive\
    \ that allows such\n   responses to be stored is present in the response.\n  \
    \ In this specification, the following Cache-Control response\n   directives (Section\
    \ 5.2.2) have such an effect: must-revalidate,\n   public, and s-maxage.\n   Note\
    \ that cached responses that contain the \"must-revalidate\" and/or\n   \"s-maxage\"\
    \ response directives are not allowed to be served stale\n   (Section 4.2.4) by\
    \ shared caches.  In particular, a response with\n   either \"max-age=0, must-revalidate\"\
    \ or \"s-maxage=0\" cannot be used to\n   satisfy a subsequent request without\
    \ revalidating it on the origin\n   server.\n"
- title: 3.3.  Combining Partial Content
  contents:
  - "3.3.  Combining Partial Content\n   A response might transfer only a partial\
    \ representation if the\n   connection closed prematurely or if the request used\
    \ one or more\n   Range specifiers ([RFC7233]).  After several such transfers,\
    \ a cache\n   might have received several ranges of the same representation. \
    \ A\n   cache MAY combine these ranges into a single stored response, and\n  \
    \ reuse that response to satisfy later requests, if they all share the\n   same\
    \ strong validator and the cache complies with the client\n   requirements in\
    \ Section 4.3 of [RFC7233].\n   When combining the new response with one or more\
    \ stored responses, a\n   cache MUST:\n   o  delete any Warning header fields\
    \ in the stored response with\n      warn-code 1xx (see Section 5.5);\n   o  retain\
    \ any Warning header fields in the stored response with\n      warn-code 2xx;\
    \ and,\n   o  use other header fields provided in the new response, aside from\n\
    \      Content-Range, to replace all instances of the corresponding\n      header\
    \ fields in the stored response.\n"
- title: 4.  Constructing Responses from Caches
  contents:
  - "4.  Constructing Responses from Caches\n   When presented with a request, a cache\
    \ MUST NOT reuse a stored\n   response, unless:\n   o  The presented effective\
    \ request URI (Section 5.5 of [RFC7230]) and\n      that of the stored response\
    \ match, and\n   o  the request method associated with the stored response allows\
    \ it\n      to be used for the presented request, and\n   o  selecting header\
    \ fields nominated by the stored response (if any)\n      match those presented\
    \ (see Section 4.1), and\n   o  the presented request does not contain the no-cache\
    \ pragma\n      (Section 5.4), nor the no-cache cache directive (Section 5.2.1),\n\
    \      unless the stored response is successfully validated\n      (Section 4.3),\
    \ and\n   o  the stored response does not contain the no-cache cache directive\n\
    \      (Section 5.2.2.2), unless it is successfully validated\n      (Section\
    \ 4.3), and\n   o  the stored response is either:\n      *  fresh (see Section\
    \ 4.2), or\n      *  allowed to be served stale (see Section 4.2.4), or\n    \
    \  *  successfully validated (see Section 4.3).\n   Note that any of the requirements\
    \ listed above can be overridden by a\n   cache-control extension; see Section\
    \ 5.2.3.\n   When a stored response is used to satisfy a request without\n   validation,\
    \ a cache MUST generate an Age header field (Section 5.1),\n   replacing any present\
    \ in the response with a value equal to the\n   stored response's current_age;\
    \ see Section 4.2.3.\n   A cache MUST write through requests with methods that\
    \ are unsafe\n   (Section 4.2.1 of [RFC7231]) to the origin server; i.e., a cache\
    \ is\n   not allowed to generate a reply to such a request before having\n   forwarded\
    \ the request and having received a corresponding response.\n   Also, note that\
    \ unsafe requests might invalidate already-stored\n   responses; see Section 4.4.\n\
    \   When more than one suitable response is stored, a cache MUST use the\n   most\
    \ recent response (as determined by the Date header field).  It\n   can also forward\
    \ the request with \"Cache-Control: max-age=0\" or\n   \"Cache-Control: no-cache\"\
    \ to disambiguate which response to use.\n   A cache that does not have a clock\
    \ available MUST NOT use stored\n   responses without revalidating them upon every\
    \ use.\n"
- title: 4.1.  Calculating Secondary Keys with Vary
  contents:
  - "4.1.  Calculating Secondary Keys with Vary\n   When a cache receives a request\
    \ that can be satisfied by a stored\n   response that has a Vary header field\
    \ (Section 7.1.4 of [RFC7231]),\n   it MUST NOT use that response unless all of\
    \ the selecting header\n   fields nominated by the Vary header field match in\
    \ both the original\n   request (i.e., that associated with the stored response),\
    \ and the\n   presented request.\n   The selecting header fields from two requests\
    \ are defined to match if\n   and only if those in the first request can be transformed\
    \ to those in\n   the second request by applying any of the following:\n   o \
    \ adding or removing whitespace, where allowed in the header field's\n      syntax\n\
    \   o  combining multiple header fields with the same field name (see\n      Section\
    \ 3.2 of [RFC7230])\n   o  normalizing both header field values in a way that\
    \ is known to\n      have identical semantics, according to the header field's\n\
    \      specification (e.g., reordering field values when order is not\n      significant;\
    \ case-normalization, where values are defined to be\n      case-insensitive)\n\
    \   If (after any normalization that might take place) a header field is\n   absent\
    \ from a request, it can only match another request if it is\n   also absent there.\n\
    \   A Vary header field-value of \"*\" always fails to match.\n   The stored response\
    \ with matching selecting header fields is known as\n   the selected response.\n\
    \   If multiple selected responses are available (potentially including\n   responses\
    \ without a Vary header field), the cache will need to choose\n   one to use.\
    \  When a selecting header field has a known mechanism for\n   doing so (e.g.,\
    \ qvalues on Accept and similar request header fields),\n   that mechanism MAY\
    \ be used to select preferred responses; of the\n   remainder, the most recent\
    \ response (as determined by the Date header\n   field) is used, as per Section\
    \ 4.\n   If no selected response is available, the cache cannot satisfy the\n\
    \   presented request.  Typically, it is forwarded to the origin server\n   in\
    \ a (possibly conditional; see Section 4.3) request.\n"
- title: 4.2.  Freshness
  contents:
  - "4.2.  Freshness\n   A fresh response is one whose age has not yet exceeded its\
    \ freshness\n   lifetime.  Conversely, a stale response is one where it has.\n\
    \   A response's freshness lifetime is the length of time between its\n   generation\
    \ by the origin server and its expiration time.  An explicit\n   expiration time\
    \ is the time at which the origin server intends that a\n   stored response can\
    \ no longer be used by a cache without further\n   validation, whereas a heuristic\
    \ expiration time is assigned by a\n   cache when no explicit expiration time\
    \ is available.\n   A response's age is the time that has passed since it was\
    \ generated\n   by, or successfully validated with, the origin server.\n   When\
    \ a response is \"fresh\" in the cache, it can be used to satisfy\n   subsequent\
    \ requests without contacting the origin server, thereby\n   improving efficiency.\n\
    \   The primary mechanism for determining freshness is for an origin\n   server\
    \ to provide an explicit expiration time in the future, using\n   either the Expires\
    \ header field (Section 5.3) or the max-age response\n   directive (Section 5.2.2.8).\
    \  Generally, origin servers will assign\n   future explicit expiration times\
    \ to responses in the belief that the\n   representation is not likely to change\
    \ in a semantically significant\n   way before the expiration time is reached.\n\
    \   If an origin server wishes to force a cache to validate every\n   request,\
    \ it can assign an explicit expiration time in the past to\n   indicate that the\
    \ response is already stale.  Compliant caches will\n   normally validate a stale\
    \ cached response before reusing it for\n   subsequent requests (see Section 4.2.4).\n\
    \   Since origin servers do not always provide explicit expiration times,\n  \
    \ caches are also allowed to use a heuristic to determine an expiration\n   time\
    \ under certain circumstances (see Section 4.2.2).\n   The calculation to determine\
    \ if a response is fresh is:\n      response_is_fresh = (freshness_lifetime >\
    \ current_age)\n   freshness_lifetime is defined in Section 4.2.1; current_age\
    \ is\n   defined in Section 4.2.3.\n   Clients can send the max-age or min-fresh\
    \ cache directives in a\n   request to constrain or relax freshness calculations\
    \ for the\n   corresponding response (Section 5.2.1).\n   When calculating freshness,\
    \ to avoid common problems in date parsing:\n   o  Although all date formats are\
    \ specified to be case-sensitive, a\n      cache recipient SHOULD match day, week,\
    \ and time-zone names\n      case-insensitively.\n   o  If a cache recipient's\
    \ internal implementation of time has less\n      resolution than the value of\
    \ an HTTP-date, the recipient MUST\n      internally represent a parsed Expires\
    \ date as the nearest time\n      equal to or earlier than the received value.\n\
    \   o  A cache recipient MUST NOT allow local time zones to influence the\n  \
    \    calculation or comparison of an age or expiration time.\n   o  A cache recipient\
    \ SHOULD consider a date with a zone abbreviation\n      other than GMT or UTC\
    \ to be invalid for calculating expiration.\n   Note that freshness applies only\
    \ to cache operation; it cannot be\n   used to force a user agent to refresh its\
    \ display or reload a\n   resource.  See Section 6 for an explanation of the difference\
    \ between\n   caches and history mechanisms.\n"
- title: 4.2.1.  Calculating Freshness Lifetime
  contents:
  - "4.2.1.  Calculating Freshness Lifetime\n   A cache can calculate the freshness\
    \ lifetime (denoted as\n   freshness_lifetime) of a response by using the first\
    \ match of the\n   following:\n   o  If the cache is shared and the s-maxage response\
    \ directive\n      (Section 5.2.2.9) is present, use its value, or\n   o  If the\
    \ max-age response directive (Section 5.2.2.8) is present,\n      use its value,\
    \ or\n   o  If the Expires response header field (Section 5.3) is present, use\n\
    \      its value minus the value of the Date response header field, or\n   o \
    \ Otherwise, no explicit expiration time is present in the response.\n      A\
    \ heuristic freshness lifetime might be applicable; see\n      Section 4.2.2.\n\
    \   Note that this calculation is not vulnerable to clock skew, since all\n  \
    \ of the information comes from the origin server.\n   When there is more than\
    \ one value present for a given directive\n   (e.g., two Expires header fields,\
    \ multiple Cache-Control: max-age\n   directives), the directive's value is considered\
    \ invalid.  Caches are\n   encouraged to consider responses that have invalid\
    \ freshness\n   information to be stale.\n"
- title: 4.2.2.  Calculating Heuristic Freshness
  contents:
  - "4.2.2.  Calculating Heuristic Freshness\n   Since origin servers do not always\
    \ provide explicit expiration times,\n   a cache MAY assign a heuristic expiration\
    \ time when an explicit time\n   is not specified, employing algorithms that use\
    \ other header field\n   values (such as the Last-Modified time) to estimate a\
    \ plausible\n   expiration time.  This specification does not provide specific\n\
    \   algorithms, but does impose worst-case constraints on their results.\n   A\
    \ cache MUST NOT use heuristics to determine freshness when an\n   explicit expiration\
    \ time is present in the stored response.  Because\n   of the requirements in\
    \ Section 3, this means that, effectively,\n   heuristics can only be used on\
    \ responses without explicit freshness\n   whose status codes are defined as cacheable\
    \ by default (see Section\n   6.1 of [RFC7231]), and those responses without explicit\
    \ freshness\n   that have been marked as explicitly cacheable (e.g., with a \"\
    public\"\n   response directive).\n   If the response has a Last-Modified header\
    \ field (Section 2.2 of\n   [RFC7232]), caches are encouraged to use a heuristic\
    \ expiration value\n   that is no more than some fraction of the interval since\
    \ that time.\n   A typical setting of this fraction might be 10%.\n   When a heuristic\
    \ is used to calculate freshness lifetime, a cache\n   SHOULD generate a Warning\
    \ header field with a 113 warn-code (see\n   Section 5.5.4) in the response if\
    \ its current_age is more than 24\n   hours and such a warning is not already\
    \ present.\n      Note: Section 13.9 of [RFC2616] prohibited caches from calculating\n\
    \      heuristic freshness for URIs with query components (i.e., those\n     \
    \ containing '?').  In practice, this has not been widely\n      implemented.\
    \  Therefore, origin servers are encouraged to send\n      explicit directives\
    \ (e.g., Cache-Control: no-cache) if they wish\n      to preclude caching.\n"
- title: 4.2.3.  Calculating Age
  contents:
  - "4.2.3.  Calculating Age\n   The Age header field is used to convey an estimated\
    \ age of the\n   response message when obtained from a cache.  The Age field value\
    \ is\n   the cache's estimate of the number of seconds since the response was\n\
    \   generated or validated by the origin server.  In essence, the Age\n   value\
    \ is the sum of the time that the response has been resident in\n   each of the\
    \ caches along the path from the origin server, plus the\n   amount of time it\
    \ has been in transit along network paths.\n   The following data is used for\
    \ the age calculation:\n   age_value\n      The term \"age_value\" denotes the\
    \ value of the Age header field\n      (Section 5.1), in a form appropriate for\
    \ arithmetic operation; or\n      0, if not available.\n   date_value\n      The\
    \ term \"date_value\" denotes the value of the Date header field,\n      in a\
    \ form appropriate for arithmetic operations.  See Section\n      7.1.1.2 of [RFC7231]\
    \ for the definition of the Date header field,\n      and for requirements regarding\
    \ responses without it.\n   now\n      The term \"now\" means \"the current value\
    \ of the clock at the host\n      performing the calculation\".  A host ought\
    \ to use NTP ([RFC5905])\n      or some similar protocol to synchronize its clocks\
    \ to Coordinated\n      Universal Time.\n   request_time\n      The current value\
    \ of the clock at the host at the time the request\n      resulting in the stored\
    \ response was made.\n   response_time\n      The current value of the clock at\
    \ the host at the time the\n      response was received.\n   A response's age\
    \ can be calculated in two entirely independent ways:\n   1.  the \"apparent_age\"\
    : response_time minus date_value, if the local\n       clock is reasonably well\
    \ synchronized to the origin server's\n       clock.  If the result is negative,\
    \ the result is replaced by\n       zero.\n   2.  the \"corrected_age_value\"\
    , if all of the caches along the\n       response path implement HTTP/1.1.  A\
    \ cache MUST interpret this\n       value relative to the time the request was\
    \ initiated, not the\n       time that the response was received.\n     apparent_age\
    \ = max(0, response_time - date_value);\n     response_delay = response_time -\
    \ request_time;\n     corrected_age_value = age_value + response_delay;\n   These\
    \ are combined as\n     corrected_initial_age = max(apparent_age, corrected_age_value);\n\
    \   unless the cache is confident in the value of the Age header field\n   (e.g.,\
    \ because there are no HTTP/1.0 hops in the Via header field),\n   in which case\
    \ the corrected_age_value MAY be used as the\n   corrected_initial_age.\n   The\
    \ current_age of a stored response can then be calculated by adding\n   the amount\
    \ of time (in seconds) since the stored response was last\n   validated by the\
    \ origin server to the corrected_initial_age.\n     resident_time = now - response_time;\n\
    \     current_age = corrected_initial_age + resident_time;\n"
- title: 4.2.4.  Serving Stale Responses
  contents:
  - "4.2.4.  Serving Stale Responses\n   A \"stale\" response is one that either has\
    \ explicit expiry information\n   or is allowed to have heuristic expiry calculated,\
    \ but is not fresh\n   according to the calculations in Section 4.2.\n   A cache\
    \ MUST NOT generate a stale response if it is prohibited by an\n   explicit in-protocol\
    \ directive (e.g., by a \"no-store\" or \"no-cache\"\n   cache directive, a \"\
    must-revalidate\" cache-response-directive, or an\n   applicable \"s-maxage\"\
    \ or \"proxy-revalidate\" cache-response-directive;\n   see Section 5.2.2).\n\
    \   A cache MUST NOT send stale responses unless it is disconnected\n   (i.e.,\
    \ it cannot contact the origin server or otherwise find a\n   forward path) or\
    \ doing so is explicitly allowed (e.g., by the\n   max-stale request directive;\
    \ see Section 5.2.1).\n   A cache SHOULD generate a Warning header field with\
    \ the 110 warn-code\n   (see Section 5.5.1) in stale responses.  Likewise, a cache\
    \ SHOULD\n   generate a 112 warn-code (see Section 5.5.3) in stale responses if\n\
    \   the cache is disconnected.\n   A cache SHOULD NOT generate a new Warning header\
    \ field when\n   forwarding a response that does not have an Age header field,\
    \ even if\n   the response is already stale.  A cache need not validate a response\n\
    \   that merely became stale in transit.\n"
- title: 4.3.  Validation
  contents:
  - "4.3.  Validation\n   When a cache has one or more stored responses for a requested\
    \ URI,\n   but cannot serve any of them (e.g., because they are not fresh, or\n\
    \   one cannot be selected; see Section 4.1), it can use the conditional\n   request\
    \ mechanism [RFC7232] in the forwarded request to give the next\n   inbound server\
    \ an opportunity to select a valid stored response to\n   use, updating the stored\
    \ metadata in the process, or to replace the\n   stored response(s) with a new\
    \ response.  This process is known as\n   \"validating\" or \"revalidating\" the\
    \ stored response.\n"
- title: 4.3.1.  Sending a Validation Request
  contents:
  - "4.3.1.  Sending a Validation Request\n   When sending a conditional request for\
    \ cache validation, a cache\n   sends one or more precondition header fields containing\
    \ validator\n   metadata from its stored response(s), which is then compared by\n\
    \   recipients to determine whether a stored response is equivalent to a\n   current\
    \ representation of the resource.\n   One such validator is the timestamp given\
    \ in a Last-Modified header\n   field (Section 2.2 of [RFC7232]), which can be\
    \ used in an\n   If-Modified-Since header field for response validation, or in\
    \ an\n   If-Unmodified-Since or If-Range header field for representation\n   selection\
    \ (i.e., the client is referring specifically to a previously\n   obtained representation\
    \ with that timestamp).\n   Another validator is the entity-tag given in an ETag\
    \ header field\n   (Section 2.3 of [RFC7232]).  One or more entity-tags, indicating\
    \ one\n   or more stored responses, can be used in an If-None-Match header\n \
    \  field for response validation, or in an If-Match or If-Range header\n   field\
    \ for representation selection (i.e., the client is referring\n   specifically\
    \ to one or more previously obtained representations with\n   the listed entity-tags).\n"
- title: 4.3.2.  Handling a Received Validation Request
  contents:
  - "4.3.2.  Handling a Received Validation Request\n   Each client in the request\
    \ chain may have its own cache, so it is\n   common for a cache at an intermediary\
    \ to receive conditional requests\n   from other (outbound) caches.  Likewise,\
    \ some user agents make use of\n   conditional requests to limit data transfers\
    \ to recently modified\n   representations or to complete the transfer of a partially\
    \ retrieved\n   representation.\n   If a cache receives a request that can be\
    \ satisfied by reusing one of\n   its stored 200 (OK) or 206 (Partial Content)\
    \ responses, the cache\n   SHOULD evaluate any applicable conditional header field\
    \ preconditions\n   received in that request with respect to the corresponding\
    \ validators\n   contained within the selected response.  A cache MUST NOT evaluate\n\
    \   conditional header fields that are only applicable to an origin\n   server,\
    \ found in a request with semantics that cannot be satisfied\n   with a cached\
    \ response, or applied to a target resource for which it\n   has no stored responses;\
    \ such preconditions are likely intended for\n   some other (inbound) server.\n\
    \   The proper evaluation of conditional requests by a cache depends on\n   the\
    \ received precondition header fields and their precedence, as\n   defined in\
    \ Section 6 of [RFC7232].  The If-Match and\n   If-Unmodified-Since conditional\
    \ header fields are not applicable to a\n   cache.\n   A request containing an\
    \ If-None-Match header field (Section 3.2 of\n   [RFC7232]) indicates that the\
    \ client wants to validate one or more of\n   its own stored responses in comparison\
    \ to whichever stored response\n   is selected by the cache.  If the field-value\
    \ is \"*\", or if the\n   field-value is a list of entity-tags and at least one\
    \ of them matches\n   the entity-tag of the selected stored response, a cache\
    \ recipient\n   SHOULD generate a 304 (Not Modified) response (using the metadata\
    \ of\n   the selected stored response) instead of sending that stored\n   response.\n\
    \   When a cache decides to revalidate its own stored responses for a\n   request\
    \ that contains an If-None-Match list of entity-tags, the cache\n   MAY combine\
    \ the received list with a list of entity-tags from its own\n   stored set of\
    \ responses (fresh or stale) and send the union of the\n   two lists as a replacement\
    \ If-None-Match header field value in the\n   forwarded request.  If a stored\
    \ response contains only partial\n   content, the cache MUST NOT include its entity-tag\
    \ in the union\n   unless the request is for a range that would be fully satisfied\
    \ by\n   that partial stored response.  If the response to the forwarded\n   request\
    \ is 304 (Not Modified) and has an ETag header field value with\n   an entity-tag\
    \ that is not in the client's list, the cache MUST\n   generate a 200 (OK) response\
    \ for the client by reusing its\n   corresponding stored response, as updated\
    \ by the 304 response\n   metadata (Section 4.3.4).\n   If an If-None-Match header\
    \ field is not present, a request containing\n   an If-Modified-Since header field\
    \ (Section 3.3 of [RFC7232])\n   indicates that the client wants to validate one\
    \ or more of its own\n   stored responses by modification date.  A cache recipient\
    \ SHOULD\n   generate a 304 (Not Modified) response (using the metadata of the\n\
    \   selected stored response) if one of the following cases is true: 1)\n   the\
    \ selected stored response has a Last-Modified field-value that is\n   earlier\
    \ than or equal to the conditional timestamp; 2) no\n   Last-Modified field is\
    \ present in the selected stored response, but\n   it has a Date field-value that\
    \ is earlier than or equal to the\n   conditional timestamp; or, 3) neither Last-Modified\
    \ nor Date is\n   present in the selected stored response, but the cache recorded\
    \ it as\n   having been received at a time earlier than or equal to the\n   conditional\
    \ timestamp.\n   A cache that implements partial responses to range requests,\
    \ as\n   defined in [RFC7233], also needs to evaluate a received If-Range\n  \
    \ header field (Section 3.2 of [RFC7233]) with respect to its selected\n   stored\
    \ response.\n"
- title: 4.3.3.  Handling a Validation Response
  contents:
  - "4.3.3.  Handling a Validation Response\n   Cache handling of a response to a\
    \ conditional request is dependent\n   upon its status code:\n   o  A 304 (Not\
    \ Modified) response status code indicates that the\n      stored response can\
    \ be updated and reused; see Section 4.3.4.\n   o  A full response (i.e., one\
    \ with a payload body) indicates that\n      none of the stored responses nominated\
    \ in the conditional request\n      is suitable.  Instead, the cache MUST use\
    \ the full response to\n      satisfy the request and MAY replace the stored response(s).\n\
    \   o  However, if a cache receives a 5xx (Server Error) response while\n    \
    \  attempting to validate a response, it can either forward this\n      response\
    \ to the requesting client, or act as if the server failed\n      to respond.\
    \  In the latter case, the cache MAY send a previously\n      stored response\
    \ (see Section 4.2.4).\n"
- title: 4.3.4.  Freshening Stored Responses upon Validation
  contents:
  - "4.3.4.  Freshening Stored Responses upon Validation\n   When a cache receives\
    \ a 304 (Not Modified) response and already has\n   one or more stored 200 (OK)\
    \ responses for the same cache key, the\n   cache needs to identify which of the\
    \ stored responses are updated by\n   this new response and then update the stored\
    \ response(s) with the new\n   information provided in the 304 response.\n   The\
    \ stored response to update is identified by using the first match\n   (if any)\
    \ of the following:\n   o  If the new response contains a strong validator (see\
    \ Section 2.1\n      of [RFC7232]), then that strong validator identifies the\
    \ selected\n      representation for update.  All of the stored responses with\
    \ the\n      same strong validator are selected.  If none of the stored\n    \
    \  responses contain the same strong validator, then the cache MUST\n      NOT\
    \ use the new response to update any stored responses.\n   o  If the new response\
    \ contains a weak validator and that validator\n      corresponds to one of the\
    \ cache's stored responses, then the most\n      recent of those matching stored\
    \ responses is selected for update.\n   o  If the new response does not include\
    \ any form of validator (such\n      as in the case where a client generates an\
    \ If-Modified-Since\n      request from a source other than the Last-Modified\
    \ response header\n      field), and there is only one stored response, and that\
    \ stored\n      response also lacks a validator, then that stored response is\n\
    \      selected for update.\n   If a stored response is selected for update, the\
    \ cache MUST:\n   o  delete any Warning header fields in the stored response with\n\
    \      warn-code 1xx (see Section 5.5);\n   o  retain any Warning header fields\
    \ in the stored response with\n      warn-code 2xx; and,\n   o  use other header\
    \ fields provided in the 304 (Not Modified)\n      response to replace all instances\
    \ of the corresponding header\n      fields in the stored response.\n"
- title: 4.3.5.  Freshening Responses via HEAD
  contents:
  - "4.3.5.  Freshening Responses via HEAD\n   A response to the HEAD method is identical\
    \ to what an equivalent\n   request made with a GET would have been, except it\
    \ lacks a body.\n   This property of HEAD responses can be used to invalidate\
    \ or update a\n   cached GET response if the more efficient conditional GET request\n\
    \   mechanism is not available (due to no validators being present in the\n  \
    \ stored response) or if transmission of the representation body is not\n   desired\
    \ even if it has changed.\n   When a cache makes an inbound HEAD request for a\
    \ given request target\n   and receives a 200 (OK) response, the cache SHOULD\
    \ update or\n   invalidate each of its stored GET responses that could have been\n\
    \   selected for that request (see Section 4.1).\n   For each of the stored responses\
    \ that could have been selected, if\n   the stored response and HEAD response\
    \ have matching values for any\n   received validator fields (ETag and Last-Modified)\
    \ and, if the HEAD\n   response has a Content-Length header field, the value of\n\
    \   Content-Length matches that of the stored response, the cache SHOULD\n   update\
    \ the stored response as described below; otherwise, the cache\n   SHOULD consider\
    \ the stored response to be stale.\n   If a cache updates a stored response with\
    \ the metadata provided in a\n   HEAD response, the cache MUST:\n   o  delete\
    \ any Warning header fields in the stored response with\n      warn-code 1xx (see\
    \ Section 5.5);\n   o  retain any Warning header fields in the stored response\
    \ with\n      warn-code 2xx; and,\n   o  use other header fields provided in the\
    \ HEAD response to replace\n      all instances of the corresponding header fields\
    \ in the stored\n      response and append new header fields to the stored response's\n\
    \      header section unless otherwise restricted by the Cache-Control\n     \
    \ header field.\n"
- title: 4.4.  Invalidation
  contents:
  - "4.4.  Invalidation\n   Because unsafe request methods (Section 4.2.1 of [RFC7231])\
    \ such as\n   PUT, POST or DELETE have the potential for changing state on the\n\
    \   origin server, intervening caches can use them to keep their contents\n  \
    \ up to date.\n   A cache MUST invalidate the effective Request URI (Section 5.5\
    \ of\n   [RFC7230]) as well as the URI(s) in the Location and Content-Location\n\
    \   response header fields (if present) when a non-error status code is\n   received\
    \ in response to an unsafe request method.\n   However, a cache MUST NOT invalidate\
    \ a URI from a Location or\n   Content-Location response header field if the host\
    \ part of that URI\n   differs from the host part in the effective request URI\
    \ (Section 5.5\n   of [RFC7230]).  This helps prevent denial-of-service attacks.\n\
    \   A cache MUST invalidate the effective request URI (Section 5.5 of\n   [RFC7230])\
    \ when it receives a non-error response to a request with a\n   method whose safety\
    \ is unknown.\n   Here, a \"non-error response\" is one with a 2xx (Successful)\
    \ or 3xx\n   (Redirection) status code.  \"Invalidate\" means that the cache will\n\
    \   either remove all stored responses related to the effective request\n   URI\
    \ or will mark these as \"invalid\" and in need of a mandatory\n   validation\
    \ before they can be sent in response to a subsequent\n   request.\n   Note that\
    \ this does not guarantee that all appropriate responses are\n   invalidated.\
    \  For example, a state-changing request might invalidate\n   responses in the\
    \ caches it travels through, but relevant responses\n   still might be stored\
    \ in other caches that it has not.\n"
- title: 5.  Header Field Definitions
  contents:
  - "5.  Header Field Definitions\n   This section defines the syntax and semantics\
    \ of HTTP/1.1 header\n   fields related to caching.\n"
- title: 5.1.  Age
  contents:
  - "5.1.  Age\n   The \"Age\" header field conveys the sender's estimate of the amount\
    \ of\n   time since the response was generated or successfully validated at\n\
    \   the origin server.  Age values are calculated as specified in\n   Section\
    \ 4.2.3.\n     Age = delta-seconds\n   The Age field-value is a non-negative integer,\
    \ representing time in\n   seconds (see Section 1.2.1).\n   The presence of an\
    \ Age header field implies that the response was not\n   generated or validated\
    \ by the origin server for this request.\n   However, lack of an Age header field\
    \ does not imply the origin was\n   contacted, since the response might have been\
    \ received from an\n   HTTP/1.0 cache that does not implement Age.\n"
- title: 5.2.  Cache-Control
  contents:
  - "5.2.  Cache-Control\n   The \"Cache-Control\" header field is used to specify\
    \ directives for\n   caches along the request/response chain.  Such cache directives\
    \ are\n   unidirectional in that the presence of a directive in a request does\n\
    \   not imply that the same directive is to be given in the response.\n   A cache\
    \ MUST obey the requirements of the Cache-Control directives\n   defined in this\
    \ section.  See Section 5.2.3 for information about how\n   Cache-Control directives\
    \ defined elsewhere are handled.\n      Note: Some HTTP/1.0 caches might not implement\
    \ Cache-Control.\n   A proxy, whether or not it implements a cache, MUST pass\
    \ cache\n   directives through in forwarded messages, regardless of their\n  \
    \ significance to that application, since the directives might be\n   applicable\
    \ to all recipients along the request/response chain.  It is\n   not possible\
    \ to target a directive to a specific cache.\n   Cache directives are identified\
    \ by a token, to be compared\n   case-insensitively, and have an optional argument,\
    \ that can use both\n   token and quoted-string syntax.  For the directives defined\
    \ below\n   that define arguments, recipients ought to accept both forms, even\
    \ if\n   one is documented to be preferred.  For any directive not defined by\n\
    \   this specification, a recipient MUST accept both forms.\n     Cache-Control\
    \   = 1#cache-directive\n     cache-directive = token [ \"=\" ( token / quoted-string\
    \ ) ]\n   For the cache directives defined below, no argument is defined (nor\n\
    \   allowed) unless stated otherwise.\n"
- title: 5.2.1.  Request Cache-Control Directives
  contents:
  - '5.2.1.  Request Cache-Control Directives

    '
- title: 5.2.1.1.  max-age
  contents:
  - "5.2.1.1.  max-age\n   Argument syntax:\n      delta-seconds (see Section 1.2.1)\n\
    \   The \"max-age\" request directive indicates that the client is\n   unwilling\
    \ to accept a response whose age is greater than the\n   specified number of seconds.\
    \  Unless the max-stale request directive\n   is also present, the client is not\
    \ willing to accept a stale\n   response.\n   This directive uses the token form\
    \ of the argument syntax: e.g.,\n   'max-age=5' not 'max-age=\"5\"'.  A sender\
    \ SHOULD NOT generate the\n   quoted-string form.\n"
- title: 5.2.1.2.  max-stale
  contents:
  - "5.2.1.2.  max-stale\n   Argument syntax:\n      delta-seconds (see Section 1.2.1)\n\
    \   The \"max-stale\" request directive indicates that the client is\n   willing\
    \ to accept a response that has exceeded its freshness\n   lifetime.  If max-stale\
    \ is assigned a value, then the client is\n   willing to accept a response that\
    \ has exceeded its freshness lifetime\n   by no more than the specified number\
    \ of seconds.  If no value is\n   assigned to max-stale, then the client is willing\
    \ to accept a stale\n   response of any age.\n   This directive uses the token\
    \ form of the argument syntax: e.g.,\n   'max-stale=10' not 'max-stale=\"10\"\
    '.  A sender SHOULD NOT generate\n   the quoted-string form.\n"
- title: 5.2.1.3.  min-fresh
  contents:
  - "5.2.1.3.  min-fresh\n   Argument syntax:\n      delta-seconds (see Section 1.2.1)\n\
    \   The \"min-fresh\" request directive indicates that the client is\n   willing\
    \ to accept a response whose freshness lifetime is no less than\n   its current\
    \ age plus the specified time in seconds.  That is, the\n   client wants a response\
    \ that will still be fresh for at least the\n   specified number of seconds.\n\
    \   This directive uses the token form of the argument syntax: e.g.,\n   'min-fresh=20'\
    \ not 'min-fresh=\"20\"'.  A sender SHOULD NOT generate\n   the quoted-string\
    \ form.\n"
- title: 5.2.1.4.  no-cache
  contents:
  - "5.2.1.4.  no-cache\n   The \"no-cache\" request directive indicates that a cache\
    \ MUST NOT use\n   a stored response to satisfy the request without successful\n\
    \   validation on the origin server.\n"
- title: 5.2.1.5.  no-store
  contents:
  - "5.2.1.5.  no-store\n   The \"no-store\" request directive indicates that a cache\
    \ MUST NOT\n   store any part of either this request or any response to it.  This\n\
    \   directive applies to both private and shared caches.  \"MUST NOT\n   store\"\
    \ in this context means that the cache MUST NOT intentionally\n   store the information\
    \ in non-volatile storage, and MUST make a\n   best-effort attempt to remove the\
    \ information from volatile storage\n   as promptly as possible after forwarding\
    \ it.\n   This directive is NOT a reliable or sufficient mechanism for ensuring\n\
    \   privacy.  In particular, malicious or compromised caches might not\n   recognize\
    \ or obey this directive, and communications networks might\n   be vulnerable\
    \ to eavesdropping.\n   Note that if a request containing this directive is satisfied\
    \ from a\n   cache, the no-store request directive does not apply to the already\n\
    \   stored response.\n"
- title: 5.2.1.6.  no-transform
  contents:
  - "5.2.1.6.  no-transform\n   The \"no-transform\" request directive indicates that\
    \ an intermediary\n   (whether or not it implements a cache) MUST NOT transform\
    \ the\n   payload, as defined in Section 5.7.2 of [RFC7230].\n"
- title: 5.2.1.7.  only-if-cached
  contents:
  - "5.2.1.7.  only-if-cached\n   The \"only-if-cached\" request directive indicates\
    \ that the client only\n   wishes to obtain a stored response.  If it receives\
    \ this directive, a\n   cache SHOULD either respond using a stored response that\
    \ is\n   consistent with the other constraints of the request, or respond with\n\
    \   a 504 (Gateway Timeout) status code.  If a group of caches is being\n   operated\
    \ as a unified system with good internal connectivity, a\n   member cache MAY\
    \ forward such a request within that group of caches.\n"
- title: 5.2.2.  Response Cache-Control Directives
  contents:
  - '5.2.2.  Response Cache-Control Directives

    '
- title: 5.2.2.1.  must-revalidate
  contents:
  - "5.2.2.1.  must-revalidate\n   The \"must-revalidate\" response directive indicates\
    \ that once it has\n   become stale, a cache MUST NOT use the response to satisfy\
    \ subsequent\n   requests without successful validation on the origin server.\n\
    \   The must-revalidate directive is necessary to support reliable\n   operation\
    \ for certain protocol features.  In all circumstances a\n   cache MUST obey the\
    \ must-revalidate directive; in particular, if a\n   cache cannot reach the origin\
    \ server for any reason, it MUST generate\n   a 504 (Gateway Timeout) response.\n\
    \   The must-revalidate directive ought to be used by servers if and only\n  \
    \ if failure to validate a request on the representation could result\n   in incorrect\
    \ operation, such as a silently unexecuted financial\n   transaction.\n"
- title: 5.2.2.2.  no-cache
  contents:
  - "5.2.2.2.  no-cache\n   Argument syntax:\n      #field-name\n   The \"no-cache\"\
    \ response directive indicates that the response MUST\n   NOT be used to satisfy\
    \ a subsequent request without successful\n   validation on the origin server.\
    \  This allows an origin server to\n   prevent a cache from using it to satisfy\
    \ a request without contacting\n   it, even by caches that have been configured\
    \ to send stale responses.\n   If the no-cache response directive specifies one\
    \ or more field-names,\n   then a cache MAY use the response to satisfy a subsequent\
    \ request,\n   subject to any other restrictions on caching.  However, any header\n\
    \   fields in the response that have the field-name(s) listed MUST NOT be\n  \
    \ sent in the response to a subsequent request without successful\n   revalidation\
    \ with the origin server.  This allows an origin server to\n   prevent the re-use\
    \ of certain header fields in a response, while\n   still allowing caching of\
    \ the rest of the response.\n   The field-names given are not limited to the set\
    \ of header fields\n   defined by this specification.  Field names are case-insensitive.\n\
    \   This directive uses the quoted-string form of the argument syntax.  A\n  \
    \ sender SHOULD NOT generate the token form (even if quoting appears\n   not to\
    \ be needed for single-entry lists).\n   Note: Although it has been back-ported\
    \ to many implementations, some\n   HTTP/1.0 caches will not recognize or obey\
    \ this directive.  Also,\n   no-cache response directives with field-names are\
    \ often handled by\n   caches as if an unqualified no-cache directive was received;\
    \ i.e.,\n   the special handling for the qualified form is not widely\n   implemented.\n"
- title: 5.2.2.3.  no-store
  contents:
  - "5.2.2.3.  no-store\n   The \"no-store\" response directive indicates that a cache\
    \ MUST NOT\n   store any part of either the immediate request or response.  This\n\
    \   directive applies to both private and shared caches.  \"MUST NOT\n   store\"\
    \ in this context means that the cache MUST NOT intentionally\n   store the information\
    \ in non-volatile storage, and MUST make a\n   best-effort attempt to remove the\
    \ information from volatile storage\n   as promptly as possible after forwarding\
    \ it.\n   This directive is NOT a reliable or sufficient mechanism for ensuring\n\
    \   privacy.  In particular, malicious or compromised caches might not\n   recognize\
    \ or obey this directive, and communications networks might\n   be vulnerable\
    \ to eavesdropping.\n"
- title: 5.2.2.4.  no-transform
  contents:
  - "5.2.2.4.  no-transform\n   The \"no-transform\" response directive indicates\
    \ that an intermediary\n   (regardless of whether it implements a cache) MUST\
    \ NOT transform the\n   payload, as defined in Section 5.7.2 of [RFC7230].\n"
- title: 5.2.2.5.  public
  contents:
  - "5.2.2.5.  public\n   The \"public\" response directive indicates that any cache\
    \ MAY store\n   the response, even if the response would normally be non-cacheable\
    \ or\n   cacheable only within a private cache.  (See Section 3.2 for\n   additional\
    \ details related to the use of public in response to a\n   request containing\
    \ Authorization, and Section 3 for details of how\n   public affects responses\
    \ that would normally not be stored, due to\n   their status codes not being defined\
    \ as cacheable by default; see\n   Section 4.2.2.)\n"
- title: 5.2.2.6.  private
  contents:
  - "5.2.2.6.  private\n   Argument syntax:\n      #field-name\n   The \"private\"\
    \ response directive indicates that the response message\n   is intended for a\
    \ single user and MUST NOT be stored by a shared\n   cache.  A private cache MAY\
    \ store the response and reuse it for later\n   requests, even if the response\
    \ would normally be non-cacheable.\n   If the private response directive specifies\
    \ one or more field-names,\n   this requirement is limited to the field-values\
    \ associated with the\n   listed response header fields.  That is, a shared cache\
    \ MUST NOT\n   store the specified field-names(s), whereas it MAY store the\n\
    \   remainder of the response message.\n   The field-names given are not limited\
    \ to the set of header fields\n   defined by this specification.  Field names\
    \ are case-insensitive.\n   This directive uses the quoted-string form of the\
    \ argument syntax.  A\n   sender SHOULD NOT generate the token form (even if quoting\
    \ appears\n   not to be needed for single-entry lists).\n   Note: This usage of\
    \ the word \"private\" only controls where the\n   response can be stored; it\
    \ cannot ensure the privacy of the message\n   content.  Also, private response\
    \ directives with field-names are\n   often handled by caches as if an unqualified\
    \ private directive was\n   received; i.e., the special handling for the qualified\
    \ form is not\n   widely implemented.\n"
- title: 5.2.2.7.  proxy-revalidate
  contents:
  - "5.2.2.7.  proxy-revalidate\n   The \"proxy-revalidate\" response directive has\
    \ the same meaning as the\n   must-revalidate response directive, except that\
    \ it does not apply to\n   private caches.\n"
- title: 5.2.2.8.  max-age
  contents:
  - "5.2.2.8.  max-age\n   Argument syntax:\n      delta-seconds (see Section 1.2.1)\n\
    \   The \"max-age\" response directive indicates that the response is to be\n\
    \   considered stale after its age is greater than the specified number\n   of\
    \ seconds.\n   This directive uses the token form of the argument syntax: e.g.,\n\
    \   'max-age=5' not 'max-age=\"5\"'.  A sender SHOULD NOT generate the\n   quoted-string\
    \ form.\n"
- title: 5.2.2.9.  s-maxage
  contents:
  - "5.2.2.9.  s-maxage\n   Argument syntax:\n      delta-seconds (see Section 1.2.1)\n\
    \   The \"s-maxage\" response directive indicates that, in shared caches,\n  \
    \ the maximum age specified by this directive overrides the maximum age\n   specified\
    \ by either the max-age directive or the Expires header\n   field.  The s-maxage\
    \ directive also implies the semantics of the\n   proxy-revalidate response directive.\n\
    \   This directive uses the token form of the argument syntax: e.g.,\n   's-maxage=10'\
    \ not 's-maxage=\"10\"'.  A sender SHOULD NOT generate the\n   quoted-string form.\n"
- title: 5.2.3.  Cache Control Extensions
  contents:
  - "5.2.3.  Cache Control Extensions\n   The Cache-Control header field can be extended\
    \ through the use of one\n   or more cache-extension tokens, each with an optional\
    \ value.  A cache\n   MUST ignore unrecognized cache directives.\n   Informational\
    \ extensions (those that do not require a change in cache\n   behavior) can be\
    \ added without changing the semantics of other\n   directives.\n   Behavioral\
    \ extensions are designed to work by acting as modifiers to\n   the existing base\
    \ of cache directives.  Both the new directive and\n   the old directive are supplied,\
    \ such that applications that do not\n   understand the new directive will default\
    \ to the behavior specified\n   by the old directive, and those that understand\
    \ the new directive\n   will recognize it as modifying the requirements associated\
    \ with the\n   old directive.  In this way, extensions to the existing cache-control\n\
    \   directives can be made without breaking deployed caches.\n   For example,\
    \ consider a hypothetical new response directive called\n   \"community\" that\
    \ acts as a modifier to the private directive: in\n   addition to private caches,\
    \ any cache that is shared only by members\n   of the named community is allowed\
    \ to cache the response.  An origin\n   server wishing to allow the UCI community\
    \ to use an otherwise private\n   response in their shared cache(s) could do so\
    \ by including\n     Cache-Control: private, community=\"UCI\"\n   A cache that\
    \ recognizes such a community cache-extension could\n   broaden its behavior in\
    \ accordance with that extension.  A cache that\n   does not recognize the community\
    \ cache-extension would ignore it and\n   adhere to the private directive.\n"
- title: 5.3.  Expires
  contents:
  - "5.3.  Expires\n   The \"Expires\" header field gives the date/time after which\
    \ the\n   response is considered stale.  See Section 4.2 for further discussion\n\
    \   of the freshness model.\n   The presence of an Expires field does not imply\
    \ that the original\n   resource will change or cease to exist at, before, or\
    \ after that\n   time.\n   The Expires value is an HTTP-date timestamp, as defined\
    \ in Section\n   7.1.1.1 of [RFC7231].\n     Expires = HTTP-date\n   For example\n\
    \     Expires: Thu, 01 Dec 1994 16:00:00 GMT\n   A cache recipient MUST interpret\
    \ invalid date formats, especially the\n   value \"0\", as representing a time\
    \ in the past (i.e., \"already\n   expired\").\n   If a response includes a Cache-Control\
    \ field with the max-age\n   directive (Section 5.2.2.8), a recipient MUST ignore\
    \ the Expires\n   field.  Likewise, if a response includes the s-maxage directive\n\
    \   (Section 5.2.2.9), a shared cache recipient MUST ignore the Expires\n   field.\
    \  In both these cases, the value in Expires is only intended\n   for recipients\
    \ that have not yet implemented the Cache-Control field.\n   An origin server\
    \ without a clock MUST NOT generate an Expires field\n   unless its value represents\
    \ a fixed time in the past (always expired)\n   or its value has been associated\
    \ with the resource by a system or\n   user with a reliable clock.\n   Historically,\
    \ HTTP required the Expires field-value to be no more\n   than a year in the future.\
    \  While longer freshness lifetimes are no\n   longer prohibited, extremely large\
    \ values have been demonstrated to\n   cause problems (e.g., clock overflows due\
    \ to use of 32-bit integers\n   for time values), and many caches will evict a\
    \ response far sooner\n   than that.\n"
- title: 5.4.  Pragma
  contents:
  - "5.4.  Pragma\n   The \"Pragma\" header field allows backwards compatibility with\n\
    \   HTTP/1.0 caches, so that clients can specify a \"no-cache\" request\n   that\
    \ they will understand (as Cache-Control was not defined until\n   HTTP/1.1).\
    \  When the Cache-Control header field is also present and\n   understood in a\
    \ request, Pragma is ignored.\n   In HTTP/1.0, Pragma was defined as an extensible\
    \ field for\n   implementation-specified directives for recipients.  This\n  \
    \ specification deprecates such extensions to improve interoperability.\n    \
    \ Pragma           = 1#pragma-directive\n     pragma-directive = \"no-cache\"\
    \ / extension-pragma\n     extension-pragma = token [ \"=\" ( token / quoted-string\
    \ ) ]\n   When the Cache-Control header field is not present in a request,\n \
    \  caches MUST consider the no-cache request pragma-directive as having\n   the\
    \ same effect as if \"Cache-Control: no-cache\" were present (see\n   Section\
    \ 5.2.1).\n   When sending a no-cache request, a client ought to include both\
    \ the\n   pragma and cache-control directives, unless Cache-Control: no-cache\n\
    \   is purposefully omitted to target other Cache-Control response\n   directives\
    \ at HTTP/1.1 caches.  For example:\n     GET / HTTP/1.1\n     Host: www.example.com\n\
    \     Cache-Control: max-age=30\n     Pragma: no-cache\n   will constrain HTTP/1.1\
    \ caches to serve a response no older than 30\n   seconds, while precluding implementations\
    \ that do not understand\n   Cache-Control from serving a cached response.\n \
    \     Note: Because the meaning of \"Pragma: no-cache\" in responses is\n    \
    \  not specified, it does not provide a reliable replacement for\n      \"Cache-Control:\
    \ no-cache\" in them.\n"
- title: 5.5.  Warning
  contents:
  - "5.5.  Warning\n   The \"Warning\" header field is used to carry additional information\n\
    \   about the status or transformation of a message that might not be\n   reflected\
    \ in the status code.  This information is typically used to\n   warn about possible\
    \ incorrectness introduced by caching operations or\n   transformations applied\
    \ to the payload of the message.\n   Warnings can be used for other purposes,\
    \ both cache-related and\n   otherwise.  The use of a warning, rather than an\
    \ error status code,\n   distinguishes these responses from true failures.\n \
    \  Warning header fields can in general be applied to any message,\n   however\
    \ some warn-codes are specific to caches and can only be\n   applied to response\
    \ messages.\n     Warning       = 1#warning-value\n     warning-value = warn-code\
    \ SP warn-agent SP warn-text\n                                           [ SP\
    \ warn-date ]\n     warn-code  = 3DIGIT\n     warn-agent = ( uri-host [ \":\"\
    \ port ] ) / pseudonym\n                     ; the name or pseudonym of the server\
    \ adding\n                     ; the Warning header field, for use in debugging\n\
    \                     ; a single \"-\" is recommended when agent unknown\n   \
    \  warn-text  = quoted-string\n     warn-date  = DQUOTE HTTP-date DQUOTE\n   Multiple\
    \ warnings can be generated in a response (either by the\n   origin server or\
    \ by a cache), including multiple warnings with the\n   same warn-code number\
    \ that only differ in warn-text.\n   A user agent that receives one or more Warning\
    \ header fields SHOULD\n   inform the user of as many of them as possible, in\
    \ the order that\n   they appear in the response.  Senders that generate multiple\
    \ Warning\n   header fields are encouraged to order them with this user agent\n\
    \   behavior in mind.  A sender that generates new Warning header fields\n   MUST\
    \ append them after any existing Warning header fields.\n   Warnings are assigned\
    \ three digit warn-codes.  The first digit\n   indicates whether the Warning is\
    \ required to be deleted from a stored\n   response after validation:\n   o  1xx\
    \ warn-codes describe the freshness or validation status of the\n      response,\
    \ and so they MUST be deleted by a cache after validation.\n      They can only\
    \ be generated by a cache when validating a cached\n      entry, and MUST NOT\
    \ be generated in any other situation.\n   o  2xx warn-codes describe some aspect\
    \ of the representation that is\n      not rectified by a validation (for example,\
    \ a lossy compression of\n      the representation) and they MUST NOT be deleted\
    \ by a cache after\n      validation, unless a full response is sent, in which\
    \ case they\n      MUST be.\n   If a sender generates one or more 1xx warn-codes\
    \ in a message to be\n   sent to a recipient known to implement only HTTP/1.0,\
    \ the sender MUST\n   include in each corresponding warning-value a warn-date\
    \ that matches\n   the Date header field in the message.  For example:\n     HTTP/1.1\
    \ 200 OK\n     Date: Sat, 25 Aug 2012 23:34:45 GMT\n     Warning: 112 - \"network\
    \ down\" \"Sat, 25 Aug 2012 23:34:45 GMT\"\n   Warnings have accompanying warn-text\
    \ that describes the error, e.g.,\n   for logging.  It is advisory only, and its\
    \ content does not affect\n   interpretation of the warn-code.\n   If a recipient\
    \ that uses, evaluates, or displays Warning header\n   fields receives a warn-date\
    \ that is different from the Date value in\n   the same message, the recipient\
    \ MUST exclude the warning-value\n   containing that warn-date before storing,\
    \ forwarding, or using the\n   message.  This allows recipients to exclude warning-values\
    \ that were\n   improperly retained after a cache validation.  If all of the\n\
    \   warning-values are excluded, the recipient MUST exclude the Warning\n   header\
    \ field as well.\n   The following warn-codes are defined by this specification,\
    \ each with\n   a recommended warn-text in English, and a description of its meaning.\n\
    \   The procedure for defining additional warn codes is described in\n   Section\
    \ 7.2.1.\n"
- title: '5.5.1.  Warning: 110 - "Response is Stale"'
  contents:
  - "5.5.1.  Warning: 110 - \"Response is Stale\"\n   A cache SHOULD generate this\
    \ whenever the sent response is stale.\n"
- title: '5.5.2.  Warning: 111 - "Revalidation Failed"'
  contents:
  - "5.5.2.  Warning: 111 - \"Revalidation Failed\"\n   A cache SHOULD generate this\
    \ when sending a stale response because an\n   attempt to validate the response\
    \ failed, due to an inability to reach\n   the server.\n"
- title: '5.5.3.  Warning: 112 - "Disconnected Operation"'
  contents:
  - "5.5.3.  Warning: 112 - \"Disconnected Operation\"\n   A cache SHOULD generate\
    \ this if it is intentionally disconnected from\n   the rest of the network for\
    \ a period of time.\n"
- title: '5.5.4.  Warning: 113 - "Heuristic Expiration"'
  contents:
  - "5.5.4.  Warning: 113 - \"Heuristic Expiration\"\n   A cache SHOULD generate this\
    \ if it heuristically chose a freshness\n   lifetime greater than 24 hours and\
    \ the response's age is greater than\n   24 hours.\n"
- title: '5.5.5.  Warning: 199 - "Miscellaneous Warning"'
  contents:
  - "5.5.5.  Warning: 199 - \"Miscellaneous Warning\"\n   The warning text can include\
    \ arbitrary information to be presented to\n   a human user or logged.  A system\
    \ receiving this warning MUST NOT\n   take any automated action, besides presenting\
    \ the warning to the\n   user.\n"
- title: '5.5.6.  Warning: 214 - "Transformation Applied"'
  contents:
  - "5.5.6.  Warning: 214 - \"Transformation Applied\"\n   This Warning code MUST\
    \ be added by a proxy if it applies any\n   transformation to the representation,\
    \ such as changing the\n   content-coding, media-type, or modifying the representation\
    \ data,\n   unless this Warning code already appears in the response.\n"
- title: '5.5.7.  Warning: 299 - "Miscellaneous Persistent Warning"'
  contents:
  - "5.5.7.  Warning: 299 - \"Miscellaneous Persistent Warning\"\n   The warning text\
    \ can include arbitrary information to be presented to\n   a human user or logged.\
    \  A system receiving this warning MUST NOT\n   take any automated action.\n"
- title: 6.  History Lists
  contents:
  - "6.  History Lists\n   User agents often have history mechanisms, such as \"Back\"\
    \ buttons and\n   history lists, that can be used to redisplay a representation\n\
    \   retrieved earlier in a session.\n   The freshness model (Section 4.2) does\
    \ not necessarily apply to\n   history mechanisms.  That is, a history mechanism\
    \ can display a\n   previous representation even if it has expired.\n   This does\
    \ not prohibit the history mechanism from telling the user\n   that a view might\
    \ be stale or from honoring cache directives (e.g.,\n   Cache-Control: no-store).\n"
- title: 7.  IANA Considerations
  contents:
  - '7.  IANA Considerations

    '
- title: 7.1.  Cache Directive Registry
  contents:
  - "7.1.  Cache Directive Registry\n   The \"Hypertext Transfer Protocol (HTTP) Cache\
    \ Directive Registry\"\n   defines the namespace for the cache directives.  It\
    \ has been created\n   and is now maintained at\n   <http://www.iana.org/assignments/http-cache-directives>.\n"
- title: 7.1.1.  Procedure
  contents:
  - "7.1.1.  Procedure\n   A registration MUST include the following fields:\n   o\
    \  Cache Directive Name\n   o  Pointer to specification text\n   Values to be\
    \ added to this namespace require IETF Review (see\n   [RFC5226], Section 4.1).\n"
- title: 7.1.2.  Considerations for New Cache Control Directives
  contents:
  - "7.1.2.  Considerations for New Cache Control Directives\n   New extension directives\
    \ ought to consider defining:\n   o  What it means for a directive to be specified\
    \ multiple times,\n   o  When the directive does not take an argument, what it\
    \ means when\n      an argument is present,\n   o  When the directive requires\
    \ an argument, what it means when it is\n      missing,\n   o  Whether the directive\
    \ is specific to requests, responses, or able\n      to be used in either.\n \
    \  See also Section 5.2.3.\n"
- title: 7.1.3.  Registrations
  contents:
  - "7.1.3.  Registrations\n   The registry has been populated with the registrations\
    \ below:\n   +------------------------+----------------------------------+\n \
    \  | Cache Directive        | Reference                        |\n   +------------------------+----------------------------------+\n\
    \   | max-age                | Section 5.2.1.1, Section 5.2.2.8 |\n   | max-stale\
    \              | Section 5.2.1.2                  |\n   | min-fresh          \
    \    | Section 5.2.1.3                  |\n   | must-revalidate        | Section\
    \ 5.2.2.1                  |\n   | no-cache               | Section 5.2.1.4, Section\
    \ 5.2.2.2 |\n   | no-store               | Section 5.2.1.5, Section 5.2.2.3 |\n\
    \   | no-transform           | Section 5.2.1.6, Section 5.2.2.4 |\n   | only-if-cached\
    \         | Section 5.2.1.7                  |\n   | private                |\
    \ Section 5.2.2.6                  |\n   | proxy-revalidate       | Section 5.2.2.7\
    \                  |\n   | public                 | Section 5.2.2.5          \
    \        |\n   | s-maxage               | Section 5.2.2.9                  |\n\
    \   | stale-if-error         | [RFC5861], Section 4             |\n   | stale-while-revalidate\
    \ | [RFC5861], Section 3             |\n   +------------------------+----------------------------------+\n"
- title: 7.2.  Warn Code Registry
  contents:
  - "7.2.  Warn Code Registry\n   The \"Hypertext Transfer Protocol (HTTP) Warn Codes\"\
    \ registry defines\n   the namespace for warn codes.  It has been created and\
    \ is now\n   maintained at <http://www.iana.org/assignments/http-warn-codes>.\n"
- title: 7.2.1.  Procedure
  contents:
  - "7.2.1.  Procedure\n   A registration MUST include the following fields:\n   o\
    \  Warn Code (3 digits)\n   o  Short Description\n   o  Pointer to specification\
    \ text\n   Values to be added to this namespace require IETF Review (see\n   [RFC5226],\
    \ Section 4.1).\n"
- title: 7.2.2.  Registrations
  contents:
  - "7.2.2.  Registrations\n   The registry has been populated with the registrations\
    \ below:\n   +-----------+----------------------------------+---------------+\n\
    \   | Warn Code | Short Description                | Reference     |\n   +-----------+----------------------------------+---------------+\n\
    \   | 110       | Response is Stale                | Section 5.5.1 |\n   | 111\
    \       | Revalidation Failed              | Section 5.5.2 |\n   | 112       |\
    \ Disconnected Operation           | Section 5.5.3 |\n   | 113       | Heuristic\
    \ Expiration             | Section 5.5.4 |\n   | 199       | Miscellaneous Warning\
    \            | Section 5.5.5 |\n   | 214       | Transformation Applied      \
    \     | Section 5.5.6 |\n   | 299       | Miscellaneous Persistent Warning | Section\
    \ 5.5.7 |\n   +-----------+----------------------------------+---------------+\n"
- title: 7.3.  Header Field Registration
  contents:
  - "7.3.  Header Field Registration\n   HTTP header fields are registered within\
    \ the \"Message Headers\"\n   registry maintained at\n   <http://www.iana.org/assignments/message-headers/>.\n\
    \   This document defines the following HTTP header fields, so the\n   \"Permanent\
    \ Message Header Field Names\" registry has been updated\n   accordingly (see\
    \ [BCP90]).\n   +-------------------+----------+----------+-------------+\n  \
    \ | Header Field Name | Protocol | Status   | Reference   |\n   +-------------------+----------+----------+-------------+\n\
    \   | Age               | http     | standard | Section 5.1 |\n   | Cache-Control\
    \     | http     | standard | Section 5.2 |\n   | Expires           | http   \
    \  | standard | Section 5.3 |\n   | Pragma            | http     | standard |\
    \ Section 5.4 |\n   | Warning           | http     | standard | Section 5.5 |\n\
    \   +-------------------+----------+----------+-------------+\n   The change controller\
    \ is: \"IETF (iesg@ietf.org) - Internet\n   Engineering Task Force\".\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   This section is meant to inform developers, information\
    \ providers,\n   and users of known security concerns specific to HTTP caching.\
    \  More\n   general security considerations are addressed in HTTP messaging\n\
    \   [RFC7230] and semantics [RFC7231].\n   Caches expose additional potential\
    \ vulnerabilities, since the\n   contents of the cache represent an attractive\
    \ target for malicious\n   exploitation.  Because cache contents persist after\
    \ an HTTP request\n   is complete, an attack on the cache can reveal information\
    \ long after\n   a user believes that the information has been removed from the\n\
    \   network.  Therefore, cache contents need to be protected as sensitive\n  \
    \ information.\n   In particular, various attacks might be amplified by being\
    \ stored in\n   a shared cache; such \"cache poisoning\" attacks use the cache\
    \ to\n   distribute a malicious payload to many clients, and are especially\n\
    \   effective when an attacker can use implementation flaws, elevated\n   privileges,\
    \ or other techniques to insert such a response into a\n   cache.  One common\
    \ attack vector for cache poisoning is to exploit\n   differences in message parsing\
    \ on proxies and in user agents; see\n   Section 3.3.3 of [RFC7230] for the relevant\
    \ requirements.\n   Likewise, implementation flaws (as well as misunderstanding\
    \ of cache\n   operation) might lead to caching of sensitive information (e.g.,\n\
    \   authentication credentials) that is thought to be private, exposing\n   it\
    \ to unauthorized parties.\n   Furthermore, the very use of a cache can bring\
    \ about privacy\n   concerns.  For example, if two users share a cache, and the\
    \ first one\n   browses to a site, the second may be able to detect that the other\n\
    \   has been to that site, because the resources from it load more\n   quickly,\
    \ thanks to the cache.\n   Note that the Set-Cookie response header field [RFC6265]\
    \ does not\n   inhibit caching; a cacheable response with a Set-Cookie header\
    \ field\n   can be (and often is) used to satisfy subsequent requests to caches.\n\
    \   Servers who wish to control caching of these responses are encouraged\n  \
    \ to emit appropriate Cache-Control response header fields.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   See Section 10 of [RFC7230].\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n\
    \              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC7230]\
    \  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n             \
    \ Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC 7230,\
    \ June 2014.\n   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\
    \ Transfer\n              Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n\
    \              June 2014.\n   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed.,\
    \ \"Hypertext Transfer\n              Protocol (HTTP/1.1): Conditional Requests\"\
    , RFC 7232,\n              June 2014.\n   [RFC7233]  Fielding, R., Ed., Lafon,\
    \ Y., Ed., and J. Reschke, Ed.,\n              \"Hypertext Transfer Protocol (HTTP/1.1):\
    \ Range Requests\",\n              RFC 7233, June 2014.\n   [RFC7235]  Fielding,\
    \ R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol (HTTP/1.1):\
    \ Authentication\", RFC 7235, June 2014.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [BCP90]    Klyne, G., Nottingham, M., and J.\
    \ Mogul, \"Registration\n              Procedures for Message Header Fields\"\
    , BCP 90, RFC 3864,\n              September 2004.\n   [RFC2616]  Fielding, R.,\
    \ Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P.,\
    \ and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\"\
    , RFC 2616, June 1999.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 5226,\n              May 2008.\n   [RFC5861]  Nottingham, M., \"HTTP Cache-Control\
    \ Extensions for Stale\n              Content\", RFC 5861, April 2010.\n   [RFC5905]\
    \  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n              \"Network\
    \ Time Protocol Version 4: Protocol and Algorithms\n              Specification\"\
    , RFC 5905, June 2010.\n   [RFC6265]  Barth, A., \"HTTP State Management Mechanism\"\
    , RFC 6265,\n              April 2011.\n"
- title: Appendix A.  Changes from RFC 2616
  contents:
  - "Appendix A.  Changes from RFC 2616\n   The specification has been substantially\
    \ rewritten for clarity.\n   The conditions under which an authenticated response\
    \ can be cached\n   have been clarified.  (Section 3.2)\n   New status codes can\
    \ now define that caches are allowed to use\n   heuristic freshness with them.\
    \  Caches are now allowed to calculate\n   heuristic freshness for URIs with query\
    \ components.  (Section 4.2.2)\n   The algorithm for calculating age is now less\
    \ conservative.  Caches\n   are now required to handle dates with time zones as\
    \ if they're\n   invalid, because it's not possible to accurately guess.\n   (Section\
    \ 4.2.3)\n   The Content-Location response header field is no longer used to\n\
    \   determine the appropriate response to use when validating.\n   (Section 4.3)\n\
    \   The algorithm for selecting a cached negotiated response to use has\n   been\
    \ clarified in several ways.  In particular, it now explicitly\n   allows header-specific\
    \ canonicalization when processing selecting\n   header fields.  (Section 4.1)\n\
    \   Requirements regarding denial-of-service attack avoidance when\n   performing\
    \ invalidation have been clarified.  (Section 4.4)\n   Cache invalidation only\
    \ occurs when a successful response is\n   received.  (Section 4.4)\n   Cache\
    \ directives are explicitly defined to be case-insensitive.\n   Handling of multiple\
    \ instances of cache directives when only one is\n   expected is now defined.\
    \  (Section 5.2)\n   The \"no-store\" request directive doesn't apply to responses;\
    \ i.e., a\n   cache can satisfy a request with no-store on it and does not\n \
    \  invalidate it.  (Section 5.2.1.5)\n   The qualified forms of the private and\
    \ no-cache cache directives are\n   noted to not be widely implemented; for example,\
    \ \"private=foo\" is\n   interpreted by many caches as simply \"private\".  Additionally,\
    \ the\n   meaning of the qualified form of no-cache has been clarified.\n   (Section\
    \ 5.2.2)\n   The \"no-cache\" response directive's meaning has been clarified.\n\
    \   (Section 5.2.2.2)\n   The one-year limit on Expires header field values has\
    \ been removed;\n   instead, the reasoning for using a sensible value is given.\n\
    \   (Section 5.3)\n   The Pragma header field is now only defined for backwards\n\
    \   compatibility; future pragmas are deprecated.  (Section 5.4)\n   Some requirements\
    \ regarding production and processing of the Warning\n   header fields have been\
    \ relaxed, as it is not widely implemented.\n   Furthermore, the Warning header\
    \ field no longer uses RFC 2047\n   encoding, nor does it allow multiple languages,\
    \ as these aspects were\n   not implemented.  (Section 5.5)\n   This specification\
    \ introduces the Cache Directive and Warn Code\n   Registries, and defines considerations\
    \ for new cache directives.\n   (Section 7.1 and Section 7.2)\n"
- title: Appendix B.  Imported ABNF
  contents:
  - "Appendix B.  Imported ABNF\n   The following core rules are included by reference,\
    \ as defined in\n   Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return),\n\
    \   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double\n   quote),\
    \ HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any\n   8-bit sequence\
    \ of data), SP (space), and VCHAR (any visible US-ASCII\n   character).\n   The\
    \ rules below are defined in [RFC7230]:\n     OWS           = <OWS, see [RFC7230],\
    \ Section 3.2.3>\n     field-name    = <field-name, see [RFC7230], Section 3.2>\n\
    \     quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>\n     token\
    \         = <token, see [RFC7230], Section 3.2.6>\n     port          = <port,\
    \ see [RFC7230], Section 2.7>\n     pseudonym     = <pseudonym, see [RFC7230],\
    \ Section 5.7.1>\n     uri-host      = <uri-host, see [RFC7230], Section 2.7>\n\
    \   The rules below are defined in other parts:\n     HTTP-date     = <HTTP-date,\
    \ see [RFC7231], Section 7.1.1.1>\n"
- title: Appendix C.  Collected ABNF
  contents:
  - "Appendix C.  Collected ABNF\n   In the collected ABNF below, list rules are expanded\
    \ as per Section\n   1.2 of [RFC7230].\n   Age = delta-seconds\n   Cache-Control\
    \ = *( \",\" OWS ) cache-directive *( OWS \",\" [ OWS\n    cache-directive ] )\n\
    \   Expires = HTTP-date\n   HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>\n\
    \   OWS = <OWS, see [RFC7230], Section 3.2.3>\n   Pragma = *( \",\" OWS ) pragma-directive\
    \ *( OWS \",\" [ OWS\n    pragma-directive ] )\n   Warning = *( \",\" OWS ) warning-value\
    \ *( OWS \",\" [ OWS warning-value ]\n    )\n   cache-directive = token [ \"=\"\
    \ ( token / quoted-string ) ]\n   delta-seconds = 1*DIGIT\n   extension-pragma\
    \ = token [ \"=\" ( token / quoted-string ) ]\n   field-name = <field-name, see\
    \ [RFC7230], Section 3.2>\n   port = <port, see [RFC7230], Section 2.7>\n   pragma-directive\
    \ = \"no-cache\" / extension-pragma\n   pseudonym = <pseudonym, see [RFC7230],\
    \ Section 5.7.1>\n   quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>\n\
    \   token = <token, see [RFC7230], Section 3.2.6>\n   uri-host = <uri-host, see\
    \ [RFC7230], Section 2.7>\n   warn-agent = ( uri-host [ \":\" port ] ) / pseudonym\n\
    \   warn-code = 3DIGIT\n   warn-date = DQUOTE HTTP-date DQUOTE\n   warn-text =\
    \ quoted-string\n   warning-value = warn-code SP warn-agent SP warn-text [ SP\
    \ warn-date\n    ]\n"
- title: Index
  contents:
  - "Index\n   1\n      110 (warn-code)  31\n      111 (warn-code)  31\n      112\
    \ (warn-code)  31\n      113 (warn-code)  31\n      199 (warn-code)  32\n   2\n\
    \      214 (warn-code)  32\n      299 (warn-code)  32\n   A\n      age  11\n \
    \     Age header field  21\n   C\n      cache  4\n      cache entry  5\n     \
    \ cache key  5-6\n      Cache-Control header field  21\n   D\n      Disconnected\
    \ Operation (warn-text)  31\n   E\n      Expires header field  28\n      explicit\
    \ expiration time  11\n   F\n      fresh  11\n      freshness lifetime  11\n \
    \  G\n      Grammar\n         Age  21\n         Cache-Control  22\n         cache-directive\
    \  22\n         delta-seconds  5\n         Expires  28\n         extension-pragma\
    \  29\n         Pragma  29\n         pragma-directive  29\n         warn-agent\
    \  29\n         warn-code  29\n         warn-date  29\n         warn-text  29\n\
    \         Warning  29\n         warning-value  29\n   H\n      Heuristic Expiration\
    \ (warn-text)  31\n      heuristic expiration time  11\n   M\n      max-age (cache\
    \ directive)  22, 26\n      max-stale (cache directive)  22\n      min-fresh (cache\
    \ directive)  22\n      Miscellaneous Persistent Warning (warn-text)  32\n   \
    \   Miscellaneous Warning (warn-text)  32\n      must-revalidate (cache directive)\
    \  24\n   N\n      no-cache (cache directive)  23, 25\n      no-store (cache directive)\
    \  23, 24\n      no-transform (cache directive)  23, 25\n   O\n      only-if-cached\
    \ (cache directive)  23\n   P\n      Pragma header field  29\n      private (cache\
    \ directive)  25\n      private cache  4\n      proxy-revalidate (cache directive)\
    \  26\n      public (cache directive)  25\n   R\n      Response is Stale (warn-text)\
    \  30\n      Revalidation Failed (warn-text)  31\n   S\n      s-maxage (cache\
    \ directive)  27\n      shared cache  4\n      stale  11\n      strong validator\
    \  18\n   T\n      Transformation Applied (warn-text)  32\n   V\n      validator\
    \  16\n   W\n      Warning header field  29\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Roy T. Fielding (editor)\n   Adobe Systems Incorporated\n\
    \   345 Park Ave\n   San Jose, CA  95110\n   USA\n   EMail: fielding@gbiv.com\n\
    \   URI:   http://roy.gbiv.com/\n   Mark Nottingham (editor)\n   Akamai\n   EMail:\
    \ mnot@mnot.net\n   URI:   http://www.mnot.net/\n   Julian F. Reschke (editor)\n\
    \   greenbytes GmbH\n   Hafenweg 16\n   Muenster, NW  48155\n   Germany\n   EMail:\
    \ julian.reschke@greenbytes.de\n   URI:   http://greenbytes.de/tech/webdav/\n"
