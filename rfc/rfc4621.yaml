- title: __initial_text__
  contents:
  - '     Design of the IKEv2 Mobility and Multihoming (MOBIKE) Protocol

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   The IKEv2 Mobility and Multihoming (MOBIKE) protocol is an extension\n\
    \   of the Internet Key Exchange Protocol version 2 (IKEv2).  These\n   extensions\
    \ should enable an efficient management of IKE and IPsec\n   Security Associations\
    \ when a host possesses multiple IP addresses\n   and/or where IP addresses of\
    \ an IPsec host change over time (for\n   example, due to mobility).\n   This\
    \ document discusses the involved network entities and the\n   relationship between\
    \ IKEv2 signaling and information provided by\n   other protocols.  Design decisions\
    \ for the MOBIKE protocol,\n   background information, and discussions within\
    \ the working group are\n   recorded.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................4\n  \
    \ 3. Scenarios .......................................................6\n    \
    \  3.1. Mobility Scenario ..........................................6\n      3.2.\
    \ Multihoming Scenario .......................................7\n      3.3. Multihomed\
    \ Laptop Scenario .................................8\n   4. Scope of MOBIKE .................................................8\n\
    \   5. Design Considerations ..........................................10\n  \
    \    5.1. Choosing Addresses ........................................10\n    \
    \       5.1.1. Inputs and Triggers ................................11\n      \
    \     5.1.2. Connectivity .......................................11\n        \
    \   5.1.3. Discovering Connectivity ...........................12\n          \
    \ 5.1.4. Decision Making ....................................12\n           5.1.5.\
    \ Suggested Approach .................................12\n      5.2. NAT Traversal\
    \ (NAT-T) .....................................12\n           5.2.1. Background\
    \ and Constraints .........................12\n           5.2.2. Fundamental Restrictions\
    \ ...........................13\n           5.2.3. Moving behind a NAT and Back\
    \ .......................13\n           5.2.4. Responder behind a NAT .............................14\n\
    \           5.2.5. NAT Prevention .....................................15\n  \
    \         5.2.6. Suggested Approach .................................15\n    \
    \  5.3. Scope of SA Changes .......................................15\n      5.4.\
    \ Zero Address Set Functionality ............................16\n      5.5. Return\
    \ Routability Check ..................................17\n           5.5.1. Employing\
    \ MOBIKE Results in Other Protocols ........19\n           5.5.2. Return Routability\
    \ Failures ........................20\n           5.5.3. Suggested Approach .................................21\n\
    \      5.6. IPsec Tunnel or Transport Mode ............................22\n  \
    \ 6. Protocol Details ...............................................22\n    \
    \  6.1. Indicating Support for MOBIKE .............................22\n      6.2.\
    \ Path Testing and Window size ..............................23\n      6.3. Message\
    \ Presentation ......................................24\n      6.4. Updating Address\
    \ Set ......................................25\n   7. Security Considerations\
    \ ........................................26\n   8. Acknowledgements ...............................................26\n\
    \   9. References .....................................................27\n  \
    \    9.1. Normative references ......................................27\n    \
    \  9.2. Informative References ....................................27\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The purpose of IKEv2 is to mutually authenticate two hosts,\
    \ to\n   establish one or more IPsec Security Associations (SAs) between them,\n\
    \   and subsequently to manage these SAs (for example, by rekeying or\n   deleting).\
    \  IKEv2 enables the hosts to share information that is\n   relevant to both the\
    \ usage of the cryptographic algorithms that\n   should be employed (e.g., parameters\
    \ required by cryptographic\n   algorithms and session keys) and to the usage\
    \ of local security\n   policies, such as information about the traffic that should\n\
    \   experience protection.\n   IKEv2 assumes that an IKE SA is created implicitly\
    \ between the IP\n   address pair that is used during the protocol execution when\n\
    \   establishing the IKEv2 SA.  This means that, in each host, only one\n   IP\
    \ address pair is stored for the IKEv2 SA as part of a single IKEv2\n   protocol\
    \ session, and, for tunnel mode SAs, the host places this\n   single pair in the\
    \ outer IP headers.  Existing IPsec documents make\n   no provision to change\
    \ this pair after an IKE SA is created (except\n   for dynamic address update\
    \ of Network Address Translation Traversal\n   (NAT-T)).\n   There are scenarios\
    \ where one or both of the IP addresses of this\n   pair may change during an\
    \ IPsec session.  In principle, the IKE SA\n   and all corresponding IPsec SAs\
    \ could be re-established after the IP\n   address has changed.  However, this\
    \ is a relatively expensive\n   operation, and it can be problematic when such\
    \ changes are frequent.\n   Moreover, manual user interaction (for example, when\
    \ using human-\n   operated token cards (SecurID)) might be required as part of\
    \ the\n   IKEv2 authentication procedure.  Therefore, an automatic mechanism is\n\
    \   needed that updates the IP addresses associated with the IKE SA and\n   the\
    \ IPsec SAs.  The MOBIKE protocol provides such a mechanism.\n   The MOBIKE protocol\
    \ is assumed to work on top of IKEv2 [RFC4306].  As\n   IKEv2 is built on the\
    \ IPsec architecture [RFC4301], all protocols\n   developed within the MOBIKE\
    \ working group must be compatible with\n   both IKEv2 and the architecture described\
    \ in RFC 4301.  This document\n   does not discuss mobility and multi-homing support\
    \ for IKEv1\n   [RFC2409] or the obsoleted IPsec architecture described in RFC\
    \ 2401\n   [RFC2401].\n   This document is structured as follows: After some important\
    \ terms\n   are introduced in Section 2, a number of relevant usage scenarios\
    \ are\n   discussed in Section 3.  Section 4 describes the scope of the MOBIKE\n\
    \   protocol.  Section 5 discusses design considerations affecting the\n   MOBIKE\
    \ protocol.  Section 6 investigates details regarding the MOBIKE\n   protocol.\
    \  Finally, this document concludes in Section 7 with\n   security considerations.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This section introduces the terminology that is used in this\n\
    \   document.\n   Peer\n      A peer is an IKEv2 endpoint.  In addition, a peer\
    \ implements the\n      MOBIKE extensions, defined in [RFC4555].\n   Available\
    \ address\n      An address is said to be available if the following conditions\
    \ are\n      met:\n      *  The address has been assigned to an interface.\n \
    \     *  If the address is an IPv6 address, we additionally require (a)\n    \
    \     that the address is valid as defined in RFC 2461 [RFC2461], and\n      \
    \   (b) that the address is not tentative as defined in RFC 2462\n         [RFC2462].\
    \  In other words, we require the address assignment\n         to be complete.\n\
    \         Note that this explicitly allows an address to be optimistic as\n  \
    \       defined in [RFC4429].\n      *  If the address is an IPv6 address, it\
    \ is a global unicast or\n         unique site-local address, as defined in [RFC4193].\
    \  That is,\n         it is not an IPv6 link-local address.\n      *  The address\
    \ and interface is acceptable for sending and\n         receiving traffic according\
    \ to a local policy.\n      This definition is taken from [WIP-Ark06] and adapted\
    \ for the\n      MOBIKE context.\n   Locally operational address\n      An address\
    \ is said to be locally operational if it is available\n      and its use is locally\
    \ known to be possible and permitted.  This\n      definition is taken from [WIP-Ark06].\n\
    \   Operational address pair\n      A pair of operational addresses are said to\
    \ be an operational\n      address pair if and only if bidirectional connectivity\
    \ can be\n      shown between the two addresses.  Note that sometimes it is\n\
    \      necessary to consider connectivity on a per-flow level between two\n  \
    \    endpoints.  This differentiation might be necessary to address\n      certain\
    \ Network Address Translation types or specific firewalls.\n      This definition\
    \ is taken from [WIP-Ark06] and adapted for the\n      MOBIKE context.  Although\
    \ it is possible to further differentiate\n      unidirectional and bidirectional\
    \ operational address pairs, only\n      bidirectional connectivity is relevant\
    \ to this document, and\n      unidirectional connectivity is out of scope.\n\
    \   Path\n      The sequence of routers traversed by the MOBIKE and IPsec packets\n\
    \      exchanged between the two peers.  Note that this path may be\n      affected\
    \ not only by the involved source and destination IP\n      addresses, but also\
    \ by the transport protocol.  Since MOBIKE and\n      IPsec packets have a different\
    \ appearance on the wire, they might\n      be routed along a different path,\
    \ for example, due to load\n      balancing.  This definition is taken from [RFC2960]\
    \ and adapted to\n      the MOBIKE context.\n   Current path\n      The sequence\
    \ of routers traversed by an IP packet that carries the\n      default source\
    \ and destination addresses is said to be the Current\n      Path.  This definition\
    \ is taken from [RFC2960] and adapted to the\n      MOBIKE context.\n   Preferred\
    \ address\n      The IP address of a peer to which MOBIKE and IPsec traffic should\n\
    \      be sent by default.  A given peer has only one active preferred\n     \
    \ address at a given point in time, except for the small time period\n      where\
    \ it switches from an old to a new preferred address.  This\n      definition\
    \ is taken from [WIP-Nik06] and adapted to the MOBIKE\n      context.\n   Peer\
    \ address set\n      We denote the two peers of a MOBIKE session by peer A and\
    \ peer B.\n      A peer address set is the subset of locally operational addresses\n\
    \      of peer A that is sent to peer B. A policy available at peer A\n      indicates\
    \ which addresses are included in the peer address set.\n      Such a policy might\
    \ be created either manually or automatically\n      through interaction with\
    \ other mechanisms that indicate new\n      available addresses.\n   Bidirectional\
    \ address pair\n      The address pair, where traffic can be sent to both directions,\n\
    \      simply by reversing the IP addresses.  Note that the path of the\n    \
    \  packets going to each direction might be different.\n   Unidirectional address\
    \ pair\n      The address pair, where traffic can only be sent in one direction,\n\
    \      and reversing the IP addresses and sending reply back does not\n      work.\n\
    \   For mobility-related terminology (e.g., Make-before-break or Break-\n   before-make),\
    \ see [RFC3753].\n"
- title: 3.  Scenarios
  contents:
  - "3.  Scenarios\n   In this section, we discuss three typical usage scenarios for\
    \ the\n   MOBIKE protocol.\n"
- title: 3.1.  Mobility Scenario
  contents:
  - "3.1.  Mobility Scenario\n   Figure 1 shows a break-before-make mobility scenario\
    \ where a mobile\n   node (MN) changes its point of network attachment.  Prior\
    \ to the\n   change, the mobile node had established an IPsec connection with\
    \ a\n   security gateway that offered, for example, access to a corporate\n  \
    \ network.  The IKEv2 exchange that facilitated the setup of the IPsec\n   SA(s)\
    \ took place over the path labeled as 'old path'.  The involved\n   packets carried\
    \ the MN's \"old\" IP address and were forwarded by the\n   \"old\" access router\
    \ (OAR) to the security gateway (GW).\n   When the MN changes its point of network\
    \ attachment, it obtains a new\n   IP address using stateful or stateless address\
    \ configuration.  The\n   goal of MOBIKE, in this scenario, is to enable the MN\
    \ and the GW to\n   continue using the existing SAs and to avoid setting up a\
    \ new IKE SA.\n   A protocol exchange, denoted by 'MOBIKE Address Update', enables\
    \ the\n   peers to update their state as necessary.\n   Note that in a break-before-make\
    \ scenario the MN obtains the new IP\n   address after it can no longer be reached\
    \ at the old IP address.  In\n   a make-before-break scenario, the MN is, for\
    \ a given period of time,\n   reachable at both the old and the new IP address.\
    \  MOBIKE should work\n   in both of the above scenarios.\n                  \
    \        (Initial IKEv2 Exchange)\n                    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>v\n\
    \       Old IP   +--+        +---+                    v\n       address  |MN|------>\
    \ |OAR| -------------V     v\n                +--+        +---+ Old path     V\
    \     v\n                 .                          +----+   v>>>>> +--+\n  \
    \               .move                      | R  | -------> |GW|\n            \
    \     .                          |    |    >>>>> |  |\n                 v    \
    \                      +----+   ^      +--+\n                +--+        +---+\
    \ New path     ^     ^\n       New IP   |MN|------> |NAR|--------------^     ^\n\
    \       address  +--+        +---+                    ^\n                    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>^\n\
    \                          (MOBIKE Address Update)\n              ---> = Path\
    \ taken by data packets\n              >>>> = Signaling traffic (IKEv2 and MOBIKE)\n\
    \              ...> = End host movement\n                        Figure 1: Mobility\
    \ Scenario\n"
- title: 3.2.  Multihoming Scenario
  contents:
  - "3.2.  Multihoming Scenario\n   Another MOBIKE usage scenario is depicted in Figure\
    \ 2.  In this\n   scenario, the MOBIKE peers are equipped with multiple interfaces\
    \ (and\n   multiple IP addresses).  Peer A has two interface cards with two IP\n\
    \   addresses, IP_A1 and IP_A2, and peer B has two IP addresses, IP_B1\n   and\
    \ IP_B2.  Each peer selects one of its IP addresses as the\n   preferred address,\
    \ which is used for subsequent communication.\n   Various reasons (e.g., hardware\
    \ or network link failures) may require\n   a peer to switch from one interface\
    \ to another.\n     +------------+                                  +------------+\n\
    \     | Peer A     |           *~~~~~~~~~*            | Peer B     |\n     | \
    \           |>>>>>>>>>> * Network   *>>>>>>>>>>|            |\n     |      IP_A1\
    \ +-------->+             +--------->+ IP_B1      |\n     |            |     \
    \    |             |          |            |\n     |      IP_A2 +********>+  \
    \           +*********>+ IP_B2      |\n     |            |          *        \
    \   *           |            |\n     +------------+           *~~~~~~~~~*    \
    \        +------------+\n              ---> = Path taken by data packets\n   \
    \           >>>> = Signaling traffic (IKEv2 and MOBIKE)\n              ***> =\
    \ Potential future path through the network\n                     (if Peer A and\
    \ Peer B change their preferred\n                      address)\n            \
    \          Figure 2: Multihoming Scenario\n   Note that MOBIKE does not aim to\
    \ support load balancing between\n   multiple IP addresses.  That is, each peer\
    \ uses only one of the\n   available address pairs at a given point in time.\n"
- title: 3.3.  Multihomed Laptop Scenario
  contents:
  - "3.3.  Multihomed Laptop Scenario\n   The third scenario we consider is about\
    \ a laptop that has multiple\n   interface cards and therefore several ways to\
    \ connect to the network.\n   It may, for example, have a fixed Ethernet card,\
    \ a WLAN interface, a\n   General Packet Radio Service (GPRS) adaptor, a Bluetooth\
    \ interface,\n   or USB hardware.  Not all interfaces are used for communication\
    \ all\n   the time for a number of reasons (e.g., cost, network availability,\n\
    \   user convenience).  The policies that determine which interfaces are\n   connected\
    \ to the network at any given point in time is outside the\n   scope of the MOBIKE\
    \ protocol and, as such, this document.  However,\n   as the laptop changes its\
    \ point of attachment to the network, the set\n   of IP addresses under which\
    \ the laptop is reachable changes too.\n   In all of these scenarios, even if\
    \ IP addresses change due to\n   interface switching or mobility, the IP address\
    \ obtained via the\n   configuration payloads within IKEv2 remain unaffected.\
    \  The IP\n   address obtained via the IKEv2 configuration payloads allow the\n\
    \   configuration of the inner IP address of the IPsec tunnel.  As such,\n   applications\
    \ might not detect any change at all.\n"
- title: 4.  Scope of MOBIKE
  contents:
  - "4.  Scope of MOBIKE\n   Getting mobility and multihoming actually working requires\
    \ many\n   different components to work together, including coordinating\n   decisions\
    \ between different layers, different mobility mechanisms,\n   and IPsec/IKEv2.\
    \  Most of those aspects are beyond the scope of\n   MOBIKE: MOBIKE focuses only\
    \ on what two peers need in order to agree\n   at the IKEv2 level (like new message\
    \ formats and some aspects of\n   their processing) required for interoperability.\n\
    \   The MOBIKE protocol is not trying to be a full mobility protocol;\n   there\
    \ is no support for simultaneous movement or rendezvous\n   mechanism, and there\
    \ is no support for route optimization, etc.  The\n   design document focuses\
    \ on tunnel mode; everything going inside the\n   tunnel is unaffected by the\
    \ changes in the tunnel header IP address,\n   and this is the mobility feature\
    \ provided by the MOBIKE.  That is,\n   applications running inside the MOBIKE-controlled\
    \ IPsec tunnel might\n   not detect the movement since their IP addresses remain\
    \ constant.\n   The MOBIKE protocol should be able to perform the following\n\
    \   operations (not all of which are done explicitly by the current\n   protocol):\n\
    \   o  Inform the other peer about the peer address set\n   o  Inform the other\
    \ peer about the preferred address\n   o  Test connectivity along a path and thereby\
    \ detect an outage\n      situation\n   o  Change the preferred address\n   o\
    \  Change the peer address set\n   o  Ability to deal with Network Address Translation\
    \ devices\n   Figure 3 shows an example protocol interaction between a pair of\n\
    \   MOBIKE peers.  MOBIKE interacts with the packet processing module of\n   the\
    \ IPsec implementation using an internal API (such as those based\n   on PF_KEY\
    \ [RFC2367]).  Using this API, the MOBIKE module can create\n   entries in the\
    \ Security Association (SAD) and Security Policy\n   Databases (SPD).  The packet\
    \ processing module of the IPsec\n   implementation may also interact with IKEv2\
    \ and MOBIKE module using\n   this API.  The content of the Security Policy and\
    \ Security\n   Association Databases determines what traffic is protected with\
    \ IPsec\n   in which fashion.  MOBIKE, on the other hand, receives information\n\
    \   from a number of sources that may run both in kernel-mode and in\n   user-mode.\
    \  These sources form the basis on which MOBIKE makes\n   decisions regarding\
    \ the set of available addresses, the peer address\n   set, and the preferred\
    \ address.  Policies may also affect the\n   selection process.\n   The peer address\
    \ set and the preferred address needs to be made\n   available to the other peer.\
    \  In order to address certain failure\n   cases, MOBIKE should perform connectivity\
    \ tests between the peers\n   (potentially over a number of different paths).\
    \  Although a number of\n   address pairs may be available for such tests, the\
    \ most important is\n   the pair (source address, destination address) of the\
    \ current path.\n   This is because this pair is selected for sending and receiving\n\
    \   MOBIKE signaling and IPsec traffic.  If a problem along this current\n   path\
    \ is detected (e.g., due to a router failure), it is necessary to\n   switch to\
    \ a new current path.  In order to be able to do so quickly,\n   it may be helpful\
    \ to perform connectivity tests of other paths\n   periodically.  Such a technique\
    \ would also help identify previously\n   disconnected paths that become operational\
    \ again.\n     +---------------------+            +----------------+\n     | \
    \   User-space       |            |                |\n     |   Protocols and \
    \    |            |   MOBIKE and   |\n     | Functions Relevant  |<---------->|\
    \  IKEv2 Module  |\n     | MOBIKE (e.g., DHCP, |            |                |\n\
    \     |     policies)       |            +----------------+\n     +---------------------+\
    \                    ^\n                ^                               |\n  \
    \              |                               |        User space\n     ++++++++++API++++++++++++++++++++++++++++PF_KEY+++++++++++++++\n\
    \                |                               |      Kernel space\n       \
    \         |                               v\n                |               \
    \        +----------------+\n                v                       |       \
    \         |\n     +---------------------+            |  IPsec engine  |\n    \
    \ |   Kernel-space      |<---------->| (and databases)|\n     |     Protocols\
    \       |            |                |\n     |    Relevant for     |        \
    \    +----------------+\n     |  MOBIKE (e.g., ND,  |                    ^\n \
    \    |     DNA, L2)        |<---------------+   |\n     +---------------------+\
    \                v   v\n            ||                          +----------------+\n\
    \            \\/                          |                |\n          Inter-\
    \  =====================>| IP forwarding, |\n          faces   <=====================|input\
    \ and output|\n                                        |                |\n  \
    \                                      +----------------+\n         ===> = IP\
    \ packets arriving/leaving a MOBIKE node\n         <->  = control and configuration\
    \ operations\n                            Figure 3: Framework\n   Please note\
    \ that Figure 3 illustrates an example of how a MOBIKE\n   implementation could\
    \ work.  It serves illustrative purposes only.\n"
- title: 5.  Design Considerations
  contents:
  - "5.  Design Considerations\n   This section discusses aspects affecting the design\
    \ of the MOBIKE\n   protocol.\n"
- title: 5.1.  Choosing Addresses
  contents:
  - "5.1.  Choosing Addresses\n   One of the core aspects of the MOBIKE protocol is\
    \ the selection of\n   the address for the IPsec packets we send.  Choosing addresses\
    \ for\n   the IKEv2 request is a somewhat separate problem.  In many cases,\n\
    \   they will be the same (and in some design choice they will always be\n   the\
    \ same and could be forced to be the same by design).\n"
- title: 5.1.1.  Inputs and Triggers
  contents:
  - "5.1.1.  Inputs and Triggers\n   How address changes are triggered is largely\
    \ beyond the scope of\n   MOBIKE.  The triggers can include changes in the set\
    \ of addresses,\n   various link-layer indications, failing dead peer detection,\
    \ and\n   changes in preferences and policies.  Furthermore, there may be less\n\
    \   reliable sources of information (such as lack of IPsec packets and\n   incoming\
    \ ICMP packets) that do not trigger any changes directly, but\n   rather cause\
    \ Dead Peer Detection (DPD) to be scheduled earlier and,\n   if it fails, it might\
    \ cause a change of the preferred address.\n   These triggers are largely the\
    \ same as for other mobility protocols\n   such as Mobile IP, and they are beyond\
    \ the scope of MOBIKE.\n"
- title: 5.1.2.  Connectivity
  contents:
  - "5.1.2.  Connectivity\n   There can be two kinds of connectivity \"failures\"\
    : local failures and\n   path failures.  Local failures are problems locally at\
    \ a MOBIKE peer\n   (e.g., an interface error).  Path failures are a property\
    \ of an\n   address pair and failures of nodes and links along this path.  MOBIKE\n\
    \   does not support unidirectional address pairs.  Supporting them would\n  \
    \ require abandoning the principle of sending an IKEv2 reply to the\n   address\
    \ from which the request came.  MOBIKE decided to deal only\n   with bidirectional\
    \ address pairs.  It does consider unidirectional\n   address pairs as broken\
    \ and does not use them, but the connection\n   between peers will not break even\
    \ if unidirectional address pairs are\n   present, provided there is at least\
    \ one bidirectional address pair\n   MOBIKE can use.\n   Note that MOBIKE is not\
    \ concerned about the actual path used; it\n   cannot even detect if some path\
    \ is unidirectionally operational if\n   the same address pair has some other\
    \ unidirectional path back.\n   Ingress filters might still cause such path pairs\
    \ to be unusable, and\n   in that case MOBIKE will detect that there is no operational\
    \ address\n   pair.\n   In a sense having both an IPv4 and an IPv6 address is\
    \ basically a\n   case of partial connectivity (putting both an IPv4 and an IPv6\n\
    \   address in the same IP header does not work).  The main difference is\n  \
    \ that it is known beforehand; there is no need to discover that an\n   IPv4/IPv6\
    \ combination does not work.\n"
- title: 5.1.3.  Discovering Connectivity
  contents:
  - "5.1.3.  Discovering Connectivity\n   To detect connectivity, the MOBIKE protocol\
    \ needs to have a mechanism\n   to test connectivity.  If a MOBIKE peer receives\
    \ a reply, it can be\n   sure about the existence of a working (bidirectional)\
    \ address pair.\n   If a MOBIKE peer does not see a reply after multiple retransmissions,\n\
    \   it may assume that the tested address pair is broken.\n   The connectivity\
    \ tests require congestion problems to be taken into\n   account because the connection\
    \ failure might be caused by congestion.\n   The MOBIKE protocol should not make\
    \ the congestion problem worse by\n   sending many DPD packets.\n"
- title: 5.1.4.  Decision Making
  contents:
  - "5.1.4.  Decision Making\n   One of the main questions in designing the MOBIKE\
    \ protocol was who\n   makes the decisions how to fix a situation when failure\
    \ is detected,\n   e.g., symmetry vs. asymmetry in decision making.  Symmetric\
    \ decision\n   making (i.e., both peers can make decisions) may cause the different\n\
    \   peers to make different decisions, thus causing asymmetric upstream/\n   downstream\
    \ traffic.  In the mobility case, it is desirable that the\n   mobile peer can\
    \ move both upstream and downstream traffic to some\n   particular interface,\
    \ and this requires asymmetric decision making\n   (i.e. only one peer makes decisions).\n\
    \   Working with stateful packet filters and NATs is easier if the same\n   address\
    \ pair is used in both upstream and downstream directions.\n   Also, in common\
    \ cases, only the peer behind NAT can actually perform\n   actions to recover\
    \ from the connectivity problems, as the other peer\n   might not be able to initiate\
    \ any connections to the peer behind NAT.\n"
- title: 5.1.5.  Suggested Approach
  contents:
  - "5.1.5.  Suggested Approach\n   The working group decided to select a method whereby\
    \ the initiator\n   will decide which addresses are used.  As a consequence, the\
    \ outcome\n   is always the same for both parties.  It also works best with NATs,\n\
    \   as the initiator is most likely the node that is located behind a\n   NAT.\n"
- title: 5.2.  NAT Traversal (NAT-T)
  contents:
  - '5.2.  NAT Traversal (NAT-T)

    '
- title: 5.2.1.  Background and Constraints
  contents:
  - "5.2.1.  Background and Constraints\n   Another core aspect of MOBIKE is the treatment\
    \ of different NATs and\n   Network Address Port Translations (NAPTs).  In IKEv2\
    \ the tunnel\n   header IP addresses are not sent inside the IKEv2 payloads, and\
    \ thus\n   there is no need to do unilateral self-address fixing (UNSAF\n   [RFC3424]).\
    \  The tunnel header IP addresses are taken from the outer\n   IP header of the\
    \ IKE packets; thus, they are already processed by the\n   NAT.\n   The NAT detection\
    \ payloads are used to determine whether the\n   addresses in the IP header were\
    \ modified by a NAT along the path.\n   Detecting a NAT typically requires UDP\
    \ encapsulation of IPsec ESP\n   packets to be enabled, if desired.  MOBIKE is\
    \ not to change how IKEv2\n   NAT-T works in particular, any kind of UNSAF or\
    \ explicit interaction\n   with NATs (e.g., MIDCOM [RFC3303] or NSIS NATFW NSLP\
    \ [WIP-Sti06]) is\n   beyond the scope of the MOBIKE protocol.  The MOBIKE protocol\
    \ will\n   need to define how MOBIKE and NAT-T are used together.\n   The NAT-T\
    \ support should also be optional.  If the IKEv2\n   implementation does not implement\
    \ NAT-T, as it is not required in\n   some particular environment, implementing\
    \ MOBIKE should not require\n   adding support for NAT-T either.\n   The property\
    \ of being behind NAT is actually a property of the\n   address pair and thereby\
    \ of the path taken by a packet.  Thus, one\n   peer can have multiple IP addresses,\
    \ and some of those might be\n   behind NAT and some might not.\n"
- title: 5.2.2.  Fundamental Restrictions
  contents:
  - "5.2.2.  Fundamental Restrictions\n   There are some cases that cannot be carried\
    \ out within MOBIKE.  One\n   of those cases is when the party \"outside\" a symmetric\
    \ NAT changes\n   its address to something not known by the other peer (and the\
    \ old\n   address has stopped working).  It cannot send a packet containing the\n\
    \   new addresses to the peer because the NAT does not contain the\n   necessary\
    \ state.  Furthermore, since the party behind the NAT does\n   not know the new\
    \ IP address, it cannot cause the NAT state to be\n   created.\n   This case could\
    \ be solved using some rendezvous mechanism outside\n   IKEv2, but that is beyond\
    \ the scope of MOBIKE.\n"
- title: 5.2.3.  Moving behind a NAT and Back
  contents:
  - "5.2.3.  Moving behind a NAT and Back\n   The MOBIKE protocol should provide a\
    \ mechanism whereby a peer that is\n   initially not behind a NAT can move behind\
    \ NAT when a new preferred\n   address is selected.  The same effect might be\
    \ accomplished with the\n   change of the address pair if more than one path is\
    \ available (e.g.,\n   in the case of a multi-homed host).  An impact for the\
    \ MOBIKE\n   protocol is only caused when the currently selected address pair\n\
    \   causes MOBIKE packets to traverse a NAT.\n   Similarly, the MOBIKE protocol\
    \ provides a mechanism to detect when a\n   NATed path is changed to a non-NATed\
    \ path with the change of the\n   address pair.\n   As we only use one address\
    \ pair at time, effectively the MOBIKE peer\n   is either behind NAT or not behind\
    \ NAT, but each address change can\n   change this situation.  Because of this,\
    \ and because the initiator\n   always chooses the addresses, it is enough to\
    \ send keepalive packets\n   only to that one address pair.\n   Enabling NAT-T\
    \ involves a few different things.  One is to enable the\n   UDP encapsulation\
    \ of ESP packets.  Another is to change the IKE SA\n   ports from port 500 to\
    \ port 4500.  We do not want to do unnecessary\n   UDP encapsulation unless there\
    \ is really a NAT between peers, i.e.,\n   UDP encapsulation should only be enabled\
    \ when we actually detect NAT.\n   On the other hand, as all implementations supporting\
    \ NAT-T must be\n   able to respond to port 4500 all the time, it is simpler from\
    \ the\n   protocol point of view to change the port numbers from 500 to 4500\n\
    \   immediately upon detecting that the other end supports NAT-T.  This\n   way\
    \ it is not necessary to change ports after we later detected NAT,\n   which would\
    \ have caused complications to the protocol.\n   If we changed the port only after\
    \ we detected NAT, then the responder\n   would not be able to use the IKE and\
    \ IPsec SAs immediately after\n   their address is changed to be behind NAT. \
    \ Instead, it would need to\n   wait for the next packet from the initiator to\
    \ see what IP and port\n   numbers are used after the initiator changed its port\
    \ from 500 to\n   4500.  The responder would also not be able to send anything\
    \ to the\n   initiator before the initiator sent something to the responder. \
    \ If\n   we do the port number changing immediately after the IKE_SA_INIT and\n\
    \   before IKE_AUTH phase, then we get the rid of this problem.\n"
- title: 5.2.4.  Responder behind a NAT
  contents:
  - "5.2.4.  Responder behind a NAT\n   MOBIKE can work in cases where the responder\
    \ is behind a static NAT,\n   but the initiator would need to know all the possible\
    \ addresses to\n   which the responder can move.  That is, the responder cannot\
    \ move to\n   an address which is not known by the initiator, in case initiator\n\
    \   also moves behind NAT.\n   If the responder is behind a NAPT, then it might\
    \ need to communicate\n   with the NAT to create a mapping so the initiator can\
    \ connect to it.\n   Those external firewall pinhole opening mechanisms are beyond\
    \ the\n   scope of MOBIKE.\n   In case the responder is behind NAPT, then finding\
    \ the port numbers\n   used by the responder is outside the scope of MOBIKE.\n"
- title: 5.2.5.  NAT Prevention
  contents:
  - "5.2.5.  NAT Prevention\n   One new feature created by MOBIKE is NAT prevention.\
    \  If we detect\n   NAT between the peers, we do not allow that address pair to\
    \ be used.\n   This can be used to protect IP addresses in cases where the\n \
    \  configuration knows that there is no NAT between the nodes (for\n   example\
    \ IPv6, or fixed site-to-site VPN).  This avoids any\n   possibility of on-path\
    \ attackers modifying addresses in headers.\n   This feature means that we authenticate\
    \ the IP address and detect if\n   they were changed.  As this is done on purpose\
    \ to break the\n   connectivity if NAT is detected, and decided by the configuration,\n\
    \   there is no need to do UNSAF processing.\n"
- title: 5.2.6.  Suggested Approach
  contents:
  - "5.2.6.  Suggested Approach\n   The working group decided that MOBIKE uses NAT-T\
    \ mechanisms from the\n   IKEv2 protocol as much as possible, but decided to change\
    \ the dynamic\n   address update (see [RFC4306], Section 2.23, second to last\n\
    \   paragraph) for IKEv2 packets to \"MUST NOT\" (it would break path\n   testing\
    \ using IKEv2 packets; see Section 6.2).  The working group\n   also decided only\
    \ to send keepalives to the current address pair.\n"
- title: 5.3.  Scope of SA Changes
  contents:
  - "5.3.  Scope of SA Changes\n   Most sections of this document discuss design considerations\
    \ for\n   updating and maintaining addresses in the database entries that\n  \
    \ relate to an IKE SA.  However, changing the preferred address also\n   affects\
    \ the entries of the IPsec SA database.  The outer tunnel\n   header addresses\
    \ (source and destination IP addresses) need to be\n   modified according to the\
    \ current path to allow the IPsec protected\n   data traffic to travel along the\
    \ same path as the MOBIKE packets.  If\n   the MOBIKE messages and the IPsec protected\
    \ data traffic travel along\n   a different path, then NAT handling is severely\
    \ complicated.\n   The basic question is then how the IPsec SAs are changed to\
    \ use the\n   new address pair (the same address pair as the MOBIKE signaling\n\
    \   traffic).  One option is that when the IKE SA address is changed, all\n  \
    \ IPsec SAs associated with it are automatically moved along with it to\n   a\
    \ new address pair.  Another option is to have a separate exchange to\n   move\
    \ the IPsec SAs separately.\n   If IPsec SAs should be updated separately, then\
    \ a more efficient\n   format than the Notify payload is needed to preserve bandwidth.\
    \  A\n   Notify payload can only store one Security Parameter Index (SPI) per\n\
    \   payload.  A separate payload could have a list of IPsec SA SPIs and\n   the\
    \ new preferred address.  If there is a large number of IPsec SAs,\n   those payloads\
    \ can be quite large unless list of ranges of SPI values\n   are supported.  If\
    \ we automatically move all IPsec SAs when the IKE\n   SA moves, then we only\
    \ need to keep track of which IKE SA was used to\n   create the IPsec SA, and\
    \ fetch the IP addresses from the IKE SA,\n   i.e., there is no need to store\
    \ IP addresses per IPsec SA.  Note that\n   IKEv2 [RFC4306] already requires the\
    \ implementations to keep track of\n   which IPsec SAs are created using which\
    \ IKE SA.\n   If we do allow the address set of each IPsec SA to be updated\n\
    \   separately, then we can support scenarios where the machine has fast\n   and/or\
    \ cheap connections and slow and/or expensive connections and\n   wants to allow\
    \ moving some of the SAs to the slower and/or more\n   expensive connection, and\
    \ prevent the move, for example, of the news\n   video stream from the WLAN to\
    \ the GPRS link.\n   On the other hand, even if we tie the IKE SA update to the\
    \ IPsec SA\n   update, we can create separate IKE SAs for this scenario.  For\n\
    \   example, we create one IKE SA that has both links as endpoints, and\n   it\
    \ is used for important traffic; then we create another IKE SA which\n   has only\
    \ the fast and/or cheap connection, which is used for that\n   kind of bulk traffic.\n\
    \   The working group decided to move all IPsec SAs implicitly when the\n   IKE\
    \ SA address pair changes.  If more granular handling of the IPsec\n   SA is required,\
    \ then multiple IKE SAs can be created one for each set\n   of IPsec SAs needed.\n"
- title: 5.4.  Zero Address Set Functionality
  contents:
  - "5.4.  Zero Address Set Functionality\n   One of the features that is potentially\
    \ useful is for the peer to\n   announce that it will now disconnect for some\
    \ time, i.e., it will not\n   be reachable at all.  For instance, a laptop might\
    \ go to suspend\n   mode.  In this case, it could send address notification with\
    \ zero new\n   addresses, which would mean that it will not have any valid addresses\n\
    \   anymore.  The responder would then acknowledge that notification and\n   could\
    \ then temporarily disable all SAs and therefore stop sending\n   traffic.  If\
    \ any of the SAs get any packets, they are simply dropped.\n   This could also\
    \ include some kind of ACK spoofing to keep the TCP/IP\n   sessions alive (or\
    \ simply setting the TCP/IP keepalives and timeouts\n   large enough not to cause\
    \ problems), or it could simply be left to\n   the applications, e.g., allow TCP/IP\
    \ sessions to notice if the link\n   is broken.\n   The local policy could then\
    \ indicate how long the peer should allow\n   remote peers to remain disconnected.\n\
    \   From a technical point of view, this would provide following two\n   features:\n\
    \   o  There is no need to transmit IPsec data traffic.  IPsec-protected\n   \
    \   data can be dropped, which saves bandwidth.  This does not provide\n     \
    \ a functional benefit, i.e., nothing breaks if this feature is not\n      provided.\n\
    \   o  MOBIKE signaling messages are also ignored.  The IKE SA must not\n    \
    \  be deleted, and the suspend functionality (realized with the zero\n      address\
    \ set) may require the IKE SA to be tagged with a lifetime\n      value since\
    \ the IKE SA should not be kept alive for an undefined\n      period of time.\
    \  Note that IKEv2 does not require that the IKE SA\n      has a lifetime associated\
    \ with it.  In order to prevent the IKE SA\n      from being deleted, the dead-peer\
    \ detection mechanism needs to be\n      suspended as well.\n   Due to its complexity\
    \ and no clear requirement for it, it was decided\n   that MOBIKE does not support\
    \ this feature.\n"
- title: 5.5.  Return Routability Check
  contents:
  - "5.5.  Return Routability Check\n   Changing the preferred address and subsequently\
    \ using it for\n   communication is associated with an authorization decision:\
    \ Is a peer\n   allowed to use this address?  Does this peer own this address?\
    \  Two\n   mechanisms have been proposed in the past to allow a peer to\n   determine\
    \ the answer to these questions:\n   o  The addresses a peer is using are part\
    \ of a certificate.\n      [RFC3554] introduced this approach.  If the other peer\
    \ is, for\n      example, a security gateway with a limited set of fixed IP\n\
    \      addresses, then the security gateway may have a certificate with\n    \
    \  all the IP addresses appearing in the certificate.\n   o  A return routability\
    \ check is performed by the remote peer before\n      the address is updated in\
    \ that peer's Security Association\n      Database.  This is done in order to\
    \ provide a certain degree of\n      confidence to the remote peer that the local\
    \ peer is reachable at\n      the indicated address.\n   Without taking an authorization\
    \ decision, a malicious peer can\n   redirect traffic towards a third party or\
    \ a black hole.\n   A MOBIKE peer should not use an IP address provided by another\
    \ MOBIKE\n   peer as a current address without computing the authorization\n \
    \  decision.  If the addresses are part of the certificate, then it is\n   not\
    \ necessary to execute the return routability check.  The return\n   routability\
    \ check is a form of authorization check, although it\n   provides weaker guarantees\
    \ than the inclusion of the IP address as a\n   part of a certificate.  If multiple\
    \ addresses are communicated to the\n   remote peer, then some of these addresses\
    \ may be already verified.\n   Finally, it would be possible not to execute return\
    \ routability\n   checks at all.  In case of indirect change notifications (i.e.,\n\
    \   something we notice from the network, not from the peer directly), we\n  \
    \ only move to the new preferred address after successful dead-peer\n   detection\
    \ (i.e., a response to a DPD test) on the new address, which\n   is already a\
    \ return routability check.  With a direct notification\n   (i.e., notification\
    \ from the other end directly) the authenticated\n   peer may have provided an\
    \ authenticated IP address (i.e., inside IKE\n   encrypted and authenticated payload;\
    \ see Section 5.2.5).  Thus, it is\n   would be possible simply to trust the MOBIKE\
    \ peer to provide a proper\n   IP address.  In this case, a protection against\
    \ an internal attacker\n   (i.e., the authenticated peer forwarding its traffic\
    \ to the new\n   address) would not provided.  On the other hand, we know the\
    \ identity\n   of the peer in that case.  There might be problems when extensions\n\
    \   are added to IKEv2 that do not require authentication of end points\n   (e.g.,\
    \ opportunistic security using anonymous Diffie-Hellman).\n   There is also a\
    \ policy issue of when to schedule a return routability\n   check.  Before moving\
    \ traffic?  After moving traffic?\n   The basic format of the return routability\
    \ check could be similar to\n   dead-peer detection, but potential attacks are\
    \ possible if a return\n   routability check does not include some kind of a nonce.\
    \  In these\n   attacks, the valid end point could send an address update\n  \
    \ notification for a third party, trying to get all the traffic to be\n   sent\
    \ there, causing a denial-of-service attack.  If the return\n   routability check\
    \ does not contain any nonce or other random\n   information not known to the\
    \ other peer, then the other peer could\n   reply to the return routability checks\
    \ even when it cannot see the\n   request.  This might cause a peer to move the\
    \ traffic to a location\n   where the original recipient cannot be reached.\n\
    \   The IKEv2 NAT-T mechanism does not perform return routability checks.\n  \
    \ It simply uses the last seen source IP address used by the other peer\n   as\
    \ the destination address to which response packets are to be sent.\n   An adversary\
    \ can change those IP addresses and can cause the response\n   packets to be sent\
    \ to a wrong IP address.  The situation is self-\n   fixing when the adversary\
    \ is no longer able to modify packets and the\n   first packet with an unmodified\
    \ IP address reaches the other peer.\n   Mobility environments make this attack\
    \ more difficult for an\n   adversary since the attack requires the adversary\
    \ to be located\n   somewhere on the individual paths ({CoA1, ..., CoAn} towards\
    \ the\n   destination IP address), to have a shared path, or, if the adversary\n\
    \   is located near the MOBIKE client, to follow the user mobility\n   patterns.\
    \  With IKEv2 NAT-T, the genuine client can cause third-party\n   bombing by redirecting\
    \ all the traffic pointed to him to a third\n   party.  As the MOBIKE protocol\
    \ tries to provide equal or better\n   security than IKEv2 NAT-T mechanism, it\
    \ should protect against these\n   attacks.\n   There may be return routability\
    \ information available from the other\n   parts of the system too (as shown in\
    \ Figure 3), but the checks done\n   may have a different quality.  There are\
    \ multiple levels for return\n   routability checks:\n   o  None; no tests.\n\
    \   o  A party willing to answer the return routability check is located\n   \
    \   along the path to the claimed address.  This is the basic form of\n      return\
    \ routability check.\n   o  There is an answer from the tested address, and that\
    \ answer was\n      authenticated and integrity- and replay-protected.\n   o \
    \ There was an authenticated and integrity- and replay-protected\n      answer\
    \ from the peer, but it is not guaranteed to originate at the\n      tested address\
    \ or path to it (because the peer can construct a\n      response without seeing\
    \ the request).\n   The return routability checks do not protect against third-party\n\
    \   bombing if the attacker is along the path, as the attacker can\n   forward\
    \ the return routability checks to the real peer (even if those\n   packets are\
    \ cryptographically authenticated).\n   If the address to be tested is carried\
    \ inside the MOBIKE payload,\n   then the adversary cannot forward packets.  Thus,\
    \ third-party\n   bombings are prevented (see Section 5.2.5).\n   If the reply\
    \ packet can be constructed without seeing the request\n   packet (for example,\
    \ if there is no nonce, challenge, or similar\n   mechanism to show liveness),\
    \ then the genuine peer can cause third-\n   party bombing, by replying to those\
    \ requests without seeing them at\n   all.\n   Other levels might only provide\
    \ a guarantee that there is a node at\n   the IP address that replied to the request.\
    \  There is no indication\n   as to whether or not the reply is fresh or whether\
    \ or not the request\n   may have been transmitted from a different source address.\n"
- title: 5.5.1.  Employing MOBIKE Results in Other Protocols
  contents:
  - "5.5.1.  Employing MOBIKE Results in Other Protocols\n   If MOBIKE has learned\
    \ about new locations or verified the validity of\n   a remote address through\
    \ a return routability check, can this\n   information be useful for other protocols?\n\
    \   When the basic MOBIKE VPN scenario is considered, the answer is no.\n   Transport\
    \ and application layer protocols running inside the VPN\n   tunnel are unaware\
    \ of the outer addresses or their status.\n   Similarly, IP-layer tunnel termination\
    \ at a gateway rather than a\n   host endpoint limits the benefits for \"other\
    \ protocols\" that could be\n   informed -- all application protocols at the other\
    \ side are unaware\n   of IPsec, IKE, or MOBIKE.\n   However, it is conceivable\
    \ that future uses or extensions of the\n   MOBIKE protocol make such information\
    \ distribution useful.  For\n   instance, if transport mode MOBIKE and SCTP were\
    \ made to work\n   together, it would potentially be useful for SCTP dynamic address\n\
    \   reconfiguration [WIP-Ste06] to learn about the new addresses at the\n   same\
    \ time as MOBIKE.  Similarly, various IP-layer mechanisms may make\n   use of\
    \ the fact that a return routability check of a specific type\n   has been performed.\
    \  However, care should be exercised in all these\n   situations.\n   [WIP-Cro04]\
    \ discusses the use of common locator information pools in\n   a IPv6 multi-homing\
    \ context; it assumes that both transport and IP-\n   layer solutions are used\
    \ in order to support multi-homing, and that\n   it would be beneficial for different\
    \ protocols to coordinate their\n   results in some way, for instance, by sharing\
    \ throughput information\n   of address pairs.  This may apply to MOBIKE as well,\
    \ assuming it\n   coexists with non-IPsec protocols that are faced with the same\
    \ or\n   similar multi-homing choices.\n   Nevertheless, all of this is outside\
    \ the scope of the current MOBIKE\n   base protocol design and may be addressed\
    \ in future work.\n"
- title: 5.5.2.  Return Routability Failures
  contents:
  - "5.5.2.  Return Routability Failures\n   If the return routability check fails,\
    \ we need to tear down the IKE\n   SA if we are using IKEv2 INFORMATIONAL exchanges\
    \ to send return\n   routability checks.  On the other hand, return routability\
    \ checks can\n   only fail permanently if there was an attack by the other end;\
    \ thus,\n   tearing down the IKE SA is a suitable action in that case.\n   There\
    \ are some cases, where the return routability check temporarily\n   fails, that\
    \ need to be considered here.  In the first case, there is\n   no attacker, but\
    \ the selected address pair stops working immediately\n   after the address update,\
    \ before the return routability check.\n   What happens is that the initiator\
    \ performs the normal address\n   update; it succeeds, and then the responder\
    \ starts a return\n   routability check.  If the address pair has broken down\
    \ before that,\n   the responder will never get back the reply to the return routability\n\
    \   check.  The responder might still be using the old IP address pair,\n   which\
    \ could still work.\n   The initiator might be still seeing traffic from the responder,\
    \ but\n   using the old address pair.  The initiator should detect that this\n\
    \   traffic is not using the latest address pair, and after a while it\n   should\
    \ start dead peer detection on the current address pair.  If\n   that fails, then\
    \ it should find a new working address pair and update\n   addresses to that.\
    \  The responder should notice that the address pair\n   was updated after the\
    \ return routability check was started and change\n   the ongoing return routability\
    \ check to use the new address pair.\n   The result of that return routability\
    \ check needs to be discarded as\n   it cannot be trusted; the packets were retransmitted\
    \ to a different\n   IP address.  So normally the responder starts a new return\n\
    \   routability check afterward with the new address pair.\n   The second case\
    \ is where there is an attacker along the path\n   modifying the IP addresses.\
    \  The peers will detect this as NAT and\n   will enable NAT-T recovery of changes\
    \ in the NAT mappings.  If the\n   attacker is along the path long enough for\
    \ the return routability\n   check to succeed, then the normal recovery of changes\
    \ in the NAT\n   mappings will take care of the problem.  If the attacker disappears\n\
    \   before return routability check is finished, but after the update, we\n  \
    \ have a case similar to the last.  The only difference is that now the\n   dead\
    \ peer detection started by the initiator will succeed because the\n   responder\
    \ will reply to the addresses in the headers, not the current\n   address pair.\
    \  The initiator will then detect that the NAT mappings\n   are changed, and it\
    \ will fix the situation by doing an address\n   update.\n   The important thing\
    \ for both of these cases is that the initiator\n   needs to see that the responder\
    \ is both alive and synchronized with\n   initiator address pair updates.  That\
    \ is, it is not enough that the\n   responder is sending traffic to an initiator;\
    \ it must also be using\n   the correct IP addresses before the initiator can\
    \ believe it is alive\n   and synchronized.  From the implementation point of\
    \ view, this means\n   that the initiator must not consider packets having wrong\
    \ IP\n   addresses as packets that prove the other end is alive, i.e., they do\n\
    \   not reset the dead peer detection timers.\n"
- title: 5.5.3.  Suggested Approach
  contents:
  - "5.5.3.  Suggested Approach\n   The working group selected to use IKEv2 INFORMATIONAL\
    \ exchanges as a\n   return routability check, but included a random cookie to\
    \ prevent\n   redirection by an authenticated attacker.  Return routability checks\n\
    \   are performed by default before moving the traffic.  However, these\n   tests\
    \ are optional.  Nodes may also perform these tests upon their\n   own initiative\
    \ at other times.\n   It is worth noting that the return routability check in\
    \ MOBIKE is\n   different from Mobile IPv6 [RFC3775], which does not perform return\n\
    \   routability operations between the mobile node and its home agent at\n   all.\n"
- title: 5.6.  IPsec Tunnel or Transport Mode
  contents:
  - "5.6.  IPsec Tunnel or Transport Mode\n   The current MOBIKE design is focused\
    \ only on the VPN type usage and\n   tunnel mode.  Transport mode behavior would\
    \ also be useful and might\n   be discussed in future documents.\n"
- title: 6.  Protocol Details
  contents:
  - '6.  Protocol Details

    '
- title: 6.1.  Indicating Support for MOBIKE
  contents:
  - "6.1.  Indicating Support for MOBIKE\n   In order for MOBIKE to function, both\
    \ peers must implement the MOBIKE\n   extension of IKEv2.  If one of the peers\
    \ does not support MOBIKE,\n   then, whenever an IP address changes, IKEv2 will\
    \ have to be re-run in\n   order to create a new IKE SA and the respective IPsec\
    \ SAs.  In\n   MOBIKE, a peer needs to be confident that its address change messages\n\
    \   are understood by the other peer.  If these messages are not\n   understood,\
    \ it is possible that connectivity between the peers is\n   lost.\n   One way\
    \ to ensure that a peer receives feedback on whether its\n   messages are understood\
    \ by the other peer is to use IKEv2 messaging\n   for MOBIKE and to mark some\
    \ messages as \"critical\".  According to the\n   IKEv2 specification, either\
    \ such messages have to be understood by\n   the receiver, or an error message\
    \ has to be returned to the sender.\n   A second way to ensure receipt of the\
    \ above-mentioned feedback is by\n   using Vendor ID payloads that are exchanged\
    \ during the initial IKEv2\n   exchange.  These payloads would then indicate whether\
    \ or not a given\n   peer supports the MOBIKE protocol.\n   A third approach would\
    \ use the Notify payload to indicate support of\n   MOBIKE extension.  Such Notify\
    \ payloads are also used for indicating\n   NAT traversal support (via NAT_DETECTION_SOURCE_IP\
    \ and\n   NAT_DETECTION_DESTINATION_IP payloads).\n   Both a Vendor ID and a Notify\
    \ payload may be used to indicate the\n   support of certain extensions.\n   Note\
    \ that a MOBIKE peer could also attempt to execute MOBIKE\n   opportunistically\
    \ with the critical bit set when an address change\n   has occurred.  The drawback\
    \ of this approach is, however, that an\n   unnecessary message exchange is introduced.\n\
    \   Although Vendor ID payloads and Notify payloads are technically\n   equivalent,\
    \ Notify payloads are already used in IKEv2 as a capability\n   negotiation mechanism.\
    \  Hence, Notify payloads are used in MOBIKE to\n   indicate support of MOBIKE\
    \ protocol.\n   Also, as the information of the support of MOBIKE is not needed\n\
    \   during the IKE_SA_INIT exchange, the indication of the support is\n   done\
    \ inside the IKE_AUTH exchange.  The reason for this is the need\n   to keep the\
    \ IKE_SA_INIT messages as small as possible so that they do\n   not get fragmented.\
    \  IKEv2 allows that the responder can do stateless\n   processing of the first\
    \ IKE_SA_INIT packet and request a cookie from\n   the other end if it is under\
    \ attack.  To mandate the responder to be\n   able to reassemble initial IKE_SA_INIT\
    \ packets would not allow fully\n   stateless processing of the initial IKE_SA_INIT\
    \ packets.\n"
- title: 6.2.  Path Testing and Window size
  contents:
  - "6.2.  Path Testing and Window size\n   As IKEv2 has a window of outgoing messages,\
    \ and the sender is not\n   allowed to violate that window (meaning that if the\
    \ window is full,\n   then the sender cannot send packets), it can cause some\
    \ complications\n   to path testing.  Another complication created by IKEv2 is\
    \ that once\n   the message is created and sent to the other end, it cannot be\n\
    \   modified in its future retransmissions.  This makes it impossible to\n   know\
    \ what packet actually reached the other end first.  We cannot use\n   IP headers\
    \ to find out which packet reached the other end first\n   because if the responder\
    \ gets retransmissions of the packet it has\n   already processed and replied\
    \ to (and those replies might have been\n   lost due unidirectional address pair),\
    \ it will retransmit the\n   previous reply using the new address pair of the\
    \ request.  Because of\n   this, it might be possible that the responder has already\
    \ used the IP\n   address information from the header of the previous packet,\
    \ and the\n   reply packet ending up at the initiator has a different address\
    \ pair.\n   Another complication comes from NAT-T.  The current IKEv2 document\n\
    \   says that if NAT-T is enabled, the node not behind NAT SHOULD detect\n   if\
    \ the IP address changes in the incoming authenticated packets and\n   update\
    \ the remote peers' addresses accordingly.  This works fine with\n   NAT-T, but\
    \ it causes some complications in MOBIKE, as MOBIKE needs\n   the ability to probe\
    \ other address pairs without breaking the old\n   one.\n   One approach to fix\
    \ this would be to add a completely new protocol\n   that is outside the IKE SA\
    \ message id limitations (window code),\n   outside identical retransmission requirements,\
    \ and outside the\n   dynamic address updating of NAT-T.\n   Another approach\
    \ is to make the protocol so that it does not violate\n   window restrictions\
    \ and does not require changing the packet on\n   retransmissions, and change\
    \ the dynamic address updating of NAT-T to\n   \"MUST NOT\" for IKE SA packets\
    \ if MOBIKE is used.  In order not to\n   violate window restrictions, the addresses\
    \ of the currently ongoing\n   exchange need to be changed to test different paths.\
    \  In order not to\n   require that the packet be changed after it is first sent\
    \ requires\n   that the protocol restart from the beginning in case the packet\
    \ was\n   retransmitted to different addresses (because the sender does not\n\
    \   know which packet the responder got first, i.e., which IP addresses\n   it\
    \ used).\n   The working group decided to use normal IKEv2 exchanges for path\n\
    \   testing and decided to change the dynamic address updating of NAT-T\n   to\
    \ MUST NOT for IKE SA packets; a new protocol outside of IKEv2 was\n   not adopted.\n"
- title: 6.3.  Message Presentation
  contents:
  - "6.3.  Message Presentation\n   The IP address change notifications can be sent\
    \ either via an\n   informational exchange already specified in IKEv2, or via\
    \ a MOBIKE-\n   specific message exchange.  Using an informational exchange has\
    \ the\n   main advantage that it is already specified in the IKEv2 protocol and\n\
    \   implementations can already incorporate the functionality.\n   Another question\
    \ is the format of the address update notifications.\n   The address update notifications\
    \ can include multiple addresses, of\n   which some may be IPv4 and some IPv6\
    \ addresses.  The number of\n   addresses is most likely going to be limited in\
    \ typical environments\n   (with less than 10 addresses).  The format may need\
    \ to indicate a\n   preference value for each address.  The format could either\
    \ contain a\n   preference number that determines the relative order of the addresses\n\
    \   or could simply be an ordered list of IP addresses.  If using\n   preference\
    \ numbers, then two addresses can have the same preference\n   value; an ordered\
    \ list avoids this situation.\n   Load balancing is currently outside the scope\
    \ of MOBIKE; however,\n   future work might include support for it.  The selected\
    \ format needs\n   to be flexible enough to include additional information in\
    \ future\n   versions of the protocol (e.g., to enable load balancing).  This\
    \ may\n   be realized with an reserved field, which can later be used to store\n\
    \   additional information.  As other information may arise that may have\n  \
    \ to be tied to an address in the future, a reserved field seems like a\n   prudent\
    \ design in any case.\n   There are two basic formats that place IP address lists\
    \ into a\n   message.  One includes each IP address as separate payload (where\
    \ the\n   payload order indicates the preference order, or the payload itself\n\
    \   might include the preference number).  Alternatively, we can put the\n   IP\
    \ address list as one payload to the exchange, and that one payload\n   will then\
    \ have an internal format that includes the list of IP\n   addresses.\n   Having\
    \ multiple payloads, each one carrying one IP address, makes the\n   protocol\
    \ probably easier to parse, as we can already use the normal\n   IKEv2 payload\
    \ parsing procedures.  It also offers an easy way for the\n   extensions, as the\
    \ payload probably contains only the type of the IP\n   address (or the type is\
    \ encoded to the payload type), and the IP\n   address itself.  As each payload\
    \ already has a length field\n   associated to it, we can detect if there is any\
    \ extra data after the\n   IP address.  Some implementations might have problems\
    \ parsing more\n   than a certain number of IKEv2 payloads, but if the sender\
    \ sends them\n   in the most preferred first, the receiver can only use the first\n\
    \   addresses it was willing to parse.\n   Having all IP addresses in one big\
    \ MOBIKE-specified internal format\n   provides more compact encoding and keeps\
    \ the MOBIKE implementation\n   more concentrated to one module.\n   Another choice\
    \ is which type of payloads to use.  IKEv2 already\n   specifies a Notify payload.\
    \  It includes some extra fields (SPI size,\n   SPI, protocol, etc.), which gives\
    \ 4 bytes of the extra overhead, and\n   there is the notification data field,\
    \ which could include the\n   MOBIKE-specific data.\n   Another option would be\
    \ to have a custom payload type, which would\n   then include the information\
    \ needed for the MOBIKE protocol.\n   The working group decided to use IKEv2 Notify\
    \ payloads, and put only\n   one data item per notify.  There will be one Notify\
    \ payload for each\n   item to be sent.\n"
- title: 6.4.  Updating Address Set
  contents:
  - "6.4.  Updating Address Set\n   Because the initiator decides all address updates,\
    \ the initiator\n   needs to know all the addresses used by the responder.  The\
    \ responder\n   also needs that list in case it happens to move to an address\
    \ not\n   known by the initiator, and it needs to send an address update\n   notification\
    \ to the initiator.  It might need to try different\n   addresses for the initiator.\n\
    \   MOBIKE could send the whole peer address list every time any of the\n   IP\
    \ addresses change (addresses are added or removed, the order\n   changes, or\
    \ the preferred address is updated) or an incremental\n   update.  Sending incremental\
    \ updates provides more compact packets\n   (meaning we can support more IP addresses),\
    \ but on the other hand\n   this approach has more problems in the synchronization\
    \ and packet\n   reordering cases.  That is, incremental updates must be processed\
    \ in\n   order, but for full updates we can simply use the most recent one and\n\
    \   ignore old ones, even if they arrive after the most recent one (IKEv2\n  \
    \ packets have a message ID that is incremented for each packet; thus,\n   it\
    \ is easy to know the sending order).\n   The working group decided to use a protocol\
    \ format where both ends\n   send a full list of their addresses to the other\
    \ end, and that list\n   overwrites the previous list.  To support NAT-T, the\
    \ IP addresses of\n   the received packet are considered as one address of the\
    \ peer, even\n   when they are not present in the list.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   As all the packets are already authenticated\
    \ by IKEv2, there is no\n   risk that any attackers would undetectedly modify\
    \ the contents of the\n   packets.  The IP addresses in the IP header of the packets\
    \ are not\n   authenticated; thus, the protocol defined must take care that they\n\
    \   are only used as an indication that something might be different, and\n  \
    \ that they do not cause any direct actions, except when doing NAT\n   traversal.\n\
    \   An attacker can also spoof ICMP error messages in an effort to\n   confuse\
    \ the peers about which addresses are not working.  At worst,\n   this causes\
    \ denial of service and/or the use of non-preferred\n   addresses.\n   One type\
    \ of attack that needs to be taken care of in the MOBIKE\n   protocol is the bombing\
    \ attack type.  See [RFC4225] and [Aur02] for\n   more information about flooding\
    \ attacks.\n   See the security considerations section of [RFC4555] for more\n\
    \   information about security considerations of the actual protocol.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   This document is the result of discussions in the MOBIKE\
    \ working\n   group.  The authors would like to thank Jari Arkko, Pasi Eronen,\n\
    \   Francis Dupont, Mohan Parthasarathy, Paul Hoffman, Bill Sommerfeld,\n   James\
    \ Kempf, Vijay Devarapalli, Atul Sharma, Bora Akyol, Joe Touch,\n   Udo Schilcher,\
    \ Tom Henderson, Andreas Pashalidis, and Maureen\n   Stillman for their input.\n\
    \   We would like to particularly thank Pasi Eronen for tracking open\n   issues\
    \ on the MOBIKE mailing list.  He helped us make good progress\n   on the document.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative references
  contents:
  - "9.1.  Normative references\n   [RFC4301]    Kent, S. and K. Seo, \"Security Architecture\
    \ for the\n                Internet Protocol\", RFC 4301, December 2005.\n   [RFC4306]\
    \    Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\",\n              \
    \  RFC 4306, December 2005.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [Aur02]      Aura, T., Roe, M., and J. Arkko,\
    \ \"Security of Internet\n                Location Management\", In Proc. 18th\
    \ Annual Computer\n                Security Applications Conference, pages 78-87,\
    \ Las\n                Vegas, NV USA, December 2002.\n   [RFC2367]    McDonald,\
    \ D., Metz, C., and B. Phan, \"PF_KEY Key\n                Management API, Version\
    \ 2\", RFC 2367, July 1998.\n   [RFC2401]    Kent, S. and R. Atkinson, \"Security\
    \ Architecture for the\n                Internet Protocol\", RFC 2401, November\
    \ 1998.\n   [RFC2409]    Harkins, D. and D. Carrel, \"The Internet Key Exchange\n\
    \                (IKE)\", RFC 2409, November 1998.\n   [RFC2461]    Narten, T.,\
    \ Nordmark, E., and W. Simpson, \"Neighbor\n                Discovery for IP Version\
    \ 6 (IPv6)\", RFC 2461,\n                December 1998.\n   [RFC2462]    Thomson,\
    \ S. and T. Narten, \"IPv6 Stateless Address\n                Autoconfiguration\"\
    , RFC 2462, December 1998.\n   [RFC2960]    Stewart, R., Xie, Q., Morneault, K.,\
    \ Sharp, C.,\n                Schwarzbauer, H., Taylor, T., Rytina, I., Kalla,\
    \ M.,\n                Zhang, L., and V. Paxson, \"Stream Control Transmission\n\
    \                Protocol\", RFC 2960, October 2000.\n   [RFC3303]    Srisuresh,\
    \ P., Kuthan, J., Rosenberg, J., Molitor, A.,\n                and A. Rayhan,\
    \ \"Middlebox communication architecture and\n                framework\", RFC\
    \ 3303, August 2002.\n   [RFC3424]    Daigle, L. and IAB, \"IAB Considerations\
    \ for UNilateral\n                Self-Address Fixing (UNSAF) Across Network Address\n\
    \                Translation\", RFC 3424, November 2002.\n   [RFC3554]    Bellovin,\
    \ S., Ioannidis, J., Keromytis, A., and R.\n                Stewart, \"On the\
    \ Use of Stream Control Transmission\n                Protocol (SCTP) with IPsec\"\
    , RFC 3554, July 2003.\n   [RFC3753]    Manner, J. and M. Kojo, \"Mobility Related\
    \ Terminology\",\n                RFC 3753, June 2004.\n   [RFC3775]    Johnson,\
    \ D., Perkins, C., and J. Arkko, \"Mobility\n                Support in IPv6\"\
    , RFC 3775, June 2004.\n   [RFC4193]    Hinden, R. and B. Haberman, \"Unique Local\
    \ IPv6 Unicast\n                Addresses\", RFC 4193, October 2005.\n   [RFC4225]\
    \    Nikander, P., Arkko, J., Aura, T., Montenegro, G., and\n                E.\
    \ Nordmark, \"Mobile IP Version 6 Route Optimization\n                Security\
    \ Design Background\", RFC 4225, December 2005.\n   [RFC4429]    Moore, N., \"\
    Optimistic Duplicate Address Detection (DAD)\n                for IPv6\", RFC\
    \ 4429, April 2006.\n   [RFC4555]    Eronen, P., \"IKEv2 Mobility and Multihoming\
    \ Protocol\n                (MOBIKE)\", RFC 4555, June 2006.\n   [WIP-Ark06] \
    \ Arkko, J. and I. Beijnum, \"Failure Detection and Locator\n                Pair\
    \ Exploration Protocol for IPv6 Multihoming\", Work in\n                Progress,\
    \ June 2006.\n   [WIP-Cro04]  Crocker, D., \"Framework for Common Endpoint Locator\n\
    \                Pools\", Work in Progress, February 2004.\n   [WIP-Nik06]  Nikander,\
    \ P., \"End-Host Mobility and Multihoming with\n                the Host Identity\
    \ Protocol\", Work in Progress,\n                June 2006.\n   [WIP-Ste06]  Stewart,\
    \ R., Ramalho, M., Xie, Q., Tuexen, M., and P.\n                Conrad, \"Stream\
    \ Control Transmission Protocol (SCTP)\n                Dynamic Address Reconfiguration\"\
    , Work in Progress,\n                June 2006.\n   [WIP-Sti06]  Stiemerling,\
    \ M., Tschofenig, H., Aoun, C., and E.\n                Davies, \"NAT/Firewall\
    \ NSIS Signaling Layer Protocol\n                (NSLP)\", Work in Progress, June\
    \ 2006.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tero Kivinen\n   Safenet, Inc.\n   Fredrikinkatu 47\n\
    \   HELSINKI  FI-00100\n   FI\n   EMail: kivinen@safenet-inc.com\n   Hannes Tschofenig\n\
    \   Siemens\n   Otto-Hahn-Ring 6\n   Munich, Bavaria  81739\n   Germany\n   EMail:\
    \ Hannes.Tschofenig@siemens.com\n   URI:   http://www.tschofenig.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
