- title: __initial_text__
  contents:
  - '                IPv6 Stateless Address Autoconfiguration

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the steps a host takes in deciding how to\n\
    \   autoconfigure its interfaces in IP version 6. The autoconfiguration\n   process\
    \ includes creating a link-local address and verifying its\n   uniqueness on a\
    \ link, determining what information should be\n   autoconfigured (addresses,\
    \ other information, or both), and in the\n   case of addresses, whether they\
    \ should be obtained through the\n   stateless mechanism, the stateful mechanism,\
    \ or both.  This document\n   defines the process for generating a link-local\
    \ address, the process\n   for generating site-local and global addresses via\
    \ stateless address\n   autoconfiguration, and the Duplicate Address Detection\
    \ procedure. The\n   details of autoconfiguration using the stateful protocol\
    \ are\n   specified elsewhere.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n         5.4.4.  Receiving Neighbor Advertisement Messages......\
    \   16\n         5.4.5.  When Duplicate Address Detection Fails.........   16\n\
    \      5.5.  Creation of Global and Site-Local Addresses.........   17\n     \
    \    5.5.1.  Soliciting Router Advertisements...............   17\n         5.5.2.\
    \  Absence of Router Advertisements...............   17\n         5.5.3.  Router\
    \ Advertisement Processing................   17\n         5.5.4.  Address Lifetime\
    \ Expiry........................   19\n      5.6.  Configuration Consistency...........................\
    \   19\n   SECURITY CONSIDERATIONS......................................   19\n\
    \   REFERENCES...................................................   20\n   AUTHORS'\
    \ ADDRESSES...........................................   21\n   APPENDIX: LOOPBACK\
    \ SUPPRESSION & DUPLICATE ADDRESS DETECTION.   22\n"
- title: 1.  INTRODUCTION
  contents:
  - "1.  INTRODUCTION\n   This document specifies the steps a host takes in deciding\
    \ how to\n   autoconfigure its interfaces in IP version 6. The autoconfiguration\n\
    \   process includes creating a link-local address and verifying its\n   uniqueness\
    \ on a link, determining what information should be\n   autoconfigured (addresses,\
    \ other information, or both), and in the\n   case of addresses, whether they\
    \ should be obtained through the\n   stateless mechanism, the stateful mechanism,\
    \ or both.  This document\n   defines the process for generating a link-local\
    \ address, the process\n   for generating site-local and global addresses via\
    \ stateless address\n   autoconfiguration, and the Duplicate Address Detection\
    \ procedure. The\n   details of autoconfiguration using the stateful protocol\
    \ are\n   specified elsewhere.\n   IPv6 defines both a stateful and stateless\
    \ address autoconfiguration\n   mechanism. Stateless autoconfiguration requires\
    \ no manual\n   configuration of hosts, minimal (if any) configuration of routers,\n\
    \   and no additional servers.  The stateless mechanism allows a host to\n   generate\
    \ its own addresses using a combination of locally available\n   information and\
    \ information advertised by routers. Routers advertise\n   prefixes that identify\
    \ the subnet(s) associated with a link, while\n   hosts generate an \"interface\
    \ token\" that uniquely identifies an\n   interface on a subnet. An address is\
    \ formed by combining the two. In\n   the absence of routers, a host can only\
    \ generate link-local\n   addresses. However, link-local addresses are sufficient\
    \ for allowing\n   communication among nodes attached to the same link.\n   In\
    \ the stateful autoconfiguration model, hosts obtain interface\n   addresses and/or\
    \ configuration information and parameters from a\n   server.  Servers maintain\
    \ a database that keeps track of which\n   addresses have been assigned to which\
    \ hosts. The stateful\n   autoconfiguration protocol allows hosts to obtain addresses,\
    \ other\n   configuration information or both from a server.  Stateless and\n\
    \   stateful autoconfiguration complement each other. For example, a host\n  \
    \ can use stateless autoconfiguration to configure its own addresses,\n   but\
    \ use stateful autoconfiguration to obtain other information.\n   Stateful autoconfiguration\
    \ is described in [DHCPv6].\n   The stateless approach is used when a site is\
    \ not particularly\n   concerned with the exact addresses hosts use, so long as\
    \ they are\n   unique and properly routable. The stateful approach is used when\
    \ a\n   site requires tighter control over exact address assignments.  Both\n\
    \   stateful and stateless address autoconfiguration may be used\n   simultaneously.\
    \  The site administrator specifies which type of\n   autoconfiguration to use\
    \ through the setting of appropriate fields in\n   Router Advertisement messages\
    \ [DISCOVERY].\n   IPv6 addresses are leased to an interface for a fixed (possibly\n\
    \   infinite) length of time. Each address has an associated lifetime\n   that\
    \ indicates how long the address is bound to an interface. When a\n   lifetime\
    \ expires, the binding (and address) become invalid and the\n   address may be\
    \ reassigned to another interface elsewhere in the\n   Internet. To handle the\
    \ expiration of address bindings gracefully, an\n   address goes through two distinct\
    \ phases while assigned to an\n   interface. Initially, an address is \"preferred\"\
    , meaning that its use\n   in arbitrary communication is unrestricted. Later,\
    \ an address becomes\n   \"deprecated\" in anticipation that its current interface\
    \ binding will\n   become invalid. While in a deprecated state, the use of an\
    \ address is\n   discouraged, but not strictly forbidden.  New communication (e.g.,\n\
    \   the opening of a new TCP connection) should use a preferred address\n   when\
    \ possible.  A deprecated address should be used only by\n   applications that\
    \ have been using it and would have difficulty\n   switching to another address\
    \ without a service disruption.\n   To insure that all configured addresses are\
    \ likely to be unique on a\n   given link, nodes run a \"duplicate address detection\"\
    \ algorithm on\n   addresses before assigning them to an interface.  The Duplicate\n\
    \   Address Detection algorithm is performed on all addresses,\n   independent\
    \ of whether they are obtained via stateless or stateful\n   autoconfiguration.\
    \  This document defines the Duplicate Address\n   Detection algorithm.\n   The\
    \ autoconfiguration process specified in this document applies only\n   to hosts\
    \ and not routers. Since host autoconfiguration uses\n   information advertised\
    \ by routers, routers will need to be configured\n   by some other means. However,\
    \ it is expected that routers will\n   generate link-local addresses using the\
    \ mechanism described in this\n   document. In addition, routers are expected\
    \ to successfully pass the\n   Duplicate Address Detection procedure described\
    \ in this document on\n   all addresses prior to assigning them to an interface.\n\
    \   Section 2 provides definitions for terminology used throughout this\n   document.\
    \ Section 3 describes the design goals that lead to the\n   current autoconfiguration\
    \ procedure. Section 4 provides an overview\n   of the protocol, while Section\
    \ 5 describes the protocol in detail.\n"
- title: 2.  TERMINOLOGY
  contents:
  - "2.  TERMINOLOGY\n   IP          - Internet Protocol Version 6.  The terms IPv4\
    \ and IPv6\n                 are used only in contexts where necessary to avoid\n\
    \                 ambiguity.\n   node        - a device that implements IP.\n\
    \   router      - a node that forwards IP packets not explicitly\n           \
    \      addressed to itself.\n   host        - any node that is not a router.\n\
    \   upper layer - a protocol layer immediately above IP.  Examples are\n     \
    \            transport protocols such as TCP and UDP, control\n              \
    \   protocols such as ICMP, routing protocols such as OSPF,\n                \
    \ and internet or lower-layer protocols being \"tunneled\"\n                 over\
    \ (i.e., encapsulated in) IP such as IPX, AppleTalk,\n                 or IP itself.\n\
    \   link        - a communication facility or medium over which nodes can\n  \
    \               communicate at the link layer, i.e., the layer\n             \
    \    immediately below IP.  Examples are Ethernets (simple\n                 or\
    \ bridged); PPP links; X.25, Frame Relay, or ATM\n                 networks; and\
    \ internet (or higher) layer \"tunnels\",\n                 such as tunnels over\
    \ IPv4 or IPv6 itself.\n   interface   - a node's attachment to a link.\n   packet\
    \      - an IP header plus payload.\n   address     - an IP-layer identifier for\
    \ an interface or a set of\n                 interfaces.\n   unicast address\n\
    \               - an identifier for a single interface. A packet sent to\n   \
    \              a unicast address is delivered to the interface\n             \
    \    identified by that address.\n   multicast address\n               - an identifier\
    \ for a set of interfaces (typically\n                 belonging to different\
    \ nodes). A packet sent to a\n                 multicast address is delivered\
    \ to all interfaces\n                 identified by that address.\n   anycast\
    \ address\n               - an identifier for a set of interfaces (typically\n\
    \                 belonging to different nodes).  A packet sent to an\n      \
    \           anycast address is delivered to one of the interfaces\n          \
    \       identified by that address (the \"nearest\" one,\n                 according\
    \ to the routing protocol's measure of\n                 distance).  See [ADDR-ARCH].\n\
    \   solicited-node multicast address\n               - a multicast address to\
    \ which Neighbor Solicitation\n                 messages are sent. The algorithm\
    \ for computing the\n                 address is given in [DISCOVERY].\n   link-layer\
    \ address\n               - a link-layer identifier for an interface.  Examples\n\
    \                 include IEEE 802 addresses for Ethernet links and E.164\n  \
    \               addresses for ISDN links.\n   link-local address\n           \
    \    - an address having link-only scope that can be used to\n               \
    \  reach neighboring nodes attached to the same link.  All\n                 interfaces\
    \ have a link-local unicast address.\n   site-local address\n               -\
    \ an address having scope that is limited to the local\n                 site.\n\
    \   global address\n               - an address with unlimited scope.\n   communication\n\
    \               - any packet exchange among nodes that requires that the\n   \
    \              address of each node used in the exchange remain the\n        \
    \         same for the duration of the packet exchange. Examples\n           \
    \      are a TCP connection or a UDP request-response.\n   tentative address\n\
    \               - an address whose uniqueness on a link is being\n           \
    \      verified, prior to its assignment to an interface.  A\n               \
    \  tentative address is not considered assigned to an\n                 interface\
    \ in the usual sense. An interface discards\n                 received packets\
    \ addressed to a tentative address, but\n                 accepts Neighbor Discovery\
    \ packets related to Duplicate\n                 Address Detection for the tentative\
    \ address.\n   preferred address\n               - an address assigned to an interface\
    \ whose use by upper\n                 layer protocols is unrestricted. Preferred\
    \ addresses\n                 may be used as the source (or destination) address\
    \ of\n                 packets sent from (or to) the interface.\n   deprecated\
    \ address\n               - An address assigned to an interface whose use is\n\
    \                 discouraged, but not forbidden.  A deprecated address\n    \
    \             should no longer be used as a source address in new\n          \
    \       communications, but packets sent to deprecated\n                 addresses\
    \ are delivered as expected.  A deprecated\n                 address may continue\
    \ to be used as a source address in\n                 communications where switching\
    \ to a preferred address\n                 causes hardship to a specific upper-layer\
    \ activity\n                 (e.g., an existing TCP connection).\n   valid address\n\
    \               - a preferred or deprecated address. A valid address may\n   \
    \              appear as the source or destination address of a\n            \
    \     packet, and the internet routing system is expected to\n               \
    \  deliver packets sent to a valid address.\n   invalid address\n            \
    \   - an address that is not assigned to any interface. A\n                 valid\
    \ address becomes invalid when its valid lifetime\n                 expires. \
    \ Invalid addresses should not appear as the\n                 destination or\
    \ source address of a packet. In the\n                 former case, the internet\
    \ routing system will be unable\n                 to deliver the packet, in the\
    \ later case the recipient\n                 of the packet will be unable to respond\
    \ to it.\n   preferred lifetime\n               - the length of time that a valid\
    \ address is preferred\n                 (i.e., the time until deprecation). When\
    \ the preferred\n                 lifetime expires, the address becomes deprecated.\n\
    \   valid lifetime\n               - the length of time an address remains in\
    \ the valid\n                 state (i.e., the time until invalidation). The valid\n\
    \                 lifetime must be greater then or equal to the preferred\n  \
    \               lifetime.  When the valid lifetime expires, the address\n    \
    \             becomes invalid.\n   interface token\n               - a link-dependent\
    \ identifier for an interface that is\n                 (at least) unique per\
    \ link. Stateless address\n                 autoconfiguration combines an interface\
    \ token with a\n                 prefix to form an address. From address\n   \
    \              autoconfiguration's perspective, an interface token is\n      \
    \           a bit string of known length.  The exact length of an\n          \
    \       interface token and the way it is created is defined in\n            \
    \     a separate link-type specific document that covers\n                 issues\
    \ related to the transmission of IP over a\n                 particular link type\
    \ (e.g., [IPv6-ETHER]).  In many\n                 cases, the token will be the\
    \ same as the interface's\n                 link-layer address.\n"
- title: 2.1.  Requirements
  contents:
  - "2.1.  Requirements\n   Throughout this document, the words that are used to define\
    \ the\n   significance of the particular requirements are capitalized.  These\n\
    \   words are:\n"
- title: MUST
  contents:
  - "MUST\n     This word or the adjective \"REQUIRED\" means that the item is an\n\
    \     absolute requirement of this specification.\n"
- title: MUST NOT
  contents:
  - "MUST NOT\n     This phrase means the item is an absolute prohibition of this\n\
    \     specification.\n"
- title: SHOULD
  contents:
  - "SHOULD\n     This word or the adjective \"RECOMMENDED\" means that there may\
    \ exist\n     valid reasons in particular circumstances to ignore this item, but\n\
    \     the full implications should be understood and the case carefully\n    \
    \ weighed before choosing a different course.\n"
- title: SHOULD NOT
  contents:
  - "SHOULD NOT\n     This phrase means that there may exist valid reasons in particular\n\
    \     circumstances when the listed behavior is acceptable or even\n     useful,\
    \ but the full implications should be understood and the case\n     carefully\
    \ weighed before implementing any behavior described with\n     this label.\n"
- title: MAY
  contents:
  - "MAY\n     This word or the adjective \"OPTIONAL\" means that this item is truly\n\
    \     optional.  One vendor may choose to include the item because a\n     particular\
    \ marketplace requires it or because it enhances the\n     product, for example,\
    \ another vendor may omit the same item.\n"
- title: 3.  DESIGN GOALS
  contents:
  - "3.  DESIGN GOALS\n   Stateless autoconfiguration is designed with the following\
    \ goals in\n   mind:\n   o Manual configuration of individual machines before\
    \ connecting them\n     to the network should not be required. Consequently, a\
    \ mechanism is\n     needed that allows a host to obtain or create unique addresses\
    \ for\n     each of its interfaces. Address autoconfiguration assumes that each\n\
    \     interface can provide a unique identifier for that interface (i.e.,\n  \
    \   an \"interface token\").  In the simplest case, an interface token\n     consists\
    \ of the interface's link-layer address. An interface token\n     can be combined\
    \ with a prefix to form an address.\n   o Small sites consisting of a set of machines\
    \ attached to a single\n     link should not require the presence of a stateful\
    \ server or router\n     as a prerequisite for communicating.  Plug-and-play communication\n\
    \     is achieved through the use of link-local addresses.  Link-local\n     addresses\
    \ have a well-known prefix that identifies the (single)\n     shared link to which\
    \ a set of nodes attach. A host forms a link-\n     local address by appending\
    \ its interface token to the link-local\n     prefix.\n   o A large site with\
    \ multiple networks and routers should not require\n     the presence of a stateful\
    \ address configuration server. In order\n     to generate site-local or global\
    \ addresses, hosts must determine\n     the prefixes that identify the subnets\
    \ to which they attach.\n     Routers generate periodic Router Advertisements\
    \ that include\n     options listing the set of active prefixes on a link.\n \
    \  o Address configuration should facilitate the graceful renumbering of\n   \
    \  a site's machines. For example, a site may wish to renumber all of\n     its\
    \ nodes when it switches to a new network service provider.\n     Renumbering\
    \ is achieved through the leasing of addresses to\n     interfaces and the assignment\
    \ of multiple addresses to the same\n     interface.  Lease lifetimes provide\
    \ the mechanism through which a\n     site phases out old prefixes.  The assignment\
    \ of multiple addresses\n     to an interface provides for a transition period\
    \ during which both\n     a new address and the one being phased out work simultaneously.\n\
    \   o System administrators need the ability to specify whether stateless\n  \
    \   autoconfiguration, stateful autoconfiguration, or both should be\n     used.\
    \  Router Advertisements include flags specifying which\n     mechanisms a host\
    \ should use.\n"
- title: 4.  PROTOCOL OVERVIEW
  contents:
  - "4.  PROTOCOL OVERVIEW\n   This section provides an overview of the typical steps\
    \ that take\n   place when an interface autoconfigures itself.  Autoconfiguration\
    \ is\n   performed only on multicast-capable links and begins when a\n   multicast-capable\
    \ interface is enabled, e.g., during system startup.\n   Nodes (both hosts and\
    \ routers) begin the autoconfiguration process by\n   generating a link-local\
    \ address for the interface. A link-local\n   address is formed by appending the\
    \ interface's token to the well-\n   known link-local prefix.\n   Before the link-local\
    \ address can be assigned to an interface and\n   used, however, a node must attempt\
    \ to verify that this \"tentative\"\n   address is not already in use by another\
    \ node on the link.\n   Specifically, it sends a Neighbor Solicitation message\
    \ containing the\n   tentative address as the target. If another node is already\
    \ using\n   that address, it will return a Neighbor Advertisement saying so. If\n\
    \   another node is also attempting to use the same address, it will send\n  \
    \ a Neighbor Solicitation for the target as well. The exact number of\n   times\
    \ the Neighbor Solicitation is (re)transmitted and the delay time\n   between\
    \ consecutive solicitations is link-specific and may be set by\n   system management.\n\
    \   If a node determines that its tentative link-local address is not\n   unique,\
    \ autoconfiguration stops and manual configuration of the\n   interface is required.\
    \  To simplify recovery in this case, it should\n   be possible for an administrator\
    \ to supply an alternate interface\n   token that overrides the default token\
    \ in such a way that the\n   autoconfiguration mechanism can then be applied using\
    \ the new\n   (presumably unique) interface token.  Alternatively, link-local\
    \ and\n   other addresses will need to be configured manually.\n   Once a node\
    \ ascertains that its tentative link-local address is\n   unique, it assigns it\
    \ to the interface. At this point, the node has\n   IP-level connectivity with\
    \ neighboring nodes.  The remaining\n   autoconfiguration steps are performed\
    \ only by hosts; the\n   (auto)configuration of routers is beyond the scope of\
    \ this document.\n   The next phase of autoconfiguration involves obtaining a\
    \ Router\n   Advertisement or determining that no routers are present. If routers\n\
    \   are present, they will send Router Advertisements that specify what\n   sort\
    \ of autoconfiguration a host should do.  If no routers are\n   present, stateful\
    \ autoconfiguration should be invoked.\n   Routers send Router Advertisements\
    \ periodically, but the delay\n   between successive advertisements will generally\
    \ be longer than a\n   host performing autoconfiguration will want to wait [DISCOVERY].\
    \  To\n   obtain an advertisement quickly, a host sends one or more Router\n \
    \  Solicitations to the all-routers multicast group.  Router\n   Advertisements\
    \ contain two flags indicating what type of stateful\n   autoconfiguration (if\
    \ any) should be performed. A \"managed address\n   configuration\" flag indicates\
    \ whether hosts should use stateful\n   autoconfiguration to obtain addresses.\
    \ An \"other stateful\n   configuration\" flag indicates whether hosts should\
    \ use stateful\n   autoconfiguration to obtain additional information (excluding\n\
    \   addresses).\n   Router Advertisements also contain zero or more Prefix Information\n\
    \   options that contain information used by stateless address\n   autoconfiguration\
    \ to generate site-local and global addresses.  It\n   should be noted that the\
    \ stateless and stateful address\n   autoconfiguration fields in Router Advertisements\
    \ are processed\n   independently of one another, and a host may use both stateful\
    \ and\n   stateless address autoconfiguration simultaneously.  One Prefix\n  \
    \ Information option field, the \"autonomous address-configuration\n   flag\"\
    , indicates whether or not the option even applies to stateless\n   autoconfiguration.\
    \  If it does, additional option fields contain a\n   subnet prefix together with\
    \ lifetime values indicating how long\n   addresses created from the prefix remain\
    \ preferred and valid.\n   Because routers generate Router Advertisements periodically,\
    \ hosts\n   will continually receive new advertisements. Hosts process the\n \
    \  information contained in each advertisement as described above,\n   adding\
    \ to and refreshing information received in previous\n   advertisements.\n   For\
    \ safety, all addresses must be tested for uniqueness prior to\n   their assignment\
    \ to an interface.  In the case of addresses created\n   through stateless autoconfig,\
    \ however, the uniqueness of an address\n   is determined primarily by the portion\
    \ of the address formed from an\n   interface token.  Thus, if a node has already\
    \ verified the uniqueness\n   of a link-local address, additional addresses created\
    \ from the same\n   interface token need not be tested individually. In contrast,\
    \ all\n   addresses obtained manually or via stateful address autoconfiguration\n\
    \   should be tested for uniqueness individually. To accommodate sites\n   that\
    \ believe the overhead of performing Duplicate Address Detection\n   outweighs\
    \ its benefits, the use of Duplicate Address Detection can be\n   disabled through\
    \ the administrative setting of a per-interface\n   configuration flag.\n   To\
    \ speed the autoconfiguration process, a host may generate its\n   link-local\
    \ address (and verify its uniqueness) in parallel with\n   waiting for a Router\
    \ Advertisement. Because a router may delay\n   responding to a Router Solicitation\
    \ for a few seconds, the total time\n   needed to complete autoconfiguration can\
    \ be significantly longer if\n   the two steps are done serially.\n"
- title: 4.1.  Site Renumbering
  contents:
  - "4.1.  Site Renumbering\n   Address leasing facilitates site renumbering by providing\
    \ a mechanism\n   to time-out addresses assigned to interfaces in hosts.  At present,\n\
    \   upper layer protocols such as TCP provide no support for changing\n   end-point\
    \ addresses while a connection is open. If an end-point\n   address becomes invalid,\
    \ existing connections break and all\n   communication to the invalid address\
    \ fails.  Even when applications\n   use UDP as a transport protocol, addresses\
    \ must generally remain the\n   same during a packet exchange.\n   Dividing valid\
    \ addresses into preferred and deprecated categories\n   provides a way of indicating\
    \ to upper layers that a valid address may\n   become invalid shortly and that\
    \ future communication using the\n   address will fail, should the address's valid\
    \ lifetime expire before\n   communication ends.  To avoid this scenario, higher\
    \ layers should use\n   a preferred address (assuming one of sufficient scope\
    \ exists) to\n   increase the likelihood that an address will remain valid for\
    \ the\n   duration of the communication.  It is up to system administrators to\n\
    \   set appropriate prefix lifetimes in order to minimize the impact of\n   failed\
    \ communication when renumbering takes place.  The deprecation\n   period should\
    \ be long enough that most, if not all, communications\n   are using the new address\
    \ at the time an address becomes invalid.\n   The IP layer is expected to provide\
    \ a means for upper layers\n   (including applications) to select the most appropriate\
    \ source\n   address given a particular destination and possibly other\n   constraints.\
    \  An application may choose to select the source address\n   itself before starting\
    \ a new communication or may leave the address\n   unspecified, in which case\
    \ the upper networking layers will use the\n   mechanism provided by the IP layer\
    \ to choose a suitable address on\n   the application's behalf.\n   Detailed address\
    \ selection rules are beyond the scope of this\n   document.\n"
- title: 5.  PROTOCOL SPECIFICATION
  contents:
  - "5.  PROTOCOL SPECIFICATION\n   Autoconfiguration is performed on a per-interface\
    \ basis on\n   multicast-capable interfaces.  For multihomed hosts,\n   autoconfiguration\
    \ is performed independently on each interface.\n   Autoconfiguration applies\
    \ primarily to hosts, with two exceptions.\n   Routers are expected to generate\
    \ a link-local address using the\n   procedure outlined below.  In addition, routers\
    \ perform Duplicate\n   Address Detection on all addresses prior to assigning\
    \ them to an\n   interface.\n"
- title: 5.1.  Node Configuration Variables
  contents:
  - "5.1.  Node Configuration Variables\n   A node MUST allow the following autoconfiguration-related\
    \ variable to\n   be configured by system management for each multicast interface:\n\
    \     DupAddrDetectTransmits\n                    The number of consecutive Neighbor\
    \ Solicitation\n                    messages sent while performing Duplicate Address\n\
    \                    Detection on a tentative address. A value of zero\n     \
    \               indicates that Duplicate Address Detection is not\n          \
    \          performed on tentative addresses. A value of one\n                \
    \    indicates a single transmission with no follow up\n                    retransmissions.\n\
    \                    Default: 1, but may be overridden by a link-type\n      \
    \              specific value in the document that covers issues\n           \
    \         related to the transmission of IP over a particular\n              \
    \      link type (e.g., [IPv6-ETHER]).\n   Autoconfiguration also assumes the\
    \ presence of the variable\n   RetransTimer as defined in [DISCOVERY]. For autoconfiguration\n\
    \   purposes, RetransTimer specifies the delay between consecutive\n   Neighbor\
    \ Solicitation transmissions performed during Duplicate\n   Address Detection\
    \ (if DupAddrDetectTransmits is greater than 1), as\n   well as the time a node\
    \ waits  after sending the last Neighbor\n   Solicitation before ending the Duplicate\
    \ Address Detection process.\n"
- title: 5.2.  Autoconfiguration-Related Variables
  contents:
  - "5.2.  Autoconfiguration-Related Variables\n   A host maintains a number of data\
    \ structures and flags related to\n   autoconfiguration. In the following, we\
    \ present conceptual variables\n   and show how they are used to perform autoconfiguration.\
    \ The specific\n   variables are used for demonstration purposes only, and an\n\
    \   implementation is not required to have them, so long as its external\n   behavior\
    \ is consistent with that described in this document.\n   Beyond the formation\
    \ of a link-local address and using Duplicate\n   Address Detection, how routers\
    \ (auto)configure their interfaces is\n   beyond the scope of this document.\n\
    \   Hosts maintain the following variables on a per-interface basis:\n   ManagedFlag\
    \      Copied from the M flag field (i.e., the \"managed\n                   \
    \ address configuration\" flag) of the most recently\n                    received\
    \ Router Advertisement message. The flag\n                    indicates whether\
    \ or not addresses are to be\n                    configured using the stateful\
    \ autoconfiguration\n                    mechanism. It starts out in a FALSE state.\n\
    \   OtherConfigFlag  Copied from the O flag field (i.e., the \"other\n       \
    \             stateful configuration\" flag) of the most recently\n          \
    \          received Router Advertisement message.  The flag\n                \
    \    indicates whether or not information other than\n                    addresses\
    \ are to be obtained using the stateful\n                    autoconfiguration\
    \ mechanism. It starts out in a\n                    FALSE state.\n   A host also\
    \ maintains a list of addresses together with their\n   corresponding lifetimes.\
    \ The address list contains both\n   autoconfigured addresses and those configured\
    \ manually.\n"
- title: 5.3.  Creation of Link-Local Addresses
  contents:
  - "5.3.  Creation of Link-Local Addresses\n   A node forms a link-local address\
    \ whenever an interface becomes\n   enabled.  An interface may become enabled\
    \ after any of the following\n   events:\n   - The interface is initialized at\
    \ system startup time.\n   - The interface is reinitialized after a temporary\
    \ interface failure\n     or after being temporarily disabled by system management.\n\
    \   - The interface attaches to a link for the first time.\n   - The interface\
    \ becomes enabled by system management after having\n     been administratively\
    \ disabled.\n   A link-local address is formed by prepending the well-known link-\n\
    \   local prefix FE80::0 [ADDR-ARCH] (of appropriate length) to the\n   interface\
    \ token. If the interface token has a length of N bits, the\n   interface token\
    \ replaces the right-most N zero bits of the link-local\n   prefix.  If the interface\
    \ token is more than 118 bits in length,\n   autoconfiguration fails and manual\
    \ configuration is required.\n   A link-local address has an infinite preferred\
    \ and valid lifetime; it\n   is never timed out.\n"
- title: 5.4.  Duplicate Address Detection
  contents:
  - "5.4.  Duplicate Address Detection\n   Duplicate Address Detection MUST be performed\
    \ on unicast addresses\n   prior to assigning them to an interface whose DupAddrDetectTransmits\n\
    \   variable is greater than zero. Duplicate Address Detection takes\n   place\
    \ on all unicast addresses, regardless of whether they are\n   obtained through\
    \ stateful, stateless or manual configuration.\n   (Duplicate Address Detection\
    \ MUST NOT be performed on anycast\n   addresses.) Each individual unicast address\
    \ SHOULD be tested for\n   uniqueness. However, when stateless address autoconfiguration\
    \ is\n   used, address uniqueness is determined solely by the interface token,\n\
    \   assuming that subnet prefixes are assigned correctly (i.e., if all of\n  \
    \ an interface's addresses are generated from the same token, either\n   all addresses\
    \ or none of them will be duplicates). Thus, for a set of\n   addresses formed\
    \ from the same interface token, it is sufficient to\n   check that the link-local\
    \ address generated from the token is unique\n   on the link. In such cases, the\
    \ link-local address MUST be tested for\n   uniqueness before any of the other\
    \ addresses formed from the token\n   can be assigned to an interface.\n   The\
    \ procedure for detecting duplicate addresses uses Neighbor\n   Solicitation and\
    \ Advertisement messages as described below. If a\n   duplicate address is discovered\
    \ during the procedure, the address\n   cannot be assigned to the interface. If\
    \ the address is derived from\n   an interface token, a new token will need to\
    \ be assigned to the\n   interface, or all IP addresses for the interface will\
    \ need to be\n   manually configured.  Note that the method for detecting duplicates\n\
    \   is not completely reliable, and it is possible that duplicate\n   addresses\
    \ will still exist (e.g., if the link was partitioned while\n   Duplicate Address\
    \ Detection was performed).\n   An address on which the duplicate Address Detection\
    \ Procedure is\n   applied is said to be tentative until the procedure has completed\n\
    \   successfully.  A tentative address is not considered \"assigned to an\n  \
    \ interface\" in the traditional sense. That is, the interface must\n   accept\
    \ Neighbor Solicitation and Advertisement messages containing\n   the tentative\
    \ address in the Target Address field, but processes such\n   packets differently\
    \ from those whose Target Address matches an\n   address assigned to the interface.\
    \  Other packets addressed to the\n   tentative address should be silently discarded.\n\
    \   It should also be noted that Duplicate Address Detection must be\n   performed\
    \ prior to assigning an address to an interface in order to\n   prevent multiple\
    \ nodes from using the same address simultaneously.\n   If a node begins using\
    \ an address in parallel with Duplicate Address\n   Detection, and another node\
    \ is already using the address, the node\n   performing Duplicate Address Detection\
    \ will erroneously process\n   traffic intended for the other node, resulting\
    \ in such possible\n   negative consequences as the resetting of open TCP connections.\n\
    \   The following subsections describe specific tests a node performs to\n   verify\
    \ an address's uniqueness.  An address is considered unique if\n   none of the\
    \ tests indicate the presence of a duplicate address within\n   RetransTimer milliseconds\
    \ after having sent DupAddrDetectTransmits\n   Neighbor Solicitations. Once an\
    \ address is determined to be unique,\n   it may be assigned to an interface.\n"
- title: 5.4.1.  Message Validation
  contents:
  - "5.4.1.  Message Validation\n   A node MUST silently discard any Neighbor Solicitation\
    \ or\n   Advertisement message that does not pass the validity checks\n   specified\
    \ in [DISCOVERY].  A solicitation that passes these validity\n   checks is called\
    \ a valid solicitation or valid advertisement.\n"
- title: 5.4.2.  Sending Neighbor Solicitation Messages
  contents:
  - "5.4.2.  Sending Neighbor Solicitation Messages\n   Before sending a Neighbor\
    \ Solicitation, an interface MUST join the\n   all-nodes multicast address and\
    \ the solicited-node multicast address\n   of the tentative address.  The former\
    \ insures that the node receives\n   Neighbor Advertisements from other nodes\
    \ already using the address;\n   the latter insures that two nodes attempting\
    \ to use the same address\n   simultaneously detect each other's presence.\n \
    \  To check an address, a node sends DupAddrDetectTransmits Neighbor\n   Solicitations,\
    \ each separated by RetransTimer milliseconds. The\n   solicitation's Target Address\
    \ is set to the address being checked,\n   the IP source is set to the unspecified\
    \ address and the IP\n   destination is set to the solicited-node multicast address\
    \ of the\n   target address.\n   If the Neighbor Solicitation is the first message\
    \ to be sent from an\n   interface after interface (re)initialization, the node\
    \ should delay\n   sending the message by a random delay between 0 and\n   MAX_RTR_SOLICITATION_DELAY\
    \ as specified in [DISCOVERY].  This serves\n   to alleviate congestion when many\
    \ nodes start up on the link at the\n   same time, such as after a power failure,\
    \ and may help to avoid race\n   conditions when more than one node is trying\
    \ to solicit for the same\n   address at the same time. In order to improve the\
    \ robustness of the\n   Duplicate Address Detection algorithm, an interface MUST\
    \ receive and\n   process datagrams sent to the all-nodes multicast address or\n\
    \   solicited-node multicast address of the tentative address while\n   delaying\
    \ transmission of the initial Neighbor Solicitation.\n"
- title: 5.4.3.  Receiving Neighbor Solicitation Messages
  contents:
  - "5.4.3.  Receiving Neighbor Solicitation Messages\n   On receipt of a valid Neighbor\
    \ Solicitation message on an interface,\n   node behavior depends on whether the\
    \ target address is tentative or\n   not.  If the target address is not tentative\
    \ (i.e., it is assigned to\n   the receiving interface), the solicitation is processed\
    \ as described\n   in [DISCOVERY].  If the target address is tentative, and the\
    \ source\n   address is a unicast address, the solicitation's sender is performing\n\
    \   address resolution on the target; the solicitation should be silently\n  \
    \ ignored.  Otherwise, processing takes place as described below. In\n   all cases,\
    \ a node MUST NOT respond to a Neighbor Solicitation for a\n   tentative address.\n\
    \   If the source address of the Neighbor Solicitation is the unspecified\n  \
    \ address, the solicitation is from a node performing Duplicate Address\n   Detection.\
    \ If the solicitation is from another node, the tentative\n   address is a duplicate\
    \ and should not be used (by either node). If\n   the solicitation is from the\
    \ node itself (because the node loops back\n   multicast packets), the solicitation\
    \ does not indicate the presence\n   of a duplicate address.\n   Implementor's\
    \ Note: many interfaces provide a way for upper layers to\n   selectively enable\
    \ and disable the looping back of multicast packets.\n   The details of how such\
    \ a facility is implemented may prevent\n   Duplicate Address Detection from working\
    \ correctly.  See the Appendix\n   for further discussion.\n   The following tests\
    \ identify conditions under which a tentative\n   address is not unique:\n   -\
    \ If a Neighbor Solicitation for a tentative address is received\n     prior to\
    \ having sent one, the tentative address is a duplicate.\n     This condition\
    \ occurs when two nodes run Duplicate Address\n     Detection simultaneously,\
    \ but transmit initial solicitations at\n     different times (e.g., by selecting\
    \ different random delay values\n     before transmitting an initial solicitation).\n\
    \   - If the actual number of Neighbor Solicitations received exceeds the\n  \
    \   number expected based on the loopback semantics (e.g., the\n     interface\
    \ does not loopback packet, yet one or more solicitations\n     was received),\
    \ the tentative address is a duplicate. This condition\n     occurs when two nodes\
    \ run Duplicate Address Detection\n     simultaneously and transmit solicitations\
    \ at roughly the same time.\n"
- title: 5.4.4.  Receiving Neighbor Advertisement Messages
  contents:
  - "5.4.4.  Receiving Neighbor Advertisement Messages\n   On receipt of a valid Neighbor\
    \ Advertisement message on an interface,\n   node behavior depends on whether\
    \ the target address is tentative or\n   matches a unicast or anycast address\
    \ assigned to the interface.  If\n   the target address is assigned to the receiving\
    \ interface, the\n   solicitation is processed as described in [DISCOVERY]. If\
    \ the target\n   address is tentative, the tentative address is not unique.\n"
- title: 5.4.5.  When Duplicate Address Detection Fails
  contents:
  - "5.4.5.  When Duplicate Address Detection Fails\n   A tentative address that is\
    \ determined to be a duplicate as described\n   above, MUST NOT be assigned to\
    \ an interface and the node SHOULD log a\n   system management error.  If the\
    \ address is a link-local address\n   formed from an interface token, the interface\
    \ SHOULD be disabled.\n"
- title: 5.5.  Creation of Global and Site-Local Addresses
  contents:
  - "5.5.  Creation of Global and Site-Local Addresses\n   Global and site-local addresses\
    \ are formed by appending an interface\n   token to a prefix of appropriate length.\
    \ Prefixes are obtained from\n   Prefix Information options contained in Router\
    \ Advertisements.\n   Creation of global and site-local addresses and configuration\
    \ of\n   other parameters as described in this section SHOULD be locally\n   configurable.\
    \ However, the processing described below MUST be enabled\n   by default.\n"
- title: 5.5.1.  Soliciting Router Advertisements
  contents:
  - "5.5.1.  Soliciting Router Advertisements\n   Router Advertisements are sent periodically\
    \ to the all-nodes\n   multicast address. To obtain an advertisement quickly,\
    \ a host sends\n   out Router Solicitations as described in [DISCOVERY].\n"
- title: 5.5.2.  Absence of Router Advertisements
  contents:
  - "5.5.2.  Absence of Router Advertisements\n   If a link has no routers, a host\
    \ MUST attempt to use stateful\n   autoconfiguration to obtain addresses and other\
    \ configuration\n   information. An implementation MAY provide a way to disable\
    \ the\n   invocation of stateful autoconfiguration in this case, but the\n   default\
    \ SHOULD be enabled.  From the perspective of\n   autoconfiguration, a link has\
    \ no routers if no Router Advertisements\n   are received after having sent a\
    \ small number of Router Solicitations\n   as described in [DISCOVERY].\n"
- title: 5.5.3.  Router Advertisement Processing
  contents:
  - "5.5.3.  Router Advertisement Processing\n   On receipt of a valid Router Advertisement\
    \ (as defined in\n   [DISCOVERY]), a host copies the value of the advertisement's\
    \ M bit\n   into ManagedFlag.  If the value of ManagedFlag changes from FALSE\
    \ to\n   TRUE, the host should invoke the stateful address autoconfiguration\n\
    \   protocol, requesting address information.  If the value of the\n   ManagedFlag\
    \ changes from TRUE to FALSE, the host should terminate the\n   stateful address\
    \ autoconfiguration protocol (i.e., stop requesting\n   addresses and ignore subsequent\
    \ responses to in-progress\n   transactions). If the value of the flag stays unchanged,\
    \ no special\n   action takes place. In particular, a host MUST NOT reinvoke stateful\n\
    \   address configuration if it is already participating in the stateful\n   protocol\
    \ as a result of an earlier advertisement.\n   An advertisement's O flag field\
    \ is processed in an analogous manner.\n   A host copies the value of the O flag\
    \ into OtherConfigFlag. If the\n   value of OtherConfigFlag changes from FALSE\
    \ to TRUE, the host should\n   invoke the stateful autoconfiguration protocol,\
    \ requesting\n   information (excluding addresses).  If the value of the\n   OtherConfigFlag\
    \ changes from TRUE to FALSE, any activity related to\n   stateful autoconfiguration\
    \ for parameters other than addresses should\n   be halted. If the value of the\
    \ flag stays unchanged, no special\n   action takes place. In particular, a host\
    \ MUST NOT reinvoke stateful\n   configuration if it is already participating\
    \ in the stateful protocol\n   as a result of an earlier advertisement.\n   For\
    \ each Prefix-Information option in the Router Advertisement:\n a) If the Autonomous\
    \ flag is not set, silently ignore the Prefix\n    Information option.\n b) If\
    \ the prefix is the link-local prefix, silently ignore the Prefix\n    Information\
    \ option.\n c) If the preferred lifetime is greater than the valid lifetime,\n\
    \    silently ignore the Prefix Information option. A node MAY wish to\n    log\
    \ a system management error in this case.\n d) If the advertised prefix matches\
    \ the prefix of an autoconfigured\n    address (i.e., obtained via stateless or\
    \ stateful address\n    autoconfiguration) in the list of addresses associated\
    \ with the\n    interface, set the preferred timer to that of the option's preferred\n\
    \    lifetime, and set the valid lifetime to that of the option's valid\n    lifetime.\n\
    \ e) If the prefix advertised does not match the prefix of an address\n    already\
    \ in the list, then form an address (and add it to the list)\n    by appending\
    \ the interface token to the prefix as follows:\n    |            128 - N bits\
    \               |       N bits           |\n    +---------------------------------------+------------------------+\n\
    \    |            link prefix                |   interface token      |\n    +----------------------------------------------------------------+\n\
    \    If the sum of the prefix length and interface token length does not\n   \
    \ equal 128 bits, the Prefix Information option MUST be ignored. An\n    implementation\
    \ MAY wish to log a system management error in this\n    case. It is the responsibility\
    \ of the system administrator to insure\n    that the lengths of prefixes contained\
    \ in Router Advertisements are\n    consistent with the length of interface tokens\
    \ for that link type.\n    In those cases where a site requires the use of longer\
    \ prefixes than\n    can be accommodated by the interface token, stateful\n  \
    \  autoconfiguration can be used.\n    If an address is formed successfully, the\
    \ host adds it to the list\n    of addresses assigned to the interface, initializing\
    \ its preferred\n    and valid lifetime values from the Prefix Information option.\n"
- title: 5.5.4.  Address Lifetime Expiry
  contents:
  - "5.5.4.  Address Lifetime Expiry\n   A preferred address becomes deprecated when\
    \ its preferred lifetime\n   expires.  A deprecated address SHOULD continue to\
    \ be used as a source\n   address in existing communications, but SHOULD NOT be\
    \ used in new\n   communications if an alternate (non-deprecated) address is available\n\
    \   and has sufficient scope.  The IP layer MUST continue to accept\n   datagrams\
    \ destined to a deprecated address since a deprecated address\n   is still a valid\
    \ address for the interface. An implementation MAY\n   prevent any new communication\
    \ from using a deprecated address, but\n   system management MUST have the ability\
    \ to disable such a facility.\n   An address (and its association with an interface)\
    \ becomes invalid\n   when its valid lifetime expires.  An invalid address MUST\
    \ NOT be used\n   as a source address in outgoing communications and MUST NOT\
    \ be\n   recognized as a destination on a receiving interface.\n   Note that if\
    \ a Prefix Information option is received with a preferred\n   lifetime of zero,\
    \ any addresses generated from that prefix are\n   immediately deprecated. Similarly,\
    \ if both the advertised deprecated\n   and valid lifetimes are zero, any addresses\
    \ generated from that\n   prefix become invalid immediately.\n"
- title: 5.6.  Configuration Consistency
  contents:
  - "5.6.  Configuration Consistency\n   It is possible for hosts to obtain address\
    \ information using both\n   stateless and stateful protocols since both may be\
    \ enabled at the\n   same time.  It is also possible that the values of other\n\
    \   configuration parameters such as MTU size and hop limit will be\n   learned\
    \ from both Router Advertisements and the stateful\n   autoconfiguration protocol.\
    \  If the same configuration information is\n   provided by multiple sources,\
    \ the value of this information should be\n   consistent. However, it is not considered\
    \ a fatal error if\n   information received from multiple sources is inconsistent.\
    \ Hosts\n   accept the union of all information received via the stateless and\n\
    \   stateful protocols. If inconsistent information is learned from\n   different\
    \ sources, the most recently obtained values always have\n   precedence over information\
    \ learned earlier.\n"
- title: SECURITY CONSIDERATIONS
  contents:
  - "SECURITY CONSIDERATIONS\n   Stateless address autoconfiguration allows a host\
    \ to connect to a\n   network, configure an address and start communicating with\
    \ other\n   nodes without ever registering or authenticating itself with the\n\
    \   local site.  Although this allows unauthorized users to connect to\n   and\
    \ use a network, the threat is inherently present in the Internet\n   architecture.\
    \ Any node with a physical attachment to a network can\n   generate an address\
    \ (using a variety of ad hoc techniques) that\n   provides connectivity.\n   The\
    \ use of Duplicate Address Detection opens up the possibility of\n   denial of\
    \ service attacks. Any node can respond to Neighbor\n   Solicitations for a tentative\
    \ address, causing the other node to\n   reject the address as a duplicate. This\
    \ attack is similar to other\n   attacks involving the spoofing of Neighbor Discovery\
    \ messages and can\n   be addressed by requiring that Neighbor Discovery packets\
    \ be\n   authenticated [RFC1826].\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n   [RFC1826] Atkinson, R., \"IP Authentication Header\", RFC 1826,\
    \ August\n             1995.\n   [IPv6-ETHER] Crawford, M., \"A Method for the\
    \ Transmission of IPv6\n             Packets over Ethernet Networks\", RFC 1972,\
    \ August 1996.\n   [RFC1112] Deering, S., \"Host Extensions for IP Multicasting\"\
    , STD 5,\n             RFC 1112, August 1989.\n   [ADDR-ARCH] Hinden, R., and\
    \ S. Deering, \"Internet Protocol Version\n             (IPv6) Addressing Architecture\"\
    , RFC 1884, December 1995.\n   [DHCPv6]  Work in Progress.\n   [DISCOVERY] Narten,\
    \ T., Nordmark, E., and W. Simpson, \"Neighbor\n             Discovery for IP\
    \ Version 6 (IPv6)\", RFC 1970, August 1996.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank the members of both the\
    \ IPNG and\n   ADDRCONF working groups for their input. In particular, thanks\
    \ to Jim\n   Bound, Steve Deering, and Erik Nordmark.\n"
- title: AUTHORS' ADDRESSES
  contents:
  - "AUTHORS' ADDRESSES\n   Susan Thomson\n   Bellcore\n   445 South Street\n   Morristown,\
    \ NJ 07960\n   USA\n   Phone: +1 201-829-4514\n   EMail: set@thumper.bellcore.com\n\
    \   Thomas Narten\n   IBM Corporation\n   P.O. Box 12195\n   Research Triangle\
    \ Park, NC 27709-2195\n   USA\n   Phone: +1 919 254 7798\n   EMail: narten@vnet.ibm.com\n"
- title: 'APPENDIX: LOOPBACK SUPPRESSION & DUPLICATE ADDRESS DETECTION'
  contents:
  - "APPENDIX: LOOPBACK SUPPRESSION & DUPLICATE ADDRESS DETECTION\n   Determining\
    \ whether a received multicast solicitation was looped back\n   to the sender\
    \ or actually came from another node is implementation-\n   dependent.  A problematic\
    \ case occurs when two interfaces attached to\n   the same link happen to have\
    \ the same token and link-layer address,\n   and they both send out packets with\
    \ identical contents at roughly the\n   same time (e.g., Neighbor Solicitations\
    \ for a tentative address as\n   part of Duplicate Address Detection messages).\
    \  Although a receiver\n   will receive both packets, it cannot determine which\
    \ packet was\n   looped back and which packet came from the other node by simply\n\
    \   comparing packet contents (i.e., the contents are identical). In this\n  \
    \ particular case, it is not necessary to know precisely which packet\n   was\
    \ looped back and which was sent by another node; if one receives\n   more solicitations\
    \ than were sent, the tentative address is a\n   duplicate. However, the situation\
    \ may not always be this\n   straightforward.\n   The IPv4 multicast specification\
    \ [RFC1112] recommends that the\n   service interface provide a way for an upper-layer\
    \ protocol to\n   inhibit local delivery of packets sent to a multicast group\
    \ that the\n   sending host is a member of. Some applications know that there\
    \ will\n   be no other group members on the same host, and suppressing loopback\n\
    \   prevents them from having to receive (and discard) the packets they\n   themselves\
    \ send out.  A straightforward way to implement this\n   facility is to disable\
    \ loopback at the hardware level (if supported\n   by the hardware), with packets\
    \ looped back (if requested) by\n   software.  On interfaces in which the hardware\
    \ itself suppresses\n   loopbacks, a node running Duplicate Address Detection\
    \ simply counts\n   the number of Neighbor Solicitations received for a tentative\
    \ address\n   and compares them with the number expected. If there is a mismatch,\n\
    \   the tentative address is a duplicate.\n   In those cases where the hardware\
    \ cannot suppress loopbacks, however,\n   one possible software heuristic to filter\
    \ out unwanted loopbacks is\n   to discard any received packet whose link-layer\
    \ source address is the\n   same as the receiving interface's.  Unfortunately,\
    \ use of that\n   criteria also results in the discarding of all packets sent\
    \ by\n   another node using the same link-layer address. Duplicate Address\n \
    \  Detection will fail on interfaces that filter received packets in\n   this\
    \ manner:\n   o If a node performing Duplicate Address Detection discards received\n\
    \     packets having the same source link-layer address as the receiving\n   \
    \  interface, it will also discard packets from other nodes also using\n     the\
    \ same link-layer address, including Neighbor Advertisement and\n     Neighbor\
    \ Solicitation messages required to make Duplicate Address\n     Detection work\
    \ correctly.  This particular problem can be avoided\n     by temporarily disabling\
    \ the software suppression of loopbacks\n     while a node performs Duplicate\
    \ Address Detection.\n   o If a node that is already using a particular IP address\
    \ discards\n     received packets having the same link-layer source address as\
    \ the\n     interface, it will also discard Duplicate Address Detection-related\n\
    \     Neighbor Solicitation messages sent by another node also using the\n   \
    \  same link-layer address.  Consequently, Duplicate Address Detection\n     will\
    \ fail, and the other node will configure a non-unique address.\n     Since it\
    \ is generally impossible to know when another node is\n     performing Duplicate\
    \ Address Detection, this scenario can be\n     avoided only if software suppression\
    \ of loopback is permanently\n     disabled.\n   Thus, to perform Duplicate Address\
    \ Detection correctly in the case\n   where two interfaces are using the same\
    \ link-layer address, an\n   implementation must have a good understanding of\
    \ the interface's\n   multicast loopback semantics, and the interface cannot discard\n\
    \   received packets simply because the source link-layer address is the\n   same\
    \ as the interfaces.\n"
