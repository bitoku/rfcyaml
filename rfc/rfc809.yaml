- title: __initial_text__
  contents:
  - "                      UCL FACSIMILE SYSTEM\n                           Tawei\
    \ Chang\n     ABSTRACT:  This note describes the features  of\n              \
    \  the  computerised  facsimile  system\n                developed  in  the  \
    \ Department   of\n                Computer  Science at UCL.  First its\n    \
    \            functions  are  considered  and  the\n                related   \
    \ experimental   work   are\n                reported. Then the  disciplines \
    \ for\n                system    design    are   discussed.\n                Finally,\
    \ the implementation  of  the\n                system are described, while detailed\n\
    \                description are given as appendices.\n      NOTE: Figures 5 and\
    \ 6 may be obtained by sending a request to\n      Ann Westine at USC-Information\
    \ Sciences Institute, 4676 Admiralty\n      Way, Marina del Rey, California, 90291\
    \ (or WESTINE@ISIF) including\n      your name and postal mailing address.  Please\
    \ mention that you are\n      requesting figures 5 and 6 from RFC 809.\n     \
    \ OR: You can obtain these two figures online from the files\n          <NETINFO>RFC809a.FAX\
    \   and   <NETINFO>RFC809b.FAX\n                            Contents\n  1. INTRODUCTION...........................................1\n\
    \  2. SYSTEM FUNCTIONS.......................................2\n     2.1 Communication......................................4\n\
    \     2.2 Interworking with Other Equipment..................8\n        2.2.1\
    \ Facsimile machines............................8\n        2.2.2 Output Devices................................9\n\
    \     2.3 Image Enhancement..................................11\n     2.4 Image\
    \ Editing......................................15\n     2.5 Integration with Other\
    \ Data Types..................16\n  3. SYSTEM ARCHITECTURE....................................17\n\
    \     3.1 System Requirements................................17\n     3.2 Hierarchical\
    \ Model.................................19\n     3.3 Clean and Simple Interface.........................20\n\
    \        3.3.1 Principles....................................21\n        3.3.2\
    \ Synchronisation and Desynchronisation.........21\n        3.3.3 Data Transfer.................................22\n\
    \     3.4 Control and Organisation of the Tasks..............22\n        3.4.1\
    \ Command Language..............................23\n        3.4.2 Task Controller...............................23\n\
    \     3.5 Interface Routines.................................26\n        3.5.1\
    \ Sharable Control Structure....................26\n        3.5.2 Buffer Management.............................27\n\
    \  4. UCL FACSIMILE SYSTEM...................................28\n     4.1 Multi-Task\
    \ Structure...............................29\n     4.2 The Devices........................................29\n\
    \     4.3 The Networks.......................................30\n     4.4 File\
    \ System........................................31\n     4.5 Data Structure.....................................32\n\
    \     4.6 Data Conversion....................................34\n     4.7 Image\
    \ Manipulation.................................35\n     4.8 Data Transmission..................................39\n\
    \  5. CONCLUSION.............................................41\n     5.1 Summary............................................41\n\
    \     5.2 Problems...........................................42\n     5.3 Future\
    \ Study.......................................46\n     Appendix I:   Devices\n\
    \     Appendix II:  Task Controller and Task Processes\n     Appendix III: Utility\
    \ and Data Formats\n     1. INTRODUCTION\n       The object of a  facsimile  system\
    \  is  to  reproduce\n     faithfully  a document or image from one piece of paper\n\
    \     onto another piece of paper  sited  remotely  from  the\n     first  one.\
    \  Up  to  now,  the main method of facsimile\n     communication has been via\
    \ the telephone network.  Most\n     facsimile  machines permit neither the storage\
    \ of image\n     page nor their modification before  transmission.  With\n   \
    \  such  machines,  it is almost impossible to communicate\n     between different\
    \ makes of facsimile machines. In  this\n     respect,   facsimile   machines\
    \   fall   behind   other\n     electronic communication services.\n       Integration\
    \ of  a  facsimile  service  with  computer\n     communication  techniques  can\
    \ bring great improvements\n     in service. Not only is the reliability and \
    \ efficiency\n     improved   but,  more  important,  the  system  can  be\n \
    \    integrated with  other  forms  of  data  communication.\n     Moreover, the\
    \ computer enables the facsimile machine to\n     fit into a complete message\
    \ and information  processing\n     environment.   The  storage  facilities provided\
    \ by the\n     computer system make it possible to store large amounts\n     of\
    \  facsimile  data  and  retrieve  them  rapidly. Data\n     conversion allows\
    \ facsimile machines of different types\n     to   communicate  with  each  other.\
    \  Furthermore,  the\n     facsimile image is edited and/or  combined  with  other\n\
    \     forms  of  data,  such  as text, voice and graphics, to\n     construct\
    \ a multi-media message, which  can  be  widely\n     distributed over computer\
    \ networks.\n       In the Department  of  Computer  Science  at  UCL,  a\n  \
    \   computerised  facsimile  system  has  been developed in\n     order to fully\
    \ apply  computer  technology,  especially\n     communication,  to  the facsimile\
    \ field.  Some work has\n     been done to improve the facsimile service  in \
    \ several\n     areas.\n      (1) Adaptation of the facsimile machine for  use\
    \  with\n          computer networks.  This permits more reliable and\n      \
    \    accurate  document  transmission,   as   well   as\n          improving the\
    \ normal point-to-point transfers.\n      (2) Storage  of  facsimile  pages. \
    \ This  permits  the\n          queueing  of pages, so saving operator time. Also,\n\
    \          standard documents can  be  kept  permanently  and\n          transmitted\
    \ at any time.\n      (3) Interworking with other facsimile  machines.  This\n\
    \          permits  different  makes of facsimile machines to\n          exchange\
    \ images.\n      (4) Compression of the facsimile images.  This  allows\n    \
    \      more   efficient   transmission  to  be  achieved.\n          Different\
    \ compression schemes are investigated.\n      (5) Display of images  on  other\
    \  devices.   A  colour\n          display  is  used  so  that  the  result  of\
    \ image\n          processing can be shown very vividly.\n      (6) Improvement\
    \ of the images. The ability to  'clean'\n          the  facsimile  images  not\
    \  only  allows for even\n          higher  compression  ratio,  but  also  provide\
    \  a\n          better result at the destination.\n      (7) Editing of  facsimile\
    \  pages.  This  includes  the\n          ability  to  change  pictures,  alter\
    \  the size of\n          images  and  merge  two  or   more   images,   all\n\
    \          electronically.\n      (8) Integration of the facsimile  service  with\
    \  other\n          data  types.   For the time being, coded character\n     \
    \     text can be converted into  facsimile  format  and\n          mixed  pages\
    \  containing  pictures and text can be\n          manipulated.\n       This \
    \ note  first  considers  the  functions  of  the\n     facsimile  system,  the\
    \ related experimental work being\n     reported.  Then the discipline for the\
    \ system design is\n     discussed.  Finally,  the  implementation  of  the  UCL\n\
    \     facsimile system is described. As appendices,  detailed\n     description\
    \ of the system are given, namely\n             I.   Devices\n             II.\
    \  Task controller and task processes\n             III. Utility routines and\
    \ Data format\n     2. SYSTEM FUNCTIONS\n       The computerised facsimile system\
    \ we  have  developed\n     is composed of an LSI-11 micro-computer running the\
    \ MOS\n     operating system [14] with two AED62 floppy disk drives\n     [17],\
    \ a Grinnell colour display [18], a DACOM facsimile\n     machine [16], and a\
    \ VDU as  the  system  console.  This\n     LSI-11  is also attached to several\
    \ networks, including\n     the ARPANET/SATNET [21], [22]  and  the  UCL  Cambridge\n\
    \     Ring. A schematic of the system is shown in Fig. 1.\n              facsimile\
    \ machine  bit-map display\n                     +------+    +------+\n      \
    \               !      !    !      !\n                     +------+    +------+\n\
    \           +------+        \\      /        VDU\n           ! disk !      +----------+\
    \    +-----+\n           +------+ ---- !  LSI-11  ! -- !     !\n           ! disk\
    \ !      +----------+    +-----+\n           +------+           |\n          \
    \                 +------+\n                           !  NI  !\n            \
    \               +------+\n                       Network Interface\n         \
    \   Fig. 1  Schematic of UCL facsimile system\n       In this system, a  page\
    \  is  read  on  the  facsimile\n     machine  and  the  image data produced is\
    \ stored on the\n     floppy disk. This data can be processed locally in  the\n\
    \     micro-computer  and  then  sent  to  a  file store of a\n     remote computer\
    \ across the  computer  network.  At  the\n     remote  site,  the  image  data\
    \  may  be  processed and\n     printed on a facsimile machine.\n       On the\
    \ other hand, we can receive image data which is\n     sent  by a remote host\
    \ on the network. This data can be\n     manipulated in the same way, including\
    \ being printed on\n     the local machine.\n       Section 2.1  dicusses  the\
    \  problems  concerned  with\n     transmission  of  facsimile  image data over\
    \ a network,\n     while the following sections deal with those  of  local\n \
    \    manipulation of image data.\n       In order to interwork with other  facsimile\
    \  machine,\n     we   have   to   convert   the   image  data  from  one\n  \
    \   representation format  to  another.  Interworking  with\n     other  output\
    \ devices requires that the image be scaled\n     to fit the dimension of the\
    \ destination  device.  These\n     are described in section 2.2.\n       Being\
    \ able to process the image by computer opens the\n     door  to  many  possibilities.\
    \  First, as considered in\n     section 2.3, an image can  be  enhanced,  so\
    \  that  the\n     quality of the image may be improved and more efficient\n \
    \    storage and transmission can be achieved.  Secondly,  a\n     facsimile \
    \ editing  system  can  be supported whereby a\n     picture can  be  changed\
    \  and/or  combined  with  other\n     pictures. This is described in section\
    \ 2.4.\n       In our system, coded character text can be  converted\n     into\
    \  its  bit-map representation format so that it can\n     be  handled  as  a\
    \  facsimile  image  and  merged  with\n     pictures. This provides an environment\
    \ where multi-type\n     information can be dealt with.  This  is  discussed \
    \ in\n     section 2.5.\n     2.1 Communication\n       The first goal of our\
    \ computerised  facsimile  system\n     is  to  use a computer network to transmit\
    \ data between\n     facsimile machines which are geographically separated.\n\
    \       Normally, facsimile machines are used in  association\n     with  telephone\
    \  equipment,  the  data being sent along\n     telephone lines.  Placing the\
    \ facsimile machines  on  a\n     computer  network  presents  a problem as the\
    \ facsimile\n     machine does not have the ability  to  use  a  computer\n  \
    \   network  directly.   To  perform  the  network  tasks a\n     computer is\
    \ required, and so the  first  phase  was  to\n     attach the facsimile machine\
    \ to a computer.\n       The facsimile machine is not like a standard piece of\n\
    \     computer  equipment.  We  required  a  special hardware\n     interface\
    \ to enable communication between the facsimile\n     machine  and  a small computer.\
    \ This interface was made\n     to appear exactly like  the  telephone  system\
    \  to  the\n     facsimile   machine.   Furthermore,  the  computer  was\n   \
    \  programmed  to  act  exactly  as  if  it  were  another\n     facsimile  machine\
    \ on the end of a telephone line. Thus\n     the local facsimile machine could\
    \ transmit data to  the\n     computer  quite happily, believing that it was actually\n\
    \     talking to a remote facsimile machine on the other  end\n     of  a  telephone\
    \  wire.  Because of the property of the\n     DACOM 6450 used in the experiment\
    \ [16],  the  interface\n     could  be  identical to one developed for connecting\
    \ to\n     an X25 network. The binary synchronous mode of the chip\n     used\
    \  (SMC  COM5025) was appropriate to drive the DACOM\n     machine.\n       At\
    \ the other side of the computer network there was a\n     similar  computer \
    \ with an identical facsimile machine.\n     The problem of transmitting  a  facsimile\
    \  picture  now\n     appeared  simple:  data  was  taken  from the facsimile\n\
    \     machine into the computer, transmitted over the network\n     as  if  it\
    \ was normal computer data, and then sent from\n     the computer to the facsimile\
    \  machine  at  the  remote\n     end.  The  data  being  sent  over  the network\
    \ appears\n     exactly as any other computer data;  there  is  nothing\n    \
    \ special  about  it  to  signify  that  it  came  from a\n     facsimile machine.\
    \  The  schematic  of  such  facsimile\n     transfer system is shown in Fig.\
    \ 2.\n     facsimile\n     machine\n      +---+  interface\n      !   !    +--+\
    \    +-----+\n      !   ! == !  ! == !     ! computer\n      +---+    +--+   \
    \ +-----+\n                          |\n                           - - - - - -\
    \    computer\n                         /             \\  network\n          \
    \               \\             /             facsimile\n                     \
    \      - - - - - -               machine\n                                   \
    \   |    interface  +---+\n                                   +-----+    +--+\
    \    !   !\n                          computer !     ! == !  ! == !   !\n    \
    \                               +-----+    +--+    +---+\n                Fig.\
    \ 2  Facsimile transfer system\n       The experimental system was used to perform\
    \  a  joint\n     experiment  between  UCL  and  two groups in the United\n  \
    \   States. Pictures were exchanged via the  ARPANET/SATNET\n     [21],  [22]\
    \  between UCL in London, ISI in Los Angeles,\n     and  COMSAT  in  Washington\
    \   D.C.   (Fig.   3).   This\n     environment  was chosen because no equivalent\
    \ group was\n     available in the UK.\n       One  problem   concerned   with\
    \   such   image   data\n     transmission  is  the  quantity of data. Even with\
    \ data\n     compression,  a  single  page  of  facsimile  data  can\n     produce\
    \  as  much  computer  data  as would normally be\n     sufficient   for   sending\
    \   over   20,000   alphabetic\n     characters  -  or  over a dozen typed pages.\
    \ Thus for a\n     given number of pages put into the system,  an  immense\n \
    \    amount  of  computer  data is produced. This means that\n     the transmission\
    \ will be slower than for sending  text,\n     and  that far more storage will\
    \ be required to hold the\n     data.\n       Another problem was encountered\
    \ which became only too\n     apparent  when we implemented this system.  The\
    \ network\n     we were using was often unable  to  keep  up  with  the\n    \
    \ speed of the facsimile machine.  When this happened the\n                  \
    \    US               UK\n                           satellite\n     COMSAT  \
    \                 __\n     +---+    +--+           /  \\\n     !   ! -- !  ! \
    \          /  \\\n     +---+    +--+          /    \\\n       |          \\  \
    \      /      \\\n     +---+         \\      /        \\           UCL\n     !fax!\
    \          \\+--+/          \\+--+    +---+\n     +---+  ARPANET  !  !   SATNET\
    \   !  ! -- !   !\n                    /+--+            +--+    +---+\n      \
    \             /                           |\n     ISI         /              \
    \            +---+\n     +---+    +--+                           !fax!\n     !\
    \   ! -- !  !                           +---+\n     +---+    +--+\n       |\n\
    \     +---+\n     !fax!\n     +---+\n     Fig. 3. The three participants of the\
    \ facsimile experiments\n     computer tried to slow down the facsimile machine.\
    \  The\n     facsimile  machine  would  detect  this 'slowness' as a\n     communication\
    \ problem (as a telephone line would  never\n     act  in  this  manner),  and\
    \ would abandon the transfer\n     mid-way through the page.\n       This is because\
    \ the the  facsimile  machine  we  were\n     using  was never intended for use\
    \ on a computer; it was\n     designed and built for use on telephone lines. \
    \ Indeed,\n     being  unaware that it was connected to a computer, the\n    \
    \ facsimile machine transmitted data at a constant  rate,\n     which exceeded\
    \ the limit that the network could accept.\n     In other words, the computer\
    \ network we were using  was\n     not  designed for the transfer rate that we\
    \ were trying\n     to use over it.\n       Both  these  problems  are  surmountable.\
    \   Facsimile\n     machines are coming on the market that are designed for\n\
    \     direct communication with a computer. These machines do\n     not  mind\
    \  the delays on the computer interface and are\n     tolerant of the stops and\
    \ re-starts. On the other hand,\n     if  there were a serious use of facsimile\
    \ machines on a\n     computer network, the network could be designed for the\n\
    \     high  data rate required. Our problem was aggravated by\n     using a network\
    \ that was never designed  for  the  data\n     rates required in our mode of\
    \ usage.\n       Despite the problems we encountered being a result of\n     the\
    \  experimental  equipment  we  were working with, we\n     still had to  improve\
    \  the  situation  to  permit  more\n     extensive communications to take place.\
    \ The easiest way\n     to do this was to introduce a local storage area in our\n\
    \     computer   where  the  data  could  be  held  prior  to\n     transmission.\
    \  The transfer of a page is  now  done  in\n     three  stages.   First, the\
    \ facsimile data is read from\n     the facsimile machine and stored on a local\
    \ disk.  This\n     takes  place  at  high  speed  as  this is just a local\n\
    \     operation.  When this is complete,  the  data  is  sent\n     over  the\
    \  network  to  a  disk on the remote computer.\n     Finally, the data from \
    \ that  disk  is  output  to  the\n     remote  facsimile  machine.   This  improved\
    \  system is\n     shown in Fig. 4.\n                     computer network\n \
    \     fax    computer    - - - -     computer   fax\n     +---+   +-----+   /\
    \         \\   +-----+   +---+\n     !   ! = !     ! =     ==>     = !     ! =\
    \ !   !\n     +---+   +-----+   \\         /   +-----+   +---+\n        - - -\
    \ + |        - - - -        | + - - >\n              | | + - - - - - - - - - +\
    \ | |\n              | | |                   | | |\n              V | |      \
    \             V | |\n              +---+                   +---+\n           \
    \   !   !                   !   !\n              !   !                   !   !\n\
    \              +---+                   +---+\n              disk             \
    \       disk\n         Fig. 4.  The improved facsimile transfer system\n     \
    \  The idea  behind  this  method  is  to  decouple  the\n     facsimile  machine\
    \ from the network communications. The\n     data is read from the facsimile machine\
    \ at full  speed,\n     without  the  delays  caused  by  the computer network.\n\
    \     This also has the effect of being  more  acceptable  to\n     the human\
    \ operators: each page is now read in less than\n     a minute.  The transmission\
    \ over the network then takes\n     place  at  whatever speed the network can\
    \ sustain. This\n     does not affect the facsimile machines at all; they are\n\
    \     not involved in the sending or receiving. Only when all\n     the data has\
    \ been received at the remote  disk  is  the\n     remote  facsimile  machine\
    \ told that the data is ready.\n     The facsimile machine is then given the data\
    \ as fast as\n     it will accept it.\n       The disadvantage of such a system\
    \ is that the  person\n     sending  the  pages  does  not know how long it will\
    \ be\n     before they are actually printed at the other side.  If\n     several\
    \  pages  are  input  in  quick succession by the\n     operator, they will be\
    \ stored on disk; it may  then  be\n     some time before the last page is actually\
    \ delivered to\n     the destination. This is  not  always  a  disadvantage;\n\
    \     where  many  operators  are  sending  data  to the same\n     destination,\
    \ it is a definite advantage to be  able  to\n     input  the  pages and have\
    \ the system deliver them when\n     the  destination  becomes  free.  Such  a\
    \   system   is\n     preferable to use of the current telephone system where\n\
    \     the  operator  has  to  keep  re-dialing   the   remote\n     facsimile\
    \ machine until the call is answered.\n     2.2 Interworking with Other Equipment\n\
    \     2.2.1 Facsimile machines\n       As was mentioned earlier, facsimile machines\
    \  produce\n     a large amount of data per page due to the way in which\n   \
    \  the pages are encoded.  To reduce the data that has  to\n     be  transmitted,\
    \  various  compression  techniques  are\n     employed.  The manufacturers of\
    \ facsimile machines have\n     developed   proprietary  ways  in  which  the\
    \  data  is\n     compressed and encoded.  Unfortunately this  has  meant\n  \
    \   that  interworking  of different facsimile machines has\n     been impossible.\
    \  In the system described in  the  last\n     section, exchange of pictures was\
    \ only possible between\n     sites that had identical facsimile  machines.  The\
    \  new\n     set  of CCITT recommendations will reduce the extent to\n     which\
    \ differences in equipment persist.\n       Having  the  data  on  a  computer\
    \   gives   us   the\n     opportunity  to manipulate data in any way we wish.\
    \  In\n     particular we could convert the data from the form used\n     in \
    \ one  facsimile machine to that required by another.\n     This means that interworking\
    \ between different types of\n     facsimile machines can be achieved.\n     \
    \  The development of this  system  took  place  in  two\n     stages:  the  decompression\
    \  of the facsimile data from\n     the coded form used in our  machine  into\
    \  an  internal\n     data  form  and  the  recompression  of the data in the\n\
    \     internal form into the encoded form  required  for  the\n     destination\
    \  machine.  Two  programs  were developed to\n     perform these two operations.\n\
    \       At the same time we were developing  compression  and\n     decompression\
    \  programs  for  machines  that  use other\n     techniques.  In particular,\
    \ we  developed  programs  to\n     handle  the  recently approved CCITT recommendation\
    \ for\n     facsimile compression [15]. The CCITT came up with  two\n     varieties\
    \ of compression, depending upon the resolution\n     being used.\n       Unfortunately\
    \ there were no facsimile machines on the\n     network  that  use  the  CCITT\
    \  compression  technique.\n     However, the programming of the  new  methods\
    \  achieved\n     two  goals:  it proved that the data could be converted\n  \
    \   inside a small computer, so that machines of  different\n     types could\
    \ be supported on the network, and it enabled\n     us  to  compare  the  compression\
    \  results.  These  are\n     described  in  more detail in [13].  Essentially,\
    \ these\n     show that the DACOM technique  used  by  our  facsimile\n     machine\
    \  is  comparatively  poor, and that considerably\n     less data need be transmitted\
    \ if some other  method  is\n     used.  This  brings  up  another  possibility:\
    \ we could\n     change the compression of the data to reduce the volume\n   \
    \  for transmission and then change the data back again at\n     the   destination.\
    \   This   may    save    considerable\n     transmission  time,  especially \
    \ if  fast  computers or\n     special hardware was easily available.   This \
    \ has  not\n     been  tried  yet  in  our  system, as none of the other\n   \
    \  users on the network have the  capability  of  changing\n     the  data  format\
    \  back  into  that  required  by their\n     machines.\n       There  are  many\
    \  other  more  efficient  compression\n     schemes,  e.g.   block  compression\
    \  [7] and predictive\n     compression [8], but we have not yet incorporated\
    \  them\n     into our system.\n     2.2.2 Output Devices\n       One area that\
    \ we have explored is the use of  devices\n     other  than facsimile machines\
    \ for outputting the data.\n     Facsimile  machines  are  both  expensive  to\
    \  buy  and\n     relatively  slow  to  operate. We have investigated the\n  \
    \   use of a TV-like screen to display the  data,  just  as\n     character VDUs\
    \ are commonly used to display text.  This\n     activity requires bit-map displays,\
    \ with an address  in\n     memory  for each postion on the screen. Full colour\
    \ and\n     multiple shades can be used  with  appropriately  large\n     bit-map\
    \  storage.   Although  simple  in principle, the\n     implementation  of   the\
    \   relevant   techniques   took\n     considerable effort.\n       The problems\
    \ arise in  the  way  that  the  facsimile\n     image  is encoded. Raw facsimile\
    \ images consist of rows\n     of small dots, each dot recorded as a  black  or\
    \  white\n     space. When these dots are arranged together they build\n     up\
    \ a picture in a similar manner to the way in which  a\n     newspaper  picture\
    \ is made up. Unfortunately the number\n     of dots used in a facsimile page\
    \ is not the same as the\n     number  used  on  most screens. For instance, the\
    \ DACOM\n     facsimile machine uses 1726 dots across each page,  but\n     across\
    \  a  screen there are usually just 512 dots. Thus\n     to show the picture on\
    \ the screen the 1726 dots must be\n     'squeezed' into just 512 dots; stated\
    \ another way, 1214\n     dots must be thrown away without losing the picture!\n\
    \       It is in reducing the number of picture elements that\n     the  problem\
    \  arises.  We could just every third dot or\n     so from the facsimile  page\
    \  and  just  display  those.\n     Alternatively,  we  could  take three or more\
    \ at a time\n     and try to convert the group  of  them  into  a  single\n  \
    \   black  or  white  dot.   Unfortunately,  in  both these\n     cases, data\
    \ can get  lost  that  is  necessary  to  the\n     picture.   For  instance,\
    \  a  facsimile  encoding of an\n     architect drawing could easily end up with\
    \  a  complete\n     line  removed,  radically  changing the presentation of\n\
    \     the image.\n       After much experimentation, we developed a method  of\n\
    \     reducing  the  number  of  dots  without destroying the\n     picture. This\
    \ is  a  thinning  technique,  whereby  key\n     elements  of  the picture are\
    \ thinned, but not removed.\n     Occasionally, when  the  detail  gets  too \
    \ fine,  some\n     elements  are merged, but under these circumstances the\n\
    \     eye would not have been able to see the detail  anyway.\n     The  details\
    \ of this technique are described in [3] and\n     [4].\n       It may also be\
    \ required that a picture  be  enlarged.\n     This enlargement can be done by\
    \ simply duplicating each\n     pixel in the picture.  For a  non-integral  ratio,\
    \  the\n     picture  can  be expanded up to the nearest integer and\n     then\
    \ shrunk to the correct size.  However, this  method\n     may degrade the image\
    \ quality, e.g. the oblique contour\n     may become stepped,  especially  when\
    \  the  picture  is\n     enlarged  too much. This problem can be solved by using\n\
    \     an iterative enlargement algorithm. Each time  a  pixel\n     is  replaced\
    \  with a 2x2 array of pixels, whose pattern\n     depends  on  the  original\
    \   pixel   and   the   pixels\n     surrounding  it.  This  procedure is repeated\
    \ until the\n     requested ratio is reached. If  the  ration  is  not  a\n  \
    \   power  of 2's, the same method as that for non-integral\n     ratios is used.\n\
    \       As a side effect of  developing  this  technique,  we\n     could  freely\
    \  change  the  size and shape of an image.\n     The picture can be expanded\
    \ or shrunk,  or  it  can  be\n     distorted.   Distortion,  whereby  the  horizontal\
    \  and\n     vertical dimensions of the  image  may  be  changed  by\n     different\
    \ amounts, is often useful in image editing.\n       The immediate consequence\
    \ of this ability  to  change\n     the image size meant that we could display\
    \ the image on\n     a screen as well as output the  image  on  a  facsimile\n\
    \     machine.  To  a user of a computerised facsimile system\n     this could\
    \ be a very  useful  feature:  images  can  be\n     displayed  on  screen  much\
    \  faster than on a facsimile\n     machine, and displays are  significantly \
    \ cheaper  than\n     the  facsimile machines as well. It is possible that an\n\
    \     installation could have many screen displays where  the\n     image  could\
    \  be viewed, but perhaps only one facsimile\n     machine would be available\
    \ for hard copy. This would be\n     similar to many computer configurations today\
    \ where the\n     number of printers is limited due to  their  cost,  and\n  \
    \   display screens are far more numerous.\n     2.3 Image Enhancement\n     \
    \  One aspect of computer processing that we  wanted  to\n     investigate  was\
    \  that  of image enhancement. Enhancing\n     the image is a  very  tricky  operation;\
    \  as  the  name\n     implies  it  means  that  the image is improved in some\n\
    \     sense.  Under program  control  this  is  difficult  to\n     achieve: what\
    \ the program thinks is an improvement, the\n     human might judge to be distinctly\
    \ worse.\n       Our enhancement attempts were aimed  particularly  at\n     printed\
    \  documents  and  other forms of typed text. The\n     experiment was double\
    \ pronged: we  hoped  to  make  the\n     image  easier  to  read by humans while\
    \ also making the\n     image easier for the computer to handle.\n       In our\
    \ earlier experiments we had  noticed  that  the\n     encoding  of  printed \
    \ matter was often very poor. This\n     was especially noticeable when we  enlarged\
    \  an  image.\n     Rather  than  each  character having smooth edges as on\n\
    \     the original  document,  the  edges  were  very  rough,\n     unexpected\
    \ notches and excrescences being caused by the\n     facsimile scanner.  They\
    \ not  only  degrade  the  image\n     quality but also decrease the compression\
    \ efficiency. A\n     typical enlargement of several characters is  shown  in\n\
    \     Fig. 5.\n             Fig 5.  An enlargement of an typed text\n       The\
    \ enhancement method we adopted was first  employed\n     at  Loughborough  University\
    \  [5].  This method has the\n     effect of smoothing the edges of the dark areas\
    \ on  the\n     image.  The  technique consists of considering each dot\n    \
    \ in the image in turn. The dot is either left as  it  is\n     or changed to\
    \ the opposite colour (white  to  black  or\n     black  to  white)  depending\
    \  upon  the eight dots that\n     surround it. The particular pattern of surrounding\
    \ dots\n     that  are  required to change the inner dot's colour is\n     used\
    \ to control the harshness  of  the  algorithm  [6],\n     [8].\n       In our\
    \  first  set  of  experiments  the  result  was\n     definitely  worse  than\
    \  the original. Although square-\n     like characters such as H, L, and T came\
    \ out very well,\n     anything  with slope (M, V, W, or S) became so bad that\n\
    \     the oblique  contours  were  stepped.  The  method  was\n     subsequently\
    \  modified to produce a result that was far\n     more acceptable; the image\
    \ looked a  lot  cleaner  than\n     the  original.  Fig.  6  shows the same text\
    \ as that in\n     Fig. 5, but after it has been cleaned.\n                  \
    \   Fig. 6  A cleaned text\n       The effect of these can be difficult to see\
    \  clearly.\n     We have used the colour on our Grinnell display to show\n  \
    \   the original picture and the outcome of various picture\n     processing \
    \ operations superposed in different colours.\n     This brings out  the  effect\
    \  of  the  operations  very\n     vividly.\n       It was mentioned above that\
    \ the enhancement was  done\n     not  only to improve the image for reading but\
    \ also for\n     easier  processing  by  the  computer.   As   described\n   \
    \  earlier,  the  image  from  the  facsimile  machine  is\n     compressed in\
    \ order to reduce the amount of data.   The\n     cleaning  allows a higher compression\
    \ rate so that more\n     efficient transmission and/or storage can be achieved.\n\
    \       We  learned   some   important   lessons   from   the\n     enhancement\
    \  exercise.   Originally we thought that the\n     main attraction in enhancement\
    \ would be to improve  the\n     readability.  In  the  end, we found that improving\
    \ the\n     readability was very difficult, especially because  the\n     facsimile\
    \  image was so poor. Instead we found that the\n     effect of  reducing  the\
    \  compressed  output  was  more\n     important.  By reducing the data to be\
    \ transmitted by a\n     quarter, significant savings could be made. But  before\n\
    \     such  a  technique  could be used in a live system, the\n     time it  takes\
    \  to  produce  the  enhancement  must  be\n     weighed  against  the  time \
    \ that  would  be  saved  in\n     transmission.\n     2.4 Image Editing\n   \
    \    By editing we mean that the facsimile picture can  be\n     changed,  or\
    \  combined with other pictures, while it is\n     stored inside the computer.\
    \  In  previous  sections  it\n     was  mentioned  that we could change the size\
    \ and shape\n     of a facsimile image. This technique was later combined\n  \
    \   with  an  overlaying method that enabled one picture to\n     be combined\
    \ with another [12].\n       In order to perform any editing it  is  necessary\
    \  to\n     have  the picture displayed for the user to see. In our\n     case\
    \ we displayed the picture on  the  bit-map  screen.\n     The image took up the\
    \ left-hand side of the screen, the\n     right side being reserved  for  the\
    \  picture  that  was\n     being  built.   The  user  could  select an area of\
    \ the\n     left-hand screen and move  it  to  a  position  on  the\n     right-hand\
    \  screen.   Several images could be displayed\n     in succession on the left,\
    \ and areas selected and moved\n     to  the right.  Finally, the right-hand screen\
    \ could be\n     printed on the facsimile machine.\n       The selection of an\
    \ area of the picture was  done  by\n     the   use   of   a   coloured  rectangular\
    \  subsection,\n     controlled by a program in the computer, that could  be\n\
    \     moved  around on the screen. The rectangular subsection\n     was moved\
    \ with instructions typed in by  the  operator;\n     it  could  be  moved  up\
    \  or  down,  and  increased  or\n     decreased in size. When the  appropriate\
    \  area  of  the\n     screen  had  been  selected, the program remembered the\n\
    \     coordinates  and   moved   the   coloured   rectangular\n     subsection\
    \  to  the  right-hand side of the screen. The\n     user then selected an area\
    \ again, in a similar  manner.\n     When the user finished the editing, the program\
    \ removed\n     the part of the picture  selected  from  the  left-hand\n    \
    \ screen  and  converted  it  to  fit  the  shape  of the\n     rectangular subsection\
    \ on the  right-hand  screen.  The\n     result was then displayed for the user\
    \ to see.\n       When an image was being edited,  the  editor  had  to\n    \
    \ keep  another  scaled  copy for display. This is due to\n     the fact that\
    \ the screen had a different  dimension  to\n     that  of the facsimile machine.\
    \ The editing operations,\n     e.g.  chopping  and  merging,  were  performed\
    \  on  the\n     original  image  data  files  with  the full resolution\n   \
    \  available on the facsimile machine.\n     2.5 Integration with Other Data Types\n\
    \       The facsimile  machine  can  be  viewed  in  a  wider\n     context than\
    \ merely a facsimile input/output device. It\n     can work as a printer  for\
    \  other  data  representation\n     types,  such  as  coded  character  text\
    \  and geometric\n     graphics.  At  present,  text  can  be  converted  into\n\
    \     facsimile  format and printed on the facsimile machine.\n     Moreover,\
    \ mixed pages containing pictures and text  can\n     be  manipulated  by  our\
    \  system.  The  integration  of\n     facsimile images with geometric graphics\
    \ is a topic  of\n     future research.\n       In order to  convert  a  character\
    \  string  into  its\n     facsimile  format,  the  system maintains a translation\n\
    \     table whereby the patterns of the characters  available\n     in  the  system\
    \  can  be retrieved. The input character\n     string is translated into a set\
    \ of scan lines, each  of\n     which  is  created  by  concatenating the corresponding\n\
    \     patterns of the characters in the string.\n       The translation table\
    \ is in  fact  a  software  font,\n     which  can be edited and modified. Even\
    \ though only one\n     font is available in our system for the time being,  it\n\
    \     is  quite  easy  to  introduce  other  character fonts.\n     Furthermore,\
    \ it is also  possible  for  a  font  to  be\n     remotely  loaded  from a database\
    \ via the communication\n     network.\n       This allows for more interesting\
    \ applications of  the\n     facsimile  machine.  For  example,  it could serve\
    \ as a\n     Teletex printer, provided that  the  Teletex  character\n     font\
    \  is included in our system. In this case, the text\n     images may be distorted\
    \ to fit the presentation  format\n     requested  by  the Teletex service.  Similarly,\
    \ Prestel\n     viewdata pages  could  be  displayed  on  the  Grinnell\n    \
    \ screen.\n       Moreover,  pictures  can  be  mixed  with   text   by\n    \
    \ combining   this   text  conversion  with  the  editing\n     described in \
    \ the  previous  section.  This  should  be\n     regarded   as   a   notable\
    \   step  towards  multi-type\n     processing.\n       Not  only  does  this\
    \  support  a  local   multi-type\n     environment   but   multi-type   information\
    \   can   be\n     transmitted over a network. So far  as  this  facsimile\n \
    \    system  is  concerned, a mixed page containing text and\n     pictures can\
    \ be sent only when it has been  represented\n     in  a  bit-map  format.  However,\
    \  much  more efficient\n     transmission would be achieved if  one  could  transmit\n\
    \     the text and pictures separately and reproduce the page\n     at the destination\
    \ site. This requires  that  a  multi-\n     type  data structure be designed\
    \ which is understood by\n     the two communication sites.\n     3. SYSTEM ARCHITECTURE\n\
    \       Now let us discuss the general disciplines for design\n     and  implementation\
    \  of a computerised facsimile system\n     which  carries  out  the  functions\
    \  described  in  the\n     previous  sections.   Having discussed the requirements\n\
    \     of the system, a hierarchical model  is  introduced  in\n     which  the\
    \  modules of different layers are implemented\n     as separate processes.  The\
    \ Clean and Simple interface,\n     which  is  adopted  for inter-process communication,\
    \ is\n     then  described.   The  task   controller,   which   is\n     responsible\
    \  for  organising  the  tasks  involved in a\n     requested job, is discussed\
    \ in  detail.   Some  efforts\n     have  been  made  in our experimental work\
    \ to provide a\n     more convenient user programming environment and a more\n\
    \     efficient   data   transfer  method.  This  is  finally\n     described.\n\
    \     3.1 System Requirements\n       In a computerised facsimile system,  the\
    \  images  are\n     represented  in  a  digital  form.  To  carry  out this\n\
    \     conversion, a page is scanned by the optical scanner of\n     the  facsimile\
    \ machine, a digital number being produced\n     to represent  the  darkness \
    \ of  each  pixel.  As  high\n     resolution  has to be adopted to keep the detail\
    \ of the\n     image, the facsimile  data  files  are  usually  rather\n     large.\
    \  In  order  to  achieve  efficient  storage  and\n     transmission, the facsimile\
    \ data must be compressed  as\n     much as possible.\n       Currently, the facsimile\
    \ machines made  by  different\n     manufacturers   h different  properties,\
    \  such  as\n     different compression methods and different resolution.\n  \
    \   There   are   also  some  international  standards  for\n     facsimile data\
    \ compression, which are employed for  the\n     facsimile  data  to be transferred\
    \ over the public data\n     network. These  require  that  the  facsimile  data\
    \  be\n     converted  from  one representation form to another, so\n     that\
    \ users who are  separated  geographically  and  use\n     different  machines\
    \  can  communicate  with each other.\n     More sophisticated applications, \
    \ e.g.  image  editing,\n     request processing facilities of the system as well.\n\
    \       When being processed, the facsimile image  should  be\n     represented\
    \   in  a  common  format  or  internal  data\n     structure,  which  is  used\
    \  to  pass  the  information\n     between  different processing routines. For\
    \ the sake of\n     convenience and efficiency, the internal data structure\n\
    \     should  be fairly well compressed and its format should\n     be  easy \
    \ for  the  computer  to  manipulate.  In   our\n     experimental  work,  the\
    \  line  vector  is  chosen as a\n     standard unit, a simple  run-length  compression\
    \  being\n     employed  [3].  Some  processing routines may use other\n     data\
    \   formats,   e.g.   bit-map,   but   it   is   the\n     responsibility   of\
    \   such   routines  to  perform  the\n     conversion between those formats and\
    \ the standard one.\n       The  system   should   contain   several   processing\n\
    \     routines,  each  of  which performs one primitive task,\n     such  as \
    \ chopping,  merging,  and  scale-changing.  An\n     immense variety of processing\
    \ operations can be carried\n     out as long as those  task  modules  can  be\
    \  organised\n     flexibly. The capability for flexible task organisation\n \
    \    should be thought of  as  one  of  the  most  important\n     requirements\
    \ of the system.\n       One  possibility  is  for  the  processing   routines\n\
    \     involved  to  be  executed  separately, temporary files\n     being used\
    \ as communication media. Though very  simple,\n     this method is far too inefficient.\n\
    \       As described above,  the  information  unit  for  the\n     communication\
    \  between  the  processing routines is the\n     line vector, so that the routines\
    \ can be  organised  as\n     embedded  loops,  where  a processing routine takes\
    \ the\n     input line from its source routine located in the inner\n     loop,\
    \  and  passes  the  output line to the destination\n     routine located in the\
    \ outer loop [3].  Obviously  this\n     method  is quite efficient. But it is\
    \ not realistic for\n     our system, because it is very difficult  to  build\
    \  up\n     different  processing  loops  at  run-time and flexible\n     task\
    \ organisation is impossible.\n       In a  real-time  operating  system  environment,\
    \  the\n     primitive   tasks   can   be  implemented  as  separate\n     processes.\
    \ This method, which is discussed in detail in\n     the   following   sections,\
    \   provides   the   required\n     flexibility.\n     3.2 Hierarchical Model\n\
    \       As shown in Fig. 7, the modules in a single  computer\n     fall into\
    \ three layers.\n                       +---------+\n                       !\
    \         ! task controller\n                       +---------+\n            \
    \                  tasks\n                +---+  +---+  +---+  +---+  +---+\n\
    \                !   !  ! !   !  !   !  !   !\n                +---+  +---+  +---+\
    \  +---+  +---+\n                  |      |                    |\n           \
    \     +---+  +---+                +---+\n                !   !  !   ! device drivers\
    \ !   !\n                +---+  +---+                +---+\n            - - -\
    \ | - -  |  - - - - - - - - - | - - - -\n                +---+  +---+        \
    \        +---+\n                !   !  !   !    physical    |   !\n          \
    \      !   !  !   !    devices     !   !\n                +---+  +---+       \
    \         +---+\n                 Fig. 7  The hierarchical model\n       These\
    \ are:\n      (1) Device Drivers, which constitute the lowest  layer\n       \
    \   in the model.  The modules in this layer deal with\n          I/O activities\
    \ of the physical  devices,  such  as\n          facsimile machine, display and\
    \ floppy  disk.  This\n          layer  frees  the task modules of upper layer\
    \ from\n          the burden of I/O programming.\n      (2) Tasks, which perform\
    \ all processing primitives and\n          handle different data structures. Above\
    \ the driver\n          of each physical device, there  are  one  or  more\n \
    \         such  device-independent  modules,  which  work as\n          information\
    \ source or sink in the task chain  (see\n          below).  A file system module\
    \ allows other modules\n          to store and retrieve information on the secondary\n\
    \          storage  device such as floppy disk. Decompression\n          and recompression\
    \ routines convert data structures\n          of   facsimile   image  information\
    \  so  that  the\n          facsimile machines can communicate with  the  rest\n\
    \          of   the   system.   Processing  primitives,  e.g.\n          chopping,\
    \ merging,  scaling,  are  implemented  as\n          task modules in this layer.\
    \ They are designed such\n          that they can be concatenated to  carry  out\
    \  more\n          complex  jobs.  So far as the system is concerned,\n      \
    \    the protocols for data transmission over  computer\n          networks are\
    \ also regarded as task modules in this\n          layer.\n      (3)  Task  Controller,\
    \  which   organises   the   task\n          processes   to   perform  the  specified\
    \  job.  It\n          provides the users of the application layer with a\n  \
    \        procedure-oriented  language whereby the requested\n          job can\
    \ be defined as a  chain  of  task  modules.\n          Literally, the chain is\
    \ represented by a character\n          string:\n             <source_task>|{<processing_task>|}<sink_task>\n\
    \            According to such a command, the task controller\n          selects\
    \ the relevant task modules and concatenates\n          them in proper order by\
    \ means  of  logical  links.\n          Then the tasks on the chain are executed\
    \ under its\n          control, so that the data taken  from  the  source\n  \
    \        are processed and the result is put into the sink.\n     3.3 Clean and\
    \ Simple Interface\n       It is important, in this application, to develop  the\n\
    \     software  in  a  modular  way.  It  is desirable to put\n     together a\
    \ set of modules to carry  out  the  different\n     image   processing  tasks.\
    \  Another  set  of  transport\n     modules must be developed for shipping  data\
    \  over  the\n     different networks to which the UCL system is attached.\n \
    \    In   our  computerised  facsimile  system,  these  task\n     modules are\
    \  implemented  as  separate  processes.  The\n     operation  of  the  system\
    \  relies on the communication\n     between these processes.  The interface which\
    \  is  used\n     for   such   communication  has  been  designed  to  be\n  \
    \   universal; it is independent of these modules, and  has\n     been  termed\
    \  the Clean and Simple interface [20]. This\n     interface is discussed in this\
    \ section.\n     3.3.1 Principles\n       The Clean and Simple interface is concerned\
    \ with  the\n     synchronisation   and   transfer  of  full-duplex  data\n  \
    \   streams between two communicating processes.  Thus  the\n     interface  \
    \ has   three  major  components:  connection\n     synchronisation,   data  \
    \ transfer    and    connection\n     desynchronisation.   These   components\
    \  are  discussed\n     below.\n       The connection between two processes is\
    \ initiated  by\n     one  of  them,  which, generally speaking, belongs to a\n\
    \     higher  layer.  For  example,  the  interface   between\n     protocols\
    \  of  different  layers is always initiated by\n     the higher layer, though,\
    \ sometimes, the connection  is\n     initiated  passively by the primitive 'listen'.\
    \ It will\n     be seen in the next section  that  task  processes  can\n    \
    \ communicate  with each other via the connections to the\n     higher  layer\
    \  (task  controller)  and  this  makes  it\n     possible to achieve flexible\
    \ task organisation.\n       The process initiating the connection is  called\
    \  the\n     'master' process, while the other is called the 'slave'\n     process.\
    \ The 'master' process is also  responsible  for\n     resource   allocation \
    \  for   the   two   communicating\n     processes. Here 'resource' refers mainly\
    \ to the  memory\n     areas  for  the message structure and data buffer. This\n\
    \     asymmetric definition of the interface  eliminates  any\n     possible confusion\
    \ in resource allocation.\n       The interface is implemented by using the signal-wait\n\
    \     mechanism  provided  by  the  operating  system. A data\n     structure\
    \ called CSB (Clean and  Simple  Block),  which\n     contains  function, data\
    \ buffer, and other information,\n     is sent as the event message, when one\
    \ process  signals\n     another [20].\n     3.3.2 Synchronisation and Desynchronisation\n\
    \       The  procedure  for  connection  synchronisation   is\n     composed \
    \  of  two  steps.  First,  the  two  processes\n     exchange their identifiers\
    \ for the specific  connection\n     by  means  of a getcid primitive.  Usually,\
    \ the pointer\n     to the task control structure of the process is used as\n\
    \     the connection identifier.\n       Then, the 'master' sends an open CSB\
    \ with appropriate\n     parameter    string    passing    the    initialisation\n\
    \     information. This information, which can also be called\n     open   parameter,\
    \   is   process   dependent,  or  more\n     accurately, task dependent. For\
    \ example, the parameters\n     for  the  file  system  should be the file name\
    \ and the\n     access mode. Provided the 'slave' accepts the  request,\n    \
    \ the connection is established successfully and data can\n     be transferred\
    \ via the interface.\n       In  order  to  desynchronise  the   connection, \
    \  the\n     'master' initiates a 'close' action. On the other hand,\n     an\
    \ error state or  EOF  (end  of  file)  state  can  be\n     reported   by  the\
    \  'slave'  to  request  a  connection\n     desynchronisation.\n       The listen\
    \ primitive in our system  is  reserved  for\n     the  processes  that  receive\
    \ a request from the remote\n     hosts on the networks.\n     3.3.3 Data Transfer\n\
    \       While the Clean and Simple interface is asymmetric in\n     relation \
    \ to  connection synchronisation, data transfer\n     is completely symmetric\
    \ so long as the  connection  has\n     been  established.  Data  flows  in both\
    \ directions are\n     permitted, though the operations are quite different.\n\
    \       The  interface  provides  two  primitives  for   data\n     transfer \
    \ --  read  and write. To transfer some data to\n     the  'slave',  the  'master'\
    \  signals  it  with  a  CSB\n     containing  the write function and a buffer\
    \ filled with\n     the data to be transferred.  Having consumed the  data,\n\
    \     the 'slave' returns the CSB to report the result status\n     of the transmission.\n\
    \       On the other hand, in order to receive some data from\n     the 'slave',\
    \ the 'master' uses a read CSB with an empty\n     buffer. Having received the\
    \ CSB, the 'slave' fills  the\n     buffer  with  the data requested and, then,\
    \ returns the\n     CSB.\n     3.4 Control and Organisation of the Tasks\n   \
    \    Another  important  aspect   of   the   multi-process\n     architecture\
    \  of  the UCL facsimile system, is the need\n     to systematise the  control\
    \  and  organisation  of  the\n     tasks.  This  activity  is  the  function\
    \  of  the task\n     controller, whose  operations  are  discussed  in  this\n\
    \     section.\n     3.4.1 Command Language\n       As mentioned earlier, the\
    \ task controller supports  a\n     procedure-oriented  language by means of which\
    \ the user\n     or the routines of the upper layers can define the jobs\n   \
    \  requested.  A  command  should  contain  the  following\n     information:\n\
    \       1. the names of the task processes which are involved\n          in the\
    \ job.\n       2. the open parameters for these task processes.\n       3. the\
    \ order in which the tasks are to be linked.\n       The last item is quite  important,\
    \  though,  usually,\n     the same order as that given in the command is used.\n\
    \       A command in this language is presented  as  a  zero-\n     ended  character\
    \  string.  In the task name strings and\n     the attribute strings of the open\
    \ parameters, '|', '\"',\n     and  ','  must  be  excluded as they will be treated\
    \ as\n     separators. The definition is shown below,  where  '|',\n     which\
    \  is  the  separator of the command strings in the\n     language, does not mean\
    \ 'OR'.\n     <command_string> ::= <task_string>\n     <command_string> ::= <task_string>|<command_string>\n\
    \     <task_string> ::= <task_name>\n     <task_string> ::= <task_name>\"<open_parameter>\n\
    \     <open_parameter> ::= <attribute>\n     <open_parameter> ::= <attribute>,<open_parameter>\n\
    \     3.4.2 Task Controller\n       In our experimental work, the task controller\
    \  module\n     is  called  fitter.   This  name which is borrowed from\n    \
    \ UNIX hints how the  module  works.   According  to  the\n     command  string,\
    \  it  links  the specified tasks into a\n     chain, along which the data is\
    \ processed to fulfil  the\n     job requested (Fig. 8).\n                   \
    \         tasks\n                +-----+    +-----+    +-----+\n             \
    \   !  a  ! -> !  b  ! -> !  c  !\n                +-----+    +-----+    +-----+\n\
    \                     Fig. 8  The task chain\n       Since  all  modules,  including\
    \  fitter  itself,  are\n     implemented   as  processes,  the  connections \
    \ between\n     modules should be via the Clean and Simple  interfaces.\n    \
    \ Upon  receiving  the  command string, the fitter parses\n     the string to\
    \ find each task process involved and opens\n     a  connection  to  it. Formally,\
    \ the task processes are\n     chained directly, but, logically, there  is  no\
    \  direct\n     connection  between  them. All of them are connected to\n    \
    \ the fitter (Fig. 9).\n                           fitter\n                  \
    \     +-------------+\n                   +-- !             ! --+\n          \
    \         |   +-------------+   |\n                   |          |          |\n\
    \                   V          V          V\n                +-----+    +-----+\
    \    +-----+\n                !  a  !    !  b  !    !  c  !\n                +-----+\
    \    +-----+    +-----+\n          Fig. 9 The connection initiated by the fitter\n\
    \       For each of the processes  it  connects,  the  fitter\n     keeps  a \
    \ table called pipe. When the command string is\n     parsed, the pipe tables\
    \ are double-linked to  represent\n     the specified order of data flow. So far\
    \ as one process\n     is concerned, its pipe table contains two  pointers:  a\n\
    \     forward  one pointing to its destination and a backward\n     one pointing\
    \ to its sources. Besides the  pointers,  it\n     also  maintains  the  information\
    \  to identify the task\n     process and the corresponding connection.\n    \
    \   Fig. 10 illustrates the chain of the pipe tables  for\n     the  job \"a|b|c\"\
    .  Note that the forward (output) chain\n     ends at the sink, while the backward\
    \ (input) chain ends\n     at  the  source.  In this sense, the task processes\
    \ are\n     chained in the specified order  via  the  fitter  (Fig.\n     11).\
    \ The data transfer along the chain is initiated and\n     controlled by the \
    \ fitter,  each  process  getting  the\n     input  from  its  source  and putting\
    \ the output to its\n     destination.\n               +-----+    +-----+    +-----+\n\
    \               !  * -+--> !  * -+--> !  0  !\n               +-----+    +-----+\
    \    +-----+\n               !  0  ! <--+- *  ! <--+- *  !\n               +-----+\
    \    +-----+    +-----+\n               !  a  !    !  b  !    !  c  !\n      \
    \         +-----+    +-----+    +-----+\n               !     !    !     !   \
    \ !     !\n               !     !    !     !    !     !\n               +-----+\
    \    +-----+    +-----+\n                     Fig. 10  The pipe chain\n      \
    \                     fitter\n                       +-------------+\n       \
    \            +-> ! * -> * -> * ! --+\n                   |   +-------------+ \
    \  |\n                   |         | A         |\n                   |       \
    \  V |         V\n                +-----+    +-----+    +-----+\n            \
    \    !  a  !    !  b  !    !  c  !\n                +-----+    +-----+    +-----+\n\
    \                     Fig. 11  The data flow\n       This strategy makes the task\
    \ organisation so flexible\n     that  only the links have to be changed when\
    \ a new task\n     chain is to be built up. In such an  environment,  each\n \
    \    task process can be implemented independently, provided\n     the Clean and\
    \ Simple interface is supported. This  also\n     makes the system extension quite\
    \ easy.\n       The fitter manipulates one job at a time. But it must\n     maintain\
    \  a  command  queue  to cope with the requests,\n     which come simultaneously\
    \ from either the  upper  level\n     processes or other hosts on the network.\n\
    \     3.5 Interface Routines\n       In a modular, multi-process system such \
    \ as  the  UCL\n     facsimile   system,  the  structure  of  the  interface\n\
    \     routines is very important. The CSI of section  3.3  is\n     fundamental\
    \  to the modular interface; a common control\n     structure is also essential.\
    \ This  section  gives  some\n     details  both  about the sharable control structure\
    \ and\n     the buffer management.\n     3.5.1 Sharable Control Structure\n  \
    \     Though the CSI specification is straightforward,  the\n     implementation\
    \   of   the  inter-process  communication\n     interface may be  rather  tedious,\
    \  especially  in  our\n     system,  where  there  are  many  task  processes\
    \ to be\n     written. Not only does each process have  to  implement\n     the\
    \  same  control  structure  for signal handling, but\n     also the buffer management\
    \ routines must be included in\n     all the processes.\n       For the sake of\
    \ simplicity and efficiency, a  package\n     of  standard  interface  routines\
    \ is provided which are\n     shared by the  task  processes  in  the  system.\
    \  These\n     routines  are re-entrant, so that they can be shared by\n     all\
    \ processes.\n       The 'csinit' primitive is called for a  task  process\n \
    \    to check in.  An information table is allocated and the\n     pointer to\
    \ the table is returned to the caller  as  the\n     task  identifier,  which\
    \ is to be used for each call of\n     these interface routines.\n       Then,\
    \  each  task  process  waits  by  invoking   the\n     'csopen'  primitive  which\
    \  does  not  return until the\n     calling process  is  scheduled.   When  the\
    \  connection\n     between  the process and the fitter is established, the\n\
    \     call returns the pointer to the open  parameter  string\n     of  the  task,\
    \  the corresponding task being started. A\n     typical structure of the task\
    \ process (written in c) is\n     shown  below.  After  the task program is executed,\
    \ the\n     process calls the 'csopen' and waits again. It  can  be\n     seen\
    \  that  the  portability  of  the  task routines is\n     improved to a great\
    \ extent. Only the interface routines\n     should be changed if  the  system\
    \  were  to  run  in  a\n     different operating environment.\n     static int\
    \ mytid;       /* task identifier */\n     task()\n     {\n             char *op;\
    \       /* open parameter */\n             mytid = csinit();\n             for(;;)\
    \ {\n                     op = csopen(mytid);\n                     ...     /*\
    \ the body of the task */\n             }\n     }\n     3.5.2 Buffer Management\n\
    \       The package of the interface routines also provides a\n     universal\
    \ buffer management, so that the task processes\n     are freed from this burden.\
    \ The allocation of the  data\n     buffers  is  the  responsibility  of  the\
    \  higher level\n     process, the fitter. If the  task  processes  allocated\n\
    \     their own buffers, some redundant copying would have to\n     be  done.\
    \  Thus,  the  primitives  for  data  transfer,\n     'csread' and 'cswrite',\
    \ are designed as:\n             char *csread(tid, need);\n             char *cswrite(tid,\
    \ need);\n     where 'tid' is the identifier of the task and 'need' is\n     the\
    \  number  of  data  bytes  to  be  transferred.  The\n     primitives return\
    \ the pointer to  the  area  satisfying\n     the  caller's requirement. The 'csread'\
    \ returns an area\n     containing  the  data  required  by  the  caller.   The\n\
    \     'cswrite'  returns  an  area  into which the caller can\n     copy the data\
    \ to be transferred. The copied  data  will\n     be  written to its destination\
    \ at a proper time without\n     the caller's interference.  Obviously  the  unnecessary\n\
    \     copy  operations can be avoided. It is recommended that\n     the data buffer\
    \ returned  by  the  primitives  be  used\n     directly to attain higher performance.\n\
    \       In order to implement  this  strategy,  each  time  a\n     piece  of\
    \  data  is  required,  the  size of the buffer\n     needed is compared with\
    \ that of the unused buffer  area\n     in  the current CSB. If the latter is\
    \ not less than the\n     former,  the  current  buffer  pointer   is   returned.\n\
    \     Otherwise,  a  temporary buffer has to be employed. The\n     data is copied\
    \ into the buffer until the requested size\n     is  reached.  In  this  case,\
    \  instead of a part of the\n     current buffer, the temporary buffer will be\
    \ returned.\n       A 'cswrite' call with the 'need' field  set  to  zero\n  \
    \   tells  the  interface routine that no more data will be\n     sent. It causes\
    \  a  'close'  CSB  to  be  sent  to  the\n     destination routine.\n       If\
    \ there  is  not  enough  data  available,  'csread'\n     returns zero to indicate\
    \ the end of data.\n     4. UCL FACSIMILE SYSTEM\n       Now we discuss the implementation\
    \ of the computerised\n     facsimile   system   developed  in  the  Department\
    \  of\n     Computer Science at UCL.\n       This system has several components.\
    \ Since  the  total\n     system  is  a modular and multi-process one, a specific\n\
    \     system must be built up for a specific application. The\n     way  that\
    \ this is done is discussed in section 4.1. The\n     specific devices and their\
    \  drivers  are  described  in\n     section  4.2. The system can be attached\
    \ to a number of\n     networks.  In  the  UCL  configuration,   the   network\n\
    \     interface  can be direct to SATNET [22], SERC NET [23],\n     PSS [24],\
    \ and the Cambridge Ring. The form  of  network\n     connection  is  discussed\
    \  further  in section 4.3. The\n     system must transfer data between the facsimile\
    \ devices\n     and  the disks, and between the networks and the disks.\n    \
    \ For this a filing system is required which is discussed\n     in section 4.4.\n\
    \       A key aspect of the  UCL  system  is  flexibility  of\n     devices, networks,\
    \ and data formats. The flexibility of\n     device is achieved by the modular\
    \ nature of the  device\n     drivers  (section  4.2).  The flexibility of network\
    \ is\n     discussed in section 4.8. The additional flexibility of\n     data\
    \   structure  is  described  in  section  4.5.  The\n     flexibility can be\
    \ utilised by incorporating conversion\n     routines  as in section 4.6. An important\
    \ aspect of the\n     UCL system is the ability to provide local manipulation\n\
    \     facilities  for  the  graphics  files.   The facilities\n     implemented\
    \ for the local manipulation are discussed in\n     section 4.7.  In  order  to\
    \  transfer  files  over  the\n     different  networks  of  section 4.3. a high\
    \ level data\n     transmission protocol must be defined.  The  procedures\n \
    \    used in the UCL system are discussed in section 4.8.\n     4.1 Multi-Task\
    \ Structure\n       The  task  controller  and   processing   tasks   are\n  \
    \   implemented  as  MOS  processes.  A  number  of utility\n     routines are\
    \ provided  for  users  to  build  new  task\n     processes and modules at application\
    \ level.\n       In the environment of MOS, a process is included in a\n     system\
    \  by  specifying a Process Control Table when the\n     system is built up. The\
    \ macro  'setpcte'  is  used  for\n     this  purpose,  the  meaning  of  its\
    \  parameters being\n     defined in [14].\n     #define setpcte(name,entry,pridev,prodev,stklen,\n\
    \         relpid,relopc)\n       {0,name,entry,pridev,prodev,stklen,relpid,relopc}\n\
    \       A Device Control Table (DCT) has to be specified  for\n     each  device\
    \  when the system is built up. A DCT can be\n     defined anywhere as devices\
    \ are referenced by  the  DCT\n     address.  The  macro  'setdcte'  is designed\
    \ to declare\n     devices, the meanings of its parameters being specified\n \
    \    in   [14].    This   method   is  used  in  the  device\n     descriptions.\n\
    \     #define setdcte(name,intvec,devcsr,devbuf,devinit,\n         ioinit,intrpt,mate)\n\
    \       {04037,intrpt,0,0,name,mate,intvec,devinit,\n         devcsr,devbuf,ioinit}\n\
    \     4.2 The Devices\n       As mentioned in section 2,  apart  from  the  general\n\
    \     purpose  system console, there are three devices in the\n     system to\
    \ support the facsimile service. These are:\n      (1) AED62 Floppy Disk, which\
    \ is used as the  secondary\n          memory storing the facsimile image data.\
    \ Above its\n          driver, a file system is implemented to manage the\n  \
    \        data  stored  on  the disks, so that an image data\n          file can\
    \ be accessed through the Clean and  Simple\n          interface.  This file system\
    \ is dicussed in detail\n          in the next section. For some processing jobs,\
    \ the\n          image  data  has  to  buffered on a temporary file\n        \
    \  lest time-out occurs on the facsimile machine.\n      (2) DACOM Facsimile Machine,\
    \ which is  used  to  input\n          and  output  image  data.  It  reads  an\
    \ image and\n          creates the corresponding data  stream.  On  other\n  \
    \        hand, it accepts the image data and reproduces the\n          corresponding\
    \ image. Above its driver, there is  a\n          interface  task  to fit the\
    \ facsimile machine into\n          the system, the Clean and Simple  interface\
    \  being\n          supported.   The  encoding algorithm for the DACOM\n     \
    \     machine is described in [19].\n      (3) Grinnell Colour Display,  which\
    \  is  used  as  the\n          monitor  of  the  system.  Above  its  driver,\
    \  an\n          interface task is implemented so  that  the  image\n        \
    \  data  in  standard  format can be accepted through\n          the Clean and\
    \ Simple interface.\n       The detailed description  of  these  devices  can\
    \  be\n     found  in  Appendix  1.  The  interface  task  and  the\n     description\
    \ for each device are listed in the following\n     table. The interface tasks\
    \ can be directly used as data\n     source or sink in a task string.\n      \
    \     Device       Interface Task  Description\n     AED62 Floppy Disk       \
    \ fs()      aed62(device)\n     DACOM fax Machine       fax()      dacom(device)\n\
    \     Grinnell Display   grinnell()      grinnell(device)\n       Note that the\
    \ DCTs  for  the  facsimile  machine  and\n     Grinnell    display   have   been\
    \   included   in   the\n     corresponding interface tasks, so that there is\
    \ no need\n     to declare them if these tasks are used.\n     4.3 The Networks\n\
    \       There   are   three   relevant   wide-area   networks\n     terminating\
    \  in  the  Department of Computer Science at\n     the end of 1981. These are:\n\
    \      (1) A British Telecom X25 network (PSS, [24]).\n      (2) A private X25\
    \ network (SERC NET, [23])\n      (3) A Defence network (ARPANET/SATNET, [21],\
    \ [22])\n       In addition there is a  Cambridge  Ring  as  a  local\n     network.\n\
    \       For the time  being,  the  UCL  facsimile  system  is\n     directly \
    \ attached to the various networks at the point\n     NI (Network Interface) of\
    \ Fig. 1.\n       As mentioned earlier, pictures can be  exchanged  via\n    \
    \ the  SATNET/ARPANET,  between UCL in London, ISI in Los\n     Angeles, and COMSAT\
    \ in  Washington  D.C..  The  Network\n     Independent File Transfer Protocol\
    \ (NIFTP, [9]) is used\n     to transfer the image data.   This  protocol  has\
    \  been\n     implemented  on LSI under MOS [10].  In addition, we at\n     UCL\
    \ have put NIFTP on an ARPANET  TOPS-20  host,  which\n     can  act  as  an Internet\
    \ File Forwader (IFF).  In this\n     case, TCP/IP ([28], [29]) is employed as\
    \ the underlying\n     transport   service.   Since   TCP   provides  reliable\n\
    \     communication channels, the  provision  of  checkpoints\n     and  error-recovery\
    \  procedures are not included in our\n     NIFTP implementations.\n       In\
    \  the  X25  network,  the  transport  procedure  is\n     NITS/X25   ([25], \
    \  [26]).    Though  pictures  can  be\n     transferred to the X25 networks,\
    \ no  experimental  work\n     has been done, because:\n      (1) There is at\
    \ present no  collaborative  partner  on\n          these networks.\n      (2)\
    \ The LSI-11, on which our  system  is  implemented,\n          has no direct\
    \ connection to these networks.\n       Locally,  image  data  can  be  transmitted\
    \  to   the\n     PDP11-44s   running  the  UNIX  time-sharing  operating\n  \
    \   system. At present, the SCP ring-driver  software  uses\n     permanent  \
    \ virtual  circuits  (PVCs)  to  connect  the\n     various computers on the ring.\n\
    \     4.4 File System\n       A file system has been designed, based on  the \
    \ AED62\n     double  density  floppy  disk, for use under MOS. It is\n     itself\
    \ implemented as  a  MOS  process  supporting  the\n     Clean  and  Simple  interface.\
    \  The description of this\n     task, fs(fax), can be found in Appendix 2.\n\
    \       In a command string, the file system  task  can  only\n     serve  as\
    \  either  data  source  or data sink. In other\n     words, it can only appear\
    \ at the first or last position\n     on  a  command  string.  In  the  former\
    \ case, the file\n     specified is to be  read,  while  the  file  is  to  be\n\
    \     written in the latter case.\n       Three access modes are allowed which\
    \ are:\n       * Read a file\n       * Create a file\n       * Append a file\n\
    \       The file name and access mode are  specified  as  the\n     open parameters.\n\
    \       Let us consider an example.  If a document is  to  be\n     read  on \
    \ the  facsimile  machine  and  the data stream\n     created is to be stored\
    \ on the file system, the command\n     string required is:\n             fax\"\
    r|fs\"c,doc\n     where:  fax - interface task for facsimile machine\n       \
    \      r   - read from facsimile machine\n             fs  - file system task\n\
    \             c   - create a new file\n             doc - the name of the file\
    \ to be created.\n       In order to dump a  file,  a  task  process  od()  is\n\
    \     provided  which  works  as  a  data  sink  in a command\n     string.\n\
    \     4.5 Data Structure\n       Facsimile  image  data  is  created  using  a\
    \   high-\n     resolution raster scanner, so that the original picture\n    \
    \ can  be  reproduced  faithfully.  The  facsimile   data\n     represents  binary\
    \  images,  in  monochrome,  with  two\n     levels of intensity, belonging  to\
    \  the  data  type  of\n     bit-mapped graphics.\n       The simplest representation\
    \ is  the  bit-map  itself.\n     The bits, each of which corresponds to a single\
    \ picture\n     element, are arranged in the  same  order  as  that  in\n    \
    \ which  the original picture is scanned, 1s standing for\n     black pixels and\
    \ 0s for white ones. Operations  on  the\n     picture are easily carried out.\
    \ For example, two images\n     represented  in  the  bit-map  format  can  be\
    \   merged\n     together  by  using  a  simple  logic OR operation. Any\n   \
    \  specific  pixel  can   be   retrieved   by   a   simple\n     calculation.\
    \ However, its size is usually large because\n     of  the  high  resolution.\
    \   This   makes   it   almost\n     unrealistic for storage or transmission.\n\
    \       Facsimile image data should therefore  be  compressed\n     to reduce\
    \ its redundancy, so that the efficient storage\n     and transmission can be\
    \ achieved.\n       Run-length encoding is a useful  compression  scheme.\n  \
    \   Instead of the pattern, the counts of consecutive black\n     and white runs\
    \ are used to represent the image.\n       Vector representation, in which the\
    \  run-lengths  are\n     coded  as  integers  or  bytes,  is  a  useful internal\n\
    \     representation of images. Not  only  is  it  reasonably\n     compressed,\
    \  but  it is also quite easy for processing.\n     Chopping, scaling and mask-scanning\
    \ are examples of the\n     processing   operations   which   may   be   performed.\n\
    \     Furthermore, a conversion between different compression\n     schemes  may\
    \  have to be carried out in such a way that\n     the data is first decompressed\
    \ into the  vector  format\n     and  then recompressed. The difficulty in retrieval\
    \ can\n     be overcome by means of line  index,  which  gives  the\n     pointers\
    \ to each lines of the image.\n       A higher compression rate leads to a  more\
    \  efficient\n     transmission.  But  this  is  at the expense of ease of\n \
    \    processing.  An example of this is the use  of  Huffman\n     Code  in  the\
    \  CCITT  1-dimensional compression scheme.\n     While the data can be compressed\
    \ more  efficiently,  it\n     is rather difficult to manipulate the data direcltly.\n\
    \       Taking the correlation between  adjacent  lines  into\n     account, \
    \ 2-dimensional compression can achieve an even\n     higher   compression   \
    \ rate.    CCITT    2-dimensional\n     compression  and  the  DACOM facsimile\
    \ machine use this\n     method.\n       It is desirable to integrate  facsimile\
    \  images  with\n     other  data types, such as text and geometric graphics;\n\
    \     the  structure  of  these  other  types  must  then  be\n     incorporated\
    \  in  the  system.  At  present,  only text\n     structure  is  available, \
    \ while  the   structure   for\n     geometric graphics is a topic for the further\
    \ study.\n       In  the  facsimile   system,   the   following   data\n     structures\
    \    are    supported.    The    corresponding\n     descriptions, if any, are\
    \ listed as well and  they  can\n     be found in Appendix 3 (except of dacom(device)).\n\
    \     type    structure       compression     description\n     bit-map  bit-map\
    \               -              -\n             vector          1D run-length \
    \  vector(fax)\n             dacom block     2D run-length   dacom(device)\n \
    \            CCITT T4        1D run-length   t4(fax)\n                       \
    \      2D run-length   t4(fax)\n     text    text                  -         text(fax)\n\
    \       As an  internal  data  structure,  vector  format  is\n     widely  used\
    \  for data transfer between task processes.\n     The set of interface  routines\
    \  has  been  extended  by\n     introducing  two subroutines, namely getl() and\
    \ putl(),\n     which read and write line vectors directly through  the\n    \
    \ Clean  and  Simple interface. These two routines can be\n     found in Appendix\
    \ 3 (getl(fax) and putl(fax))\n       In order to check the validity of a  vector\
    \  file,  a\n     check task process check() is provided which works as a\n  \
    \   data sink in a command string. It  can  also  dump  the\n     vector elements\
    \ of the specific lines.\n     4.6 Data Conversion\n       In order to convert\
    \ one data structure into  another,\n     several conversion modules are provided\
    \ in this system.\n     These modules fall into two categories, task  processes\n\
    \     and  subroutines.  The task processes are MOS processes\n     which can\
    \ only be used in the environment described  in\n     this note, while the subroutines\
    \ which are written in c\n     and compatible under UNIX are more generally usable.\n\
    \       Character strings  or  text  can  be  converted  into\n     vector  format,\
    \  so  that an integrated image combining\n     picture and text can be formed.\n\
    \       The following table lists these  conversion  modules,\n     including\
    \  their  functions and descriptions (which can\n     be found in Appendix 3).\n\
    \     module  type          from          to      description\n     decomp  process\
    \       dacom         vector   decomp(fax)\n     recomp  process       vector\
    \        dacom    recomp(fax)\n     ccitt   process       vector        t4   \
    \    ccitt(fax)\n                           t4            vector\n     bitmap\
    \  subroutine    vector        bitmap    bit-map(fax)\n     tovec   subroutine\
    \    bitmap        vector    tovec(fax)\n     ts      subroutine    ASCII string\
    \  vector   ts(fax)\n     string  process       ASCII string  vector   string(fax)\n\
    \     tf      process       text          vector   tf(fax)\n       Since each\
    \ DACOM block contains a  Cyclic  Redundancy\n     Check  (CRC)  field,  the \
    \ system supplies a subroutine\n     crc()  to  calculate  or  check  the  CRC\
    \  code.   (see\n     crc(fax))\n       If a vector file  is  to  be  printed\
    \  on  the  DACOM\n     facsimile   machine,  the  image  data  should  be  re-\n\
    \     compressed into the DACOM-block  format,  the  required\n     command string\
    \ being shown below.\n     fs\"e,pic|recomp|fax\"w\n     where   fs     - file\
    \ system task\n             e      - read an existing file\n         ic    - file\
    \ name\n             recomp - re-compression task\n             fax    - interface\
    \ task for facsimile machine\n             w      - print an image on facsimile\
    \ machine\n     4.7 Image Manipulation\n       Four processing task processes\
    \ are  provided  in  the\n     system.  These are:\n      (1) Chop, which applies\
    \ a defined window to the  input\n          image.\n      (2) Scale, which enlarges\
    \ or shrinks the  input  image\n          to the defined dimensions.\n      (3)\
    \ Merge, which puts the input image on the specified\n          area of a background\
    \ image.\n      (4) Clean, which removes the noise on the input image.\n     \
    \  The Clean and  Simple  interfaces  are  supported  in\n     these processing\
    \ tasks so that the tasks can be used in\n     command strings.  However, these\
    \ tasks can  be  neither\n     source  nor  sink in a command string.  The data\
    \ format\n     of their input and output is vector.\n       For example, a facsimile\
    \ page can be cleaned and then\n     printed  on  the facsimile machine. Note\
    \ that the image\n     data must be recompressed  before  being  sent  to  the\n\
    \     facsimile  machine. If the original data is the form of\n     DACOM  block,\
    \  it  has  to  be  decompressed   as   the\n     processing   tasks   only  accept\
    \  line  vectors.   The\n     required command string is shown below.\n     fs\"\
    e,page|clean|recomp|fax\"w\n     where   fs     - file system task\n         \
    \    e      - read an existing file\n             page   - file name\n       \
    \      clean  - cleaning task\n             recomp - re-compression task\n   \
    \          fax    - interface task for facsimile machine\n             w     \
    \ - print an image on facsimile machine\n       The descriptions of these  processing\
    \  tasks  can  be\n     found in Appendix 2 (chop(fax), scale(fax), merge(fax),\n\
    \     and clean(fax)).\n       In tasks 'chop' and  'merge',  a  window  is  set\
    \  by\n     giving  the coordinates of its vertices. However, it is\n     usually\
    \ rather difficult for a human user to decide the\n     exact  coordinates.  The\
    \  system  supplies a subroutine\n     choice() which specifies a rectangular\
    \ subsection of an\n     image  by  interactive  manipulations  of a rectangular\n\
    \     subsection  on  the  screen  of  the  Grinnell  display\n     displaying\
    \ the image.  It provides a set of interactive\n     commands whereby a user can\
    \ intuitively choose an  area\n     he  is interested in. Note that this subroutine\
    \ must be\n     called by a MOS process and the Grinnell  display  must\n    \
    \ be included in the system.\n       By means of these image processing modules,\
    \ the image\n     editing  described  in  section 2.4 can be carried out.\n  \
    \   Let us consider an example. An image abstracted from  a\n     picture  'a'\
    \  is  to be merged onto a specified area of\n     another picture 'b'. First\
    \ of all, the two pictures 'a'\n     and 'b' should be displayed on the left half\
    \ and  right\n     half  of  the screen, respectively. Assume that the two\n \
    \    pictures are standard DACOM pages whose dimensions  are\n     1726x1200.\
    \  They have to be shrunk to fit the dimension\n     of the half screen (256x512).\
    \  Note that  if  the  data\n     format  is not vector, conversion should be\
    \ carried out\n     first.  the required command strings are:\n   e,a|scale\"\
    1726,1200,256,512|grinnell\"0,511,255,0,z,g\n     fs\"e,b|scale\"1726,1200,256,512|grinnell\"\
    256,511,511,0,z,b\n     where   fs            - file system task\n           \
    \  e             - read an existing file\n             a             - file name\n\
    \             b             - file name\n             scale         - scale task\n\
    \             1726,1200     - old dimension\n             256,512       - new\
    \ dimension\n             grinnell       - grinnell display interface task\n \
    \            0,511,255,0   - presentation area (the left half)\n             256,511,511,0\
    \ - presentation area (the right half)\n             z             - zero write\
    \ mode\n             g             - green\n             b             - blue\n\
    \       In an application process, the subroutine choice() is\n     called in\
    \ the following ways for the user to choose the\n     areas on both pictures.\n\
    \     choice(r, 1726, 1200, 1, 0, 0);\n             /* choice the area on 'a'\
    \ */\n             /* r    - red\n                1726 - width of the original\
    \ picture\n                1200 - height of the original picture\n           \
    \     1    - left half of the screen\n                0    - the subsection can\
    \ be of any width\n                0    - the subsection can be of any height\n\
    \              */\n     choice(r, 1726, 1200, 2, 0, 0);\n             /* choice\
    \ the area on 'b' */\n             /* r    - red\n                1726 - width\
    \ of the original picture\n                1200 - height of the original picture\n\
    \                2    - right half of the screen\n                0    - the subsection\
    \ can be of any width\n                0    - the subsection can be of any height\n\
    \              */\n       When the user finishes editing,  the  coordinates  of\n\
    \     the  chosen  rectangular areas are returned. An example\n     is given in\
    \ the table below.  The  widths  and  heights\n     listed  in  the  table are\
    \ actually calculated from the\n     coordinates returned and they indicate that\
    \ the  source\n     image has to be enlarged to fit its destination.\n       \
    \       (0, 0)\n                +-------------------------------> x\n        \
    \        |\n                |  (x0, y0)     w\n                |     +--------------------+\n\
    \                |     !                    !\n                |     !       \
    \             !\n                |     !                    ! h\n            \
    \    |     !                    !\n                |     !                   \
    \ !\n                |     +--------------------+\n                |         \
    \              (x1, y1)\n                V\n                y\n     original \
    \  x0      y0      x1      y1      w       h\n        a       30      40     100\
    \     120      70      80\n        b      100     100    1100    1100    1000\
    \    1000\n       At this stage, our final  goal  can  be  achieved  by\n    \
    \ performing  a  job  specified below. It is assumed that\n     the result image\
    \ is to be stored as a new file 'c'.\n     fs\"e,a|chop\"30,40,100,120|scale\"\
    70,80,1000,1000\n         |merge\"b,0,100,100,1100,1100|fs\"c,c\n     where  \
    \ fs                - file system task\n             e                 - read\
    \ an existing file\n             a                 - file name\n             chop\
    \              - chop task\n             30,40,100,120     - the area to be abstracted\n\
    \             scale             - scale task\n             70,80             -\
    \ old dimension\n             1000,1000         - new dimension\n            \
    \ merge             - merge task\n             b                 - file name of\
    \ the background image\n             0                 - to be overlaid\n    \
    \         100,100,1100,1100 - the area to be overlaid\n             fs       \
    \         - file system task\n             c                 - create a new file\n\
    \             c                 - the name of the file to be\n               \
    \                  created\n     4.8 Data Transmission\n       In  order  to \
    \ transmit  facsimile  image  data  over\n     computer  networks,  using the\
    \ configuration of Fig. 1,\n     the Network Independent File Transfer Protocol\
    \  [9]  is\n     implemented as a MOS task process, the Clean and Simple\n   \
    \  interface of section 3.3  being  supported  [10].  Thus\n     this  module\
    \  can be used in a command string directly.\n     In this case, the module always\
    \ works in the  initiator\n     mode,  though the server mode is supported as\
    \ well. Its\n     description can be found in Appendix 2 (ftp(fax)).\n       As\
    \  a  network-independent  protocol,  it  employs  a\n     transport  service\
    \  to communicate across the networks.\n     The Clean and Simple interface is\
    \  also  used  for  the\n     communication  between the module and transport\
    \ service\n     processes.\n       Suppose that an image file stored in  a  remote\
    \  file\n     system is to be printed on the local facsimile machine.\n     Assume\
    \ that the data is  transmitted  via  the  ARPANET\n     [21],  Transport Control\
    \ Protocol (TCP) [28] being used\n     as the underlying transport service. As\
    \  was  described\n     before, since the  delay  caused  by  the  network  may\n\
    \     result  in  a  time-out on the local facsimile machine,\n     the job should\
    \ be divided into two subjobs.\n      (1) The remote file  is  transmitted  by\
    \  using  NIFTP\n          module.   However,  instead  of  being  put on the\n\
    \          facsimile machine directly, the received  data  is\n          store\
    \ in a temporary file.\n          ftp\"r,b,ucl,fax,pic;tcp:1234,10,3,3,42,4521|fs\"\
    c,tmp\n          where   ftp - NIFTP task\n                  t   - receive\n \
    \                 b   - binary\n                  ucl - remote user name\n   \
    \               fax - remote password\n                  pic - remote file name\n\
    \                  tcp - transport service process\n                  parameters\
    \ for the transport service:\n                      1234      - local channel\
    \ number\n                      10,3,3,42 - remote address\n                 \
    \     4521      - channel reserved for the\n                                 \
    \ remote server\n                  fs  - local file system task\n            \
    \      c   - create a new file\n                  tmp - the name of the file to\
    \ be created\n      (2) The temporary file is read and the image  is  sent\n \
    \         to  the facsimile machine for printing. Here it is\n          assumed\
    \ the data received is in the form of  DACOM\n          block so that no conversion\
    \ is needed.\n          fs\"e,tmp|fax\"w\n          where   fs     - file system\
    \ task\n                  e      - read an existing file\n                  tmp\
    \    - file name\n                  fax    - interface task for facsimile machine\n\
    \                  w      - print an image on facsimile machine\n       We are\
    \ able to  exchange  image  data  with  ISI  and\n     COMSAT.  At present DACOM\
    \ block is the only format that\n     can be used as  all  the  three  participants\
    \  in  this\n     experiment  possess  DACOM  facsimile  machines  and no\n  \
    \   other data format is available in both ISI and  COMSAT.\n     However,  it\
    \  is  the  intention  of the ARPA-Facsimile\n     community to adopt the CCITT\
    \ standard for future  work.\n     As mentioned earlier, UCL already has this\
    \ facility.\n       Above NIFTP, a simple protocol was  used  to  control\n  \
    \   the  transmission  of facsimile data. In this protocol,\n     the format of\
    \ a facsimile  data  file  was  defined  as\n     follows:  Each  DACOM  block\
    \ was recorded with a 2-byte\n     header at the front. This  header  was  composed\
    \  of  a\n     length-byte   indicating   the   length  of  the  block\n     (including\
    \ the header) and a code-byte  indicating  the\n     type  of  the  block.  This\
    \  is  shown in the following\n     diagram.\n             |<--- header ---->|<------\
    \ 74 bytes ------->|\n             +--------+--------+-------------------------+\n\
    \             ! length !  code  !       DACOM block       !\n             +--------+--------+-------------------------+\n\
    \       The Length-byte is 76 (decimal) for all DACOM blocks.\n     The  code-byte\
    \ for a setup block is 071 (octal) and 072\n     for a data block. A  special\
    \  EOP  block  was  used  to\n     indicate  the  end  of  a page. This block\
    \ had only the\n     header with the length-byte set to 2 and the  code-byte\n\
    \     undefined.  A facsimile data file could contain several\n     pages, which\
    \ were separated by EOP blocks.\n     5. CONCLUSION\n     5.1 Summary\n      \
    \ Though techniques  for  facsimile  transmission  were\n     invented  in  1843,\
    \  it  was not until the recent years\n     that integration with  computer  communication\
    \  systems\n     gave rise to \"great expectation\".  The system described\n \
    \    in  this  note   incarnates   the   compatibility   and\n     flexibility\
    \ of computerised facsimile systems.\n       In this system, facsimile no longer\
    \ refers simply  to\n     the  transmission device, but rather to the function\
    \ of\n     transferring hard copy from one place to another.   Not\n     only\
    \  does  the  system  allow  for  more  reliable and\n     accurate document transmission\
    \ over  computer  networks\n     but  images  can  also  be  manipulated electronically.\n\
    \     Image is converted from one  representation  format  to\n     another, \
    \ so that different makes of facsimile machines\n     can communicate with each\
    \ other.  It is possible for  a\n     picture to be presented on different  bit-map\
    \  devices,\n     e.g.  TV-like  screen,  as it can be scaled to overcome\n  \
    \   the incompatibilities.  Moreover, the  system  provides\n     windowing  \
    \ and   overlaying   facilities   whereby   a\n     sophisticated editor can be\
    \ supported.\n       One of the most important aspects of this  system  is\n \
    \    that   text   can  be  converted  into  its  bit-mapped\n     representation\
    \ format  and  integrated  with  pictures.\n     Geometric  graphics  could  also\
    \  be  included  in  the\n     system. Thus, the facsimile  machine  may  serve\
    \  as  a\n     printer  for  multi-type  documents.  It  is clear that\n     facsimile\
    \  will  play  an  important  role  in   future\n     information processing system.\n\
    \       As far  as  the  system  per  se  is  concerned,  the\n     following\
    \  advantages  can  be  recognised.  Though our\n     discussion is concentrated\
    \  on  the  facsimile  system,\n     many  features  developed  here  apply  equally\
    \ well to\n     other information-processing systems.\n      (1)  Flexibility:\
    \  The  user  jobs   can   be   easily\n          organised.  The  only  thing\
    \  to  be done for this\n          purpose is to  make  the  logical  links  for\
    \  the\n          appropriate task processes.\n      (2) Simplicity: The interface\
    \ routines are responsible\n          for  the  operations  such  as signal handling\
    \ and\n          buffer management.  By avoiding this  burden,  the\n        \
    \  implementation  of the task processes becomes very\n          \"clean and simple\"\
    .\n      (3) Portability: The interface routines also makes the\n          task\
    \   processes   totally   independent   of  the\n          operating environment.\
    \  Only these routines should\n          be modified if the environment were changed.\n\
    \      (4) Ease of extension: The power of the system can  be\n          simply\
    \  and infinitely extended by adding new task\n          processes.\n      (5)\
    \ Distributed  Environment:  This  approach  can  be\n          easily  extended\
    \  to  a  distributed  environment,\n          where limitless hardware  and \
    \ software  resources\n          can be provided.\n     5.2 Problems\n       As\
    \ discussed earlier, the network we were  using  for\n     the  experimental \
    \ work was not designed for image data\n     transmission.  The data transfer\
    \  is  so  slow  that  a\n     time-out may be caused on the facsimile machine.\
    \ Though\n     this problem was solved by means of local buffering and\n     pictures\
    \  were successfully exchanged over the network,\n     the slowness is rather\
    \  disappointing  because  of  the\n     quantity of image data. The measurement\
    \ showed that the\n     throughput was around 500 bits/sec. In other words,  it\n\
    \     took  at  least  5 minutes to transfer a page. This was\n     caused by\
    \ the network but not our system. The situation\n     has been improved recently.\
    \ However, It is nevertheless\n     required that more  efficient  compression\
    \  schemes  be\n     developed.\n       At present, the system must be directly\
    \  attached  to\n     the  network to be accessed. However, the network ports\n\
    \     are much demanded, so that frequent reconfiguration  is\n     required.\n\
    \       The facsimile system can be  connected  only  to  the\n     local  network,\
    \  the  Cambridge Ring, while the foreign\n     networks are connected via gateways\
    \ to the  ring.  This\n     is shown in Fig. 12. Now the X25 network is attached\
    \ to\n     the Ring via an X25 gateway, XG [25], while  SATNET  is\n     connected\
    \ by another gateway, SG [25]. Both network are\n     at the transport level;\
    \ XG and SG support the  relevant\n     transport  procedures.  In  the  case\
    \  of  XG,  this is\n     NITS/X25 ([26], [27]); in the case  of  SATNET,  it\
    \  is\n     TCP/IP ([28], [29]).\n     UCL facsimile\n       system          -\
    \ - - - - - - -\n     +--------+      /                 \\      +------+\n   \
    \  !        ! ----    Cambridge Ring   ---- !  PE  !\n     +--------+      \\\
    \                 /      +------+\n                       - - - - - - - -    \
    \        |\n                         /         \\              |\n           \
    \        +------+       +------+        |\n                   !  XG  !       !\
    \  SG  ! --- SATNET\n                   +------+       +------+\n            \
    \       /       \\\n                 PSS    SERC NET\n          Fig. 12  Schematic\
    \ of UCL network connection\n       When the network software runs in the same\
    \ machine as\n     the   application   software,   the  Clean  and  Simple\n \
    \    interface of section  3.5  was  used  as  an  interface\n     between  the\
    \  modules.  When  the  gateway software was\n     removed to a separate machine,\
    \ an Inter-Processor Clean\n     and  Simple  [30]  was   required.    The   appropriate\n\
    \     transport   process  is  transferred  to  the  relevant\n     gateway, and\
    \ appropriate facilities are implemented for\n     addressing   the   relevant\
    \   gateway.  Otherwise,  the\n     software has to be little  altered  to  cater\
    \  for  the\n     distributed case.\n       In our experimental work, the following\
    \ problems were\n     also encountered.\n      (1) The primary memory of the LSI-11\
    \ is so small  that\n          we  cannot  build  up  a system to include all\
    \ the\n          modules we have developed.  In order  to  transfer\n        \
    \  an  edited picture using the NIFTP module, we have\n          to first  load\
    \  an  editor  system  to  input  and\n          process  the  picture, and then\
    \ an NIFTP system is\n          then loaded to transmit it.\n      (2) The execution\
    \ of  an  image  processing  procedure\n          becomes  very  slow. For example,\
    \ it takes several\n          minutes to shrink a picture to fit the  screen \
    \ of\n          the  Grinnell  display.  This  prevents the system\n         \
    \ from being widely used in its present form.\n      (3) As secondary storage,\
    \ floppy disks  are  far  from\n          adequate  to keep image data files.\
    \ At present, we\n          have two double-density floppy  disk  drives,  the\n\
    \          capacity  of  each  disk  being  about 630K bytes.\n          However,\
    \ an image page contains at least 50K bytes\n          and,  sometimes,  this\
    \ number may be doubled for a\n          rather complex picture.  Only a limited\
    \ number  of\n          pages can be stored.\n       On the other hand, in our\
    \  department,  we  have  two\n     PDP11-44s   running  UNIX  together  with\
    \  large  disks\n     supplying abundant file storage. Their processing speed\n\
    \     is  much  higher  than  that of the LSIs. The UNIX file\n     system  supports\
    \   a   very   convenient   information-\n     management environment. This inspired\
    \ the idea that the\n     UNIX file system could pretend  to  be  a  file  server\n\
    \     responsible for storing and managing the image data, so\n     that all the\
    \ processing tasks may  be  carried  out  on\n     UNIX. Not only does this immediately\
    \ solve the problems\n     listed above, but the following  additional  advantages\n\
    \     immediately accrue.\n      (1) UNIX provides a  far  better  software-development\n\
    \          environment than LSI MOS ever can or will.\n      (2) The facsimile\
    \ service can be enhanced to  be  able\n          to support many users at a time.\n\
    \      (3) The UNIX file system is so sophisticated that more\n          complex\
    \ data entities can be handled.\n       In  fact  the  44s  and  the  LSI-11,\
    \  to  which  the\n     facsimile  machine  and  Grinnell display are attached,\n\
    \     are  all  connected  to  the  UCL  Cambridge  Ring.   A\n     distributed\
    \  processing  environment  can  be  built up\n     where a job in one computer\
    \ can be initiated by another\n     and  then the job will be carried out by cooperation\
    \ of\n     both computers.\n       In such  a  distributed  system,  the  LSI-11\
    \  micro-\n     computer,   together   with   the   facsimile  machine,\n    \
    \ constitutes  a   totally   passive   facsimile   server\n     controlled  by\
    \  a  UNIX  user.  A  page  is read on the\n     facsimile machine and the image\
    \ data stream produced is\n     transmitted to the UNIX via the ring. The image\
    \ data is\n     stored  as  a  UNIX  file  and  may  be  processed   if\n    \
    \ necessary.  It  can  also  be  sent via the ring to the\n     facsimile server\
    \ where it  will  be  reprinted  on  the\n     facsimile machine.\n       In order\
    \ to build up such a distributed  environment,\n     IPCS  [30] is far from adequate\
    \ for this purpose, as it\n     does not provide any facility for a remote  job\
    \  to  be\n     organised.  In  our  system, the task controller can be\n    \
    \ modified so that the command strings  can  be  supplied\n     from  a remote\
    \ host on the network. Having accepted the\n     request, the task  controller\
    \  organises  the  relevant\n     task  chain and the requested job is executed\
    \ under its\n     control.  The execution  of  the  distributed  job  may\n  \
    \   require  synchronisation  between  the  two  computers.\n     These problems\
    \ are discussed in detail in [31].\n       Generally speaking, a distributed system\
    \ based  on  a\n     local network, which supplies cheap, fast, and reliable\n\
    \     communication, could be the ultimate  solution  of  the\n     operational\
    \ problems discussed in this section. In such\n     a system, different system\
    \ operations are  carried  out\n     in the most suitable places.\n       For\
    \ the time being, only a  procedure-oriented  task-\n     control  language  is\
    \  available  in  this system.  The\n     command string of the fitter  can  be\
    \  typed  from  the\n     system  console  directly,  the corresponding job being\n\
    \     organised and executed.  Theoretically, this  is  quite\n     enough   to\
    \  cope  with  any  requirement  of  a  user.\n     However,  when  the  job \
    \ is  complex,  command  typing\n     becomes very tedious and prone to error.\n\
    \       Above the task-controller, a job-controller layer  is\n     required \
    \ which  provides  a  problem-oriented language\n     whereby the user can easily\
    \ put forward his requirement\n     to  the  system.  On receipt of such a command,\
    \ the job\n     controller translates it into a command string  of  the\n    \
    \ task  controller  and  passes  the  string  to the task\n     controller so\
    \  that  operation  request  can  be  done.\n     Sometimes,  one  job  has  to\
    \  be  divided into several\n     subjobs, which are to be dealt  with  separately.\
    \   The\n     job  controller  should  be  also  responsible for high\n     level\
    \ calculation and management, so that the user need\n     not be concerned with\
    \ system details.\n       In the  system  supporting  facsimile  service  under\n\
    \     UNIX,  a  set  of high-level command is provided, while\n     the command\
    \  strings  for  the  facsimile  station  are\n     arranged automatically and\
    \ they are totally hidden from\n     a UNIX user.\n     5.3 Future Study\n   \
    \    At the next stage, our attention should be moved to a\n     higher-level,\
    \  more sophisticated system which supports\n     a multi-type environment. In\
    \ such a  system,  not  only\n     does   the  facsimile  machine  work  as  an\
    \  facsimile\n     input/output device, but it should also play  the  role\n \
    \    of  a  printer  for  the  multi-type  document. This is\n     because other\
    \ data types, e.g. coded character text and\n     geometric  graphics  can  be\
    \ easily converted into bit-\n     mapped graphics format which the facsimile\
    \  machine  is\n     able to accept.\n       First of all, a data structure should\
    \ be designed  to\n     represent  multi-type  information.  In  a  distributed\n\
    \     environment, such a structure should be understood  all\n     over  the\
    \  system,  so  that multi-media message can be\n     exchanged.\n       In a\
    \ future  system,  different  services  should  be\n     supported,   including\
    \  viewdata,  Teletex,  facsimile,\n     graphics,  slow-scan  TV  and  speech.\
    \  The  techniques\n     developed  for facsimile will be generalised for use\
    \ of\n     other bit-mapped image representations, such  as  slow-\n     scan\
    \ TV.\n       To improve the performance of the  facsimile  system,\n     we \
    \ are  investigating  how  we  could use an auxiliary\n     special purpose processor\
    \ to perform some of the  image\n     processing   operations.   Such  a  processor\
    \  will  be\n     essential for the higher data rate  involved  in  slow-\n  \
    \   scan TV.\n                            Reference\n      [1] P. T. Kirstein,\
    \ \"The Role of Facsimile in Business\n          Communication\", INDRA Note 1047,\
    \ Jan. 1981.\n      [2]  T.  Chang,  \"A  Proposed  Configuration  of   the\n\
    \          Facsimile station\", INDRA Note 922, May, 1980.\n      [3] T.  Chang,\
    \  \"Data  Structure  and  Procedures  for\n          Facsimile Signal Processing\"\
    , INDRA Note 923, May,\n          1980.\n      [4] S. Treadwell,  \"On  Distorting\
    \  Facsimile  Image\",\n          INDRA Note No 762, June, 1979.\n      [5] M.\
    \ G. B. Ismail and R.  J.  Clarke,  \"A  New  Pre-\n          Processing   Techniques\
    \   for   Digital  Facsimile\n          Transmission\", Dept.  of  Electronic\
    \  Engineering,\n          University of Technology, Loughborough.\n      [6]\
    \  T.  Chang,  \"Mask  Scanning  Algorithm  and   Its\n          Application\"\
    , INDRA Note 924, June, 1980.\n      [7] M. Kunt and O. Johnsen, \"Block Coding\
    \ of Graphics:\n          A  Tutorial  Review\",  Proceedings  of  the  IEEE,\n\
    \          special issue on  digital  encoding  of  graphics,\n          Vol.\
    \ 68, No 7, July, 1980.\n      [8]  T.  Chang,   \"Facsimile   Data   Compression\
    \   by\n          Predictive  Encoding\",  INDRA  Note  No  978, May.\n      \
    \    1980.\n      [9] High Level Protocol Group, \"A Network  Independent\n  \
    \        File  Transfer  Protocol\",  HLP/CP(78)1, alos INWG\n          Protocol\
    \ Note 86, Dec. 1978.\n     [10] T. Chang, \"The Implementation of NIFTP on LSI-11\"\
    ,\n          INDRA Note 1056, Mar. 1981.\n     [11] T. Chang, \"The  Design  and\
    \  Implementation  of  a\n          Computerised  Facsimile  System\",  INDRA\
    \  Note No.\n          1184, Apr. 1981.\n     [12] T. Chang, \"The Facsimile Editor\"\
    , INDRA Note 1085,\n          Apr. 1981.\n     [13]  K.  Jackson,  \"Facsimile\
    \   Compression\",  Project\n          Report,  Dept.  of  Computer  Science,\
    \  UCL, June,\n          1981.\n     [14] R. Cole and S. Treadwell, \"MOS User\
    \ Guide\",  INDRA\n          Note 1042, Jan. 1981.\n     [15] CCITT,  \"Recommendation\
    \  T.4,  Standardisation  of\n          Group   3   Facsimile   Apparatus   for\
    \   Document\n          Transmission\", Geneva, 1980.\n     [16]  \"DACOM  6450\
    \  Computerfax  Transceiver   Operator\n          Instructions\", DACOM, Mar.\
    \ 1977.\n     [17] \"AED 6200LP Floppy Disk Storage System\", Technical\n    \
    \      Manual,  105499-01A,  Advanced Electronics Design,\n          Inc. Feb.\
    \ 1977.\n     [18] \"The User Manual for Grinnelll Colour Display\".\n     [19]\
    \ D. R. Weber,  \"An  Adaptive  Run  Length  Encoding\n          Algorithm\",\
    \ ICC-75.\n     [20] R. Braden and P. L. Higginson, \"Clean  and  Simple\n   \
    \       Interface  under  MOS\",  INDRA Note No. 1054, Feb.\n          1981.\n\
    \     [21] L. G. Roberts et al, \"The ARPA Computer  Network\",\n          Computer\
    \  Communication  Networks,  Prentice Hall,\n          Englewood, pp485-500, 1973.\n\
    \     [22] I. M. Jacobs et  al:  \"General  Purpose  Satellite\n          Network\"\
    ,   Proc.   IEEE,   Vol.   66,   No.   11,\n          pp1448-1467, 1978.\n   \
    \  [23] J.  W.  Burren  et  al,  \"Design  fo  an  SRC/NERC\n          Computer\
    \   Network\",   RL   77-0371A,   Rutherford\n          Laboratory, 1977.\n  \
    \   [24] P. T. F.  Kelly,  \"Non-Voice  Network  Services  -\n          Future\
    \     Plans\",     Proc.     Conf.    Business\n          Telecommunications,\
    \ Online, pp62-82, 1980.\n     [25] P. T. Kirstein, \"UK-US  Collaborative  Computing\"\
    ,\n          INDRA Note No. 972, Aug. 1980.\n     [26] \"A Network  Independent\
    \  Transport  Service\",  PSS\n          User   Forum,  Study  Group  3,  British\
    \  Telecom,\n          London, 1980.\n     [27] CCITT, Recommendation X3,  X25,\
    \  X28  and  X29  on\n          Packet Switched Data Services\", Geneva 1978.\n\
    \     [28]  \"DoD  Standard  Transmission  Control  Protocol\",\n          RFC761,\
    \  Information  Sciences  Inst.,  Marina del\n          Rey, 1979.\n     [29]\
    \  \"DoD   Standard   Internet   Protocol\",   RFC760,\n          Information\
    \ Sciences Inst., Marina del Rey, 1979.\n     [30] P. L. Higginson, \"The Orgainisation\
    \ of the Current\n          IPCS System\", INDRA Note No. 1163, Oct. 1981.\n \
    \    [31] T. Chang, \"Distributed Processing for  LSIs  under\n          MOS\"\
    , INDRA Note No. 1199, Jan. 1982.\n                             - 50 -\n"
- title: UCL FACSIMILE SYSTEM                              INDRA Note 1185
  contents:
  - "UCL FACSIMILE SYSTEM                              INDRA Note 1185\n         \
    \            Appendix I: Devices\n"
- title: NAME
  contents:
  - "NAME\n     aed62 - double density floppy disk\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     DCT aed62\n     setdct(\"aed62\", 0170, 0170450, 0170450,\n  \
    \           aedini, aedsio, aedint, 0);\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     The Double Density disks contain 77 tracks numbered  from \
    \ 0\n     to  76.  There  are 16 sectors (sometimes called blocks) per\n     track,\
    \ for a total of 1232 sectors on each side of the disk.\n     These  are  numbered\
    \  0  to  1231.  Each sector contains 512\n     bytes, for a total of 630,784\
    \ bytes  on  each  side  of  the\n     floppy.\n     Only one side of the floppy\
    \ can be accessed at a time. There\n     is  only one head per drive, and it is\
    \ located on the under-\n     side of the disk. To access the other side, the\
    \ disk must be\n     manually removed and inserted the other way up.\n     Each\
    \ block is actually two blocks on the disk:  an  adddress\n     ID  block  and\
    \ the data block.  The address ID block is used\n     by the hardware and contains\
    \ the  track  number,  the  block\n     number and the size of the data block\
    \ that follows.  When an\n     operation is to take place, the seek mechanism\
    \ first locates\n     the  block  by  reading  the address ID blocks and literally\n\
    \     'hunting' for the correct one. It will  hunt  for  up  to  2\n     seconds\
    \ before reporting a failure.\n     Both the address ID and the data blocks are\
    \  followed  by  a\n     checksum word that is maintained by the hardware and\
    \ is hid-\n     den from the user. On writing, the  checksum  is  calculated\n\
    \     and  appended  to the block. On reading it is verified (both\n     on reading\
    \ the ID and data blocks) and any error is reported\n     as  a  Data Check. No\
    \ checking on the data block takes place\n     on a write, and the hardware has\
    \ no idea if it  was  written\n     correctly. The only way to verify it is to\
    \ read it.\n     Although there are two drives in the unit,  they  cannot  be\n\
    \     used  simultaneously. If an operation is in progress on one,\n     no access\
    \ can be made to the other until the first operation\n     is  complete. The driver\
    \ will queue requests for both drives\n     however, and ensure that are performed\
    \ in order.\n     irfnc\n          The operation to be performed, as follows:\n\
    \                          0 - Read\n                          1 - Write\n   \
    \                       2 - Verify\n                          3 - Seek\n     \
    \     Read and Write cause data to be transferred to and from\n          disk.\
    \  Verify does a hardware read without transferring\n          the data to memory\
    \ and is used for verifying  that  the\n          data  can be successfully read.\
    \ The checksum at the end\n          of  the  block  of  each  sector  is  verified\
    \  by  the\n          hardware.  The  seek  command  is used to move the disk\n\
    \          heads to a specified track.\n     irusr1\n          The drive number.\
    \ Only Zero or One is accepted. This is\n          matched  against the number\
    \ dialed on the drive. If the\n          number is specified  on  both  drives,\
    \  or  neither,  a\n          hardware error will be reported.\n     irusr2\n\
    \          The Sector or Block Number. Must be in the range  0  to\n         \
    \ 1231 inclusive.  irusr2 specifies the block number that\n          the transfer\
    \ is to begin at for Read and Write, the be-\n          ginning  of  the  verified\
    \ area for the Verify command,\n          and the position of the head for the\
    \ Seek  command.  In\n          the  latter  case  the  head  will be positioned\
    \ to the\n          track that contains the block.\n     iruva\n          This\
    \ specifies the data  adress,  which  must  be  even\n          (word  boundary).\
    \   If an odd address is given, the low\n          order bit is set to zero to\
    \ make it even. Not  required\n          for the Seek or Verify commands.\n  \
    \   irbr\n          Transfer length as a positive number of bytes. Not  re-\n\
    \          quired for the seek command, bit IS used by Verify com-\n         \
    \ mand so that the correct number of blocks may be  veri-\n          fied.  The\
    \ disk is only capable of transferring an even\n          number of bytes. If\
    \ an odd length is given the low ord-\n          er  bit  is made zero to reduce\
    \ the length to the lower\n          even value.  The length is NOT restricted\
    \ to the sector\n          size  of  512 bytes. If the length is greater than\
    \ 512,\n          length has been satisfied. If the length is not an  ex-\n  \
    \        act  multiple  of  512 bytes, only the specified length\n          will\
    \ be read/written. Note  that  the  hardware  always\n          reads  and  writes\
    \  a  complete sector, so specifying a\n          shorter length on a read will\
    \ cause  the  remainder  of\n          the  block to be skipped. On a write, the\
    \ hardware will\n          repeat the last specified  word  until  the  sector\
    \  is\n          full.\n     The driver will attempt to recover  from  all  soft\
    \  errors.\n     There  is no automatic write/read verify as on mag tapes, so\n\
    \     that data that is incorrectly written will not  be  detected\n     as such\
    \ until a read is attempted. For this reason, the ver-\n     ify feature can be\
    \ used (see above) to force the checking of\n     written  data.  When an error\
    \ is detected while performing a\n     read, the offending block will be re-read\
    \ up to 16 times and\n     disk  resets  will be attempted during this time too.\
    \ If all\n     fails a hardware error indication is returned to  the  user.\n\
    \     Other errors possible are Protection Error (attempt to write\n     to a\
    \ read-only disk) and User Error,  which  indicates  that\n     the  parameters\
    \  in  the IORB were incorrect. Errors such as\n     there being no disk loaded,\
    \ or the drive door being open are\n     NOT  detectable  by the program. The\
    \ interface sees these as\n     Seek Errors (i.e. soft errors), and thus the driver\
    \ will re-\n     try  several times before returning a Hardware Error indica-\n\
    \     tion to the user. It should be noted that error recovery can\n     take\
    \  a  long  time. As mentioned above, there is a 2 second\n     delay before a\
    \ seek error is reported by the  hardware,  for\n     instance.\n"
- title: NAME
  contents:
  - "NAME\n     grinnell - colour display\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     DCT grndout\n     setdct(\"grndout\", 03000, 0172520, 0172522,\n\
    \             grnoi, grnot, grnoti, &grndin);\n     DCT grndin\n     setdct(\"\
    grndin\", 03000, 0172524, 0172526,\n             grnoi, grnot, grnoti, &grndout);\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     The Grinnell colour display has a screen  of  512x512  pels.\n\
    \     Three colours (red, green and blue) can be used, but no grey\n     scale\
    \ is supported.  Three  graphics  modes  are  available.\n     These are:\n  \
    \    (1) Alphanumeric: The input ASCII characters are  displayed\n          at\
    \ the selected positions on the screen.\n      (2) Graphic: Basic geometric elements,\
    \  such  as  line  and\n          rectangle, are drawn by means of graphics commands.\n\
    \      (3) Image: The input data is interpreted as  bit  patterns,\n         \
    \ the corresponding images being illustrated.\n     The values used to construct\
    \ commands are described  in  the\n     Grinnell User Manual. They are also listed\
    \ below.\n      #define LDC     0100000   /* Load Display Channels */\n      #define\
    \ LSM     0010000   /* Load Subchannel Mask */\n      #define   RED   0000010\
    \   /* Read Subchannel */\n      #define   GREEN 0000020   /* Green subchannel\
    \ */\n      #define   BLUE  0000040   /* Blue subchannel */\n      #define WID\
    \     0000000   /* Write Image Data */\n      #define WGD     0020000   /* Write\
    \ Graphic Data */\n      #define WAC     0022000   /* Write AlphanumCh */\n  \
    \    #define LWM     0024000   /* Load Write Mode */\n      #define   REVERSE\
    \  0200   /* Reverse Background */\n      #define   ADDITIVE 0100   /* Additive\
    \ (not Replace) */\n      #define   ZEROWRITE 040   /* Dark Write */\n      #define\
    \   VECTOR    020   /* Select Vector Graph */\n      #define   CURSORON  001 \
    \  /* Cursor On */\n      #define LUM     0026000   /* Load Update Mode */\n \
    \     #define   Ec        001   /* Load Ea with Ec */\n      #define   Ea_Eb \
    \    002   /* Load Ea with Ea + Eb */\n      #define   Ea_Ec     003   /* load\
    \ Ea with Ea + Ec */\n      #define   Lc        004   /* Load La with Lc */\n\
    \      #define   La_Lb     010   /* Load La with La + Lb */\n      #define   La_Lc\
    \     014   /* Load La with La + Lc */\n      #define   SRCL_HOME 020   /* Scroll\
    \ dsiplay to HOME */\n      #define   SRCL_DOWN 040   /* Scroll down one line\
    \ */\n      #define   SCRL_UP   060   /* Scroll up one line */\n      #define\
    \ ERS     0030000   /* Erase */\n      #define ERL     0032000   /* Erase Line\
    \ */\n      #define SLU     0034000   /* Special Location Update */\n      #define\
    \   SCRL_ZAP 0100   /* unlimited scroll speed */\n      #define EGW     0036000\
    \   /* Execute Graphic Write */\n      #define LER     0040000   /* Load Ea relative\
    \ */\n      #define LEA     0044000   /* Load Ea */\n      #define LEB     0050000\
    \   /* Load Eb */\n      #define LEC     0054000   /* Load Ec */\n      #define\
    \ LLR     0060000   /* Load La Relative */\n      #define LLA     0064000   /*\
    \ Load La */\n      #define LLB     0070000   /* Load Lb */\n      #define LLC\
    \     0074000   /* Load Lc */\n      #define   LGW     02000   /* perform write\
    \ */\n      #define NOP     0110000   /* No-Operation */\n      #define SPD  \
    \   0120000   /* Select Special Device */\n      #define LPA     0130000   /*\
    \ Load Peripheral Address */\n      #define LPR     0140000   /* Load Peripheral\
    \ Register */\n      #define LPD     0150000   /* Load Peripheral Data */\n  \
    \    #define RPD     0160000   /* ReadBack Peripheral Data */\n      #define MEMRB\
    \     00400   /* SPD - Memory Read-Back */\n      #define DATA      01000   /*\
    \ SPD - Byte Unpacking */\n      #define   ALPHA   06000   /* LPR - Alphanumeric\
    \ data */\n      #define   GRAPH   04000   /* LPR - Graphic data */\n      #define\
    \   IMAGE   02000   /* LPR - Image data */\n      #define   LTHENH  01000   /*\
    \ take lo byte then hi byte */\n      #define   DROPBYTE 0400   /* drop last byte\
    \ */\n      #define INTERR    02000   /* SPD - Interrupt Enable */\n      #define\
    \ TEST      04000   /* SPD - Diagnostic Test */\n     The MOS driver is called\
    \ grin.obj. It operates on  the  fol-\n     lowing IORB entries.\n     iruva\n\
    \          This data must be ready formtatted  for  the  Grinnell,\n         \
    \ since no conversion is performed by the driver.\n     irbr\n          This transfer\
    \ length as a positive number of bytes.\n     Addressing the grinnell. Rows consist\
    \ of elments numbered  0\n     to 511 running left to right. The lines are number\
    \ from 0 to\n     511 running from bottom to top. It is thus  addressed  as  a\n\
    \     conventional  X-Y  coordinate system. Note that this coordi-\n   e system\
    \ is different the one used for the image.\n        X A\n          |\n       \
    \   |                                 (511, 511)\n      511 +-------------------------------+\n\
    \          |                               |\n          |                    \
    \           |\n          |                               |\n          |      \
    \                         |\n          |             (x, y)            |\n   \
    \       |            +                  |\n          |                       \
    \        |\n          |                               |\n          |         \
    \                      |\n          |                               |\n      \
    \    |                               |\n          +-------------------------------+----->\n\
    \         0                               511    Y\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     grinnell(fax)\n"
- title: NAME
  contents:
  - "NAME\n     dacom - facsimile machine\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     DCT faxinput\n     setdct(\"faxin\", 0350, 0174750, 0174740,\n\
    \             faxii, faxin, faxini, &faxoutput);\n     DCT faxoutput\n     setdct(\"\
    faxout\", 0354, 0174752, 0174742,\n             faxoi, faxot, faxoti, &faxinput);\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     The DACOM facsimile machine can read  a  document,  creating\n\
    \     the  corresponding image data blocks. It can also accept the\n     data\
    \ of relevant format, printing the correponding image.\n     Each data block consists\
    \ of 585 bits, and  is  stored  in  a\n     block  of  74 bytes starting on a\
    \ byte boundary. The final 7\n     bits of the last byte are not used and they\
    \  are  undefined.\n     The  585 bits in each block need to be read as a bit\
    \ stream:\n     the bits in each byte run from the high  orger  end  of  the\n\
    \     byte  to the low order end. The last 12 bits of the 585 bits\n     in each\
    \ block consistute the CRC field whereby the block can\n     be validated.\n \
    \    There are two kinds of blocks: SETUP blocks and DATA blocks.\n     The  first\
    \ of block of an image data file should be a single\n     SETUP block. All following\
    \ blocks in the file must  be  DATA\n     blocks. Note that the second block is\
    \ a DATA block that con-\n     tains ZERO samples, i.e. a dummy data blocks. Form\
    \ the third\n     block, the DATA blocks store the reall image data.\n       \
    \   Appendix II: Task Controller and Task Processes\n"
- title: NAME
  contents:
  - "NAME\n     ccitt - conversion between vector and CCITT T4 format\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     ccitt() - a MOS task\n     command string (task name is defined\
    \ as ccitt):\n     ccitt\"<function>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task to convert the vec-\n\
    \     tors to CCITT T4 format or inversely.\n     The parameter function specifies\
    \ what the task is to do.\n      value           function\n       1c         \
    \    one-dimensional compression\n       1d             one-dimensional decompression\n\
    \       2c[<k>]        two-dimensional compression\n       2d             two-dimensional\
    \ decompression\n     Note k is the maximun number  of  lines  to  be  coded \
    \ two-\n     dimensionally  before  a one-dimensionally coded line is in-\n  \
    \   serted. If k is omitted, the default value 2 is adopted.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), t4(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     check - check the validity of a vector file.\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     check() - a MOS task\n     command string (the task name is defined\
    \ as check):\n     check\"<function>,<width>,<height>,[<from>,<to>]\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task checking the  vali-\n\
    \     dity of the input vector file.\n     The number of lines to be checked is\
    \ specified by the param-\n     eter  height.   If  the height of the image is\
    \ less than the\n     parameter, the actual height is printed. Thus, one  can\
    \  set\n     the  parameter  height to a big number in order to count the\n  \
    \   number of lines of the input image.\n     The run lengths in each of these\
    \ lines are  accumulated  and\n     the sum is compared with the parameter width.\n\
    \     These are the basic functions which are  performed  whenever\n     the \
    \ task is invoked. However, there are several options one\n     can choose by\
    \ setting the one-character parameter function.\n      value         function\n\
    \       'n'          basic function only\n       'c'          print the count\
    \ of each line\n       'l'          print all lines\n       's'          print\
    \ the lines in the interval\n                    specified by parameter from and\
    \ to\n"
- title: DIAGNOSTICS
  contents:
  - "DIAGNOSTICS\n     A bad line will be reported and it will cause the job abort-\n\
    \     ed.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), getl(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     chop - extract a designated rectangular area from an image\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     chop() - a MOS task\n     command string (task name is defined\
    \ as chop):\n     chop\"<x0>,<y0>,<x1>,<y1>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task extracting a desig-\n\
    \     nated  rectangular area from an input image.  Input and out-\n     put are\
    \ image data files in the form of vectors.\n     The following diagram  shows\
    \  the  coordinate  system  being\n     used.  Note that the lengths are measured\
    \ in number of pels.\n          (0, 0)                     width  X\n        \
    \     +-------------------------+---->\n             |                       \
    \  |\n             |                         |\n             |   (x0, y0)    \
    \          |\n             |     +---------+         |\n             |     | \
    \        |         |\n             |     |         |         |\n             |\
    \     |         |         |\n             |     |         |         |\n      \
    \       |     |         |         |\n             |     |         |         |\n\
    \             |     |         |         |\n             |     +---------+    \
    \     |\n             |            (x1, y1)     |\n             |            \
    \             |\n             |                         |\n             |    \
    \                     |\n             |                         |\n      height\
    \ +-------------------------+\n             |\n             |\n           Y V\n\
    \     As can be seen in the diagram, the rectangular  area  to  be\n     extracted\
    \  is  specified  by  the parameters x0, x1, y0, y1,\n     which are decimal strings.\n\
    \             0 < x0 < width\n             0 < y0 < height\n             0 < x1\
    \ < width\n             0 < y1 < height\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), getl(fax), putl(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     clean - clean an image.\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     clean() - a MOS task\n     command string (task name is defined\
    \ as clean):\n     clean\"<width>,<height>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task cleaning  an  image\n\
    \     by  means of mask scanning.  Input and output are image data\n     files\
    \ in the form of vectors.\n     The width and height should be given as the parameters.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), getl(fax), putl(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     decomp - decompress DACOM blocks\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     decomp() - a MOS task\n     command string (task name is defined\
    \ as decomp):\n     decomp\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This task takes DACOM blocks from the Clean and  Simple  in-\n\
    \     terface,  and  decompresses them into vector format. Then it\n     writes\
    \ the vectors to the Clean and Simple interface.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     dacom(dev), vector(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     fax - interface process for DACOM facsimile machine\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     fax() - a MOS task\n     command string (task name is defined\
    \ as fax):\n     fax\"<function>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This task uses the Clean and Simple  interface  to  read  or\n\
    \     write facsimile image data.\n     The one character parameter function specifies\
    \  whether  the\n     data  is  to be read or written. Character w is for writing.\n\
    \     In this case, 74 byte DACOM  blocks  contaning  correct  CRC\n     fields\
    \  are  expected. On the other hand, character r is for\n     reading. In this\
    \ case, a document is read on  the  facsimile\n     machine, the DACOM blocks\
    \ being created.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     dacom(dev), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     fitter - fit processes together to form a data pipe\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     fitter() - the MOS task controller\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     According to the command string typed on the console, fitter\n\
    \     links the specified processes together to form a task chain.\n     The name\
    \ of the processes is the name given in the PCB.  The\n     processes must communicate\
    \ using the C+S interface. Only one\n     C+S interface is opened per process\
    \ - data is pushed in with\n     a cswrite and pulled out with a csread.  The\
    \ fitter does not\n     inspect the data in any way but merely passes  it  from\
    \  one\n     process to another.\n     The format of command string is:\n    \
    \         A | B | C.\n     The fitter takes data from the process called A, write\
    \ it to\n     the  process  called  B,  reads  data from the process B and\n \
    \    write that data to the process  C.   Note  that  all  middle\n     processes\
    \  are both read and written, while the first one in\n     the list is only read\
    \ from and the last in the list is  only\n     written to.\n     A double quote\
    \ is used as the  separator  between  the  task\n     name and the open parameter\
    \ string, e.g.\n             A\"500 | B\"n,xyz | C,\n     where the strings '500'\
    \ and 'n,xyz' are the  open  parameter\n     stings  for  tasks  A  and  B,  respectively.\
    \  The parameter\n     stirng is passed to the corresponding task routine when\
    \  the\n     csopen call returns.\n"
- title: DIAGNOSTICS
  contents:
  - "DIAGNOSTICS\n     The command string containing undefined task will be reject-\n\
    \     ed.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     csinit(fax), csopen(fax), csread(fax), cswrite(fax)\n"
- title: NAME
  contents:
  - "NAME\n     fs - file system for use under MOS\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     fs() - a MOS task\n     command string (task name is defined as\
    \ fs):\n     fs\"<funciton>,<file_name>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This is a file system, based on the  Double  Density  floppy\n\
    \     disk,  for use under MOS. The fs task is used for manipulate\n     the files,\
    \ managed by the file system. This  task  can  only\n     appear at the first\
    \ or last position on a command string. In\n     the former case, the file specified\
    \ is to be read, while the\n     file is to be written in the latter case.\n \
    \    The <function> field contains only one character  indicating\n     the function\
    \ to be performed. The possible values are:\n             e - open an existing\
    \ file (for reading).\n             c - open an existing file, and set the length\n\
    \                       to zero (for rewriting).\n             a - append to an\
    \ existing file.\n     If the capitals A, C, and E are used, the functions are\
    \  the\n     same as described above but the specified file is created if\n  \
    \   it does not exist.\n"
- title: BUGS
  contents:
  - "BUGS\n     This task is for reading and writing only. As for the  other\n   \
    \  facilities,  e.g.  seek, delete, status and sync, one has to\n     use C+S\
    \ interface directly.\n     Note that only 15 files are permitted per disk, only\
    \ drive 0\n     is  supported  at  present, and no hierarchical directory is\n\
    \     allowed.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     aed62(dev), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     ftp, pftp - NIFTP task processes\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     ftp(), pftp() - MOS tasks\n     command string (task name is defined\
    \ as ftp):\n     ftp\"<function>,<code>,<user_name>,<password>,<file_name>;\n\
    \         <trasport_service_process>:<transport_service_parameters>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     These tasks are implementation of Network  Independent  File\n\
    \     Transfer  Protocol (NIFTP) for LSIs under MOS. They employ a\n     transport\
    \ service for communication with a  remote  host  on\n     the network, where\
    \ the same protocol must be supported. They\n     communicate with the  user \
    \ process  and  transport  service\n     processes  thourgh  the  Clean and Simple\
    \ interface, so that\n     they can be used in a fitter command chain directly.\n\
    \     The code is available in two versions: ftp which  is  a  P+Q\n     version\
    \ supporting both server and intitiator and pftp which\n     is a P version working\
    \ only as an initiator.  Both  of  them\n     are capable of sending and receiving.\n\
    \     This implementation of NIFTP is just a subset of the  proto-\n     col \
    \ as its main purpose is to provided the facsimile system\n     with a data transmission\
    \ mechanism. For the sake of  simpli-\n     city,  only  the  necessary  facilities\
    \  are included in the\n     module, while more complex facilities, such as data\
    \ compres-\n     sion  and  error recovery are not implemented. The following\n\
    \     table shows the transfer control parameters being used.\n      Attribute\
    \       Value Mod. Remarks\n      Mode of access  0001  EQ   Creating a new file\n\
    \                      8002  EQ   Retrieving file\n      Codes            -  \
    \  -    Text file, any parity\n                      1002  EQ   Binary file\n\
    \      Format effector 0000  EQ   No interpretation\n      Binary mapping  0008\
    \  EQ   Default byte size\n      Max record size 00FC  EQ   Default record size\n\
    \      Transfer size   0400  LE   Default transfer size\n      Facilities    \
    \  0000  EQ   Minimum service\n     The meanings of the parameters in  the  command\
    \  string  are\n     listed below:\n     beginning with 't' means the file is\
    \ to  be  transmitted  to\n     the remote site.  Otherwise, the file will be\
    \ retrieved from\n     the remote site.\n     code specifies the type of the file\
    \ to be  transferred.  Any\n     ASCII  string  beginning with 'b' means it is\
    \ a binary file,\n     while others mean text file.\n     user_name is the login\
    \ name of the server site.\n     password is the password of the server site.\n\
    \     file_name is the name of the file to be transmitted.\n     transport_service_process\
    \ is the process name of  the  tran-\n     sport service to be used.\n     transport_service_parameters\
    \ are the  parameter  string  re-\n     quired by the transport service.  They\
    \ are network dependent\n     and specified by the corresponding transport service.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     grinnell - task to convert and display fax vector data\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     grinnell() - a MOS task\n     command string (task name is defined\
    \ as string):\n     grinnell\"<x0>,<y0>,<x1>,<y1>,<mode>,<colour>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This task takes the vector data from a Clean and Simple  in-\n\
    \     terface and displays it on the Grinnell screen. The Grinnell\n     screen\
    \ is viewed as an X-Y plane with (0,0) being the  lower\n     left  hand  corner,\
    \  (512,  0)  being  the  lower right hand\n     corner, etc.\n     The parameters\
    \ x0, y0, x1, y1 are decimal  strings  defining\n     the rectangular space on\
    \ the screen where the image is to be\n     displayed. If the image is smaller\
    \ than this area, it is ar-\n     tificially  expanded  to the size of this area.\
    \ If the image\n     is larger than this area it is truncated to the size of \
    \ the\n     area.\n     The colour field consists of any combination of the  charac-\n\
    \     ters  r,g  or  b  to  define the colours red, green and blue\n     respectively.\
    \ For instance \"gb\" would  write  the  image  as\n     yellow.\n     The mode\
    \ defines how the image is to be displayed. Any  com-\n     bination  of  the\
    \  characters  r,a and z may be used, to the\n     following effect:\n       \
    \      r = reverse image\n             a = additive image\n             z = zerowrite\
    \ image.\n     There are three bit planes to define the three colours. Nor-\n\
    \     mally  the  bit planes corresponding to the selected colours\n     have\
    \ either zero bits or one bits written to them  depending\n     upon  whether\
    \  the image or the background is being written.\n     For zerowrite, all non-selected\
    \ bit planes  (i.e.   colours)\n     are  always set to zero, thus erasing any\
    \ unselected colours\n     in the area. Additive mode means that in the selected\
    \ colour\n     planes  the  new bits are ORed in, rather than just written.\n\
    \     Thus the image is added to. In reverse mode, the image writ-\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     grinnell(dev), vector(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     merge - merge two images together\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     merge() - a MOS task\n     command string (task name is defined\
    \ as merge):\n     merge\"<file_name>,<action>,<x0>,<y0>,<x1>,<y1>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task merging two  images\n\
    \     together to form the result image.  Input and output are im-\n     age data\
    \ files in the form of vectors.\n     One of the two input images is called background\
    \ which is to\n     be  copied  directly.  This  is  specified  by the parameter\n\
    \     file_name.  The image data of the back ground is read via  a\n     'tunnel',\
    \  maintained  by  this task. Another input image is\n     taken form the Clean\
    \ and Simple  interface  managed  by  the\n     fitter.   As  shown  in  the following\
    \ diagram, the position\n     where it is to be put on the background image  is\
    \  specified\n     by the parameters x0, y0, x1, y1, which are decimal strings.\n\
    \     This implies that the dimension of the image is x1 - x0  and\n     y1 -y0.\n\
    \          (0, 0)                     width  X\n             +-------------------------+---->\n\
    \             |                         |\n             |   (x0, y0)         \
    \     |\n             |     +---------+         |\n             |     |      \
    \   |         |\n             |     |         |         |\n             |    \
    \ |         |         |\n             |     |         |         |\n          \
    \   |     |         |         |\n             |     +---------+         |\n  \
    \           |            (x1, y1)     |\n             |                      \
    \   |\n             |                         |\n             |       (back ground)\
    \     |\n      height +-------------------------+\n             |\n          \
    \   |\n           Y V\n     The parameter  action  indicates  how  the  two  images\
    \  are\n     merged.  If it set to 0, The second image is simply overlaid\n  \
    \   causes the second image to replace the specified area of the\n     back ground\
    \ image.\n"
- title: BUGS
  contents:
  - "BUGS\n     One has to make sure that\n             0 < x0 < width_of_back_ground\n\
    \             0 < y0 < height_of_back_ground\n             0 < x1 < width_of_back_ground\n\
    \             0 < y1 < height_of_back_ground\n     In addition, x0, y0, x1, y1\
    \ must be consistent with the  di-\n     mension of the image\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), getl(fax), putl(fax), chop(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     od - dump the input data\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     od() - a MOS task\n     command string (task name is defined as\
    \ od):\n     od\"<format>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task dumping  the  input\n\
    \     data in a selected format.  The input data is taken from the\n     Clean\
    \ and Simple interface.\n     The meanings of the one character parameter format\
    \ are:\n            value          format\n             'd'           words in\
    \ decimal\n             'o'           words in octal\n             'c'       \
    \    bytes in ASCII\n             'b'           bytes in octal\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     recomp - compress the vectors to form the DACOM blocks\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     recomp() - a MOS task\n     command string (task name is defined\
    \ as recomp):\n     recomp\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This task takes vectors from the Clean and Simple interface,\n\
    \     and  recompresses them into DACOM blocks. Then it writes the\n     blocks\
    \ to the Clean and Simple interface.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     dacom(dev), vector(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     scale - scale an image to a specified dimension\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     scale() - a MOS task\n     command string (task name is defined\
    \ as scale):\n     scale\"<old_width>,<old_height>,<new_width>,<new_height>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task scaling  the  input\n\
    \     image  to the specified dimension.  Input and output are im-\n     age data\
    \ files in the form of vectors.\n     The dimension of the input image is given\
    \ by the  parameters\n     old_width  and old_height, while the dimension of the\
    \ output\n     is specified by the parameters new_width and new_height.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), getl(fax), putl(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     string - convert an ASCII string to the vector format\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     string() - a MOS task\n     command string (task name is defined\
    \ as string):\n     string\"<s>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a  MOS  pipe  task  converting  the\n\
    \     parameter string s to the corresponding vectors.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), ts(fax)\n"
- title: NAME
  contents:
  - "NAME\n     tf - convert a text to the vector format.\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     tf() - a MOS task\n     command string (task name is defined as\
    \ tf):\n     tf\"<width>,<line_sp>,<upper>,<left>\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine operates as a MOS pipe task converting the  in-\n\
    \     put text to the corresponding vectors. The input text, taken\n     from\
    \ the Clean and Simple interface should be in the  format\n     defined in text(fax).\n\
    \             +-------------------------+\n             |                    \
    \     |\n             |            upper        |\n             |            \
    \             |\n             |         XXXXXXXXXXXX    |\n             |    \
    \     XXXXXXXXXXXX    |\n             |         XXXXXXXXXXXX    |\n          \
    \   |         XXXXXXXXXXXX    |\n             |  left   XXXXXXXXXXXX    |\n  \
    \           |         XXXXXXXXXXXX    |\n             |         XXXXXXXXXXXX \
    \   |\n             |         XXXXXXXXXXXX    |\n             |         XXXXXXXXXXXX\
    \    |\n             |            width        |\n             |             \
    \            |\n             +-------------------------+\n     As shown in the\
    \ diagram, the parameters give the information\n     for  the formating. The parameter\
    \ width is the maximum width\n     of the text lines.\n     Every vector will\
    \ be padded to fit this  width.  White  pels\n     may be padded to the left of\
    \ each vectors, and the number of\n     pel to be padded is specified by the parameter\
    \ left.\n     Empty lines may also be inserted. They are defined by param-\n \
    \    eters  upper  and  line_sp, the number of pels being used as\n     the unit.\n\
    \          Appendix III: Utility Routines and Data Formats\n"
- title: NAME
  contents:
  - "NAME\n     bitmap - convert vector format to core bit map\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     int  bitmap(ivec, cnt, buff);\n     int  *ivec;\n     int  cnt;\n\
    \     char *buff;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     Bitmap converts the fax vector format into a bit map,  using\n\
    \     each bit of the area pointed to by buff.  The number of ele-\n     ments\
    \ in ivec is given by cnt, and the first element of ivec\n     is  taken  as \
    \ a  white pel count, the second as a black pel\n     count, etc. The resultant\
    \ bit map  is  placed  in  the  area\n     pointed  to by buff. The actual number\
    \ of bits stored is re-\n     turned from the function.  The bits in buff  are\
    \  stored  in\n     byte  order, with the highest value bit of the byte taken\
    \ as\n     the first bit of the byte.\n"
- title: BUGS
  contents:
  - "BUGS\n     You have to make sure that buff is big enough  for  all  the\n   \
    \  bits.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), tovec(fax)\n"
- title: NAME
  contents:
  - "NAME\n     tovec - convert bitmap to vector format\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     int  *tovec(buff, nbits);\n     char *buff;\n     int  nbits;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     The bitmap in the buffer pointed to by buff is converted  to\n\
    \     vector format. The length of the bitmap in bits is passed in\n     nbits.\
    \  As the caller would normally not know how many  vec-\n     tor elements are\
    \ going to be needed, the tovec routine allo-\n     cates this area for the user.\n\
    \     Buff is assumed to be  organised  in  byte  order  with  the\n     highest\
    \  value  bit  of each byte being the first bit of the\n     byte. The counts\
    \ of white and black pels are placed into  an\n     integer  vector, the first\
    \ element of which is the length of\n     the rest of the vector. The vector information\
    \ proper starts\n     in  the  second  element which is the count of the number\
    \ of\n     leading white pels.  This is followed by the  count  of  the\n    \
    \ numbr of black pels, etc.\n     The routine goes to great lengths to make sure\
    \  only  enough\n     vector  storage is allocated. Temporary storage is allocated\n\
    \     in small chunks and then, when the length of the whole  vec-\n     tor \
    \ is known, the chunks are contacenated into a contiguous\n     vector.  The pointer\
    \ to this vector is returned to the user.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), bitmap(fax)\n"
- title: NAME
  contents:
  - "NAME\n     choice - specify a rectangular area on Grinnell\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     struct  square  {\n             int  x0, y0;\n             int\
    \  x1, y1;\n     };\n     struct  square  *choice(colour, height, width, area,\
    \ fw, fh)\n     char colour;\n     int  height, width, area, fw, fh;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This subroutine is called by a MOS task.  to specify a  rec-\n\
    \     tangular  area  of  an image by manipulating a square on the\n     Grinnel\
    \ display being illustrating the image. The  dimension\n     of  the  original\
    \ image is defined as height and width.  The\n     area on which the original\
    \ image is shown  is  specified  by\n     the parameter area.\n      value   \
    \    area           dimension    coordinates\n        0     the whole screen \
    \   512x512     0,511,511,0\n        1     the left half       256x512     0,511,255,0\n\
    \        2     the right half      256x512     256,511,511,0\n     The square\
    \ will be drwan in a colour defined by the  parame-\n     ter colour, which can\
    \ only be:\n             value   colour\n              'r'     red\n         \
    \     'g'     green\n              'b'     blue\n     There are two modes being\
    \ supported:\n      (1) Fixed: The square will have a fixed dimension specified\n\
    \          by the parameters fw and fh.  The operator can move the\n         \
    \ square around as a whole within the predetermined  area\n          by  using\
    \  following commands, each of which is invoked\n          by typing the corresponding\
    \ characer on the keyboard of\n          the system console.\n           command\
    \         function\n             'u'           move the square up one step\n \
    \            'd'           move the square down one step\n             'l'   \
    \        move the square one step left\n             'r'           move the square\
    \ one step right\n             'f'           move fast - set the step to 8 pel\n\
    \             'o'           move slowly - set the step to 1 pel\n            \
    \ <CR>          ok - the area has been chosen, and\n                         \
    \ return its coordinates\n      (2) Arbitrary: This mode is set up when the  subroutine\
    \  is\n          called  with  the  parameters  fw and fh set to 0.  Any\n   \
    \       edge of the square can be selected to be moved  on  its\n          own\
    \  by  using  the  same commands described above. The\n          following commands\
    \ are required to select the  relevant\n          edge as well as switching the\
    \ operation mode.\n           command         function\n             'e'     \
    \      select the right ('east') edge.\n             'w'           select the\
    \ left ('west') edge.\n             'n'           select the upper ('north') edge.\n\
    \             's'           select the lower ('south') edge.\n             'a'\
    \           move the square as a whole\n     As soon as the user  types  <CR>,\
    \  the  coordinates  of  the\n     current  square,  which  are accommodated in\
    \ a square struc-\n     ture, are returned. Note these are concerned with the\
    \  coor-\n     dinate  system  defined  for the image but not for the grin-\n\
    \     nell.\n"
- title: BUGS
  contents:
  - "BUGS\n     Currently, only three working areas can be used.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), grinnell(dev), grinnell(fax)\n"
- title: NAME
  contents:
  - "NAME\n     crc - calculate or check the DACOM CRC code\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     int  crc(buff, insert);\n     char *buff;\n     int  insert;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine will check/insert the 12-bit  CRC  code  for \
    \ a\n     DACOM  block,  pointed  to  by buff.  The block contains 585\n     bits,\
    \ the last 12 bits being the  CRC  code.  The  block  is\n     checked  only \
    \ when the parameter insert is set to 0, other-\n     wise the CRC code is created\
    \ and inserted  into  the  block.\n     When the block is checked, the routine\
    \ returns the result: 0\n     means OK and any non-zero value means the block\
    \ is  bad.  On\n     the  other  hand, when the CRC code is inserted, the routine\n\
    \     returns the CRC code it has created.\n     This routine uses a tabular approach\
    \ to  determine  the  CRC\n     code,  processing  a whole byte at a time and\
    \ resulting in a\n     high throughput.\n"
- title: BUGS
  contents:
  - "BUGS\n     Do not forget to supply enough space  when  the  12-bit  CRC\n   \
    \  code is to be inserted.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     dacom(dev)\n"
- title: NAME
  contents:
  - "NAME\n     csinit - initiate the Clean and Simple interface\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     int  csinit();\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine is called to initiate the Clean and Simple  in-\n\
    \     terface for the calling process.  Its code is re-entrant, so\n     that\
    \ only one copy is needed for all processes in a system.\n     This routine returns\
    \ the task identifier, which must be used\n     on all subsequent interface calls.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     csopen(fax), csread(fax), cswrite(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     csopen - establish the Clean and Simple connection\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     char *csopen(tid);\n     int  tid;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     A process calls this routine, waiting to be scheduled.   Its\n\
    \     code  is re-entrant, so that only one copy is needed for all\n     processes\
    \ in a system.\n     The task identifier tid is the word returned from the csinit\n\
    \     call.  When the fitter process has established the Clean and\n     Simple\
    \ connection for the process, this routine returns  the\n     pointer  to  the\
    \  parameter string of the corresponding task\n     command.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     csinit(fax), csread(fax), cswrite(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     csread - read data from the Clean and Simple interface\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     char *csread(tid, need);\n     int  tid, need;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine is called to read data from the Clean and  Sim-\n\
    \     ple interface. Its code is re-entrant, so that only one copy\n     is needed\
    \ for all processes in a system.\n     The task identifier tid is the word returned\
    \ from the csinit\n     call.  The need parameter indicates the number of bytes\
    \ that\n     are required. This routine returns a  pointer  to  a  buffer\n  \
    \   with this much data in it. This is usually more efficient as\n     it means\
    \ that the data does not have to be reblocked.\n"
- title: DIAGNOSTICS
  contents:
  - "DIAGNOSTICS\n     If the returned value is 0, the end of data is reached.\n"
- title: BUGS
  contents:
  - "BUGS\n     Funnies happen at the end of data to be read.  The  csread()\n   \
    \  call  has  no  way of saying that the final buffer is partly\n     filled.\
    \  Thus if you ask for more data,  you  hang  forever.\n     But  if  the  data\
    \  structures  are  working correctly, this\n     should never happen.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     csinit(fax), cswrite(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     cswrite - write data to the Clean and Simple interface\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     char *cswrite(tid, need);\n     int  tid, need;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine is call to write data to the Clean  and  Simple\n\
    \     interface.  Its code is re-entrant, so that only one copy is\n     needed\
    \ for all processes in a system.\n     The task identifier tid is the word returned\
    \ from the csinit\n     call.  The need parameter indicates the number of bytes\
    \ that\n     are to be written. This routine returns a  write  buffer  of\n  \
    \   the  required  length, to which the user data can be copied.\n     The subsequent\
    \ cswrite()  call  automatically  releases  the\n     previous write buffer.\n\
    \     The cswrite() call with need set to 0 indicates the  end  of\n     data,\
    \ closing the current Clean and Simple connection.\n"
- title: BUGS
  contents:
  - "BUGS\n     As indicated, the write buffer must be filled up before  the\n   \
    \  next cswrite() call.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     csinit(fax), csread(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     getl - get a line vector from the Clean and Simple interface\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     int  *getl(tid);\n     int  tid, need;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine is called to read a line vector from the  Clean\n\
    \     and  Simple  interface. Its code is re-entrant, so that only\n     one copy\
    \ is needed for all processes in a system.\n     The task identifier tid is the\
    \ word returned from the csinit\n     call.  The  routine  returns the pointer\
    \ to the buffer where\n     the line vector is stored.\n"
- title: DIAGNOSTICS
  contents:
  - "DIAGNOSTICS\n     0 will be returned when end of file is reached.\n"
- title: BUGS
  contents:
  - "BUGS\n     Any memory violation causes  the  whole  task  chain  to  be\n   \
    \  aborted.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), putl(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     putl - put a line vector to the Clean and Simple Interface\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     putl(tid, buf);\n     int  tid, *buf;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine is called to write a line vector to  the  Clean\n\
    \     and  Simple  interface. Its code is re-entrant, so that only\n     one copy\
    \ is needed for all processes in a system.\n     The task identifier tid is the\
    \ word returned from the csinit\n     call. The line vector is stored in a buffer\
    \ pointed by buf.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax), getl(fax), fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     t4 - the data format defined in CCITT recommendation T4\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     Dimension and Resolution: In vertical direction the  resolu-\n\
    \     tion is defined below.\n             Standard resolution:            3.85\
    \ line/mm\n             Optional higher resolution:     7.70 line/mm\n     In\
    \ horizontal direction, the standard resolution is  defined\n     as  1728 black\
    \ and white picture elements along the standard\n     line length of 215 mm. \
    \ Optionally, there  can  be  2048  or\n     2432 picture elements along a scan\
    \ line length of 255 or 303\n     mm, respectively. The input documents up to\
    \ a minimum of ISO\n     A4 size should be accepted.\n     One-Dimensional Coding:\
    \ The one-dimensional run length  data\n     compression  is accomplished by the\
    \ popular modified Huffman\n     coding scheme. In this scheme, black and white\
    \ runs are  re-\n     placed  by  a  base  64 codes representation. Compression\
    \ is\n     achieved since the code word lengths are invertly related to\n    \
    \ the  probability  of  the  occurrence of a particular run. A\n     special code\
    \ (000000000001), known as  EOL  (End  of  Line),\n     follows  each  line  of\
    \ data. This code starts the facsimile\n     message phase, while the control\
    \ phase is restored by a com-\n     bination  of six contiguous EOLs (RTC). The\
    \ data format of a\n     facsimile message is shown below.\n      start of the\
    \ facsimile data\n      |\n      v\n      +---+------+---+------+-/\n      !EOL!\
    \ DATA !EOL! DATA !\n      +---+------+---+------+-/\n                    end\
    \ of the facsimile data\n                                            |\n     \
    \                                       v\n       /-+---+------+---+---+---+---+---+---+\n\
    \         !EOL! DATA !EOL!EOL!EOL!EOL!EOL!EOL!\n       /-+---+------+---+---+---+---+---+---+\n\
    \                    |<------   RTC  ------->|\n     Two-Dimensional Coding: The\
    \ two-dimensional coding scheme is\n     labeled  as  the  Modified READ Code.\
    \ It codes one line with\n     reference to the line above,correlation  between\
    \  adja-\n     cent lines allowing for more efficient compression. In order\n\
    \     a one-dimensionally coded line is transmitted after  one  or\n     more\
    \  two-dimensionally  coded  lines.  A bit, following the\n     EOL, indicates\
    \ whether one-  or  two-dimensional  coding  is\n     used for the next line:\n\
    \             EOL1: one-dimensional coding;\n             EOL0: two-dimensional\
    \ coding.\n      start of the facsimile data\n      |\n      v\n      +----+--------+----+--------+-/\n\
    \      !EOL1!DATA(1D)!EOL0!DATA(2D)!\n      +----+--------+----+--------+-/\n\
    \                             end of the facsimile data\n                    \
    \                                 |\n                                        \
    \             v\n       /-+----+--------+----+----+----+----+----+----+\n    \
    \     !EOL0!DATA(2D)!EOL1!EOL1!EOL1!EOL1!EOL1!EOL1!\n       /-+----+--------+----+----+----+----+----+----+\n\
    \                       |<---------   RTC   --------->|\n"
- title: NAME
  contents:
  - "NAME\n     text - the text format for use in the facsimile system\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This is the representation  structure  for  coded  character\n\
    \     text.  It is used in the facsimile system.\n     The  text  structure  consists\
    \  of  a  series  of  character\n     strings,  each  of  which represents a text\
    \ line. However no\n     control characters, e.g. <CR> and  <LF>,  are  used \
    \ in  the\n     structure. Each text line is proeeded by a count byte, indi-\n\
    \     cating the number of characters on the line.  The  character\n     sting\
    \  follows  after the the count byte. A zero count indi-\n     cates the end of\
    \ file.\n"
- title: EXAMPLES
  contents:
  - "EXAMPLES\n     Here is an example text shown below:\n             This is a text.\n\
    \             This is a picture.\n     It can be represented as:\n      <017>\
    \ T  h  i  s <040> i  s <040> a <040> t  e  x  t  .\n      <022> T  h  i  s <040>\
    \ i  s <040> a <040> p  i  c  t  u\n      r e  . <0>\n"
- title: NAME
  contents:
  - "NAME\n     ts - translate an ASCII string into vector format\n"
- title: SYNOPSIS
  contents:
  - "SYNOPSIS\n     ts(ar_in, left, right, tid)\n     char *ar_in;\n     int  left,\
    \ right, tid;\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This routine will convert a zero-ended ASCII string  pointed\n\
    \     to  by  ar_in  into  the corresponding vecter format. As the\n     character\
    \ font being used is a set of 12x20 matrices,  there\n     will  be  20 line vectors\
    \ created. These vectors are written\n     to the Cleans and Simple interface\
    \ by calling cswrite.   The\n     callers task identifier tid has to be provided.\n\
    \     At the two ends of the text line, blanks can be padded  that\n     are \
    \ specified  as left and right.  Note that they are meas-\n     ured in pels.\n\
    \     Consequently, the result should be a image, whose  dimension\n     is:\n\
    \             width  = left + 12*length + right;\n             height = 20;\n\
    \     where length is  the  number  of  characters  in  the  input\n     string.\n\
    \     As an intermediate result the bitmap is first created  which\n     is then\
    \ converted into the vector format, by calling tovec.\n"
- title: BUGS
  contents:
  - "BUGS\n     The input string must be ended with a zero field.\n"
- title: SEE ALSO
  contents:
  - "SEE ALSO\n     vector(fax),    tovec(fax),    csinit(fax),    cswrite(fax),\n\
    \     fitter(fax)\n"
- title: NAME
  contents:
  - "NAME\n     vector - the internal data structure for a facsimile image\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n     This is the representation structure for  binary  images, \
    \ a\n     simple  run length compression algorithm being used. Most of\n     the\
    \ image files are kept in vector format for ease  of  pro-\n     cessing.\n  \
    \   The vector format consists of a series of  integer  vectors,\n     one vector\
    \ for each row of pels in the image. Each vector is\n     proceeded by a count\
    \ word which indicates the number of  in-\n     teger  words  in the vector. \
    \ The next element of the vector\n     after the count field is the number of\
    \  white  pels  in  the\n     first  run  of  the  line.   The  second word then\
    \ gives the\n     number of pels that follow the initial white run, and so  on\n\
    \     t  the  end of the vector. Note the first run length element\n     must\
    \ refer to a white run. It should be  set  to  0  if  the\n     first run is black.\n"
- title: EXAMPLES
  contents:
  - "EXAMPLES\n     A line consists of 20 pels as follows:\n             00011111111011100000\n\
    \     It can be represented as:\n             5, 3, 8, 1, 3, 5\n     The inverse\
    \ of the line:\n             11100000000100011111\n"
