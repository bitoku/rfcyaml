- title: __initial_text__
  contents:
  - '           HOTP: An HMAC-Based One-Time Password Algorithm

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes an algorithm to generate one-time password\n\
    \   values, based on Hashed Message Authentication Code (HMAC).  A\n   security\
    \ analysis of the algorithm is presented, and important\n   parameters related\
    \ to the secure deployment of the algorithm are\n   discussed.  The proposed algorithm\
    \ can be used across a wide range of\n   network applications ranging from remote\
    \ Virtual Private Network\n   (VPN) access, Wi-Fi network logon to transaction-oriented\
    \ Web\n   applications.\n   This work is a joint effort by the OATH (Open AuTHentication)\n\
    \   membership to specify an algorithm that can be freely distributed to\n   the\
    \ technical community.  The authors believe that a common and\n   shared algorithm\
    \ will facilitate adoption of two-factor\n   authentication on the Internet by\
    \ enabling interoperability across\n   commercial and open-source implementations.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Overview ........................................................3\n\
    \   2. Introduction ....................................................3\n  \
    \ 3. Requirements Terminology ........................................4\n   4.\
    \ Algorithm Requirements ..........................................4\n   5. HOTP\
    \ Algorithm ..................................................5\n      5.1. Notation\
    \ and Symbols .......................................5\n      5.2. Description\
    \ ................................................6\n      5.3. Generating an\
    \ HOTP Value ...................................6\n      5.4. Example of HOTP\
    \ Computation for Digit = 6 ..................7\n   6. Security Considerations\
    \ .........................................8\n   7. Security Requirements ...........................................9\n\
    \      7.1. Authentication Protocol Requirements .......................9\n  \
    \    7.2. Validation of HOTP Values .................................10\n    \
    \  7.3. Throttling at the Server ..................................10\n      7.4.\
    \ Resynchronization of the Counter ..........................11\n      7.5. Management\
    \ of Shared Secrets ..............................11\n   8. Composite Shared Secrets\
    \ .......................................14\n   9. Bi-Directional Authentication\
    \ ..................................14\n   10. Conclusion ....................................................15\n\
    \   11. Acknowledgements ..............................................15\n  \
    \ 12. Contributors ..................................................15\n   13.\
    \ References ....................................................15\n      13.1.\
    \ Normative References .....................................15\n      13.2. Informative\
    \ References ...................................16\n   Appendix A - HOTP Algorithm\
    \ Security: Detailed Analysis ...........17\n      A.1. Definitions and Notations\
    \ .................................17\n      A.2. The Idealized Algorithm: HOTP-IDEAL\
    \ .......................17\n      A.3. Model of Security .........................................18\n\
    \      A.4. Security of the Ideal Authentication Algorithm ............19\n  \
    \         A.4.1. From Bits to Digits ................................19\n    \
    \       A.4.2. Brute Force Attacks ................................21\n      \
    \     A.4.3. Brute force attacks are the best possible attacks ..22\n      A.5.\
    \ Security Analysis of HOTP .................................23\n   Appendix B\
    \ - SHA-1 Attacks ........................................25\n      B.1. SHA-1\
    \ Status ..............................................25\n      B.2. HMAC-SHA-1\
    \ Status .........................................26\n      B.3. HOTP Status ...............................................26\n\
    \   Appendix C - HOTP Algorithm: Reference Implementation .............27\n  \
    \ Appendix D - HOTP Algorithm: Test Values ..........................32\n   Appendix\
    \ E - Extensions ...........................................33\n      E.1. Number\
    \ of Digits ..........................................33\n      E.2. Alphanumeric\
    \ Values .......................................33\n      E.3. Sequence of HOTP\
    \ values ...................................34\n      E.4. A Counter-Based Resynchronization\
    \ Method ..................34\n      E.5. Data Field ................................................35\n"
- title: 1.  Overview
  contents:
  - "1.  Overview\n   The document introduces first the context around an algorithm\
    \ that\n   generates one-time password values based on HMAC [BCK1] and, thus,\
    \ is\n   named the HMAC-Based One-Time Password (HOTP) algorithm.  In Section\n\
    \   4, the algorithm requirements are listed and in Section 5, the HOTP\n   algorithm\
    \ is described.  Sections 6 and 7 focus on the algorithm\n   security.  Section\
    \ 8 proposes some extensions and improvements, and\n   Section 10 concludes this\
    \ document.  In Appendix A, the interested\n   reader will find a detailed, full-fledged\
    \ analysis of the algorithm\n   security: an idealized version of the algorithm\
    \ is evaluated, and\n   then the HOTP algorithm security is analyzed.\n"
- title: 2.  Introduction
  contents:
  - "2.  Introduction\n   Today, deployment of two-factor authentication remains extremely\n\
    \   limited in scope and scale.  Despite increasingly higher levels of\n   threats\
    \ and attacks, most Internet applications still rely on weak\n   authentication\
    \ schemes for policing user access.  The lack of\n   interoperability among hardware\
    \ and software technology vendors has\n   been a limiting factor in the adoption\
    \ of two-factor authentication\n   technology.  In particular, the absence of\
    \ open specifications has\n   led to solutions where hardware and software components\
    \ are tightly\n   coupled through proprietary technology, resulting in high-cost\n\
    \   solutions, poor adoption, and limited innovation.\n   In the last two years,\
    \ the rapid rise of network threats has exposed\n   the inadequacies of static\
    \ passwords as the primary mean of\n   authentication on the Internet.  At the\
    \ same time, the current\n   approach that requires an end user to carry an expensive,\
    \ single-\n   function device that is only used to authenticate to the network\
    \ is\n   clearly not the right answer.  For two-factor authentication to\n   propagate\
    \ on the Internet, it will have to be embedded in more\n   flexible devices that\
    \ can work across a wide range of applications.\n   The ability to embed this\
    \ base technology while ensuring broad\n   interoperability requires that it be\
    \ made freely available to the\n   broad technical community of hardware and software\
    \ developers.  Only\n   an open-system approach will ensure that basic two-factor\n\
    \   authentication primitives can be built into the next generation of\n   consumer\
    \ devices such as USB mass storage devices, IP phones, and\n   personal digital\
    \ assistants.\n   One-Time Password is certainly one of the simplest and most\
    \ popular\n   forms of two-factor authentication for securing network access.\
    \  For\n   example, in large enterprises, Virtual Private Network access often\n\
    \   requires the use of One-Time Password tokens for remote user\n   authentication.\
    \  One-Time Passwords are often preferred to stronger\n   forms of authentication\
    \ such as Public-Key Infrastructure (PKI) or\n   biometrics because an air-gap\
    \ device does not require the\n   installation of any client desktop software\
    \ on the user machine,\n   therefore allowing them to roam across multiple machines\
    \ including\n   home computers, kiosks, and personal digital assistants.\n   This\
    \ document proposes a simple One-Time Password algorithm that can\n   be implemented\
    \ by any hardware manufacturer or software developer to\n   create interoperable\
    \ authentication devices and software agents.  The\n   algorithm is event-based\
    \ so that it can be embedded in high-volume\n   devices such as Java smart cards,\
    \ USB dongles, and GSM SIM cards.\n   The presented algorithm is made freely available\
    \ to the developer\n   community under the terms and conditions of the IETF Intellectual\n\
    \   Property Rights [RFC3979].\n   The authors of this document are members of\
    \ the Open AuTHentication\n   initiative [OATH].  The initiative was created in\
    \ 2004 to facilitate\n   collaboration among strong authentication technology\
    \ providers.\n"
- title: 3.  Requirements Terminology
  contents:
  - "3.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 4.  Algorithm Requirements
  contents:
  - "4.  Algorithm Requirements\n   This section presents the main requirements that\
    \ drove this algorithm\n   design.  A lot of emphasis was placed on end-consumer\
    \ usability as\n   well as the ability for the algorithm to be implemented by\
    \ low-cost\n   hardware that may provide minimal user interface capabilities.\
    \  In\n   particular, the ability to embed the algorithm into high-volume SIM\n\
    \   and Java cards was a fundamental prerequisite.\n   R1 - The algorithm MUST\
    \ be sequence- or counter-based: one of the\n   goals is to have the HOTP algorithm\
    \ embedded in high-volume devices\n   such as Java smart cards, USB dongles, and\
    \ GSM SIM cards.\n   R2 - The algorithm SHOULD be economical to implement in hardware\
    \ by\n   minimizing requirements on battery, number of buttons, computational\n\
    \   horsepower, and size of LCD display.\n   R3 - The algorithm MUST work with\
    \ tokens that do not support any\n   numeric input, but MAY also be used with\
    \ more sophisticated devices\n   such as secure PIN-pads.\n   R4 - The value displayed\
    \ on the token MUST be easily read and entered\n   by the user: This requires\
    \ the HOTP value to be of reasonable length.\n   The HOTP value must be at least\
    \ a 6-digit value.  It is also\n   desirable that the HOTP value be 'numeric only'\
    \ so that it can be\n   easily entered on restricted devices such as phones.\n\
    \   R5 - There MUST be user-friendly mechanisms available to\n   resynchronize\
    \ the counter.  Section 7.4 and Appendix E.4 details the\n   resynchronization\
    \ mechanism proposed in this document\n   R6 - The algorithm MUST use a strong\
    \ shared secret.  The length of\n   the shared secret MUST be at least 128 bits.\
    \  This document\n   RECOMMENDs a shared secret length of 160 bits.\n"
- title: 5.  HOTP Algorithm
  contents:
  - "5.  HOTP Algorithm\n   In this section, we introduce the notation and describe\
    \ the HOTP\n   algorithm basic blocks -- the base function to compute an HMAC-SHA-1\n\
    \   value and the truncation method to extract an HOTP value.\n"
- title: 5.1.  Notation and Symbols
  contents:
  - "5.1.  Notation and Symbols\n   A string always means a binary string, meaning\
    \ a sequence of zeros\n   and ones.\n   If s is a string, then |s| denotes its\
    \ length.\n   If n is a number, then |n| denotes its absolute value.\n   If s\
    \ is a string, then s[i] denotes its i-th bit.  We start numbering\n   the bits\
    \ at 0, so s = s[0]s[1]...s[n-1] where n = |s| is the length\n   of s.\n   Let\
    \ StToNum (String to Number) denote the function that as input a\n   string s\
    \ returns the number whose binary representation is s. (For\n   example, StToNum(110)\
    \ = 6.)\n   Here is a list of symbols used in this document.\n   Symbol  Represents\n\
    \   -------------------------------------------------------------------\n   C\
    \       8-byte counter value, the moving factor.  This counter\n           MUST\
    \ be synchronized between the HOTP generator (client)\n           and the HOTP\
    \ validator (server).\n   K       shared secret between client and server; each\
    \ HOTP\n           generator has a different and unique secret K.\n   T      \
    \ throttling parameter: the server will refuse connections\n           from a\
    \ user after T unsuccessful authentication attempts.\n   s       resynchronization\
    \ parameter: the server will attempt to\n           verify a received authenticator\
    \ across s consecutive\n           counter values.\n   Digit   number of digits\
    \ in an HOTP value; system parameter.\n"
- title: 5.2.  Description
  contents:
  - "5.2.  Description\n   The HOTP algorithm is based on an increasing counter value\
    \ and a\n   static symmetric key known only to the token and the validation\n\
    \   service.  In order to create the HOTP value, we will use the HMAC-\n   SHA-1\
    \ algorithm, as defined in RFC 2104 [BCK2].\n   As the output of the HMAC-SHA-1\
    \ calculation is 160 bits, we must\n   truncate this value to something that can\
    \ be easily entered by a\n   user.\n                   HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))\n\
    \   Where:\n     - Truncate represents the function that converts an HMAC-SHA-1\n\
    \       value into an HOTP value as defined in Section 5.3.\n   The Key (K), the\
    \ Counter (C), and Data values are hashed high-order\n   byte first.\n   The HOTP\
    \ values generated by the HOTP generator are treated as big\n   endian.\n"
- title: 5.3.  Generating an HOTP Value
  contents:
  - "5.3.  Generating an HOTP Value\n   We can describe the operations in 3 distinct\
    \ steps:\n   Step 1: Generate an HMAC-SHA-1 value Let HS = HMAC-SHA-1(K,C)  //\
    \ HS\n   is a 20-byte string\n   Step 2: Generate a 4-byte string (Dynamic Truncation)\n\
    \   Let Sbits = DT(HS)   //  DT, defined below,\n                        //  returns\
    \ a 31-bit string\n   Step 3: Compute an HOTP value\n   Let Snum  = StToNum(Sbits)\
    \   // Convert S to a number in\n                                    0...2^{31}-1\n\
    \   Return D = Snum mod 10^Digit //  D is a number in the range\n            \
    \                        0...10^{Digit}-1\n   The Truncate function performs Step\
    \ 2 and Step 3, i.e., the dynamic\n   truncation and then the reduction modulo\
    \ 10^Digit.  The purpose of\n   the dynamic offset truncation technique is to\
    \ extract a 4-byte\n   dynamic binary code from a 160-bit (20-byte) HMAC-SHA-1\
    \ result.\n    DT(String) // String = String[0]...String[19]\n     Let OffsetBits\
    \ be the low-order 4 bits of String[19]\n     Offset = StToNum(OffsetBits) //\
    \ 0 <= OffSet <= 15\n     Let P = String[OffSet]...String[OffSet+3]\n     Return\
    \ the Last 31 bits of P\n   The reason for masking the most significant bit of\
    \ P is to avoid\n   confusion about signed vs. unsigned modulo computations. \
    \ Different\n   processors perform these operations differently, and masking out\
    \ the\n   signed bit removes all ambiguity.\n   Implementations MUST extract a\
    \ 6-digit code at a minimum and possibly\n   7 and 8-digit code.  Depending on\
    \ security requirements, Digit = 7 or\n   more SHOULD be considered in order to\
    \ extract a longer HOTP value.\n   The following paragraph is an example of using\
    \ this technique for\n   Digit = 6, i.e., that a 6-digit HOTP value is calculated\
    \ from the\n   HMAC value.\n"
- title: 5.4.  Example of HOTP Computation for Digit = 6
  contents:
  - "5.4.  Example of HOTP Computation for Digit = 6\n   The following code example\
    \ describes the extraction of a dynamic\n   binary code given that hmac_result\
    \ is a byte array with the HMAC-\n   SHA-1 result:\n        int offset   =  hmac_result[19]\
    \ & 0xf ;\n        int bin_code = (hmac_result[offset]  & 0x7f) << 24\n      \
    \     | (hmac_result[offset+1] & 0xff) << 16\n           | (hmac_result[offset+2]\
    \ & 0xff) <<  8\n           | (hmac_result[offset+3] & 0xff) ;\n   SHA-1 HMAC\
    \ Bytes (Example)\n   -------------------------------------------------------------\n\
    \   | Byte Number                                               |\n   -------------------------------------------------------------\n\
    \   |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|\n   -------------------------------------------------------------\n\
    \   | Byte Value                                                |\n   -------------------------------------------------------------\n\
    \   |1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|\n   -------------------------------***********----------------++|\n\
    \   * The last byte (byte 19) has the hex value 0x5a.\n   * The value of the lower\
    \ 4 bits is 0xa (the offset value).\n   * The offset value is byte 10 (0xa).\n\
    \   * The value of the 4 bytes starting at byte 10 is 0x50ef7f19,\n     which\
    \ is the dynamic binary code DBC1.\n   * The MSB of DBC1 is 0x50 so DBC2 = DBC1\
    \ = 0x50ef7f19 .\n   * HOTP = DBC2 modulo 10^6 = 872921.\n   We treat the dynamic\
    \ binary code as a 31-bit, unsigned, big-endian\n   integer; the first byte is\
    \ masked with a 0x7f.\n   We then take this number modulo 1,000,000 (10^6) to\
    \ generate the 6-\n   digit HOTP value 872921 decimal.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The conclusion of the security analysis detailed\
    \ in the Appendix is\n   that, for all practical purposes, the outputs of the\
    \ Dynamic\n   Truncation (DT) on distinct counter inputs are uniformly and\n \
    \  independently distributed 31-bit strings.\n   The security analysis then details\
    \ the impact of the conversion from\n   a string to an integer and the final reduction\
    \ modulo 10^Digit, where\n   Digit is the number of digits in an HOTP value.\n\
    \   The analysis demonstrates that these final steps introduce a\n   negligible\
    \ bias, which does not impact the security of the HOTP\n   algorithm, in the sense\
    \ that the best possible attack against the\n   HOTP function is the brute force\
    \ attack.\n   Assuming an adversary is able to observe numerous protocol exchanges\n\
    \   and collect sequences of successful authentication values.  This\n   adversary,\
    \ trying to build a function F to generate HOTP values based\n   on his observations,\
    \ will not have a significant advantage over a\n   random guess.\n   The logical\
    \ conclusion is simply that the best strategy will once\n   again be to perform\
    \ a brute force attack to enumerate and try all the\n   possible values.\n   Considering\
    \ the security analysis in the Appendix of this document,\n   without loss of\
    \ generality, we can approximate closely the security\n   of the HOTP algorithm\
    \ by the following formula:\n                            Sec = sv/10^Digit\n \
    \  Where:\n     - Sec is the probability of success of the adversary;\n     -\
    \ s is the look-ahead synchronization window size;\n     - v is the number of\
    \ verification attempts;\n     - Digit is the number of digits in HOTP values.\n\
    \   Obviously, we can play with s, T (the Throttling parameter that would\n  \
    \ limit the number of attempts by an attacker), and Digit until\n   achieving\
    \ a certain level of security, still preserving the system\n   usability.\n"
- title: 7.  Security Requirements
  contents:
  - "7.  Security Requirements\n   Any One-Time Password algorithm is only as secure\
    \ as the application\n   and the authentication protocols that implement it. \
    \ Therefore, this\n   section discusses the critical security requirements that\
    \ our choice\n   of algorithm imposes on the authentication protocol and validation\n\
    \   software.\n   The parameters T and s discussed in this section have a significant\n\
    \   impact on the security -- further details in Section 6 elaborate on\n   the\
    \ relations between these parameters and their impact on the system\n   security.\n\
    \   It is also important to remark that the HOTP algorithm is not a\n   substitute\
    \ for encryption and does not provide for the privacy of\n   data transmission.\
    \  Other mechanisms should be used to defeat attacks\n   aimed at breaking confidentiality\
    \ and privacy of transactions.\n"
- title: 7.1.  Authentication Protocol Requirements
  contents:
  - "7.1.  Authentication Protocol Requirements\n   We introduce in this section some\
    \ requirements for a protocol P\n   implementing HOTP as the authentication method\
    \ between a prover and a\n   verifier.\n   RP1 - P MUST support two-factor authentication,\
    \ i.e., the\n   communication and verification of something you know (secret code\n\
    \   such as a Password, Pass phrase, PIN code, etc.) and something you\n   have\
    \ (token).  The secret code is known only to the user and usually\n   entered\
    \ with the One-Time Password value for authentication purpose\n   (two-factor\
    \ authentication).\n   RP2 - P SHOULD NOT be vulnerable to brute force attacks.\
    \  This\n   implies that a throttling/lockout scheme is RECOMMENDED on the\n \
    \  validation server side.\n   RP3 - P SHOULD be implemented over a secure channel\
    \ in order to\n   protect users' privacy and avoid replay attacks.\n"
- title: 7.2.  Validation of HOTP Values
  contents:
  - "7.2.  Validation of HOTP Values\n   The HOTP client (hardware or software token)\
    \ increments its counter\n   and then calculates the next HOTP value HOTP client.\
    \  If the value\n   received by the authentication server matches the value calculated\
    \ by\n   the client, then the HOTP value is validated.  In this case, the\n  \
    \ server increments the counter value by one.\n   If the value received by the\
    \ server does not match the value\n   calculated by the client, the server initiate\
    \ the resynch protocol\n   (look-ahead window) before it requests another pass.\n\
    \   If the resynch fails, the server asks then for another\n   authentication\
    \ pass of the protocol to take place, until the\n   maximum number of authorized\
    \ attempts is reached.\n   If and when the maximum number of authorized attempts\
    \ is reached, the\n   server SHOULD lock out the account and initiate a procedure\
    \ to inform\n   the user.\n"
- title: 7.3.  Throttling at the Server
  contents:
  - "7.3.  Throttling at the Server\n   Truncating the HMAC-SHA-1 value to a shorter\
    \ value makes a brute\n   force attack possible.  Therefore, the authentication\
    \ server needs to\n   detect and stop brute force attacks.\n   We RECOMMEND setting\
    \ a throttling parameter T, which defines the\n   maximum number of possible attempts\
    \ for One-Time Password validation.\n   The validation server manages individual\
    \ counters per HOTP device in\n   order to take note of any failed attempt.  We\
    \ RECOMMEND T not to be\n   too large, particularly if the resynchronization method\
    \ used on the\n   server is window-based, and the window size is large.  T SHOULD\
    \ be\n   set as low as possible, while still ensuring that usability is not\n\
    \   significantly impacted.\n   Another option would be to implement a delay scheme\
    \ to avoid a brute\n   force attack.  After each failed attempt A, the authentication\
    \ server\n   would wait for an increased T*A number of seconds, e.g., say T =\
    \ 5,\n   then after 1 attempt, the server waits for 5 seconds, at the second\n\
    \   failed attempt, it waits for 5*2 = 10 seconds, etc.\n   The delay or lockout\
    \ schemes MUST be across login sessions to prevent\n   attacks based on multiple\
    \ parallel guessing techniques.\n"
- title: 7.4.  Resynchronization of the Counter
  contents:
  - "7.4.  Resynchronization of the Counter\n   Although the server's counter value\
    \ is only incremented after a\n   successful HOTP authentication, the counter\
    \ on the token is\n   incremented every time a new HOTP is requested by the user.\
    \  Because\n   of this, the counter values on the server and on the token might\
    \ be\n   out of synchronization.\n   We RECOMMEND setting a look-ahead parameter\
    \ s on the server, which\n   defines the size of the look-ahead window.  In a\
    \ nutshell, the server\n   can recalculate the next s HOTP-server values, and\
    \ check them against\n   the received HOTP client.\n   Synchronization of counters\
    \ in this scenario simply requires the\n   server to calculate the next HOTP values\
    \ and determine if there is a\n   match.  Optionally, the system MAY require the\
    \ user to send a\n   sequence of (say, 2, 3) HOTP values for resynchronization\
    \ purpose,\n   since forging a sequence of consecutive HOTP values is even more\n\
    \   difficult than guessing a single HOTP value.\n   The upper bound set by the\
    \ parameter s ensures the server does not go\n   on checking HOTP values forever\
    \ (causing a denial-of-service attack)\n   and also restricts the space of possible\
    \ solutions for an attacker\n   trying to manufacture HOTP values. s SHOULD be\
    \ set as low as\n   possible, while still ensuring that usability is not impacted.\n"
- title: 7.5.  Management of Shared Secrets
  contents:
  - "7.5.  Management of Shared Secrets\n   The operations dealing with the shared\
    \ secrets used to generate and\n   verify OTP values must be performed securely,\
    \ in order to mitigate\n   risks of any leakage of sensitive information.  We\
    \ describe in this\n   section different modes of operations and techniques to\
    \ perform these\n   different operations with respect to the state of the art\
    \ in data\n   security.\n   We can consider two different avenues for generating\
    \ and storing\n   (securely) shared secrets in the Validation system:\n      *\
    \ Deterministic Generation: secrets are derived from a master\n        seed, both\
    \ at provisioning and verification stages and generated\n        on-the-fly whenever\
    \ it is required.\n      * Random Generation: secrets are generated randomly at\n\
    \        provisioning stage and must be stored immediately and kept\n        secure\
    \ during their life cycle.\n   Deterministic Generation\n   ------------------------\n\
    \   A possible strategy is to derive the shared secrets from a master\n   secret.\
    \  The master secret will be stored at the server only.  A\n   tamper-resistant\
    \ device MUST be used to store the master key and\n   derive the shared secrets\
    \ from the master key and some public\n   information.  The main benefit would\
    \ be to avoid the exposure of the\n   shared secrets at any time and also avoid\
    \ specific requirements on\n   storage, since the shared secrets could be generated\
    \ on-demand when\n   needed at provisioning and validation time.\n   We distinguish\
    \ two different cases:\n      - A single master key MK is used to derive the shared\
    \ secrets;\n        each HOTP device has a different secret, K_i = SHA-1 (MK,i)\n\
    \        where i stands for a public piece of information that identifies\n  \
    \      uniquely the HOTP device such as a serial number, a token ID,\n       \
    \ etc.  Obviously, this is in the context of an application or\n        service\
    \ -- different application or service providers will have\n        different secrets\
    \ and settings.\n      - Several master keys MK_i are used and each HOTP device\
    \ stores a\n        set of different derived secrets, {K_i,j = SHA-1(MK_i,j)}\
    \ where\n        j stands for a public piece of information identifying the\n\
    \        device.  The idea would be to store ONLY the active master key\n    \
    \    at the validation server, in the Hardware Security Module (HSM),\n      \
    \  and keep in a safe place, using secret sharing methods such as\n        [Shamir]\
    \ for instance.  In this case, if a master secret MK_i is\n        compromised,\
    \ then it is possible to switch to another secret\n        without replacing all\
    \ the devices.\n   The drawback in the deterministic case is that the exposure\
    \ of the\n   master secret would obviously enable an attacker to rebuild any\n\
    \   shared secret based on correct public information.  The revocation of\n  \
    \ all secrets would be required, or switching to a new set of secrets\n   in the\
    \ case of multiple master keys.\n   On the other hand, the device used to store\
    \ the master key(s) and\n   generate the shared secrets MUST be tamper resistant.\
    \  Furthermore,\n   the HSM will not be exposed outside the security perimeter\
    \ of the\n   validation system, therefore reducing the risk of leakage.\n   Random\
    \ Generation\n   -----------------\n   The shared secrets are randomly generated.\
    \  We RECOMMEND following\n   the recommendations in [RFC4086] and selecting a\
    \ good and secure\n   random source for generating these secrets.  A (true) random\n\
    \   generator requires a naturally occurring source of randomness.\n   Practically,\
    \ there are two possible avenues to consider for the\n   generation of the shared\
    \ secrets:\n      * Hardware-based generators: they exploit the randomness that\n\
    \   occurs in physical phenomena.  A nice implementation can be based on\n   oscillators\
    \ and built in such ways that active attacks are more\n   difficult to perform.\n\
    \      * Software-based generators: designing a good software random\n   generator\
    \ is not an easy task.  A simple, but efficient,\n   implementation should be\
    \ based on various sources and apply to the\n   sampled sequence a one-way function\
    \ such as SHA-1.\n   We RECOMMEND selecting proven products, being hardware or\
    \ software\n   generators, for the computation of shared secrets.\n   We also\
    \ RECOMMEND storing the shared secrets securely, and more\n   specifically encrypting\
    \ the shared secrets when stored using tamper-\n   resistant hardware encryption\
    \ and exposing them only when required:\n   for example, the shared secret is\
    \ decrypted when needed to verify an\n   HOTP value, and re-encrypted immediately\
    \ to limit exposure in the RAM\n   for a short period of time.  The data store\
    \ holding the shared\n   secrets MUST be in a secure area, to avoid as much as\
    \ possible direct\n   attack on the validation system and secrets database.\n\
    \   Particularly, access to the shared secrets should be limited to\n   programs\
    \ and processes required by the validation system only.  We\n   will not elaborate\
    \ on the different security mechanisms to put in\n   place, but obviously, the\
    \ protection of shared secrets is of the\n   uttermost importance.\n"
- title: 8.  Composite Shared Secrets
  contents:
  - "8.  Composite Shared Secrets\n   It may be desirable to include additional authentication\
    \ factors in\n   the shared secret K.  These additional factors can consist of\
    \ any\n   data known at the token but not easily obtained by others.  Examples\n\
    \   of such data include:\n      * PIN or Password obtained as user input at the\
    \ token\n      * Phone number\n      * Any unique identifier programmatically\
    \ available at the token\n   In this scenario, the composite shared secret K is\
    \ constructed during\n   the provisioning process from a random seed value combined\
    \ with one\n   or more additional authentication factors.  The server could either\n\
    \   build on-demand or store composite secrets -- in any case, depending\n   on\
    \ implementation choice, the token only stores the seed value.  When\n   the token\
    \ performs the HOTP calculation, it computes K from the seed\n   value and the\
    \ locally derived or input values of the other\n   authentication factors.\n \
    \  The use of composite shared secrets can strengthen HOTP-based\n   authentication\
    \ systems through the inclusion of additional\n   authentication factors at the\
    \ token.  To the extent that the token is\n   a trusted device, this approach\
    \ has the further benefit of not\n   requiring exposure of the authentication\
    \ factors (such as the user\n   input PIN) to other devices.\n"
- title: 9.  Bi-Directional Authentication
  contents:
  - "9.  Bi-Directional Authentication\n   Interestingly enough, the HOTP client could\
    \ also be used to\n   authenticate the validation server, claiming that it is\
    \ a genuine\n   entity knowing the shared secret.\n   Since the HOTP client and\
    \ the server are synchronized and share the\n   same secret (or a method to recompute\
    \ it), a simple 3-pass protocol\n   could be put in place:\n   1- The end user\
    \ enter the TokenID and a first OTP value OTP1;\n   2- The server checks OTP1\
    \ and if correct, sends back OTP2;\n   3- The end user checks OTP2 using his HOTP\
    \ device and if correct,\n      uses the web site.\n   Obviously, as indicated\
    \ previously, all the OTP communications have\n   to take place over a secure\
    \ channel, e.g., SSL/TLS, IPsec\n   connections.\n"
- title: 10.  Conclusion
  contents:
  - "10.  Conclusion\n   This document describes HOTP, a HMAC-based One-Time Password\n\
    \   algorithm.  It also recommends the preferred implementation and\n   related\
    \ modes of operations for deploying the algorithm.\n   The document also exhibits\
    \ elements of security and demonstrates that\n   the HOTP algorithm is practical\
    \ and sound, the best possible attack\n   being a brute force attack that can\
    \ be prevented by careful\n   implementation of countermeasures in the validation\
    \ server.\n   Eventually, several enhancements have been proposed, in order to\n\
    \   improve security if needed for specific applications.\n"
- title: 11.  Acknowledgements
  contents:
  - "11.  Acknowledgements\n   The authors would like to thank Siddharth Bajaj, Alex\
    \ Deacon, Loren\n   Hart, and Nico Popp for their help during the conception and\n\
    \   redaction of this document.\n"
- title: 12.  Contributors
  contents:
  - "12.  Contributors\n   The authors of this document would like to emphasize the\
    \ role of\n   three persons who have made a key contribution to this document:\n\
    \   - Laszlo Elteto is system architect with SafeNet, Inc.\n   - Ernesto Frutos\
    \ is director of Engineering with Authenex, Inc.\n   - Fred McClain is Founder\
    \ and CTO with Boojum Mobile, Inc.\n   Without their advice and valuable inputs,\
    \ this document would not be\n   the same.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [BCK1]     M.  Bellare, R.  Canetti and H.  Krawczyk,\
    \ \"Keyed Hash\n              Functions and Message Authentication\", Proceedings\
    \ of\n              Crypto'96, LNCS Vol. 1109, pp. 1-15.\n   [BCK2]     Krawczyk,\
    \ H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n              Hashing for Message\
    \ Authentication\", RFC 2104, February\n              1997.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC3979]  Bradner, S., \"Intellectual Property\
    \ Rights in IETF\n              Technology\", BCP 79, RFC 3979, March 2005.\n\
    \   [RFC4086]  Eastlake, D., 3rd, Schiller, J., and S.  Crocker,\n           \
    \   \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n           \
    \   June 2005.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [OATH]     Initiative for Open AuTHentication\n\
    \              http://www.openauthentication.org\n   [PrOo]     B.  Preneel and\
    \ P. van Oorschot, \"MD-x MAC and building\n              fast MACs from hash\
    \ functions\", Advances in Cryptology\n              CRYPTO '95, Lecture Notes\
    \ in Computer Science Vol. 963, D.\n              Coppersmith ed., Springer-Verlag,\
    \ 1995.\n   [Crack]    Crack in SHA-1 code 'stuns' security gurus\n          \
    \    http://www.eetimes.com/showArticle.jhtml?\n              articleID=60402150\n\
    \   [Sha1]     Bruce Schneier.  SHA-1 broken.  February 15, 2005.\n          \
    \    http://www.schneier.com/blog/archives/2005/02/\n              sha1_broken.html\n\
    \   [Res]      Researchers: Digital encryption standard flawed\n             \
    \ http://news.com.com/\n              Researchers+Digital+encryption+standard+flawed/\n\
    \              2100-1002-5579881.html?part=dht&tag=ntop&tag=nl.e703\n   [Shamir]\
    \   How to Share a Secret, by Adi Shamir.  In Communications\n              of\
    \ the ACM, Vol. 22, No. 11, pp. 612-613, November, 1979.\n"
- title: 'Appendix A - HOTP Algorithm Security: Detailed Analysis'
  contents:
  - "Appendix A - HOTP Algorithm Security: Detailed Analysis\n   The security analysis\
    \ of the HOTP algorithm is summarized in this\n   section.  We first detail the\
    \ best attack strategies, and then\n   elaborate on the security under various\
    \ assumptions and the impact of\n   the truncation and make some recommendations\
    \ regarding the number of\n   digits.\n   We focus this analysis on the case where\
    \ Digit = 6, i.e., an HOTP\n   function that produces 6-digit values, which is\
    \ the bare minimum\n   recommended in this document.\n"
- title: A.1.  Definitions and Notations
  contents:
  - "A.1.  Definitions and Notations\n   We denote by {0,1}^l the set of all strings\
    \ of length l.\n   Let Z_{n} = {0,.., n - 1}.\n   Let IntDiv(a,b) denote the integer\
    \ division algorithm that takes\n   input integers a, b where a >= b >= 1 and\
    \ returns integers (q,r)\n   the quotient and remainder, respectively, of the\
    \ division of a by b.\n   (Thus, a = bq + r and 0 <= r < b.)\n   Let H: {0,1}^k\
    \ x {0,1}^c --> {0,1}^n be the base function that takes\n   a k-bit key K and\
    \ c-bit counter C and returns an n-bit output H(K,C).\n   (In the case of HOTP,\
    \ H is HMAC-SHA-1; we use this formal definition\n   for generalizing our proof\
    \ of security.)\n"
- title: 'A.2.  The Idealized Algorithm: HOTP-IDEAL'
  contents:
  - "A.2.  The Idealized Algorithm: HOTP-IDEAL\n   We now define an idealized counterpart\
    \ of the HOTP algorithm.  In\n   this algorithm, the role of H is played by a\
    \ random function that\n   forms the key.\n   To be more precise, let Maps(c,n)\
    \ denote the set of all functions\n   mapping from {0,1}^c to {0,1}^n.  The idealized\
    \ algorithm has key\n   space Maps(c,n), so that a \"key\" for such an algorithm\
    \ is a function\n   h from {0,1}^c to {0,1}^n.  We imagine this key (function)\
    \ to be\n   drawn at random.  It is not feasible to implement this idealized\n\
    \   algorithm, since the key, being a function from {0,1}^c to {0,1}^n,\n   is\
    \ way too large to even store.  So why consider it?\n   Our security analysis\
    \ will show that as long as H satisfies a certain\n   well-accepted assumption,\
    \ the security of the actual and idealized\n   algorithms is for all practical\
    \ purposes the same.  The task that\n   really faces us, then, is to assess the\
    \ security of the idealized\n   algorithm.\n   In analyzing the idealized algorithm,\
    \ we are concentrating on\n   assessing the quality of the design of the algorithm\
    \ itself,\n   independently of HMAC-SHA-1.  This is in fact the important issue.\n"
- title: A.3.  Model of Security
  contents:
  - "A.3.  Model of Security\n   The model exhibits the type of threats or attacks\
    \ that are being\n   considered and enables one to assess the security of HOTP\
    \ and HOTP-\n   IDEAL.  We denote ALG as either HOTP or HOTP-IDEAL for the purpose\
    \ of\n   this security analysis.\n   The scenario we are considering is that a\
    \ user and server share a key\n   K for ALG.  Both maintain a counter C, initially\
    \ zero, and the user\n   authenticates itself by sending ALG(K,C) to the server.\
    \  The latter\n   accepts if this value is correct.\n   In order to protect against\
    \ accidental increment of the user counter,\n   the server, upon receiving a value\
    \ z, will accept as long as z equals\n   ALG(K,i) for some i in the range C,...,C\
    \ + s-1, where s is the\n   resynchronization parameter and C is the server counter.\
    \  If it\n   accepts with some value of i, it then increments its counter to i+1.\n\
    \   If it does not accept, it does not change its counter value.\n   The model\
    \ we specify captures what an adversary can do and what it\n   needs to achieve\
    \ in order to \"win\".  First, the adversary is assumed\n   to be able to eavesdrop,\
    \ meaning, to see the authenticator\n   transmitted by the user.  Second, the\
    \ adversary wins if it can get\n   the server to accept an authenticator relative\
    \ to a counter value for\n   which the user has never transmitted an authenticator.\n\
    \   The formal adversary, which we denote by B, starts out knowing which\n   algorithm\
    \ ALG is being used, knowing the system design, and knowing\n   all system parameters.\
    \  The one and only thing it is not given a\n   priori is the key K shared between\
    \ the user and the server.\n   The model gives B full control of the scheduling\
    \ of events.  It has\n   access to an authenticator oracle representing the user.\
    \  By calling\n   this oracle, the adversary can ask the user to authenticate\
    \ itself\n   and get back the authenticator in return.  It can call this oracle\
    \ as\n   often as it wants and when it wants, using the authenticators it\n  \
    \ accumulates to perhaps \"learn\" how to make authenticators itself.  At\n  \
    \ any time, it may also call a verification oracle, supplying the\n   latter with\
    \ a candidate authenticator of its choice.  It wins if the\n   server accepts\
    \ this accumulator.\n   Consider the following game involving an adversary B that\
    \ is\n   attempting to compromise the security of an authentication algorithm\n\
    \   ALG: K x {0,1}^c --> R.\n   Initializations - A key K is selected at random\
    \ from K, a counter C\n   is initialized to 0, and the Boolean value win is set\
    \ to false.\n   Game execution - Adversary B is provided with the two following\n\
    \   oracles:\n   Oracle AuthO()\n   --------------\n      A = ALG(K,C)\n     \
    \ C = C + 1\n      Return O to B\n   Oracle VerO(A)\n   --------------\n     \
    \ i = C\n      While (i <= C + s - 1 and Win == FALSE) do\n         If A == ALG(K,i)\
    \ then Win = TRUE; C = i + 1\n         Else i = i + 1\n      Return Win to B\n\
    \   AuthO() is the authenticator oracle and VerO(A) is the verification\n   oracle.\n\
    \   Upon execution, B queries the two oracles at will.  Let Adv(B) be the\n  \
    \ probability that win gets set to true in the above game.  This is the\n   probability\
    \ that the adversary successfully impersonates the user.\n   Our goal is to assess\
    \ how large this value can be as a function of\n   the number v of verification\
    \ queries made by B, the number a of\n   authenticator oracle queries made by\
    \ B, and the running time t of B.\n   This will tell us how to set the throttle,\
    \ which effectively upper\n   bounds v.\n"
- title: A.4.  Security of the Ideal Authentication Algorithm
  contents:
  - "A.4.  Security of the Ideal Authentication Algorithm\n   This section summarizes\
    \ the security analysis of HOTP-IDEAL, starting\n   with the impact of the conversion\
    \ modulo 10^Digit and then focusing\n   on the different possible attacks.\n"
- title: A.4.1.  From Bits to Digits
  contents:
  - "A.4.1.  From Bits to Digits\n   The dynamic offset truncation of a random n-bit\
    \ string yields a\n   random 31-bit string.  What happens to the distribution\
    \ when it is\n   taken modulo m = 10^Digit, as done in HOTP?\n   The following\
    \ lemma estimates the biases in the outputs in this case.\n   Lemma 1\n   -------\n\
    \   Let N >= m >= 1 be integers, and let (q,r) = IntDiv(N,m).  For z in\n   Z_{m}\
    \ let:\n          P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{n}]\n \
    \  Then for any z in Z_{m}\n   P_{N,m}(z) =   (q + 1) / N    if 0 <= z < r\n \
    \                 q / N          if r <= z < m\n   Proof of Lemma 1\n   ----------------\n\
    \   Let the random variable X be uniformly distributed over Z_{N}.  Then:\n  \
    \ P_{N,m}(z)  = Pr [X mod m = z]\n                = Pr [X < mq] * Pr [X mod m\
    \ = z| X < mq]\n                + Pr [mq <= X < N] * Pr [X mod m = z| mq <= X\
    \ < N]\n                = mq/N * 1/m +\n                   (N - mq)/N * 1 / (N\
    \ - mq)     if 0 <= z < N - mq\n                   0                         \
    \    if N - mq <= z <= m\n                = q/N +\n                   r/N * 1\
    \ / r                   if 0 <= z < N - mq\n                   0             \
    \                if r <= z <= m\n   Simplifying yields the claimed equation.\n\
    \   Let N = 2^31, d = 6, and m = 10^d.  If x is chosen at random from\n   Z_{N}\
    \ (meaning, is a random 31-bit string), then reducing it to a 6-\n   digit number\
    \ by taking x mod m does not yield a random 6-digit\n   number.\n   Rather, x\
    \ mod m is distributed as shown in the following table:\n   Values           \
    \    Probability that each appears as output\n   ----------------------------------------------------------------\n\
    \   0,1,...,483647       2148/2^31 roughly equals to 1.00024045/10^6\n   483648,...,999999\
    \    2147/2^31 roughly equals to 0.99977478/10^6\n   If X is uniformly distributed\
    \ over Z_{2^31} (meaning, is a random\n   31-bit string), then the above shows\
    \ the probabilities for different\n   outputs of X mod 10^6.  The first set of\
    \ values appears with\n   probability slightly greater than 10^-6, the rest with\
    \ probability\n   slightly less, meaning that the distribution is slightly non-uniform.\n\
    \   However, as the table above indicates, the bias is small, and as we\n   will\
    \ see later, negligible: the probabilities are very close to\n   10^-6.\n"
- title: A.4.2.  Brute Force Attacks
  contents:
  - "A.4.2.  Brute Force Attacks\n   If the authenticator consisted of d random digits,\
    \ then a brute force\n   attack using v verification attempts would succeed with\
    \ probability\n   sv/10^Digit.\n   However, an adversary can exploit the bias\
    \ in the outputs of\n   HOTP-IDEAL, predicted by Lemma 1, to mount a slightly\
    \ better attack.\n   Namely, it makes authentication attempts with authenticators\
    \ that are\n   the most likely values, meaning the ones in the range 0,...,r -\
    \ 1,\n   where (q,r) = IntDiv(2^31,10^Digit).\n   The following specifies an adversary\
    \ in our model of security that\n   mounts the attack.  It estimates the success\
    \ probability as a\n   function of the number of verification queries.\n   For\
    \ simplicity, we assume that the number of verification queries is\n   at most\
    \ r.  With N = 2^31 and m = 10^6, we have r = 483,648, and the\n   throttle value\
    \ is certainly less than this, so this assumption is not\n   much of a restriction.\n\
    \   Proposition 1\n   -------------\n   Suppose m = 10^Digit < 2^31, and let (q,r)\
    \ = IntDiv(2^31,m).  Assume\n   s <= m.  The brute-force-attack adversary B-bf\
    \ attacks HOTP using v\n   <= r verification oracle queries.  This adversary makes\
    \ no\n   authenticator oracle queries, and succeeds with probability\n       \
    \             Adv(B-bf) = 1 - (1 - v(q+1)/2^31)^s\n   which is roughly equal to\n\
    \                             sv * (q+1)/2^31\n   With m = 10^6 we get q = 2,147.\
    \  In that case, the brute force attack\n   using v verification attempts succeeds\
    \ with probability\n         Adv(B-bf) roughly = sv * 2148/2^31 = sv * 1.00024045/10^6\n\
    \   As this equation shows, the resynchronization parameter s has a\n   significant\
    \ impact in that the adversary's success probability is\n   proportional to s.\
    \  This means that s cannot be made too large\n   without compromising security.\n"
- title: A.4.3.  Brute force attacks are the best possible attacks.
  contents:
  - "A.4.3.  Brute force attacks are the best possible attacks.\n   A central question\
    \ is whether there are attacks any better than the\n   brute force one.  In particular,\
    \ the brute force attack did not\n   attempt to collect authenticators sent by\
    \ the user and try to\n   cryptanalyze them in an attempt to learn how to better\
    \ construct\n   authenticators.  Would doing this help? Is there some way to \"\
    learn\"\n   how to build authenticators that result in a higher success rate than\n\
    \   given by the brute-force attack?\n   The following says the answer to these\
    \ questions is no.  No matter\n   what strategy the adversary uses, and even if\
    \ it sees, and tries to\n   exploit, the authenticators from authentication attempts\
    \ of the user,\n   its success probability will not be above that of the brute\
    \ force\n   attack -- this is true as long as the number of authentications it\n\
    \   observes is not incredibly large.  This is valuable information\n   regarding\
    \ the security of the scheme.\n   Proposition 2 ------------- Suppose m = 10^Digit\
    \ < 2^31, and let\n   (q,r) = IntDiv(2^31,m).  Let B be any adversary attacking\
    \ HOTP-IDEAL\n   using v verification oracle queries and a <= 2^c - s authenticator\n\
    \   oracle queries.  Then\n                        Adv(B) < = sv * (q+1)/ 2^31\n\
    \   Note: This result is conditional on the adversary not seeing more\n   than\
    \ 2^c - s authentications performed by the user, which is hardly\n   restrictive\
    \ as long as c is large enough.\n   With m = 10^6, we get q = 2,147.  In that\
    \ case, Proposition 2 says\n   that any adversary B attacking HOTP-IDEAL and making\
    \ v verification\n   attempts succeeds with probability at most\n   Equation 1\n\
    \   ----------\n              sv * 2148/2^31 roughly = sv * 1.00024045/10^6\n\
    \   Meaning, B's success rate is not more than that achieved by the brute\n  \
    \ force attack.\n"
- title: A.5.  Security Analysis of HOTP
  contents:
  - "A.5.  Security Analysis of HOTP\n   We have analyzed, in the previous sections,\
    \ the security of the\n   idealized counterparts HOTP-IDEAL of the actual authentication\n\
    \   algorithm HOTP.  We now show that, under appropriate and well-\n   believed\
    \ assumption on H, the security of the actual algorithms is\n   essentially the\
    \ same as that of its idealized counterpart.\n   The assumption in question is\
    \ that H is a secure pseudorandom\n   function, or PRF, meaning that its input-output\
    \ values are\n   indistinguishable from those of a random function in practice.\n\
    \   Consider an adversary A that is given an oracle for a function f:\n   {0,1}^c\
    \ --> {0, 1}^n and eventually outputs a bit.  We denote Adv(A)\n   as the prf-advantage\
    \ of A, which represents how well the adversary\n   does at distinguishing the\
    \ case where its oracle is H(K,.) from the\n   case where its oracle is a random\
    \ function of {0,1}^c to {0,1}^n.\n   One possible attack is based on exhaustive\
    \ search for the key K.  If\n   A runs for t steps and T denotes the time to perform\
    \ one computation\n   of H, its prf-advantage from this attack turns out to be\
    \ (t/T)2^-k.\n   Another possible attack is a birthday one [PrOo], whereby A can\n\
    \   attain advantage p^2/2^n in p oracle queries and running time about\n   pT.\n\
    \   Our assumption is that these are the best possible attacks.  This\n   translates\
    \ into the following.\n   Assumption 1\n   ------------\n   Let T denotes the\
    \ time to perform one computation of H.  Then if A is\n   any adversary with running\
    \ time at most t and making at most p oracle\n   queries,\n                  \
    \     Adv(A) <= (t/T)/2^k + p^2/2^n\n   In practice, this assumption means that\
    \ H is very secure as PRF.  For\n   example, given that k = n = 160, an attacker\
    \ with running time 2^60\n   and making 2^40 oracle queries has advantage at most\
    \ (about) 2^-80.\n   Theorem 1\n   ---------\n   Suppose m = 10^Digit < 2^31,\
    \ and let (q,r) = IntDiv(2^31,m).  Let B\n   be any adversary attacking HOTP using\
    \ v verification oracle queries,\n   a <= 2^c - s authenticator oracle queries,\
    \ and running time t.  Let T\n   denote the time to perform one computation of\
    \ H.  If Assumption 1 is\n   true, then\n         Adv(B) <= sv * (q + 1)/2^31\
    \ + (t/T)/2^k + ((sv + a)^2)/2^n\n   In practice, the (t/T)2^-k + ((sv + a)^2)2^-n\
    \ term is much smaller\n   than the sv(q + 1)/2^n term, so that the above says\
    \ that for all\n   practical purposes the success rate of an adversary attacking\
    \ HOTP is\n   sv(q + 1)/2^n, just as for HOTP-IDEAL, meaning the HOTP algorithm\
    \ is\n   in practice essentially as good as its idealized counterpart.\n   In\
    \ the case m = 10^6 of a 6-digit output, this means that an\n   adversary making\
    \ v authentication attempts will have a success rate\n   that is at most that\
    \ of Equation 1.\n   For example, consider an adversary with running time at most\
    \ 2^60\n   that sees at most 2^40 authentication attempts of the user.  Both\n\
    \   these choices are very generous to the adversary, who will typically\n   not\
    \ have these resources, but we are saying that even such a powerful\n   adversary\
    \ will not have more success than indicated by Equation 1.\n   We can safely assume\
    \ sv <= 2^40 due to the throttling and bounds on\n   s.  So:\n       (t/T)/2^k\
    \ + ((sv + a)^2)/2^n  <= 2^60/2^160 + (2^41)^2/2^160\n                       \
    \             roughly <= 2^-78\n   which is much smaller than the success probability\
    \ of Equation 1 and\n   negligible compared to it.\n"
- title: Appendix B - SHA-1 Attacks
  contents:
  - "Appendix B - SHA-1 Attacks\n   This sections addresses the impact of the recent\
    \ attacks on SHA-1 on\n   the security of the HMAC-SHA-1-based HOTP.  We begin\
    \ with some\n   discussion of the situation of SHA-1 and then discuss the relevance\n\
    \   to HMAC-SHA-1 and HOTP.  Cited references are in Section 13.\n"
- title: B.1.  SHA-1 Status
  contents:
  - "B.1.  SHA-1 Status\n   A collision for a hash function h means a pair x,y of\
    \ different\n   inputs such that h(x)=h(y).  Since SHA-1 outputs 160 bits, a birthday\n\
    \   attack finds a collision in 2^{80} trials.  (A trial means one\n   computation\
    \ of the function.)  This was thought to be the best\n   possible until Wang,\
    \ Yin, and Yu announced on February 15, 2005, that\n   they had an attack finding\
    \ collisions in 2^{69} trials.\n   Is SHA-1 broken? For most practical purposes,\
    \ we would say probably\n   not, since the resources needed to mount the attack\
    \ are huge.  Here\n   is one way to get a sense of it: we can estimate it is about\
    \ the same\n   as the time we would need to factor a 760-bit RSA modulus, and\
    \ this\n   is currently considered out of reach.\n   Burr of NIST is quoted in\
    \ [Crack] as saying \"Large national\n   intelligence agencies could do this in\
    \ a reasonable amount of time\n   with a few million dollars in computer time\"\
    .  However, the\n   computation may be out of reach of all but such well-funded\
    \ agencies.\n   One should also ask what impact finding SHA-1 collisions actually\
    \ has\n   on security of real applications such as signatures.  To exploit a\n\
    \   collision x,y to forge signatures, you need to somehow obtain a\n   signature\
    \ of x and then you can forge a signature of y.  How damaging\n   this is depends\
    \ on the content of y: the y created by the attack may\n   not be meaningful in\
    \ the application context.  Also, one needs a\n   chosen-message attack to get\
    \ the signature of x.  This seems possible\n   in some contexts, but not others.\
    \  Overall, it is not clear that the\n   impact on the security of signatures\
    \ is significant.\n   Indeed, one can read in the press that SHA-1 is \"broken\"\
    \ [Sha1] and\n   that encryption and SSL are \"broken\" [Res].  The media have\
    \ a\n   tendency to magnify events: it would hardly be interesting to\n   announce\
    \ in the news that a team of cryptanalysts did very\n   interesting theoretical\
    \ work in attacking SHA-1.\n   Cryptographers are excited too.  But mainly because\
    \ this is an\n   important theoretical breakthrough.  Attacks can only get better\
    \ with\n   time: it is therefore important to monitor any progress in hash\n \
    \  functions cryptanalysis and be prepared for any really practical\n   break\
    \ with a sound migration plan for the future.\n"
- title: B.2.  HMAC-SHA-1 Status
  contents:
  - "B.2.  HMAC-SHA-1 Status\n   The new attacks on SHA-1 have no impact on the security\
    \ of\n   HMAC-SHA-1.  The best attack on the latter remains one needing a\n  \
    \ sender to authenticate 2^{80} messages before an adversary can create\n   a\
    \ forgery.  Why?\n   HMAC is not a hash function.  It is a message authentication\
    \ code\n   (MAC) that uses a hash function internally.  A MAC depends on a\n \
    \  secret key, while hash functions don't.  What one needs to worry\n   about\
    \ with a MAC is forgery, not collisions.  HMAC was designed so\n   that collisions\
    \ in the hash function (here SHA-1) do not yield\n   forgeries for HMAC.\n   Recall\
    \ that HMAC-SHA-1(K,x) = SHA-1(K_o,SHA-1(K_i,x)) where the keys\n   K_o,K_i are\
    \ derived from K.  Suppose the attacker finds a pair x,y\n   such that SHA-1(K_i,x)\
    \ = SHA-1(K_i,y).  (Call this a hidden-key\n   collision.)  Then if it can obtain\
    \ the MAC of x (itself a tall\n   order), it can forge the MAC of y.  (These values\
    \ are the same.)  But\n   finding hidden-key collisions is harder than finding\
    \ collisions,\n   because the attacker does not know the hidden key K_i.  All\
    \ it may\n   have is some outputs of HMAC-SHA-1 with key K.  To date, there are\
    \ no\n   claims or evidence that the recent attacks on SHA-1 extend to find\n\
    \   hidden-key collisions.\n   Historically, the HMAC design has already proven\
    \ itself in this\n   regard.  MD5 is considered broken in that collisions in this\
    \ hash\n   function can be found relatively easily.  But there is still no\n \
    \  attack on HMAC-MD5 better than the trivial 2^{64} time birthday one.\n   (MD5\
    \ outputs 128 bits, not 160.)  We are seeing this strength of HMAC\n   coming\
    \ into play again in the SHA-1 context.\n"
- title: B.3.  HOTP Status
  contents:
  - "B.3.  HOTP Status\n   Since no new weakness has surfaced in HMAC-SHA-1, there\
    \ is no impact\n   on HOTP.  The best attacks on HOTP remain those described in\
    \ the\n   document, namely, to try to guess output values.\n   The security proof\
    \ of HOTP requires that HMAC-SHA-1 behave like a\n   pseudorandom function.  The\
    \ quality of HMAC-SHA-1 as a pseudorandom\n   function is not impacted by the\
    \ new attacks on SHA-1, and so neither\n   is this proven guarantee.\n"
- title: 'Appendix C - HOTP Algorithm: Reference Implementation'
  contents:
  - "Appendix C - HOTP Algorithm: Reference Implementation\n   /*\n    * OneTimePasswordAlgorithm.java\n\
    \    * OATH Initiative,\n    * HOTP one-time password algorithm\n    *\n    */\n\
    \   /* Copyright (C) 2004, OATH.  All rights reserved.\n    *\n    * License to\
    \ copy and use this software is granted provided that it\n    * is identified\
    \ as the \"OATH HOTP Algorithm\" in all material\n    * mentioning or referencing\
    \ this software or this function.\n    *\n    * License is also granted to make\
    \ and use derivative works provided\n    * that such works are identified as\n\
    \    *  \"derived from OATH HOTP algorithm\"\n    * in all material mentioning\
    \ or referencing the derived work.\n    *\n    * OATH (Open AuTHentication) and\
    \ its members make no\n    * representations concerning either the merchantability\
    \ of this\n    * software or the suitability of this software for any particular\n\
    \    * purpose.\n    *\n    * It is provided \"as is\" without express or implied\
    \ warranty\n    * of any kind and OATH AND ITS MEMBERS EXPRESSaLY DISCLAIMS\n\
    \    * ANY WARRANTY OR LIABILITY OF ANY KIND relating to this software.\n    *\n\
    \    * These notices must be retained in any copies of any part of this\n    *\
    \ documentation and/or software.\n    */\n   package org.openauthentication.otp;\n\
    \   import java.io.IOException;\n   import java.io.File;\n   import java.io.DataInputStream;\n\
    \   import java.io.FileInputStream ;\n   import java.lang.reflect.UndeclaredThrowableException;\n\
    \   import java.security.GeneralSecurityException;\n   import java.security.NoSuchAlgorithmException;\n\
    \   import java.security.InvalidKeyException;\n   import javax.crypto.Mac;\n \
    \  import javax.crypto.spec.SecretKeySpec;\n   /**\n    * This class contains\
    \ static methods that are used to calculate the\n    * One-Time Password (OTP)\
    \ using\n    * JCE to provide the HMAC-SHA-1.\n    *\n    * @author Loren Hart\n\
    \    * @version 1.0\n    */\n   public class OneTimePasswordAlgorithm {\n    \
    \   private OneTimePasswordAlgorithm() {}\n       // These are used to calculate\
    \ the check-sum digits.\n       //                                0  1  2  3 \
    \ 4  5  6  7  8  9\n       private static final int[] doubleDigits =\n       \
    \                { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };\n       /**\n        * Calculates\
    \ the checksum using the credit card algorithm.\n        * This algorithm has\
    \ the advantage that it detects any single\n        * mistyped digit and any single\
    \ transposition of\n        * adjacent digits.\n        *\n        * @param num\
    \ the number to calculate the checksum for\n        * @param digits number of\
    \ significant places in the number\n        *\n        * @return the checksum\
    \ of num\n        */\n       public static int calcChecksum(long num, int digits)\
    \ {\n           boolean doubleDigit = true;\n           int     total = 0;\n \
    \          while (0 < digits--) {\n               int digit = (int) (num % 10);\n\
    \               num /= 10;\n               if (doubleDigit) {\n              \
    \     digit = doubleDigits[digit];\n               }\n               total +=\
    \ digit;\n               doubleDigit = !doubleDigit;\n           }\n         \
    \  int result = total % 10;\n           if (result > 0) {\n               result\
    \ = 10 - result;\n           }\n           return result;\n       }\n       /**\n\
    \        * This method uses the JCE to provide the HMAC-SHA-1\n        * algorithm.\n\
    \        * HMAC computes a Hashed Message Authentication Code and\n        * in\
    \ this case SHA1 is the hash algorithm used.\n        *\n        * @param keyBytes\
    \   the bytes to use for the HMAC-SHA-1 key\n        * @param text       the message\
    \ or text to be authenticated.\n        *\n        * @throws NoSuchAlgorithmException\
    \ if no provider makes\n        *       either HmacSHA1 or HMAC-SHA-1\n      \
    \  *       digest algorithms available.\n        * @throws InvalidKeyException\n\
    \        *       The secret provided was not a valid HMAC-SHA-1 key.\n       \
    \ *\n        */\n       public static byte[] hmac_sha1(byte[] keyBytes, byte[]\
    \ text)\n           throws NoSuchAlgorithmException, InvalidKeyException\n   \
    \    {\n   //        try {\n               Mac hmacSha1;\n               try {\n\
    \                   hmacSha1 = Mac.getInstance(\"HmacSHA1\");\n              \
    \ } catch (NoSuchAlgorithmException nsae) {\n                   hmacSha1 = Mac.getInstance(\"\
    HMAC-SHA-1\");\n               }\n               SecretKeySpec macKey =\n    \
    \       new SecretKeySpec(keyBytes, \"RAW\");\n               hmacSha1.init(macKey);\n\
    \               return hmacSha1.doFinal(text);\n   //        } catch (GeneralSecurityException\
    \ gse) {\n   //            throw new UndeclaredThrowableException(gse);\n   //\
    \        }\n       }\n       private static final int[] DIGITS_POWER\n     //\
    \ 0 1  2   3    4     5      6       7        8\n     = {1,10,100,1000,10000,100000,1000000,10000000,100000000};\n\
    \       /**\n        * This method generates an OTP value for the given\n    \
    \    * set of parameters.\n        *\n        * @param secret       the shared\
    \ secret\n        * @param movingFactor the counter, time, or other value that\n\
    \        *                     changes on a per use basis.\n        * @param codeDigits\
    \   the number of digits in the OTP, not\n        *                     including\
    \ the checksum, if any.\n        * @param addChecksum  a flag that indicates if\
    \ a checksum digit\n        *                     should be appended to the OTP.\n\
    \        * @param truncationOffset the offset into the MAC result to\n       \
    \ *                     begin truncation.  If this value is out of\n        *\
    \                     the range of 0 ... 15, then dynamic\n        *         \
    \            truncation  will be used.\n        *                     Dynamic\
    \ truncation is when the last 4\n        *                     bits of the last\
    \ byte of the MAC are\n        *                     used to determine the start\
    \ offset.\n        * @throws NoSuchAlgorithmException if no provider makes\n \
    \       *                     either HmacSHA1 or HMAC-SHA-1\n        *       \
    \              digest algorithms available.\n        * @throws InvalidKeyException\n\
    \        *                     The secret provided was not\n        *        \
    \             a valid HMAC-SHA-1 key.\n        *\n        * @return A numeric\
    \ String in base 10 that includes\n        * {@link codeDigits} digits plus the\
    \ optional checksum\n        * digit if requested.\n        */\n       static\
    \ public String generateOTP(byte[] secret,\n                  long movingFactor,\n\
    \             int codeDigits,\n                  boolean addChecksum,\n      \
    \       int truncationOffset)\n           throws NoSuchAlgorithmException, InvalidKeyException\n\
    \       {\n           // put movingFactor value into text byte array\n     String\
    \ result = null;\n     int digits = addChecksum ? (codeDigits + 1) : codeDigits;\n\
    \           byte[] text = new byte[8];\n           for (int i = text.length -\
    \ 1; i >= 0; i--) {\n               text[i] = (byte) (movingFactor & 0xff);\n\
    \               movingFactor >>= 8;\n           }\n           // compute hmac\
    \ hash\n           byte[] hash = hmac_sha1(secret, text);\n           // put selected\
    \ bytes into result int\n           int offset = hash[hash.length - 1] & 0xf;\n\
    \     if ( (0<=truncationOffset) &&\n            (truncationOffset<(hash.length-4))\
    \ ) {\n         offset = truncationOffset;\n     }\n           int binary =\n\
    \               ((hash[offset] & 0x7f) << 24)\n               | ((hash[offset\
    \ + 1] & 0xff) << 16)\n               | ((hash[offset + 2] & 0xff) << 8)\n   \
    \            | (hash[offset + 3] & 0xff);\n           int otp = binary % DIGITS_POWER[codeDigits];\n\
    \     if (addChecksum) {\n         otp =  (otp * 10) + calcChecksum(otp, codeDigits);\n\
    \     }\n     result = Integer.toString(otp);\n     while (result.length() < digits)\
    \ {\n         result = \"0\" + result;\n     }\n     return result;\n       }\n\
    \   }\n"
- title: 'Appendix D - HOTP Algorithm: Test Values'
  contents:
  - "Appendix D - HOTP Algorithm: Test Values\n   The following test data uses the\
    \ ASCII string\n   \"12345678901234567890\" for the secret:\n   Secret = 0x3132333435363738393031323334353637383930\n\
    \   Table 1 details for each count, the intermediate HMAC value.\n   Count   \
    \ Hexadecimal HMAC-SHA-1(secret, count)\n   0        cc93cf18508d94934c64b65d8ba7667fb7cde4b0\n\
    \   1        75a48a19d4cbe100644e8ac1397eea747a2d33ab\n   2        0bacb7fa082fef30782211938bc1c5e70416ff44\n\
    \   3        66c28227d03a2d5529262ff016a1e6ef76557ece\n   4        a904c900a64b35909874b33e61c5938a8e15ed1c\n\
    \   5        a37e783d7b7233c083d4f62926c7a25f238d0316\n   6        bc9cd28561042c83f219324d3c607256c03272ae\n\
    \   7        a4fb960c0bc06e1eabb804e5b397cdc4b45596fa\n   8        1b3c89f65e6c9e883012052823443f048b4332db\n\
    \   9        1637409809a679dc698207310c8c7fc07290d9e5\n   Table 2 details for\
    \ each count the truncated values (both in\n   hexadecimal and decimal) and then\
    \ the HOTP value.\n                     Truncated\n   Count    Hexadecimal   \
    \ Decimal        HOTP\n   0        4c93cf18       1284755224     755224\n   1\
    \        41397eea       1094287082     287082\n   2         82fef30        137359152\
    \     359152\n   3        66ef7655       1726969429     969429\n   4        61c5938a\
    \       1640338314     338314\n   5        33c083d4        868254676     254676\n\
    \   6        7256c032       1918287922     287922\n   7         4e5b397      \
    \   82162583     162583\n   8        2823443f        673399871     399871\n  \
    \ 9        2679dc69        645520489     520489\n"
- title: Appendix E - Extensions
  contents:
  - "Appendix E - Extensions\n   We introduce in this section several enhancements\
    \ to the HOTP\n   algorithm.  These are not recommended extensions or part of\
    \ the\n   standard algorithm, but merely variations that could be used for\n \
    \  customized implementations.\n"
- title: E.1.  Number of Digits
  contents:
  - "E.1.  Number of Digits\n   A simple enhancement in terms of security would be\
    \ to extract more\n   digits from the HMAC-SHA-1 value.\n   For instance, calculating\
    \ the HOTP value modulo 10^8 to build an 8-\n   digit HOTP value would reduce\
    \ the probability of success of the\n   adversary from sv/10^6 to sv/10^8.\n \
    \  This could give the opportunity to improve usability, e.g., by\n   increasing\
    \ T and/or s, while still achieving a better security\n   overall.  For instance,\
    \ s = 10 and 10v/10^8 = v/10^7 < v/10^6 which\n   is the theoretical optimum for\
    \ 6-digit code when s = 1.\n"
- title: E.2.  Alphanumeric Values
  contents:
  - "E.2.  Alphanumeric Values\n   Another option is to use A-Z and 0-9 values; or\
    \ rather a subset of 32\n   symbols taken from the alphanumerical alphabet in\
    \ order to avoid any\n   confusion between characters: 0, O, and Q as well as\
    \ l, 1, and I are\n   very similar, and can look the same on a small display.\n\
    \   The immediate consequence is that the security is now in the order of\n  \
    \ sv/32^6 for a 6-digit HOTP value and sv/32^8 for an 8-digit HOTP\n   value.\n\
    \   32^6 > 10^9 so the security of a 6-alphanumeric HOTP code is slightly\n  \
    \ better than a 9-digit HOTP value, which is the maximum length of an\n   HOTP\
    \ code supported by the proposed algorithm.\n   32^8 > 10^12 so the security of\
    \ an 8-alphanumeric HOTP code is\n   significantly better than a 9-digit HOTP\
    \ value.\n   Depending on the application and token/interface used for displaying\n\
    \   and entering the HOTP value, the choice of alphanumeric values could\n   be\
    \ a simple and efficient way to improve security at a reduced cost\n   and impact\
    \ on users.\n"
- title: E.3.  Sequence of HOTP Values
  contents:
  - "E.3.  Sequence of HOTP Values\n   As we suggested for the resynchronization to\
    \ enter a short sequence\n   (say, 2 or 3) of HOTP values, we could generalize\
    \ the concept to the\n   protocol, and add a parameter L that would define the\
    \ length of the\n   HOTP sequence to enter.\n   Per default, the value L SHOULD\
    \ be set to 1, but if security needs to\n   be increased, users might be asked\
    \ (possibly for a short period of\n   time, or a specific operation) to enter\
    \ L HOTP values.\n   This is another way, without increasing the HOTP length or\
    \ using\n   alphanumeric values to tighten security.\n   Note: The system MAY\
    \ also be programmed to request synchronization on\n   a regular basis (e.g.,\
    \ every night, twice a week, etc.) and to\n   achieve this purpose, ask for a\
    \ sequence of L HOTP values.\n"
- title: E.4.  A Counter-Based Resynchronization Method
  contents:
  - "E.4.  A Counter-Based Resynchronization Method\n   In this case, we assume that\
    \ the client can access and send not only\n   the HOTP value but also other information,\
    \ more specifically, the\n   counter value.\n   A more efficient and secure method\
    \ for resynchronization is possible\n   in this case.  The client application\
    \ will not send the HOTP-client\n   value only, but the HOTP-client and the related\
    \ C-client counter\n   value, the HOTP value acting as a message authentication\
    \ code of the\n   counter.\n   Resynchronization Counter-based Protocol (RCP)\n\
    \   ----------------------------------------------\n   The server accepts if the\
    \ following are all true, where C-server is\n   its own current counter value:\n\
    \   1) C-client >= C-server\n   2) C-client - C-server <= s\n   3) Check that\
    \ HOTP client is valid HOTP(K,C-Client)\n   4) If true, the server sets C to C-client\
    \ + 1 and client is\n      authenticated\n   In this case, there is no need for\
    \ managing a look-ahead window\n   anymore.  The probability of success of the\
    \ adversary is only v/10^6\n   or roughly v in one million.  A side benefit is\
    \ obviously to be able\n   to increase s \"infinitely\" and therefore improve\
    \ the system usability\n   without impacting the security.\n   This resynchronization\
    \ protocol SHOULD be used whenever the related\n   impact on the client and server\
    \ applications is deemed acceptable.\n"
- title: E.5. Data Field
  contents:
  - "E.5. Data Field\n   Another interesting option is the introduction of a Data\
    \ field, which\n   would be used for generating the One-Time Password values:\
    \ HOTP (K,\n   C, [Data]) where Data is an optional field that can be the\n  \
    \ concatenation of various pieces of identity-related information,\n   e.g., Data\
    \ = Address | PIN.\n   We could also use a Timer, either as the only moving factor\
    \ or in\n   combination with the Counter -- in this case, e.g., Data = Timer,\n\
    \   where Timer could be the UNIX-time (GMT seconds since 1/1/1970)\n   divided\
    \ by some factor (8, 16, 32, etc.) in order to give a specific\n   time step.\
    \  The time window for the One-Time Password is then equal\n   to the time step\
    \ multiplied by the resynchronization parameter as\n   defined before.  For example,\
    \ if we take 64 seconds as the time step\n   and 7 for the resynchronization parameter,\
    \ we obtain an acceptance\n   window of +/- 3 minutes.\n   Using a Data field\
    \ opens for more flexibility in the algorithm\n   implementation, provided that\
    \ the Data field is clearly specified.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   David M'Raihi (primary contact for sending comments and\
    \ questions)\n   VeriSign, Inc.\n   685 E. Middlefield Road\n   Mountain View,\
    \ CA 94043 USA\n   Phone: 1-650-426-3832\n   EMail: dmraihi@verisign.com\n   Mihir\
    \ Bellare\n   Dept of Computer Science and Engineering, Mail Code 0114\n   University\
    \ of California at San Diego\n   9500 Gilman Drive\n   La Jolla, CA 92093, USA\n\
    \   EMail: mihir@cs.ucsd.edu\n   Frank Hoornaert\n   VASCO Data Security, Inc.\n\
    \   Koningin Astridlaan 164\n   1780 Wemmel, Belgium\n   EMail: frh@vasco.com\n\
    \   David Naccache\n   Gemplus Innovation\n   34 rue Guynemer, 92447,\n   Issy\
    \ les Moulineaux, France\n   and\n   Information Security Group,\n   Royal Holloway,\n\
    \   University of London, Egham,\n   Surrey TW20 0EX, UK\n   EMail: david.naccache@gemplus.com,\
    \ david.naccache@rhul.ac.uk\n   Ohad Ranen\n   Aladdin Knowledge Systems Ltd.\n\
    \   15 Beit Oved Street\n   Tel Aviv, Israel 61110\n   EMail: Ohad.Ranen@ealaddin.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
