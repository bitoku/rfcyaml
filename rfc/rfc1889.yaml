- title: __initial_text__
  contents:
  - '          RTP: A Transport Protocol for Real-Time Applications

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memorandum describes RTP, the real-time transport protocol.\
    \ RTP\n   provides end-to-end network transport functions suitable for\n   applications\
    \ transmitting real-time data, such as audio, video or\n   simulation data, over\
    \ multicast or unicast network services. RTP does\n   not address resource reservation\
    \ and does not guarantee quality-of-\n   service for real-time services. The data\
    \ transport is augmented by a\n   control protocol (RTCP) to allow monitoring\
    \ of the data delivery in a\n   manner scalable to large multicast networks, and\
    \ to provide minimal\n   control and identification functionality. RTP and RTCP\
    \ are designed\n   to be independent of the underlying transport and network layers.\
    \ The\n   protocol supports the use of RTP-level translators and mixers.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   5.3        Profile-Specific Modifications to the RTP Header.....\
    \   14\n   5.3.1      RTP Header Extension ................................  \
    \ 14\n   6.         RTP Control Protocol -- RTCP ........................   15\n\
    \   6.1        RTCP Packet Format ..................................   17\n  \
    \ 6.2        RTCP Transmission Interval ..........................   19\n   6.2.1\
    \      Maintaining the number of session members ...........   21\n   6.2.2  \
    \    Allocation of source description bandwidth ..........   21\n   6.3      \
    \  Sender and Receiver Reports .........................   22\n   6.3.1      SR:\
    \ Sender report RTCP packet .......................   23\n   6.3.2      RR: Receiver\
    \ report RTCP packet .....................   28\n   6.3.3      Extending the sender\
    \ and receiver reports ...........   29\n   6.3.4      Analyzing sender and receiver\
    \ reports ...............   29\n   6.4        SDES: Source description RTCP packet\
    \ ................   31\n   6.4.1      CNAME: Canonical end-point identifier SDES\
    \ item .....   32\n   6.4.2      NAME: User name SDES item ...........................\
    \   34\n   6.4.3      EMAIL: Electronic mail address SDES item ............  \
    \ 34\n   6.4.4      PHONE: Phone number SDES item .......................   34\n\
    \   6.4.5      LOC: Geographic user location SDES item .............   35\n  \
    \ 6.4.6      TOOL: Application or tool name SDES item ............   35\n   6.4.7\
    \      NOTE: Notice/status SDES item .......................   35\n   6.4.8  \
    \    PRIV: Private extensions SDES item ..................   36\n   6.5      \
    \  BYE: Goodbye RTCP packet ............................   37\n   6.6        APP:\
    \ Application-defined RTCP packet ................   38\n   7.         RTP Translators\
    \ and Mixers ..........................   39\n   7.1        General Description\
    \ .................................   39\n   7.2        RTCP Processing in Translators\
    \ ......................   41\n   7.3        RTCP Processing in Mixers ...........................\
    \   43\n   7.4        Cascaded Mixers .....................................  \
    \ 44\n   8.         SSRC Identifier Allocation and Use ..................   44\n\
    \   8.1        Probability of Collision ............................   44\n  \
    \ 8.2        Collision Resolution and Loop Detection .............   45\n   9.\
    \         Security ............................................   49\n   9.1 \
    \       Confidentiality .....................................   49\n   9.2   \
    \     Authentication and Message Integrity ................   50\n   10.     \
    \   RTP over Network and Transport Protocols ............   51\n   11.       \
    \ Summary of Protocol Constants .......................   51\n   11.1       RTCP\
    \ packet types ...................................   52\n   11.2       SDES types\
    \ ..........................................   52\n   12.        RTP Profiles\
    \ and Payload Format Specifications ......   53\n   A.         Algorithms ..........................................\
    \   56\n   A.1        RTP Data Header Validity Checks .....................  \
    \ 59\n   A.2        RTCP Header Validity Checks .........................   63\n\
    \   A.3        Determining the Number of RTP Packets Expected and\n          \
    \    Lost ................................................   63\n   A.4      \
    \  Generating SDES RTCP Packets ........................   64\n   A.5        Parsing\
    \ RTCP SDES Packets ...........................   65\n   A.6        Generating\
    \ a Random 32-bit Identifier ...............   66\n   A.7        Computing the\
    \ RTCP Transmission Interval ............   68\n   A.8        Estimating the Interarrival\
    \ Jitter ..................   71\n   B.         Security Considerations .............................\
    \   72\n   C.         Addresses of Authors ................................  \
    \ 72\n   D.         Bibliography ........................................   73\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memorandum specifies the real-time transport protocol\
    \ (RTP),\n   which provides end-to-end delivery services for data with real-time\n\
    \   characteristics, such as interactive audio and video. Those services\n   include\
    \ payload type identification, sequence numbering, timestamping\n   and delivery\
    \ monitoring. Applications typically run RTP on top of UDP\n   to make use of\
    \ its multiplexing and checksum services; both protocols\n   contribute parts\
    \ of the transport protocol functionality. However,\n   RTP may be used with other\
    \ suitable underlying network or transport\n   protocols (see Section 10). RTP\
    \ supports data transfer to multiple\n   destinations using multicast distribution\
    \ if provided by the\n   underlying network.\n   Note that RTP itself does not\
    \ provide any mechanism to ensure timely\n   delivery or provide other quality-of-service\
    \ guarantees, but relies\n   on lower-layer services to do so. It does not guarantee\
    \ delivery or\n   prevent out-of-order delivery, nor does it assume that the underlying\n\
    \   network is reliable and delivers packets in sequence. The sequence\n   numbers\
    \ included in RTP allow the receiver to reconstruct the\n   sender's packet sequence,\
    \ but sequence numbers might also be used to\n   determine the proper location\
    \ of a packet, for example in video\n   decoding, without necessarily decoding\
    \ packets in sequence.\n   While RTP is primarily designed to satisfy the needs\
    \ of multi-\n   participant multimedia conferences, it is not limited to that\n\
    \   particular application. Storage of continuous data, interactive\n   distributed\
    \ simulation, active badge, and control and measurement\n   applications may also\
    \ find RTP applicable.\n   This document defines RTP, consisting of two closely-linked\
    \ parts:\n        o the real-time transport protocol (RTP), to carry data that\
    \ has\n         real-time properties.\n        o the RTP control protocol (RTCP),\
    \ to monitor the quality of\n         service and to convey information about\
    \ the participants in an\n         on-going session. The latter aspect of RTCP\
    \ may be sufficient\n         for \"loosely controlled\" sessions, i.e., where\
    \ there is no\n         explicit membership control and set-up, but it is not\n\
    \         necessarily intended to support all of an application's control\n  \
    \       communication requirements.  This functionality may be fully or\n    \
    \     partially subsumed by a separate session control protocol,\n         which\
    \ is beyond the scope of this document.\n   RTP represents a new style of protocol\
    \ following the principles of\n   application level framing and integrated layer\
    \ processing proposed by\n   Clark and Tennenhouse [1]. That is, RTP is intended\
    \ to be malleable\n   to provide the information required by a particular application\
    \ and\n   will often be integrated into the application processing rather than\n\
    \   being implemented as a separate layer. RTP is a protocol framework\n   that\
    \ is deliberately not complete.  This document specifies those\n   functions expected\
    \ to be common across all the applications for which\n   RTP would be appropriate.\
    \ Unlike conventional protocols in which\n   additional functions might be accommodated\
    \ by making the protocol\n   more general or by adding an option mechanism that\
    \ would require\n   parsing, RTP is intended to be tailored through modifications\
    \ and/or\n   additions to the headers as needed. Examples are given in Sections\n\
    \   5.3 and 6.3.3.\n   Therefore, in addition to this document, a complete specification\
    \ of\n   RTP for a particular application will require one or more companion\n\
    \   documents (see Section 12):\n        o a profile specification document, which\
    \ defines a set of\n         payload type codes and their mapping to payload formats\
    \ (e.g.,\n         media encodings). A profile may also define extensions or\n\
    \         modifications to RTP that are specific to a particular class of\n  \
    \       applications.  Typically an application will operate under only\n    \
    \     one profile. A profile for audio and video data may be found in\n      \
    \   the companion RFC TBD.\n        o payload format specification documents,\
    \ which define how a\n         particular payload, such as an audio or video encoding,\
    \ is to\n         be carried in RTP.\n   A discussion of real-time services and\
    \ algorithms for their\n   implementation as well as background discussion on\
    \ some of the RTP\n   design decisions can be found in [2].\n   Several RTP applications,\
    \ both experimental and commercial, have\n   already been implemented from draft\
    \ specifications. These\n   applications include audio and video tools along with\
    \ diagnostic\n   tools such as traffic monitors. Users of these tools number in\
    \ the\n   thousands.  However, the current Internet cannot yet support the full\n\
    \   potential demand for real-time services. High-bandwidth services\n   using\
    \ RTP, such as video, can potentially seriously degrade the\n   quality of service\
    \ of other network services. Thus, implementors\n   should take appropriate precautions\
    \ to limit accidental bandwidth\n   usage. Application documentation should clearly\
    \ outline the\n   limitations and possible operational impact of high-bandwidth\
    \ real-\n   time services on the Internet and other network services.\n"
- title: 2.  RTP Use Scenarios
  contents:
  - "2.  RTP Use Scenarios\n   The following sections describe some aspects of the\
    \ use of RTP. The\n   examples were chosen to illustrate the basic operation of\n\
    \   applications using RTP, not to limit what RTP may be used for. In\n   these\
    \ examples, RTP is carried on top of IP and UDP, and follows the\n   conventions\
    \ established by the profile for audio and video specified\n   in the companion\
    \ Internet-Draft draft-ietf-avt-profile\n"
- title: 2.1 Simple Multicast Audio Conference
  contents:
  - "2.1 Simple Multicast Audio Conference\n   A working group of the IETF meets to\
    \ discuss the latest protocol\n   draft, using the IP multicast services of the\
    \ Internet for voice\n   communications. Through some allocation mechanism the\
    \ working group\n   chair obtains a multicast group address and pair of ports.\
    \ One port\n   is used for audio data, and the other is used for control (RTCP)\n\
    \   packets.  This address and port information is distributed to the\n   intended\
    \ participants. If privacy is desired, the data and control\n   packets may be\
    \ encrypted as specified in Section 9.1, in which case\n   an encryption key must\
    \ also be generated and distributed.  The exact\n   details of these allocation\
    \ and distribution mechanisms are beyond\n   the scope of RTP.\n   The audio conferencing\
    \ application used by each conference\n   participant sends audio data in small\
    \ chunks of, say, 20 ms duration.\n   Each chunk of audio data is preceded by\
    \ an RTP header; RTP header and\n   data are in turn contained in a UDP packet.\
    \ The RTP header indicates\n   what type of audio encoding (such as PCM, ADPCM\
    \ or LPC) is contained\n   in each packet so that senders can change the encoding\
    \ during a\n   conference, for example, to accommodate a new participant that\
    \ is\n   connected through a low-bandwidth link or react to indications of\n \
    \  network congestion.\n   The Internet, like other packet networks, occasionally\
    \ loses and\n   reorders packets and delays them by variable amounts of time.\
    \ To cope\n   with these impairments, the RTP header contains timing information\n\
    \   and a sequence number that allow the receivers to reconstruct the\n   timing\
    \ produced by the source, so that in this example, chunks of\n   audio are contiguously\
    \ played out the speaker every 20 ms. This\n   timing reconstruction is performed\
    \ separately for each source of RTP\n   packets in the conference. The sequence\
    \ number can also be used by\n   the receiver to estimate how many packets are\
    \ being lost.\n   Since members of the working group join and leave during the\n\
    \   conference, it is useful to know who is participating at any moment\n   and\
    \ how well they are receiving the audio data. For that purpose,\n   each instance\
    \ of the audio application in the conference periodically\n   multicasts a reception\
    \ report plus the name of its user on the RTCP\n   (control) port. The reception\
    \ report indicates how well the current\n   speaker is being received and may\
    \ be used to control adaptive\n   encodings. In addition to the user name, other\
    \ identifying\n   information may also be included subject to control bandwidth\
    \ limits.\n   A site sends the RTCP BYE packet (Section 6.5) when it leaves the\n\
    \   conference.\n"
- title: 2.2 Audio and Video Conference
  contents:
  - "2.2 Audio and Video Conference\n   If both audio and video media are used in\
    \ a conference, they are\n   transmitted as separate RTP sessions RTCP packets\
    \ are transmitted for\n   each medium using two different UDP port pairs and/or\
    \ multicast\n   addresses. There is no direct coupling at the RTP level between\
    \ the\n   audio and video sessions, except that a user participating in both\n\
    \   sessions should use the same distinguished (canonical) name in the\n   RTCP\
    \ packets for both so that the sessions can be associated.\n   One motivation\
    \ for this separation is to allow some participants in\n   the conference to receive\
    \ only one medium if they choose. Further\n   explanation is given in Section\
    \ 5.2. Despite the separation,\n   synchronized playback of a source's audio and\
    \ video can be achieved\n   using timing information carried in the RTCP packets\
    \ for both\n   sessions.\n"
- title: 2.3 Mixers and Translators
  contents:
  - "2.3 Mixers and Translators\n   So far, we have assumed that all sites want to\
    \ receive  media data in\n   the same format. However, this may not always be\
    \ appropriate.\n   Consider the case where participants in one area are connected\n\
    \   through a low-speed link to the majority of the conference\n   participants\
    \ who enjoy high-speed network access. Instead of forcing\n   everyone to use\
    \ a lower-bandwidth, reduced-quality audio encoding, an\n   RTP-level relay called\
    \ a mixer may be placed near the low-bandwidth\n   area. This mixer resynchronizes\
    \ incoming audio packets to reconstruct\n   the constant 20 ms spacing generated\
    \ by the sender, mixes these\n   reconstructed audio streams into a single stream,\
    \ translates the\n   audio encoding to a lower-bandwidth one and forwards the\
    \ lower-\n   bandwidth packet stream across the low-speed link. These packets\n\
    \   might be unicast to a single recipient or multicast on a different\n   address\
    \ to multiple recipients. The RTP header includes a means for\n   mixers to identify\
    \ the sources that contributed to a mixed packet so\n   that correct talker indication\
    \ can be provided at the receivers.\n   Some of the intended participants in the\
    \ audio conference may be\n   connected with high bandwidth links but might not\
    \ be directly\n   reachable via IP multicast. For example, they might be behind\
    \ an\n   application-level firewall that will not let any IP packets pass. For\n\
    \   these sites, mixing may not be necessary, in which case another type\n   of\
    \ RTP-level relay called a translator may be used. Two translators\n   are installed,\
    \ one on either side of the firewall, with the outside\n   one funneling all multicast\
    \ packets received through a secure\n   connection to the translator inside the\
    \ firewall. The translator\n   inside the firewall sends them again as multicast\
    \ packets to a\n   multicast group restricted to the site's internal network.\n\
    \   Mixers and translators may be designed for a variety of purposes. An\n   example\
    \ is a video mixer that scales the images of individual people\n   in separate\
    \ video streams and composites them into one video stream\n   to simulate a group\
    \ scene. Other examples of translation include the\n   connection of a group of\
    \ hosts speaking only IP/UDP to a group of\n   hosts that understand only ST-II,\
    \ or the packet-by-packet encoding\n   translation of video streams from individual\
    \ sources without\n   resynchronization or mixing. Details of the operation of\
    \ mixers and\n   translators are given in Section 7.\n"
- title: 3.  Definitions
  contents:
  - "3.  Definitions\n   RTP payload: The data transported by RTP in a packet, for\
    \ example\n        audio samples or compressed video data. The payload format\
    \ and\n        interpretation are beyond the scope of this document.\n   RTP packet:\
    \ A data packet consisting of the fixed RTP header, a\n        possibly empty\
    \ list of contributing sources (see below), and the\n        payload data. Some\
    \ underlying protocols may require an\n        encapsulation of the RTP packet\
    \ to be defined. Typically one\n        packet of the underlying protocol contains\
    \ a single RTP packet,\n        but several RTP packets may be contained if permitted\
    \ by the\n        encapsulation method (see Section 10).\n   RTCP packet: A control\
    \ packet consisting of a fixed header part\n        similar to that of RTP data\
    \ packets, followed by structured\n        elements that vary depending upon the\
    \ RTCP packet type. The\n        formats are defined in Section 6. Typically,\
    \ multiple RTCP\n        packets are sent together as a compound RTCP packet in\
    \ a single\n        packet of the underlying protocol; this is enabled by the\
    \ length\n        field in the fixed header of each RTCP packet.\n   Port: The\
    \ \"abstraction that transport protocols use to distinguish\n        among multiple\
    \ destinations within a given host computer. TCP/IP\n        protocols identify\
    \ ports using small positive integers.\" [3] The\n        transport selectors\
    \ (TSEL) used by the OSI transport layer are\n        equivalent to ports.  RTP\
    \ depends upon the lower-layer protocol\n        to provide some mechanism such\
    \ as ports to multiplex the RTP and\n        RTCP packets of a session.\n   Transport\
    \ address: The combination of a network address and port that\n        identifies\
    \ a transport-level endpoint, for example an IP address\n        and a UDP port.\
    \ Packets are transmitted from a source transport\n        address to a destination\
    \ transport address.\n   RTP session: The association among a set of participants\n\
    \        communicating with RTP. For each participant, the session is\n      \
    \  defined by a particular pair of destination transport addresses\n        (one\
    \ network address plus a port pair for RTP and RTCP). The\n        destination\
    \ transport address pair may be common for all\n        participants, as in the\
    \ case of IP multicast, or may be\n        different for each, as in the case\
    \ of individual unicast network\n        addresses plus a common port pair.  In\
    \ a multimedia session,\n        each medium is carried in a separate RTP session\
    \ with its own\n        RTCP packets. The multiple RTP sessions are distinguished\
    \ by\n        different port number pairs and/or different multicast\n       \
    \ addresses.\n   Synchronization source (SSRC): The source of a stream of RTP\
    \ packets,\n        identified by a 32-bit numeric SSRC identifier carried in\
    \ the\n        RTP header so as not to be dependent upon the network address.\n\
    \        All packets from a synchronization source form part of the same\n   \
    \     timing and sequence number space, so a receiver groups packets\n       \
    \ by synchronization source for playback. Examples of\n        synchronization\
    \ sources include the sender of a stream of\n        packets derived from a signal\
    \ source such as a microphone or a\n        camera, or an RTP mixer (see below).\
    \ A synchronization source\n        may change its data format, e.g., audio encoding,\
    \ over time. The\n        SSRC identifier is a randomly chosen value meant to\
    \ be globally\n        unique within a particular RTP session (see Section 8).\
    \ A\n        participant need not use the same SSRC identifier for all the\n \
    \       RTP sessions in a multimedia session; the binding of the SSRC\n      \
    \  identifiers is provided through RTCP (see Section 6.4.1).  If a\n        participant\
    \ generates multiple streams in one RTP session, for\n        example from separate\
    \ video cameras, each must be identified as\n        a different SSRC.\n   Contributing\
    \ source (CSRC): A source of a stream of RTP packets that\n        has contributed\
    \ to the combined stream produced by an RTP mixer\n        (see below). The mixer\
    \ inserts a list of the SSRC identifiers of\n        the sources that contributed\
    \ to the generation of a particular\n        packet into the RTP header of that\
    \ packet. This list is called\n        the CSRC list. An example application is\
    \ audio conferencing\n        where a mixer indicates all the talkers whose speech\
    \ was\n        combined to produce the outgoing packet, allowing the receiver\n\
    \        to indicate the current talker, even though all the audio\n        packets\
    \ contain the same SSRC identifier (that of the mixer).\n   End system: An application\
    \ that generates the content to be sent in\n        RTP packets and/or consumes\
    \ the content of received RTP packets.\n        An end system can act as one or\
    \ more synchronization sources in\n        a particular RTP session, but typically\
    \ only one.\n   Mixer: An intermediate system that receives RTP packets from one\
    \ or\n        more sources, possibly changes the data format, combines the\n \
    \       packets in some manner and then forwards a new RTP packet. Since\n   \
    \     the timing among multiple input sources will not generally be\n        synchronized,\
    \ the mixer will make timing adjustments among the\n        streams and generate\
    \ its own timing for the combined stream.\n        Thus, all data packets originating\
    \ from a mixer will be\n        identified as having the mixer as their synchronization\
    \ source.\n   Translator: An intermediate system that forwards RTP packets with\n\
    \        their synchronization source identifier intact. Examples of\n       \
    \ translators include devices that convert encodings without\n        mixing,\
    \ replicators from multicast to unicast, and application-\n        level filters\
    \ in firewalls.\n   Monitor: An application that receives RTCP packets sent by\n\
    \        participants in an RTP session, in particular the reception\n       \
    \ reports, and estimates the current quality of service for\n        distribution\
    \ monitoring, fault diagnosis and long-term\n        statistics. The monitor function\
    \ is likely to be built into the\n        application(s) participating in the\
    \ session, but may also be a\n        separate application that does not otherwise\
    \ participate and\n        does not send or receive the RTP data packets. These\
    \ are called\n        third party monitors.\n   Non-RTP means: Protocols and mechanisms\
    \ that may be needed in\n        addition to RTP to provide a usable service.\
    \ In particular, for\n        multimedia conferences, a conference control application\
    \ may\n        distribute multicast addresses and keys for encryption,\n     \
    \   negotiate the encryption algorithm to be used, and define\n        dynamic\
    \ mappings between RTP payload type values and the payload\n        formats they\
    \ represent for formats that do not have a predefined\n        payload type value.\
    \ For simple applications, electronic mail or\n        a conference database may\
    \ also be used. The specification of\n        such protocols and mechanisms is\
    \ outside the scope of this\n        document.\n"
- title: 4.  Byte Order, Alignment, and Time Format
  contents:
  - "4.  Byte Order, Alignment, and Time Format\n   All integer fields are carried\
    \ in network byte order, that is, most\n   significant byte (octet) first. This\
    \ byte order is commonly known as\n   big-endian. The transmission order is described\
    \ in detail in [4].\n   Unless otherwise noted, numeric constants are in decimal\
    \ (base 10).\n   All header data is aligned to its natural length, i.e., 16-bit\
    \ fields\n   are aligned on even offsets, 32-bit fields are aligned at offsets\n\
    \   divisible by four, etc. Octets designated as padding have the value\n   zero.\n\
    \   Wallclock time (absolute time) is represented using the timestamp\n   format\
    \ of the Network Time Protocol (NTP), which is in seconds\n   relative to 0h UTC\
    \ on 1 January 1900 [5]. The full resolution NTP\n   timestamp is a 64-bit unsigned\
    \ fixed-point number with the integer\n   part in the first 32 bits and the fractional\
    \ part in the last 32\n   bits. In some fields where a more compact representation\
    \ is\n   appropriate, only the middle 32 bits are used; that is, the low 16\n\
    \   bits of the integer part and the high 16 bits of the fractional part.\n  \
    \ The high 16 bits of the integer part must be determined\n   independently.\n"
- title: 5.  RTP Data Transfer Protocol
  contents:
  - '5.  RTP Data Transfer Protocol

    '
- title: 5.1 RTP Fixed Header Fields
  contents:
  - "5.1 RTP Fixed Header Fields\n      The RTP header has the following format:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |V=2|P|X|  CC   |M|     PT      |       sequence number         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           synchronization source (SSRC) identifier            |\n   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \   |            contributing source (CSRC) identifiers             |\n   |  \
    \                           ....                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The first twelve octets are present in every RTP packet, while the\n   list\
    \ of CSRC identifiers is present only when inserted by a mixer.\n   The fields\
    \ have the following meaning:\n   version (V): 2 bits\n        This field identifies\
    \ the version of RTP. The version defined by\n        this specification is two\
    \ (2). (The value 1 is used by the first\n        draft version of RTP and the\
    \ value 0 is used by the protocol\n        initially implemented in the \"vat\"\
    \ audio tool.)\n   padding (P): 1 bit\n        If the padding bit is set, the\
    \ packet contains one or more\n        additional padding octets at the end which\
    \ are not part of the\n        payload. The last octet of the padding contains\
    \ a count of how\n        many padding octets should be ignored. Padding may be\
    \ needed by\n        some encryption algorithms with fixed block sizes or for\n\
    \        carrying several RTP packets in a lower-layer protocol data\n       \
    \ unit.\n   extension (X): 1 bit\n        If the extension bit is set, the fixed\
    \ header is followed by\n        exactly one header extension, with a format defined\
    \ in Section\n        5.3.1.\n   CSRC count (CC): 4 bits\n        The CSRC count\
    \ contains the number of CSRC identifiers that\n        follow the fixed header.\n\
    \   marker (M): 1 bit\n        The interpretation of the marker is defined by\
    \ a profile. It is\n        intended to allow significant events such as frame\
    \ boundaries to\n        be marked in the packet stream. A profile may define\
    \ additional\n        marker bits or specify that there is no marker bit by changing\n\
    \        the number of bits in the payload type field (see Section 5.3).\n   payload\
    \ type (PT): 7 bits\n        This field identifies the format of the RTP payload\
    \ and\n        determines its interpretation by the application. A profile\n \
    \       specifies a default static mapping of payload type codes to\n        payload\
    \ formats. Additional payload type codes may be defined\n        dynamically through\
    \ non-RTP means (see Section 3). An initial\n        set of default mappings for\
    \ audio and video is specified in the\n        companion profile Internet-Draft\
    \ draft-ietf-avt-profile, and\n        may be extended in future editions of the\
    \ Assigned Numbers RFC\n        [6].  An RTP sender emits a single RTP payload\
    \ type at any given\n        time; this field is not intended for multiplexing\
    \ separate media\n        streams (see Section 5.2).\n   sequence number: 16 bits\n\
    \        The sequence number increments by one for each RTP data packet\n    \
    \    sent, and may be used by the receiver to detect packet loss and\n       \
    \ to restore packet sequence. The initial value of the sequence\n        number\
    \ is random (unpredictable) to make known-plaintext attacks\n        on encryption\
    \ more difficult, even if the source itself does not\n        encrypt, because\
    \ the packets may flow through a translator that\n        does. Techniques for\
    \ choosing unpredictable numbers are\n        discussed in [7].\n   timestamp:\
    \ 32 bits\n        The timestamp reflects the sampling instant of the first octet\n\
    \        in the RTP data packet. The sampling instant must be derived\n      \
    \  from a clock that increments monotonically and linearly in time\n        to\
    \ allow synchronization and jitter calculations (see Section\n        6.3.1).\
    \  The resolution of the clock must be sufficient for the\n        desired synchronization\
    \ accuracy and for measuring packet\n        arrival jitter (one tick per video\
    \ frame is typically not\n        sufficient).  The clock frequency is dependent\
    \ on the format of\n        data carried as payload and is specified statically\
    \ in the\n        profile or payload format specification that defines the format,\n\
    \        or may be specified dynamically for payload formats defined\n       \
    \ through non-RTP means. If RTP packets are generated\n        periodically, the\
    \ nominal sampling instant as determined from\n        the sampling clock is to\
    \ be used, not a reading of the system\n        clock. As an example, for fixed-rate\
    \ audio the timestamp clock\n        would likely increment by one for each sampling\
    \ period.  If an\n        audio application reads blocks covering 160 sampling\
    \ periods\n        from the input device, the timestamp would be increased by\
    \ 160\n        for each such block, regardless of whether the block is\n     \
    \   transmitted in a packet or dropped as silent.\n   The initial value of the\
    \ timestamp is random, as for the sequence\n   number. Several consecutive RTP\
    \ packets may have equal timestamps if\n   they are (logically) generated at once,\
    \ e.g., belong to the same\n   video frame. Consecutive RTP packets may contain\
    \ timestamps that are\n   not monotonic if the data is not transmitted in the\
    \ order it was\n   sampled, as in the case of MPEG interpolated video frames.\
    \ (The\n   sequence numbers of the packets as transmitted will still be\n   monotonic.)\n\
    \   SSRC: 32 bits\n        The SSRC field identifies the synchronization source.\
    \ This\n        identifier is chosen randomly, with the intent that no two\n \
    \       synchronization sources within the same RTP session will have\n      \
    \  the same SSRC identifier. An example algorithm for generating a\n        random\
    \ identifier is presented in Appendix A.6. Although the\n        probability of\
    \ multiple sources choosing the same identifier is\n        low, all RTP implementations\
    \ must be prepared to detect and\n        resolve collisions.  Section 8 describes\
    \ the probability of\n        collision along with a mechanism for resolving collisions\
    \ and\n        detecting RTP-level forwarding loops based on the uniqueness of\n\
    \        the SSRC identifier. If a source changes its source transport\n     \
    \   address, it must also choose a new SSRC identifier to avoid\n        being\
    \ interpreted as a looped source.\n   CSRC list: 0 to 15 items, 32 bits each\n\
    \        The CSRC list identifies the contributing sources for the\n        payload\
    \ contained in this packet. The number of identifiers is\n        given by the\
    \ CC field. If there are more than 15 contributing\n        sources, only 15 may\
    \ be identified. CSRC identifiers are\n        inserted by mixers, using the SSRC\
    \ identifiers of contributing\n        sources. For example, for audio packets\
    \ the SSRC identifiers of\n        all sources that were mixed together to create\
    \ a packet are\n        listed, allowing correct talker indication at the receiver.\n"
- title: 5.2 Multiplexing RTP Sessions
  contents:
  - "5.2 Multiplexing RTP Sessions\n   For efficient protocol processing, the number\
    \ of multiplexing points\n   should be minimized, as described in the integrated\
    \ layer processing\n   design principle [1]. In RTP, multiplexing is provided\
    \ by the\n   destination transport address (network address and port number) which\n\
    \   define an RTP session. For example, in a teleconference composed of\n   audio\
    \ and video media encoded separately, each medium should be\n   carried in a separate\
    \ RTP session with its own destination transport\n   address. It is not intended\
    \ that the audio and video be carried in a\n   single RTP session and demultiplexed\
    \ based on the payload type or\n   SSRC fields. Interleaving packets with different\
    \ payload types but\n   using the same SSRC would introduce several problems:\n\
    \        1.   If one payload type were switched during a session, there\n    \
    \         would be no general means to identify which of the old\n           \
    \  values the new one replaced.\n        2.   An SSRC is defined to identify a\
    \ single timing and sequence\n             number space. Interleaving multiple\
    \ payload types would\n             require different timing spaces if the media\
    \ clock rates\n             differ and would require different sequence number\
    \ spaces\n             to tell which payload type suffered packet loss.\n    \
    \    3.   The RTCP sender and receiver reports (see Section 6.3) can\n       \
    \      only describe one timing and sequence number space per SSRC\n         \
    \    and do not carry a payload type field.\n        4.   An RTP mixer would not\
    \ be able to combine interleaved\n             streams of incompatible media into\
    \ one stream.\n        5.   Carrying multiple media in one RTP session precludes:\
    \ the\n             use of different network paths or network resource\n     \
    \        allocations if appropriate; reception of a subset of the\n          \
    \   media if desired, for example just audio if video would\n             exceed\
    \ the available bandwidth; and receiver\n             implementations that use\
    \ separate processes for the\n             different media, whereas using separate\
    \ RTP sessions\n             permits either single- or multiple-process implementations.\n\
    \   Using a different SSRC for each medium but sending them in the same\n   RTP\
    \ session would avoid the first three problems but not the last\n   two.\n"
- title: 5.3 Profile-Specific Modifications to the RTP Header
  contents:
  - "5.3 Profile-Specific Modifications to the RTP Header\n   The existing RTP data\
    \ packet header is believed to be complete for\n   the set of functions required\
    \ in common across all the application\n   classes that RTP might support. However,\
    \ in keeping with the ALF\n   design principle, the header may be tailored through\
    \ modifications or\n   additions defined in a profile specification while still\
    \ allowing\n   profile-independent monitoring and recording tools to function.\n\
    \        o The marker bit and payload type field carry profile-specific\n    \
    \     information, but they are allocated in the fixed header since\n        \
    \ many applications are expected to need them and might otherwise\n         have\
    \ to add another 32-bit word just to hold them. The octet\n         containing\
    \ these fields may be redefined by a profile to suit\n         different requirements,\
    \ for example with a more or fewer marker\n         bits. If there are any marker\
    \ bits, one should be located in\n         the most significant bit of the octet\
    \ since profile-independent\n         monitors may be able to observe a correlation\
    \ between packet\n         loss patterns and the marker bit.\n        o Additional\
    \ information that is required for a particular\n         payload format, such\
    \ as a video encoding, should be carried in\n         the payload section of the\
    \ packet. This might be in a header\n         that is always present at the start\
    \ of the payload section, or\n         might be indicated by a reserved value\
    \ in the data pattern.\n        o If a particular class of applications needs\
    \ additional\n         functionality independent of payload format, the profile\
    \ under\n         which those applications operate should define additional fixed\n\
    \         fields to follow immediately after the SSRC field of the\n         existing\
    \ fixed header.  Those applications will be able to\n         quickly and directly\
    \ access the additional fields while\n         profile-independent monitors or\
    \ recorders can still process the\n         RTP packets by interpreting only the\
    \ first twelve octets.\n   If it turns out that additional functionality is needed\
    \ in common\n   across all profiles, then a new version of RTP should be defined\
    \ to\n   make a permanent change to the fixed header.\n"
- title: 5.3.1 RTP Header Extension
  contents:
  - "5.3.1 RTP Header Extension\n   An extension mechanism is provided to allow individual\n\
    \   implementations to experiment with new payload-format-independent\n   functions\
    \ that require additional information to be carried in the\n   RTP data packet\
    \ header. This mechanism is designed so that the header\n   extension may be ignored\
    \ by other interoperating implementations that\n   have not been extended.\n \
    \  Note that this header extension is intended only for limited use.\n   Most\
    \ potential uses of this mechanism would be better done another\n   way, using\
    \ the methods described in the previous section. For\n   example, a profile-specific\
    \ extension to the fixed header is less\n   expensive to process because it is\
    \ not conditional nor in a variable\n   location. Additional information required\
    \ for a particular payload\n   format should not use this header extension, but\
    \ should be carried in\n   the payload section of the packet.\n    0         \
    \          1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      defined by profile       |           length              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        header extension                       |\n   |  \
    \                           ....                              |\n   If the X bit\
    \ in the RTP header is one, a variable-length header\n   extension is appended\
    \ to the RTP header, following the CSRC list if\n   present. The header extension\
    \ contains a 16-bit length field that\n   counts the number of 32-bit words in\
    \ the extension, excluding the\n   four-octet extension header (therefore zero\
    \ is a valid length). Only\n   a single extension may be appended to the RTP data\
    \ header. To allow\n   multiple interoperating implementations to each experiment\n\
    \   independently with different header extensions, or to allow a\n   particular\
    \ implementation to experiment with more than one type of\n   header extension,\
    \ the first 16 bits of the header extension are left\n   open for distinguishing\
    \ identifiers or parameters. The format of\n   these 16 bits is to be defined\
    \ by the profile specification under\n   which the implementations are operating.\
    \ This RTP specification does\n   not define any header extensions itself.\n"
- title: 6.  RTP Control Protocol -- RTCP
  contents:
  - "6.  RTP Control Protocol -- RTCP\n   The RTP control protocol (RTCP) is based\
    \ on the periodic transmission\n   of control packets to all participants in the\
    \ session, using the same\n   distribution mechanism as the data packets. The\
    \ underlying protocol\n   must provide multiplexing of the data and control packets,\
    \ for\n   example using separate port numbers with UDP. RTCP performs four\n \
    \  functions:\n        1.   The primary function is to provide feedback on the\
    \ quality\n             of the data distribution. This is an integral part of\
    \ the\n             RTP's role as a transport protocol and is related to the\n\
    \             flow and congestion control functions of other transport\n     \
    \        protocols. The feedback may be directly useful for control\n        \
    \     of adaptive encodings [8,9], but experiments with IP\n             multicasting\
    \ have shown that it is also critical to get\n             feedback from the receivers\
    \ to diagnose faults in the\n             distribution. Sending reception feedback\
    \ reports to all\n             participants allows one who is observing problems\
    \ to\n             evaluate whether those problems are local or global. With a\n\
    \             distribution mechanism like IP multicast, it is also\n         \
    \    possible for an entity such as a network service provider\n             who\
    \ is not otherwise involved in the session to receive the\n             feedback\
    \ information and act as a third-party monitor to\n             diagnose network\
    \ problems. This feedback function is\n             performed by the RTCP sender\
    \ and receiver reports,\n             described below in Section 6.3.\n      \
    \  2.   RTCP carries a persistent transport-level identifier for an\n        \
    \     RTP source called the canonical name or CNAME, Section\n             6.4.1.\
    \ Since the SSRC identifier may change if a conflict\n             is discovered\
    \ or a program is restarted, receivers require\n             the CNAME to keep\
    \ track of each participant. Receivers also\n             require the CNAME to\
    \ associate multiple data streams from a\n             given participant in a\
    \ set of related RTP sessions, for\n             example to synchronize audio\
    \ and video.\n        3.   The first two functions require that all participants\
    \ send\n             RTCP packets, therefore the rate must be controlled in\n\
    \             order for RTP to scale up to a large number of\n             participants.\
    \ By having each participant send its control\n             packets to all the\
    \ others, each can independently observe\n             the number of participants.\
    \ This number is used to\n             calculate the rate at which the packets\
    \ are sent, as\n             explained in Section 6.2.\n        4.   A fourth,\
    \ optional function is to convey minimal session\n             control information,\
    \ for example participant identification\n             to be displayed in the\
    \ user interface. This is most likely\n             to be useful in \"loosely\
    \ controlled\" sessions where\n             participants enter and leave without\
    \ membership control or\n             parameter negotiation. RTCP serves as a\
    \ convenient channel\n             to reach all the participants, but it is not\
    \ necessarily\n             expected to support all the control communication\n\
    \             requirements of an application. A higher-level session\n       \
    \      control protocol, which is beyond the scope of this\n             document,\
    \ may be needed.\n   Functions 1-3 are mandatory when RTP is used in the IP multicast\n\
    \   environment, and are recommended for all environments. RTP\n   application\
    \ designers are advised to avoid mechanisms that can only\n   work in unicast\
    \ mode and will not scale to larger numbers.\n"
- title: 6.1 RTCP Packet Format
  contents:
  - "6.1 RTCP Packet Format\n   This specification defines several RTCP packet types\
    \ to carry a\n   variety of control information:\n   SR: Sender report, for transmission\
    \ and reception statistics from\n        participants that are active senders\n\
    \   RR: Receiver report, for reception statistics from participants that\n   \
    \     are not active senders\n   SDES: Source description items, including CNAME\n\
    \   BYE: Indicates end of participation\n   APP: Application specific functions\n\
    \   Each RTCP packet begins with a fixed part similar to that of RTP data\n  \
    \ packets, followed by structured elements that may be of variable\n   length\
    \ according to the packet type but always end on a 32-bit\n   boundary. The alignment\
    \ requirement and a length field in the fixed\n   part are included to make RTCP\
    \ packets \"stackable\". Multiple RTCP\n   packets may be concatenated without\
    \ any intervening separators to\n   form a compound RTCP packet that is sent in\
    \ a single packet of the\n   lower layer protocol, for example UDP. There is no\
    \ explicit count of\n   individual RTCP packets in the compound packet since the\
    \ lower layer\n   protocols are expected to provide an overall length to determine\
    \ the\n   end of the compound packet.\n   Each individual RTCP packet in the compound\
    \ packet may be processed\n   independently with no requirements upon the order\
    \ or combination of\n   packets. However, in order to perform the functions of\
    \ the protocol,\n   the following constraints are imposed:\n        o Reception\
    \ statistics (in SR or RR) should be sent as often as\n         bandwidth constraints\
    \ will allow to maximize the resolution of\n         the statistics, therefore\
    \ each periodically transmitted\n         compound RTCP packet should include\
    \ a report packet.\n        o New receivers need to receive the CNAME for a source\
    \ as soon\n         as possible to identify the source and to begin associating\n\
    \         media for purposes such as lip-sync, so each compound RTCP\n       \
    \  packet should also include the SDES CNAME.\n        o The number of packet\
    \ types that may appear first in the\n         compound packet should be limited\
    \ to increase the number of\n         constant bits in the first word and the\
    \ probability of\n         successfully validating RTCP packets against misaddressed\
    \ RTP\n         data packets or other unrelated packets.\n   Thus, all RTCP packets\
    \ must be sent in a compound packet of at least\n   two individual packets, with\
    \ the following format recommended:\n   Encryption prefix:  If and only if the\
    \ compound packet is to be\n        encrypted, it is prefixed by a random 32-bit\
    \ quantity redrawn\n        for every compound packet transmitted.\n   SR or RR:\
    \  The first RTCP packet in the compound packet must always\n        be a report\
    \ packet to facilitate header validation as described\n        in Appendix A.2.\
    \ This is true even if no data has been sent nor\n        received, in which case\
    \ an empty RR is sent, and even if the\n        only other RTCP packet in the\
    \ compound packet is a BYE.\n   Additional RRs:  If the number of sources for\
    \ which reception\n        statistics are being reported exceeds 31, the number\
    \ that will\n        fit into one SR or RR packet, then additional RR packets\
    \ should\n        follow the initial report packet.\n   SDES:  An SDES packet\
    \ containing a CNAME item must be included in\n        each compound RTCP packet.\
    \ Other source description items may\n        optionally be included if required\
    \ by a particular application,\n        subject to bandwidth constraints (see\
    \ Section 6.2.2).\n   BYE or APP:  Other RTCP packet types, including those yet\
    \ to be\n        defined, may follow in any order, except that BYE should be the\n\
    \        last packet sent with a given SSRC/CSRC. Packet types may appear\n  \
    \      more than once.\n   It is advisable for translators and mixers to combine\
    \ individual RTCP\n   packets from the multiple sources they are forwarding into\
    \ one\n   compound packet whenever feasible in order to amortize the packet\n\
    \   overhead (see Section 7). An example RTCP compound packet as might be\n  \
    \ produced by a mixer is shown in Fig. 1.  If the overall length of a\n   compound\
    \ packet would exceed the maximum transmission unit (MTU) of\n   the network path,\
    \ it may be segmented into multiple shorter compound\n   packets to be transmitted\
    \ in separate packets of the underlying\n   protocol. Note that each of the compound\
    \ packets must begin with an\n   SR or RR packet.\n   An implementation may ignore\
    \ incoming RTCP packets with types unknown\n   to it. Additional RTCP packet types\
    \ may be registered with the\n   Internet Assigned Numbers Authority (IANA).\n"
- title: 6.2 RTCP Transmission Interval
  contents:
  - "6.2 RTCP Transmission Interval\n   if encrypted: random 32-bit integer\n    |\n\
    \    |[------- packet -------][----------- packet -----------][-packet-]\n   \
    \ |\n    |             receiver reports          chunk        chunk\n    V   \
    \                                 item  item     item  item\n   --------------------------------------------------------------------\n\
    \   |R[SR|# sender #site#site][SDES|# CNAME PHONE |#CNAME LOC][BYE##why]\n   |R[\
    \  |# report #  1 #  2 ][    |#             |#         ][   ##   ]\n   |R[  |#\
    \        #    #    ][    |#             |#         ][   ##   ]\n   |R[  |#   \
    \     #    #    ][    |#             |#         ][   ##   ]\n   --------------------------------------------------------------------\n\
    \   |<------------------  UDP packet (compound packet) --------------->|\n   #:\
    \ SSRC/CSRC\n              Figure 1: Example of an RTCP compound packet\n   RTP\
    \ is designed to allow an application to scale automatically over\n   session\
    \ sizes ranging from a few participants to thousands. For\n   example, in an audio\
    \ conference the data traffic is inherently self-\n   limiting because only one\
    \ or two people will speak at a time, so with\n   multicast distribution the data\
    \ rate on any given link remains\n   relatively constant independent of the number\
    \ of participants.\n   However, the control traffic is not self-limiting. If the\
    \ reception\n   reports from each participant were sent at a constant rate, the\n\
    \   control traffic would grow linearly with the number of participants.\n   Therefore,\
    \ the rate must be scaled down.\n   For each session, it is assumed that the data\
    \ traffic is subject to\n   an aggregate limit called the \"session bandwidth\"\
    \ to be divided among\n   the participants. This bandwidth might be reserved and\
    \ the limit\n   enforced by the network, or it might just be a reasonable share.\
    \ The\n   session bandwidth may be chosen based or some cost or a priori\n   knowledge\
    \ of the available network bandwidth for the session. It is\n   somewhat independent\
    \ of the media encoding, but the encoding choice\n   may be limited by the session\
    \ bandwidth. The session bandwidth\n   parameter is expected to be supplied by\
    \ a session management\n   application when it invokes a media application, but\
    \ media\n   applications may also set a default based on the single-sender data\n\
    \   bandwidth for the encoding selected for the session. The application\n   may\
    \ also enforce bandwidth limits based on multicast scope rules or\n   other criteria.\n\
    \   Bandwidth calculations for control and data traffic include lower-\n   layer\
    \ transport and network protocols (e.g., UDP and IP) since that\n   is what the\
    \ resource reservation system would need to know. The\n   application can also\
    \ be expected to know which of these protocols are\n   in use. Link level headers\
    \ are not included in the calculation since\n   the packet will be encapsulated\
    \ with different link level headers as\n   it travels.\n   The control traffic\
    \ should be limited to a small and known fraction\n   of the session bandwidth:\
    \ small so that the primary function of the\n   transport protocol to carry data\
    \ is not impaired; known so that the\n   control traffic can be included in the\
    \ bandwidth specification given\n   to a resource reservation protocol, and so\
    \ that each participant can\n   independently calculate its share. It is suggested\
    \ that the fraction\n   of the session bandwidth allocated to RTCP be fixed at\
    \ 5%. While the\n   value of this and other constants in the interval calculation\
    \ is not\n   critical, all participants in the session must use the same values\
    \ so\n   the same interval will be calculated. Therefore, these constants\n  \
    \ should be fixed for a particular profile.\n   The algorithm described in Appendix\
    \ A.7 was designed to meet the\n   goals outlined above. It calculates the interval\
    \ between sending\n   compound RTCP packets to divide the allowed control traffic\
    \ bandwidth\n   among the participants. This allows an application to provide\
    \ fast\n   response for small sessions where, for example, identification of all\n\
    \   participants is important, yet automatically adapt to large sessions.\n  \
    \ The algorithm incorporates the following characteristics:\n        o Senders\
    \ are collectively allocated at least 1/4 of the control\n         traffic bandwidth\
    \ so that in sessions with a large number of\n         receivers but a small number\
    \ of senders, newly joining\n         participants will more quickly receive the\
    \ CNAME for the\n         sending sites.\n        o The calculated interval between\
    \ RTCP packets is required to be\n         greater than a minimum of 5 seconds\
    \ to avoid having bursts of\n         RTCP packets exceed the allowed bandwidth\
    \ when the number of\n         participants is small and the traffic isn't smoothed\
    \ according\n         to the law of large numbers.\n        o The interval between\
    \ RTCP packets is varied randomly over the\n         range [0.5,1.5] times the\
    \ calculated interval to avoid\n         unintended synchronization of all participants\
    \ [10].  The first\n         RTCP packet sent after joining a session is also\
    \ delayed by a\n         random variation of half the minimum RTCP interval in\
    \ case the\n         application is started at multiple sites simultaneously,\
    \ for\n         example as initiated by a session announcement.\n        o A dynamic\
    \ estimate of the average compound RTCP packet size is\n         calculated, including\
    \ all those received and sent, to\n         automatically adapt to changes in\
    \ the amount of control\n         information carried.\n   This algorithm may\
    \ be used for sessions in which all participants are\n   allowed to send. In that\
    \ case, the session bandwidth parameter is the\n   product of the individual sender's\
    \ bandwidth times the number of\n   participants, and the RTCP bandwidth is 5%\
    \ of that.\n"
- title: 6.2.1 Maintaining the number of session members
  contents:
  - "6.2.1 Maintaining the number of session members\n   Calculation of the RTCP packet\
    \ interval depends upon an estimate of\n   the number of sites participating in\
    \ the session. New sites are added\n   to the count when they are heard, and an\
    \ entry for each is created in\n   a table indexed by the SSRC or CSRC identifier\
    \ (see Section 8.2) to\n   keep track of them. New entries may not be considered\
    \ valid until\n   multiple packets carrying the new SSRC have been received (see\n\
    \   Appendix A.1). Entries may be deleted from the table when an RTCP BYE\n  \
    \ packet with the corresponding SSRC identifier is received.\n   A participant\
    \ may mark another site inactive, or delete it if not yet\n   valid, if no RTP\
    \ or RTCP packet has been received for a small number\n   of RTCP report intervals\
    \ (5 is suggested). This provides some\n   robustness against packet loss. All\
    \ sites must calculate roughly the\n   same value for the RTCP report interval\
    \ in order for this timeout to\n   work properly.\n   Once a site has been validated,\
    \ then if it is later marked inactive\n   the state for that site should still\
    \ be retained and the site should\n   continue to be counted in the total number\
    \ of sites sharing RTCP\n   bandwidth for a period long enough to span typical\
    \ network\n   partitions.  This is to avoid excessive traffic, when the partition\n\
    \   heals, due to an RTCP report interval that is too small. A timeout of\n  \
    \ 30 minutes is suggested. Note that this is still larger than 5 times\n   the\
    \ largest value to which the RTCP report interval is expected to\n   usefully\
    \ scale, about 2 to 5 minutes.\n"
- title: 6.2.2 Allocation of source description bandwidth
  contents:
  - "6.2.2 Allocation of source description bandwidth\n   This specification defines\
    \ several source description (SDES) items in\n   addition to the mandatory CNAME\
    \ item, such as NAME (personal name)\n   and EMAIL (email address). It also provides\
    \ a means to define new\n   application-specific RTCP packet types. Applications\
    \ should exercise\n   caution in allocating control bandwidth to this additional\n\
    \   information because it will slow down the rate at which reception\n   reports\
    \ and CNAME are sent, thus impairing the performance of the\n   protocol. It is\
    \ recommended that no more than 20% of the RTCP\n   bandwidth allocated to a single\
    \ participant be used to carry the\n   additional information.  Furthermore, it\
    \ is not intended that all\n   SDES items should be included in every application.\
    \ Those that are\n   included should be assigned a fraction of the bandwidth according\
    \ to\n   their utility.  Rather than estimate these fractions dynamically, it\n\
    \   is recommended that the percentages be translated statically into\n   report\
    \ interval counts based on the typical length of an item.\n   For example, an\
    \ application may be designed to send only CNAME, NAME\n   and EMAIL and not any\
    \ others. NAME might be given much higher\n   priority than EMAIL because the\
    \ NAME would be displayed continuously\n   in the application's user interface,\
    \ whereas EMAIL would be displayed\n   only when requested. At every RTCP interval,\
    \ an RR packet and an SDES\n   packet with the CNAME item would be sent. For a\
    \ small session\n   operating at the minimum interval, that would be every 5 seconds\
    \ on\n   the average. Every third interval (15 seconds), one extra item would\n\
    \   be included in the SDES packet. Seven out of eight times this would\n   be\
    \ the NAME item, and every eighth time (2 minutes) it would be the\n   EMAIL item.\n\
    \   When multiple applications operate in concert using cross-application\n  \
    \ binding through a common CNAME for each participant, for example in a\n   multimedia\
    \ conference composed of an RTP session for each medium, the\n   additional SDES\
    \ information might be sent in only one RTP session.\n   The other sessions would\
    \ carry only the CNAME item.\n"
- title: 6.3 Sender and Receiver Reports
  contents:
  - "6.3 Sender and Receiver Reports\n   RTP receivers provide reception quality feedback\
    \ using RTCP report\n   packets which may take one of two forms depending upon\
    \ whether or not\n   the receiver is also a sender. The only difference between\
    \ the sender\n   report (SR) and receiver report (RR) forms, besides the packet\
    \ type\n   code, is that the sender report includes a 20-byte sender information\n\
    \   section for use by active senders. The SR is issued if a site has\n   sent\
    \ any data packets during the interval since issuing the last\n   report or the\
    \ previous one, otherwise the RR is issued.\n   Both the SR and RR forms include\
    \ zero or more reception report\n   blocks, one for each of the synchronization\
    \ sources from which this\n   receiver has received RTP data packets since the\
    \ last report. Reports\n   are not issued for contributing sources listed in the\
    \ CSRC list. Each\n   reception report block provides statistics about the data\
    \ received\n   from the particular source indicated in that block. Since a maximum\n\
    \   of 31 reception report blocks will fit in an SR or RR packet,\n   additional\
    \ RR packets may be stacked after the initial SR or RR\n   packet as needed to\
    \ contain the reception reports for all sources\n   heard during the interval\
    \ since the last report.\n   The next sections define the formats of the two reports,\
    \ how they may\n   be extended in a profile-specific manner if an application\
    \ requires\n   additional feedback information, and how the reports may be used.\n\
    \   Details of reception reporting by translators and mixers is given in\n   Section\
    \ 7.\n"
- title: '6.3.1 SR: Sender report RTCP packet'
  contents:
  - "6.3.1 SR: Sender report RTCP packet\n 0                   1                 \
    \  2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n"
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|V=2|P|    RC   |   PT=SR=200   |             length            | header'
  contents:
  - '|V=2|P|    RC   |   PT=SR=200   |             length            | header

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                         SSRC of sender                        |'
  contents:
  - '|                         SSRC of sender                        |

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|              NTP timestamp, most significant word             | sender'
  contents:
  - '|              NTP timestamp, most significant word             | sender

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ info
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ info

    '
- title: '|             NTP timestamp, least significant word             |'
  contents:
  - '|             NTP timestamp, least significant word             |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                         RTP timestamp                         |'
  contents:
  - '|                         RTP timestamp                         |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                     sender''s packet count                     |'
  contents:
  - '|                     sender''s packet count                     |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                      sender''s octet count                     |'
  contents:
  - '|                      sender''s octet count                     |

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                 SSRC_1 (SSRC of first source)                 | report'
  contents:
  - '|                 SSRC_1 (SSRC of first source)                 | report

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block

    '
- title: '| fraction lost |       cumulative number of packets lost       |   1'
  contents:
  - '| fraction lost |       cumulative number of packets lost       |   1

    '
- title: -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|           extended highest sequence number received           |'
  contents:
  - '|           extended highest sequence number received           |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                      interarrival jitter                      |'
  contents:
  - '|                      interarrival jitter                      |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                         last SR (LSR)                         |'
  contents:
  - '|                         last SR (LSR)                         |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                   delay since last SR (DLSR)                  |'
  contents:
  - '|                   delay since last SR (DLSR)                  |

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                 SSRC_2 (SSRC of second source)                | report'
  contents:
  - '|                 SSRC_2 (SSRC of second source)                | report

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block

    '
- title: ':                               ...                             :   2'
  contents:
  - ':                               ...                             :   2

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                  profile-specific extensions                  |'
  contents:
  - '|                  profile-specific extensions                  |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The sender\
    \ report packet consists of three sections, possibly\n   followed by a fourth\
    \ profile-specific extension section if defined.\n   The first section, the header,\
    \ is 8 octets long. The fields have the\n   following meaning:\n   version (V):\
    \ 2 bits\n        Identifies the version of RTP, which is the same in RTCP packets\n\
    \        as in RTP data packets. The version defined by this\n        specification\
    \ is two (2).\n   padding (P): 1 bit\n        If the padding bit is set, this\
    \ RTCP packet contains some\n        additional padding octets at the end which\
    \ are not part of the\n        control information. The last octet of the padding\
    \ is a count of\n        how many padding octets should be ignored. Padding may\
    \ be needed\n        by some encryption algorithms with fixed block sizes. In\
    \ a\n        compound RTCP packet, padding should only be required on the\n  \
    \      last individual packet because the compound packet is encrypted\n     \
    \   as a whole.\n   reception report count (RC): 5 bits\n        The number of\
    \ reception report blocks contained in this packet.\n        A value of zero is\
    \ valid.\n   packet type (PT): 8 bits\n        Contains the constant 200 to identify\
    \ this as an RTCP SR packet.\n   length: 16 bits\n        The length of this RTCP\
    \ packet in 32-bit words minus one,\n        including the header and any padding.\
    \ (The offset of one makes\n        zero a valid length and avoids a possible\
    \ infinite loop in\n        scanning a compound RTCP packet, while counting 32-bit\
    \ words\n        avoids a validity check for a multiple of 4.)\n   SSRC: 32 bits\n\
    \        The synchronization source identifier for the originator of this\n  \
    \      SR packet.\n   The second section, the sender information, is 20 octets\
    \ long and is\n   present in every sender report packet. It summarizes the data\n\
    \   transmissions from this sender. The fields have the following\n   meaning:\n\
    \   NTP timestamp: 64 bits\n        Indicates the wallclock time when this report\
    \ was sent so that\n        it may be used in combination with timestamps returned\
    \ in\n        reception reports from other receivers to measure round-trip\n \
    \       propagation to those receivers. Receivers should expect that the\n   \
    \     measurement accuracy of the timestamp may be limited to far less\n     \
    \   than the resolution of the NTP timestamp. The measurement\n        uncertainty\
    \ of the timestamp is not indicated as it may not be\n        known. A sender\
    \ that can keep track of elapsed time but has no\n        notion of wallclock\
    \ time may use the elapsed time since joining\n        the session instead. This\
    \ is assumed to be less than 68 years,\n        so the high bit will be zero.\
    \ It is permissible to use the\n        sampling clock to estimate elapsed wallclock\
    \ time. A sender that\n        has no notion of wallclock or elapsed time may\
    \ set the NTP\n        timestamp to zero.\n   RTP timestamp: 32 bits\n       \
    \ Corresponds to the same time as the NTP timestamp (above), but\n        in the\
    \ same units and with the same random offset as the RTP\n        timestamps in\
    \ data packets. This correspondence may be used for\n        intra- and inter-media\
    \ synchronization for sources whose NTP\n        timestamps are synchronized,\
    \ and may be used by media-\n        independent receivers to estimate the nominal\
    \ RTP clock\n        frequency. Note that in most cases this timestamp will not\
    \ be\n        equal to the RTP timestamp in any adjacent data packet. Rather,\n\
    \        it is calculated from the corresponding NTP timestamp using the\n   \
    \     relationship between the RTP timestamp counter and real time as\n      \
    \  maintained by periodically checking the wallclock time at a\n        sampling\
    \ instant.\n   sender's packet count: 32 bits\n        The total number of RTP\
    \ data packets transmitted by the sender\n        since starting transmission\
    \ up until the time this SR packet was\n        generated.  The count is reset\
    \ if the sender changes its SSRC\n        identifier.\n   sender's octet count:\
    \ 32 bits\n        The total number of payload octets (i.e., not including header\n\
    \        or padding) transmitted in RTP data packets by the sender since\n   \
    \     starting transmission up until the time this SR packet was\n        generated.\
    \ The count is reset if the sender changes its SSRC\n        identifier. This\
    \ field can be used to estimate the average\n        payload data rate.\n   The\
    \ third section contains zero or more reception report blocks\n   depending on\
    \ the number of other sources heard by this sender since\n   the last report.\
    \ Each reception report block conveys statistics on\n   the reception of RTP packets\
    \ from a single synchronization source.\n   Receivers do not carry over statistics\
    \ when a source changes its SSRC\n   identifier due to a collision. These statistics\
    \ are:\n   SSRC_n (source identifier): 32 bits\n        The SSRC identifier of\
    \ the source to which the information in\n        this reception report block\
    \ pertains.\n   fraction lost: 8 bits\n        The fraction of RTP data packets\
    \ from source SSRC_n lost since\n        the previous SR or RR packet was sent,\
    \ expressed as a fixed\n        point number with the binary point at the left\
    \ edge of the\n        field. (That is equivalent to taking the integer part after\n\
    \        multiplying the loss fraction by 256.) This fraction is defined\n   \
    \     to be the number of packets lost divided by the number of\n        packets\
    \ expected,  as defined in the next paragraph.  An\n        implementation is\
    \ shown in Appendix A.3. If the loss is negative\n        due to duplicates, the\
    \ fraction lost is set to zero. Note that a\n        receiver cannot tell whether\
    \ any packets were lost after the\n        last one received, and that there will\
    \ be no reception report\n        block issued for a source if all packets from\
    \ that source sent\n        during the last reporting interval have been lost.\n\
    \   cumulative number of packets lost: 24 bits\n        The total number of RTP\
    \ data packets from source SSRC_n that\n        have been lost since the beginning\
    \ of reception. This number is\n        defined to be the number of packets expected\
    \ less the number of\n        packets actually received, where the number of packets\
    \ received\n        includes any which are late or duplicates. Thus packets that\n\
    \        arrive late are not counted as lost, and the loss may be\n        negative\
    \ if there are duplicates.  The number of packets\n        expected is defined\
    \ to be the extended last sequence number\n        received, as defined next,\
    \ less the initial sequence number\n        received. This may be calculated as\
    \ shown in Appendix A.3.\n   extended highest sequence number received: 32 bits\n\
    \        The low 16 bits contain the highest sequence number received in\n   \
    \     an RTP data packet from source SSRC_n, and the most significant\n      \
    \  16 bits extend that sequence number with the corresponding count\n        of\
    \ sequence number cycles, which may be maintained according to\n        the algorithm\
    \ in Appendix A.1. Note that different receivers\n        within the same session\
    \ will generate different extensions to\n        the sequence number if their\
    \ start times differ significantly.\n   interarrival jitter: 32 bits\n       \
    \ An estimate of the statistical variance of the RTP data packet\n        interarrival\
    \ time, measured in timestamp units and expressed as\n        an unsigned integer.\
    \ The interarrival jitter J is defined to be\n        the mean deviation (smoothed\
    \ absolute value) of the difference D\n        in packet spacing at the receiver\
    \ compared to the sender for a\n        pair of packets. As shown in the equation\
    \ below, this is\n        equivalent to the difference in the \"relative transit\
    \ time\" for\n        the two packets; the relative transit time is the difference\n\
    \        between a packet's RTP timestamp and the receiver's clock at the\n  \
    \      time of arrival, measured in the same units.\n   If Si is the RTP timestamp\
    \ from packet i, and Ri is the time of\n   arrival in RTP timestamp units for\
    \ packet i, then for two packets i\n   and j, D may be expressed as\n        \
    \         D(i,j)=(Rj-Ri)-(Sj-Si)=(Rj-Sj)-(Ri-Si)\n   The interarrival jitter is\
    \ calculated continuously as each data\n   packet i is received from source SSRC_n,\
    \ using this difference D for\n   that packet and the previous packet i-1 in order\
    \ of arrival (not\n   necessarily in sequence), according to the formula\n   \
    \                 J=J+(|D(i-1,i)|-J)/16\n   Whenever a reception report is issued,\
    \ the current value of J is\n   sampled.\n   The jitter calculation is prescribed\
    \ here to allow profile-\n   independent monitors to make valid interpretations\
    \ of reports coming\n   from different implementations. This algorithm is the\
    \ optimal first-\n   order estimator and the gain parameter 1/16 gives a good\
    \ noise\n   reduction ratio while maintaining a reasonable rate of convergence\n\
    \   [11].  A sample implementation is shown in Appendix A.8.\n   last SR timestamp\
    \ (LSR): 32 bits\n        The middle 32 bits out of 64 in the NTP timestamp (as\
    \ explained\n        in Section 4) received as part of the most recent RTCP sender\n\
    \        report (SR) packet from source SSRC_n.  If no SR has been\n        received\
    \ yet, the field is set to zero.\n   delay since last SR (DLSR): 32 bits\n   \
    \     The delay, expressed in units of 1/65536 seconds, between\n        receiving\
    \ the last SR packet from source SSRC_n and sending this\n        reception report\
    \ block.  If no SR packet has been received yet\n        from SSRC_n, the DLSR\
    \ field is set to zero.\n   Let SSRC_r denote the receiver issuing this receiver\
    \ report. Source\n   SSRC_n can compute the round propagation delay to SSRC_r\
    \ by recording\n   the time A when this reception report block is received.  It\n\
    \   calculates the total round-trip time A-LSR using the last SR\n   timestamp\
    \ (LSR) field, and then subtracting this field to leave the\n   round-trip propagation\
    \ delay as (A- LSR - DLSR).  This is illustrated\n   in Fig. 2.\n   This may be\
    \ used as an approximate measure of distance to cluster\n   receivers, although\
    \ some links have very asymmetric delays.\n"
- title: '6.3.2 RR: Receiver report RTCP packet'
  contents:
  - "6.3.2 RR: Receiver report RTCP packet\n   [10 Nov 1995 11:33:25.125]        \
    \   [10 Nov 1995 11:33:36.5]\n   n                 SR(n)              A=b710:8000\
    \ (46864.500 s)\n   ---------------------------------------------------------------->\n\
    \                      v                 ^\n   ntp_sec =0xb44db705 v         \
    \      ^ dlsr=0x0005.4000 (    5.250s)\n   ntp_frac=0x20000000  v            \
    \ ^  lsr =0xb705:2000 (46853.125s)\n     (3024992016.125 s)  v           ^\n \
    \  r                      v         ^ RR(n)\n   ---------------------------------------------------------------->\n\
    \                          |<-DLSR->|\n                           (5.250 s)\n\
    \   A     0xb710:8000 (46864.500 s)\n   DLSR -0x0005:4000 (    5.250 s)\n   LSR\
    \  -0xb705:2000 (46853.125 s)\n   -------------------------------\n   delay 0x\
    \   6:2000 (    6.125 s)\n           Figure 2: Example for round-trip time computation\n\
    \ 0                   1                   2                   3\n 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n"
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|V=2|P|    RC   |   PT=RR=201   |             length            | header'
  contents:
  - '|V=2|P|    RC   |   PT=RR=201   |             length            | header

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                     SSRC of packet sender                     |'
  contents:
  - '|                     SSRC of packet sender                     |

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                 SSRC_1 (SSRC of first source)                 | report'
  contents:
  - '|                 SSRC_1 (SSRC of first source)                 | report

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block

    '
- title: '| fraction lost |       cumulative number of packets lost       |   1'
  contents:
  - '| fraction lost |       cumulative number of packets lost       |   1

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|           extended highest sequence number received           |'
  contents:
  - '|           extended highest sequence number received           |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                      interarrival jitter                      |'
  contents:
  - '|                      interarrival jitter                      |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                         last SR (LSR)                         |'
  contents:
  - '|                         last SR (LSR)                         |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|                   delay since last SR (DLSR)                  |'
  contents:
  - '|                   delay since last SR (DLSR)                  |

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                 SSRC_2 (SSRC of second source)                | report'
  contents:
  - '|                 SSRC_2 (SSRC of second source)                | report

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block

    '
- title: ':                               ...                             :   2'
  contents:
  - ':                               ...                             :   2

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                  profile-specific extensions                  |'
  contents:
  - '|                  profile-specific extensions                  |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The format\
    \ of the receiver report (RR) packet is the same as that of\n   the SR packet\
    \ except that the packet type field contains the constant\n   201 and the five\
    \ words of sender information are omitted (these are\n   the NTP and RTP timestamps\
    \ and sender's packet and octet counts). The\n   remaining fields have the same\
    \ meaning as for the SR packet.\n   An empty RR packet (RC = 0) is put at the\
    \ head of a compound RTCP\n   packet when there is no data transmission or reception\
    \ to report.\n"
- title: 6.3.3 Extending the sender and receiver reports
  contents:
  - "6.3.3 Extending the sender and receiver reports\n   A profile should define profile-\
    \ or application-specific extensions\n   to the sender report and receiver if\
    \ there is additional information\n   that should be reported regularly about\
    \ the sender or receivers. This\n   method should be used in preference to defining\
    \ another RTCP packet\n   type because it requires less overhead:\n        o fewer\
    \ octets in the packet (no RTCP header or SSRC field);\n        o simpler and\
    \ faster parsing because applications running under\n         that profile would\
    \ be programmed to always expect the extension\n         fields in the directly\
    \ accessible location after the reception\n         reports.\n   If additional\
    \ sender information is required, it should be included\n   first in the extension\
    \ for sender reports, but would not be present\n   in receiver reports. If information\
    \ about receivers is to be\n   included, that data may be structured as an array\
    \ of blocks parallel\n   to the existing array of reception report blocks; that\
    \ is, the number\n   of blocks would be indicated by the RC field.\n"
- title: 6.3.4 Analyzing sender and receiver reports
  contents:
  - "6.3.4 Analyzing sender and receiver reports\n   It is expected that reception\
    \ quality feedback will be useful not\n   only for the sender but also for other\
    \ receivers and third-party\n   monitors.  The sender may modify its transmissions\
    \ based on the\n   feedback; receivers can determine whether problems are local,\n\
    \   regional or global; network managers may use profile-independent\n   monitors\
    \ that receive only the RTCP packets and not the corresponding\n   RTP data packets\
    \ to evaluate the performance of their networks for\n   multicast distribution.\n\
    \   Cumulative counts are used in both the sender information and\n   receiver\
    \ report blocks so that differences may be calculated between\n   any two reports\
    \ to make measurements over both short and long time\n   periods, and to provide\
    \ resilience against the loss of a report. The\n   difference between the last\
    \ two reports received can be used to\n   estimate the recent quality of the distribution.\
    \ The NTP timestamp is\n   included so that rates may be calculated from these\
    \ differences over\n   the interval between two reports. Since that timestamp\
    \ is independent\n   of the clock rate for the data encoding, it is possible to\
    \ implement\n   encoding- and profile-independent quality monitors.\n   An example\
    \ calculation is the packet loss rate over the interval\n   between two reception\
    \ reports. The difference in the cumulative\n   number of packets lost gives the\
    \ number lost during that interval.\n   The difference in the extended last sequence\
    \ numbers received gives\n   the number of packets expected during the interval.\
    \ The ratio of\n   these two is the packet loss fraction over the interval. This\
    \ ratio\n   should equal the fraction lost field if the two reports are\n   consecutive,\
    \ but otherwise not. The loss rate per second can be\n   obtained by dividing\
    \ the loss fraction by the difference in NTP\n   timestamps, expressed in seconds.\
    \ The number of packets received is\n   the number of packets expected minus the\
    \ number lost. The number of\n   packets expected may also be used to judge the\
    \ statistical validity\n   of any loss estimates.  For example, 1 out of 5 packets\
    \ lost has a\n   lower significance than 200 out of 1000.\n   From the sender\
    \ information, a third-party monitor can calculate the\n   average payload data\
    \ rate and the average packet rate over an\n   interval without receiving the\
    \ data. Taking the ratio of the two\n   gives the average payload size. If it\
    \ can be assumed that packet loss\n   is independent of packet size, then the\
    \ number of packets received by\n   a particular receiver times the average payload\
    \ size (or the\n   corresponding packet size) gives the apparent throughput available\
    \ to\n   that receiver.\n   In addition to the cumulative counts which allow long-term\
    \ packet\n   loss measurements using differences between reports, the fraction\n\
    \   lost field provides a short-term measurement from a single report.\n   This\
    \ becomes more important as the size of a session scales up enough\n   that reception\
    \ state information might not be kept for all receivers\n   or the interval between\
    \ reports becomes long enough that only one\n   report might have been received\
    \ from a particular receiver.\n   The interarrival jitter field provides a second\
    \ short-term measure of\n   network congestion. Packet loss tracks persistent\
    \ congestion while\n   the jitter measure tracks transient congestion. The jitter\
    \ measure\n   may indicate congestion before it leads to packet loss. Since the\n\
    \   interarrival jitter field is only a snapshot of the jitter at the\n   time\
    \ of a report, it may be necessary to analyze a number of reports\n   from one\
    \ receiver over time or from multiple receivers, e.g., within\n   a single network.\n"
- title: '6.4 SDES: Source description RTCP packet'
  contents:
  - "6.4 SDES: Source description RTCP packet\n 0                   1            \
    \       2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n"
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '|V=2|P|    SC   |  PT=SDES=202  |             length            | header'
  contents:
  - '|V=2|P|    SC   |  PT=SDES=202  |             length            | header

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                          SSRC/CSRC_1                          | chunk'
  contents:
  - '|                          SSRC/CSRC_1                          | chunk

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   1
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   1

    '
- title: '|                           SDES items                          |'
  contents:
  - '|                           SDES items                          |

    '
- title: '|                              ...                              |'
  contents:
  - '|                              ...                              |

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - '+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

    '
- title: '|                          SSRC/CSRC_2                          | chunk'
  contents:
  - '|                          SSRC/CSRC_2                          | chunk

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   2
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   2

    '
- title: '|                           SDES items                          |'
  contents:
  - '|                           SDES items                          |

    '
- title: '|                              ...                              |'
  contents:
  - '|                              ...                              |

    '
- title: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
  contents:
  - "+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n   The SDES\
    \ packet is a three-level structure composed of a header and\n   zero or more\
    \ chunks, each of of which is composed of items describing\n   the source identified\
    \ in that chunk. The items are described\n   individually in subsequent sections.\n\
    \   version (V), padding (P), length:\n        As described for the SR packet\
    \ (see Section 6.3.1).\n   packet type (PT): 8 bits\n        Contains the constant\
    \ 202 to identify this as an RTCP SDES\n        packet.\n   source count (SC):\
    \ 5 bits\n        The number of SSRC/CSRC chunks contained in this SDES packet.\
    \ A\n        value of zero is valid but useless.\n   Each chunk consists of an\
    \ SSRC/CSRC identifier followed by a list of\n   zero or more items, which carry\
    \ information about the SSRC/CSRC. Each\n   chunk starts on a 32-bit boundary.\
    \ Each item consists of an 8-bit\n   type field, an 8-bit octet count describing\
    \ the length of the text\n   (thus, not including this two-octet header), and\
    \ the text itself.\n   Note that the text can be no longer than 255 octets, but\
    \ this is\n   consistent with the need to limit RTCP bandwidth consumption.\n\
    \   The text is encoded according to the UTF-2 encoding specified in\n   Annex\
    \ F of ISO standard 10646 [12,13]. This encoding is also known as\n   UTF-8 or\
    \ UTF-FSS. It is described in \"File System Safe UCS\n   Transformation Format\
    \ (FSS_UTF)\", X/Open Preliminary Specification,\n   Document Number P316 and\
    \ Unicode Technical Report #4. US-ASCII is a\n   subset of this encoding and requires\
    \ no additional encoding. The\n   presence of multi-octet encodings is indicated\
    \ by setting the most\n   significant bit of a character to a value of one.\n\
    \   Items are contiguous, i.e., items are not individually padded to a\n   32-bit\
    \ boundary. Text is not null terminated because some multi-octet\n   encodings\
    \ include null octets. The list of items in each chunk is\n   terminated by one\
    \ or more null octets, the first of which is\n   interpreted as an item type of\
    \ zero to denote the end of the list,\n   and the remainder as needed to pad until\
    \ the next 32-bit boundary. A\n   chunk with zero items (four null octets) is\
    \ valid but useless.\n   End systems send one SDES packet containing their own\
    \ source\n   identifier (the same as the SSRC in the fixed RTP header). A mixer\n\
    \   sends one SDES packet containing a chunk for each contributing source\n  \
    \ from which it is receiving SDES information, or multiple complete\n   SDES packets\
    \ in the format above if there are more than 31 such\n   sources (see Section\
    \ 7).\n   The SDES items currently defined are described in the next sections.\n\
    \   Only the CNAME item is mandatory. Some items shown here may be useful\n  \
    \ only for particular profiles, but the item types are all assigned\n   from one\
    \ common space to promote shared use and to simplify profile-\n   independent\
    \ applications. Additional items may be defined in a\n   profile by registering\
    \ the type numbers with IANA.\n"
- title: '6.4.1 CNAME: Canonical end-point identifier SDES item'
  contents:
  - "6.4.1 CNAME: Canonical end-point identifier SDES item\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    CNAME=1    |     length    | user and domain name         ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The CNAME identifier has the following properties:\n        o Because the\
    \ randomly allocated SSRC identifier may change if a\n         conflict is discovered\
    \ or if a program is restarted, the CNAME\n         item is required to provide\
    \ the binding from the SSRC\n         identifier to an identifier for the source\
    \ that remains\n         constant.\n        o Like the SSRC identifier, the CNAME\
    \ identifier should also be\n         unique among all participants within one\
    \ RTP session.\n        o To provide a binding across multiple media tools used\
    \ by one\n         participant in a set of related RTP sessions, the CNAME should\n\
    \         be fixed for that participant.\n        o To facilitate third-party\
    \ monitoring, the CNAME should be\n         suitable for either a program or a\
    \ person to locate the source.\n   Therefore, the CNAME should be derived algorithmically\
    \ and not\n   entered manually, when possible. To meet these requirements, the\n\
    \   following format should be used unless a profile specifies an\n   alternate\
    \ syntax or semantics. The CNAME item should have the format\n   \"user@host\"\
    , or \"host\" if a user name is not available as on single-\n   user systems.\
    \  For both formats, \"host\" is either the fully qualified\n   domain name of\
    \ the host from which the real-time data originates,\n   formatted according to\
    \ the rules specified in RFC 1034 [14], RFC 1035\n   [15] and Section 2.1 of RFC\
    \ 1123 [16]; or the standard ASCII\n   representation of the host's numeric address\
    \ on the interface used\n   for the RTP communication. For example, the standard\
    \ ASCII\n   representation of an IP Version 4 address is \"dotted decimal\", also\n\
    \   known as dotted quad. Other address types are expected to have ASCII\n   representations\
    \ that are mutually unique.  The fully qualified domain\n   name is more convenient\
    \ for a human observer and may avoid the need\n   to send a NAME item in addition,\
    \ but it may be difficult or\n   impossible to obtain reliably in some operating\
    \ environments.\n   Applications that may be run in such environments should use\
    \ the\n   ASCII representation of the address instead.\n   Examples are \"doe@sleepy.megacorp.com\"\
    \ or \"doe@192.0.2.89\" for a\n   multi-user system. On a system with no user\
    \ name, examples would be\n   \"sleepy.megacorp.com\" or \"192.0.2.89\".\n   The\
    \ user name should be in a form that a program such as \"finger\" or\n   \"talk\"\
    \ could use, i.e., it typically is the login name rather than\n   the personal\
    \ name. The host name is not necessarily identical to the\n   one in the participant's\
    \ electronic mail address.\n   This syntax will not provide unique identifiers\
    \ for each source if an\n   application permits a user to generate multiple sources\
    \ from one\n   host.  Such an application would have to rely on the SSRC to further\n\
    \   identify the source, or the profile for that application would have\n   to\
    \ specify additional syntax for the CNAME identifier.\n   If each application\
    \ creates its CNAME independently, the resulting\n   CNAMEs may not be identical\
    \ as would be required to provide a binding\n   across multiple media tools belonging\
    \ to one participant in a set of\n   related RTP sessions. If cross-media binding\
    \ is required, it may be\n   necessary for the CNAME of each tool to be externally\
    \ configured with\n   the same value by a coordination tool.\n   Application writers\
    \ should be aware that private network address\n   assignments such as the Net-10\
    \ assignment proposed in RFC 1597 [17]\n   may create network addresses that are\
    \ not globally unique. This would\n   lead to non-unique CNAMEs if hosts with\
    \ private addresses and no\n   direct IP connectivity to the public Internet have\
    \ their RTP packets\n   forwarded to the public Internet through an RTP-level\
    \ translator.\n   (See also RFC 1627 [18].) To handle this case, applications\
    \ may\n   provide a means to configure a unique CNAME, but the burden is on the\n\
    \   translator to translate CNAMEs from private addresses to public\n   addresses\
    \ if necessary to keep private addresses from being exposed.\n"
- title: '6.4.2 NAME: User name SDES item'
  contents:
  - "6.4.2 NAME: User name SDES item\n    0                   1                  \
    \ 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     NAME=2    |     length    | common name of source        ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This is the real name used to describe the source, e.g., \"John Doe,\n   Bit\
    \ Recycler, Megacorp\". It may be in any form desired by the user.\n   For applications\
    \ such as conferencing, this form of name may be the\n   most desirable for display\
    \ in participant lists, and therefore might\n   be sent most frequently of those\
    \ items other than CNAME. Profiles may\n   establish such priorities.  The NAME\
    \ value is expected to remain\n   constant at least for the duration of a session.\
    \ It should not be\n   relied upon to be unique among all participants in the\
    \ session.\n"
- title: '6.4.3 EMAIL: Electronic mail address SDES item'
  contents:
  - "6.4.3 EMAIL: Electronic mail address SDES item\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    EMAIL=3    |     length    | email address of source      ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The email address is formatted according to RFC 822 [19], for\n   example,\
    \ \"John.Doe@megacorp.com\". The EMAIL value is expected to\n   remain constant\
    \ for the duration of a session.\n"
- title: '6.4.4 PHONE: Phone number SDES item'
  contents:
  - "6.4.4 PHONE: Phone number SDES item\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    PHONE=4    |     length    | phone number of source       ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The phone number should be formatted with the plus sign replacing the\n  \
    \ international access code.  For example, \"+1 908 555 1212\" for a\n   number\
    \ in the United States.\n"
- title: '6.4.5 LOC: Geographic user location SDES item'
  contents:
  - "6.4.5 LOC: Geographic user location SDES item\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     LOC=5     |     length    | geographic location of site  ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Depending on the application, different degrees of detail are\n   appropriate\
    \ for this item. For conference applications, a string like\n   \"Murray Hill,\
    \ New Jersey\" may be sufficient, while, for an active\n   badge system, strings\
    \ like \"Room 2A244, AT&T BL MH\" might be\n   appropriate. The degree of detail\
    \ is left to the implementation\n   and/or user, but format and content may be\
    \ prescribed by a profile.\n   The LOC value is expected to remain constant for\
    \ the duration of a\n   session, except for mobile hosts.\n"
- title: '6.4.6 TOOL: Application or tool name SDES item'
  contents:
  - "6.4.6 TOOL: Application or tool name SDES item\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     TOOL=6    |     length    | name/version of source appl. ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A string giving the name and possibly version of the application\n   generating\
    \ the stream, e.g., \"videotool 1.2\". This information may be\n   useful for\
    \ debugging purposes and is similar to the Mailer or Mail-\n   System-Version\
    \ SMTP headers. The TOOL value is expected to remain\n   constant for the duration\
    \ of the session.\n"
- title: '6.4.7 NOTE: Notice/status SDES item'
  contents:
  - "6.4.7 NOTE: Notice/status SDES item\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     NOTE=7    |     length    | note about the source        ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The following semantics are suggested for this item, but these or\n   other\
    \ semantics may be explicitly defined by a profile. The NOTE item\n   is intended\
    \ for transient messages describing the current state of\n   the source, e.g.,\
    \ \"on the phone, can't talk\". Or, during a seminar,\n   this item might be used\
    \ to convey the title of the talk. It should be\n   used only to carry exceptional\
    \ information and should not be included\n   routinely by all participants because\
    \ this would slow down the rate\n   at which reception reports and CNAME are sent,\
    \ thus impairing the\n   performance of the protocol. In particular, it should\
    \ not be included\n   as an item in a user's configuration file nor automatically\
    \ generated\n   as in a quote-of-the-day.\n   Since the NOTE item may be important\
    \ to display while it is active,\n   the rate at which other non-CNAME items such\
    \ as NAME are transmitted\n   might be reduced so that the NOTE item can take\
    \ that part of the RTCP\n   bandwidth. When the transient message becomes inactive,\
    \ the NOTE item\n   should continue to be transmitted a few times at the same\
    \ repetition\n   rate but with a string of length zero to signal the receivers.\n\
    \   However, receivers should also consider the NOTE item inactive if it\n   is\
    \ not received for a small multiple of the repetition rate, or\n   perhaps 20-30\
    \ RTCP intervals.\n"
- title: '6.4.8 PRIV: Private extensions SDES item'
  contents:
  - "6.4.8 PRIV: Private extensions SDES item\n      0                   1       \
    \            2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |     PRIV=8    |     length    | prefix length | prefix string...\n   \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    ...\
    \              |                  value string                ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This item is used to define experimental or application-specific SDES\n  \
    \ extensions. The item contains a prefix consisting of a length-string\n   pair,\
    \ followed by the value string filling the remainder of the item\n   and carrying\
    \ the desired information. The prefix length field is 8\n   bits long. The prefix\
    \ string is a name chosen by the person defining\n   the PRIV item to be unique\
    \ with respect to other PRIV items this\n   application might receive. The application\
    \ creator might choose to\n   use the application name plus an additional subtype\
    \ identification if\n   needed.  Alternatively, it is recommended that others\
    \ choose a name\n   based on the entity they represent, then coordinate the use\
    \ of the\n   name within that entity.\n   Note that the prefix consumes some space\
    \ within the item's total\n   length of 255 octets, so the prefix should be kept\
    \ as short as\n   possible. This facility and the constrained RTCP bandwidth should\
    \ not\n   be overloaded; it is not intended to satisfy all the control\n   communication\
    \ requirements of all applications.\n   SDES PRIV prefixes will not be registered\
    \ by IANA. If some form of\n   the PRIV item proves to be of general utility,\
    \ it should instead be\n   assigned a regular SDES item type registered with IANA\
    \ so that no\n   prefix is required. This simplifies use and increases transmission\n\
    \   efficiency.\n"
- title: '6.5 BYE: Goodbye RTCP packet'
  contents:
  - "6.5 BYE: Goodbye RTCP packet\n    0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |V=2|P|    SC   |   PT=BYE=203  |             length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SSRC/CSRC                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                              ...                              :\n   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \   |     length    |               reason for leaving             ... (opt)\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The\
    \ BYE packet indicates that one or more sources are no longer\n   active.\n  \
    \ version (V), padding (P), length:\n        As described for the SR packet (see\
    \ Section 6.3.1).\n   packet type (PT): 8 bits\n        Contains the constant\
    \ 203 to identify this as an RTCP BYE\n        packet.\n   source count (SC):\
    \ 5 bits\n        The number of SSRC/CSRC identifiers included in this BYE packet.\n\
    \        A count value of zero is valid, but useless.\n   If a BYE packet is received\
    \ by a mixer, the mixer forwards the BYE\n   packet with the SSRC/CSRC identifier(s)\
    \ unchanged. If a mixer shuts\n   down, it should send a BYE packet listing all\
    \ contributing sources it\n   handles, as well as its own SSRC identifier. Optionally,\
    \ the BYE\n   packet may include an 8-bit octet count followed by that many octets\n\
    \   of text indicating the reason for leaving, e.g., \"camera malfunction\"\n\
    \   or \"RTP loop detected\". The string has the same encoding as that\n   described\
    \ for SDES. If the string fills the packet to the next 32-bit\n   boundary, the\
    \ string is not null terminated. If not, the BYE packet\n   is padded with null\
    \ octets.\n"
- title: '6.6 APP: Application-defined RTCP packet'
  contents:
  - "6.6 APP: Application-defined RTCP packet\n    0                   1         \
    \          2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |V=2|P| subtype |   PT=APP=204  |             length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SSRC/CSRC                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          name (ASCII)                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   application-dependent data                 ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The APP packet is intended for experimental use as new applications\n   and\
    \ new features are developed, without requiring packet type value\n   registration.\
    \ APP packets with unrecognized names should be ignored.\n   After testing and\
    \ if wider use is justified, it is recommended that\n   each APP packet be redefined\
    \ without the subtype and name fields and\n   registered with the Internet Assigned\
    \ Numbers Authority using an RTCP\n   packet type.\n   version (V), padding (P),\
    \ length:\n        As described for the SR packet (see Section 6.3.1).\n   subtype:\
    \ 5 bits\n        May be used as a subtype to allow a set of APP packets to be\n\
    \        defined under one unique name, or for any application-dependent\n   \
    \     data.\n   packet type (PT): 8 bits\n        Contains the constant 204 to\
    \ identify this as an RTCP APP\n        packet.\n   name: 4 octets\n        A\
    \ name chosen by the person defining the set of APP packets to\n        be unique\
    \ with respect to other APP packets this application\n        might receive. The\
    \ application creator might choose to use the\n        application name, and then\
    \ coordinate the allocation of subtype\n        values to others who want to define\
    \ new packet types for the\n        application.  Alternatively, it is recommended\
    \ that others\n        choose a name based on the entity they represent, then\n\
    \        coordinate the use of the name within that entity. The name is\n    \
    \    interpreted as a sequence of four ASCII characters, with\n        uppercase\
    \ and lowercase characters treated as distinct.\n   application-dependent data:\
    \ variable length\n        Application-dependent data may or may not appear in\
    \ an APP\n        packet. It is interpreted by the application and not RTP itself.\n\
    \        It must be a multiple of 32 bits long.\n"
- title: 7.  RTP Translators and Mixers
  contents:
  - "7.  RTP Translators and Mixers\n   In addition to end systems, RTP supports the\
    \ notion of \"translators\"\n   and \"mixers\", which could be considered as \"\
    intermediate systems\" at\n   the RTP level. Although this support adds some complexity\
    \ to the\n   protocol, the need for these functions has been clearly established\n\
    \   by experiments with multicast audio and video applications in the\n   Internet.\
    \ Example uses of translators and mixers given in Section 2.3\n   stem from the\
    \ presence of firewalls and low bandwidth connections,\n   both of which are likely\
    \ to remain.\n"
- title: 7.1 General Description
  contents:
  - "7.1 General Description\n   An RTP translator/mixer connects two or more transport-level\n\
    \   \"clouds\".  Typically, each cloud is defined by a common network and\n  \
    \ transport protocol (e.g., IP/UDP), multicast address or pair of\n   unicast\
    \ addresses, and transport level destination port.  (Network-\n   level protocol\
    \ translators, such as IP version 4 to IP version 6, may\n   be present within\
    \ a cloud invisibly to RTP.) One system may serve as\n   a translator or mixer\
    \ for a number of RTP sessions, but each is\n   considered a logically separate\
    \ entity.\n   In order to avoid creating a loop when a translator or mixer is\n\
    \   installed, the following rules must be observed:\n        o Each of the clouds\
    \ connected by translators and mixers\n         participating in one RTP session\
    \ either must be distinct from\n         all the others in at least one of these\
    \ parameters (protocol,\n         address, port), or must be isolated at the network\
    \ level from\n         the others.\n        o A derivative of the first rule is\
    \ that there must not be\n         multiple translators or mixers connected in\
    \ parallel unless by\n         some arrangement they partition the set of sources\
    \ to be\n         forwarded.\n   Similarly, all RTP end systems that can communicate\
    \ through one or\n   more RTP translators or mixers share the same SSRC space,\
    \ that is,\n   the SSRC identifiers must be unique among all these end systems.\n\
    \   Section 8.2 describes the collision resolution algorithm by which\n   SSRC\
    \ identifiers are kept unique and loops are detected.\n   There may be many varieties\
    \ of translators and mixers designed for\n   different purposes and applications.\
    \ Some examples are to add or\n   remove encryption, change the encoding of the\
    \ data or the underlying\n   protocols, or replicate between a multicast address\
    \ and one or more\n   unicast addresses. The distinction between translators and\
    \ mixers is\n   that a translator passes through the data streams from different\n\
    \   sources separately, whereas a mixer combines them to form one new\n   stream:\n\
    \   Translator: Forwards RTP packets with their SSRC identifier intact;\n    \
    \    this makes it possible for receivers to identify individual\n        sources\
    \ even though packets from all the sources pass through\n        the same translator\
    \ and carry the translator's network source\n        address. Some kinds of translators\
    \ will pass through the data\n        untouched, but others may change the encoding\
    \ of the data and\n        thus the RTP data payload type and timestamp. If multiple\
    \ data\n        packets are re-encoded into one, or vice versa, a translator\n\
    \        must assign new sequence numbers to the outgoing packets. Losses\n  \
    \      in the incoming packet stream may induce corresponding gaps in\n      \
    \  the outgoing sequence numbers. Receivers cannot detect the\n        presence\
    \ of a translator unless they know by some other means\n        what payload type\
    \ or transport address was used by the original\n        source.\n   Mixer: Receives\
    \ streams of RTP data packets from one or more sources,\n        possibly changes\
    \ the data format, combines the streams in some\n        manner and then forwards\
    \ the combined stream. Since the timing\n        among multiple input sources\
    \ will not generally be synchronized,\n        the mixer will make timing adjustments\
    \ among the streams and\n        generate its own timing for the combined stream,\
    \ so it is the\n        synchronization source. Thus, all data packets forwarded\
    \ by a\n        mixer will be marked with the mixer's own SSRC identifier. In\n\
    \        order to preserve the identity of the original sources\n        contributing\
    \ to the mixed packet, the mixer should insert their\n        SSRC identifiers\
    \ into the CSRC identifier list following the\n        fixed RTP header of the\
    \ packet. A mixer that is also itself a\n        contributing source for some\
    \ packet should explicitly include\n        its own SSRC identifier in the CSRC\
    \ list for that packet.\n   For some applications, it may be acceptable for a\
    \ mixer not to\n   identify sources in the CSRC list. However, this introduces\
    \ the\n   danger that loops involving those sources could not be detected.\n \
    \  The advantage of a mixer over a translator for applications like\n   audio\
    \ is that the output bandwidth is limited to that of one source\n   even when\
    \ multiple sources are active on the input side. This may be\n   important for\
    \ low-bandwidth links. The disadvantage is that receivers\n   on the output side\
    \ don't have any control over which sources are\n   passed through or muted, unless\
    \ some mechanism is implemented for\n   remote control of the mixer. The regeneration\
    \ of synchronization\n   information by mixers also means that receivers can't\
    \ do inter-media\n   synchronization of the original streams. A multi-media mixer\
    \ could do\n   it.\n         [E1]                                    [E6]\n  \
    \        |                                       |\n    E1:17 |              \
    \                   E6:15 |\n          |                                     \
    \  |   E6:15\n          V  M1:48 (1,17)         M1:48 (1,17)    V   M1:48 (1,17)\n\
    \         (M1)-------------><T1>-----------------><T2>-------------->[E7]\n  \
    \        ^                 ^     E4:47           ^   E4:47\n     E2:1 |      \
    \     E4:47 |                     |   M3:89 (64,45)\n          |             \
    \    |                     |\n         [E2]              [E4]     M3:89 (64,45)\
    \ |\n                                                  |        legend:\n   [E3]\
    \ --------->(M2)----------->(M3)------------|        [End system]\n          E3:64\
    \        M2:12 (64)  ^                       (Mixer)\n                       \
    \            | E5:45                 <Translator>\n                          \
    \         |\n                                  [E5]          source: SSRC (CSRCs)\n\
    \                                                ------------------->\n Figure\
    \ 3: Sample RTP network with end systems, mixers and translators\n   A collection\
    \ of mixers and translators is shown in Figure 3 to\n   illustrate their effect\
    \ on SSRC and CSRC identifiers. In the figure,\n   end systems are shown as rectangles\
    \ (named E), translators as\n   triangles (named T) and mixers as ovals (named\
    \ M). The notation \"M1:\n   48(1,17)\" designates a packet originating a mixer\
    \ M1, identified with\n   M1's (random) SSRC value of 48 and two CSRC identifiers,\
    \ 1 and 17,\n   copied from the SSRC identifiers of packets from E1 and E2.\n"
- title: 7.2 RTCP Processing in Translators
  contents:
  - "7.2 RTCP Processing in Translators\n   In addition to forwarding data packets,\
    \ perhaps modified, translators\n   and mixers must also process RTCP packets.\
    \ In many cases, they will\n   take apart the compound RTCP packets received from\
    \ end systems to\n   aggregate SDES information and to modify the SR or RR packets.\n\
    \   Retransmission of this information may be triggered by the packet\n   arrival\
    \ or by the RTCP interval timer of the translator or mixer\n   itself.\n   A translator\
    \ that does not modify the data packets, for example one\n   that just replicates\
    \ between a multicast address and a unicast\n   address, may simply forward RTCP\
    \ packets unmodified as well. A\n   translator that transforms the payload in\
    \ some way must make\n   corresponding transformations in the SR and RR information\
    \ so that it\n   still reflects the characteristics of the data and the reception\n\
    \   quality. These translators must not simply forward RTCP packets. In\n   general,\
    \ a translator should not aggregate SR and RR packets from\n   different sources\
    \ into one packet since that would reduce the\n   accuracy of the propagation\
    \ delay measurements based on the LSR and\n   DLSR fields.\n   SR sender information:\
    \  A translator does not generate its own sender\n        information, but forwards\
    \ the SR packets received from one cloud\n        to the others. The SSRC is left\
    \ intact but the sender\n        information must be modified if required by the\
    \ translation. If\n        a translator changes the data encoding, it must change\
    \ the\n        \"sender's byte count\" field. If it also combines several data\n\
    \        packets into one output packet, it must change the \"sender's\n     \
    \   packet count\" field. If it changes the timestamp frequency, it\n        must\
    \ change the \"RTP timestamp\" field in the SR packet.\n   SR/RR reception report\
    \ blocks:  A translator forwards reception\n        reports received from one\
    \ cloud to the others. Note that these\n        flow in the direction opposite\
    \ to the data.  The SSRC is left\n        intact. If a translator combines several\
    \ data packets into one\n        output packet, and therefore changes the sequence\
    \ numbers, it\n        must make the inverse manipulation for the packet loss\
    \ fields\n        and the \"extended last sequence number\" field. This may be\n\
    \        complex. In the extreme case, there may be no meaningful way to\n   \
    \     translate the reception reports, so the translator may pass on\n       \
    \ no reception report at all or a synthetic report based on its\n        own reception.\
    \ The general rule is to do what makes sense for a\n        particular translation.\n\
    \   A translator does not require an SSRC identifier of its own, but may\n   choose\
    \ to allocate one for the purpose of sending reports about what\n   it has received.\
    \ These would be sent to all the connected clouds,\n   each corresponding to the\
    \ translation of the data stream as sent to\n   that cloud, since reception reports\
    \ are normally multicast to all\n   participants.\n   SDES:  Translators typically\
    \ forward without change the SDES\n        information they receive from one cloud\
    \ to the others, but may,\n        for example, decide to filter non-CNAME SDES\
    \ information if\n        bandwidth is limited. The CNAMEs must be forwarded to\
    \ allow SSRC\n        identifier collision detection to work. A translator that\n\
    \        generates its own RR packets must send SDES CNAME information\n     \
    \   about itself to the same clouds that it sends those RR packets.\n   BYE: \
    \ Translators forward BYE packets unchanged. Translators with\n        their own\
    \ SSRC should generate BYE packets with that SSRC\n        identifier if they\
    \ are about to cease forwarding packets.\n   APP:  Translators forward APP packets\
    \ unchanged.\n"
- title: 7.3 RTCP Processing in Mixers
  contents:
  - "7.3 RTCP Processing in Mixers\n   Since a mixer generates a new data stream of\
    \ its own, it does not\n   pass through SR or RR packets at all and instead generates\
    \ new\n   information for both sides.\n   SR sender information:  A mixer does\
    \ not pass through sender\n        information from the sources it mixes because\
    \ the\n        characteristics of the source streams are lost in the mix. As a\n\
    \        synchronization source, the mixer generates its own SR packets\n    \
    \    with sender information about the mixed data stream and sends\n        them\
    \ in the same direction as the mixed stream.\n   SR/RR reception report blocks:\
    \  A mixer generates its own reception\n        reports for sources in each cloud\
    \ and sends them out only to the\n        same cloud. It does not send these reception\
    \ reports to the\n        other clouds and does not forward reception reports\
    \ from one\n        cloud to the others because the sources would not be SSRCs\
    \ there\n        (only CSRCs).\n   SDES:  Mixers typically forward without change\
    \ the SDES information\n        they receive from one cloud to the others, but\
    \ may, for example,\n        decide to filter non-CNAME SDES information if bandwidth\
    \ is\n        limited. The CNAMEs must be forwarded to allow SSRC identifier\n\
    \        collision detection to work. (An identifier in a CSRC list\n        generated\
    \ by a mixer might collide with an SSRC identifier\n        generated by an end\
    \ system.) A mixer must send SDES CNAME\n        information about itself to the\
    \ same clouds that it sends SR or\n        RR packets.\n   Since mixers do not\
    \ forward SR or RR packets, they will typically be\n   extracting SDES packets\
    \ from a compound RTCP packet. To minimize\n   overhead, chunks from the SDES\
    \ packets may be aggregated into a\n   single SDES packet which is then stacked\
    \ on an SR or RR packet\n   originating from the mixer. The RTCP packet rate may\
    \ be different on\n   each side of the mixer.\n   A mixer that does not insert\
    \ CSRC identifiers may also refrain from\n   forwarding SDES CNAMEs. In this case,\
    \ the SSRC identifier spaces in\n   the two clouds are independent. As mentioned\
    \ earlier, this mode of\n   operation creates a danger that loops can't be detected.\n\
    \   BYE:  Mixers need to forward BYE packets. They should generate BYE\n     \
    \   packets with their own SSRC identifiers if they are about to\n        cease\
    \ forwarding packets.\n   APP:  The treatment of APP packets by mixers is application-specific.\n"
- title: 7.4 Cascaded Mixers
  contents:
  - "7.4 Cascaded Mixers\n   An RTP session may involve a collection of mixers and\
    \ translators as\n   shown in Figure 3. If two mixers are cascaded, such as M2\
    \ and M3 in\n   the figure, packets received by a mixer may already have been\
    \ mixed\n   and may include a CSRC list with multiple identifiers. The second\n\
    \   mixer should build the CSRC list for the outgoing packet using the\n   CSRC\
    \ identifiers from already-mixed input packets and the SSRC\n   identifiers from\
    \ unmixed input packets. This is shown in the output\n   arc from mixer M3 labeled\
    \ M3:89(64,45) in the figure. As in the case\n   of mixers that are not cascaded,\
    \ if the resulting CSRC list has more\n   than 15 identifiers, the remainder cannot\
    \ be included.\n"
- title: 8.  SSRC Identifier Allocation and Use
  contents:
  - "8.  SSRC Identifier Allocation and Use\n   The SSRC identifier carried in the\
    \ RTP header and in various fields\n   of RTCP packets is a random 32-bit number\
    \ that is required to be\n   globally unique within an RTP session. It is crucial\
    \ that the number\n   be chosen with care in order that participants on the same\
    \ network or\n   starting at the same time are not likely to choose the same number.\n\
    \   It is not sufficient to use the local network address (such as an\n   IPv4\
    \ address) for the identifier because the address may not be\n   unique. Since\
    \ RTP translators and mixers enable interoperation among\n   multiple networks\
    \ with different address spaces, the allocation\n   patterns for addresses within\
    \ two spaces might result in a much\n   higher rate of collision than would occur\
    \ with random allocation.\n   Multiple sources running on one host would also\
    \ conflict.\n   It is also not sufficient to obtain an SSRC identifier simply\
    \ by\n   calling random() without carefully initializing the state. An example\n\
    \   of how to generate a random identifier is presented in Appendix A.6.\n"
- title: 8.1 Probability of Collision
  contents:
  - "8.1 Probability of Collision\n   Since the identifiers are chosen randomly, it\
    \ is possible that two or\n   more sources will choose the same number. Collision\
    \ occurs with the\n   highest probability when all sources are started simultaneously,\
    \ for\n   example when triggered automatically by some session management\n  \
    \ event. If N is the number of sources and L the length of the\n   identifier\
    \ (here, 32 bits), the probability that two sources\n   independently pick the\
    \ same value can be approximated for large N\n   [20] as 1 - exp(-N**2 / 2**(L+1)).\
    \ For N=1000, the probability is\n   roughly 10**-4.\n   The typical collision\
    \ probability is much lower than the worst-case\n   above. When one new source\
    \ joins an RTP session in which all the\n   other sources already have unique\
    \ identifiers, the probability of\n   collision is just the fraction of numbers\
    \ used out of the space.\n   Again, if N is the number of sources and L the length\
    \ of the\n   identifier, the probability of collision is N / 2**L. For N=1000,\
    \ the\n   probability is roughly 2*10**-7.\n   The probability of collision is\
    \ further reduced by the opportunity\n   for a new source to receive packets from\
    \ other participants before\n   sending its first packet (either data or control).\
    \ If the new source\n   keeps track of the other participants (by SSRC identifier),\
    \ then\n   before transmitting its first packet the new source can verify that\n\
    \   its identifier does not conflict with any that have been received, or\n  \
    \ else choose again.\n"
- title: 8.2 Collision Resolution and Loop Detection
  contents:
  - "8.2 Collision Resolution and Loop Detection\n   Although the probability of SSRC\
    \ identifier collision is low, all RTP\n   implementations must be prepared to\
    \ detect collisions and take the\n   appropriate actions to resolve them. If a\
    \ source discovers at any\n   time that another source is using the same SSRC\
    \ identifier as its\n   own, it must send an RTCP BYE packet for the old identifier\
    \ and\n   choose another random one. If a receiver discovers that two other\n\
    \   sources are colliding, it may keep the packets from one and discard\n   the\
    \ packets from the other when this can be detected by different\n   source transport\
    \ addresses or CNAMEs. The two sources are expected to\n   resolve the collision\
    \ so that the situation doesn't last.\n   Because the random identifiers are kept\
    \ globally unique for each RTP\n   session, they can also be used to detect loops\
    \ that may be introduced\n   by mixers or translators. A loop causes duplication\
    \ of data and\n   control information, either unmodified or possibly mixed, as\
    \ in the\n   following examples:\n        o A translator may incorrectly forward\
    \ a packet to the same\n         multicast group from which it has received the\
    \ packet, either\n         directly or through a chain of translators. In that\
    \ case, the\n         same packet appears several times, originating from different\n\
    \         network sources.\n        o Two translators incorrectly set up in parallel,\
    \ i.e., with the\n         same multicast groups on both sides, would both forward\
    \ packets\n         from one multicast group to the other. Unidirectional\n  \
    \       translators would produce two copies; bidirectional translators\n    \
    \     would form a loop.\n        o A mixer can close a loop by sending to the\
    \ same transport\n         destination upon which it receives packets, either\
    \ directly or\n         through another mixer or translator. In this case a source\n\
    \         might show up both as an SSRC on a data packet and a CSRC in a\n   \
    \      mixed data packet.\n   A source may discover that its own packets are being\
    \ looped, or that\n   packets from another source are being looped (a third-party\
    \ loop).\n   Both loops and collisions in the random selection of a source\n \
    \  identifier result in packets arriving with the same SSRC identifier\n   but\
    \ a different source transport address, which may be that of the\n   end system\
    \ originating the packet or an intermediate system.\n   Consequently, if a source\
    \ changes its source transport address, it\n   must also choose a new SSRC identifier\
    \ to avoid being interpreted as\n   a looped source. Loops or collisions occurring\
    \ on the far side of a\n   translator or mixer cannot be detected using the source\
    \ transport\n   address if all copies of the packets go through the translator\
    \ or\n   mixer, however collisions may still be detected when chunks from two\n\
    \   RTCP SDES packets contain the same SSRC identifier but different\n   CNAMEs.\n\
    \   To detect and resolve these conflicts, an RTP implementation must\n   include\
    \ an algorithm similar to the one described below. It ignores\n   packets from\
    \ a new source or loop that collide with an established\n   source. It resolves\
    \ collisions with the participant's own SSRC\n   identifier by sending an RTCP\
    \ BYE for the old identifier and choosing\n   a new one. However, when the collision\
    \ was induced by a loop of the\n   participant's own packets, the algorithm will\
    \ choose a new identifier\n   only once and thereafter ignore packets from the\
    \ looping source\n   transport address. This is required to avoid a flood of BYE\
    \ packets.\n   This algorithm depends upon the source transport address being\
    \ the\n   same for both RTP and RTCP packets from a source. The algorithm would\n\
    \   require modifications to support applications that don't meet this\n   constraint.\n\
    \   This algorithm requires keeping a table indexed by source identifiers\n  \
    \ and containing the source transport address from which the identifier\n   was\
    \ (first) received, along with other state for that source. Each\n   SSRC or CSRC\
    \ identifier received in a data or control packet is\n   looked up in this table\
    \ in order to process that data or control\n   information.  For control packets,\
    \ each element with its own SSRC,\n   for example an SDES chunk, requires a separate\
    \ lookup. (The SSRC in a\n   reception report block is an exception.) If the SSRC\
    \ or CSRC is not\n   found, a new entry is created. These table entries are removed\
    \ when\n   an RTCP BYE packet is received with the corresponding SSRC, or after\n\
    \   no packets have arrived for a relatively long time (see Section\n   6.2.1).\n\
    \   In order to track loops of the participant's own data packets, it is\n   also\
    \ necessary to keep a separate list of source transport addresses\n   (not identifiers)\
    \ that have been found to be conflicting. Note that\n   this should be a short\
    \ list, usually empty. Each element in this list\n   stores the source address\
    \ plus the time when the most recent\n   conflicting packet was received. An element\
    \ may be removed from the\n   list when no conflicting packet has arrived from\
    \ that source for a\n   time on the order of 10 RTCP report intervals (see Section\
    \ 6.2).\n   For the algorithm as shown, it is assumed that the participant's own\n\
    \   source identifier and state are included in the source identifier\n   table.\
    \ The algorithm could be restructured to first make a separate\n   comparison\
    \ against the participant's own source identifier.\n       IF the SSRC or CSRC\
    \ identifier is not found in the source\n          identifier table:\n       THEN\
    \ create a new entry storing the source transport address\n            and the\
    \ SSRC or CSRC along with other state.\n            CONTINUE with normal processing.\n\
    \       (identifier is found in the table)\n       IF the source transport address\
    \ from the packet matches\n          the one saved in the table entry for this\
    \ identifier:\n       THEN CONTINUE with normal processing.\n       (an identifier\
    \ collision or a loop is indicated)\n       IF the source identifier is not the\
    \ participant's own:\n       THEN IF the source identifier is from an RTCP SDES\
    \ chunk\n               containing a CNAME item that differs from the CNAME\n\
    \               in the table entry:\n            THEN (optionally) count a third-party\
    \ collision.\n            ELSE (optionally) count a third-party loop.\n      \
    \      ABORT processing of data packet or control element.\n       (a collision\
    \ or loop of the participant's own data)\n       IF the source transport address\
    \ is found in the list of\n         conflicting addresses:\n       THEN IF the\
    \ source identifier is not from an RTCP SDES chunk\n               containing\
    \ a CNAME item OR if that CNAME is the\n               participant's own:\n  \
    \          THEN (optionally) count occurrence of own traffic looped.\n       \
    \          mark current time in conflicting address list entry.\n            \
    \     ABORT processing of data packet or control element.\n       log occurrence\
    \ of a collision.\n       create a new entry in the conflicting address list and\n\
    \       mark current time.\n       send an RTCP BYE packet with the old SSRC identifier.\n\
    \       choose a new identifier.\n       create a new entry in the source identifier\
    \ table with the\n         old SSRC plus the source transport address from the\
    \ packet\n         being processed.\n       CONTINUE with normal processing.\n\
    \   In this algorithm, packets from a newly conflicting source address\n   will\
    \ be ignored and packets from the original source will be kept.\n   (If the original\
    \ source was through a mixer and later the same source\n   is received directly,\
    \ the receiver may be well advised to switch\n   unless other sources in the mix\
    \ would be lost.) If no packets arrive\n   from the original source for an extended\
    \ period, the table entry will\n   be timed out and the new source will be able\
    \ to take over. This might\n   occur if the original source detects the collision\
    \ and moves to a new\n   source identifier, but in the usual case an RTCP BYE\
    \ packet will be\n   received from the original source to delete the state without\
    \ having\n   to wait for a timeout.\n   When a new SSRC identifier is chosen due\
    \ to a collision, the\n   candidate identifier should first be looked up in the\
    \ source\n   identifier table to see if it was already in use by some other\n\
    \   source. If so, another candidate should be generated and the process\n   repeated.\n\
    \   A loop of data packets to a multicast destination can cause severe\n   network\
    \ flooding. All mixers and translators are required to\n   implement a loop detection\
    \ algorithm like the one here so that they\n   can break loops. This should limit\
    \ the excess traffic to no more than\n   one duplicate copy of the original traffic,\
    \ which may allow the\n   session to continue so that the cause of the loop can\
    \ be found and\n   fixed. However, in extreme cases where a mixer or translator\
    \ does not\n   properly break the loop and high traffic levels result, it may\
    \ be\n   necessary for end systems to cease transmitting data or control\n   packets\
    \ entirely. This decision may depend upon the application. An\n   error condition\
    \ should be indicated as appropriate. Transmission\n   might be attempted again\
    \ periodically after a long, random time (on\n   the order of minutes).\n"
- title: 9.  Security
  contents:
  - "9.  Security\n   Lower layer protocols may eventually provide all the security\n\
    \   services that may be desired for applications of RTP, including\n   authentication,\
    \ integrity, and confidentiality. These services  have\n   recently been specified\
    \ for IP. Since the need for a confidentiality\n   service is well established\
    \ in the initial audio and video\n   applications that are expected to use RTP,\
    \ a confidentiality service\n   is defined in the next section for use with RTP\
    \ and RTCP until lower\n   layer services are available. The overhead on the protocol\
    \ for this\n   service is low, so the penalty will be minimal if this service\
    \ is\n   obsoleted by lower layer services in the future.\n   Alternatively, other\
    \ services, other implementations of services and\n   other algorithms may be\
    \ defined for RTP in the future if warranted.\n   The selection presented here\
    \ is meant to simplify implementation of\n   interoperable, secure applications\
    \ and provide guidance to\n   implementors. No claim is made that the methods\
    \ presented here are\n   appropriate for a particular security need. A profile\
    \ may specify\n   which services and algorithms should be offered by applications,\
    \ and\n   may provide guidance as to their appropriate use.\n   Key distribution\
    \ and certificates are outside the scope of this\n   document.\n"
- title: 9.1 Confidentiality
  contents:
  - "9.1 Confidentiality\n   Confidentiality means that only the intended receiver(s)\
    \ can decode\n   the received packets; for others, the packet contains no useful\n\
    \   information. Confidentiality of the content is achieved by\n   encryption.\n\
    \   When encryption of RTP or RTCP is desired, all the octets that will\n   be\
    \ encapsulated for transmission in a single lower-layer packet are\n   encrypted\
    \ as a unit. For RTCP, a 32-bit random number is prepended to\n   the unit before\
    \ encryption to deter known plaintext attacks. For RTP,\n   no prefix is required\
    \ because the sequence number and timestamp\n   fields are initialized with random\
    \ offsets.\n   For RTCP, it is allowed to split a compound RTCP packet into two\n\
    \   lower-layer packets, one to be encrypted and one to be sent in the\n   clear.\
    \ For example, SDES information might be encrypted while\n   reception reports\
    \ were sent in the clear to accommodate third-party\n   monitors that are not\
    \ privy to the encryption key. In this example,\n   depicted in Fig. 4, the SDES\
    \ information must be appended to an RR\n   packet with no reports (and the encrypted)\
    \ to satisfy the requirement\n   that all compound RTCP packets begin with an\
    \ SR or RR packet.\n                 UDP packet                        UDP packet\n\
    \   -------------------------------------  -------------------------\n   [32-bit\
    \ ][       ][     #           ]  [    # sender # receiver]\n   [random ][  RR\
    \   ][SDES # CNAME, ...]  [ SR # report # report  ]\n   [integer][(empty)][  \
    \   #           ]  [    #        #         ]\n   -------------------------------------\
    \  -------------------------\n                 encrypted                     \
    \  not encrypted\n   #: SSRC\n           Figure 4: Encrypted and non-encrypted\
    \ RTCP packets\n   The presence of encryption and the use of the correct key are\n\
    \   confirmed by the receiver through header or payload validity checks.\n   Examples\
    \ of such validity checks for RTP and RTCP headers are given\n   in Appendices\
    \ A.1 and A.2.\n   The default encryption algorithm is the Data Encryption Standard\n\
    \   (DES) algorithm in cipher block chaining (CBC) mode, as described in\n   Section\
    \ 1.1 of RFC 1423 [21], except that padding to a multiple of 8\n   octets is indicated\
    \ as described for the P bit in Section 5.1. The\n   initialization vector is\
    \ zero because random values are supplied in\n   the RTP header or by the random\
    \ prefix for compound RTCP packets. For\n   details on the use of CBC initialization\
    \ vectors, see [22].\n   Implementations that support encryption should always\
    \ support the DES\n   algorithm in CBC mode as the default to maximize interoperability.\n\
    \   This method is chosen because it has been demonstrated to be easy and\n  \
    \ practical to use in experimental audio and video tools in operation\n   on the\
    \ Internet. Other encryption algorithms may be specified\n   dynamically for a\
    \ session by non-RTP means.\n   As an alternative to encryption at the RTP level\
    \ as described above,\n   profiles may define additional payload types for encrypted\
    \ encodings.\n   Those encodings must specify how padding and other aspects of\
    \ the\n   encryption should be handled. This method allows encrypting only the\n\
    \   data while leaving the headers in the clear for applications where\n   that\
    \ is desired. It may be particularly useful for hardware devices\n   that will\
    \ handle both decryption and decoding.\n"
- title: 9.2 Authentication and Message Integrity
  contents:
  - "9.2 Authentication and Message Integrity\n   Authentication and message integrity\
    \ are not defined in the current\n   specification of RTP since these services\
    \ would not be directly\n   feasible without a key management infrastructure.\
    \ It is expected that\n   authentication and integrity services will be provided\
    \ by lower layer\n   protocols in the future.\n"
- title: 10.  RTP over Network and Transport Protocols
  contents:
  - "10.  RTP over Network and Transport Protocols\n   This section describes issues\
    \ specific to carrying RTP packets within\n   particular network and transport\
    \ protocols. The following rules apply\n   unless superseded by protocol-specific\
    \ definitions outside this\n   specification.\n   RTP relies on the underlying\
    \ protocol(s) to provide demultiplexing of\n   RTP data and RTCP control streams.\
    \ For UDP and similar protocols, RTP\n   uses an even port number and the corresponding\
    \ RTCP stream uses the\n   next higher (odd) port number. If an application is\
    \ supplied with an\n   odd number for use as the RTP port, it should replace this\
    \ number\n   with the next lower (even) number.\n   RTP data packets contain no\
    \ length field or other delineation,\n   therefore RTP relies on the underlying\
    \ protocol(s) to provide a\n   length indication. The maximum length of RTP packets\
    \ is limited only\n   by the underlying protocols.\n   If RTP packets are to be\
    \ carried in an underlying protocol that\n   provides the abstraction of a continuous\
    \ octet stream rather than\n   messages (packets), an encapsulation of the RTP\
    \ packets must be\n   defined to provide a framing mechanism. Framing is also\
    \ needed if the\n   underlying protocol may contain padding so that the extent\
    \ of the RTP\n   payload cannot be determined. The framing mechanism is not defined\n\
    \   here.\n   A profile may specify a framing method to be used even when RTP\
    \ is\n   carried in protocols that do provide framing in order to allow\n   carrying\
    \ several RTP packets in one lower-layer protocol data unit,\n   such as a UDP\
    \ packet. Carrying several RTP packets in one network or\n   transport packet\
    \ reduces header overhead and may simplify\n   synchronization between different\
    \ streams.\n"
- title: 11.  Summary of Protocol Constants
  contents:
  - "11.  Summary of Protocol Constants\n   This section contains a summary listing\
    \ of the constants defined in\n   this specification.\n   The RTP payload type\
    \ (PT) constants are defined in profiles rather\n   than this document. However,\
    \ the octet of the RTP header which\n   contains the marker bit(s) and payload\
    \ type must avoid the reserved\n   values 200 and 201 (decimal) to distinguish\
    \ RTP packets from the RTCP\n   SR and RR packet types for the header validation\
    \ procedure described\n   in Appendix A.1. For the standard definition of one\
    \ marker bit and a\n   7-bit payload type field as shown in this specification,\
    \ this\n   restriction means that payload types 72 and 73 are reserved.\n"
- title: 11.1 RTCP packet types
  contents:
  - "11.1 RTCP packet types\n   abbrev.    name                   value\n   SR   \
    \      sender report            200\n   RR         receiver report          201\n\
    \   SDES       source description       202\n   BYE        goodbye           \
    \       203\n   APP        application-defined      204\n   These type values\
    \ were chosen in the range 200-204 for improved\n   header validity checking of\
    \ RTCP packets compared to RTP packets or\n   other unrelated packets. When the\
    \ RTCP packet type field is compared\n   to the corresponding octet of the RTP\
    \ header, this range corresponds\n   to the marker bit being 1 (which it usually\
    \ is not in data packets)\n   and to the high bit of the standard payload type\
    \ field being 1 (since\n   the static payload types are typically defined in the\
    \ low half). This\n   range was also chosen to be some distance numerically from\
    \ 0 and 255\n   since all-zeros and all-ones are common data patterns.\n   Since\
    \ all compound RTCP packets must begin with SR or RR, these codes\n   were chosen\
    \ as an even/odd pair to allow the RTCP validity check to\n   test the maximum\
    \ number of bits with mask and value.\n   Other constants are assigned by IANA.\
    \ Experimenters are encouraged to\n   register the numbers they need for experiments,\
    \ and then unregister\n   those which prove to be unneeded.\n"
- title: 11.2 SDES types
  contents:
  - "11.2 SDES types\n   abbrev.    name                              value\n   END\
    \        end of SDES list                      0\n   CNAME      canonical name\
    \                        1\n   NAME       user name                          \
    \   2\n   EMAIL      user's electronic mail address        3\n   PHONE      user's\
    \ phone number                   4\n   LOC        geographic user location   \
    \           5\n   TOOL       name of application or tool           6\n   NOTE\
    \       notice about the source               7\n   PRIV       private extensions\
    \                    8\n   Other constants are assigned by IANA. Experimenters\
    \ are encouraged to\n   register the numbers they need for experiments, and then\
    \ unregister\n   those which prove to be unneeded.\n"
- title: 12.  RTP Profiles and Payload Format Specifications
  contents:
  - "12.  RTP Profiles and Payload Format Specifications\n   A complete specification\
    \ of RTP for a particular application will\n   require one or more companion documents\
    \ of two types described here:\n   profiles, and payload format specifications.\n\
    \   RTP may be used for a variety of applications with somewhat differing\n  \
    \ requirements. The flexibility to adapt to those requirements is\n   provided\
    \ by allowing multiple choices in the main protocol\n   specification, then selecting\
    \ the appropriate choices or defining\n   extensions for a particular environment\
    \ and class of applications in\n   a separate profile document. Typically an application\
    \ will operate\n   under only one profile so there is no explicit indication of\
    \ which\n   profile is in use. A profile for audio and video applications may\
    \ be\n   found in the companion Internet-Draft draft-ietf-avt-profile for\n  \
    \ The second type of companion document is a payload format\n   specification,\
    \ which defines how a particular kind of payload data,\n   such as H.261 encoded\
    \ video, should be carried in RTP. These\n   documents are typically titled \"\
    RTP Payload Format for XYZ\n   Audio/Video Encoding\". Payload formats may be\
    \ useful under multiple\n   profiles and may therefore be defined independently\
    \ of any particular\n   profile. The profile documents are then responsible for\
    \ assigning a\n   default mapping of that format to a payload type value if needed.\n\
    \   Within this specification, the following items have been identified\n   for\
    \ possible definition within a profile, but this list is not meant\n   to be exhaustive:\n\
    \   RTP data header: The octet in the RTP data header that contains the\n    \
    \    marker bit and payload type field may be redefined by a profile\n       \
    \ to suit different requirements, for example with more or fewer\n        marker\
    \ bits (Section 5.3).\n   Payload types: Assuming that a payload type field is\
    \ included, the\n        profile will usually define a set of payload formats\
    \ (e.g.,\n        media encodings) and a default static mapping of those formats\n\
    \        to payload type values. Some of the payload formats may be\n        defined\
    \ by reference to separate payload format specifications.\n        For each payload\
    \ type defined, the profile must specify the RTP\n        timestamp clock rate\
    \ to be used (Section 5.1).\n   RTP data header additions: Additional fields may\
    \ be appended to the\n        fixed RTP data header if some additional functionality\
    \ is\n        required across the profile's class of applications independent\n\
    \        of payload type (Section 5.3).\n   RTP data header extensions: The contents\
    \ of the first 16 bits of the\n        RTP data header extension structure must\
    \ be defined if use of\n        that mechanism is to be allowed under the profile\
    \ for\n        implementation-specific extensions (Section 5.3.1).\n   RTCP packet\
    \ types: New application-class-specific RTCP packet types\n        may be defined\
    \ and registered with IANA.\n   RTCP report interval: A profile should specify\
    \ that the values\n        suggested in Section 6.2 for the constants employed\
    \ in the\n        calculation of the RTCP report interval will be used.  Those\
    \ are\n        the RTCP fraction of session bandwidth, the minimum report\n  \
    \      interval, and the bandwidth split between senders and receivers.\n    \
    \    A profile may specify alternate values if they have been\n        demonstrated\
    \ to work in a scalable manner.\n   SR/RR extension: An extension section may\
    \ be defined for the RTCP SR\n        and RR packets if there is additional information\
    \ that should be\n        reported regularly about the sender or receivers (Section\
    \ 6.3.3).\n   SDES use: The profile may specify the relative priorities for RTCP\n\
    \        SDES items to be transmitted or excluded entirely (Section\n        6.2.2);\
    \ an alternate syntax or semantics for the CNAME item\n        (Section 6.4.1);\
    \ the format of the LOC item (Section 6.4.5); the\n        semantics and use of\
    \ the NOTE item (Section 6.4.7); or new SDES\n        item types to be registered\
    \ with IANA.\n   Security: A profile may specify which security services and\n\
    \        algorithms should be offered by applications, and may provide\n     \
    \   guidance as to their appropriate use (Section 9).\n   String-to-key mapping:\
    \ A profile may specify how a user-provided\n        password or pass phrase is\
    \ mapped into an encryption key.\n   Underlying protocol: Use of a particular\
    \ underlying network or\n        transport layer protocol to carry RTP packets\
    \ may be required.\n   Transport mapping: A mapping of RTP and RTCP to transport-level\n\
    \        addresses, e.g., UDP ports, other than the standard mapping\n       \
    \ defined in Section 10 may be specified.\n   Encapsulation: An encapsulation\
    \ of RTP packets may be defined to\n        allow multiple RTP data packets to\
    \ be carried in one lower-layer\n        packet or to provide framing over underlying\
    \ protocols that do\n        not already do so (Section 10).\n   It is not expected\
    \ that a new profile will be required for every\n   application. Within one application\
    \ class, it would be better to\n   extend an existing profile rather than make\
    \ a new one in order to\n   facilitate interoperation among the applications since\
    \ each will\n   typically run under only one profile. Simple extensions such as\
    \ the\n   definition of additional payload type values or RTCP packet types may\n\
    \   be accomplished by registering them through the Internet Assigned\n   Numbers\
    \ Authority and publishing their descriptions in an addendum to\n   the profile\
    \ or in a payload format specification.\n"
- title: A.  Algorithms
  contents:
  - "A.  Algorithms\n   We provide examples of C code for aspects of RTP sender and\
    \ receiver\n   algorithms. There may be other implementation methods that are\
    \ faster\n   in particular operating environments or have other advantages. These\n\
    \   implementation notes are for informational purposes only and are\n   meant\
    \ to clarify the RTP specification.\n   The following definitions are used for\
    \ all examples; for clarity and\n   brevity, the structure definitions are only\
    \ valid for 32-bit big-\n   endian (most significant octet first) architectures.\
    \ Bit fields are\n   assumed to be packed tightly in big-endian bit order, with\
    \ no\n   additional padding. Modifications would be required to construct a\n\
    \   portable implementation.\n   /*\n    * rtp.h  --  RTP header file (RFC XXXX)\n\
    \    */\n   #include <sys/types.h>\n   /*\n    * The type definitions below are\
    \ valid for 32-bit architectures and\n    * may have to be adjusted for 16- or\
    \ 64-bit architectures.\n    */\n   typedef unsigned char  u_int8;\n   typedef\
    \ unsigned short u_int16;\n   typedef unsigned int   u_int32;\n   typedef    \
    \      short int16;\n   /*\n    * Current protocol version.\n    */\n   #define\
    \ RTP_VERSION    2\n   #define RTP_SEQ_MOD (1<<16)\n   #define RTP_MAX_SDES 255\
    \      /* maximum text length for SDES */\n   typedef enum {\n       RTCP_SR \
    \  = 200,\n       RTCP_RR   = 201,\n       RTCP_SDES = 202,\n       RTCP_BYE \
    \ = 203,\n       RTCP_APP  = 204\n   } rtcp_type_t;\n   typedef enum {\n     \
    \  RTCP_SDES_END   = 0,\n       RTCP_SDES_CNAME = 1,\n       RTCP_SDES_NAME  =\
    \ 2,\n       RTCP_SDES_EMAIL = 3,\n       RTCP_SDES_PHONE = 4,\n       RTCP_SDES_LOC\
    \   = 5,\n       RTCP_SDES_TOOL  = 6,\n       RTCP_SDES_NOTE  = 7,\n       RTCP_SDES_PRIV\
    \  = 8\n   } rtcp_sdes_type_t;\n   /*\n    * RTP data header\n    */\n   typedef\
    \ struct {\n       unsigned int version:2;   /* protocol version */\n       unsigned\
    \ int p:1;         /* padding flag */\n       unsigned int x:1;         /* header\
    \ extension flag */\n       unsigned int cc:4;        /* CSRC count */\n     \
    \  unsigned int m:1;         /* marker bit */\n       unsigned int pt:7;     \
    \   /* payload type */\n       u_int16 seq;              /* sequence number */\n\
    \       u_int32 ts;               /* timestamp */\n       u_int32 ssrc;      \
    \       /* synchronization source */\n       u_int32 csrc[1];          /* optional\
    \ CSRC list */\n   } rtp_hdr_t;\n   /*\n    * RTCP common header word\n    */\n\
    \   typedef struct {\n       unsigned int version:2;   /* protocol version */\n\
    \       unsigned int p:1;         /* padding flag */\n       unsigned int count:5;\
    \     /* varies by packet type */\n       unsigned int pt:8;        /* RTCP packet\
    \ type */\n       u_int16 length;           /* pkt len in words, w/o this word\
    \ */\n   } rtcp_common_t;\n   /*\n    * Big-endian mask for version, padding bit\
    \ and packet type pair\n    */\n   #define RTCP_VALID_MASK (0xc000 | 0x2000 |\
    \ 0xfe)\n   #define RTCP_VALID_VALUE ((RTP_VERSION << 14) | RTCP_SR)\n   /*\n\
    \    * Reception report block\n    */\n   typedef struct {\n       u_int32 ssrc;\
    \             /* data source being reported */\n       unsigned int fraction:8;\
    \  /* fraction lost since last SR/RR */\n       int lost:24;              /* cumul.\
    \ no. pkts lost (signed!) */\n       u_int32 last_seq;         /* extended last\
    \ seq. no. received */\n       u_int32 jitter;           /* interarrival jitter\
    \ */\n       u_int32 lsr;              /* last SR packet from this source */\n\
    \       u_int32 dlsr;             /* delay since last SR packet */\n   } rtcp_rr_t;\n\
    \   /*\n    * SDES item\n    */\n   typedef struct {\n       u_int8 type;    \
    \          /* type of item (rtcp_sdes_type_t) */\n       u_int8 length;      \
    \      /* length of item (in octets) */\n       char data[1];             /* text,\
    \ not null-terminated */\n   } rtcp_sdes_item_t;\n   /*\n    * One RTCP packet\n\
    \    */\n   typedef struct {\n       rtcp_common_t common;     /* common header\
    \ */\n       union {\n           /* sender report (SR) */\n           struct {\n\
    \               u_int32 ssrc;     /* sender generating this report */\n      \
    \         u_int32 ntp_sec;  /* NTP timestamp */\n               u_int32 ntp_frac;\n\
    \               u_int32 rtp_ts;   /* RTP timestamp */\n               u_int32\
    \ psent;    /* packets sent */\n               u_int32 osent;    /* octets sent\
    \ */\n               rtcp_rr_t rr[1];  /* variable-length list */\n          \
    \ } sr;\n           /* reception report (RR) */\n           struct {\n       \
    \        u_int32 ssrc;     /* receiver generating this report */\n           \
    \    rtcp_rr_t rr[1];  /* variable-length list */\n           } rr;\n        \
    \   /* source description (SDES) */\n           struct rtcp_sdes {\n         \
    \      u_int32 src;      /* first SSRC/CSRC */\n               rtcp_sdes_item_t\
    \ item[1]; /* list of SDES items */\n           } sdes;\n           /* BYE */\n\
    \           struct {\n               u_int32 src[1];   /* list of sources */\n\
    \               /* can't express trailing text for reason */\n           } bye;\n\
    \       } r;\n   } rtcp_t;\n   typedef struct rtcp_sdes rtcp_sdes_t;\n   /*\n\
    \    * Per-source state information\n    */\n   typedef struct {\n       u_int16\
    \ max_seq;        /* highest seq. number seen */\n       u_int32 cycles;     \
    \    /* shifted count of seq. number cycles */\n       u_int32 base_seq;     \
    \  /* base seq number */\n       u_int32 bad_seq;        /* last 'bad' seq number\
    \ + 1 */\n       u_int32 probation;      /* sequ. packets till source is valid\
    \ */\n       u_int32 received;       /* packets received */\n       u_int32 expected_prior;\
    \ /* packet expected at last interval */\n       u_int32 received_prior; /* packet\
    \ received at last interval */\n       u_int32 transit;        /* relative trans\
    \ time for prev pkt */\n       u_int32 jitter;         /* estimated jitter */\n\
    \       /* ... */\n   } source;\n"
- title: A.1 RTP Data Header Validity Checks
  contents:
  - "A.1 RTP Data Header Validity Checks\n   An RTP receiver should check the validity\
    \ of the RTP header on\n   incoming packets since they might be encrypted or might\
    \ be from a\n   different application that happens to be misaddressed. Similarly,\
    \ if\n   encryption is enabled, the header validity check is needed to verify\n\
    \   that incoming packets have been correctly decrypted, although a\n   failure\
    \ of the header validity check (e.g., unknown payload type) may\n   not necessarily\
    \ indicate decryption failure.\n   Only weak validity checks are possible on an\
    \ RTP data packet from a\n   source that has not been heard before:\n        o\
    \ RTP version field must equal 2.\n        o The payload type must be known, in\
    \ particular it must not be\n         equal to SR or RR.\n        o If the P bit\
    \ is set, then the last octet of the packet must\n         contain a valid octet\
    \ count, in particular, less than the total\n         packet length minus the\
    \ header size.\n        o The X bit must be zero if the profile does not specify\
    \ that\n         the header extension mechanism may be used. Otherwise, the\n\
    \         extension length field must be less than the total packet size\n   \
    \      minus the fixed header length and padding.\n        o The length of the\
    \ packet must be consistent with CC and\n         payload type (if payloads have\
    \ a known length).\n   The last three checks are somewhat complex and not always\
    \ possible,\n   leaving only the first two which total just a few bits. If the\
    \ SSRC\n   identifier in the packet is one that has been received before, then\n\
    \   the packet is probably valid and checking if the sequence number is\n   in\
    \ the expected range provides further validation. If the SSRC\n   identifier has\
    \ not been seen before, then data packets carrying that\n   identifier may be\
    \ considered invalid until a small number of them\n   arrive with consecutive\
    \ sequence numbers.\n   The routine update_seq shown below ensures that a source\
    \ is declared\n   valid only after MIN_SEQUENTIAL packets have been received in\n\
    \   sequence. It also validates the sequence number seq of a newly\n   received\
    \ packet and updates the sequence state for the packet's\n   source in the structure\
    \ to which s points.\n   When a new source is heard for the first time, that is,\
    \ its SSRC\n   identifier is not in the table (see Section 8.2), and the per-source\n\
    \   state is allocated for it, s->probation should be set to the number\n   of\
    \ sequential packets required before declaring a source valid\n   (parameter MIN_SEQUENTIAL\
    \ ) and s->max_seq initialized to seq-1 s-\n   >probation marks the source as\
    \ not yet valid so the state may be\n   discarded after a short timeout rather\
    \ than a long one, as discussed\n   in Section 6.2.1.\n   After a source is considered\
    \ valid, the sequence number is considered\n   valid if it is no more than MAX_DROPOUT\
    \ ahead of s->max_seq nor more\n   than MAX_MISORDER behind. If the new sequence\
    \ number is ahead of\n   max_seq modulo the RTP sequence number range (16 bits),\
    \ but is\n   smaller than max_seq , it has wrapped around and the (shifted) count\n\
    \   of sequence number cycles is incremented. A value of one is returned\n   to\
    \ indicate a valid sequence number.\n   Otherwise, the value zero is returned\
    \ to indicate that the validation\n   failed, and the bad sequence number is stored.\
    \ If the next packet\n   received carries the next higher sequence number, it\
    \ is considered\n   the valid start of a new packet sequence presumably caused\
    \ by an\n   extended dropout or a source restart. Since multiple complete\n  \
    \ sequence number cycles may have been missed, the packet loss\n   statistics\
    \ are reset.\n   Typical values for the parameters are shown, based on a maximum\n\
    \   misordering time of 2 seconds at 50 packets/second and a maximum\n   dropout\
    \ of 1 minute. The dropout parameter MAX_DROPOUT should be a\n   small fraction\
    \ of the 16-bit sequence number space to give a\n   reasonable probability that\
    \ new sequence numbers after a restart will\n   not fall in the acceptable range\
    \ for sequence numbers from before the\n   restart.\n   void init_seq(source *s,\
    \ u_int16 seq)\n   {\n       s->base_seq = seq - 1;\n       s->max_seq = seq;\n\
    \       s->bad_seq = RTP_SEQ_MOD + 1;\n       s->cycles = 0;\n       s->received\
    \ = 0;\n       s->received_prior = 0;\n       s->expected_prior = 0;\n       /*\
    \ other initialization */\n   }\n   int update_seq(source *s, u_int16 seq)\n \
    \  {\n       u_int16 udelta = seq - s->max_seq;\n       const int MAX_DROPOUT\
    \ = 3000;\n       const int MAX_MISORDER = 100;\n       const int MIN_SEQUENTIAL\
    \ = 2;\n       /*\n        * Source is not valid until MIN_SEQUENTIAL packets\
    \ with\n        * sequential sequence numbers have been received.\n        */\n\
    \       if (s->probation) {\n           /* packet is in sequence */\n        \
    \   if (seq == s->max_seq + 1) {\n               s->probation--;\n           \
    \    s->max_seq = seq;\n               if (s->probation == 0) {\n            \
    \       init_seq(s, seq);\n                   s->received++;\n               \
    \    return 1;\n               }\n           } else {\n               s->probation\
    \ = MIN_SEQUENTIAL - 1;\n               s->max_seq = seq;\n           }\n    \
    \       return 0;\n       } else if (udelta < MAX_DROPOUT) {\n           /* in\
    \ order, with permissible gap */\n           if (seq < s->max_seq) {\n       \
    \        /*\n                * Sequence number wrapped - count another 64K cycle.\n\
    \                */\n               s->cycles += RTP_SEQ_MOD;\n           }\n\
    \           s->max_seq = seq;\n       } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER)\
    \ {\n           /* the sequence number made a very large jump */\n           if\
    \ (seq == s->bad_seq) {\n               /*\n                * Two sequential packets\
    \ -- assume that the other side\n                * restarted without telling us\
    \ so just re-sync\n                * (i.e., pretend this was the first packet).\n\
    \                */\n               init_seq(s, seq);\n           }\n        \
    \   else {\n               s->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);\n       \
    \        return 0;\n           }\n       } else {\n           /* duplicate or\
    \ reordered packet */\n       }\n       s->received++;\n       return 1;\n   }\n\
    \   The validity check can be made stronger requiring more than two\n   packets\
    \ in sequence.  The disadvantages are that a larger number of\n   initial packets\
    \ will be discarded and that high packet loss rates\n   could prevent validation.\
    \ However, because the RTCP header validation\n   is relatively strong, if an\
    \ RTCP packet is received from a source\n   before the data packets, the count\
    \ could be adjusted so that only two\n   packets are required in sequence.  If\
    \ initial data loss for a few\n   seconds can be tolerated, an application could\
    \ choose to discard all\n   data packets from a source until a valid RTCP packet\
    \ has been\n   received from that source.\n   Depending on the application and\
    \ encoding, algorithms may exploit\n   additional knowledge about the payload\
    \ format for further validation.\n   For payload types where the timestamp increment\
    \ is the same for all\n   packets, the timestamp values can be predicted from\
    \ the previous\n   packet received from the same source using the sequence number\n\
    \   difference (assuming no change in payload type).\n   A strong \"fast-path\"\
    \ check is possible since with high probability\n   the first four octets in the\
    \ header of a newly received RTP data\n   packet will be just the same as that\
    \ of the previous packet from the\n   same SSRC except that the sequence number\
    \ will have increased by one.\n   Similarly, a single-entry cache may be used\
    \ for faster SSRC lookups\n   in applications where data is typically received\
    \ from one source at a\n   time.\n"
- title: A.2 RTCP Header Validity Checks
  contents:
  - "A.2 RTCP Header Validity Checks\n   The following checks can be applied to RTCP\
    \ packets.\n        o RTP version field must equal 2.\n        o The payload type\
    \ field of the first RTCP packet in a compound\n         packet must be equal\
    \ to SR or RR.\n        o The padding bit (P) should be zero for the first packet\
    \ of a\n         compound RTCP packet because only the last should possibly need\n\
    \         padding.\n        o The length fields of the individual RTCP packets\
    \ must total to\n         the overall length of the compound RTCP packet as received.\n\
    \         This is a fairly strong check.\n   The code fragment below performs\
    \ all of these checks. The packet type\n   is not checked for subsequent packets\
    \ since unknown packet types may\n   be present and should be ignored.\n     \
    \  u_int32 len;        /* length of compound RTCP packet in words */\n       rtcp_t\
    \ *r;          /* RTCP header */\n       rtcp_t *end;        /* end of compound\
    \ RTCP packet */\n       if ((*(u_int16 *)r & RTCP_VALID_MASK) != RTCP_VALID_VALUE)\
    \ {\n           /* something wrong with packet format */\n       }\n       end\
    \ = (rtcp_t *)((u_int32 *)r + len);\n       do r = (rtcp_t *)((u_int32 *)r + r->common.length\
    \ + 1);\n       while (r < end && r->common.version == 2);\n       if (r != end)\
    \ {\n           /* something wrong with packet format */\n       }\n"
- title: A.3 Determining the Number of RTP Packets Expected and Lost
  contents:
  - "A.3 Determining the Number of RTP Packets Expected and Lost\n   In order to compute\
    \ packet loss rates, the number of packets expected\n   and actually received\
    \ from each source needs to be known, using per-\n   source state information\
    \ defined in struct source referenced via\n   pointer s in the code below. The\
    \ number of packets received is simply\n   the count of packets as they arrive,\
    \ including any late or duplicate\n   packets. The number of packets expected\
    \ can be computed by the\n   receiver as the difference between the highest sequence\
    \ number\n   received ( s->max_seq ) and the first sequence number received (\
    \ s-\n   >base_seq ). Since the sequence number is only 16 bits and will wrap\n\
    \   around, it is necessary to extend the highest sequence number with\n   the\
    \ (shifted) count of sequence number wraparounds ( s->cycles ).\n   Both the received\
    \ packet count and the count of cycles are maintained\n   the RTP header validity\
    \ check routine in Appendix A.1.\n       extended_max = s->cycles + s->max_seq;\n\
    \       expected = extended_max - s->base_seq + 1;\n   The number of packets lost\
    \ is defined to be the number of packets\n   expected less the number of packets\
    \ actually received:\n       lost = expected - s->received;\n   Since this number\
    \ is carried in 24 bits, it should be clamped at\n   0xffffff rather than wrap\
    \ around to zero.\n   The fraction of packets lost during the last reporting interval\n\
    \   (since the previous SR or RR packet was sent) is calculated from\n   differences\
    \ in the expected and received packet counts across the\n   interval, where expected_prior\
    \ and received_prior are the values\n   saved when the previous reception report\
    \ was generated:\n       expected_interval = expected - s->expected_prior;\n \
    \      s->expected_prior = expected;\n       received_interval = s->received -\
    \ s->received_prior;\n       s->received_prior = s->received;\n       lost_interval\
    \ = expected_interval - received_interval;\n       if (expected_interval == 0\
    \ || lost_interval <= 0) fraction = 0;\n       else fraction = (lost_interval\
    \ << 8) / expected_interval;\n   The resulting fraction is an 8-bit fixed point\
    \ number with the binary\n   point at the left edge.\n"
- title: A.4 Generating SDES RTCP Packets
  contents:
  - "A.4 Generating SDES RTCP Packets\n   This function builds one SDES chunk into\
    \ buffer b composed of argc\n   items supplied in arrays type , value and length\
    \ b\n   char *rtp_write_sdes(char *b, u_int32 src, int argc,\n               \
    \         rtcp_sdes_type_t type[], char *value[],\n                        int\
    \ length[])\n   {\n       rtcp_sdes_t *s = (rtcp_sdes_t *)b;\n       rtcp_sdes_item_t\
    \ *rsp;\n       int i;\n       int len;\n       int pad;\n       /* SSRC header\
    \ */\n       s->src = src;\n       rsp = &s->item[0];\n       /* SDES items */\n\
    \       for (i = 0; i < argc; i++) {\n           rsp->type = type[i];\n      \
    \     len = length[i];\n           if (len > RTP_MAX_SDES) {\n               /*\
    \ invalid length, may want to take other action */\n               len = RTP_MAX_SDES;\n\
    \           }\n           rsp->length = len;\n           memcpy(rsp->data, value[i],\
    \ len);\n           rsp = (rtcp_sdes_item_t *)&rsp->data[len];\n       }\n   \
    \    /* terminate with end marker and pad to next 4-octet boundary */\n      \
    \ len = ((char *) rsp) - b;\n       pad = 4 - (len & 0x3);\n       b = (char *)\
    \ rsp;\n       while (pad--) *b++ = RTCP_SDES_END;\n       return b;\n   }\n"
- title: A.5 Parsing RTCP SDES Packets
  contents:
  - "A.5 Parsing RTCP SDES Packets\n   This function parses an SDES packet, calling\
    \ functions find_member()\n   to find a pointer to the information for a session\
    \ member given the\n   SSRC identifier and member_sdes() to store the new SDES\
    \ information\n   for that member. This function expects a pointer to the header\
    \ of the\n   RTCP packet.\n   void rtp_read_sdes(rtcp_t *r)\n   {\n       int\
    \ count = r->common.count;\n       rtcp_sdes_t *sd = &r->r.sdes;\n       rtcp_sdes_item_t\
    \ *rsp, *rspn;\n       rtcp_sdes_item_t *end = (rtcp_sdes_item_t *)\n        \
    \                       ((u_int32 *)r + r->common.length + 1);\n       source\
    \ *s;\n       while (--count >= 0) {\n           rsp = &sd->item[0];\n       \
    \    if (rsp >= end) break;\n           s = find_member(sd->src);\n          \
    \ for (; rsp->type; rsp = rspn ) {\n               rspn = (rtcp_sdes_item_t *)((char*)rsp+rsp->length+2);\n\
    \               if (rspn >= end) {\n                   rsp = rspn;\n         \
    \          break;\n               }\n               member_sdes(s, rsp->type,\
    \ rsp->data, rsp->length);\n           }\n           sd = (rtcp_sdes_t *)\n  \
    \              ((u_int32 *)sd + (((char *)rsp - (char *)sd) >> 2)+1);\n      \
    \ }\n       if (count >= 0) {\n           /* invalid packet format */\n      \
    \ }\n   }\n"
- title: A.6 Generating a Random 32-bit Identifier
  contents:
  - "A.6 Generating a Random 32-bit Identifier\n   The following subroutine generates\
    \ a random 32-bit identifier using\n   the MD5 routines published in RFC 1321\
    \ [23]. The system routines may\n   not be present on all operating systems, but\
    \ they should serve as\n   hints as to what kinds of information may be used.\
    \ Other system calls\n   that may be appropriate include\n        o getdomainname()\
    \ ,\n        o getwd() , or\n        o getrusage()\n   \"Live\" video or audio\
    \ samples are also a good source of random\n   numbers, but care must be taken\
    \ to avoid using a turned-off\n   microphone or blinded camera as a source [7].\n\
    \   Use of this or similar routine is suggested to generate the initial\n   seed\
    \ for the random number generator producing the RTCP period (as\n   shown in Appendix\
    \ A.7), to generate the initial values for the\n   sequence number and timestamp,\
    \ and to generate SSRC values.  Since\n   this routine is likely to be CPU-intensive,\
    \ its direct use to\n   generate RTCP periods is inappropriate because predictability\
    \ is not\n   an issue. Note that this routine produces the same result on repeated\n\
    \   calls until the value of the system clock changes unless different\n   values\
    \ are supplied for the type argument.\n   /*\n    * Generate a random 32-bit quantity.\n\
    \    */\n   #include <sys/types.h>   /* u_long */\n   #include <sys/time.h>  \
    \  /* gettimeofday() */\n   #include <unistd.h>      /* get..() */\n   #include\
    \ <stdio.h>       /* printf() */\n   #include <time.h>        /* clock() */\n\
    \   #include <sys/utsname.h> /* uname() */\n   #include \"global.h\"      /* from\
    \ RFC 1321 */\n   #include \"md5.h\"         /* from RFC 1321 */\n   #define MD_CTX\
    \ MD5_CTX\n   #define MDInit MD5Init\n   #define MDUpdate MD5Update\n   #define\
    \ MDFinal MD5Final\n   static u_long md_32(char *string, int length)\n   {\n \
    \      MD_CTX context;\n       union {\n           char   c[16];\n           u_long\
    \ x[4];\n       } digest;\n       u_long r;\n       int i;\n       MDInit (&context);\n\
    \       MDUpdate (&context, string, length);\n       MDFinal ((unsigned char *)&digest,\
    \ &context);\n       r = 0;\n       for (i = 0; i < 3; i++) {\n           r ^=\
    \ digest.x[i];\n       }\n       return r;\n   }                             \
    \  /* md_32 */\n   /*\n    * Return random unsigned 32-bit quantity. Use 'type'\
    \ argument if you\n    * need to generate several different values in close succession.\n\
    \    */\n   u_int32 random32(int type)\n   {\n       struct {\n           int\
    \     type;\n           struct  timeval tv;\n           clock_t cpu;\n       \
    \    pid_t   pid;\n           u_long  hid;\n           uid_t   uid;\n        \
    \   gid_t   gid;\n           struct  utsname name;\n       } s;\n       gettimeofday(&s.tv,\
    \ 0);\n       uname(&s.name);\n       s.type = type;\n       s.cpu  = clock();\n\
    \       s.pid  = getpid();\n       s.hid  = gethostid();\n       s.uid  = getuid();\n\
    \       s.gid  = getgid();\n       return md_32((char *)&s, sizeof(s));\n   }\
    \                               /* random32 */\n"
- title: A.7 Computing the RTCP Transmission Interval
  contents:
  - "A.7 Computing the RTCP Transmission Interval\n   The following function returns\
    \ the time between transmissions of RTCP\n   packets, measured in seconds. It\
    \ should be called after sending one\n   compound RTCP packet to calculate the\
    \ delay until the next should be\n   sent. This function should also be called\
    \ to calculate the delay\n   before sending the first RTCP packet upon startup\
    \ rather than send\n   the packet immediately. This avoids any burst of RTCP packets\
    \ if an\n   application is started at many sites simultaneously, for example as\
    \ a\n   result of a session announcement.\n   The parameters have the following\
    \ meaning:\n   rtcp_bw: The target RTCP bandwidth, i.e., the total bandwidth that\n\
    \        will be used for RTCP packets by all members of this session, in\n  \
    \      octets per second. This should be 5% of the \"session bandwidth\"\n   \
    \     parameter supplied to the application at startup.\n   senders: Number of\
    \ active senders since sending last report, known\n        from construction of\
    \ receiver reports for this RTCP packet.\n        Includes ourselves, if we also\
    \ sent during this interval.\n   members: The estimated number of session members,\
    \ including\n        ourselves. Incremented as we discover new session members\
    \ from\n        the receipt of RTP or RTCP packets, and decremented as session\n\
    \        members leave (via RTCP BYE) or their state is timed out (30\n      \
    \  minutes is recommended). On the first call, this parameter\n        should\
    \ have the value 1.\n   we_sent: Flag that is true if we have sent data during\
    \ the last two\n        RTCP intervals. If the flag is true, the compound RTCP\
    \ packet\n        just sent contained an SR packet.\n   packet_size: The size\
    \ of the compound RTCP packet just sent, in\n        octets, including the network\
    \ encapsulation (e.g., 28 octets for\n        UDP over IP).\n   avg_rtcp_size:\
    \ Pointer to estimator for compound RTCP packet size;\n        initialized and\
    \ updated by this function for the packet just\n        sent, and also updated\
    \ by an identical line of code in the RTCP\n        receive routine for every\
    \ RTCP packet received from other\n        participants in the session.\n   initial:\
    \ Flag that is true for the first call upon startup to\n        calculate the\
    \ time until the first report should be sent.\n   #include <math.h>\n   double\
    \ rtcp_interval(int members,\n                        int senders,\n         \
    \               double rtcp_bw,\n                        int we_sent,\n      \
    \                  int packet_size,\n                        int *avg_rtcp_size,\n\
    \                        int initial)\n   {\n       /*\n        * Minimum time\
    \ between RTCP packets from this site (in seconds).\n        * This time prevents\
    \ the reports from `clumping' when sessions\n        * are small and the law of\
    \ large numbers isn't helping to smooth\n        * out the traffic.  It also keeps\
    \ the report interval from\n        * becoming ridiculously small during transient\
    \ outages like a\n        * network partition.\n        */\n       double const\
    \ RTCP_MIN_TIME = 5.;\n       /*\n        * Fraction of the RTCP bandwidth to\
    \ be shared among active\n        * senders.  (This fraction was chosen so that\
    \ in a typical\n        * session with one or two active senders, the computed\
    \ report\n        * time would be roughly equal to the minimum report time so\
    \ that\n        * we don't unnecessarily slow down receiver reports.) The\n  \
    \      * receiver fraction must be 1 - the sender fraction.\n        */\n    \
    \   double const RTCP_SENDER_BW_FRACTION = 0.25;\n       double const RTCP_RCVR_BW_FRACTION\
    \ = (1-RTCP_SENDER_BW_FRACTION);\n       /*\n        * Gain (smoothing constant)\
    \ for the low-pass filter that\n        * estimates the average RTCP packet size\
    \ (see Cadzow reference).\n        */\n       double const RTCP_SIZE_GAIN = (1./16.);\n\
    \       double t;                   /* interval */\n       double rtcp_min_time\
    \ = RTCP_MIN_TIME;\n       int n;                      /* no. of members for computation\
    \ */\n       /*\n        * Very first call at application start-up uses half the\
    \ min\n        * delay for quicker notification while still allowing some time\n\
    \        * before reporting for randomization and to learn about other\n     \
    \   * sources so the report interval will converge to the correct\n        * interval\
    \ more quickly.  The average RTCP size is initialized\n        * to 128 octets\
    \ which is conservative (it assumes everyone else\n        * is generating SRs\
    \ instead of RRs: 20 IP + 8 UDP + 52 SR + 48\n        * SDES CNAME).\n       \
    \ */\n       if (initial) {\n           rtcp_min_time /= 2;\n           *avg_rtcp_size\
    \ = 128;\n       }\n       /*\n        * If there were active senders, give them\
    \ at least a minimum\n        * share of the RTCP bandwidth.  Otherwise all participants\
    \ share\n        * the RTCP bandwidth equally.\n        */\n       n = members;\n\
    \       if (senders > 0 && senders < members * RTCP_SENDER_BW_FRACTION) {\n  \
    \         if (we_sent) {\n               rtcp_bw *= RTCP_SENDER_BW_FRACTION;\n\
    \               n = senders;\n           } else {\n               rtcp_bw *= RTCP_RCVR_BW_FRACTION;\n\
    \               n -= senders;\n           }\n       }\n       /*\n        * Update\
    \ the average size estimate by the size of the report\n        * packet we just\
    \ sent.\n        */\n       *avg_rtcp_size += (packet_size - *avg_rtcp_size)*RTCP_SIZE_GAIN;\n\
    \       /*\n        * The effective number of sites times the average packet size\
    \ is\n        * the total number of octets sent when each site sends a report.\n\
    \        * Dividing this by the effective bandwidth gives the time\n        *\
    \ interval over which those packets must be sent in order to\n        * meet the\
    \ bandwidth target, with a minimum enforced.  In that\n        * time interval\
    \ we send one report so this time is also our\n        * average time between\
    \ reports.\n        */\n       t = (*avg_rtcp_size) * n / rtcp_bw;\n       if\
    \ (t < rtcp_min_time) t = rtcp_min_time;\n       /*\n        * To avoid traffic\
    \ bursts from unintended synchronization with\n        * other sites, we then\
    \ pick our actual next report interval as a\n        * random number uniformly\
    \ distributed between 0.5*t and 1.5*t.\n        */\n       return t * (drand48()\
    \ + 0.5);\n   }\n"
- title: A.8 Estimating the Interarrival Jitter
  contents:
  - "A.8 Estimating the Interarrival Jitter\n   The code fragments below implement\
    \ the algorithm given in Section\n   6.3.1 for calculating an estimate of the\
    \ statistical variance of the\n   RTP data interarrival time to be inserted in\
    \ the interarrival jitter\n   field of reception reports. The inputs are r->ts\
    \ , the timestamp from\n   the incoming packet, and arrival , the current time\
    \ in the same\n   units. Here s points to state for the source; s->transit holds\
    \ the\n   relative transit time for the previous packet, and s->jitter holds\n\
    \   the estimated jitter. The jitter field of the reception report is\n   measured\
    \ in timestamp units and expressed as an unsigned integer, but\n   the jitter\
    \ estimate is kept in a floating point. As each data packet\n   arrives, the jitter\
    \ estimate is updated:\n       int transit = arrival - r->ts;\n       int d =\
    \ transit - s->transit;\n       s->transit = transit;\n       if (d < 0) d = -d;\n\
    \       s->jitter += (1./16.) * ((double)d - s->jitter);\n   When a reception\
    \ report block (to which rr points) is generated for\n   this member, the current\
    \ jitter estimate is returned:\n       rr->jitter = (u_int32) s->jitter;\n   Alternatively,\
    \ the jitter estimate can be kept as an integer, but\n   scaled to reduce round-off\
    \ error. The calculation is the same except\n   for the last line:\n       s->jitter\
    \ += d - ((s->jitter + 8) >> 4);\n   In this case, the estimate is sampled for\
    \ the reception report as:\n       rr->jitter = s->jitter >> 4;\n"
- title: B.  Security Considerations
  contents:
  - "B.  Security Considerations\n   RTP suffers from the same security liabilities\
    \ as the underlying\n   protocols. For example, an impostor can fake source or\
    \ destination\n   network addresses, or change the header or payload. Within RTCP,\
    \ the\n   CNAME and NAME information may be used to impersonate another\n   participant.\
    \ In addition, RTP may be sent via IP multicast, which\n   provides no direct\
    \ means for a sender to know all the receivers of\n   the data sent and therefore\
    \ no measure of privacy. Rightly or not,\n   users may be more sensitive to privacy\
    \ concerns with audio and video\n   communication than they have been with more\
    \ traditional forms of\n   network communication [24]. Therefore, the use of security\
    \ mechanisms\n   with RTP is important. These mechanisms are discussed in Section\
    \ 9.\n   RTP-level translators or mixers may be used to allow RTP traffic to\n\
    \   reach hosts behind firewalls. Appropriate firewall security\n   principles\
    \ and practices, which are beyond the scope of this\n   document, should be followed\
    \ in the design and installation of these\n   devices and in the admission of\
    \ RTP applications for use behind the\n   firewall.\n"
- title: C. Authors' Addresses
  contents:
  - "C. Authors' Addresses\n   Henning Schulzrinne\n   GMD Fokus\n   Hardenbergplatz\
    \ 2\n   D-10623 Berlin\n   Germany\n   EMail: schulzrinne@fokus.gmd.de\n   Stephen\
    \ L. Casner\n   Precept Software, Inc.\n   21580 Stevens Creek Boulevard, Suite\
    \ 207\n   Cupertino, CA 95014\n   United States\n   EMail: casner@precept.com\n\
    \   Ron Frederick\n   Xerox Palo Alto Research Center\n   3333 Coyote Hill Road\n\
    \   Palo Alto, CA 94304\n   United States\n   EMail: frederic@parc.xerox.com\n\
    \   Van Jacobson\n   MS 46a-1121\n   Lawrence Berkeley National Laboratory\n \
    \  Berkeley, CA 94720\n   United States\n   EMail: van@ee.lbl.gov\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   This memorandum is based on discussions within the IETF Audio/Video\n\
    \   Transport working group chaired by Stephen Casner. The current\n   protocol\
    \ has its origins in the Network Voice Protocol and the Packet\n   Video Protocol\
    \ (Danny Cohen and Randy Cole) and the protocol\n   implemented by the vat application\
    \ (Van Jacobson and Steve McCanne).\n   Christian Huitema provided ideas for the\
    \ random identifier generator.\n"
- title: D.  Bibliography
  contents:
  - "D.  Bibliography\n   [1] D. D. Clark and D. L. Tennenhouse, \"Architectural considerations\n\
    \       for a new generation of protocols,\" in SIGCOMM Symposium on\n       Communications\
    \ Architectures and Protocols , (Philadelphia,\n       Pennsylvania), pp. 200--208,\
    \ IEEE, Sept. 1990.  Computer\n       Communications Review, Vol. 20(4), Sept.\
    \ 1990.\n   [2] H. Schulzrinne, \"Issues in designing a transport protocol for\n\
    \       audio and video conferences and other multiparticipant real-time\n   \
    \    applications\", Work in Progress.\n   [3] D. E. Comer, Internetworking with\
    \ TCP/IP , vol. 1.  Englewood\n       Cliffs, New Jersey: Prentice Hall, 1991.\n\
    \   [4] Postel, J., \"Internet Protocol\", STD 5, RFC 791, USC/Information\n \
    \      Sciences Institute, September 1981.\n   [5] Mills, D., \"Network Time Protocol\
    \ Version 3\", RFC 1305, UDEL,\n       March 1992.\n   [6] Reynolds, J., and J.\
    \ Postel, \"Assigned Numbers\", STD 2, RFC 1700,\n       USC/Information Sciences\
    \ Institute, October 1994.\n   [7] Eastlake, D., Crocker, S., and J. Schiller,\
    \ \"Randomness\n       Recommendations for Security\", RFC 1750, DEC, Cybercash,\
    \ MIT,\n       December 1994.\n   [8] J.-C. Bolot, T. Turletti, and I. Wakeman,\
    \ \"Scalable feedback\n       control for multicast video distribution in the\
    \ internet,\" in\n       SIGCOMM Symposium on Communications Architectures and\
    \ Protocols ,\n       (London, England), pp. 58--67, ACM, Aug. 1994.\n   [9] I.\
    \ Busse, B. Deffner, and H. Schulzrinne, \"Dynamic QoS control of\n       multimedia\
    \ applications based on RTP,\" Computer Communications ,\n       Jan.  1996.\n\
    \  [10] S. Floyd and V. Jacobson, \"The synchronization of periodic\n       routing\
    \ messages,\" in SIGCOMM Symposium on Communications\n       Architectures and\
    \ Protocols (D. P. Sidhu, ed.), (San Francisco,\n       California), pp. 33--44,\
    \ ACM, Sept. 1993.  also in [25].\n  [11] J. A. Cadzow, Foundations of digital\
    \ signal processing and data\n       analysis New York, New York: Macmillan, 1987.\n\
    \  [12] International Standards Organization, \"ISO/IEC DIS 10646-1:1993\n   \
    \    information technology -- universal multiple-octet coded\n       character\
    \ set (UCS) -- part I: Architecture and basic\n       multilingual plane,\" 1993.\n\
    \  [13] The Unicode Consortium, The Unicode Standard New York, New York:\n   \
    \    Addison-Wesley, 1991.\n  [14] Mockapetris, P., \"Domain Names - Concepts\
    \ and Facilities\", STD\n       13, RFC 1034, USC/Information Sciences Institute,\
    \ November 1987.\n  [15] Mockapetris, P., \"Domain Names - Implementation and\n\
    \       Specification\", STD 13, RFC 1035, USC/Information Sciences\n       Institute,\
    \ November 1987.\n  [16] Braden, R., \"Requirements for Internet Hosts - Application\
    \ and\n       Support\", STD 3, RFC 1123, Internet Engineering Task Force,\n \
    \      October 1989.\n  [17] Rekhter, Y., Moskowitz, R., Karrenberg, D., and G.\
    \ de Groot,\n       \"Address Allocation for Private Internets\", RFC 1597, T.J.\
    \ Watson\n       Research Center, IBM Corp., Chrysler Corp., RIPE NCC, March 1994.\n\
    \  [18] Lear, E., Fair, E., Crocker, D., and T. Kessler, \"Network 10\n      \
    \ Considered Harmful (Some Practices Shouldn't be Codified)\", RFC\n       1627,\
    \ Silicon Graphics, Inc., Apple Computer, Inc., Silicon\n       Graphics, Inc.,\
    \ July 1994.\n  [19] Crocker, D., \"Standard for the Format of ARPA Internet Text\n\
    \       Messages\", STD 11, RFC 822, UDEL, August 1982.\n  [20] W. Feller, An\
    \ Introduction to Probability Theory and its\n       Applications, Volume 1 ,\
    \ vol. 1.  New York, New York: John Wiley\n       and Sons, third ed., 1968.\n\
    \  [21] Balenson, D., \"Privacy Enhancement for Internet Electronic Mail:\n  \
    \     Part III: Algorithms, Modes, and Identifiers\", RFC 1423, TIS, IAB\n   \
    \    IRTF PSRG, IETF PEM WG, February 1993.\n  [22] V. L. Voydock and S. T. Kent,\
    \ \"Security mechanisms in high-level\n       network protocols,\" ACM Computing\
    \ Surveys , vol. 15, pp. 135--\n       171, June 1983.\n  [23] Rivest, R., \"\
    The MD5 Message-Digest Algorithm\", RFC 1321, MIT\n       Laboratory for Computer\
    \ Science and RSA Data Security, Inc.,\n       April 1992.\n  [24] S. Stubblebine,\
    \ \"Security services for multimedia conferencing,\"\n       in 16th National\
    \ Computer Security Conference , (Baltimore,\n       Maryland), pp. 391--395,\
    \ Sept. 1993.\n  [25] S. Floyd and V. Jacobson, \"The synchronization of periodic\n\
    \       routing messages,\" IEEE/ACM Transactions on Networking , vol. 2,\n  \
    \     pp.  122-136, April 1994.\n"
