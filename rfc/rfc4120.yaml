- contents:
  - '            The Kerberos Network Authentication Service (V5)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document provides an overview and specification of Version
    5 of\n   the Kerberos protocol, and it obsoletes RFC 1510 to clarify aspects\n
    \  of the protocol and its intended use that require more detailed or\n   clearer
    explanation than was provided in RFC 1510.  This document is\n   intended to provide
    a detailed description of the protocol, suitable\n   for implementation, together
    with descriptions of the appropriate use\n   of protocol messages and fields within
    those messages.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \     1.1. The Kerberos Protocol ......................................6\n      1.2.
    Cross-Realm Operation ......................................8\n      1.3. Choosing
    a Principal with Which to Communicate .............9\n      1.4. Authorization
    .............................................10\n      1.5. Extending Kerberos
    without Breaking Interoperability ......11\n           1.5.1. Compatibility with
    RFC 1510 ........................11\n           1.5.2. Sending Extensible Messages
    ........................12\n      1.6. Environmental Assumptions .................................12\n
    \     1.7. Glossary of Terms .........................................13\n   2.
    Ticket Flag Uses and Requests ..................................16\n      2.1.
    Initial, Pre-authenticated, and\n           Hardware-Authenticated Tickets ............................17\n
    \     2.2. Invalid Tickets ...........................................17\n      2.3.
    Renewable Tickets .........................................17\n      2.4. Postdated
    Tickets .........................................18\n      2.5. Proxiable and
    Proxy Tickets ...............................19\n      2.6. Forwardable Tickets
    .......................................19\n      2.7. Transited Policy Checking
    .................................20\n      2.8. OK as Delegate ............................................21\n
    \     2.9. Other KDC Options .........................................21\n           2.9.1.
    Renewable-OK .......................................21\n           2.9.2. ENC-TKT-IN-SKEY
    ....................................22\n           2.9.3. Passwordless Hardware
    Authentication ...............22\n   3. Message Exchanges ..............................................22\n
    \     3.1. The Authentication Service Exchange .......................22\n           3.1.1.
    Generation of KRB_AS_REQ Message ...................24\n           3.1.2. Receipt
    of KRB_AS_REQ Message ......................24\n           3.1.3. Generation of
    KRB_AS_REP Message ...................24\n           3.1.4. Generation of KRB_ERROR
    Message ....................27\n           3.1.5. Receipt of KRB_AS_REP Message
    ......................27\n           3.1.6. Receipt of KRB_ERROR Message .......................28\n
    \     3.2. The Client/Server Authentication Exchange .................29\n           3.2.1.
    The KRB_AP_REQ Message .............................29\n           3.2.2. Generation
    of a KRB_AP_REQ Message .................29\n           3.2.3. Receipt of KRB_AP_REQ
    Message ......................30\n           3.2.4. Generation of a KRB_AP_REP
    Message .................33\n           3.2.5. Receipt of KRB_AP_REP Message ......................33\n
    \          3.2.6. Using the Encryption Key ...........................33\n      3.3.
    The Ticket-Granting Service (TGS) Exchange ................34\n           3.3.1.
    Generation of KRB_TGS_REQ Message ..................35\n           3.3.2. Receipt
    of KRB_TGS_REQ Message .....................37\n           3.3.3. Generation of
    KRB_TGS_REP Message ..................38\n           3.3.4. Receipt of KRB_TGS_REP
    Message .....................42\n      3.4. The KRB_SAFE Exchange .....................................42\n
    \          3.4.1. Generation of a KRB_SAFE Message ...................42\n           3.4.2.
    Receipt of KRB_SAFE Message ........................43\n      3.5. The KRB_PRIV
    Exchange .....................................44\n           3.5.1. Generation
    of a KRB_PRIV Message ...................44\n           3.5.2. Receipt of KRB_PRIV
    Message ........................44\n      3.6. The KRB_CRED Exchange .....................................45\n
    \          3.6.1. Generation of a KRB_CRED Message ...................45\n           3.6.2.
    Receipt of KRB_CRED Message ........................46\n      3.7. User-to-User
    Authentication Exchanges .....................47\n   4. Encryption and Checksum
    Specifications .........................48\n   5. Message Specifications .........................................50\n
    \     5.1. Specific Compatibility Notes on ASN.1 .....................51\n           5.1.1.
    ASN.1 Distinguished Encoding Rules .................51\n           5.1.2. Optional
    Integer Fields ............................52\n           5.1.3. Empty SEQUENCE
    OF Types ............................52\n           5.1.4. Unrecognized Tag Numbers
    ...........................52\n           5.1.5. Tag Numbers Greater Than 30 ........................53\n
    \     5.2. Basic Kerberos Types ......................................53\n           5.2.1.
    KerberosString .....................................53\n           5.2.2. Realm
    and PrincipalName ............................55\n           5.2.3. KerberosTime
    .......................................55\n           5.2.4. Constrained Integer
    Types ..........................55\n           5.2.5. HostAddress and HostAddresses
    ......................56\n           5.2.6. AuthorizationData ..................................57\n
    \          5.2.7. PA-DATA ............................................60\n           5.2.8.
    KerberosFlags ......................................64\n           5.2.9. Cryptosystem-Related
    Types .........................65\n      5.3. Tickets ...................................................66\n
    \     5.4. Specifications for the AS and TGS Exchanges ...............73\n           5.4.1.
    KRB_KDC_REQ Definition .............................73\n           5.4.2. KRB_KDC_REP
    Definition .............................81\n      5.5. Client/Server (CS) Message
    Specifications .................84\n           5.5.1. KRB_AP_REQ Definition ..............................84\n
    \          5.5.2. KRB_AP_REP Definition ..............................88\n           5.5.3.
    Error Message Reply ................................89\n      5.6. KRB_SAFE Message
    Specification ............................89\n           5.6.1. KRB_SAFE definition
    ................................89\n      5.7. KRB_PRIV Message Specification
    ............................91\n           5.7.1. KRB_PRIV Definition ................................91\n
    \     5.8. KRB_CRED Message Specification ............................92\n           5.8.1.
    KRB_CRED Definition ................................92\n      5.9. Error Message
    Specification ...............................94\n           5.9.1. KRB_ERROR Definition
    ...............................94\n      5.10. Application Tag Numbers ..................................96\n
    \  6. Naming Constraints .............................................97\n      6.1.
    Realm Names ...............................................97\n      6.2. Principal
    Names .......................................... 99\n           6.2.1. Name of
    Server Principals .........................100\n   7. Constants and Other Defined
    Values ............................101\n      7.1. Host Address Types .......................................101\n
    \     7.2. KDC Messaging: IP Transports .............................102\n           7.2.1.
    UDP/IP transport ..................................102\n           7.2.2. TCP/IP
    Transport ..................................103\n           7.2.3. KDC Discovery
    on IP Networks ......................104\n      7.3. Name of the TGS ..........................................105\n
    \     7.4. OID Arc for KerberosV5 ...................................106\n      7.5.
    Protocol Constants and Associated Values .................106\n           7.5.1.
    Key Usage Numbers .................................106\n           7.5.2. PreAuthentication
    Data Types ......................108\n           7.5.3. Address Types .....................................109\n
    \          7.5.4. Authorization Data Types ..........................109\n           7.5.5.
    Transited Encoding Types ..........................109\n           7.5.6. Protocol
    Version Number ...........................109\n           7.5.7. Kerberos Message
    Types ............................110\n           7.5.8. Name Types ........................................110\n
    \          7.5.9. Error Codes .......................................110\n   8.
    Interoperability Requirements .................................113\n      8.1.
    Specification 2 ..........................................113\n      8.2. Recommended
    KDC Values ...................................116\n   9. IANA Considerations ...........................................116\n
    \  10. Security Considerations ......................................117\n   11.
    Acknowledgements .............................................121\n   A. ASN.1
    Module ..................................................123\n   B. Changes since
    RFC 1510 ........................................131\n   Normative References
    .............................................134\n   Informative References ...........................................135\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes the concepts and model upon which
    the\n   Kerberos network authentication system is based.  It also specifies\n
    \  Version 5 of the Kerberos protocol.  The motivations, goals,\n   assumptions,
    and rationale behind most design decisions are treated\n   cursorily; they are
    more fully described in a paper available in IEEE\n   communications [NT94] and
    earlier in the Kerberos portion of the\n   Athena Technical Plan [MNSS87].\n   This
    document is not intended to describe Kerberos to the end user,\n   system administrator,
    or application developer.  Higher-level papers\n   describing Version 5 of the
    Kerberos system [NT94] and documenting\n   version 4 [SNS88] are available elsewhere.\n
    \  The Kerberos model is based in part on Needham and Schroeder's\n   trusted
    third-party authentication protocol [NS78] and on\n   modifications suggested
    by Denning and Sacco [DS81].  The original\n   design and implementation of Kerberos
    Versions 1 through 4 was the\n   work of two former Project Athena staff members,
    Steve Miller of\n   Digital Equipment Corporation and Clifford Neuman (now at
    the\n   Information Sciences Institute of the University of Southern\n   California),
    along with Jerome Saltzer, Technical Director of Project\n   Athena, and Jeffrey
    Schiller, MIT Campus Network Manager.  Many other\n   members of Project Athena
    have also contributed to the work on\n   Kerberos.\n   Version 5 of the Kerberos
    protocol (described in this document) has\n   evolved because of new requirements
    and desires for features not\n   available in Version 4.  The design of Version
    5 was led by Clifford\n   Neuman and John Kohl with much input from the community.
    \ The\n   development of the MIT reference implementation was led at MIT by\n
    \  John Kohl and Theodore Ts'o, with help and contributed code from many\n   others.
    \ Since RFC 1510 was issued, many individuals have proposed\n   extensions and
    revisions to the protocol.  This document reflects\n   some of these proposals.
    \ Where such changes involved significant\n   effort, the document cites the contribution
    of the proposer.\n   Reference implementations of both Version 4 and Version 5
    of Kerberos\n   are publicly available, and commercial implementations have been\n
    \  developed and are widely used.  Details on the differences between\n   Versions
    4 and 5 can be found in [KNT94].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
  title: 1.  Introduction
- contents:
  - "1.1.  The Kerberos Protocol\n   Kerberos provides a means of verifying the identities
    of principals,\n   (e.g., a workstation user or a network server) on an open\n
    \  (unprotected) network.  This is accomplished without relying on\n   assertions
    by the host operating system, without basing trust on host\n   addresses, without
    requiring physical security of all the hosts on\n   the network, and under the
    assumption that packets traveling along\n   the network can be read, modified,
    and inserted at will.  Kerberos\n   performs authentication under these conditions
    as a trusted third-\n   party authentication service by using conventional (shared
    secret\n   key) cryptography.  Extensions to Kerberos (outside the scope of this\n
    \  document) can provide for the use of public key cryptography during\n   certain
    phases of the authentication protocol.  Such extensions\n   support Kerberos authentication
    for users registered with public key\n   certification authorities and provide
    certain benefits of public key\n   cryptography in situations where they are needed.\n
    \  The basic Kerberos authentication process proceeds as follows: A\n   client
    sends a request to the authentication server (AS) for\n   \"credentials\" for
    a given server.  The AS responds with these\n   credentials, encrypted in the
    client's key.  The credentials consist\n   of a \"ticket\" for the server and
    a temporary encryption key (often\n   called a \"session key\").  The client transmits
    the ticket (which\n   contains the client's identity and a copy of the session
    key, all\n   encrypted in the server's key) to the server.  The session key (now\n
    \  shared by the client and server) is used to authenticate the client\n   and
    may optionally be used to authenticate the server.  It may also\n   be used to
    encrypt further communication between the two parties or\n   to exchange a separate
    sub-session key to be used to encrypt further\n   communication.  Note that many
    applications use Kerberos' functions\n   only upon the initiation of a stream-based
    network connection.\n   Unless an application performs encryption or integrity
    protection for\n   the data stream, the identity verification applies only to
    the\n   initiation of the connection, and it does not guarantee that\n   subsequent
    messages on the connection originate from the same\n   principal.\n   Implementation
    of the basic protocol consists of one or more\n   authentication servers running
    on physically secure hosts.  The\n   authentication servers maintain a database
    of principals (i.e., users\n   and servers) and their secret keys.  Code libraries
    provide\n   encryption and implement the Kerberos protocol.  In order to add\n
    \  authentication to its transactions, a typical network application\n   adds
    calls to the Kerberos library directly or through the Generic\n   Security Services
    Application Programming Interface (GSS-API)\n   described in a separate document
    [RFC4121].  These calls result in\n   the transmission of the messages necessary
    to achieve authentication.\n   The Kerberos protocol consists of several sub-protocols
    (or\n   exchanges).  There are two basic methods by which a client can ask a\n
    \  Kerberos server for credentials.  In the first approach, the client\n   sends
    a cleartext request for a ticket for the desired server to the\n   AS.  The reply
    is sent encrypted in the client's secret key.  Usually\n   this request is for
    a ticket-granting ticket (TGT), which can later\n   be used with the ticket-granting
    server (TGS).  In the second method,\n   the client sends a request to the TGS.
    \ The client uses the TGT to\n   authenticate itself to the TGS in the same manner
    as if it were\n   contacting any other application server that requires Kerberos\n
    \  authentication.  The reply is encrypted in the session key from the\n   TGT.
    \ Though the protocol specification describes the AS and the TGS\n   as separate
    servers, in practice they are implemented as different\n   protocol entry points
    within a single Kerberos server.\n   Once obtained, credentials may be used to
    verify the identity of the\n   principals in a transaction, to ensure the integrity
    of messages\n   exchanged between them, or to preserve privacy of the messages.
    \ The\n   application is free to choose whatever protection may be necessary.\n
    \  To verify the identities of the principals in a transaction, the\n   client
    transmits the ticket to the application server.  Because the\n   ticket is sent
    \"in the clear\" (parts of it are encrypted, but this\n   encryption doesn't thwart
    replay) and might be intercepted and reused\n   by an attacker, additional information
    is sent to prove that the\n   message originated with the principal to whom the
    ticket was issued.\n   This information (called the authenticator) is encrypted
    in the\n   session key and includes a timestamp.  The timestamp proves that the\n
    \  message was recently generated and is not a replay.  Encrypting the\n   authenticator
    in the session key proves that it was generated by a\n   party possessing the
    session key.  Since no one except the requesting\n   principal and the server
    know the session key (it is never sent over\n   the network in the clear), this
    guarantees the identity of the\n   client.\n   The integrity of the messages exchanged
    between principals can also\n   be guaranteed by using the session key (passed
    in the ticket and\n   contained in the credentials).  This approach provides detection
    of\n   both replay attacks and message stream modification attacks.  It is\n   accomplished
    by generating and transmitting a collision-proof\n   checksum (elsewhere called
    a hash or digest function) of the client's\n   message, keyed with the session
    key.  Privacy and integrity of the\n   messages exchanged between principals can
    be secured by encrypting\n   the data to be passed by using the session key contained
    in the\n   ticket or the sub-session key found in the authenticator.\n   The authentication
    exchanges mentioned above require read-only access\n   to the Kerberos database.
    \ Sometimes, however, the entries in the\n   database must be modified, such as
    when adding new principals or\n   changing a principal's key.  This is done using
    a protocol between a\n   client and a third Kerberos server, the Kerberos Administration\n
    \  Server (KADM).  There is also a protocol for maintaining multiple\n   copies
    of the Kerberos database.  Neither of these protocols are\n   described in this
    document.\n"
  title: 1.1.  The Kerberos Protocol
- contents:
  - "1.2.  Cross-Realm Operation\n   The Kerberos protocol is designed to operate
    across organizational\n   boundaries.  A client in one organization can be authenticated
    to a\n   server in another.  Each organization wishing to run a Kerberos\n   server
    establishes its own \"realm\".  The name of the realm in which a\n   client is
    registered is part of the client's name and can be used by\n   the end-service
    to decide whether to honor a request.\n   By establishing \"inter-realm\" keys,
    the administrators of two realms\n   can allow a client authenticated in the local
    realm to prove its\n   identity to servers in other realms.  The exchange of inter-realm\n
    \  keys (a separate key may be used for each direction) registers the\n   ticket-granting
    service of each realm as a principal in the other\n   realm.  A client is then
    able to obtain a TGT for the remote realm's\n   ticket-granting service from its
    local realm.  When that TGT is used,\n   the remote ticket-granting service uses
    the inter-realm key (which\n   usually differs from its own normal TGS key) to
    decrypt the TGT; thus\n   it is certain that the ticket was issued by the client's
    own TGS.\n   Tickets issued by the remote ticket-granting service will indicate
    to\n   the end-service that the client was authenticated from another realm.\n
    \  Without cross-realm operation, and with appropriate permission, the\n   client
    can arrange registration of a separately-named principal in a\n   remote realm
    and engage in normal exchanges with that realm's\n   services.  However, for even
    small numbers of clients this becomes\n   cumbersome, and more automatic methods
    as described here are\n   necessary.\n   A realm is said to communicate with another
    realm if the two realms\n   share an inter-realm key, or if the local realm shares
    an inter-realm\n   key with an intermediate realm that communicates with the remote\n
    \  realm.  An authentication path is the sequence of intermediate realms\n   that
    are transited in communicating from one realm to another.\n   Realms may be organized
    hierarchically.  Each realm shares a key with\n   its parent and a different key
    with each child.  If an inter-realm\n   key is not directly shared by two realms,
    the hierarchical\n   organization allows an authentication path to be easily constructed.\n
    \  If a hierarchical organization is not used, it may be necessary to\n   consult
    a database in order to construct an authentication path\n   between realms.\n
    \  Although realms are typically hierarchical, intermediate realms may\n   be
    bypassed to achieve cross-realm authentication through alternate\n   authentication
    paths.  (These might be established to make\n   communication between two realms
    more efficient.)  It is important\n   for the end-service to know which realms
    were transited when deciding\n   how much faith to place in the authentication
    process.  To facilitate\n   this decision, a field in each ticket contains the
    names of the\n   realms that were involved in authenticating the client.\n   The
    application server is ultimately responsible for accepting or\n   rejecting authentication
    and SHOULD check the transited field.  The\n   application server may choose to
    rely on the Key Distribution Center\n   (KDC) for the application server's realm
    to check the transited\n   field.  The application server's KDC will set the\n
    \  TRANSITED-POLICY-CHECKED flag in this case.  The KDCs for\n   intermediate
    realms may also check the transited field as they issue\n   TGTs for other realms,
    but they are encouraged not to do so.  A\n   client may request that the KDCs
    not check the transited field by\n   setting the DISABLE-TRANSITED-CHECK flag.
    \ KDCs SHOULD honor this\n   flag.\n"
  title: 1.2.  Cross-Realm Operation
- contents:
  - "1.3.  Choosing a Principal with Which to Communicate\n   The Kerberos protocol
    provides the means for verifying (subject to\n   the assumptions in Section 1.6)
    that the entity with which one\n   communicates is the same entity that was registered
    with the KDC\n   using the claimed identity (principal name).  It is still necessary\n
    \  to determine whether that identity corresponds to the entity with\n   which
    one intends to communicate.\n   When appropriate data has been exchanged in advance,
    the application\n   may perform this determination syntactically based on the
    application\n   protocol specification, information provided by the user, and\n
    \  configuration files.  For example, the server principal name\n   (including
    realm) for a telnet server might be derived from the\n   user-specified host name
    (from the telnet command line), the \"host/\"\n   prefix specified in the application
    protocol specification, and a\n   mapping to a Kerberos realm derived syntactically
    from the domain\n   part of the specified hostname and information from the local\n
    \  Kerberos realms database.\n   One can also rely on trusted third parties to
    make this\n   determination, but only when the data obtained from the third party\n
    \  is suitably integrity-protected while resident on the third-party\n   server
    and when transmitted.  Thus, for example, one should not rely\n   on an unprotected
    DNS record to map a host alias to the primary name\n   of a server, accepting
    the primary name as the party that one intends\n   to contact, since an attacker
    can modify the mapping and impersonate\n   the party.\n   Implementations of Kerberos
    and protocols based on Kerberos MUST NOT\n   use insecure DNS queries to canonicalize
    the hostname components of\n   the service principal names (i.e., they MUST NOT
    use insecure DNS\n   queries to map one name to another to determine the host
    part of the\n   principal name with which one is to communicate).  In an environment\n
    \  without secure name service, application authors MAY append a\n   statically
    configured domain name to unqualified hostnames before\n   passing the name to
    the security mechanisms, but they should do no\n   more than that.  Secure name
    service facilities, if available, might\n   be trusted for hostname canonicalization,
    but such canonicalization\n   by the client SHOULD NOT be required by KDC implementations.\n
    \  Implementation note: Many current implementations do some degree of\n   canonicalization
    of the provided service name, often using DNS even\n   though it creates security
    problems.  However, there is no\n   consistency among implementations as to whether
    the service name is\n   case folded to lowercase or whether reverse resolution
    is used.  To\n   maximize interoperability and security, applications SHOULD provide\n
    \  security mechanisms with names that result from folding the user-\n   entered
    name to lowercase without performing any other modifications\n   or canonicalization.\n"
  title: 1.3.  Choosing a Principal with Which to Communicate
- contents:
  - "1.4.  Authorization\n   As an authentication service, Kerberos provides a means
    of verifying\n   the identity of principals on a network.  Authentication is usually\n
    \  useful primarily as a first step in the process of authorization,\n   determining
    whether a client may use a service, which objects the\n   client is allowed to
    access, and the type of access allowed for each.\n   Kerberos does not, by itself,
    provide authorization.  Possession of a\n   client ticket for a service provides
    only for authentication of the\n   client to that service, and in the absence
    of a separate\n   authorization procedure, an application should not consider
    it to\n   authorize the use of that service.\n   Separate authorization methods
    MAY be implemented as application-\n   specific access control functions and may
    utilize files on the\n   application server, on separately issued authorization
    credentials\n   such as those based on proxies [Neu93], or on other authorization\n
    \  services.  Separately authenticated authorization credentials MAY be\n   embedded
    in a ticket's authorization data when encapsulated by the\n   KDC-issued authorization
    data element.\n   Applications should not accept the mere issuance of a service
    ticket\n   by the Kerberos server (even by a modified Kerberos server) as\n   granting
    authority to use the service, since such applications may\n   become vulnerable
    to the bypass of this authorization check in an\n   environment where other options
    for application authentication are\n   provided, or if they interoperate with
    other KDCs.\n"
  title: 1.4.  Authorization
- contents:
  - "1.5.  Extending Kerberos without Breaking Interoperability\n   As the deployed
    base of Kerberos implementations grows, extending\n   Kerberos becomes more important.
    \ Unfortunately, some extensions to\n   the existing Kerberos protocol create
    interoperability issues because\n   of uncertainty regarding the treatment of
    certain extensibility\n   options by some implementations.  This section includes
    guidelines\n   that will enable future implementations to maintain interoperability.\n
    \  Kerberos provides a general mechanism for protocol extensibility.\n   Some
    protocol messages contain typed holes -- sub-messages that\n   contain an octet-string
    along with an integer that defines how to\n   interpret the octet-string.  The
    integer types are registered\n   centrally, but they can be used both for vendor
    extensions and for\n   extensions standardized through the IETF.\n   In this document,
    the word \"extension\" refers to extension by\n   defining a new type to insert
    into an existing typed hole in a\n   protocol message.  It does not refer to extension
    by addition of new\n   fields to ASN.1 types, unless the text explicitly indicates\n
    \  otherwise.\n"
  title: 1.5.  Extending Kerberos without Breaking Interoperability
- contents:
  - "1.5.1.  Compatibility with RFC 1510\n   Note that existing Kerberos message formats
    cannot readily be\n   extended by adding fields to the ASN.1 types.  Sending additional\n
    \  fields often results in the entire message being discarded without an\n   error
    indication.  Future versions of this specification will provide\n   guidelines
    to ensure that ASN.1 fields can be added without creating\n   an interoperability
    problem.\n   In the meantime, all new or modified implementations of Kerberos
    that\n   receive an unknown message extension SHOULD preserve the encoding of\n
    \  the extension but otherwise ignore its presence.  Recipients MUST NOT\n   decline
    a request simply because an extension is present.\n   There is one exception to
    this rule.  If an unknown authorization\n   data element type is received by a
    server other than the ticket-\n   granting service either in an AP-REQ or in a
    ticket contained in an\n   AP-REQ, then authentication MUST fail.  One of the
    primary uses of\n   authorization data is to restrict the use of the ticket.  If
    the\n   service cannot determine whether the restriction applies to that\n   service,
    then a security weakness may result if the ticket can be\n   used for that service.
    \ Authorization elements that are optional\n   SHOULD be enclosed in the AD-IF-RELEVANT
    element.\n   The ticket-granting service MUST ignore but propagate to derivative\n
    \  tickets any unknown authorization data types, unless those data types\n   are
    embedded in a MANDATORY-FOR-KDC element, in which case the\n   request will be
    rejected.  This behavior is appropriate because\n   requiring that the ticket-granting
    service understand unknown\n   authorization data types would require that KDC
    software be upgraded\n   to understand new application-level restrictions before
    applications\n   used these restrictions, decreasing the utility of authorization
    data\n   as a mechanism for restricting the use of tickets.  No security\n   problem
    is created because services to which the tickets are issued\n   will verify the
    authorization data.\n   Implementation note: Many RFC 1510 implementations ignore
    unknown\n   authorization data elements.  Depending on these implementations to\n
    \  honor authorization data restrictions may create a security weakness.\n"
  title: 1.5.1.  Compatibility with RFC 1510
- contents:
  - "1.5.2.  Sending Extensible Messages\n   Care must be taken to ensure that old
    implementations can understand\n   messages sent to them, even if they do not
    understand an extension\n   that is used.  Unless the sender knows that an extension
    is\n   supported, the extension cannot change the semantics of the core\n   message
    or previously defined extensions.\n   For example, an extension including key
    information necessary to\n   decrypt the encrypted part of a KDC-REP could only
    be used in\n   situations where the recipient was known to support the extension.\n
    \  Thus when designing such extensions it is important to provide a way\n   for
    the recipient to notify the sender of support for the extension.\n   For example
    in the case of an extension that changes the KDC-REP\n   reply key, the client
    could indicate support for the extension by\n   including a padata element in
    the AS-REQ sequence.  The KDC should\n   only use the extension if this padata
    element is present in the\n   AS-REQ.  Even if policy requires the use of the
    extension, it is\n   better to return an error indicating that the extension is
    required\n   than to use the extension when the recipient may not support it.\n
    \  Debugging implementations that do not interoperate is easier when\n   errors
    are returned.\n"
  title: 1.5.2.  Sending Extensible Messages
- contents:
  - "1.6.  Environmental Assumptions\n   Kerberos imposes a few assumptions on the
    environment in which it can\n   properly function, including the following:\n
    \  *  \"Denial of service\" attacks are not solved with Kerberos.  There\n      are
    places in the protocols where an intruder can prevent an\n      application from
    participating in the proper authentication steps.\n      Detection and solution
    of such attacks (some of which can appear\n      to be not-uncommon \"normal\"
    failure modes for the system) are\n      usually best left to the human administrators
    and users.\n   *  Principals MUST keep their secret keys secret.  If an intruder\n
    \     somehow steals a principal's key, it will be able to masquerade as\n      that
    principal or to impersonate any server to the legitimate\n      principal.\n   *
    \ \"Password guessing\" attacks are not solved by Kerberos.  If a user\n      chooses
    a poor password, it is possible for an attacker to\n      successfully mount an
    offline dictionary attack by repeatedly\n      attempting to decrypt, with successive
    entries from a dictionary,\n      messages obtained which are encrypted under
    a key derived from the\n      user's password.\n   *  Each host on the network
    MUST have a clock which is \"loosely\n      synchronized\" to the time of the
    other hosts; this synchronization\n      is used to reduce the bookkeeping needs
    of application servers\n      when they do replay detection.  The degree of \"looseness\"
    can be\n      configured on a per-server basis, but it is typically on the order\n
    \     of 5 minutes.  If the clocks are synchronized over the network,\n      the
    clock synchronization protocol MUST itself be secured from\n      network attackers.\n
    \  *  Principal identifiers are not recycled on a short-term basis.  A\n      typical
    mode of access control will use access control lists\n      (ACLs) to grant permissions
    to particular principals.  If a stale\n      ACL entry remains for a deleted principal
    and the principal\n      identifier is reused, the new principal will inherit
    rights\n      specified in the stale ACL entry.  By not re-using principal\n      identifiers,
    the danger of inadvertent access is removed.\n"
  title: 1.6.  Environmental Assumptions
- contents:
  - "1.7.  Glossary of Terms\n   Below is a list of terms used throughout this document.\n
    \  Authentication\n      Verifying the claimed identity of a principal.\n   Authentication
    header\n      A record containing a Ticket and an Authenticator to be presented\n
    \     to a server as part of the authentication process.\n   Authentication path\n
    \     A sequence of intermediate realms transited in the authentication\n      process
    when communicating from one realm to another.\n   Authenticator\n      A record
    containing information that can be shown to have been\n      recently generated
    using the session key known only by the client\n      and server.\n   Authorization\n
    \     The process of determining whether a client may use a service,\n      which
    objects the client is allowed to access, and the type of\n      access allowed
    for each.\n   Capability\n      A token that grants the bearer permission to access
    an object or\n      service.  In Kerberos, this might be a ticket whose use is\n
    \     restricted by the contents of the authorization data field, but\n      which
    lists no network addresses, together with the session key\n      necessary to
    use the ticket.\n   Ciphertext\n      The output of an encryption function.  Encryption
    transforms\n      plaintext into ciphertext.\n   Client\n      A process that
    makes use of a network service on behalf of a user.\n      Note that in some cases
    a Server may itself be a client of some\n      other server (e.g., a print server
    may be a client of a file\n      server).\n   Credentials\n      A ticket plus
    the secret session key necessary to use that ticket\n      successfully in an
    authentication exchange.\n   Encryption Type (etype)\n      When associated with
    encrypted data, an encryption type identifies\n      the algorithm used to encrypt
    the data and is used to select the\n      appropriate algorithm for decrypting
    the data.  Encryption type\n      tags are communicated in other messages to enumerate
    algorithms\n      that are desired, supported, preferred, or allowed to be used
    for\n      encryption of data between parties.  This preference is combined\n
    \     with local information and policy to select an algorithm to be\n      used.\n
    \  KDC\n      Key Distribution Center.  A network service that supplies tickets\n
    \     and temporary session keys; or an instance of that service or the\n      host
    on which it runs.  The KDC services both initial ticket and\n      ticket-granting
    ticket requests.  The initial ticket portion is\n      sometimes referred to as
    the Authentication Server (or service).\n      The ticket-granting ticket portion
    is sometimes referred to as the\n      ticket-granting server (or service).\n
    \  Kerberos\n      The name given to the Project Athena's authentication service,
    the\n      protocol used by that service, or the code used to implement the\n
    \     authentication service.  The name is adopted from the three-headed\n      dog
    that guards Hades.\n   Key Version Number (kvno)\n      A tag associated with
    encrypted data identifies which key was used\n      for encryption when a long-lived
    key associated with a principal\n      changes over time.  It is used during the
    transition to a new key\n      so that the party decrypting a message can tell
    whether the data\n      was encrypted with the old or the new key.\n   Plaintext\n
    \     The input to an encryption function or the output of a decryption\n      function.
    \ Decryption transforms ciphertext into plaintext.\n   Principal\n      A named
    client or server entity that participates in a network\n      communication, with
    one name that is considered canonical.\n   Principal identifier\n      The canonical
    name used to identify each different principal\n      uniquely.\n   Seal\n      To
    encipher a record containing several fields in such a way that\n      the fields
    cannot be individually replaced without knowledge of\n      the encryption key
    or leaving evidence of tampering.\n   Secret key\n      An encryption key shared
    by a principal and the KDC, distributed\n      outside the bounds of the system,
    with a long lifetime.  In the\n      case of a human user's principal, the secret
    key MAY be derived\n      from a password.\n   Server\n      A particular Principal
    that provides a resource to network\n      clients.  The server is sometimes referred
    to as the Application\n      Server.\n   Service\n      A resource provided to
    network clients; often provided by more\n      than one server (for example, remote
    file service).\n   Session key\n      A temporary encryption key used between
    two principals, with a\n      lifetime limited to the duration of a single login
    \"session\".  In\n      the Kerberos system, a session key is generated by the
    KDC.  The\n      session key is distinct from the sub-session key, described next.\n
    \  Sub-session key\n      A temporary encryption key used between two principals,
    selected\n      and exchanged by the principals using the session key, and with
    a\n      lifetime limited to the duration of a single association.  The\n      sub-session
    key is also referred to as the subkey.\n   Ticket\n      A record that helps a
    client authenticate itself to a server; it\n      contains the client's identity,
    a session key, a timestamp, and\n      other information, all sealed using the
    server's secret key.  It\n      only serves to authenticate a client when presented
    along with a\n      fresh Authenticator.\n"
  title: 1.7.  Glossary of Terms
- contents:
  - "2.  Ticket Flag Uses and Requests\n   Each Kerberos ticket contains a set of
    flags that are used to\n   indicate attributes of that ticket.  Most flags may
    be requested by a\n   client when the ticket is obtained; some are automatically
    turned on\n   and off by a Kerberos server as required.  The following sections\n
    \  explain what the various flags mean and give examples of reasons to\n   use
    them.  With the exception of the INVALID flag, clients MUST\n   ignore ticket
    flags that are not recognized.  KDCs MUST ignore KDC\n   options that are not
    recognized.  Some implementations of RFC 1510\n   are known to reject unknown
    KDC options, so clients may need to\n   resend a request without new KDC options
    if the request was rejected\n   when sent with options added since RFC 1510.  Because
    new KDCs will\n   ignore unknown options, clients MUST confirm that the ticket
    returned\n   by the KDC meets their needs.\n   Note that it is not, in general,
    possible to determine whether an\n   option was not honored because it was not
    understood or because it\n   was rejected through either configuration or policy.
    \ When adding a\n   new option to the Kerberos protocol, designers should consider\n
    \  whether the distinction is important for their option.  If it is, a\n   mechanism
    for the KDC to return an indication that the option was\n   understood but rejected
    needs to be provided in the specification of\n   the option.  Often in such cases,
    the mechanism needs to be broad\n   enough to permit an error or reason to be
    returned.\n"
  title: 2.  Ticket Flag Uses and Requests
- contents:
  - "2.1.  Initial, Pre-authenticated, and Hardware-Authenticated Tickets\n   The
    INITIAL flag indicates that a ticket was issued using the AS\n   protocol, rather
    than issued based on a TGT.  Application servers\n   that want to require the
    demonstrated knowledge of a client's secret\n   key (e.g., a password-changing
    program) can insist that this flag be\n   set in any tickets they accept, and
    can thus be assured that the\n   client's key was recently presented to the authentication
    server.\n   The PRE-AUTHENT and HW-AUTHENT flags provide additional information\n
    \  about the initial authentication, regardless of whether the current\n   ticket
    was issued directly (in which case INITIAL will also be set)\n   or issued on
    the basis of a TGT (in which case the INITIAL flag is\n   clear, but the PRE-AUTHENT
    and HW-AUTHENT flags are carried forward\n   from the TGT).\n"
  title: 2.1.  Initial, Pre-authenticated, and Hardware-Authenticated Tickets
- contents:
  - "2.2.  Invalid Tickets\n   The INVALID flag indicates that a ticket is invalid.
    \ Application\n   servers MUST reject tickets that have this flag set.  A postdated\n
    \  ticket will be issued in this form.  Invalid tickets MUST be\n   validated
    by the KDC before use, by being presented to the KDC in a\n   TGS request with
    the VALIDATE option specified.  The KDC will only\n   validate tickets after their
    starttime has passed.  The validation is\n   required so that postdated tickets
    that have been stolen before their\n   starttime can be rendered permanently invalid
    (through a hot-list\n   mechanism) (see Section 3.3.3.1).\n"
  title: 2.2.  Invalid Tickets
- contents:
  - "2.3.  Renewable Tickets\n   Applications may desire to hold tickets that can
    be valid for long\n   periods of time.  However, this can expose their credentials
    to\n   potential theft for equally long periods, and those stolen\n   credentials
    would be valid until the expiration time of the\n   ticket(s).  Simply using short-lived
    tickets and obtaining new ones\n   periodically would require the client to have
    long-term access to its\n   secret key, an even greater risk.  Renewable tickets
    can be used to\n   mitigate the consequences of theft.  Renewable tickets have
    two\n   \"expiration times\": the first is when the current instance of the\n
    \  ticket expires, and the second is the latest permissible value for an\n   individual
    expiration time.  An application client must periodically\n   (i.e., before it
    expires) present a renewable ticket to the KDC, with\n   the RENEW option set
    in the KDC request.  The KDC will issue a new\n   ticket with a new session key
    and a later expiration time.  All other\n   fields of the ticket are left unmodified
    by the renewal process.\n   When the latest permissible expiration time arrives,
    the ticket\n   expires permanently.  At each renewal, the KDC MAY consult a hot-list\n
    \  to determine whether the ticket had been reported stolen since its\n   last
    renewal; it will refuse to renew stolen tickets, and thus the\n   usable lifetime
    of stolen tickets is reduced.\n   The RENEWABLE flag in a ticket is normally only
    interpreted by the\n   ticket-granting service (discussed below in Section 3.3).
    \ It can\n   usually be ignored by application servers.  However, some\n   particularly
    careful application servers MAY disallow renewable\n   tickets.\n   If a renewable
    ticket is not renewed by its expiration time, the KDC\n   will not renew the ticket.
    \ The RENEWABLE flag is reset by default,\n   but a client MAY request it be set
    by setting the RENEWABLE option in\n   the KRB_AS_REQ message.  If it is set,
    then the renew-till field in\n   the ticket contains the time after which the
    ticket may not be\n   renewed.\n"
  title: 2.3.  Renewable Tickets
- contents:
  - "2.4.  Postdated Tickets\n   Applications may occasionally need to obtain tickets
    for use much\n   later; e.g., a batch submission system would need tickets to
    be valid\n   at the time the batch job is serviced.  However, it is dangerous
    to\n   hold valid tickets in a batch queue, since they will be on-line\n   longer
    and more prone to theft.  Postdated tickets provide a way to\n   obtain these
    tickets from the KDC at job submission time, but to\n   leave them \"dormant\"
    until they are activated and validated by a\n   further request of the KDC.  If
    a ticket theft were reported in the\n   interim, the KDC would refuse to validate
    the ticket, and the thief\n   would be foiled.\n   The MAY-POSTDATE flag in a
    ticket is normally only interpreted by the\n   ticket-granting service.  It can
    be ignored by application servers.\n   This flag MUST be set in a TGT in order
    to issue a postdated ticket\n   based on the presented ticket.  It is reset by
    default; a client MAY\n   request it by setting the ALLOW-POSTDATE option in the
    KRB_AS_REQ\n   message.  This flag does not allow a client to obtain a postdated\n
    \  TGT; postdated TGTs can only be obtained by requesting the postdating\n   in
    the KRB_AS_REQ message.  The life (endtime-starttime) of a\n   postdated ticket
    will be the remaining life of the TGT at the time of\n   the request, unless the
    RENEWABLE option is also set, in which case\n   it can be the full life (endtime-starttime)
    of the TGT.  The KDC MAY\n   limit how far in the future a ticket may be postdated.\n
    \  The POSTDATED flag indicates that a ticket has been postdated.  The\n   application
    server can check the authtime field in the ticket to see\n   when the original
    authentication occurred.  Some services MAY choose\n   to reject postdated tickets,
    or they may only accept them within a\n   certain period after the original authentication.
    \ When the KDC\n   issues a POSTDATED ticket, it will also be marked as INVALID,
    so that\n   the application client MUST present the ticket to the KDC to be\n
    \  validated before use.\n"
  title: 2.4.  Postdated Tickets
- contents:
  - "2.5.  Proxiable and Proxy Tickets\n   At times it may be necessary for a principal
    to allow a service to\n   perform an operation on its behalf.  The service must
    be able to take\n   on the identity of the client, but only for a particular purpose.
    \ A\n   principal can allow a service to do this by granting it a proxy.\n   The
    process of granting a proxy by using the proxy and proxiable\n   flags is used
    to provide credentials for use with specific services.\n   Though conceptually
    also a proxy, users wishing to delegate their\n   identity in a form usable for
    all purposes MUST use the ticket\n   forwarding mechanism described in the next
    section to forward a TGT.\n   The PROXIABLE flag in a ticket is normally only
    interpreted by the\n   ticket-granting service.  It can be ignored by application
    servers.\n   When set, this flag tells the ticket-granting server that it is OK
    to\n   issue a new ticket (but not a TGT) with a different network address\n   based
    on this ticket.  This flag is set if requested by the client on\n   initial authentication.
    \ By default, the client will request that it\n   be set when requesting a TGT,
    and that it be reset when requesting\n   any other ticket.\n   This flag allows
    a client to pass a proxy to a server to perform a\n   remote request on its behalf
    (e.g., a print service client can give\n   the print server a proxy to access
    the client's files on a particular\n   file server in order to satisfy a print
    request).\n   In order to complicate the use of stolen credentials, Kerberos\n
    \  tickets are often valid only from those network addresses\n   specifically
    included in the ticket, but it is permissible as a\n   policy option to allow
    requests and to issue tickets with no network\n   addresses specified.  When granting
    a proxy, the client MUST specify\n   the new network address from which the proxy
    is to be used or\n   indicate that the proxy is to be issued for use from any
    address.\n   The PROXY flag is set in a ticket by the TGS when it issues a proxy\n
    \  ticket.  Application servers MAY check this flag; and at their option\n   they
    MAY require additional authentication from the agent presenting\n   the proxy
    in order to provide an audit trail.\n"
  title: 2.5.  Proxiable and Proxy Tickets
- contents:
  - "2.6.  Forwardable Tickets\n   Authentication forwarding is an instance of a proxy
    where the service\n   that is granted is complete use of the client's identity.
    \ An example\n   of where it might be used is when a user logs in to a remote
    system\n   and wants authentication to work from that system as if the login\n
    \  were local.\n   The FORWARDABLE flag in a ticket is normally only interpreted
    by the\n   ticket-granting service.  It can be ignored by application servers.\n
    \  The FORWARDABLE flag has an interpretation similar to that of the\n   PROXIABLE
    flag, except TGTs may also be issued with different network\n   addresses.  This
    flag is reset by default, but users MAY request that\n   it be set by setting
    the FORWARDABLE option in the AS request when\n   they request their initial TGT.\n
    \  This flag allows for authentication forwarding without requiring the\n   user
    to enter a password again.  If the flag is not set, then\n   authentication forwarding
    is not permitted, but the same result can\n   still be achieved if the user engages
    in the AS exchange, specifies\n   the requested network addresses, and supplies
    a password.\n   The FORWARDED flag is set by the TGS when a client presents a
    ticket\n   with the FORWARDABLE flag set and requests a forwarded ticket by\n
    \  specifying the FORWARDED KDC option and supplying a set of addresses\n   for
    the new ticket.  It is also set in all tickets issued based on\n   tickets with
    the FORWARDED flag set.  Application servers may choose\n   to process FORWARDED
    tickets differently than non-FORWARDED tickets.\n   If addressless tickets are
    forwarded from one system to another,\n   clients SHOULD still use this option
    to obtain a new TGT in order to\n   have different session keys on the different
    systems.\n"
  title: 2.6.  Forwardable Tickets
- contents:
  - "2.7.  Transited Policy Checking\n   In Kerberos, the application server is ultimately
    responsible for\n   accepting or rejecting authentication, and it SHOULD check
    that only\n   suitably trusted KDCs are relied upon to authenticate a principal.\n
    \  The transited field in the ticket identifies which realms (and thus\n   which
    KDCs) were involved in the authentication process, and an\n   application server
    would normally check this field.  If any of these\n   are untrusted to authenticate
    the indicated client principal\n   (probably determined by a realm-based policy),
    the authentication\n   attempt MUST be rejected.  The presence of trusted KDCs
    in this list\n   does not provide any guarantee; an untrusted KDC may have fabricated\n
    \  the list.\n   Although the end server ultimately decides whether authentication
    is\n   valid, the KDC for the end server's realm MAY apply a realm-specific\n
    \  policy for validating the transited field and accepting credentials\n   for
    cross-realm authentication.  When the KDC applies such checks and\n   accepts
    such cross-realm authentication, it will set the\n   TRANSITED-POLICY-CHECKED
    flag in the service tickets it issues based\n   on the cross-realm TGT.  A client
    MAY request that the KDCs not check\n   the transited field by setting the DISABLE-TRANSITED-CHECK
    flag.\n   KDCs are encouraged but not required to honor this flag.\n   Application
    servers MUST either do the transited-realm checks\n   themselves or reject cross-realm
    tickets without\n   TRANSITED-POLICY-CHECKED set.\n"
  title: 2.7.  Transited Policy Checking
- contents:
  - "2.8.  OK as Delegate\n   For some applications, a client may need to delegate
    authority to a\n   server to act on its behalf in contacting other services.  This\n
    \  requires that the client forward credentials to an intermediate\n   server.
    \ The ability for a client to obtain a service ticket to a\n   server conveys
    no information to the client about whether the server\n   should be trusted to
    accept delegated credentials.  The\n   OK-AS-DELEGATE provides a way for a KDC
    to communicate local realm\n   policy to a client regarding whether an intermediate
    server is\n   trusted to accept such credentials.\n   The copy of the ticket flags
    in the encrypted part of the KDC reply\n   may have the OK-AS-DELEGATE flag set
    to indicate to the client that\n   the server specified in the ticket has been
    determined by the policy\n   of the realm to be a suitable recipient of delegation.
    \ A client can\n   use the presence of this flag to help it decide whether to
    delegate\n   credentials (grant either a proxy or a forwarded TGT) to this server.\n
    \  It is acceptable to ignore the value of this flag.  When setting this\n   flag,
    an administrator should consider the security and placement of\n   the server
    on which the service will run, as well as whether the\n   service requires the
    use of delegated credentials.\n"
  title: 2.8.  OK as Delegate
- contents:
  - "2.9.  Other KDC Options\n   There are three additional options that MAY be set
    in a client's\n   request of the KDC.\n"
  title: 2.9.  Other KDC Options
- contents:
  - "2.9.1.  Renewable-OK\n   The RENEWABLE-OK option indicates that the client will
    accept a\n   renewable ticket if a ticket with the requested life cannot otherwise\n
    \  be provided.  If a ticket with the requested life cannot be provided,\n   then
    the KDC MAY issue a renewable ticket with a renew-till equal to\n   the requested
    endtime.  The value of the renew-till field MAY still\n   be adjusted by site-determined
    limits or limits imposed by the\n   individual principal or server.\n"
  title: 2.9.1.  Renewable-OK
- contents:
  - "2.9.2.  ENC-TKT-IN-SKEY\n   In its basic form, the Kerberos protocol supports
    authentication in a\n   client-server setting and is not well suited to authentication
    in a\n   peer-to-peer environment because the long-term key of the user does\n
    \  not remain on the workstation after initial login.  Authentication of\n   such
    peers may be supported by Kerberos in its user-to-user variant.\n   The ENC-TKT-IN-SKEY
    option supports user-to-user authentication by\n   allowing the KDC to issue a
    service ticket encrypted using the\n   session key from another TGT issued to
    another user.  The\n   ENC-TKT-IN-SKEY option is honored only by the ticket-granting\n
    \  service.  It indicates that the ticket to be issued for the end\n   server
    is to be encrypted in the session key from the additional\n   second TGT provided
    with the request.  See Section 3.3.3 for specific\n   details.\n"
  title: 2.9.2.  ENC-TKT-IN-SKEY
- contents:
  - "2.9.3.  Passwordless Hardware Authentication\n   The OPT-HARDWARE-AUTH option
    indicates that the client wishes to use\n   some form of hardware authentication
    instead of or in addition to the\n   client's password or other long-lived encryption
    key.\n   OPT-HARDWARE-AUTH is honored only by the authentication service.  If\n
    \  supported and allowed by policy, the KDC will return an error code of\n   KDC_ERR_PREAUTH_REQUIRED
    and include the required METHOD-DATA to\n   perform such authentication.\n"
  title: 2.9.3.  Passwordless Hardware Authentication
- contents:
  - "3.  Message Exchanges\n   The following sections describe the interactions between
    network\n   clients and servers and the messages involved in those exchanges.\n"
  title: 3.  Message Exchanges
- contents:
  - "3.1.  The Authentication Service Exchange\n                             Summary\n
    \        Message direction       Message type    Section\n         1. Client to
    Kerberos   KRB_AS_REQ      5.4.1\n         2. Kerberos to client   KRB_AS_REP
    or   5.4.2\n                                 KRB_ERROR       5.9.1\n   The Authentication
    Service (AS) Exchange between the client and the\n   Kerberos Authentication Server
    is initiated by a client when it\n   wishes to obtain authentication credentials
    for a given server but\n   currently holds no credentials.  In its basic form,
    the client's\n   secret key is used for encryption and decryption.  This exchange
    is\n   typically used at the initiation of a login session to obtain\n   credentials
    for a Ticket-Granting Server, which will subsequently be\n   used to obtain credentials
    for other servers (see Section 3.3)\n   without requiring further use of the client's
    secret key.  This\n   exchange is also used to request credentials for services
    that must\n   not be mediated through the Ticket-Granting Service, but rather\n
    \  require knowledge of a principal's secret key, such as the password-\n   changing
    service (the password-changing service denies requests\n   unless the requester
    can demonstrate knowledge of the user's old\n   password; requiring this knowledge
    prevents unauthorized password\n   changes by someone walking up to an unattended
    session).\n   This exchange does not by itself provide any assurance of the\n
    \  identity of the user.  To authenticate a user logging on to a local\n   system,
    the credentials obtained in the AS exchange may first be used\n   in a TGS exchange
    to obtain credentials for a local server; those\n   credentials must then be verified
    by a local server through\n   successful completion of the Client/Server exchange.\n
    \  The AS exchange consists of two messages: KRB_AS_REQ from the client\n   to
    Kerberos, and KRB_AS_REP or KRB_ERROR in reply.  The formats for\n   these messages
    are described in Sections 5.4.1, 5.4.2, and 5.9.1.\n   In the request, the client
    sends (in cleartext) its own identity and\n   the identity of the server for which
    it is requesting credentials,\n   other information about the credentials it is
    requesting, and a\n   randomly generated nonce, which can be used to detect replays
    and to\n   associate replies with the matching requests.  This nonce MUST be\n
    \  generated randomly by the client and remembered for checking against\n   the
    nonce in the expected reply.  The response, KRB_AS_REP, contains\n   a ticket
    for the client to present to the server, and a session key\n   that will be shared
    by the client and the server.  The session key\n   and additional information
    are encrypted in the client's secret key.\n   The encrypted part of the KRB_AS_REP
    message also contains the nonce\n   that MUST be matched with the nonce from the
    KRB_AS_REQ message.\n   Without pre-authentication, the authentication server
    does not know\n   whether the client is actually the principal named in the request.\n
    \  It simply sends a reply without knowing or caring whether they are\n   the
    same.  This is acceptable because nobody but the principal whose\n   identity
    was given in the request will be able to use the reply.  Its\n   critical information
    is encrypted in that principal's key.  However,\n   an attacker can send a KRB_AS_REQ
    message to get known plaintext in\n   order to attack the principal's key.  Especially
    if the key is based\n   on a password, this may create a security exposure.  So
    the initial\n   request supports an optional field that can be used to pass\n
    \  additional information that might be needed for the initial exchange.\n   This
    field SHOULD be used for pre-authentication as described in\n   sections 3.1.1
    and 5.2.7.\n   Various errors can occur; these are indicated by an error response\n
    \  (KRB_ERROR) instead of the KRB_AS_REP response.  The error message is\n   not
    encrypted.  The KRB_ERROR message contains information that can\n   be used to
    associate it with the message to which it replies.  The\n   contents of the KRB_ERROR
    message are not integrity-protected.  As\n   such, the client cannot detect replays,
    fabrications, or\n   modifications.  A solution to this problem will be included
    in a\n   future version of the protocol.\n"
  title: 3.1.  The Authentication Service Exchange
- contents:
  - "3.1.1.  Generation of KRB_AS_REQ Message\n   The client may specify a number
    of options in the initial request.\n   Among these options are whether pre-authentication
    is to be\n   performed; whether the requested ticket is to be renewable,\n   proxiable,
    or forwardable; whether it should be postdated or allow\n   postdating of derivative
    tickets; and whether a renewable ticket will\n   be accepted in lieu of a non-renewable
    ticket if the requested ticket\n   expiration date cannot be satisfied by a non-renewable
    ticket (due to\n   configuration constraints).\n   The client prepares the KRB_AS_REQ
    message and sends it to the KDC.\n"
  title: 3.1.1.  Generation of KRB_AS_REQ Message
- contents:
  - "3.1.2.  Receipt of KRB_AS_REQ Message\n   If all goes well, processing the KRB_AS_REQ
    message will result in\n   the creation of a ticket for the client to present
    to the server.\n   The format for the ticket is described in Section 5.3.\n   Because
    Kerberos can run over unreliable transports such as UDP, the\n   KDC MUST be prepared
    to retransmit responses in case they are lost.\n   If a KDC receives a request
    identical to one it has recently\n   processed successfully, the KDC MUST respond
    with a KRB_AS_REP\n   message rather than a replay error.  In order to reduce
    ciphertext\n   given to a potential attacker, KDCs MAY send the same response\n
    \  generated when the request was first handled.  KDCs MUST obey this\n   replay
    behavior even if the actual transport in use is reliable.\n"
  title: 3.1.2.  Receipt of KRB_AS_REQ Message
- contents:
  - "3.1.3.  Generation of KRB_AS_REP Message\n   The authentication server looks
    up the client and server principals\n   named in the KRB_AS_REQ in its database,
    extracting their respective\n   keys.  If the requested client principal named
    in the request is\n   unknown because it doesn't exist in the KDC's principal
    database,\n   then an error message with a KDC_ERR_C_PRINCIPAL_UNKNOWN is returned.\n
    \  If required to do so, the server pre-authenticates the request, and\n   if
    the pre-authentication check fails, an error message with the code\n   KDC_ERR_PREAUTH_FAILED
    is returned.  If pre-authentication is\n   required, but was not present in the
    request, an error message with\n   the code KDC_ERR_PREAUTH_REQUIRED is returned,
    and a METHOD-DATA\n   object will be stored in the e-data field of the KRB-ERROR
    message to\n   specify which pre-authentication mechanisms are acceptable.  Usually\n
    \  this will include PA-ETYPE-INFO and/or PA-ETYPE-INFO2 elements as\n   described
    below.  If the server cannot accommodate any encryption\n   type requested by
    the client, an error message with code\n   KDC_ERR_ETYPE_NOSUPP is returned.  Otherwise,
    the KDC generates a\n   'random' session key, meaning that, among other things,
    it should be\n   impossible to guess the next session key based on knowledge of
    past\n   session keys.  Although this can be achieved in a pseudo-random\n   number
    generator if it is based on cryptographic principles, it is\n   more desirable
    to use a truly random number generator, such as one\n   based on measurements
    of random physical phenomena.  See [RFC4086]\n   for an in-depth discussion of
    randomness.\n   In response to an AS request, if there are multiple encryption
    keys\n   registered for a client in the Kerberos database, then the etype\n   field
    from the AS request is used by the KDC to select the encryption\n   method to
    be used to protect the encrypted part of the KRB_AS_REP\n   message that is sent
    to the client.  If there is more than one\n   supported strong encryption type
    in the etype list, the KDC SHOULD\n   use the first valid strong etype for which
    an encryption key is\n   available.\n   When the user's key is generated from
    a password or pass phrase, the\n   string-to-key function for the particular encryption
    key type is\n   used, as specified in [RFC3961].  The salt value and additional\n
    \  parameters for the string-to-key function have default values\n   (specified
    by Section 4 and by the encryption mechanism\n   specification, respectively)
    that may be overridden by\n   pre-authentication data (PA-PW-SALT, PA-AFS3-SALT,
    PA-ETYPE-INFO,\n   PA-ETYPE-INFO2, etc).  Since the KDC is presumed to store a
    copy of\n   the resulting key only, these values should not be changed for\n   password-based
    keys except when changing the principal's key.\n   When the AS server is to include
    pre-authentication data in a\n   KRB-ERROR or in an AS-REP, it MUST use PA-ETYPE-INFO2,
    not PA-ETYPE-\n   INFO, if the etype field of the client's AS-REQ lists at least
    one\n   \"newer\" encryption type.  Otherwise (when the etype field of the\n   client's
    AS-REQ does not list any \"newer\" encryption types), it MUST\n   send both PA-ETYPE-INFO2
    and PA-ETYPE-INFO (both with an entry for\n   each enctype).  A \"newer\" enctype
    is any enctype first officially\n   specified concurrently with or subsequent
    to the issue of this RFC.\n   The enctypes DES, 3DES, or RC4 and any defined in
    [RFC1510] are not\n   \"newer\" enctypes.\n   It is not possible to generate a
    user's key reliably given a pass\n   phrase without contacting the KDC, since
    it will not be known whether\n   alternate salt or parameter values are required.\n
    \  The KDC will attempt to assign the type of the random session key\n   from
    the list of methods in the etype field.  The KDC will select the\n   appropriate
    type using the list of methods provided and information\n   from the Kerberos
    database indicating acceptable encryption methods\n   for the application server.
    \ The KDC will not issue tickets with a\n   weak session key encryption type.\n
    \  If the requested starttime is absent, indicates a time in the past,\n   or
    is within the window of acceptable clock skew for the KDC and the\n   POSTDATE
    option has not been specified, then the starttime of the\n   ticket is set to
    the authentication server's current time.  If it\n   indicates a time in the future
    beyond the acceptable clock skew, but\n   the POSTDATED option has not been specified,
    then the error\n   KDC_ERR_CANNOT_POSTDATE is returned.  Otherwise the requested\n
    \  starttime is checked against the policy of the local realm (the\n   administrator
    might decide to prohibit certain types or ranges of\n   postdated tickets), and
    if the ticket's starttime is acceptable, it\n   is set as requested, and the INVALID
    flag is set in the new ticket.\n   The postdated ticket MUST be validated before
    use by presenting it to\n   the KDC after the starttime has been reached.\n   The
    expiration time of the ticket will be set to the earlier of the\n   requested
    endtime and a time determined by local policy, possibly by\n   using realm- or
    principal-specific factors.  For example, the\n   expiration time MAY be set to
    the earliest of the following:\n      *  The expiration time (endtime) requested
    in the KRB_AS_REQ\n         message.\n      *  The ticket's starttime plus the
    maximum allowable lifetime\n         associated with the client principal from
    the authentication\n         server's database.\n      *  The ticket's starttime
    plus the maximum allowable lifetime\n         associated with the server principal.\n
    \     *  The ticket's starttime plus the maximum lifetime set by the\n         policy
    of the local realm.\n   If the requested expiration time minus the starttime (as
    determined\n   above) is less than a site-determined minimum lifetime, an error\n
    \  message with code KDC_ERR_NEVER_VALID is returned.  If the requested\n   expiration
    time for the ticket exceeds what was determined as above,\n   and if the 'RENEWABLE-OK'
    option was requested, then the 'RENEWABLE'\n   flag is set in the new ticket,
    and the renew-till value is set as if\n   the 'RENEWABLE' option were requested
    (the field and option names are\n   described fully in Section 5.4.1).\n   If
    the RENEWABLE option has been requested or if the RENEWABLE-OK\n   option has
    been set and a renewable ticket is to be issued, then the\n   renew-till field
    MAY be set to the earliest of:\n      *  Its requested value.\n      *  The starttime
    of the ticket plus the minimum of the two maximum\n         renewable lifetimes
    associated with the principals' database\n         entries.\n      *  The starttime
    of the ticket plus the maximum renewable lifetime\n         set by the policy
    of the local realm.\n   The flags field of the new ticket will have the following
    options set\n   if they have been requested and if the policy of the local realm\n
    \  allows:  FORWARDABLE, MAY-POSTDATE, POSTDATED, PROXIABLE, RENEWABLE.\n   If
    the new ticket is postdated (the starttime is in the future), its\n   INVALID
    flag will also be set.\n   If all of the above succeed, the server will encrypt
    the ciphertext\n   part of the ticket using the encryption key extracted from
    the server\n   principal's record in the Kerberos database using the encryption
    type\n   associated with the server principal's key.  (This choice is NOT\n   affected
    by the etype field in the request.)  It then formats a\n   KRB_AS_REP message
    (see Section 5.4.2), copying the addresses in the\n   request into the caddr of
    the response, placing any required pre-\n   authentication data into the padata
    of the response, and encrypts the\n   ciphertext part in the client's key using
    an acceptable encryption\n   method requested in the etype field of the request,
    or in some key\n   specified by pre-authentication mechanisms being used.\n"
  title: 3.1.3.  Generation of KRB_AS_REP Message
- contents:
  - "3.1.4.  Generation of KRB_ERROR Message\n   Several errors can occur, and the
    Authentication Server responds by\n   returning an error message, KRB_ERROR, to
    the client, with the\n   error-code and e-text fields set to appropriate values.
    \ The error\n   message contents and details are described in Section 5.9.1.\n"
  title: 3.1.4.  Generation of KRB_ERROR Message
- contents:
  - "3.1.5.  Receipt of KRB_AS_REP Message\n   If the reply message type is KRB_AS_REP,
    then the client verifies\n   that the cname and crealm fields in the cleartext
    portion of the\n   reply match what it requested.  If any padata fields are present,\n
    \  they may be used to derive the proper secret key to decrypt the\n   message.
    \ The client decrypts the encrypted part of the response\n   using its secret
    key and verifies that the nonce in the encrypted\n   part matches the nonce it
    supplied in its request (to detect\n   replays).  It also verifies that the sname
    and srealm in the response\n   match those in the request (or are otherwise expected
    values), and\n   that the host address field is also correct.  It then stores
    the\n   ticket, session key, start and expiration times, and other\n   information
    for later use.  The last-req field (and the deprecated\n   key-expiration field)
    from the encrypted part of the response MAY be\n   checked to notify the user
    of impending key expiration.  This enables\n   the client program to suggest remedial
    action, such as a password\n   change.\n   Upon validation of the KRB_AS_REP message
    (by checking the returned\n   nonce against that sent in the KRB_AS_REQ message),
    the client knows\n   that the current time on the KDC is that read from the authtime
    field\n   of the encrypted part of the reply.  The client can optionally use\n
    \  this value for clock synchronization in subsequent messages by\n   recording
    with the ticket the difference (offset) between the\n   authtime value and the
    local clock.  This offset can then be used by\n   the same user to adjust the
    time read from the system clock when\n   generating messages [DGT96].\n   This
    technique MUST be used when adjusting for clock skew instead of\n   directly changing
    the system clock, because the KDC reply is only\n   authenticated to the user
    whose secret key was used, but not to the\n   system or workstation.  If the clock
    were adjusted, an attacker\n   colluding with a user logging into a workstation
    could agree on a\n   password, resulting in a KDC reply that would be correctly
    validated\n   even though it did not originate from a KDC trusted by the\n   workstation.\n
    \  Proper decryption of the KRB_AS_REP message is not sufficient for the\n   host
    to verify the identity of the user; the user and an attacker\n   could cooperate
    to generate a KRB_AS_REP format message that decrypts\n   properly but is not
    from the proper KDC.  If the host wishes to\n   verify the identity of the user,
    it MUST require the user to present\n   application credentials that can be verified
    using a securely-stored\n   secret key for the host.  If those credentials can
    be verified, then\n   the identity of the user can be assured.\n"
  title: 3.1.5.  Receipt of KRB_AS_REP Message
- contents:
  - "3.1.6.  Receipt of KRB_ERROR Message\n   If the reply message type is KRB_ERROR,
    then the client interprets it\n   as an error and performs whatever application-specific
    tasks are\n   necessary for recovery.\n"
  title: 3.1.6.  Receipt of KRB_ERROR Message
- contents:
  - "3.2.  The Client/Server Authentication Exchange\n                                Summary\n
    \  Message direction                         Message type    Section\n   Client
    to Application server              KRB_AP_REQ      5.5.1\n   [optional] Application
    server to client   KRB_AP_REP or   5.5.2\n                                             KRB_ERROR
    \      5.9.1\n   The client/server authentication (CS) exchange is used by network\n
    \  applications to authenticate the client to the server and vice versa.\n   The
    client MUST have already acquired credentials for the server\n   using the AS
    or TGS exchange.\n"
  title: 3.2.  The Client/Server Authentication Exchange
- contents:
  - "3.2.1.  The KRB_AP_REQ Message\n   The KRB_AP_REQ contains authentication information
    that SHOULD be\n   part of the first message in an authenticated transaction.
    \ It\n   contains a ticket, an authenticator, and some additional bookkeeping\n
    \  information (see Section 5.5.1 for the exact format).  The ticket by\n   itself
    is insufficient to authenticate a client, since tickets are\n   passed across
    the network in cleartext (tickets contain both an\n   encrypted and unencrypted
    portion, so cleartext here refers to the\n   entire unit, which can be copied
    from one message and replayed in\n   another without any cryptographic skill).
    \ The authenticator is used\n   to prevent invalid replay of tickets by proving
    to the server that\n   the client knows the session key of the ticket and thus
    is entitled\n   to use the ticket.  The KRB_AP_REQ message is referred to elsewhere\n
    \  as the 'authentication header'.\n"
  title: 3.2.1.  The KRB_AP_REQ Message
- contents:
  - "3.2.2.  Generation of a KRB_AP_REQ Message\n   When a client wishes to initiate
    authentication to a server, it\n   obtains (either through a credentials cache,
    the AS exchange, or the\n   TGS exchange) a ticket and session key for the desired
    service.  The\n   client MAY re-use any tickets it holds until they expire.  To
    use a\n   ticket, the client constructs a new Authenticator from the system\n
    \  time and its name, and optionally from an application-specific\n   checksum,
    an initial sequence number to be used in KRB_SAFE or\n   KRB_PRIV messages, and/or
    a session subkey to be used in negotiations\n   for a session key unique to this
    particular session.  Authenticators\n   MUST NOT be re-used and SHOULD be rejected
    if replayed to a server.\n   Note that this can make applications based on unreliable
    transports\n   difficult to code correctly.  If the transport might deliver\n
    \  duplicated messages, either a new authenticator MUST be generated for\n   each
    retry, or the application server MUST match requests and replies\n   and replay
    the first reply in response to a detected duplicate.\n   If a sequence number
    is to be included, it SHOULD be randomly chosen\n   so that even after many messages
    have been exchanged it is not likely\n   to collide with other sequence numbers
    in use.\n   The client MAY indicate a requirement of mutual authentication or
    the\n   use of a session-key based ticket (for user-to-user authentication,\n
    \  see section 3.7) by setting the appropriate flag(s) in the ap-options\n   field
    of the message.\n   The Authenticator is encrypted in the session key and combined
    with\n   the ticket to form the KRB_AP_REQ message, which is then sent to the\n
    \  end server along with any additional application-specific\n   information.\n"
  title: 3.2.2.  Generation of a KRB_AP_REQ Message
- contents:
  - "3.2.3.  Receipt of KRB_AP_REQ Message\n   Authentication is based on the server's
    current time of day (clocks\n   MUST be loosely synchronized), the authenticator,
    and the ticket.\n   Several errors are possible.  If an error occurs, the server
    is\n   expected to reply to the client with a KRB_ERROR message.  This\n   message
    MAY be encapsulated in the application protocol if its raw\n   form is not acceptable
    to the protocol.  The format of error messages\n   is described in Section 5.9.1.\n
    \  The algorithm for verifying authentication information is as follows.\n   If
    the message type is not KRB_AP_REQ, the server returns the\n   KRB_AP_ERR_MSG_TYPE
    error.  If the key version indicated by the\n   Ticket in the KRB_AP_REQ is not
    one the server can use (e.g., it\n   indicates an old key, and the server no longer
    possesses a copy of\n   the old key), the KRB_AP_ERR_BADKEYVER error is returned.
    \ If the\n   USE-SESSION-KEY flag is set in the ap-options field, it indicates
    to\n   the server that user-to-user authentication is in use, and that the\n   ticket
    is encrypted in the session key from the server's TGT rather\n   than in the server's
    secret key.  See Section 3.7 for a more complete\n   description of the effect
    of user-to-user authentication on all\n   messages in the Kerberos protocol.\n
    \  Because it is possible for the server to be registered in multiple\n   realms,
    with different keys in each, the srealm field in the\n   unencrypted portion of
    the ticket in the KRB_AP_REQ is used to\n   specify which secret key the server
    should use to decrypt that\n   ticket.  The KRB_AP_ERR_NOKEY error code is returned
    if the server\n   doesn't have the proper key to decipher the ticket.\n   The
    ticket is decrypted using the version of the server's key\n   specified by the
    ticket.  If the decryption routines detect a\n   modification of the ticket (each
    encryption system MUST provide\n   safeguards to detect modified ciphertext),
    the\n   KRB_AP_ERR_BAD_INTEGRITY error is returned (chances are good that\n   different
    keys were used to encrypt and decrypt).\n   The authenticator is decrypted using
    the session key extracted from\n   the decrypted ticket.  If decryption shows
    that is has been modified,\n   the KRB_AP_ERR_BAD_INTEGRITY error is returned.
    \ The name and realm\n   of the client from the ticket are compared against the
    same fields in\n   the authenticator.  If they don't match, the KRB_AP_ERR_BADMATCH\n
    \  error is returned; normally this is caused by a client error or an\n   attempted
    attack.  The addresses in the ticket (if any) are then\n   searched for an address
    matching the operating-system reported\n   address of the client.  If no match
    is found or the server insists on\n   ticket addresses but none are present in
    the ticket, the\n   KRB_AP_ERR_BADADDR error is returned.  If the local (server)
    time and\n   the client time in the authenticator differ by more than the\n   allowable
    clock skew (e.g., 5 minutes), the KRB_AP_ERR_SKEW error is\n   returned.\n   Unless
    the application server provides its own suitable means to\n   protect against
    replay (for example, a challenge-response sequence\n   initiated by the server
    after authentication, or use of a server-\n   generated encryption subkey), the
    server MUST utilize a replay cache\n   to remember any authenticator presented
    within the allowable clock\n   skew.  Careful analysis of the application protocol
    and\n   implementation is recommended before eliminating this cache.  The\n   replay
    cache will store at least the server name, along with the\n   client name, time,
    and microsecond fields from the recently-seen\n   authenticators, and if a matching
    tuple is found, the\n   KRB_AP_ERR_REPEAT error is returned.  Note that the rejection
    here is\n   restricted to authenticators from the same principal to the same\n
    \  server.  Other client principals communicating with the same server\n   principal
    should not have their authenticators rejected if the time\n   and microsecond
    fields happen to match some other client's\n   authenticator.\n   If a server
    loses track of authenticators presented within the\n   allowable clock skew, it
    MUST reject all requests until the clock\n   skew interval has passed, providing
    assurance that any lost or\n   replayed authenticators will fall outside the allowable
    clock skew\n   and can no longer be successfully replayed.  If this were not done,\n
    \  an attacker could subvert the authentication by recording the ticket\n   and
    authenticator sent over the network to a server and replaying\n   them following
    an event that caused the server to lose track of\n   recently seen authenticators.\n
    \  Implementation note: If a client generates multiple requests to the\n   KDC
    with the same timestamp, including the microsecond field, all but\n   the first
    of the requests received will be rejected as replays.  This\n   might happen,
    for example, if the resolution of the client's clock is\n   too coarse.  Client
    implementations SHOULD ensure that the timestamps\n   are not reused, possibly
    by incrementing the microseconds field in\n   the time stamp when the clock returns
    the same time for multiple\n   requests.\n   If multiple servers (for example,
    different services on one machine,\n   or a single service implemented on multiple
    machines) share a service\n   principal (a practice that we do not recommend in
    general, but that\n   we acknowledge will be used in some cases), either they
    MUST share\n   this replay cache, or the application protocol MUST be designed
    so as\n   to eliminate the need for it.  Note that this applies to all of the\n
    \  services.  If any of the application protocols does not have replay\n   protection
    built in, an authenticator used with such a service could\n   later be replayed
    to a different service with the same service\n   principal but no replay protection,
    if the former doesn't record the\n   authenticator information in the common replay
    cache.\n   If a sequence number is provided in the authenticator, the server\n
    \  saves it for later use in processing KRB_SAFE and/or KRB_PRIV\n   messages.
    \ If a subkey is present, the server either saves it for\n   later use or uses
    it to help generate its own choice for a subkey to\n   be returned in a KRB_AP_REP
    message.\n   The server computes the age of the ticket: local (server) time minus\n
    \  the starttime inside the Ticket.  If the starttime is later than the\n   current
    time by more than the allowable clock skew, or if the INVALID\n   flag is set
    in the ticket, the KRB_AP_ERR_TKT_NYV error is returned.\n   Otherwise, if the
    current time is later than end time by more than\n   the allowable clock skew,
    the KRB_AP_ERR_TKT_EXPIRED error is\n   returned.\n   If all these checks succeed
    without an error, the server is assured\n   that the client possesses the credentials
    of the principal named in\n   the ticket, and thus, that the client has been authenticated
    to the\n   server.\n   Passing these checks provides only authentication of the
    named\n   principal; it does not imply authorization to use the named service.\n
    \  Applications MUST make a separate authorization decision based upon\n   the
    authenticated name of the user, the requested operation, local\n   access control
    information such as that contained in a .k5login or\n   .k5users file, and possibly
    a separate distributed authorization\n   service.\n"
  title: 3.2.3.  Receipt of KRB_AP_REQ Message
- contents:
  - "3.2.4.  Generation of a KRB_AP_REP Message\n   Typically, a client's request
    will include both the authentication\n   information and its initial request in
    the same message, and the\n   server need not explicitly reply to the KRB_AP_REQ.
    \ However, if\n   mutual authentication (authenticating not only the client to
    the\n   server, but also the server to the client) is being performed, the\n   KRB_AP_REQ
    message will have MUTUAL-REQUIRED set in its ap-options\n   field, and a KRB_AP_REP
    message is required in response.  As with the\n   error message, this message
    MAY be encapsulated in the application\n   protocol if its \"raw\" form is not
    acceptable to the application's\n   protocol.  The timestamp and microsecond field
    used in the reply MUST\n   be the client's timestamp and microsecond field (as
    provided in the\n   authenticator).  If a sequence number is to be included, it
    SHOULD be\n   randomly chosen as described above for the authenticator.  A subkey\n
    \  MAY be included if the server desires to negotiate a different\n   subkey.
    \ The KRB_AP_REP message is encrypted in the session key\n   extracted from the
    ticket.\n   Note that in the Kerberos Version 4 protocol, the timestamp in the\n
    \  reply was the client's timestamp plus one.  This is not necessary in\n   Version
    5 because Version 5 messages are formatted in such a way that\n   it is not possible
    to create the reply by judicious message surgery\n   (even in encrypted form)
    without knowledge of the appropriate\n   encryption keys.\n"
  title: 3.2.4.  Generation of a KRB_AP_REP Message
- contents:
  - "3.2.5.  Receipt of KRB_AP_REP Message\n   If a KRB_AP_REP message is returned,
    the client uses the session key\n   from the credentials obtained for the server
    to decrypt the message\n   and verifies that the timestamp and microsecond fields
    match those in\n   the Authenticator it sent to the server.  If they match, then
    the\n   client is assured that the server is genuine.  The sequence number\n   and
    subkey (if present) are retained for later use.  (Note that for\n   encrypting
    the KRB_AP_REP message, the sub-session key is not used,\n   even if it is present
    in the Authentication.)\n"
  title: 3.2.5.  Receipt of KRB_AP_REP Message
- contents:
  - "3.2.6.  Using the Encryption Key\n   After the KRB_AP_REQ/KRB_AP_REP exchange
    has occurred, the client and\n   server share an encryption key that can be used
    by the application.\n   In some cases, the use of this session key will be implicit
    in the\n   protocol; in others the method of use must be chosen from several\n
    \  alternatives.  The application MAY choose the actual encryption key\n   to
    be used for KRB_PRIV, KRB_SAFE, or other application-specific uses\n   based on
    the session key from the ticket and subkeys in the\n   KRB_AP_REP message and
    the authenticator.  Implementations of the\n   protocol MAY provide routines to
    choose subkeys based on session keys\n   and random numbers and to generate a
    negotiated key to be returned in\n   the KRB_AP_REP message.\n   To mitigate the
    effect of failures in random number generation on the\n   client, it is strongly
    encouraged that any key derived by an\n   application for subsequent use include
    the full key entropy derived\n   from the KDC-generated session key carried in
    the ticket.  We leave\n   the protocol negotiations of how to use the key (e.g.,
    for selecting\n   an encryption or checksum type) to the application programmer.
    \ The\n   Kerberos protocol does not constrain the implementation options, but\n
    \  an example of how this might be done follows.\n   One way that an application
    may choose to negotiate a key to be used\n   for subsequent integrity and privacy
    protection is for the client to\n   propose a key in the subkey field of the authenticator.
    \ The server\n   can then choose a key using the key proposed by the client as
    input,\n   returning the new subkey in the subkey field of the application\n   reply.
    \ This key could then be used for subsequent communication.\n   With both the
    one-way and mutual authentication exchanges, the peers\n   should take care not
    to send sensitive information to each other\n   without proper assurances.  In
    particular, applications that require\n   privacy or integrity SHOULD use the
    KRB_AP_REP response from the\n   server to the client to assure both client and
    server of their peer's\n   identity.  If an application protocol requires privacy
    of its\n   messages, it can use the KRB_PRIV message (section 3.5).  The\n   KRB_SAFE
    message (Section 3.4) can be used to ensure integrity.\n"
  title: 3.2.6.  Using the Encryption Key
- contents:
  - "3.3.  The Ticket-Granting Service (TGS) Exchange\n                             Summary\n
    \        Message direction       Message type     Section\n         1. Client
    to Kerberos   KRB_TGS_REQ      5.4.1\n         2. Kerberos to client   KRB_TGS_REP
    or   5.4.2\n                                 KRB_ERROR        5.9.1\n   The TGS
    exchange between a client and the Kerberos TGS is initiated\n   by a client when
    it seeks to obtain authentication credentials for a\n   given server (which might
    be registered in a remote realm), when it\n   seeks to renew or validate an existing
    ticket, or when it seeks to\n   obtain a proxy ticket.  In the first case, the
    client must already\n   have acquired a ticket for the Ticket-Granting Service
    using the AS\n   exchange (the TGT is usually obtained when a client initially\n
    \  authenticates to the system, such as when a user logs in).  The\n   message
    format for the TGS exchange is almost identical to that for\n   the AS exchange.
    \ The primary difference is that encryption and\n   decryption in the TGS exchange
    does not take place under the client's\n   key.  Instead, the session key from
    the TGT or renewable ticket, or\n   sub-session key from an Authenticator is used.
    \ As is the case for\n   all application servers, expired tickets are not accepted
    by the TGS,\n   so once a renewable or TGT expires, the client must use a separate\n
    \  exchange to obtain valid tickets.\n   The TGS exchange consists of two messages:
    a request (KRB_TGS_REQ)\n   from the client to the Kerberos Ticket-Granting Server,
    and a reply\n   (KRB_TGS_REP or KRB_ERROR).  The KRB_TGS_REQ message includes\n
    \  information authenticating the client plus a request for credentials.\n   The
    authentication information consists of the authentication header\n   (KRB_AP_REQ),
    which includes the client's previously obtained\n   ticket-granting, renewable,
    or invalid ticket.  In the TGT and proxy\n   cases, the request MAY include one
    or more of the following: a list\n   of network addresses, a collection of typed
    authorization data to be\n   sealed in the ticket for authorization use by the
    application server,\n   or additional tickets (the use of which are described
    later).  The\n   TGS reply (KRB_TGS_REP) contains the requested credentials, encrypted\n
    \  in the session key from the TGT or renewable ticket, or, if present,\n   in
    the sub-session key from the Authenticator (part of the\n   authentication header).
    \ The KRB_ERROR message contains an error code\n   and text explaining what went
    wrong.  The KRB_ERROR message is not\n   encrypted.  The KRB_TGS_REP message contains
    information that can be\n   used to detect replays, and to associate it with the
    message to which\n   it replies.  The KRB_ERROR message also contains information
    that can\n   be used to associate it with the message to which it replies.  The\n
    \  same comments about integrity protection of KRB_ERROR messages\n   mentioned
    in Section 3.1 apply to the TGS exchange.\n"
  title: 3.3.  The Ticket-Granting Service (TGS) Exchange
- contents:
  - "3.3.1.  Generation of KRB_TGS_REQ Message\n   Before sending a request to the
    ticket-granting service, the client\n   MUST determine in which realm the application
    server is believed to\n   be registered.  This can be accomplished in several
    ways.  It might\n   be known beforehand (since the realm is part of the principal\n
    \  identifier), it might be stored in a nameserver, or it might be\n   obtained
    from a configuration file.  If the realm to be used is\n   obtained from a nameserver,
    there is a danger of being spoofed if the\n   nameservice providing the realm
    name is not authenticated.  This\n   might result in the use of a realm that has
    been compromised, which\n   would result in an attacker's ability to compromise
    the\n   authentication of the application server to the client.\n   If the client
    knows the service principal name and realm and it does\n   not already possess
    a TGT for the appropriate realm, then one must be\n   obtained.  This is first
    attempted by requesting a TGT for the\n   destination realm from a Kerberos server
    for which the client\n   possesses a TGT (by using the KRB_TGS_REQ message recursively).
    \ The\n   Kerberos server MAY return a TGT for the desired realm, in which case\n
    \  one can proceed.  Alternatively, the Kerberos server MAY return a TGT\n   for
    a realm that is 'closer' to the desired realm (further along the\n   standard
    hierarchical path between the client's realm and the\n   requested realm server's
    realm).  Note that in this case\n   misconfiguration of the Kerberos servers may
    cause loops in the\n   resulting authentication path, which the client should
    be careful to\n   detect and avoid.\n   If the Kerberos server returns a TGT for
    a realm 'closer' than the\n   desired realm, the client MAY use local policy configuration
    to\n   verify that the authentication path used is an acceptable one.\n   Alternatively,
    a client MAY choose its own authentication path,\n   rather than rely on the Kerberos
    server to select one.  In either\n   case, any policy or configuration information
    used to choose or\n   validate authentication paths, whether by the Kerberos server
    or by\n   the client, MUST be obtained from a trusted source.\n   When a client
    obtains a TGT that is 'closer' to the destination\n   realm, the client MAY cache
    this ticket and reuse it in future\n   KRB-TGS exchanges with services in the
    'closer' realm.  However, if\n   the client were to obtain a TGT for the 'closer'
    realm by starting at\n   the initial KDC rather than as part of obtaining another
    ticket, then\n   a shorter path to the 'closer' realm might be used.  This shorter\n
    \  path may be desirable because fewer intermediate KDCs would know the\n   session
    key of the ticket involved.  For this reason, clients SHOULD\n   evaluate whether
    they trust the realms transited in obtaining the\n   'closer' ticket when making
    a decision to use the ticket in future.\n   Once the client obtains a TGT for
    the appropriate realm, it\n   determines which Kerberos servers serve that realm
    and contacts one\n   of them.  The list might be obtained through a configuration
    file or\n   network service, or it MAY be generated from the name of the realm.\n
    \  As long as the secret keys exchanged by realms are kept secret, only\n   denial
    of service results from using a false Kerberos server.\n   As in the AS exchange,
    the client MAY specify a number of options in\n   the KRB_TGS_REQ message.  One
    of these options is the ENC-TKT-IN-SKEY\n   option used for user-to-user authentication.
    \ An overview of user-\n   to-user authentication can be found in Section 3.7.
    \ When generating\n   the KRB_TGS_REQ message, this option indicates that the
    client is\n   including a TGT obtained from the application server in the\n   additional
    tickets field of the request and that the KDC SHOULD\n   encrypt the ticket for
    the application server using the session key\n   from this additional ticket,
    instead of a server key from the\n   principal database.\n   The client prepares
    the KRB_TGS_REQ message, providing an\n   authentication header as an element
    of the padata field, and\n   including the same fields as used in the KRB_AS_REQ
    message along\n   with several optional fields: the enc-authorizatfion-data field
    for\n   application server use and additional tickets required by some\n   options.\n
    \  In preparing the authentication header, the client can select a sub-\n   session
    key under which the response from the Kerberos server will be\n   encrypted.  If
    the client selects a sub-session key, care must be\n   taken to ensure the randomness
    of the selected sub-session key.\n   If the sub-session key is not specified,
    the session key from the TGT\n   will be used.  If the enc-authorization-data
    is present, it MUST be\n   encrypted in the sub-session key, if present, from
    the authenticator\n   portion of the authentication header, or, if not present,
    by using\n   the session key from the TGT.\n   Once prepared, the message is sent
    to a Kerberos server for the\n   destination realm.\n"
  title: 3.3.1.  Generation of KRB_TGS_REQ Message
- contents:
  - "3.3.2.  Receipt of KRB_TGS_REQ Message\n   The KRB_TGS_REQ message is processed
    in a manner similar to the\n   KRB_AS_REQ message, but there are many additional
    checks to be\n   performed.  First, the Kerberos server MUST determine which server\n
    \  the accompanying ticket is for, and it MUST select the appropriate\n   key
    to decrypt it.  For a normal KRB_TGS_REQ message, it will be for\n   the ticket-granting
    service, and the TGS's key will be used.  If the\n   TGT was issued by another
    realm, then the appropriate inter-realm key\n   MUST be used.  If (a) the accompanying
    ticket is not a TGT for the\n   current realm, but is for an application server
    in the current realm,\n   (b) the RENEW, VALIDATE, or PROXY options are specified
    in the\n   request, and (c) the server for which a ticket is requested is the\n
    \  server named in the accompanying ticket, then the KDC will decrypt\n   the
    ticket in the authentication header using the key of the server\n   for which
    it was issued.  If no ticket can be found in the padata\n   field, the KDC_ERR_PADATA_TYPE_NOSUPP
    error is returned.\n   Once the accompanying ticket has been decrypted, the user-supplied\n
    \  checksum in the Authenticator MUST be verified against the contents\n   of
    the request, and the message MUST be rejected if the checksums do\n   not match
    (with an error code of KRB_AP_ERR_MODIFIED) or if the\n   checksum is not collision-proof
    (with an error code of\n   KRB_AP_ERR_INAPP_CKSUM).  If the checksum type is not
    supported, the\n   KDC_ERR_SUMTYPE_NOSUPP error is returned.  If the authorization-data\n
    \  are present, they are decrypted using the sub-session key from the\n   Authenticator.\n
    \  If any of the decryptions indicate failed integrity checks, the\n   KRB_AP_ERR_BAD_INTEGRITY
    error is returned.\n   As discussed in Section 3.1.2, the KDC MUST send a valid
    KRB_TGS_REP\n   message if it receives a KRB_TGS_REQ message identical to one
    it has\n   recently processed.  However, if the authenticator is a replay, but\n
    \  the rest of the request is not identical, then the KDC SHOULD return\n   KRB_AP_ERR_REPEAT.\n"
  title: 3.3.2.  Receipt of KRB_TGS_REQ Message
- contents:
  - "3.3.3.  Generation of KRB_TGS_REP Message\n   The KRB_TGS_REP message shares
    its format with the KRB_AS_REP\n   (KRB_KDC_REP), but with its type field set
    to KRB_TGS_REP.  The\n   detailed specification is in Section 5.4.2.\n   The response
    will include a ticket for the requested server or for a\n   ticket granting server
    of an intermediate KDC to be contacted to\n   obtain the requested ticket.  The
    Kerberos database is queried to\n   retrieve the record for the appropriate server
    (including the key\n   with which the ticket will be encrypted).  If the request
    is for a\n   TGT for a remote realm, and if no key is shared with the requested\n
    \  realm, then the Kerberos server will select the realm 'closest' to\n   the
    requested realm with which it does share a key and use that realm\n   instead.
    \ This is the only case where the response for the KDC will\n   be for a different
    server than that requested by the client.\n   By default, the address field, the
    client's name and realm, the list\n   of transited realms, the time of initial
    authentication, the\n   expiration time, and the authorization data of the newly-issued\n
    \  ticket will be copied from the TGT or renewable ticket.  If the\n   transited
    field needs to be updated, but the transited type is not\n   supported, the KDC_ERR_TRTYPE_NOSUPP
    error is returned.\n   If the request specifies an endtime, then the endtime of
    the new\n   ticket is set to the minimum of (a) that request, (b) the endtime\n
    \  from the TGT, and (c) the starttime of the TGT plus the minimum of\n   the
    maximum life for the application server and the maximum life for\n   the local
    realm (the maximum life for the requesting principal was\n   already applied when
    the TGT was issued).  If the new ticket is to be\n   a renewal, then the endtime
    above is replaced by the minimum of (a)\n   the value of the renew_till field
    of the ticket and (b) the starttime\n   for the new ticket plus the life (endtime-starttime)
    of the old\n   ticket.\n   If the FORWARDED option has been requested, then the
    resulting ticket\n   will contain the addresses specified by the client.  This
    option will\n   only be honored if the FORWARDABLE flag is set in the TGT.  The
    PROXY\n   option is similar; the resulting ticket will contain the addresses\n
    \  specified by the client.  It will be honored only if the PROXIABLE\n   flag
    in the TGT is set.  The PROXY option will not be honored on\n   requests for additional
    TGTs.\n   If the requested starttime is absent, indicates a time in the past,\n
    \  or is within the window of acceptable clock skew for the KDC and the\n   POSTDATE
    option has not been specified, then the starttime of the\n   ticket is set to
    the authentication server's current time.  If it\n   indicates a time in the future
    beyond the acceptable clock skew, but\n   the POSTDATED option has not been specified
    or the MAY-POSTDATE flag\n   is not set in the TGT, then the error KDC_ERR_CANNOT_POSTDATE
    is\n   returned.  Otherwise, if the TGT has the MAY-POSTDATE flag set, then\n
    \  the resulting ticket will be postdated, and the requested starttime\n   is
    checked against the policy of the local realm.  If acceptable, the\n   ticket's
    starttime is set as requested, and the INVALID flag is set.\n   The postdated
    ticket MUST be validated before use by presenting it to\n   the KDC after the
    starttime has been reached.  However, in no case\n   may the starttime, endtime,
    or renew-till time of a newly-issued\n   postdated ticket extend beyond the renew-till
    time of the TGT.\n   If the ENC-TKT-IN-SKEY option has been specified and an additional\n
    \  ticket has been included in the request, it indicates that the client\n   is
    using user-to-user authentication to prove its identity to a\n   server that does
    not have access to a persistent key.  Section 3.7\n   describes the effect of
    this option on the entire Kerberos protocol.\n   When generating the KRB_TGS_REP
    message, this option in the\n   KRB_TGS_REQ message tells the KDC to decrypt the
    additional ticket\n   using the key for the server to which the additional ticket
    was\n   issued and to verify that it is a TGT.  If the name of the requested\n
    \  server is missing from the request, the name of the client in the\n   additional
    ticket will be used.  Otherwise, the name of the requested\n   server will be
    compared to the name of the client in the additional\n   ticket.  If it is different,
    the request will be rejected.  If the\n   request succeeds, the session key from
    the additional ticket will be\n   used to encrypt the new ticket that is issued
    instead of using the\n   key of the server for which the new ticket will be used.\n
    \  If (a) the name of the server in the ticket that is presented to the\n   KDC
    as part of the authentication header is not that of the TGS\n   itself, (b) the
    server is registered in the realm of the KDC, and (c)\n   the RENEW option is
    requested, then the KDC will verify that the\n   RENEWABLE flag is set in the
    ticket, that the INVALID flag is not set\n   in the ticket, and that the renew_till
    time is still in the future.\n   If the VALIDATE option is requested, the KDC
    will check that the\n   starttime has passed and that the INVALID flag is set.
    \ If the PROXY\n   option is requested, then the KDC will check that the PROXIABLE
    flag\n   is set in the ticket.  If the tests succeed and the ticket passes the\n
    \  hotlist check described in the next section, the KDC will issue the\n   appropriate
    new ticket.\n   The ciphertext part of the response in the KRB_TGS_REP message
    is\n   encrypted in the sub-session key from the Authenticator, if present,\n
    \  or in the session key from the TGT.  It is not encrypted using the\n   client's
    secret key.  Furthermore, the client's key's expiration date\n   and the key version
    number fields are left out since these values are\n   stored along with the client's
    database record, and that record is\n   not needed to satisfy a request based
    on a TGT.\n"
  title: 3.3.3.  Generation of KRB_TGS_REP Message
- contents:
  - "3.3.3.1.  Checking for Revoked Tickets\n   Whenever a request is made to the
    ticket-granting server, the\n   presented ticket(s) is (are) checked against a
    hot-list of tickets\n   that have been canceled.  This hot-list might be implemented
    by\n   storing a range of issue timestamps for 'suspect tickets'; if a\n   presented
    ticket had an authtime in that range, it would be rejected.\n   In this way, a
    stolen TGT or renewable ticket cannot be used to gain\n   additional tickets (renewals
    or otherwise) once the theft has been\n   reported to the KDC for the realm in
    which the server resides.  Any\n   normal ticket obtained before it was reported
    stolen will still be\n   valid (because tickets require no interaction with the
    KDC), but only\n   until its normal expiration time.  If TGTs have been issued
    for\n   cross-realm authentication, use of the cross-realm TGT will not be\n   affected
    unless the hot-list is propagated to the KDCs for the realms\n   for which such
    cross-realm tickets were issued.\n"
  title: 3.3.3.1.  Checking for Revoked Tickets
- contents:
  - "3.3.3.2.  Encoding the Transited Field\n   If the identity of the server in the
    TGT that is presented to the KDC\n   as part of the authentication header is that
    of the ticket-granting\n   service, but the TGT was issued from another realm,
    the KDC will look\n   up the inter-realm key shared with that realm and use that
    key to\n   decrypt the ticket.  If the ticket is valid, then the KDC will honor\n
    \  the request, subject to the constraints outlined above in the section\n   describing
    the AS exchange.  The realm part of the client's identity\n   will be taken from
    the TGT.  The name of the realm that issued the\n   TGT, if it is not the realm
    of the client principal, will be added to\n   the transited field of the ticket
    to be issued.  This is accomplished\n   by reading the transited field from the
    TGT (which is treated as an\n   unordered set of realm names), adding the new
    realm to the set, and\n   then constructing and writing out its encoded (shorthand)
    form (this\n   may involve a rearrangement of the existing encoding).\n   Note
    that the ticket-granting service does not add the name of its\n   own realm.  Instead,
    its responsibility is to add the name of the\n   previous realm.  This prevents
    a malicious Kerberos server from\n   intentionally leaving out its own name (it
    could, however, omit other\n   realms' names).\n   The names of neither the local
    realm nor the principal's realm are to\n   be included in the transited field.
    \ They appear elsewhere in the\n   ticket and both are known to have taken part
    in authenticating the\n   principal.  Because the endpoints are not included,
    both local and\n   single-hop inter-realm authentication result in a transited
    field\n   that is empty.\n   Because this field has the name of each transited
    realm added to it,\n   it might potentially be very long.  To decrease the length
    of this\n   field, its contents are encoded.  The initially supported encoding
    is\n   optimized for the normal case of inter-realm communication: a\n   hierarchical
    arrangement of realms using either domain or X.500 style\n   realm names.  This
    encoding (called DOMAIN-X500-COMPRESS) is now\n   described.\n   Realm names in
    the transited field are separated by a \",\".  The \",\",\n   \"\\\", trailing
    \".\"s, and leading spaces (\" \") are special characters,\n   and if they are
    part of a realm name, they MUST be quoted in the\n   transited field by preceding
    them with a \"\\\".\n   A realm name ending with a \".\" is interpreted as being
    prepended to\n   the previous realm.  For example, we can encode traversal of
    EDU,\n   MIT.EDU, ATHENA.MIT.EDU, WASHINGTON.EDU, and CS.WASHINGTON.EDU as:\n
    \     \"EDU,MIT.,ATHENA.,WASHINGTON.EDU,CS.\".\n   Note that if either ATHENA.MIT.EDU,
    or CS.WASHINGTON.EDU were\n   endpoints, they would not be included in this field,
    and we would\n   have:\n      \"EDU,MIT.,WASHINGTON.EDU\"\n   A realm name beginning
    with a \"/\" is interpreted as being appended to\n   the previous realm.  For
    the purpose of appending, the realm\n   preceding the first listed realm is considered
    the null realm (\"\").\n   If a realm name beginning with a \"/\" is to stand
    by itself, then it\n   SHOULD be preceded by a space (\" \").  For example, we
    can encode\n   traversal of /COM/HP/APOLLO, /COM/HP, /COM, and /COM/DEC as:\n
    \     \"/COM,/HP,/APOLLO, /COM/DEC\".\n   As in the example above, if /COM/HP/APOLLO
    and /COM/DEC were\n   endpoints, they would not be included in this field, and
    we would\n   have:\n      \"/COM,/HP\"\n   A null subfield preceding or following
    a \",\" indicates that all\n   realms between the previous realm and the next
    realm have been\n   traversed.  For the purpose of interpreting null subfields,
    the\n   client's realm is considered to precede those in the transited field,\n
    \  and the server's realm is considered to follow them.  Thus, \",\" means\n   that
    all realms along the path between the client and the server have\n   been traversed.
    \ \",EDU, /COM,\" means that all realms from the\n   client's realm up to EDU
    (in a domain style hierarchy) have been\n   traversed, and that everything from
    /COM down to the server's realm\n   in an X.500 style has also been traversed.
    \ This could occur if the\n   EDU realm in one hierarchy shares an inter-realm
    key directly with\n   the /COM realm in another hierarchy.\n"
  title: 3.3.3.2.  Encoding the Transited Field
- contents:
  - "3.3.4.  Receipt of KRB_TGS_REP Message\n   When the KRB_TGS_REP is received by
    the client, it is processed in\n   the same manner as the KRB_AS_REP processing
    described above.  The\n   primary difference is that the ciphertext part of the
    response must\n   be decrypted using the sub-session key from the Authenticator,
    if it\n   was specified in the request, or the session key from the TGT, rather\n
    \  than the client's secret key.  The server name returned in the reply\n   is
    the true principal name of the service.\n"
  title: 3.3.4.  Receipt of KRB_TGS_REP Message
- contents:
  - "3.4.  The KRB_SAFE Exchange\n   The KRB_SAFE message MAY be used by clients requiring
    the ability to\n   detect modifications of messages they exchange.  It achieves
    this by\n   including a keyed collision-proof checksum of the user data and some\n
    \  control information.  The checksum is keyed with an encryption key\n   (usually
    the last key negotiated via subkeys, or the session key if\n   no negotiation
    has occurred).\n"
  title: 3.4.  The KRB_SAFE Exchange
- contents:
  - "3.4.1.  Generation of a KRB_SAFE Message\n   When an application wishes to send
    a KRB_SAFE message, it collects\n   its data and the appropriate control information
    and computes a\n   checksum over them.  The checksum algorithm should be the keyed\n
    \  checksum mandated to be implemented along with the crypto system used\n   for
    the sub-session or session key.  The checksum is generated using\n   the sub-session
    key, if present, or the session key.  Some\n   implementations use a different
    checksum algorithm for the KRB_SAFE\n   messages, but doing so in an interoperable
    manner is not always\n   possible.\n   The control information for the KRB_SAFE
    message includes both a\n   timestamp and a sequence number.  The designer of
    an application\n   using the KRB_SAFE message MUST choose at least one of the
    two\n   mechanisms.  This choice SHOULD be based on the needs of the\n   application
    protocol.\n   Sequence numbers are useful when all messages sent will be received\n
    \  by one's peer.  Connection state is presently required to maintain\n   the
    session key, so maintaining the next sequence number should not\n   present an
    additional problem.\n   If the application protocol is expected to tolerate lost
    messages\n   without their being resent, the use of the timestamp is the\n   appropriate
    replay detection mechanism.  Using timestamps is also the\n   appropriate mechanism
    for multi-cast protocols in which all of one's\n   peers share a common sub-session
    key, but some messages will be sent\n   to a subset of one's peers.\n   After
    computing the checksum, the client then transmits the\n   information and checksum
    to the recipient in the message format\n   specified in Section 5.6.1.\n"
  title: 3.4.1.  Generation of a KRB_SAFE Message
- contents:
  - "3.4.2.  Receipt of KRB_SAFE Message\n   When an application receives a KRB_SAFE
    message, it verifies it as\n   follows.  If any error occurs, an error code is
    reported for use by\n   the application.\n   The message is first checked by verifying
    that the protocol version\n   and type fields match the current version and KRB_SAFE,
    respectively.\n   A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE\n
    \  error.  The application verifies that the checksum used is a\n   collision-proof
    keyed checksum that uses keys compatible with the\n   sub-session or session key
    as appropriate (or with the application\n   key derived from the session or sub-session
    keys).  If it is not, a\n   KRB_AP_ERR_INAPP_CKSUM error is generated.  The sender's
    address MUST\n   be included in the control information; the recipient verifies
    that\n   the operating system's report of the sender's address matches the\n   sender's
    address in the message, and (if a recipient address is\n   specified or the recipient
    requires an address) that one of the\n   recipient's addresses appears as the
    recipient's address in the\n   message.  To work with network address translation,
    senders MAY use\n   the directional address type specified in Section 8.1 for
    the sender\n   address and not include recipient addresses.  A failed match for\n
    \  either case generates a KRB_AP_ERR_BADADDR error.  Then the timestamp\n   and
    usec and/or the sequence number fields are checked.  If timestamp\n   and usec
    are expected and not present, or if they are present but not\n   current, the
    KRB_AP_ERR_SKEW error is generated.  Timestamps are not\n   required to be strictly
    ordered; they are only required to be in the\n   skew window.  If the server name,
    along with the client name, time,\n   and microsecond fields from the Authenticator
    match any recently-seen\n   (sent or received) such tuples, the KRB_AP_ERR_REPEAT
    error is\n   generated.  If an incorrect sequence number is included, or if a\n
    \  sequence number is expected but not present, the KRB_AP_ERR_BADORDER\n   error
    is generated.  If neither a time-stamp and usec nor a sequence\n   number is present,
    a KRB_AP_ERR_MODIFIED error is generated.\n   Finally, the checksum is computed
    over the data and control\n   information, and if it doesn't match the received
    checksum, a\n   KRB_AP_ERR_MODIFIED error is generated.\n   If all the checks
    succeed, the application is assured that the\n   message was generated by its
    peer and was not modified in transit.\n   Implementations SHOULD accept any checksum
    algorithm they implement\n   that has both adequate security and keys compatible
    with the sub-\n   session or session key.  Unkeyed or non-collision-proof checksums
    are\n   not suitable for this use.\n"
  title: 3.4.2.  Receipt of KRB_SAFE Message
- contents:
  - "3.5.  The KRB_PRIV Exchange\n   The KRB_PRIV message MAY be used by clients requiring
    confidentiality\n   and the ability to detect modifications of exchanged messages.
    \ It\n   achieves this by encrypting the messages and adding control\n   information.\n"
  title: 3.5.  The KRB_PRIV Exchange
- contents:
  - "3.5.1.  Generation of a KRB_PRIV Message\n   When an application wishes to send
    a KRB_PRIV message, it collects\n   its data and the appropriate control information
    (specified in\n   Section 5.7.1) and encrypts them under an encryption key (usually
    the\n   last key negotiated via subkeys, or the session key if no negotiation\n
    \  has occurred).  As part of the control information, the client MUST\n   choose
    to use either a timestamp or a sequence number (or both); see\n   the discussion
    in Section 3.4.1 for guidelines on which to use.\n   After the user data and control
    information are encrypted, the client\n   transmits the ciphertext and some 'envelope'
    information to the\n   recipient.\n"
  title: 3.5.1.  Generation of a KRB_PRIV Message
- contents:
  - "3.5.2.  Receipt of KRB_PRIV Message\n   When an application receives a KRB_PRIV
    message, it verifies it as\n   follows.  If any error occurs, an error code is
    reported for use by\n   the application.\n   The message is first checked by verifying
    that the protocol version\n   and type fields match the current version and KRB_PRIV,
    respectively.\n   A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE\n
    \  error.  The application then decrypts the ciphertext and processes\n   the
    resultant plaintext.  If decryption shows that the data has been\n   modified,
    a KRB_AP_ERR_BAD_INTEGRITY error is generated.\n   The sender's address MUST be
    included in the control information; the\n   recipient verifies that the operating
    system's report of the sender's\n   address matches the sender's address in the
    message.  If a recipient\n   address is specified or the recipient requires an
    address, then one\n   of the recipient's addresses MUST also appear as the recipient's\n
    \  address in the message.  Where a sender's or receiver's address might\n   not
    otherwise match the address in a message because of network\n   address translation,
    an application MAY be written to use addresses\n   of the directional address
    type in place of the actual network\n   address.\n   A failed match for either
    case generates a KRB_AP_ERR_BADADDR error.\n   To work with network address translation,
    implementations MAY use the\n   directional address type defined in Section 7.1
    for the sender\n   address and include no recipient address.\n   Next the timestamp
    and usec and/or the sequence number fields are\n   checked.  If timestamp and
    usec are expected and not present, or if\n   they are present but not current,
    the KRB_AP_ERR_SKEW error is\n   generated.  If the server name, along with the
    client name, time, and\n   microsecond fields from the Authenticator match any
    such recently-\n   seen tuples, the KRB_AP_ERR_REPEAT error is generated.  If
    an\n   incorrect sequence number is included, or if a sequence number is\n   expected
    but not present, the KRB_AP_ERR_BADORDER error is generated.\n   If neither a
    time-stamp and usec nor a sequence number is present, a\n   KRB_AP_ERR_MODIFIED
    error is generated.\n   If all the checks succeed, the application can assume
    the message was\n   generated by its peer and was securely transmitted (without
    intruders\n   seeing the unencrypted contents).\n"
  title: 3.5.2.  Receipt of KRB_PRIV Message
- contents:
  - "3.6.  The KRB_CRED Exchange\n   The KRB_CRED message MAY be used by clients requiring
    the ability to\n   send Kerberos credentials from one host to another.  It achieves
    this\n   by sending the tickets together with encrypted data containing the\n
    \  session keys and other information associated with the tickets.\n"
  title: 3.6.  The KRB_CRED Exchange
- contents:
  - "3.6.1.  Generation of a KRB_CRED Message\n   When an application wishes to send
    a KRB_CRED message, it first\n   (using the KRB_TGS exchange) obtains credentials
    to be sent to the\n   remote host.  It then constructs a KRB_CRED message using
    the ticket\n   or tickets so obtained, placing the session key needed to use each\n
    \  ticket in the key field of the corresponding KrbCredInfo sequence of\n   the
    encrypted part of the KRB_CRED message.\n   Other information associated with
    each ticket and obtained during the\n   KRB_TGS exchange is also placed in the
    corresponding KrbCredInfo\n   sequence in the encrypted part of the KRB_CRED message.
    \ The current\n   time and, if they are specifically required by the application,
    the\n   nonce, s-address, and r-address fields are placed in the encrypted\n   part
    of the KRB_CRED message, which is then encrypted under an\n   encryption key previously
    exchanged in the KRB_AP exchange (usually\n   the last key negotiated via subkeys,
    or the session key if no\n   negotiation has occurred).\n   Implementation note:
    When constructing a KRB_CRED message for\n   inclusion in a GSSAPI initial context
    token, the MIT implementation\n   of Kerberos will not encrypt the KRB_CRED message
    if the session key\n   is a DES or triple DES key.  For interoperability with
    MIT, the\n   Microsoft implementation will not encrypt the KRB_CRED in a GSSAPI\n
    \  token if it is using a DES session key.  Starting at version 1.2.5,\n   MIT
    Kerberos can receive and decode either encrypted or unencrypted\n   KRB_CRED tokens
    in the GSSAPI exchange.  The Heimdal implementation\n   of Kerberos can also accept
    either encrypted or unencrypted KRB_CRED\n   messages.  Since the KRB_CRED message
    in a GSSAPI token is encrypted\n   in the authenticator, the MIT behavior does
    not present a security\n   problem, although it is a violation of the Kerberos
    specification.\n"
  title: 3.6.1.  Generation of a KRB_CRED Message
- contents:
  - "3.6.2.  Receipt of KRB_CRED Message\n   When an application receives a KRB_CRED
    message, it verifies it.  If\n   any error occurs, an error code is reported for
    use by the\n   application.  The message is verified by checking that the protocol\n
    \  version and type fields match the current version and KRB_CRED,\n   respectively.
    \ A mismatch generates a KRB_AP_ERR_BADVERSION or\n   KRB_AP_ERR_MSG_TYPE error.
    \ The application then decrypts the\n   ciphertext and processes the resultant
    plaintext.  If decryption\n   shows the data to have been modified, a KRB_AP_ERR_BAD_INTEGRITY\n
    \  error is generated.\n   If present or required, the recipient MAY verify that
    the operating\n   system's report of the sender's address matches the sender's
    address\n   in the message, and that one of the recipient's addresses appears
    as\n   the recipient's address in the message.  The address check does not\n   provide
    any added security, since the address, if present, has\n   already been checked
    in the KRB_AP_REQ message and there is not any\n   benefit to be gained by an
    attacker in reflecting a KRB_CRED message\n   back to its originator.  Thus, the
    recipient MAY ignore the address\n   even if it is present in order to work better
    in Network Address\n   Translation (NAT) environments.  A failed match for either
    case\n   generates a KRB_AP_ERR_BADADDR error.  Recipients MAY skip the\n   address
    check, as the KRB_CRED message cannot generally be reflected\n   back to the originator.
    \ The timestamp and usec fields (and the nonce\n   field, if required) are checked
    next.  If the timestamp and usec are\n   not present, or if they are present but
    not current, the\n   KRB_AP_ERR_SKEW error is generated.\n   If all the checks
    succeed, the application stores each of the new\n   tickets in its credentials
    cache together with the session key and\n   other information in the corresponding
    KrbCredInfo sequence from the\n   encrypted part of the KRB_CRED message.\n"
  title: 3.6.2.  Receipt of KRB_CRED Message
- contents:
  - "3.7.  User-to-User Authentication Exchanges\n   User-to-User authentication provides
    a method to perform\n   authentication when the verifier does not have a access
    to long-term\n   service key.  This might be the case when running a server (for\n
    \  example, a window server) as a user on a workstation.  In such cases,\n   the
    server may have access to the TGT obtained when the user logged\n   in to the
    workstation, but because the server is running as an\n   unprivileged user, it
    might not have access to system keys.  Similar\n   situations may arise when running
    peer-to-peer applications.\n                             Summary\n       Message
    direction                    Message type     Sections\n       0. Message from
    application server   Not specified\n       1. Client to Kerberos                KRB_TGS_REQ
    \     3.3 & 5.4.1\n       2. Kerberos to client                KRB_TGS_REP or
    \  3.3 & 5.4.2\n                                            KRB_ERROR        5.9.1\n
    \      3. Client to application server      KRB_AP_REQ       3.2 & 5.5.1\n   To
    address this problem, the Kerberos protocol allows the client to\n   request that
    the ticket issued by the KDC be encrypted using a\n   session key from a TGT issued
    to the party that will verify the\n   authentication.  This TGT must be obtained
    from the verifier by means\n   of an exchange external to the Kerberos protocol,
    usually as part of\n   the application protocol.  This message is shown in the
    summary above\n   as message 0.  Note that because the TGT is encrypted in the
    KDC's\n   secret key, it cannot be used for authentication without possession\n
    \  of the corresponding secret key.  Furthermore, because the verifier\n   does
    not reveal the corresponding secret key, providing a copy of the\n   verifier's
    TGT does not allow impersonation of the verifier.\n   Message 0 in the table above
    represents an application-specific\n   negotiation between the client and server,
    at the end of which both\n   have determined that they will use user-to-user authentication,
    and\n   the client has obtained the server's TGT.\n   Next, the client includes
    the server's TGT as an additional ticket in\n   its KRB_TGS_REQ request to the
    KDC (message 1 in the table above) and\n   specifies the ENC-TKT-IN-SKEY option
    in its request.\n   If validated according to the instructions in Section 3.3.3,
    the\n   application ticket returned to the client (message 2 in the table\n   above)
    will be encrypted using the session key from the additional\n   ticket and the
    client will note this when it uses or stores the\n   application ticket.\n   When
    contacting the server using a ticket obtained for user-to-user\n   authentication
    (message 3 in the table above), the client MUST\n   specify the USE-SESSION-KEY
    flag in the ap-options field.  This tells\n   the application server to use the
    session key associated with its TGT\n   to decrypt the server ticket provided
    in the application request.\n"
  title: 3.7.  User-to-User Authentication Exchanges
- contents:
  - "4.  Encryption and Checksum Specifications\n   The Kerberos protocols described
    in this document are designed to\n   encrypt messages of arbitrary sizes, using
    stream or block encryption\n   ciphers.  Encryption is used to prove the identities
    of the network\n   entities participating in message exchanges.  The Key Distribution\n
    \  Center for each realm is trusted by all principals registered in that\n   realm
    to store a secret key in confidence.  Proof of knowledge of\n   this secret key
    is used to verify the authenticity of a principal.\n   The KDC uses the principal's
    secret key (in the AS exchange) or a\n   shared session key (in the TGS exchange)
    to encrypt responses to\n   ticket requests; the ability to obtain the secret
    key or session key\n   implies the knowledge of the appropriate keys and the identity
    of the\n   KDC.  The ability of a principal to decrypt the KDC response and to\n
    \  present a Ticket and a properly formed Authenticator (generated with\n   the
    session key from the KDC response) to a service verifies the\n   identity of the
    principal; likewise the ability of the service to\n   extract the session key
    from the Ticket and to prove its knowledge\n   thereof in a response verifies
    the identity of the service.\n   [RFC3961] defines a framework for defining encryption
    and checksum\n   mechanisms for use with Kerberos.  It also defines several such\n
    \  mechanisms, and more may be added in future updates to that document.\n   The
    string-to-key operation provided by [RFC3961] is used to produce\n   a long-term
    key for a principal (generally for a user).  The default\n   salt string, if none
    is provided via pre-authentication data, is the\n   concatenation of the principal's
    realm and name components, in order,\n   with no separators.  Unless it is indicated
    otherwise, the default\n   string-to-key opaque parameter set as defined in [RFC3961]
    is used.\n   Encrypted data, keys, and checksums are transmitted using the\n   EncryptedData,
    EncryptionKey, and Checksum data objects defined in\n   Section 5.2.9.  The encryption,
    decryption, and checksum operations\n   described in this document use the corresponding
    encryption,\n   decryption, and get_mic operations described in [RFC3961], with\n
    \  implicit \"specific key\" generation using the \"key usage\" values\n   specified
    in the description of each EncryptedData or Checksum object\n   to vary the key
    for each operation.  Note that in some cases, the\n   value to be used is dependent
    on the method of choosing the key or\n   the context of the message.\n   Key usages
    are unsigned 32-bit integers; zero is not permitted.  The\n   key usage values
    for encrypting or checksumming Kerberos messages are\n   indicated in Section
    5 along with the message definitions.  The key\n   usage values 512-1023 are reserved
    for uses internal to a Kerberos\n   implementation.  (For example, seeding a pseudo-random
    number\n   generator with a value produced by encrypting something with a\n   session
    key and a key usage value not used for any other purpose.)\n   Key usage values
    between 1024 and 2047 (inclusive) are reserved for\n   application use; applications
    SHOULD use even values for encryption\n   and odd values for checksums within
    this range.  Key usage values are\n   also summarized in a table in Section 7.5.1.\n
    \  There might exist other documents that define protocols in terms of\n   the
    RFC 1510 encryption types or checksum types.  These documents\n   would not know
    about key usages.  In order that these specifications\n   continue to be meaningful
    until they are updated, if no key usage\n   values are specified, then key usages
    1024 and 1025 must be used to\n   derive keys for encryption and checksums, respectively.
    \ (This does\n   not apply to protocols that do their own encryption independent
    of\n   this framework, by directly using the key resulting from the Kerberos\n
    \  authentication exchange.)  New protocols defined in terms of the\n   Kerberos
    encryption and checksum types SHOULD use their own key usage\n   values.\n   Unless
    it is indicated otherwise, no cipher state chaining is done\n   from one encryption
    operation to another.\n   Implementation note: Although it is not recommended,
    some application\n   protocols will continue to use the key data directly, even
    if only in\n   currently existing protocol specifications.  An implementation\n
    \  intended to support general Kerberos applications may therefore need\n   to
    make key data available, as well as the attributes and operations\n   described
    in [RFC3961].  One of the more common reasons for directly\n   performing encryption
    is direct control over negotiation and\n   selection of a \"sufficiently strong\"
    encryption algorithm (in the\n   context of a given application).  Although Kerberos
    does not directly\n   provide a facility for negotiating encryption types between
    the\n   application client and server, there are approaches for using\n   Kerberos
    to facilitate this negotiation.  For example, a client may\n   request only \"sufficiently
    strong\" session key types from the KDC and\n   expect that any type returned
    by the KDC will be understood and\n   supported by the application server.\n"
  title: 4.  Encryption and Checksum Specifications
- contents:
  - "5.  Message Specifications\n   The ASN.1 collected here should be identical to
    the contents of\n   Appendix A.  In the case of a conflict, the contents of Appendix
    A\n   shall take precedence.\n   The Kerberos protocol is defined here in terms
    of Abstract Syntax\n   Notation One (ASN.1) [X680], which provides a syntax for
    specifying\n   both the abstract layout of protocol messages as well as their\n
    \  encodings.  Implementors not utilizing an existing ASN.1 compiler or\n   support
    library are cautioned to understand the actual ASN.1\n   specification thoroughly
    in order to ensure correct implementation\n   behavior.  There is more complexity
    in the notation than is\n   immediately obvious, and some tutorials and guides
    to ASN.1 are\n   misleading or erroneous.\n   Note that in several places, changes
    to abstract types from RFC 1510\n   have been made.  This is in part to address
    widespread assumptions\n   that various implementors have made, in some cases
    resulting in\n   unintentional violations of the ASN.1 standard.  These are clearly\n
    \  flagged where they occur.  The differences between the abstract types\n   in
    RFC 1510 and abstract types in this document can cause\n   incompatible encodings
    to be emitted when certain encoding rules,\n   e.g., the Packed Encoding Rules
    (PER), are used.  This theoretical\n   incompatibility should not be relevant
    for Kerberos, since Kerberos\n   explicitly specifies the use of the Distinguished
    Encoding Rules\n   (DER).  It might be an issue for protocols seeking to use Kerberos\n
    \  types with other encoding rules.  (This practice is not recommended.)\n   With
    very few exceptions (most notably the usages of BIT STRING), the\n   encodings
    resulting from using the DER remain identical between the\n   types defined in
    RFC 1510 and the types defined in this document.\n   The type definitions in this
    section assume an ASN.1 module\n   definition of the following form:\n   KerberosV5Spec2
    {\n           iso(1) identified-organization(3) dod(6) internet(1)\n           security(5)
    kerberosV5(2) modules(4) krb5spec2(2)\n   } DEFINITIONS EXPLICIT TAGS ::= BEGIN\n
    \  -- rest of definitions here\n   END\n   This specifies that the tagging context
    for the module will be\n   explicit and non-automatic.\n   Note that in some other
    publications (such as [RFC1510] and\n   [RFC1964]), the \"dod\" portion of the
    object identifier is erroneously\n   specified as having the value \"5\".  In
    the case of RFC 1964, use of\n   the \"correct\" OID value would result in a change
    in the wire\n   protocol; therefore, it remains unchanged for now.\n   Note that
    elsewhere in this document, nomenclature for various\n   message types is inconsistent,
    but it largely follows C language\n   conventions, including use of underscore
    (_) characters and all-caps\n   spelling of names intended to be numeric constants.
    \ Also, in some\n   places, identifiers (especially those referring to constants)
    are\n   written in all-caps in order to distinguish them from surrounding\n   explanatory
    text.\n   The ASN.1 notation does not permit underscores in identifiers, so in\n
    \  actual ASN.1 definitions, underscores are replaced with hyphens (-).\n   Additionally,
    structure member names and defined values in ASN.1 MUST\n   begin with a lowercase
    letter, whereas type names MUST begin with an\n   uppercase letter.\n"
  title: 5.  Message Specifications
- contents:
  - "5.1.  Specific Compatibility Notes on ASN.1\n   For compatibility purposes, implementors
    should heed the following\n   specific notes regarding the use of ASN.1 in Kerberos.
    \ These notes\n   do not describe deviations from standard usage of ASN.1.  The
    purpose\n   of these notes is instead to describe some historical quirks and\n
    \  non-compliance of various implementations, as well as historical\n   ambiguities,
    which, although they are valid ASN.1, can lead to\n   confusion during implementation.\n"
  title: 5.1.  Specific Compatibility Notes on ASN.1
- contents:
  - "5.1.1.  ASN.1 Distinguished Encoding Rules\n   The encoding of Kerberos protocol
    messages shall obey the\n   Distinguished Encoding Rules (DER) of ASN.1 as described
    in [X690].\n   Some implementations (believed primarily to be those derived from
    DCE\n   1.1 and earlier) are known to use the more general Basic Encoding\n   Rules
    (BER); in particular, these implementations send indefinite\n   encodings of lengths.
    \ Implementations MAY accept such encodings in\n   the interest of backward compatibility,
    though implementors are\n   warned that decoding fully-general BER is fraught
    with peril.\n"
  title: 5.1.1.  ASN.1 Distinguished Encoding Rules
- contents:
  - "5.1.2.  Optional Integer Fields\n   Some implementations do not internally distinguish
    between an omitted\n   optional integer value and a transmitted value of zero.
    \ The places\n   in the protocol where this is relevant include various microseconds\n
    \  fields, nonces, and sequence numbers.  Implementations SHOULD treat\n   omitted
    optional integer values as having been transmitted with a\n   value of zero, if
    the application is expecting this.\n"
  title: 5.1.2.  Optional Integer Fields
- contents:
  - "5.1.3.  Empty SEQUENCE OF Types\n   There are places in the protocol where a
    message contains a SEQUENCE\n   OF type as an optional member.  This can result
    in an encoding that\n   contains an empty SEQUENCE OF encoding.  The Kerberos
    protocol does\n   not semantically distinguish between an absent optional SEQUENCE
    OF\n   type and a present optional but empty SEQUENCE OF type.\n   Implementations
    SHOULD NOT send empty SEQUENCE OF encodings that are\n   marked OPTIONAL, but
    SHOULD accept them as being equivalent to an\n   omitted OPTIONAL type.  In the
    ASN.1 syntax describing Kerberos\n   messages, instances of these problematic
    optional SEQUENCE OF types\n   are indicated with a comment.\n"
  title: 5.1.3.  Empty SEQUENCE OF Types
- contents:
  - "5.1.4.  Unrecognized Tag Numbers\n   Future revisions to this protocol may include
    new message types with\n   different APPLICATION class tag numbers.  Such revisions
    should\n   protect older implementations by only sending the message types to\n
    \  parties that are known to understand them; e.g., by means of a flag\n   bit
    set by the receiver in a preceding request.  In the interest of\n   robust error
    handling, implementations SHOULD gracefully handle\n   receiving a message with
    an unrecognized tag anyway, and return an\n   error message, if appropriate.\n
    \  In particular, KDCs SHOULD return KRB_AP_ERR_MSG_TYPE if the\n   incorrect
    tag is sent over a TCP transport.  The KDCs SHOULD NOT\n   respond to messages
    received with an unknown tag over UDP transport\n   in order to avoid denial of
    service attacks.  For non-KDC\n   applications, the Kerberos implementation typically
    indicates an\n   error to the application which takes appropriate steps based
    on the\n   application protocol.\n"
  title: 5.1.4.  Unrecognized Tag Numbers
- contents:
  - "5.1.5.  Tag Numbers Greater Than 30\n   A naive implementation of a DER ASN.1
    decoder may experience problems\n   with ASN.1 tag numbers greater than 30, due
    to such tag numbers being\n   encoded using more than one byte.  Future revisions
    of this protocol\n   may utilize tag numbers greater than 30, and implementations
    SHOULD\n   be prepared to gracefully return an error, if appropriate, when they\n
    \  do not recognize the tag.\n"
  title: 5.1.5.  Tag Numbers Greater Than 30
- contents:
  - "5.2.  Basic Kerberos Types\n   This section defines a number of basic types that
    are potentially\n   used in multiple Kerberos protocol messages.\n"
  title: 5.2.  Basic Kerberos Types
- contents:
  - "5.2.1.  KerberosString\n   The original specification of the Kerberos protocol
    in RFC 1510 uses\n   GeneralString in numerous places for human-readable string
    data.\n   Historical implementations of Kerberos cannot utilize the full power\n
    \  of GeneralString.  This ASN.1 type requires the use of designation\n   and
    invocation escape sequences as specified in ISO-2022/ECMA-35\n   [ISO-2022/ECMA-35]
    to switch character sets, and the default\n   character set that is designated
    as G0 is the ISO-646/ECMA-6\n   [ISO-646/ECMA-6] International Reference Version
    (IRV) (a.k.a. U.S.\n   ASCII), which mostly works.\n   ISO-2022/ECMA-35 defines
    four character-set code elements (G0..G3)\n   and two Control-function code elements
    (C0..C1).  DER prohibits the\n   designation of character sets as any but the
    G0 and C0 sets.\n   Unfortunately, this seems to have the side effect of prohibiting
    the\n   use of ISO-8859 (ISO Latin) [ISO-8859] character sets or any other\n   character
    sets that utilize a 96-character set, as ISO-2022/ECMA-35\n   prohibits designating
    them as the G0 code element.  This side effect\n   is being investigated in the
    ASN.1 standards community.\n   In practice, many implementations treat GeneralStrings
    as if they\n   were 8-bit strings of whichever character set the implementation\n
    \  defaults to, without regard to correct usage of character-set\n   designation
    escape sequences.  The default character set is often\n   determined by the current
    user's operating system-dependent locale.\n   At least one major implementation
    places unescaped UTF-8 encoded\n   Unicode characters in the GeneralString.  This
    failure to adhere to\n   the GeneralString specifications results in interoperability
    issues\n   when conflicting character encodings are utilized by the Kerberos\n
    \  clients, services, and KDC.\n   This unfortunate situation is the result of
    improper documentation of\n   the restrictions of the ASN.1 GeneralString type
    in prior Kerberos\n   specifications.\n   The new (post-RFC 1510) type KerberosString,
    defined below, is a\n   GeneralString that is constrained to contain only characters
    in\n   IA5String.\n      KerberosString  ::= GeneralString (IA5String)\n   In
    general, US-ASCII control characters should not be used in\n   KerberosString.
    \ Control characters SHOULD NOT be used in principal\n   names or realm names.\n
    \  For compatibility, implementations MAY choose to accept GeneralString\n   values
    that contain characters other than those permitted by\n   IA5String, but they
    should be aware that character set designation\n   codes will likely be absent,
    and that the encoding should probably be\n   treated as locale-specific in almost
    every way.  Implementations MAY\n   also choose to emit GeneralString values that
    are beyond those\n   permitted by IA5String, but they should be aware that doing
    so is\n   extraordinarily risky from an interoperability perspective.\n   Some
    existing implementations use GeneralString to encode unescaped\n   locale-specific
    characters.  This is a violation of the ASN.1\n   standard.  Most of these implementations
    encode US-ASCII in the\n   left-hand half, so as long as the implementation transmits
    only\n   US-ASCII, the ASN.1 standard is not violated in this regard.  As soon\n
    \  as such an implementation encodes unescaped locale-specific\n   characters
    with the high bit set, it violates the ASN.1 standard.\n   Other implementations
    have been known to use GeneralString to contain\n   a UTF-8 encoding.  This also
    violates the ASN.1 standard, since UTF-8\n   is a different encoding, not a 94
    or 96 character \"G\" set as defined\n   by ISO 2022.  It is believed that these
    implementations do not even\n   use the ISO 2022 escape sequence to change the
    character encoding.\n   Even if implementations were to announce the encoding
    change by using\n   that escape sequence, the ASN.1 standard prohibits the use
    of any\n   escape sequences other than those used to designate/invoke \"G\" or
    \"C\"\n   sets allowed by GeneralString.\n   Future revisions to this protocol
    will almost certainly allow for a\n   more interoperable representation of principal
    names, probably\n   including UTF8String.\n   Note that applying a new constraint
    to a previously unconstrained\n   type constitutes creation of a new ASN.1 type.
    \ In this particular\n   case, the change does not result in a changed encoding
    under DER.\n"
  title: 5.2.1.  KerberosString
- contents:
  - "5.2.2.  Realm and PrincipalName\n   Realm           ::= KerberosString\n   PrincipalName
    \  ::= SEQUENCE {\n           name-type       [0] Int32,\n           name-string
    \    [1] SEQUENCE OF KerberosString\n   }\n   Kerberos realm names are encoded
    as KerberosStrings.  Realms shall\n   not contain a character with the code 0
    (the US-ASCII NUL).  Most\n   realms will usually consist of several components
    separated by\n   periods (.), in the style of Internet Domain Names, or separated
    by\n   slashes (/), in the style of X.500 names.  Acceptable forms for realm\n
    \  names are specified in Section 6.1.  A PrincipalName is a typed\n   sequence
    of components consisting of the following subfields:\n   name-type\n      This
    field specifies the type of name that follows.  Pre-defined\n      values for
    this field are specified in Section 6.2.  The name-type\n      SHOULD be treated
    as a hint.  Ignoring the name type, no two names\n      can be the same (i.e.,
    at least one of the components, or the\n      realm, must be different).\n   name-string\n
    \     This field encodes a sequence of components that form a name, each\n      component
    encoded as a KerberosString.  Taken together, a\n      PrincipalName and a Realm
    form a principal identifier.  Most\n      PrincipalNames will have only a few
    components (typically one or\n      two).\n"
  title: 5.2.2.  Realm and PrincipalName
- contents:
  - "5.2.3.  KerberosTime\n   KerberosTime    ::= GeneralizedTime -- with no fractional
    seconds\n   The timestamps used in Kerberos are encoded as GeneralizedTimes.  A\n
    \  KerberosTime value shall not include any fractional portions of the\n   seconds.
    \ As required by the DER, it further shall not include any\n   separators, and
    it shall specify the UTC time zone (Z).  Example: The\n   only valid format for
    UTC time 6 minutes, 27 seconds after 9 pm on 6\n   November 1985 is 19851106210627Z.\n"
  title: 5.2.3.  KerberosTime
- contents:
  - "5.2.4.  Constrained Integer Types\n   Some integer members of types SHOULD be
    constrained to values\n   representable in 32 bits, for compatibility with reasonable\n
    \  implementation limits.\n   Int32           ::= INTEGER (-2147483648..2147483647)\n
    \                      -- signed values representable in 32 bits\n   UInt32          ::=
    INTEGER (0..4294967295)\n                       -- unsigned 32 bit values\n   Microseconds
    \   ::= INTEGER (0..999999)\n                       -- microseconds\n   Although
    this results in changes to the abstract types from the RFC\n   1510 version, the
    encoding in DER should be unaltered.  Historical\n   implementations were typically
    limited to 32-bit integer values\n   anyway, and assigned numbers SHOULD fall
    in the space of integer\n   values representable in 32 bits in order to promote
    interoperability\n   anyway.\n   Several integer fields in messages are constrained
    to fixed values.\n   pvno\n      also TKT-VNO or AUTHENTICATOR-VNO, this recurring
    field is always\n      the constant integer 5.  There is no easy way to make this
    field\n      into a useful protocol version number, so its value is fixed.\n   msg-type\n
    \     this integer field is usually identical to the application tag\n      number
    of the containing message type.\n"
  title: 5.2.4.  Constrained Integer Types
- contents:
  - "5.2.5.  HostAddress and HostAddresses\n   HostAddress     ::= SEQUENCE  {\n           addr-type
    \      [0] Int32,\n           address         [1] OCTET STRING\n   }\n   -- NOTE:
    HostAddresses is always used as an OPTIONAL field and\n   -- should not be empty.\n
    \  HostAddresses   -- NOTE: subtly different from rfc1510,\n                   --
    but has a value mapping and encodes the same\n           ::= SEQUENCE OF HostAddress\n
    \  The host address encodings consist of two fields:\n   addr-type\n      This
    field specifies the type of address that follows.  Pre-\n      defined values
    for this field are specified in Section 7.5.3.\n   address\n      This field encodes
    a single address of type addr-type.\n"
  title: 5.2.5.  HostAddress and HostAddresses
- contents:
  - "5.2.6.  AuthorizationData\n      -- NOTE: AuthorizationData is always used as
    an OPTIONAL field and\n      -- should not be empty.\n      AuthorizationData
    \      ::= SEQUENCE OF SEQUENCE {\n              ad-type         [0] Int32,\n
    \             ad-data         [1] OCTET STRING\n      }\n   ad-data\n      This
    field contains authorization data to be interpreted according\n      to the value
    of the corresponding ad-type field.\n   ad-type\n      This field specifies the
    format for the ad-data subfield.  All\n      negative values are reserved for
    local use.  Non-negative values\n      are reserved for registered use.\n   Each
    sequence of type and data is referred to as an authorization\n   element.  Elements
    MAY be application specific; however, there is a\n   common set of recursive elements
    that should be understood by all\n   implementations.  These elements contain
    other elements embedded\n   within them, and the interpretation of the encapsulating
    element\n   determines which of the embedded elements must be interpreted, and\n
    \  which may be ignored.\n   These common authorization data elements are recursively
    defined,\n   meaning that the ad-data for these types will itself contain a\n
    \  sequence of authorization data whose interpretation is affected by\n   the
    encapsulating element.  Depending on the meaning of the\n   encapsulating element,
    the encapsulated elements may be ignored,\n   might be interpreted as issued directly
    by the KDC, or might be\n   stored in a separate plaintext part of the ticket.
    \ The types of the\n   encapsulating elements are specified as part of the Kerberos\n
    \  specification because the behavior based on these values should be\n   understood
    across implementations, whereas other elements need only\n   be understood by
    the applications that they affect.\n   Authorization data elements are considered
    critical if present in a\n   ticket or authenticator.  If an unknown authorization
    data element\n   type is received by a server either in an AP-REQ or in a ticket\n
    \  contained in an AP-REQ, then, unless it is encapsulated in a known\n   authorization
    data element amending the criticality of the elements\n   it contains, authentication
    MUST fail.  Authorization data is\n   intended to restrict the use of a ticket.
    \ If the service cannot\n   determine whether the restriction applies to that
    service, then a\n   security weakness may result if the ticket can be used for
    that\n   service.  Authorization elements that are optional can be enclosed in\n
    \  an AD-IF-RELEVANT element.\n   In the definitions that follow, the value of
    the ad-type for the\n   element will be specified as the least significant part
    of the\n   subsection number, and the value of the ad-data will be as shown in\n
    \  the ASN.1 structure that follows the subsection heading.\n   Contents of ad-data
    \               ad-type\n   DER encoding of AD-IF-RELEVANT        1\n   DER encoding
    of AD-KDCIssued          4\n   DER encoding of AD-AND-OR             5\n   DER
    encoding of AD-MANDATORY-FOR-KDC  8\n"
  title: 5.2.6.  AuthorizationData
- contents:
  - "5.2.6.1.  IF-RELEVANT\n   AD-IF-RELEVANT          ::= AuthorizationData\n   AD
    elements encapsulated within the if-relevant element are intended\n   for interpretation
    only by application servers that understand the\n   particular ad-type of the
    embedded element.  Application servers that\n   do not understand the type of
    an element embedded within the\n   if-relevant element MAY ignore the uninterpretable
    element.  This\n   element promotes interoperability across implementations that
    may\n   have local extensions for authorization.  The ad-type for\n   AD-IF-RELEVANT
    is (1).\n"
  title: 5.2.6.1.  IF-RELEVANT
- contents:
  - "5.2.6.2.  KDCIssued\n   AD-KDCIssued            ::= SEQUENCE {\n           ad-checksum
    \    [0] Checksum,\n           i-realm         [1] Realm OPTIONAL,\n           i-sname
    \        [2] PrincipalName OPTIONAL,\n           elements        [3] AuthorizationData\n
    \  }\n   ad-checksum\n      A cryptographic checksum computed over the DER encoding
    of the\n      AuthorizationData in the \"elements\" field, keyed with the session\n
    \     key.  Its checksumtype is the mandatory checksum type for the\n      encryption
    type of the session key, and its key usage value is 19.\n   i-realm, i-sname\n
    \     The name of the issuing principal if different from that of the\n      KDC
    itself.  This field would be used when the KDC can verify the\n      authenticity
    of elements signed by the issuing principal, and it\n      allows this KDC to
    notify the application server of the validity\n      of those elements.\n   elements\n
    \     A sequence of authorization data elements issued by the KDC.\n   The KDC-issued
    ad-data field is intended to provide a means for\n   Kerberos principal credentials
    to embed within themselves privilege\n   attributes and other mechanisms for positive
    authorization,\n   amplifying the privileges of the principal beyond what can
    be done\n   using credentials without such an a-data element.\n   The above means
    cannot be provided without this element because the\n   definition of the authorization-data
    field allows elements to be\n   added at will by the bearer of a TGT at the time
    when they request\n   service tickets, and elements may also be added to a delegated
    ticket\n   by inclusion in the authenticator.\n   For KDC-issued elements, this
    is prevented because the elements are\n   signed by the KDC by including a checksum
    encrypted using the\n   server's key (the same key used to encrypt the ticket
    or a key\n   derived from that key).  Elements encapsulated with in the KDC-issued\n
    \  element MUST be ignored by the application server if this \"signature\"\n   is
    not present.  Further, elements encapsulated within this element\n   from a TGT
    MAY be interpreted by the KDC, and used as a basis\n   according to policy for
    including new signed elements within\n   derivative tickets, but they will not
    be copied to a derivative\n   ticket directly.  If they are copied directly to
    a derivative ticket\n   by a KDC that is not aware of this element, the signature
    will not be\n   correct for the application ticket elements, and the field will
    be\n   ignored by the application server.\n   This element and the elements it
    encapsulates MAY safely be ignored\n   by applications, application servers, and
    KDCs that do not implement\n   this element.\n   The ad-type for AD-KDC-ISSUED
    is (4).\n"
  title: 5.2.6.2.  KDCIssued
- contents:
  - "5.2.6.3.  AND-OR\n   AD-AND-OR               ::= SEQUENCE {\n           condition-count
    [0] Int32,\n           elements        [1] AuthorizationData\n   }\n   When restrictive
    AD elements are encapsulated within the and-or\n   element, the and-or element
    is considered satisfied if and only if at\n   least the number of encapsulated
    elements specified in condition-\n   count are satisfied.  Therefore, this element
    MAY be used to\n   implement an \"or\" operation by setting the condition-count
    field to\n   1, and it MAY specify an \"and\" operation by setting the condition\n
    \  count to the number of embedded elements.  Application servers that\n   do
    not implement this element MUST reject tickets that contain\n   authorization
    data elements of this type.\n   The ad-type for AD-AND-OR is (5).\n"
  title: 5.2.6.3.  AND-OR
- contents:
  - "5.2.6.4.  MANDATORY-FOR-KDC\n   AD-MANDATORY-FOR-KDC    ::= AuthorizationData\n
    \  AD elements encapsulated within the mandatory-for-kdc element are to\n   be
    interpreted by the KDC.  KDCs that do not understand the type of\n   an element
    embedded within the mandatory-for-kdc element MUST reject\n   the request.\n   The
    ad-type for AD-MANDATORY-FOR-KDC is (8).\n"
  title: 5.2.6.4.  MANDATORY-FOR-KDC
- contents:
  - "5.2.7.  PA-DATA\n   Historically, PA-DATA have been known as \"pre-authentication
    data\",\n   meaning that they were used to augment the initial authentication\n
    \  with the KDC.  Since that time, they have also been used as a typed\n   hole
    with which to extend protocol exchanges with the KDC.\n   PA-DATA         ::=
    SEQUENCE {\n           -- NOTE: first tag is [1], not [0]\n           padata-type
    \    [1] Int32,\n           padata-value    [2] OCTET STRING -- might be encoded
    AP-REQ\n   }\n   padata-type\n      Indicates the way that the padata-value element
    is to be\n      interpreted.  Negative values of padata-type are reserved for\n
    \     unregistered use; non-negative values are used for a registered\n      interpretation
    of the element type.\n   padata-value\n      Usually contains the DER encoding
    of another type; the padata-type\n      field identifies which type is encoded
    here.\n      padata-type  Name             Contents of padata-value\n      1            pa-tgs-req
    \      DER encoding of AP-REQ\n      2            pa-enc-timestamp DER encoding
    of PA-ENC-TIMESTAMP\n      3            pa-pw-salt       salt (not ASN.1 encoded)\n
    \     11           pa-etype-info    DER encoding of ETYPE-INFO\n      19           pa-etype-info2
    \  DER encoding of ETYPE-INFO2\n      This field MAY also contain information
    needed by certain\n      extensions to the Kerberos protocol.  For example, it
    might be\n      used to verify the identity of a client initially before any\n
    \     response is returned.\n      The padata field can also contain information
    needed to help the\n      KDC or the client select the key needed for generating
    or\n      decrypting the response.  This form of the padata is useful for\n      supporting
    the use of certain token cards with Kerberos.  The\n      details of such extensions
    are specified in separate documents.\n      See [Pat92] for additional uses of
    this field.\n"
  title: 5.2.7.  PA-DATA
- contents:
  - "5.2.7.1.  PA-TGS-REQ\n   In the case of requests for additional tickets (KRB_TGS_REQ),\n
    \  padata-value will contain an encoded AP-REQ.  The checksum in the\n   authenticator
    (which MUST be collision-proof) is to be computed over\n   the KDC-REQ-BODY encoding.\n"
  title: 5.2.7.1.  PA-TGS-REQ
- contents:
  - "5.2.7.2.  Encrypted Timestamp Pre-authentication\n   There are pre-authentication
    types that may be used to pre-\n   authenticate a client by means of an encrypted
    timestamp.\n   PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC\n   PA-ENC-TS-ENC
    \          ::= SEQUENCE {\n           patimestamp     [0] KerberosTime -- client's
    time --,\n           pausec          [1] Microseconds OPTIONAL\n   }\n   Patimestamp
    contains the client's time, and pausec contains the\n   microseconds, which MAY
    be omitted if a client will not generate more\n   than one request per second.
    \ The ciphertext (padata-value) consists\n   of the PA-ENC-TS-ENC encoding, encrypted
    using the client's secret\n   key and a key usage value of 1.\n   This pre-authentication
    type was not present in RFC 1510, but many\n   implementations support it.\n"
  title: 5.2.7.2.  Encrypted Timestamp Pre-authentication
- contents:
  - "5.2.7.3.  PA-PW-SALT\n   The padata-value for this pre-authentication type contains
    the salt\n   for the string-to-key to be used by the client to obtain the key
    for\n   decrypting the encrypted part of an AS-REP message.  Unfortunately,\n
    \  for historical reasons, the character set to be used is unspecified\n   and
    probably locale-specific.\n   This pre-authentication type was not present in
    RFC 1510, but many\n   implementations support it.  It is necessary in any case
    where the\n   salt for the string-to-key algorithm is not the default.\n   In
    the trivial example, a zero-length salt string is very commonplace\n   for realms
    that have converted their principal databases from\n   Kerberos Version 4.\n   A
    KDC SHOULD NOT send PA-PW-SALT when issuing a KRB-ERROR message\n   that requests
    additional pre-authentication.  Implementation note:\n   Some KDC implementations
    issue an erroneous PA-PW-SALT when issuing a\n   KRB-ERROR message that requests
    additional pre-authentication.\n   Therefore, clients SHOULD ignore a PA-PW-SALT
    accompanying a\n   KRB-ERROR message that requests additional pre-authentication.
    \ As\n   noted in section 3.1.3, a KDC MUST NOT send PA-PW-SALT when the\n   client's
    AS-REQ includes at least one \"newer\" etype.\n"
  title: 5.2.7.3.  PA-PW-SALT
- contents:
  - "5.2.7.4.  PA-ETYPE-INFO\n   The ETYPE-INFO pre-authentication type is sent by
    the KDC in a\n   KRB-ERROR indicating a requirement for additional pre-authentication.\n
    \  It is usually used to notify a client of which key to use for the\n   encryption
    of an encrypted timestamp for the purposes of sending a\n   PA-ENC-TIMESTAMP pre-authentication
    value.  It MAY also be sent in an\n   AS-REP to provide information to the client
    about which key salt to\n   use for the string-to-key to be used by the client
    to obtain the key\n   for decrypting the encrypted part the AS-REP.\n   ETYPE-INFO-ENTRY
    \       ::= SEQUENCE {\n           etype           [0] Int32,\n           salt
    \           [1] OCTET STRING OPTIONAL\n   }\n   ETYPE-INFO              ::= SEQUENCE
    OF ETYPE-INFO-ENTRY\n   The salt, like that of PA-PW-SALT, is also completely
    unspecified\n   with respect to character set and is probably locale-specific.\n
    \  If ETYPE-INFO is sent in an AS-REP, there shall be exactly one\n   ETYPE-INFO-ENTRY,
    and its etype shall match that of the enc-part in\n   the AS-REP.\n   This pre-authentication
    type was not present in RFC 1510, but many\n   implementations that support encrypted
    timestamps for pre-\n   authentication need to support ETYPE-INFO as well.  As
    noted in\n   Section 3.1.3, a KDC MUST NOT send PA-ETYPE-INFO when the client's\n
    \  AS-REQ includes at least one \"newer\" etype.\n"
  title: 5.2.7.4.  PA-ETYPE-INFO
- contents:
  - "5.2.7.5.  PA-ETYPE-INFO2\n   The ETYPE-INFO2 pre-authentication type is sent
    by the KDC in a\n   KRB-ERROR indicating a requirement for additional pre-authentication.\n
    \  It is usually used to notify a client of which key to use for the\n   encryption
    of an encrypted timestamp for the purposes of sending a\n   PA-ENC-TIMESTAMP pre-authentication
    value.  It MAY also be sent in an\n   AS-REP to provide information to the client
    about which key salt to\n   use for the string-to-key to be used by the client
    to obtain the key\n   for decrypting the encrypted part the AS-REP.\n"
  title: 5.2.7.5.  PA-ETYPE-INFO2
- contents:
  - "ETYPE-INFO2-ENTRY       ::= SEQUENCE {\n        etype           [0] Int32,\n
    \       salt            [1] KerberosString OPTIONAL,\n        s2kparams       [2]
    OCTET STRING OPTIONAL\n"
  title: ETYPE-INFO2-ENTRY       ::= SEQUENCE {
- contents:
  - '}

    '
  title: '}'
- contents:
  - "ETYPE-INFO2              ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY\n   The
    type of the salt is KerberosString, but existing installations\n   might have
    locale-specific characters stored in salt strings, and\n   implementors MAY choose
    to handle them.\n   The interpretation of s2kparams is specified in the cryptosystem\n
    \  description associated with the etype.  Each cryptosystem has a\n   default
    interpretation of s2kparams that will hold if that element is\n   omitted from
    the encoding of ETYPE-INFO2-ENTRY.\n   If ETYPE-INFO2 is sent in an AS-REP, there
    shall be exactly one\n   ETYPE-INFO2-ENTRY, and its etype shall match that of
    the enc-part in\n   the AS-REP.\n   The preferred ordering of the \"hint\" pre-authentication
    data that\n   affect client key selection is: ETYPE-INFO2, followed by ETYPE-INFO,\n
    \  followed by PW-SALT.  As noted in Section 3.1.3, a KDC MUST NOT send\n   ETYPE-INFO
    or PW-SALT when the client's AS-REQ includes at least one\n   \"newer\" etype.\n
    \  The ETYPE-INFO2 pre-authentication type was not present in RFC 1510.\n"
  title: ETYPE-INFO2              ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY
- contents:
  - "5.2.8.  KerberosFlags\n   For several message types, a specific constrained bit
    string type,\n   KerberosFlags, is used.\n   KerberosFlags   ::= BIT STRING (SIZE
    (32..MAX))\n                       -- minimum number of bits shall be sent,\n
    \                      -- but no fewer than 32\n   Compatibility note: The following
    paragraphs describe a change from\n   the RFC 1510 description of bit strings
    that would result in\n   incompatility in the case of an implementation that strictly\n
    \  conformed to ASN.1 DER and RFC 1510.\n   ASN.1 bit strings have multiple uses.
    \ The simplest use of a bit\n   string is to contain a vector of bits, with no
    particular meaning\n   attached to individual bits.  This vector of bits is not
    necessarily\n   a multiple of eight bits long.  The use in Kerberos of a bit string\n
    \  as a compact boolean vector wherein each element has a distinct\n   meaning
    poses some problems.  The natural notation for a compact\n   boolean vector is
    the ASN.1 \"NamedBit\" notation, and the DER require\n   that encodings of a bit
    string using \"NamedBit\" notation exclude any\n   trailing zero bits.  This truncation
    is easy to neglect, especially\n   given C language implementations that naturally
    choose to store\n   boolean vectors as 32-bit integers.\n   For example, if the
    notation for KDCOptions were to include the\n   \"NamedBit\" notation, as in RFC
    1510, and a KDCOptions value to be\n   encoded had only the \"forwardable\" (bit
    number one) bit set, the DER\n   encoding MUST include only two bits: the first
    reserved bit\n   (\"reserved\", bit number zero, value zero) and the one-valued
    bit (bit\n   number one) for \"forwardable\".\n   Most existing implementations
    of Kerberos unconditionally send 32\n   bits on the wire when encoding bit strings
    used as boolean vectors.\n   This behavior violates the ASN.1 syntax used for
    flag values in RFC\n   1510, but it occurs on such a widely installed base that
    the protocol\n   description is being modified to accommodate it.\n   Consequently,
    this document removes the \"NamedBit\" notations for\n   individual bits, relegating
    them to comments.  The size constraint on\n   the KerberosFlags type requires
    that at least 32 bits be encoded at\n   all times, though a lenient implementation
    MAY choose to accept fewer\n   than 32 bits and to treat the missing bits as set
    to zero.\n   Currently, no uses of KerberosFlags specify more than 32 bits' worth\n
    \  of flags, although future revisions of this document may do so.  When\n   more
    than 32 bits are to be transmitted in a KerberosFlags value,\n   future revisions
    to this document will likely specify that the\n   smallest number of bits needed
    to encode the highest-numbered one-\n   valued bit should be sent.  This is somewhat
    similar to the DER\n   encoding of a bit string that is declared with the \"NamedBit\"\n
    \  notation.\n"
  title: 5.2.8.  KerberosFlags
- contents:
  - "5.2.9.  Cryptosystem-Related Types\n   Many Kerberos protocol messages contain
    an EncryptedData as a\n   container for arbitrary encrypted data, which is often
    the encrypted\n   encoding of another data type.  Fields within EncryptedData
    assist\n   the recipient in selecting a key with which to decrypt the enclosed\n
    \  data.\n   EncryptedData   ::= SEQUENCE {\n           etype   [0] Int32 -- EncryptionType
    --,\n           kvno    [1] UInt32 OPTIONAL,\n           cipher  [2] OCTET STRING
    -- ciphertext\n   }\n   etype\n      This field identifies which encryption algorithm
    was used to\n      encipher the cipher.\n   kvno\n      This field contains the
    version number of the key under which data\n      is encrypted.  It is only present
    in messages encrypted under long\n      lasting keys, such as principals' secret
    keys.\n   cipher\n      This field contains the enciphered text, encoded as an
    OCTET\n      STRING.  (Note that the encryption mechanisms defined in [RFC3961]\n
    \     MUST incorporate integrity protection as well, so no additional\n      checksum
    is required.)\n   The EncryptionKey type is the means by which cryptographic keys
    used\n   for encryption are transferred.\n   EncryptionKey   ::= SEQUENCE {\n
    \          keytype         [0] Int32 -- actually encryption type --,\n           keyvalue
    \       [1] OCTET STRING\n   }\n   keytype\n      This field specifies the encryption
    type of the encryption key\n      that follows in the keyvalue field.  Although
    its name is\n      \"keytype\", it actually specifies an encryption type.  Previously,\n
    \     multiple cryptosystems that performed encryption differently but\n      were
    capable of using keys with the same characteristics were\n      permitted to share
    an assigned number to designate the type of\n      key; this usage is now deprecated.\n
    \  keyvalue\n      This field contains the key itself, encoded as an octet string.\n
    \  Messages containing cleartext data to be authenticated will usually\n   do
    so by using a member of type Checksum.  Most instances of Checksum\n   use a keyed
    hash, though exceptions will be noted.\n   Checksum        ::= SEQUENCE {\n           cksumtype
    \      [0] Int32,\n           checksum        [1] OCTET STRING\n   }\n   cksumtype\n
    \     This field indicates the algorithm used to generate the\n      accompanying
    checksum.\n   checksum\n      This field contains the checksum itself, encoded
    as an octet\n      string.\n   See Section 4 for a brief description of the use
    of encryption and\n   checksums in Kerberos.\n"
  title: 5.2.9.  Cryptosystem-Related Types
- contents:
  - "5.3.  Tickets\n   This section describes the format and encryption parameters
    for\n   tickets and authenticators.  When a ticket or authenticator is\n   included
    in a protocol message, it is treated as an opaque object.  A\n   ticket is a record
    that helps a client authenticate to a service.  A\n   Ticket contains the following
    information:\n   Ticket          ::= [APPLICATION 1] SEQUENCE {\n           tkt-vno
    \        [0] INTEGER (5),\n           realm           [1] Realm,\n           sname
    \          [2] PrincipalName,\n           enc-part        [3] EncryptedData --
    EncTicketPart\n   }\n   -- Encrypted part of ticket\n   EncTicketPart   ::= [APPLICATION
    3] SEQUENCE {\n           flags                   [0] TicketFlags,\n           key
    \                    [1] EncryptionKey,\n           crealm                  [2]
    Realm,\n           cname                   [3] PrincipalName,\n           transited
    \              [4] TransitedEncoding,\n           authtime                [5]
    KerberosTime,\n           starttime               [6] KerberosTime OPTIONAL,\n
    \          endtime                 [7] KerberosTime,\n           renew-till              [8]
    KerberosTime OPTIONAL,\n           caddr                   [9] HostAddresses OPTIONAL,\n
    \          authorization-data      [10] AuthorizationData OPTIONAL\n   }\n   --
    encoded Transited field\n   TransitedEncoding       ::= SEQUENCE {\n           tr-type
    \        [0] Int32 -- must be registered --,\n           contents        [1] OCTET
    STRING\n   }\n   TicketFlags     ::= KerberosFlags\n           -- reserved(0),\n
    \          -- forwardable(1),\n           -- forwarded(2),\n           -- proxiable(3),\n
    \          -- proxy(4),\n           -- may-postdate(5),\n           -- postdated(6),\n
    \          -- invalid(7),\n           -- renewable(8),\n           -- initial(9),\n
    \          -- pre-authent(10),\n           -- hw-authent(11),\n   -- the following
    are new since 1510\n           -- transited-policy-checked(12),\n           --
    ok-as-delegate(13)\n   tkt-vno\n      This field specifies the version number
    for the ticket format.\n      This document describes version number 5.\n   realm\n
    \     This field specifies the realm that issued a ticket.  It also\n      serves
    to identify the realm part of the server's principal\n      identifier.  Since
    a Kerberos server can only issue tickets for\n      servers within its realm,
    the two will always be identical.\n   sname\n      This field specifies all components
    of the name part of the\n      server's identity, including those parts that identify
    a specific\n      instance of a service.\n   enc-part\n      This field holds
    the encrypted encoding of the EncTicketPart\n      sequence.  It is encrypted
    in the key shared by Kerberos and the\n      end server (the server's secret key),
    using a key usage value of\n      2.\n   flags\n      This field indicates which
    of various options were used or\n      requested when the ticket was issued.  The
    meanings of the flags\n      are as follows:\n   Bit(s)  Name             Description\n
    \  0       reserved         Reserved for future expansion of this field.\n   1
    \      forwardable      The FORWARDABLE flag is normally only\n                            interpreted
    by the TGS, and can be ignored\n                            by end servers.  When
    set, this flag tells\n                            the ticket-granting server that
    it is OK to\n                            issue a new TGT with a different network\n
    \                           address based on the presented ticket.\n   2       forwarded
    \       When set, this flag indicates that the\n                            ticket
    has either been forwarded or was\n                            issued based on
    authentication involving a\n                            forwarded TGT.\n   3       proxiable
    \       The PROXIABLE flag is normally only\n                            interpreted
    by the TGS, and can be ignored\n                            by end servers.  The
    PROXIABLE flag has an\n                            interpretation identical to
    that of the\n                            FORWARDABLE flag, except that the PROXIABLE\n
    \                           flag tells the ticket-granting server that\n                            only
    non-TGTs may be issued with different\n                            network addresses.\n
    \  4       proxy            When set, this flag indicates that a ticket\n                            is
    a proxy.\n   5       may-postdate     The MAY-POSTDATE flag is normally only\n
    \                           interpreted by the TGS, and can be ignored\n                            by
    end servers.  This flag tells the\n                            ticket-granting
    server that a post-dated\n                            ticket MAY be issued based
    on this TGT.\n   6       postdated        This flag indicates that this ticket
    has\n                            been postdated.  The end-service can check\n
    \                           the authtime field to see when the original\n                            authentication
    occurred.\n   7       invalid          This flag indicates that a ticket is\n
    \                           invalid, and it must be validated by the KDC\n                            before
    use.  Application servers must reject\n                            tickets which
    have this flag set.\n   8       renewable        The RENEWABLE flag is normally
    only\n                            interpreted by the TGS, and can usually be\n
    \                           ignored by end servers (some particularly\n                            careful
    servers MAY disallow renewable\n                            tickets).  A renewable
    ticket can be used to\n                            obtain a replacement ticket
    that expires at\n                            a later date.\n   9       initial
    \         This flag indicates that this ticket was\n                            issued
    using the AS protocol, and not issued\n                            based on a
    TGT.\n   10      pre-authent      This flag indicates that during initial\n                            authentication,
    the client was authenticated\n                            by the KDC before a
    ticket was issued.  The\n                            strength of the pre-authentication
    method is\n                            not indicated, but is acceptable to the
    KDC.\n   11      hw-authent       This flag indicates that the protocol\n                            employed
    for initial authentication required\n                            the use of hardware
    expected to be possessed\n                            solely by the named client.
    \ The hardware\n                            authentication method is selected
    by the KDC\n                            and the strength of the method is not\n
    \                           indicated.\n   12      transited-       This flag
    indicates that the KDC for\n           policy-checked   the realm has checked
    the transited field\n                            against a realm-defined policy
    for trusted\n                            certifiers.  If this flag is reset (0),
    then\n                            the application server must check the\n                            transited
    field itself, and if unable to do\n                            so, it must reject
    the authentication.  If\n                            the flag is set (1), then
    the application\n                            server MAY skip its own validation
    of the\n                            transited field, relying on the validation\n
    \                           performed by the KDC.  At its option the\n                            application
    server MAY still apply its own\n                            validation based on
    a separate policy for\n                            acceptance.\n                            This
    flag is new since RFC 1510.\n   13      ok-as-delegate   This flag indicates that
    the server (not the\n                            client) specified in the ticket
    has been\n                            determined by policy of the realm to be
    a\n                            suitable recipient of delegation.  A client\n                            can
    use the presence of this flag to help it\n                            decide whether
    to delegate credentials\n                            (either grant a proxy or
    a forwarded TGT) to\n                            this server.  The client is free
    to ignore\n                            the value of this flag.  When setting this\n
    \                           flag, an administrator should consider the\n                            security
    and placement of the server on\n                            which the service
    will run, as well as\n                            whether the service requires
    the use of\n                            delegated credentials.\n                            This
    flag is new since RFC 1510.\n   14-31   reserved         Reserved for future use.\n
    \  key\n      This field exists in the ticket and the KDC response and is used\n
    \     to pass the session key from Kerberos to the application server\n      and
    the client.\n   crealm\n      This field contains the name of the realm in which
    the client is\n      registered and in which initial authentication took place.\n
    \  cname\n      This field contains the name part of the client's principal\n
    \     identifier.\n   transited\n      This field lists the names of the Kerberos
    realms that took part\n      in authenticating the user to whom this ticket was
    issued.  It\n      does not specify the order in which the realms were transited.\n
    \     See Section 3.3.3.2 for details on how this field encodes the\n      traversed
    realms.  When the names of CAs are to be embedded in the\n      transited field
    (as specified for some extensions to the\n      protocol), the X.500 names of
    the CAs SHOULD be mapped into items\n      in the transited field using the mapping
    defined by RFC 2253.\n   authtime\n      This field indicates the time of initial
    authentication for the\n      named principal.  It is the time of issue for the
    original ticket\n      on which this ticket is based.  It is included in the ticket
    to\n      provide additional information to the end service, and to provide\n
    \     the necessary information for implementation of a \"hot list\"\n      service
    at the KDC.  An end service that is particularly paranoid\n      could refuse
    to accept tickets for which the initial\n      authentication occurred \"too far\"
    in the past.  This field is also\n      returned as part of the response from
    the KDC.  When it is\n      returned as part of the response to initial authentication\n
    \     (KRB_AS_REP), this is the current time on the Kerberos server.  It\n      is
    NOT recommended that this time value be used to adjust the\n      workstation's
    clock, as the workstation cannot reliably determine\n      that such a KRB_AS_REP
    actually came from the proper KDC in a\n      timely manner.\n   starttime\n      This
    field in the ticket specifies the time after which the ticket\n      is valid.
    \ Together with endtime, this field specifies the life of\n      the ticket.  If
    the starttime field is absent from the ticket,\n      then the authtime field
    SHOULD be used in its place to determine\n      the life of the ticket.\n   endtime\n
    \     This field contains the time after which the ticket will not be\n      honored
    (its expiration time).  Note that individual services MAY\n      place their own
    limits on the life of a ticket and MAY reject\n      tickets which have not yet
    expired.  As such, this is really an\n      upper bound on the expiration time
    for the ticket.\n   renew-till\n      This field is only present in tickets that
    have the RENEWABLE flag\n      set in the flags field.  It indicates the maximum
    endtime that may\n      be included in a renewal.  It can be thought of as the
    absolute\n      expiration time for the ticket, including all renewals.\n   caddr\n
    \     This field in a ticket contains zero (if omitted) or more (if\n      present)
    host addresses.  These are the addresses from which the\n      ticket can be used.
    \ If there are no addresses, the ticket can be\n      used from any location.
    \ The decision by the KDC to issue or by\n      the end server to accept addressless
    tickets is a policy decision\n      and is left to the Kerberos and end-service
    administrators; they\n      MAY refuse to issue or accept such tickets.  Because
    of the wide\n      deployment of network address translation, it is recommended
    that\n      policy allow the issue and acceptance of such tickets.\n      Network
    addresses are included in the ticket to make it harder for\n      an attacker
    to use stolen credentials.  Because the session key is\n      not sent over the
    network in cleartext, credentials can't be\n      stolen simply by listening to
    the network; an attacker has to gain\n      access to the session key (perhaps
    through operating system\n      security breaches or a careless user's unattended
    session) to make\n      use of stolen tickets.\n      Note that the network address
    from which a connection is received\n      cannot be reliably determined.  Even
    if it could be, an attacker\n      who has compromised the client's workstation
    could use the\n      credentials from there.  Including the network addresses
    only\n      makes it more difficult, not impossible, for an attacker to walk\n
    \     off with stolen credentials and then to use them from a \"safe\"\n      location.\n
    \  authorization-data\n      The authorization-data field is used to pass authorization
    data\n      from the principal on whose behalf a ticket was issued to the\n      application
    service.  If no authorization data is included, this\n      field will be left
    out.  Experience has shown that the name of\n      this field is confusing, and
    that a better name would be\n      \"restrictions\".  Unfortunately, it is not
    possible to change the\n      name at this time.\n      This field contains restrictions
    on any authority obtained on the\n      basis of authentication using the ticket.
    \ It is possible for any\n      principal in possession of credentials to add
    entries to the\n      authorization data field since these entries further restrict
    what\n      can be done with the ticket.  Such additions can be made by\n      specifying
    the additional entries when a new ticket is obtained\n      during the TGS exchange,
    or they MAY be added during chained\n      delegation using the authorization
    data field of the\n      authenticator.\n      Because entries may be added to
    this field by the holder of\n      credentials, except when an entry is separately
    authenticated by\n      encapsulation in the KDC-issued element, it is not allowable
    for\n      the presence of an entry in the authorization data field of a\n      ticket
    to amplify the privileges one would obtain from using a\n      ticket.\n      The
    data in this field may be specific to the end service; the\n      field will contain
    the names of service specific objects, and the\n      rights to those objects.
    \ The format for this field is described\n      in Section 5.2.6.  Although Kerberos
    is not concerned with the\n      format of the contents of the subfields, it does
    carry type\n      information (ad-type).\n      By using the authorization_data
    field, a principal is able to\n      issue a proxy that is valid for a specific
    purpose.  For example,\n      a client wishing to print a file can obtain a file
    server proxy to\n      be passed to the print server.  By specifying the name
    of the file\n      in the authorization_data field, the file server knows that
    the\n      print server can only use the client's rights when accessing the\n
    \     particular file to be printed.\n      A separate service providing authorization
    or certifying group\n      membership may be built using the authorization-data
    field.  In\n      this case, the entity granting authorization (not the authorized\n
    \     entity) may obtain a ticket in its own name (e.g., the ticket is\n      issued
    in the name of a privilege server), and this entity adds\n      restrictions on
    its own authority and delegates the restricted\n      authority through a proxy
    to the client.  The client would then\n      present this authorization credential
    to the application server\n      separately from the authentication exchange.
    \ Alternatively, such\n      authorization credentials MAY be embedded in the
    ticket\n      authenticating the authorized entity, when the authorization is\n
    \     separately authenticated using the KDC-issued authorization data\n      element
    (see 5.2.6.2).\n      Similarly, if one specifies the authorization-data field
    of a\n      proxy and leaves the host addresses blank, the resulting ticket\n
    \     and session key can be treated as a capability.  See [Neu93] for\n      some
    suggested uses of this field.\n      The authorization-data field is optional
    and does not have to be\n      included in a ticket.\n"
  title: 5.3.  Tickets
- contents:
  - "5.4.  Specifications for the AS and TGS Exchanges\n   This section specifies
    the format of the messages used in the\n   exchange between the client and the
    Kerberos server.  The format of\n   possible error messages appears in Section
    5.9.1.\n"
  title: 5.4.  Specifications for the AS and TGS Exchanges
- contents:
  - "5.4.1.  KRB_KDC_REQ Definition\n   The KRB_KDC_REQ message has no application
    tag number of its own.\n   Instead, it is incorporated into either KRB_AS_REQ
    or KRB_TGS_REQ,\n   each of which has an application tag, depending on whether
    the\n   request is for an initial ticket or an additional ticket.  In either\n
    \  case, the message is sent from the client to the KDC to request\n   credentials
    for a service.\n   The message fields are as follows:\n"
  title: 5.4.1.  KRB_KDC_REQ Definition
- contents:
  - 'AS-REQ          ::= [APPLICATION 10] KDC-REQ

    '
  title: AS-REQ          ::= [APPLICATION 10] KDC-REQ
- contents:
  - 'TGS-REQ         ::= [APPLICATION 12] KDC-REQ

    '
  title: TGS-REQ         ::= [APPLICATION 12] KDC-REQ
- contents:
  - "KDC-REQ         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n
    \       pvno            [1] INTEGER (5) ,\n        msg-type        [2] INTEGER
    (10 -- AS -- | 12 -- TGS --),\n        padata          [3] SEQUENCE OF PA-DATA
    OPTIONAL\n                            -- NOTE: not empty --,\n        req-body
    \       [4] KDC-REQ-BODY\n"
  title: KDC-REQ         ::= SEQUENCE {
- contents:
  - '}

    '
  title: '}'
- contents:
  - "KDC-REQ-BODY    ::= SEQUENCE {\n        kdc-options             [0] KDCOptions,\n
    \       cname                   [1] PrincipalName OPTIONAL\n                                    --
    Used only in AS-REQ --,\n        realm                   [2] Realm\n                                    --
    Server's realm\n                                    -- Also client's in AS-REQ
    --,\n        sname                   [3] PrincipalName OPTIONAL,\n        from
    \                   [4] KerberosTime OPTIONAL,\n        till                    [5]
    KerberosTime,\n        rtime                   [6] KerberosTime OPTIONAL,\n        nonce
    \                  [7] UInt32,\n        etype                   [8] SEQUENCE OF
    Int32 -- EncryptionType\n                                    -- in preference
    order --,\n        addresses               [9] HostAddresses OPTIONAL,\n        enc-authorization-data
    \ [10] EncryptedData OPTIONAL\n                                    -- AuthorizationData
    --,\n        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL\n                                       --
    NOTE: not empty\n"
  title: KDC-REQ-BODY    ::= SEQUENCE {
- contents:
  - '}

    '
  title: '}'
- contents:
  - "KDCOptions      ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n
    \       -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        --
    allow-postdate(5),\n        -- postdated(6),\n        -- unused7(7),\n        --
    renewable(8),\n        -- unused9(9),\n        -- unused10(10),\n        -- opt-hardware-auth(11),\n
    \       -- unused12(12),\n        -- unused13(13),\n"
  title: KDCOptions      ::= KerberosFlags
- contents:
  - "-- 15 is reserved for canonicalize\n        -- unused15(15),\n"
  title: -- 15 is reserved for canonicalize
- contents:
  - "-- 26 was unused in 1510\n        -- disable-transited-check(26),\n"
  title: -- 26 was unused in 1510
- contents:
  - "--\n        -- renewable-ok(27),\n        -- enc-tkt-in-skey(28),\n        --
    renew(30),\n        -- validate(31)\n   The fields in this message are as follows:\n
    \  pvno\n      This field is included in each message, and specifies the protocol\n
    \     version number.  This document specifies protocol version 5.\n   msg-type\n
    \     This field indicates the type of a protocol message.  It will\n      almost
    always be the same as the application identifier associated\n      with a message.
    \ It is included to make the identifier more\n      readily accessible to the
    application.  For the KDC-REQ message,\n      this type will be KRB_AS_REQ or
    KRB_TGS_REQ.\n   padata\n      Contains pre-authentication data.  Requests for
    additional tickets\n      (KRB_TGS_REQ) MUST contain a padata of PA-TGS-REQ.\n
    \     The padata (pre-authentication data) field contains a sequence of\n      authentication
    information that may be needed before credentials\n      can be issued or decrypted.\n
    \  req-body\n      This field is a placeholder delimiting the extent of the remaining\n
    \     fields.  If a checksum is to be calculated over the request, it is\n      calculated
    over an encoding of the KDC-REQ-BODY sequence which is\n      enclosed within
    the req-body field.\n   kdc-options\n      This field appears in the KRB_AS_REQ
    and KRB_TGS_REQ requests to\n      the KDC and indicates the flags that the client
    wants set on the\n      tickets as well as other information that is to modify
    the\n      behavior of the KDC.  Where appropriate, the name of an option may\n
    \     be the same as the flag that is set by that option.  Although in\n      most
    cases, the bit in the options field will be the same as that\n      in the flags
    field, this is not guaranteed, so it is not\n      acceptable simply to copy the
    options field to the flags field.\n      There are various checks that must be
    made before an option is\n      honored anyway.\n      The kdc_options field is
    a bit-field, where the selected options\n      are indicated by the bit being
    set (1), and the unselected options\n      and reserved fields being reset (0).
    \ The encoding of the bits is\n      specified in Section 5.2.  The options are
    described in more\n      detail above in Section 2.  The meanings of the options
    are as\n      follows:\n   Bits    Name                     Description\n   0
    \      RESERVED                 Reserved for future expansion of\n                                    this
    field.\n   1       FORWARDABLE              The FORWARDABLE option indicates\n
    \                                   that the ticket to be issued is to\n                                    have
    its forwardable flag set.  It\n                                    may only be
    set on the initial\n                                    request, or in a subsequent
    request\n                                    if the TGT on which it is based is\n
    \                                   also forwardable.\n   2       FORWARDED                The
    FORWARDED option is only\n                                    specified in a request
    to the\n                                    ticket-granting server and will only\n
    \                                   be honored if the TGT in the request\n                                    has
    its FORWARDABLE bit set.  This\n                                    option indicates
    that this is a\n                                    request for forwarding.  The\n
    \                                   address(es) of the host from which\n                                    the
    resulting ticket is to be valid\n                                    are included
    in the addresses field\n                                    of the request.\n
    \  3       PROXIABLE                The PROXIABLE option indicates that\n                                    the
    ticket to be issued is to have\n                                    its proxiable
    flag set.  It may only\n                                    be set on the initial
    request, or a\n                                    subsequent request if the TGT
    on\n                                    which it is based is also proxiable.\n
    \  4       PROXY                    The PROXY option indicates that this\n                                    is
    a request for a proxy.  This\n                                    option will
    only be honored if the\n                                    TGT in the request
    has its PROXIABLE\n                                    bit set.  The address(es)
    of the\n                                    host from which the resulting ticket\n
    \                                   is to be valid are included in the\n                                    addresses
    field of the request.\n   5       ALLOW-POSTDATE           The ALLOW-POSTDATE
    option indicates\n                                    that the ticket to be issued
    is to\n                                    have its MAY-POSTDATE flag set.  It\n
    \                                   may only be set on the initial\n                                    request,
    or in a subsequent request\n                                    if the TGT on
    which it is based also\n                                    has its MAY-POSTDATE
    flag set.\n   6       POSTDATED                The POSTDATED option indicates
    that\n                                    this is a request for a postdated\n
    \                                   ticket.  This option will only be\n                                    honored
    if the TGT on which it is\n                                    based has its MAY-POSTDATE
    flag set.\n                                    The resulting ticket will also
    have\n                                    its INVALID flag set, and that flag\n
    \                                   may be reset by a subsequent request\n                                    to
    the KDC after the starttime in\n                                    the ticket
    has been reached.\n   7       RESERVED                 This option is presently
    unused.\n   8       RENEWABLE                The RENEWABLE option indicates that\n
    \                                   the ticket to be issued is to have\n                                    its
    RENEWABLE flag set.  It may only\n                                    be set on
    the initial request, or\n                                    when the TGT on which
    the request is\n                                    based is also renewable.  If
    this\n                                    option is requested, then the rtime\n
    \                                   field in the request contains the\n                                    desired
    absolute expiration time for\n                                    the ticket.\n
    \  9       RESERVED                 Reserved for PK-Cross.\n   10      RESERVED
    \                Reserved for future use.\n   11      RESERVED                 Reserved
    for opt-hardware-auth.\n   12-25   RESERVED                 Reserved for future
    use.\n   26      DISABLE-TRANSITED-CHECK  By default the KDC will check the\n
    \                                   transited field of a TGT against the\n                                    policy
    of the local realm before it\n                                    will issue derivative
    tickets based\n                                    on the TGT.  If this flag is
    set in\n                                    the request, checking of the\n                                    transited
    field is disabled.\n                                    Tickets issued without
    the\n                                    performance of this check will be\n                                    noted
    by the reset (0) value of the\n                                    TRANSITED-POLICY-CHECKED
    flag,\n                                    indicating to the application server\n
    \                                   that the transited field must be\n                                    checked
    locally.  KDCs are\n                                    encouraged but not required
    to honor\n                                    the DISABLE-TRANSITED-CHECK option.\n
    \                                   This flag is new since RFC 1510.\n   27      RENEWABLE-OK
    \            The RENEWABLE-OK option indicates\n                                    that
    a renewable ticket will be\n                                    acceptable if
    a ticket with the\n                                    requested life cannot otherwise
    be\n                                    provided, in which case a renewable\n
    \                                   ticket may be issued with a renew-\n                                    till
    equal to the requested endtime.\n                                    The value
    of the renew-till field\n                                    may still be limited
    by local\n                                    limits, or limits selected by the\n
    \                                   individual principal or server.\n   28      ENC-TKT-IN-SKEY
    \         This option is used only by the\n                                    ticket-granting
    service.  The ENC-\n                                    TKT-IN-SKEY option indicates
    that\n                                    the ticket for the end server is to\n
    \                                   be encrypted in the session key from\n                                    the
    additional TGT provided.\n   29      RESERVED                 Reserved for future
    use.\n   30      RENEW                    This option is used only by the\n                                    ticket-granting
    service.  The RENEW\n                                    option indicates that
    the present\n                                    request is for a renewal.  The\n
    \                                   ticket provided is encrypted in the\n                                    secret
    key for the server on which\n                                    it is valid.
    \ This option will only\n                                    be honored if the
    ticket to be\n                                    renewed has its RENEWABLE flag
    set\n                                    and if the time in its renew-till\n                                    field
    has not passed.  The ticket to\n                                    be renewed
    is passed in the padata\n                                    field as part of
    the authentication\n                                    header.\n   31      VALIDATE
    \                This option is used only by the\n                                    ticket-granting
    service.  The\n                                    VALIDATE option indicates that
    the\n                                    request is to validate a postdated\n
    \                                   ticket.  It will only be honored if\n                                    the
    ticket presented is postdated,\n                                    presently
    has its INVALID flag set,\n                                    and would otherwise
    be usable at\n                                    this time.  A ticket cannot
    be\n                                    validated before its starttime.  The\n
    \                                   ticket presented for validation is\n                                    encrypted
    in the key of the server\n                                    for which it is
    valid and is passed\n                                    in the padata field as
    part of the\n                                    authentication header.\n   cname
    and sname\n      These fields are the same as those described for the ticket in\n
    \     section 5.3.  The sname may only be absent when the ENC-TKT-IN-\n      SKEY
    option is specified.  If the sname is absent, the name of the\n      server is
    taken from the name of the client in the ticket passed\n      as additional-tickets.\n
    \  enc-authorization-data\n      The enc-authorization-data, if present (and it
    can only be present\n      in the TGS_REQ form), is an encoding of the desired\n
    \     authorization-data encrypted under the sub-session key if present\n      in
    the Authenticator, or alternatively from the session key in the\n      TGT (both
    the Authenticator and TGT come from the padata field in\n      the KRB_TGS_REQ).
    \ The key usage value used when encrypting is 5\n      if a sub-session key is
    used, or 4 if the session key is used.\n   realm\n      This field specifies the
    realm part of the server's principal\n      identifier.  In the AS exchange, this
    is also the realm part of\n      the client's principal identifier.\n   from\n
    \     This field is included in the KRB_AS_REQ and KRB_TGS_REQ ticket\n      requests
    when the requested ticket is to be postdated.  It\n      specifies the desired
    starttime for the requested ticket.  If this\n      field is omitted, then the
    KDC SHOULD use the current time\n      instead.\n   till\n      This field contains
    the expiration date requested by the client in\n      a ticket request.  It is
    not optional, but if the requested\n      endtime is \"19700101000000Z\", the
    requested ticket is to have the\n      maximum endtime permitted according to
    KDC policy.  Implementation\n      note: This special timestamp corresponds to
    a UNIX time_t value of\n      zero on most systems.\n   rtime\n      This field
    is the requested renew-till time sent from a client to\n      the KDC in a ticket
    request.  It is optional.\n   nonce\n      This field is part of the KDC request
    and response.  It is\n      intended to hold a random number generated by the
    client.  If the\n      same number is included in the encrypted response from
    the KDC, it\n      provides evidence that the response is fresh and has not been\n
    \     replayed by an attacker.  Nonces MUST NEVER be reused.\n   etype\n      This
    field specifies the desired encryption algorithm to be used\n      in the response.\n
    \  addresses\n      This field is included in the initial request for tickets,
    and it\n      is optionally included in requests for additional tickets from the\n
    \     ticket-granting server.  It specifies the addresses from which the\n      requested
    ticket is to be valid.  Normally it includes the\n      addresses for the client's
    host.  If a proxy is requested, this\n      field will contain other addresses.
    \ The contents of this field\n      are usually copied by the KDC into the caddr
    field of the\n      resulting ticket.\n   additional-tickets\n      Additional
    tickets MAY be optionally included in a request to the\n      ticket-granting
    server.  If the ENC-TKT-IN-SKEY option has been\n      specified, then the session
    key from the additional ticket will be\n      used in place of the server's key
    to encrypt the new ticket.  When\n      the ENC-TKT-IN-SKEY option is used for
    user-to-user\n      authentication, this additional ticket MAY be a TGT issued
    by the\n      local realm or an inter-realm TGT issued for the current KDC's\n
    \     realm by a remote KDC.  If more than one option that requires\n      additional
    tickets has been specified, then the additional tickets\n      are used in the
    order specified by the ordering of the options\n      bits (see kdc-options, above).\n
    \  The application tag number will be either ten (10) or twelve (12)\n   depending
    on whether the request is for an initial ticket (AS-REQ) or\n   for an additional
    ticket (TGS-REQ).\n   The optional fields (addresses, authorization-data, and
    additional-\n   tickets) are only included if necessary to perform the operation\n
    \  specified in the kdc-options field.\n   Note that in KRB_TGS_REQ, the protocol
    version number appears twice\n   and two different message types appear: the KRB_TGS_REQ
    message\n   contains these fields as does the authentication header (KRB_AP_REQ)\n
    \  that is passed in the padata field.\n"
  title: --
- contents:
  - "5.4.2.  KRB_KDC_REP Definition\n   The KRB_KDC_REP message format is used for
    the reply from the KDC for\n   either an initial (AS) request or a subsequent
    (TGS) request.  There\n   is no message type for KRB_KDC_REP.  Instead, the type
    will be either\n   KRB_AS_REP or KRB_TGS_REP.  The key used to encrypt the ciphertext\n
    \  part of the reply depends on the message type.  For KRB_AS_REP, the\n   ciphertext
    is encrypted in the client's secret key, and the client's\n   key version number
    is included in the key version number for the\n   encrypted data.  For KRB_TGS_REP,
    the ciphertext is encrypted in the\n   sub-session key from the Authenticator;
    if it is absent, the\n   ciphertext is encrypted in the session key from the TGT
    used in the\n   request.  In that case, no version number will be present in the\n
    \  EncryptedData sequence.\n   The KRB_KDC_REP message contains the following
    fields:\n   AS-REP          ::= [APPLICATION 11] KDC-REP\n   TGS-REP         ::=
    [APPLICATION 13] KDC-REP\n   KDC-REP         ::= SEQUENCE {\n           pvno            [0]
    INTEGER (5),\n           msg-type        [1] INTEGER (11 -- AS -- | 13 -- TGS
    --),\n           padata          [2] SEQUENCE OF PA-DATA OPTIONAL\n                                   --
    NOTE: not empty --,\n           crealm          [3] Realm,\n           cname           [4]
    PrincipalName,\n           ticket          [5] Ticket,\n           enc-part        [6]
    EncryptedData\n                                   -- EncASRepPart or EncTGSRepPart,\n
    \                                  -- as appropriate\n   }\n   EncASRepPart    ::=
    [APPLICATION 25] EncKDCRepPart\n   EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart\n
    \  EncKDCRepPart   ::= SEQUENCE {\n           key             [0] EncryptionKey,\n
    \          last-req        [1] LastReq,\n           nonce           [2] UInt32,\n
    \          key-expiration  [3] KerberosTime OPTIONAL,\n           flags           [4]
    TicketFlags,\n           authtime        [5] KerberosTime,\n           starttime
    \      [6] KerberosTime OPTIONAL,\n           endtime         [7] KerberosTime,\n
    \          renew-till      [8] KerberosTime OPTIONAL,\n           srealm          [9]
    Realm,\n           sname           [10] PrincipalName,\n           caddr           [11]
    HostAddresses OPTIONAL\n   }\n   LastReq         ::=     SEQUENCE OF SEQUENCE
    {\n           lr-type         [0] Int32,\n           lr-value        [1] KerberosTime\n
    \  }\n   pvno and msg-type\n      These fields are described above in Section
    5.4.1.  msg-type is\n      either KRB_AS_REP or KRB_TGS_REP.\n   padata\n      This
    field is described in detail in Section 5.4.1.  One possible\n      use for it
    is to encode an alternate \"salt\" string to be used with\n      a string-to-key
    algorithm.  This ability is useful for easing\n      transitions if a realm name
    needs to change (e.g., when a company\n      is acquired); in such a case all
    existing password-derived entries\n      in the KDC database would be flagged
    as needing a special salt\n      string until the next password change.\n   crealm,
    cname, srealm, and sname\n      These fields are the same as those described for
    the ticket in\n      section 5.3.\n   ticket\n      The newly-issued ticket, from
    Section 5.3.\n   enc-part\n      This field is a place holder for the ciphertext
    and related\n      information that forms the encrypted part of a message.  The\n
    \     description of the encrypted part of the message follows each\n      appearance
    of this field.\n      The key usage value for encrypting this field is 3 in an
    AS-REP\n      message, using the client's long-term key or another key selected\n
    \     via pre-authentication mechanisms.  In a TGS-REP message, the key\n      usage
    value is 8 if the TGS session key is used, or 9 if a TGS\n      authenticator
    subkey is used.\n      Compatibility note: Some implementations unconditionally
    send an\n      encrypted EncTGSRepPart (application tag number 26) in this field\n
    \     regardless of whether the reply is a AS-REP or a TGS-REP.  In the\n      interest
    of compatibility, implementors MAY relax the check on the\n      tag number of
    the decrypted ENC-PART.\n   key\n      This field is the same as described for
    the ticket in Section 5.3.\n   last-req\n      This field is returned by the KDC
    and specifies the time(s) of the\n      last request by a principal.  Depending
    on what information is\n      available, this might be the last time that a request
    for a TGT\n      was made, or the last time that a request based on a TGT was\n
    \     successful.  It also might cover all servers for a realm, or just\n      the
    particular server.  Some implementations MAY display this\n      information to
    the user to aid in discovering unauthorized use of\n      one's identity.  It
    is similar in spirit to the last login time\n      displayed when logging in to
    timesharing systems.\n   lr-type\n      This field indicates how the following
    lr-value field is to be\n      interpreted.  Negative values indicate that the
    information\n      pertains only to the responding server.  Non-negative values\n
    \     pertain to all servers for the realm.\n      If the lr-type field is zero
    (0), then no information is conveyed\n      by the lr-value subfield.  If the
    absolute value of the lr-type\n      field is one (1), then the lr-value subfield
    is the time of last\n      initial request for a TGT.  If it is two (2), then
    the lr-value\n      subfield is the time of last initial request.  If it is three
    (3),\n      then the lr-value subfield is the time of issue for the newest TGT\n
    \     used.  If it is four (4), then the lr-value subfield is the time\n      of
    the last renewal.  If it is five (5), then the lr-value\n      subfield is the
    time of last request (of any type).  If it is (6),\n      then the lr-value subfield
    is the time when the password will\n      expire.  If it is (7), then the lr-value
    subfield is the time when\n      the account will expire.\n   lr-value\n      This
    field contains the time of the last request.  The time MUST\n      be interpreted
    according to the contents of the accompanying lr-\n      type subfield.\n   nonce\n
    \     This field is described above in Section 5.4.1.\n   key-expiration\n      The
    key-expiration field is part of the response from the KDC and\n      specifies
    the time that the client's secret key is due to expire.\n      The expiration
    might be the result of password aging or an account\n      expiration.  If present,
    it SHOULD be set to the earlier of the\n      user's key expiration and account
    expiration.  The use of this\n      field is deprecated, and the last-req field
    SHOULD be used to\n      convey this information instead.  This field will usually
    be left\n      out of the TGS reply since the response to the TGS request is\n
    \     encrypted in a session key and no client information has to be\n      retrieved
    from the KDC database.  It is up to the application\n      client (usually the
    login program) to take appropriate action\n      (such as notifying the user)
    if the expiration time is imminent.\n   flags, authtime, starttime, endtime, renew-till
    and caddr\n      These fields are duplicates of those found in the encrypted\n
    \     portion of the attached ticket (see Section 5.3), provided so the\n      client
    MAY verify that they match the intended request and in\n      order to assist
    in proper ticket caching.  If the message is of\n      type KRB_TGS_REP, the caddr
    field will only be filled in if the\n      request was for a proxy or forwarded
    ticket, or if the user is\n      substituting a subset of the addresses from the
    TGT.  If the\n      client-requested addresses are not present or not used, then
    the\n      addresses contained in the ticket will be the same as those\n      included
    in the TGT.\n"
  title: 5.4.2.  KRB_KDC_REP Definition
- contents:
  - "5.5.  Client/Server (CS) Message Specifications\n   This section specifies the
    format of the messages used for the\n   authentication of the client to the application
    server.\n"
  title: 5.5.  Client/Server (CS) Message Specifications
- contents:
  - "5.5.1.  KRB_AP_REQ Definition\n   The KRB_AP_REQ message contains the Kerberos
    protocol version number,\n   the message type KRB_AP_REQ, an options field to
    indicate any options\n   in use, and the ticket and authenticator themselves.
    \ The KRB_AP_REQ\n   message is often referred to as the \"authentication header\".\n
    \  AP-REQ          ::= [APPLICATION 14] SEQUENCE {\n           pvno            [0]
    INTEGER (5),\n           msg-type        [1] INTEGER (14),\n           ap-options
    \     [2] APOptions,\n           ticket          [3] Ticket,\n           authenticator
    \  [4] EncryptedData -- Authenticator\n   }\n   APOptions       ::= KerberosFlags\n
    \          -- reserved(0),\n           -- use-session-key(1),\n           -- mutual-required(2)\n
    \  pvno and msg-type\n      These fields are described above in Section 5.4.1.
    msg-type is\n      KRB_AP_REQ.\n   ap-options\n      This field appears in the
    application request (KRB_AP_REQ) and\n      affects the way the request is processed.
    \ It is a bit-field,\n      where the selected options are indicated by the bit
    being set (1),\n      and the unselected options and reserved fields by being
    reset (0).\n      The encoding of the bits is specified in Section 5.2.  The\n
    \     meanings of the options are as follows:\n   Bit(s)  Name             Description\n
    \  0       reserved         Reserved for future expansion of this field.\n   1
    \      use-session-key  The USE-SESSION-KEY option indicates that\n                            the
    ticket the client is presenting to a\n                            server is encrypted
    in the session key from\n                            the server's TGT.  When this
    option is not\n                            specified, the ticket is encrypted
    in the\n                            server's secret key.\n   2       mutual-required
    \ The MUTUAL-REQUIRED option tells the server\n                            that
    the client requires mutual\n                            authentication, and that
    it must respond\n                            with a KRB_AP_REP message.\n   3-31
    \   reserved         Reserved for future use.\n   ticket\n      This field is
    a ticket authenticating the client to the server.\n   authenticator\n      This
    contains the encrypted authenticator, which includes the\n      client's choice
    of a subkey.\n   The encrypted authenticator is included in the AP-REQ; it certifies\n
    \  to a server that the sender has recent knowledge of the encryption\n   key
    in the accompanying ticket, to help the server detect replays.\n   It also assists
    in the selection of a \"true session key\" to use with\n   the particular session.
    \ The DER encoding of the following is\n   encrypted in the ticket's session key,
    with a key usage value of 11\n   in normal application exchanges, or 7 when used
    as the PA-TGS-REQ\n   PA-DATA field of a TGS-REQ exchange (see Section 5.4.1):\n
    \  -- Unencrypted authenticator\n   Authenticator   ::= [APPLICATION 2] SEQUENCE
    \ {\n           authenticator-vno       [0] INTEGER (5),\n           crealm                  [1]
    Realm,\n           cname                   [2] PrincipalName,\n           cksum
    \                  [3] Checksum OPTIONAL,\n           cusec                   [4]
    Microseconds,\n           ctime                   [5] KerberosTime,\n           subkey
    \                 [6] EncryptionKey OPTIONAL,\n           seq-number              [7]
    UInt32 OPTIONAL,\n           authorization-data      [8] AuthorizationData OPTIONAL\n
    \  }\n   authenticator-vno\n      This field specifies the version number for
    the format of the\n      authenticator.  This document specifies version 5.\n
    \  crealm and cname\n      These fields are the same as those described for the
    ticket in\n      section 5.3.\n   cksum\n      This field contains a checksum
    of the application data that\n      accompanies the KRB_AP_REQ, computed using
    a key usage value of 10\n      in normal application exchanges, or 6 when used
    in the TGS-REQ\n      PA-TGS-REQ AP-DATA field.\n   cusec\n      This field contains
    the microsecond part of the client's\n      timestamp.  Its value (before encryption)
    ranges from 0 to 999999.\n      It often appears along with ctime.  The two fields
    are used\n      together to specify a reasonably accurate timestamp.\n   ctime\n
    \     This field contains the current time on the client's host.\n   subkey\n
    \     This field contains the client's choice for an encryption key to\n      be
    used to protect this specific application session.  Unless an\n      application
    specifies otherwise, if this field is left out, the\n      session key from the
    ticket will be used.\n   seq-number\n      This optional field includes the initial
    sequence number to be\n      used by the KRB_PRIV or KRB_SAFE messages when sequence
    numbers\n      are used to detect replays.  (It may also be used by application\n
    \     specific messages.)  When included in the authenticator, this\n      field
    specifies the initial sequence number for messages from the\n      client to the
    server.  When included in the AP-REP message, the\n      initial sequence number
    is that for messages from the server to\n      the client.  When used in KRB_PRIV
    or KRB_SAFE messages, it is\n      incremented by one after each message is sent.
    \ Sequence numbers\n      fall in the range 0 through 2^32 - 1 and wrap to zero
    following\n      the value 2^32 - 1.\n      For sequence numbers to support the
    detection of replays\n      adequately, they SHOULD be non-repeating, even across
    connection\n      boundaries.  The initial sequence number SHOULD be random and\n
    \     uniformly distributed across the full space of possible sequence\n      numbers,
    so that it cannot be guessed by an attacker and so that\n      it and the successive
    sequence numbers do not repeat other\n      sequences.  In the event that more
    than 2^32 messages are to be\n      generated in a series of KRB_PRIV or KRB_SAFE
    messages, rekeying\n      SHOULD be performed before sequence numbers are reused
    with the\n      same encryption key.\n      Implmentation note: Historically,
    some implementations transmit\n      signed twos-complement numbers for sequence
    numbers.  In the\n      interests of compatibility, implementations MAY accept
    the\n      equivalent negative number where a positive number greater than\n      2^31
    - 1 is expected.\n      Implementation note: As noted before, some implementations
    omit\n      the optional sequence number when its value would be zero.\n      Implementations
    MAY accept an omitted sequence number when\n      expecting a value of zero, and
    SHOULD NOT transmit an\n      Authenticator with a initial sequence number of
    zero.\n   authorization-data\n      This field is the same as described for the
    ticket in Section 5.3.\n      It is optional and will only appear when additional
    restrictions\n      are to be placed on the use of a ticket, beyond those carried
    in\n      the ticket itself.\n"
  title: 5.5.1.  KRB_AP_REQ Definition
- contents:
  - "5.5.2.  KRB_AP_REP Definition\n   The KRB_AP_REP message contains the Kerberos
    protocol version number,\n   the message type, and an encrypted time-stamp.  The
    message is sent\n   in response to an application request (KRB_AP_REQ) for which
    the\n   mutual authentication option has been selected in the ap-options\n   field.\n
    \  AP-REP          ::= [APPLICATION 15] SEQUENCE {\n           pvno            [0]
    INTEGER (5),\n           msg-type        [1] INTEGER (15),\n           enc-part
    \       [2] EncryptedData -- EncAPRepPart\n   }\n   EncAPRepPart    ::= [APPLICATION
    27] SEQUENCE {\n           ctime           [0] KerberosTime,\n           cusec
    \          [1] Microseconds,\n           subkey          [2] EncryptionKey OPTIONAL,\n
    \          seq-number      [3] UInt32 OPTIONAL\n   }\n   The encoded EncAPRepPart
    is encrypted in the shared session key of\n   the ticket.  The optional subkey
    field can be used in an\n   application-arranged negotiation to choose a per association
    session\n   key.\n   pvno and msg-type\n      These fields are described above
    in Section 5.4.1.  msg-type is\n      KRB_AP_REP.\n   enc-part\n      This field
    is described above in Section 5.4.2.  It is computed\n      with a key usage value
    of 12.\n   ctime\n      This field contains the current time on the client's host.\n
    \  cusec\n      This field contains the microsecond part of the client's\n      timestamp.\n
    \  subkey\n      This field contains an encryption key that is to be used to\n
    \     protect this specific application session.  See Section 3.2.6 for\n      specifics
    on how this field is used to negotiate a key.  Unless an\n      application specifies
    otherwise, if this field is left out, the\n      sub-session key from the authenticator
    or if the latter is also\n      left out, the session key from the ticket will
    be used.\n   seq-number\n      This field is described above in Section 5.3.2.\n"
  title: 5.5.2.  KRB_AP_REP Definition
- contents:
  - "5.5.3.  Error Message Reply\n   If an error occurs while processing the application
    request, the\n   KRB_ERROR message will be sent in response.  See Section 5.9.1
    for\n   the format of the error message.  The cname and crealm fields MAY be\n
    \  left out if the server cannot determine their appropriate values from\n   the
    corresponding KRB_AP_REQ message.  If the authenticator was\n   decipherable,
    the ctime and cusec fields will contain the values from\n   it.\n"
  title: 5.5.3.  Error Message Reply
- contents:
  - "5.6.  KRB_SAFE Message Specification\n   This section specifies the format of
    a message that can be used by\n   either side (client or server) of an application
    to send a tamper-\n   proof message to its peer.  It presumes that a session key
    has\n   previously been exchanged (for example, by using the\n   KRB_AP_REQ/KRB_AP_REP
    messages).\n"
  title: 5.6.  KRB_SAFE Message Specification
- contents:
  - "5.6.1.  KRB_SAFE definition\n   The KRB_SAFE message contains user data along
    with a collision-proof\n   checksum keyed with the last encryption key negotiated
    via subkeys,\n   or with the session key if no negotiation has occurred.  The
    message\n   fields are as follows:\n   KRB-SAFE        ::= [APPLICATION 20] SEQUENCE
    {\n           pvno            [0] INTEGER (5),\n           msg-type        [1]
    INTEGER (20),\n           safe-body       [2] KRB-SAFE-BODY,\n           cksum
    \          [3] Checksum\n   }\n   KRB-SAFE-BODY   ::= SEQUENCE {\n           user-data
    \      [0] OCTET STRING,\n           timestamp       [1] KerberosTime OPTIONAL,\n
    \          usec            [2] Microseconds OPTIONAL,\n           seq-number      [3]
    UInt32 OPTIONAL,\n           s-address       [4] HostAddress,\n           r-address
    \      [5] HostAddress OPTIONAL\n   }\n   pvno and msg-type\n      These fields
    are described above in Section 5.4.1.  msg-type is\n      KRB_SAFE.\n   safe-body\n
    \     This field is a placeholder for the body of the KRB-SAFE message.\n   cksum\n
    \     This field contains the checksum of the application data, computed\n      with
    a key usage value of 15.\n      The checksum is computed over the encoding of
    the KRB-SAFE\n      sequence.  First, the cksum is set to a type zero, zero-length\n
    \     value, and the checksum is computed over the encoding of the KRB-\n      SAFE
    sequence.  Then the checksum is set to the result of that\n      computation.
    \ Finally, the KRB-SAFE sequence is encoded again.\n      This method, although
    different than the one specified in RFC\n      1510, corresponds to existing practice.\n
    \  user-data\n      This field is part of the KRB_SAFE and KRB_PRIV messages,
    and\n      contains the application-specific data that is being passed from\n
    \     the sender to the recipient.\n   timestamp\n      This field is part of
    the KRB_SAFE and KRB_PRIV messages.  Its\n      contents are the current time
    as known by the sender of the\n      message.  By checking the timestamp, the
    recipient of the message\n      is able to make sure that it was recently generated,
    and is not a\n      replay.\n   usec\n      This field is part of the KRB_SAFE
    and KRB_PRIV headers.  It\n      contains the microsecond part of the timestamp.\n
    \  seq-number\n      This field is described above in Section 5.3.2.\n   s-address\n
    \     Sender's address.\n      This field specifies the address in use by the
    sender of the\n      message.\n   r-address\n      This field specifies the address
    in use by the recipient of the\n      message.  It MAY be omitted for some uses
    (such as broadcast\n      protocols), but the recipient MAY arbitrarily reject
    such\n      messages.  This field, along with s-address, can be used to help\n
    \     detect messages that have been incorrectly or maliciously\n      delivered
    to the wrong recipient.\n"
  title: 5.6.1.  KRB_SAFE definition
- contents:
  - "5.7.  KRB_PRIV Message Specification\n   This section specifies the format of
    a message that can be used by\n   either side (client or server) of an application
    to send a message to\n   its peer securely and privately.  It presumes that a
    session key has\n   previously been exchanged (for example, by using the\n   KRB_AP_REQ/KRB_AP_REP
    messages).\n"
  title: 5.7.  KRB_PRIV Message Specification
- contents:
  - "5.7.1.  KRB_PRIV Definition\n   The KRB_PRIV message contains user data encrypted
    in the Session Key.\n   The message fields are as follows:\n   KRB-PRIV        ::=
    [APPLICATION 21] SEQUENCE {\n           pvno            [0] INTEGER (5),\n           msg-type
    \       [1] INTEGER (21),\n                           -- NOTE: there is no [2]
    tag\n           enc-part        [3] EncryptedData -- EncKrbPrivPart\n   }\n   EncKrbPrivPart
    \ ::= [APPLICATION 28] SEQUENCE {\n           user-data       [0] OCTET STRING,\n
    \          timestamp       [1] KerberosTime OPTIONAL,\n           usec            [2]
    Microseconds OPTIONAL,\n           seq-number      [3] UInt32 OPTIONAL,\n           s-address
    \      [4] HostAddress -- sender's addr --,\n           r-address       [5] HostAddress
    OPTIONAL -- recip's addr\n   }\n   pvno and msg-type\n      These fields are described
    above in Section 5.4.1.  msg-type is\n      KRB_PRIV.\n   enc-part\n      This
    field holds an encoding of the EncKrbPrivPart sequence\n      encrypted under
    the session key, with a key usage value of 13.\n      This encrypted encoding
    is used for the enc-part field of the\n      KRB-PRIV message.\n   user-data,
    timestamp, usec, s-address, and r-address\n      These fields are described above
    in Section 5.6.1.\n   seq-number\n      This field is described above in Section
    5.3.2.\n"
  title: 5.7.1.  KRB_PRIV Definition
- contents:
  - "5.8.  KRB_CRED Message Specification\n   This section specifies the format of
    a message that can be used to\n   send Kerberos credentials from one principal
    to another.  It is\n   presented here to encourage a common mechanism to be used
    by\n   applications when forwarding tickets or providing proxies to\n   subordinate
    servers.  It presumes that a session key has already been\n   exchanged, perhaps
    by using the KRB_AP_REQ/KRB_AP_REP messages.\n"
  title: 5.8.  KRB_CRED Message Specification
- contents:
  - "5.8.1.  KRB_CRED Definition\n   The KRB_CRED message contains a sequence of tickets
    to be sent and\n   information needed to use the tickets, including the session
    key from\n   each.  The information needed to use the tickets is encrypted under\n
    \  an encryption key previously exchanged or transferred alongside the\n   KRB_CRED
    message.  The message fields are as follows:\n   KRB-CRED        ::= [APPLICATION
    22] SEQUENCE {\n           pvno            [0] INTEGER (5),\n           msg-type
    \       [1] INTEGER (22),\n           tickets         [2] SEQUENCE OF Ticket,\n
    \          enc-part        [3] EncryptedData -- EncKrbCredPart\n   }\n   EncKrbCredPart
    \ ::= [APPLICATION 29] SEQUENCE {\n           ticket-info     [0] SEQUENCE OF
    KrbCredInfo,\n           nonce           [1] UInt32 OPTIONAL,\n           timestamp
    \      [2] KerberosTime OPTIONAL,\n           usec            [3] Microseconds
    OPTIONAL,\n           s-address       [4] HostAddress OPTIONAL,\n           r-address
    \      [5] HostAddress OPTIONAL\n   }\n   KrbCredInfo     ::= SEQUENCE {\n           key
    \            [0] EncryptionKey,\n           prealm          [1] Realm OPTIONAL,\n
    \          pname           [2] PrincipalName OPTIONAL,\n           flags           [3]
    TicketFlags OPTIONAL,\n           authtime        [4] KerberosTime OPTIONAL,\n
    \          starttime       [5] KerberosTime OPTIONAL,\n           endtime         [6]
    KerberosTime OPTIONAL,\n           renew-till      [7] KerberosTime OPTIONAL,\n
    \          srealm          [8] Realm OPTIONAL,\n           sname           [9]
    PrincipalName OPTIONAL,\n           caddr           [10] HostAddresses OPTIONAL\n
    \  }\n   pvno and msg-type\n      These fields are described above in Section
    5.4.1.  msg-type is\n      KRB_CRED.\n   tickets\n      These are the tickets
    obtained from the KDC specifically for use\n      by the intended recipient.  Successive
    tickets are paired with the\n      corresponding KrbCredInfo sequence from the
    enc-part of the KRB-\n      CRED message.\n   enc-part\n      This field holds
    an encoding of the EncKrbCredPart sequence\n      encrypted under the session
    key shared by the sender and the\n      intended recipient, with a key usage value
    of 14.  This encrypted\n      encoding is used for the enc-part field of the KRB-CRED
    message.\n      Implementation note: Implementations of certain applications,
    most\n      notably certain implementations of the Kerberos GSS-API mechanism,\n
    \     do not separately encrypt the contents of the EncKrbCredPart of\n      the
    KRB-CRED message when sending it.  In the case of those GSS-\n      API mechanisms,
    this is not a security vulnerability, as the\n      entire KRB-CRED message is
    itself embedded in an encrypted\n      message.\n   nonce\n      If practical,
    an application MAY require the inclusion of a nonce\n      generated by the recipient
    of the message.  If the same value is\n      included as the nonce in the message,
    it provides evidence that\n      the message is fresh and has not been replayed
    by an attacker.  A\n      nonce MUST NEVER be reused.\n   timestamp and usec\n
    \     These fields specify the time that the KRB-CRED message was\n      generated.
    \ The time is used to provide assurance that the message\n      is fresh.\n   s-address
    and r-address\n      These fields are described above in Section 5.6.1.  They
    are used\n      optionally to provide additional assurance of the integrity of
    the\n      KRB-CRED message.\n   key\n      This field exists in the corresponding
    ticket passed by the KRB-\n      CRED message and is used to pass the session
    key from the sender\n      to the intended recipient.  The field's encoding is
    described in\n      Section 5.2.9.\n   The following fields are optional.  If
    present, they can be\n   associated with the credentials in the remote ticket
    file.  If left\n   out, then it is assumed that the recipient of the credentials
    already\n   knows their values.\n   prealm and pname\n      The name and realm
    of the delegated principal identity.\n   flags, authtime, starttime, endtime,
    renew-till, srealm, sname,\n   and caddr\n      These fields contain the values
    of the corresponding fields from\n      the ticket found in the ticket field.
    \ Descriptions of the fields\n      are identical to the descriptions in the KDC-REP
    message.\n"
  title: 5.8.1.  KRB_CRED Definition
- contents:
  - "5.9.  Error Message Specification\n   This section specifies the format for the
    KRB_ERROR message.  The\n   fields included in the message are intended to return
    as much\n   information as possible about an error.  It is not expected that all\n
    \  the information required by the fields will be available for all\n   types
    of errors.  If the appropriate information is not available\n   when the message
    is composed, the corresponding field will be left\n   out of the message.\n   Note
    that because the KRB_ERROR message is not integrity protected,\n   it is quite
    possible for an intruder to synthesize or modify it.  In\n   particular, this
    means that the client SHOULD NOT use any fields in\n   this message for security-critical
    purposes, such as setting a system\n   clock or generating a fresh authenticator.
    \ The message can be\n   useful, however, for advising a user on the reason for
    some failure.\n"
  title: 5.9.  Error Message Specification
- contents:
  - "5.9.1.  KRB_ERROR Definition\n   The KRB_ERROR message consists of the following
    fields:\n   KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {\n           pvno            [0]
    INTEGER (5),\n           msg-type        [1] INTEGER (30),\n           ctime           [2]
    KerberosTime OPTIONAL,\n           cusec           [3] Microseconds OPTIONAL,\n
    \          stime           [4] KerberosTime,\n           susec           [5] Microseconds,\n
    \          error-code      [6] Int32,\n           crealm          [7] Realm OPTIONAL,\n
    \          cname           [8] PrincipalName OPTIONAL,\n           realm           [9]
    Realm -- service realm --,\n           sname           [10] PrincipalName -- service
    name --,\n           e-text          [11] KerberosString OPTIONAL,\n           e-data
    \         [12] OCTET STRING OPTIONAL\n   }\n   pvno and msg-type\n      These
    fields are described above in Section 5.4.1.  msg-type is\n      KRB_ERROR.\n
    \  ctime and cusec\n      These fields are described above in Section 5.5.2.  If
    the values\n      for these fields are known to the entity generating the error
    (as\n      they would be if the KRB-ERROR is generated in reply to, e.g., a\n
    \     failed authentication service request), they should be populated\n      in
    the KRB-ERROR.  If the values are not available, these fields\n      can be omitted.\n
    \  stime\n      This field contains the current time on the server.  It is of
    type\n      KerberosTime.\n   susec\n      This field contains the microsecond
    part of the server's\n      timestamp.  Its value ranges from 0 to 999999.  It
    appears along\n      with stime.  The two fields are used in conjunction to specify
    a\n      reasonably accurate timestamp.\n   error-code\n      This field contains
    the error code returned by Kerberos or the\n      server when a request fails.
    \ To interpret the value of this field\n      see the list of error codes in Section
    7.5.9.  Implementations are\n      encouraged to provide for national language
    support in the display\n      of error messages.\n   crealm, and cname\n      These
    fields are described above in Section 5.3.  When the entity\n      generating
    the error knows these values, they should be populated\n      in the KRB-ERROR.
    \ If the values are not known, the crealm and\n      cname fields SHOULD be omitted.\n
    \  realm and sname\n      These fields are described above in Section 5.3.\n   e-text\n
    \     This field contains additional text to help explain the error code\n      associated
    with the failed request (for example, it might include\n      a principal name
    which was unknown).\n   e-data\n      This field contains additional data about
    the error for use by the\n      application to help it recover from or handle
    the error.  If the\n      errorcode is KDC_ERR_PREAUTH_REQUIRED, then the e-data
    field will\n      contain an encoding of a sequence of padata fields, each\n      corresponding
    to an acceptable pre-authentication method and\n      optionally containing data
    for the method:\n      METHOD-DATA     ::= SEQUENCE OF PA-DATA\n   For error codes
    defined in this document other than\n   KDC_ERR_PREAUTH_REQUIRED, the format and
    contents of the e-data field\n   are implementation-defined.  Similarly, for future
    error codes, the\n   format and contents of the e-data field are implementation-defined\n
    \  unless specified otherwise.  Whether defined by the implementation or\n   in
    a future document, the e-data field MAY take the form of TYPED-\n   DATA:\n   TYPED-DATA
    \     ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {\n           data-type       [0]
    Int32,\n           data-value      [1] OCTET STRING OPTIONAL\n   }\n"
  title: 5.9.1.  KRB_ERROR Definition
- contents:
  - "5.10.  Application Tag Numbers\n   The following table lists the application
    class tag numbers used by\n   various data types defined in this section.\n   Tag
    Number(s)  Type Name      Comments\n   0                             unused\n
    \  1              Ticket         PDU\n   2              Authenticator  non-PDU\n
    \  3              EncTicketPart  non-PDU\n   4-9                           unused\n
    \  10             AS-REQ         PDU\n   11             AS-REP         PDU\n   12
    \            TGS-REQ        PDU\n   13             TGS-REP        PDU\n   14             AP-REQ
    \        PDU\n   15             AP-REP         PDU\n   16             RESERVED16
    \    TGT-REQ (for user-to-user)\n   17             RESERVED17     TGT-REP (for
    user-to-user)\n   18-19                         unused\n   20             KRB-SAFE
    \      PDU\n   21             KRB-PRIV       PDU\n   22             KRB-CRED       PDU\n
    \  23-24                         unused\n   25             EncASRepPart   non-PDU\n
    \  26             EncTGSRepPart  non-PDU\n   27             EncApRepPart   non-PDU\n
    \  28             EncKrbPrivPart non-PDU\n   29             EncKrbCredPart non-PDU\n
    \  30             KRB-ERROR      PDU\n   The ASN.1 types marked above as \"PDU\"
    (Protocol Data Unit) are the\n   only ASN.1 types intended as top-level types
    of the Kerberos\n   protocol, and are the only types that may be used as elements
    in\n   another protocol that makes use of Kerberos.\n"
  title: 5.10.  Application Tag Numbers
- contents:
  - '6.  Naming Constraints

    '
  title: 6.  Naming Constraints
- contents:
  - "6.1.  Realm Names\n   Although realm names are encoded as GeneralStrings and
    technically a\n   realm can select any name it chooses, interoperability across
    realm\n   boundaries requires agreement on how realm names are to be assigned,\n
    \  and what information they imply.\n   To enforce these conventions, each realm
    MUST conform to the\n   conventions itself, and it MUST require that any realms
    with which\n   inter-realm keys are shared also conform to the conventions and\n
    \  require the same from its neighbors.\n   Kerberos realm names are case sensitive.
    \ Realm names that differ\n   only in the case of the characters are not equivalent.
    \ There are\n   presently three styles of realm names: domain, X500, and other.\n
    \  Examples of each style follow:\n        domain:   ATHENA.MIT.EDU\n          X500:
    \  C=US/O=OSF\n         other:   NAMETYPE:rest/of.name=without-restrictions\n
    \  Domain style realm names MUST look like domain names: they consist of\n   components
    separated by periods (.) and they contain neither colons\n   (:) nor slashes (/).
    \ Though domain names themselves are case\n   insensitive, in order for realms
    to match, the case must match as\n   well.  When establishing a new realm name
    based on an internet domain\n   name it is recommended by convention that the
    characters be converted\n   to uppercase.\n   X.500 names contain an equals sign
    (=) and cannot contain a colon (:)\n   before the equals sign.  The realm names
    for X.500 names will be\n   string representations of the names with components
    separated by\n   slashes.  Leading and trailing slashes will not be included.
    \ Note\n   that the slash separator is consistent with Kerberos implementations\n
    \  based on RFC 1510, but it is different from the separator recommended\n   in
    RFC 2253.\n   Names that fall into the other category MUST begin with a prefix
    that\n   contains no equals sign (=) or period (.), and the prefix MUST be\n   followed
    by a colon (:) and the rest of the name.  All prefixes\n   expect those beginning
    with used.  Presently none are assigned.\n   The reserved category includes strings
    that do not fall into the\n   first three categories.  All names in this category
    are reserved.  It\n   is unlikely that names will be assigned to this category
    unless there\n   is a very strong argument for not using the 'other' category.\n
    \  These rules guarantee that there will be no conflicts between the\n   various
    name styles.  The following additional constraints apply to\n   the assignment
    of realm names in the domain and X.500 categories:\n   either the name of a realm
    for the domain or X.500 formats must be\n   used by the organization owning (to
    whom it was assigned) an Internet\n   domain name or X.500 name, or, in the case
    that no such names are\n   registered, authority to use a realm name MAY be derived
    from the\n   authority of the parent realm.  For example, if there is no domain\n
    \  name for E40.MIT.EDU, then the administrator of the MIT.EDU realm can\n   authorize
    the creation of a realm with that name.\n   This is acceptable because the organization
    to which the parent is\n   assigned is presumably the organization authorized
    to assign names to\n   its children in the X.500 and domain name systems as well.
    \ If the\n   parent assigns a realm name without also registering it in the domain\n
    \  name or X.500 hierarchy, it is the parent's responsibility to make\n   sure
    that in the future there will not exist a name identical to the\n   realm name
    of the child unless it is assigned to the same entity as\n   the realm name.\n"
  title: 6.1.  Realm Names
- contents:
  - "6.2.  Principal Names\n   As was the case for realm names, conventions are needed
    to ensure\n   that all agree on what information is implied by a principal name.\n
    \  The name-type field that is part of the principal name indicates the\n   kind
    of information implied by the name.  The name-type SHOULD be\n   treated only
    as a hint to interpreting the meaning of a name.  It is\n   not significant when
    checking for equivalence.  Principal names that\n   differ only in the name-type
    identify the same principal.  The name\n   type does not partition the name space.
    \ Ignoring the name type, no\n   two names can be the same (i.e., at least one
    of the components, or\n   the realm, MUST be different).  The following name types
    are defined:\n   Name Type       Value  Meaning\n   NT-UNKNOWN        0    Name
    type not known\n   NT-PRINCIPAL      1    Just the name of the principal as in
    DCE,\n                            or for users\n   NT-SRV-INST       2    Service
    and other unique instance (krbtgt)\n   NT-SRV-HST        3    Service with host
    name as instance\n                            (telnet, rcommands)\n   NT-SRV-XHST
    \      4    Service with host as remaining components\n   NT-UID            5
    \   Unique ID\n   NT-X500-PRINCIPAL 6    Encoded X.509 Distinguished name [RFC2253]\n
    \  NT-SMTP-NAME      7    Name in form of SMTP email name\n                            (e.g.,
    user@example.com)\n   NT-ENTERPRISE    10    Enterprise name - may be mapped to
    principal\n                            name\n   When a name implies no information
    other than its uniqueness at a\n   particular time, the name type PRINCIPAL SHOULD
    be used.  The\n   principal name type SHOULD be used for users, and it might also
    be\n   used for a unique server.  If the name is a unique machine-generated\n
    \  ID that is guaranteed never to be reassigned, then the name type of\n   UID
    SHOULD be used.  (Note that it is generally a bad idea to\n   reassign names of
    any type since stale entries might remain in access\n   control lists.)\n   If
    the first component of a name identifies a service and the\n   remaining components
    identify an instance of the service in a\n   server-specified manner, then the
    name type of SRV-INST SHOULD be\n   used.  An example of this name type is the
    Kerberos ticket-granting\n   service whose name has a first component of krbtgt
    and a second\n   component identifying the realm for which the ticket is valid.\n
    \  If the first component of a name identifies a service and there is a\n   single
    component following the service name identifying the instance\n   as the host
    on which the server is running, then the name type\n   SRV-HST SHOULD be used.
    \ This type is typically used for Internet\n   services such as telnet and the
    Berkeley R commands.  If the separate\n   components of the host name appear as
    successive components following\n   the name of the service, then the name type
    SRV-XHST SHOULD be used.\n   This type might be used to identify servers on hosts
    with X.500\n   names, where the slash (/) might otherwise be ambiguous.\n   A
    name type of NT-X500-PRINCIPAL SHOULD be used when a name from an\n   X.509 certificate
    is translated into a Kerberos name.  The encoding\n   of the X.509 name as a Kerberos
    principal shall conform to the\n   encoding rules specified in RFC 2253.\n   A
    name type of SMTP allows a name to be of a form that resembles an\n   SMTP email
    name.  This name, including an \"@\" and a domain name, is\n   used as the one
    component of the principal name.\n   A name type of UNKNOWN SHOULD be used when
    the form of the name is\n   not known.  When comparing names, a name of type UNKNOWN
    will match\n   principals authenticated with names of any type.  A principal\n
    \  authenticated with a name of type UNKNOWN, however, will only match\n   other
    names of type UNKNOWN.\n   Names of any type with an initial component of 'krbtgt'
    are reserved\n   for the Kerberos ticket-granting service.  See Section 7.3 for
    the\n   form of such names.\n"
  title: 6.2.  Principal Names
- contents:
  - "6.2.1.  Name of Server Principals\n   The principal identifier for a server on
    a host will generally be\n   composed of two parts: (1) the realm of the KDC with
    which the server\n   is registered, and (2) a two-component name of type NT-SRV-HST,
    if\n   the host name is an Internet domain name, or a multi-component name\n   of
    type NT-SRV-XHST, if the name of the host is of a form (such as\n   X.500) that
    allows slash (/) separators.  The first component of the\n   two- or multi-component
    name will identify the service, and the\n   latter components will identify the
    host.  Where the name of the host\n   is not case sensitive (for example, with
    Internet domain names) the\n   name of the host MUST be lowercase.  If specified
    by the application\n   protocol for services such as telnet and the Berkeley R
    commands that\n   run with system privileges, the first component MAY be the string\n
    \  'host' instead of a service-specific identifier.\n"
  title: 6.2.1.  Name of Server Principals
- contents:
  - '7.  Constants and Other Defined Values

    '
  title: 7.  Constants and Other Defined Values
- contents:
  - "7.1.  Host Address Types\n   All negative values for the host address type are
    reserved for local\n   use.  All non-negative values are reserved for officially
    assigned\n   type fields and interpretations.\n   Internet (IPv4) Addresses\n
    \     Internet (IPv4) addresses are 32-bit (4-octet) quantities, encoded\n      in
    MSB order (most significant byte first).  The IPv4 loopback\n      address SHOULD
    NOT appear in a Kerberos PDU.  The type of IPv4\n      addresses is two (2).\n
    \  Internet (IPv6) Addresses\n      IPv6 addresses [RFC3513] are 128-bit (16-octet)
    quantities,\n      encoded in MSB order (most significant byte first).  The type
    of\n      IPv6 addresses is twenty-four (24).  The following addresses MUST\n
    \     NOT appear in any Kerberos PDU:\n         *  the Unspecified Address\n         *
    \ the Loopback Address\n         *  Link-Local addresses\n      This restriction
    applies to the inclusion in the address fields of\n      Kerberos PDUs, but not
    to the address fields of packets that might\n      carry such PDUs.  The restriction
    is necessary because the use of\n      an address with non-global scope could
    allow the acceptance of a\n      message sent from a node that may have the same
    address, but which\n      is not the host intended by the entity that added the
    restriction.\n      If the link-local address type needs to be used for communication,\n
    \     then the address restriction in tickets must not be used (i.e.,\n      addressless
    tickets must be used).\n      IPv4-mapped IPv6 addresses MUST be represented as
    addresses of\n      type 2.\n   DECnet Phase IV Addresses\n      DECnet Phase
    IV addresses are 16-bit addresses, encoded in LSB\n      order.  The type of DECnet
    Phase IV addresses is twelve (12).\n   Netbios Addresses\n      Netbios addresses
    are 16-octet addresses typically composed of 1\n      to 15 alphanumeric characters
    and padded with the US-ASCII SPC\n      character (code 32).  The 16th octet MUST
    be the US-ASCII NUL\n      character (code 0).  The type of Netbios addresses
    is twenty (20).\n   Directional Addresses\n      Including the sender address
    in KRB_SAFE and KRB_PRIV messages is\n      undesirable in many environments because
    the addresses may be\n      changed in transport by network address translators.
    \ However, if\n      these addresses are removed, the messages may be subject
    to a\n      reflection attack in which a message is reflected back to its\n      originator.
    \ The directional address type provides a way to avoid\n      transport addresses
    and reflection attacks.  Directional addresses\n      are encoded as four-byte
    unsigned integers in network byte order.\n      If the message is originated by
    the party sending the original\n      KRB_AP_REQ message, then an address of 0
    SHOULD be used.  If the\n      message is originated by the party to whom that
    KRB_AP_REQ was\n      sent, then the address 1 SHOULD be used.  Applications involving\n
    \     multiple parties can specify the use of other addresses.\n      Directional
    addresses MUST only be used for the sender address\n      field in the KRB_SAFE
    or KRB_PRIV messages.  They MUST NOT be used\n      as a ticket address or in
    a KRB_AP_REQ message.  This address type\n      SHOULD only be used in situations
    where the sending party knows\n      that the receiving party supports the address
    type.  This\n      generally means that directional addresses may only be used
    when\n      the application protocol requires their support.  Directional\n      addresses
    are type (3).\n"
  title: 7.1.  Host Address Types
- contents:
  - "7.2.  KDC Messaging: IP Transports\n   Kerberos defines two IP transport mechanisms
    for communication\n   between clients and servers: UDP/IP and TCP/IP.\n"
  title: '7.2.  KDC Messaging: IP Transports'
- contents:
  - "7.2.1.  UDP/IP transport\n   Kerberos servers (KDCs) supporting IP transports
    MUST accept UDP\n   requests and SHOULD listen for them on port 88 (decimal) unless\n
    \  specifically configured to listen on an alternative UDP port.\n   Alternate
    ports MAY be used when running multiple KDCs for multiple\n   realms on the same
    host.\n   Kerberos clients supporting IP transports SHOULD support the sending\n
    \  of UDP requests.  Clients SHOULD use KDC discovery [7.2.3] to\n   identify
    the IP address and port to which they will send their\n   request.\n   When contacting
    a KDC for a KRB_KDC_REQ request using UDP/IP\n   transport, the client shall send
    a UDP datagram containing only an\n   encoding of the request to the KDC.  The
    KDC will respond with a\n   reply datagram containing only an encoding of the
    reply message\n   (either a KRB_ERROR or a KRB_KDC_REP) to the sending port at
    the\n   sender's IP address.  The response to a request made through UDP/IP\n
    \  transport MUST also use UDP/IP transport.  If the response cannot be\n   handled
    using UDP (for example, because it is too large), the KDC\n   MUST return KRB_ERR_RESPONSE_TOO_BIG,
    forcing the client to retry the\n   request using the TCP transport.\n"
  title: 7.2.1.  UDP/IP transport
- contents:
  - "7.2.2.  TCP/IP Transport\n   Kerberos servers (KDCs) supporting IP transports
    MUST accept TCP\n   requests and SHOULD listen for them on port 88 (decimal) unless\n
    \  specifically configured to listen on an alternate TCP port.\n   Alternate ports
    MAY be used when running multiple KDCs for multiple\n   realms on the same host.\n
    \  Clients MUST support the sending of TCP requests, but MAY choose to\n   try
    a request initially using the UDP transport.  Clients SHOULD use\n   KDC discovery
    [7.2.3] to identify the IP address and port to which\n   they will send their
    request.\n   Implementation note: Some extensions to the Kerberos protocol will\n
    \  not succeed if any client or KDC not supporting the TCP transport is\n   involved.
    \ Implementations of RFC 1510 were not required to support\n   TCP/IP transports.\n
    \  When the KRB_KDC_REQ message is sent to the KDC over a TCP stream,\n   the
    response (KRB_KDC_REP or KRB_ERROR message) MUST be returned to\n   the client
    on the same TCP stream that was established for the\n   request.  The KDC MAY
    close the TCP stream after sending a response,\n   but MAY leave the stream open
    for a reasonable period of time if it\n   expects a follow-up.  Care must be taken
    in managing TCP/IP\n   connections on the KDC to prevent denial of service attacks
    based on\n   the number of open TCP/IP connections.\n   The client MUST be prepared
    to have the stream closed by the KDC at\n   any time after the receipt of a response.
    \ A stream closure SHOULD\n   NOT be treated as a fatal error.  Instead, if multiple
    exchanges are\n   required (e.g., certain forms of pre-authentication), the client
    may\n   need to establish a new connection when it is ready to send\n   subsequent
    messages.  A client MAY close the stream after receiving a\n   response, and SHOULD
    close the stream if it does not expect to send\n   follow-up messages.\n   A client
    MAY send multiple requests before receiving responses,\n   though it must be prepared
    to handle the connection being closed\n   after the first response.\n   Each request
    (KRB_KDC_REQ) and response (KRB_KDC_REP or KRB_ERROR)\n   sent over the TCP stream
    is preceded by the length of the request as\n   4 octets in network byte order.
    \ The high bit of the length is\n   reserved for future expansion and MUST currently
    be set to zero.  If\n   a KDC that does not understand how to interpret a set
    high bit of the\n   length encoding receives a request with the high order bit
    of the\n   length set, it MUST return a KRB-ERROR message with the error\n   KRB_ERR_FIELD_TOOLONG
    and MUST close the TCP stream.\n   If multiple requests are sent over a single
    TCP connection and the\n   KDC sends multiple responses, the KDC is not required
    to send the\n   responses in the order of the corresponding requests.  This may\n
    \  permit some implementations to send each response as soon as it is\n   ready,
    even if earlier requests are still being processed (for\n   example, waiting for
    a response from an external device or database).\n"
  title: 7.2.2.  TCP/IP Transport
- contents:
  - "7.2.3.  KDC Discovery on IP Networks\n   Kerberos client implementations MUST
    provide a means for the client\n   to determine the location of the Kerberos Key
    Distribution Centers\n   (KDCs).  Traditionally, Kerberos implementations have
    stored such\n   configuration information in a file on each client machine.\n
    \  Experience has shown that this method of storing configuration\n   information
    presents problems with out-of-date information and\n   scaling, especially when
    using cross-realm authentication.  This\n   section describes a method for using
    the Domain Name System [RFC1035]\n   for storing KDC location information.\n"
  title: 7.2.3.  KDC Discovery on IP Networks
- contents:
  - "7.2.3.1.  DNS vs. Kerberos: Case Sensitivity of Realm Names\n   In Kerberos,
    realm names are case sensitive.  Although it is strongly\n   encouraged that all
    realm names be all uppercase, this recommendation\n   has not been adopted by
    all sites.  Some sites use all lowercase\n   names and other use mixed case.  DNS,
    on the other hand, is case\n   insensitive for queries.  Because the realm names
    \"MYREALM\",\n   \"myrealm\", and \"MyRealm\" are all different, but resolve the
    same in\n   the domain name system, it is necessary that only one of the possible\n
    \  combinations of upper- and lowercase characters be used in realm\n   names.\n"
  title: '7.2.3.1.  DNS vs. Kerberos: Case Sensitivity of Realm Names'
- contents:
  - "7.2.3.2.  Specifying KDC Location Information with DNS SRV records\n   KDC location
    information is to be stored using the DNS SRV RR\n   [RFC2782].  The format of
    this RR is as follows:\n      _Service._Proto.Realm TTL Class SRV Priority Weight
    Port Target\n   The Service name for Kerberos is always \"kerberos\".\n   The
    Proto can be either \"udp\" or \"tcp\".  If these SRV records are to\n   be used,
    both \"udp\" and \"tcp\" records MUST be specified for all KDC\n   deployments.\n
    \  The Realm is the Kerberos realm that this record corresponds to.  The\n   realm
    MUST be a domain-style realm name.\n   TTL, Class, SRV, Priority, Weight, and
    Target have the standard\n   meaning as defined in RFC 2782.\n   As per RFC 2782,
    the Port number used for \"_udp\" and \"_tcp\" SRV\n   records SHOULD be the value
    assigned to \"kerberos\" by the Internet\n   Assigned Number Authority: 88 (decimal),
    unless the KDC is configured\n   to listen on an alternate TCP port.\n   Implementation
    note: Many existing client implementations do not\n   support KDC Discovery and
    are configured to send requests to the IANA\n   assigned port (88 decimal), so
    it is strongly recommended that KDCs\n   be configured to listen on that port.\n"
  title: 7.2.3.2.  Specifying KDC Location Information with DNS SRV records
- contents:
  - "7.2.3.3.  KDC Discovery for Domain Style Realm Names on IP Networks\n   These
    are DNS records for a Kerberos realm EXAMPLE.COM.  It has two\n   Kerberos servers,
    kdc1.example.com and kdc2.example.com.  Queries\n   should be directed to kdc1.example.com
    first as per the specified\n   priority.  Weights are not used in these sample
    records.\n     _kerberos._udp.EXAMPLE.COM.     IN   SRV   0 0 88 kdc1.example.com.\n
    \    _kerberos._udp.EXAMPLE.COM.     IN   SRV   1 0 88 kdc2.example.com.\n     _kerberos._tcp.EXAMPLE.COM.
    \    IN   SRV   0 0 88 kdc1.example.com.\n     _kerberos._tcp.EXAMPLE.COM.     IN
    \  SRV   1 0 88 kdc2.example.com.\n"
  title: 7.2.3.3.  KDC Discovery for Domain Style Realm Names on IP Networks
- contents:
  - "7.3.  Name of the TGS\n   The principal identifier of the ticket-granting service
    shall be\n   composed of three parts: the realm of the KDC issuing the TGS ticket,\n
    \  and a two-part name of type NT-SRV-INST, with the first part \"krbtgt\"\n   and
    the second part the name of the realm that will accept the TGT.\n   For example,
    a TGT issued by the ATHENA.MIT.EDU realm to be used to\n   get tickets from the
    ATHENA.MIT.EDU KDC has a principal identifier of\n   \"ATHENA.MIT.EDU\" (realm),
    (\"krbtgt\", \"ATHENA.MIT.EDU\") (name).  A TGT\n   issued by the ATHENA.MIT.EDU
    realm to be used to get tickets from the\n   MIT.EDU realm has a principal identifier
    of \"ATHENA.MIT.EDU\" (realm),\n   (\"krbtgt\", \"MIT.EDU\") (name).\n"
  title: 7.3.  Name of the TGS
- contents:
  - "7.4.  OID Arc for KerberosV5\n   This OID MAY be used to identify Kerberos protocol
    messages\n   encapsulated in other protocols.  It also designates the OID arc
    for\n   KerberosV5-related OIDs assigned by future IETF action.\n   Implementation
    note: RFC 1510 had an incorrect value (5) for \"dod\" in\n   its OID.\n   id-krb5
    \        OBJECT IDENTIFIER ::= {\n           iso(1) identified-organization(3)
    dod(6) internet(1)\n           security(5) kerberosV5(2)\n   }\n   Assignment
    of OIDs beneath the id-krb5 arc must be obtained by\n   contacting the registrar
    for the id-krb5 arc, or its designee.  At\n   the time of the issuance of this
    RFC, such registrations can be\n   obtained by contacting krb5-oid-registrar@mit.edu.\n"
  title: 7.4.  OID Arc for KerberosV5
- contents:
  - "7.5.  Protocol Constants and Associated Values\n   The following tables list
    constants used in the protocol and define\n   their meanings.  In the \"specification\"
    section, ranges are specified\n   that limit the values of constants for which
    values are defined here.\n   This allows implementations to make assumptions about
    the maximum\n   values that will be received for these constants.  Implementations\n
    \  receiving values outside the range specified in the \"specification\"\n   section
    MAY reject the request, but they MUST recover cleanly.\n"
  title: 7.5.  Protocol Constants and Associated Values
- contents:
  - "7.5.1.  Key Usage Numbers\n   The encryption and checksum specifications in [RFC3961]
    require as\n   input a \"key usage number\", to alter the encryption key used
    in any\n   specific message in order to make certain types of cryptographic\n
    \  attack more difficult.  These are the key usage values assigned in\n   this
    document:\n           1.  AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted
    with\n               the client key (Section 5.2.7.2)\n           2.  AS-REP Ticket
    and TGS-REP Ticket (includes TGS session\n               key or application session
    key), encrypted with the\n               service key (Section 5.3)\n           3.
    \ AS-REP encrypted part (includes TGS session key or\n               application
    session key), encrypted with the client key\n               (Section 5.4.2)\n
    \          4.  TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with\n               the
    TGS session key (Section 5.4.1)\n           5.  TGS-REQ KDC-REQ-BODY AuthorizationData,
    encrypted with\n               the TGS authenticator subkey (Section 5.4.1)\n
    \          6.  TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator cksum,\n               keyed
    with the TGS session key (Section 5.5.1)\n           7.  TGS-REQ PA-TGS-REQ padata
    AP-REQ Authenticator (includes\n               TGS authenticator subkey), encrypted
    with the TGS session\n               key (Section 5.5.1)\n           8.  TGS-REP
    encrypted part (includes application session\n               key), encrypted with
    the TGS session key (Section 5.4.2)\n           9.  TGS-REP encrypted part (includes
    application session\n               key), encrypted with the TGS authenticator
    subkey\n               (Section 5.4.2)\n          10.  AP-REQ Authenticator cksum,
    keyed with the application\n               session key (Section 5.5.1)\n          11.
    \ AP-REQ Authenticator (includes application authenticator\n               subkey),
    encrypted with the application session key\n               (Section 5.5.1)\n          12.
    \ AP-REP encrypted part (includes application session\n               subkey),
    encrypted with the application session key\n               (Section 5.5.2)\n          13.
    \ KRB-PRIV encrypted part, encrypted with a key chosen by\n               the
    application (Section 5.7.1)\n          14.  KRB-CRED encrypted part, encrypted
    with a key chosen by\n               the application (Section 5.8.1)\n          15.
    \ KRB-SAFE cksum, keyed with a key chosen by the\n               application (Section
    5.6.1)\n       16-18.  Reserved for future use in Kerberos and related\n               protocols.\n
    \         19.  AD-KDC-ISSUED checksum (ad-checksum in 5.2.6.4)\n       20-21.
    \ Reserved for future use in Kerberos and related\n               protocols.\n
    \      22-25.  Reserved for use in the Kerberos Version 5 GSS-API\n               mechanisms
    [RFC4121].\n      26-511.  Reserved for future use in Kerberos and related\n               protocols.\n
    \   512-1023.  Reserved for uses internal to a Kerberos implementation.\n        1024.
    \ Encryption for application use in protocols that do not\n               specify
    key usage values\n        1025.  Checksums for application use in protocols that
    do not\n               specify key usage values\n   1026-2047.  Reserved for application
    use.\n"
  title: 7.5.1.  Key Usage Numbers
- contents:
  - "7.5.2.  PreAuthentication Data Types\n   Padata and Data Type    Padata-type
    \  Comment\n                            Value\n   PA-TGS-REQ                  1\n
    \  PA-ENC-TIMESTAMP            2\n   PA-PW-SALT                  3\n   [reserved]
    \                 4\n   PA-ENC-UNIX-TIME            5        (deprecated)\n   PA-SANDIA-SECUREID
    \         6\n   PA-SESAME                   7\n   PA-OSF-DCE                  8\n
    \  PA-CYBERSAFE-SECUREID       9\n   PA-AFS3-SALT                10\n   PA-ETYPE-INFO
    \              11\n   PA-SAM-CHALLENGE            12       (sam/otp)\n   PA-SAM-RESPONSE
    \            13       (sam/otp)\n   PA-PK-AS-REQ_OLD            14       (pkinit)\n
    \  PA-PK-AS-REP_OLD            15       (pkinit)\n   PA-PK-AS-REQ                16
    \      (pkinit)\n   PA-PK-AS-REP                17       (pkinit)\n   PA-ETYPE-INFO2
    \             19       (replaces pa-etype-info)\n   PA-USE-SPECIFIED-KVNO       20\n
    \  PA-SAM-REDIRECT             21       (sam/otp)\n   PA-GET-FROM-TYPED-DATA      22
    \      (embedded in typed data)\n   TD-PADATA                   22       (embeds
    padata)\n   PA-SAM-ETYPE-INFO           23       (sam/otp)\n   PA-ALT-PRINC                24
    \      (crawdad@fnal.gov)\n   PA-SAM-CHALLENGE2           30       (kenh@pobox.com)\n
    \  PA-SAM-RESPONSE2            31       (kenh@pobox.com)\n   PA-EXTRA-TGT                41
    \      Reserved extra TGT\n   TD-PKINIT-CMS-CERTIFICATES  101      CertificateSet
    from CMS\n   TD-KRB-PRINCIPAL            102      PrincipalName\n   TD-KRB-REALM
    \               103      Realm\n   TD-TRUSTED-CERTIFIERS       104      from PKINIT\n
    \  TD-CERTIFICATE-INDEX        105      from PKINIT\n   TD-APP-DEFINED-ERROR        106
    \     application specific\n   TD-REQ-NONCE                107      INTEGER\n
    \  TD-REQ-SEQ                  108      INTEGER\n   PA-PAC-REQUEST              128
    \     (jbrezak@exchange.microsoft.com)\n"
  title: 7.5.2.  PreAuthentication Data Types
- contents:
  - "7.5.3.  Address Types\n   Address Type                   Value\n   IPv4                             2\n
    \  Directional                      3\n   ChaosNet                         5\n
    \  XNS                              6\n   ISO                              7\n
    \  DECNET Phase IV                 12\n   AppleTalk DDP                   16\n
    \  NetBios                         20\n   IPv6                            24\n"
  title: 7.5.3.  Address Types
- contents:
  - "7.5.4.  Authorization Data Types\n   Authorization Data Type          Ad-type
    Value\n   AD-IF-RELEVANT                     1\n   AD-INTENDED-FOR-SERVER             2\n
    \  AD-INTENDED-FOR-APPLICATION-CLASS  3\n   AD-KDC-ISSUED                      4\n
    \  AD-AND-OR                          5\n   AD-MANDATORY-TICKET-EXTENSIONS     6\n
    \  AD-IN-TICKET-EXTENSIONS            7\n   AD-MANDATORY-FOR-KDC               8\n
    \  Reserved values                 9-63\n   OSF-DCE                           64\n
    \  SESAME                            65\n   AD-OSF-DCE-PKI-CERTID             66
    (hemsath@us.ibm.com)\n   AD-WIN2K-PAC                     128 (jbrezak@exchange.microsoft.com)\n
    \  AD-ETYPE-NEGOTIATION             129  (lzhu@windows.microsoft.com)\n"
  title: 7.5.4.  Authorization Data Types
- contents:
  - "7.5.5.  Transited Encoding Types\n   Transited Encoding Type         Tr-type
    Value\n   DOMAIN-X500-COMPRESS            1\n   Reserved values                 All
    others\n"
  title: 7.5.5.  Transited Encoding Types
- contents:
  - "7.5.6.  Protocol Version Number\n   Label               Value   Meaning or MIT
    Code\n   pvno                  5     Current Kerberos protocol version number\n"
  title: 7.5.6.  Protocol Version Number
- contents:
  - "7.5.7.  Kerberos Message Types\n   Message Type   Value  Meaning\n   KRB_AS_REQ
    \     10    Request for initial authentication\n   KRB_AS_REP      11    Response
    to KRB_AS_REQ request\n   KRB_TGS_REQ     12    Request for authentication based
    on TGT\n   KRB_TGS_REP     13    Response to KRB_TGS_REQ request\n   KRB_AP_REQ
    \     14    Application request to server\n   KRB_AP_REP      15    Response to
    KRB_AP_REQ_MUTUAL\n   KRB_RESERVED16  16    Reserved for user-to-user krb_tgt_request\n
    \  KRB_RESERVED17  17    Reserved for user-to-user krb_tgt_reply\n   KRB_SAFE
    \       20    Safe (checksummed) application message\n   KRB_PRIV        21    Private
    (encrypted) application message\n   KRB_CRED        22    Private (encrypted)
    message to forward\n                           credentials\n   KRB_ERROR       30
    \   Error response\n"
  title: 7.5.7.  Kerberos Message Types
- contents:
  - "7.5.8.  Name Types\n   Name Type           Value  Meaning\n   KRB_NT_UNKNOWN
    \       0    Name type not known\n   KRB_NT_PRINCIPAL      1    Just the name
    of the principal as in DCE,\n                                or for users\n   KRB_NT_SRV_INST
    \      2    Service and other unique instance (krbtgt)\n   KRB_NT_SRV_HST        3
    \   Service with host name as instance\n                                (telnet,
    rcommands)\n   KRB_NT_SRV_XHST       4    Service with host as remaining components\n
    \  KRB_NT_UID            5    Unique ID\n   KRB_NT_X500_PRINCIPAL 6    Encoded
    X.509 Distinguished name [RFC2253]\n   KRB_NT_SMTP_NAME      7    Name in form
    of SMTP email name\n                                (e.g., user@example.com)\n
    \  KRB_NT_ENTERPRISE    10    Enterprise name; may be mapped to\n                                principal
    name\n"
  title: 7.5.8.  Name Types
- contents:
  - "7.5.9.  Error Codes\n   Error Code                         Value  Meaning\n   KDC_ERR_NONE
    \                          0  No error\n   KDC_ERR_NAME_EXP                       1
    \ Client's entry in database\n                                               has
    expired\n   KDC_ERR_SERVICE_EXP                    2  Server's entry in database\n
    \                                              has expired\n   KDC_ERR_BAD_PVNO
    \                      3  Requested protocol version\n                                               number
    not supported\n   KDC_ERR_C_OLD_MAST_KVNO                4  Client's key encrypted
    in\n                                               old master key\n   KDC_ERR_S_OLD_MAST_KVNO
    \               5  Server's key encrypted in\n                                               old
    master key\n   KDC_ERR_C_PRINCIPAL_UNKNOWN            6  Client not found in\n
    \                                              Kerberos database\n   KDC_ERR_S_PRINCIPAL_UNKNOWN
    \           7  Server not found in\n                                               Kerberos
    database\n   KDC_ERR_PRINCIPAL_NOT_UNIQUE           8  Multiple principal entries\n
    \                                              in database\n   KDC_ERR_NULL_KEY
    \                      9  The client or server has a\n                                               null
    key\n   KDC_ERR_CANNOT_POSTDATE               10  Ticket not eligible for\n                                               postdating\n
    \  KDC_ERR_NEVER_VALID                   11  Requested starttime is\n                                               later
    than end time\n   KDC_ERR_POLICY                        12  KDC policy rejects
    request\n   KDC_ERR_BADOPTION                     13  KDC cannot accommodate\n
    \                                              requested option\n   KDC_ERR_ETYPE_NOSUPP
    \                 14  KDC has no support for\n                                               encryption
    type\n   KDC_ERR_SUMTYPE_NOSUPP                15  KDC has no support for\n                                               checksum
    type\n   KDC_ERR_PADATA_TYPE_NOSUPP            16  KDC has no support for\n                                               padata
    type\n   KDC_ERR_TRTYPE_NOSUPP                 17  KDC has no support for\n                                               transited
    type\n   KDC_ERR_CLIENT_REVOKED                18  Clients credentials have\n
    \                                              been revoked\n   KDC_ERR_SERVICE_REVOKED
    \              19  Credentials for server have\n                                               been
    revoked\n   KDC_ERR_TGT_REVOKED                   20  TGT has been revoked\n   KDC_ERR_CLIENT_NOTYET
    \                21  Client not yet valid; try\n                                               again
    later\n   KDC_ERR_SERVICE_NOTYET                22  Server not yet valid; try\n
    \                                              again later\n   KDC_ERR_KEY_EXPIRED
    \                  23  Password has expired;\n                                               change
    password to reset\n   KDC_ERR_PREAUTH_FAILED                24  Pre-authentication\n
    \                                              information was invalid\n   KDC_ERR_PREAUTH_REQUIRED
    \             25  Additional pre-\n                                               authentication
    required\n   KDC_ERR_SERVER_NOMATCH                26  Requested server and ticket\n
    \                                              don't match\n   KDC_ERR_MUST_USE_USER2USER
    \           27  Server principal valid for\n                                               user2user
    only\n   KDC_ERR_PATH_NOT_ACCEPTED             28  KDC Policy rejects\n                                               transited
    path\n   KDC_ERR_SVC_UNAVAILABLE               29  A service is not available\n
    \  KRB_AP_ERR_BAD_INTEGRITY              31  Integrity check on\n                                               decrypted
    field failed\n   KRB_AP_ERR_TKT_EXPIRED                32  Ticket expired\n   KRB_AP_ERR_TKT_NYV
    \                   33  Ticket not yet valid\n   KRB_AP_ERR_REPEAT                     34
    \ Request is a replay\n   KRB_AP_ERR_NOT_US                     35  The ticket
    isn't for us\n   KRB_AP_ERR_BADMATCH                   36  Ticket and authenticator\n
    \                                              don't match\n   KRB_AP_ERR_SKEW
    \                      37  Clock skew too great\n   KRB_AP_ERR_BADADDR                    38
    \ Incorrect net address\n   KRB_AP_ERR_BADVERSION                 39  Protocol
    version mismatch\n   KRB_AP_ERR_MSG_TYPE                   40  Invalid msg type\n
    \  KRB_AP_ERR_MODIFIED                   41  Message stream modified\n   KRB_AP_ERR_BADORDER
    \                  42  Message out of order\n   KRB_AP_ERR_BADKEYVER                  44
    \ Specified version of key is\n                                               not
    available\n   KRB_AP_ERR_NOKEY                      45  Service key not available\n
    \  KRB_AP_ERR_MUT_FAIL                   46  Mutual authentication\n                                               failed\n
    \  KRB_AP_ERR_BADDIRECTION               47  Incorrect message direction\n   KRB_AP_ERR_METHOD
    \                    48  Alternative authentication\n                                               method
    required\n   KRB_AP_ERR_BADSEQ                     49  Incorrect sequence number\n
    \                                              in message\n   KRB_AP_ERR_INAPP_CKSUM
    \               50  Inappropriate type of\n                                               checksum
    in message\n   KRB_AP_PATH_NOT_ACCEPTED              51  Policy rejects transited\n
    \                                              path\n   KRB_ERR_RESPONSE_TOO_BIG
    \             52  Response too big for UDP;\n                                               retry
    with TCP\n   KRB_ERR_GENERIC                       60  Generic error (description\n
    \                                              in e-text)\n   KRB_ERR_FIELD_TOOLONG
    \                61  Field is too long for this\n                                               implementation\n
    \  KDC_ERROR_CLIENT_NOT_TRUSTED          62  Reserved for PKINIT\n   KDC_ERROR_KDC_NOT_TRUSTED
    \            63  Reserved for PKINIT\n   KDC_ERROR_INVALID_SIG                 64
    \ Reserved for PKINIT\n   KDC_ERR_KEY_TOO_WEAK                  65  Reserved for
    PKINIT\n   KDC_ERR_CERTIFICATE_MISMATCH          66  Reserved for PKINIT\n   KRB_AP_ERR_NO_TGT
    \                    67  No TGT available to\n                                               validate
    USER-TO-USER\n   KDC_ERR_WRONG_REALM                   68  Reserved for future
    use\n   KRB_AP_ERR_USER_TO_USER_REQUIRED      69  Ticket must be for\n                                               USER-TO-USER\n
    \  KDC_ERR_CANT_VERIFY_CERTIFICATE       70  Reserved for PKINIT\n   KDC_ERR_INVALID_CERTIFICATE
    \          71  Reserved for PKINIT\n   KDC_ERR_REVOKED_CERTIFICATE           72
    \ Reserved for PKINIT\n   KDC_ERR_REVOCATION_STATUS_UNKNOWN     73  Reserved for
    PKINIT\n   KDC_ERR_REVOCATION_STATUS_UNAVAILABLE 74  Reserved for PKINIT\n   KDC_ERR_CLIENT_NAME_MISMATCH
    \         75  Reserved for PKINIT\n   KDC_ERR_KDC_NAME_MISMATCH             76
    \ Reserved for PKINIT\n"
  title: 7.5.9.  Error Codes
- contents:
  - "8.  Interoperability Requirements\n   Version 5 of the Kerberos protocol supports
    a myriad of options.\n   Among these are multiple encryption and checksum types;
    alternative\n   encoding schemes for the transited field; optional mechanisms
    for\n   pre-authentication; the handling of tickets with no addresses;\n   options
    for mutual authentication; user-to-user authentication;\n   support for proxies;
    the format of realm names; the handling of\n   authorization data; and forwarding,
    postdating, and renewing tickets.\n   In order to ensure the interoperability
    of realms, it is necessary to\n   define a minimal configuration that must be
    supported by all\n   implementations.  This minimal configuration is subject to
    change as\n   technology does.  For example, if at some later date it is discovered\n
    \  that one of the required encryption or checksum algorithms is not\n   secure,
    it will be replaced.\n"
  title: 8.  Interoperability Requirements
- contents:
  - "8.1.  Specification 2\n   This section defines the second specification of these
    options.\n   Implementations which are configured in this way can be said to\n
    \  support Kerberos Version 5 Specification 2 (5.2).  Specification 1\n   (deprecated)
    may be found in RFC 1510.\n   Transport\n      TCP/IP and UDP/IP transport MUST
    be supported by clients and KDCs\n      claiming conformance to specification
    2.\n   Encryption and Checksum Methods\n      The following encryption and checksum
    mechanisms MUST be\n      supported:\n      Encryption: AES256-CTS-HMAC-SHA1-96
    [RFC3962]\n      Checksums: HMAC-SHA1-96-AES256 [RFC3962]\n      Implementations
    SHOULD support other mechanisms as well, but the\n      additional mechanisms
    may only be used when communicating with\n      principals known to also support
    them.  The following mechanisms\n      from [RFC3961] and [RFC3962] SHOULD be
    supported:\n      Encryption: AES128-CTS-HMAC-SHA1-96, DES-CBC-MD5, DES3-CBC-SHA1-KD\n
    \     Checksums: DES-MD5, HMAC-SHA1-DES3-KD, HMAC-SHA1-96-AES128\n      Implementations
    MAY support other mechanisms as well, but the\n      additional mechanisms may
    only be used when communicating with\n      principals known to support them also.\n
    \     Implementation note: Earlier implementations of Kerberos generate\n      messages
    using the CRC-32 and RSA-MD5 checksum methods.  For\n      interoperability with
    these earlier releases, implementors MAY\n      consider supporting these checksum
    methods but should carefully\n      analyze the security implications to limit
    the situations within\n      which these methods are accepted.\n   Realm Names\n
    \     All implementations MUST understand hierarchical realms in both\n      the
    Internet Domain and the X.500 style.  When a TGT for an\n      unknown realm is
    requested, the KDC MUST be able to determine the\n      names of the intermediate
    realms between the KDCs realm and the\n      requested realm.\n   Transited Field
    Encoding\n      DOMAIN-X500-COMPRESS (described in Section 3.3.3.2) MUST be\n
    \     supported.  Alternative encodings MAY be supported, but they may\n      only
    be used when that encoding is supported by ALL intermediate\n      realms.\n   Pre-authentication
    Methods\n      The TGS-REQ method MUST be supported.  It is not used on the\n
    \     initial request.  The PA-ENC-TIMESTAMP method MUST be supported by\n      clients,
    but whether it is enabled by default MAY be determined on\n      a realm-by-realm
    basis.  If the method is not used in the initial\n      request and the error
    KDC_ERR_PREAUTH_REQUIRED is returned\n      specifying PA-ENC-TIMESTAMP as an
    acceptable method, the client\n      SHOULD retry the initial request using the
    PA-ENC-TIMESTAMP pre-\n      authentication method.  Servers need not support
    the PA-ENC-\n      TIMESTAMP method, but if it is not supported the server SHOULD\n
    \     ignore the presence of PA-ENC-TIMESTAMP pre-authentication in a\n      request.\n
    \     The ETYPE-INFO2 method MUST be supported; this method is used to\n      communicate
    the set of supported encryption types, and\n      corresponding salt and string
    to key parameters.  The ETYPE-INFO\n      method SHOULD be supported for interoperability
    with older\n      implementation.\n   Mutual Authentication\n      Mutual authentication
    (via the KRB_AP_REP message) MUST be\n      supported.\n   Ticket Addresses and
    Flags\n      All KDCs MUST pass through tickets that carry no addresses (i.e.,\n
    \     if a TGT contains no addresses, the KDC will return derivative\n      tickets).
    \ Implementations SHOULD default to requesting\n      addressless tickets, as
    this significantly increases\n      interoperability with network address translation.
    \ In some cases,\n      realms or application servers MAY require that tickets
    have an\n      address.\n      Implementations SHOULD accept directional address
    type for the\n      KRB_SAFE and KRB_PRIV message and SHOULD include directional\n
    \     addresses in these messages when other address types are not\n      available.\n
    \     Proxies and forwarded tickets MUST be supported.  Individual\n      realms
    and application servers can set their own policy on when\n      such tickets will
    be accepted.\n      All implementations MUST recognize renewable and postdated\n
    \     tickets, but they need not actually implement them.  If these\n      options
    are not supported, the starttime and endtime in the ticket\n      SHALL specify
    a ticket's entire useful life.  When a postdated\n      ticket is decoded by a
    server, all implementations SHALL make the\n      presence of the postdated flag
    visible to the calling server.\n   User-to-User Authentication\n      Support
    for user-to-user authentication (via the ENC-TKT-IN-SKEY\n      KDC option) MUST
    be provided by implementations, but individual\n      realms MAY decide as a matter
    of policy to reject such requests on\n      a per-principal or realm-wide basis.\n
    \  Authorization Data\n      Implementations MUST pass all authorization data
    subfields from\n      TGTs to any derivative tickets unless they are directed
    to\n      suppress a subfield as part of the definition of that registered\n      subfield
    type.  (It is never incorrect to pass on a subfield, and\n      no registered
    subfield types presently specify suppression at the\n      KDC.)\n      Implementations
    MUST make the contents of any authorization data\n      subfields available to
    the server when a ticket is used.\n      Implementations are not required to allow
    clients to specify the\n      contents of the authorization data fields.\n   Constant
    Ranges\n      All protocol constants are constrained to 32-bit (signed) values\n
    \     unless further constrained by the protocol definition.  This limit\n      is
    provided to allow implementations to make assumptions about the\n      maximum
    values that will be received for these constants.\n      Implementations receiving
    values outside this range MAY reject the\n      request, but they MUST recover
    cleanly.\n"
  title: 8.1.  Specification 2
- contents:
  - "8.2.  Recommended KDC Values\n   Following is a list of recommended values for
    a KDC configuration.\n      Minimum lifetime              5 minutes\n      Maximum
    renewable lifetime    1 week\n      Maximum ticket lifetime       1 day\n      Acceptable
    clock skew         5 minutes\n      Empty addresses               Allowed\n      Proxiable,
    etc.               Allowed\n"
  title: 8.2.  Recommended KDC Values
- contents:
  - "9.  IANA Considerations\n   Section 7 of this document specifies protocol constants
    and other\n   defined values required for the interoperability of multiple\n   implementations.
    \ Until a subsequent RFC specifies otherwise, or the\n   Kerberos working group
    is shut down, allocations of additional\n   protocol constants and other defined
    values required for extensions\n   to the Kerberos protocol will be administered
    by the Kerberos working\n   group.  Following the recommendations outlined in
    [RFC2434], guidance\n   is provided to the IANA as follows:\n   \"reserved\" realm
    name types in Section 6.1 and \"other\" realm types\n   except those beginning
    with \"X-\" or \"x-\" will not be registered\n   without IETF standards action,
    at which point guidelines for further\n   assignment will be specified.  Realm
    name types beginning with \"X-\"\n   or \"x-\" are for private use.\n   For host
    address types described in Section 7.1, negative values are\n   for private use.
    \ Assignment of additional positive numbers is\n   subject to review by the Kerberos
    working group or other expert\n   review.\n   Additional key usage numbers, as
    defined in Section 7.5.1, will be\n   assigned subject to review by the Kerberos
    working group or other\n   expert review.\n   Additional preauthentication data
    type values, as defined in section\n   7.5.2, will be assigned subject to review
    by the Kerberos working\n   group or other expert review.\n   Additional authorization
    data types as defined in Section 7.5.4, will\n   be assigned subject to review
    by the Kerberos working group or other\n   expert review.  Although it is anticipated
    that there may be\n   significant demand for private use types, provision is intentionally\n
    \  not made for a private use portion of the namespace because conflicts\n   between
    privately assigned values could have detrimental security\n   implications.\n
    \  Additional transited encoding types, as defined in Section 7.5.5,\n   present
    special concerns for interoperability with existing\n   implementations.  As such,
    such assignments will only be made by\n   standards action, except that the Kerberos
    working group or another\n   other working group with competent jurisdiction may
    make preliminary\n   assignments for documents that are moving through the standards\n
    \  process.\n   Additional Kerberos message types, as described in Section 7.5.7,\n
    \  will be assigned subject to review by the Kerberos working group or\n   other
    expert review.\n   Additional name types, as described in Section 7.5.8, will
    be\n   assigned subject to review by the Kerberos working group or other\n   expert
    review.\n   Additional error codes described in Section 7.5.9 will be assigned\n
    \  subject to review by the Kerberos working group or other expert\n   review.\n"
  title: 9.  IANA Considerations
- contents:
  - "10.  Security Considerations\n   As an authentication service, Kerberos provides
    a means of verifying\n   the identity of principals on a network.  By itself,
    Kerberos does\n   not provide authorization.  Applications should not accept the\n
    \  issuance of a service ticket by the Kerberos server as granting\n   authority
    to use the service, since such applications may become\n   vulnerable to the bypass
    of this authorization check in an\n   environment where they inter-operate with
    other KDCs or where other\n   options for application authentication are provided.\n
    \  Denial of service attacks are not solved with Kerberos.  There are\n   places
    in the protocols where an intruder can prevent an application\n   from participating
    in the proper authentication steps.  Because\n   authentication is a required
    step for the use of many services,\n   successful denial of service attacks on
    a Kerberos server might\n   result in the denial of other network services that
    rely on Kerberos\n   for authentication.  Kerberos is vulnerable to many kinds
    of denial\n   of service attacks: those on the network, which would prevent clients\n
    \  from contacting the KDC; those on the domain name system, which could\n   prevent
    a client from finding the IP address of the Kerberos server;\n   and those by
    overloading the Kerberos KDC itself with repeated\n   requests.\n   Interoperability
    conflicts caused by incompatible character-set usage\n   (see 5.2.1) can result
    in denial of service for clients that utilize\n   character-sets in Kerberos strings
    other than those stored in the KDC\n   database.\n   Authentication servers maintain
    a database of principals (i.e., users\n   and servers) and their secret keys.
    \ The security of the\n   authentication server machines is critical.  The breach
    of security\n   of an authentication server will compromise the security of all\n
    \  servers that rely upon the compromised KDC, and will compromise the\n   authentication
    of any principals registered in the realm of the\n   compromised KDC.\n   Principals
    must keep their secret keys secret.  If an intruder\n   somehow steals a principal's
    key, it will be able to masquerade as\n   that principal or impersonate any server
    to the legitimate principal.\n   Password-guessing attacks are not solved by Kerberos.
    \ If a user\n   chooses a poor password, it is possible for an attacker to\n   successfully
    mount an off-line dictionary attack by repeatedly\n   attempting to decrypt, with
    successive entries from a dictionary,\n   messages obtained that are encrypted
    under a key derived from the\n   user's password.\n   Unless pre-authentication
    options are required by the policy of a\n   realm, the KDC will not know whether
    a request for authentication\n   succeeds.  An attacker can request a reply with
    credentials for any\n   principal.  These credentials will likely not be of much
    use to the\n   attacker unless it knows the client's secret key, but the\n   availability
    of the response encrypted in the client's secret key\n   provides the attacker
    with ciphertext that may be used to mount brute\n   force or dictionary attacks
    to decrypt the credentials, by guessing\n   the user's password.  For this reason
    it is strongly encouraged that\n   Kerberos realms require the use of pre-authentication.
    \ Even with\n   pre-authentication, attackers may try brute force or dictionary\n
    \  attacks against credentials that are observed by eavesdropping on the\n   network.\n
    \  Because a client can request a ticket for any server principal and\n   can
    attempt a brute force or dictionary attack against the server\n   principal's
    key using that ticket, it is strongly encouraged that\n   keys be randomly generated
    (rather than generated from passwords) for\n   any principals that are usable
    as the target principal for a\n   KRB_TGS_REQ or KRB_AS_REQ messages.  [RFC4086]\n
    \  Although the DES-CBC-MD5 encryption method and DES-MD5 checksum\n   methods
    are listed as SHOULD be implemented for backward\n   compatibility, the single
    DES encryption algorithm on which these are\n   based is weak, and stronger algorithms
    should be used whenever\n   possible.\n   Each host on the network must have a
    clock that is loosely\n   synchronized to the time of the other hosts; this synchronization
    is\n   used to reduce the bookkeeping needs of application servers when they\n
    \  do replay detection.  The degree of \"looseness\" can be configured on\n   a
    per-server basis, but it is typically on the order of 5 minutes.\n   If the clocks
    are synchronized over the network, the clock\n   synchronization protocol MUST
    itself be secured from network\n   attackers.\n   Principal identifiers must not
    recycled on a short-term basis.  A\n   typical mode of access control will use
    access control lists (ACLs)\n   to grant permissions to particular principals.
    \ If a stale ACL entry\n   remains for a deleted principal and the principal identifier
    is\n   reused, the new principal will inherit rights specified in the stale\n
    \  ACL entry.  By not reusing principal identifiers, the danger of\n   inadvertent
    access is removed.\n   Proper decryption of an KRB_AS_REP message from the KDC
    is not\n   sufficient for the host to verify the identity of the user; the user\n
    \  and an attacker could cooperate to generate a KRB_AS_REP format\n   message
    that decrypts properly but is not from the proper KDC.  To\n   authenticate a
    user logging on to a local system, the credentials\n   obtained in the AS exchange
    may first be used in a TGS exchange to\n   obtain credentials for a local server.
    \ Those credentials must then\n   be verified by a local server through successful
    completion of the\n   Client/Server exchange.\n   Many RFC 1510-compliant implementations
    ignore unknown authorization\n   data elements.  Depending on these implementations
    to honor\n   authorization data restrictions may create a security weakness.\n
    \  Kerberos credentials contain clear-text information identifying the\n   principals
    to which they apply.  If privacy of this information is\n   needed, this exchange
    should itself be encapsulated in a protocol\n   providing for confidentiality
    on the exchange of these credentials.\n   Applications must take care to protect
    communications subsequent to\n   authentication, either by using the KRB_PRIV
    or KRB_SAFE messages as\n   appropriate, or by applying their own confidentiality
    or integrity\n   mechanisms on such communications.  Completion of the KRB_AP_REQ
    and\n   KRB_AP_REP exchange without subsequent use of confidentiality and\n   integrity
    mechanisms provides only for authentication of the parties\n   to the communication
    and not confidentiality and integrity of the\n   subsequent communication.  Applications
    applying confidentiality and\n   integrity protection mechanisms other than KRB_PRIV
    and KRB_SAFE must\n   make sure that the authentication step is appropriately
    linked with\n   the protected communication channel that is established by the\n
    \  application.\n   Unless the application server provides its own suitable means
    to\n   protect against replay (for example, a challenge-response sequence\n   initiated
    by the server after authentication, or use of a server-\n   generated encryption
    subkey), the server must utilize a replay cache\n   to remember any authenticator
    presented within the allowable clock\n   skew.  All services sharing a key need
    to use the same replay cache.\n   If separate replay caches are used, then an
    authenticator used with\n   one such service could later be replayed to a different
    service with\n   the same service principal.\n   If a server loses track of authenticators
    presented within the\n   allowable clock skew, it must reject all requests until
    the clock\n   skew interval has passed, providing assurance that any lost or\n
    \  replayed authenticators will fall outside the allowable clock skew\n   and
    can no longer be successfully replayed.\n   Implementations of Kerberos should
    not use untrusted directory\n   servers to determine the realm of a host.  To
    allow this would allow\n   the compromise of the directory server to enable an
    attacker to\n   direct the client to accept authentication with the wrong principal\n
    \  (i.e., one with a similar name, but in a realm with which the\n   legitimate
    host was not registered).\n   Implementations of Kerberos must not use DNS to
    map one name to\n   another (canonicalize) in order to determine the host part
    of the\n   principal name with which one is to communicate.  To allow this\n   canonicalization
    would allow a compromise of the DNS to result in a\n   client obtaining credentials
    and correctly authenticating to the\n   wrong principal.  Though the client will
    know who it is communicating\n   with, it will not be the principal with which
    it intended to\n   communicate.\n   If the Kerberos server returns a TGT for a
    realm 'closer' than the\n   desired realm, the client may use local policy configuration
    to\n   verify that the authentication path used is an acceptable one.\n   Alternatively,
    a client may choose its own authentication path rather\n   than rely on the Kerberos
    server to select one.  In either case, any\n   policy or configuration information
    used to choose or validate\n   authentication paths, whether by the Kerberos server
    or client, must\n   be obtained from a trusted source.\n   The Kerberos protocol
    in its basic form does not provide perfect\n   forward secrecy for communications.
    \ If traffic has been recorded by\n   an eavesdropper, then messages encrypted
    using the KRB_PRIV message,\n   or messages encrypted using application-specific
    encryption under\n   keys exchanged using Kerberos can be decrypted if the user's,\n
    \  application server's, or KDC's key is subsequently discovered.  This\n   is
    because the session key used to encrypt such messages, when\n   transmitted over
    the network, is encrypted in the key of the\n   application server.  It is also
    encrypted under the session key from\n   the user's TGT when it is returned to
    the user in the KRB_TGS_REP\n   message.  The session key from the TGT is sent
    to the user in the\n   KRB_AS_REP message encrypted in the user's secret key and
    embedded in\n   the TGT, which was encrypted in the key of the KDC.  Applications\n
    \  requiring perfect forward secrecy must exchange keys through\n   mechanisms
    that provide such assurance, but may use Kerberos for\n   authentication of the
    encrypted channel established through such\n   other means.\n"
  title: 10.  Security Considerations
- contents:
  - "11.  Acknowledgements\n   This document is a revision to RFC 1510 which was co-authored
    with\n   John Kohl.  The specification of the Kerberos protocol described in\n
    \  this document is the result of many years of effort.  Over this\n   period,
    many individuals have contributed to the definition of the\n   protocol and to
    the writing of the specification.  Unfortunately, it\n   is not possible to list
    all contributors as authors of this document,\n   though there are many not listed
    who are authors in spirit, including\n   those who contributed text for parts
    of some sections, who\n   contributed to the design of parts of the protocol,
    and who\n   contributed significantly to the discussion of the protocol in the\n
    \  IETF common authentication technology (CAT) and Kerberos working\n   groups.\n
    \  Among those contributing to the development and specification of\n   Kerberos
    were Jeffrey Altman, John Brezak, Marc Colan, Johan\n   Danielsson, Don Davis,
    Doug Engert, Dan Geer, Paul Hill, John Kohl,\n   Marc Horowitz, Matt Hur, Jeffrey
    Hutzelman, Paul Leach, John Linn,\n   Ari Medvinsky, Sasha Medvinsky, Steve Miller,
    Jon Rochlis, Jerome\n   Saltzer, Jeffrey Schiller, Jennifer Steiner, Ralph Swick,
    Mike Swift,\n   Jonathan Trostle, Theodore Ts'o, Brian Tung, Jacques Vidrine,
    Assar\n   Westerlund, and Nicolas Williams.  Many other members of MIT Project\n
    \  Athena, the MIT networking group, and the Kerberos and CAT working\n   groups
    of the IETF contributed but are not listed.\n"
  title: 11.  Acknowledgements
- contents:
  - 'A.  ASN.1 module

    '
  - "KerberosV5Spec2 {\n        iso(1) identified-organization(3) dod(6) internet(1)\n
    \       security(5) kerberosV5(2) modules(4) krb5spec2(2)\n"
  - '} DEFINITIONS EXPLICIT TAGS ::= BEGIN

    '
  - '-- OID arc for KerberosV5

    '
  - '--

    '
  - '-- This OID may be used to identify Kerberos protocol messages

    '
  - '-- encapsulated in other protocols.

    '
  - '--

    '
  - '-- This OID also designates the OID arc for KerberosV5-related OIDs.

    '
  - '--

    '
  - '-- NOTE: RFC 1510 had an incorrect value (5) for "dod" in its OID.

    '
  - "id-krb5         OBJECT IDENTIFIER ::= {\n        iso(1) identified-organization(3)
    dod(6) internet(1)\n        security(5) kerberosV5(2)\n"
  - '}

    '
  - "Int32           ::= INTEGER (-2147483648..2147483647)\n                    --
    signed values representable in 32 bits\n"
  - "UInt32          ::= INTEGER (0..4294967295)\n                    -- unsigned
    32 bit values\n"
  - "Microseconds    ::= INTEGER (0..999999)\n                    -- microseconds\n"
  - 'KerberosString  ::= GeneralString (IA5String)

    '
  - 'Realm           ::= KerberosString

    '
  - "PrincipalName   ::= SEQUENCE {\n        name-type       [0] Int32,\n        name-string
    \    [1] SEQUENCE OF KerberosString\n"
  - '}

    '
  - 'KerberosTime    ::= GeneralizedTime -- with no fractional seconds

    '
  - "HostAddress     ::= SEQUENCE  {\n        addr-type       [0] Int32,\n        address
    \        [1] OCTET STRING\n"
  - '}

    '
  - '-- NOTE: HostAddresses is always used as an OPTIONAL field and

    '
  - '-- should not be empty.

    '
  - "HostAddresses   -- NOTE: subtly different from rfc1510,\n                -- but
    has a value mapping and encodes the same\n        ::= SEQUENCE OF HostAddress\n"
  - '-- NOTE: AuthorizationData is always used as an OPTIONAL field and

    '
  - '-- should not be empty.

    '
  - "AuthorizationData       ::= SEQUENCE OF SEQUENCE {\n        ad-type         [0]
    Int32,\n        ad-data         [1] OCTET STRING\n"
  - '}

    '
  - "PA-DATA         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n
    \       padata-type     [1] Int32,\n        padata-value    [2] OCTET STRING --
    might be encoded AP-REQ\n"
  - '}

    '
  - "KerberosFlags   ::= BIT STRING (SIZE (32..MAX))\n                    -- minimum
    number of bits shall be sent,\n                    -- but no fewer than 32\n"
  - "EncryptedData   ::= SEQUENCE {\n        etype   [0] Int32 -- EncryptionType --,\n
    \       kvno    [1] UInt32 OPTIONAL,\n        cipher  [2] OCTET STRING -- ciphertext\n"
  - '}

    '
  - "EncryptionKey   ::= SEQUENCE {\n        keytype         [0] Int32 -- actually
    encryption type --,\n        keyvalue        [1] OCTET STRING\n"
  - '}

    '
  - "Checksum        ::= SEQUENCE {\n        cksumtype       [0] Int32,\n        checksum
    \       [1] OCTET STRING\n"
  - '}

    '
  - "Ticket          ::= [APPLICATION 1] SEQUENCE {\n        tkt-vno         [0] INTEGER
    (5),\n        realm           [1] Realm,\n        sname           [2] PrincipalName,\n
    \       enc-part        [3] EncryptedData -- EncTicketPart\n"
  - '}

    '
  - '-- Encrypted part of ticket

    '
  - "EncTicketPart   ::= [APPLICATION 3] SEQUENCE {\n        flags                   [0]
    TicketFlags,\n        key                     [1] EncryptionKey,\n        crealm
    \                 [2] Realm,\n        cname                   [3] PrincipalName,\n
    \       transited               [4] TransitedEncoding,\n        authtime                [5]
    KerberosTime,\n        starttime               [6] KerberosTime OPTIONAL,\n        endtime
    \                [7] KerberosTime,\n        renew-till              [8] KerberosTime
    OPTIONAL,\n        caddr                   [9] HostAddresses OPTIONAL,\n        authorization-data
    \     [10] AuthorizationData OPTIONAL\n"
  - '}

    '
  - '-- encoded Transited field

    '
  - "TransitedEncoding       ::= SEQUENCE {\n        tr-type         [0] Int32 --
    must be registered --,\n        contents        [1] OCTET STRING\n"
  - '}

    '
  - "TicketFlags     ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n
    \       -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        --
    may-postdate(5),\n        -- postdated(6),\n        -- invalid(7),\n        --
    renewable(8),\n        -- initial(9),\n        -- pre-authent(10),\n        --
    hw-authent(11),\n"
  - "-- the following are new since 1510\n        -- transited-policy-checked(12),\n
    \       -- ok-as-delegate(13)\n"
  - 'AS-REQ          ::= [APPLICATION 10] KDC-REQ

    '
  - 'TGS-REQ         ::= [APPLICATION 12] KDC-REQ

    '
  - "KDC-REQ         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n
    \       pvno            [1] INTEGER (5) ,\n        msg-type        [2] INTEGER
    (10 -- AS -- | 12 -- TGS --),\n        padata          [3] SEQUENCE OF PA-DATA
    OPTIONAL\n                            -- NOTE: not empty --,\n        req-body
    \       [4] KDC-REQ-BODY\n"
  - '}

    '
  - "KDC-REQ-BODY    ::= SEQUENCE {\n        kdc-options             [0] KDCOptions,\n
    \       cname                   [1] PrincipalName OPTIONAL\n                                    --
    Used only in AS-REQ --,\n        realm                   [2] Realm\n                                    --
    Server's realm\n                                    -- Also client's in AS-REQ
    --,\n        sname                   [3] PrincipalName OPTIONAL,\n        from
    \                   [4] KerberosTime OPTIONAL,\n        till                    [5]
    KerberosTime,\n        rtime                   [6] KerberosTime OPTIONAL,\n        nonce
    \                  [7] UInt32,\n        etype                   [8] SEQUENCE OF
    Int32 -- EncryptionType\n                                    -- in preference
    order --,\n        addresses               [9] HostAddresses OPTIONAL,\n        enc-authorization-data
    \ [10] EncryptedData OPTIONAL\n                                    -- AuthorizationData
    --,\n        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL\n                                        --
    NOTE: not empty\n"
  - '}

    '
  - "KDCOptions      ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n
    \       -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        --
    allow-postdate(5),\n        -- postdated(6),\n        -- unused7(7),\n        --
    renewable(8),\n        -- unused9(9),\n        -- unused10(10),\n        -- opt-hardware-auth(11),\n
    \       -- unused12(12),\n        -- unused13(13),\n"
  - "-- 15 is reserved for canonicalize\n        -- unused15(15),\n"
  - "-- 26 was unused in 1510\n        -- disable-transited-check(26),\n"
  - "--\n        -- renewable-ok(27),\n        -- enc-tkt-in-skey(28),\n        --
    renew(30),\n        -- validate(31)\n"
  - 'AS-REP          ::= [APPLICATION 11] KDC-REP

    '
  - 'TGS-REP         ::= [APPLICATION 13] KDC-REP

    '
  - "KDC-REP         ::= SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type
    \       [1] INTEGER (11 -- AS -- | 13 -- TGS --),\n        padata          [2]
    SEQUENCE OF PA-DATA OPTIONAL\n                                -- NOTE: not empty
    --,\n        crealm          [3] Realm,\n        cname           [4] PrincipalName,\n
    \       ticket          [5] Ticket,\n        enc-part        [6] EncryptedData\n
    \                               -- EncASRepPart or EncTGSRepPart,\n                                --
    as appropriate\n"
  - '}

    '
  - 'EncASRepPart    ::= [APPLICATION 25] EncKDCRepPart

    '
  - 'EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart

    '
  - "EncKDCRepPart   ::= SEQUENCE {\n        key             [0] EncryptionKey,\n
    \       last-req        [1] LastReq,\n        nonce           [2] UInt32,\n        key-expiration
    \ [3] KerberosTime OPTIONAL,\n        flags           [4] TicketFlags,\n        authtime
    \       [5] KerberosTime,\n        starttime       [6] KerberosTime OPTIONAL,\n
    \       endtime         [7] KerberosTime,\n        renew-till      [8] KerberosTime
    OPTIONAL,\n        srealm          [9] Realm,\n        sname           [10] PrincipalName,\n
    \       caddr           [11] HostAddresses OPTIONAL\n"
  - '}

    '
  - "LastReq         ::=     SEQUENCE OF SEQUENCE {\n        lr-type         [0] Int32,\n
    \       lr-value        [1] KerberosTime\n"
  - '}

    '
  - "AP-REQ          ::= [APPLICATION 14] SEQUENCE {\n        pvno            [0]
    INTEGER (5),\n        msg-type        [1] INTEGER (14),\n        ap-options      [2]
    APOptions,\n        ticket          [3] Ticket,\n        authenticator   [4] EncryptedData
    -- Authenticator\n"
  - '}

    '
  - "APOptions       ::= KerberosFlags\n        -- reserved(0),\n        -- use-session-key(1),\n
    \       -- mutual-required(2)\n"
  - '-- Unencrypted authenticator

    '
  - "Authenticator   ::= [APPLICATION 2] SEQUENCE  {\n        authenticator-vno       [0]
    INTEGER (5),\n        crealm                  [1] Realm,\n        cname                   [2]
    PrincipalName,\n        cksum                   [3] Checksum OPTIONAL,\n        cusec
    \                  [4] Microseconds,\n        ctime                   [5] KerberosTime,\n
    \       subkey                  [6] EncryptionKey OPTIONAL,\n        seq-number
    \             [7] UInt32 OPTIONAL,\n        authorization-data      [8] AuthorizationData
    OPTIONAL\n"
  - '}

    '
  - "AP-REP          ::= [APPLICATION 15] SEQUENCE {\n        pvno            [0]
    INTEGER (5),\n        msg-type        [1] INTEGER (15),\n        enc-part        [2]
    EncryptedData -- EncAPRepPart\n"
  - '}

    '
  - "EncAPRepPart    ::= [APPLICATION 27] SEQUENCE {\n        ctime           [0]
    KerberosTime,\n        cusec           [1] Microseconds,\n        subkey          [2]
    EncryptionKey OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL\n"
  - '}

    '
  - "KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {\n        pvno            [0]
    INTEGER (5),\n        msg-type        [1] INTEGER (20),\n        safe-body       [2]
    KRB-SAFE-BODY,\n        cksum           [3] Checksum\n"
  - '}

    '
  - "KRB-SAFE-BODY   ::= SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp
    \      [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n
    \       seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress,\n
    \       r-address       [5] HostAddress OPTIONAL\n"
  - '}

    '
  - "KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {\n        pvno            [0]
    INTEGER (5),\n        msg-type        [1] INTEGER (21),\n                        --
    NOTE: there is no [2] tag\n        enc-part        [3] EncryptedData -- EncKrbPrivPart\n"
  - '}

    '
  - "EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {\n        user-data       [0]
    OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec
    \           [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n
    \       s-address       [4] HostAddress -- sender's addr --,\n        r-address
    \      [5] HostAddress OPTIONAL -- recip's addr\n"
  - '}

    '
  - "KRB-CRED        ::= [APPLICATION 22] SEQUENCE {\n        pvno            [0]
    INTEGER (5),\n        msg-type        [1] INTEGER (22),\n        tickets         [2]
    SEQUENCE OF Ticket,\n        enc-part        [3] EncryptedData -- EncKrbCredPart\n"
  - '}

    '
  - "EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE {\n        ticket-info     [0]
    SEQUENCE OF KrbCredInfo,\n        nonce           [1] UInt32 OPTIONAL,\n        timestamp
    \      [2] KerberosTime OPTIONAL,\n        usec            [3] Microseconds OPTIONAL,\n
    \       s-address       [4] HostAddress OPTIONAL,\n        r-address       [5]
    HostAddress OPTIONAL\n"
  - '}

    '
  - "KrbCredInfo     ::= SEQUENCE {\n        key             [0] EncryptionKey,\n
    \       prealm          [1] Realm OPTIONAL,\n        pname           [2] PrincipalName
    OPTIONAL,\n        flags           [3] TicketFlags OPTIONAL,\n        authtime
    \       [4] KerberosTime OPTIONAL,\n        starttime       [5] KerberosTime OPTIONAL,\n
    \       endtime         [6] KerberosTime OPTIONAL,\n        renew-till      [7]
    KerberosTime OPTIONAL,\n        srealm          [8] Realm OPTIONAL,\n        sname
    \          [9] PrincipalName OPTIONAL,\n        caddr           [10] HostAddresses
    OPTIONAL\n"
  - '}

    '
  - "KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {\n        pvno            [0]
    INTEGER (5),\n        msg-type        [1] INTEGER (30),\n        ctime           [2]
    KerberosTime OPTIONAL,\n        cusec           [3] Microseconds OPTIONAL,\n        stime
    \          [4] KerberosTime,\n        susec           [5] Microseconds,\n        error-code
    \     [6] Int32,\n        crealm          [7] Realm OPTIONAL,\n        cname           [8]
    PrincipalName OPTIONAL,\n        realm           [9] Realm -- service realm --,\n
    \       sname           [10] PrincipalName -- service name --,\n        e-text
    \         [11] KerberosString OPTIONAL,\n        e-data          [12] OCTET STRING
    OPTIONAL\n"
  - '}

    '
  - 'METHOD-DATA     ::= SEQUENCE OF PA-DATA

    '
  - "TYPED-DATA      ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {\n        data-type       [0]
    Int32,\n        data-value      [1] OCTET STRING OPTIONAL\n"
  - '}

    '
  - '-- preauth stuff follows

    '
  - 'PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC

    '
  - "PA-ENC-TS-ENC           ::= SEQUENCE {\n        patimestamp     [0] KerberosTime
    -- client's time --,\n        pausec          [1] Microseconds OPTIONAL\n"
  - '}

    '
  - "ETYPE-INFO-ENTRY        ::= SEQUENCE {\n        etype           [0] Int32,\n
    \       salt            [1] OCTET STRING OPTIONAL\n"
  - '}

    '
  - 'ETYPE-INFO              ::= SEQUENCE OF ETYPE-INFO-ENTRY

    '
  - "ETYPE-INFO2-ENTRY       ::= SEQUENCE {\n        etype           [0] Int32,\n
    \       salt            [1] KerberosString OPTIONAL,\n        s2kparams       [2]
    OCTET STRING OPTIONAL\n"
  - '}

    '
  - 'ETYPE-INFO2             ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY

    '
  - 'AD-IF-RELEVANT          ::= AuthorizationData

    '
  - "AD-KDCIssued            ::= SEQUENCE {\n        ad-checksum     [0] Checksum,\n
    \       i-realm         [1] Realm OPTIONAL,\n        i-sname         [2] PrincipalName
    OPTIONAL,\n        elements        [3] AuthorizationData\n"
  - '}

    '
  - "AD-AND-OR               ::= SEQUENCE {\n        condition-count [0] Int32,\n
    \       elements        [1] AuthorizationData\n"
  - '}

    '
  - 'AD-MANDATORY-FOR-KDC    ::= AuthorizationData

    '
  - 'END

    '
  title: A.  ASN.1 module
- contents:
  - "B.  Changes since RFC 1510\n   This document replaces RFC 1510 and clarifies
    specification of items\n   that were not completely specified.  Where changes
    to recommended\n   implementation choices were made, or where new options were
    added,\n   those changes are described within the document and listed in this\n
    \  section.  More significantly, \"Specification 2\" in Section 8 changes\n   the
    required encryption and checksum methods to bring them in line\n   with the best
    current practices and to deprecate methods that are no\n   longer considered sufficiently
    strong.\n   Discussion was added to Section 1 regarding the ability to rely on\n
    \  the KDC to check the transited field, and on the inclusion of a flag\n   in
    a ticket indicating that this check has occurred.  This is a new\n   capability
    not present in RFC 1510.  Pre-existing implementations may\n   ignore or not set
    this flag without negative security implications.\n   The definition of the secret
    key says that in the case of a user the\n   key may be derived from a password.
    \ In RFC 1510, it said that the\n   key was derived from the password.  This change
    was made to\n   accommodate situations where the user key might be stored on a\n
    \  smart-card, or otherwise obtained independently of a password.\n   The introduction
    mentions the use of public key cryptography for\n   initial authentication in
    Kerberos by reference.  RFC 1510 did not\n   include such a reference.\n   Section
    1.3 was added to explain that while Kerberos provides\n   authentication of a
    named principal, it is still the responsibility\n   of the application to ensure
    that the authenticated name is the\n   entity with which the application wishes
    to communicate.\n   Discussion of extensibility has been added to the introduction.\n
    \  Discussion of how extensibility affects ticket flags and KDC options\n   was
    added to the introduction of Section 2.  No changes were made to\n   existing
    options and flags specified in RFC 1510, though some of the\n   sections in the
    specification were renumbered, and text was revised\n   to make the description
    and intent of existing options clearer,\n   especially with respect to the ENC-TKT-IN-SKEY
    option (now section\n   2.9.2) which is used for user-to-user authentication.
    \ The new option\n   and ticket flag transited policy checking (Section 2.7) was
    added.\n   A warning regarding generation of session keys for application use\n
    \  was added to Section 3, urging the inclusion of key entropy from the\n   KDC
    generated session key in the ticket.  An example regarding use of\n   the sub-session
    key was added to Section 3.2.6.  Descriptions of the\n   pa-etype-info, pa-etype-info2,
    and pa-pw-salt pre-authentication data\n   items were added.  The recommendation
    for use of pre-authentication\n   was changed from \"MAY\" to \"SHOULD\" and a
    note was added regarding\n   known plaintext attacks.\n   In RFC 1510, Section
    4 described the database in the KDC.  This\n   discussion was not necessary for
    interoperability and unnecessarily\n   constrained implementation.  The old Section
    4 was removed.\n   The current Section 4 was formerly Section 6 on encryption
    and\n   checksum specifications.  The major part of this section was brought\n
    \  up to date to support new encryption methods, and moved to a separate\n   document.
    \ Those few remaining aspects of the encryption and checksum\n   specification
    specific to Kerberos are now specified in Section 4.\n   Significant changes were
    made to the layout of Section 5 to clarify\n   the correct behavior for optional
    fields.  Many of these changes were\n   made necessary because of improper ASN.1
    description in the original\n   Kerberos specification which left the correct
    behavior\n   underspecified.  Additionally, the wording in this section was\n
    \  tightened wherever possible to ensure that implementations conforming\n   to
    this specification will be extensible with the addition of new\n   fields in future
    specifications.\n   Text was added describing time_t=0 issues in the ASN.1.  Text
    was\n   also added, clarifying issues with implementations treating omitted\n
    \  optional integers as zero.  Text was added clarifying behavior for\n   optional
    SEQUENCE or SEQUENCE OF that may be empty.  Discussion was\n   added regarding
    sequence numbers and behavior of some\n   implementations, including \"zero\"
    behavior and negative numbers.  A\n   compatibility note was added regarding the
    unconditional sending of\n   EncTGSRepPart regardless of the enclosing reply type.
    \ Minor changes\n   were made to the description of the HostAddresses type.  Integer\n
    \  types were constrained.  KerberosString was defined as a\n   (significantly)
    constrained GeneralString.  KerberosFlags was defined\n   to reflect existing
    implementation behavior that departs from the\n   definition in RFC 1510.  The
    transited-policy-checked(12) and the\n   ok-as-delegate(13) ticket flags were
    added.  The disable-transited-\n   check(26) KDC option was added.\n   Descriptions
    of commonly implemented PA-DATA were added to Section 5.\n   The description of
    KRB-SAFE has been updated to note the existing\n   implementation behavior of
    double-encoding.\n   There were two definitions of METHOD-DATA in RFC 1510.  The
    second\n   one, intended for use with KRB_AP_ERR_METHOD was removed leaving the\n
    \  SEQUENCE OF PA-DATA definition.\n   Section 7, naming constraints, from RFC
    1510 was moved to Section 6.\n   Words were added describing the convention that
    domain-based realm\n   names for newly-created realms should be specified as uppercase.\n
    \  This recommendation does not make lowercase realm names illegal.\n   Words
    were added highlighting that the slash-separated components in\n   the X.500 style
    of realm names is consistent with existing RFC 1510\n   based implementations,
    but that it conflicts with the general\n   recommendation of X.500 name representation
    specified in RFC 2253.\n   Section 8, network transport, constants and defined
    values, from RFC\n   1510 was moved to Section 7.  Since RFC 1510, the definition
    of the\n   TCP transport for Kerberos messages was added, and the encryption and\n
    \  checksum number assignments have been moved into a separate document.\n   \"Specification
    2\" in Section 8 of the current document changes the\n   required encryption and
    checksum methods to bring them in line with\n   the best current practices and
    to deprecate methods that are no\n   longer considered sufficiently strong.\n
    \  Two new sections, on IANA considerations and security considerations\n   were
    added.\n   The pseudo-code has been removed from the appendix.  The pseudo-code\n
    \  was sometimes misinterpreted to limit implementation choices and in\n   RFC
    1510, it was not always consistent with the words in the\n   specification.  Effort
    was made to clear up any ambiguities in the\n   specification, rather than to
    rely on the pseudo-code.\n   An appendix was added containing the complete ASN.1
    module drawn from\n   the discussion in Section 5 of the current document.\n"
  - "END NOTES\n   (*TM) Project Athena, Athena, and Kerberos are trademarks of the\n
    \  Massachusetts Institute of Technology (MIT).\n"
  title: B.  Changes since RFC 1510
- contents:
  - "Normative References\n   [RFC3961]          Raeburn, K., \"Encryption and Checksum\n
    \                     Specifications for Kerberos 5\", RFC 3961, February\n                      2005.\n
    \  [RFC3962]          Raeburn, K., \"Advanced Encryption Standard (AES)\n                      Encryption
    for Kerberos 5\", RFC 3962, February\n                      2005.\n   [ISO-646/ECMA-6]
    \  International Organization for Standardization,\n                      \"7-bit
    Coded Character Set for Information\n                      Interchange\", ISO/IEC
    646:1991.\n   [ISO-2022/ECMA-35] International Organization for Standardization,\n
    \                     \"Character code structure and extension\n                      techniques\",
    ISO/IEC 2022:1994.\n   [RFC1035]          Mockapetris, P., \"Domain names - implementation\n
    \                     and specification\", STD 13, RFC 1035, November\n                      1987.\n
    \  [RFC2119]          Bradner, S., \"Key words for use in RFCs to\n                      Indicate
    Requirement Levels\", BCP 14, RFC 2119,\n                      March 1997.\n   [RFC2434]
    \         Narten, T. and H. Alvestrand, \"Guidelines for\n                      Writing
    an IANA Considerations Section in RFCs\",\n                      BCP 26, RFC 2434,
    October 1998.\n   [RFC2782]          Gulbrandsen, A., Vixie, P., and L. Esibov,
    \"A DNS\n                      RR for specifying the location of services (DNS\n
    \                     SRV)\", RFC 2782, February 2000.\n   [RFC2253]          Wahl,
    M., Kille, S., and T. Howes, \"Lightweight\n                      Directory Access
    Protocol (v3): UTF-8 String\n                      Representation of Distinguished
    Names\", RFC 2253,\n                      December 1997.\n   [RFC3513]          Hinden,
    R. and S. Deering, \"Internet Protocol\n                      Version 6 (IPv6)
    Addressing Architecture\", RFC\n                      3513, April 2003.\n   [X680]
    \            Abstract Syntax Notation One (ASN.1):\n                      Specification
    of Basic Notation, ITU-T\n                      Recommendation X.680 (1997) |
    ISO/IEC\n                      International Standard 8824-1:1998.\n   [X690]
    \            ASN.1 encoding rules: Specification of Basic\n                      Encoding
    Rules (BER), Canonical Encoding Rules\n                      (CER) and Distinguished
    Encoding Rules (DER),\n                      ITU-T Recommendation X.690 (1997)|
    ISO/IEC\n                      International Standard 8825-1:1998.\n"
  title: Normative References
- contents:
  - "Informative References\n   [ISO-8859]         International Organization for
    Standardization,\n                      \"8-bit Single-byte Coded Graphic Character
    Sets --\n                      Latin Alphabet\", ISO/IEC 8859.\n   [RFC1964]          Linn,
    J., \"The Kerberos Version 5 GSS-API\n                      Mechanism\", RFC 1964,
    June 1996.\n   [DGT96]            Don Davis, Daniel Geer, and Theodore Ts'o,\n
    \                     \"Kerberos With Clocks Adrift: History, Protocols,\n                      and
    Implementation\", USENIX Computing Systems 9:1,\n                      January
    1996.\n   [DS81]             Dorothy E. Denning and Giovanni Maria Sacco,\n                      \"Time-stamps
    in Key Distribution Protocols,\"\n                      Communications of the
    ACM, Vol. 24 (8), p. 533-\n                      536, August 1981.\n   [KNT94]
    \           John T. Kohl, B. Clifford Neuman, and Theodore Y.\n                      Ts'o,
    \"The Evolution of the Kerberos\n                      Authentication System\".
    In Distributed Open\n                      Systems, pages 78-94. IEEE Computer
    Society Press,\n                      1994.\n   [MNSS87]           S. P. Miller,
    B. C. Neuman, J. I. Schiller, and J.\n                      H. Saltzer, Section
    E.2.1: Kerberos Authentication\n                      and Authorization System,
    M.I.T. Project Athena,\n                      Cambridge, Massachusetts, December
    21, 1987.\n   [NS78]             Roger M. Needham and Michael D. Schroeder, \"Using\n
    \                     Encryption for Authentication in Large Networks of\n                      Computers,\"
    Communications of the ACM, Vol. 21\n                      (12), pp. 993-999, December
    1978.\n   [Neu93]            B. Clifford Neuman, \"Proxy-Based Authorization and\n
    \                     Accounting for Distributed Systems,\" in\n                      Proceedings
    of the 13th International Conference\n                      on Distributed Computing
    Systems, Pittsburgh, PA,\n                      May 1993.\n   [NT94]             B.
    Clifford Neuman and Theodore Y. Ts'o, \"An\n                      Authentication
    Service for Computer Networks,\"\n                      IEEE Communications Magazine,
    Vol. 32 (9), p. 33-\n                      38, September 1994.\n   [Pat92]            J.
    Pato, Using Pre-Authentication to Avoid\n                      Password Guessing
    Attacks, Open Software\n                      Foundation DCE Request for Comments
    26 (December\n                      1992.\n   [RFC1510]          Kohl, J. and
    C. Neuman, \"The Kerberos Network\n                      Authentication Service
    (V5)\", RFC 1510, September\n                      1993.\n   [RFC4086]          Eastlake,
    D., 3rd, Schiller, J., and S. Crocker,\n                      \"Randomness Requirements
    for Security\", BCP 106,\n                      RFC 4086, June 2005.\n   [SNS88]
    \           J. G. Steiner, B. C. Neuman, and J. I. Schiller,\n                      \"Kerberos:
    An Authentication Service for Open\n                      Network Systems,\" p.
    191-202, Usenix Conference\n                      Proceedings, Dallas, Texas,
    February 1988.\n   [RFC4121]          Zhu, L., Jaganathan, K., and S. Hartman,
    \"The\n                      Kerberos Version 5 Generic Security Service\n                      Application
    Program Interface (GSS-API) Mechanism:\n                      Version 2\", RFC
    4121, July 2005.\n"
  title: Informative References
- contents:
  - "Authors' Addresses\n   Clifford Neuman\n   Information Sciences Institute\n   University
    of Southern California\n   4676 Admiralty Way\n   Marina del Rey, CA 90292, USA\n
    \  EMail: bcn@isi.edu\n   Tom Yu\n   Massachusetts Institute of Technology\n   77
    Massachusetts Avenue\n   Cambridge, MA 02139, USA\n   EMail: tlyu@mit.edu\n   Sam
    Hartman\n   Massachusetts Institute of Technology\n   77 Massachusetts Avenue\n
    \  Cambridge, MA 02139, USA\n   EMail: hartmans-ietf@mit.edu\n   Kenneth Raeburn\n
    \  Massachusetts Institute of Technology\n   77 Massachusetts Avenue\n   Cambridge,
    MA 02139, USA\n   EMail: raeburn@mit.edu\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
