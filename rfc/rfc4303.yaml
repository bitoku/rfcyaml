- title: __initial_text__
  contents:
  - '                IP Encapsulating Security Payload (ESP)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes an updated version of the Encapsulating\n\
    \   Security Payload (ESP) protocol, which is designed to provide a mix\n   of\
    \ security services in IPv4 and IPv6.  ESP is used to provide\n   confidentiality,\
    \ data origin authentication, connectionless\n   integrity, an anti-replay service\
    \ (a form of partial sequence\n   integrity), and limited traffic flow confidentiality.\
    \  This document\n   obsoletes RFC 2406 (November 1998).\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n      3.2. Algorithms ................................................20\n\
    \           3.2.1. Encryption Algorithms ..............................21\n  \
    \         3.2.2. Integrity Algorithms ...............................21\n    \
    \       3.2.3. Combined Mode Algorithms ...........................22\n      3.3.\
    \ Outbound Packet Processing ................................22\n           3.3.1.\
    \ Security Association Lookup ........................22\n           3.3.2. Packet\
    \ Encryption and Integrity Check Value\n                  (ICV) Calculation ..................................22\n\
    \                  3.3.2.1. Separate Confidentiality and\n                   \
    \        Integrity Algorithms ......................23\n                  3.3.2.2.\
    \ Combined Confidentiality and\n                           Integrity Algorithms\
    \ ......................24\n           3.3.3. Sequence Number Generation .........................25\n\
    \           3.3.4. Fragmentation ......................................26\n  \
    \    3.4. Inbound Packet Processing .................................27\n    \
    \       3.4.1. Reassembly .........................................27\n      \
    \     3.4.2. Security Association Lookup ........................27\n        \
    \   3.4.3. Sequence Number Verification .......................28\n          \
    \ 3.4.4. Integrity Check Value Verification .................30\n            \
    \      3.4.4.1. Separate Confidentiality and\n                           Integrity\
    \ Algorithms ......................30\n                  3.4.4.2. Combined Confidentiality\
    \ and\n                           Integrity Algorithms ......................32\n\
    \   4. Auditing .......................................................33\n  \
    \ 5. Conformance Requirements .......................................34\n   6.\
    \ Security Considerations ........................................34\n   7. Differences\
    \ from RFC 2406 ......................................34\n   8. Backward-Compatibility\
    \ Considerations ..........................35\n   9. Acknowledgements ...............................................36\n\
    \   10. References ....................................................36\n  \
    \    10.1. Normative References .....................................36\n    \
    \  10.2. Informative References ...................................37\n   Appendix\
    \ A: Extended (64-bit) Sequence Numbers ....................38\n      A1. Overview\
    \ ...................................................38\n      A2. Anti-Replay\
    \ Window .........................................38\n          A2.1. Managing\
    \ and Using the Anti-Replay Window ............39\n          A2.2. Determining\
    \ the Higher-Order Bits (Seqh) of the\n                Sequence Number ......................................40\n\
    \          A2.3. Pseudo-Code Example ..................................41\n  \
    \    A3. Handling Loss of Synchronization due to Significant\n          Packet\
    \ Loss ................................................42\n          A3.1. Triggering\
    \ Re-synchronization ........................43\n          A3.2. Re-synchronization\
    \ Process ...........................43\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document assumes that the reader is familiar with the\
    \ terms and\n   concepts described in the \"Security Architecture for the Internet\n\
    \   Protocol\" [Ken-Arch], hereafter referred to as the Security\n   Architecture\
    \ document.  In particular, the reader should be familiar\n   with the definitions\
    \ of security services offered by the\n   Encapsulating Security Payload (ESP)\
    \ and the IP Authentication Header\n   (AH), the concept of Security Associations,\
    \ the ways in which ESP can\n   be used in conjunction with AH, and the different\
    \ key management\n   options available for ESP and AH.\n   The keywords MUST,\
    \ MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,\n   SHOULD NOT, RECOMMENDED, MAY,\
    \ and OPTIONAL, when they appear in this\n   document, are to be interpreted as\
    \ described in RFC 2119 [Bra97].\n   The Encapsulating Security Payload (ESP)\
    \ header is designed to\n   provide a mix of security services in IPv4 and IPv6\
    \ [DH98].  ESP may\n   be applied alone, in combination with AH [Ken-AH], or in\
    \ a nested\n   fashion (see the Security Architecture document [Ken-Arch]).\n\
    \   Security services can be provided between a pair of communicating\n   hosts,\
    \ between a pair of communicating security gateways, or between\n   a security\
    \ gateway and a host.  For more details on how to use ESP\n   and AH in various\
    \ network environments, see the Security Architecture\n   document [Ken-Arch].\n\
    \   The ESP header is inserted after the IP header and before the next\n   layer\
    \ protocol header (transport mode) or before an encapsulated IP\n   header (tunnel\
    \ mode).  These modes are described in more detail\n   below.\n   ESP can be used\
    \ to provide confidentiality, data origin\n   authentication, connectionless integrity,\
    \ an anti-replay service (a\n   form of partial sequence integrity), and (limited)\
    \ traffic flow\n   confidentiality.  The set of services provided depends on options\n\
    \   selected at the time of Security Association (SA) establishment and\n   on\
    \ the location of the implementation in a network topology.\n   Using encryption-only\
    \ for confidentiality is allowed by ESP.\n   However, it should be noted that\
    \ in general, this will provide\n   defense only against passive attackers.  Using\
    \ encryption without a\n   strong integrity mechanism on top of it (either in\
    \ ESP or separately\n   via AH) may render the confidentiality service insecure\
    \ against some\n   forms of active attacks [Bel96, Kra01].  Moreover, an underlying\n\
    \   integrity service, such as AH, applied before encryption does not\n   necessarily\
    \ protect the encryption-only confidentiality against\n   active attackers [Kra01].\
    \  ESP allows encryption-only SAs because\n   this may offer considerably better\
    \ performance and still provide\n   adequate security, e.g., when higher-layer\
    \ authentication/integrity\n   protection is offered independently.  However,\
    \ this standard does not\n   require ESP implementations to offer an encryption-only\
    \ service.\n   Data origin authentication and connectionless integrity are joint\n\
    \   services, hereafter referred to jointly as \"integrity\".  (This term\n  \
    \ is employed because, on a per-packet basis, the computation being\n   performed\
    \ provides connectionless integrity directly; data origin\n   authentication is\
    \ provided indirectly as a result of binding the key\n   used to verify the integrity\
    \ to the identity of the IPsec peer.\n   Typically, this binding is effected through\
    \ the use of a shared,\n   symmetric key.)  Integrity-only ESP MUST be offered\
    \ as a service\n   selection option, e.g., it must be negotiable in SA management\n\
    \   protocols and MUST be configurable via management interfaces.\n   Integrity-only\
    \ ESP is an attractive alternative to AH in many\n   contexts, e.g., because it\
    \ is faster to process and more amenable to\n   pipelining in many implementations.\n\
    \   Although confidentiality and integrity can be offered independently,\n   ESP\
    \ typically will employ both services, i.e., packets will be\n   protected with\
    \ regard to confidentiality and integrity.  Thus, there\n   are three possible\
    \ ESP security service combinations involving these\n   services:\n          \
    \  - confidentiality-only (MAY be supported)\n            - integrity only (MUST\
    \ be supported)\n            - confidentiality and integrity (MUST be supported)\n\
    \   The anti-replay service may be selected for an SA only if the\n   integrity\
    \ service is selected for that SA.  The selection of this\n   service is solely\
    \ at the discretion of the receiver and thus need not\n   be negotiated.  However,\
    \ to make use of the Extended Sequence Number\n   feature in an interoperable\
    \ fashion, ESP does impose a requirement on\n   SA management protocols to be\
    \ able to negotiate this feature (see\n   Section 2.2.1 below).\n   The traffic\
    \ flow confidentiality (TFC) service generally is effective\n   only if ESP is\
    \ employed in a fashion that conceals the ultimate\n   source and destination\
    \ addresses of correspondents, e.g., in tunnel\n   mode between security gateways,\
    \ and only if sufficient traffic flows\n   between IPsec peers (either naturally\
    \ or as a result of generation of\n   masking traffic) to conceal the characteristics\
    \ of specific,\n   individual subscriber traffic flows.  (ESP may be employed\
    \ as part of\n   a higher-layer TFC system, e.g., Onion Routing [Syverson], but\
    \ such\n   systems are outside the scope of this standard.)  New TFC features\n\
    \   present in ESP facilitate efficient generation and discarding of\n   dummy\
    \ traffic and better padding of real traffic, in a backward-\n   compatible fashion.\n\
    \   Section 7 provides a brief review of the differences between this\n   document\
    \ and RFC 2406.\n"
- title: 2.  Encapsulating Security Payload Packet Format
  contents:
  - "2.  Encapsulating Security Payload Packet Format\n   The (outer) protocol header\
    \ (IPv4, IPv6, or Extension) that\n   immediately precedes the ESP header SHALL\
    \ contain the value 50 in its\n   Protocol (IPv4) or Next Header (IPv6, Extension)\
    \ field (see IANA web\n   page at http://www.iana.org/assignments/protocol-numbers).\
    \  Figure 1\n   illustrates the top-level format of an ESP packet.  The packet\
    \ begins\n   with two 4-byte fields (Security Parameters Index (SPI) and Sequence\n\
    \   Number).  Following these fields is the Payload Data, which has\n   substructure\
    \ that depends on the choice of encryption algorithm and\n   mode, and on the\
    \ use of TFC padding, which is examined in more detail\n   later.  Following the\
    \ Payload Data are Padding and Pad Length fields,\n   and the Next Header field.\
    \  The optional Integrity Check Value (ICV)\n   field completes the packet.\n\
    \ 0                   1                   2                   3\n 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n"
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ----
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ----

    '
- title: '|               Security Parameters Index (SPI)                 | ^Int.'
  contents:
  - '|               Security Parameters Index (SPI)                 | ^Int.

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-

    '
- title: '|                      Sequence Number                          | |ered'
  contents:
  - '|                      Sequence Number                          | |ered

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ----
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ----

    '
- title: '|                    Payload Data* (variable)                   | |   ^'
  contents:
  - '|                    Payload Data* (variable)                   | |   ^

    '
- title: ~                                                               ~ |   |
  contents:
  - '~                                                               ~ |   |

    '
- title: '|                                                               | |Conf.'
  contents:
  - '|                                                               | |Conf.

    '
- title: +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-
  contents:
  - '+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-

    '
- title: '|               |     Padding (0-255 bytes)                     | |ered*'
  contents:
  - '|               |     Padding (0-255 bytes)                     | |ered*

    '
- title: +-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |   |
  contents:
  - '+-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |   |

    '
- title: '|                               |  Pad Length   | Next Header   | v   v'
  contents:
  - '|                               |  Pad Length   | Next Header   | v   v

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------

    '
- title: '|         Integrity Check Value-ICV   (variable)                |'
  contents:
  - '|         Integrity Check Value-ICV   (variable)                |

    '
- title: ~                                                               ~
  contents:
  - '~                                                               ~

    '
- title: '|                                                               |'
  contents:
  - '|                                                               |

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         \
    \   Figure 1.  Top-Level Format of an ESP Packet\n    * If included in the Payload\
    \ field, cryptographic synchronization\n      data, e.g., an Initialization Vector\
    \ (IV, see Section 2.3),\n      usually is not encrypted per se, although it often\
    \ is referred\n      to as being part of the ciphertext.\n   The (transmitted)\
    \ ESP trailer consists of the Padding, Pad Length,\n   and Next Header fields.\
    \  Additional, implicit ESP trailer data (which\n   is not transmitted) is included\
    \ in the integrity computation, as\n   described below.\n   If the integrity service\
    \ is selected, the integrity computation\n   encompasses the SPI, Sequence Number,\
    \ Payload Data, and the ESP\n   trailer (explicit and implicit).\n   If the confidentiality\
    \ service is selected, the ciphertext consists\n   of the Payload Data (except\
    \ for any cryptographic synchronization\n   data that may be included) and the\
    \ (explicit) ESP trailer.\n   As noted above, the Payload Data may have substructure.\
    \  An\n   encryption algorithm that requires an explicit Initialization Vector\n\
    \   (IV), e.g., Cipher Block Chaining (CBC) mode, often prefixes the\n   Payload\
    \ Data to be protected with that value.  Some algorithm modes\n   combine encryption\
    \ and integrity into a single operation; this\n   document refers to such algorithm\
    \ modes as \"combined mode\n   algorithms\".  Accommodation of combined mode algorithms\
    \ requires that\n   the algorithm explicitly describe the payload substructure\
    \ used to\n   convey the integrity data.\n   Some combined mode algorithms provide\
    \ integrity only for data that is\n   encrypted, whereas others can provide integrity\
    \ for some additional\n   data that is not encrypted for transmission.  Because\
    \ the SPI and\n   Sequence Number fields require integrity as part of the integrity\n\
    \   service, and they are not encrypted, it is necessary to ensure that\n   they\
    \ are afforded integrity whenever the service is selected,\n   regardless of the\
    \ style of combined algorithm mode employed.\n   When any combined mode algorithm\
    \ is employed, the algorithm itself is\n   expected to return both decrypted plaintext\
    \ and a pass/fail\n   indication for the integrity check.  For combined mode algorithms,\n\
    \   the ICV that would normally appear at the end of the ESP packet (when\n  \
    \ integrity is selected) may be omitted.  When the ICV is omitted and\n   integrity\
    \ is selected, it is the responsibility of the combined mode\n   algorithm to\
    \ encode within the Payload Data an ICV-equivalent means\n   of verifying the\
    \ integrity of the packet.\n   If a combined mode algorithm offers integrity only\
    \ to data that is\n   encrypted, it will be necessary to replicate the SPI and\
    \ Sequence\n   Number as part of the Payload Data.\n   Finally, a new provision\
    \ is made to insert padding for traffic flow\n   confidentiality after the Payload\
    \ Data and before the ESP trailer.\n   Figure 2 illustrates this substructure\
    \ for Payload Data.  (Note: This\n   diagram shows bits-on-the-wire.  So even\
    \ if extended sequence numbers\n   are being used, only 32 bits of the Sequence\
    \ Number will be\n   transmitted (see Section 2.2.1).)\n     0               \
    \    1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Security Parameters Index (SPI)                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Sequence Number                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---\n\
    \   |                    IV (optional)                              | ^ p\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a\n   |\
    \                    Rest of Payload Data  (variable)           | | y\n   ~  \
    \                                                             ~ | l\n   |    \
    \                                                           | | o\n   +      \
    \         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a\n   |        \
    \       |         TFC Padding * (optional, variable)    | v d\n   +-+-+-+-+-+-+-+-+\
    \         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---\n   |                   \
    \      |        Padding (0-255 bytes)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                               |\
    \  Pad Length   | Next Header   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Integrity Check Value-ICV   (variable)                |\n   ~  \
    \                                                             ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 2. Substructure of Payload Data\n         * If tunnel mode\
    \ is being used, then the IPsec implementation\n           can add Traffic Flow\
    \ Confidentiality (TFC) padding (see\n           Section 2.4)  after the Payload\
    \ Data and before the Padding\n           (0-255 bytes) field.\n   If a combined\
    \ algorithm mode is employed, the explicit ICV shown in\n   Figures 1 and 2 may\
    \ be omitted (see Section 3.3.2.2 below).  Because\n   algorithms and modes are\
    \ fixed when an SA is established, the\n   detailed format of ESP packets for\
    \ a given SA (including the Payload\n   Data substructure) is fixed, for all traffic\
    \ on the SA.\n   The tables below refer to the fields in the preceding figures\
    \ and\n   illustrate how several categories of algorithmic options, each with\
    \ a\n   different processing model, affect the fields noted above.  The\n   processing\
    \ details are described in later sections.\n          Table 1. Separate Encryption\
    \ and Integrity Algorithms\n                                            What \
    \   What    What\n                          # of     Requ'd  Encrypt Integ   \
    \ is\n                          bytes      [1]   Covers  Covers  Xmtd\n      \
    \                    ------   ------  ------  ------  ------\n   SPI         \
    \              4        M              Y     plain\n   Seq# (low-order bits) \
    \    4        M              Y     plain       p\n                           \
    \                                     ------ a\n   IV                     variable\
    \    O              Y     plain     | y\n   IP datagram [2]        variable  M\
    \ or D    Y      Y     cipher[3] |-l\n   TFC padding [4]        variable    O\
    \       Y      Y     cipher[3] | o\n                                         \
    \                       ------ a\n   Padding                 0-255      M    \
    \   Y      Y     cipher[3]   d\n   Pad Length                1        M      \
    \ Y      Y     cipher[3]\n   Next Header               1        M       Y    \
    \  Y     cipher[3]\n   Seq# (high-order bits)    4     if ESN [5]        Y   \
    \  not xmtd\n   ICV Padding            variable if need           Y     not xmtd\n\
    \   ICV                    variable   M [6]                 plain\n          \
    \ [1] M = mandatory; O = optional; D = dummy\n           [2] If tunnel mode ->\
    \ IP datagram\n               If transport mode -> next header and data\n    \
    \       [3] ciphertext if encryption has been selected\n           [4] Can be\
    \ used only if payload specifies its \"real\" length\n           [5] See section\
    \ 2.2.1\n           [6] mandatory if a separate integrity algorithm is used\n\
    \                  Table 2. Combined Mode Algorithms\n                       \
    \                      What    What    What\n                            # of\
    \     Requ'd  Encrypt Integ    is\n                            bytes      [1]\
    \   Covers  Covers  Xmtd\n                            ------   ------  ------\
    \  ------  ------\n    SPI                        4        M                 \
    \   plain\n    Seq# (low-order bits)      4        M                    plain\
    \    p\n                                                                  ---\
    \ a\n    IV                      variable    O              Y     plain  | y\n\
    \    IP datagram [2]         variable  M or D    Y      Y     cipher |-l\n   \
    \ TFC padding [3]         variable    O       Y      Y     cipher | o\n      \
    \                                                            --- a\n    Padding\
    \                  0-255      M       Y      Y     cipher   d\n    Pad Length\
    \                 1        M       Y      Y     cipher\n    Next Header      \
    \          1        M       Y      Y     cipher\n    Seq# (high-order bits)  \
    \   4     if ESN [4]        Y     [5]\n    ICV Padding             variable if\
    \ need           Y     [5]\n    ICV                     variable    O [6]    \
    \            plain\n            [1] M = mandatory; O = optional; D = dummy\n \
    \           [2] If tunnel mode -> IP datagram\n                If transport mode\
    \ -> next header and data\n            [3] Can be used only if payload specifies\
    \ its \"real\" length\n            [4] See Section 2.2.1\n            [5] The\
    \ algorithm choices determines whether these are\n                transmitted,\
    \ but in either case, the result is invisible\n                to ESP\n      \
    \      [6] The algorithm spec determines whether this field is\n             \
    \   present\n   The following subsections describe the fields in the header format.\n\
    \   \"Optional\" means that the field is omitted if the option is not\n   selected,\
    \ i.e., it is present in neither the packet as transmitted\n   nor as formatted\
    \ for computation of an ICV (see Section 2.7).\n   Whether or not an option is\
    \ selected is determined as part of\n   Security Association (SA) establishment.\
    \  Thus, the format of ESP\n   packets for a given SA is fixed, for the duration\
    \ of the SA.  In\n   contrast, \"mandatory\" fields are always present in the\
    \ ESP packet\n   format, for all SAs.\n   Note: All of the cryptographic algorithms\
    \ used in IPsec expect their\n   input in canonical network byte order (see Appendix\
    \ of RFC 791\n   [Pos81]) and generate their output in canonical network byte\
    \ order.\n   IP packets are also transmitted in network byte order.\n   ESP does\
    \ not contain a version number, therefore if there are\n   concerns about backward\
    \ compatibility, they MUST be addressed by\n   using a signaling mechanism between\
    \ the two IPsec peers to ensure\n   compatible versions of ESP (e.g., Internet\
    \ Key Exchange (IKEv2)\n   [Kau05]) or an out-of-band configuration mechanism.\n"
- title: 2.1.  Security Parameters Index (SPI)
  contents:
  - "2.1.  Security Parameters Index (SPI)\n   The SPI is an arbitrary 32-bit value\
    \ that is used by a receiver to\n   identify the SA to which an incoming packet\
    \ is bound.  The SPI field\n   is mandatory.\n   For a unicast SA, the SPI can\
    \ be used by itself to specify an SA, or\n   it may be used in conjunction with\
    \ the IPsec protocol type (in this\n   case ESP).  Because the SPI value is generated\
    \ by the receiver for a\n   unicast SA, whether the value is sufficient to identify\
    \ an SA by\n   itself or whether it must be used in conjunction with the IPsec\n\
    \   protocol value is a local matter.  This mechanism for mapping inbound\n  \
    \ traffic to unicast SAs MUST be supported by all ESP implementations.\n   If\
    \ an IPsec implementation supports multicast, then it MUST support\n   multicast\
    \ SAs using the algorithm below for mapping inbound IPsec\n   datagrams to SAs.\
    \  Implementations that support only unicast traffic\n   need not implement this\
    \ de-multiplexing algorithm.\n   In many secure multicast architectures (e.g.,\
    \ [RFC3740]), a central\n   Group Controller/Key Server unilaterally assigns the\
    \ group security\n   association's SPI.  This SPI assignment is not negotiated\
    \ or\n   coordinated with the key management (e.g., IKE) subsystems that\n   reside\
    \ in the individual end systems that comprise the group.\n   Consequently, it\
    \ is possible that a group security association and a\n   unicast security association\
    \ can simultaneously use the same SPI.  A\n   multicast-capable IPsec implementation\
    \ MUST correctly de-multiplex\n   inbound traffic even in the context of SPI collisions.\n\
    \   Each entry in the Security Association Database (SAD) [Ken-Arch] must\n  \
    \ indicate whether the SA lookup makes use of the destination, or\n   destination\
    \ and source, IP addresses, in addition to the SPI.  For\n   multicast SAs, the\
    \ protocol field is not employed for SA lookups.\n   For each inbound, IPsec-protected\
    \ packet, an implementation must\n   conduct its search of the SAD such that it\
    \ finds the entry that\n   matches the \"longest\" SA identifier.  In this context,\
    \ if two or more\n   SAD entries match based on the SPI value, then the entry\
    \ that also\n   matches based on destination, or destination and source, address\n\
    \   comparison (as indicated in the SAD entry) is the \"longest\" match.\n   This\
    \ implies a logical ordering of the SAD search as follows:\n         1. Search\
    \ the SAD for a match on {SPI, destination address,\n            source address}.\
    \  If an SAD entry matches, then process the\n            inbound ESP packet with\
    \ that matching SAD entry.  Otherwise,\n            proceed to step 2.\n     \
    \    2. Search the SAD for a match on {SPI, destination address}.\n          \
    \  If the SAD entry matches, then process the inbound ESP\n            packet\
    \ with that matching SAD entry.  Otherwise, proceed to\n            step 3.\n\
    \         3. Search the SAD for a match on only {SPI} if the receiver has\n  \
    \          chosen to maintain a single SPI space for AH and ESP, or on\n     \
    \       {SPI, protocol} otherwise.  If an SAD entry matches, then\n          \
    \  process the inbound ESP packet with that matching SAD entry.\n            Otherwise,\
    \ discard the packet and log an auditable event.\n   In practice, an implementation\
    \ MAY choose any method to accelerate\n   this search, although its externally\
    \ visible behavior MUST be\n   functionally equivalent to having searched the\
    \ SAD in the above\n   order.  For example, a software-based implementation could\
    \ index into\n   a hash table by the SPI.  The SAD entries in each hash table\
    \ bucket's\n   linked list are kept sorted to have those SAD entries with the\n\
    \   longest SA identifiers first in that linked list.  Those SAD entries\n   having\
    \ the shortest SA identifiers are sorted so that they are the\n   last entries\
    \ in the linked list.  A hardware-based implementation may\n   be able to effect\
    \ the longest match search intrinsically, using\n   commonly available Ternary\
    \ Content-Addressable Memory (TCAM)\n   features.\n   The indication of whether\
    \ source and destination address matching is\n   required to map inbound IPsec\
    \ traffic to SAs MUST be set either as a\n   side effect of manual SA configuration\
    \ or via negotiation using an SA\n   management protocol, e.g., IKE or Group Domain\
    \ of Interpretation\n   (GDOI) [RFC3547].  Typically, Source-Specific Multicast\
    \ (SSM) [HC03]\n   groups use a 3-tuple SA identifier composed of an SPI, a destination\n\
    \   multicast address, and source address.  An Any-Source Multicast group\n  \
    \ SA requires only an SPI and a destination multicast address as an\n   identifier.\n\
    \   The set of SPI values in the range 1 through 255 are reserved by the\n   Internet\
    \ Assigned Numbers Authority (IANA) for future use; a reserved\n   SPI value will\
    \ not normally be assigned by IANA unless the use of the\n   assigned SPI value\
    \ is specified in an RFC.  The SPI value of zero (0)\n   is reserved for local,\
    \ implementation-specific use and MUST NOT be\n   sent on the wire.  (For example,\
    \ a key management implementation\n   might use the zero SPI value to mean \"\
    No Security Association Exists\"\n   during the period when the IPsec implementation\
    \ has requested that\n   its key management entity establish a new SA, but the\
    \ SA has not yet\n   been established.)\n"
- title: 2.2.  Sequence Number
  contents:
  - "2.2.  Sequence Number\n   This unsigned 32-bit field contains a counter value\
    \ that increases by\n   one for each packet sent, i.e., a per-SA packet sequence\
    \ number.  For\n   a unicast SA or a single-sender multicast SA, the sender MUST\n\
    \   increment this field for every transmitted packet.  Sharing an SA\n   among\
    \ multiple senders is permitted, though generally not\n   recommended.  ESP provides\
    \ no means of synchronizing packet counters\n   among multiple senders or meaningfully\
    \ managing a receiver packet\n   counter and window in the context of multiple\
    \ senders.  Thus, for a\n   multi-sender SA, the anti-replay features of ESP are\
    \ not available\n   (see Sections 3.3.3 and 3.4.3.)\n   The field is mandatory\
    \ and MUST always be present even if the\n   receiver does not elect to enable\
    \ the anti-replay service for a\n   specific SA.  Processing of the Sequence Number\
    \ field is at the\n   discretion of the receiver, but all ESP implementations\
    \ MUST be\n   capable of performing the processing described in Sections 3.3.3\
    \ and\n   3.4.3. Thus, the sender MUST always transmit this field, but the\n \
    \  receiver need not act upon it (see the discussion of Sequence Number\n   Verification\
    \ in the \"Inbound Packet Processing\" section (3.4.3)\n   below).\n   The sender's\
    \ counter and the receiver's counter are initialized to 0\n   when an SA is established.\
    \  (The first packet sent using a given SA\n   will have a sequence number of\
    \ 1; see Section 3.3.3 for more details\n   on how the sequence number is generated.)\
    \  If anti-replay is enabled\n   (the default), the transmitted sequence number\
    \ must never be allowed\n   to cycle.  Thus, the sender's counter and the receiver's\
    \ counter MUST\n   be reset (by establishing a new SA and thus a new key) prior\
    \ to the\n   transmission of the 2^32nd packet on an SA.\n"
- title: 2.2.1.  Extended (64-bit) Sequence Number
  contents:
  - "2.2.1.  Extended (64-bit) Sequence Number\n   To support high-speed IPsec implementations,\
    \ Extended Sequence\n   Numbers (ESNs) SHOULD be implemented, as an extension\
    \ to the current,\n   32-bit sequence number field.  Use of an ESN MUST be negotiated\
    \ by an\n   SA management protocol.  Note that in IKEv2, this negotiation is\n\
    \   implicit; the default is ESN unless 32-bit sequence numbers are\n   explicitly\
    \ negotiated.  (The ESN feature is applicable to multicast\n   as well as unicast\
    \ SAs.)\n   The ESN facility allows use of a 64-bit sequence number for an SA.\n\
    \   (See Appendix A, \"Extended (64-bit) Sequence Numbers\", for details.)\n \
    \  Only the low-order 32 bits of the sequence number are transmitted in\n   the\
    \ plaintext ESP header of each packet, thus minimizing packet\n   overhead.  The\
    \ high-order 32 bits are maintained as part of the\n   sequence number counter\
    \ by both transmitter and receiver and are\n   included in the computation of\
    \ the ICV (if the integrity service is\n   selected).  If a separate integrity\
    \ algorithm is employed, the high\n   order bits are included in the implicit\
    \ ESP trailer, but are not\n   transmitted, analogous to integrity algorithm padding\
    \ bits.  If a\n   combined mode algorithm is employed, the algorithm choice determines\n\
    \   whether the high-order ESN bits are transmitted or are included\n   implicitly\
    \ in the computation.  See Section 3.3.2.2 for processing\n   details.\n"
- title: 2.3.  Payload Data
  contents:
  - "2.3.  Payload Data\n   Payload Data is a variable-length field containing data\
    \ (from the\n   original IP packet) described by the Next Header field.  The Payload\n\
    \   Data field is mandatory and is an integral number of bytes in length.\n  \
    \ If the algorithm used to encrypt the payload requires cryptographic\n   synchronization\
    \ data, e.g., an Initialization Vector (IV), then this\n   data is carried explicitly\
    \ in the Payload field, but it is not called\n   out as a separate field in ESP,\
    \ i.e., the transmission of an explicit\n   IV is invisible to ESP.  (See Figure\
    \ 2.)  Any encryption algorithm\n   that requires such explicit, per-packet synchronization\
    \ data MUST\n   indicate the length, any structure for such data, and the location\
    \ of\n   this data as part of an RFC specifying how the algorithm is used with\n\
    \   ESP.  (Typically, the IV immediately precedes the ciphertext.  See\n   Figure\
    \ 2.)  If such synchronization data is implicit, the algorithm\n   for deriving\
    \ the data MUST be part of the algorithm definition RFC.\n   (If included in the\
    \ Payload field, cryptographic synchronization\n   data, e.g., an Initialization\
    \ Vector (IV), usually is not encrypted\n   per se (see Tables 1 and 2), although\
    \ it sometimes is referred to as\n   being part of the ciphertext.)\n   Note that\
    \ the beginning of the next layer protocol header MUST be\n   aligned relative\
    \ to the beginning of the ESP header as follows.  For\n   IPv4, this alignment\
    \ is a multiple of 4 bytes.  For IPv6, the\n   alignment is a multiple of 8 bytes.\n\
    \   With regard to ensuring the alignment of the (real) ciphertext in the\n  \
    \ presence of an IV, note the following:\n         o For some IV-based modes of\
    \ operation, the receiver treats\n           the IV as the start of the ciphertext,\
    \ feeding it into the\n           algorithm directly.  In these modes, alignment\
    \ of the start\n           of the (real) ciphertext is not an issue at the receiver.\n\
    \         o In some cases, the receiver reads the IV in separately from\n    \
    \       the ciphertext.  In these cases, the algorithm specification\n       \
    \    MUST address how alignment of the (real) ciphertext is to be\n          \
    \ achieved.\n"
- title: 2.4.  Padding (for Encryption)
  contents:
  - "2.4.  Padding (for Encryption)\n   Two primary factors require or motivate use\
    \ of the Padding field.\n      o If an encryption algorithm is employed that requires\
    \ the\n        plaintext to be a multiple of some number of bytes, e.g.,\n   \
    \     the block size of a block cipher, the Padding field is used\n        to\
    \ fill the plaintext (consisting of the Payload Data,\n        Padding, Pad Length,\
    \ and Next Header fields) to the size\n        required by the algorithm.\n  \
    \    o Padding also may be required, irrespective of encryption\n        algorithm\
    \ requirements, to ensure that the resulting\n        ciphertext terminates on\
    \ a 4-byte boundary.  Specifically,\n        the Pad Length and Next Header fields\
    \ must be right aligned\n        within a 4-byte word, as illustrated in the ESP\
    \ packet\n        format figures above, to ensure that the ICV field (if\n   \
    \     present) is aligned on a 4-byte boundary.\n   Padding beyond that required\
    \ for the algorithm or alignment reasons\n   cited above could be used to conceal\
    \ the actual length of the\n   payload, in support of TFC.  However, the Padding\
    \ field described is\n   too limited to be effective for TFC and thus should not\
    \ be used for\n   that purpose.  Instead, the separate mechanism described below\
    \ (see\n   Section 2.7) should be used when TFC is required.\n   The sender MAY\
    \ add 0 to 255 bytes of padding.  Inclusion of the\n   Padding field in an ESP\
    \ packet is optional, subject to the\n   requirements noted above, but all implementations\
    \ MUST support\n   generation and consumption of padding.\n      o For the purpose\
    \ of ensuring that the bits to be encrypted\n        are a multiple of the algorithm's\
    \ block size (first bullet\n        above), the padding computation applies to\
    \ the Payload Data\n        exclusive of any IV, but including the ESP trailer\n\
    \        fields.  If a combined algorithm mode requires transmission\n       \
    \ of the SPI and Sequence Number to effect integrity, e.g.,\n        replication\
    \ of the SPI and Sequence Number in the Payload\n        Data, then the replicated\
    \ versions of these data items, and\n        any associated, ICV-equivalent data,\
    \ are included in the\n        computation of the pad length.  (If the ESN option\
    \ is\n        selected, the high-order 32 bits of the ESN also would enter\n \
    \       into the computation, if the combined mode algorithm\n        requires\
    \ their transmission for integrity.)\n      o For the purposes of ensuring that\
    \ the ICV is aligned on a\n        4-byte boundary (second bullet above), the\
    \ padding\n        computation applies to the Payload Data inclusive of the IV,\n\
    \        the Pad Length, and Next Header fields.  If a combined mode\n       \
    \ algorithm is used, any replicated data and ICV-equivalent\n        data are\
    \ included in the Payload Data covered by the padding\n        computation.\n\
    \   If Padding bytes are needed but the encryption algorithm does not\n   specify\
    \ the padding contents, then the following default processing\n   MUST be used.\
    \  The Padding bytes are initialized with a series of\n   (unsigned, 1-byte) integer\
    \ values.  The first padding byte appended\n   to the plaintext is numbered 1,\
    \ with subsequent padding bytes making\n   up a monotonically increasing sequence:\
    \ 1, 2, 3, ....  When this\n   padding scheme is employed, the receiver SHOULD\
    \ inspect the Padding\n   field.  (This scheme was selected because of its relative\
    \ simplicity,\n   ease of implementation in hardware, and because it offers limited\n\
    \   protection against certain forms of \"cut and paste\" attacks in the\n   absence\
    \ of other integrity measures, if the receiver checks the\n   padding values upon\
    \ decryption.)\n   If an encryption or combined mode algorithm imposes constraints\
    \ on\n   the values of the bytes used for padding, they MUST be specified by\n\
    \   the RFC defining how the algorithm is employed with ESP.  If the\n   algorithm\
    \ requires checking of the values of the bytes used for\n   padding, this too\
    \ MUST be specified in that RFC.\n"
- title: 2.5.  Pad Length
  contents:
  - "2.5.  Pad Length\n   The Pad Length field indicates the number of pad bytes immediately\n\
    \   preceding it in the Padding field.  The range of valid values is 0 to\n  \
    \ 255, where a value of zero indicates that no Padding bytes are\n   present.\
    \  As noted above, this does not include any TFC padding\n   bytes.  The Pad Length\
    \ field is mandatory.\n"
- title: 2.6.  Next Header
  contents:
  - "2.6.  Next Header\n   The Next Header is a mandatory, 8-bit field that identifies\
    \ the type\n   of data contained in the Payload Data field, e.g., an IPv4 or IPv6\n\
    \   packet, or a next layer header and data.  The value of this field is\n   chosen\
    \ from the set of IP Protocol Numbers defined on the web page of\n   the IANA,\
    \ e.g., a value of 4 indicates IPv4, a value of 41 indicates\n   IPv6, and a value\
    \ of 6 indicates TCP.\n   To facilitate the rapid generation and discarding of\
    \ the padding\n   traffic in support of traffic flow confidentiality (see Section\
    \ 2.4),\n   the protocol value 59 (which means \"no next header\") MUST be used\
    \ to\n   designate a \"dummy\" packet.  A transmitter MUST be capable of\n   generating\
    \ dummy packets marked with this value in the next protocol\n   field, and a receiver\
    \ MUST be prepared to discard such packets,\n   without indicating an error. \
    \ All other ESP header and trailer fields\n   (SPI, Sequence Number, Padding,\
    \ Pad Length, Next Header, and ICV)\n   MUST be present in dummy packets, but\
    \ the plaintext portion of the\n   payload, other than this Next Header field,\
    \ need not be well-formed,\n   e.g., the rest of the Payload Data may consist\
    \ of only random bytes.\n   Dummy packets are discarded without prejudice.\n \
    \  Implementations SHOULD provide local management controls to enable\n   the\
    \ use of this capability on a per-SA basis.  The controls should\n   allow the\
    \ user to specify if this feature is to be used and also\n   provide parametric\
    \ controls; for example, the controls might allow an\n   administrator to generate\
    \ random-length or fixed-length dummy\n   packets.\n   DISCUSSION: Dummy packets\
    \ can be inserted at random intervals to mask\n   the absence of actual traffic.\
    \  One can also \"shape\" the actual\n   traffic to match some distribution to\
    \ which dummy traffic is added as\n   dictated by the distribution parameters.\
    \  As with the packet length\n   padding facility for Traffic Flow Security (TFS),\
    \ the most secure\n   approach would be to generate dummy packets at whatever\
    \ rate is\n   needed to maintain a constant rate on an SA.  If packets are all\
    \ the\n   same size, then the SA presents the appearance of a constant bit rate\n\
    \   data stream, analogous to what a link crypto would offer at layer 1\n   or\
    \ 2.  However, this is unlikely to be practical in many contexts,\n   e.g., when\
    \ there are multiple SAs active, because it would imply\n   reducing the allowed\
    \ bandwidth for a site, based on the number of\n   SAs, and that would undermine\
    \ the benefits of packet switching.\n   Implementations SHOULD provide controls\
    \ to enable local\n   administrators to manage the generation of dummy packets\
    \ for TFC\n   purposes.\n"
- title: 2.7.  Traffic Flow Confidentiality (TFC) Padding
  contents:
  - "2.7.  Traffic Flow Confidentiality (TFC) Padding\n   As noted above, the Padding\
    \ field is limited to 255 bytes in length.\n   This generally will not be adequate\
    \ to hide traffic characteristics\n   relative to traffic flow confidentiality\
    \ requirements.  An optional\n   field, within the payload data, is provided specifically\
    \ to address\n   the TFC requirement.\n   An IPsec implementation SHOULD be capable\
    \ of padding traffic by\n   adding bytes after the end of the Payload Data, prior\
    \ to the\n   beginning of the Padding field.  However, this padding (hereafter\n\
    \   referred to as TFC padding) can be added only if the Payload Data\n   field\
    \ contains a specification of the length of the IP datagram.\n   This is always\
    \ true in tunnel mode, and may be true in transport mode\n   depending on whether\
    \ the next layer protocol (e.g., IP, UDP, ICMP)\n   contains explicit length information.\
    \  This length information will\n   enable the receiver to discard the TFC padding,\
    \ because the true\n   length of the Payload Data will be known.  (ESP trailer\
    \ fields are\n   located by counting back from the end of the ESP packet.)\n \
    \  Accordingly, if TFC padding is added, the field containing the\n   specification\
    \ of the length of the IP datagram MUST NOT be modified\n   to reflect this padding.\
    \  No requirements for the value of this\n   padding are established by this standard.\n\
    \   In principle, existing IPsec implementations could have made use of\n   this\
    \ capability previously, in a transparent fashion.  However,\n   because receivers\
    \ may not have been prepared to deal with this\n   padding, the SA management\
    \ protocol MUST negotiate this service prior\n   to a transmitter employing it,\
    \ to ensure backward compatibility.\n   Combined with the convention described\
    \ in Section 2.6 above, about\n   the use of protocol ID 59, an ESP implementation\
    \ is capable of\n   generating dummy and real packets that exhibit much greater\
    \ length\n   variability, in support of TFC.\n   Implementations SHOULD provide\
    \ local management controls to enable\n   the use of this capability on a per-SA\
    \ basis.  The controls should\n   allow the user to specify if this feature is\
    \ to be used and also\n   provide parametric controls for the feature.\n"
- title: 2.8.  Integrity Check Value (ICV)
  contents:
  - "2.8.  Integrity Check Value (ICV)\n   The Integrity Check Value is a variable-length\
    \ field computed over\n   the ESP header, Payload, and ESP trailer fields.  Implicit\
    \ ESP\n   trailer fields (integrity padding and high-order ESN bits, if\n   applicable)\
    \ are included in the ICV computation.  The ICV field is\n   optional.  It is\
    \ present only if the integrity service is selected\n   and is provided by either\
    \ a separate integrity algorithm or a\n   combined mode algorithm that uses an\
    \ ICV.  The length of the field is\n   specified by the integrity algorithm selected\
    \ and associated with the\n   SA.  The integrity algorithm specification MUST\
    \ specify the length of\n   the ICV and the comparison rules and processing steps\
    \ for validation.\n"
- title: 3.  Encapsulating Security Protocol Processing
  contents:
  - '3.  Encapsulating Security Protocol Processing

    '
- title: 3.1.  ESP Header Location
  contents:
  - "3.1.  ESP Header Location\n   ESP may be employed in two ways: transport mode\
    \ or tunnel mode.\n"
- title: 3.1.1.  Transport Mode Processing
  contents:
  - "3.1.1.  Transport Mode Processing\n   In transport mode, ESP is inserted after\
    \ the IP header and before a\n   next layer protocol, e.g., TCP, UDP, ICMP, etc.\
    \  In the context of\n   IPv4, this translates to placing ESP after the IP header\
    \ (and any\n   options that it contains), but before the next layer protocol.\
    \  (If\n   AH is also applied to a packet, it is applied to the ESP header,\n\
    \   Payload, ESP trailer, and ICV, if present.)  (Note that the term\n   \"transport\"\
    \ mode should not be misconstrued as restricting its use to\n   TCP and UDP.)\
    \  The following diagram illustrates ESP transport mode\n   positioning for a\
    \ typical IPv4 packet, on a \"before and after\" basis.\n   (This and subsequent\
    \ diagrams in this section show the ICV field, the\n   presence of which is a\
    \ function of the security services and the\n   algorithm/mode selected.)\n  \
    \                BEFORE APPLYING ESP\n             ----------------------------\n\
    \       IPv4  |orig IP hdr  |     |      |\n             |(any options)| TCP |\
    \ Data |\n             ----------------------------\n                  AFTER APPLYING\
    \ ESP\n             -------------------------------------------------\n      \
    \ IPv4  |orig IP hdr  | ESP |     |      |   ESP   | ESP|\n             |(any\
    \ options)| Hdr | TCP | Data | Trailer | ICV|\n             -------------------------------------------------\n\
    \                                 |<---- encryption ---->|\n                 \
    \          |<-------- integrity ------->|\n   In the IPv6 context, ESP is viewed\
    \ as an end-to-end payload, and thus\n   should appear after hop-by-hop, routing,\
    \ and fragmentation extension\n   headers.  Destination options extension header(s)\
    \ could appear\n   before, after, or both before and after the ESP header depending\
    \ on\n   the semantics desired.  However, because ESP protects only fields\n \
    \  after the ESP header, it generally will be desirable to place the\n   destination\
    \ options header(s) after the ESP header.  The following\n   diagram illustrates\
    \ ESP transport mode positioning for a typical IPv6\n   packet.\n            \
    \          BEFORE APPLYING ESP\n             ---------------------------------------\n\
    \       IPv6  |             | ext hdrs |     |      |\n             | orig IP\
    \ hdr |if present| TCP | Data |\n             ---------------------------------------\n\
    \                      AFTER APPLYING ESP\n             ---------------------------------------------------------\n\
    \       IPv6  | orig |hop-by-hop,dest*,|   |dest|   |    | ESP   | ESP|\n    \
    \         |IP hdr|routing,fragment.|ESP|opt*|TCP|Data|Trailer| ICV|\n        \
    \     ---------------------------------------------------------\n            \
    \                              |<--- encryption ---->|\n                     \
    \                 |<------ integrity ------>|\n                 * = if present,\
    \ could be before ESP, after ESP, or both\n   Note that in transport mode, for\
    \ \"bump-in-the-stack\" or \"bump-in-\n   the-wire\" implementations, as defined\
    \ in the Security Architecture\n   document, inbound and outbound IP fragments\
    \ may require an IPsec\n   implementation to perform extra IP reassembly/fragmentation\
    \ in order\n   to both conform to this specification and provide transparent IPsec\n\
    \   support.  Special care is required to perform such operations within\n   these\
    \ implementations when multiple interfaces are in use.\n"
- title: 3.1.2.  Tunnel Mode Processing
  contents:
  - "3.1.2.  Tunnel Mode Processing\n   In tunnel mode, the \"inner\" IP header carries\
    \ the ultimate (IP)\n   source and destination addresses, while an \"outer\" IP\
    \ header contains\n   the addresses of the IPsec \"peers\", e.g., addresses of\
    \ security\n   gateways.  Mixed inner and outer IP versions are allowed, i.e.,\
    \ IPv6\n   over IPv4 and IPv4 over IPv6.  In tunnel mode, ESP protects the\n \
    \  entire inner IP packet, including the entire inner IP header.  The\n   position\
    \ of ESP in tunnel mode, relative to the outer IP header, is\n   the same as for\
    \ ESP in transport mode.  The following diagram\n   illustrates ESP tunnel mode\
    \ positioning for typical IPv4 and IPv6\n   packets.\n                 BEFORE\
    \ APPLYING ESP\n            ----------------------------\n      IPv4  |orig IP\
    \ hdr  |     |      |\n            |(any options)| TCP | Data |\n            ----------------------------\n\
    \                 AFTER APPLYING ESP\n            -----------------------------------------------------------\n\
    \      IPv4  | new IP hdr* |     | orig IP hdr*  |   |    | ESP   | ESP|\n   \
    \         |(any options)| ESP | (any options) |TCP|Data|Trailer| ICV|\n      \
    \      -----------------------------------------------------------\n         \
    \                       |<--------- encryption --------->|\n                 \
    \         |<------------- integrity ------------>|\n                      BEFORE\
    \ APPLYING ESP\n            ---------------------------------------\n      IPv6\
    \  |             | ext hdrs |     |      |\n            | orig IP hdr |if present|\
    \ TCP | Data |\n            ---------------------------------------\n        \
    \             AFTER APPLYING ESP\n            ------------------------------------------------------------\n\
    \      IPv6  | new* |new ext |   | orig*|orig ext |   |    | ESP   | ESP|\n  \
    \          |IP hdr| hdrs*  |ESP|IP hdr| hdrs *  |TCP|Data|Trailer| ICV|\n    \
    \        ------------------------------------------------------------\n      \
    \                          |<--------- encryption ---------->|\n             \
    \               |<------------ integrity ------------>|\n            * = if present,\
    \ construction of outer IP hdr/extensions and\n                modification of\
    \ inner IP hdr/extensions is discussed in\n                the Security Architecture\
    \ document.\n"
- title: 3.2.  Algorithms
  contents:
  - "3.2.  Algorithms\n   The mandatory-to-implement algorithms for use with ESP are\
    \ described\n   in a separate RFC, to facilitate updating the algorithm requirements\n\
    \   independently from the protocol per se.  Additional algorithms,\n   beyond\
    \ those mandated for ESP, MAY be supported.  Note that although\n   both confidentiality\
    \ and integrity are optional, at least one of\n   these services MUST be selected,\
    \ hence both algorithms MUST NOT be\n   simultaneously NULL.\n"
- title: 3.2.1.  Encryption Algorithms
  contents:
  - "3.2.1.  Encryption Algorithms\n   The encryption algorithm employed to protect\
    \ an ESP packet is\n   specified by the SA via which the packet is transmitted/received.\n\
    \   Because IP packets may arrive out of order, and not all packets may\n   arrive\
    \ (packet loss), each packet must carry any data required to\n   allow the receiver\
    \ to establish cryptographic synchronization for\n   decryption.  This data may\
    \ be carried explicitly in the payload\n   field, e.g., as an IV (as described\
    \ above), or the data may be\n   derived from the plaintext portions of the (outer\
    \ IP or ESP) packet\n   header.  (Note that if plaintext header information is\
    \ used to derive\n   an IV, that information may become security critical and\
    \ thus the\n   protection boundary associated with the encryption process may\
    \ grow.\n   For example, if one were to use the ESP Sequence Number to derive\
    \ an\n   IV, the Sequence Number generation logic (hardware or software) would\n\
    \   have to be evaluated as part of the encryption algorithm\n   implementation.\
    \  In the case of FIPS 140-2 [NIST01], this could\n   significantly extend the\
    \ scope of a cryptographic module evaluation.)\n   Because ESP makes provision\
    \ for padding of the plaintext, encryption\n   algorithms employed with ESP may\
    \ exhibit either block or stream mode\n   characteristics.  Note that because\
    \ encryption (confidentiality) MAY\n   be an optional service (e.g., integrity-only\
    \ ESP), this algorithm MAY\n   be \"NULL\" [Ken-Arch].\n   To allow an ESP implementation\
    \ to compute the encryption padding\n   required by a block mode encryption algorithm,\
    \ and to determine the\n   MTU impact of the algorithm, the RFC for each encryption\
    \ algorithm\n   used with ESP must specify the padding modulus for the algorithm.\n"
- title: 3.2.2.  Integrity Algorithms
  contents:
  - "3.2.2.  Integrity Algorithms\n   The integrity algorithm employed for the ICV\
    \ computation is specified\n   by the SA via which the packet is transmitted/received.\
    \  As was the\n   case for encryption algorithms, any integrity algorithm employed\
    \ with\n   ESP must make provisions to permit processing of packets that arrive\n\
    \   out of order and to accommodate packet loss.  The same admonition\n   noted\
    \ above applies to use of any plaintext data to facilitate\n   receiver synchronization\
    \ of integrity algorithms.  Note that because\n   the integrity service MAY be\
    \ optional, this algorithm may be \"NULL\".\n   To allow an ESP implementation\
    \ to compute any implicit integrity\n   algorithm padding required, the RFC for\
    \ each algorithm used with ESP\n   must specify the padding modulus for the algorithm.\n"
- title: 3.2.3.  Combined Mode Algorithms
  contents:
  - "3.2.3.  Combined Mode Algorithms\n   If a combined mode algorithm is employed,\
    \ both confidentiality and\n   integrity services are provided.  As was the case\
    \ for encryption\n   algorithms, a combined mode algorithm must make provisions\
    \ for per-\n   packet cryptographic synchronization, to permit decryption of packets\n\
    \   that arrive out of order and to accommodate packet loss.  The means\n   by\
    \ which a combined mode algorithm provides integrity for the\n   payload, and\
    \ for the SPI and (Extended) Sequence Number fields, may\n   vary for different\
    \ algorithm choices.  In order to provide a uniform,\n   algorithm-independent\
    \ approach to invocation of combined mode\n   algorithms, no payload substructure\
    \ is defined.  For example, the SPI\n   and Sequence Number fields might be replicated\
    \ within the ciphertext\n   envelope and an ICV may be appended to the ESP trailer.\
    \  None of\n   these details should be observable externally.\n   To allow an\
    \ ESP implementation to determine the MTU impact of a\n   combined mode algorithm,\
    \ the RFC for each algorithm used with ESP\n   must specify a (simple) formula\
    \ that yields encrypted payload size,\n   as a function of the plaintext payload\
    \ and sequence number sizes.\n"
- title: 3.3.  Outbound Packet Processing
  contents:
  - "3.3.  Outbound Packet Processing\n   In transport mode, the sender encapsulates\
    \ the next layer protocol\n   information between the ESP header and the ESP trailer\
    \ fields, and\n   retains the specified IP header (and any IP extension headers\
    \ in the\n   IPv6 context).  In tunnel mode, the outer and inner IP\n   header/extensions\
    \ can be interrelated in a variety of ways.  The\n   construction of the outer\
    \ IP header/extensions during the\n   encapsulation process is described in the\
    \ Security Architecture\n   document.\n"
- title: 3.3.1.  Security Association Lookup
  contents:
  - "3.3.1.  Security Association Lookup\n   ESP is applied to an outbound packet\
    \ only after an IPsec\n   implementation determines that the packet is associated\
    \ with an SA\n   that calls for ESP processing.  The process of determining what,\
    \ if\n   any, IPsec processing is applied to outbound traffic is described in\n\
    \   the Security Architecture document.\n"
- title: 3.3.2.  Packet Encryption and Integrity Check Value (ICV) Calculation
  contents:
  - "3.3.2.  Packet Encryption and Integrity Check Value (ICV) Calculation\n   In\
    \ this section, we speak in terms of encryption always being applied\n   because\
    \ of the formatting implications.  This is done with the\n   understanding that\
    \ \"no confidentiality\" is offered by using the NULL\n   encryption algorithm\
    \ (RFC 2410).  There are several algorithmic\n   options.\n"
- title: 3.3.2.1.  Separate Confidentiality and Integrity Algorithms
  contents:
  - "3.3.2.1.  Separate Confidentiality and Integrity Algorithms\n   If separate confidentiality\
    \ and integrity algorithms are employed,\n   the Sender proceeds as follows:\n\
    \         1. Encapsulate (into the ESP Payload field):\n                 - for\
    \ transport mode -- just the original next layer\n                   protocol\
    \ information.\n                 - for tunnel mode -- the entire original IP datagram.\n\
    \         2. Add any necessary padding -- Optional TFC padding and\n         \
    \   (encryption) Padding\n         3. Encrypt the result using the key, encryption\
    \ algorithm,\n            and algorithm mode specified for the SA and using any\n\
    \            required cryptographic synchronization data.\n                 -\
    \ If explicit cryptographic synchronization data,\n                   e.g., an\
    \ IV, is indicated, it is input to the\n                   encryption algorithm\
    \ per the algorithm specification\n                   and placed in the Payload\
    \ field.\n                 - If implicit cryptographic synchronization data is\n\
    \                   employed, it is constructed and input to the\n           \
    \        encryption algorithm as per the algorithm\n                   specification.\n\
    \                 - If integrity is selected, encryption is performed\n      \
    \             first, before the integrity algorithm is applied, and\n        \
    \           the encryption does not encompass the ICV field.\n               \
    \    This order of processing facilitates rapid detection\n                  \
    \ and rejection of replayed or bogus packets by the\n                   receiver,\
    \ prior to decrypting the packet, hence\n                   potentially reducing\
    \ the impact of denial of service\n                   (DoS) attacks.  It also\
    \ allows for the possibility of\n                   parallel processing of packets\
    \ at the receiver, i.e.,\n                   decryption can take place in parallel\
    \ with integrity\n                   checking.  Note that because the ICV is not\
    \ protected\n                   by encryption, a keyed integrity algorithm must\
    \ be\n                   employed to compute the ICV.\n         4. Compute the\
    \ ICV over the ESP packet minus the ICV field.\n            Thus, the ICV computation\
    \ encompasses the SPI, Sequence\n            Number, Payload Data, Padding (if\
    \ present), Pad Length, and\n            Next Header.  (Note that the last 4 fields\
    \ will be in\n            ciphertext form, because encryption is performed first.)\
    \  If\n            the ESN option is enabled for the SA, the high-order 32\n \
    \           bits of the sequence number are appended after the Next\n        \
    \    Header field for purposes of this computation, but are not\n            transmitted.\n\
    \   For some integrity algorithms, the byte string over which the ICV\n   computation\
    \ is performed must be a multiple of a block size specified\n   by the algorithm.\
    \  If the length of ESP packet (as described above)\n   does not match the block\
    \ size requirements for the algorithm,\n   implicit padding MUST be appended to\
    \ the end of the ESP packet.\n   (This padding is added after the Next Header\
    \ field, or after the\n   high-order 32 bits of the sequence number, if ESN is\
    \ selected.)  The\n   block size (and hence the length of the padding) is specified\
    \ by the\n   integrity algorithm specification.  This padding is not transmitted\n\
    \   with the packet.  The document that defines an integrity algorithm\n   MUST\
    \ be consulted to determine if implicit padding is required as\n   described above.\
    \  If the document does not specify an answer to this\n   question, then the default\
    \ is to assume that implicit padding is\n   required (as needed to match the packet\
    \ length to the algorithm's\n   block size.)  If padding bytes are needed but\
    \ the algorithm does not\n   specify the padding contents, then the padding octets\
    \ MUST have a\n   value of zero.\n"
- title: 3.3.2.2.  Combined Confidentiality and Integrity Algorithms
  contents:
  - "3.3.2.2.  Combined Confidentiality and Integrity Algorithms\n   If a combined\
    \ confidentiality/integrity algorithm is employed, the\n   Sender proceeds as\
    \ follows:\n         1. Encapsulate into the ESP Payload Data field:\n       \
    \          - for transport mode -- just the original next layer\n            \
    \       protocol information.\n                 - for tunnel mode -- the entire\
    \ original IP datagram.\n         2. Add any necessary padding -- includes optional\
    \ TFC padding\n            and (encryption) Padding.\n         3. Encrypt and\
    \ integrity protect the result using the key\n            and combined mode algorithm\
    \ specified for the SA and using\n            any required cryptographic synchronization\
    \ data.\n                 - If explicit cryptographic synchronization data,\n\
    \                   e.g., an IV, is indicated, it is input to the\n          \
    \         combined mode algorithm per the algorithm\n                   specification\
    \ and placed in the Payload field.\n                 - If implicit cryptographic\
    \ synchronization data is\n                   employed, it is constructed and\
    \ input to the\n                   encryption algorithm as per the algorithm\n\
    \                   specification.\n                 - The Sequence Number (or\
    \ Extended Sequence Number, as\n                   appropriate) and the SPI are\
    \ inputs to the\n                   algorithm, as they must be included in the\
    \ integrity\n                   check computation.  The means by which these values\n\
    \                   are included in this computation are a function of\n     \
    \              the combined mode algorithm employed and thus not\n           \
    \        specified in this standard.\n                 - The (explicit) ICV field\
    \ MAY be a part of the ESP\n                   packet format when a combined mode\
    \ algorithm is\n                   employed.  If one is not used, an analogous\
    \ field\n                   usually will be a part of the ciphertext payload.\n\
    \                   The location of any integrity fields, and the means\n    \
    \               by which the Sequence Number and SPI are included in\n       \
    \            the integrity computation, MUST be defined in an RFC\n          \
    \         that defines the use of the combined mode algorithm\n              \
    \     with ESP.\n"
- title: 3.3.3.  Sequence Number Generation
  contents:
  - "3.3.3.  Sequence Number Generation\n   The sender's counter is initialized to\
    \ 0 when an SA is established.\n   The sender increments the sequence number (or\
    \ ESN) counter for this\n   SA and inserts the low-order 32 bits of the value\
    \ into the Sequence\n   Number field.  Thus, the first packet sent using a given\
    \ SA will\n   contain a sequence number of 1.\n   If anti-replay is enabled (the\
    \ default), the sender checks to ensure\n   that the counter has not cycled before\
    \ inserting the new value in the\n   Sequence Number field.  In other words, the\
    \ sender MUST NOT send a\n   packet on an SA if doing so would cause the sequence\
    \ number to cycle.\n   An attempt to transmit a packet that would result in sequence\
    \ number\n   overflow is an auditable event.  The audit log entry for this event\n\
    \   SHOULD include the SPI value, current date/time, Source Address,\n   Destination\
    \ Address, and (in IPv6) the cleartext Flow ID.\n   The sender assumes anti-replay\
    \ is enabled as a default, unless\n   otherwise notified by the receiver (see\
    \ Section 3.4.3).  Thus,\n   typical behavior of an ESP implementation calls for\
    \ the sender to\n   establish a new SA when the Sequence Number (or ESN) cycles,\
    \ or in\n   anticipation of this value cycling.\n   If the key used to compute\
    \ an ICV is manually distributed, a\n   compliant implementation SHOULD NOT provide\
    \ anti-replay service.  If\n   a user chooses to employ anti-replay in conjunction\
    \ with SAs that are\n   manually keyed, the sequence number counter at the sender\
    \ MUST be\n   correctly maintained across local reboots, etc., until the key is\n\
    \   replaced.  (See Section 5.)\n   If anti-replay is disabled (as noted above),\
    \ the sender does not need\n   to monitor or reset the counter.  However, the\
    \ sender still\n   increments the counter and when it reaches the maximum value,\
    \ the\n   counter rolls over back to zero.  (This behavior is recommended for\n\
    \   multi-sender, multicast SAs, unless anti-replay mechanisms outside\n   the\
    \ scope of this standard are negotiated between the sender and\n   receiver.)\n\
    \   If ESN (see Appendix) is selected, only the low-order 32 bits of the\n   sequence\
    \ number are transmitted in the Sequence Number field,\n   although both sender\
    \ and receiver maintain full 64-bit ESN counters.\n   The high order 32 bits are\
    \ included in the integrity check in an\n   algorithm/mode-specific fashion, e.g.,\
    \ the high-order 32 bits may be\n   appended after the Next Header field when\
    \ a separate integrity\n   algorithm is employed.\n   Note: If a receiver chooses\
    \ to not enable anti-replay for an SA, then\n   the receiver SHOULD NOT negotiate\
    \ ESN in an SA management protocol.\n   Use of ESN creates a need for the receiver\
    \ to manage the anti-replay\n   window (in order to determine the correct value\
    \ for the high-order\n   bits of the ESN, which are employed in the ICV computation),\
    \ which is\n   generally contrary to the notion of disabling anti-replay for an\
    \ SA.\n"
- title: 3.3.4.  Fragmentation
  contents:
  - "3.3.4.  Fragmentation\n   If necessary, fragmentation is performed after ESP\
    \ processing within\n   an IPsec implementation.  Thus, transport mode ESP is\
    \ applied only to\n   whole IP datagrams (not to IP fragments).  An IP packet\
    \ to which ESP\n   has been applied may itself be fragmented by routers en route,\
    \ and\n   such fragments must be reassembled prior to ESP processing at a\n  \
    \ receiver.  In tunnel mode, ESP is applied to an IP packet, which may\n   be\
    \ a fragment of an IP datagram.  For example, a security gateway or\n   a \"bump-in-the-stack\"\
    \ or \"bump-in-the-wire\" IPsec implementation (as\n   defined in the Security\
    \ Architecture document) may apply tunnel mode\n   ESP to such fragments.\n  \
    \ NOTE: For transport mode -- As mentioned at the end of Section 3.1.1,\n   bump-in-the-stack\
    \ and bump-in-the-wire implementations may have to\n   first reassemble a packet\
    \ fragmented by the local IP layer, then\n   apply IPsec, and then fragment the\
    \ resulting packet.\n   NOTE: For IPv6 -- For bump-in-the-stack and bump-in-the-wire\n\
    \   implementations, it will be necessary to examine all the extension\n   headers\
    \ to determine if there is a fragmentation header and hence\n   that the packet\
    \ needs reassembling prior to IPsec processing.\n   Fragmentation, whether performed\
    \ by an IPsec implementation or by\n   routers along the path between IPsec peers,\
    \ significantly reduces\n   performance.  Moreover, the requirement for an ESP\
    \ receiver to accept\n   fragments for reassembly creates denial of service vulnerabilities.\n\
    \   Thus, an ESP implementation MAY choose to not support fragmentation\n   and\
    \ may mark transmitted packets with the DF bit, to facilitate Path\n   MTU (PMTU)\
    \ discovery.  In any case, an ESP implementation MUST\n   support generation of\
    \ ICMP PMTU messages (or equivalent internal\n   signaling for native host implementations)\
    \ to minimize the likelihood\n   of fragmentation.  Details of the support required\
    \ for MTU management\n   are contained in the Security Architecture document.\n"
- title: 3.4.  Inbound Packet Processing
  contents:
  - '3.4.  Inbound Packet Processing

    '
- title: 3.4.1.  Reassembly
  contents:
  - "3.4.1.  Reassembly\n   If required, reassembly is performed prior to ESP processing.\
    \  If a\n   packet offered to ESP for processing appears to be an IP fragment,\n\
    \   i.e., the OFFSET field is non-zero or the MORE FRAGMENTS flag is set,\n  \
    \ the receiver MUST discard the packet; this is an auditable event.\n   The audit\
    \ log entry for this event SHOULD include the SPI value,\n   date/time received,\
    \ Source Address, Destination Address, Sequence\n   Number, and (in IPv6) the\
    \ Flow ID.\n   NOTE: For packet reassembly, the current IPv4 spec does NOT require\n\
    \   either the zeroing of the OFFSET field or the clearing of the MORE\n   FRAGMENTS\
    \ flag.  In order for a reassembled packet to be processed by\n   IPsec (as opposed\
    \ to discarded as an apparent fragment), the IP code\n   must do these two things\
    \ after it reassembles a packet.\n"
- title: 3.4.2.  Security Association Lookup
  contents:
  - "3.4.2.  Security Association Lookup\n   Upon receipt of a packet containing an\
    \ ESP Header, the receiver\n   determines the appropriate (unidirectional) SA\
    \ via lookup in the SAD.\n   For a unicast SA, this determination is based on\
    \ the SPI or the SPI\n   plus protocol field, as described in Section 2.1.  If\
    \ an\n   implementation supports multicast traffic, the destination address is\n\
    \   also employed in the lookup (in addition to the SPI), and the sender\n   address\
    \ also may be employed, as described in Section 2.1.  (This\n   process is described\
    \ in more detail in the Security Architecture\n   document.)  The SAD entry for\
    \ the SA also indicates whether the\n   Sequence Number field will be checked,\
    \ whether 32- or 64-bit sequence\n   numbers are employed for the SA, and whether\
    \ the (explicit) ICV field\n   should be present (and if so, its size).  Also,\
    \ the SAD entry will\n   specify the algorithms and keys to be employed for decryption\
    \ and ICV\n   computation (if applicable).\n   If no valid Security Association\
    \ exists for this packet, the receiver\n   MUST discard the packet; this is an\
    \ auditable event.  The audit log\n   entry for this event SHOULD include the\
    \ SPI value, date/time\n   received, Source Address, Destination Address, Sequence\
    \ Number, and\n   (in IPv6) the cleartext Flow ID.\n   (Note that SA management\
    \ traffic, such as IKE packets, does not need\n   to be processed based on SPI,\
    \ i.e., one can demultiplex this traffic\n   separately based on Next Protocol\
    \ and Port fields, for example.)\n"
- title: 3.4.3.  Sequence Number Verification
  contents:
  - "3.4.3.  Sequence Number Verification\n   All ESP implementations MUST support\
    \ the anti-replay service, though\n   its use may be enabled or disabled by the\
    \ receiver on a per-SA basis.\n   This service MUST NOT be enabled unless the\
    \ ESP integrity service\n   also is enabled for the SA, because otherwise the\
    \ Sequence Number\n   field has not been integrity protected.  Anti-replay is\
    \ applicable to\n   unicast as well as multicast SAs.  However, this standard\
    \ specifies\n   no mechanisms for providing anti-replay for a multi-sender SA\n\
    \   (unicast or multicast).  In the absence of negotiation (or manual\n   configuration)\
    \ of an anti-replay mechanism for such an SA, it is\n   recommended that sender\
    \ and receiver checking of the sequence number\n   for the SA be disabled (via\
    \ negotiation or manual configuration), as\n   noted below.\n   If the receiver\
    \ does not enable anti-replay for an SA, no inbound\n   checks are performed on\
    \ the Sequence Number.  However, from the\n   perspective of the sender, the default\
    \ is to assume that anti-replay\n   is enabled at the receiver.  To avoid having\
    \ the sender do\n   unnecessary sequence number monitoring and SA setup (see section\n\
    \   3.3.3), if an SA establishment protocol is employed, the receiver\n   SHOULD\
    \ notify the sender, during SA establishment, if the receiver\n   will not provide\
    \ anti-replay protection.\n   If the receiver has enabled the anti-replay service\
    \ for this SA, the\n   receive packet counter for the SA MUST be initialized to\
    \ zero when\n   the SA is established.  For each received packet, the receiver\
    \ MUST\n   verify that the packet contains a Sequence Number that does not\n \
    \  duplicate the Sequence Number of any other packets received during\n   the\
    \ life of this SA.  This SHOULD be the first ESP check applied to a\n   packet\
    \ after it has been matched to an SA, to speed rejection of\n   duplicate packets.\n\
    \   ESP permits two-stage verification of packet sequence numbers.  This\n   capability\
    \ is important whenever an ESP implementation (typically the\n   cryptographic\
    \ module portion thereof) is not capable of performing\n   decryption and/or integrity\
    \ checking at the same rate as the\n   interface(s) to unprotected networks. \
    \ If the implementation is\n   capable of such \"line rate\" operation, then it\
    \ is not necessary to\n   perform the preliminary verification stage described\
    \ below.\n   The preliminary Sequence Number check is effected utilizing the\n\
    \   Sequence Number value in the ESP Header and is performed prior to\n   integrity\
    \ checking and decryption.  If this preliminary check fails,\n   the packet is\
    \ discarded, thus avoiding the need for any cryptographic\n   operations by the\
    \ receiver.  If the preliminary check is successful,\n   the receiver cannot yet\
    \ modify its local counter, because the\n   integrity of the Sequence Number has\
    \ not been verified at this point.\n   Duplicates are rejected through the use\
    \ of a sliding receive window.\n   How the window is implemented is a local matter,\
    \ but the following\n   text describes the functionality that the implementation\
    \ must\n   exhibit.\n   The \"right\" edge of the window represents the highest,\
    \ validated\n   Sequence Number value received on this SA.  Packets that contain\n\
    \   sequence numbers lower than the \"left\" edge of the window are\n   rejected.\
    \  Packets falling within the window are checked against a\n   list of received\
    \ packets within the window.  If the ESN option is\n   selected for an SA, only\
    \ the low-order 32 bits of the sequence number\n   are explicitly transmitted,\
    \ but the receiver employs the full\n   sequence number computed using the high-order\
    \ 32 bits for the\n   indicated SA (from his local counter) when checking the\
    \ received\n   Sequence Number against the receive window.  In constructing the\
    \ full\n   sequence number, if the low-order 32 bits carried in the packet are\n\
    \   lower in value than the low-order 32 bits of the receiver's sequence\n   number,\
    \ the receiver assumes that the high-order 32 bits have been\n   incremented,\
    \ moving to a new sequence number subspace.  (This\n   algorithm accommodates\
    \ gaps in reception for a single SA as large as\n   2**32-1 packets.  If a larger\
    \ gap occurs, additional, heuristic\n   checks for re-synchronization of the receiver\
    \ sequence number counter\n   MAY be employed, as described in the Appendix.)\n\
    \   If the received packet falls within the window and is not a\n   duplicate,\
    \ or if the packet is to the right of the window, and if a\n   separate integrity\
    \ algorithm is employed, then the receiver proceeds\n   to integrity verification.\
    \  If a combined mode algorithm is employed,\n   the integrity check is performed\
    \ along with decryption.  In either\n   case, if the integrity check fails, the\
    \ receiver MUST discard the\n   received IP datagram as invalid; this is an auditable\
    \ event.  The\n   audit log entry for this event SHOULD include the SPI value,\n\
    \   date/time received, Source Address, Destination Address, the Sequence\n  \
    \ Number, and (in IPv6) the Flow ID.  The receive window is updated\n   only if\
    \ the integrity verification succeeds.  (If a combined mode\n   algorithm is being\
    \ used, then the integrity protected Sequence Number\n   must also match the Sequence\
    \ Number used for anti-replay protection.)\n   A minimum window size of 32 packets\
    \ MUST be supported when 32-bit\n   sequence numbers are employed; a window size\
    \ of 64 is preferred and\n   SHOULD be employed as the default.  Another window\
    \ size (larger than\n   the minimum) MAY be chosen by the receiver.  (The receiver\
    \ does NOT\n   notify the sender of the window size.)  The receive window size\n\
    \   should be increased for higher-speed environments, irrespective of\n   assurance\
    \ issues.  Values for minimum and recommended receive window\n   sizes for very\
    \ high-speed (e.g., multi-gigabit/second) devices are\n   not specified by this\
    \ standard.\n"
- title: 3.4.4.  Integrity Check Value Verification
  contents:
  - "3.4.4.  Integrity Check Value Verification\n   As with outbound processing, there\
    \ are several options for inbound\n   processing, based on features of the algorithms\
    \ employed.\n"
- title: 3.4.4.1.  Separate Confidentiality and Integrity Algorithms
  contents:
  - "3.4.4.1.  Separate Confidentiality and Integrity Algorithms\n   If separate confidentiality\
    \ and integrity algorithms are employed\n   processing proceeds as follows:\n\
    \         1. If integrity has been selected, the receiver computes the\n     \
    \       ICV over the ESP packet minus the ICV, using the specified\n         \
    \   integrity algorithm and verifies that it is the same as the\n            ICV\
    \ carried in the packet.  Details of the computation are\n            provided\
    \ below.\n            If the computed and received ICVs match, then the datagram\n\
    \            is valid, and it is accepted.  If the test fails, then the\n    \
    \        receiver MUST discard the received IP datagram as invalid;\n        \
    \    this is an auditable event.  The log data SHOULD include the\n          \
    \  SPI value, date/time received, Source Address, Destination\n            Address,\
    \ the Sequence Number, and (for IPv6) the cleartext\n            Flow ID.\n  \
    \          Implementation Note:\n            Implementations can use any set of\
    \ steps that results in the\n            same result as the following set of steps.\
    \  Begin by\n            removing and saving the ICV field.  Next check the overall\n\
    \            length of the ESP packet minus the ICV field.  If implicit\n    \
    \        padding is required, based on the block size of the\n            integrity\
    \ algorithm, append zero-filled bytes to the end of\n            the ESP packet\
    \ directly after the Next Header field, or\n            after the high-order 32\
    \ bits of the sequence number if ESN\n            is selected.  Perform the ICV\
    \ computation and compare the\n            result with the saved value, using\
    \ the comparison rules\n            defined by the algorithm specification.\n\
    \         2. The receiver decrypts the ESP Payload Data, Padding, Pad\n      \
    \      Length, and Next Header using the key, encryption algorithm,\n        \
    \    algorithm mode, and cryptographic synchronization data (if\n            any),\
    \ indicated by the SA.  As in Section 3.3.2, we speak\n            here in terms\
    \ of encryption always being applied because of\n            the formatting implications.\
    \  This is done with the\n            understanding that \"no confidentiality\"\
    \ is offered by using\n            the NULL encryption algorithm (RFC 2410).\n\
    \                 - If explicit cryptographic synchronization data, e.g.,\n  \
    \                 an IV, is indicated, it is taken from the Payload\n        \
    \           field and input to the decryption algorithm as per\n             \
    \      the algorithm specification.\n                 - If implicit cryptographic\
    \ synchronization data is\n                   indicated, a local version of the\
    \ IV is constructed\n                   and input to the decryption algorithm\
    \ as per the\n                   algorithm specification.\n         3. The receiver\
    \ processes any Padding as specified in the\n            encryption algorithm\
    \ specification.  If the default padding\n            scheme (see Section 2.4)\
    \ has been employed, the receiver\n            SHOULD inspect the Padding field\
    \ before removing the padding\n            prior to passing the decrypted data\
    \ to the next layer.\n         4. The receiver checks the Next Header field. \
    \ If the value is\n            \"59\" (no next header), the (dummy) packet is\
    \ discarded\n            without further processing.\n         5. The receiver\
    \ reconstructs the original IP datagram from:\n                 - for transport\
    \ mode -- outer IP header plus the\n                   original next layer protocol\
    \ information in the ESP\n                   Payload field\n                 -\
    \ for tunnel mode -- the entire IP datagram in the ESP\n                   Payload\
    \ field.\n            The exact steps for reconstructing the original datagram\n\
    \            depend on the mode (transport or tunnel) and are described\n    \
    \        in the Security Architecture document.  At a minimum, in an\n       \
    \     IPv6 context, the receiver SHOULD ensure that the decrypted\n          \
    \  data is 8-byte aligned, to facilitate processing by the\n            protocol\
    \ identified in the Next Header field.  This\n            processing \"discards\"\
    \ any (optional) TFC padding that has\n            been added for traffic flow\
    \ confidentiality.  (If present,\n            this will have been inserted after\
    \ the IP datagram (or\n            transport-layer frame) and before the Padding\
    \ field (see\n            Section 2.4).)\n   If integrity checking and encryption\
    \ are performed in parallel,\n   integrity checking MUST be completed before the\
    \ decrypted packet is\n   passed on for further processing.  This order of processing\n\
    \   facilitates rapid detection and rejection of replayed or bogus\n   packets\
    \ by the receiver, prior to decrypting the packet, hence\n   potentially reducing\
    \ the impact of denial of service attacks.\n   Note: If the receiver performs\
    \ decryption in parallel with integrity\n   checking, care must be taken to avoid\
    \ possible race conditions with\n   regard to packet access and extraction of\
    \ the decrypted packet.\n"
- title: 3.4.4.2.  Combined Confidentiality and Integrity Algorithms
  contents:
  - "3.4.4.2.  Combined Confidentiality and Integrity Algorithms\n   If a combined\
    \ confidentiality and integrity algorithm is employed,\n   then the receiver proceeds\
    \ as follows:\n         1. Decrypts and integrity checks the ESP Payload Data,\
    \ Padding,\n            Pad Length, and Next Header, using the key, algorithm,\n\
    \            algorithm mode, and cryptographic synchronization data (if\n    \
    \        any), indicated by the SA.  The SPI from the ESP header, and\n      \
    \      the (receiver) packet counter value (adjusted as required\n           \
    \ from the processing described in Section 3.4.3) are inputs\n            to this\
    \ algorithm, as they are required for the integrity\n            check.\n    \
    \             - If explicit cryptographic synchronization data, e.g.,\n      \
    \             an IV, is indicated, it is taken from the Payload\n            \
    \       field and input to the decryption algorithm as per\n                 \
    \  the algorithm specification.\n                 - If implicit cryptographic\
    \ synchronization data, e.g.,\n                   an IV, is indicated, a local\
    \ version of the IV is\n                   constructed and input to the decryption\
    \ algorithm as\n                   per the algorithm specification.\n        \
    \ 2. If the integrity check performed by the combined mode\n            algorithm\
    \ fails, the receiver MUST discard the received IP\n            datagram as invalid;\
    \ this is an auditable event.  The log\n            data SHOULD include the SPI\
    \ value, date/time received,\n            Source Address, Destination Address,\
    \ the Sequence Number,\n            and (in IPv6) the cleartext Flow ID.\n   \
    \      3. Process any Padding as specified in the encryption algorithm\n     \
    \       specification, if the algorithm has not already done so.\n         4.\
    \ The receiver checks the Next Header field.  If the value is\n            \"\
    59\" (no next header), the (dummy) packet is discarded\n            without further\
    \ processing.\n         5. Extract the original IP datagram (tunnel mode) or\n\
    \            transport-layer frame (transport mode) from the ESP Payload\n   \
    \         Data field.  This implicitly discards any (optional) padding\n     \
    \       that has been added for traffic flow confidentiality.  (If\n         \
    \   present, the TFC padding will have been inserted after the\n            IP\
    \ payload and before the Padding field (see Section 2.4).)\n"
- title: 4.  Auditing
  contents:
  - "4.  Auditing\n   Not all systems that implement ESP will implement auditing.\
    \  However,\n   if ESP is incorporated into a system that supports auditing, then\
    \ the\n   ESP implementation MUST also support auditing and MUST allow a system\n\
    \   administrator to enable or disable auditing for ESP.  For the most\n   part,\
    \ the granularity of auditing is a local matter.  However,\n   several auditable\
    \ events are identified in this specification and for\n   each of these events\
    \ a minimum set of information that SHOULD be\n   included in an audit log is\
    \ defined.\n         - No valid Security Association exists for a session.  The\n\
    \           audit log entry for this event SHOULD include the SPI value,\n   \
    \        date/time received, Source Address, Destination Address,\n          \
    \ Sequence Number, and (for IPv6) the cleartext Flow ID.\n         - A packet\
    \ offered to ESP for processing appears to be an IP\n           fragment, i.e.,\
    \ the OFFSET field is non-zero or the MORE\n           FRAGMENTS flag is set.\
    \  The audit log entry for this event\n           SHOULD include the SPI value,\
    \ date/time received, Source\n           Address, Destination Address, Sequence\
    \ Number, and (in IPv6)\n           the Flow ID.\n         - Attempt to transmit\
    \ a packet that would result in Sequence\n           Number overflow.  The audit\
    \ log entry for this event SHOULD\n           include the SPI value, current date/time,\
    \ Source Address,\n           Destination Address, Sequence Number, and (for IPv6)\
    \ the\n           cleartext Flow ID.\n         - The received packet fails the\
    \ anti-replay checks.  The audit\n           log entry for this event SHOULD include\
    \ the SPI value,\n           date/time received, Source Address, Destination Address,\
    \ the\n           Sequence Number, and (in IPv6) the Flow ID.\n         - The\
    \ integrity check fails.  The audit log entry for this\n           event SHOULD\
    \ include the SPI value, date/time received,\n           Source Address, Destination\
    \ Address, the Sequence Number, and\n           (for IPv6) the Flow ID.\n   Additional\
    \ information also MAY be included in the audit log for each\n   of these events,\
    \ and additional events, not explicitly called out in\n   this specification,\
    \ also MAY result in audit log entries.  There is\n   no requirement for the receiver\
    \ to transmit any message to the\n   purported sender in response to the detection\
    \ of an auditable event,\n   because of the potential to induce denial of service\
    \ via such action.\n"
- title: 5.  Conformance Requirements
  contents:
  - "5.  Conformance Requirements\n   Implementations that claim conformance or compliance\
    \ with this\n   specification MUST implement the ESP syntax and processing described\n\
    \   here for unicast traffic, and MUST comply with all additional packet\n   processing\
    \ requirements levied by the Security Architecture document\n   [Ken-Arch].  Additionally,\
    \ if an implementation claims to support\n   multicast traffic, it MUST comply\
    \ with the additional requirements\n   specified for support of such traffic.\
    \  If the key used to compute an\n   ICV is manually distributed, correct provision\
    \ of the anti-replay\n   service requires correct maintenance of the counter state\
    \ at the\n   sender (across local reboots, etc.), until the key is replaced, and\n\
    \   there likely would be no automated recovery provision if counter\n   overflow\
    \ were imminent.  Thus, a compliant implementation SHOULD NOT\n   provide anti-replay\
    \ service in conjunction with SAs that are manually\n   keyed.\n   The mandatory-to-implement\
    \ algorithms for use with ESP are described\n   in a separate document [Eas04],\
    \ to facilitate updating the algorithm\n   requirements independently from the\
    \ protocol per se.  Additional\n   algorithms, beyond those mandated for ESP,\
    \ MAY be supported.\n   Because use of encryption in ESP is optional, support\
    \ for the \"NULL\"\n   encryption algorithm also is required to maintain consistency\
    \ with\n   the way ESP services are negotiated.  Support for the\n   confidentiality-only\
    \ service version of ESP is optional.  If an\n   implementation offers this service,\
    \ it MUST also support the\n   negotiation of the \"NULL\" integrity algorithm.\
    \  NOTE that although\n   integrity and encryption may each be \"NULL\" under\
    \ the circumstances\n   noted above, they MUST NOT both be \"NULL\".\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Security is central to the design of this protocol,\
    \ and thus security\n   considerations permeate the specification.  Additional\
    \ security-\n   relevant aspects of using the IPsec protocol are discussed in\
    \ the\n   Security Architecture document.\n"
- title: 7.  Differences from RFC 2406
  contents:
  - "7.  Differences from RFC 2406\n   This document differs from RFC 2406 in a number\
    \ of significant ways.\n        o Confidentiality-only service -- now a MAY, not\
    \ a MUST.\n        o SPI -- modified to specify a uniform algorithm for SAD lookup\n\
    \          for unicast and multicast SAs, covering a wider range of\n        \
    \  multicast technologies.  For unicast, the SPI may be used\n          alone\
    \ to select an SA, or may be combined with the protocol,\n          at the option\
    \ of the receiver.  For multicast SAs, the SPI is\n          combined with the\
    \ destination address, and optionally the\n          source address, to select\
    \ an SA.\n        o Extended Sequence Number -- added a new option for a 64-bit\n\
    \          sequence number for very high-speed communications.  Clarified\n  \
    \        sender and receiver processing requirements for multicast SAs\n     \
    \     and multi-sender SAs.\n        o Payload data -- broadened model to accommodate\
    \ combined mode\n          algorithms.\n        o Padding for improved traffic\
    \ flow confidentiality -- added\n          requirement to be able to add bytes\
    \ after the end of the IP\n          Payload, prior to the beginning of the Padding\
    \ field.\n        o Next Header -- added requirement to be able to generate and\n\
    \          discard dummy padding packets (Next Header = 59)\n        o ICV --\
    \ broadened model to accommodate combined mode\n          algorithms.\n      \
    \  o Algorithms -- Added combined confidentiality mode algorithms.\n        o\
    \ Moved references to mandatory algorithms to a separate\n          document.\n\
    \        o Inbound and Outbound packet processing -- there are now two\n     \
    \     paths: (1) separate confidentiality and integrity\n          algorithms\
    \ and (2) combined confidentiality mode\n          algorithms.  Because of the\
    \ addition of combined mode\n          algorithms, the encryption/decryption and\
    \ integrity sections\n          have been combined for both inbound and outbound\
    \ packet\n          processing.\n"
- title: 8.  Backward-Compatibility Considerations
  contents:
  - "8.  Backward-Compatibility Considerations\n   There is no version number in ESP\
    \ and no mechanism enabling IPsec\n   peers to discover or negotiate which version\
    \ of ESP each is using or\n   should use.  This section discusses consequent backward-compatibility\n\
    \   issues.\n   First, if none of the new features available in ESP v3 are employed,\n\
    \   then the format of an ESP packet is identical in ESP v2 and v3.  If a\n  \
    \ combined mode encryption algorithm is employed, a feature supported\n   only\
    \ in ESP v3, then the resulting packet format may differ from the\n   ESP v2 spec.\
    \  However, a peer who implements only ESP v2 would never\n   negotiate such an\
    \ algorithm, as they are defined for use only in the\n   ESP v3 context.\n   Extended\
    \ Sequence Number (ESN) negotiation is supported by IKE v2 and\n   has been addressed\
    \ for IKE v1 by the ESN Addendum to the IKE v1\n   Domain of Interpretation (DOI).\n\
    \   In the new ESP (v3), we make two provisions to better support traffic\n  \
    \ flow confidentiality (TFC):\n        - arbitrary padding after the end of an\
    \ IP packet\n        - a discard convention using Next Header = 59\n   The first\
    \ feature is one that should not cause problems for a\n   receiver, since the\
    \ IP total length field indicates where the IP\n   packet ends.  Thus, any TFC\
    \ padding bytes after the end of the packet\n   should be removed at some point\
    \ during IP packet processing, after\n   ESP processing, even if the IPsec software\
    \ does not remove such\n   padding.  Thus, this is an ESP v3 feature that a sender\
    \ can employ\n   irrespective of whether a receiver implements ESP v2 or ESP v3.\n\
    \   The second feature allows a sender to send a payload that is an\n   arbitrary\
    \ string of bytes that do not necessarily constitute a well-\n   formed IP packet,\
    \ inside of a tunnel, for TFC purposes.  It is an\n   open question as to what\
    \ an ESP v2 receiver will do when the Next\n   Header field in an ESP packet contains\
    \ the value \"59\".  It might\n   discard the packet when it finds an ill-formed\
    \ IP header, and log\n   this event, but it certainly ought not to crash, because\
    \ such\n   behavior would constitute a DoS vulnerability relative to traffic\n\
    \   received from authenticated peers.  Thus this feature is an\n   optimization\
    \ that an ESP v3 sender can make use of irrespective of\n   whether a receiver\
    \ implements ESP v2 or ESP v3.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   The author would like to acknowledge the contributions\
    \ of Ran\n   Atkinson, who played a critical role in initial IPsec activities,\
    \ and\n   who authored the first series of IPsec standards: RFCs 1825-1827.\n\
    \   Karen Seo deserves special thanks for providing help in the editing\n   of\
    \ this and the previous version of this specification.  The author\n   also would\
    \ like to thank the members of the IPSEC and MSEC working\n   groups who have\
    \ contributed to the development of this protocol\n   specification.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [Bra97]    Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Level\", BCP 14, RFC 2119, March\
    \ 1997.\n   [DH98]     Deering, S. and R. Hinden, \"Internet Protocol, Version\
    \ 6\n              (IPv6) Specification\", RFC 2460, December 1998.\n   [Eas04]\
    \    3rd Eastlake, D., \"Cryptographic Algorithm Implementation\n            \
    \  Requirements for Encapsulating Security Payload (ESP) and\n              Authentication\
    \ Header (AH)\", RFC 4305, December 2005.\n   [Ken-Arch] Kent, S. and K. Seo,\
    \ \"Security Architecture for the\n              Internet Protocol\", RFC 4301,\
    \ December 2005.\n   [Pos81]    Postel, J., \"Internet Protocol\", STD 5, RFC\
    \ 791, September\n              1981.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [Bel96]    Steven M. Bellovin, \"Problem Areas\
    \ for the IP Security\n              Protocols\", Proceedings of the Sixth Usenix\
    \ Unix Security\n              Symposium, July, 1996.\n   [HC03]     Holbrook,\
    \ H. and B. Cain, \"Source-Specific Multicast for\n              IP\", Work in\
    \ Progress, November 3, 2002.\n   [Kau05]    Kaufman, C., Ed., \"The Internet\
    \ Key Exchange (IKEv2)\n              Protocol\", RFC 4306, December 2005.\n \
    \  [Ken-AH]   Kent, S., \"IP Authentication Header\", RFC 4302, December\n   \
    \           2005.\n   [Kra01]    Krawczyk, H., \"The Order of Encryption and Authentication\n\
    \              for Protecting Communications (Or: How Secure Is SSL?)\",\n   \
    \           CRYPTO' 2001.\n   [NIST01]   Federal Information Processing Standards\
    \ Publication 140-2\n              (FIPS PUB 140-2), \"Security Requirements for\
    \ Cryptographic\n              Modules\", Information Technology Laboratory, National\n\
    \              Institute of Standards and Technology, May 25, 2001.\n   [RFC3547]\
    \  Baugher, M., Weis, B., Hardjono, T., and H. Harney, \"The\n              Group\
    \ Domain of Interpretation\", RFC 3547, July 2003.\n   [RFC3740]  Hardjono, T.\
    \ and B. Weis, \"The Multicast Group Security\n              Architecture\", RFC\
    \ 3740, March 2004.\n   [Syverson] P. Syverson, D. Goldschlag, and M. Reed, \"\
    Anonymous\n              Connections and Onion Routing\", Proceedings of the\n\
    \              Symposium on Security and Privacy, Oakland, CA, May 1997,\n   \
    \           pages 44-54.\n"
- title: 'Appendix A: Extended (64-bit) Sequence Numbers'
  contents:
  - 'Appendix A: Extended (64-bit) Sequence Numbers

    '
- title: A1.  Overview
  contents:
  - "A1.  Overview\n   This appendix describes an extended sequence number (ESN) scheme\
    \ for\n   use with IPsec (ESP and AH) that employs a 64-bit sequence number,\n\
    \   but in which only the low-order 32 bits are transmitted as part of\n   each\
    \ packet.  It covers both the window scheme used to detect\n   replayed packets\
    \ and the determination of the high-order bits of the\n   sequence number that\
    \ are used both for replay rejection and for\n   computation of the ICV.  It also\
    \ discusses a mechanism for handling\n   loss of synchronization relative to the\
    \ (not transmitted) high-order\n   bits.\n"
- title: A2.  Anti-Replay Window
  contents:
  - "A2.  Anti-Replay Window\n   The receiver will maintain an anti-replay window\
    \ of size W.  This\n   window will limit how far out of order a packet can be,\
    \ relative to\n   the packet with the highest sequence number that has been\n\
    \   authenticated so far.  (No requirement is established for minimum or\n   recommended\
    \ sizes for this window, beyond the 32- and 64-packet\n   values already established\
    \ for 32-bit sequence number windows.\n   However, it is suggested that an implementer\
    \ scale these values\n   consistent with the interface speed supported by an implementation\n\
    \   that makes use of the ESN option.  Also, the algorithm described\n   below\
    \ assumes that the window is no greater than 2^31 packets in\n   width.)  All\
    \ 2^32 sequence numbers associated with any fixed value\n   for the high-order\
    \ 32 bits (Seqh) will hereafter be called a sequence\n   number subspace.  The\
    \ following table lists pertinent variables and\n   their definitions.\n     \
    \   Var.   Size\n        Name  (bits)            Meaning\n        ----  ------\
    \  ---------------------------\n        W       32    Size of window\n       \
    \ T       64    Highest sequence number authenticated so far,\n              \
    \        upper bound of window\n          Tl      32    Lower 32 bits of T\n \
    \         Th      32    Upper 32 bits of T\n        B       64    Lower bound\
    \ of window\n          Bl      32    Lower 32 bits of B\n          Bh      32\
    \    Upper 32 bits of B\n        Seq     64    Sequence Number of received packet\n\
    \          Seql    32    Lower 32 bits of Seq\n          Seqh    32    Upper 32\
    \ bits of Seq\n   When performing the anti-replay check, or when determining which\n\
    \   high-order bits to use to authenticate an incoming packet, there are\n   two\
    \ cases:\n     + Case A: Tl >= (W - 1). In this case, the window is within one\n\
    \                              sequence number subspace.  (See Figure 1)\n   \
    \  + Case B: Tl < (W - 1).  In this case, the window spans two\n             \
    \                 sequence number subspaces.  (See Figure 2)\n   In the figures\
    \ below, the bottom line (\"----\") shows two consecutive\n   sequence number\
    \ subspaces, with zeros indicating the beginning of\n   each subspace.  The two\
    \ shorter lines above it show the higher-order\n   bits that apply.  The \"====\"\
    \ represents the window.  The \"****\"\n   represents future sequence numbers,\
    \ i.e., those beyond the current\n   highest sequence number authenticated (ThTl).\n\
    \        Th+1                         *********\n        Th               =======*****\n\
    \              --0--------+-----+-----0--------+-----------0--\n             \
    \            Bl    Tl            Bl\n                                        (Bl+2^32)\
    \ mod 2^32\n                            Figure 1 -- Case A\n        Th       \
    \                    ====**************\n        Th-1                      ===\n\
    \              --0-----------------+--0--+--------------+--0--\n             \
    \                     Bl    Tl            Bl\n                               \
    \                  (Bl+2^32) mod 2^32\n                            Figure 2 --\
    \ Case B\n"
- title: A2.1.  Managing and Using the Anti-Replay Window
  contents:
  - "A2.1.  Managing and Using the Anti-Replay Window\n   The anti-replay window can\
    \ be thought of as a string of bits where\n   `W' defines the length of the string.\
    \  W = T - B + 1 and cannot\n   exceed 2^32 - 1 in value.  The bottom-most bit\
    \ corresponds to B and\n   the top-most bit corresponds to T, and each sequence\
    \ number from Bl\n   through Tl is represented by a corresponding bit.  The value\
    \ of the\n   bit indicates whether or not a packet with that sequence number has\n\
    \   been received and authenticated, so that replays can be detected and\n   rejected.\n\
    \   When a packet with a 64-bit sequence number (Seq) greater than T is\n   received\
    \ and validated,\n      + B is increased by (Seq - T)\n      + (Seq - T) bits\
    \ are dropped from the low end of the window\n      + (Seq - T) bits are added\
    \ to the high end of the window\n      + The top bit is set to indicate that a\
    \ packet with that sequence\n        number has been received and authenticated\n\
    \      + The new bits between T and the top bit are set to indicate that\n   \
    \     no packets with those sequence numbers have been received yet.\n      +\
    \ T is set to the new sequence number\n   In checking for replayed packets,\n\
    \      + Under Case A: If Seql >= Bl (where Bl = Tl - W + 1) AND Seql <=\n   \
    \     Tl, then check the corresponding bit in the window to see if\n        this\
    \ Seql has already been seen.  If yes, reject the packet.  If\n        no, perform\
    \ integrity check (see Appendix A2.2. below for\n        determination of Seqh).\n\
    \      + Under Case B: If Seql >= Bl (where Bl = Tl - W + 1) OR Seql <=\n    \
    \    Tl, then check the corresponding bit in the window to see if\n        this\
    \ Seql has already been seen.  If yes, reject the packet.  If\n        no, perform\
    \ integrity check (see Appendix A2.2. below for\n        determination of Seqh).\n"
- title: A2.2.  Determining the Higher-Order Bits (Seqh) of the Sequence Number
  contents:
  - "A2.2.  Determining the Higher-Order Bits (Seqh) of the Sequence Number\n   Because\
    \ only `Seql' will be transmitted with the packet, the receiver\n   must deduce\
    \ and track the sequence number subspace into which each\n   packet falls, i.e.,\
    \ determine the value of Seqh.  The following\n   equations define how to select\
    \ Seqh under \"normal\" conditions; see\n   Section A3 for a discussion of how\
    \ to recover from extreme packet\n   loss.\n      + Under Case A (Figure 1):\n\
    \        If Seql >= Bl (where Bl = Tl - W + 1), then Seqh = Th\n        If Seql\
    \ <  Bl (where Bl = Tl - W + 1), then Seqh = Th + 1\n      + Under Case B (Figure\
    \ 2):\n        If Seql >= Bl (where Bl = Tl - W + 1), then Seqh = Th - 1\n   \
    \     If Seql <  Bl (where Bl = Tl - W + 1), then Seqh = Th\n"
- title: A2.3.  Pseudo-Code Example
  contents:
  - "A2.3.  Pseudo-Code Example\n   The following pseudo-code illustrates the above\
    \ algorithms for anti-\n   replay and integrity checks.  The values for `Seql',\
    \ `Tl', `Th' and\n   `W' are 32-bit unsigned integers.  Arithmetic is mod 2^32.\n\
    \        If (Tl >= W - 1)                            Case A\n            If (Seql\
    \ >= Tl - W + 1)\n                Seqh = Th\n                If (Seql <= Tl)\n\
    \                    If (pass replay check)\n                        If (pass\
    \ integrity check)\n                            Set bit corresponding to Seql\n\
    \                            Pass the packet on\n                        Else\
    \ reject packet\n                    Else reject packet\n                Else\n\
    \                    If (pass integrity check)\n                        Tl = Seql\
    \ (shift bits)\n                        Set bit corresponding to Seql\n      \
    \                  Pass the packet on\n                    Else reject packet\n\
    \            Else\n                Seqh = Th + 1\n                If (pass integrity\
    \ check)\n                    Tl = Seql (shift bits)\n                    Th =\
    \ Th + 1\n                    Set bit corresponding to Seql\n                \
    \    Pass the packet on\n                Else reject packet\n        Else    \
    \                                Case B\n            If (Seql >= Tl - W + 1)\n\
    \                Seqh = Th - 1\n                If (pass replay check)\n     \
    \               If (pass integrity check)\n                        Set the bit\
    \ corresponding to Seql\n                        Pass packet on\n            \
    \        Else reject packet\n                Else reject packet\n            Else\n\
    \                Seqh = Th\n                If (Seql <= Tl)\n                \
    \    If (pass replay check)\n                        If (pass integrity check)\n\
    \                            Set the bit corresponding to Seql\n             \
    \               Pass packet on\n                        Else reject packet\n \
    \                   Else reject packet\n                Else\n               \
    \     If (pass integrity check)\n                        Tl = Seql (shift bits)\n\
    \                        Set the bit corresponding to Seql\n                 \
    \       Pass packet on\n                    Else reject packet\n"
- title: A3.  Handling Loss of Synchronization due to Significant Packet Loss
  contents:
  - "A3.  Handling Loss of Synchronization due to Significant Packet Loss\n   If there\
    \ is an undetected packet loss of 2^32 or more consecutive\n   packets on a single\
    \ SA, then the transmitter and receiver will lose\n   synchronization of the high-order\
    \ bits, i.e., the equations in\n   Section A2.2. will fail to yield the correct\
    \ value.  Unless this\n   problem is detected and addressed, subsequent packets\
    \ on this SA will\n   fail authentication checks and be discarded.  The following\
    \ procedure\n   SHOULD be implemented by any IPsec (ESP or AH) implementation\
    \ that\n   supports the ESN option.\n   Note that this sort of extended traffic\
    \ loss is likely to be detected\n   at higher layers in most cases, before IPsec\
    \ would have to invoke the\n   sort of re-synchronization mechanism described\
    \ in A3.1 and A3.2. If\n   any significant fraction of the traffic on the SA in\
    \ question is TCP,\n   the source would fail to receive ACKs and would stop sending\
    \ long\n   before 2^32 packets had been lost.  Also, for any bi-directional\n\
    \   application, even ones operating above UDP, such an extended outage\n   would\
    \ likely result in triggering some form of timeout.  However, a\n   unidirectional\
    \ application, operating over UDP, might lack feedback\n   that would cause automatic\
    \ detection of a loss of this magnitude,\n   hence the motivation to develop a\
    \ recovery method for this case.\n   Note that the above observations apply to\
    \ SAs between security\n   gateways, or between hosts, or between host and security\
    \ gateways.\n   The solution we've chosen was selected to:\n     + minimize the\
    \ impact on normal traffic processing\n     + avoid creating an opportunity for\
    \ a new denial of service attack\n       such as might occur by allowing an attacker\
    \ to force diversion of\n       resources to a re-synchronization process\n  \
    \   + limit the recovery mechanism to the receiver -- because anti-\n       replay\
    \ is a service only for the receiver, and the transmitter\n       generally is\
    \ not aware of whether the receiver is using sequence\n       numbers in support\
    \ of this optional service, it is preferable for\n       recovery mechanisms to\
    \ be local to the receiver.  This also\n       allows for backward compatibility.\n"
- title: A3.1.  Triggering Re-synchronization
  contents:
  - "A3.1.  Triggering Re-synchronization\n   For each SA, the receiver records the\
    \ number of consecutive packets\n   that fail authentication.  This count is used\
    \ to trigger the re-\n   synchronization process, which should be performed in\
    \ the background\n   or using a separate processor.  Receipt of a valid packet\
    \ on the SA\n   resets the counter to zero.  The value used to trigger the re-\n\
    \   synchronization process is a local parameter.  There is no\n   requirement\
    \ to support distinct trigger values for different SAs,\n   although an implementer\
    \ may choose to do so.\n"
- title: A3.2.  Re-synchronization Process
  contents:
  - "A3.2.  Re-synchronization Process\n   When the above trigger point is reached,\
    \ a \"bad\" packet is selected\n   for which authentication is retried using successively\
    \ larger values\n   for the upper half of the sequence number (Seqh).  These values\
    \ are\n   generated by incrementing by one for each retry.  The number of\n  \
    \ retries should be limited, in case this is a packet from the \"past\"\n   or\
    \ a bogus packet.  The limit value is a local parameter.  (Because\n   the Seqh\
    \ value is implicitly placed after the ESP (or AH) payload, it\n   may be possible\
    \ to optimize this procedure by executing the integrity\n   algorithm over the\
    \ packet up to the endpoint of the payload, then\n   compute different candidate\
    \ ICVs by varying the value of Seqh.)\n   Successful authentication of a packet\
    \ via this procedure resets the\n   consecutive failure count and sets the value\
    \ of T to that of the\n   received packet.\n   This solution requires support\
    \ only on the part of the receiver,\n   thereby allowing for backward compatibility.\
    \  Also, because re-\n   synchronization efforts would either occur in the background\
    \ or\n   utilize an additional processor, this solution does not impact\n   traffic\
    \ processing and a denial of service attack cannot divert\n   resources away from\
    \ traffic processing.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Stephen Kent\n   BBN Technologies\n   10 Moulton Street\n\
    \   Cambridge, MA  02138\n   USA\n   Phone: +1 (617) 873-3988\n   EMail: kent@bbn.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
