- contents:
  - '                         GMPLS Segment Recovery

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes protocol specific procedures for GMPLS\n
    \  (Generalized Multi-Protocol Label Switching) RSVP-TE (Resource\n   ReserVation
    Protocol - Traffic Engineering) signaling extensions to\n   support label switched
    path (LSP) segment protection and restoration.\n   These extensions are intended
    to complement and be consistent with\n   the RSVP-TE Extensions for End-to-End
    GMPLS Recovery (RFC 4872).\n   Implications and interactions with fast reroute
    are also addressed.\n   This document also updates the handling of NOTIFY_REQUEST
    objects.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Conventions Used in This Document ..........................3\n   2.
    Segment Recovery ................................................4\n      2.1.
    Segment Protection .........................................6\n      2.2. Segment
    Re-routing and Restoration .........................6\n   3. ASSOCIATION Object
    ..............................................6\n      3.1. Format .....................................................7\n
    \     3.2. Procedures .................................................7\n           3.2.1.
    Recovery Type Processing ............................7\n           3.2.2. Resource
    Sharing Association Type Processing ........7\n   4. Explicit Control of LSP Segment
    Recovery ........................8\n      4.1. Secondary Explicit Route Object
    Format .....................8\n           4.1.1. Protection Subobject ................................8\n
    \     4.2. Explicit Control Procedures ................................9\n           4.2.1.
    Branch Failure Handling ............................10\n           4.2.2. Resv
    Message Processing ............................11\n           4.2.3. Admin Status
    Change ................................12\n           4.2.4. Recovery LSP Teardown
    ..............................12\n      4.3. Teardown From Non-Ingress Nodes ...........................12\n
    \          4.3.1. Modified NOTIFY_REQUEST Object Processing ..........13\n           4.3.2.
    Modified Notify and Error Message Processing .......14\n   5. Secondary Record
    Route Objects .................................14\n      5.1. Format ....................................................14\n
    \     5.2. Path Processing ...........................................15\n      5.3.
    Resv Processing ...........................................15\n   6. Dynamic Control
    of LSP Segment Recovery ........................16\n      6.1. Modified PROTECTION
    Object Format .........................16\n      6.2. Dynamic Control Procedures
    ................................17\n   7. Updated RSVP Message Formats ...................................18\n
    \  8. Security Considerations ........................................20\n   9.
    IANA Considerations ............................................21\n      9.1.
    New Association Type Assignment ...........................21\n      9.2. Definition
    of PROTECTION Object Reserved Bits .............21\n      9.3. Secondary Explicit
    Route Object ...........................21\n      9.4. Secondary Record Route
    Object .............................21\n      9.5. New Error Code ............................................22\n
    \     9.6. Use of PROTECTION Object C-type ...........................22\n   10.
    References ....................................................23\n      10.1.
    Normative References .....................................23\n      10.2. Informative
    References ...................................23\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   [RFC4427] covers multiple types of protection, including
    end-to-end\n   and segment-based approaches.  \"RSVP-TE Extensions in Support
    of\n   End-to-End Generalized Multi-Protocol Label Switching (GMPLS)\n   Recovery\"
    [RFC4872] defines a set of extensions to support multiple\n   types of recovery.
    \ The supported types include 1+1 unidirectional/\n   1+1 bidirectional protection,
    LSP protection with extra-traffic\n   (including 1:N protection with extra-traffic),
    pre-planned LSP re-\n   routing without extra-traffic (including shared mesh),
    and full LSP\n   re-routing.  In all cases, the recovery is provided on an end-to-end\n
    \  basis, i.e., the ingress and egress nodes of both the protected and\n   the
    protecting LSP are the same.\n   [RFC4090] provides a form of segment recovery
    for packet MPLS-TE\n   networks.  Two methods of fast reroute are defined in [RFC4090].
    \ The\n   one-to-one backup method creates detour LSPs for each protected LSP\n
    \  at each potential point of local repair.  The facility backup method\n   creates
    a bypass tunnel to protect a potential failure point that is\n   shared by multiple
    LSPs and uses label stacking.  Neither approach\n   supports the full set of recovery
    types supported by [RFC4872].\n   Additionally, the facility backup method is
    not applicable to most\n   non-PSC (packet switch capable) switching technologies.\n
    \  The extensions defined in this document allow for support of the full\n   set
    of recovery types supported by [RFC4872], but on a segment, or\n   portion of
    the LSP, basis.  The extensions allow (a) the signaling of\n   desired LSP segment
    protection type, (b) upstream nodes to optionally\n   identify where segment protection
    starts and stops, (c) the optional\n   identification of hops used on protection
    segments, and (d) the\n   reporting of paths used to protect an LSP.  The extensions
    also widen\n   the topological scope over which protection can be supported.  They\n
    \  allow recovery segments that protect against an arbitrary number of\n   nodes
    and links.  They enable overlapping protection and nested\n   protection.  These
    extensions are intended to be compatible with fast\n   reroute, and in some cases
    used with fast reroute.\n"
  - contents:
    - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in [RFC2119].\n   In addition, the reader is assumed to be familiar
      with the\n   terminology used in [RFC3209], [RFC3471], and [RFC3473], as well
      as\n   [RFC4427], [RFC4426], [RFC4872], and [RFC4090].\n"
    title: 1.1.  Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - "2.  Segment Recovery\n   Segment recovery is used to provide protection and restoration
    over a\n   portion of an end-to-end LSP.  Such segment protection and\n   restoration
    is useful to protect against a span failure, a node\n   failure, or failure over
    a particular portion of a network used by an\n   LSP.\n   Consider the following
    topology:\n                        A---B---C---D---E---F\n                                 \\
    \    /\n                                  G---I\n   In this topology, end-to-end
    protection and recovery is not possible\n   for an LSP going between node A and
    node F, but it is possible to\n   protect/recover a portion of the LSP.  Specifically,
    if the LSP uses\n   a working path of [A,B,C,D,E,F], then a protection or restoration
    LSP\n   can be established along the path [C,G,I,E].  This LSP protects\n   against
    failures on spans {C,D} and {D,E}, as well as a failure of\n   node D.  This form
    of protection/restoration is referred to as\n   Segment Protection and Segment
    Restoration, or as Segment Recovery,\n   collectively.  The LSP providing the
    protection or restoration is\n   referred to as a segment protection LSP or a
    segment restoration LSP.\n   The term \"segment recovery LSP\" is used to cover
    either a segment\n   protection LSP or a segment restoration LSP.  The term \"branch
    node\"\n   is used to refer to a node that initiates a recovery LSP, e.g., node\n
    \  C in the figure shown above.  This is equivalent to the point of\n   local
    repair (PLR) used in [RFC4090].  As with [RFC4090], the term\n   \"merge node\"
    is used to refer to a node that terminates a recovery\n   LSP, e.g., node E in
    the figure shown above.\n   Segment protection or restoration is signaled using
    a working LSP and\n   one or more segment recovery LSPs.  Each segment recovery
    LSP is\n   signaled as an independent LSP.  Specifically, the Sender_Template\n
    \  object uses the IP address of the node originating the recovery path,\n   e.g.,
    node C in the topology shown above, and the Session object\n   contains the IP
    address of the node terminating the recovery path,\n   e.g., node E shown above.
    \ There is no specific requirement on LSP ID\n   value, Tunnel ID, and Extended
    Tunnel ID.  Values for these fields\n   are selected normally, including consideration
    for the make-before-\n   break concept (as described in [RFC3209]).  Intermediate
    nodes follow\n   standard signaling procedures when processing segment recovery
    LSPs.\n   A segment recovery LSP may be protected itself using segment or end-\n
    \  to-end protection/restoration.  Note, in PSC environments, it may be\n   desirable
    to construct the Sender_Template and Session objects per\n   [RFC4090].\n   When
    [RFC4090] isn't being used, the association between segment\n   recovery LSPs
    with other LSPs is indicated using the ASSOCIATION\n   object defined in [RFC4872].
    \ The ASSOCIATION object is used to\n   associate recovery LSPs with the LSP they
    are protecting.  Working\n   and protecting LSPs, as well as primary and secondary
    LSPs, are\n   identified using LSP Status as described in [RFC4872].  The O-bit
    in\n   the segment flags portion of the PROTECTION object is used to\n   identify
    when a recovery LSP is carrying the normal (active) traffic.\n   An upstream node
    can permit downstream nodes to dynamically identify\n   branch and merge points
    by setting the desired LSP segment protection\n   bits in the PROTECTION object.
    \ These bits are defined below.\n   Optionally, an upstream node, usually the
    ingress node, can identify\n   the endpoints of a segment recovery LSP.  This
    is accomplished using\n   a new object.  This object uses the same format as an
    Explicit Route\n   Object (ERO) and is referred to as a Secondary Explicit Route
    object\n   (SERO); see Section 4.1.  SEROs also support a new subobject to\n   indicate
    the type of protection or restoration to be provided.  At a\n   minimum, an SERO
    will indicate a recovery LSP's initiator,\n   protection/restoration type and
    terminator.  Standard ERO semantics\n   (see [RFC3209]) can optionally be used
    within and SERO to explicitly\n   control the recovery LSP.  A Secondary Record
    Route object (SRRO) is\n   defined for recording the path of a segment recovery
    LSP; see Section\n   5.\n   SEROs are carried between the node creating the SERO,
    typically the\n   ingress, and the node initiating a recovery LSP.  The node initiating\n
    \  a recovery LSP uses the SERO to create the ERO for the recovery LSP.\n   At
    this (branch) node, all local objects are removed, and the new\n   protection
    subobject is used to create the PROTECTION object for the\n   recovery LSP.  It
    is also possible to control the handling of a\n   failure to establish a recovery
    LSP.\n   SRROs are carried in Path messages between the node terminating a\n   recovery
    LSP, the merge node, and the egress.  SRROs are used in Resv\n   messages between
    a branch node and the ingress.  The merge node of a\n   recovery LSP creates an
    SRRO by copying the RRO from the Path message\n   of the associated recovery LSP
    into a new SRRO object.  Any SRROs\n   present in the recovery LSP's Path message
    are also copied.  The\n   branch node of a recovery LSP creates an SRRO by copying
    the RRO from\n   the Resv message of associated recovery LSP into a new SRRO object.\n
    \  Any SRROs present in the recovery LSP's Resv message are also copied.\n   Notify
    request processing is also impacted by LSP segment recovery.\n   Per [RFC3473],
    only one NOTIFY_REQUEST object is meaningful and\n   should be propagated.  Additional
    NOTIFY_REQUEST objects are used to\n   identify recovery LSP branch nodes.\n"
  - contents:
    - "2.1.  Segment Protection\n   Three approaches for end-to-end protection are
      defined in [RFC4872]:\n   1+1 Unidirectional Protection (Section 5), 1+1 Bidirectional\n
      \  Protection (Section 6), and 1:1 Protection With Extra-Traffic\n   (Section
      7).  The segment protection forms of these protection\n   approaches all operate
      much like their end-to-end counterparts.  Each\n   behaves just like its end-to-end
      counterpart, with the exception that\n   the protection LSP protects only a
      portion of the working LSP.  The\n   type of protection to be used on a segment
      protection LSP is\n   indicated, to the protection LSP's ingress, using the
      protection SERO\n   subobject defined in Section 4.1.\n   The switch-over processing
      for segment 1+1 Bidirectional protection\n   and 1:1 Protection With Extra-Traffic
      follows the same procedures as\n   end-to-end protection forms; see Sections
      6.2 and 7.2 of [RFC4872]\n   for details.\n"
    title: 2.1.  Segment Protection
  - contents:
    - "2.2.  Segment Re-routing and Restoration\n   Three re-routing and restoration
      approaches are defined in [RFC4872]:\n   Re-routing without Extra-Traffic (Section
      8), Shared-Mesh Restoration\n   (Section 9), (Full) LSP Re-routing (Section
      11).  As with protection,\n   these approaches are supported on a segment basis.
      \ The segment forms\n   of re-routing and restoration operate exactly like their
      end-to-end\n   counterparts, with the exception that the restoration LSP recovers\n
      \  only a portion of the working LSP.  The type of re-routing or\n   restoration
      to be used on a segment restoration LSP is indicated, to\n   the restoration
      LSP's ingress, using the new protection SERO\n   subobject.\n"
    title: 2.2.  Segment Re-routing and Restoration
  title: 2.  Segment Recovery
- contents:
  - "3.  ASSOCIATION Object\n   The ASSOCIATION object is used for the association
    of segment\n   protection LSPs when [RFC4090] isn't being used.  The ASSOCIATION\n
    \  object is defined in [RFC4872].  In this document, we define a new\n   Association
    Type field value to support make-before-break; the\n   formats and procedures
    defined in [RFC4872] are not otherwise\n   modified.\n"
  - contents:
    - "3.1.  Format\n   Association Type: 16 bits\n      Value       Type\n      -----
      \      ----\n        2         Resource Sharing (R)\n   See [RFC4872] for the
      definition of other fields and values.\n"
    title: 3.1.  Format
  - contents:
    - "3.2.  Procedures\n   The ASSOCIATION object is used to associate different
      LSPs with each\n   other.  In the protection and restoration context, the object
      is used\n   to associate a recovery LSP with the LSP it is protecting.  The\n
      \  ASSOCIATION object is also used to support resource sharing during\n   make-before-break.
      \ This object MUST NOT be used when association is\n   made according to the
      methods defined in [RFC4090].\n"
    - contents:
      - "3.2.1.  Recovery Type Processing\n   Recovery type processing procedures
        are the same as those defined in\n   [RFC4872], but processing and identification
        occur with respect to\n   segment recovery LSPs.  Note that this means that
        multiple\n   ASSOCIATION objects of type recovery may be present on an LSP.\n"
      title: 3.2.1.  Recovery Type Processing
    - contents:
      - "3.2.2.  Resource Sharing Association Type Processing\n   The ASSOCIATION
        object with an Association Type with the value\n   Resource Sharing is used
        to enable resource sharing during make-\n   before-break.  Resource sharing
        during make-before-break is defined\n   in [RFC3209].  The defined support
        only works with LSPs that share\n   the same LSP egress.  With the introduction
        of segment recovery LSPs,\n   it is now possible for an LSP endpoint to change
        during make-before-\n   break.\n   A node includes an ASSOCIATION object with
        a Resource Sharing\n   Association Type in an outgoing Path message when it
        wishes to\n   indicate resource sharing across an associated set of LSPs.
        \ The\n   Association Source is set to the originating node's router address.\n
        \  The Association ID MUST be set to a value that uniquely identifies\n   the
        association of LSPs.  This MAY be set to the working LSP's LSP\n   ID.  Once
        included, an ASSOCIATION object with a Resource Sharing\n   Association Type
        SHOULD NOT be removed from the Path messages\n   associated with an LSP.\n
        \  Any node processing a Path message for which the node does not have a\n
        \  matching state, and which contains an ASSOCIATION object with a\n   Resource
        Sharing type, examines existing LSPs for matching\n   Association Type, Association
        Source, and Association ID values.  If\n   any match is found, then [RFC3209]
        style resource sharing SHOULD be\n   provided between the new and old LSPs.
        \ See [RFC3209] for additional\n   details.\n"
      title: 3.2.2.  Resource Sharing Association Type Processing
    title: 3.2.  Procedures
  title: 3.  ASSOCIATION Object
- contents:
  - "4.  Explicit Control of LSP Segment Recovery\n   Secondary Explicit Route objects,
    or SEROs, are defined in this\n   document.  They may be used to indicate the
    branch and merge nodes of\n   recovery LSPs.  They may also provide additional
    information that is\n   to be carried in a recovery LSP's ERO.  When upstream
    control of\n   branch and merge nodes is not desired, SEROs are not used.\n"
  - contents:
    - "4.1.  Secondary Explicit Route Object Format\n   The format of a SECONDARY_EXPLICIT_ROUTE
      object is the same as an\n   EXPLICIT_ROUTE object.  This includes the definition
      of subobjects\n   defined for EXPLICIT_ROUTE object.  The class of the\n   SECONDARY_EXPLICIT_ROUTE
      object is 200 (of the form 11bbbbbb).\n"
    - contents:
      - "4.1.1.  Protection Subobject\n   A new subobject, called the protection subobject,
        is defined for use\n   in the SECONDARY_EXPLICIT_ROUTE object.  As mentioned
        above, the new\n   protection subobject is used to create the PROTECTION object
        for the\n   recovery LSP.  Specific procedures related to the protection\n
        \  subobject are provided in Section 4.2.  The protection subobject is\n   not
        valid for use with the Explicit and Record Route objects and MUST\n   NOT
        be included in those objects.\n   The format of the protection subobject is
        defined as follows:\n       0                   1                   2                   3\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |L|    Type     |     Length    |    Reserved   |   C-Type      |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                  PROTECTION Object Contents                   |\n
        \     |                              ...                              |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     L-bit\n         This is defined in [RFC3209] and MUST be set to zero
        for\n         protection subobjects.\n      Type\n         37 Protection\n
        \     Length\n         As defined in [RFC3209], Section 4.3.3.\n      Reserved\n
        \        This field is reserved.  It MUST be set to zero on transmission\n
        \        and MUST be ignored on receipt.\n      C-Type\n         The C-Type
        of the included PROTECTION object.\n      PROTECTION Object Contents\n         The
        contents of the PROTECTION object, with the format matching\n         the
        indicated C-Type, excluding the object header.\n"
      title: 4.1.1.  Protection Subobject
    title: 4.1.  Secondary Explicit Route Object Format
  - contents:
    - "4.2.  Explicit Control Procedures\n   SEROs are carried in Path messages and
      indicate at which node a\n   recovery LSP is to be initiated relative to the
      LSP carrying the\n   SERO.  More than one SERO MAY be present in a Path message.\n
      \  To indicate the branch and merge nodes of a recovery LSP, an SERO is\n   created
      and added to the Path message of the LSP being recovered.\n   The decision to
      create and insert an SERO is a local matter and\n   outside the scope of this
      document.\n   An SERO SHOULD contain at least three subobjects.  The first\n
      \  subobject MUST indicate the node that is to originate the recovery\n   LSP,
      i.e. the segment branch node.  The address used SHOULD also be\n   listed in
      the ERO or another SERO.  This ensures that the branch node\n   is along the
      LSP path.  The second subobject SHOULD be a protection\n   subobject and should
      indicate the protection or restoration to be\n   provided by the recovery LSP.
      \ When the protection subobject is\n   present, the LSP Segment Recovery Flags
      in the protection subobject\n   MUST be ignored.  The final subobject in the
      SERO MUST be the merge\n   node of the recovery LSP, and MAY have the L-bit
      set.  Standard ERO\n   subobjects MAY be inserted between the protection subobject
      and the\n   final subobject.  These subobjects MAY be loose or strict.\n   A
      node receiving a Path message containing one or more SEROs SHOULD\n   examine
      each SERO to see if it indicates a local branch point.  This\n   determination
      is made by examining the first object of each SERO and\n   seeing if the address
      indicated in the subobject can be associated\n   with the local node.  If any
      of indicated addresses are associated\n   with the local node, then the local
      node is a branch node.  If the\n   local node is not a branch node, all received
      SEROs MUST be\n   transmitted, without modification, in the corresponding outgoing
      Path\n   message.\n   At a branch node, the SERO, together with the Path message
      of LSP\n   being recovered, provides the information to create the recovery
      LSP.\n   The Path message for the recovery LSP is created at the branch node\n
      \  by cloning the objects carried in the incoming Path message of the\n   LSP
      being protected.  Certain objects are replaced or modified in the\n   recovery
      LSP's outgoing Path message.  The Sender_template object\n   MUST be updated
      to use an address (in its Tunnel Sender Address\n   field) on the local node,
      and the LSP ID MUST be updated to ensure\n   uniqueness.  The Session object
      MUST be updated to use the address\n   indicated in the final subobject of the
      SERO as the tunnel endpoint\n   address, the tunnel ID MAY be updated, and the
      extended tunnel ID\n   MUST be set to the local node address.  The PROTECTION
      object is\n   replaced with the contents of the matching SERO protection subobject,\n
      \  when present.  In all cases, the R-bit of a new PROTECTION object is\n   reset
      (0).  Any RROs and EROs present in the incoming Path message\n   MUST NOT be
      included in the recovery LSP.  A new ERO MUST be\n   included, with the contents
      of the SERO that indicated a local\n   branch.  As with all EROs, no local information
      (local address and\n   any protection subobjects) is carried in the ERO carried
      in the\n   recovery LSP's outgoing Path message.  The SERO that indicated a\n
      \  local branch MUST be omitted from the recovery LSP's outgoing Path\n   message.
      \ Note, by default, all other received SEROs are passed in\n   the recovery
      LSP's outgoing Path message.  SEROs MAY be omitted, from\n   the recovery LSP's
      outgoing Path message as well as the outgoing Path\n   message for the LSP being
      protected, when the SERO does not relate to\n   the outgoing path message.\n
      \  The resulting Path message is used to create the recovery LSP.  From\n   this
      point on, Standard Path message processing is used in processing\n   the resulting
      Path message.\n"
    - contents:
      - "4.2.1.  Branch Failure Handling\n   During setup, it is possible that a processing
        node will be unable to\n   support a requested branch.  Additionally, during
        setup and normal\n   operation, PathErr messages may be received at a branch
        node.  The\n   processing of these events depend on a number of factors.\n
        \  When a failure or received PathErr message is associated with the LSP\n
        \  being protected, the event is first processed per standard processing\n
        \  rules.  This includes generation of a standard PathErr message.  When\n
        \  LSP state is removed due to a local failure or a PathErr message with\n
        \  the Path_State_Removed flag set (1), the node MUST send a PathTear\n   message
        downstream on all other branches.\n   When a failure or received PathErr message
        is associated with a\n   recovery LSP, processing is based on the R-bit in
        addition to the\n   Path_State_Removed flag.  In all cases, a received PathErr
        message is\n   first processed per standard processing rules and the failure
        or\n   received PathErr message SHOULD trigger the generation of a PathErr\n
        \  message upstream for the LSP being protected.  The outgoing PathErr\n   message
        SHOULD indicate an error of \"Routing Problem/LSP Segment\n   Protection Failed\".
        \ The outgoing PathErr message MUST include any\n   SEROs carried in a received
        PathErr message.  If no SERO is present\n   in a received PathErr message
        or when the failure is local, then an\n   SERO that matches the errored LSP
        or failed branch MUST be added to\n   the outgoing PathErr message.\n   When
        a PathErr message with the Path_State_Removed flag cleared (0)\n   is received,
        the outgoing (upstream) PathErr message SHOULD be sent\n   with the Path_State_Removed
        flag cleared (0).\n   When a PathErr message for a recovery LSP with the Path_State_Removed\n
        \  flag set (1) is received, the processing node MUST examine the R-bit\n
        \  (as defined below) of the LSP being protected.  The R-bit is carried\n
        \  in the PROTECTION object that triggered the initiation of the\n   recovery
        LSP.  When the R-bit is not set (0), the outgoing (upstream)\n   PathErr message
        SHOULD be sent with the Path_State_Removed flag\n   cleared (0).  When the
        R-bit is set (1), the outgoing (upstream)\n   PathErr message MUST be sent
        with the Path_State_Removed flag set\n   (1).\n   In all cases where an outgoing
        (upstream) PathErr message is sent\n   with the Path_State_Removed flag set
        (1), all path state for the LSP\n   being protected MUST be removed, and the
        node MUST send a PathTear\n   message downstream on all active branches.\n"
      title: 4.2.1.  Branch Failure Handling
    - contents:
      - "4.2.2.  Resv Message Processing\n   Branch nodes will process Resv messages
        for both recovery LSPs and\n   LSPs being protected.  Resv messages are propagated
        upstream of\n   branch nodes only after a Resv message is received for the
        protected\n   LSP.  Resv messages on recovery LSPs will typically not trigger\n
        \  transmission of upstream Resv messages (for the LSP being protected).\n
        \  Exceptions to this include when RROs/SRROs are being collected and\n   during
        certain ADMIN_STATUS object processing.  See below for more\n   information
        on related processing.\n"
      title: 4.2.2.  Resv Message Processing
    - contents:
      - "4.2.3.  Admin Status Change\n   In general, objects in a recovery LSP are
        created based on the\n   corresponding objects in the LSP being protected.
        \ The ADMIN_STATUS\n   object is created the same way, but it also requires
        some special\n   coordination at branch nodes.  Specifically, in addition
        to normal\n   processing, a branch node that receives an ADMIN_STATUS object
        in a\n   Path message also MUST relay the ADMIN_STATUS object in a Path on\n
        \  every recovery LSP.  All Path messages MAY be concurrently sent\n   downstream.\n
        \  Downstream nodes process the change in the ADMIN_STATUS object per\n   [RFC3473],
        including generation of Resv messages.  When the most\n   recently received
        upstream ADMIN_STATUS object has the R bit set,\n   branch nodes wait for
        a Resv message with a matching ADMIN_STATUS\n   object to be received on all
        branches before relaying a corresponding\n   Resv message upstream.\n"
      title: 4.2.3.  Admin Status Change
    - contents:
      - "4.2.4.  Recovery LSP Teardown\n   Recovery LSP removal follows standard procedures
        defined in [RFC3209]\n   and [RFC3473].  This includes with and without setting
        the\n   administrative status.\n"
      - contents:
        - "4.2.4.1.  Teardown Without Admin Status Change\n   The node initiating
          the teardown originates a PathTear message.  Each\n   node that receives
          a PathTear message processes the PathTear message\n   per standard processing
          (see [RFC3209] and [RFC2205]), and MUST also\n   relay a PathTear on every
          recovery LSP.  All PathTear messages\n   (received from upstream and locally
          originated) may be concurrently\n   sent downstream.\n"
        title: 4.2.4.1.  Teardown Without Admin Status Change
      - contents:
        - "4.2.4.2.  Teardown With Admin Status Change\n   Per [RFC3473], the ingress
          node originates a Path message with the D\n   and R bits set in the ADMIN_STATUS
          object.  The admin status change\n   procedure defined in Section 4.2.3
          MUST then be followed.  Once the\n   ingress receives all expected Resv
          messages, it MUST follow the\n   teardown procedure described in Section
          4.2.4.1.\n"
        title: 4.2.4.2.  Teardown With Admin Status Change
      title: 4.2.4.  Recovery LSP Teardown
    title: 4.2.  Explicit Control Procedures
  - contents:
    - "4.3.  Teardown From Non-Ingress Nodes\n   As with any LSP, any node along a
      recovery LSP may initiate removal\n   of the recovery LSP.  To do this, the
      node initiating the teardown\n   sends a PathErr message with the appropriate
      Error Code and the\n   Path_State_Removed flag cleared (0) toward the LSP ingress.
      \ As\n   described above, the recovery LSP ingress will propagate the error
      to\n   the LSP ingress, which can then signal the removal of the recovery\n
      \  LSP.\n   It is also possible for the node initiating the teardown to remove
      a\n   Recovery LSP in a non-graceful manner.  In this case, the initiator\n
      \  sends a PathTear message downstream and a PathErr message with a\n   \"Confirmation\"
      indication (error code and value set to zero), and the\n   Path_State_Removed
      flag set (1) toward the LSP ingress node.  This\n   manner of non-ingress node
      teardown is NOT RECOMMENDED because in\n   some cases it can result in the removal
      of the LSP being protected.\n"
    - contents:
      - "4.3.1.  Modified NOTIFY_REQUEST Object Processing\n   A parallel set of rules
        are applied at branch and merge nodes to\n   enable the branch or merge node
        to add a NOTIFY_REQUEST object to the\n   Path and Resv messages of protected
        and recovery LSPs.  Branch nodes\n   add NOTIFY_REQUEST objects to Path messages,
        and merge nodes add\n   NOTIFY_REQUEST objects to Resv messages.\n   When
        a node is branching or merging a recovery LSP, the node SHOULD\n   include
        a single NOTIFY_REQUEST object in the Path message of the\n   recovery LSP,
        in the case of a branch node, or the Resv message of\n   the recovery LSP,
        in the case of a merge node.  The notify node\n   address MUST be set to the
        router address of the processing node.\n   Branch and merge nodes SHOULD also
        add a NOTIFY_REQUEST object to the\n   LSP being protected.  For branch nodes,
        the notify node address is\n   set to the address used in the sender template
        object of the\n   associated recovery LSP.  For merge nodes, the notify node
        address is\n   set to the address used in the session object of the associated\n
        \  recovery LSP.  A locally added NOTIFY_REQUEST object MUST be listed\n   first
        in an outgoing message; any received NOTIFY_REQUEST objects\n   MUST then
        be listed in the message in the order that they were\n   received.  Note that
        this can result in a stack (or ordered list) of\n   objects.\n   Normal notification
        procedures are then followed for the LSP being\n   protected.  That is, the
        notifying node MUST issue a Notify message\n   to the recipient indicated
        by the notify address of the first listed\n   NOTIFY_REQUEST object.  Under
        local policy control, a node issuing a\n   Notify message MAY also send a
        Notify message to the Notify Node\n   Address indicated in the last, or any
        other, NOTIFY_REQUEST object\n   carried in the Path or Resv message.\n   Recovery
        LSP merge and branch nodes remove the object added by the\n   recovery branch
        or merge node from outgoing Path and Resv messages\n   for the LSP being protected.
        \ This is done by removing the\n   NOTIFY_REQUEST object that, in the case
        of a merge node, matches the\n   source address of the recovery LSP and, in
        the case of a branch node,\n   matches the tunnel endpoint address of the
        recovery LSP.  The\n   matching NOTIFY_REQUEST object will normally be the
        first of the\n   listed NOTIFY_REQUEST objects.  Note, to cover certain backwards\n
        \  compatibility scenarios, the NOTIFY_REQUEST object SHOULD NOT be\n   removed
        if it is the sole NOTIFY_REQUEST object.\n   Note this requires the following
        change to [RFC3473], Section 4.2.1:\n   o old text:\n      If a message contains
        multiple NOTIFY_REQUEST objects, only the\n      first object is meaningful.
        \ Subsequent NOTIFY_REQUEST objects MAY\n      be ignored and SHOULD NOT be
        propagated.\n   o new text:\n      If a message contains multiple NOTIFY_REQUEST
        objects, only the\n      first object used is in notification.  Subsequent
        NOTIFY_REQUEST\n      objects MUST be propagated in the order received.\n"
      title: 4.3.1.  Modified NOTIFY_REQUEST Object Processing
    - contents:
      - "4.3.2.  Modified Notify and Error Message Processing\n   Branch and merge
        nodes MUST support the following modification to\n   Notify message processing.
        \ When a branch or merge node receives\n   notification of an LSP failure
        and it is unable to recover from that\n   failure, it MUST notify the node
        indicated in the first\n   NOTIFY_REQUEST object received in the Path message
        (for branch nodes)\n   or Resv message (for merge nodes) associated with the
        LSP.\n"
      title: 4.3.2.  Modified Notify and Error Message Processing
    title: 4.3.  Teardown From Non-Ingress Nodes
  title: 4.  Explicit Control of LSP Segment Recovery
- contents:
  - "5.  Secondary Record Route Objects\n   Secondary Record Route objects, or SRROs,
    are used to record the path\n   used by recovery LSPs.\n"
  - contents:
    - "5.1.  Format\n   The format of a SECONDARY_RECORD_ROUTE object is the same
      as a\n   RECORD_ROUTE object, Class number 21.  This includes the definition\n
      \  of subobjects defined for RECORD_ROUTE object.  The class of the\n   SECONDARY_RECORD_ROUTE
      object is 201 (of the form 11bbbbbb).\n   The protection subobject defined above
      can also be used in\n   SECONDARY_RECORD_ROUTE objects.\n"
    title: 5.1.  Format
  - contents:
    - "5.2.  Path Processing\n   SRROs may be carried in Path messages and indicate
      the presence of\n   upstream recovery LSPs.  More than one SRRO MAY be added
      and present\n   in a Path message.\n   Any received SRRO MUST be transmitted
      by transit nodes, without\n   modification, in the corresponding outgoing Path
      message.\n   SRROs are inserted in Path messages by recovery LSP merge nodes.
      \ The\n   SRRO is created by copying the contents of an RRO received by the\n
      \  recovery LSP into a new SRRO object.  This SRRO is added to the\n   outgoing
      Path message of the recovered LSP.  Note that multiple SRROs\n   may be present.
      \ The collection of SRROs is controlled via the\n   segment-recording-desired
      flag in the SESSION_ATTRIBUTE object.  This\n   flag MAY be set even when SEROs
      are not used.\n"
    title: 5.2.  Path Processing
  - contents:
    - "5.3.  Resv Processing\n   SRROs may be carried in Resv messages and indicate
      the presence of\n   downstream recovery LSPs.  More than one SRRO MAY be added
      and\n   present in a Resv message.\n   Any received SRRO MUST be transmitted
      by transit nodes, without\n   modification, in the corresponding outgoing Resv
      message.  When Resv\n   messages are merged, the resulting merged Resv SHOULD
      contain all\n   SRROs received in downstream Resv messages.\n   SRROs are inserted
      in Resv messages by branch nodes of recovery LSPs.\n   The SRRO SHOULD be created
      with the first two objects being the local\n   node address, followed by a protection
      subobject with the contents of\n   the recovery LSP's PROTECTION object.  The
      remainder of the SRRO\n   SHOULD be created by copying the contents of the RRO
      received by the\n   recovery LSP.  This SRRO SHOULD be added to the outgoing
      Resv message\n   of the recovered LSP.  Again, multiple SRROs may be present.\n
      \  If the newly added SRRO causes the message to be too big to fit in a\n   Resv
      message, SRRO subobjects SHOULD be removed from any present\n   SRROs.  When
      removing subobjects, the first two subobjects and the\n   last subobject in
      an SRRO MUST NOT be removed.  Note that the\n   subobject that followed a removed
      subobject MUST be updated with the\n   L-bit set (1).  If after removing all
      but the first and last\n   subobjects in all SRROs the resulting message is
      still too large to\n   fit, then whole SRROs SHOULD be removed until the message
      does fit.\n"
    title: 5.3.  Resv Processing
  title: 5.  Secondary Record Route Objects
- contents:
  - "6.  Dynamic Control of LSP Segment Recovery\n   Dynamic identification of branch
    and merge nodes is supported via the\n   LSP Segment Recovery Flags carried in
    the PROTECTION object.  The LSP\n   Segment Recovery Flags are carried within
    one of the Reserved fields\n   defined in the PROTECTION object defined in [RFC4872].
    \ LSP Segment\n   Recovery Flags are used to indicate when LSP segment recovery
    is\n   desired.  When these bits are set, branch and merge nodes are\n   dynamically
    identified.\n   Note, the procedures defined in this section parallel the explicit\n
    \  control procedures defined above in Section 4.2.  The primary\n   difference
    is in the creation of a recovery LSP's ERO.\n"
  - contents:
    - "6.1.  Modified PROTECTION Object Format\n   LSP Segment Recovery Flags are
      carried in the PROTECTION object of\n   the same C-Type defined in [RFC4872].
      \ The format of the flags are:\n       0                   1                   2
      \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |            Length             | Class-Num(37) | C-Type (2)    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |S|P|N|O| Reserved  | LSP Flags |     Reserved      | Link Flags|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |I|R|   Reserved    | Seg.Flags |           Reserved            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     In-Place (I): 1 bit\n         When set (1) indicates that the desired
      segment recovery type\n         indicated in the LSP Segment Recovery Flag is
      already in place\n         for the associated LSP.\n      Required (R): 1 bit\n
      \        When set (1) indicates that failure to establish the indicated\n         protection
      should result in a failure of the LSP being\n         protected.\n      Segment
      Recovery Flags (Seg.Flags): 6 bits\n         This field is used to indicate
      when an upstream node desires\n         LSP Segment recovery to be dynamically
      initiated where\n         possible.  The values used in this field are identical
      to the\n         values defined for LSP Flags; see [RFC4872].\n   See [RFC4872]
      for the definition of other fields.\n"
    title: 6.1.  Modified PROTECTION Object Format
  - contents:
    - "6.2.  Dynamic Control Procedures\n   LSP Segment Recovery Flags are set to
      indicate that LSP segment\n   recovery is desired for the LSP being signaled.
      \ The type of recovery\n   desired is indicated by the flags.  The decision
      to set the LSP\n   Segment Recovery Flags is a local matter and outside the
      scope of\n   this document.  A value of zero (0) means that no dynamic\n   identification
      of segment recovery branch nodes are needed for the\n   associated LSP.  When
      the In-Place bit is set, it means that the\n   desired type of recovery is already
      in place for that particular LSP.\n   A transit node receiving a Path message
      containing a PROTECTION\n   object with a non-zero LSP Segment Recovery Flags
      value and the In-\n   Place bit clear (0) SHOULD consider if it can support
      the indicated\n   recovery type and if it can identify an appropriate merge
      node for a\n   recovery LSP.  Dynamic identification MUST NOT be done when the\n
      \  processing node is identified as a branch node in an SERO.  If a node\n   is
      unable to provide the indicated recovery type or identify a merge\n   node,
      the Path message MUST be processed normally, and the LSP\n   Segment Recovery
      Flags MUST NOT be modified.\n   When a node dynamically identifies itself as
      a branch node and\n   identifies the merge node for the type of recovery indicated
      in the\n   LSP Segment Recovery Flags, it attempts to setup a recovery LSP.
      \ The\n   dynamically identified information, together with the Path message
      of\n   LSP being recovered, is used to create the recovery LSP.\n   The Path
      message for the recovery LSP is created at the branch node\n   by cloning the
      objects carried in the incoming Path message of the\n   LSP being protected.
      \ Certain objects are replaced or modified in the\n   recovery LSP's outgoing
      Path message.  The Sender_template object\n   MUST be updated to use an address
      (in its Tunnel Sender Address\n   field) on the local node, and the LSP ID MUST
      be updated to ensure\n   uniqueness.  The Session object MUST be updated to
      use the address of\n   the dynamically identified merge node as the tunnel endpoint
      address,\n   the tunnel ID MAY be updated, and the extended tunnel ID MUST be
      set\n   to the local node address.  The PROTECTION object is updated with the\n
      \  In-Place bit set (1).  Any RROs and EROs present in the incoming Path\n   message
      MUST NOT be included in the recovery LSP.  A new ERO MAY be\n   created based
      on any path information dynamically computed by the\n   local node.\n   The
      resulting Path message is used to create the recovery LSP.  While\n   the recovery
      LSP exists, the PROTECTION object in the original Path\n   message  (unless
      overridden by local policy) MUST also be updated\n   with the In-Place bit set
      (1).  From this point on, Standard Path\n   message processing is used in processing
      the resulting and original\n   Path messages.\n   The merge node of a dynamically
      controlled recovery LSP SHOULD reset\n   (0) the In-Place bit in the PROTECTION
      object of the outgoing Path\n   message associated with the terminated recovery
      LSP.\n   Unlike with explicit control, if the creation of a dynamically\n   identified
      recovery LSP fails for any reason, the recovery LSP is\n   removed, and no error
      message or indication is sent upstream.  With\n   this exception, all the other
      procedures for explicitly controlled\n   recovery LSPs apply to dynamically
      controlled recovery LSPs.  These\n   other procedures are defined above in Sections
      4.2.1 through 4.2.4.\n"
    title: 6.2.  Dynamic Control Procedures
  title: 6.  Dynamic Control of LSP Segment Recovery
- contents:
  - "7.  Updated RSVP Message Formats\n   This section presents the RSVP message related
    formats as modified by\n   this document.  Where they differ, formats for unidirectional
    LSPs\n   are presented separately from bidirectional LSPs.\n   The format of a
    Path message is as follows:\n   <Path Message> ::=   <Common Header> [ <INTEGRITY>
    ]\n                        [ [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                        [
    <MESSAGE_ID> ]\n                        <SESSION> <RSVP_HOP>\n                        <TIME_VALUES>\n
    \                       [ <EXPLICIT_ROUTE> ]\n                         <LABEL_REQUEST>\n
    \                        [ <PROTECTION> ]\n                         [ <LABEL_SET>
    ... ]\n                         [ <SESSION_ATTRIBUTE> ]\n                         [
    <NOTIFY_REQUEST> ... ]\n                         [ <ADMIN_STATUS> ]\n                         [
    <ASSOCIATION> ... ]\n                         [ <SECONDARY_EXPLICIT_ROUTE> ...
    ]\n                         [ <POLICY_DATA> ... ]\n                         <sender
    descriptor>\n   The format of the sender description for unidirectional LSPs is:\n
    \  <sender descriptor> ::=  <SENDER_TEMPLATE> <SENDER_TSPEC>\n                            [
    <ADSPEC> ]\n                            [ <RECORD_ROUTE> ]\n                            [
    <SUGGESTED_LABEL> ]\n                            [ <RECOVERY_LABEL> ]\n                            [
    <SECONDARY_RECORD_ROUTE> ... ]\n   The format of the sender description for bidirectional
    LSPs is:\n   <sender descriptor> ::=  <SENDER_TEMPLATE> <SENDER_TSPEC>\n                            [
    <ADSPEC> ]\n                            [ <RECORD_ROUTE> ]\n                            [
    <SUGGESTED_LABEL> ]\n                            [ <RECOVERY_LABEL> ]\n                            <UPSTREAM_LABEL>\n
    \                           [ <SECONDARY_RECORD_ROUTE> ... ]\n   The format of
    a PathErr message is as follows:\n   <PathErr Message> ::= <Common Header> [ <INTEGRITY>
    ]\n                         [ [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>] ... ]\n                         [
    <MESSAGE_ID> ]\n                         <SESSION> <ERROR_SPEC>\n                         [
    <ACCEPTABLE_LABEL_SET> ... ]\n                         [ <SECONDARY_EXPLICIT_ROUTE>
    ... ]\n                         [ <POLICY_DATA> ... ]\n                         <sender
    descriptor>\n   The format of a Resv message is as follows:\n   <Resv Message>
    ::=    <Common Header> [ <INTEGRITY> ]\n                         [ [<MESSAGE_ID_ACK>
    | <MESSAGE_ID_NACK>] ... ]\n                         [ <MESSAGE_ID> ]\n                         <SESSION>
    <RSVP_HOP>\n                         <TIME_VALUES>\n                         [
    <RESV_CONFIRM> ]  [ <SCOPE> ]\n                         [ <NOTIFY_REQUEST> ...
    ]\n                         [ <ADMIN_STATUS> ]\n                         [ <POLICY_DATA>
    ... ]\n                         <STYLE> <flow descriptor list>\n   <flow descriptor
    list> ::= <FF flow descriptor list>\n                            | <SE flow descriptor>\n
    \  <FF flow descriptor list> ::= <FLOWSPEC> <FILTER_SPEC>\n                            <LABEL>
    [ <RECORD_ROUTE> ]\n                            [ <SECONDARY_RECORD_ROUTE> ...
    ]\n                            | <FF flow descriptor list>\n                            <FF
    flow descriptor>\n   <FF flow descriptor> ::= [ <FLOWSPEC> ] <FILTER_SPEC> <LABEL>\n
    \                           [ <RECORD_ROUTE> ]\n                            [
    <SECONDARY_RECORD_ROUTE> ... ]\n   <SE flow descriptor> ::= <FLOWSPEC> <SE filter
    spec list>\n   <SE filter spec list> ::= <SE filter spec>\n                            |
    <SE filter spec list> <SE filter spec>\n   <SE filter spec> ::=     <FILTER_SPEC>
    <LABEL> [ <RECORD_ROUTE> ]\n                            [ <SECONDARY_RECORD_ROUTE>
    ... ]\n"
  title: 7.  Updated RSVP Message Formats
- contents:
  - "8.  Security Considerations\n   This document introduces new message objects
    for use in GMPLS\n   signaling [RFC3473].  It does not introduce any new signaling\n
    \  messages, nor change the relationship between LSRs that are adjacent\n   in
    the control plane.\n   The procedures defined in this document result in an increase
    in the\n   amount of topology information carried in signaling messages since\n
    \  the presence of SEROs and SRROs necessarily means that there is more\n   information
    about LSP paths carried than in simple EROs and RROs.\n   Thus, in the event of
    the interception of a signaling message,\n   slightly more could be deduced about
    the state of the network than\n   was previously the case, but this is judged
    to be a very minor\n   security risk as this information is already available
    via routing.\n   Otherwise, this document introduces no additional security\n
    \  considerations.  See [RFC3473] for relevant security considerations.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   IANA has assigned the following values for the namespaces
    defined in\n   this document and reviewed in this section.\n"
  - contents:
    - "9.1.  New Association Type Assignment\n   IANA has made the following assignment
      to the \"GMPLS Signaling\n   Parameters\" Registry (see [RFC4872]) located at\n
      \  http://www.iana.org/assignments/gmpls-sig-parameters.\n      Value       Type\n
      \     -----       ----\n        2         Resource Sharing (R) [RFC4873]\n"
    title: 9.1.  New Association Type Assignment
  - contents:
    - "9.2.  Definition of PROTECTION Object Reserved Bits\n   This document defines
      bits carried in the Reserved field of the\n   PROTECTION object defined in [RFC4872].
      \ As no IANA registry for\n   these bits is requested in [RFC4872], no IANA
      action is required\n   related to this definition.\n"
    title: 9.2.  Definition of PROTECTION Object Reserved Bits
  - contents:
    - "9.3.  Secondary Explicit Route Object\n   IANA has made the following assignments
      in the \"Class Names, Class\n   Numbers, and Class Types\" section of the \"RSVP
      PARAMETERS\" registry\n   located at http://www.iana.org/assignments/rsvp-parameters.\n
      \  A new class named SECONDARY_EXPLICIT_ROUTE has been created in the\n   11bbbbbb
      range (200) with the following definition:\n      Class Types or C-types:\n
      \     Same values as EXPLICIT_ROUTE object (C-Num 20)\n      For Class 1, C-Type
      1, the following additional Subobject type is\n      defined:\n         37   PROTECTION
      \             [RFC4873]\n"
    title: 9.3.  Secondary Explicit Route Object
  - contents:
    - "9.4.  Secondary Record Route Object\n   IANA has made the following assignments
      in the \"Class Names, Class\n   Numbers, and Class Types\" section of the \"RSVP
      PARAMETERS\" registry\n   located at http://www.iana.org/assignments/rsvp-parameters.\n
      \  A new class named SECONDARY_RECORD_ROUTE has been created in the\n   11bbbbbb
      range (201) with the following definition:\n      Class Types or C-types:\n
      \     Same values as RECORD_ROUTE object (C-Num 21)\n      For Class 1, C-Type
      1, the following additional Subobject type is\n      defined:\n         37   PROTECTION
      \             [RFC4873]\n"
    title: 9.4.  Secondary Record Route Object
  - contents:
    - "9.5.  New Error Code\n   IANA has made the following assignments in the \"Routing
      Problem\"\n   subsection of \"Error Codes and Values\" section of the \"RSVP\n
      \  PARAMETERS\" registry located at\n   http://www.iana.org/assignments/rsvp-parameters.\n
      \  21 = LSP Segment Protection Failed [RFC4873]\n"
    title: 9.5.  New Error Code
  - contents:
    - "9.6.  Use of PROTECTION Object C-type\n   This document modifies the PROTECTION
      object, class number 37, C-Type\n   2 (defined in Section 14.1. of [RFC4872]).\n"
    title: 9.6.  Use of PROTECTION Object C-type
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use
      in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC2205]   Braden, R., Zhang, L., Berson, S., Herzog, S., and
      S.\n               Jamin, \"Resource ReSerVation Protocol (RSVP) -- Version
      1\n               Functional Specification\", RFC 2205, September 1997.\n   [RFC3209]
      \  Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan, V.,\n               and
      G. Swallow, \"RSVP-TE: Extensions to RSVP for LSP\n               Tunnels\",
      RFC 3209, December 2001.\n   [RFC3471]   Berger, L., Ed., \"Generalized Multi-Protocol
      Label\n               Switching (GMPLS) Signaling Functional Description\",
      RFC\n               3471, January 2003.\n   [RFC3473]   Berger, L., Ed., \"Generalized
      Multi-Protocol Label\n               Switching (GMPLS) Signaling - Resource
      ReserVation\n               Protocol-Traffic Engineering (RSVP-TE) Extensions\",
      RFC\n               3473, January 2003.\n   [RFC4872]   Lang, J.P., Ed., Rekhter,
      Y., Ed., and D. Papadimitriou,\n               Ed., \"RSVP-TE Extensions in
      support of End-to-End\n               Generalized Multi-Protocol Label Switching
      (GMPLS)\n               Recovery\", RFC 4872, May 2007.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC4090]   Pan, P., Swallow, G., and A.
      Atlas, \"Fast Reroute\n               Extensions to RSVP-TE for LSP Tunnels\",
      RFC 4090, May\n               2005.\n   [RFC4426]   Lang, J., Ed., Rajagopalan,
      B., Ed., and D.\n               Papadimitriou, Ed., \"Generalized Multi-Protocol
      Label\n               Switching (GMPLS) Recovery Functional Specification,\"
      RFC\n               4426, March 2006.\n   [RFC4427]   Mannie, E., Ed., and D.
      Papadimitriou, Ed., \"Recovery\n               (Protection and Restoration)
      Terminology for Generalized\n               Multi-Protocol Label Switching (GMPLS)\",
      RFC 4427, March\n               2006.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Authors' Addresses\n   Lou Berger\n   LabN Consulting, L.L.C.\n   Phone:  +1
    301-468-9228\n   EMail:  lberger@labn.net\n   Igor Bryskin\n   ADVA Optical\n
    \  7926 Jones Branch Drive\n   Suite 615\n   McLean VA, 22102\n   EMail:  IBryskin@advaoptical.com\n
    \  Dimitri Papadimitriou\n   Alcatel\n   Francis Wellesplein 1\n   B-2018 Antwerpen,
    Belgium\n   Phone:  +32 3 240-8491\n   EMail:  dimitri.papadimitriou@alcatel-lucent.be\n
    \  Adrian Farrel\n   Old Dog Consulting\n   Phone:  +44 (0) 1978 860944\n   EMail:
    \ adrian@olddog.co.uk\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
