- title: __initial_text__
  contents:
  - '          PKCS #12: Personal Information Exchange Syntax v1.1

    '
- title: Abstract
  contents:
  - "Abstract\n   PKCS #12 v1.1 describes a transfer syntax for personal identity\n\
    \   information, including private keys, certificates, miscellaneous\n   secrets,\
    \ and extensions.  Machines, applications, browsers, Internet\n   kiosks, and\
    \ so on, that support this standard will allow a user to\n   import, export, and\
    \ exercise a single set of personal identity\n   information.  This standard supports\
    \ direct transfer of personal\n   information under several privacy and integrity\
    \ modes.\n   This document represents a republication of PKCS #12 v1.1 from RSA\n\
    \   Laboratories' Public Key Cryptography Standard (PKCS) series.  By\n   publishing\
    \ this RFC, change control is transferred to the IETF.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   The IESG thanks RSA Laboratories for transferring change control\
    \ to\n   the IETF.  Enhancements to this specification that preserve backward\n\
    \   compatibility are expected in an upcoming IETF Standards Track\n   document.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7292.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Changes from PKCS #12 Version 1 . . . . . . . . .\
    \ . . . .   4\n   2.  Definitions and Notation  . . . . . . . . . . . . . . .\
    \ . . .   5\n   3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   7\n     3.1.  Exchange Modes  . . . . . . . . . . . . . . . . . . . .\
    \ .   7\n     3.2.  Mode Choice Policies  . . . . . . . . . . . . . . . . . .\
    \   8\n     3.3.  Trusted Public Keys . . . . . . . . . . . . . . . . . . .  \
    \ 8\n     3.4.  The AuthenticatedSafe . . . . . . . . . . . . . . . . . .   9\n\
    \   4.  PFX PDU Syntax  . . . . . . . . . . . . . . . . . . . . . . .  10\n  \
    \   4.1.  The AuthenticatedSafe Type  . . . . . . . . . . . . . . .  11\n    \
    \ 4.2.  The SafeBag Type  . . . . . . . . . . . . . . . . . . . .  12\n      \
    \ 4.2.1.  The KeyBag Type . . . . . . . . . . . . . . . . . . .  13\n       4.2.2.\
    \  The PKCS8ShroudedKeyBag Type  . . . . . . . . . . . .  13\n       4.2.3.  The\
    \ CertBag Type  . . . . . . . . . . . . . . . . . .  13\n       4.2.4.  The CRLBag\
    \ Type . . . . . . . . . . . . . . . . . . .  14\n       4.2.5.  The SecretBag\
    \ Type  . . . . . . . . . . . . . . . . .  14\n       4.2.6.  The SafeContents\
    \ Type . . . . . . . . . . . . . . . .  14\n   5.  Using PFX PDUs  . . . . . .\
    \ . . . . . . . . . . . . . . . . .  15\n     5.1.  Creating PFX PDUs . . . .\
    \ . . . . . . . . . . . . . . . .  15\n     5.2.  Importing Keys, etc., from a\
    \ PFX PDU  . . . . . . . . . .  16\n   6.  Security Considerations . . . . . .\
    \ . . . . . . . . . . . . .  16\n   7.  Normative References  . . . . . . . .\
    \ . . . . . . . . . . . .  17\n   Appendix A.  Message Authentication Codes (MACs)\
    \  . . . . . . . .  19\n   Appendix B.  Deriving Keys and IVs from Passwords and\
    \ Salt  . . .  19\n     B.1.  Password Formatting . . . . . . . . . . . . . .\
    \ . . . . .  19\n     B.2.  General Method  . . . . . . . . . . . . . . . . .\
    \ . . . .  20\n     B.3.  More on the ID Byte . . . . . . . . . . . . . . . .\
    \ . . .  22\n     B.4.  Keys for Password Integrity Mode  . . . . . . . . . .\
    \ . .  22\n   Appendix C.  Keys and IVs for Password Privacy Mode . . . . . .\
    \ .  22\n   Appendix D.  ASN.1 Module . . . . . . . . . . . . . . . . . . . .\
    \  24\n   Appendix E.  Intellectual Property Considerations . . . . . . . .  28\n\
    \   Appendix F.  Acknowledgments  . . . . . . . . . . . . . . . . . .  28\n  \
    \ Appendix G.  About PKCS . . . . . . . . . . . . . . . . . . . . .  28\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document represents a republication of PKCS #12 v1.1\
    \ from RSA\n   Laboratories' Public Key Cryptography Standard (PKCS) series. \
    \ By\n   publishing this RFC, change control is transferred to the IETF.  RSA\n\
    \   and its parent company EMC reserve the right to continue publishing\n   and\
    \ distributing PKCS #12 v1.1 and its predecessors.\n   The body of this document,\
    \ except for the Security Considerations\n   section, is taken directly from the\
    \ PKCS #12 v1.1 specification.  The\n   list of references and the in-line cites\
    \ have been updated or added\n   where appropriate to cite the most current documents\
    \ in addition to\n   those current at the original publication of PKCS #12 v1.1.\n\
    \   This standard describes a transfer syntax for personal identity\n   information,\
    \ including private keys, certificates, miscellaneous\n   secrets, and extensions.\
    \  Machines, applications, browsers, Internet\n   kiosks, and so on, that support\
    \ this standard will allow a user to\n   import, export, and exercise a single\
    \ set of personal identity\n   information.\n   This standard supports direct\
    \ transfer of personal information under\n   several privacy and integrity modes.\
    \  The most secure of the privacy\n   and integrity modes require the source and\
    \ destination platforms to\n   have trusted public/private key pairs usable for\
    \ digital signatures\n   and encryption, respectively.  The standard also supports\
    \ lower-\n   security, password-based privacy and integrity modes for those cases\n\
    \   where trusted public/private key pairs are not available.\n   This standard\
    \ should be amenable to both software and hardware\n   implementations.  Hardware\
    \ implementations offer physical security in\n   tamper-resistant tokens such\
    \ as smart cards and Personal Computer\n   Memory Card International Association\
    \ (PCMCIA) devices.\n   This standard can be viewed as building on PKCS #8 [15]\
    \ [24] by\n   including essential but ancillary identity information along with\n\
    \   private keys and by instituting higher security through public-key\n   privacy\
    \ and integrity modes.\n"
- title: '1.1.  Changes from PKCS #12 Version 1'
  contents:
  - "1.1.  Changes from PKCS #12 Version 1\n   This document transfers PKCS #12 [16]\
    \ into the IETF and includes some\n   minor changes from the authors for this\
    \ submission.\n   o  Addition of hash algorithms.\n   o  Incorporation of Technical\
    \ Corrigendum #1, which makes some minor\n      corrections to the ASN.1 syntax.\n\
    \   o  Removed (from the ASN.1 syntax) 1024 as an example of the\n      iteration\
    \ count.\n   o  Addition of a recommendation that the technique in Appendix B\
    \ no\n      longer be used for a specific mode (password privacy mode) and\n \
    \     that techniques from PKCS#5 v2.1 be used instead.\n   o  Addition of comments\
    \ and minor corrections to the ASN.1 module in\n      Appendix C.\n   o  Removal\
    \ of the export regulations discussion in the former\n      Appendix D.\n   o\
    \  Replacement of RSA with EMC in the \"Intellectual Property\n      Considerations\"\
    .\n   o  Many changes and additions to the references.\n   o  A reference was\
    \ added to NIST SP 800-132 for its recommendations\n      on selection of the\
    \ iteration count value for password integrity\n      (part of dictionary-attack\
    \ resistance).\n   o  Comment included on acronym expansion of PFX: The acronym\
    \ is\n      sometimes expanded as Personal Information Exchange.\n   o  In Appendix\
    \ B, the phrase \"no longer recommended\" was changed to\n      \"not recommended\"\
    \ in the following sentence to address a question\n      and make it clear the\
    \ method was not recommended: \"Note that this\n      method for password privacy\
    \ mode is no longer recommended.\"\n"
- title: 2.  Definitions and Notation
  contents:
  - "2.  Definitions and Notation\n   AlgorithmIdentifier:  An ASN.1 type that identifies\
    \ an algorithm (by\n      an object identifier) and any associated parameters.\
    \  This type is\n      defined in [8].\n   ASN.1:  Abstract Syntax Notation One,\
    \ as defined in [2], [3], [4],\n      and [5].\n   Attribute:  An ASN.1 type that\
    \ identifies an attribute type (by an\n      object identifier) and an associated\
    \ attribute value.  The ASN.1\n      type Attribute is defined in [7].\n   Certificate:\
    \  A digitally signed data unit binding a public key to\n      identity information.\
    \  A specific format for identity certificates\n      is defined in [8].  Another\
    \ format is described in [17].\n   Certificate Revocation List (CRL):  A digitally\
    \ signed list of\n      certificates that should no longer be honored, having\
    \ been revoked\n      by the issuers or a higher authority.  One format for CRLs\
    \ is\n      defined in [8].\n   ContentInfo:  An ASN.1 type used to hold data\
    \ that may have been\n      cryptographically protected.  This type is defined\
    \ in [21] and\n      [14].\n   DER:  Distinguished Encoding Rules, as defined\
    \ in [6].\n   Destination platform:  The ultimate, final target platform for the\n\
    \      personal information originating from the source platform.  Even\n    \
    \  though certain information may be transported from the destination\n      platform\
    \ to the source platform, the ultimate target for personal\n      information\
    \ is always called the destination platform.\n   DigestInfo:  An ASN.1 type used\
    \ to hold a message digest.  This type\n      is defined in [21] and [14].\n \
    \  Encryption Key Pair (DestEncK):  A public/private key pair used for\n     \
    \ the public-key privacy mode of this standard.  The public half is\n      called\
    \ PDestEncK (TPDestEncK when emphasizing that the public key\n      is \"trusted\"\
    ), and the private half is called VDestEncK.\n   Export time:  The time that a\
    \ user reads personal information from a\n      source platform and transforms\
    \ the information into an\n      interoperable, secure Protocol Data Unit (PDU).\n\
    \   Import time:  The time that a user writes personal information from a\n  \
    \    Safe PDU to a destination platform.\n   Message Authentication Code (MAC):\
    \  A type of collision-resistant,\n      \"unpredictable\" function of a message\
    \ and a secret key.  MACs are\n      used for data authentication and are akin\
    \ to secret-key digital\n      signatures in many respects.\n   Object Identifier:\
    \  A sequence of integers that uniquely identifies\n      an associated data object\
    \ in a global name space administrated by\n      a hierarchy of naming authorities.\
    \  This is a primitive data type\n      in ASN.1.\n   PFX:  The top-level exchange\
    \ PDU defined in this standard.  The\n      acronym is sometimes expanded as Personal\
    \ Information Exchange.\n   Platform:  A combination of machine, operating system,\
    \ and\n      applications software within which the user exercises personal\n\
    \      identity.  An application, in this context, is software that uses\n   \
    \   personal information.  Two platforms differ if their machine types\n     \
    \ differ or if their applications software differs.  There is at\n      least\
    \ one platform per user in multi-user systems.\n   Protocol Data Unit (PDU): \
    \ A sequence of bits in machine-independent\n      format constituting a message\
    \ in a protocol.\n   Shrouding:  Encryption as applied to private keys, possibly\
    \ in\n      concert with a policy that prevents the plaintext of the key from\n\
    \      ever being visible beyond a certain, well-defined interface.\n   Signature\
    \ Key Pair (SrcSigK):  A platform-specific signature key pair\n      used for\
    \ the public-key integrity mode of this standard.  The\n      public half is called\
    \ PSrcSigK (TPSrcSigK when emphasizing that\n      the public key is \"trusted\"\
    ), and the private half is called\n      VSrcSigK.\n   Source platform:  The origin\
    \ platform of the personal information\n      ultimately intended for the destination\
    \ platform.  Even though\n      certain information may be transported from the\
    \ destination\n      platform to the source platform, the platform that is the\
    \ origin\n      of personal information is always called the source platform.\n"
- title: 3.  Overview
  contents:
  - '3.  Overview

    '
- title: 3.1.  Exchange Modes
  contents:
  - "3.1.  Exchange Modes\n   There are four combinations of privacy modes and integrity\
    \ modes.\n   The privacy modes use encryption to protect personal information\
    \ from\n   exposure, and the integrity modes protect personal information from\n\
    \   tampering.  Without protection from tampering, an adversary could\n   conceivably\
    \ substitute invalid information for the user's personal\n   information without\
    \ the user being aware of the substitution.\n   The following are the privacy\
    \ modes:\n   o  Public-key privacy mode: Personal information is enveloped on\
    \ the\n      source platform using a trusted encryption public key of a known\n\
    \      destination platform (see Section 3.3).  The envelope is opened\n     \
    \ with the corresponding private key.\n   o  Password privacy mode: Personal information\
    \ is encrypted with a\n      symmetric key derived from a user name and a privacy\
    \ password, as\n      in [22] and [13].  If password integrity mode is used as\
    \ well, the\n      privacy password and the integrity password may or may not\
    \ be the\n      same.\n   The following are the integrity modes:\n   o  Public-key\
    \ integrity mode: Integrity is guaranteed through a\n      digital signature on\
    \ the contents of the PFX PDU, which is\n      produced using the source platform's\
    \ private signature key.  The\n      signature is verified on the destination\
    \ platform by using the\n      corresponding public key (see Section 3.4).\n \
    \  o  Password integrity mode: Integrity is guaranteed through a Message\n   \
    \   Authentication Code (MAC) derived from a secret integrity\n      password.\
    \  If password privacy mode is used as well, the privacy\n      password and the\
    \ integrity password may or may not be the same.\n"
- title: 3.2.  Mode Choice Policies
  contents:
  - "3.2.  Mode Choice Policies\n   All combinations of the privacy and integrity\
    \ modes are permitted in\n   this standard.  Of course, good security policy suggests\
    \ that certain\n   practices be avoided, e.g., it can be unwise to transport private\n\
    \   keys without physical protection when using password privacy mode or\n   when\
    \ using public-key privacy mode with weak symmetric encryption.\n   In general,\
    \ the public-key modes for both privacy and integrity are\n   preferable to the\
    \ password modes (from a security viewpoint).\n   However, it is not always possible\
    \ to use the public-key modes.  For\n   example, it may not be known at export\
    \ time what the destination\n   platform is; if this is the case, then the use\
    \ of the public-key\n   privacy mode is precluded.\n"
- title: 3.3.  Trusted Public Keys
  contents:
  - "3.3.  Trusted Public Keys\n   Asymmetric key pairs may be used in this standard\
    \ in two ways:\n   public-key privacy mode and public-key integrity mode.  For\
    \ public-\n   key privacy mode, an encryption key pair is required; for public-key\n\
    \   integrity mode, a signature key pair is required.\n   It may be appropriate\
    \ for the keys discussed in this section to be\n   platform-specific keys dedicated\
    \ solely for the purpose of\n   transporting a user's personal information.  Whether\
    \ or not that is\n   the case, though, the keys discussed here should not be confused\
    \ with\n   the user's personal keys that the user wishes to transport from one\n\
    \   platform to another.  (These latter keys are stored within the PDU.)\n   For\
    \ public-key privacy mode, the private key from the encryption key\n   pair is\
    \ kept on the destination platform, where it is ultimately used\n   to open a\
    \ private envelope.  The corresponding trusted public key is\n   called TPDestEncK.\n\
    \   For public-key integrity mode, the private key from the signature\n   pair\
    \ is kept on the source platform, where it is used to sign\n   personal information.\
    \  The corresponding trusted public key is called\n   TPSrcSigK.\n   For both\
    \ uses of public/private key pairs, the public key from the\n   key pair must\
    \ be transported to the other platform such that it is\n   trusted to have originated\
    \ at the correct platform.  Judging whether\n   or not a public key is trusted\
    \ in this sense must ultimately be left\n   to the user.  There are a variety\
    \ of methods for ensuring that a\n   public key is trusted.\n   The processes\
    \ of imbuing keys with trust and of verifying\n   trustworthiness of keys are\
    \ not discussed further in this document.\n   Whenever asymmetric keys are discussed\
    \ in what follows, the public\n   keys are assumed to be trusted.\n"
- title: 3.4.  The AuthenticatedSafe
  contents:
  - "3.4.  The AuthenticatedSafe\n   Each compliant platform shall be able to import\
    \ and export\n   AuthenticatedSafe PDUs wrapped in PFX PDUs.\n   For integrity,\
    \ the AuthenticatedSafe is either signed (if public-key\n   integrity mode is\
    \ used) or MACed (if password integrity mode is used)\n   to produce a PFX PDU.\
    \  If the AuthenticatedSafe is signed, then it is\n   accompanied by a digital\
    \ signature, which was produced on the source\n   platform with a private signature\
    \ key, VSrcSigK, corresponding to a\n   trusted public signature key, TPSrcSigK.\
    \  TPSrcSigK must accompany\n   the PFX to the destination platform, where the\
    \ user can verify the\n   trust in the key and can verify the signature on the\n\
    \   AuthenticatedSafe.  If the AuthenticatedSafe is MACed, then it is\n   accompanied\
    \ by a MAC computed from a secret integrity password, salt\n   bits, an iteration\
    \ count, and the contents of the AuthenticatedSafe.\n   The AuthenticatedSafe\
    \ itself consists of a sequence of ContentInfo\n   values, some of which may consist\
    \ of plaintext (data), and others\n   that may either be enveloped (if public-key\
    \ privacy mode is used) or\n   encrypted (if password privacy mode is used). \
    \ If the contents are\n   enveloped, then they are encrypted with a symmetric\
    \ cipher under a\n   freshly generated key, which is in turn encrypted with RSA\
    \ asymmetric\n   encryption.  The RSA public key used to encrypt the symmetric\
    \ key is\n   called TPDestEncK and corresponds to an RSA private key, VDestEncK,\n\
    \   on the destination platform.  TPDestEncK needs to be trusted by the\n   user\
    \ when it is used at export time.  If the contents are encrypted,\n   then they\
    \ are encrypted with a symmetric cipher under a key derived\n   from a secret\
    \ privacy password, salt bits, and an iteration counter.\n   Each ContentInfo\
    \ contains an arbitrary collection of private keys,\n   PKCS #8-shrouded private\
    \ keys, certificates, CRLs, or opaque data\n   objects, at the user's discretion,\
    \ stored in values of type\n   SafeContents.\n   The raison d'etre for the unencrypted\
    \ option is that some governments\n   restrict certain uses of cryptography. \
    \ Having several parts in an\n   AuthenticatedSafe keeps implementers' options\
    \ open.  For example, it\n   may be the case that strong cryptography can be used\
    \ to make PKCS\n   #8-shrouded keys, but then these shrouded keys should not be\
    \ further\n   encrypted, because super-encryption can limit a product's\n   exportability.\
    \  The multi-part AuthenticatedSafe design permits this\n   possibility.\n   Around\
    \ the AuthenticatedSafe is the integrity-mode wrapper, which\n   protects the\
    \ entire contents of the AuthenticatedSafe (including\n   unencrypted parts, if\
    \ they are present).  This is the reverse of the\n   wrapping order in many protocols,\
    \ in which privacy is the outermost\n   protection.  This latter, more-common\
    \ wrapping order avoids\n   signatures on encrypted data, which are undesirable\
    \ under certain\n   circumstances; however, these circumstances do not apply to\
    \ this\n   document, and it is therefore preferable to protect the integrity of\n\
    \   as much information as possible.\n"
- title: 4.  PFX PDU Syntax
  contents:
  - "4.  PFX PDU Syntax\n   This format corresponds to the data model presented above,\
    \ with\n   wrappers for privacy and integrity.  This section makes free\n   reference\
    \ to PKCS #7 [14] [21] and assumes the reader is familiar\n   with terms defined\
    \ in that document.\n   All modes of direct exchange use the same PDU format.\
    \  ASN.1 and BER-\n   encoding ensure platform independence.\n   This standard\
    \ has one ASN.1 export: PFX.  This is the outer integrity\n   wrapper.  Instances\
    \ of PFX contain:\n   1.  A version indicator.  The version shall be v3 for this\
    \ version of\n       this document.\n   2.  A PKCS #7 ContentInfo, whose contentType\
    \ is signedData in public-\n       key integrity mode and data in password integrity\
    \ mode.\n   3.  An optional instance of MacData, present only in password\n  \
    \     integrity.  This object, if present, contains a PKCS #7\n       DigestInfo,\
    \ which holds the MAC value, a macSalt, and an\n       iterationCount.  As described\
    \ in Appendix B, the MAC key is\n       derived from the password, the macSalt,\
    \ and the iterationCount;\n       as described in Section 5, the MAC is computed\
    \ from the authSafe\n       value and the MAC key via HMAC [11] [20].  The password\
    \ and the\n       MAC key are not actually present anywhere in the PFX.  The salt\n\
    \       and (to a certain extent) the iteration count thwarts dictionary\n   \
    \    attacks against the integrity password.  See NIST Special\n       Publication\
    \ 800-132 [12] about how to choose a reasonable value\n       for the iteration\
    \ count.\n   PFX ::= SEQUENCE {\n       version     INTEGER {v3(3)}(v3,...),\n\
    \       authSafe    ContentInfo,\n       macData     MacData OPTIONAL\n   }\n\
    \   MacData ::= SEQUENCE {\n       mac         DigestInfo,\n       macSalt   \
    \  OCTET STRING,\n       iterations  INTEGER DEFAULT 1\n       -- Note: The default\
    \ is for historical reasons and its\n       --       use is deprecated.\n   }\n"
- title: 4.1.  The AuthenticatedSafe Type
  contents:
  - "4.1.  The AuthenticatedSafe Type\n   As mentioned, the contentType field of authSafe\
    \ shall be of type data\n   or signedData.  The content field of the authSafe\
    \ shall, either\n   directly (data case) or indirectly (signedData case), contain\
    \ a BER-\n   encoded value of type AuthenticatedSafe.\n   AuthenticatedSafe ::=\
    \ SEQUENCE OF ContentInfo\n       -- Data if unencrypted\n       -- EncryptedData\
    \ if password-encrypted\n       -- EnvelopedData if public key-encrypted\n   An\
    \ AuthenticatedSafe contains a sequence of ContentInfo values.  The\n   content\
    \ field of these ContentInfo values contains either plaintext,\n   encrypted,\
    \ or enveloped data.  In the case of encrypted or enveloped\n   data, the plaintext\
    \ of the data holds the BER-encoding of an instance\n   of SafeContents.  Section\
    \ 5.1 of this document describes the\n   construction of values of type AuthenticatedSafe\
    \ in more detail.\n"
- title: 4.2.  The SafeBag Type
  contents:
  - "4.2.  The SafeBag Type\n   The SafeContents type is made up of SafeBags.  Each\
    \ SafeBag holds one\n   piece of information -- a key, a certificate, etc. --\
    \ which is\n   identified by an object identifier.\n SafeContents ::= SEQUENCE\
    \ OF SafeBag\n SafeBag ::= SEQUENCE {\n     bagId          BAG-TYPE.&id ({PKCS12BagSet})\n\
    \     bagValue       [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n  \
    \   bagAttributes  SET OF PKCS12Attribute OPTIONAL\n }\n PKCS12Attribute ::= SEQUENCE\
    \ {\n     attrId      ATTRIBUTE.&id ({PKCS12AttrSet}),\n     attrValues  SET OF\
    \ ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n } -- This type is compatible with\
    \ the X.500 type 'Attribute'\n PKCS12AttrSet ATTRIBUTE ::= {\n     friendlyName\
    \ | -- from PKCS #9 [23]\n     localKeyId,    -- from PKCS #9\n     ... -- Other\
    \ attributes are allowed\n }\n   The optional bagAttributes field allows users\
    \ to assign nicknames and\n   identifiers to keys, etc., and permits visual tools\
    \ to display\n   meaningful strings of some sort to the user.\n   Six types of\
    \ SafeBags are defined in this version of this document:\n   bagtypes OBJECT IDENTIFIER\
    \ ::= {pkcs-12 10 1}\n   BAG-TYPE ::= TYPE-IDENTIFIER\n   keyBag BAG-TYPE ::=\n\
    \       {KeyBag IDENTIFIED BY {bagtypes 1}}\n   pkcs8ShroudedKeyBag BAG-TYPE ::=\n\
    \       {PKCS8ShroudedKeyBag IDENTIFIED BY {bagtypes 2}}\n   certBag BAG-TYPE\
    \ ::=\n       {CertBag IDENTIFIED BY {bagtypes 3}}\n   crlBag BAG-TYPE ::=\n \
    \      {CRLBag IDENTIFIED BY {bagtypes 4}}\n   secretBag BAG-TYPE ::=\n      \
    \ {SecretBag IDENTIFIED BY {bagtypes 5}}\n   safeContentsBag BAG-TYPE ::=\n  \
    \     {SafeContents IDENTIFIED BY {bagtypes 6}}\n   PKCS12BagSet BAG-TYPE ::=\
    \ {\n       keyBag |\n       pkcs8ShroudedKeyBag |\n       certBag |\n       crlBag\
    \ |\n       secretBag |\n       safeContentsBag,\n       ... -- For future extensions\n\
    \   }\n   As new bag types become recognized in future versions of this\n   standard,\
    \ the PKCS12BagSet may be extended.\n"
- title: 4.2.1.  The KeyBag Type
  contents:
  - "4.2.1.  The KeyBag Type\n   A KeyBag is a PKCS #8 PrivateKeyInfo.  Note that\
    \ a KeyBag contains\n   only one private key.\n   KeyBag ::= PrivateKeyInfo\n"
- title: 4.2.2.  The PKCS8ShroudedKeyBag Type
  contents:
  - "4.2.2.  The PKCS8ShroudedKeyBag Type\n   A PKCS8ShroudedKeyBag holds a private\
    \ key, which has been shrouded in\n   accordance with PKCS #8.  Note that a PKCS8ShroudedKeyBag\
    \ holds only\n   one shrouded private key.\n   PKCS8ShroudedKeyBag ::= EncryptedPrivateKeyInfo\n"
- title: 4.2.3.  The CertBag Type
  contents:
  - "4.2.3.  The CertBag Type\n   A CertBag contains a certificate of a certain type.\
    \  Object\n   identifiers are used to distinguish between different certificate\n\
    \   types.\n   CertBag ::= SEQUENCE {\n       certId      BAG-TYPE.&id   ({CertTypes}),\n\
    \       certValue   [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\n   }\n\
    \   x509Certificate BAG-TYPE ::=\n       {OCTET STRING IDENTIFIED BY {certTypes\
    \ 1}}\n       -- DER-encoded X.509 certificate stored in OCTET STRING\n   sdsiCertificate\
    \ BAG-TYPE ::=\n       {IA5String IDENTIFIED BY {certTypes 2}}\n       -- Base64-encoded\
    \ SDSI certificate stored in IA5String\n   CertTypes BAG-TYPE ::= {\n       x509Certificate\
    \ |\n       sdsiCertificate,\n       ... -- For future extensions\n   }\n"
- title: 4.2.4.  The CRLBag Type
  contents:
  - "4.2.4.  The CRLBag Type\n   A CRLBag contains a Certificate Revocation List (CRL)\
    \ of a certain\n   type.  Object identifiers are used to distinguish between different\n\
    \   CRL types.\n   CRLBag ::= SEQUENCE {\n       crlId      BAG-TYPE.&id  ({CRLTypes}),\n\
    \       crlValue  [0] EXPLICIT BAG-TYPE.&Type ({CRLTypes}{@crlId})\n   }\n   x509CRL\
    \ BAG-TYPE ::=\n       {OCTET STRING IDENTIFIED BY {crlTypes 1}}\n       -- DER-encoded\
    \ X.509 CRL stored in OCTET STRING\n   CRLTypes BAG-TYPE ::= {\n       x509CRL,\n\
    \       ... -- For future extensions\n   }\n"
- title: 4.2.5.  The SecretBag Type
  contents:
  - "4.2.5.  The SecretBag Type\n   Each of the user's miscellaneous personal secrets\
    \ is contained in an\n   instance of SecretBag, which holds an object identifier-dependent\n\
    \   value.  Note that a SecretBag contains only one secret.\n   SecretBag ::=\
    \ SEQUENCE {\n       secretTypeId   BAG-TYPE.&id ({SecretTypes}),\n       secretValue\
    \    [0] EXPLICIT BAG-TYPE.&Type ({SecretTypes}\n                          {@secretTypeId})\n\
    \   }\n   SecretTypes BAG-TYPE ::= {\n       ... -- For future extensions\n  \
    \ }\n   Implementers can add values to this set at their own discretion.\n"
- title: 4.2.6.  The SafeContents Type
  contents:
  - "4.2.6.  The SafeContents Type\n   The sixth type of bag that can be held in a\
    \ SafeBag is a\n   SafeContents.  This recursive structure allows for arbitrary\
    \ nesting\n   of multiple KeyBags, PKCS8ShroudedKeyBags, CertBags, CRLBags, and\n\
    \   SecretBags within the top-level SafeContents.\n"
- title: 5.  Using PFX PDUs
  contents:
  - "5.  Using PFX PDUs\n   This section describes the creation and usage of PFX PDUs.\n"
- title: 5.1.  Creating PFX PDUs
  contents:
  - "5.1.  Creating PFX PDUs\n   The steps for creating PFX PDUs are as follows.\n\
    \   1.  It is somewhat clear from the ASN.1 how to make a number of\n       instances\
    \ of SafeContents, each containing a number of (possibly\n       nested) instances\
    \ of SafeBag.  Let us assume, therefore, a number\n       of instances SC_1, SC_2,...,\
    \ SC_n of SafeContents.  Note that\n       there can be a more or less arbitrary\
    \ number of instances of\n       SafeContents in a PFX PDU.  As will be seen in\
    \ step 2, each\n       instance can be encrypted (or not) separately.\n   2. \
    \ For each SCI, depending on the chosen encryption option,\n       A.  If SC_i\
    \ is not to be encrypted, make a ContentInfo CI_i\n           holding content\
    \ type Data.  The contents of the Data OCTET\n           STRING shall be a BER-encoding\
    \ of SC_i (including tag,\n           length, and value octets).\n       B.  If\
    \ SC_i is to be encrypted with a password, make a\n           ContentInfo CI_i\
    \ of type EncryptedData.  The\n           encryptedContentInfo field of CI_i has\
    \ its contentType field\n           set to data and its encryptedContent field\
    \ set to the\n           encryption of the BER-encoding of SC_i (note that the\
    \ tag and\n           length octets shall be present).\n       C.  If SC_i is\
    \ to be encrypted with a public key, make a\n           ContentInfo CI_i of type\
    \ EnvelopedData in essentially the\n           same fashion as the EncryptedData\
    \ ContentInfo was made in B.\n   3.  Make an instance of AuthenticatedSafe by\
    \ stringing together the\n       CI_i's in a SEQUENCE.\n   4.  Make a ContentInfo\
    \ T holding content type Data.  The contents of\n       the Data OCTET STRING\
    \ shall be a BER-encoding of the\n       AuthenticatedSafe value (including tag,\
    \ length, and value\n       octets).\n   5.  For integrity protection,\n     \
    \  A.  If the PFX PDU is to be authenticated with a digital\n           signature,\
    \ make a ContentInfo C of type SignedData.  The\n           contentInfo field\
    \ of the SignedData in C has T in it.  C is\n           the ContentInfo in the\
    \ top-level PFX structure.\n       B.  If the PFX PDU is to be authenticated with\
    \ HMAC, then an HMAC\n           with SHA-1, SHA-224, SHA-256, SHA-384, SHA-512,\
    \ SHA-512/224,\n           or SHA-512/256 is computed on the contents of the Data\
    \ in T\n           (i.e., excluding the OCTET STRING tag and length bytes).\n\
    \           This is exactly what would be initially digested in step 5A\n    \
    \       if public-key authentication were being used.\n"
- title: 5.2.  Importing Keys, etc., from a PFX PDU
  contents:
  - "5.2.  Importing Keys, etc., from a PFX PDU\n   Importation from a PFX is accomplished\
    \ essentially by reversing the\n   procedure for creating a PFX.  In general,\
    \ when an application\n   imports keys, etc., from a PFX, it should ignore any\
    \ object\n   identifiers that it is not familiar with.  At times, it may be\n\
    \   appropriate to alert the user to the presence of such object\n   identifiers.\n\
    \   Special care may be taken by the application when importing an item\n   in\
    \ the PFX would require overwriting an item that already exists\n   locally. \
    \ The behavior of the application when such an item is\n   encountered may depend\
    \ on what the item is (i.e., it may be that a\n   PKCS #8-shrouded private key\
    \ and a CRL should be treated differently\n   here).  Appropriate behavior may\
    \ be to ask the user what action\n   should be taken for this item.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   When using passwords in privacy or integrity\
    \ mode, it needs to be\n   considered that password-based cryptography is generally\
    \ limited in\n   the security that it can provide, particularly for methods such\
    \ as\n   those defined in this document where off-line password search is\n  \
    \ possible.  While the use of salt and iteration count can increase the\n   complexity\
    \ of attack, it is essential that passwords are selected\n   well and that relevant\
    \ guidelines (e.g., NIST SP 800-61-1) are taken\n   into account.  It is also\
    \ important that passwords be protected well\n   if stored.\n   When choosing\
    \ a salt value in password privacy or integrity mode, the\n   recommendations\
    \ in Section 4 of PKCS #5 2.1 [13] [22] should be taken\n   into account.  Ideally,\
    \ the salt is as long as the output of the hash\n   function being used and consists\
    \ of randomly generated data.\n"
- title: 7.  Normative References
  contents:
  - "7.  Normative References\n   [1]   Dobbertin, H., \"The status of MD5 after a\
    \ recent attack.\",\n         CryptoBytes Vol. 2, #2, 1996.\n   [2]   ISO/IEC,\
    \ \"Information technology -- Abstract Syntax Notation\n         One (ASN.1) --\
    \ Specification of basic notation\", ISO/IEC\n         8824-1:2008, 2008.\n  \
    \ [3]   ISO/IEC, \"Information technology -- Abstract Syntax Notation\n      \
    \   One (ASN.1) -- Information object specification\", ISO/IEC\n         8824-2:2008,\
    \ 2008.\n   [4]   ISO/IEC, \"Information technology -- Abstract Syntax Notation\n\
    \         One (ASN.1) -- Constraint specification\", ISO/IEC 88247-3:2008,\n \
    \        2008.\n   [5]   ISO/IEC, \"Information technology -- Abstract Syntax\
    \ Notation\n         One (ASN.1) -- Parameterization of ASN.1 specifications\"\
    ,\n         ISO/IEC 8824-4:2008, 2008.\n   [6]   ISO/IEC, \"Information Technology\
    \ - ASN.1 Encoding Rules:\n         Specification of Basic Encoding Rules (BER),\
    \ Canonical Encoding\n         Rules (CER), and Distinguished Encoding Rules\"\
    , ISO/IEC\n         8825-1:2008, 2008.\n   [7]   ISO/IEC, \"Information technology\
    \ -- Open Systems\n         Interconnection -- The Directory: Models\", ISO/IEC\
    \ 9594-2:1997,\n         1997.\n   [8]   ISO/IEC, \"Information technology --\
    \ Open Systems\n         Interconnection -- The Directory: Authentication Framework\"\
    ,\n         ISO/IEC 9594-8:1997, 1997.\n   [9]   Microsoft, \"PFX: Personal Exchange\
    \ Syntax and Protocol\n         Standard\", ISO/IEC Version 0.020, January 1997.\n\
    \   [10]  National Institute of Standards and Technology (NIST), \"Secure\n  \
    \       Hash Standard\", FIPS Publication 180-4, March 2012.\n   [11]  National\
    \ Institute of Standards and Technology (NIST), \"The\n         Keyed-Hash Message\
    \ Authentication Code (HMAC)\", FIPS\n         Publication 198-1, July 2008.\n\
    \   [12]  National Institute of Standards and Technology (NIST), \"The\n     \
    \    Recommendation for Password-Based Key Derivation, Part 1:\n         Storage\
    \ Applications\", NIST Special Publication 800-132,\n         December 2010.\n\
    \   [13]  RSA Laboratories, \"PKCS #5: Password-Based Encryption\n         Standard\"\
    , PKCS Version 2.1, October 2012.\n   [14]  RSA Laboratories, \"PKCS #7: Cryptographic\
    \ Message Syntax\n         Standard\", PKCS Version 1.5, November 1993.\n   [15]\
    \  RSA Laboratories, \"PKCS #8: Private-Key Information Syntax\n         Standard\"\
    , PKCS Version 1.2, November 1993.\n   [16]  RSA Laboratories, \"PKCS #12: Personal\
    \ Information Exchange\n         Syntax\", PKCS Version 1.1, December 2012.\n\
    \   [17]  Rivest, R. and B. Lampson, \"SDSI - A Simple Distributed\n         Security\
    \ Infrastructure\", 1996,\n         <http://people.csail.mit.edu/rivest/sdsi10.html>.\n\
    \   [18]  Turner, S. and L. Chen, \"MD2 to Historic Status\", RFC 6149,\n    \
    \     March 2011.\n   [19]  Rivest, R., \"The MD5 Message-Digest Algorithm\",\
    \ RFC 1321, April\n         1992.\n   [20]  Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC: Keyed-\n         Hashing for Message Authentication\", RFC\
    \ 2104, February 1997.\n   [21]  Kaliski, B., \"PKCS #7: Cryptographic Message\
    \ Syntax Version\n         1.5\", RFC 2315, March 1998.\n   [22]  Kaliski, B.,\
    \ \"PKCS #5: Password-Based Cryptography\n         Specification Version 2.0\"\
    , RFC 2898, September 2000.\n   [23]  Nystrom, M. and B. Kaliski, \"PKCS #9: Selected\
    \ Object Classes\n         and Attribute Types Version 2.0\", RFC 2985, November\
    \ 2000.\n   [24]  Turner, S., \"Asymmetric Key Packages\", RFC 5958, August 2010.\n\
    \   [25]  Turner, S. and L. Chen, \"Updated Security Considerations for\n    \
    \     the MD5 Message-Digest and the HMAC-MD5 Algorithms\", RFC 6151,\n      \
    \   March 2011.\n"
- title: Appendix A.  Message Authentication Codes (MACs)
  contents:
  - "Appendix A.  Message Authentication Codes (MACs)\n   A MAC is a special type\
    \ of function of a message (data bits) and an\n   integrity key.  It can be computed\
    \ or checked only by someone\n   possessing both the message and the integrity\
    \ key.  Its security\n   follows from the secrecy of the integrity key.  In this\
    \ standard,\n   MACing is used in password integrity mode.\n   This document uses\
    \ a particular type of MAC called HMAC [11] [20],\n   which can be constructed\
    \ from any of a variety of hash functions.\n   Note that the specifications in\
    \ [20] and [11] differ somewhat from\n   the specification in [9].  The hash function\
    \ HMAC is based on is\n   identified in the MacData, which holds the MAC; for\
    \ this version of\n   this standard, the hash function can be one of the following:\
    \ SHA-1,\n   SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or SHA-512/256 [10].\n\
    \   As indicated in Appendix B.4, this structure implies that the same\n   hash\
    \ algorithm must be used to derive the MAC key itself in password\n   integrity\
    \ mode and that the MAC key has either 160, 224, 256, 384, or\n   512 bits.\n\
    \   When password integrity mode is used to secure a PFX PDU, an HMAC\n   with\
    \ SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or\n   SHA-512/256 is\
    \ computed on the BER-encoding of the contents of the\n   content field of the\
    \ authSafe field in the PFX PDU (see Section 5.1).\n"
- title: Appendix B.  Deriving Keys and IVs from Passwords and Salt
  contents:
  - "Appendix B.  Deriving Keys and IVs from Passwords and Salt\n   Note that this\
    \ method for password privacy mode is not recommended\n   and is deprecated for\
    \ new usage.  The procedures and algorithms\n   defined in PKCS #5 v2.1 [13] [22]\
    \ should be used instead.\n   Specifically, PBES2 should be used as encryption\
    \ scheme, with PBKDF2\n   as the key derivation function.\n   The method presented\
    \ here is still used to generate the key in\n   password integrity mode.\n   We\
    \ present here a general method for using a hash function to produce\n   various\
    \ types of pseudorandom bits from a password and a string of\n   salt bits.  This\
    \ method is used for password privacy mode and\n   password integrity mode in\
    \ the present standard.\n"
- title: B.1.  Password Formatting
  contents:
  - "B.1.  Password Formatting\n   The underlying password-based encryption methods\
    \ in PKCS #5 v2.1 view\n   passwords (and salt) as being simple byte strings.\
    \  The underlying\n   password-based encryption methods and the underlying password-based\n\
    \   authentication methods in this version of this document are similar.\n   What's\
    \ left unspecified in the above paragraph is precisely where the\n   byte string\
    \ representing a password comes from.  (This is not an\n   issue with salt strings,\
    \ since they are supplied as a password-based\n   encryption (or authentication)\
    \ parameter.)  PKCS #5 v2.1 says: \"[...]\n   a password is considered to be an\
    \ octet string of arbitrary length\n   whose interpretation as a text string is\
    \ unspecified.  In the\n   interest of interoperability, however, it is recommended\
    \ that\n   applications follow some common text encoding rules.  ASCII and UTF-8\n\
    \   are two possibilities.\"\n   In this specification, however, all passwords\
    \ are created from\n   BMPStrings with a NULL terminator.  This means that each\
    \ character in\n   the original BMPString is encoded in 2 bytes in big-endian\
    \ format\n   (most-significant byte first).  There are no Unicode byte order\n\
    \   marks.  The 2 bytes produced from the last character in the BMPString\n  \
    \ are followed by 2 additional bytes with the value 0x00.\n   To illustrate with\
    \ a simple example, if a user enters the 6-character\n   password \"Beavis\",\
    \ the string that PKCS #12 implementations should\n   treat as the password is\
    \ the following string of 14 bytes:\n   0x00 0x42 0x00 0x65 0x00 0x61 0x00 0x76\
    \ 0x00 0x69 0x00 0x73 0x00 0x00\n"
- title: B.2.  General Method
  contents:
  - "B.2.  General Method\n   Let H be a hash function built around a compression\
    \ function f:\n      Z_2^u x Z_2^v -> Z_2^u\n   (that is, H has a chaining variable\
    \ and output of length u bits, and\n   the message input to the compression function\
    \ of H is v bits).  The\n   values for u and v are as follows:\n           HASH\
    \ FUNCTION     VALUE u        VALUE v\n             MD2, MD5          128    \
    \        512\n               SHA-1           160            512\n            \
    \  SHA-224          224            512\n              SHA-256          256   \
    \         512\n              SHA-384          384            1024\n          \
    \    SHA-512          512            1024\n            SHA-512/224        224\
    \            1024\n            SHA-512/256        256            1024\n   Furthermore,\
    \ let r be the iteration count.\n   We assume here that u and v are both multiples\
    \ of 8, as are the\n   lengths of the password and salt strings (which we denote\
    \ by p and s,\n   respectively) and the number n of pseudorandom bits required.\
    \  In\n   addition, u and v are of course non-zero.\n   For information on security\
    \ considerations for MD5 [19], see [25] and\n   [1], and on those for MD2, see\
    \ [18].\n   The following procedure can be used to produce pseudorandom bits for\n\
    \   a particular \"purpose\" that is identified by a byte called \"ID\".  The\n\
    \   meaning of this ID byte will be discussed later.\n   1.  Construct a string,\
    \ D (the \"diversifier\"), by concatenating v/8\n       copies of ID.\n   2. \
    \ Concatenate copies of the salt together to create a string S of\n       length\
    \ v(ceiling(s/v)) bits (the final copy of the salt may be\n       truncated to\
    \ create S).  Note that if the salt is the empty\n       string, then so is S.\n\
    \   3.  Concatenate copies of the password together to create a string P\n   \
    \    of length v(ceiling(p/v)) bits (the final copy of the password\n       may\
    \ be truncated to create P).  Note that if the password is the\n       empty string,\
    \ then so is P.\n   4.  Set I=S||P to be the concatenation of S and P.\n   5.\
    \  Set c=ceiling(n/u).\n   6.  For i=1, 2, ..., c, do the following:\n       A.\
    \  Set A2=H^r(D||I). (i.e., the r-th hash of D||1,\n           H(H(H(... H(D||I))))\n\
    \       B.  Concatenate copies of Ai to create a string B of length v\n      \
    \     bits (the final copy of Ai may be truncated to create B).\n       C.  Treating\
    \ I as a concatenation I_0, I_1, ..., I_(k-1) of v-bit\n           blocks, where\
    \ k=ceiling(s/v)+ceiling(p/v), modify I by\n           setting I_j=(I_j+B+1) mod\
    \ 2^v for each j.\n   7.  Concatenate A_1, A_2, ..., A_c together to form a pseudorandom\n\
    \       bit string, A.\n   8.  Use the first n bits of A as the output of this\
    \ entire process.\n   If the above process is being used to generate a DES key,\
    \ the process\n   should be used to create 64 random bits, and the key's parity\
    \ bits\n   should be set after the 64 bits have been produced.  Similar concerns\n\
    \   hold for 2-key and 3-key triple-DES keys, for CDMF keys, and for any\n   similar\
    \ keys with parity bits \"built into them\".\n"
- title: B.3.  More on the ID Byte
  contents:
  - "B.3.  More on the ID Byte\n   This standard specifies 3 different values for\
    \ the ID byte mentioned\n   above:\n   1.  If ID=1, then the pseudorandom bits\
    \ being produced are to be used\n       as key material for performing encryption\
    \ or decryption.\n   2.  If ID=2, then the pseudorandom bits being produced are\
    \ to be used\n       as an IV (Initial Value) for encryption or decryption.\n\
    \   3.  If ID=3, then the pseudorandom bits being produced are to be used\n  \
    \     as an integrity key for MACing.\n"
- title: B.4.  Keys for Password Integrity Mode
  contents:
  - "B.4.  Keys for Password Integrity Mode\n   When password integrity mode is used\
    \ to protect a PFX PDU, a password\n   and salt are used to derive a MAC key.\
    \  As with password privacy\n   mode, the password is a Unicode string, and the\
    \ salt is a byte\n   string.  No particular lengths are prescribed in this standard\
    \ for\n   either the password or the salt, but the general advice about\n   passwords\
    \ and salt that is given in Appendix C applies here, as well.\n   The hash function\
    \ used to derive MAC keys is whatever hash function\n   is going to be used for\
    \ MACing.  The MAC keys that are derived have\n   the same length as the hash\
    \ function's output.  In this version of\n   this standard, SHA-1, SHA-224, SHA-256,\
    \ SHA384, SHA-512, SHA-512/224,\n   or SHA/512/256 can be used to perform MACing,\
    \ and so the MAC keys can\n   be 160, 224, 256, 384, or 512 bits.  See Appendix\
    \ A for more\n   information on MACing.\n"
- title: Appendix C.  Keys and IVs for Password Privacy Mode
  contents:
  - "Appendix C.  Keys and IVs for Password Privacy Mode\n   As stated at the start\
    \ of Appendix B, use of this method for password\n   privacy mode is not recommended;\
    \ this specification of keys and IVs\n   for password privacy mode is retained\
    \ for backwards compatibility\n   with PKCS #12 v1.0 only.\n   When password privacy\
    \ mode is used to encrypt a PFX PDU, a password\n   (typically entered by the\
    \ user), a salt and an iteration parameter\n   are used to derive a key (and an\
    \ IV, if necessary).  The password is\n   a Unicode string, and as such, each\
    \ character in it is represented by\n   2 bytes.  The salt is a byte string and\
    \ so can be represented\n   directly as a sequence of bytes.\n   This standard\
    \ does not prescribe a length for the password.  As\n   usual, however, too short\
    \ a password might compromise privacy.  A\n   particular application might well\
    \ require a user-entered privacy\n   password for creating a PFX PDU to have a\
    \ password exceeding some\n   specific length.\n   This standard does not prescribe\
    \ a length for the salt either.\n   Ideally, the salt is as long as the output\
    \ of the hash function being\n   used and consists of completely random bits.\n\
    \   The iteration count is recommended to be 1024 or more.  (See [22] and\n  \
    \ [13] for more information.)\n   The PBES1 encryption scheme defined in PKCS\
    \ #5 provides a number of\n   algorithm identifiers for deriving keys and IVs;\
    \ here, we specify a\n   few more, all of which use the procedure detailed in\
    \ Appendices B.2\n   and B.3 to construct keys (and IVs, where needed).  As is\
    \ implied by\n   their names, all of the object identifiers below use the hash\n\
    \   function SHA-1.\n"
- title: pkcs-12PbeIds                    OBJECT IDENTIFIER ::= {pkcs-12 1}
  contents:
  - 'pkcs-12PbeIds                    OBJECT IDENTIFIER ::= {pkcs-12 1}

    '
- title: pbeWithSHAAnd128BitRC4           OBJECT IDENTIFIER ::= {pkcs-12PbeIds 1}
  contents:
  - 'pbeWithSHAAnd128BitRC4           OBJECT IDENTIFIER ::= {pkcs-12PbeIds 1}

    '
- title: pbeWithSHAAnd40BitRC4            OBJECT IDENTIFIER ::= {pkcs-12PbeIds 2}
  contents:
  - 'pbeWithSHAAnd40BitRC4            OBJECT IDENTIFIER ::= {pkcs-12PbeIds 2}

    '
- title: pbeWithSHAAnd3-KeyTripleDES-CBC  OBJECT IDENTIFIER ::= {pkcs-12PbeIds 3}
  contents:
  - 'pbeWithSHAAnd3-KeyTripleDES-CBC  OBJECT IDENTIFIER ::= {pkcs-12PbeIds 3}

    '
- title: pbeWithSHAAnd2-KeyTripleDES-CBC  OBJECT IDENTIFIER ::= {pkcs-12PbeIds 4}
  contents:
  - 'pbeWithSHAAnd2-KeyTripleDES-CBC  OBJECT IDENTIFIER ::= {pkcs-12PbeIds 4}

    '
- title: pbeWithSHAAnd128BitRC2-CBC       OBJECT IDENTIFIER ::= {pkcs-12PbeIds 5}
  contents:
  - 'pbeWithSHAAnd128BitRC2-CBC       OBJECT IDENTIFIER ::= {pkcs-12PbeIds 5}

    '
- title: pbewithSHAAnd40BitRC2-CBC        OBJECT IDENTIFIER ::= {pkcs-12PbeIds 6}
  contents:
  - "pbewithSHAAnd40BitRC2-CBC        OBJECT IDENTIFIER ::= {pkcs-12PbeIds 6}\n  \
    \ Each of the six PBE object identifiers above has the following ASN.1\n   type\
    \ for parameters:\n   pkcs-12PbeParams ::= SEQUENCE {\n       salt        OCTET\
    \ STRING,\n       iterations  INTEGER\n   }\n   The pkcs-12PbeParams holds the\
    \ salt that is used to generate the key\n   (and IV, if necessary) and the number\
    \ of iterations to carry out.\n   Note that the first two algorithm identifiers\
    \ above (the algorithm\n   identifiers for RC4) only derive keys; it is unnecessary\
    \ to derive an\n   IV for RC4.\n   This section is here for two reasons: first,\
    \ to enable backwards\n   compatibility as described in the first paragraph of\
    \ this section;\n   second, because it is still used in password integrity mode.\
    \  In\n   order to not use it in password integrity mode, the ASN.1 definitions\n\
    \   require updates.  This document recommends that future definitions of\n  \
    \ the PFX structure replace the existing MacData object, optionally\n   present\
    \ in password integrity mode, with a new object definition that\n   holds a MAC\
    \ based on PKCS#5 [13] [22] PBMAC1 message authentication\n   scheme.  This change\
    \ would simplify the requirements for key\n   derivation functions used across\
    \ all parts of the PFX structure.\n"
- title: Appendix D.  ASN.1 Module
  contents:
  - "Appendix D.  ASN.1 Module\n   This appendix documents all ASN.1 types, values,\
    \ and object sets\n   defined in this specification.  It does so by providing\
    \ an ASN.1\n   module called PKCS-12.\n PKCS-12 {\n     iso(1) member-body(2)\
    \ us(840) rsadsi(113549) pkcs(1) pkcs-12(12)\n     modules(0) pkcs-12(1)}\n --\
    \ PKCS #12 v1.1 ASN.1 Module\n -- Revised October 27, 2012\n -- This module has\
    \ been checked for conformance with the ASN.1 standard\n -- by the OSS ASN.1 Tools\n\
    \ DEFINITIONS IMPLICIT TAGS ::=\n BEGIN\n -- EXPORTS ALL\n -- All types and values\
    \ defined in this module are exported for use\n -- in other ASN.1 modules.\n IMPORTS\n\
    \ informationFramework\n     FROM UsefulDefinitions {joint-iso-itu-t(2) ds(5)\
    \ module(1)\n                             usefulDefinitions(0) 3}\n ATTRIBUTE\n\
    \     FROM InformationFramework informationFramework\n ContentInfo, DigestInfo\n\
    \     FROM PKCS-7 {iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)\n    \
    \              pkcs-7(7) modules(0) pkcs-7(1)}\n PrivateKeyInfo, EncryptedPrivateKeyInfo\n\
    \     FROM PKCS-8 {iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)\n    \
    \              pkcs-8(8) modules(1) pkcs-8(1)}\n pkcs-9, friendlyName, localKeyId,\
    \ certTypes, crlTypes\n     FROM PKCS-9 {iso(1) member-body(2) us(840) rsadsi(113549)\
    \ pkcs(1)\n                  pkcs-9(9) modules(0) pkcs-9(1)};\n -- ============================\n\
    \ -- Object identifiers\n -- ============================\n rsadsi  OBJECT IDENTIFIER\
    \ ::= {iso(1) member-body(2) us(840)\n                                rsadsi(113549)}\n\
    \ pkcs    OBJECT IDENTIFIER ::= {rsadsi pkcs(1)}\n pkcs-12 OBJECT IDENTIFIER ::=\
    \ {pkcs 12}\n pkcs-12PbeIds OBJECT IDENTIFIER ::= {pkcs-12 1}\n pbeWithSHAAnd128BitRC4\
    \          OBJECT IDENTIFIER ::= {pkcs-12PbeIds 1}\n pbeWithSHAAnd40BitRC4   \
    \        OBJECT IDENTIFIER ::= {pkcs-12PbeIds 2}\n pbeWithSHAAnd3-KeyTripleDES-CBC\
    \ OBJECT IDENTIFIER ::= {pkcs-12PbeIds 3}\n pbeWithSHAAnd2-KeyTripleDES-CBC OBJECT\
    \ IDENTIFIER ::= {pkcs-12PbeIds 4}\n pbeWithSHAAnd128BitRC2-CBC      OBJECT IDENTIFIER\
    \ ::= {pkcs-12PbeIds 5}\n pbewithSHAAnd40BitRC2-CBC       OBJECT IDENTIFIER ::=\
    \ {pkcs-12PbeIds 6}\n bagtypes OBJECT IDENTIFIER ::= {pkcs-12 10 1}\n -- ============================\n\
    \ -- The PFX PDU\n -- ============================\n PFX ::= SEQUENCE {\n    \
    \ version    INTEGER {v3(3)}(v3,...),\n     authSafe   ContentInfo,\n     macData\
    \    MacData OPTIONAL\n }\n MacData ::= SEQUENCE {\n     mac        DigestInfo,\n\
    \     macSalt    OCTET STRING,\n     iterations INTEGER DEFAULT 1\n     -- Note:\
    \ The default is for historical reasons and its use is\n     -- deprecated.\n\
    \ }\n AuthenticatedSafe ::= SEQUENCE OF ContentInfo\n     -- Data if unencrypted\n\
    \     -- EncryptedData if password-encrypted\n     -- EnvelopedData if public\
    \ key-encrypted\n SafeContents ::= SEQUENCE OF SafeBag\n SafeBag ::= SEQUENCE\
    \ {\n     bagId         BAG-TYPE.&id ({PKCS12BagSet}),\n     bagValue      [0]\
    \ EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n     bagAttributes SET OF\
    \ PKCS12Attribute OPTIONAL\n }\n -- ============================\n -- Bag types\n\
    \ -- ============================\n keyBag BAG-TYPE ::=\n     {KeyBag        \
    \      IDENTIFIED BY {bagtypes 1}}\n pkcs8ShroudedKeyBag BAG-TYPE ::=\n     {PKCS8ShroudedKeyBag\
    \ IDENTIFIED BY {bagtypes 2}}\n certBag BAG-TYPE ::=\n     {CertBag          \
    \   IDENTIFIED BY {bagtypes 3}}\n crlBag BAG-TYPE ::=\n     {CRLBag          \
    \    IDENTIFIED BY {bagtypes 4}}\n secretBag BAG-TYPE ::=\n     {SecretBag   \
    \        IDENTIFIED BY {bagtypes 5}}\n safeContentsBag BAG-TYPE ::=\n     {SafeContents\
    \        IDENTIFIED BY {bagtypes 6}}\n PKCS12BagSet BAG-TYPE ::= {\n     keyBag\
    \ |\n     pkcs8ShroudedKeyBag |\n     certBag |\n     crlBag |\n     secretBag\
    \ |\n     safeContentsBag,\n     ... -- For future extensions\n }\n BAG-TYPE ::=\
    \ TYPE-IDENTIFIER\n -- KeyBag\n KeyBag ::= PrivateKeyInfo\n -- Shrouded KeyBag\n\
    \ PKCS8ShroudedKeyBag ::= EncryptedPrivateKeyInfo\n -- CertBag\n CertBag ::= SEQUENCE\
    \ {\n     certId    BAG-TYPE.&id   ({CertTypes}),\n     certValue [0] EXPLICIT\
    \ BAG-TYPE.&Type ({CertTypes}{@certId})\n }\n x509Certificate BAG-TYPE ::=\n \
    \    {OCTET STRING IDENTIFIED BY {certTypes 1}}\n     -- DER-encoded X.509 certificate\
    \ stored in OCTET STRING\n sdsiCertificate BAG-TYPE ::=\n     {IA5String IDENTIFIED\
    \ BY {certTypes 2}}\n     -- Base64-encoded SDSI certificate stored in IA5String\n\
    \ CertTypes BAG-TYPE ::= {\n     x509Certificate |\n     sdsiCertificate,\n  \
    \   ... -- For future extensions\n }\n -- CRLBag\n CRLBag ::= SEQUENCE {\n   \
    \  crlId     BAG-TYPE.&id ({CRLTypes}),\n     crltValue [0] EXPLICIT BAG-TYPE.&Type\
    \ ({CRLTypes}{@crlId})\n }\n x509CRL BAG-TYPE ::=\n     {OCTET STRING IDENTIFIED\
    \ BY {crlTypes 1}}\n     -- DER-encoded X.509 CRL stored in OCTET STRING\n CRLTypes\
    \ BAG-TYPE ::= {\n     x509CRL,\n     ... -- For future extensions\n }\n -- Secret\
    \ Bag\n SecretBag ::= SEQUENCE {\n     secretTypeId  BAG-TYPE.&id ({SecretTypes}),\n\
    \     secretValue   [0] EXPLICIT BAG-TYPE.&Type ({SecretTypes}\n             \
    \                                   {@secretTypeId})\n }\n SecretTypes BAG-TYPE\
    \ ::= {\n     ... -- For future extensions\n }\n -- ============================\n\
    \ -- Attributes\n -- ============================\n PKCS12Attribute ::= SEQUENCE\
    \ {\n     attrId      ATTRIBUTE.&id ({PKCS12AttrSet}),\n     attrValues  SET OF\
    \ ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n } -- This type is compatible with\
    \ the X.500 type 'Attribute'\n PKCS12AttrSet ATTRIBUTE ::= {\n     friendlyName\
    \ |\n     localKeyId,\n     ... -- Other attributes are allowed\n }\n END\n"
- title: Appendix E.  Intellectual Property Considerations
  contents:
  - "Appendix E.  Intellectual Property Considerations\n   EMC Corporation makes no\
    \ patent claims on the general constructions\n   described in this document, although\
    \ specific underlying techniques\n   may be covered.\n   RC2 and RC4 are trademarks\
    \ of EMC Corporation.\n   EMC Corporation makes no representations regarding intellectual\n\
    \   property claims by other parties.  Such determination is the\n   responsibility\
    \ of the user.\n"
- title: Appendix F.  Acknowledgments
  contents:
  - "Appendix F.  Acknowledgments\n   Many thanks to Dan Simon of Microsoft Corporation\
    \ and Jim Spring of\n   Netscape Communications Corporation for their assistance\
    \ in preparing\n   early drafts of this document.  Especial thanks to Brian Beckman\
    \ of\n   Microsoft Corporation for writing the specification that this\n   document\
    \ is based on.\n"
- title: Appendix G.  About PKCS
  contents:
  - "Appendix G.  About PKCS\n   The Public-Key Cryptography Standards are specifications\
    \ produced by\n   RSA Laboratories in cooperation with secure systems developers\n\
    \   worldwide for the purpose of accelerating the deployment of public-\n   key\
    \ cryptography.  First published in 1991 as a result of meetings\n   with a small\
    \ group of early adopters of public-key technology, the\n   PKCS documents have\
    \ become widely referenced and implemented.\n   Contributions from the PKCS series\
    \ have become part of many formal\n   and de facto standards, including ANSI X9\
    \ documents, PKIX, SET, S/\n   MIME, and SSL.\n   Further development of PKCS\
    \ occurs through the IETF.  Suggestions for\n   improvement are welcome.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Kathleen M. Moriarty (editor)\n   EMC Corporation\n  \
    \ 176 South Street\n   Hopkinton, MA\n   United States\n   EMail: Kathleen.Moriarty@emc.com\n\
    \   Magnus Nystrom\n   Microsoft Corporation\n   1 Microsoft Way\n   Redmond,\
    \ WA  98052\n   United States\n   EMail: mnystrom@microsoft.com\n   Sean Parkinson\n\
    \   RSA Security Inc.\n   345 Queen Street\n   Brisbane, QLD, 4000\n   Australia\n\
    \   EMail: Sean.Parkinson@rsa.com\n   Andreas Rusch\n   RSA Security Inc.\n  \
    \ 345 Queen Street\n   Brisbane, QLD, 4000\n   Australia\n   EMail: Andreas.Rusch@rsa.com\n\
    \   Michael Scott\n   RSA Security Inc.\n   345 Queen Street\n   Brisbane, QLD,\
    \ 4000\n   Australia\n   EMail: Michael2.Scott@rsa.com\n"
