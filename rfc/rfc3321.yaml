- title: __initial_text__
  contents:
  - '         Signaling Compression (SigComp) - Extended Operations

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes how to implement certain mechanisms in\n\
    \   Signaling Compression (SigComp), RFC 3320, which can significantly\n   improve\
    \ the compression efficiency compared to using simple per-\n   message compression.\n\
    \   SigComp uses a Universal Decompressor Virtual Machine (UDVM) for\n   decompression,\
    \ and the mechanisms described in this document are\n   possible to implement\
    \ using the UDVM instructions defined in RFC\n   3320.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction..................................................2\n\
    \   2.  Terminology...................................................3\n   3.\
    \  Architectural View of Feedback................................4\n   4.  State\
    \ Reference Model.........................................5\n   5.  Extended Mechanisms...........................................6\n\
    \   6.  Implications on SigComp......................................13\n   7.\
    \  Security Considerations......................................17\n   8.  IANA\
    \ Considerations..........................................17\n   9.  Acknowledgements.............................................17\n\
    \   10. Intellectual Property Right Considerations...................17\n   11.\
    \ References...................................................17\n   12. Authors'\
    \ Addresses...........................................18\n   13. Full Copyright\
    \ Statement.....................................19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes how to implement mechanisms with\
    \ [SIGCOMP] to\n   significantly improve the compression efficiency compared to\
    \ per-\n   message compression.\n   One such mechanism is to use previously sent\
    \ messages in the SigComp\n   compression process, referred to as dynamic compression.\
    \  In order to\n   utilize information from previously sent messages, it is necessary\n\
    \   for a compressor to gain knowledge about the reception of these\n   messages.\
    \  For a reliable transport, such as TCP, this is guaranteed.\n   For an unreliable\
    \ transport however, the SigComp protocol can be used\n   to provide such a functionality\
    \ itself.  That functionality is\n   described in this document and is referred\
    \ to as explicit\n   acknowledgement.\n   Another mechanism that will improve\
    \ the compression efficiency of\n   SigComp, especially when SigComp is applied\
    \ to protocols that are of\n   request/response type, is shared compression. \
    \ This involves using\n   received messages in the SigComp compression process.\
    \  In particular\n   the compression of the first few messages will gain from\
    \ shared\n   compression.  Shared compression is described in this document.\n\
    \   For better understanding of this document the reader should be\n   familiar\
    \ with the concept of [SIGCOMP].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The reader should consult [SIGCOMP] for definitions of terminology,\n\
    \   since this document uses the same terminology.  Further terminology\n   is\
    \ defined below.\n     Compressor\n       Entity that encodes application messages\
    \ using a certain\n       compression algorithm and keeps track of state that\
    \ can be used\n       for compression.  The compressor is responsible for ensuring\
    \ that\n       the messages it generates can be decompressed by the remote UDVM.\n\
    \     Decompressor\n       The decompressor is responsible for converting a SigComp\
    \ message\n       into uncompressed data.  Decompression functionality is provided\n\
    \       by the UDVM.\n     Dynamic compression\n       Compression relative to\
    \ messages sent prior to the current\n       compressed message.\n     Explicit\
    \ acknowledgement\n       Acknowledgement for a state.  The acknowledgment is\
    \ explicitly\n       sent from a decompressor to its remote compressor.  The\n\
    \       acknowledgement should be piggybacked onto a SigComp message in\n    \
    \   order not to create additional security risks.\n     Shared compression\n\
    \       Compression relative to messages received by the local endpoint\n    \
    \   prior to the current compressed message.\n     Shared state\n       A state\
    \ used for shared compression consists only of an\n       uncompressed message.\
    \  This makes the state independent of the\n       compression algorithm.\n  \
    \   State identifier\n       Reference used to access a previously created item\
    \ of state.\n       - shared_state_id\n           State identifier of a shared\
    \ state.\n       - acked_state_id\n           State identifier of a state that\
    \ is acknowledged as\n           successfully saved by the decompressor.\n"
- title: 3.  Architectural View of Feedback
  contents:
  - "3.  Architectural View of Feedback\n   SigComp has a request/response mechanism\
    \ to provide feedback between\n   endpoints, see Figure 1.  This particular functionality\
    \ of SigComp is\n   used in this document to provide support for the mechanisms\
    \ described\n   in this document.\n      +--------------------+              +--------------------+\n\
    \      |    Endpoint 1      |              |     Endpoint 2     |\n      |  +--------------+\
    \  |              |  +--------------+  |\n      |  | Compressor 1 |  |       \
    \       |  |Decompressor 2|  |\n      |  | [------------+--+--------------+--+--]\
    \   *       |  |\n      |  +-|-------^----+  |              |  +--|---|-------+\
    \  |\n      |    |       |       |              |     |   |          |\n     \
    \ |    |       |       |              |     |   |          |\n      |    |   \
    \    |       |              |     |   |          |\n      |  +-|-------|----+\
    \  |              |  +--v---|-------+  |\n      |  | *       [----+--+--------------+--+------]\
    \       |  |\n      |  |Decompressor 1|  |              |  | Compressor 2 |  |\n\
    \      |  +--------------+  |              |  +--------------+  |\n      +--------------------+\
    \              +--------------------+\n                       Figure 1.  Architectural\
    \ view\n   The feedback functionality of SigComp is used in this document to\n\
    \   provide a mechanism for a SigComp endpoint to confirm which states\n   have\
    \ been established by its remote SigComp endpoint during the\n   lifetime of a\
    \ SigComp compartment.  The established state\n   confirmations are referred to\
    \ as acknowledgments.  Depending on the\n   established states this particular\
    \ type of feedback may or may not be\n   used to increase the compression efficiency.\n\
    \   The following sections describe how the SigComp functionality of\n   providing\
    \ feedback information is used to support the mechanisms\n   described in this\
    \ document.  Section 4 describes the state reference\n   model of SigComp.  Section\
    \ 5 continues with a general description of\n   the mechanisms and Section 6 describes\
    \ the implications of some of\n   the mechanisms on basic SigComp.\n"
- title: 4.  State Reference Model
  contents:
  - "4.  State Reference Model\n   A UDVM may want to save the status of its memory,\
    \ and this status is\n   referred to as a state.  As explained in [SIGCOMP] a\
    \ state save\n   request may or may not be granted by the application.  For later\n\
    \   reference to a saved state, e.g., if the UDVM is to be loaded with\n   this\
    \ state, a reference is needed to locate the specific state.  This\n   reference\
    \ is called a state identifier.\n"
- title: 4.1.  Overview of State Reference with Dynamic Compression
  contents:
  - "4.1.  Overview of State Reference with Dynamic Compression\n   When compressor\
    \ 1 compresses a message m it uses the information\n   corresponding to a SigComp\
    \ state that its remote decompressor 2 has\n   established and acknowledged. \
    \ If compressor 1 wishes to use the new\n   state for compression of later messages\
    \ it must save the new state.\n   The new state contains information from the\
    \ former state and from m.\n   When an acknowledgement is received for this new\
    \ state, compressor 1\n   can utilize the new state in the compression process.\
    \  Below is an\n   overview of the model together with an example of a message\
    \ flow.\n   Saved state(s)\n     A state which is expected to be used for compression/decompression\n\
    \     of later messages.\n   Acked state(s)\n     An acked state is a saved state\
    \ for which the compressor has\n     received an acknowledgement, i.e., the state\
    \ has been established\n     at the remote decompressor.  The compressor must\
    \ only use states\n     that are established at the remote decompressor, otherwise\
    \ a\n     decompression failure will occur.  For this reason,\n     acknowledgements\
    \ are necessary, at least for unreliable transport.\n            Compressor 1\
    \                    Decompressor 2\n               +---+                    \
    \        +---+\n               | C |                            | D |\n      \
    \         +---+                            +---+\n    Saved       Acked    | \
    \           |   Saved\n   State(s)    State(s)  |            |  State(s)\n  -----------------------+------------+------------------\n\
    \  s0             s0      |            |    s0\n  s1=s0+m1               | --m1(s0)-->|\n\
    \                         | <--ack(s1) |  s0,s1\n  s0,s1        s0,s1     |  \
    \          |\n                         |            |\n  s0,s1        s0,s1  \
    \   | --m2(s1)-->|   (m2 Lost)\n  s2=s1+m1               |            |\n    \
    \                     |            |\n  s0-s2        s0,s1     |            |\n\
    \  s3=s1+m3               | --m3(s1)-->|   s0,s1\n                         | \
    \           |\n                         |            |\n                     \
    \    | <--ack(s3) |   s0,s1,s3=s1+m3\n  s0-s3       s0,s1,s3   |            |\n\
    \         Figure 2.  Example of message flow for dynamic compression\n   Legend:\
    \ Message 1 compressed making use of state s0 is denoted\n   m1(s0).  The notation\
    \ s1=s0+m1 means that state s1 is created using\n   information from state s0\
    \ and message m1.  ack(s1) means that the\n   creation of state s1 is acknowledged\
    \ through piggybacking on a\n   message traveling in the reverse direction (which\
    \ is not shown in the\n   figure).\n"
- title: 5.  Extended Mechanisms
  contents:
  - "5.  Extended Mechanisms\n   The following subsections give a general description\
    \ of the extended\n   mechanisms.\n"
- title: 5.1.  Explicit Acknowledgement Scheme
  contents:
  - "5.1.  Explicit Acknowledgement Scheme\n   For a compressor to be able to utilize\
    \ a certain state it must know\n   that the remote decompressor has access to\
    \ this state.\n   In the case where compressed messages can be lost or misordered\
    \ on\n   the path between compressor and decompressor, an acknowledgement\n  \
    \ scheme must be used to notify the remote compressor that a certain\n   state\
    \ has been established.\n   Explicit acknowledgements can be initiated either\
    \ by UDVM-code\n   uploaded to the decompressor by the remote compressor or by\
    \ the\n   endpoint where the states have been established.  These two cases\n\
    \   will be explained in more detail in the following two sections.\n"
- title: 5.1.1.  Remote Compressor Initiated Acknowledgements
  contents:
  - "5.1.1.  Remote Compressor Initiated Acknowledgements\n   This is the case when\
    \ e.g., compressor 1 has uploaded UDVM bytecode\n   to decompressor 2.  The UDVM\
    \ bytecode will use the requested feedback\n   field in the announcement information\
    \ and the returned feedback field\n   in the SigComp header to obtain knowledge\
    \ about established states at\n   endpoint 2.\n   Consider Figure 3.  An event\
    \ flow for successful use of remote\n   compressor initiated acknowledgements\
    \ can be as follows:\n   (1): Compressor 1 saves e.g., state(A).\n   (2): The\
    \ UDVM bytecode to initiate a state save for state(A) is\n        either carried\
    \ in the compressed message, or can be retrieved by\n        decompressor 2 from\
    \ a state already saved at endpoint 2.\n   (3): As compressor 1 is the initiator\
    \ of this acknowledgement it can\n        use an arbitrary identifier to be returned\
    \ to indicate that\n        state(A) has been established.  The identifier needs\
    \ to consist\n        of enough bits to avoid acknowledgement of wrong state.\n\
    \        To avoid padding of the feedback items and for simplicity a\n       \
    \ minimum of 1 octet should be used for the identifier.\n        The identifier\
    \ is placed at the location of the\n        requested_feedback_item [SIGCOMP].\n\
    \        The END-MESSAGE instruction is used to indicate the location of\n   \
    \     the requested_feedback_item to the state handler.\n   (4): The requested\
    \ feedback data is now called returned feedback data\n        as it is placed\
    \ into the SigComp message at compressor 2.\n   (5): The returned feedback item\
    \ is carried in the SigComp message\n        according to Figure 4: see Section\
    \ 6.1 and [SIGCOMP].\n   (6): The returned feedback item is handled according\
    \ to: Section 7\n        of [SIGCOMP]\n        +--------------+           (2)\
    \              +--------------+\n        | Compressor 1 |--------------------------->|Decompressor\
    \ 2|\n        +------^-------+                            +-------^------+\n \
    \              |    (1)                              (3)    |\n           +---v---+\
    \                                    +---v---+\n           |State  |         \
    \                           |State  |\n           |handler|                  \
    \                  |handler|\n           +---^---+                           \
    \         +---^---+\n               |    (6)                              (4)\
    \    |\n        +------v-------+           (5)              +-------v------+\n\
    \        |Decompressor 1|<---------------------------| Compressor 2 |\n      \
    \  +--------------+                            +--------------+\n            \
    \      Figure 3.  Simplified SigComp endpoints\n"
- title: 5.1.2.  Local Endpoint Initiated Acknowledgements
  contents:
  - "5.1.2.  Local Endpoint Initiated Acknowledgements\n   When explicit acknowledgements\
    \ are provided by an endpoint, the\n   SigComp message will also carry acknowledgements,\
    \ so-called\n   acked_state_id: see Section 2.  Consider Figure 3, an event flow\
    \ for\n   successful use of explicit endpoint initiated acknowledgements can be\n\
    \   as follows:\n   (1): Compressor 1 saves e.g., state(A).\n   (2): The UDVM\
    \ bytecode to initiate a state save for state(A) is\n        either carried in\
    \ the compressed message, or can be retrieved by\n        decompressor 2 from\
    \ a state already saved at endpoint 2.\n   (3): A save state request for state(A)\
    \ is passed to the state handler\n        using the END-MESSAGE instruction. \
    \ The application may then\n        grant the state handler permission to save\
    \ state(A): see\n        [SIGCOMP].\n   (4): Endpoint 2 decides to acknowledge\
    \ state(A) to endpoint 1.  The\n        state identifier (acked_state_id) for\
    \ state(A) is placed in\n        the SigComp message sent from compressor 2 to\
    \ decompressor 1.\n   (5): The UDVM bytecode to initiate (pass) the explicit\n\
    \        acknowledgement to endpoint 1 is either carried in the\n        compressed\
    \ message, or can be retrieved by decompressor 1 from a\n        state already\
    \ saved at endpoint 1.\n   (6): The acked_state_id for state(A) is passed to the\
    \ state handler\n        by placing the acked_state_id at the location of the\n\
    \        \"returned SigComp parameters\" [SIGCOMP], whose location is given\n\
    \        to the state handler using the END-MESSAGE instruction.\n   Note: When\
    \ the requested feedback length is non-zero endpoint\n   initiated acknowledgements\
    \ should not be used, due to possible waste\n   of bandwidth.  When deciding to\
    \ implement this mechanism one should\n   consider whether this is worth the effort\
    \ as all SigComp\n   implementations will support the feedback mechanism and thus\
    \ have the\n   possibility to implement the mechanism of Section 5.1.1.\n"
- title: 5.2.  Shared Compression
  contents:
  - "5.2.  Shared Compression\n   To make use of shared compression a compressing\
    \ endpoint saves the\n   uncompressed version of the compressed message as a state\
    \ (shared\n   state).  As described in Section 2 the reference to a shared state\
    \ is\n   referred to as shared_state_id.  The shared state's parameters\n   state_address\
    \ and state_instruction must be set to zero.  The\n   state_retention_priority\
    \ must be set to 65535, and the other state\n   parameters are set according to\
    \ [SIGCOMP].  This is because different\n   compression algorithms may be used\
    \ to compress application messages\n   traveling in different directions.  The\
    \ shared state is also created\n   on a per-compartment basis, i.e., the shared\
    \ state is stored in the\n   same memory as the states created by the particular\
    \ remote\n   compressor.  The choice of how to divide the state memory between\n\
    \   \"ordinary\" states and shared states is an implementation decision at\n \
    \  the compressor.  Note that new shared state items must not be created\n   unless\
    \ the compressor has made enough state memory available (as\n   decompression\
    \ failure could occur if the shared state pushed existing\n   state out of the\
    \ state memory buffer).\n   A compressing endpoint must also indicate to the remote\
    \ compressor\n   that the shared state is available, but only if the local\n \
    \  decompressor can retrieve the shared state.  The retrieval of the\n   shared\
    \ state is done according to the state retrieval instruction of\n   the UDVM.\n\
    \   Consider Figure 3.  An event flow for successful use of shared\n   compression\
    \ can be as follows:\n   (1): Compressor 1 saves e.g., state(M), which is the\
    \ uncompressed\n        version of the current application message to be compressed\
    \ and\n        sent.\n   (2): The UDVM bytecode to indicate the presence of state(M)\
    \ at\n        endpoint 1 is either carried in the compressed message, or can\n\
    \        be retrieved by decompressor 2 from a state already saved at\n      \
    \  endpoint 2.\n   (3): The SHA-1 instruction is used at endpoint 2 to calculate\
    \ the\n        shared_state_id for state(M).  The indication is passed to the\n\
    \        state handler, by placing the shared identifier at the location\n   \
    \     of the \"returned SigComp parameters\" [SIGCOMP].  The location of\n   \
    \     the \"returned SigComp parameters\" is given to the state handler\n    \
    \    using the END-MESSAGE instruction.\n   (4): If endpoint 2 uses shared compression,\
    \ it compares the state\n        identifier values in the \"returned SigComp parameters\"\
    \n        information with the value it has calculated for the current\n     \
    \   decompressed message received from endpoint 1.  If there is a\n        match\
    \ then endpoint 2 uses the shared state together with the\n        state it would\
    \ normally use if shared compression is not\n        supported to compress the\
    \ next message.\n   (5): The UDVM bytecode that will use the shared state (state(M))\
    \ in\n        the decompression process at decompressor 1 is either carried\n\
    \        in the compressed message, or can be retrieved by decompressor 1\n  \
    \      from a state already saved at endpoint 1.\n"
- title: 5.3.  Maintaining State Data Across Application Sessions
  contents:
  - "5.3.  Maintaining State Data Across Application Sessions\n   Usually, signaling\
    \ protocols (e.g., SIP) employ the concept of\n   sessions.  However, from the\
    \ compression point of view, the messages\n   sent by the same source contain\
    \ redundancies beyond the session\n   boundary.  Consequently, it is natural to\
    \ maintain the state data\n   from the same source across sessions so that high\
    \ performance can be\n   achieved and maintained, with the overhead amortized\
    \ over a much\n   longer period of time than one application session.\n   Maintaining\
    \ states across application sessions can be achieved simply\n   by making the\
    \ lifetime of a compartment longer than the time duration\n   of a single application\
    \ session.  Note that the states here are\n   referring to those stored on a per-compartment\
    \ basis, not the locally\n   available states that are stored on a global basis\
    \ (i.e., not\n   compartment specific).\n"
- title: 5.4.  Use of User-Specific Dictionary
  contents:
  - "5.4.  Use of User-Specific Dictionary\n   The concept of the user-specific dictionary\
    \ is based on the\n   observation that for protocols such as SIP, a given user/device\n\
    \   combination will produce some messages containing fields that are\n   always\
    \ populated with the same data.\n   Take SIP as an example.  Capabilities of the\
    \ SIP endpoints are\n   communicated during session initiation, and tend not to\
    \ change unless\n   the capabilities of the device change.  Similarly, user-specific\n\
    \   information such as the user's URL, name, and e-mail address will\n   likely\
    \ not change on a frequent basis, and will appear regularly in\n   SIP signaling\
    \ exchanges involving a specific user.\n   Therefore, a SigComp compressor could\
    \ include the user-specific\n   dictionary as part of the initial messages to\
    \ the decompressor, even\n   before any time critical signaling messages are generated\
    \ from a\n   particular application.  This enables an increase in compression\n\
    \   efficiency once the messages start to flow.\n   Obviously, the user-specific\
    \ dictionary is a state item that would be\n   good to have as a cross-session\
    \ state: see Section 5.3.\n"
- title: 5.5.  Checkpoint State
  contents:
  - "5.5.  Checkpoint State\n   The following mechanism can be used to avoid decompression\
    \ failure\n   due to reference to a non-existent state.  This may occur in three\n\
    \   cases: a) a state is not established at the remote SigComp endpoint\n   due\
    \ to the loss of a SigComp message; b) a state is not established\n   due to insufficient\
    \ memory; c) a state has been established but was\n   deleted later due to insufficient\
    \ memory.\n   When a compressor sends a SigComp message that will create a new\n\
    \   state on the decompressor side, it can indicate that the newly\n   created\
    \ state will be a checkpoint state by setting\n   state_retention_priority [SIGCOMP]\
    \ to the highest value sent by the\n   same compressor.  In addition, a checkpoint\
    \ state must be explicitly\n   acknowledged by the receiving decompressor to the\
    \ sending compressor.\n   Consider Figure 3.  An event flow for this kind of state\
    \ management\n   can be as follows:\n   (1): Compressor 1 saves e.g., state(A),\
    \ which it would like to have\n        as a checkpoint state at decompressor 2.\n\
    \   (2): The UDVM bytecode to indicate the state priority ([SIGCOMP]\n       \
    \ state_retention_priority) of state(A) and initiate a state save\n        for\
    \ state(A) is either carried in the compressed message, or can\n        be retrieved\
    \ by decompressor 2 from a state already saved at\n        endpoint 2.\n   (3):\
    \ A save state request for state(A) is passed to the state handler\n        using\
    \ the END-MESSAGE instruction, including the indication of\n        the state\
    \ priority.  The application grants the saving of\n        state(A): see [SIGCOMP].\n\
    \   (4): An acknowledgement for state(A) (the checkpoint state) is\n        returned\
    \ to endpoint 2 using one of the mechanisms described in\n        Section 5.1.\n\
    \   Note: To avoid using a state that has been deleted due to\n   insufficient\
    \ memory a compressor must keep track of the memory\n   available for saving states\
    \ at the remote endpoint.  The SigComp\n   parameter state_memory_size which is\
    \ announced by the SigComp\n   feedback mechanism can be used to infer if a previous\
    \ checkpoint\n   state has been deleted (by a later checkpoint state creation\
    \ request)\n   due to lack of memory.\n"
- title: 5.6.  Implicit Deletion for Dictionary Update
  contents:
  - "5.6.  Implicit Deletion for Dictionary Update\n   Usually a state consists of\
    \ two parts: UDVM bytecode and dictionary.\n   When dynamic compression is applied,\
    \ new content needs to be added to\n   the dictionary.  To keep an upper bound\
    \ of the memory consumption\n   such as in the case for a low end mobile terminal,\
    \ existing content\n   of the dictionary must be deleted to make room for the\
    \ new content.\n   Instead of explicitly signaling which parts of the dictionary\
    \ need to\n   be deleted on a per message basis, an implicit deletion approach\
    \ may\n   be applied.  Specifically, some parts of the dictionary are chosen to\n\
    \   be deleted according to a well-defined algorithm that is known and\n   applied\
    \ in the same way at both compressor and decompressor.  For\n   instance, the\
    \ algorithm can be part of the predefined UDVM bytecode\n   that is agreed between\
    \ the two SigComp endpoints.  As input to the\n   algorithm, one provides the\
    \ total number of bytes to be deleted.  The\n   algorithm then specifies which\
    \ parts of the dictionary are to be\n   deleted.  Since the same algorithm is\
    \ applied at both SigComp\n   endpoints, there is no need for explicit signaling\
    \ on a per message\n   basis.  This may lead to higher compression efficiency\
    \ due to the\n   avoidance of\n   signaling overhead.  It also means more robustness\
    \ as there are no\n   signaling bits on the wire that are subject to possible\
    \ transmission\n   errors/losses.\n"
- title: 6.  Implications on SigComp
  contents:
  - "6.  Implications on SigComp\n   The extended features will have implications\
    \ on the SigComp messages\n   sent between the compressor and its remote decompressor,\
    \ and on how\n   to interpret e.g., returned SigComp parameters [SIGCOMP].  However,\n\
    \   except for the mandatory bytes of the SigComp messages [SIGCOMP], the\n  \
    \ final message formats used are implementation issues.  Note that an\n   implementation\
    \ that does not make use of explicit acknowledgements\n   and/or shared compression\
    \ is not affected, even if it receives this\n   kind of feedback.\n"
- title: 6.1.  Implications on SigComp Messages
  contents:
  - "6.1.  Implications on SigComp Messages\n   To support the extended features,\
    \ SigComp messages must carry the\n   indications and information addressed in\
    \ Section 5.  For example to\n   support shared compression and explicit acknowledgements\
    \ the SigComp\n   messages need to convey the following information:\n   - The\
    \ acked_state_id as described in Sections 2 and 5.1.\n   - The shared_state_id\
    \ as described in Sections 2 and 5.2.\n   Figure 4 depicts the format of a SigComp\
    \ message according to\n   [SIGCOMP]:\n     0   1   2   3   4   5   6   7    \
    \   0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1 | T |  len  |   | 1   1   1   1   1 | T |   0   |\n  \
    \ +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n   |\
    \                               |   |                               |\n   :  \
    \  returned feedback item     :   :    returned feedback item     :\n   |    \
    \                           |   |                               |\n   +---+---+---+---+---+---+---+---+\
    \   +---+---+---+---+---+---+---+---+\n   |                               |  \
    \ |           code_len            |\n   :   partial state identifier    :   +---+---+---+---+---+---+---+---+\n\
    \   |                               |   |   code_len    |  destination  |\n  \
    \ +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n   |\
    \                               |   |                               |\n   :  \
    \ remaining SigComp message   :   :    uploaded UDVM bytecode     :\n   |    \
    \                           |   |                               |\n   +---+---+---+---+---+---+---+---+\
    \   +---+---+---+---+---+---+---+---+\n                                      \
    \ |                               |\n                                       :\
    \   remaining SigComp message   :\n                                       |  \
    \                             |\n                                       +---+---+---+---+---+---+---+---+\n\
    \                  Figure 4.  Format of a SigComp message\n   The format of the\
    \ field \"remaining SigComp message\" is an\n   implementation decision by the\
    \ compressor which supplies the UDVM\n   bytecode.  Therefore there is no need\
    \ to specify a message format to\n   carry the information necessary for the extended\
    \ features described\n   in this document.\n   Figure 5 depicts an example of\
    \ what the \"remaining SigComp message\"\n   with support for shared compression\
    \ and explicit acknowledgements,\n   could look like.  Note that this is only\
    \ an example; the format is an\n   implementation decision.\n     0   1   2  \
    \ 3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | Format according\
    \ to Figure 4  |\n   :   except for the field called :\n   |   \"remaining SigComp\
    \ message\" |   \"remaining SigComp message\" field\n   +---+---+---+---+---+---+---+---+\
    \             --------\n   | s | a | r |    Reserved       |                |\n\
    \   +---+---+---+---+---+---+---+---+                |\n   |                 \
    \              |                |\n   :       shared_state_id*        : Present\
    \ if 's' is set\n   |                               |                |\n   +---+---+---+---+---+---+---+---+\
    \                |\n   |                               |                |\n  \
    \ :       acked_state_id*         : Present if 'a' is set\n   |              \
    \                 |                |\n   +---+---+---+---+---+---+---+---+   \
    \             |\n   |                               |                |\n   : \
    \ Rest of the SigComp message  :                |\n   |                      \
    \         |                v\n   +---+---+---+---+---+---+---+---+          --------------\n\
    \   Figure 5. Example of SigComp message for some of the extended\n          \
    \   features.\n   'r' : If set, then a state corresponding to the decompressed\n\
    \         version of this compressed message (shared state) was saved at\n   \
    \      the compressor.\n    *  : The length of the shared_state_id and acked_state_id\
    \ fields\n         are of the same length as the partial state identifier.\n"
- title: 6.2.  Extended SigComp Announcement/Feedback Format
  contents:
  - "6.2.  Extended SigComp Announcement/Feedback Format\n   This section describes\
    \ how the \"returned_SigComp_parameters\"\n   [SIGCOMP] information is interpreted\
    \ to provide feedback according to\n   Section 5.1 and 5.2.\n   The partial_state_identifiers\
    \ correspond to the hash_value for states\n   that have been established at the\
    \ remote endpoint after the reception\n   of SigComp messages, i.e., these are\
    \ acknowledgements for established\n   states and may be used for compression.\
    \  The\n   partial_state_identifiers may also announce \"global state\" that is\n\
    \   not mapped to any particular compartment and is not established upon\n   the\
    \ receipt of a SigComp message.\n   It is up to the implementation to deduce what\
    \ kind of state each\n   partial_state_identifier refers to, e.g., an acknowledged\
    \ state or a\n   shared state.  In case a SigComp message that includes state\n\
    \   identifiers for shared states and/or acknowledged states is received\n   by\
    \ a basic SigComp implementation, these identifiers will be ignored.\n   The I-bit\
    \ of the requested feedback format is provided to switch off\n   the list of locally\
    \ available state items.  An endpoint that wishes\n   to receive shared_state_id\
    \ must not set the I-bit to 1.  The endpoint\n   storing shared states and sending\
    \ the list of locally available\n   states to its remote endpoint must be careful\
    \ when taking the\n   decision whether to exclude or include different types of\
    \ the locally\n   available states (i.e., shared states or states of e.g., well-known\n\
    \   algorithms) from/to the list.\n"
- title: 6.3.  Acknowledgement Optimization
  contents:
  - "6.3.  Acknowledgement Optimization\n   If shared compression is used between\
    \ two endpoints (see Figure 1)\n   then there exists an optimization, which, if\
    \ implemented, makes an\n   acked_state_id in the SigComp message unnecessary:\n\
    \   Compressor 1 saves a shared state(M), which is the uncompressed\n   version\
    \ of the current compressed message (message m) to be sent.\n   Compressor 1 also\
    \ sets bit 'r' (see Figure 5), to signal that\n   state(M) can be used by endpoint\
    \ 2 in the compression process.  The\n   acked_state_id for state(S), which was\
    \ created at endpoint 2 upon the\n   decompression of message m, may not have\
    \ to be explicitly placed in\n   the compressed messages from compressor 2 if\
    \ the shared state(M) is\n   used in the compression process.\n   When endpoint\
    \ 1 notices that shared state(M) is requested by\n   decompressor 1, it implicitly\
    \ knows that state(S) was created at\n   endpoint 2.  This follows since:\n  \
    \ * Compressor 1 has instructed decompressor 2 to save state(S).\n   * The indication\
    \ of shared state(M) would never have been received by\n     compressor 2 if state(S)\
    \ had not been successfully saved, because\n     if a state save request is denied\
    \ then the corresponding\n     announcement information is discarded by the state\
    \ handler.\n   Note: Endpoint 1's state handler must maintain a mapping between\n\
    \   state(M) and state(S) for this optimization to work.\n   Note: The only state\
    \ that is acknowledged by this feature is the\n   state that was created by combining\
    \ the state used for compression of\n   the message and the message itself.  For\
    \ any other case the\n   acked_state_id has to be used.\n   Note: There is a possibility\
    \ that state(S) is discarded due to lack\n   of state memory even though the announcement\
    \ information is\n   successfully forwarded.  This possibility must be taken into\
    \ account\n   (otherwise a decompression failure may occur); this can be done\
    \ by\n   using the SigComp parameter state_memory_size which is announced by\n\
    \   the SigComp feedback mechanism.  The endpoint can use this parameter\n   to\
    \ infer if a state creation request has failed due to lack of\n   memory.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The features in this document are believed not\
    \ to add any security\n   risks to the ones mentioned in [SIGCOMP].\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document does not require any IANA involvement.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   Thanks to Carsten Bormann, Christopher Clanton, Miguel\
    \ Garcia, Lars-\n   Erik Jonsson, Khiem Le, Mats Nordberg, Jonathan Rosenberg\
    \ and Krister\n   Svanbro for valuable input.\n"
- title: 10.  Intellectual Property Right Considerations
  contents:
  - "10.  Intellectual Property Right Considerations\n   The IETF has been notified\
    \ of intellectual property rights claimed in\n   regard to some or all of the\
    \ specification contained in this\n   document.  For more information consult\
    \ the online list of claimed\n   rights.\n"
- title: 11.  References
  contents:
  - "11.  References\n   [SIP]       Rosenberg, J., Schulzrinne, H., Camarillo, G.,\
    \ Johnston,\n               A., Peterson, J., Sparks, R., Handley, M. and E.\n\
    \               Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n  \
    \             June 2002.\n   [SIGCOMP]   Price R., Bormann, C., Christoffersson,\
    \ J., Hannu, H.,\n               Liu, Z. and J. Rosenberg, \"Signaling Compression\n\
    \               (SigComp)\", RFC 3320, January 2003.\n"
- title: 12.  Authors' Addresses
  contents:
  - "12.  Authors' Addresses\n   Hans Hannu\n   Box 920\n   Ericsson AB\n   SE-971\
    \ 28 Lulea, Sweden\n   Phone: +46 920 20 21 84\n   EMail: hans.hannu@epl.ericsson.se\n\
    \   Jan Christoffersson\n   Box 920\n   Ericsson AB\n   SE-971 28 Lulea, Sweden\n\
    \   Phone: +46 920 20 28 40\n   EMail: jan.christoffersson@epl.ericsson.se\n \
    \  Stefan Forsgren\n   EMail: StefanForsgren@alvishagglunds.se\n   Ka-Cheong Leung\n\
    \   Department of Computer Science\n   Texas Tech University\n   Lubbock, TX 79409-3104\n\
    \   United States of America\n   Phone: +1 806 742-3527\n   EMail: kcleung@cs.ttu.edu\n\
    \   Zhigang Liu\n   Nokia Research Center\n   6000 Connection Drive\n   Irving,\
    \ TX 75039, USA\n   Phone: +1 972 894-5935\n   EMail: zhigang.c.liu@nokia.com\n\
    \   Richard Price\n   Roke Manor Research Ltd\n   Romsey, Hants, SO51 0ZN, United\
    \ Kingdom\n   Phone: +44 1794 833681\n   EMail: richard.price@roke.co.uk\n"
- title: 13.  Full Copyright Statement
  contents:
  - "13.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
