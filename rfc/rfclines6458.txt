Abstract This document describes a mapping of the Stream Control Transmission Protocol (SCTP) into a sockets API.
The benefits of this mapping include compatibility for TCP applications, access to new SCTP features, and a consolidated error and event notification scheme.
The sockets API has provided a standard mapping of the Internet Protocol suite to many operating systems.
Both TCP [RFC0793] and UDP [RFC0768] have benefited from this standard representation and access method across many diverse platforms.
SCTP is a new protocol that provides many of the characteristics of TCP but also incorporates semantics more akin to UDP.
This document defines a method to map the existing sockets API for use with SCTP, providing both a base for access to new features and compatibility so that most existing TCP applications can be migrated to SCTP with few (if any) changes.
There are three basic design objectives: 1.
Maintain consistency with existing sockets APIs: We define a sockets mapping for SCTP that is consistent with other sockets API protocol mappings (for instance UDP, TCP, IPv4, and IPv6).
Support a one to many style interface: This set of semantics is similar to that defined for connectionless protocols, such as UDP.
A one to many style SCTP socket should be able to control multiple SCTP associations.
This is similar to a UDP socket, which can communicate with many peer endpoints.
Each of these associations is assigned an association identifier so that an application can use the ID to differentiate them.
Note that SCTP is connection oriented in nature, and it does not support broadcast or multicast communications, as UDP does.
Support a one to one style interface
: This interface supports a similar semantics as sockets for connection oriented protocols, such as TCP.
A one to one style SCTP socket should only control one SCTP association.
One purpose of defining this interface is to allow existing applications built on other connection oriented protocols to be ported to use SCTP with very little effort.
Developers familiar with these semantics can easily adapt to SCTP.
Another purpose is to make sure that existing mechanisms in most operating systems that support sockets, such as select(), should continue to work with this style of socket.
Extensions are added to this mapping to provide mechanisms to exploit new features of SCTP.
Goals 2 and 3 are not compatible, so this document defines two modes of mapping, namely the one to many style mapping and the one to one style mapping.
These two modes share some common data structures and operations, but will require the use of two different application programming styles.
Note that all new SCTP features can be used with both styles of socket.
The decision on which one to use depends mainly on the nature of the applications.
A mechanism is defined to extract an SCTP association from a one to  many style socket into a one to one style socket.
Some of the SCTP mechanisms cannot be adequately mapped to an existing socket interface.
In some cases, it is more desirable to have a new interface instead of using existing socket calls.
Section 9 of this document describes these new interfaces.
Please note that some elements of the SCTP sockets API are declared as deprecated.
During the evolution of this document, elements of the API were introduced, implemented, and later on replaced by other elements.
These replaced elements are declared as deprecated, since they are still available in some implementations and the replacement functions are not.
This applies especially to older versions of operating systems supporting SCTP.
New SCTP socket implementations must implement at least the non deprecated elements.
Implementations intending interoperability with older versions of the API should also include the deprecated functions.
Whenever possible, Portable Operating System Interface (POSIX) data types defined in [IEEE 1003.1 2008] are used: uintN t means an unsigned integer of exactly N bits (e.g., uint16 t).
This document also assumes the argument data types from POSIX when possible (e.g., the final argument to setsockopt() is a socklen t value).
Whenever buffer sizes are specified, the POSIX size t data type is used.
One to Many Style Interface
In the one to many style interface, there is a one to many relationship between sockets and associations.
Basic Operation A typical server in this style uses the following socket calls in sequence to prepare an endpoint for servicing requests:  socket()  bind()  listen()  recvmsg()  sendmsg()
A typical client uses the following calls in sequence to set up an association with a server to request services:  socket()  sendmsg()  recvmsg()  close()
In this style, by default, all of the associations connected to the endpoint are represented with a single socket.
Each association is assigned an association identifier (the type is sctp assoc t) so that an application can use it to differentiate among them.
In some implementations, the peer endpoints' addresses can also be used for this purpose.
But this is not required for performance reasons.
If an implementation does not support using addresses to differentiate between different associations, the sendto() call can only be used to set up an association implicitly.
It cannot be used to send data to an established association, as the association identifier cannot be specified.
Once an association identifier is assigned to an SCTP association, that identifier will not be reused until the application explicitly terminates the use of the association.
The resources belonging to that association will not be freed until that happens.
This is similar to the close() operation on a normal socket.
The only exception is when the SCTP AUTOCLOSE option (Section 8.1.8) is set.
In this case, after the association is terminated gracefully and automatically, the association identifier assigned to it can be reused.
All applications using this option should be aware of this to avoid the possible problem of sending data to an incorrect peer endpoint.
If the server or client wishes to branch an existing association off to a separate socket, it is required to call sctp peeloff() and to specify the association identifier.
The sctp peeloff() call will return a new one to one style socket that can then be used with recv() and send() functions for message passing.
See Section 9.2 for more on branched off associations.
Once an association is branched off to a separate socket, it becomes completely separated from the original socket.
All subsequent control and data operations to that association must be done through the new socket.
For example, the close() operation on the original socket will not terminate any associations that have been branched off to a different socket.
One to many style socket calls are discussed in more detail in the following subsections.
Applications use socket() to create a socket descriptor to represent an SCTP endpoint.
The function prototype is int socket(int domain, int type, int protocol); and one uses PF INET or PF INET6 as the domain
, SOCK SEQPACKET as the type, and IPPROTO SCTP as the protocol.
Here, SOCK SEQPACKET indicates the creation of a one to many style socket.
The function returns a socket descriptor, or  1 in case of an error.
Using the PF INET domain indicates the creation of an endpoint that can use only IPv4 addresses, while PF INET6 creates an endpoint that can use both IPv6 and IPv4 addresses.
Applications use bind() to specify with which local address and port the SCTP endpoint should associate itself.
An SCTP endpoint can be associated with multiple addresses.
To do this, sctp bindx() is introduced in Section 9.1 to help applications do the job of associating multiple addresses.
But note that an endpoint can only be associated with one local port.
These addresses associated with a socket are the eligible transport addresses for the endpoint to send and receive data.
The endpoint will also present these addresses to its peers during the association initialization process; see [RFC4960].
After calling bind(), if the endpoint wishes to accept new associations on the socket, it must call listen() (see Section 3.1.3).
The function prototype of bind() is int
bind(int sd, struct sockaddr  addr, socklen t addrlen); and the arguments are sd:
The socket descriptor returned by socket().
The address structure (struct sockaddr in for an IPv4 address or struct sockaddr in6 for an IPv6 address; see [RFC3493]).
The size of the address structure.
() returns 0 on success and  1 in case of an error.
If sd is an IPv4 socket, the address passed must be an IPv4 address.
If the sd is an IPv6 socket, the address passed can either be an IPv4 or an IPv6 address.
Applications cannot call bind() multiple times to associate multiple addresses to an endpoint.
After the first call to bind(), all subsequent calls will return an error.
If the IP address part of addr is specified as a wildcard (INADDR ANY for an IPv4 address, or as IN6ADDR ANY INIT or in6addr
any for an IPv6 address), the operating system will associate the endpoint with an optimal address set of the available interfaces.
If the IPv4 sin port or IPv6 sin6 port is set to 0, the operating system will choose an ephemeral port for the endpoint.
If bind() is not called prior to a sendmsg() call that initiates a new association, the system picks an ephemeral port and will choose an address set equivalent to binding with a wildcard address.
One of those addresses will be the primary address for the association.
This automatically enables the multi homing capability of SCTP.
The completion of this bind() process does not allow the SCTP endpoint to accept inbound SCTP association requests.
Until a listen() system call, described below, is performed on the socket, the SCTP endpoint will promptly reject an inbound SCTP INIT request with an SCTP ABORT.
By default, a one to many style socket does not accept new association requests.
An application uses listen() to mark a socket as being able to accept new associations.
The function prototype is int listen(int sd, int backlog); and the arguments are sd:
The socket descriptor of the endpoint.
If backlog is non zero, enable listening, else disable listening.
listen() returns 0 on success and  1 in case of an error.
Note that one to many style socket consumers do not need to call accept() to retrieve new associations.
on a one to  many style socket should return EOPNOTSUPP.
Rather, new associations are accepted automatically, and notifications of the new associations are delivered via recvmsg() with the SCTP ASSOC CHANGE event (if these notifications are enabled).
Clients will typically not call listen(), so that they can be assured that only actively initiated associations are possible on the socket.
Server or peer to peer sockets, on the other hand, will always accept new associations, so a well written application using server one to many style sockets must be prepared to handle new associations from unwanted peers.
Also note that the SCTP ASSOC CHANGE event provides the association identifier for a new association, so if applications wish to use the association identifier as a parameter to other socket calls, they should ensure that the SCTP ASSOC CHANGE event is enabled.
An application uses the sendmsg() and recvmsg() calls to transmit data to and receive data from its peer.
The function prototypes are ssize t sendmsg(int sd, const struct msghdr  message, int flags); and ssize t recvmsg(int sd, struct msghdr  message, int flags); using the following arguments: sd:
The socket descriptor of the endpoint.
message:  Pointer to the msghdr structure that contains a single user message and possibly some ancillary data.
See Section 5 for a complete description of the data structures.
No new flags are defined for SCTP at this level.
See Section 5 for SCTP specific flags used in the msghdr structure.
() returns the number of bytes accepted by the kernel or  1 in case of an error.
recvmsg() returns the number of bytes received or  1 in case of an error.
As described in Section 5, different types of ancillary data can be sent and received along with user data.
When sending, the ancillary data is used to specify the sent behavior, such as the SCTP stream number to use.
When receiving, the ancillary data is used to describe the received data, such as the SCTP stream sequence number of the message.
When sending user data with sendmsg(), the msg name field in the msghdr structure will be filled with one of the transport addresses of the intended receiver.
If there is no existing association between the sender and the intended receiver, the sender's SCTP stack will set up a new association and then send the user data (see Section 7.5 for more on implicit association setup).
If sendmsg() is called with no data and there is no existing association, a new one will be established.
The SCTP INIT type ancillary data can be used to change some of the parameters used to set up a new association.
If sendmsg() is called with NULL data, and there is no existing association but the SCTP ABORT or SCTP EOF flags are set as described in Section 5.3.4,
then  1 is returned and errno is set to EINVAL.
Sending a message using sendmsg() is atomic unless explicit end of record (EOR) marking is enabled on the socket specified by sd (see Section 8.1.26).
If a peer sends a SHUTDOWN, an SCTP SHUTDOWN EVENT notification will be delivered if that notification has been enabled, and no more data can be sent to that association.
Any attempt to send more data will cause sendmsg() to return with an ESHUTDOWN error.
Note that the socket is still open for reading at this point
, so it is possible to retrieve notifications.
When receiving a user message with recvmsg(), the msg name field in the msghdr structure will be populated with the source transport address of the user data.
The caller of recvmsg() can use this address information to determine to which association the received user message belongs.
Note that if SCTP ASSOC CHANGE events are disabled, applications must use the peer transport address provided in the msg name field by recvmsg() to perform correlation to an association, since they will not have the association identifier.
If all data in a single message has been delivered, MSG EOR will be set in the msg flags field of the msghdr structure (see Section 5.1).
If the application does not provide enough buffer space to completely receive a data message, MSG EOR will not be set in msg flags.
Successive reads will consume more of the same message until the entire message has been delivered, and MSG EOR will be set.
If the SCTP stack is running low on buffers, it may partially deliver a message.
In this case, MSG EOR will not be set, and more calls to recvmsg
() will be necessary to completely consume the message.
Only one message at a time can be partially delivered in any stream.
FRAGMENT INTERLEAVE controls various aspects of what interlacing of messages occurs for both the one to one and the one to many style sockets.
Please consult Section 8.1.20 for further details on message delivery options.
close() Applications use close() to perform graceful shutdown (as described in Section 10.1 of [RFC4960])
on all of the associations currently represented by a one to many style socket.
The function prototype is int close(int sd); and the argument is sd:
The socket descriptor of the associations to be closed.
0 is returned on success and  1 in case of an error.
To gracefully shut down a specific association represented by the one to many style socket, an application should use the sendmsg() call and include the SCTP EOF flag.
A user may optionally terminate an association non gracefully by using sendmsg() with the SCTP ABORT flag set and possibly passing a user specified abort code in the data field.
Both flags SCTP EOF and SCTP ABORT
are passed with ancillary data (see Section 5.3.4) in the sendmsg() call.
If sd in the close() call is a branched off socket representing only one association, the shutdown is performed on that association only.
An application may use the connect() call in the one to many style to initiate an association without sending data.
The function prototype is int connect(int
nam, socklen t len); and
The socket descriptor to which a new association is added.
The address structure (struct sockaddr in for an IPv4 address or struct sockaddr in6 for an IPv6 address; see [RFC3493]).
The size of the address.
0 is returned on success and  1 in case of an error.
Multiple connect() calls can be made on the same socket to create multiple associations.
This is different from the semantics of connect() on a UDP socket.
Note that SCTP allows data exchange, similar to T/TCP [RFC1644] (made Historic by [RFC6247]), during the association setup phase.
If an application wants to do this, it cannot use the connect() call.
Instead, it should use sendto() or sendmsg() to initiate an association.
If it uses sendto() and it wants to change the initialization behavior, it needs to use the SCTP INITMSG socket option before calling sendto().
Or it can use sendmsg() with SCTP INIT type ancillary data to initiate an association without calling setsockopt().
Note that the implicit setup is supported for the one to many style sockets.
SCTP does not support half close semantics.
This means that unlike T/TCP, MSG EOF should not be set in the flags parameter when calling sendto() or sendmsg() when the call is used to initiate a connection.
MSG EOF is not an acceptable flag with an SCTP socket.
Some SCTP applications may wish to avoid being blocked when calling a socket interface function.
Once a bind() call and/or subsequent sctp bindx() calls are complete on a one to many style socket, an application may set the non blocking option via a fcntl() (such as O NONBLOCK).
After setting the socket to non blocking mode, the sendmsg() function returns immediately.
The success or failure of sending the data message (with possible SCTP INITMSG ancillary data) will be signaled by the SCTP
ASSOC CHANGE event with SCTP
COMM UP or SCTP CANT START ASSOC.
If user data could not be sent (due to an SCTP CANT START ASSOC), the sender will also receive an SCTP SEND FAILED EVENT event.
Events can be received by the user calling recvmsg().
A server (having called listen()) is also notified of an association up event via the reception of an SCTP
ASSOC CHANGE with SCTP COMM UP via the calling of recvmsg() and possibly the reception of the first data message.
To shut down the association gracefully, the user must call sendmsg() with no data and with the SCTP EOF flag set as described in Section 5.3.4.
The function returns immediately, and completion of the graceful shutdown is indicated by an SCTP
ASSOC CHANGE notification of type SCTP SHUTDOWN COMP (see Section 6.1.1).
Note that this can also be done using the sctp sendv() call described in Section 9.12.
It is recommended that an application use caution when using select() (or poll()) for writing on a one to many style socket, because the interpretation of select() on write is implementation specific.
Generally, a positive return on a select() on write would only indicate that one of the associations represented by the one to many style socket is writable.
An application that writes after the select() returns may still block, since the association that was writable is not the destination association of the write call.
Likewise, select() (or poll()) for reading from a one to many style socket will only return an indication that one of the associations represented by the socket has data to be read.
An application that wishes to know that a particular association is ready for reading or writing should either use the one to one style or use the sctp peeloff() function (see Section 9.2) to separate the association of interest from the one to many style socket.
Note that some implementations may have an extended select call, such as epoll or kqueue, that may escape this limitation and allow a select on a specific association of a one to many style socket, but this is an implementation specific detail that a portable application cannot depend on.
The fact that a one to many style socket can provide access to many SCTP associations through a single socket descriptor has important implications for both application programmers and system programmers implementing this API.
A key issue is how buffer space inside the sockets layer is managed.
Because this implementation detail directly affects how application programmers must write their code to ensure correct operation and portability, this section provides some guidance to both implementers and application programmers.
An important feature that SCTP shares with TCP is flow control.
Specifically, a sender may not send data faster than the receiver can consume it.
For TCP, flow control is typically provided for in the sockets API as follows.
If the reader stops reading, the sender queues messages in the socket layer until the send socket buffer is completely filled.
This results in a "stalled connection".
Further attempts to write to the socket will block or return the error EAGAIN or EWOULDBLOCK for a non blocking socket.
At some point, either the connection is closed, or the receiver begins to read, again freeing space in the output queue.
For one to many style SCTP sockets, there are multiple associations for a single socket, which makes the situation more complicated.
If the implementation uses a single buffer space allocation shared by all associations, a single stalled association can prevent the further sending of data on all associations active on a particular one to many style socket.
For a blocking socket, it should be clear that a single stalled association can block the entire socket.
For this reason, application programmers may want to use non blocking one to many style sockets.
The application should at least be able to send messages to the non stalled associations.
But a non blocking socket is not sufficient if the API implementer has chosen a single shared buffer allocation for the socket.
A single stalled association would eventually cause the shared allocation to fill, and it would become impossible to send even to non stalled associations.
The API implementer can solve this problem by providing each association with its own allocation of outbound buffer space.
Each association should conceptually have as much buffer space as it would have if it had its own socket.
As a bonus, this simplifies the implementation of sctp peeloff().
To ensure that a given stalled association will not prevent other non stalled associations from being writable, application programmers should either  demand that the underlying implementation dedicates independent buffer space reservation to each association (as suggested above), or  verify that their application layer protocol does not permit large amounts of unread data at the receiver
(this is true of some request response protocols, for example), or  use one to one style sockets for association, which may potentially stall (either from the beginning, or by using sctp peeloff() before sending large amounts of data that may cause a stalled condition).
One to One Style Interface
The goal of this style is to follow as closely as possible the current practice of using the sockets interface for a connection  oriented protocol such as TCP.
This style enables existing applications using connection oriented protocols to be ported to SCTP with very little effort.
One to one style sockets can be connected (explicitly or implicitly) at most once, similar to TCP sockets.
Note that some new SCTP features and some new SCTP socket options can only be utilized through the use of sendmsg() and recvmsg()
; see Section 4.1.8. 4.1.
Basic Operation A typical one to one style server uses the following system call sequence to prepare an SCTP endpoint for servicing requests:  socket()  bind()
The accept() call blocks until a new association is set up.
It returns with a new socket descriptor.
The server then uses the new socket descriptor to communicate with the client, using recv() and send() calls to get requests and send back responses.
Then it calls  close() to terminate the association.
A typical client uses the following system call sequence to set up an association with a server to request services:  socket()  connect()
After returning from the connect() call, the client uses send()/ sendmsg() and recv()/recvmsg
() calls to send out requests and receive responses from the server.
The client calls  close() to terminate this association when done.
Applications call socket() to create a socket descriptor to represent an SCTP endpoint.
The function prototype is int socket(int domain, int type, int protocol); and one uses PF INET or PF INET6 as the domain, SOCK STREAM as the type, and IPPROTO SCTP as the protocol.
Here, SOCK STREAM indicates the creation of a one to one style socket.
Using the PF INET domain indicates the creation of an endpoint that can use only IPv4 addresses, while PF INET6 creates an endpoint that can use both IPv6 and IPv4 addresses.
Applications use bind() to specify with which local address and port the SCTP endpoint should associate itself.
An SCTP endpoint can be associated with multiple addresses.
To do this, sctp bindx() is introduced in Section 9.1 to help applications do the job of associating multiple addresses.
But note that an endpoint can only be associated with one local port.
These addresses associated with a socket are the eligible transport addresses for the endpoint to send and receive data.
The endpoint will also present these addresses to its peers during the association initialization process; see [RFC4960].
The function prototype of bind() is int
bind(int sd, struct sockaddr  addr, socklen t addrlen); and the arguments are sd:
The socket descriptor returned by socket().
The address structure (struct sockaddr in for an IPv4 address or struct sockaddr in6 for an IPv6 address; see [RFC3493]).
The size of the address structure.
If sd is an IPv4 socket, the address passed must be an IPv4 address.
If sd is an IPv6 socket, the address passed can either be an IPv4 or an IPv6 address.
Applications cannot call bind() multiple times to associate multiple addresses to the endpoint.
After the first call to bind(), all subsequent calls will return an error.
If the IP address part of addr is specified as a wildcard (INADDR ANY for an IPv4 address, or as IN6ADDR ANY INIT or in6addr
any for an IPv6 address), the operating system will associate the endpoint with an optimal address set of the available interfaces.
If the IPv4 sin port or IPv6 sin6 port is set to 0, the operating system will choose an ephemeral port for the endpoint.
If bind() is not called prior to the connect() call, the system picks an ephemeral port and will choose an address set equivalent to binding with a wildcard address.
One of these addresses will be the primary address for the association.
This automatically enables the multi homing capability of SCTP.
The completion of this bind() process does not allow the SCTP endpoint to accept inbound SCTP association requests.
Until a listen() system call, described below, is performed on the socket, the SCTP endpoint will promptly reject an inbound SCTP INIT request with an SCTP ABORT.
Applications use listen() to allow the SCTP endpoint to accept inbound associations.
The function prototype is int listen(int sd, int backlog); and the arguments are sd:
The socket descriptor of the SCTP endpoint.
Specifies the max number of outstanding associations allowed in the socket's accept queue.
These are the associations that have finished the four way initiation handshake (see Section 5 of [RFC4960]) and are in the ESTABLISHED state.
Note that a backlog of '0' indicates that the caller no longer wishes to receive new associations.
listen() returns 0 on success and  1 in case of an error.
accept() Applications use the accept()
call to remove an established SCTP association from the accept queue of the endpoint.
A new socket descriptor will be returned from accept() to represent the newly formed association.
The function prototype is int accept(int
sd, struct sockaddr  addr, socklen t  addrlen); and the arguments are sd:  The listening socket descriptor.
On return, addr (struct sockaddr in for an IPv4 address or struct sockaddr in6 for an IPv6 address; see [RFC3493]) will contain the primary address of the peer endpoint.
On return, addrlen will contain the size of addr.
The function returns the socket descriptor for the newly formed association on success and  1 in case of an error.
Applications use connect() to initiate an association to a peer.
The function prototype is int connect(int
, const struct sockaddr  addr, socklen t addrlen); and
The socket descriptor of the endpoint.
The peer's (struct sockaddr in for an IPv4 address or struct sockaddr in6 for an IPv6 address; see [RFC3493]) address.
The size of the address.
connect() returns 0 on success and  1 on error.
This operation corresponds to the ASSOCIATE primitive described in Section 10.1 of [RFC4960].
The number of outbound streams the new association has is stack dependent.
Before connecting, applications can use the SCTP INITMSG option described in Section 8.1.3 to change the number of outbound streams.
If bind() is not called prior to the connect() call, the system picks an ephemeral port and will choose an address set equivalent to binding with INADDR ANY and IN6ADDR
ANY INIT for IPv4 and IPv6 sockets, respectively.
One of the addresses will be the primary address for the association.
This automatically enables the multi homing capability of SCTP.
Note that SCTP allows data exchange, similar to T/TCP [RFC1644] (made Historic by [RFC6247]), during the association setup phase.
If an application wants to do this, it cannot use the connect() call.
Instead, it should use sendto() or sendmsg() to initiate an association.
If it uses sendto() and it wants to change the initialization behavior, it needs to use the SCTP INITMSG socket option before calling sendto().
Or it can use sendmsg() with SCTP INIT type ancillary data to initiate an association without calling setsockopt().
Note that the implicit setup is supported for the one to one style sockets.
SCTP does not support half close semantics.
This means that unlike T/TCP, MSG EOF should not be set in the flags parameter when calling sendto() or sendmsg() when the call is used to initiate a connection.
MSG EOF is not an acceptable flag with an SCTP socket.
to gracefully close down an association.
The function prototype is int close(int sd); and the argument is sd:
The socket descriptor of the association to be closed.
close() returns 0 on success and  1 in case of an error.
After an application calls close() on a socket descriptor, no further socket operations will succeed on that descriptor.
shutdown() SCTP differs from TCP in that it does not have half close semantics.
Hence, the shutdown() call for SCTP is an approximation of the TCP shutdown() call, and solves some different problems.
Full TCP compatibility is not provided, so developers porting TCP applications to SCTP may need to recode sections that use shutdown().
(Note that it is possible to achieve the same results as half close in SCTP using SCTP streams.)
The function prototype is int shutdown(int sd
The socket descriptor of the association to be closed.
how:  Specifies the type of shutdown.
The values are as follows:
No SCTP protocol action is taken.
Disables further send operations, and initiates the SCTP shutdown sequence.
Disables further send and receive operations, and initiates the SCTP shutdown sequence.
shutdown() returns 0 on success and  1 in case of an error.
The major difference between SCTP and TCP shutdown() is that SCTP SHUT WR initiates immediate and full protocol shutdown, whereas TCP SHUT WR causes TCP to go into the half close state.
SHUT RD behaves the same for SCTP as for TCP.
The purpose of SCTP SHUT WR is to close the SCTP association while still leaving the socket descriptor open.
This allows the caller to receive back any data that SCTP is unable to deliver (see Section 6.1.4 for more information) and receive event notifications.
To perform the ABORT operation described in Section 10.1 of [RFC4960], an application can use the socket option SO LINGER.
SO LINGER is described in Section 8.1.4.
With a one to one style socket, the application can also use sendmsg() and recvmsg() to transmit data to and receive data from its peer.
The semantics is similar to those used in the one to many style (see Section 3.1.4), with the following differences: 1.
When sending, the msg name field in the msghdr is not used to specify the intended receiver; rather, it is used to indicate a preferred peer address if the sender wishes to discourage the stack from sending the message to the primary address of the receiver.
If the socket is connected and the transport address given is not part of the current association, the data will not be sent, and an SCTP SEND FAILED EVENT event will be delivered to the application if send failure events are enabled.
Using sendmsg() on a non connected one to one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.
getpeername() Applications use getpeername() to retrieve the primary socket address of the peer.
This call is for TCP compatibility and is not multi homed.
It may not work with one to many style sockets, depending on the implementation.
See Section 9.3 for a multi homed style version of the call.
The function prototype is int getpeername(int sd, struct sockaddr  address, socklen t  len); and the arguments are sd:
The socket descriptor to be queried.
On return, the peer primary address is stored in this buffer.
If the socket is an IPv4 socket, the address will be IPv4.
If the socket is an IPv6 socket, the address will be either an IPv6 or IPv4 address.
The caller should set the length of address here.
On return, this is set to the length of the returned address.
getpeername() returns 0 on success and  1 in case of an error.
If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address will be truncated.
This section discusses important data structures that are specific to SCTP and are used with sendmsg() and recvmsg()
calls to control SCTP endpoint operations and to access ancillary information and notifications.
The msghdr and cmsghdr Structures
The msghdr structure used in the sendmsg() and recvmsg() calls, as well as the ancillary data carried in the structure, is the key for the application to set and get various control information from the SCTP endpoint.
The msghdr and the related cmsghdr structures are defined and discussed in detail in [RFC3542].
/ socklen t msg controllen
The scatter/gather buffers, or I/
O vectors (pointed to by the msg iov field) are treated by SCTP as a single user message for both sendmsg() and recvmsg().
The SCTP stack uses the ancillary data (msg control field) to communicate the attributes, such as SCTP RCVINFO, of the message stored in msg iov to the socket endpoint.
The different ancillary data types are described in Section 5.3.
The msg flags are not used when sending a message with sendmsg().
If a notification has arrived, recvmsg() will return the notification in the msg iov field and set the MSG NOTIFICATION flag in msg flags.
If the MSG NOTIFICATION flag is not set, recvmsg() will return data.
See Section 6 for more information about notifications.
If all portions of a data frame or notification have been read, recvmsg() will return with MSG EOR set in msg flags.
Ancillary Data Considerations and Semantics Programming with ancillary socket data (msg control) contains some subtleties and pitfalls, which are discussed below.
Multiple Items and Ordering Multiple ancillary data items may be included in any call to sendmsg() or recvmsg(); these may include multiple SCTP items, non SCTP items (such as IP level items), or both.
The ordering of ancillary data items (either by SCTP or another protocol) is not significant and is implementation dependent, so applications must not depend on any ordering.
SCTP SNDINFO/SCTP RCVINFO type ancillary data always corresponds to the data in the msghdr's msg iov member.
There can be only one such type of ancillary data for each sendmsg() or recvmsg() call.
Accessing and Manipulating Ancillary Data Applications can infer the presence of data or ancillary data by examining the msg iovlen and msg controllen msghdr members, respectively.
Implementations may have different padding requirements for ancillary data, so portable applications should make use of the macros CMSG FIRSTHDR, CMSG NXTHDR, CMSG DATA, CMSG SPACE, and CMSG LEN.
See [RFC3542] and the SCTP implementation's documentation for more information.
; cmsgptr   CMSG NXTHDR(&msg, cmsgptr))
Control Message Buffer Sizing The information conveyed via SCTP SNDRCV/SCTP SNDINFO/SCTP RCVINFO ancillary data will often be fundamental to the correct and sane operation of the sockets application.
This is particularly true for one to many style sockets, but also for one to one style sockets.
For example, if an application needs to send and receive data on different SCTP streams, SCTP SNDRCV/SCTP SNDINFO/SCTP RCVINFO ancillary data is indispensable.
Given that some ancillary data is critical, and that multiple ancillary data items may appear in any order, applications should be carefully written to always provide a large enough buffer to contain all possible ancillary data that can be presented by recvmsg().
If the buffer is too small, and crucial data is truncated, it may pose a fatal error condition.
Thus, it is essential that applications be able to deterministically calculate the maximum required buffer size to pass to recvmsg().
One constraint imposed on this specification that makes this possible is that all ancillary data definitions are of a fixed length.
One way to calculate the maximum required buffer size might be to take the sum of the sizes of all enabled ancillary data item structures, as calculated by CMSG SPACE.
For example, if we enabled SCTP SNDRCV INFO and IPV6 RECVPKTINFO
[RFC3542], we would calculate and allocate the buffer size as follows: size t total; void  buf; total   CMSG SPACE(sizeof(struct sctp sndrcvinfo))
CMSG SPACE(sizeof(struct in6 pktinfo)); buf   malloc(total); We could then use this buffer (buf) for msg control on each call to recvmsg() and be assured that we would not lose any ancillary data to truncation.
A key element of all SCTP specific socket extensions is the use of ancillary data to specify and access SCTP specific data via the msghdr structure's msg control member used in sendmsg() and recvmsg().
Fine grained control over initialization and sending parameters are handled with ancillary data.
Each ancillary data item is preceded by a struct cmsghdr (see Section 5.1), which defines the function and purpose of the data contained in the cmsg data[] member.
By default, on either style of socket, SCTP will pass no ancillary data.
Specific ancillary data items can be enabled with socket options defined for SCTP; see Section 6.2.
Note that all ancillary types are of fixed length; see Section 5.2 for further discussion on this.
These data structures use struct sockaddr storage (defined in [RFC3493]) as a portable, fixed length address format.
Other protocols may also provide ancillary data to the socket layer consumer.
These ancillary data items from other protocols may intermingle with SCTP data.
For example, the IPv6 sockets API definitions ([RFC3542] and [RFC3493])
define a number of ancillary data items.
If a sockets API consumer enables delivery of both SCTP and IPv6 ancillary data, they both may appear in the same msg control buffer in any order.
An application may thus need to handle other types of ancillary data besides those passed by SCTP.
The sockets application must provide a buffer large enough to accommodate all ancillary data provided via recvmsg().
If the buffer is not large enough, the ancillary data will be truncated and the msghdr's msg flags will include MSG CTRUNC.
SCTP Initiation Structure (SCTP INIT)
This cmsghdr structure provides information for initializing new SCTP associations with sendmsg().
The SCTP INITMSG socket option uses this same data structure.
This structure is not used for recvmsg().
The sctp initmsg structure is defined below: struct sctp initmsg { uint16 t sinit num ostreams; uint16 t sinit max instreams; uint16 t sinit max attempts;
This is an integer representing the number of streams to which the application wishes to be able to send.
This number is confirmed in the SCTP COMM UP notification and must be verified, since it is a negotiated number with the remote endpoint.
The default value of 0 indicates the use of the endpoint's default value.
This value represents the maximum number of inbound streams the application is prepared to support.
This value is bounded by the actual implementation.
In other words, the user may be able to support more streams than the operating system.
In such a case, the operating system limit overrides the value requested by the user.
The default value of 0 indicates the use of the endpoint's default value.
This integer specifies how many attempts the SCTP endpoint should make at resending the INIT.
This value overrides the system SCTP 'Max.
The default value of 0 indicates the use of the endpoint's default value.
This is normally set to the system's default 'Max.
This value represents the largest timeout or retransmission timeout (RTO) value (in milliseconds) to use in attempting an INIT.
Normally, the 'RTO.Max' is used to limit the doubling of the RTO upon timeout.
For the INIT message, this value may override 'RTO.Max'.
This value must not influence 'RTO.Max' during data transmission and is only used to bound the initial setup time.
A default value of 0 indicates the use of the endpoint's default value.
This is normally set to the system's 'RTO.Max' value (60 seconds).
SCTP Header Information Structure (SCTP SNDRCV)
This cmsghdr structure specifies SCTP options for sendmsg() and describes SCTP header information about a received message through recvmsg().
This structure mixes the send and receive path.
SCTP SNDINFO (described in Section 5.3.4) and SCTP RCVINFO (described in Section 5.3.5) split this information.
These structures should be used, when possible, since SCTP SNDRCV is deprecated.
SCTP SNDRCV   struct sctp sndrcvinfo
The sctp sndrcvinfo structure is defined below:
struct sctp sndrcvinfo { uint16 t sinfo stream; uint16 t sinfo ssn; uint16 t sinfo flags; uint32 t sinfo ppid; uint32 t sinfo context; uint32 t sinfo timetolive; uint32 t sinfo tsn; uint32 t sinfo cumtsn; sctp assoc t sinfo assoc id; };
sinfo stream:  For recvmsg(), the SCTP stack places the message's stream number in this value.
For sendmsg(), this value holds the stream number to which the application wishes to send this message.
If a sender specifies an invalid stream number, an error indication is returned and the call fails.
For recvmsg(), this value contains the stream sequence number that
the remote endpoint placed in the DATA chunk.
For fragmented messages, this is the same number for all deliveries of the message (if more than one recvmsg() is needed to read the message).
The sendmsg() call will ignore this parameter.
This field may contain any of the following flags and is composed of a bitwise OR of these values.
This flag is present when the message was sent unordered.
This flag requests the unordered delivery of the message.
If this flag is clear, the datagram is considered an ordered send.
This flag, for a one to many style socket, requests that the SCTP stack override the primary destination address with the address found with the sendto/ sendmsg call.
Setting this flag causes the specified association to abort by sending an ABORT message to the peer.
The ABORT chunk will contain an error cause of 'User Initiated Abort' with cause code 12.
The cause specific information of this error cause is provided in msg iov.
Setting this flag invokes the SCTP graceful shutdown procedure on the specified association.
Graceful shutdown assures that all data queued by both endpoints is successfully transmitted before closing the association.
This flag, if set, will cause a one to many style socket to send the message to all associations that are currently established on this socket.
For the one to  one style socket, this flag has no effect.
This value in sendmsg() is an unsigned integer that is passed to the remote end in each user message.
In recvmsg(), this value is the same information that was passed by the upper layer in the peer application.
Please note that the SCTP stack performs no byte order modification of this field.
For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the htonl() computation.
This value is an opaque 32 bit context datum that is used in the sendmsg() function.
This value is passed back to the upper layer if an error occurs on the send of a message and is retrieved with each undelivered message.
sinfo timetolive:  For the sending side, this field contains the message's time to live, in milliseconds.
The sending side will expire the message within the specified time period if the message has not been sent to the peer within this time period.
This value will override any default value set using any socket option.
Also note that the value of 0 is special in that it indicates no timeout should occur on this message.
sinfo tsn:  For the receiving side
, this field holds a Transmission Sequence Number (TSN) that was assigned to one of the SCTP DATA chunks.
For the sending side, it is ignored.
This field will hold the current cumulative TSN as known by the underlying SCTP layer.
Note that this field is ignored when sending.
The association handle field, sinfo assoc id, holds the identifier for the association announced in the SCTP COMM UP notification.
All notifications for a given association have the same identifier.
This field is ignored for one to one style sockets.
An sctp sndrcvinfo item always corresponds to the data in msg iov.
Extended SCTP Header Information Structure (SCTP EXTRCV)
This cmsghdr structure specifies SCTP options for SCTP header information about a received message via recvmsg().
Note that this structure is an extended version of SCTP SNDRCV (see Section 5.3.2) and will only be received if the user has set the socket option SCTP USE EXT RCVINFO (see Section 8.1.22) to true in addition to any event subscription needed to receive ancillary data.
Note that data in the next message is not valid unless the current message is completely read, i.e., unless the MSG EOR is set; in other words, if the application has more data to read from the current message, then no next message information will be available.
SCTP NXTINFO (described in Section 5.3.6) should be used when possible, since SCTP EXTRCV is considered deprecated.
SCTP EXTRCV   struct sctp extrcvinfo
The sctp extrcvinfo structure is defined below: struct sctp extrcvinfo { uint16 t sinfo stream; uint16 t sinfo ssn; uint16 t sinfo flags; uint32 t sinfo ppid; uint32 t sinfo context; uint32 t sinfo pr value; uint32 t sinfo tsn; uint32 t sinfo cumtsn; uint16 t serinfo next flags; uint16 t serinfo next stream;
Please see Section 5.3.2 for details for these fields.
This bitmask will hold one or more of the following values:
This bit, when set to 1, indicates that next message information is available; i.e., next stream, next aid, next length, and next ppid fields all have valid values.
If this bit is set to 0, then these fields are not valid and should be ignored.
This bit, when set, indicates that the next message is completely in the receive buffer.
The next length field thus contains the entire message size.
If this flag is set to 0, then the next length field only contains part of the message size, since the message is still being received (it is being partially delivered).
SCTP NEXT MSG IS UNORDERED:
This bit, when set, indicates that the next message to be received was sent by the peer as unordered.
If this bit is not set (i.e., the bit is 0)
the next message to be read is an ordered message in the stream specified.
SCTP NEXT MSG IS NOTIFICATION:
This bit, when set, indicates that the next message to be received is not a message from the peer, but instead is a MSG NOTIFICATION from the local SCTP stack.
This value, when valid (see serinfo next flags), contains the next stream number that will be received on a subsequent call to one of the receive message functions.
This value, when valid (see serinfo next flags), contains the next association identifier that will be received on a subsequent call to one of the receive message functions.
This value, when valid (see serinfo next flags), contains the length of the next message that will be received on a subsequent call to one of the receive message functions.
Note that this length may be a partial length, depending on the settings of next flags.
This value, when valid (see serinfo next flags), contains the ppid of the next message that will be received on a subsequent call to one of the receive message functions.
SCTP Send Information Structure (SCTP SNDINFO)
This cmsghdr structure specifies SCTP options for sendmsg().
SCTP SNDINFO   struct sctp sndinfo
This value holds the stream number to which the application wishes to send this message.
If a sender specifies an invalid stream number, an error indication is returned and the call fails.
This field may contain any of the following flags and is composed of a bitwise OR of these values.
This flag requests the unordered delivery of the message.
If this flag is clear, the datagram is considered an ordered send.
This flag, for a one to many style socket, requests that the SCTP stack override the primary destination address with the address found with the sendto()/sendmsg call.
Setting this flag causes the specified association to abort by sending an ABORT message to the peer.
The ABORT chunk will contain an error cause of 'User Initiated Abort' with cause code 12.
The cause specific information of this error cause is provided in msg iov.
Setting this flag invokes the SCTP graceful shutdown procedures on the specified association.
Graceful shutdown assures that all data queued by both endpoints is successfully transmitted before closing the association.
This flag, if set, will cause a one to many style socket to send the message to all associations that are currently established on this socket.
For the one to one style socket, this flag has no effect.
This value in sendmsg() is an unsigned integer that is passed to the remote end in each user message.
Please note that the SCTP stack performs no byte order modification of this field.
For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the htonl() computation.
This value is an opaque 32 bit context datum that is used in the sendmsg() function.
This value is passed back to the upper layer if an error occurs on the send of a message and is retrieved with each undelivered message.
The association handle field, sinfo assoc id, holds the identifier for the association announced in the SCTP COMM UP notification.
All notifications for a given association have the same identifier.
This field is ignored for one to one style sockets.
An sctp sndinfo item always corresponds to the data in msg iov.
SCTP Receive Information Structure (SCTP RCVINFO)
SCTP receive information about a received message through recvmsg().
To enable the delivery of this information, an application must use the SCTP RECVRCVINFO socket option (see Section 8.1.29).
SCTP RCVINFO   struct sctp rcvinfo
The sctp rcvinfo structure is defined below: struct sctp rcvinfo { uint16 t rcv sid;
uint16 t rcv ssn; uint16 t rcv flags; uint32 t rcv ppid; uint32 t rcv tsn; uint32 t rcv cumtsn; uint32 t rcv context; sctp assoc t
This value contains the stream sequence number that the remote endpoint placed in the DATA chunk.
For fragmented messages, this is the same number for all deliveries of the message (if more than one recvmsg() is needed to read the message).
This field may contain any of the following flags and is composed of a bitwise OR of these values.
This flag is present when the message was sent unordered.
This value is the same information that was passed by the upper layer in the peer application.
Please note that the SCTP stack performs no byte order modification of this field.
For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the ntohl() computation.
This field holds a TSN that was assigned to one of the SCTP DATA chunks.
This field will hold the current cumulative TSN as known by the underlying SCTP layer.
This value is an opaque 32 bit context datum that was set by the user with the SCTP CONTEXT socket option.
This value is passed back to the upper layer if an error occurs on the send of a message and is retrieved with each undelivered message.
The association handle field, sinfo assoc id, holds the identifier for the association announced in the SCTP COMM UP notification.
All notifications for a given association have the same identifier.
This field is ignored for one to one style sockets.
An sctp rcvinfo item always corresponds to the data in msg iov.
SCTP Next Receive Information Structure (SCTP NXTINFO)
SCTP receive information of the next message that will be delivered through recvmsg() if this information is already available when delivering the current message.
To enable the delivery of this information, an application must use the SCTP RECVNXTINFO socket option (see Section 8.1.30).
This field may contain any of the following flags and is composed of a bitwise OR of these values.
This flag is present when the next message was sent unordered.
This flag indicates that the entire message has been received and is in the socket buffer.
Note that this has special implications with respect to the nxt length field; see the description for nxt length below.
This flag is present when the next message is not a user message but instead is a notification.
This value is the same information that was passed by the upper layer in the peer application for the next message.
Please note that the SCTP stack performs no byte order modification of this field.
For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the ntohl() computation.
This value is the length of the message currently within the socket buffer.
This might NOT be the entire length of the message, since a partial delivery may be in progress.
Only if the flag SCTP COMPLETE is set in the nxt flags field does this field represent the size of the entire next message.
The association handle field of the next message, nxt assoc id, holds the identifier for the association announced in the SCTP COMM UP notification.
All notifications for a given association have the same identifier.
This field is ignored for one to one style sockets.
SCTP PR SCTP Information Structure (SCTP PRINFO)
This cmsghdr structure specifies SCTP options for sendmsg().
This specifies which Partially Reliable SCTP (PR SCTP) policy is used.
Using SCTP PR SCTP NONE results in a reliable transmission.
TTL is used, the PR SCTP policy "timed reliability" defined in [RFC3758] is used.
In this case, the lifetime is provided in pr value.
The meaning of this field depends on the PR SCTP policy specified by the pr policy field.
It is ignored when SCTP PR SCTP
In the case of SCTP PR SCTP TTL, the lifetime in milliseconds is specified.
An sctp prinfo item always corresponds to the data in msg iov.
SCTP AUTH Information Structure (SCTP AUTHINFO)
This cmsghdr structure specifies SCTP options for sendmsg().
This specifies the shared key identifier used for sending the user message.
An sctp authinfo item always corresponds to the data in msg iov.
Please note that the SCTP implementation must not bundle user messages that need to be authenticated using different shared key identifiers.
SCTP Destination IPv4 Address Structure (SCTP DSTADDRV4)
This cmsghdr structure specifies SCTP options for sendmsg().
This ancillary data can be used to provide more than one destination address to sendmsg().
It can be used to implement sctp sendv() using sendmsg().
SCTP Destination IPv6 Address Structure (SCTP DSTADDRV6)
This cmsghdr structure specifies SCTP options for sendmsg().
This ancillary data can be used to provide more than one destination address to sendmsg().
It can be used to implement sctp sendv() using sendmsg().
An SCTP application may need to understand and process events and errors that happen on the SCTP stack.
These events include network status changes, association startups, remote operational errors, and undeliverable messages.
All of these can be essential for the application.
When an SCTP application layer does a recvmsg(), the message read is normally a data message from a peer endpoint.
If the application wishes to have the SCTP stack deliver notifications of non data events, it sets the appropriate socket option for the notifications it wants.
See Section 6.2 for these socket options.
When a notification arrives, recvmsg() returns the notification in the application supplied data buffer via msg iov, and sets MSG NOTIFICATION in msg flags.
This section details the notification structures.
Every notification structure carries some common fields that provide general information.
A recvmsg() call will return only one notification at a time.
Just as when reading normal data, it may return part of a notification if the msg iov buffer is not large enough.
If a single read is not sufficient, msg flags will have MSG EOR clear.
The user must finish reading the notification before subsequent data can arrive.
The notification structure is defined as the union of all notification types.
The following list describes the SCTP notification and event types for the field sn type.
This tag indicates that an association has either been opened or closed.
Refer to Section 6.1.1 for details.
This tag indicates that an address that is part of an existing association has experienced a change of state (e.g., a failure or return to service of the reachability of an endpoint via a specific transport address).
Please see Section 6.1.2 for data structure details.
The attached error message is an Operation Error message received from the remote peer.
It includes the complete TLV sent by the remote endpoint.
See Section 6.1.3 for the detailed format.
The attached datagram could not be sent to the remote endpoint.
This structure includes the original SCTP SNDINFO that was used in sending this message; i.e., this structure uses the sctp sndinfo per Section 6.1.11.
The peer has sent a SHUTDOWN.
No further data should be sent on this socket.
This notification holds the peer's indicated adaptation layer.
This notification is used to tell a receiver that the partial delivery has been aborted.
This may indicate that the association is about to be aborted.
This notification is used to tell a receiver that either an error occurred on authentication, or a new key was made active.
This notification is used to inform the application that the sender has no more user data queued for transmission or retransmission.
These are notification specific flags.
This is the length of the whole sctp notification structure, including the sn type, sn flags, and sn length fields.
SCTP ASSOC CHANGE Communication notifications inform the application that an SCTP association has either begun or ended.
The identifier for a new association is provided by this notification.
The notification information has the following format: struct sctp assoc change { uint16 t sac type; uint16 t sac flags; uint32 t sac length; uint16 t sac state; uint16 t sac error; uint16 t sac outbound streams; uint16 t sac inbound streams;
sctp assoc t sac assoc id
This field should be set to SCTP ASSOC CHANGE.
This field is currently unused.
This field is the total length of the notification data, including the notification header.
This field holds one of a number of values that communicate the event that happened to the association.
These values include SCTP COMM UP:  A new association is now ready, and data may be exchanged with this peer.
When an association has been established successfully, this notification should be the first one.
The association is now in the closed state.
If SEND FAILED notifications are turned on, an SCTP COMM LOST is accompanied by a series of SCTP SEND FAILED EVENT events, one for each outstanding message.
SCTP has detected that the peer has restarted.
The association has gracefully closed.
If non blocking mode is set and data was sent (on a one to many style socket), an SCTP CANT STR ASSOC is accompanied by a series of SCTP SEND FAILED EVENT events, one for each outstanding message.
If the state was reached due to an error condition (e.g., SCTP COMM LOST), any relevant error information is available in this field.
This corresponds to the protocol error codes defined in [RFC4960].
sac outbound streams and sac inbound streams:
The maximum number of streams allowed in each direction is available in sac outbound streams and sac inbound streams.
id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to one style socket, this field is ignored.
If sac state is SCTP COMM LOST and an ABORT chunk was received for this association, sac info[] contains the complete ABORT chunk as defined in Section 3.3.7 of the SCTP specification [RFC4960].
If sac state is SCTP COMM UP or SCTP RESTART, sac info may contain an array of uint8 t describing the features that the current association supports.
Features may include SCTP ASSOC
Both endpoints support the protocol extension described in [RFC3758].
Both endpoints support the protocol extension described in [RFC4895].
Both endpoints support the protocol extension described in [RFC5061].
For a one to many style socket, the local endpoints use separate send and/or receive buffers for each SCTP association.
When a destination address of a multi homed peer encounters a state change, a peer address change event is sent.
The notification has the following format: struct sctp paddr change { uint16 t spc type; uint16 t spc flags;
uint32 t spc length; struct sockaddr storage spc aaddr;
uint32 t spc state; uint32 t spc error; sctp assoc t spc assoc id
This field should be set to SCTP PEER ADDR CHANGE.
This field is currently unused.
This field is the total length of the notification data, including the notification header.
spc aaddr:  The affected address field holds the remote peer's address that is encountering the change of state.
This field holds one of a number of values that communicate the event that happened to the address.
They include SCTP ADDR AVAILABLE:
This address is now reachable.
This notification is provided whenever an address becomes reachable.
The address specified can no longer be reached.
Any data sent to this address is rerouted to an alternate until this address becomes reachable.
This notification is provided whenever an address becomes unreachable.
The address is no longer part of the association.
The address is now part of the association.
This address has now been made the primary destination address.
This notification is provided whenever an address is made primary.
If the state was reached due to any error condition (e.g., SCTP ADDR UNREACHABLE), any relevant error information is available in this field.
The spc assoc id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to one style socket, this field is ignored.
SCTP REMOTE ERROR A remote peer may send an Operation Error message to its peer.
This message indicates a variety of error conditions on an association.
The entire ERROR chunk as it appears on the wire is included in an SCTP REMOTE ERROR event.
Please refer to the SCTP specification [RFC4960] and any extensions for a list of possible error formats.
An SCTP error notification has the following format: struct sctp remote error { uint16 t sre type; uint16 t sre flags; uint32 t sre length; uint16 t sre error; sctp assoc t sre assoc id;
This field should be set to SCTP REMOTE ERROR.
This field is currently unused.
This field is the total length of the notification data, including the notification header and the contents of sre data.
This value represents one of the Operation Error causes defined in the SCTP specification [RFC4960], in network byte order.
id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to one style socket, this field is ignored.
This contains the ERROR chunk as defined in Section 3.3.10 of the SCTP specification [RFC4960].
Please note that this notification is deprecated.
Use SCTP SEND FAILED EVENT instead.
If SCTP cannot deliver a message, it can return back the message as a notification if the SCTP SEND FAILED event is enabled.
The notification has the following format: struct sctp send failed { uint16 t ssf type; uint16 t ssf flags; uint32 t ssf length; uint32 t ssf error; struct sctp sndrcvinfo ssf info; sctp assoc t ssf assoc id;
This field should be set to SCTP SEND FAILED.
The flag value will take one of the following values: SCTP DATA UNSENT:
This value indicates that the data was never put on the wire.
This value indicates that the data was put on the wire.
Note that this does not necessarily mean that the data was (or was not) successfully delivered.
This field is the total length of the notification data, including the notification header and the payload in ssf data.
This value represents the reason why the send failed, and if set, will be an SCTP protocol error code as defined in Section 3.3.10 of [RFC4960].
This field includes the ancillary data (struct sctp sndrcvinfo) used to send the undelivered message.
Regardless of whether ancillary data is used or not, the ssf info.sinfo flags field indicates whether the complete message or only part of the message is returned in ssf data.
If only part of the message is returned, it means that the part that is not present has been sent successfully to the peer.
If the complete message cannot be sent, the SCTP DATA NOT FRAG flag is set in ssf info.sinfo flags.
If the first part of the message is sent successfully, SCTP DATA LAST FRAG is set.
This means that the tail end of the message is returned in ssf data.
The ssf assoc id field, ssf assoc id, holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to  one style socket, this field is ignored.
The undelivered message or part of the undelivered message will be present in the ssf data field.
Note that the ssf info.sinfo flags field as noted above should be used to determine whether a complete message or just a piece of the message is present.
Note that only user data is present in this field;
any chunk headers or SCTP common headers must be removed by the SCTP stack.
When a peer sends a SHUTDOWN, SCTP delivers this notification to inform the application that it should cease sending data.
struct sctp shutdown event { uint16 t sse type; uint16 t sse flags; uint32 t sse length; sctp assoc t sse assoc id
This field should be set to SCTP SHUTDOWN EVENT.
This field is currently unused.
This field is the total length of the notification data, including the notification header.
It will generally be sizeof(struct sctp shutdown event).
The sse assoc id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to one style socket, this field is ignored.
When a peer sends an Adaptation Layer Indication parameter as described in [RFC5061], SCTP delivers this notification to inform the application about the peer's adaptation layer indication.
struct sctp adaptation event { uint16 t sai type; uint16 t sai flags; uint32 t sai length; uint32 t sai adaptation ind; sctp assoc t sai assoc id; };
This field should be set to SCTP ADAPTATION INDICATION.
This field is currently unused.
This field is the total length of the notification data, including the notification header.
It will generally be sizeof(struct sctp adaptation event).
This field holds the bit array sent by the peer in the Adaptation Layer Indication parameter.
The sai assoc id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to one style socket, this field is ignored.
When a receiver is engaged in a partial delivery of a message, this notification will be used to indicate various events.
struct sctp pdapi event { uint16 t pdapi type; uint16 t pdapi flags; uint32 t pdapi length; uint32 t pdapi indication; uint32 t pdapi stream; uint32 t pdapi seq; sctp assoc t pdapi assoc id; };
This field should be set to SCTP PARTIAL DELIVERY EVENT.
This field is currently unused.
This field is the total length of the notification data, including the notification header.
It will generally be sizeof(struct sctp pdapi event).
This field holds the indication being sent to the application.
Currently, there is only one defined value:
This indicates that the partial delivery of a user message has been aborted.
This happens, for example, if an association is aborted while a partial delivery is going on or the user message gets abandoned using PR SCTP while the partial delivery of this message is going on.
This field holds the stream on which the partial delivery event happened.
This field holds the stream sequence number that was being partially delivered.
id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to one style socket, this field is ignored.
RFC4895] defines an extension to authenticate SCTP messages.
The following notification is used to report different events relating to the use of this extension.
struct sctp authkey event { uint16 t auth type; uint16 t auth flags; uint32 t auth length; uint16 t auth keynumber; uint32 t auth indication;
This field should be set to SCTP AUTHENTICATION EVENT.
This field is currently unused.
This field is the total length of the notification data, including the notification header.
It will generally be sizeof(struct sctp authkey event).
This field holds the key number for the affected key indicated in the event (depends on auth indication).
This field holds the error or indication being reported.
The following values are currently defined: SCTP AUTH NEW KEY:
This report indicates that a new key has been made active (used for the first time by the peer) and is now the active key.
The auth keynumber field holds the user  specified key number.
This report indicates that the peer does not support SCTP authentication as defined in [RFC4895].
This report indicates that the SCTP implementation will no longer use the key identifier specified in auth keynumber.
id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to one style socket, this field is ignored.
When the SCTP stack has no more user data to send or retransmit, this notification is given to the user.
Also, at the time when a user app subscribes to this event, if there is no data to be sent or retransmit, the stack will immediately send up this notification.
struct sctp sender dry event { uint16 t sender dry type; uint16 t sender dry flags; uint32 t sender dry length; sctp assoc t sender dry assoc id
This field should be set to SCTP SENDER DRY EVENT.
This field is currently unused.
This field is the total length of the notification data, including the notification header.
sizeof(struct sctp sender dry event).
The sender dry assoc id field holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to  one style socket, this field is ignored.
SCTP NOTIFICATIONS STOPPED EVENT SCTP notifications, when subscribed to, are reliable.
They are always delivered as long as there is space in the socket receive buffer.
However, if an implementation experiences a notification storm, it may run out of socket buffer space.
When this occurs, it may wish to disable notifications.
If the implementation chooses to do this, it will append a final notification SCTP NOTIFICATIONS STOPPED EVENT.
This notification is a union sctp notification, where only the sctp tlv structure (see the union above) is used.
It only contains this type in the sn type field, the sn length field set to the size of an sctp tlv structure, and the sn flags set to 0.
If an application receives this notification, it will need to re subscribe to any notifications of interest to it, except for the sctp data io event (note that SCTP EVENTS is deprecated).
An endpoint is automatically subscribed to this event as soon as it is subscribed to any event other than data io events.
If SCTP cannot deliver a message, it can return back the message as a notification if the SCTP SEND FAILED EVENT event is enabled.
This field should be set to SCTP SEND FAILED EVENT.
The flag value will take one of the following values: SCTP DATA UNSENT:
This value indicates that the data was never put on the wire.
This value indicates that the data was put on the wire.
Note that this does not necessarily mean that the data was (or was not) successfully delivered.
This field is the total length of the notification data, including the notification header and the payload in ssf data.
This value represents the reason why the send failed, and if set, will be an SCTP protocol error code as defined in Section 3.3.10 of [RFC4960].
This field includes the ancillary data (struct sctp sndinfo) used to send the undelivered message.
Regardless of whether ancillary data is used or not, the ssfe info.sinfo flags field indicates whether the complete message or only part of the message is returned in ssf data.
If only part of the message is returned, it means that the part that is not present has been sent successfully to the peer.
If the complete message cannot be sent, the SCTP DATA NOT FRAG flag is set in ssfe info.sinfo flags.
If the first part of the message is sent successfully, SCTP DATA LAST FRAG is set.
This means that the tail end of the message is returned in ssf data.
The ssfe assoc id field, ssf assoc id, holds the identifier for the association.
All notifications for a given association have the same association identifier.
For a one to  one style socket, this field is ignored.
The undelivered message or part of the undelivered message will be present in the ssf data field.
Note that the ssf info.sinfo flags field as noted above should be used to determine whether a complete message or just a piece of the message is present.
Note that only user data is present in this field;
any chunk headers or SCTP common headers must be removed by the SCTP stack.
Please note that this option is deprecated.
Use the SCTP EVENT option described in Section 6.2.2 instead.
To receive SCTP event notifications, an application registers its interest by setting the SCTP EVENTS socket option.
The application then uses recvmsg() to retrieve notifications.
A notification is stored in the data part (msg iov) of the msghdr structure.
Setting this flag to 1 will cause the reception of SCTP SNDRCV information on a per message basis.
The application will need to use the recvmsg() interface so that it can receive the event information contained in the msg control field.
Setting the flag to 0 will disable the reception of the message control information.
Note that this flag is not really a notification and is stored in the ancillary data (msg control), not in the data part (msg iov).
sctp association event:  Setting this flag to 1 will enable the reception of association event notifications.
Setting the flag to 0 will disable association event notifications.
Setting this flag to 1 will enable the reception of address event notifications.
Setting the flag to 0 will disable address event notifications.
Setting this flag to 1 will enable the reception of send failure event notifications.
Setting the flag to 0 will disable send failure event notifications.
Setting this flag to 1 will enable the reception of peer error event notifications.
Setting the flag to 0 will disable peer error event notifications.
Setting this flag to 1 will enable the reception of shutdown event notifications.
Setting the flag to 0 will disable shutdown event notifications.
sctp partial delivery event:  Setting this flag to 1 will enable the reception of partial delivery event notifications.
Setting the flag to 0 will disable partial delivery event notifications.
Setting this flag to 1 will enable the reception of adaptation layer event notifications.
Setting the flag to 0 will disable adaptation layer event notifications.
Setting this flag to 1 will enable the reception of authentication layer event notifications.
Setting the flag to 0 will disable authentication layer event notifications.
Setting this flag to 1 will enable the reception of sender dry event notifications.
Setting the flag to 0 will disable sender dry event notifications.
An example where an application would like to receive data io events and association events but no others would be as follows: { struct sctp event subscribe events;
For one to one style SCTP sockets, the caller receives ancillary data and notifications only for the single association bound to the file descriptor.
By default, both the one to one style and the one to many style socket do not subscribe to any notification.
The SCTP EVENTS socket option has one issue for future compatibility.
As new features are added, the structure (sctp event subscribe) must be expanded.
This can cause an application binary interface (ABI) issue unless an implementation has added padding at the end of the structure.
To avoid this problem, SCTP EVENTS has been deprecated and a new socket option SCTP EVENT has taken its place.
The option is used with the following structure: struct sctp event { sctp assoc t se
id field is ignored for one to one style sockets.
For one to many style sockets, this field can be a particular association identifier or SCTP {FUTURE CURRENT
The se type field can be filled with any value that would show up in the respective sn type field (in the sctp tlv structure of the notification).
se on:  The se on field is set to 1 to turn on an event and set to 0 to turn off an event.
To use this option, the user fills in this structure and then calls setsockopt() to turn on or off an individual event.
The following is an example use of this option: { struct sctp event event; memset(&event, 0, sizeof(event)); event.se assoc i
SCTP FUTURE ASSOC; event.se type   SCTP SENDER DRY EVENT; event.se on   1; setsockopt(sd, IPPROTO SCTP, SCTP EVENT, &event,
Common Operations for Both Styles 7.1.
send(), recv(), sendto(), and recvfrom()
Applications can use send() and sendto() to transmit data to the peer of an SCTP endpoint.
recv() and recvfrom() can be used to receive data from the peer.
The function prototypes are ssize
msg, size t len, int flags); ssize t sendto(int
msg, size t len, int flags
, const struct sockaddr  to, socklen t tolen); ssize t recv(int sd, void  buf, size t len, int flags); ssize t recvfrom(int sd, void  buf, size t len, int flags, struct sockaddr  from, socklen t  fromlen); and the arguments are sd:  The socket descriptor of an SCTP endpoint.
The message to be sent.
The size of the message or the size of the buffer.
to:  One of the peer addresses of the association to be used to send the message.
The size of the address.
The buffer to store a received message.
from:  The buffer to store the peer address used to send the received message.
The size of the from address.
These calls give access to only basic SCTP protocol features.
If either peer in the association uses multiple streams, or sends unordered data, these calls will usually be inadequate and may deliver the data in unpredictable ways.
SCTP has the concept of multiple streams in one association.
The above calls do not allow the caller to specify on which stream a message should be sent.
The system uses stream 0 as the default stream for send() and sendto().
recv() and recvfrom() return data from any stream, but the caller cannot distinguish the different streams.
This may result in data seeming to arrive out of order.
Similarly, if a DATA chunk is sent unordered, recv() and recvfrom() provide no indication.
The msg buffer above in send() and sendto() is considered to be a single message.
This means that if the caller wants to send a message that is composed by several buffers, the caller needs to combine them before calling send() or sendto().
Alternately, the caller can use sendmsg() to do that without combining them.
Sending a message using send() or sendto() is atomic unless explicit EOR marking is enabled on the socket specified by sd.
Using sendto() on a non connected one to one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.
recv() and recvfrom() cannot distinguish message boundaries (i.e., there is no way to observe the MSG EOR flag to detect partial delivery).
When receiving, if the buffer supplied is not large enough to hold a complete message, the receive call acts like a stream socket and returns as much data as will fit in the buffer.
Note that the send() and recv() calls may not be used for a one to  many style socket.
Note that if an application calls a send() or sendto() function with no user data, the SCTP implementation should reject the request with an appropriate error message.
An implementation is not allowed to send a DATA chunk with no user data [RFC4960].
Applications use setsockopt() and getsockopt() to set or retrieve socket options.
Socket options are used to change the default behavior of socket calls.
They are described in Section 8.
int level, int optname, void  optval, socklen t  optlen); and int setsockopt(int sd, int level, int optname,
const void  optval, socklen t optlen); and the arguments are sd:
Set to IPPROTO SCTP for all SCTP options.
The buffer to store the value of the option.
The size of the buffer (or the length of the option returned).
These functions return 0 on success and  1 in case of an error.
All socket options set on a one to one style listening socket also apply to all future accepted sockets.
For one to many style sockets, often a socket option will pass a structure that includes an assoc id field.
This field can be filled with the association identifier of a particular association and unless otherwise specified can be filled with one of the following constants:
Specifies that only future associations created after this socket option will be affected by this call.
Specifies that only currently existing associations will be affected by this call, and future associations will still receive the previous default value.
Specifies that all current and future associations will be affected by this call.
Applications can use read() and write() to receive and send data from and to a peer.
They have the same semantics as recv() and send(), except that the flags parameter cannot be used.
Applications use getsockname() to retrieve the locally bound socket address of the specified socket.
This is especially useful if the caller let SCTP choose a local port.
This call is for single homed endpoints.
It does not work well with multi homed endpoints.
See Section 9.5 for a multi homed version of the call.
The function prototype is int getsockname(int sd,
struct sockaddr  address, socklen t  len); and the arguments are sd:
The socket descriptor to be queried.
On return, one locally bound address (chosen by the SCTP stack) is stored in this buffer.
If the socket is an IPv4 socket, the address will be IPv4.
If the socket is an IPv6 socket, the address will be either an IPv6 or IPv4 address.
The caller should set the length of the address here.
On return, this is set to the length of the returned address.
getsockname() returns 0 on success and  1 in case of an error.
If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address will be truncated.
If the socket has not been bound to a local name, the value stored in the object pointed to by address is unspecified.
The application can begin sending and receiving data using the sendmsg()/recvmsg() or sendto()/recvfrom() calls, without going through any explicit association setup procedures (i.e., no connect()
Whenever sendmsg() or sendto() is called and the SCTP stack at the sender finds that no association exists between the sender and the intended receiver (identified by the address passed either in the msg name field of the msghdr structure in the sendmsg() call or the dest addr field in the sendto() call), the SCTP stack will automatically set up an association to the intended receiver.
Upon successful association setup, an SCTP COMM UP notification will be dispatched to the socket at both the sender and receiver side.
This notification can be read by the recvmsg() system call (see Section 3.1.4).
Note that if the SCTP stack at the sender side supports bundling, the first user message may be bundled with the COOKIE ECHO message [RFC4960].
When the SCTP stack sets up a new association implicitly, the SCTP INIT type ancillary data may also be passed along (see Section 5.3.1 for details of the data structures) to change some parameters used in setting up a new association.
If this information is not present in the sendmsg() call, or if the implicit association setup is triggered by a sendto() call, the default association initialization parameters will be used.
These default association parameters may be set with respective setsockopt() calls or be left to the system defaults.
Implicit association setup cannot be initiated by send() calls.
The following subsection describes various SCTP level socket options that are common to both styles.
SCTP associations can be multi homed.
Therefore, certain option parameters include a sockaddr storage structure to select to which peer address the option should be applied.
For the one to many style sockets, an sctp assoc t (association identifier)
parameter is used to identify the association instance that the operation affects.
So it must be set when using this style.
For the one to one style sockets and branched off one to many style sockets (see Section 9.2), this association ID parameter is ignored.
Note that socket  or IP level options are set or retrieved per socket.
This means that for one to many style sockets, the options will be applied to all associations (similar to using SCTP ALL
ASSOC as the association identifier) belonging to the socket.
For the one  to one style, these options will be applied to all peer addresses of the association controlled by the socket.
Applications should be careful in setting those options.
For some IP stacks, getsockopt() is read only, so a new interface will be needed when information must be passed both into and out of the SCTP stack.
The syntax for sctp opt info() is int sctp opt info(int
sd, sctp assoc t id, int opt, void  arg, socklen t  size); The sctp opt info() call is a replacement for getsockopt() only and will not set any options associated with the specified socket.
A setsockopt() call must be used to set any writable option.
For one to many style sockets, id specifies the association to query.
For one to one style sockets, id is ignored.
For one to many style sockets, any association identifier in the structure provided as arg is ignored, and id takes precedence.
Note that SCTP CURRENT ASSOC and SCTP
ALL ASSOC cannot be used with sctp opt info() or in getsockopt() calls.
Using them will result in an error (returning  1 and errno set to EINVAL).
SCTP FUTURE ASSOC can be used to query information for future associations.
The field opt specifies which SCTP socket option to get.
It can get any socket option currently supported that requests information (either read/write options or read only) such as SCTP RTOINFO SCTP ASSOCINFO SCTP PRIMARY ADDR SCTP
PEER ADDR PARAMS SCTP DEFAULT SEND
PARAM SCTP MAX SEG SCTP AUTH
ACTIVE KEY SCTP DELAYED SACK SCTP MAX BURST
DEFAULT PRINFO SCTP STATUS SCTP
PEER AUTH CHUNKS SCTP LOCAL AUTH CHUNKS
The arg field is an option specific structure buffer provided by the caller.
See the rest of this section for more information on these options and option specific structures.
() returns 0 on success, or on failure returns  1 and sets errno to the appropriate error code.
Retransmission Timeout Parameters (SCTP RTOINFO)
The protocol parameters used to initialize and limit the retransmission timeout (RTO) are tunable.
See [RFC4960] for more information on how these parameters are used in RTO calculation.
The following structure is used to access and modify these parameters: struct sctp rtoinfo { sctp assoc t srto assoc id;
uint32 t srto initial; uint32 t srto max; uint32 t srto min; }
This parameter is ignored for one to one style sockets.
For one to many style sockets, the application may fill in an association identifier or SCTP FUTURE ASSOC.
It is an error to use SCTP {CURRENT ALL} ASSOC in
This parameter contains the initial RTO value.
srto max and srto min:
These parameters contain the maximum and minimum bounds for all RTOs.
All times are given in milliseconds.
A value of 0, when modifying the parameters, indicates that the current value should not be changed.
To access or modify these parameters, the application should call getsockopt() or setsockopt(), respectively, with the option name SCTP RTOINFO.
This option is used to both examine and set various association and endpoint parameters.
See [RFC4960] for more information on how these parameters are used.
This parameter is ignored for one to one style sockets.
For one to many style sockets, the application may fill in an association identifier or SCTP FUTURE ASSOC.
It is an error to use SCTP {CURRENT ALL
} ASSOC in sasoc assoc id.
This parameter contains the maximum retransmission attempts to make for the association.
This parameter is the number of destination addresses that the peer has.
This parameter holds the current value of the peer's rwnd (reported in the last selective acknowledgment (SACK))
minus any outstanding data (i.e., data in flight).
This parameter holds the last reported rwnd that was sent to the peer.
This parameter is the association's cookie life value used when issuing cookies.
The value of sasoc peer rwnd is meaningless when examining endpoint information (i.e., it is only valid when examining information on a specific association).
All time values are given in milliseconds.
A value of 0, when modifying the parameters, indicates that the current value should not be changed.
The values of sasoc asocmaxrxt and sasoc cookie life may be set on either an endpoint or association basis.
The rwnd and destination counts (sasoc number peer destinations, sasoc peer rwnd, sasoc local rwnd) are not settable, and any value placed in these is ignored.
To access or modify these parameters, the application should call getsockopt() or setsockopt(), respectively, with the option name SCTP ASSOCINFO.
The maximum number of retransmissions before an address is considered unreachable is also tunable, but is address specific, so it is covered in a separate option.
If an application attempts to set the value of the association's maximum retransmission parameter to more than the sum of all maximum retransmission parameters, setsockopt() may return an error.
The reason for this, from Section 8.2 of [RFC4960], is as follows:
Note: When configuring the SCTP endpoint, the user should avoid having the value of 'Association.
Retrans' (sasoc maxrxt in this option) larger than the summation of the 'Path.
Retrans' (see spp pathmaxrxt in Section 8.1.12) of all of the destination addresses for the remote endpoint.
Otherwise, all of the destination addresses may become inactive while the endpoint still considers the peer endpoint reachable.
Applications can specify protocol parameters for the default association initialization.
The structure used to access and modify these parameters is defined in Section 5.3.1.
The option name argument to setsockopt() and getsockopt() is SCTP INITMSG.
Setting initialization parameters is effective only on an unconnected socket (for one to many style sockets, only future associations are affected by the change).
An application can use this option to perform the SCTP ABORT primitive.
This option affects all associations related to the socket.
If the l linger value is set to 0, calling close() is the same as the ABORT primitive.
If the value is set to a negative value, the setsockopt() call will return an error.
If the value is set to a positive value linger time, the close() can be blocked for at most linger time.
Please note that the time unit is in seconds, according to POSIX, but might be different on specific platforms.
If the graceful shutdown phase does not finish during this period, close() will return, but the graceful shutdown phase will continue in the system.
Note that this is a socket level option, not an SCTP level option.
When using this option, an application must specify a level of SOL SOCKET in the call.
This option turns on/off any Nagle like algorithm.
This means that packets are generally sent as soon as possible, and no unnecessary delays are introduced, at the cost of more packets in the network.
In particular, not using any Nagle like algorithm might reduce the bundling of small user messages in cases where this would require an additional delay.
Turning this option on disables any Nagle like algorithm.
This option expects an integer boolean flag, where a non zero value turns on the option, and a zero value turns off the option.
This option sets the receive buffer size in octets.
For SCTP one to  one style sockets, this option controls the receiver window size.
For one to many style sockets, the meaning is implementation dependent.
It might control the receive buffer for each association bound to the socket descriptor, or it might control the receive buffer for the whole socket.
This option expects an integer.
Note that this is a socket level option, not an SCTP level option.
When using this option, an application must specify a level of SOL SOCKET in the call.
This option sets the send buffer size.
For SCTP one to one style sockets, this option controls the amount of data SCTP may have waiting in internal buffers to be sent.
This option therefore bounds the maximum size of data that can be sent in a single send call.
For one to many style sockets, the effect is the same, except that it applies to one or all associations (see Section 3.3) bound to the socket descriptor used in the setsockopt() or
The option applies to each association's window size separately.
This option expects an integer.
Note that this is a socket level option, not an SCTP level option.
When using this option, an application must specify a level of SOL SOCKET in the call.
Automatic Close of Associations (SCTP AUTOCLOSE)
This socket option is applicable to the one to many style socket only.
When set, it will cause associations that are idle for more than the specified number of seconds to automatically close using the graceful shutdown procedure.
An idle association is defined as an association that has not sent or received user data.
The special value of '0' indicates that no automatic close of any association should be performed; this is the default value.
This option expects an integer defining the number of seconds of idle time before an association is closed.
An application using this option should enable the ability to receive the association change notification.
This is the only mechanism by which an application is informed about the closing of an association.
After an association is closed, the association identifier assigned to it can be reused.
An application should be aware of this to avoid the possible problem of sending data to an incorrect peer endpoint.
Set Primary Address (SCTP PRIMARY ADDR)
This option requests that the local SCTP stack uses the enclosed peer address as the association's primary.
The enclosed address must be one of the association peer's addresses.
The following structure is used to make a set peer primary request:
This parameter is ignored for one to one style sockets.
For one to many style sockets, it identifies the association for this request.
Note that the special sctp assoc t SCTP {FUTURE ALL CURRENT
} ASSOC are not allowed.
This parameter is the address to set as primary.
No wildcard address is allowed.
Set Adaptation Layer Indicator (SCTP ADAPTATION LAYER)
This option requests that the local endpoint set the specified Adaptation Layer Indication parameter for all future INIT and INIT ACK exchanges.
The adaptation layer indicator that will be included in any outgoing Adaptation Layer Indication parameter.
Enable/Disable Message Fragmentation (SCTP DISABLE FRAGMENTS)
This option is an on/off flag and is passed as an integer, where a non zero is on and a zero is off.
If enabled, no SCTP message fragmentation will be performed.
The effect of enabling this option is that if a message being sent exceeds the current Path MTU (PMTU) size, the message will not be sent and instead an error will be indicated to the user.
If this option is disabled (the default), then a message exceeding the size of the PMTU will be fragmented and reassembled by the peer.
Peer Address Parameters (SCTP PEER ADDR PARAMS)
Applications can enable or disable heartbeats for any peer address of an association, modify an address's heartbeat interval, force a heartbeat to be sent immediately, and adjust the address's maximum number of retransmissions sent before an address is considered unreachable.
The following structure is used to access and modify an address's parameters: struct sctp paddrparams { sctp assoc t spp assoc id; struct sockaddr storage spp address; uint32 t spp hbinterval; uint16 t spp pathmaxrxt; uint32 t spp pathmtu; uint32 t spp flags; uint32 t spp ipv6 flowlabel;
This parameter is ignored for one to one style sockets.
For one to many style sockets, the application may fill in an association identifier or SCTP FUTURE ASSOC for this query.
It is an error to use SCTP {CURRENT ALL} ASSOC in spp assoc id.
This specifies which address is of interest.
If a wildcard address is provided, it applies to all current and future paths.
This contains the value of the heartbeat interval, in milliseconds (HB.Interval in [RFC4960]).
Note that unless the spp flags field is set to SPP HB ENABLE, the value of this field is ignored.
Note also that a value of zero indicates that the current setting should be left unchanged.
To set an actual value of zero, the SPP HB TIME IS ZERO flag should be used.
Even when it is set to 0, it does not mean that SCTP will continuously send out heartbeats, since the actual interval also includes the current RTO and jitter (see Section 8.3 of [RFC4960]).
This contains the maximum number of retransmissions before this address shall be considered unreachable.
Note that a value of zero indicates that the current setting should be left unchanged.
This field contains the current Path MTU of the peer address.
It is the number of bytes available in an SCTP packet for chunks.
Providing a value of 0 does not change the current setting.
If a positive value is provided and SPP PMTUD DISABLE is set in the spp flags field, the given value is used as the Path MTU.
If SPP PMTUD ENABLE is set in the spp flags field, the spp pathmtu field is ignored.
These flags are used to control various features on an association.
The flag field is a bitmask that may contain zero or more of the following options: SPP HB ENABLE:
This field enables heartbeats on the specified address.
This field disables heartbeats on the specified address.
Note that SPP HB ENABLE and SPP HB DISABLE are mutually exclusive; only one of these two should be specified.
Enabling both fields will yield undetermined results.
This field requests that a user initiated heartbeat be made immediately.
This must not be used in conjunction with a wildcard address.
SPP HB TIME IS ZERO:
This field specifies that the time for heartbeat delay is to be set to 0 milliseconds.
This field will enable PMTU discovery on the specified address.
This field will disable PMTU discovery on the specified address.
Note that if the address field is empty, then all addresses on the association are affected.
Note also that SPP PMTUD ENABLE and SPP PMTUD DISABLE are mutually exclusive.
Enabling both fields will yield undetermined results.
Setting this flag enables the setting of the IPV6 flow label value.
The value is contained in the spp ipv6 flowlabel field.
Upon retrieval, this flag will be set to indicate that the spp ipv6 flowlabel field has a valid value returned.
If a specific destination address is set (in the spp address field), then the value returned is that of the address.
If just an association is specified (and no address), then the association's default flow label is returned.
If neither an association nor a destination is specified, then the socket's default flow label is returned.
For non IPv6 sockets, this flag will be left cleared.
Setting this flag enables the setting of the Differentiated Services Code Point (DSCP) value associated with either the association or a specific address.
The value is obtained in the spp dscp field.
Upon retrieval, this flag will be set to indicate that the spp dscp field has a valid value returned.
If a specific destination address is set when called (in the spp address field), then that specific destination address's DSCP value is returned.
If just an association is specified, then the association's default DSCP is returned.
If neither an association nor a destination is specified, then the socket's default DSCP is returned.
This field is used in conjunction with the SPP IPV6 FLOWLABEL flag and contains the IPv6 flow label.
The 20 least significant bits are used for the flow label.
This setting has precedence over any IPv6 layer setting.
This field is used in conjunction with the SPP DSCP flag and contains the DSCP.
The 6 most significant bits are used for the DSCP.
This setting has precedence over any IPv4  or IPv6  layer setting.
Please note that changing the flow label or DSCP value will affect all packets sent by the SCTP stack after setting these parameters.
The flow label might also be set via the sin6 flowinfo field of the sockaddr in6 structure.
Set Default Send Parameters (SCTP DEFAULT SEND PARAM)
Please note that this option is deprecated.
SCTP DEFAULT SNDINFO (Section 8.1.31) should be used instead.
Applications that wish to use the sendto() system call may wish to specify a default set of parameters that would normally be supplied through the inclusion of ancillary data.
This socket option allows such an application to set the default sctp sndrcvinfo structure.
The application that wishes to use this socket option simply passes the sctp sndrcvinfo structure (defined in Section 5.3.2) to this call.
The input parameters accepted by this call include sinfo stream, sinfo flags, sinfo ppid, sinfo context, and sinfo timetolive.
The sinfo flags field is composed of a bitwise OR of SCTP UNORDERED, SCTP EOF, and SCTP SENDALL.
The sinfo assoc id field specifies the association to which to apply the parameters.
For a one to many style socket, any of the predefined constants are also allowed in this field.
The field is ignored for one to one style sockets.
Set Notification and Ancillary Events
This socket option is used to specify various notifications and ancillary data the user wishes to receive.
Please see Section 6.2.1 for a full description of this option and its usage.
Note that this option is considered deprecated and is present for backward compatibility.
New applications should use the SCTP EVENT option.
See Section 6.2.2 for a full description of that option as well.
Set/Clear IPv4 Mapped Addresses (
I WANT MAPPED V4 ADDR)
This socket option is a boolean flag that turns on or off the mapping of IPv4 addresses.
If this option is turned on, then IPv4 addresses will be mapped to IPv6 representation.
If this option is turned off, then no mapping will be done of IPv4 addresses, and a user will receive both PF INET6 and PF INET type addresses on the socket.
See [RFC3542] for more details on mapped IPv6 addresses.
If this socket option is used on a socket of type PF INET, an error is returned.
By default, this option is turned off and expects an integer to be passed where a non zero value turns on the option and a zero value turns off the option.
Get or Set the Maximum Fragmentation Size
This option will get or set the maximum size to put in any outgoing SCTP DATA chunk.
If a message is larger than this maximum size, it will be fragmented by SCTP into the specified size.
Note that the underlying SCTP implementation may fragment into smaller sized chunks when the PMTU of the underlying association is smaller than the value set by the user.
The default value for this option is '0', which indicates that the user is not limiting fragmentation and only the PMTU will affect SCTP's choice of DATA chunk size.
Note also that values set larger than the maximum size of an IP datagram will effectively let SCTP control fragmentation (i.e., the same as setting this option to 0).
This parameter is ignored for one to one style sockets.
For one to many style sockets, this parameter indicates upon which association the user is performing an action.
It is an error to use SCTP {CURRENT ALL} ASSOC in assoc
This parameter specifies the maximum size in bytes.
Get or Set the List of Supported HMAC Identifiers
This option gets or sets the list of Hashed Message Authentication Code (HMAC) algorithms that the local endpoint requires the peer to use.
This field gives the number of elements present in the array shmac idents.
This parameter contains an array of HMAC identifiers that the local endpoint is requesting the peer to use, in priority order.
AUTH HMAC ID SHA256 Note that the list supplied must include SCTP AUTH HMAC ID SHA1 and may include any of the other values in its preferred order
(lowest list position has the highest preference in algorithm selection).
Note also that the lack of SCTP AUTH HMAC ID SHA1, or the inclusion of an unknown HMAC identifier (including optional identifiers unknown to the implementation), will cause the set option to fail and return an error.
Get or Set the Active Shared Key
This option will get or set the active shared key to be used to build the association shared key.
The following structure is used to access and modify these parameters: struct sctp authkeyid { sctp assoc t scact assoc id;
This parameter sets the active key of the specified association.
The special SCTP {FUTURE CURRENT
ALL} ASSOC can be used.
For one to one style sockets, this parameter is ignored.
Note, however, that this option will set the active key on the association if the socket is connected; otherwise, this option will set the default active key for the endpoint.
This parameter is the shared key identifier that the application is requesting to become the active shared key to be used for sending authenticated chunks.
The key identifier must correspond to an existing shared key.
Note that shared key identifier '0' defaults to a null key.
When used with setsockopt(), the SCTP implementation must use the indicated shared key identifier for all messages being given to an SCTP implementation via a send call after the setsockopt() call, until changed again.
Therefore, the SCTP implementation must not bundle user messages that should be authenticated using different shared key identifiers.
Initially, the key with key identifier 0 is the active key.
Get or Set Delayed SACK Timer
This option will affect the way delayed SACKs are performed.
This option allows the application to get or set the delayed SACK time, in milliseconds.
It also allows changing the delayed SACK frequency.
Changing the frequency to 1 disables the delayed SACK algorithm.
Note that if sack delay or sack freq is 0 when setting this option, the current values will remain unchanged.
This parameter is ignored for one to one style sockets.
For one to many style sockets, this parameter indicates upon which association the user is performing an action.
The special SCTP {FUTURE CURRENT
ALL} ASSOC can also be used.
This parameter contains the number of milliseconds the user is requesting that the delayed SACK timer be set to.
Note that this value is defined in [RFC4960] to be between 200 and 500 milliseconds.
This parameter contains the number of packets that must be received before a SACK is sent without waiting for the delay timer to expire.
The default value is 2; setting this value to 1 will disable the delayed SACK algorithm.
Get or Set Fragmented Interleave
Fragmented interleave controls how the presentation of messages occurs for the message receiver.
There are three levels of fragment interleave defined.
Two of the levels affect one to one style sockets, while one to many style sockets are affected by all three levels.
This option takes an integer value.
It can be set to a value of 0, 1, or 2.
Attempting to set this level to other values will return an error.
Setting the three levels provides the following receiver interactions: level 0:  Prevents the interleaving of any messages.
This means that when a partial delivery begins, no other messages will be received except the message being partially delivered.
If another message arrives on a different stream (or association) that could be delivered, it will be blocked waiting for the user to read all of the partially delivered message.
level 1:  Allows interleaving of messages that are from different associations.
For one to one style sockets, level 0 and level 1 thus have the same meaning, since a one to one style socket always receives messages from the same association.
Note that setting a one to many style socket to this level may cause multiple partial deliveries from different associations, but for any given association, only one message will be delivered until all parts of a message have been delivered.
This means that one large message, being read with an association identifier of "X", will block other messages from association "X" from being delivered.
level 2:  Allows complete interleaving of messages.
This level requires that the sender not only carefully observe the peer association identifier (or address) but also pay careful attention to the stream number.
With this option enabled, a partially delivered message may begin being delivered for association "X" stream "Y", and the next subsequent receive may return a message from association "X" stream "Z".
Note that no other messages would be delivered for association "X" stream "Y" until all of stream "Y"'s partially delivered message was read.
Note that this option also affects one to one style sockets.
Also note that for one to many style sockets, not only another stream's message from the same association may be delivered upon the next receive, but some other association's message may also be delivered upon the next receive.
An implementation should default one to many style sockets to level 1, because otherwise, it is possible that a peer could begin sending a partial message and thus block all other peers from sending data.
However, a setting of level 2 requires that the application not only be aware of the association (via the association identifier or peer's address) but also the stream number.
The stream number is not present unless the user has subscribed to the sctp data io event (see Section 6.2), which is deprecated, or has enabled the SCTP RECVRCVINFO socket option (see Section 8.1.29).
This is also why we recommend that one to one style sockets be defaulted to level 0
(level 1 for one to one style sockets has no effect).
Note that an implementation should return an error if an application attempts to set the level to 2 and has not subscribed to the sctp data io event event, which is deprecated, or has enabled the SCTP RECVRCVINFO socket option.
For applications that have subscribed to events, those events appear in the normal socket buffer data stream.
This means that unless the user has set the fragmentation interleave level to 0, notifications may also be interleaved with partially delivered messages.
Set or Get the SCTP Partial Delivery Point
This option will set or get the SCTP partial delivery point.
This point is the size of a message where the partial delivery API will be invoked to help free up rwnd space for the peer.
Setting this to a lower value will cause partial deliveries to happen more often.
This option expects an integer that sets or gets the partial delivery point in bytes.
Note also that the call will fail if the user attempts to set this value larger than the socket receive buffer size.
Note that any single message having a length smaller than or equal to the SCTP partial delivery point will be delivered in a single read call as long as the user provided buffer is large enough to hold the message.
Set or Get the Use of Extended Receive Info (SCTP USE EXT RCVINFO)
This option will enable or disable the use of the extended version of the sctp sndrcvinfo structure.
If this option is disabled, then the normal sctp sndrcvinfo structure is returned in all receive message calls.
If this option is enabled, then the sctp extrcvinfo structure is returned in all receive message calls.
Note that the sctp extrcvinfo structure is never used in any send call.
This option is present for compatibility with older applications and is deprecated.
Future applications should use SCTP NXTINFO to retrieve this same information via ancillary data.
Set or Get the Auto ASCONF Flag (SCTP AUTO ASCONF)
This option will enable or disable the use of the automatic generation of ASCONF chunks to add and delete addresses to an existing association.
Note that this option has two caveats, namely a)
it only affects sockets that are bound to all addresses available to the SCTP stack, and b) the system administrator may have an overriding control that turns the ASCONF feature off no matter what setting the socket option may have.
This option expects an integer boolean flag, where a non zero value turns on the option, and a zero value turns off the option.
Set or Get the Maximum Burst
This option will allow a user to change the maximum burst of packets that can be emitted by this association.
Note that the default value is 4, and some implementations may restrict this setting so that it can only be lowered to positive values.
To set or get this option, the user fills in the following structure: struct sctp assoc value { sctp assoc t assoc id;
This parameter is ignored for one to one style sockets.
For one to many style sockets, this parameter indicates upon which association the user is performing an action.
The special SCTP {FUTURE CURRENT
ALL} ASSOC can also be used.
This parameter contains the maximum burst.
Setting the value to 0 disables burst mitigation.
Set or Get the Default Context
The context field in the sctp sndrcvinfo structure is normally only used when a failed message is retrieved holding the value that was sent down on the actual send call.
This option allows the setting, on an association basis, of a default context that will be received on reading messages from the peer.
This is especially helpful for an application when using one to many style sockets to keep some reference to an internal state machine that is processing messages on the association.
Note that the setting of this value only affects received messages from the peer and does not affect the value that is saved with outbound messages.
To set or get this option, the user fills in the following structure: struct sctp assoc value { sctp assoc t assoc id;
This parameter is ignored for one to one style sockets.
For one to many style sockets, this parameter indicates upon which association the user is performing an action.
The special SCTP {FUTURE CURRENT
ALL} ASSOC can also be used.
This parameter contains the context.
Enable or Disable Explicit EOR Marking
This boolean flag is used to enable or disable explicit end of record (EOR) marking.
When this option is enabled, a user may make multiple send system calls to send a record and must indicate that they are finished sending a particular record by including the SCTP EOR flag.
If this boolean flag is disabled, then each individual send system call is considered to have an SCTP EOR indicator set on it implicitly without the user having to explicitly add this flag.
This option expects an integer boolean flag, where a non zero value turns on the option, and a zero value turns off the option.
Enable SCTP Port Reusage (SCTP REUSE PORT)
This option only supports one to one style SCTP sockets.
If used on a one to many style SCTP socket, an error is indicated.
This option expects an integer boolean flag, where a non zero value turns on the option, and a zero value turns off the option.
This socket option must not be used after calling bind() or sctp bindx() for a one to one style SCTP socket.
If using bind() or sctp bindx() on a socket with the SCTP REUSE PORT option, all other SCTP sockets bound to the same port must have set the SCTP REUSE PORT option.
Calling bind() or sctp bindx() for a socket without having set the SCTP REUSE PORT option will fail if there are other sockets bound to the same port.
At most one socket being bound to the same port may be listening.
It should be noted that the behavior of the socket level socket option to reuse ports and/or addresses for SCTP sockets is unspecified.
Set Notification Event (SCTP EVENT)
This socket option is used to set a specific notification option.
Please see Section 6.2.2 for a full description of this option and its usage.
the Delivery of SCTP RCVINFO as Ancillary Data (SCTP RECVRCVINFO)
Setting this option specifies that SCTP RCVINFO (defined in Section 5.3.5) is returned as ancillary data by recvmsg().
This option expects an integer boolean flag, where a non zero value turns on the option, and a zero value turns off the option.
as Ancillary Data (SCTP RECVNXTINFO)
Setting this option specifies that SCTP NXTINFO (defined in Section 5.3.6) is returned as ancillary data by recvmsg().
This option expects an integer boolean flag, where a non zero value turns on the option, and a zero value turns off the option.
Set Default Send Parameters (SCTP DEFAULT SNDINFO) Applications that wish to use the sendto
() system call may wish to specify a default set of parameters that would normally be supplied through the inclusion of ancillary data.
This socket option allows such an application to set the default sctp sndinfo structure.
The application that wishes to use this socket option simply passes the sctp sndinfo structure (defined in Section 5.3.4) to this call.
The input parameters accepted by this call include snd sid, snd flags, snd ppid, and snd context.
The snd flags parameter is composed of a bitwise OR of SCTP UNORDERED, SCTP EOF, and SCTP SENDALL.
id field specifies the association to which to apply the parameters.
For a one to many style socket, any of the predefined constants are also allowed in this field.
The field is ignored for one to one style sockets.
Set Default PR SCTP Parameters (SCTP DEFAULT PRINFO)
This option sets and gets the default parameters for PR SCTP.
They can be overwritten by specific information provided in send calls.
This field is the same as that described in Section 5.3.7.
This field is the same as that described in Section 5.3.7.
This field is ignored for one to one style sockets.
For one to many style sockets, pr assoc id can be a particular association identifier or SCTP {FUTURE CURRENT
The options defined in this subsection are read only.
Using this option in a setsockopt() call will result in an error indicating EOPNOTSUPP.
Applications can retrieve current status information about an association, including association state, peer receiver window size, number of unacknowledged DATA chunks, and number of DATA chunks pending receipt.
This information is read only.
The following structure is used to access this information: struct sctp status
{ sctp assoc t sstat assoc id;
; uint32 t sstat rwnd; uint16 t sstat unackdata; uint16 t sstat penddata
This parameter is ignored for one to one style sockets.
For one to many style sockets, it holds the identifier for the association.
All notifications for a given association have the same association identifier.
The special SCTP {FUTURE  CURRENT
ALL} ASSOC cannot be used.
PENDING    SCTP SHUTDOWN SENT    SCTP SHUTDOWN
This contains the association peer's current receiver window size.
This is the number of unacknowledged DATA chunks.
This is the number of DATA chunks pending receipt.
This is the number of streams that the peer will be using outbound.
This is the number of outbound streams that the endpoint is allowed to use.
This is the size at which SCTP fragmentation will occur.
This is information on the current primary peer address.
To access these status values, the application calls getsockopt() with the option name SCTP STATUS.
(SCTP GET PEER ADDR INFO)
Applications can retrieve information about a specific peer address of an association, including its reachability state, congestion window, and retransmission timer values.
This information is read only.
This parameter is ignored for one to one style sockets.
For one to many style sockets, this field may be filled by the application, and if so, this field will have priority in looking up the association instead of using the address specified in spinfo address.
Note that if the address does not belong to the association specified, then this call will fail.
If the application does not fill in the spinfo assoc id, then the address will be used to look up the association, and on return, this field will have the valid association identifier.
In other words, this call can be used to translate an address into an association identifier.
Note that the predefined constants are not allowed for this option.
This is filled by the application and contains the peer address of interest.
This contains the peer address's state:
This is the initial state of a peer address.
This state is entered the first time after path verification.
It can also be entered
if the state is SCTP INACTIVE and the path supervision detects that the peer address is reachable again.
This state is entered whenever a path failure is detected.
This contains the peer address's current congestion window.
This contains the peer address's current smoothed round trip time calculation in milliseconds.
This contains the peer address's current retransmission timeout value in milliseconds.
This is the current Path MTU of the peer address.
It is the number of bytes available in an SCTP packet for chunks.
Get the List of Chunks the Peer Requires to Be Authenticated (SCTP PEER AUTH CHUNKS)
This option gets a list of chunk types (see [RFC4960]) for a specified association that the peer requires to be received authenticated only.
The following structure is used to access these parameters: struct sctp authchunks { sctp assoc t gauth assoc id; uint32 t gauth number of chunks uint8
This parameter indicates for which association the user is requesting the list of peer authenticated chunks.
For one to one style sockets, this parameter is ignored.
Note that the predefined constants are not allowed with this option.
This parameter gives the number of elements in the array gauth chunks.
This parameter contains an array of chunk types that the peer is requesting to be authenticated.
If the passed in buffer size is not large enough to hold the list of chunk types, ENOBUFS is returned.
Get the List of Chunks the Local Endpoint Requires to Be Authenticated (SCTP LOCAL AUTH CHUNKS)
This option gets a list of chunk types (see [RFC4960]) for a specified association that the local endpoint requires to be received authenticated only.
This parameter is ignored for one to one style sockets.
For one to many style sockets, the application may fill in an association identifier or SCTP FUTURE ASSOC.
It is an error to use SCTP {CURRENT ALL
} ASSOC in gauth assoc id.
This parameter gives the number of elements in the array gauth chunks.
This parameter contains an array of chunk types that the local endpoint is requesting to be authenticated.
If the passed in buffer is not large enough to hold the list of chunk types, ENOBUFS is returned.
Get the Current Number of Associations
This option gets the current number of associations that are attached to a one to many style socket.
The option value is an uint32 t. Note that this number is only a snapshot.
This means that the number of associations may have changed when the caller gets back the option result.
For a one to one style socket, this socket option results in an error.
Get the Current Identifiers of Associations
(SCTP GET ASSOC ID LIST)
This option gets the current list of SCTP association identifiers of the SCTP associations handled by a one to many style socket.
If the buffer is too small, an error must be returned.
The user can use the SCTP GET ASSOC NUMBER socket option to get an idea of how large the buffer has to be.
gaids number of ids gives the number of elements in the array gaids assoc id.
Note also that some or all of sctp assoc t returned in the array may become invalid by the time the caller gets back the result.
For a one to one style socket, this socket option results in an error.
The options defined in this subsection are write only.
Using this option in a getsockopt() or sctp opt info() call will result in an error indicating EOPNOTSUPP.
(SCTP SET PEER PRIMARY ADDR)
This call requests that the peer mark the enclosed address as the association primary (see [RFC5061]).
The enclosed address must be one of the association's locally bound addresses.
The following structure is used to make a set peer primary request:
This parameter is ignored for one to one style sockets.
For one to many style sockets, it identifies the association for this request.
Note that the predefined constants are not allowed for this option.
The address to set as primary.
Add a Chunk That Must Be Authenticated (SCTP AUTH CHUNK)
This set option adds a chunk type that the user is requesting to be received only in an authenticated way.
Changes to the list of chunks will only affect future associations on the socket.
This parameter contains a chunk type that the user is requesting to be authenticated.
The chunk types for INIT, INIT ACK, SHUTDOWN COMPLETE, and AUTH chunks must not be used.
If they are used, an error must be returned.
The usage of this option enables SCTP AUTH in cases where it is not required by other means (for example, the use of dynamic address reconfiguration).
This option will set a shared secret key that is used to build an association shared key.
The following structure is used to access and modify these parameters: struct sctp authkey { sctp assoc t sca assoc id; uint16 t sca keynumber; uint16 t sca keylength;
This parameter indicates on what association the shared key is being set.
The special SCTP {FUTURE CURRENT
ALL} ASSOC can be used.
For one to one style sockets, this parameter is ignored.
Note, however, that on one to one style sockets, this option will set a key on the association if the socket is connected; otherwise, this option will set a key on the endpoint.
This parameter is the shared key identifier by which the application will refer to this shared key.
If a key of the specified index already exists, then this new key will replace the old existing key.
Note that shared key identifier '0' defaults to a null key.
This parameter is the length of the array sca key.
This parameter contains an array of bytes that is to be used by the endpoint (or association) as the shared secret key.
Note that if the length of this field is zero, a null key is set.
a Shared Key (SCTP AUTH DEACTIVATE KEY)
This set option indicates that the application will no longer send user messages using the indicated key identifier.
struct sctp authkeyid { sctp assoc t scact assoc id;
This parameter indicates from which association the shared key identifier is being deleted.
The special SCTP {FUTURE  CURRENT
ALL} ASSOC can be used.
For one to one style sockets, this parameter is ignored.
Note, however, that this option will deactivate the key from the association if the socket is connected; otherwise, this option will deactivate the key from the endpoint.
This parameter is the shared key identifier that the application is requesting to be deactivated.
The key identifier must correspond to an existing shared key.
Note that if this parameter is zero, use of the null key identifier '0' is deactivated on the endpoint and/or association.
The currently active key cannot be deactivated.
a Shared Key (SCTP AUTH DELETE KEY)
This set option will delete an SCTP association's shared secret key that has been deactivated.
struct sctp authkeyid { sctp assoc t scact assoc id;
This parameter indicates from which association the shared key identifier is being deleted.
The special SCTP {FUTURE  CURRENT
ALL} ASSOC can be used.
For one to one style sockets, this parameter is ignored.
Note, however, that this option will delete the key from the association if the socket is connected; otherwise, this option will delete the key from the endpoint.
This parameter is the shared key identifier that the application is requesting to be deleted.
The key identifier must correspond to an existing shared key and must not be in use for any packet being sent by the SCTP implementation.
This means, in particular, that it must be deactivated first.
Note that if this parameter is zero, use of the null key identifier '0' is deleted from the endpoint and/or association.
Only deactivated keys that are no longer used by an association can be deleted.
Depending on the system, the following interface can be implemented as a system call or library function.
This function allows the user to bind a specific subset of addresses or, if the SCTP extension described in [RFC5061] is supported, add or delete specific addresses.
The function prototype is int sctp bindx(int
sd, struct sockaddr  addrs, int addrcnt, int flags); If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.
If the sd is an IPv6 socket, the addresses passed can either be IPv4 or IPv6 addresses.
A single address may be specified as INADDR ANY for an IPv4 address, or as IN6ADDR ANY INIT or in6addr
any for an IPv6 address; see Section 3.1.2 for this usage.
addrs is a pointer to an array of one or more socket addresses.
Each address is contained in its appropriate structure.
For an IPv6 socket, an array of sockaddr in6 is used.
For an IPv4 socket, an array of sockaddr in is used.
The caller specifies the number of addresses in the array with addrcnt.
Note that the wildcard addresses cannot be used in combination with non wildcard addresses on a socket with this function; doing so will result in an error.
On success, sctp bindx() returns 0.
On failure, sctp bindx() returns  1 and sets errno to the appropriate error code.
For SCTP, the port given in each socket address must be the same, or sctp bindx() will fail, setting errno to EINVAL.
The flags parameter is formed from the bitwise OR of zero or more of the following currently defined flags:  SCTP
BINDX REM ADDR SCTP BINDX ADD ADDR directs
SCTP to add the given addresses to the socket (i.e., endpoint), and SCTP BINDX REM ADDR directs SCTP to remove the given addresses from the socket.
The two flags are mutually exclusive; if both are given, sctp bindx() will fail with EINVAL.
A caller may not remove all addresses from a socket; sctp bindx() will reject such an attempt with EINVAL.
An application can use sctp bindx(SCTP BINDX ADD ADDR) to associate additional addresses with an endpoint after calling bind().
Or, an application can use sctp bindx(SCTP BINDX REM ADDR) to remove some addresses with which a listening socket is associated, so that no new association accepted
will be associated with these addresses.
If the endpoint supports dynamic address reconfiguration, an SCTP BINDX REM ADDR or SCTP BINDX ADD ADDR may cause an endpoint to send the appropriate message to its peers to change the peers' address lists.
Adding and removing addresses from established associations is an optional functionality.
Implementations that do not support this functionality should return  1 and set errno to EOPNOTSUPP.
sctp bindx() can be called on an already bound socket or on an unbound socket.
If the socket is unbound and the first port number in the addrs parameter is zero, the kernel will choose a port number.
All port numbers after the first one being 0 must also be zero.
If the first port number is not zero, the following port numbers must be zero or have the same value as the first one.
For an already bound socket, all port numbers provided must be the bound one or 0.
sctp bindx() is an atomic operation.
Therefore, the binding will either succeed on all addresses or fail on all addresses.
If multiple addresses are provided and the sctp bindx() call fails, there is no indication of which address is responsible for the failure.
The only way to identify the specific error indication is to call sctp bindx() sequentially with only one address per call.
After an association is established on a one to many style socket, the application may wish to branch off the association into a separate socket/file descriptor.
This is particularly desirable when, for instance, the application wishes to have a number of sporadic message senders/receivers remain under the original one to many style socket but branch off these associations carrying high volume data traffic into their own separate socket descriptors.
The application uses the sctp peeloff() call to branch off an association into a separate socket.
(Note that the semantics are somewhat changed from the traditional one to one style accept() call.)
Note also that the new socket is a one to one style socket.
Thus, it will be confined to operations allowed for a one to one style socket.
The function prototype is int sctp peeloff(int
sctp assoc t assoc id); and the arguments are sd:
The original one to many style socket descriptor returned from the socket() system call (see Section 3.1.1).
The specified identifier of the association that is to be branched off to a separate file descriptor.
(Note that in a traditional one to one style accept() call, this would be an out parameter, but for the one to many style call, this is an in parameter.)
The function returns a non negative file descriptor representing the branched off association, or  1 if an error occurred.
The variable errno is then set appropriately.
sctp getpaddrs() sctp getpaddrs() returns all peer addresses in an association.
The function prototype is int sctp getpaddrs(int
sd, sctp assoc t id, struct sockaddr   addrs); On return, addrs will point to a dynamically allocated array of sockaddr structures of the appropriate type for the socket type.
The caller should use sctp freepaddrs() to free the memory.
Note that the in/out parameter addrs must not be NULL.
If sd is an IPv4 socket, the addresses returned will be all IPv4 addresses.
If sd is an IPv6 socket, the addresses returned can be a mix of IPv4 or IPv6 addresses, with IPv4 addresses returned according to the SCTP I WANT MAPPED V4 ADDR option setting.
For one to many style sockets, id specifies the association to query.
For one to one style sockets, id is ignored.
On success, sctp getpaddrs() returns the number of peer addresses in the association.
If there is no association on this socket, sctp getpaddrs() returns 0, and the value of  addrs is undefined.
If an error occurs, sctp getpaddrs() returns  1, and the value of  addrs is undefined.
sctp freepaddrs() frees all resources allocated by sctp getpaddrs().
The function prototype is void sctp
sockaddr  addrs); and addrs is the array of peer addresses returned by sctp getpaddrs().
sctp getladdrs() sctp getladdrs() returns all locally bound addresses on a socket.
The function prototype is int sctp getladdrs(int
sd, sctp assoc t id, struct sockaddr   addrs); On return, addrs will point to a dynamically allocated array of sockaddr structures of the appropriate type for the socket type.
The caller should use sctp freeladdrs() to free the memory.
Note that the in/out parameter addrs must not be NULL.
If sd is an IPv4 socket, the addresses returned will be all IPv4 addresses.
If sd is an IPv6 socket, the addresses returned can be a mix of IPv4 or IPv6 addresses, with IPv4 addresses returned according to the SCTP I WANT MAPPED V4 ADDR option setting.
For one to many style sockets, id specifies the association to query.
For one to one style sockets, id is ignored.
If the id field is set to the value '0', then the locally bound addresses are returned without regard to any particular association.
On success, sctp getladdrs() returns the number of local addresses bound to the socket.
If the socket is unbound, sctp getladdrs() returns 0, and
the value of  addrs is undefined.
If an error occurs, sctp getladdrs() returns  1, and the value of  addrs is undefined.
() frees all resources allocated by sctp getladdrs().
The function prototype is void sctp freeladdrs(struct sockaddr  addrs); and addrs is the array of local addresses returned by sctp getladdrs().
This function is deprecated; sctp sendv() (see Section 9.12) should be used instead.
An implementation may provide a library function (or possibly system call) to assist the user with the advanced features of SCTP.
The function prototype is ssize t sctp sendmsg(int sd,
, const struct sockaddr  to, socklen t tolen, uint32 t ppid, uint32 t flags, uint16 t stream
no, uint32 t timetolive, uint32 t context); and
The message to be sent.
The length of the message.
The destination address of the message.
The length of the destination address.
The same as sinfo ppid (see Section 5.3.2).
The same as sinfo flags (see Section 5.3.2).
The same as sinfo stream (see Section 5.3.2).
The same as sinfo timetolive (see Section 5.3.2).
The same as sinfo context (see Section 5.3.2).
The call returns the number of characters sent, or  1 if an error occurred.
The variable errno is then set appropriately.
Sending a message using sctp sendmsg() is atomic (unless explicit EOR marking is enabled on the socket specified by sd).
Using sctp sendmsg() on a non connected one to one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.
This function is deprecated; sctp recvv() (see Section 9.13) should be used instead.
An implementation may provide a library function (or possibly system call) to assist the user with the advanced features of SCTP.
Note that in order for the sctp sndrcvinfo structure to be filled in by sctp recvmsg(), the caller must enable the sctp data io event with the SCTP EVENTS option.
Note that the setting of the SCTP USE EXT RCVINFO will affect this function as well, causing the sctp sndrcvinfo information to be extended.
The function prototype is ssize t sctp recvmsg(int sd, void  msg, size t len, struct sockaddr  from, socklen t  fromlen struct sctp sndrcvinfo  sinfo int  msg flags); and the arguments are sd:  The socket descriptor.
The message buffer to be filled.
The length of the message buffer.
from:  A pointer to an address to be filled with the address of the sender of this message.
An in/out parameter describing the from length.
A pointer to an sctp sndrcvinfo structure to be filled upon receipt of the message.
msg flags:  A pointer to an integer to be filled with any message flags (e.g., MSG NOTIFICATION).
Note that this field is
Options for the receive may also be passed into the value (e.g., MSG PEEK).
On return from the call, the msg flags value will be different than what was sent in to the call.
If implemented via a recvmsg() call, the msg flags parameter should only contain the value of the flags from the recvmsg() call.
The call returns the number of bytes received, or  1 if an error occurred.
The variable errno is then set appropriately.
() An implementation may provide a library function (or possibly system call) to assist the user with associating to an endpoint that is multi homed.
Much like sctp bindx(), this call allows a caller to specify multiple addresses at which a peer can be reached.
The way the SCTP stack uses the list of addresses to set up the association is implementation dependent.
This function only specifies that the stack will try to make use of all of the addresses in the list when needed.
Note that the list of addresses passed in is only used for setting up the association.
It does not necessarily equal the set of addresses the peer uses for the resulting association.
If the caller wants to find out the set of peer addresses, it must use sctp getpaddrs() to retrieve them after the association has been set up.
The function prototype is int sctp connectx(int
addrs, int addrcnt, sctp assoc t  id); and
The number of addresses in the array.
An output parameter that, if passed in as non NULL, will return the association identifier for the newly created association (if successful).
The call returns 0 on success or  1 if an error occurred.
The variable errno is then set appropriately.
This function is deprecated; sctp sendv() should be used instead.
An implementation may provide another alternative function or system call to assist an application with the sending of data without the use of the cmsghdr structures.
The function prototype is ssize t sctp send(int
, const struct sctp sndrcvinfo  sinfo, int flags); and the arguments are sd:
The message to be sent.
The length of the message.
A pointer to an sctp sndrcvinfo structure used as described in Section 5.3.2 for a sendmsg() call.
The same flags as used by the sendmsg() call flags (e.g., MSG DONTROUTE).
The call returns the number of bytes sent, or  1 if an error occurred.
The variable errno is then set appropriately.
This function call may also be used to terminate an association using an association identifier by setting the sinfo.sinfo flags to SCTP EOF and the sinfo.sinfo assoc id to the association that needs to be terminated.
In such a case, len can be zero.
Using sctp send() on a non connected one to one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.
Sending a message using sctp send() is atomic unless explicit EOR marking is enabled on the socket specified by sd. 9.11.
This function is deprecated; sctp sendv() should be used instead.
An implementation may provide another alternative function or system call to assist an application with the sending of data without the use of the cmsghdr structure, and to provide a list of addresses.
The list of addresses is provided for implicit association setup.
In such a case, the list of addresses serves the same purpose as the addresses given in sctp connectx() (see Section 9.9).
The function prototype is ssize t sctp sendx(int
msg, size t len, struct sockaddr  addrs, int addrcnt, struct sctp sndrcvinfo  sinfo, int flags); and the arguments are sd:
The message to be sent.
The length of the message.
The number of addresses in the array.
A pointer to an sctp sndrcvinfo structure used as described in Section 5.3.2 for a sendmsg() call.
The same flags as used by the sendmsg() call flags (e.g., MSG DONTROUTE).
The call returns the number of bytes sent, or  1 if an error occurred.
The variable errno is then set appropriately.
Note that in the case of implicit connection setup, on return from this call, the sinfo assoc id field of the sinfo structure will contain the new association identifier.
This function call may also be used to terminate an association using an association identifier by setting the sinfo.sinfo flags to SCTP EOF and the sinfo.sinfo assoc id to the association that needs to be terminated.
In such a case, len would be zero.
Sending a message using sctp sendx() is atomic unless explicit EOR marking is enabled on the socket specified by sd.
Using sctp sendx() on a non connected one to one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.
The function prototype is ssize t sctp sendv(int sd
iov, int iovcnt, struct sockaddr  addrs, int addrcnt, void  info, socklen t infolen, unsigned int infotype, int flags); The function sctp sendv() provides an extensible way for an application to communicate different send attributes to the SCTP stack when sending a message.
An implementation may provide sctp sendv() as a library function or a system call.
This document defines three types of attributes that can be used to describe a message to be sent.
They are struct sctp sndinfo (Section 5.3.4), struct sctp prinfo (Section 5.3.7), and struct sctp authinfo (Section 5.3.8).
The following structure, sctp sendv spa, is defined to be used when more than one of the above attributes are needed to describe a message to be sent.
In future, when new send attributes are needed, new structures can be defined.
But those new structures do not need to be based on any of the above defined structures.
The function takes the following arguments:
The data in the buffer is treated as a single user message.
The number of elements in iov.
An array of addresses to be used to set up an association or a single address to be used to send the message.
NULL is passed in if the caller neither wants to set up an association nor wants to send the message to a specific address.
The number of addresses in the addrs array.
A pointer to the buffer containing the attribute associated with the message to be sent.
The type is indicated by the info type parameter.
The length of info, in bytes.
Identifies the type of the information provided in info.
The current defined values are as follows:
The parameter info is a NULL pointer, and infolen is 0.
The parameter info is pointing to a struct sctp sndinfo.
The parameter info is pointing to a struct sctp prinfo.
The parameter info is pointing to a struct sctp authinfo.
The parameter info is pointing to a struct sctp sendv spa.
The same flags as used by the sendmsg() call flags (e.g., MSG DONTROUTE).
The call returns the number of bytes sent, or  1 if an error occurred.
The variable errno is then set appropriately.
A note on the one to many style socket: The struct sctp sndinfo attribute must always be used in order to specify the association on which the message is to be sent.
The only case where it is not needed is when this call is used to set up a new association.
The caller provides a list of addresses in the addrs parameter to set up an association.
This function will behave like calling sctp connectx() (see Section 9.9), first using the list of addresses and then calling sendmsg() with the given message and attributes.
For a one to many style socket, if the struct sctp sndinfo attribute is provided, the snd assoc id field must be 0.
When this function returns, the snd assoc id field will contain the association identifier of the newly established association.
Note that the struct sctp sndinfo attribute is not required to set up an association for a one to many style socket.
If this attribute is not provided, the caller can enable the SCTP ASSOC
CHANGE notification and use the SCTP COMM UP message to find out the association identifier.
If the caller wants to send the message to a specific peer address (hence overriding the primary address), it can provide the specific address in the addrs parameter and provide a struct sctp sndinfo attribute with the field snd flags set to SCTP ADDR OVER.
This function call may also be used to terminate an association.
The caller provides an sctp sndinfo attribute with the snd flags set to SCTP EOF.
In this case, len would be zero.
Sending a message using sctp sendv() is atomic unless explicit EOR marking is enabled on the socket specified by sd. 9.13.
The function prototype is ssize t sctp recvv(int sd
, const struct iovec  iov, int iovlen, struct sockaddr  from, socklen t  fromlen, void  info, socklen t  infolen, unsigned int  infotype, int  flags); The function sctp recvv() provides an extensible way for the SCTP stack to pass up different SCTP attributes associated with a received message to an application.
An implementation may provide sctp recvv() as a library function or as a system call.
This document defines two types of attributes that can be returned by this call: the attribute of the received message and the attribute of the next message in the receive buffer.
The caller enables the SCTP RECVRCVINFO and SCTP RECVNXTINFO socket options, respectively, to receive these attributes.
Attributes of the received message are returned in struct sctp rcvinfo (Section 5.3.5), and attributes of the next message are returned in struct sctp nxtinfo (Section 5.3.6).
If both options are enabled, both attributes are returned using the following structure.
The new structures do not need to be based on struct sctp recvv rn or struct sctp rcvinfo.
This function takes the following arguments:
Only one user message is returned in this buffer.
The number of elements in iov.
from:  A pointer to an address to be filled with the sender of the received message's address.
An in/out parameter describing the from length.
A pointer to the buffer to hold the attributes of the received message.
The structure type of info is determined by the info type parameter.
An in/out parameter describing the size of the info buffer.
On return,  info type is set to the type of the info buffer.
The current defined values are as follows: SCTP RECVV NOINFO:
If both SCTP RECVRCVINFO and SCTP RECVNXTINFO options are not enabled, no attribute will be returned.
If only the SCTP RECVNXTINFO option is enabled but there is no next message in the buffer, no attribute will be returned.
In these cases,  info type will be set to SCTP RECVV NOINFO.
The type of info is struct sctp rcvinfo, and the attribute relates to the received message.
The type of info is struct sctp nxtinfo, and the attribute relates to the next message in the receive buffer.
This is the case when only the SCTP RECVNXTINFO option is enabled and there is a next message in the buffer.
The type of info is struct sctp recvv rn.
The recvv rcvinfo field is the attribute of the received message, and the recvv nxtinfo field is the attribute of the next message in the buffer.
This is the case when both SCTP RECVRCVINFO and SCTP RECVNXTINFO options are enabled and there is a next message in the receive buffer.
A pointer to an integer to be filled with any message flags (e.g., MSG NOTIFICATION).
Note that this field is an in/out parameter.
Options for the receive may also be passed into the value (e.g., MSG PEEK).
On return from the call, the flags value will be different than what was sent in to the call.
If implemented via a recvmsg() call, the flags should only contain the value of the flags from the recvmsg() call when calling sctp recvv(), and on return it has the value from msg flags.
The call returns the number of bytes received, or  1 if an error occurred.
The variable errno is then set appropriately.
Many TCP and UDP implementations reserve port numbers below 1024 for privileged users.
If the target platform supports privileged users, the SCTP implementation should restrict the ability to call bind() or sctp bindx() on these port numbers to privileged users.
Similarly, unprivileged users should not be able to set protocol parameters that could result in the congestion control algorithm being more aggressive than permitted on the public Internet.
These parameters are as follows:  struct sctp rtoinfo
If an unprivileged user inherits a one to many style socket with open associations on a privileged port, accepting new associations might be permitted, but opening new associations should not be permitted.
Applications using the one to many style sockets and using the interleave level (if 0) are subject to denial of service attacks, as described in Section 8.1.20.
Applications needing transport layer security can use Datagram Transport Layer Security/SCTP (DTLS/SCTP) as specified in [RFC6083].
This can be implemented using the sockets API described in this document.
Using One to One Style Sockets
The following code is an implementation of a simple client that sends a number of messages marked for unordered delivery to an echo server making use of all outgoing streams.
The example shows how to use some features of one to one style IPv4 SCTP sockets, including  Creating and connecting an SCTP socket.
Making a request to negotiate a number of outgoing streams.
Determining the negotiated number of outgoing streams.
Setting an adaptation layer indication.
Sending messages with a given payload protocol identifier on a particular stream using sctp sendv().
Copyright (c) 2011 IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license info).
> #include <string.h> #include <stdio.h
#define SIZE OF MESSAGE 1000 #define NUMBER OF MESSAGES 10
0, sizeof(init)); init.sinit num ostreams   2048; if (setsockopt(sd, IPPROTO SCTP, SCTP INITMSG, &init, (socklen t)sizeof(init))
/ memset(&status, 0, sizeof(status)); opt len   (socklen t)sizeof(status); if (getsockopt(sd, IPPROTO SCTP, SCTP STATUS, &status, &opt len) < 0)
if (sctp sendv(sd, (const struct
iovec  )&iov, 1, NULL, 0, &info, sizeof(info)
, SCTP SENDV SNDINFO, 0) < 0)
Using One to Many Style
The following code is a simple implementation of a discard server over SCTP.
The example shows how to use some features of one to many style IPv6 SCTP sockets, including  Opening and binding of a socket.
Configuring the auto close timer.
Using sctp recvv() to receive messages.
Please note that this server can be used in combination with the client described in Appendix A. <CODE BEGINS> /
2011 IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license info).
> #include <string.h> #include <stdio.h
> #define BUFFER SIZE (1<<16)
#define TIMEOUT 5 static void print
{ struct sctp assoc change  sac; struct sctp paddr change  spc; struct sctp adaptation event  sad; union sctp notification  snp; char addrbuf[INET6 ADDRSTRLEN]; const char  ap; struct sockaddr in  sin; struct sockaddr in6  sin6; snp   buf
; switch (snp sn header.sn type) { case SCTP
printf("Communication up (streams (in/out) (%u/%u)).\n", sac sac inbound streams, sac sac outbound streams); break; case SCTP COMM LOST:
printf("Communication lost (error %d).\n", sac sac error); break; case SCTP RESTART:
(%u/%u).\n", sac sac inbound streams, sac sac outbound streams); break;
break; case SCTP CANT STR ASSOC:
printf("Communication couldn't be started.\n"); break; default: printf("Unknown state: %d.\n", sac sac state); break; } break; case SCTP PEER ADDR CHANGE: spc   &snp sn paddr change;
if (spc spc aaddr.ss family   AF INET) { sin
(struct sockaddr in  )&spc spc aaddr;
{ case SCTP ADDR AVAILABLE: printf("is available.\n"); break; case SCTP ADDR UNREACHABLE: printf("is not available (error %d).\n", spc spc error); break
; case SCTP ADDR REMOVED: printf("was removed.\n"); break; case SCTP ADDR ADDED: printf("was added.\n"); break; case SCTP ADDR MADE PRIM:
printf("is primary.\n"); break; default: printf("unknown state (%d).\n", spc spc state); break; } break; case SCTP
{ int sd, flags, timeout, on; ssize t n; unsigned int i; union { struct sockaddr sa; struct sockaddr in sin; struct sockaddr in6 sin6; } addr; socklen t fromlen, infolen; struct sctp rcvinfo info; unsigned int infotype;
memset(&event, 0, sizeof(event)); event.se assoc i
SCTP FUTURE ASSOC; event.se on   1; for (i   0; i < sizeof(event
; const char  ap; in port t port; if (addr.sa.sa family   AF INET) { ap   inet ntop(AF INET, &addr.sin.sin addr, addrbuf, INET6 ADDRSTRLEN); port   ntohs(addr.sin.sin port)
; } else { ap   inet ntop(AF INET6, &addr.sin6.sin6 addr, addrbuf, INET6 ADDRSTRLEN)
case SCTP RECVV RN: printf(".\n")
