- contents:
  - "                           INTERNET PROTOCOL\n                         DARPA
    INTERNET PROGRAM\n                         PROTOCOL SPECIFICATION\n                             September
    1981\n                              prepared for\n               Defense Advanced
    Research Projects Agency\n                Information Processing Techniques Office\n
    \                        1400 Wilson Boulevard\n                       Arlington,
    Virginia  22209\n                     Information Sciences Institute\n                                                       Internet
    Protocol\n                           TABLE OF CONTENTS\n    PREFACE ........................................................
    iii\n"
  title: __initial_text__
- contents:
  - "1.  INTRODUCTION ..................................................... 1\n  1.1
    \ Motivation .................................................... 1\n  1.2  Scope
    ......................................................... 1\n  1.3  Interfaces
    .................................................... 1\n  1.4  Operation .....................................................
    2\n"
  title: 1.  INTRODUCTION ..................................................... 1
- contents:
  - "2.  OVERVIEW ......................................................... 5\n  2.1
    \ Relation to Other Protocols ................................... 9\n  2.2  Model
    of Operation ............................................ 5\n  2.3  Function Description
    .......................................... 7\n  2.4  Gateways ......................................................
    9\n"
  title: 2.  OVERVIEW ......................................................... 5
- contents:
  - "3.  SPECIFICATION ................................................... 11\n  3.1
    \ Internet Header Format ....................................... 11\n  3.2  Discussion
    ................................................... 23\n  3.3  Interfaces ...................................................
    31\n"
  title: 3.  SPECIFICATION ................................................... 11
- contents:
  - 'APPENDIX A:  Examples & Scenarios ................................... 34

    '
  title: 'APPENDIX A:  Examples & Scenarios ................................... 34'
- contents:
  - 'APPENDIX B:  Data Transmission Order ................................ 39

    '
  title: 'APPENDIX B:  Data Transmission Order ................................ 39'
- contents:
  - 'GLOSSARY ............................................................ 41

    '
  title: GLOSSARY ............................................................ 41
- contents:
  - 'REFERENCES .......................................................... 45

    '
  title: REFERENCES .......................................................... 45
- contents:
  - "Internet Protocol\n                                                       Internet
    Protocol\n                                PREFACE\n"
  title: Internet Protocol
- contents:
  - 'This document specifies the DoD Standard Internet Protocol.  This

    '
  title: This document specifies the DoD Standard Internet Protocol.  This
- contents:
  - 'document is based on six earlier editions of the ARPA Internet Protocol

    '
  title: document is based on six earlier editions of the ARPA Internet Protocol
- contents:
  - 'Specification, and the present text draws heavily from them.  There have

    '
  title: Specification, and the present text draws heavily from them.  There have
- contents:
  - 'been many contributors to this work both in terms of concepts and in

    '
  title: been many contributors to this work both in terms of concepts and in
- contents:
  - 'terms of text.  This edition revises aspects of addressing, error

    '
  title: terms of text.  This edition revises aspects of addressing, error
- contents:
  - 'handling, option codes, and the security, precedence, compartments, and

    '
  title: handling, option codes, and the security, precedence, compartments, and
- contents:
  - "handling restriction features of the internet protocol.\n                                                           Jon
    Postel\n                                                           Editor\n"
  title: handling restriction features of the internet protocol.
- contents:
  - 'RFC:  791

    '
  title: 'RFC:  791'
- contents:
  - 'Replaces:  RFC 760

    '
  title: 'Replaces:  RFC 760'
- contents:
  - 'IENs 128, 123, 111,

    '
  title: IENs 128, 123, 111,
- contents:
  - "80, 54, 44, 41, 28, 26\n                           INTERNET PROTOCOL\n                         DARPA
    INTERNET PROGRAM\n                         PROTOCOL SPECIFICATION\n                            1.
    \ INTRODUCTION\n"
  title: 80, 54, 44, 41, 28, 26
- contents:
  - "1.1.  Motivation\n  The Internet Protocol is designed for use in interconnected
    systems of\n  packet-switched computer communication networks.  Such a system
    has\n  been called a \"catenet\" [1].  The internet protocol provides for\n  transmitting
    blocks of data called datagrams from sources to\n  destinations, where sources
    and destinations are hosts identified by\n  fixed length addresses.  The internet
    protocol also provides for\n  fragmentation and reassembly of long datagrams,
    if necessary, for\n  transmission through \"small packet\" networks.\n"
  title: 1.1.  Motivation
- contents:
  - "1.2.  Scope\n  The internet protocol is specifically limited in scope to provide
    the\n  functions necessary to deliver a package of bits (an internet\n  datagram)
    from a source to a destination over an interconnected system\n  of networks.  There
    are no mechanisms to augment end-to-end data\n  reliability, flow control, sequencing,
    or other services commonly\n  found in host-to-host protocols.  The internet protocol
    can capitalize\n  on the services of its supporting networks to provide various
    types\n  and qualities of service.\n"
  title: 1.2.  Scope
- contents:
  - "1.3.  Interfaces\n  This protocol is called on by host-to-host protocols in an
    internet\n  environment.  This protocol calls on local network protocols to carry\n
    \ the internet datagram to the next gateway or destination host.\n  For example,
    a TCP module would call on the internet module to take a\n  TCP segment (including
    the TCP header and user data) as the data\n  portion of an internet datagram.
    \ The TCP module would provide the\n  addresses and other parameters in the internet
    header to the internet\n  module as arguments of the call.  The internet module
    would then\n  create an internet datagram and call on the local network interface
    to\n  transmit the internet datagram.\n  In the ARPANET case, for example, the
    internet module would call on a\n"
  title: 1.3.  Interfaces
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Introduction\n  local net module which would add the 1822 leader [2] to the internet\n
    \ datagram creating an ARPANET message to transmit to the IMP.  The\n  ARPANET
    address would be derived from the internet address by the\n  local network interface
    and would be the address of some host in the\n  ARPANET, that host might be a
    gateway to other networks.\n"
  title: Introduction
- contents:
  - "1.4.  Operation\n  The internet protocol implements two basic functions:  addressing
    and\n  fragmentation.\n  The internet modules use the addresses carried in the
    internet header\n  to transmit internet datagrams toward their destinations.  The\n
    \ selection of a path for transmission is called routing.\n  The internet modules
    use fields in the internet header to fragment and\n  reassemble internet datagrams
    when necessary for transmission through\n  \"small packet\" networks.\n  The model
    of operation is that an internet module resides in each host\n  engaged in internet
    communication and in each gateway that\n  interconnects networks.  These modules
    share common rules for\n  interpreting address fields and for fragmenting and
    assembling\n  internet datagrams.  In addition, these modules (especially in\n
    \ gateways) have procedures for making routing decisions and other\n  functions.\n
    \ The internet protocol treats each internet datagram as an independent\n  entity
    unrelated to any other internet datagram.  There are no\n  connections or logical
    circuits (virtual or otherwise).\n  The internet protocol uses four key mechanisms
    in providing its\n  service:  Type of Service, Time to Live, Options, and Header
    Checksum.\n  The Type of Service is used to indicate the quality of the service\n
    \ desired.  The type of service is an abstract or generalized set of\n  parameters
    which characterize the service choices provided in the\n  networks that make up
    the internet.  This type of service indication\n  is to be used by gateways to
    select the actual transmission parameters\n  for a particular network, the network
    to be used for the next hop, or\n  the next gateway when routing an internet datagram.\n
    \ The Time to Live is an indication of an upper bound on the lifetime of\n  an
    internet datagram.  It is set by the sender of the datagram and\n  reduced at
    the points along the route where it is processed.  If the\n  time to live reaches
    zero before the internet datagram reaches its\n  destination, the internet datagram
    is destroyed.  The time to live can\n  be thought of as a self destruct time limit.\n
    \                                                      Internet Protocol\n                                                            Introduction\n
    \ The Options provide for control functions needed or useful in some\n  situations
    but unnecessary for the most common communications.  The\n  options include provisions
    for timestamps, security, and special\n  routing.\n  The Header Checksum provides
    a verification that the information used\n  in processing internet datagram has
    been transmitted correctly.  The\n  data may contain errors.  If the header checksum
    fails, the internet\n  datagram is discarded at once by the entity which detects
    the error.\n  The internet protocol does not provide a reliable communication\n
    \ facility.  There are no acknowledgments either end-to-end or\n  hop-by-hop.
    \ There is no error control for data, only a header\n  checksum.  There are no
    retransmissions.  There is no flow control.\n  Errors detected may be reported
    via the Internet Control Message\n  Protocol (ICMP) [3] which is implemented in
    the internet protocol\n  module.\n"
  title: 1.4.  Operation
- contents:
  - "Internet Protocol\n                                                       Internet
    Protocol\n                              2.  OVERVIEW\n"
  title: Internet Protocol
- contents:
  - "2.1.  Relation to Other Protocols\n  The following diagram illustrates the place
    of the internet protocol\n  in the protocol hierarchy:\n                 +------+
    +-----+ +-----+     +-----+  \n                 |Telnet| | FTP | | TFTP| ... |
    ... |  \n                 +------+ +-----+ +-----+     +-----+  \n                       |
    \  |         |           |     \n                      +-----+     +-----+     +-----+
    \ \n                      | TCP |     | UDP | ... | ... |  \n                      +-----+
    \    +-----+     +-----+  \n                         |           |           |
    \    \n                      +--------------------------+----+\n                      |
    \   Internet Protocol & ICMP   |\n                      +--------------------------+----+\n
    \                                    |                 \n                        +---------------------------+
    \ \n                        |   Local Network Protocol  |  \n                        +---------------------------+
    \ \n                         Protocol Relationships\n                               Figure
    1.\n  Internet protocol interfaces on one side to the higher level\n  host-to-host
    protocols and on the other side to the local network\n  protocol.  In this context
    a \"local network\" may be a small network in\n  a building or a large network
    such as the ARPANET.\n"
  title: 2.1.  Relation to Other Protocols
- contents:
  - "2.2.  Model of Operation\n  The  model of operation for transmitting a datagram
    from one\n  application program to another is illustrated by the following\n  scenario:\n
    \   We suppose that this transmission will involve one intermediate\n    gateway.\n
    \   The sending application program prepares its data and calls on its\n    local
    internet module to send that data as a datagram and passes the\n    destination
    address and other parameters as arguments of the call.\n    The internet module
    prepares a datagram header and attaches the data\n    to it.  The internet module
    determines a local network address for\n    this internet address, in this case
    it is the address of a gateway.\n"
  title: 2.2.  Model of Operation
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Overview\n    It sends this datagram and the local network address to the local\n
    \   network interface.\n    The local network interface creates a local network
    header, and\n    attaches the datagram to it, then sends the result via the local\n
    \   network.\n    The datagram arrives at a gateway host wrapped in the local
    network\n    header, the local network interface strips off this header, and\n
    \   turns the datagram over to the internet module.  The internet module\n    determines
    from the internet address that the datagram is to be\n    forwarded to another
    host in a second network.  The internet module\n    determines a local net address
    for the destination host.  It calls\n    on the local network interface for that
    network to send the\n    datagram.\n    This local network interface creates a
    local network header and\n    attaches the datagram sending the result to the
    destination host.\n    At this destination host the datagram is stripped of the
    local net\n    header by the local network interface and handed to the internet\n
    \   module.\n    The internet module determines that the datagram is for an\n
    \   application program in this host.  It passes the data to the\n    application
    program in response to a system call, passing the source\n    address and other
    parameters as results of the call.\n   Application                                           Application\n
    \  Program                                                   Program\n         \\
    \                                                  /      \n       Internet Module
    \     Internet Module      Internet Module    \n             \\                 /
    \      \\                /           \n             LNI-1          LNI-1      LNI-2
    \        LNI-2          \n                \\           /             \\          /
    \             \n               Local Network 1           Local Network 2            \n
    \                           Transmission Path\n                                Figure
    2\n                                                       Internet Protocol\n
    \                                                               Overview\n"
  title: Overview
- contents:
  - "2.3.  Function Description\n  The function or purpose of Internet Protocol is
    to move datagrams\n  through an interconnected set of networks.  This is done
    by passing\n  the datagrams from one internet module to another until the\n  destination
    is reached.  The internet modules reside in hosts and\n  gateways in the internet
    system.  The datagrams are routed from one\n  internet module to another through
    individual networks based on the\n  interpretation of an internet address.  Thus,
    one important mechanism\n  of the internet protocol is the internet address.\n
    \ In the routing of messages from one internet module to another,\n  datagrams
    may need to traverse a network whose maximum packet size is\n  smaller than the
    size of the datagram.  To overcome this difficulty, a\n  fragmentation mechanism
    is provided in the internet protocol.\n  Addressing\n    A distinction is made
    between names, addresses, and routes [4].   A\n    name indicates what we seek.
    \ An address indicates where it is.  A\n    route indicates how to get there.
    \ The internet protocol deals\n    primarily with addresses.  It is the task of
    higher level (i.e.,\n    host-to-host or application) protocols to make the mapping
    from\n    names to addresses.   The internet module maps internet addresses to\n
    \   local net addresses.  It is the task of lower level (i.e., local net\n    or
    gateways) procedures to make the mapping from local net addresses\n    to routes.\n
    \   Addresses are fixed length of four octets (32 bits).  An address\n    begins
    with a network number, followed by local address (called the\n    \"rest\" field).
    \ There are three formats or classes of internet\n    addresses:  in class a,
    the high order bit is zero, the next 7 bits\n    are the network, and the last
    24 bits are the local address; in\n    class b, the high order two bits are one-zero,
    the next 14 bits are\n    the network and the last 16 bits are the local address;
    in class c,\n    the high order three bits are one-one-zero, the next 21 bits
    are the\n    network and the last 8 bits are the local address.\n    Care must
    be taken in mapping internet addresses to local net\n    addresses; a single physical
    host must be able to act as if it were\n    several distinct hosts to the extent
    of using several distinct\n    internet addresses.  Some hosts will also have
    several physical\n    interfaces (multi-homing).\n    That is, provision must
    be made for a host to have several physical\n    interfaces to the network with
    each having several logical internet\n    addresses.\n"
  title: 2.3.  Function Description
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Overview\n    Examples of address mappings may be found in \"Address Mappings\"
    [5].\n  Fragmentation\n    Fragmentation of an internet datagram is necessary
    when it\n    originates in a local net that allows a large packet size and must\n
    \   traverse a local net that limits packets to a smaller size to reach\n    its
    destination.\n    An internet datagram can be marked \"don't fragment.\"  Any
    internet\n    datagram so marked is not to be internet fragmented under any\n
    \   circumstances.  If internet datagram marked don't fragment cannot be\n    delivered
    to its destination without fragmenting it, it is to be\n    discarded instead.\n
    \   Fragmentation, transmission and reassembly across a local network\n    which
    is invisible to the internet protocol module is called\n    intranet fragmentation
    and may be used [6].\n    The internet fragmentation and reassembly procedure
    needs to be able\n    to break a datagram into an almost arbitrary number of pieces
    that\n    can be later reassembled.  The receiver of the fragments uses the\n
    \   identification field to ensure that fragments of different datagrams\n    are
    not mixed.  The fragment offset field tells the receiver the\n    position of
    a fragment in the original datagram.  The fragment\n    offset and length determine
    the portion of the original datagram\n    covered by this fragment.  The more-fragments
    flag indicates (by\n    being reset) the last fragment.  These fields provide
    sufficient\n    information to reassemble datagrams.\n    The identification field
    is used to distinguish the fragments of one\n    datagram from those of another.
    \ The originating protocol module of\n    an internet datagram sets the identification
    field to a value that\n    must be unique for that source-destination pair and
    protocol for the\n    time the datagram will be active in the internet system.
    \ The\n    originating protocol module of a complete datagram sets the\n    more-fragments
    flag to zero and the fragment offset to zero.\n    To fragment a long internet
    datagram, an internet protocol module\n    (for example, in a gateway), creates
    two new internet datagrams and\n    copies the contents of the internet header
    fields from the long\n    datagram into both new internet headers.  The data of
    the long\n    datagram is divided into two portions on a 8 octet (64 bit) boundary\n
    \   (the second portion might not be an integral multiple of 8 octets,\n    but
    the first must be).  Call the number of 8 octet blocks in the\n    first portion
    NFB (for Number of Fragment Blocks).  The first\n    portion of the data is placed
    in the first new internet datagram,\n    and the total length field is set to
    the length of the first\n                                                       Internet
    Protocol\n                                                                Overview\n
    \   datagram.  The more-fragments flag is set to one.  The second\n    portion
    of the data is placed in the second new internet datagram,\n    and the total
    length field is set to the length of the second\n    datagram.  The more-fragments
    flag carries the same value as the\n    long datagram.  The fragment offset field
    of the second new internet\n    datagram is set to the value of that field in
    the long datagram plus\n    NFB.\n    This procedure can be generalized for an
    n-way split, rather than\n    the two-way split described.\n    To assemble the
    fragments of an internet datagram, an internet\n    protocol module (for example
    at a destination host) combines\n    internet datagrams that all have the same
    value for the four fields:\n    identification, source, destination, and protocol.
    \ The combination\n    is done by placing the data portion of each fragment in
    the relative\n    position indicated by the fragment offset in that fragment's\n
    \   internet header.  The first fragment will have the fragment offset\n    zero,
    and the last fragment will have the more-fragments flag reset\n    to zero.\n"
  title: Overview
- contents:
  - "2.4.  Gateways\n  Gateways implement internet protocol to forward datagrams between\n
    \ networks.  Gateways also implement the Gateway to Gateway Protocol\n  (GGP)
    [7] to coordinate routing and other internet control\n  information.\n  In a gateway
    the higher level protocols need not be implemented and\n  the GGP functions are
    added to the IP module.\n                   +-------------------------------+
    \  \n                   | Internet Protocol & ICMP & GGP|   \n                   +-------------------------------+
    \  \n                           |                 |         \n                 +---------------+
    \  +---------------+ \n                 |   Local Net   |   |   Local Net   |
    \n                 +---------------+   +---------------+ \n                           Gateway
    Protocols\n                               Figure 3.\n"
  title: 2.4.  Gateways
- contents:
  - "Internet Protocol\n                                                       Internet
    Protocol\n                           3.  SPECIFICATION\n"
  title: Internet Protocol
- contents:
  - "3.1.  Internet Header Format\n  A summary of the contents of the internet header
    follows:\n    0                   1                   2                   3   \n
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |Version|  IHL  |Type of Service|          Total Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |         Identification        |Flags|      Fragment Offset    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |  Time to Live |    Protocol   |         Header Checksum       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                       Source Address                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                    Destination Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                   Example Internet Datagram Header\n                               Figure
    4.\n  Note that each tick mark represents one bit position.\n  Version:  4 bits\n
    \   The Version field indicates the format of the internet header.  This\n    document
    describes version 4.\n  IHL:  4 bits\n    Internet Header Length is the length
    of the internet header in 32\n    bit words, and thus points to the beginning
    of the data.  Note that\n    the minimum value for a correct header is 5.\n"
  title: 3.1.  Internet Header Format
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n  Type of Service:  8 bits\n    The Type of Service provides an
    indication of the abstract\n    parameters of the quality of service desired.
    \ These parameters are\n    to be used to guide the selection of the actual service
    parameters\n    when transmitting a datagram through a particular network.  Several\n
    \   networks offer service precedence, which somehow treats high\n    precedence
    traffic as more important than other traffic (generally\n    by accepting only
    traffic above a certain precedence at time of high\n    load).  The major choice
    is a three way tradeoff between low-delay,\n    high-reliability, and high-throughput.\n
    \     Bits 0-2:  Precedence.\n      Bit    3:  0 = Normal Delay,      1 = Low
    Delay.\n      Bits   4:  0 = Normal Throughput, 1 = High Throughput.\n      Bits
    \  5:  0 = Normal Relibility, 1 = High Relibility.\n      Bit  6-7:  Reserved
    for Future Use.\n         0     1     2     3     4     5     6     7\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n
    \     |                 |     |     |     |     |     |\n      |   PRECEDENCE
    \   |  D  |  T  |  R  |  0  |  0  |\n      |                 |     |     |     |
    \    |     |\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n        Precedence\n
    \         111 - Network Control\n          110 - Internetwork Control\n          101
    - CRITIC/ECP\n          100 - Flash Override\n          011 - Flash\n          010
    - Immediate\n          001 - Priority\n          000 - Routine\n    The use of
    the Delay, Throughput, and Reliability indications may\n    increase the cost
    (in some sense) of the service.  In many networks\n    better performance for
    one of these parameters is coupled with worse\n    performance on another.  Except
    for very unusual cases at most two\n    of these three indications should be set.\n
    \   The type of service is used to specify the treatment of the datagram\n    during
    its transmission through the internet system.  Example\n    mappings of the internet
    type of service to the actual service\n    provided on networks such as AUTODIN
    II, ARPANET, SATNET, and PRNET\n    is given in \"Service Mappings\" [8].\n                                                       Internet
    Protocol\n                                                           Specification\n
    \   The Network Control precedence designation is intended to be used\n    within
    a network only.  The actual use and control of that\n    designation is up to
    each network. The Internetwork Control\n    designation is intended for use by
    gateway control originators only.\n    If the actual use of these precedence designations
    is of concern to\n    a particular network, it is the responsibility of that network
    to\n    control the access to, and use of, those precedence designations.\n  Total
    Length:  16 bits\n    Total Length is the length of the datagram, measured in
    octets,\n    including internet header and data.  This field allows the length
    of\n    a datagram to be up to 65,535 octets.  Such long datagrams are\n    impractical
    for most hosts and networks.  All hosts must be prepared\n    to accept datagrams
    of up to 576 octets (whether they arrive whole\n    or in fragments).  It is recommended
    that hosts only send datagrams\n    larger than 576 octets if they have assurance
    that the destination\n    is prepared to accept the larger datagrams.\n    The
    number 576 is selected to allow a reasonable sized data block to\n    be transmitted
    in addition to the required header information.  For\n    example, this size allows
    a data block of 512 octets plus 64 header\n    octets to fit in a datagram.  The
    maximal internet header is 60\n    octets, and a typical internet header is 20
    octets, allowing a\n    margin for headers of higher level protocols.\n  Identification:
    \ 16 bits\n    An identifying value assigned by the sender to aid in assembling
    the\n    fragments of a datagram.\n  Flags:  3 bits\n    Various Control Flags.\n
    \     Bit 0: reserved, must be zero\n      Bit 1: (DF) 0 = May Fragment,  1 =
    Don't Fragment.\n      Bit 2: (MF) 0 = Last Fragment, 1 = More Fragments.\n          0
    \  1   2\n        +---+---+---+\n        |   | D | M |\n        | 0 | F | F |\n
    \       +---+---+---+\n  Fragment Offset:  13 bits\n    This field indicates where
    in the datagram this fragment belongs.\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n    The fragment offset is measured in units of 8 octets (64 bits).
    \ The\n    first fragment has offset zero.\n  Time to Live:  8 bits\n    This
    field indicates the maximum time the datagram is allowed to\n    remain in the
    internet system.  If this field contains the value\n    zero, then the datagram
    must be destroyed.  This field is modified\n    in internet header processing.
    \ The time is measured in units of\n    seconds, but since every module that processes
    a datagram must\n    decrease the TTL by at least one even if it process the datagram
    in\n    less than a second, the TTL must be thought of only as an upper\n    bound
    on the time a datagram may exist.  The intention is to cause\n    undeliverable
    datagrams to be discarded, and to bound the maximum\n    datagram lifetime.\n
    \ Protocol:  8 bits\n    This field indicates the next level protocol used in
    the data\n    portion of the internet datagram.  The values for various protocols\n
    \   are specified in \"Assigned Numbers\" [9].\n  Header Checksum:  16 bits\n
    \   A checksum on the header only.  Since some header fields change\n    (e.g.,
    time to live), this is recomputed and verified at each point\n    that the internet
    header is processed.\n    The checksum algorithm is:\n      The checksum field
    is the 16 bit one's complement of the one's\n      complement sum of all 16 bit
    words in the header.  For purposes of\n      computing the checksum, the value
    of the checksum field is zero.\n    This is a simple to compute checksum and experimental
    evidence\n    indicates it is adequate, but it is provisional and may be replaced\n
    \   by a CRC procedure, depending on further experience.\n  Source Address:  32
    bits\n    The source address.  See section 3.2.\n  Destination Address:  32 bits\n
    \   The destination address.  See section 3.2.\n                                                       Internet
    Protocol\n                                                           Specification\n
    \ Options:  variable\n    The options may appear or not in datagrams.  They must
    be\n    implemented by all IP modules (host and gateways).  What is optional\n
    \   is their transmission in any particular datagram, not their\n    implementation.\n
    \   In some environments the security option may be required in all\n    datagrams.\n
    \   The option field is variable in length.  There may be zero or more\n    options.
    \ There are two cases for the format of an option:\n      Case 1:  A single octet
    of option-type.\n      Case 2:  An option-type octet, an option-length octet,
    and the\n               actual option-data octets.\n    The option-length octet
    counts the option-type octet and the\n    option-length octet as well as the option-data
    octets.\n    The option-type octet is viewed as having 3 fields:\n      1 bit
    \  copied flag,\n      2 bits  option class,\n      5 bits  option number.\n    The
    copied flag indicates that this option is copied into all\n    fragments on fragmentation.\n
    \     0 = not copied\n      1 = copied\n    The option classes are:\n      0 =
    control\n      1 = reserved for future use\n      2 = debugging and measurement\n
    \     3 = reserved for future use\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n    The following internet options are defined:\n      CLASS NUMBER
    LENGTH DESCRIPTION\n      ----- ------ ------ -----------\n        0     0      -
    \   End of Option list.  This option occupies only\n                          1
    octet; it has no length octet.\n        0     1      -    No Operation.  This
    option occupies only 1\n                          octet; it has no length octet.\n
    \       0     2     11    Security.  Used to carry Security,\n                          Compartmentation,
    User Group (TCC), and\n                          Handling Restriction Codes compatible
    with DOD\n                          requirements.\n        0     3     var.  Loose
    Source Routing.  Used to route the\n                          internet datagram
    based on information\n                          supplied by the source.\n        0
    \    9     var.  Strict Source Routing.  Used to route the\n                          internet
    datagram based on information\n                          supplied by the source.\n
    \       0     7     var.  Record Route.  Used to trace the route an\n                          internet
    datagram takes.\n        0     8      4    Stream ID.  Used to carry the stream\n
    \                         identifier.\n        2     4     var.  Internet Timestamp.\n
    \   Specific Option Definitions\n      End of Option List\n        +--------+\n
    \       |00000000|\n        +--------+\n          Type=0\n        This option
    indicates the end of the option list.  This might\n        not coincide with the
    end of the internet header according to\n        the internet header length.  This
    is used at the end of all\n        options, not the end of each option, and need
    only be used if\n        the end of the options would not otherwise coincide with
    the end\n        of the internet header.\n        May be copied, introduced, or
    deleted on fragmentation, or for\n        any other reason.\n                                                       Internet
    Protocol\n                                                           Specification\n
    \     No Operation\n        +--------+\n        |00000001|\n        +--------+\n
    \         Type=1\n        This option may be used between options, for example,
    to align\n        the beginning of a subsequent option on a 32 bit boundary.\n
    \       May be copied, introduced, or deleted on fragmentation, or for\n        any
    other reason.\n      Security\n        This option provides a way for hosts to
    send security,\n        compartmentation, handling restrictions, and TCC (closed
    user\n        group) parameters.  The format for this option is as follows:\n
    \         +--------+--------+---//---+---//---+---//---+---//---+\n          |10000010|00001011|SSS
    \ SSS|CCC  CCC|HHH  HHH|  TCC   |\n          +--------+--------+---//---+---//---+---//---+---//---+\n
    \          Type=130 Length=11\n        Security (S field):  16 bits\n          Specifies
    one of 16 levels of security (eight of which are\n          reserved for future
    use).\n            00000000 00000000 - Unclassified\n            11110001 00110101
    - Confidential\n            01111000 10011010 - EFTO\n            10111100 01001101
    - MMMM\n            01011110 00100110 - PROG\n            10101111 00010011 -
    Restricted\n            11010111 10001000 - Secret\n            01101011 11000101
    - Top Secret\n            00110101 11100010 - (Reserved for future use)\n            10011010
    11110001 - (Reserved for future use)\n            01001101 01111000 - (Reserved
    for future use)\n            00100100 10111101 - (Reserved for future use)\n            00010011
    01011110 - (Reserved for future use)\n            10001001 10101111 - (Reserved
    for future use)\n            11000100 11010110 - (Reserved for future use)\n            11100010
    01101011 - (Reserved for future use)\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n        Compartments (C field):  16 bits\n          An all zero
    value is used when the information transmitted is\n          not compartmented.
    \ Other values for the compartments field\n          may be obtained from the
    Defense Intelligence Agency.\n        Handling Restrictions (H field):  16 bits\n
    \         The values for the control and release markings are\n          alphanumeric
    digraphs and are defined in the Defense\n          Intelligence Agency Manual
    DIAM 65-19, \"Standard Security\n          Markings\".\n        Transmission Control
    Code (TCC field):  24 bits\n          Provides a means to segregate traffic and
    define controlled\n          communities of interest among subscribers. The TCC
    values are\n          trigraphs, and are available from HQ DCA Code 530.\n        Must
    be copied on fragmentation.  This option appears at most\n        once in a datagram.\n
    \     Loose Source and Record Route\n        +--------+--------+--------+---------//--------+\n
    \       |10000011| length | pointer|     route data    |\n        +--------+--------+--------+---------//--------+\n
    \        Type=131\n        The loose source and record route (LSRR) option provides
    a means\n        for the source of an internet datagram to supply routing\n        information
    to be used by the gateways in forwarding the\n        datagram to the destination,
    and to record the route\n        information.\n        The option begins with
    the option type code.  The second octet\n        is the option length which includes
    the option type code and the\n        length octet, the pointer octet, and length-3
    octets of route\n        data.  The third octet is the pointer into the route
    data\n        indicating the octet which begins the next source address to be\n
    \       processed.  The pointer is relative to this option, and the\n        smallest
    legal value for the pointer is 4.\n        A route data is composed of a series
    of internet addresses.\n        Each internet address is 32 bits or 4 octets.
    \ If the pointer is\n        greater than the length, the source route is empty
    (and the\n        recorded route full) and the routing is to be based on the\n
    \       destination address field.\n                                                       Internet
    Protocol\n                                                           Specification\n
    \       If the address in destination address field has been reached and\n        the
    pointer is not greater than the length, the next address in\n        the source
    route replaces the address in the destination address\n        field, and the
    recorded route address replaces the source\n        address just used, and pointer
    is increased by four.\n        The recorded route address is the internet module's
    own internet\n        address as known in the environment into which this datagram
    is\n        being forwarded.\n        This procedure of replacing the source route
    with the recorded\n        route (though it is in the reverse of the order it
    must be in to\n        be used as a source route) means the option (and the IP
    header\n        as a whole) remains a constant length as the datagram progresses\n
    \       through the internet.\n        This option is a loose source route because
    the gateway or host\n        IP is allowed to use any route of any number of other\n
    \       intermediate gateways to reach the next address in the route.\n        Must
    be copied on fragmentation.  Appears at most once in a\n        datagram.\n      Strict
    Source and Record Route\n        +--------+--------+--------+---------//--------+\n
    \       |10001001| length | pointer|     route data    |\n        +--------+--------+--------+---------//--------+\n
    \        Type=137\n        The strict source and record route (SSRR) option provides
    a\n        means for the source of an internet datagram to supply routing\n        information
    to be used by the gateways in forwarding the\n        datagram to the destination,
    and to record the route\n        information.\n        The option begins with
    the option type code.  The second octet\n        is the option length which includes
    the option type code and the\n        length octet, the pointer octet, and length-3
    octets of route\n        data.  The third octet is the pointer into the route
    data\n        indicating the octet which begins the next source address to be\n
    \       processed.  The pointer is relative to this option, and the\n        smallest
    legal value for the pointer is 4.\n        A route data is composed of a series
    of internet addresses.\n        Each internet address is 32 bits or 4 octets.
    \ If the pointer is\n        greater than the length, the source route is empty
    (and the\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n        recorded route full) and the routing is to be based on
    the\n        destination address field.\n        If the address in destination
    address field has been reached and\n        the pointer is not greater than the
    length, the next address in\n        the source route replaces the address in
    the destination address\n        field, and the recorded route address replaces
    the source\n        address just used, and pointer is increased by four.\n        The
    recorded route address is the internet module's own internet\n        address
    as known in the environment into which this datagram is\n        being forwarded.\n
    \       This procedure of replacing the source route with the recorded\n        route
    (though it is in the reverse of the order it must be in to\n        be used as
    a source route) means the option (and the IP header\n        as a whole) remains
    a constant length as the datagram progresses\n        through the internet.\n
    \       This option is a strict source route because the gateway or host\n        IP
    must send the datagram directly to the next address in the\n        source route
    through only the directly connected network\n        indicated in the next address
    to reach the next gateway or host\n        specified in the route.\n        Must
    be copied on fragmentation.  Appears at most once in a\n        datagram.\n      Record
    Route\n        +--------+--------+--------+---------//--------+\n        |00000111|
    length | pointer|     route data    |\n        +--------+--------+--------+---------//--------+\n
    \         Type=7\n        The record route option provides a means to record the
    route of\n        an internet datagram.\n        The option begins with the option
    type code.  The second octet\n        is the option length which includes the
    option type code and the\n        length octet, the pointer octet, and length-3
    octets of route\n        data.  The third octet is the pointer into the route
    data\n        indicating the octet which begins the next area to store a route\n
    \       address.  The pointer is relative to this option, and the\n        smallest
    legal value for the pointer is 4.\n        A recorded route is composed of a series
    of internet addresses.\n        Each internet address is 32 bits or 4 octets.
    \ If the pointer is\n                                                       Internet
    Protocol\n                                                           Specification\n
    \       greater than the length, the recorded route data area is full.\n        The
    originating host must compose this option with a large\n        enough route data
    area to hold all the address expected.  The\n        size of the option does not
    change due to adding addresses.  The\n        intitial contents of the route data
    area must be zero.\n        When an internet module routes a datagram it checks
    to see if\n        the record route option is present.  If it is, it inserts its\n
    \       own internet address as known in the environment into which this\n        datagram
    is being forwarded into the recorded route begining at\n        the octet indicated
    by the pointer, and increments the pointer\n        by four.\n        If the route
    data area is already full (the pointer exceeds the\n        length) the datagram
    is forwarded without inserting the address\n        into the recorded route.  If
    there is some room but not enough\n        room for a full address to be inserted,
    the original datagram is\n        considered to be in error and is discarded.
    \ In either case an\n        ICMP parameter problem message may be sent to the
    source\n        host [3].\n        Not copied on fragmentation, goes in first
    fragment only.\n        Appears at most once in a datagram.\n      Stream Identifier\n
    \       +--------+--------+--------+--------+\n        |10001000|00000010|    Stream
    ID    |\n        +--------+--------+--------+--------+\n         Type=136 Length=4\n
    \       This option provides a way for the 16-bit SATNET stream\n        identifier
    to be carried through networks that do not support\n        the stream concept.\n
    \       Must be copied on fragmentation.  Appears at most once in a\n        datagram.\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n      Internet Timestamp\n        +--------+--------+--------+--------+\n
    \       |01000100| length | pointer|oflw|flg|\n        +--------+--------+--------+--------+\n
    \       |         internet address          |\n        +--------+--------+--------+--------+\n
    \       |             timestamp             |\n        +--------+--------+--------+--------+\n
    \       |                 .                 |\n                          .\n                          .\n
    \       Type = 68\n        The Option Length is the number of octets in the option
    counting\n        the type, length, pointer, and overflow/flag octets (maximum\n
    \       length 40).\n        The Pointer is the number of octets from the beginning
    of this\n        option to the end of timestamps plus one (i.e., it points to
    the\n        octet beginning the space for next timestamp).  The smallest\n        legal
    value is 5.  The timestamp area is full when the pointer\n        is greater than
    the length.\n        The Overflow (oflw) [4 bits] is the number of IP modules
    that\n        cannot register timestamps due to lack of space.\n        The Flag
    (flg) [4 bits] values are\n          0 -- time stamps only, stored in consecutive
    32-bit words,\n          1 -- each timestamp is preceded with internet address
    of the\n               registering entity,\n          3 -- the internet address
    fields are prespecified.  An IP\n               module only registers its timestamp
    if it matches its own\n               address with the next specified internet
    address.\n        The Timestamp is a right-justified, 32-bit timestamp in\n        milliseconds
    since midnight UT.  If the time is not available in\n        milliseconds or cannot
    be provided with respect to midnight UT\n        then any time may be inserted
    as a timestamp provided the high\n        order bit of the timestamp field is
    set to one to indicate the\n        use of a non-standard value.\n        The
    originating host must compose this option with a large\n        enough timestamp
    data area to hold all the timestamp information\n        expected.  The size of
    the option does not change due to adding\n                                                       Internet
    Protocol\n                                                           Specification\n
    \       timestamps.  The intitial contents of the timestamp data area\n        must
    be zero or internet address/zero pairs.\n        If the timestamp data area is
    already full (the pointer exceeds\n        the length) the datagram is forwarded
    without inserting the\n        timestamp, but the overflow count is incremented
    by one.\n        If there is some room but not enough room for a full timestamp\n
    \       to be inserted, or the overflow count itself overflows, the\n        original
    datagram is considered to be in error and is discarded.\n        In either case
    an ICMP parameter problem message may be sent to\n        the source host [3].\n
    \       The timestamp option is not copied upon fragmentation.  It is\n        carried
    in the first fragment.  Appears at most once in a\n        datagram.\n  Padding:
    \ variable\n    The internet header padding is used to ensure that the internet\n
    \   header ends on a 32 bit boundary.  The padding is zero.\n"
  title: Specification
- contents:
  - "3.2.  Discussion\n  The implementation of a protocol must be robust.  Each implementation\n
    \ must expect to interoperate with others created by different\n  individuals.
    \ While the goal of this specification is to be explicit\n  about the protocol
    there is the possibility of differing\n  interpretations.  In general, an implementation
    must be conservative\n  in its sending behavior, and liberal in its receiving
    behavior.  That\n  is, it must be careful to send well-formed datagrams, but must
    accept\n  any datagram that it can interpret (e.g., not object to technical\n
    \ errors where the meaning is still clear).\n  The basic internet service is datagram
    oriented and provides for the\n  fragmentation of datagrams at gateways, with
    reassembly taking place\n  at the destination internet protocol module in the
    destination host.\n  Of course, fragmentation and reassembly of datagrams within
    a network\n  or by private agreement between the gateways of a network is also\n
    \ allowed since this is transparent to the internet protocols and the\n  higher-level
    protocols.  This transparent type of fragmentation and\n  reassembly is termed
    \"network-dependent\" (or intranet) fragmentation\n  and is not discussed further
    here.\n  Internet addresses distinguish sources and destinations to the host\n
    \ level and provide a protocol field as well.  It is assumed that each\n  protocol
    will provide for whatever multiplexing is necessary within a\n  host.\n"
  title: 3.2.  Discussion
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n  Addressing\n    To provide for flexibility in assigning address
    to networks and\n    allow for the  large number of small to intermediate sized
    networks\n    the interpretation of the address field is coded to specify a small\n
    \   number of networks with a large number of host, a moderate number of\n    networks
    with a moderate number of hosts, and a large number of\n    networks with a small
    number of hosts.  In addition there is an\n    escape code for extended addressing
    mode.\n    Address Formats:\n      High Order Bits   Format                           Class\n
    \     ---------------   -------------------------------  -----\n            0
    \           7 bits of net, 24 bits of host    a\n            10          14 bits
    of net, 16 bits of host    b\n            110         21 bits of net,  8 bits
    of host    c\n            111         escape to extended addressing mode\n      A
    value of zero in the network field means this network.  This is\n      only used
    in certain ICMP messages.  The extended addressing mode\n      is undefined.  Both
    of these features are reserved for future use.\n    The actual values assigned
    for network addresses is given in\n    \"Assigned Numbers\" [9].\n    The local
    address, assigned by the local network, must allow for a\n    single physical
    host to act as several distinct internet hosts.\n    That is, there must be a
    mapping between internet host addresses and\n    network/host interfaces that
    allows several internet addresses to\n    correspond to one interface.  It must
    also be allowed for a host to\n    have several physical interfaces and to treat
    the datagrams from\n    several of them as if they were all addressed to a single
    host.\n    Address mappings between internet addresses and addresses for\n    ARPANET,
    SATNET, PRNET, and other networks are described in \"Address\n    Mappings\" [5].\n
    \ Fragmentation and Reassembly.\n    The internet identification field (ID) is
    used together with the\n    source and destination address, and the protocol fields,
    to identify\n    datagram fragments for reassembly.\n    The More Fragments flag
    bit (MF) is set if the datagram is not the\n    last fragment.  The Fragment Offset
    field identifies the fragment\n    location, relative to the beginning of the
    original unfragmented\n    datagram.  Fragments are counted in units of 8 octets.
    \ The\n                                                       Internet Protocol\n
    \                                                          Specification\n    fragmentation
    strategy is designed so than an unfragmented datagram\n    has all zero fragmentation
    information (MF = 0, fragment offset =\n    0).  If an internet datagram is fragmented,
    its data portion must be\n    broken on 8 octet boundaries.\n    This format allows
    2**13 = 8192 fragments of 8 octets each for a\n    total of 65,536 octets.  Note
    that this is consistent with the the\n    datagram total length field (of course,
    the header is counted in the\n    total length and not in the fragments).\n    When
    fragmentation occurs, some options are copied, but others\n    remain with the
    first fragment only.\n    Every internet module must be able to forward a datagram
    of 68\n    octets without further fragmentation.  This is because an internet\n
    \   header may be up to 60 octets, and the minimum fragment is 8 octets.\n    Every
    internet destination must be able to receive a datagram of 576\n    octets either
    in one piece or in fragments to be reassembled.\n    The fields which may be affected
    by fragmentation include:\n      (1) options field\n      (2) more fragments flag\n
    \     (3) fragment offset\n      (4) internet header length field\n      (5) total
    length field\n      (6) header checksum\n    If the Don't Fragment flag (DF) bit
    is set, then internet\n    fragmentation of this datagram is NOT permitted, although
    it may be\n    discarded.  This can be used to prohibit fragmentation in cases\n
    \   where the receiving host does not have sufficient resources to\n    reassemble
    internet fragments.\n    One example of use of the Don't Fragment feature is to
    down line\n    load a small host.  A small host could have a boot strap program\n
    \   that accepts a datagram stores it in memory and then executes it.\n    The
    fragmentation and reassembly procedures are most easily\n    described by examples.
    \ The following procedures are example\n    implementations.\n    General notation
    in the following pseudo programs: \"=<\" means \"less\n    than or equal\", \"#\"
    means \"not equal\", \"=\" means \"equal\", \"<-\" means\n    \"is set to\".  Also,
    \"x to y\" includes x and excludes y; for example,\n    \"4 to 7\" would include
    4, 5, and 6 (but not 7).\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n    An Example Fragmentation Procedure\n      The maximum sized
    datagram that can be transmitted through the\n      next network is called the
    maximum transmission unit (MTU).\n      If the total length is less than or equal
    the maximum transmission\n      unit then submit this datagram to the next step
    in datagram\n      processing; otherwise cut the datagram into two fragments,
    the\n      first fragment being the maximum size, and the second fragment\n      being
    the rest of the datagram.  The first fragment is submitted\n      to the next
    step in datagram processing, while the second fragment\n      is submitted to
    this procedure in case it is still too large.\n      Notation:\n        FO    -
    \ Fragment Offset\n        IHL   -  Internet Header Length\n        DF    -  Don't
    Fragment flag\n        MF    -  More Fragments flag\n        TL    -  Total Length\n
    \       OFO   -  Old Fragment Offset\n        OIHL  -  Old Internet Header Length\n
    \       OMF   -  Old More Fragments flag\n        OTL   -  Old Total Length\n
    \       NFB   -  Number of Fragment Blocks\n        MTU   -  Maximum Transmission
    Unit\n      Procedure:\n        IF TL =< MTU THEN Submit this datagram to the
    next step\n             in datagram processing ELSE IF DF = 1 THEN discard the\n
    \       datagram ELSE\n        To produce the first fragment:\n        (1)  Copy
    the original internet header;\n        (2)  OIHL <- IHL; OTL <- TL; OFO <- FO;
    OMF <- MF;\n        (3)  NFB <- (MTU-IHL*4)/8;\n        (4)  Attach the first
    NFB*8 data octets;\n        (5)  Correct the header:\n             MF <- 1;  TL
    <- (IHL*4)+(NFB*8);\n             Recompute Checksum;\n        (6)  Submit this
    fragment to the next step in\n             datagram processing;\n        To produce
    the second fragment:\n        (7)  Selectively copy the internet header (some
    options\n             are not copied, see option definitions);\n        (8)  Append
    the remaining data;\n        (9)  Correct the header:\n             IHL <- (((OIHL*4)-(length
    of options not copied))+3)/4;\n                                                       Internet
    Protocol\n                                                           Specification\n
    \            TL <- OTL - NFB*8 - (OIHL-IHL)*4);\n             FO <- OFO + NFB;
    \ MF <- OMF;  Recompute Checksum;\n        (10) Submit this fragment to the fragmentation
    test; DONE.\n      In the above procedure each fragment (except the last) was
    made\n      the maximum allowable size.  An alternative might produce less\n      than
    the maximum size datagrams.  For example, one could implement\n      a fragmentation
    procedure that repeatly divided large datagrams in\n      half until the resulting
    fragments were less than the maximum\n      transmission unit size.\n    An Example
    Reassembly Procedure\n      For each datagram the buffer identifier is computed
    as the\n      concatenation of the source, destination, protocol, and\n      identification
    fields.  If this is a whole datagram (that is both\n      the fragment offset
    and the more fragments  fields are zero), then\n      any reassembly resources
    associated with this buffer identifier\n      are released and the datagram is
    forwarded to the next step in\n      datagram processing.\n      If no other fragment
    with this buffer identifier is on hand then\n      reassembly resources are allocated.
    \ The reassembly resources\n      consist of a data buffer, a header buffer, a
    fragment block bit\n      table, a total data length field, and a timer.  The
    data from the\n      fragment is placed in the data buffer according to its fragment\n
    \     offset and length, and bits are set in the fragment block bit\n      table
    corresponding to the fragment blocks received.\n      If this is the first fragment
    (that is the fragment offset is\n      zero)  this header is placed in the header
    buffer.  If this is the\n      last fragment ( that is the more fragments field
    is zero) the\n      total data length is computed.  If this fragment completes
    the\n      datagram (tested by checking the bits set in the fragment block\n      table),
    then the datagram is sent to the next step in datagram\n      processing; otherwise
    the timer is set to the maximum of the\n      current timer value and the value
    of the time to live field from\n      this fragment; and the reassembly routine
    gives up control.\n      If the timer runs out, the all reassembly resources for
    this\n      buffer identifier are released.  The initial setting of the timer\n
    \     is a lower bound on the reassembly waiting time.  This is because\n      the
    waiting time will be increased if the Time to Live in the\n      arriving fragment
    is greater than the current timer value but will\n      not be decreased if it
    is less.  The maximum this timer value\n      could reach is the maximum time
    to live (approximately 4.25\n      minutes).  The current recommendation for the
    initial timer\n      setting is 15 seconds.  This may be changed as experience
    with\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n      this protocol accumulates.  Note that the choice of this
    parameter\n      value is related to the buffer capacity available and the data\n
    \     rate of the transmission medium; that is, data rate times timer\n      value
    equals buffer size (e.g., 10Kb/s X 15s = 150Kb).\n      Notation:\n        FO
    \   -  Fragment Offset\n        IHL   -  Internet Header Length\n        MF    -
    \ More Fragments flag\n        TTL   -  Time To Live\n        NFB   -  Number
    of Fragment Blocks\n        TL    -  Total Length\n        TDL   -  Total Data
    Length\n        BUFID -  Buffer Identifier\n        RCVBT -  Fragment Received
    Bit Table\n        TLB   -  Timer Lower Bound\n      Procedure:\n        (1)  BUFID
    <- source|destination|protocol|identification;\n        (2)  IF FO = 0 AND MF
    = 0\n        (3)     THEN IF buffer with BUFID is allocated\n        (4)             THEN
    flush all reassembly for this BUFID;\n        (5)          Submit datagram to
    next step; DONE.\n        (6)     ELSE IF no buffer with BUFID is allocated\n
    \       (7)             THEN allocate reassembly resources\n                             with
    BUFID;\n                             TIMER <- TLB; TDL <- 0;\n        (8)          put
    data from fragment into data buffer with\n                     BUFID from octet
    FO*8 to\n                                         octet (TL-(IHL*4))+FO*8;\n        (9)
    \         set RCVBT bits from FO\n                                        to FO+((TL-(IHL*4)+7)/8);\n
    \       (10)         IF MF = 0 THEN TDL <- TL-(IHL*4)+(FO*8)\n        (11)         IF
    FO = 0 THEN put header in header buffer\n        (12)         IF TDL # 0\n        (13)
    \         AND all RCVBT bits from 0\n                                             to
    (TDL+7)/8 are set\n        (14)            THEN TL <- TDL+(IHL*4)\n        (15)
    \                Submit datagram to next step;\n        (16)                 free
    all reassembly resources\n                             for this BUFID; DONE.\n
    \       (17)         TIMER <- MAX(TIMER,TTL);\n        (18)         give up until
    next fragment or timer expires;\n        (19) timer expires: flush all reassembly
    with this BUFID; DONE.\n      In the case that two or more fragments contain the
    same data\n                                                       Internet Protocol\n
    \                                                          Specification\n      either
    identically or through a partial overlap, this procedure\n      will use the more
    recently arrived copy in the data buffer and\n      datagram delivered.\n  Identification\n
    \   The choice of the Identifier for a datagram is based on the need to\n    provide
    a way to uniquely identify the fragments of a particular\n    datagram.  The protocol
    module assembling fragments judges fragments\n    to belong to the same datagram
    if they have the same source,\n    destination, protocol, and Identifier.  Thus,
    the sender must choose\n    the Identifier to be unique for this source, destination
    pair and\n    protocol for the time the datagram (or any fragment of it) could
    be\n    alive in the internet.\n    It seems then that a sending protocol module
    needs to keep a table\n    of Identifiers, one entry for each destination it has
    communicated\n    with in the last maximum packet lifetime for the internet.\n
    \   However, since the Identifier field allows 65,536 different values,\n    some
    host may be able to simply use unique identifiers independent\n    of destination.\n
    \   It is appropriate for some higher level protocols to choose the\n    identifier.
    For example, TCP protocol modules may retransmit an\n    identical TCP segment,
    and the probability for correct reception\n    would be enhanced if the retransmission
    carried the same identifier\n    as the original transmission since fragments
    of either datagram\n    could be used to construct a correct TCP segment.\n  Type
    of Service\n    The type of service (TOS) is for internet service quality selection.\n
    \   The type of service is specified along the abstract parameters\n    precedence,
    delay, throughput, and reliability.  These abstract\n    parameters are to be
    mapped into the actual service parameters of\n    the particular networks the
    datagram traverses.\n    Precedence.  An independent measure of the importance
    of this\n    datagram.\n    Delay.  Prompt delivery is important for datagrams
    with this\n    indication.\n    Throughput.  High data rate is important for datagrams
    with this\n    indication.\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n    Reliability.  A higher level of effort to ensure delivery
    is\n    important for datagrams with this indication.\n    For example, the ARPANET
    has a priority bit, and a choice between\n    \"standard\" messages (type 0) and
    \"uncontrolled\" messages (type 3),\n    (the choice between single packet and
    multipacket messages can also\n    be considered a service parameter). The uncontrolled
    messages tend\n    to be less reliably delivered and suffer less delay.  Suppose
    an\n    internet datagram is to be sent through the ARPANET.  Let the\n    internet
    type of service be given as:\n      Precedence:    5\n      Delay:         0\n
    \     Throughput:    1\n      Reliability:   1\n    In this example, the mapping
    of these parameters to those available\n    for the ARPANET would be  to set the
    ARPANET priority bit on since\n    the Internet precedence is in the upper half
    of its range, to select\n    standard messages since the throughput and reliability
    requirements\n    are indicated and delay is not.  More details are given on service\n
    \   mappings in \"Service Mappings\" [8].\n  Time to Live\n    The time to live
    is set by the sender to the maximum time the\n    datagram is allowed to be in
    the internet system.  If the datagram\n    is in the internet system longer than
    the time to live, then the\n    datagram must be destroyed.\n    This field must
    be decreased at each point that the internet header\n    is processed to reflect
    the time spent processing the datagram.\n    Even if no local information is available
    on the time actually\n    spent, the field must be decremented by 1.  The time
    is measured in\n    units of seconds (i.e. the value 1 means one second).  Thus,
    the\n    maximum time to live is 255 seconds or 4.25 minutes.  Since every\n    module
    that processes a datagram must decrease the TTL by at least\n    one even if it
    process the datagram in less than a second, the TTL\n    must be thought of only
    as an upper bound on the time a datagram may\n    exist.  The intention is to
    cause undeliverable datagrams to be\n    discarded, and to bound the maximum datagram
    lifetime.\n    Some higher level reliable connection protocols are based on\n
    \   assumptions that old duplicate datagrams will not arrive after a\n    certain
    time elapses.  The TTL is a way for such protocols to have\n    an assurance that
    their assumption is met.\n                                                       Internet
    Protocol\n                                                           Specification\n
    \ Options\n    The options are optional in each datagram, but required in\n    implementations.
    \ That is, the presence or absence of an option is\n    the choice of the sender,
    but each internet module must be able to\n    parse every option.  There can be
    several options present in the\n    option field.\n    The options might not end
    on a 32-bit boundary.  The internet header\n    must be filled out with octets
    of zeros.  The first of these would\n    be interpreted as the end-of-options
    option, and the remainder as\n    internet header padding.\n    Every internet
    module must be able to act on every option.  The\n    Security Option is required
    if classified, restricted, or\n    compartmented traffic is to be passed.\n  Checksum\n
    \   The internet header checksum is recomputed if the internet header is\n    changed.
    \ For example, a reduction of the time to live, additions or\n    changes to internet
    options, or due to fragmentation.  This checksum\n    at the internet level is
    intended to protect the internet header\n    fields from transmission errors.\n
    \   There are some applications where a few data bit errors are\n    acceptable
    while retransmission delays are not.  If the internet\n    protocol enforced data
    correctness such applications could not be\n    supported.\n  Errors\n    Internet
    protocol errors may be reported via the ICMP messages [3].\n"
  title: Specification
- contents:
  - "3.3.  Interfaces\n  The functional description of user interfaces to the IP is,
    at best,\n  fictional, since every operating system will have different\n  facilities.
    \ Consequently, we must warn readers that different IP\n  implementations may
    have different user interfaces.  However, all IPs\n  must provide a certain minimum
    \ set of services to guarantee that all\n  IP implementations can support the
    same protocol hierarchy.  This\n  section specifies the functional interfaces
    required of all IP\n  implementations.\n  Internet protocol interfaces on one
    side to the local network and on\n  the other side to either a higher level protocol
    or an application\n  program.  In the following, the higher level protocol or
    application\n"
  title: 3.3.  Interfaces
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Specification\n  program (or even a gateway program) will be called the \"user\"
    since it\n  is using the internet module.  Since internet protocol is a datagram\n
    \ protocol, there is minimal memory or state maintained between datagram\n  transmissions,
    and each call on the internet protocol module by the\n  user supplies all information
    necessary for the IP to perform the\n  service requested.\n  An Example Upper
    Level Interface\n  The following two example calls satisfy the requirements for
    the user\n  to internet protocol module communication (\"=>\" means returns):\n
    \ SEND (src, dst, prot, TOS, TTL, BufPTR, len, Id, DF, opt => result)\n    where:\n
    \     src = source address\n      dst = destination address\n      prot = protocol\n
    \     TOS = type of service\n      TTL = time to live\n      BufPTR = buffer pointer\n
    \     len = length of buffer\n      Id  = Identifier\n      DF = Don't Fragment\n
    \     opt = option data\n      result = response\n        OK = datagram sent ok\n
    \       Error = error in arguments or local network error\n    Note that the precedence
    is included in the TOS and the\n    security/compartment is passed as an option.\n
    \ RECV (BufPTR, prot, => result, src, dst, TOS, len, opt)\n    where:\n      BufPTR
    = buffer pointer\n      prot = protocol\n      result = response\n        OK =
    datagram received ok\n        Error = error in arguments\n      len = length of
    buffer\n      src = source address\n      dst = destination address\n      TOS
    = type of service\n      opt = option data\n                                                       Internet
    Protocol\n                                                           Specification\n
    \ When the user sends a datagram, it executes the SEND call supplying\n  all the
    arguments.  The internet protocol module, on receiving this\n  call, checks the
    arguments and prepares and sends the message.  If the\n  arguments are good and
    the datagram is accepted by the local network,\n  the call returns successfully.
    \ If either the arguments are bad, or\n  the datagram is not accepted by the local
    network, the call returns\n  unsuccessfully.  On unsuccessful returns, a reasonable
    report must be\n  made as to the cause of the problem, but the details of such
    reports\n  are up to individual implementations.\n  When a datagram arrives at
    the internet protocol module from the local\n  network, either there is a pending
    RECV call from the user addressed\n  or there is not.  In the first case, the
    pending call is satisfied by\n  passing the information from the datagram to the
    user.  In the second\n  case, the user addressed is notified of a pending datagram.
    \ If the\n  user addressed does not exist, an ICMP error message is returned to\n
    \ the sender, and the data is discarded.\n  The notification of a user may be
    via a pseudo interrupt or similar\n  mechanism, as appropriate in the particular
    operating system\n  environment of the implementation.\n  A user's RECV call may
    then either be immediately satisfied by a\n  pending datagram, or the call may
    be pending until a datagram arrives.\n  The source address is included in the
    send call in case the sending\n  host has several addresses (multiple physical
    connections or logical\n  addresses).  The internet module must check to see that
    the source\n  address is one of the legal address for this host.\n  An implementation
    may also allow or require a call to the internet\n  module to indicate interest
    in or reserve exclusive use of a class of\n  datagrams (e.g., all those with a
    certain value in the protocol\n  field).\n  This section functionally characterizes
    a USER/IP interface.  The\n  notation used is similar to most procedure of function
    calls in high\n  level languages, but this usage is not meant to rule out trap
    type\n  service calls (e.g., SVCs, UUOs, EMTs), or any other form of\n  interprocess
    communication.\n"
  title: Specification
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - 'APPENDIX A:  Examples & Scenarios

    '
  title: 'APPENDIX A:  Examples & Scenarios'
- contents:
  - "Example 1:\n  This is an example of the minimal data carrying internet datagram:\n
    \   0                   1                   2                   3   \n    0 1
    2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |Ver= 4 |IHL= 5 |Type of Service|        Total Length = 21      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |      Identification = 111     |Flg=0|   Fragment Offset = 0   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |   Time = 123  |  Protocol = 1 |        header checksum        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                         source address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                      destination address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |     data      |                                                \n   +-+-+-+-+-+-+-+-+
    \                                               \n                       Example
    Internet Datagram\n                               Figure 5.\n  Note that each
    tick mark represents one bit position.\n  This is a internet datagram in version
    4 of internet protocol; the\n  internet header consists of five 32 bit words,
    and the total length of\n  the datagram is 21 octets.  This datagram is a complete
    datagram (not\n  a fragment).\n                                                       Internet
    Protocol\n"
  title: 'Example 1:'
- contents:
  - "Example 2:\n  In this example, we show first a moderate size internet datagram
    (452\n  data octets), then two internet fragments that might result from the\n
    \ fragmentation of this datagram if the maximum sized transmission\n  allowed
    were 280 octets.\n    0                   1                   2                   3
    \  \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 472      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |     Identification = 111      |Flg=0|     Fragment Offset = 0 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |   Time = 123  | Protocol = 6  |        header checksum        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                         source address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                      destination address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   \\                                                               \\\n
    \  \\                                                               \\\n   |                             data
    \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |             data              |                                \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                               \n                       Example Internet Datagram\n
    \                              Figure 6.\n"
  title: 'Example 2:'
- contents:
  - "Internet Protocol\n  Now the first fragment that results from splitting the datagram
    after\n  256 data octets.\n    0                   1                   2                   3
    \  \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 276      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |     Identification = 111      |Flg=1|     Fragment Offset = 0 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |   Time = 119  | Protocol = 6  |        Header Checksum        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                         source address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                      destination address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   \\                                                               \\\n
    \  \\                                                               \\\n   |                             data
    \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                      Example Internet Fragment\n                               Figure
    7.\n                                                       Internet Protocol\n
    \ And the second fragment.\n    0                   1                   2                   3
    \  \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 216      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |     Identification = 111      |Flg=0|  Fragment Offset  =  32 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |   Time = 119  | Protocol = 6  |        Header Checksum        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                         source address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                      destination address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   \\                                                               \\\n
    \  \\                                                               \\\n   |                             data
    \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |            data               |                                \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \                               \n                       Example Internet Fragment\n
    \                              Figure 8.\n"
  title: Internet Protocol
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - "Example 3:\n  Here, we show an example of a datagram containing options:\n    0
    \                  1                   2                   3   \n    0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |Ver= 4 |IHL= 8 |Type of Service|       Total Length = 576      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |       Identification = 111    |Flg=0|     Fragment Offset = 0 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |   Time = 123  |  Protocol = 6 |       Header Checksum         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                        source address                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                      destination address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  | Opt. Code = x | Opt.  Len.= 3 | option value  | Opt. Code = x |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  | Opt. Len. = 4 |           option value        | Opt. Code = 1 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  | Opt. Code = y | Opt. Len. = 3 |  option value | Opt. Code = 0 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   \\                                                               \\\n
    \  \\                                                               \\\n   |                             data
    \                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                      Example Internet Datagram\n                               Figure
    9.\n                                                       Internet Protocol\n"
  title: 'Example 3:'
- contents:
  - 'APPENDIX B:  Data Transmission Order

    '
  title: 'APPENDIX B:  Data Transmission Order'
- contents:
  - 'The order of transmission of the header and data described in this

    '
  title: The order of transmission of the header and data described in this
- contents:
  - 'document is resolved to the octet level.  Whenever a diagram shows a

    '
  title: document is resolved to the octet level.  Whenever a diagram shows a
- contents:
  - 'group of octets, the order of transmission of those octets is the normal

    '
  title: group of octets, the order of transmission of those octets is the normal
- contents:
  - 'order in which they are read in English.  For example, in the following

    '
  title: order in which they are read in English.  For example, in the following
- contents:
  - "diagram the octets are transmitted in the order they are numbered.\n    0                   1
    \                  2                   3   \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |       1       |       2       |       3       |       4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |       5       |       6       |       7       |       8       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |       9       |      10       |      11       |      12       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                     Transmission Order of Bytes\n                               Figure
    10.\n"
  title: diagram the octets are transmitted in the order they are numbered.
- contents:
  - 'Whenever an octet represents a numeric quantity the left most bit in the

    '
  title: Whenever an octet represents a numeric quantity the left most bit in the
- contents:
  - 'diagram is the high order or most significant bit.  That is, the bit

    '
  title: diagram is the high order or most significant bit.  That is, the bit
- contents:
  - 'labeled 0 is the most significant bit.  For example, the following

    '
  title: labeled 0 is the most significant bit.  For example, the following
- contents:
  - "diagram represents the value 170 (decimal).\n                            0 1
    2 3 4 5 6 7 \n                           +-+-+-+-+-+-+-+-+\n                           |1
    0 1 0 1 0 1 0|\n                           +-+-+-+-+-+-+-+-+\n                          Significance
    of Bits\n                               Figure 11.\n"
  title: diagram represents the value 170 (decimal).
- contents:
  - 'Similarly, whenever a multi-octet field represents a numeric quantity

    '
  title: Similarly, whenever a multi-octet field represents a numeric quantity
- contents:
  - 'the left most bit of the whole field is the most significant bit.  When

    '
  title: the left most bit of the whole field is the most significant bit.  When
- contents:
  - 'a multi-octet quantity is transmitted the most significant octet is

    '
  title: a multi-octet quantity is transmitted the most significant octet is
- contents:
  - 'transmitted first.

    '
  title: transmitted first.
- contents:
  - "Internet Protocol\n                                                       Internet
    Protocol\n                                GLOSSARY\n"
  title: Internet Protocol
- contents:
  - "1822\n          BBN Report 1822, \"The Specification of the Interconnection of\n
    \         a Host and an IMP\".  The specification of interface between a\n          host
    and the ARPANET.\n"
  title: '1822'
- contents:
  - "ARPANET leader\n          The control information on an ARPANET message at the
    host-IMP\n          interface.\n"
  title: ARPANET leader
- contents:
  - "ARPANET message\n          The unit of transmission between a host and an IMP
    in the\n          ARPANET.  The maximum size is about 1012 octets (8096 bits).\n"
  title: ARPANET message
- contents:
  - "ARPANET packet\n          A unit of transmission used internally in the ARPANET
    between\n          IMPs. The maximum size is about 126 octets (1008 bits).\n"
  title: ARPANET packet
- contents:
  - "Destination\n          The destination address, an internet header field.\n"
  title: Destination
- contents:
  - "DF\n          The Don't Fragment bit carried in the flags field.\n"
  title: DF
- contents:
  - "Flags\n          An internet header field carrying various control flags.\n"
  title: Flags
- contents:
  - "Fragment Offset\n          This internet header field indicates where in the
    internet\n          datagram a fragment belongs.\n"
  title: Fragment Offset
- contents:
  - "GGP\n          Gateway to Gateway Protocol, the protocol used primarily\n          between
    gateways to control routing and other gateway\n          functions.\n"
  title: GGP
- contents:
  - "header\n          Control information at the beginning of a message, segment,\n
    \         datagram, packet or block of data.\n"
  title: header
- contents:
  - "ICMP\n          Internet Control Message Protocol, implemented in the internet\n
    \         module, the ICMP is used from gateways to hosts and between\n          hosts
    to report errors and make routing suggestions.\n"
  title: ICMP
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - 'Glossary

    '
  title: Glossary
- contents:
  - "Identification\n          An internet header field carrying the identifying value\n
    \         assigned by the sender to aid in assembling the fragments of a\n          datagram.\n"
  title: Identification
- contents:
  - "IHL\n          The internet header field Internet Header Length is the length\n
    \         of the internet header measured in 32 bit words.\n"
  title: IHL
- contents:
  - "IMP\n          The Interface Message Processor, the packet switch of the\n          ARPANET.\n"
  title: IMP
- contents:
  - "Internet Address\n          A four octet (32 bit) source or destination address
    consisting\n          of a Network field and a Local Address field.\n"
  title: Internet Address
- contents:
  - "internet datagram\n          The unit of data exchanged between a pair of internet
    modules\n          (includes the internet header).\n"
  title: internet datagram
- contents:
  - "internet fragment\n          A portion of the data of an internet datagram with
    an internet\n          header.\n"
  title: internet fragment
- contents:
  - "Local Address\n          The address of a host within a network.  The actual
    mapping of\n          an internet local address on to the host addresses in a\n
    \         network is quite general, allowing for many to one mappings.\n"
  title: Local Address
- contents:
  - "MF\n          The More-Fragments Flag carried in the internet header flags\n
    \         field.\n"
  title: MF
- contents:
  - "module\n          An implementation, usually in software, of a protocol or other\n
    \         procedure.\n"
  title: module
- contents:
  - "more-fragments flag\n          A flag indicating whether or not this internet
    datagram\n          contains the end of an internet datagram, carried in the\n
    \         internet header Flags field.\n"
  title: more-fragments flag
- contents:
  - "NFB\n          The Number of Fragment Blocks in a the data portion of an\n          internet
    fragment.  That is, the length of a portion of data\n          measured in 8 octet
    units.\n                                                       Internet Protocol\n
    \                                                               Glossary\n"
  title: NFB
- contents:
  - "octet\n          An eight bit byte.\n"
  title: octet
- contents:
  - "Options\n          The internet header Options field may contain several options,\n
    \         and each option may be several octets in length.\n"
  title: Options
- contents:
  - "Padding\n          The internet header Padding field is used to ensure that the\n
    \         data begins on 32 bit word boundary.  The padding is zero.\n"
  title: Padding
- contents:
  - "Protocol\n          In this document, the next higher level protocol identifier,\n
    \         an internet header field.\n"
  title: Protocol
- contents:
  - "Rest\n          The local address portion of an Internet Address.\n"
  title: Rest
- contents:
  - "Source\n          The source address, an internet header field.\n"
  title: Source
- contents:
  - "TCP\n          Transmission Control Protocol:  A host-to-host protocol for\n
    \         reliable communication in internet environments.\n"
  title: TCP
- contents:
  - "TCP Segment\n          The unit of data exchanged between TCP modules (including
    the\n          TCP header).\n"
  title: TCP Segment
- contents:
  - "TFTP\n          Trivial File Transfer Protocol:  A simple file transfer\n          protocol
    built on UDP.\n"
  title: TFTP
- contents:
  - "Time to Live\n          An internet header field which indicates the upper bound
    on\n          how long this internet datagram may exist.\n"
  title: Time to Live
- contents:
  - "TOS\n          Type of Service\n"
  title: TOS
- contents:
  - "Total Length\n          The internet header field Total Length is the length
    of the\n          datagram in octets including internet header and data.\n"
  title: Total Length
- contents:
  - "TTL\n          Time to Live\n"
  title: TTL
- contents:
  - 'Internet Protocol

    '
  title: Internet Protocol
- contents:
  - 'Glossary

    '
  title: Glossary
- contents:
  - "Type of Service\n          An internet header field which indicates the type
    (or quality)\n          of service for this internet datagram.\n"
  title: Type of Service
- contents:
  - "UDP\n          User Datagram Protocol:  A user level protocol for transaction\n
    \         oriented applications.\n"
  title: UDP
- contents:
  - "User\n          The user of the internet protocol.  This may be a higher level\n
    \         protocol module, an application program, or a gateway program.\n"
  title: User
- contents:
  - "Version\n          The Version field indicates the format of the internet header.\n
    \                                                      Internet Protocol\n                               REFERENCES\n"
  title: Version
- contents:
  - "[1]  Cerf, V., \"The Catenet Model for Internetworking,\" Information\n     Processing
    Techniques Office, Defense Advanced Research Projects\n     Agency, IEN 48, July
    1978.\n"
  title: '[1]  Cerf, V., "The Catenet Model for Internetworking," Information'
- contents:
  - "[2]  Bolt Beranek and Newman, \"Specification for the Interconnection of\n     a
    Host and an IMP,\" BBN Technical Report 1822, Revised May 1978.\n"
  title: '[2]  Bolt Beranek and Newman, "Specification for the Interconnection of'
- contents:
  - "[3]  Postel, J., \"Internet Control Message Protocol - DARPA Internet\n     Program
    Protocol Specification,\" RFC 792, USC/Information Sciences\n     Institute, September
    1981.\n"
  title: '[3]  Postel, J., "Internet Control Message Protocol - DARPA Internet'
- contents:
  - "[4]  Shoch, J., \"Inter-Network Naming, Addressing, and Routing,\"\n     COMPCON,
    IEEE Computer Society, Fall 1978.\n"
  title: '[4]  Shoch, J., "Inter-Network Naming, Addressing, and Routing,"'
- contents:
  - "[5]  Postel, J., \"Address Mappings,\" RFC 796, USC/Information Sciences\n     Institute,
    September 1981.\n"
  title: '[5]  Postel, J., "Address Mappings," RFC 796, USC/Information Sciences'
- contents:
  - "[6]  Shoch, J., \"Packet Fragmentation in Inter-Network Protocols,\"\n     Computer
    Networks, v. 3, n. 1, February 1979.\n"
  title: '[6]  Shoch, J., "Packet Fragmentation in Inter-Network Protocols,"'
- contents:
  - "[7]  Strazisar, V., \"How to Build a Gateway\", IEN 109, Bolt Beranek and\n     Newman,
    August 1979.\n"
  title: '[7]  Strazisar, V., "How to Build a Gateway", IEN 109, Bolt Beranek and'
- contents:
  - "[8]  Postel, J., \"Service Mappings,\" RFC 795, USC/Information Sciences\n     Institute,
    September 1981.\n"
  title: '[8]  Postel, J., "Service Mappings," RFC 795, USC/Information Sciences'
- contents:
  - "[9]  Postel, J., \"Assigned Numbers,\" RFC 790, USC/Information Sciences\n     Institute,
    September 1981.\n"
  title: '[9]  Postel, J., "Assigned Numbers," RFC 790, USC/Information Sciences'
