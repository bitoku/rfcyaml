- title: __initial_text__
  contents:
  - '                 On the Design of Application Protocols

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes the design principles for the Blocks eXtensible\n\
    \   eXchange Protocol (BXXP).  BXXP is a generic application protocol\n   framework\
    \ for connection-oriented, asynchronous interactions.  The\n   framework permits\
    \ simultaneous and independent exchanges within the\n   context of a single application\
    \ user-identity, supporting both\n   textual and binary messages.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  A Problem 19 Years in the Making . . . . . . . . .\
    \ . . . . . .  3\n   2.  You can Solve Any Problem... . . . . . . . . . . . .\
    \ . . . . .  6\n   3.  Protocol Mechanisms  . . . . . . . . . . . . . . . . .\
    \ . . . .  8\n   3.1 Framing  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  8\n   3.2 Encoding . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  9\n   3.3 Reporting  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  9\n   3.4 Asynchrony . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 10\n   3.5 Authentication . . . . . . . . . . . . . . . . . . . . . . . . 12\n\
    \   3.6 Privacy  . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n  \
    \ 3.7 Let's Recap  . . . . . . . . . . . . . . . . . . . . . . . . . 13\n   4.\
    \  Protocol Properties  . . . . . . . . . . . . . . . . . . . . . 14\n   4.1 Scalability\
    \  . . . . . . . . . . . . . . . . . . . . . . . . . 14\n   4.2 Efficiency . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 15\n   4.3 Simplicity . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . 15\n   4.4 Extensibility  . .\
    \ . . . . . . . . . . . . . . . . . . . . . . 15\n   4.5 Robustness . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . 16\n   5.  The BXXP Framework . .\
    \ . . . . . . . . . . . . . . . . . . . . 17\n   5.1 Framing and Encoding . .\
    \ . . . . . . . . . . . . . . . . . . . 17\n   5.2 Reporting  . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 19\n   5.3 Asynchrony . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . 19\n   5.4 Authentication . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 21\n   5.5 Privacy  . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . 21\n   5.6 Things We Left Out . . . . . . . .\
    \ . . . . . . . . . . . . . . 21\n   5.7 From Framework to Protocol . . . . .\
    \ . . . . . . . . . . . . . 22\n   6.  BXXP is now BEEP . . . . . . . . . . .\
    \ . . . . . . . . . . . . 23\n   7.  Security Considerations  . . . . . . . .\
    \ . . . . . . . . . . . 23\n   References . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 24\n   Author's Address . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . 26\n   Full Copyright Statement . . . . . . . . . . . . .\
    \ . . . . . . . . 27\n"
- title: 1. A Problem 19 Years in the Making
  contents:
  - "1. A Problem 19 Years in the Making\n   SMTP [1] is close to being the perfect\
    \ application protocol: it\n   solves a large, important problem in a minimalist\
    \ way.  It's simple\n   enough for an entry-level implementation to fit on one\
    \ or two screens\n   of code, and flexible enough to form the basis of very powerful\n\
    \   product offerings in a robust and competitive market.  Modulo a few\n   oddities\
    \ (e.g., SAML), the design is well conceived and the resulting\n   specification\
    \ is well-written and largely self-contained.  There is\n   very little about\
    \ good application protocol design that you can't\n   learn by reading the SMTP\
    \ specification.\n   Unfortunately, there's one little problem: SMTP was originally\n\
    \   published in 1981 and since that time, a lot of application protocols\n  \
    \ have been designed for the Internet, but there hasn't been a lot of\n   reuse\
    \ going on.  You might expect this if the application protocols\n   were all radically\
    \ different, but this isn't the case: most are\n   surprisingly similar in their\
    \ functional behavior, even though the\n   actual details vary considerably.\n\
    \   In late 1998, as Carl Malamud and I were sitting down to review the\n   Blocks\
    \ architecture, we realized that we needed to have a protocol\n   for exchanging\
    \ Blocks.  The conventional wisdom is that when you need\n   an application protocol,\
    \ there are four ways to proceed:\n   1. find an existing exchange protocol that\
    \ (more or less) does what\n      you want;\n   2. define an exchange model on\
    \ top of the world-wide web\n      infrastructure that (more or less) does what\
    \ you want;\n   3. define an exchange model on top of the electronic mail\n  \
    \    infrastructure that (more or less) does what you want; or,\n   4. define\
    \ a new protocol from scratch that does exactly what you\n      want.\n   An engineer\
    \ can make reasoned arguments about the merits of each of\n   the these approaches.\
    \  Here's the process we followed...\n   The most appealing option is to find\
    \ an existing protocol and use\n   that.  (In other words, we'd rather \"buy\"\
    \ than \"make\".) So, we did a\n   survey of many existing application protocols\
    \ and found that none of\n   them were a good match for the semantics of the protocol\
    \ we needed.\n   For example, most application protocols are oriented toward\n\
    \   client/server behavior, and emphasize the client pulling data from\n   the\
    \ server; in contrast with Blocks, a client usually pulls data from\n   the server,\
    \ but it also may request the server to asynchronously push\n   (new) data to\
    \ it.  Clearly, we could mutate a protocol such as FTP\n   [2] or SMTP into what\
    \ we wanted, but by the time we did all that, the\n   base protocol and our protocol\
    \ would have more differences than\n   similarities.  In other words, the cost\
    \ of modifying an off-the-shelf\n   implementation becomes comparable with starting\
    \ from scratch.\n   Another approach is to use HTTP [3] as the exchange protocol\
    \ and\n   define the rules for data exchange over that.  For example, IPP [4]\n\
    \   (the Internet Printing Protocol) uses this approach.  The basic idea\n   is\
    \ that HTTP defines the rules for exchanging data and then you\n   define the\
    \ data's syntax and semantics.  Because you inherit the\n   entire HTTP infrastructure\
    \ (e.g., HTTP's authentication mechanisms,\n   caching proxies, and so on), there's\
    \ less for you to have to invent\n   (and code!).  Or, conversely, you might view\
    \ the HTTP infrastructure\n   as too helpful.  As an added bonus, if you decide\
    \ that your protocol\n   runs over port 80, you may be able to sneak your traffic\
    \ past older\n   firewalls, at the cost of port 80 saturation.\n   HTTP has many\
    \ strengths: it's ubiquitous, it's familiar, and there\n   are a lot of tools\
    \ available for developing HTTP-based systems.\n   Another good thing about HTTP\
    \ is that it uses MIME [5] for encoding\n   data.\n   Unfortunately for us, even\
    \ with HTTP 1.1 [6], there still wasn't a\n   good fit.  As a consequence of the\
    \ highly-desirable goal of\n   maintaining compatibility with the original HTTP,\
    \ HTTP's framing\n   mechanism isn't flexible enough to support server-side asynchronous\n\
    \   behavior and its authentication model isn't similar to other Internet\n  \
    \ applications.\n   Mapping IPP onto HTTP 1.1 illustrates the former issue.  For\
    \ example,\n   the IPP server is supposed to signal its client when a job completes.\n\
    \   Since the HTTP client must originate all requests and since the\n   decision\
    \ to close a persistent connection in HTTP is unilateral, the\n   best that the\
    \ IPP specification can do is specify this functionality\n   in a non-deterministic\
    \ fashion.\n   Further, the IPP mapping onto HTTP shows that even subtle shifts\
    \ in\n   behavior have unintended consequences.  For example, requests in IPP\n\
    \   are typically much larger than those seen by many HTTP server\n   implementations\
    \ -- resulting in oddities in many HTTP servers (e.g.,\n   requests are sometimes\
    \ silently truncated).  The lesson is that\n   HTTP's framing mechanism is very\
    \ rigid with respect to its view of\n   the request/response model.\n   Lastly,\
    \ given our belief that the port field of the TCP header isn't\n   a constant\
    \ 80, we were immune to the seductive allure of wanting to\n   sneak our traffic\
    \ past unwary site administrators.\n   The third choice, layering the protocol\
    \ on top of email, was\n   attractive.  Unfortunately, the nature of our application\
    \ includes a\n   lot of interactivity with relatively small response times.  So,\
    \ this\n   left us the final alternative: defining a protocol from scratch.\n\
    \   To begin, we figured that our requirements, while a little more\n   stringent\
    \ than most, could fit inside a framework suitable for a\n   large number of future\
    \ application protocols.  The trick is to avoid\n   the kitchen-sink approach.\
    \  (Dave Clark has a saying: \"One of the\n   roles of architecture is to tell\
    \ you what you can't do.\")\n"
- title: 2. You can Solve Any Problem...
  contents:
  - "2. You can Solve Any Problem...\n    ...if you're willing to make the problem\
    \ small enough.\n   Our most important step is to limit the problem to application\n\
    \   protocols that exhibit certain features:\n   o  they are connection-oriented;\n\
    \   o  they use requests and responses to exchange messages; and,\n   o  they\
    \ allow for asynchronous message exchange.\n   Let's look at each, in turn.\n\
    \   First, we're only going to consider connection-oriented application\n   protocols\
    \ (e.g., those that work on top of TCP [7]).  Another branch\n   in the taxonomy,\
    \ connectionless, consists of those that don't want\n   the delay or overhead\
    \ of establishing and maintaining a reliable\n   stream.  For example, most DNS\
    \ [8] traffic is characterized by a\n   single request and response, both of which\
    \  fit within a single IP\n   datagram.  In this case, it makes sense to implement\
    \ a basic\n   reliability service above the transport layer in the application\n\
    \   protocol itself.\n   Second, we're only going to consider message-oriented\
    \ application\n   protocols.  A \"message\" -- in our lexicon -- is simply structured\n\
    \   data exchanged between loosely-coupled systems.  Another branch in\n   the\
    \ taxonomy, tightly-coupled systems, uses remote procedure calls as\n   the exchange\
    \ paradigm.  Unlike the connection-oriented/connectionless\n   dichotomy, the\
    \ issue of loosely- or tightly-coupled systems is\n   similar to a continuous\
    \ spectrum.  Fortunately, the edges are fairly\n   sharp.\n   For example, NFS\
    \ [9] is a tightly-coupled system using RPCs.  When\n   running in a properly-configured\
    \ LAN, a remote disk accessible via\n   NFS is virtually indistinguishable from\
    \ a local disk.  To achieve\n   this, tightly-coupled systems are highly concerned\
    \ with issues of\n   latency.  Hence, most (but not all) tightly-coupled systems\
    \ use\n   connection-less RPC mechanisms; further, most tend to be implemented\n\
    \   as operating system functions rather than user-level programs.  (In\n   some\
    \ environments, the tightly-coupled systems are implemented as\n   single-purpose\
    \ servers, on hardware specifically optimized for that\n   one function.)\n  \
    \ Finally, we're going to consider the needs of application protocols\n   that\
    \ exchange messages asynchronously.  The classic client/server\n   model is that\
    \ the client sends a request and the server sends a\n   response.  If you think\
    \ of requests as \"questions\" and responses as\n   \"answers\", then the server\
    \ answers only those questions that it's\n   asked and it never asks any questions\
    \ of its own.  We'll need to\n   support a more general model, peer-to-peer. \
    \ In this model, for a\n   given transaction one peer might be the \"client\"\
    \ and the other the\n   \"server\", but for the next transaction, the two peers\
    \ might switch\n   roles.\n   It turns out that the client/server model is a proper\
    \ subset of the\n   peer-to-peer model: it's acceptable for a particular application\n\
    \   protocol to dictate that the peer that establishes the connection\n   always\
    \ acts as the client (initiates requests), and that the peer\n   that listens\
    \ for incoming connections always acts as the server\n   (issuing responses to\
    \ requests).\n   There are quite a few existing application domains that don't\
    \ fit our\n   requirements, e.g., nameservice (via the DNS), fileservice (via\
    \ NFS),\n   multicast-enabled applications such as distributed video\n   conferencing,\
    \ and so on.  However, there are a lot of application\n   domains that do fit\
    \ these requirements, e.g., electronic mail, file\n   transfer, remote shell,\
    \ and the world-wide web.  So, the bet we are\n   placing in going forward is\
    \ that there will continue to be reasons\n   for defining protocols that fit within\
    \ our framework.\n"
- title: 3. Protocol Mechanisms
  contents:
  - "3. Protocol Mechanisms\n   The next step is to look at the tasks that an application\
    \ protocol\n   must perform and how it goes about performing them.  Although an\n\
    \   exhaustive exposition might identify a dozen (or so) areas, the ones\n   we're\
    \ interested in are:\n   o  framing, which tells how the beginning and ending\
    \ of each message\n      is delimited;\n   o  encoding, which tells how a message\
    \ is represented when exchanged;\n   o  reporting, which tells how errors are\
    \ described;\n   o  asynchrony, which tells how independent exchanges are handled;\n\
    \   o  authentication, which tells how the peers at each end of the\n      connection\
    \ are identified and verified; and,\n   o  privacy, which tells how the exchanges\
    \ are protected against\n      third-party interception or modification.\n   A\
    \ notable absence in this list is naming -- we'll explain why later\n   on.\n"
- title: 3.1 Framing
  contents:
  - "3.1 Framing\n   There are three commonly used approaches to delimiting messages:\n\
    \   octet-stuffing, octet-counting, and connection-blasting.\n   An example of\
    \ a protocol that uses octet-stuffing is SMTP.  Commands\n   in SMTP are line-oriented\
    \ (each command ends in a CR-LF pair).  When\n   an SMTP peer sends a message,\
    \ it first transmits the \"DATA\" command,\n   then it transmits the message,\
    \ then it transmits a \".\" (dot) followed\n   by a CR-LF.  If the message contains\
    \ any lines that begin with a dot,\n   the sending SMTP peer sends two dots; similarly,\
    \ when the other SMTP\n   peer receives a line that begins with a dot, it discards\
    \ the dot,\n   and, if the line is empty, then it knows it's received the entire\n\
    \   message.  Octet-stuffing has the property that you don't need the\n   entire\
    \ message in front of you before you start sending it.\n   Unfortunately, it's\
    \ slow because both the sender and receiver must\n   scan each line of the message\
    \ to see if they need to transform it.\n   An example of a protocol that uses\
    \ octet-counting is HTTP.  Commands\n   in HTTP consist of a request line followed\
    \ by headers and a body. The\n   headers contain an octet count indicating how\
    \ large the body is. The\n   properties of octet-counting are the inverse of octet-stuffing:\n\
    \   before you can start sending a message you need to know the length of\n  \
    \ the whole message, but you don't need to look at the content of the\n   message\
    \ once you start sending or receiving.\n   An example of a protocol that uses\
    \ connection-blasting is FTP.\n   Commands in FTP are line-oriented, and when\
    \ it's time to exchange a\n   message, a new TCP connection is established to\
    \ transmit the message.\n   Both octet-counting and connection-blasting have the\
    \ property that\n   the messages can be arbitrary binary data; however, the drawback\
    \ of\n   the connection-blasting approach is that the peers need to\n   communicate\
    \ IP addresses and TCP port numbers, which may be\n   \"transparently\" altered\
    \ by NATS [10] and network bugs.  In addition,\n   if the messages being exchanged\
    \ are small (say less than 32k), then\n   the overhead of establishing a connection\
    \ for each message\n   contributes significant latency during data exchange.\n"
- title: 3.2 Encoding
  contents:
  - "3.2 Encoding\n   There are many schemes used for encoding data (and many more\
    \ encoding\n   schemes have been proposed than are actually in use).  Fortunately,\n\
    \   only a few are burning brightly on the radar.\n   The messages exchanged using\
    \ SMTP are encoded using the 822-style\n   [11].  The 822-style divides a message\
    \ into textual headers and an\n   unstructured body.  Each header consists of\
    \ a name and a value and is\n   terminated with a CR-LF pair.  An additional CR-LF\
    \ separates the\n   headers from the body.\n   It is this structure that HTTP\
    \ uses to indicate the length of the\n   body for framing purposes.  More formally,\
    \ HTTP uses MIME, an\n   application of the 822-style to encode both the data\
    \ itself (the\n   body) and information about the data (the headers).  That is,\n\
    \   although HTTP is commonly viewed as a retrieval mechanism for HTML\n   [12],\
    \ it is really a retrieval mechanism for objects encoded using\n   MIME, most\
    \ of which are either HTML pages or referenced objects such\n   as GIFs.\n"
- title: 3.3 Reporting
  contents:
  - "3.3 Reporting\n   An application protocol needs a mechanism for conveying error\n\
    \   information between peers.  The first formal method for doing this\n   was\
    \ defined by SMTP's \"theory of reply codes\".  The basic idea is\n   that an\
    \ error is identified by a three-digit string, with each\n   position having a\
    \ different significance:\n   the first digit: indicating success or failure,\
    \ either permanent or\n      transient;\n   the second digit: indicating the part\
    \ of the system reporting the\n      situation (e.g., the syntax analyzer); and,\n\
    \   the third digit: identifying the actual situation.\n   Operational experience\
    \ with SMTP suggests that the range of error\n   conditions is larger than can\
    \ be comfortably encoded using a three-\n   digit string (i.e., you can report\
    \ on only 10 different things going\n   wrong for any given part of the system).\
    \  So, [13] provides a\n   convenient mechanism for extending the number of values\
    \ that can\n   occur in the second and third positions.\n   Virtually all of the\
    \ application protocols we've discussed thus far\n   use the three-digit reply\
    \ codes, although there is less coordination\n   between the designers of different\
    \ application protocols than most\n   would care to admit.  (A variation on the\
    \ theory of reply codes is\n   employed by IMAP [14] which provides the same information\
    \ using a\n   different syntax.)\n   In addition to conveying a reply code, most\
    \ application protocols\n   also send a textual diagnostic suitable for human,\
    \ not machine,\n   consumption.  (More accurately, the textual diagnostic is suitable\n\
    \   for people who can read a widely used variant of the English\n   language.)\
    \ Since reply codes reflect both positive and negative\n   outcomes, there have\
    \ been some innovative uses made for the text\n   accompanying positive responses,\
    \ e.g., prayer wheels [39].\n   Regardless, some of the more modern application\
    \ protocols include a\n   language localization parameter for the diagnostic text.\n\
    \   Finally, since the introduction of reply codes in 1981, two\n   unresolved\
    \ criticisms have been raised:\n   o  a reply code is used both to signal the\
    \ outcome of an operation\n      and a change in the application protocol's state;\
    \ and,\n   o  a reply code doesn't specify whether the associated textual\n  \
    \    diagnostic is destined for the end-user, administrator, or\n      programmer.\n"
- title: 3.4 Asynchrony
  contents:
  - "3.4 Asynchrony\n   Few application protocols today allow independent exchanges\
    \ over the\n   same connection.  In fact, the more widely implemented approach\
    \ is to\n   allow pipelining, e.g., command pipelining [15] in SMTP or persistent\n\
    \   connections in HTTP 1.1.  Pipelining allows a client to make multiple\n  \
    \ requests of a server, but requires the requests to be processed\n   serially.\
    \  (Note that a protocol needs to explicitly provide support\n   for pipelining,\
    \ since, without explicit guidance, many implementors\n   produce systems that\
    \ don't handle pipelining properly; typically, an\n   error in a request causes\
    \ subsequent requests in the pipeline to be\n   discarded).\n   Pipelining is\
    \ a powerful method for reducing network latency.  For\n   example, without persistent\
    \ connections, HTTP's framing mechanism is\n   really closer to connection-blasting\
    \ than octet-counting, and it\n   enjoys the same latency and efficiency problems.\n\
    \   In addition to reducing network latency (the pipelining effect),\n   asynchrony\
    \ also reduces server latency by allowing multiple requests\n   to be processed\
    \ by multi-threaded implementations.  Note that if you\n   allow any form of asynchronous\
    \ exchange, then support for parallelism\n   is also required, because exchanges\
    \ aren't necessarily occurring\n   under the synchronous direction of a single\
    \ peer.\n   Unfortunately, when you allow parallelism, you also need a flow\n\
    \   control mechanism to avoid starvation and deadlock.  Otherwise, a\n   single\
    \ set of exchanges can monopolize the bandwidth provided by the\n   transport\
    \ layer.  Further, if a peer is resource-starved, then it may\n   not have enough\
    \ buffers to receive a message and deadlock results.\n   Flow control is typically\
    \ implemented at the transport layer.  For\n   example, TCP uses sequence numbers\
    \ and a sliding window: each\n   receiver manages a sliding window that indicates\
    \ the number of data\n   octets that may be transmitted before receiving further\
    \ permission.\n   However, it's now time for the second shoe to drop: segmentation.\
    \  If\n   you do flow control then you also need a segmentation mechanism to\n\
    \   fragment messages into smaller pieces before sending and then re-\n   assemble\
    \ them as they're received.\n   Both flow control and segmentation have an impact\
    \ on how the protocol\n   does framing.  Before we defined framing as \"how to\
    \ tell the\n   beginning and end of each message\" -- in addition, we need to\
    \ be able\n   to identify independent messages, send messages only when flow\n\
    \   control allows us to, and segment them if they're larger than the\n   available\
    \ window (or too large for comfort).\n   Segmentation impacts framing in another\
    \ way -- it relaxes the octet-\n   counting requirement that you need to know\
    \ the length of the whole\n   message before sending it.  With segmentation, you\
    \ can start sending\n   segments before the whole message is available.  In HTTP\
    \ 1.1 you can\n   \"chunk\" (segment) data to get this advantage.\n"
- title: 3.5 Authentication
  contents:
  - "3.5 Authentication\n   Perhaps for historical (or hysterical) reasons, most application\n\
    \   protocols don't do authentication.  That is, they don't authenticate\n   the\
    \ identity of the peers on the connection or the authenticity of\n   the messages\
    \ being exchanged.  Or, if authentication is done, it is\n   domain-specific for\
    \ each protocol.  For example, FTP and HTTP use\n   entirely different models\
    \ and mechanisms for authenticating the\n   initiator of a connection.  (Independent\
    \ of mainstream HTTP, there is\n   a little-used variant [16] that authenticates\
    \ the messages it\n   exchanges.)\n   A large part of the problem is that different\
    \ security mechanisms\n   optimize for strength, scalability, or ease of deployment.\
    \  So, a few\n   years ago, SASL [17] (the Simple Authentication and Security\
    \ Layer)\n   was developed to provide a framework for authenticating protocol\n\
    \   peers.  SASL let's you describe how an authentication mechanism\n   works,\
    \ e.g., an OTP [18] (One-Time Password) exchange.  It's then up\n   to each protocol\
    \ designer to specify how SASL exchanges are\n   generically conveyed by the protocol.\
    \  For example, [19] explains how\n   SASL works with SMTP.\n   A notable exception\
    \ to the SASL bandwagon is HTTP, which defines its\n   own authentication mechanisms\
    \ [20].  There is little reason why SASL\n   couldn't be introduced to HTTP, although\
    \ to avoid certain race-\n   conditions, the persistent connection mechanism of\
    \ HTTP 1.1 must be\n   used.\n   SASL has an interesting feature in that in addition\
    \ to explicit\n   protocol exchanges to authenticate identity, it can also use\
    \ implicit\n   information provided from the layer below.  For example, if the\n\
    \   connection is running over IPsec [21], then the credentials of each\n   peer\
    \ are known and verified when the TCP connection is established.\n   Finally,\
    \ as its name implies, SASL can do more than authentication --\n   depending on\
    \ which SASL mechanism is in use, message integrity or\n   privacy services may\
    \ also be provided.\n"
- title: 3.6 Privacy
  contents:
  - "3.6 Privacy\n   HTTP is the first widely used protocol to make use of a transport\n\
    \   security protocol to encrypt the data sent on the connection.  The\n   current\
    \ version of this mechanism, TLS [22], is available to all\n   application protocols,\
    \ e.g., SMTP and ACAP [23] (the Application\n   Configuration Access Protocol).\n\
    \   The key difference between the original mechanism and TLS, is one of\n   provisioning\
    \ not technology.  In the original approach to\n   provisioning, a world-wide\
    \ web server listens on two ports (one for\n   plaintext traffic and the other\
    \ for secured traffic); in contrast, by\n   today's conventions, a server implementing\
    \ an application protocol\n   that is specified as TLS-enabled (e.g., [24] and\
    \ [25]) listens on a\n   single port for plaintext traffic, and, once a connection\
    \ is\n   established, the use of TLS on that connection is negotiable.\n   Finally,\
    \ note that both SASL and TLS are about \"transport security\"\n   not \"object\
    \ security\".  What this means is that they focus on\n   providing security properties\
    \ for the actual communication, they\n   don't provide any security properties\
    \ for the data exchanged\n   independent of the communication.\n"
- title: 3.7 Let's Recap
  contents:
  - "3.7 Let's Recap\n   Let's briefly compare the properties of the three main connection-\n\
    \   oriented application protocols in use today:\n                Mechanism  ESMTP\
    \        FTP        HTTP1.1\n           --------------  -----------  ---------\
    \  -------------\n                  Framing  stuffing     blasting   counting\n\
    \                 Encoding  822-style    binary     MIME\n                Reporting\
    \  3-digit      3-digit    3-digit\n               Asynchrony  pipelining   none\
    \       pipelining\n                                                   and chunking\n\
    \           Authentication  SASL         user/pass  user/pass\n              \
    \    Privacy  SASL or TLS  none       TLS (nee SSL)\n   Note that the username/password\
    \ mechanisms used by FTP and HTTP are\n   entirely different with one exception:\
    \ both can be termed a\n   \"username/password\" mechanism.\n   These three choices\
    \ are broadly representative: as more protocols are\n   considered, the patterns\
    \ are reinforced.  For example, POP [26] uses\n   octet-stuffing, but IMAP uses\
    \ octet-counting, and so on.\n"
- title: 4. Protocol Properties
  contents:
  - "4. Protocol Properties\n   When we design an application protocol, there are\
    \ a few properties\n   that we should keep an eye on.\n"
- title: 4.1 Scalability
  contents:
  - "4.1 Scalability\n   A well-designed protocol is scalable.\n   Because few application\
    \ protocols support asynchrony, a common trick\n   is for a program to open multiple\
    \ simultaneous connections to a\n   single destination.  The theory is that this\
    \ reduces latency and\n   increases throughput.  The reality is that both the\
    \ transport layer\n   and the server view each connection as an independent instance\
    \ of the\n   application protocol, and this causes problems.\n   In terms of the\
    \ transport layer, TCP uses adaptive algorithms to\n   efficiently transmit data\
    \ as networks conditions change.  But what\n   TCP learns is limited to each connection.\
    \  So, if you have multiple\n   TCP connections, you have to go through the same\
    \ learning process\n   multiple times -- even if you're going to the same host.\
    \  Not only\n   does this introduce unnecessary traffic spikes into the network,\n\
    \   because TCP uses a slow-start algorithm when establishing a\n   connection,\
    \ the program still sees additional latency.  To deal with\n   the fact that a\
    \ lack of asynchrony in application protocols causes\n   implementors to make\
    \ sloppy use of the transport layer, network\n   protocols are now provisioned\
    \ with increasing sophistication, e.g.,\n   RED [27].  Further, suggestions are\
    \ also being considered for\n   modification of TCP implementations to reduce\
    \ concurrent learning,\n   e.g., [28].\n   In terms of the server, each incoming\
    \ connection must be dispatched\n   and (probably) authenticated against the same\
    \ resources.\n   Consequently, server overhead increases based on the number of\n\
    \   connections established, rather than the number of remote users.  The\n  \
    \ same issues of fairness arise: it's much harder for servers to\n   allocate\
    \ resources on a per-user basis, when a user can cause an\n   arbitrary number\
    \ of connections to pound on the server.\n   Another important aspect of scalability\
    \ to consider is the relative\n   numbers of clients and servers.  (This is true\
    \ even in the peer-to-\n   peer model, where a peer can act both in the client\
    \ and server role.)\n   Typically, there are many more client peers than server\
    \ peers.  In\n   this case, functional requirements should be shifted from the\
    \ servers\n   onto the clients.  The reason is that a server is likely to be\n\
    \   interacting with multiple clients and this functional shift makes it\n   easier\
    \ to scale.\n"
- title: 4.2 Efficiency
  contents:
  - "4.2 Efficiency\n   A well-designed protocol is efficient.\n   For example, although\
    \ a compelling argument can be made than octet-\n   stuffing leads to more elegant\
    \ implementations than octet-counting,\n   experience shows that octet-counting\
    \ consumes far fewer cycles.\n   Regrettably, we sometimes have to compromise\
    \ efficiency in order to\n   satisfy other properties.  For example, 822 (and\
    \ MIME) use textual\n   headers.  We could certainly define a more efficient representation\n\
    \   for the headers if we were willing to limit the header names and\n   values\
    \ that could be used.  In this case, extensibility is viewed as\n   more important\
    \ than efficiency.  Of course, if we were designing a\n   network protocol instead\
    \ of an application protocol, then we'd make\n   the trade-offs using a razor\
    \ with a different edge.\n"
- title: 4.3 Simplicity
  contents:
  - "4.3 Simplicity\n   A well-designed protocol is simple.\n   Here's a good rule\
    \ of thumb: a poorly-designed application protocol\n   is one in which it is equally\
    \ as \"challenging\" to do something basic\n   as it is to do something complex.\
    \  Easy things should be easy to do\n   and hard things should be harder to do.\
    \  The reason is simple: the\n   pain should be proportional to the gain.\n  \
    \ Another rule of thumb is that if an application protocol has two ways\n   of\
    \ doing the exact same thing, then there's a problem somewhere in\n   the architecture\
    \ underlying the design of the application protocol.\n   Hopefully, simple doesn't\
    \ mean simple-minded: something that's well-\n   designed accommodates everything\
    \ in the problem domain, even the\n   troublesome things at the edges.  What makes\
    \ the design simple is\n   that it does this in a consistent fashion.  Typically,\
    \ this leads to\n   an elegant design.\n"
- title: 4.4 Extensibility
  contents:
  - "4.4 Extensibility\n   A well-designed protocol is extensible.\n   As clever as\
    \ application protocol designers are, there are likely to\n   be unforeseen problems\
    \ that the application protocol will be asked to\n   solve.  So, it's important\
    \ to provide the hooks that can be used to\n   add functionality or customize\
    \ behavior.  This means that the\n   protocol is evolutionary, and there must\
    \ be a way for implementations\n   reflecting different steps in the evolutionary\
    \ path to negotiate\n   which extensions will be used.\n   But, it's important\
    \ to avoid falling into the extensibility trap: the\n   hooks provided should\
    \ not be targeted at half-baked future\n   requirements.  Above all, the hooks\
    \ should be simple.\n   Of course good design goes a long way towards minimizing\
    \ the need for\n   extensibility.  For example, although SMTP initially didn't\
    \ have an\n   extension framework, it was only after ten years of experience that\n\
    \   its excellent design was altered.  In contrast, a poorly-designed\n   protocol\
    \ such as Telnet [29] can't function without being built\n   around the notion\
    \ of extensions.\n"
- title: 4.5 Robustness
  contents:
  - "4.5 Robustness\n   A well-designed protocol is robust.\n   Robustness and efficiency\
    \ are often at odds.  For example, although\n   defaults are useful to reduce\
    \ packet sizes and processing time, they\n   tend to encourage implementation\
    \ errors.\n   Counter-intuitively, Postel's robustness principle (\"be conservative\n\
    \   in what you send, liberal in what you accept\") often leads to\n   deployment\
    \ problems.  Why? When a new implementation is initially\n   fielded, it is likely\
    \ that it will encounter only a subset of\n   existing implementations.  If those\
    \ implementations follow the\n   robustness principle, then errors in the new\
    \ implementation will\n   likely go undetected.  The new implementation then sees\
    \ some, but not\n   widespread deployment.  This process repeats for several new\n\
    \   implementations.  Eventually, the not-quite-correct implementations\n   run\
    \ into other implementations that are less liberal than the initial\n   set of\
    \ implementations.  The reader should be able to figure out what\n   happens next.\n\
    \   Accordingly, explicit consistency checks in a protocol are very\n   useful,\
    \ even if they impose implementation overhead.\n"
- title: 5. The BXXP Framework
  contents:
  - "5. The BXXP Framework\n   Finally, we get to the money shot: here's what we did.\n\
    \   We defined an application protocol framework called BXXP (the Blocks\n   eXtensible\
    \ eXchange Protocol).  The reason it's a \"framework\" instead\n   of an application\
    \ protocol is that we provide all the mechanisms\n   discussed earlier without\
    \ actually specifying the kind of messages\n   that get exchanged.  So, when someone\
    \ else needs an application\n   protocol that requires connection-oriented, asynchronous\n\
    \   interactions, they can start with BXXP.  It's then their\n   responsibility\
    \ to define the last 10% of the application protocol,\n   the part that does,\
    \ as we say, \"the useful work\".\n   So, what does BXXP look like?\n        \
    \   Mechanism  BXXP\n       --------------  ----------------------------------------\n\
    \             Framing  counting, with a trailer\n            Encoding  MIME, defaulting\
    \ to text/xml\n           Reporting  3-digit and localized textual diagnostic\n\
    \          Asynchrony  channels\n      Authentication  SASL\n             Privacy\
    \  SASL or TLS\n"
- title: 5.1 Framing and Encoding
  contents:
  - "5.1 Framing and Encoding\n   Framing in BXXP looks a lot like SMTP or HTTP: there's\
    \ a command line\n   that identifies the beginning of the frame, then there's\
    \ a MIME\n   object (headers and body).  Unlike SMTP, BXXP uses octet-counting,\n\
    \   but unlike HTTP, the command line is where you find the size of the\n   payload.\
    \  Finally, there's a trailer after the MIME object to aid in\n   detecting framing\
    \ errors.\n   Actually, the command line for BXXP has a lot of information, it\n\
    \   tells you:\n   o  what kind of message is in this frame;\n   o  whether there's\
    \ more to the message than just what's in this frame\n      (a continuation flag);\n\
    \   o  how to distinguish the message contained in this frame from other\n   \
    \   messages (a message number);\n   o  where the payload occurs in the sliding\
    \ window (a sequence number)\n      along with how many octets are in the payload\
    \ of this frame; and,\n   o  which part of the application should get the message\
    \ (a channel\n      number).\n      (The command line is textual and ends in a\
    \ CR-LF pair, and the\n      arguments are separated by a space.)\n   Since you\
    \ need to know all this stuff to process a frame, we put it\n   all in one easy\
    \ to parse location.  You could probably devise a more\n   efficient encoding,\
    \ but the command line is a very small part of the\n   frame, so you wouldn't\
    \ get much bounce from optimizing it.  Further,\n   because framing is at the\
    \ heart of BXXP, the frame format has several\n   consistency checks that catch\
    \ the majority of programming errors.\n   (The combination of a sequence number,\
    \ an octet count, and a trailer\n   allows for very robust error detection.)\n\
    \   Another trick is in the headers: because the command line contains\n   all\
    \ the framing information, the headers may contain minimal MIME\n   information\
    \ (such as Content-Type).  Usually, however, the headers\n   are empty.  That's\
    \ because the BXXP default payload is XML [30].\n   (Actually, a \"Content-Type:\
    \ text/xml\" with binary transfer encoding).\n   We chose XML as the default because\
    \ it provides a simple mechanism\n   for nested, textual representations.  (Alas,\
    \ the 822-style encoding\n   doesn't easily support nesting.) By design, XML's\
    \ nature isn't\n   optimized for compact representations.  That's okay because\
    \ we're\n   focusing on loosely-coupled systems and besides there are efficient\n\
    \   XML parsers available.  Further, there's a fair amount of anecdotal\n   experience\
    \ -- and we'll stress the word \"anecdotal\" -- that if you\n   have any kind\
    \ of compression (either at the link-layer or during\n   encryption), then XML\
    \ encodings squeeze down nicely.\n   Even so, use of XML is probably the most\
    \ controversial part of BXXP.\n   After all, there are more efficient representations\
    \ around.  We\n   agree, but the real issue isn't efficiency, it's ease of use:\
    \ there\n   are a lot of people who grok the XML thing and there are a lot of\
    \ XML\n   tools out there.  The pain of recreating this social infrastructure\n\
    \   far outweighs any benefits of devising a new representation.  So, if\n   the\
    \ \"make\" option is too expensive, is there something else we can\n   \"buy\"\
    \ besides XML? Well, there's ASN.1/BER (just kidding).\n   In the early days of\
    \ the SNMP [31], which does use ASN.1, the same\n   issues arose.  In the end,\
    \ the working group agreed that the use of\n   ASN.1 for SNMP was axiomatic, but\
    \ not because anyone thought that\n   ASN.1 was the most efficient, or the easiest\
    \ to explain, or even well\n   liked.  ASN.1 was given axiomatic status because\
    \ the working group\n   decided it was not going to spend the next three years\
    \ explaining an\n   alternative encoding scheme to the developer community.\n\
    \   So -- and we apologize for appealing to dogma -- use of XML as the\n   favored\
    \ encoding scheme in BXXP is axiomatic.\n"
- title: 5.2 Reporting
  contents:
  - "5.2 Reporting\n   We use 3-digit error codes, with a localized textual diagnostic.\n\
    \   (Each peer specifies a preferred ordering of languages.)\n   In addition,\
    \ the reply to a message is flagged as either positive or\n   negative.  This\
    \ makes it easy to signal success or failure and allow\n   the receiving peer\
    \ some freedom in the amount of parsing it wants to\n   do on failure.\n"
- title: 5.3 Asynchrony
  contents:
  - "5.3 Asynchrony\n   Despite the lessons of SMTP and HTTP, there isn't a lot of\
    \ field\n   experience to rely on when designing the asynchrony features of BXXP.\n\
    \   (Actually, there were several efforts in 1998 related to application\n   layer\
    \ framing, e.g., [32], but none appear to have achieved orbit.)\n   So, here's\
    \ what we did: frames are exchanged in the context of a\n   \"channel\".  Each\
    \ channel has an associated \"profile\" that defines the\n   syntax and semantics\
    \ of the messages exchanged over a channel.\n   Channels provide both an extensibility\
    \ mechanism for BXXP and the\n   basis for parallelism.  Remember the last parameter\
    \ in the command\n   line of a BXXP frame? The \"part of the application\" that\
    \ gets the\n   message is identified by a channel number.\n   A profile is defined\
    \ according to a \"Profile Registration\" template.\n   The template defines how\
    \ the profile is identified (using a URI\n   [33]), what kind of messages get\
    \ exchanged, along with the syntax and\n   semantics of those messages.  When\
    \ you create a channel, you identify\n   a profile and maybe piggyback your first\
    \ message.  If the channel is\n   successfully created, you get back a positive\
    \ response; otherwise,\n   you get back a negative response explaining why.\n\
    \   Perhaps the easiest way to see how channels provide an extensibility\n   mechanism\
    \ is to consider what happens when a session is established.\n   Each BXXP peer\
    \ immediately sends a greeting on channel zero\n   identifying the profiles that\
    \ each support.  (Channel 0 is used for\n   channel management -- it's automatically\
    \ created when a session is\n   opened.) If you want transport security, the very\
    \ first thing you do\n   is to create a channel that negotiates transport security,\
    \ and, once\n   the channel is created, you tell it to do its thing.  Next, if\
    \ you\n   want to authenticate, you create a channel that performs user\n   authentication,\
    \ and, once the channel is created, you tell it to get\n   busy.  At this point,\
    \ you create one or more channels for data\n   exchange.  This process is called\
    \ \"tuning\"; once you've tuned the\n   session, you start using the data exchange\
    \ channels to do \"the useful\n   work\".\n   The first channel that's successfully\
    \ started has a trick associated\n   with it: when you ask to start the channel,\
    \ you're allowed to specify\n   a \"service name\" that goes with it.  This allows\
    \ a server with\n   multiple configurations to select one based on the client's\n\
    \   suggestion.  (A useful analogy is HTTP 1.1's \"Host:\" header.) If the\n \
    \  server accepts the \"service name\", then this configuration is used\n   for\
    \ the rest of the session.\n   To allow parallelism, BXXP allows you to use multiple\
    \ channels\n   simultaneously.  Each channel processes messages serially, but\
    \ there\n   are no constraints on the processing order for different channels.\n\
    \   So, in a multi-threaded implementation, each channel maps to its own\n   thread.\n\
    \   This is the most general case, of course.  For one reason or another,\n  \
    \ an implementor may not be able to support this.  So, BXXP allows for\n   both\
    \ positive and negative replies when a message is sent.  So, if\n   you want the\
    \ classic client/server model, the client program should\n   simply reject any\
    \ new message sent by the server.  This effectively\n   throttles any asynchronous\
    \ messages from the server.\n   Of course, we now need to provide mechanisms for\
    \ segmentation and\n   flow control.  For the former, we just put a \"continuation\"\
    \ or \"more\n   to come\" flag in the command line for the frame.  For the latter,\
    \ we\n   introduced the notion of a \"transport mapping\".\n   What this means\
    \ is that BXXP doesn't directly define how it sits of\n   top of TCP.  Instead,\
    \ it lists a bunch of requirements for how a\n   transport service needs to support\
    \ a BXXP session.  Then, in a\n   separate document, we defined how you can use\
    \ TCP to meet these\n   requirements.\n   This second document pretty much says\
    \ \"use TCP directly\", except that\n   it introduces a flow control mechanism\
    \ for multiplexing channels over\n   a single TCP connection.  The mechanism we\
    \ use is the same one used\n   by TCP (sequence numbers and a sliding window).\
    \  It's proven, and can\n   be trivially implemented by a minimal implementation\
    \ of BXXP.\n   The introduction of flow control is a burden from an implementation\n\
    \   perspective -- although TCP's mechanism is conceptually simple, an\n   implementor\
    \ must take great care.  For example, issues such as\n   priorities, queue management,\
    \ and the like should be addressed.\n   Regardless, we feel that the benefits\
    \ of allowing parallelism for\n   intra-application streams is worth it.  (Besides,\
    \ our belief is that\n   few application implementors will actually code the BXXP\
    \ framework\n   directly -- rather, we expect them to use third-party packages\
    \ that\n   implement BXXP.)\n"
- title: 5.4 Authentication
  contents:
  - "5.4 Authentication\n   We use SASL.  If you successfully authenticate using a\
    \ channel, then\n   there is a single user identity for each peer on that session\
    \ (i.e.,\n   authentication is per-session, not per-channel).  This design\n \
    \  decision mandates that each session correspond to a single user\n   regardless\
    \ of how many channels are open on that session.  One reason\n   why this is important\
    \ is that it allows service provisioning, such as\n   quality of service (e.g.,\
    \ as in [34]) to be done on a per-user\n   granularity.\n"
- title: 5.5 Privacy
  contents:
  - "5.5 Privacy\n   We use SASL and TLS.  If you successfully complete a transport\n\
    \   security negotiation using a channel, then all traffic on that\n   session\
    \ is secured (i.e., confidentiality is per-session, not per-\n   channel, just\
    \ like authentication).\n   We defined a BXXP profile that's used to start the\
    \ TLS engine.\n"
- title: 5.6 Things We Left Out
  contents:
  - "5.6 Things We Left Out\n   We purposefully excluded two things that are common\
    \ to most\n   application protocols: naming and authorization.\n   Naming was\
    \ excluded from the framework because, outside of URIs,\n   there isn't a commonly\
    \ accepted framework for naming things.  To our\n   view, this remains a domain-specific\
    \ problem for each application\n   protocol.  Maybe URIs are appropriate in the\
    \ context of a\n   particularly problem domain, maybe not.  So, when an application\n\
    \   protocol designer defines their own profile to do \"the useful work\",\n \
    \  they'll have to deal with naming issues themselves.  BXXP provides a\n   mechanism\
    \ for identifying profiles and binding them to channels. It's\n   up to you to\
    \ define the profile and use the channel.\n   Similarly, authorization was explicitly\
    \ excluded from the framework.\n   Every approach to authorization we've seen\
    \ uses names to identify\n   principals (i.e., targets and subjects), so if a\
    \ framework doesn't\n   include naming, it can't very well include authorization.\n\
    \   Of course, application protocols do have to deal with naming and\n   authorization\
    \ -- those are two of the issues addressed by the\n   applications protocol designer\
    \ when defining a profile for use with\n   BXXP.\n"
- title: 5.7 From Framework to Protocol
  contents:
  - "5.7 From Framework to Protocol\n   So, how do you go about using BXXP? To begin,\
    \ call it \"BEEP\", not\n   \"BXXP\" (we'll explain why momentarily).\n   First,\
    \ get the BEEP core specification [35] and read it.  Next,\n   define your own\
    \ profile.  Finally, get one of the open source SDKs\n   (in C, Java, or Tcl)\
    \ and start coding.\n   The BEEP specification defines several profiles itself:\
    \ a channel\n   management profile, a family of profiles for SASL, and a transport\n\
    \   security profile.  In addition, there's a second specification [36]\n   that\
    \ explains how a BEEP session maps onto a single TCP connection.\n   For a complete\
    \ example of an application protocol defined using BEEP,\n   look at reliable\
    \ syslog [37].  This document exemplifies the formula:\n   application protocol\
    \ = BEEP + 1 or more profiles\n                        + authorization policies\n\
    \                        + provisioning rules (e.g., use of SRV RRs [38])\n"
- title: 6. BXXP is now BEEP
  contents:
  - "6. BXXP is now BEEP\n   We started work on BXXP in the fall of 1998.  The IETF\
    \ formed a\n   working group on BXXP in the summer of 2000.  Although the working\n\
    \   group made some enhancements to BXXP, three are the most notable:\n   o  The\
    \ payload default is \"application/octet-stream\".  This is\n      primarily for\
    \ wire-efficiency -- if you care about wire-\n      efficiency, then you probably\
    \ wouldn't be using \"text/xml\"...\n   o  One-to-many exchanges are supported\
    \ (the client sends one message\n      and the server sends back many replies).\n\
    \   o  BXXP is now called BEEP (more comic possibilities).\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   Consult Section [35]'s Section 8 for a discussion\
    \ of BEEP-related\n   security issues.\n"
- title: References
  contents:
  - "References\n   [1]   Postel, J., \"Simple Mail Transfer Protocol\", STD 10, RFC\
    \ 821,\n         August 1982.\n   [2]   Postel, J. and J. Reynolds, \"File Transfer\
    \ Protocol\", STD 9,\n         RFC 959, October 1985.\n   [3]   Berners-Lee, T.,\
    \ Fielding, R. and H. Nielsen, \"Hypertext\n         Transfer Protocol -- HTTP/1.0\"\
    , RFC 1945, May 1996.\n   [4]   Herriot, R., \"Internet Printing Protocol/1.0:\
    \ Encoding and\n         Transport\", RFC 2565, April 1999.\n   [5]   Freed, N.\
    \ and N. Borenstein, \"Multipurpose Internet Mail\n         Extensions (MIME)\
    \ Part One: Format of Internet Message Bodies\",\n         RFC 2045, November\
    \ 1996.\n   [6]   Fielding, R., Gettys, J., Mogul, J., Nielsen, H., Masinter,\
    \ L.,\n         Leach, P. and T. Berners-Lee, \"Hypertext Transfer Protocol --\n\
    \         HTTP/1.1\", RFC 2616, June 1999.\n   [7]   Postel, J., \"Transmission\
    \ Control Protocol\", STD 7, RFC 793,\n         September 1981.\n   [8]   Mockapetris,\
    \ P., \"Domain names - concepts and facilities\", STD\n         13, RFC 1034,\
    \ November 1987.\n   [9]   Microsystems, Sun., \"NFS: Network File System Protocol\n\
    \         specification\", RFC 1094, March 1989.\n   [10]  Srisuresh, P. and M.\
    \ Holdrege, \"IP Network Address Translator\n         (NAT) Terminology and Considerations\"\
    , RFC 2663, August 1999.\n   [11]  Crocker, D., \"Standard for the format of ARPA\
    \ Internet text\n         messages\", STD 11, RFC 822, August 1982.\n   [12] \
    \ Berners-Lee, T. and D. Connolly, \"Hypertext Markup Language -\n         2.0\"\
    , RFC 1866, November 1995.\n   [13]  Freed, N., \"SMTP Service Extension for Returning\
    \ Enhanced Error\n         Codes\", RFC 2034, October 1996.\n   [14]  Myers, J.,\
    \ \"IMAP4 Authentication Mechanisms\", RFC 1731,\n         December 1994.\n  \
    \ [15]  Freed, N., \"SMTP Service Extension for Command Pipelining\", RFC\n  \
    \       2197, September 1997.\n   [16]  Rescorla, E. and A. Schiffman, \"The Secure\
    \ HyperText Transfer\n         Protocol\", RFC 2660, August 1999.\n   [17]  Myers,\
    \ J., \"Simple Authentication and Security Layer (SASL)\",\n         RFC 2222,\
    \ October 1997.\n   [18]  Newman, C., \"The One-Time-Password SASL Mechanism\"\
    , RFC 2444,\n         October 1998.\n   [19]  Myers, J., \"SMTP Service Extension\
    \ for Authentication\", RFC\n         2554, March 1999.\n   [20]  Franks, J.,\
    \ Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n         Leach, P., Luotonen,\
    \ A. and L. Stewart, \"HTTP Authentication:\n         Basic and Digest Access\
    \ Authentication\", RFC 2617, June 1999.\n   [21]  Kent, S. and R. Atkinson, \"\
    Security Architecture for the\n         Internet Protocol\", RFC 2401, November\
    \ 1998.\n   [22]  Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC\n\
    \         2246, January 1999.\n   [23]  Newman, C. and J. Myers, \"ACAP -- Application\
    \ Configuration\n         Access Protocol\", RFC 2244, November 1997.\n   [24]\
    \  Hoffman, P., \"SMTP Service Extension for Secure SMTP over TLS\",\n       \
    \  RFC 2487, January 1999.\n   [25]  Newman, C., \"Using TLS with IMAP, POP3 and\
    \ ACAP\", RFC 2595,\n         June 1999.\n   [26]  Myers, J. and M. Rose, \"Post\
    \ Office Protocol - Version 3\", STD\n         53, RFC 1939, May 1996.\n   [27]\
    \  Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S.,\n         Estrin,\
    \ D., Floyd, S., Jacobson, V., Minshall, G., Partridge,\n         C., Peterson,\
    \ L., Ramakrishnan, K., Shenker, S., Wroclawski, J.\n         and L. Zhang, \"\
    Recommendations on Queue Management and\n         Congestion Avoidance in the\
    \ Internet\", RFC 2309, April 1998.\n   [28]  Touch, J., \"TCP Control Block Interdependence\"\
    , RFC 2140, April\n         1997.\n   [29]  Postel, J. and J. Reynolds, \"Telnet\
    \ Protocol Specification\",\n         STD 8, RFC 854, May 1983.\n   [30]  World\
    \ Wide Web Consortium, \"Extensible Markup Language (XML)\n         1.0\", W3C\
    \ XML, February 1998, <http://www.w3.org/TR/1998/REC-\n         xml-19980210>.\n\
    \   [31]  Case, J., Fedor, M., Schoffstall, M. and C. Davin, \"Simple\n      \
    \   Network Management Protocol (SNMP)\", STD 15, RFC 1157, May\n         1990.\n\
    \   [32]  World Wide Web Consortium, \"SMUX Protocol Specification\",\n      \
    \   Working Draft, July 1998, <http://www.w3.org/TR/1998/WD-mux-\n         19980710>.\n\
    \   [33]  Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform\n         Resource\
    \ Identifiers (URI): Generic Syntax\", RFC 2396, August\n         1998.\n   [34]\
    \  Waitzman, D., \"IP over Avian Carriers with Quality of Service\",\n       \
    \  RFC 2549, April 1999.\n   [35]  Rose, M., \"The Blocks Extensible Exchange\
    \ Protocol Core\", RFC\n         3080, March 2001.\n   [36]  Rose, M., \"Mapping\
    \ the BEEP Core onto TCP\", RFC 3081, March\n         2001.\n   [37]  New, D.\
    \ and M. Rose, \"Reliable Delivery for syslog\", RFC 3195,\n         November\
    \ 2001.\n   [38]  Gulbrandsen, A., Vixie, P. and L. Esibov, \"A DNS RR for\n \
    \        specifying the location of services (DNS SRV)\", RFC 2782,\n        \
    \ February 2000.\n   [39]  <http://mappa.mundi.net/cartography/Wheel/>\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Marshall T. Rose\n   Dover Beach Consulting, Inc.\n   POB\
    \ 255268\n   Sacramento, CA  95865-5268\n   US\n   Phone: +1 916 483 8878\n  \
    \ EMail: mrose@dbc.mtview.ca.us\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2001).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
