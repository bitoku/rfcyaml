- title: __initial_text__
  contents:
  - '                        Concise MIB Definitions

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines a format for producing MIB modules.\
    \  This RFC\n   specifies an IAB standards track document for the Internet community,\n\
    \   and requests discussion and suggestions for improvements.  Please\n   refer\
    \ to the current edition of the \"IAB Official Protocol Standards\"\n   for the\
    \ standardization state and status of this protocol.\n   Distribution of this\
    \ memo is unlimited.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Abstract..............................................\
    \    2\n   2. Historical Perspective ...............................    2\n  \
    \ 3. Columnar Objects .....................................    3\n   3.1 Row Deletion\
    \ ........................................    4\n   3.2 Row Addition ........................................\
    \    4\n   4. Defining Objects .....................................    5\n  \
    \ 4.1 Mapping of the OBJECT-TYPE macro ....................    7\n   4.1.1 Mapping\
    \ of the SYNTAX clause ......................    7\n   4.1.2 Mapping of the ACCESS\
    \ clause ......................    8\n   4.1.3 Mapping of the STATUS clause ......................\
    \    8\n   4.1.4 Mapping of the DESCRIPTION clause .................    8\n  \
    \ 4.1.5 Mapping of the REFERENCE clause ...................    8\n   4.1.6 Mapping\
    \ of the INDEX clause .......................    8\n   4.1.7 Mapping of the DEFVAL\
    \ clause ......................   10\n   4.1.8 Mapping of the OBJECT-TYPE value\
    \ ..................   11\n   4.2 Usage Example .......................................\
    \   11\n   5. Appendix: DE-osifying MIBs ...........................   13\n  \
    \ 5.1 Managed Object Mapping ..............................   14\n   5.1.1 Mapping\
    \ to the SYNTAX clause ......................   15\n   5.1.2 Mapping to the ACCESS\
    \ clause ......................   15\n   5.1.3 Mapping to the STATUS clause ......................\
    \   15\n   5.1.4 Mapping to the DESCRIPTION clause .................   15\n  \
    \ 5.1.5 Mapping to the REFERENCE clause ...................   16\n   5.1.6 Mapping\
    \ to the INDEX clause .......................   16\n   5.1.7 Mapping to the DEFVAL\
    \ clause ......................   16\n   5.2 Action Mapping ......................................\
    \   16\n   5.2.1 Mapping to the SYNTAX clause ......................   16\n  \
    \ 5.2.2 Mapping to the ACCESS clause ......................   16\n   5.2.3 Mapping\
    \ to the STATUS clause ......................   16\n   5.2.4 Mapping to the DESCRIPTION\
    \ clause .................   16\n   5.2.5 Mapping to the REFERENCE clause ...................\
    \   16\n   6. Acknowledgements .....................................   17\n  \
    \ 7. References ...........................................   18\n   8. Security\
    \ Considerations...............................   19\n   9. Authors' Addresses....................................\
    \   19\n"
- title: 1.  Abstract
  contents:
  - "1.  Abstract\n   This memo describes a straight-forward approach toward producing\n\
    \   concise, yet descriptive, MIB modules.  It is intended that all\n   future\
    \ MIB modules be written in this format.\n"
- title: 2.  Historical Perspective
  contents:
  - "2.  Historical Perspective\n   As reported in RFC 1052, IAB Recommendations for\
    \ the Development of\n   Internet Network Management Standards [1], a two-prong\
    \ strategy for\n   network management of TCP/IP-based internets was undertaken.\
    \  In the\n   short-term, the Simple Network Management Protocol (SNMP), defined\
    \ in\n   RFC 1067, was to be used to manage nodes in the Internet community.\n\
    \   In the long-term, the use of the OSI network management framework was\n  \
    \ to be examined.  Two documents were produced to define the management\n   information:\
    \ RFC 1065, which defined the Structure of Management\n   Information (SMI), and\
    \ RFC 1066, which defined the Management\n   Information Base (MIB).  Both of\
    \ these documents were designed so as\n   to be compatible with both the SNMP\
    \ and the OSI network management\n   framework.\n   This strategy was quite successful\
    \ in the short-term: Internet-based\n   network management technology was fielded,\
    \ by both the research and\n   commercial communities, within a few months.  As\
    \ a result of this,\n   portions of the Internet community became network manageable\
    \ in a\n   timely fashion.\n   As reported in RFC 1109, Report of the Second Ad\
    \ Hoc Network\n   Management Review Group [2], the requirements of the SNMP and\
    \ the OSI\n   network management frameworks were more different than anticipated.\n\
    \   As such, the requirement for compatibility between the SMI/MIB and\n   both\
    \ frameworks was suspended.  This action permitted the operational\n   network\
    \ management framework, based on the SNMP, to respond to new\n   operational needs\
    \ in the Internet community by producing MIB-II.\n   In May of 1990, the core\
    \ documents were elevated to \"Standard\n   Protocols\" with \"Recommended\" status.\
    \  As such, the Internet-standard\n   network management framework consists of:\
    \ Structure and\n   Identification of Management Information for TCP/IP-based\
    \ internets,\n   RFC 1155 [3], which describes how managed objects contained in\
    \ the\n   MIB are defined; Management Information Base for Network Management\n\
    \   of TCP/IP-based internets, which describes the managed objects\n   contained\
    \ in the MIB, RFC 1156 [4]; and, the Simple Network\n   Management Protocol, RFC\
    \ 1157 [5], which defines the protocol used to\n   manage these objects.  Consistent\
    \ with the IAB directive to produce\n   simple, workable systems in the short-term,\
    \ the list of managed\n   objects defined in the Internet-standard MIB was derived\
    \ by taking\n   only those elements which are considered essential.  However,\
    \ the SMI\n   defined three extensibility mechanisms: one, the addition of new\n\
    \   standard objects through the definitions of new versions of the MIB;\n   two,\
    \ the addition of widely-available but non-standard objects\n   through the experimental\
    \ subtree; and three, the addition of private\n   objects through the enterprises\
    \ subtree.  Such additional objects can\n   not only be used for vendor-specific\
    \ elements, but also for\n   experimentation as required to further the knowledge\
    \ of which other\n   objects are essential.\n   As more objects are defined using\
    \ the second method, experience has\n   shown that the resulting MIB descriptions\
    \ contain redundant\n   information.  In order to provide for MIB descriptions\
    \ which are more\n   concise, and yet as informative, an enhancement is suggested.\
    \  This\n   enhancement allows the author of a MIB to remove the redundant\n \
    \  information, while retaining the important descriptive text.\n   Before presenting\
    \ the approach, a brief presentation of columnar\n   object handling by the SNMP\
    \ is necessary.  This explains and further\n   motivates the value of the enhancement.\n"
- title: 3.  Columnar Objects
  contents:
  - "3.  Columnar Objects\n   The SNMP supports operations on MIB objects whose syntax\
    \ is\n   ObjectSyntax as defined in the SMI.  Informally stated, SNMP\n   operations\
    \ apply exclusively to scalar objects.  However, it is\n   convenient for developers\
    \ of management applications to impose\n   imaginary, tabular structures on the\
    \ ordered collection of objects\n   that constitute the MIB.  Each such conceptual\
    \ table contains zero or\n   more rows, and each row may contain one or more scalar\
    \ objects,\n   termed columnar objects.  Historically, this conceptualization\
    \ has\n   been formalized by using the OBJECT-TYPE macro to define both an\n \
    \  object which corresponds to a table and an object which corresponds\n   to\
    \ a row in that table.  (The ACCESS clause for such objects is\n   \"not-accessible\"\
    , of course.) However, it must be emphasized that, at\n   the protocol level,\
    \ relationships among columnar objects in the same\n   row is a matter of convention,\
    \ not of protocol.\n   Note that there are good reasons why the tabular structure\
    \ is not a\n   matter of protocol.  Consider the operation of the SNMP Get-Next-PDU\n\
    \   acting on the last columnar object of an instance of a conceptual\n   row;\
    \ it returns the next column of the first conceptual row or the\n   first object\
    \ instance occurring after the table.  In contrast, if the\n   rows were a matter\
    \ of protocol, then it would instead return an\n   error.  By not returning an\
    \ error, a single PDU exchange informs the\n   manager that not only has the end\
    \ of the conceptual row/table been\n   reached, but also provides information\
    \ on the next object instance,\n   thereby increasing the information density\
    \ of the PDU exchange.\n"
- title: 3.1.  Row Deletion
  contents:
  - "3.1.  Row Deletion\n   Nonetheless, it is highly useful to provide a means whereby\
    \ a\n   conceptual row may be removed from a table. In MIB-II, this was\n   achieved\
    \ by defining, for each conceptual row, an integer-valued\n   columnar object.\
    \  If a management station sets the value of this\n   object to some value, usually\
    \ termed \"invalid\", then the effect is\n   one of invalidating the corresponding\
    \ row in the table.  However, it\n   is an implementation-specific matter as to\
    \ whether an agent removes\n   an invalidated entry from the table.  Accordingly,\
    \ management\n   stations must be prepared to receive tabular information from\
    \ agents\n   that corresponds to entries not currently in use.  Proper\n   interpretation\
    \ of such entries requires examination of the columnar\n   object indicating the\
    \ in-use status.\n"
- title: 3.2.  Row Addition
  contents:
  - "3.2.  Row Addition\n   It is also highly useful to have a clear understanding\
    \ of how a\n   conceptual row may be added to a table.  In the SNMP, at the protocol\n\
    \   level, a management station issues an SNMP set operation containing\n   an\
    \ arbitrary set of variable bindings.  In the case that an agent\n   detects that\
    \ one or more of those variable bindings refers to an\n   object instance not\
    \ currently available in that agent, it may,\n   according to the rules of the\
    \ SNMP, behave according to any of the\n   following paradigms:\n          (1)\
    \  It may reject the SNMP set operation as referring to\n               non-existent\
    \ object instances by returning a response\n               with the error-status\
    \ field set to \"noSuchName\" and the\n               error-index field set to\
    \ refer to the first vacuous\n               reference.\n          (2)  It may\
    \ accept the SNMP set operation as requesting the\n               creation  of\
    \ new object instances corresponding to each\n               of the object instances\
    \ named in the variable bindings.\n               The value of each (potentially)\
    \ newly created object\n               instance is specified by the \"value\"\
    \ component of the\n               relevant variable binding.  In this case, if\
    \ the request\n               specifies a value for a newly (or previously) created\n\
    \               object that it deems inappropriate by reason of value or\n   \
    \            syntax, then it rejects the SNMP set operation by\n             \
    \  responding with the error-status field set to badValue\n               and\
    \ the error-index field set to refer to the first\n               offending variable\
    \ binding.\n          (3)  It may accept the SNMP set operation and create new\n\
    \               object instances as described in (2) above and, in\n         \
    \      addition, at its discretion, create supplemental object\n             \
    \  instances to complete a row in a conceptual table of\n               which\
    \ the new object instances specified in the request\n               may be a part.\n\
    \   It should be emphasized that all three of the above behaviors are\n   fully\
    \ conformant to the SNMP specification and are fully acceptable,\n   subject to\
    \ any restrictions which may be imposed by access control\n   and/or the definitions\
    \ of the MIB objects themselves.\n"
- title: 4.  Defining Objects
  contents:
  - "4.  Defining Objects\n   The Internet-standard SMI employs a two-level approach\
    \ towards object\n   definition.  A MIB definition consists of two parts: a textual\
    \ part,\n   in which objects are placed into groups, and a MIB module, in which\n\
    \   objects are described solely in terms of the ASN.1 macro OBJECT-TYPE,\n  \
    \ which is defined by the SMI.\n   An example of the former definition might be:\n\
    \          OBJECT:\n          -------\n               sysLocation { system 6 }\n\
    \          Syntax:\n               DisplayString (SIZE (0..255))\n          Definition:\n\
    \               The physical location of this node (e.g., \"telephone\n      \
    \         closet, 3rd floor\").\n          Access:\n               read-only.\n\
    \          Status:\n               mandatory.\n          An example of the latter\
    \ definition might be:\n               sysLocation OBJECT-TYPE\n             \
    \      SYNTAX  DisplayString (SIZE (0..255))\n                   ACCESS  read-only\n\
    \                   STATUS  mandatory\n                   ::= { system 6 }\n \
    \         In the interests of brevity and to reduce the chance of\n          editing\
    \ errors, it would seem useful to combine the two\n          definitions.  This\
    \ can be accomplished by defining an\n          extension to the OBJECT-TYPE macro:\n\
    \          IMPORTS\n              ObjectName\n                  FROM RFC1155-SMI\n\
    \              DisplayString\n                  FROM RFC1158-MIB;\n          OBJECT-TYPE\
    \ MACRO ::=\n          BEGIN\n              TYPE NOTATION ::=\n              \
    \                            -- must conform to\n                            \
    \              -- RFC1155's ObjectSyntax\n                                \"SYNTAX\"\
    \ type(ObjectSyntax)\n                                \"ACCESS\" Access\n    \
    \                            \"STATUS\" Status\n                             \
    \   DescrPart\n                                ReferPart\n                   \
    \             IndexPart\n                                DefValPart\n        \
    \      VALUE NOTATION ::= value (VALUE ObjectName)\n              Access ::= \"\
    read-only\"\n                              | \"read-write\"\n                \
    \              | \"write-only\"\n                              | \"not-accessible\"\
    \n              Status ::= \"mandatory\"\n                              | \"optional\"\
    \n                              | \"obsolete\"\n                             \
    \ | \"deprecated\"\n              DescrPart ::=\n                         \"DESCRIPTION\"\
    \ value (description DisplayString)\n                              | empty\n \
    \             ReferPart ::=\n                         \"REFERENCE\" value (reference\
    \ DisplayString)\n                              | empty\n              IndexPart\
    \ ::=\n                         \"INDEX\" \"{\" IndexTypes \"}\"\n           \
    \                   | empty\n              IndexTypes ::=\n                  \
    \       IndexType | IndexTypes \",\" IndexType\n              IndexType ::=\n\
    \                                  -- if indexobject, use the SYNTAX\n       \
    \                           -- value of the correspondent\n                  \
    \                -- OBJECT-TYPE invocation\n                         value (indexobject\
    \ ObjectName)\n                                  -- otherwise use named SMI type\n\
    \                                  -- must conform to IndexSyntax below\n    \
    \                          | type (indextype)\n              DefValPart ::=\n\
    \                         \"DEFVAL\" \"{\" value (defvalue ObjectSyntax) \"}\"\
    \n                              | empty\n          END\n          IndexSyntax\
    \ ::=\n              CHOICE {\n                  number\n                    \
    \  INTEGER (0..MAX),\n                  string\n                      OCTET STRING,\n\
    \                  object\n                      OBJECT IDENTIFIER,\n        \
    \          address\n                      NetworkAddress,\n                  ipAddress\n\
    \                      IpAddress\n              }\n"
- title: 4.1.  Mapping of the OBJECT-TYPE macro
  contents:
  - "4.1.  Mapping of the OBJECT-TYPE macro\n   It should be noted that the expansion\
    \ of the OBJECT-TYPE macro is\n   something which conceptually happens during\
    \ implementation and not\n   during run-time.\n"
- title: 4.1.1.  Mapping of the SYNTAX clause
  contents:
  - "4.1.1.  Mapping of the SYNTAX clause\n   The SYNTAX clause, which must be present,\
    \ defines the abstract data\n   structure corresponding to that object type. \
    \ The ASN.1 language [6]\n   is used for this purpose.  However, the SMI purposely\
    \ restricts the\n   ASN.1 constructs which may be used.  These restrictions are\
    \ made\n   expressly for simplicity.\n"
- title: 4.1.2.  Mapping of the ACCESS clause
  contents:
  - "4.1.2.  Mapping of the ACCESS clause\n   The ACCESS clause, which must be present,\
    \ defines the minimum level\n   of support required for that object type.  As\
    \ a local matter,\n   implementations may support other access types (e.g., an\n\
    \   implementation may elect to permitting writing a variable marked as\n   read-only).\
    \  Further, protocol-specific \"views\" (e.g., those\n   indirectly implied by\
    \ an SNMP community) may make further\n   restrictions on access to a variable.\n"
- title: 4.1.3.  Mapping of the STATUS clause
  contents:
  - "4.1.3.  Mapping of the STATUS clause\n   The STATUS clause, which must be present,\
    \ defines the implementation\n   support required for that object type.\n"
- title: 4.1.4.  Mapping of the DESCRIPTION clause
  contents:
  - "4.1.4.  Mapping of the DESCRIPTION clause\n   The DESCRIPTION clause, which need\
    \ not be present, contains a textual\n   definition of that object type which\
    \ provides all semantic\n   definitions necessary for implementation, and should\
    \ embody any\n   information which would otherwise be communicated in any ASN.1\n\
    \   commentary annotations associated with the object.  Note that, in\n   order\
    \ to conform to the ASN.1 syntax, the entire value of this clause\n   must be\
    \ enclosed in double quotation marks, although the value may be\n   multi-line.\n\
    \   Further, note that if the MIB module does not contain a textual\n   description\
    \ of the object type elsewhere then the DESCRIPTION clause\n   must be present.\n"
- title: 4.1.5.  Mapping of the REFERENCE clause
  contents:
  - "4.1.5.  Mapping of the REFERENCE clause\n   The REFERENCE clause, which need\
    \ not be present, contains a textual\n   cross-reference to an object defined\
    \ in some other MIB module.  This\n   is useful when de-osifying a MIB produced\
    \ by some other organization.\n"
- title: 4.1.6.  Mapping of the INDEX clause
  contents:
  - "4.1.6.  Mapping of the INDEX clause\n   The INDEX clause, which may be present\
    \ only if that object type\n   corresponds to a conceptual row, defines instance\
    \ identification\n   information for that object type.  (Historically, each MIB\
    \ definition\n   contained a section entitled \"Identification of OBJECT instances\
    \ for\n   use with the SNMP\".  By using the INDEX clause, this section need no\n\
    \   longer occur as this clause concisely captures the precise semantics\n   needed\
    \ for instance identification.)\n   If the INDEX clause is not present, and the\
    \ object type corresponds\n   to a non-columnar object, then instances of the\
    \ object are identified\n   by appending a sub-identifier of zero to the name\
    \ of that object.\n   Further, note that if the MIB module does not contain a\
    \ textual\n   description of how instance identification information is derived\
    \ for\n   columnar objects, then the INDEX clause must be present.\n   To define\
    \ the instance identification information, determine which\n   object value(s)\
    \ will unambiguously distinguish a conceptual row.  The\n   syntax of those objects\
    \ indicate how to form the instance-identifier:\n          (1)  integer-valued:\
    \ a single sub-identifier taking the\n               integer value (this works\
    \ only for non-negative\n               integers);\n          (2)  string-valued,\
    \ fixed-length strings: `n' sub-identifiers,\n               where `n' is the\
    \ length of the string (each octet of the\n               string is encoded in\
    \ a separate sub-identifier);\n          (3)  string-valued, variable-length strings:\
    \ `n+1' sub-\n               identifiers, where `n' is the length of the string\
    \ (the\n               first sub-identifier is `n' itself, following this, each\n\
    \               octet of the string is encoded in a separate sub-\n          \
    \     identifier);\n          (4)  object identifier-valued: `n+1' sub-identifiers,\
    \ where\n               `n' is the number of sub-identifiers in the value (the\n\
    \               first sub-identifier is `n' itself, following this, each\n   \
    \            sub-identifier in the value is copied);\n          (5)  NetworkAddress-valued:\
    \ `n+1' sub-identifiers, where `n'\n               depends on the kind of address\
    \ being encoded (the first\n               sub-identifier indicates the kind of\
    \ address, value 1\n               indicates an IpAddress); or,\n          (6)\
    \  IpAddress-valued: 4 sub-identifiers, in the familiar\n               a.b.c.d\
    \ notation.\n   Note that if an \"indextype\" value is present (e.g., INTEGER\
    \ rather\n   than ifIndex), then a DESCRIPTION clause must be present; the text\n\
    \   contained therein indicates the semantics of the \"indextype\" value.\n  \
    \ By way of example, in the context of MIB-II [7], the following INDEX\n   clauses\
    \ might be present:\n                 objects under         INDEX clause\n   \
    \            -----------------       ------------\n               ifEntry    \
    \             { ifIndex }\n               atEntry                 { atNetIfIndex,\n\
    \                                         atNetAddress }\n               ipAddrEntry\
    \             { ipAdEntAddr }\n               ipRouteEntry            { ipRouteDest\
    \ }\n               ipNetToMediaEntry       { ipNetToMediaIfIndex,\n         \
    \                                ipNetToMediaNetAddress }\n               tcpConnEntry\
    \            { tcpConnLocalAddress,\n                                        \
    \ tcpConnLocalPort,\n                                         tcpConnRemoteAddress,\n\
    \                                         tcpConnRemotePort }\n              \
    \ udpEntry                { udpLocalAddress,\n                               \
    \          udpLocalPort }\n               egpNeighEntry           { egpNeighAddr\
    \ }\n"
- title: 4.1.7.  Mapping of the DEFVAL clause
  contents:
  - "4.1.7.  Mapping of the DEFVAL clause\n   The DEFVAL clause, which need not be\
    \ present, defines an acceptable\n   default value which may be used when an object\
    \ instance is created at\n   the discretion of the agent acting in conformance\
    \ with the third\n   paradigm described in Section 4.2 above.\n   During conceptual\
    \ row creation, if an instance of a columnar object\n   is not present as one\
    \ of the operands in the correspondent SNMP set\n   operation, then the value\
    \ of the DEFVAL clause, if present, indicates\n   an acceptable default value\
    \ that the agent might use.\n   The value of the DEFVAL clause must, of course,\
    \ correspond to the\n   SYNTAX clause for the object.  Note that if an operand\
    \ to the SNMP\n   set operation is an instance of a read-only object, then the\
    \ error\n   noSuchName will be returned.  As such, the DEFVAL clause can be used\n\
    \   to provide an acceptable default value that the agent might use.\n   It is\
    \ possible that no acceptable default value may exist for any of\n   the columnar\
    \ objects in a conceptual row for which the creation of\n   new object instances\
    \ is allowed.  In this case, the objects specified\n   in the INDEX clause must\
    \ have a corresponding ACCESS clause value of\n   read-write.\n   By way of example,\
    \ consider the following possible DEFVAL clauses:\n       ObjectSyntax       \
    \     DEFVAL clause\n       -----------------       ------------\n       INTEGER\
    \                 1 -- same for Counter, Gauge, TimeTicks\n       OCTET STRING\
    \            'ffffffffffff'h\n       DisplayString           \"any NVT ASCII string\"\
    \n       OBJECT IDENTIFIER       sysDescr\n       OBJECT IDENTIFIER       { system\
    \ 2 }\n       NULL                    NULL\n       NetworkAddress          { internet\
    \ 'c0210415'h }\n       IpAddress               'c0210415'h -- 192.33.4.21\n"
- title: 4.1.8.  Mapping of the OBJECT-TYPE value
  contents:
  - "4.1.8.  Mapping of the OBJECT-TYPE value\n   The value of an invocation of the\
    \ OBJECT-TYPE macro is the name of\n   the object, which is an object identifier.\n"
- title: 4.2.  Usage Example
  contents:
  - "4.2.  Usage Example\n   Consider how the ipNetToMediaTable from MIB-II might\
    \ be fully\n   described:\n          -- the IP Address Translation tables\n  \
    \        -- The Address Translation tables contain IpAddress to\n          --\
    \ \"physical\" address equivalences.  Some interfaces do not\n          -- use\
    \ translation tables for determining address equivalences\n          -- (e.g.,\
    \ DDN-X.25 has an algorithmic method); if all\n          -- interfaces are of\
    \ this type, then the Address Translation\n          -- table is empty, i.e.,\
    \ has zero entries.\n          ipNetToMediaTable OBJECT-TYPE\n              SYNTAX\
    \  SEQUENCE OF IpNetToMediaEntry\n              ACCESS  not-accessible\n     \
    \         STATUS  mandatory\n              DESCRIPTION\n                     \
    \ \"The IP Address Translation table used for mapping\n                      from\
    \ IP addresses to physical addresses.\"\n              ::= { ip 22 }\n       \
    \   ipNetToMediaEntry OBJECT-TYPE\n              SYNTAX  IpNetToMediaEntry\n \
    \             ACCESS  not-accessible\n              STATUS  mandatory\n      \
    \        DESCRIPTION\n                      \"Each entry contains one IpAddress\
    \ to 'physical'\n                      address equivalence.\"\n              INDEX\
    \   { ipNetToMediaIfIndex,\n                        ipNetToMediaNetAddress }\n\
    \              ::= { ipNetToMediaTable 1 }\n          IpNetToMediaEntry ::=\n\
    \              SEQUENCE {\n                  ipNetToMediaIfIndex\n           \
    \           INTEGER,\n                  ipNetToMediaPhysAddress\n            \
    \          OCTET STRING,\n                  ipNetToMediaNetAddress\n         \
    \             IpAddress,\n                  ipNetoToMediaType\n              \
    \        INTEGER\n              }\n          ipNetToMediaIfIndex OBJECT-TYPE\n\
    \              SYNTAX  INTEGER\n              ACCESS  read-write\n           \
    \   STATUS  mandatory\n              DESCRIPTION\n                      \"The\
    \ interface on which this entry's equivalence\n                      is effective.\
    \  The interface identified by a\n                      particular value of this\
    \ index is the same\n                      interface as identified by the same\
    \ value of\n                      ifIndex.\"\n              ::= { ipNetToMediaEntry\
    \ 1 }\n          ipNetToMediaPhysAddress OBJECT-TYPE\n              SYNTAX  OCTET\
    \ STRING\n              ACCESS  read-write\n              STATUS  mandatory\n\
    \              DESCRIPTION\n                      \"The media-dependent 'physical'\
    \ address.\"\n              ::= { ipNetToMediaEntry 2 }\n          ipNetToMediaNetAddress\
    \ OBJECT-TYPE\n              SYNTAX  IpAddress\n              ACCESS  read-write\n\
    \              STATUS  mandatory\n              DESCRIPTION\n                \
    \      \"The IpAddress corresponding to the media-\n                      dependent\
    \ 'physical' address.\"\n              ::= { ipNetToMediaEntry 3 }\n         \
    \ ipNetToMediaType OBJECT-TYPE\n              SYNTAX  INTEGER {\n            \
    \              other(1),   -- none of the following\n                        \
    \  invalid(2), -- an invalidated mapping\n                          dynamic(3),\n\
    \                          static(4)\n                      }\n              ACCESS\
    \  read-write\n              STATUS  mandatory\n              DESCRIPTION\n  \
    \                    \"The type of mapping.\n                      Setting this\
    \ object to the value invalid(2) has\n                      the effect of invalidating\
    \ the corresponding entry\n                      in the ipNetToMediaTable.  That\
    \ is, it effectively\n                      disassociates the interface identified\
    \ with said\n                      entry from the mapping identified with said\
    \ entry.\n                      It is an implementation-specific matter as to\n\
    \                      whether the agent removes an invalidated entry\n      \
    \                from the table.  Accordingly, management stations\n         \
    \             must be prepared to receive tabular information\n              \
    \        from agents that corresponds to entries not\n                      currently\
    \ in use.  Proper interpretation of such\n                      entries requires\
    \ examination of the relevant\n                      ipNetToMediaType object.\"\
    \n                  ::= { ipNetToMediaEntry 4 }\n"
- title: '5.  Appendix: DE-osifying MIBs'
  contents:
  - "5.  Appendix: DE-osifying MIBs\n   There has been an increasing amount of work\
    \ recently on taking MIBs\n   defined by other organizations (e.g., the IEEE)\
    \ and de-osifying them\n   for use with the Internet-standard network management\
    \ framework.  The\n   steps to achieve this are straight-forward, though tedious.\
    \  Of\n   course, it is helpful to already be experienced in writing MIB\n   modules\
    \ for use with the Internet-standard network management\n   framework.\n   The\
    \ first step is to construct a skeletal MIB module, e.g.,\n               RFC1213-MIB\
    \ DEFINITIONS ::= BEGIN\n               IMPORTS\n                       experimental,\
    \ OBJECT-TYPE, Counter\n                           FROM RFC1155-SMI;\n       \
    \                -- contact IANA for actual number\n               root    OBJECT\
    \ IDENTIFIER ::= { experimental xx }\n               END\n   The next step is\
    \ to categorize the objects into groups.  For\n   experimental MIBs, optional\
    \ objects are permitted.  However, when a\n   MIB module is placed in the Internet-standard\
    \ space, these optional\n   objects are either removed, or placed in a optional\
    \ group, which, if\n   implemented, all objects in the group must be implemented.\
    \  For the\n   first pass, it is wisest to simply ignore any optional objects\
    \ in the\n   original MIB: experience shows it is better to define a core MIB\n\
    \   module first, containing only essential objects; later, if experience\n  \
    \ demands, other objects can be added.\n   It must be emphasized that groups are\
    \ \"units of conformance\" within a\n   MIB: everything in a group is \"mandatory\"\
    \ and implementations do\n   either whole groups or none.\n"
- title: 5.1.  Managed Object Mapping
  contents:
  - "5.1.  Managed Object Mapping\n   Next for each managed object class, determine\
    \ whether there can exist\n   multiple instances of that managed object class.\
    \  If not, then for\n   each of its attributes, use the OBJECT-TYPE macro to make\
    \ an\n   equivalent definition.\n   Otherwise, if multiple instances of the managed\
    \ object class can\n   exist, then define a conceptual table having conceptual\
    \ rows each\n   containing a columnar object for each of the managed object class's\n\
    \   attributes. If the managed object class is contained within the\n   containment\
    \ tree of another managed object class, then the assignment\n   of an object type\
    \ is normally required for each of the \"distinguished\n   attributes\" of the\
    \ containing managed object class.  If they do not\n   already exist within the\
    \ MIB module, then they can be added via the\n   definition of additional columnar\
    \ objects in the conceptual row\n   corresponding to the contained managed object\
    \ class.\n   In defining a conceptual row, it is useful to consider the\n   optimization\
    \ of network management operations which will act upon its\n   columnar objects.\
    \  In particular, it is wisest to avoid defining more\n   columnar objects within\
    \ a conceptual row, than can fit in a single\n   PDU.  As a rule of thumb, a conceptual\
    \ row should contain no more\n   than approximately 20 objects.  Similarly, or\
    \ as a way to abide by\n   the \"20 object guideline\", columnar objects should\
    \ be grouped into\n   tables according to the expected grouping of network management\n\
    \   operations upon them.  As such, the content of conceptual rows should\n  \
    \ reflect typical access scenarios, e.g., they should be organized\n   along functional\
    \ lines such as one row for statistics and another row\n   for parameters, or\
    \ along usage lines such as commonly-needed objects\n   versus rarely-needed objects.\n\
    \   On the other hand, the definition of conceptual rows where the number\n  \
    \ of columnar objects used as indexes outnumbers the number used to\n   hold information,\
    \ should also be avoided.  In particular, the\n   splitting of a managed object\
    \ class's attributes into many conceptual\n   tables should not be used as a way\
    \ to obtain the same degree of\n   flexibility/complexity as is often found in\
    \ MIB's with a myriad of\n   optionals.\n"
- title: 5.1.1.  Mapping to the SYNTAX clause
  contents:
  - "5.1.1.  Mapping to the SYNTAX clause\n   When mapping to the SYNTAX clause of\
    \ the OBJECT-type macro:\n          (1)  An object with BOOLEAN syntax becomes\
    \ an INTEGER taking\n               either of values true(1) or false(2).\n  \
    \        (2)  An object with ENUMERATED syntax becomes an INTEGER,\n         \
    \      taking any of the values given.\n          (3)  An object with BIT STRING\
    \ syntax containing no more than\n               32 bits becomes an INTEGER defined\
    \ as a sum; otherwise if\n               more than 32 bits are present, the object\
    \ becomes an\n               OCTET STRING, with the bits numbered from left-to-right,\n\
    \               in which the least significant bits of the last octet may\n  \
    \             be \"reserved for future use\".\n          (4)  An object with a\
    \ character string syntax becomes either\n               an OCTET STRING or a\
    \ DisplayString, depending on the\n               repertoire of the character\
    \ string.\n          (5)  An non-tabular object with a complex syntax, such as\
    \ REAL\n               or EXTERNAL, must be decomposed, usually into an OCTET\n\
    \               STRING (if sensible).  As a rule, any object with a\n        \
    \       complicated syntax should be avoided.\n          (6)  Tabular objects\
    \ must be decomposed into rows of columnar\n               objects.\n"
- title: 5.1.2.  Mapping to the ACCESS clause
  contents:
  - "5.1.2.  Mapping to the ACCESS clause\n   This is straight-forward.\n"
- title: 5.1.3.  Mapping to the STATUS clause
  contents:
  - "5.1.3.  Mapping to the STATUS clause\n   This is usually straight-forward; however,\
    \ some osified-MIBs use the\n   term \"recommended\".  In this case, a choice\
    \ must be made between\n   \"mandatory\" and \"optional\".\n"
- title: 5.1.4.  Mapping to the DESCRIPTION clause
  contents:
  - "5.1.4.  Mapping to the DESCRIPTION clause\n   This is straight-forward: simply\
    \ copy the text, making sure that any\n   embedded double quotation marks are\
    \ sanitized (i.e., replaced with\n   single-quotes or removed).\n"
- title: 5.1.5.  Mapping to the REFERENCE clause
  contents:
  - "5.1.5.  Mapping to the REFERENCE clause\n   This is straight-forward: simply\
    \ include a textual reference to the\n   object being mapped, the document which\
    \ defines the object, and\n   perhaps a page number in the document.\n"
- title: 5.1.6.  Mapping to the INDEX clause
  contents:
  - "5.1.6.  Mapping to the INDEX clause\n   Decide how instance-identifiers for columnar\
    \ objects are to be formed\n   and define this clause accordingly.\n"
- title: 5.1.7.  Mapping to the DEFVAL clause
  contents:
  - "5.1.7.  Mapping to the DEFVAL clause\n   Decide if a meaningful default value\
    \ can be assigned to the object\n   being mapped, and if so, define the DEFVAL\
    \ clause accordingly.\n"
- title: 5.2.  Action Mapping
  contents:
  - "5.2.  Action Mapping\n   Actions are modeled as read-write objects, in which\
    \ writing a\n   particular value results in the action taking place.\n"
- title: 5.2.1.  Mapping to the SYNTAX clause
  contents:
  - "5.2.1.  Mapping to the SYNTAX clause\n   Usually an INTEGER syntax is used with\
    \ a distinguished value provided\n   for each action that the object provides\
    \ access to.  In addition,\n   there is usually one other distinguished value,\
    \ which is the one\n   returned when the object is read.\n"
- title: 5.2.2.  Mapping to the ACCESS clause
  contents:
  - "5.2.2.  Mapping to the ACCESS clause\n   Always use read-write.\n"
- title: 5.2.3.  Mapping to the STATUS clause
  contents:
  - "5.2.3.  Mapping to the STATUS clause\n   This is straight-forward.\n"
- title: 5.2.4.  Mapping to the DESCRIPTION clause
  contents:
  - "5.2.4.  Mapping to the DESCRIPTION clause\n   This is straight-forward: simply\
    \ copy the text, making sure that any\n   embedded double quotation marks are\
    \ sanitized (i.e., replaced with\n   single-quotes or removed).\n"
- title: 5.2.5.  Mapping to the REFERENCE clause
  contents:
  - "5.2.5.  Mapping to the REFERENCE clause\n   This is straight-forward: simply\
    \ include a textual reference to the\n   action being mapped, the document which\
    \ defines the action, and\n   perhaps a page number in the document.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   This document was produced by the SNMP Working Group:\n\
    \               Anne Ambler, Spider\n               Karl Auerbach, Sun\n     \
    \          Fred Baker, ACC\n               Ken Brinkerhoff\n               Ron\
    \ Broersma, NOSC\n               Jack Brown, US Army\n               Theodore\
    \ Brunner, Bellcore\n               Jeffrey Buffum, HP\n               John Burress,\
    \ Wellfleet\n               Jeffrey D. Case, University of Tennessee at Knoxville\n\
    \               Chris Chiptasso, Spartacus\n               Paul Ciarfella, DEC\n\
    \               Bob Collet\n               John Cook, Chipcom\n              \
    \ Tracy Cox, Bellcore\n               James R. Davin, MIT-LCS\n              \
    \ Eric Decker, cisco\n               Kurt Dobbins, Cabletron\n               Nadya\
    \ El-Afandi, Network Systems\n               Gary Ellis, HP\n               Fred\
    \ Engle\n               Mike Erlinger\n               Mark S. Fedor, PSI\n   \
    \            Richard Fox, Synoptics\n               Karen Frisa, CMU\n       \
    \        Chris Gunner, DEC\n               Fred Harris, University of Tennessee\
    \ at Knoxville\n               Ken Hibbard, Xylogics\n               Ole Jacobsen,\
    \ Interop\n               Ken Jones\n               Satish Joshi, Synoptics\n\
    \               Frank Kastenholz, Racal-Interlan\n               Shimshon Kaufman,\
    \ Spartacus\n               Ken Key, University of Tennessee at Knoxville\n  \
    \             Jim Kinder, Fibercom\n               Alex Koifman, BBN\n       \
    \        Christopher Kolb, PSI\n               Cheryl Krupczak, NCR\n        \
    \       Paul Langille, DEC\n               Peter Lin, Vitalink\n             \
    \  John Lunny, TWG\n               Carl Malamud\n               Randy Mayhew,\
    \ University of Tennessee at Knoxville\n               Keith McCloghrie, Hughes\
    \ LAN Systems\n               Donna McMaster, David Systems\n               Lynn\
    \ Monsanto, Sun\n               Dave Perkins, 3COM\n               Jim Reinstedler,\
    \ Ungerman Bass\n               Anil Rijsinghani, DEC\n               Kathy Rinehart,\
    \ Arnold AFB\n               Kary Robertson\n               Marshall T. Rose,\
    \ PSI (chair)\n               L. Michael Sabo, NCSC\n               Jon Saperia,\
    \ DEC\n               Greg Satz, cisco\n               Martin Schoffstall, PSI\n\
    \               John Seligson\n               Steve Sherry, Xyplex\n         \
    \      Fei Shu, NEC\n               Sam Sjogren, TGV\n               Mark Sleeper,\
    \ Sparta\n               Lance Sprung\n               Mike St.Johns\n        \
    \       Bob Stewart, Xyplex\n               Emil Sturniold\n               Kaj\
    \ Tesink, Bellcore\n               Dean Throop, Data General\n               Bill\
    \ Townsend, Xylogics\n               Maurice Turcotte, Racal-Milgo\n         \
    \      Kannan Varadhou\n               Sudhanshu Verma, HP\n               Bill\
    \ Versteeg, Network Research Corporation\n               Warren Vik, Interactive\
    \ Systems\n               David Waitzman, BBN\n               Steve Waldbusser,\
    \ CMU\n               Dan Wintringhan\n               David Wood\n           \
    \    Wengyik Yeong, PSI\n               Jeff Young, Cray Research\n"
- title: 7.  References
  contents:
  - "7.  References\n   [1] Cerf, V., \"IAB Recommendations for the Development of\
    \ Internet\n       Network Management Standards\", RFC 1052, NRI, April 1988.\n\
    \   [2] Cerf, V., \"Report of the Second Ad Hoc Network Management Review\n  \
    \     Group\", RFC 1109, NRI, August 1989.\n   [3] Rose M., and K. McCloghrie,\
    \ \"Structure and Identification of\n       Management Information for TCP/IP-based\
    \ internets\", RFC 1155,\n       Performance Systems International, Hughes LAN\
    \ Systems, May 1990.\n   [4] McCloghrie K., and M. Rose, \"Management Information\
    \ Base for\n       Network Management of TCP/IP-based internets\", RFC 1156, Hughes\n\
    \       LAN Systems, Performance Systems International, May 1990.\n   [5] Case,\
    \ J., Fedor, M., Schoffstall, M., and J. Davin, \"Simple\n       Network Management\
    \ Protocol\", RFC 1157, SNMP Research,\n       Performance Systems International,\
    \ Performance Systems\n       International, MIT Laboratory for Computer Science,\
    \ May 1990.\n   [6] Information processing systems - Open Systems Interconnection\
    \ -\n       Specification of Abstract Syntax Notation One (ASN.1),\n       International\
    \ Organization for Standardization International\n       Standard 8824, December\
    \ 1987.\n   [7] Rose M., Editor, \"Management Information Base for Network\n \
    \      Management of TCP/IP-based internets: MIB-II\", RFC 1213,\n       Performance\
    \ Systems International, March 1991.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 9.  Authors' Addresses
  contents:
  - "9.  Authors' Addresses\n   Marshall T. Rose\n   Performance Systems International\n\
    \   5201 Great America Parkway\n   Suite 3106\n   Santa Clara, CA  95054\n   Phone:\
    \ +1 408 562 6222\n   EMail: mrose@psi.com\n   X.500:  rose, psi, us\n   Keith\
    \ McCloghrie\n   Hughes LAN Systems\n   1225 Charleston Road\n   Mountain View,\
    \ CA 94043\n   1225 Charleston Road\n   Mountain View, CA 94043\n   Phone: (415)\
    \ 966-7934\n   EMail: kzm@hls.com\n"
