- title: __initial_text__
  contents:
  - '                       MPLS Label Stack Encoding

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   \"Multi-Protocol Label Switching (MPLS)\" [1] requires a set of\n\
    \   procedures for augmenting network layer packets with \"label stacks\",\n \
    \  thereby turning them into \"labeled packets\".  Routers which support\n   MPLS\
    \ are known as \"Label Switching Routers\", or \"LSRs\".  In order to\n   transmit\
    \ a labeled packet on a particular data link, an LSR must\n   support an encoding\
    \ technique which, given a label stack and a\n   network layer packet, produces\
    \ a labeled packet.  This document\n   specifies the encoding to be used by an\
    \ LSR in order to transmit\n   labeled packets on Point-to-Point Protocol (PPP)\
    \ data links, on LAN\n   data links, and possibly on other data links as well.\
    \  On some data\n   links, the label at the top of the stack may be encoded in\
    \ a\n   different manner, but the techniques described here MUST be used to\n\
    \   encode the remainder of the label stack.  This document also\n   specifies\
    \ rules and procedures for processing the various fields of\n   the label stack\
    \ encoding.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    1      Introduction  ...........................................\
    \  2\n    1.1    Specification of Requirements  ..........................  3\n\
    \    2      The Label Stack  ........................................  3\n   \
    \ 2.1    Encoding the Label Stack  ...............................  3\n    2.2\
    \    Determining the Network Layer Protocol  .................  5\n    2.3   \
    \ Generating ICMP Messages for Labeled IP Packets  ........  6\n    2.3.1  Tunneling\
    \ through a Transit Routing Domain  .............  7\n    2.3.2  Tunneling Private\
    \ Addresses through a Public Backbone  ..  7\n    2.4    Processing the Time to\
    \ Live Field  ......................  8\n    2.4.1  Definitions  ............................................\
    \  8\n    2.4.2  Protocol-independent rules  .............................  8\n\
    \    2.4.3  IP-dependent rules  .....................................  9\n   \
    \ 2.4.4  Translating Between Different Encapsulations  ...........  9\n    3 \
    \     Fragmentation and Path MTU Discovery  ................... 10\n    3.1  \
    \  Terminology  ............................................ 11\n    3.2    Maximum\
    \ Initially Labeled IP Datagram Size  ............. 12\n    3.3    When are Labeled\
    \ IP Datagrams Too Big?  ................. 13\n    3.4    Processing Labeled IPv4\
    \ Datagrams which are Too Big  .... 13\n    3.5    Processing Labeled IPv6 Datagrams\
    \ which are Too Big  .... 14\n    3.6    Implications with respect to Path MTU\
    \ Discovery  ........ 15\n    4      Transporting Labeled Packets over PPP  ..................\
    \ 16\n    4.1    Introduction  ........................................... 16\n\
    \    4.2    A PPP Network Control Protocol for MPLS  ................ 17\n   \
    \ 4.3    Sending Labeled Packets  ................................ 18\n    4.4\
    \    Label Switching Control Protocol Configuration Options  . 18\n    5     \
    \ Transporting Labeled Packets over LAN Media  ............ 18\n    6      IANA\
    \ Considerations  .................................... 19\n    7      Security\
    \ Considerations  ................................ 19\n    8      Intellectual\
    \ Property  .................................. 19\n    9      Authors' Addresses\
    \  ..................................... 20\n   10      References  .............................................\
    \ 22\n   11      Full Copyright Statement  ............................... 23\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   \"Multi-Protocol Label Switching (MPLS)\" [1] requires a\
    \ set of\n   procedures for augmenting network layer packets with \"label stacks\"\
    ,\n   thereby turning them into \"labeled packets\".  Routers which support\n\
    \   MPLS are known as \"Label Switching Routers\", or \"LSRs\".  In order to\n\
    \   transmit a labeled packet on a particular data link, an LSR must\n   support\
    \ an encoding technique which, given a label stack and a\n   network layer packet,\
    \ produces a labeled packet.\n   This document specifies the encoding to be used\
    \ by an LSR in order to\n   transmit labeled packets on PPP data links and on\
    \ LAN data links.\n   The specified encoding may also be useful for other data\
    \ links as\n   well.\n   This document also specifies rules and procedures for\
    \ processing the\n   various fields of the label stack encoding.  Since MPLS is\n\
    \   independent of any particular network layer protocol, the majority of\n  \
    \ such procedures are also protocol-independent.  A few, however, do\n   differ\
    \ for different protocols.  In this document, we specify the\n   protocol-independent\
    \ procedures, and we specify the protocol-\n   dependent procedures for IPv4 and\
    \ IPv6.\n   LSRs that are implemented on certain switching devices (such as ATM\n\
    \   switches) may use different encoding techniques for encoding the top\n   one\
    \ or two entries of the label stack.  When the label stack has\n   additional\
    \ entries, however, the encoding technique described in this\n   document MUST\
    \ be used for the additional label stack entries.\n"
- title: 1.1. Specification of Requirements
  contents:
  - "1.1. Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\",\
    \ \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [2].\n"
- title: 2. The Label Stack
  contents:
  - '2. The Label Stack

    '
- title: 2.1. Encoding the Label Stack
  contents:
  - "2.1. Encoding the Label Stack\n   The label stack is represented as a sequence\
    \ of \"label stack\n   entries\".  Each label stack entry is represented by 4\
    \ octets.  This\n   is shown in Figure 1.\n 0                   1            \
    \       2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n"
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Label
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Label

    '
- title: '|                Label                  | Exp |S|       TTL     | Stack'
  contents:
  - '|                Label                  | Exp |S|       TTL     | Stack

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Entry
  contents:
  - "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Entry\n   \
    \                 Label:  Label Value, 20 bits\n                    Exp:    Experimental\
    \ Use, 3 bits\n                    S:      Bottom of Stack, 1 bit\n          \
    \          TTL:    Time to Live, 8 bits\n                              Figure\
    \ 1\n   The label stack entries appear AFTER the data link layer headers, but\n\
    \   BEFORE any network layer headers.  The top of the label stack appears\n  \
    \ earliest in the packet, and the bottom appears latest.  The network\n   layer\
    \ packet immediately follows the label stack entry which has the\n   S bit set.\n\
    \   Each label stack entry is broken down into the following fields:\n      1.\
    \ Bottom of Stack (S)\n         This bit is set to one for the last entry in the\
    \ label stack\n         (i.e., for the bottom of the stack), and zero for all\
    \ other\n         label stack entries.\n      2. Time to Live (TTL)\n        \
    \ This eight-bit field is used to encode a time-to-live value.\n         The processing\
    \ of this field is described in section 2.4.\n      3. Experimental Use\n    \
    \     This three-bit field is reserved for experimental use.\n      4. Label Value\n\
    \         This 20-bit field carries the actual value of the Label.\n         When\
    \ a labeled packet is received, the label value at the top\n         of the stack\
    \ is looked up.  As a result of a successful lookup\n         one learns:\n  \
    \       a) the next hop to which the packet is to be forwarded;\n         b) the\
    \ operation to be performed on the label stack before\n            forwarding;\
    \ this operation may be to replace the top label\n            stack entry with\
    \ another, or to pop an entry off the label\n            stack, or to replace\
    \ the top label stack entry and then to\n            push one or more additional\
    \ entries on the label stack.\n         In addition to learning the next hop and\
    \ the label stack\n         operation, one may also learn the outgoing data link\n\
    \         encapsulation, and possibly other information which is needed\n    \
    \     in order to properly forward the packet.\n         There are several reserved\
    \ label values:\n           i. A value of 0 represents the \"IPv4 Explicit NULL\
    \ Label\".\n              This label value is only legal at the bottom of the\
    \ label\n              stack.  It indicates that the label stack must be popped,\n\
    \              and the forwarding of the packet must then be based on the\n  \
    \            IPv4 header.\n          ii. A value of 1 represents the \"Router\
    \ Alert Label\".  This\n              label value is legal anywhere in the label\
    \ stack except at\n              the bottom.  When a received packet contains\
    \ this label\n              value at the top of the label stack, it is delivered\
    \ to a\n              local software module for processing.  The actual\n    \
    \          forwarding of the packet is determined by the label\n             \
    \ beneath it in the stack.  However, if the packet is\n              forwarded\
    \ further, the Router Alert Label should be pushed\n              back onto the\
    \ label stack before forwarding.  The use of\n              this label is analogous\
    \ to the use of the \"Router Alert\n              Option\" in IP packets [5].\
    \  Since this label cannot occur\n              at the bottom of the stack, it\
    \ is not associated with a\n              particular network layer protocol.\n\
    \         iii. A value of 2 represents the \"IPv6 Explicit NULL Label\".\n   \
    \           This label value is only legal at the bottom of the label\n      \
    \        stack.  It indicates that the label stack must be popped,\n         \
    \     and the forwarding of the packet must then be based on the\n           \
    \   IPv6 header.\n          iv. A value of 3 represents the \"Implicit NULL Label\"\
    .  This\n              is a label that an LSR may assign and distribute, but\n\
    \              which never actually appears in the encapsulation.  When\n    \
    \          an LSR would otherwise replace the label at the top of the\n      \
    \        stack with a new label, but the new label is \"Implicit\n           \
    \   NULL\", the LSR will pop the stack instead of doing the\n              replacement.\
    \  Although this value may never appear in the\n              encapsulation, it\
    \ needs to be specified in the Label\n              Distribution Protocol, so\
    \ a value is reserved.\n           v. Values 4-15 are reserved.\n"
- title: 2.2. Determining the Network Layer Protocol
  contents:
  - "2.2. Determining the Network Layer Protocol\n   When the last label is popped\
    \ from a packet's label stack (resulting\n   in the stack being emptied), further\
    \ processing of the packet is\n   based on the packet's network layer header.\
    \  The LSR which pops the\n   last label off the stack must therefore be able\
    \ to identify the\n   packet's network layer protocol.  However, the label stack\
    \ does not\n   contain any field which explicitly identifies the network layer\n\
    \   protocol.  This means that the identity of the network layer protocol\n  \
    \ must be inferable from the value of the label which is popped from\n   the bottom\
    \ of the stack, possibly along with the contents of the\n   network layer header\
    \ itself.\n   Therefore, when the first label is pushed onto a network layer\n\
    \   packet, either the label must be one which is used ONLY for packets\n   of\
    \ a particular network layer, or the label must be one which is used\n   ONLY\
    \ for a specified set of network layer protocols, where packets of\n   the specified\
    \ network layers can be distinguished by inspection of\n   the network layer header.\
    \  Furthermore, whenever that label is\n   replaced by another label value during\
    \ a packet's transit, the new\n   value must also be one which meets the same\
    \ criteria.  If these\n   conditions are not met, the LSR which pops the last\
    \ label off a\n   packet will not be able to identify the packet's network layer\n\
    \   protocol.\n   Adherence to these conditions does not necessarily enable\n\
    \   intermediate nodes to identify a packet's network layer protocol.\n   Under\
    \ ordinary conditions, this is not necessary, but there are error\n   conditions\
    \ under which it is desirable.  For instance, if an\n   intermediate LSR determines\
    \ that a labeled packet is undeliverable,\n   it may be desirable for that LSR\
    \ to generate error messages which are\n   specific to the packet's network layer.\
    \  The only means the\n   intermediate LSR has for identifying the network layer\
    \ is inspection\n   of the top label and the network layer header.  So if intermediate\n\
    \   nodes are to be able to generate protocol-specific error messages for\n  \
    \ labeled packets, all labels in the stack must meet the criteria\n   specified\
    \ above for labels which appear at the bottom of the stack.\n   If a packet cannot\
    \ be forwarded for some reason (e.g., it exceeds the\n   data link MTU), and either\
    \ its network layer protocol cannot be\n   identified, or there are no specified\
    \ protocol-dependent rules for\n   handling the error condition, then the packet\
    \ MUST be silently\n   discarded.\n"
- title: 2.3. Generating ICMP Messages for Labeled IP Packets
  contents:
  - "2.3. Generating ICMP Messages for Labeled IP Packets\n   Section 2.4 and section\
    \ 3 discuss situations in which it is desirable\n   to generate ICMP messages\
    \ for labeled IP packets.  In order for a\n   particular LSR to be able to generate\
    \ an ICMP packet and have that\n   packet sent to the source of the IP packet,\
    \ two conditions must hold:\n      1. it must be possible for that LSR to determine\
    \ that a particular\n         labeled packet is an IP packet;\n      2. it must\
    \ be possible for that LSR to route to the packet's IP\n         source address.\n\
    \   Condition 1 is discussed in section 2.2.  The following two\n   subsections\
    \ discuss condition 2.  However, there will be some cases\n   in which condition\
    \ 2 does not hold at all, and in these cases it will\n   not be possible to generate\
    \ the ICMP message.\n"
- title: 2.3.1. Tunneling through a Transit Routing Domain
  contents:
  - "2.3.1. Tunneling through a Transit Routing Domain\n   Suppose one is using MPLS\
    \ to \"tunnel\" through a transit routing\n   domain, where the external routes\
    \ are not leaked into the domain's\n   interior routers.  For example, the interior\
    \ routers may be running\n   OSPF, and may only know how to reach destinations\
    \ within that OSPF\n   domain.  The domain might contain several Autonomous System\
    \ Border\n   Routers (ASBRs), which talk BGP to each other.  However, in this\n\
    \   example the routes from BGP are not distributed into OSPF, and the\n   LSRs\
    \ which are not ASBRs do not run BGP.\n   In this example, only an ASBR will know\
    \ how to route to the source of\n   some arbitrary packet.  If an interior router\
    \ needs to send an ICMP\n   message to the source of an IP packet, it will not\
    \ know how to route\n   the ICMP message.\n   One solution is to have one or more\
    \ of the ASBRs inject \"default\"\n   into the IGP.  (N.B.: this does NOT require\
    \ that there be a \"default\"\n   carried by BGP.)  This would then ensure that\
    \ any unlabeled packet\n   which must leave the domain (such as an ICMP packet)\
    \ gets sent to a\n   router which has full routing information.  The routers with\
    \ full\n   routing information will label the packets before sending them back\n\
    \   through the transit domain, so the use of default routing within the\n   transit\
    \ domain does not cause any loops.\n   This solution only works for packets which\
    \ have globally unique\n   addresses, and for networks in which all the ASBRs\
    \ have complete\n   routing information.  The next subsection describes a solution\
    \ which\n   works when these conditions do not hold.\n"
- title: 2.3.2. Tunneling Private Addresses through a Public Backbone
  contents:
  - "2.3.2. Tunneling Private Addresses through a Public Backbone\n   In some cases\
    \ where MPLS is used to tunnel through a routing domain,\n   it may not be possible\
    \ to route to the source address of a fragmented\n   packet at all.  This would\
    \ be the case, for example, if the IP\n   addresses carried in the packet were\
    \ private (i.e., not globally\n   unique) addresses, and MPLS were being used\
    \ to tunnel those packets\n   through a public backbone.  Default routing to an\
    \ ASBR will not work\n   in this environment.\n   In this environment, in order\
    \ to send an ICMP message to the source\n   of a packet, one can copy the label\
    \ stack from the original packet to\n   the ICMP message, and then label switch\
    \ the ICMP message.  This will\n   cause the message to proceed in the direction\
    \ of the original\n   packet's destination, rather than its source.  Unless the\
    \ message is\n   label switched all the way to the destination host, it will end\
    \ up,\n   unlabeled, in a router which does know how to route to the source of\n\
    \   original packet, at which point the message will be sent in the\n   proper\
    \ direction.\n   This technique can be very useful if the ICMP message is a \"\
    Time\n   Exceeded\" message or a \"Destination Unreachable because fragmentation\n\
    \   needed and DF set\" message.\n   When copying the label stack from the original\
    \ packet to the ICMP\n   message, the label values must be copied exactly, but\
    \ the TTL values\n   in the label stack should be set to the TTL value that is\
    \ placed in\n   the IP header of the ICMP message.  This TTL value should be long\n\
    \   enough to allow the circuitous route that the ICMP message will need\n   to\
    \ follow.\n   Note that if a packet's TTL expiration is due to the presence of\
    \ a\n   routing loop, then if this technique is used, the ICMP message may\n \
    \  loop as well.  Since an ICMP message is  never sent as a result of\n   receiving\
    \ an ICMP message, and since many implementations throttle\n   the rate at which\
    \ ICMP messages can be generated, this is not\n   expected to pose a problem.\n"
- title: 2.4. Processing the Time to Live Field
  contents:
  - '2.4. Processing the Time to Live Field

    '
- title: 2.4.1. Definitions
  contents:
  - "2.4.1. Definitions\n   The \"incoming TTL\" of a labeled packet is defined to\
    \ be the value of\n   the TTL field of the top label stack entry when the packet\
    \ is\n   received.\n   The \"outgoing TTL\" of a labeled packet is defined to\
    \ be the larger\n   of:\n      a) one less than the incoming TTL,\n      b) zero.\n"
- title: 2.4.2. Protocol-independent rules
  contents:
  - "2.4.2. Protocol-independent rules\n   If the outgoing TTL of a labeled packet\
    \ is 0, then the labeled packet\n   MUST NOT be further forwarded; nor may the\
    \ label stack be stripped\n   off and the packet forwarded as an unlabeled packet.\
    \  The packet's\n   lifetime in the network is considered to have expired.\n \
    \  Depending on the label value in the label stack entry, the packet MAY\n   be\
    \ simply discarded, or it may be passed to the appropriate\n   \"ordinary\" network\
    \ layer for error processing (e.g., for the\n   generation of an ICMP error message,\
    \ see section 2.3).\n   When a labeled packet is forwarded, the TTL field of the\
    \ label stack\n   entry at the top of the label stack MUST be set to the outgoing\
    \ TTL\n   value.\n   Note that the outgoing TTL value is a function solely of\
    \ the incoming\n   TTL value, and is independent of whether any labels are pushed\
    \ or\n   popped before forwarding.  There is no significance to the value of\n\
    \   the TTL field in any label stack entry which is not at the top of the\n  \
    \ stack.\n"
- title: 2.4.3. IP-dependent rules
  contents:
  - "2.4.3. IP-dependent rules\n   We define the \"IP TTL\" field to be the value\
    \ of the IPv4 TTL field,\n   or the value of the IPv6 Hop Limit field, whichever\
    \ is applicable.\n   When an IP packet is first labeled, the TTL field of the\
    \ label stack\n   entry MUST BE set to the value of the IP TTL field.  (If the\
    \ IP TTL\n   field needs to be decremented, as part of the IP processing, it is\n\
    \   assumed that this has already been done.)\n   When a label is popped, and\
    \ the resulting label stack is empty, then\n   the value of the IP TTL field SHOULD\
    \ BE replaced with the outgoing\n   TTL value, as defined above.  In IPv4 this\
    \ also requires modification\n   of the IP header checksum.\n   It is recognized\
    \ that there may be situations where a network\n   administration prefers to decrement\
    \ the IPv4 TTL by one as it\n   traverses an MPLS domain, instead of decrementing\
    \ the IPv4 TTL by the\n   number of LSP hops within the domain.\n"
- title: 2.4.4. Translating Between Different Encapsulations
  contents:
  - "2.4.4. Translating Between Different Encapsulations\n   Sometimes an LSR may\
    \ receive a labeled packet over, e.g., a label\n   switching controlled ATM (LC-ATM)\
    \ interface [9], and may need to send\n   it out over a PPP or LAN link.  Then\
    \ the incoming packet will not be\n   received using the encapsulation specified\
    \ in this document, but the\n   outgoing packet will be sent using the encapsulation\
    \ specified in\n   this document.\n   In this case, the value of the \"incoming\
    \ TTL\" is determined by the\n   procedures used for carrying labeled packets\
    \ on, e.g., LC-ATM\n   interfaces.  TTL processing then proceeds as described\
    \ above.\n   Sometimes an LSR may receive a labeled packet over a PPP or a LAN\n\
    \   link, and may need to send it out, say, an LC-ATM interface.  Then\n   the\
    \ incoming packet will be received using the encapsulation\n   specified in this\
    \ document, but the outgoing packet will not be sent\n   using the encapsulation\
    \ specified in this document.  In this case,\n   the procedure for carrying the\
    \ value of the \"outgoing TTL\" is\n   determined by the procedures used for carrying\
    \ labeled packets on,\n   e.g., LC-ATM interfaces.\n"
- title: 3. Fragmentation and Path MTU Discovery
  contents:
  - "3. Fragmentation and Path MTU Discovery\n   Just as it is possible to receive\
    \ an unlabeled IP datagram which is\n   too large to be transmitted on its output\
    \ link, it is possible to\n   receive a labeled packet which is too large to be\
    \ transmitted on its\n   output link.\n   It is also possible that a received\
    \ packet (labeled or unlabeled)\n   which was originally small enough to be transmitted\
    \ on that link\n   becomes too large by virtue of having one or more additional\
    \ labels\n   pushed onto its label stack.  In label switching, a packet may grow\n\
    \   in size if additional labels get pushed on.  Thus if one receives a\n   labeled\
    \ packet with a 1500-byte frame payload, and pushes on an\n   additional label,\
    \ one needs to forward it as frame with a 1504-byte\n   payload.\n   This section\
    \ specifies the rules for processing labeled packets which\n   are \"too large\"\
    .  In particular, it provides rules which ensure that\n   hosts implementing Path\
    \ MTU Discovery [4], and hosts using IPv6\n   [7,8], will be able to generate\
    \ IP datagrams that do not need\n   fragmentation, even if those datagrams get\
    \ labeled as they traverse\n   the network.\n   In general, IPv4 hosts which do\
    \ not implement Path MTU Discovery [4]\n   send IP datagrams which contain no\
    \ more than 576 bytes.  Since the\n   MTUs in use on most data links today are\
    \ 1500 bytes or more, the\n   probability that such datagrams will need to get\
    \ fragmented, even if\n   they get labeled, is very small.\n   Some hosts that\
    \ do not implement Path MTU Discovery [4] will generate\n   IP datagrams containing\
    \ 1500 bytes, as long as the IP Source and\n   Destination addresses are on the\
    \ same subnet.  These datagrams will\n   not pass through routers, and hence will\
    \ not get fragmented.\n   Unfortunately, some hosts will generate IP datagrams\
    \ containing 1500\n   bytes, as long the IP Source and Destination addresses have\
    \ the same\n   classful network number.  This is the one case in which there is\
    \ any\n   risk of fragmentation when such datagrams get labeled.  (Even so,\n\
    \   fragmentation is not likely unless the packet must traverse an\n   ethernet\
    \ of some sort between the time it first gets labeled and the\n   time it gets\
    \ unlabeled.)\n   This document specifies procedures which allow one to configure\
    \ the\n   network so that large datagrams from hosts which do not implement\n\
    \   Path MTU Discovery get fragmented just once, when they are first\n   labeled.\
    \  These procedures make it possible (assuming suitable\n   configuration) to\
    \ avoid any need to fragment packets which have\n   already been labeled.\n"
- title: 3.1. Terminology
  contents:
  - "3.1. Terminology\n   With respect to a particular data link, we can use the following\n\
    \   terms:\n      -  Frame Payload:\n         The contents of a data link frame,\
    \ excluding any data link\n         layer headers or trailers (e.g., MAC headers,\
    \ LLC headers,\n         802.1Q headers, PPP header, frame check sequences, etc.).\n\
    \         When a frame is carrying an unlabeled IP datagram, the Frame\n     \
    \    Payload is just the IP datagram itself.  When a frame is\n         carrying\
    \ a labeled IP datagram, the Frame Payload consists of\n         the label stack\
    \ entries and the IP datagram.\n      -  Conventional Maximum Frame Payload Size:\n\
    \         The maximum Frame Payload size allowed by data link standards.\n   \
    \      For example, the Conventional Maximum Frame Payload Size for\n        \
    \ ethernet is 1500 bytes.\n      -  True Maximum Frame Payload Size:\n       \
    \  The maximum size frame payload which can be sent and received\n         properly\
    \ by the interface hardware attached to the data link.\n         On ethernet and\
    \ 802.3 networks, it is believed that the True\n         Maximum Frame Payload\
    \ Size is 4-8 bytes larger than the\n         Conventional Maximum Frame Payload\
    \ Size (as long as neither an\n         802.1Q header nor an 802.1p header is\
    \ present, and as long as\n         neither can be added by a switch or bridge\
    \ while a packet is in\n         transit to its next hop).  For example, it is\
    \ believed that\n         most ethernet equipment could correctly send and receive\n\
    \         packets carrying a payload of 1504 or perhaps even 1508 bytes,\n   \
    \      at least, as long as the ethernet header does not have an\n         802.1Q\
    \ or 802.1p field.\n         On PPP links, the True Maximum Frame Payload Size\
    \ may be\n         virtually unbounded.\n      -  Effective Maximum Frame Payload\
    \ Size for Labeled Packets:\n         This is either the Conventional Maximum\
    \ Frame Payload Size or\n         the True Maximum Frame Payload Size, depending\
    \ on the\n         capabilities of the equipment on the data link and the size\
    \ of\n         the data link header being used.\n      -  Initially Labeled IP\
    \ Datagram:\n         Suppose that an unlabeled IP datagram is received at a\n\
    \         particular LSR, and that the the LSR pushes on a label before\n    \
    \     forwarding the datagram.  Such a datagram will be called an\n         Initially\
    \ Labeled IP Datagram at that LSR.\n      -  Previously Labeled IP Datagram:\n\
    \         An IP datagram which had already been labeled before it was\n      \
    \   received by a particular LSR.\n"
- title: 3.2. Maximum Initially Labeled IP Datagram Size
  contents:
  - "3.2. Maximum Initially Labeled IP Datagram Size\n   Every LSR which is capable\
    \ of\n      a) receiving an unlabeled IP datagram,\n      b) adding a label stack\
    \ to the datagram, and\n      c) forwarding the resulting labeled packet,\n  \
    \ SHOULD support a configuration parameter known as the \"Maximum\n   Initially\
    \ Labeled IP Datagram Size\", which can be set to a non-\n   negative value.\n\
    \   If this configuration parameter is set to zero, it has no effect.\n   If it\
    \ is set to a positive value, it is used in the following way.\n   If:\n     \
    \ a) an unlabeled IP datagram is received, and\n      b) that datagram does not\
    \ have the DF bit set in its IP header,\n         and\n      c) that datagram\
    \ needs to be labeled before being forwarded, and\n      d) the size of the datagram\
    \ (before labeling) exceeds the value of\n         the parameter,\n   then\n \
    \     a) the datagram must be broken into fragments, each of whose size\n    \
    \     is no greater than the value of the parameter, and\n      b) each fragment\
    \ must be labeled and then forwarded.\n   For example, if this configuration parameter\
    \ is set to a value of\n   1488, then any unlabeled IP datagram containing more\
    \ than 1488 bytes\n   will be fragmented before being labeled.  Each fragment\
    \ will be\n   capable of being carried on a 1500-byte data link, without further\n\
    \   fragmentation, even if as many as three labels are pushed onto its\n   label\
    \ stack.\n   In other words, setting this parameter to a non-zero value allows\
    \ one\n   to eliminate all fragmentation of Previously Labeled IP Datagrams,\n\
    \   but it may cause some unnecessary fragmentation of Initially Labeled\n   IP\
    \ Datagrams.\n   Note that the setting of this parameter does not affect the\n\
    \   processing of IP datagrams that have the DF bit set; hence the result\n  \
    \ of Path MTU discovery is unaffected by the setting of this parameter.\n"
- title: 3.3. When are Labeled IP Datagrams Too Big?
  contents:
  - "3.3. When are Labeled IP Datagrams Too Big?\n   A labeled IP datagram whose size\
    \ exceeds the Conventional Maximum\n   Frame Payload Size of the data link over\
    \ which it is to be forwarded\n   MAY be considered to be \"too big\".\n   A labeled\
    \ IP datagram whose size exceeds the True Maximum Frame\n   Payload Size of the\
    \ data link over which it is to be forwarded MUST\n   be considered to be \"too\
    \ big\".\n   A labeled IP datagram which is not \"too big\" MUST be transmitted\n\
    \   without fragmentation.\n"
- title: 3.4. Processing Labeled IPv4 Datagrams which are Too Big
  contents:
  - "3.4. Processing Labeled IPv4 Datagrams which are Too Big\n   If a labeled IPv4\
    \ datagram is \"too big\", and the DF bit is not set in\n   its IP header, then\
    \ the LSR MAY silently discard the datagram.\n   Note that discarding such datagrams\
    \ is a sensible procedure only if\n   the \"Maximum Initially Labeled IP Datagram\
    \ Size\" is set to a non-zero\n   value in every LSR in the network which is capable\
    \ of adding a label\n   stack to an unlabeled IP datagram.\n   If the LSR chooses\
    \ not to discard a labeled IPv4 datagram which is\n   too big, or if the DF bit\
    \ is set in that datagram, then it MUST\n   execute the following algorithm:\n\
    \      1. Strip off the label stack entries to obtain the IP datagram.\n     \
    \ 2. Let N be the number of bytes in the label stack (i.e, 4 times\n         the\
    \ number of label stack entries).\n      3. If the IP datagram does NOT have the\
    \ \"Don't Fragment\" bit set\n         in its IP header:\n         a. convert\
    \ it into fragments, each of which MUST be at least N\n            bytes less\
    \ than the Effective Maximum Frame Payload Size.\n         b. Prepend each fragment\
    \ with the same label header that would\n            have been on the original\
    \ datagram had fragmentation not\n            been necessary.\n         c. Forward\
    \ the fragments\n      4. If the IP datagram has the \"Don't Fragment\" bit set\
    \ in its IP\n         header:\n         a. the datagram MUST NOT be forwarded\n\
    \         b. Create an ICMP Destination Unreachable Message:\n             i.\
    \ set its Code field [3] to \"Fragmentation Required and DF\n                Set\"\
    ,\n            ii. set its Next-Hop MTU field [4] to the difference between\n\
    \                the Effective Maximum Frame Payload Size and the value\n    \
    \            of N\n         c. If possible, transmit the ICMP Destination Unreachable\n\
    \            Message to the source of the of the discarded datagram.\n"
- title: 3.5. Processing Labeled IPv6 Datagrams which are Too Big
  contents:
  - "3.5. Processing Labeled IPv6 Datagrams which are Too Big\n   To process a labeled\
    \ IPv6 datagram which is too big, an LSR MUST\n   execute the following algorithm:\n\
    \      1. Strip off the label stack entries to obtain the IP datagram.\n     \
    \ 2. Let N be the number of bytes in the label stack (i.e., 4 times\n        \
    \ the number of label stack entries).\n      3. If the IP datagram contains more\
    \ than 1280 bytes (not counting\n         the label stack entries), or if it does\
    \ not contain a fragment\n         header, then:\n         a. Create an ICMP Packet\
    \ Too Big Message, and set its Next-Hop\n            MTU field to the difference\
    \ between the Effective Maximum\n            Frame Payload Size and the value\
    \ of N\n         b. If possible, transmit the ICMP Packet Too Big Message to the\n\
    \            source of the datagram.\n         c. discard the labeled IPv6 datagram.\n\
    \      4. If the IP datagram is not larger than 1280 octets, and it\n        \
    \ contains a fragment header, then\n         a. Convert it into fragments, each\
    \ of which MUST be at least N\n            bytes less than the Effective Maximum\
    \ Frame Payload Size.\n         b. Prepend each fragment with the same label header\
    \ that would\n            have been on the original datagram had fragmentation\
    \ not\n            been necessary.\n         c. Forward the fragments.\n     \
    \    Reassembly of the fragments will be done at the destination\n         host.\n"
- title: 3.6. Implications with respect to Path MTU Discovery
  contents:
  - "3.6. Implications with respect to Path MTU Discovery\n   The procedures described\
    \ above for handling datagrams which have the\n   DF bit set, but which are \"\
    too large\", have an impact on the Path MTU\n   Discovery procedures of RFC 1191\
    \ [4].  Hosts which implement these\n   procedures will discover an MTU which\
    \ is small enough to allow n\n   labels to be pushed on the datagrams, without\
    \ need for fragmentation,\n   where n is the number of labels that actually get\
    \ pushed on along the\n   path currently in use.\n   In other words, datagrams\
    \ from hosts that use Path MTU Discovery will\n   never need to be fragmented\
    \ due to the need to put on a label header,\n   or to add new labels to an existing\
    \ label header.  (Also, datagrams\n   from hosts that use Path MTU Discovery generally\
    \ have the DF bit set,\n   and so will never get fragmented anyway.)\n   Note\
    \ that Path MTU Discovery will only work properly if, at the point\n   where a\
    \ labeled IP Datagram's fragmentation needs to occur, it is\n   possible to cause\
    \ an ICMP Destination Unreachable message to be\n   routed to the packet's source\
    \ address.  See section 2.3.\n   If it is not possible to forward an ICMP message\
    \ from within an MPLS\n   \"tunnel\" to a packet's source address, but the network\
    \ configuration\n   makes it possible for the LSR at the transmitting end of the\
    \ tunnel\n   to receive packets that must go through the tunnel, but are too large\n\
    \   to pass through the tunnel unfragmented, then:\n      -  The LSR at the transmitting\
    \ end of the tunnel MUST be able to\n         determine the MTU of the tunnel\
    \ as a whole.  It MAY do this by\n         sending packets through the tunnel\
    \ to the tunnel's receiving\n         endpoint, and performing Path MTU Discovery\
    \ with those packets.\n      -  Any time the transmitting endpoint of the tunnel\
    \ needs to send\n         a packet into the tunnel, and that packet has the DF\
    \ bit set,\n         and it exceeds the tunnel MTU, the transmitting endpoint\
    \ of the\n         tunnel MUST send the ICMP Destination Unreachable message to\n\
    \         the source, with code \"Fragmentation Required and DF Set\", and\n \
    \        the Next-Hop MTU Field set as described above.\n"
- title: 4. Transporting Labeled Packets over PPP
  contents:
  - "4. Transporting Labeled Packets over PPP\n   The Point-to-Point Protocol (PPP)\
    \ [6] provides a standard method for\n   transporting multi-protocol datagrams\
    \ over point-to-point links.  PPP\n   defines an extensible Link Control Protocol,\
    \ and proposes a family of\n   Network Control Protocols for establishing and\
    \ configuring different\n   network-layer protocols.\n   This section defines\
    \ the Network Control Protocol for establishing\n   and configuring label Switching\
    \ over PPP.\n"
- title: 4.1. Introduction
  contents:
  - "4.1. Introduction\n   PPP has three main components:\n      1. A method for encapsulating\
    \ multi-protocol datagrams.\n      2. A Link Control Protocol (LCP) for establishing,\
    \ configuring,\n         and testing the data-link connection.\n      3. A family\
    \ of Network Control Protocols for establishing and\n         configuring different\
    \ network-layer protocols.\n   In order to establish communications over a point-to-point\
    \ link, each\n   end of the PPP link must first send LCP packets to configure\
    \ and test\n   the data link.  After the link has been established and optional\n\
    \   facilities have been negotiated as needed by the LCP, PPP must send\n   \"\
    MPLS Control Protocol\" packets to enable the transmission of labeled\n   packets.\
    \  Once the \"MPLS Control Protocol\" has reached the Opened\n   state, labeled\
    \ packets can be sent over the link.\n   The link will remain configured for communications\
    \ until explicit LCP\n   or MPLS Control Protocol packets close the link down,\
    \ or until some\n   external event occurs (an inactivity timer expires or network\n\
    \   administrator intervention).\n"
- title: 4.2. A PPP Network Control Protocol for MPLS
  contents:
  - "4.2. A PPP Network Control Protocol for MPLS\n   The MPLS Control Protocol (MPLSCP)\
    \ is responsible for enabling and\n   disabling the use of label switching on\
    \ a PPP link.  It uses the same\n   packet exchange mechanism as the Link Control\
    \ Protocol (LCP).  MPLSCP\n   packets may not be exchanged until PPP has reached\
    \ the Network-Layer\n   Protocol phase.  MPLSCP packets received before this phase\
    \ is reached\n   should be silently discarded.\n   The MPLS Control Protocol is\
    \ exactly the same as the Link Control\n   Protocol [6] with the following exceptions:\n\
    \      1. Frame Modifications\n         The packet may utilize any modifications\
    \ to the basic frame\n         format which have been negotiated during the Link\
    \ Establishment\n         phase.\n      2. Data Link Layer Protocol Field\n  \
    \       Exactly one MPLSCP packet is encapsulated in the PPP\n         Information\
    \ field, where the PPP Protocol field indicates type\n         hex 8281 (MPLS).\n\
    \      3. Code field\n         Only Codes 1 through 7 (Configure-Request, Configure-Ack,\n\
    \         Configure-Nak, Configure-Reject, Terminate-Request, Terminate-\n   \
    \      Ack and Code-Reject) are used.  Other Codes should be treated\n       \
    \  as unrecognized and should result in Code-Rejects.\n      4. Timeouts\n   \
    \      MPLSCP packets may not be exchanged until PPP has reached the\n       \
    \  Network-Layer Protocol phase.  An implementation should be\n         prepared\
    \ to wait for Authentication and Link Quality\n         Determination to finish\
    \ before timing out waiting for a\n         Configure-Ack or other response. \
    \ It is suggested that an\n         implementation give up only after user intervention\
    \ or a\n         configurable amount of time.\n      5. Configuration Option Types\n\
    \         None.\n"
- title: 4.3. Sending Labeled Packets
  contents:
  - "4.3. Sending Labeled Packets\n   Before any labeled packets may be communicated,\
    \ PPP must reach the\n   Network-Layer Protocol phase, and the MPLS Control Protocol\
    \ must\n   reach the Opened state.\n   Exactly one labeled packet is encapsulated\
    \ in the PPP Information\n   field, where the PPP Protocol field indicates either\
    \ type hex 0281\n   (MPLS Unicast) or type hex 0283 (MPLS Multicast).  The maximum\
    \ length\n   of a labeled packet transmitted over a PPP link is the same as the\n\
    \   maximum length of the Information field of a PPP encapsulated packet.\n  \
    \ The format of the Information field itself is as defined in section\n   2.\n\
    \   Note that two codepoints are defined for labeled packets; one for\n   multicast\
    \ and one for unicast.  Once the MPLSCP has reached the\n   Opened state, both\
    \ label switched multicasts and label switched\n   unicasts can be sent over the\
    \ PPP link.\n"
- title: 4.4. Label Switching Control Protocol Configuration Options
  contents:
  - "4.4. Label Switching Control Protocol Configuration Options\n   There are no\
    \ configuration options.\n"
- title: 5. Transporting Labeled Packets over LAN Media
  contents:
  - "5. Transporting Labeled Packets over LAN Media\n   Exactly one labeled packet\
    \ is carried in each frame.\n   The label stack entries immediately precede the\
    \ network layer header,\n   and follow any data link layer headers, including,\
    \ e.g., any 802.1Q\n   headers that may exist.\n   The ethertype value 8847 hex\
    \ is used to indicate that a frame is\n   carrying an MPLS unicast packet.\n \
    \  The ethertype value 8848 hex is used to indicate that a frame is\n   carrying\
    \ an MPLS multicast packet.\n   These ethertype values can be used with either\
    \ the ethernet\n   encapsulation or the 802.3 LLC/SNAP encapsulation to carry\
    \ labeled\n   packets.  The procedure for choosing which of these two\n   encapsulations\
    \ to use is beyond the scope of this document.\n"
- title: 6. IANA Considerations
  contents:
  - "6. IANA Considerations\n   Label values 0-15 inclusive have special meaning,\
    \ as specified in\n   this document, or as further assigned by IANA.\n   In this\
    \ document, label values 0-3 are specified in section 2.1.\n   Label values 4-15\
    \ may be assigned by IANA, based on IETF Consensus.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   The MPLS encapsulation that is specified herein\
    \ does not raise any\n   security issues that are not already present in either\
    \ the MPLS\n   architecture [1] or in the architecture of the network layer protocol\n\
    \   contained within the encapsulation.\n   There are two security considerations\
    \ inherited from the MPLS\n   architecture which may be pointed out here:\n  \
    \    -  Some routers may implement security procedures which depend on\n     \
    \    the network layer header being in a fixed place relative to the\n       \
    \  data link layer header.  These procedures will not work when\n         the\
    \ MPLS encapsulation is used, because that encapsulation is\n         of a variable\
    \ size.\n      -  An MPLS label has its meaning by virtue of an agreement between\n\
    \         the LSR that puts the label in the label stack (the \"label\n      \
    \   writer\"), and the LSR that interprets that label (the \"label\n         reader\"\
    ).  However, the label stack does not provide any means\n         of determining\
    \ who the label writer was for any particular\n         label.  If labeled packets\
    \ are accepted from untrusted sources,\n         the result may be that packets\
    \ are routed in an illegitimate\n         manner.\n"
- title: 8. Intellectual Property
  contents:
  - "8. Intellectual Property\n   The IETF has been notified of intellectual property\
    \ rights claimed in\n   regard to some or all of the specification contained in\
    \ this\n   document.  For more information consult the online list of claimed\n\
    \   rights.\n"
- title: 9. Authors' Addresses
  contents:
  - "9. Authors' Addresses\n   Eric C. Rosen\n   Cisco Systems, Inc.\n   250 Apollo\
    \ Drive\n   Chelmsford, MA, 01824\n   EMail: erosen@cisco.com\n   Dan Tappan\n\
    \   Cisco Systems, Inc.\n   250 Apollo Drive\n   Chelmsford, MA, 01824\n   EMail:\
    \ tappan@cisco.com\n   Yakov Rekhter\n   Juniper Networks\n   1194 N. Mathilda\
    \ Avenue\n   Sunnyvale, CA 94089\n   EMail: yakov@juniper.net\n   Guy Fedorkow\n\
    \   Cisco Systems, Inc.\n   250 Apollo Drive\n   Chelmsford, MA, 01824\n   EMail:\
    \ fedorkow@cisco.com\n   Dino Farinacci\n   Procket Networks, Inc.\n   3910 Freedom\
    \ Circle, Ste. 102A\n   Santa Clara, CA 95054\n   EMail: dino@procket.com\n  \
    \ Tony Li\n   Procket Networks, Inc.\n   3910 Freedom Circle, Ste. 102A\n   Santa\
    \ Clara, CA 95054\n   EMail: tli@procket.com\n   Alex Conta\n   TranSwitch Corporation\n\
    \   3 Enterprise Drive\n   Shelton, CT, 06484\n   EMail: aconta@txc.com\n"
- title: 10. References
  contents:
  - "10. References\n   [1] Rosen, E., Viswanathan, A., and R. Callon, \"Multiprotocol\
    \ Label\n       Switching Architecture\", RFC 3031, January 2001.\n   [2] Bradner,\
    \ S., \"Key words for use in RFCs to Indicate Requirement\n       Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [3] Postel, J., \"Internet Control Message Protocol\"\
    , STD 5, RFC 792,\n       September 1981.\n   [4] Mogul, J. and S. Deering, \"\
    Path MTU Discovery\", RFC 1191,\n       November 1990.\n   [5] Katz, D., \"IP\
    \ Router Alert Option\", RFC 2113, February 1997.\n   [6] Simpson, W., Editor,\
    \ \"The Point-to-Point Protocol (PPP)\", STD 51,\n       RFC 1661, July 1994.\n\
    \   [7] Conta, A. and S. Deering, \"Internet Control Message Protocol\n      \
    \ (ICMPv6) for the Internet Protocol Version 6 (IPv6)\n       Specification\"\
    , RFC 1885, December 1995.\n   [8] McCann, J., Deering, S. and J. Mogul, \"Path\
    \ MTU Discovery for IP\n       version 6\", RFC 1981, August 1996.\n   [9] Davie,\
    \ B., Lawrence, J., McCloghrie, K., Rekhter, Y., Rosen, E.\n       and G. Swallow,\
    \ \"MPLS Using LDP and ATM VC Switching\", RFC 3035,\n       January 2001.\n"
- title: 11. Full Copyright Statement
  contents:
  - "11. Full Copyright Statement\n   Copyright (C) The Internet Society (2001). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
