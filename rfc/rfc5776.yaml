- title: __initial_text__
  contents:
  - " Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in\n    \
    \           the Asynchronous Layered Coding (ALC) and\n           NACK-Oriented\
    \ Reliable Multicast (NORM) Protocols\n"
- title: Abstract
  contents:
  - "Abstract\n   This document details the Timed Efficient Stream Loss-Tolerant\n\
    \   Authentication (TESLA) packet source authentication and packet\n   integrity\
    \ verification protocol and its integration within the\n   Asynchronous Layered\
    \ Coding (ALC) and NACK-Oriented Reliable\n   Multicast (NORM) content delivery\
    \ protocols.  This document only\n   considers the authentication/integrity verification\
    \ of the packets\n   generated by the session's sender.  The authentication and\
    \ integrity\n   verification of the packets sent by receivers, if any, is out\
    \ of the\n   scope of this document.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5776.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  5\n     1.1.  Scope of This Document . . . . . . . . . . . . .\
    \ . . . . .  6\n     1.2.  Conventions Used in This Document  . . . . . . . .\
    \ . . . .  7\n     1.3.  Terminology and Notations  . . . . . . . . . . . . .\
    \ . . .  7\n       1.3.1.  Notations and Definitions Related to Cryptographic\n\
    \               Functions  . . . . . . . . . . . . . . . . . . . . . .  7\n  \
    \     1.3.2.  Notations and Definitions Related to Time  . . . . . .  8\n   2.\
    \  Using TESLA with ALC and NORM: General Operations  . . . . . .  9\n     2.1.\
    \  ALC and NORM Specificities That Impact TESLA . . . . . . .  9\n     2.2.  Bootstrapping\
    \ TESLA  . . . . . . . . . . . . . . . . . . . 10\n       2.2.1.  Bootstrapping\
    \ TESLA with an Out-Of-Band Mechanism  . . 10\n       2.2.2.  Bootstrapping TESLA\
    \ with an In-Band Mechanism  . . . . 11\n     2.3.  Setting Up a Secure Time Synchronization\
    \ . . . . . . . . . 11\n       2.3.1.  Direct Time Synchronization  . . . . .\
    \ . . . . . . . . 12\n       2.3.2.  Indirect Time Synchronization  . . . . .\
    \ . . . . . . . 12\n     2.4.  Determining the Delay Bounds . . . . . . . . .\
    \ . . . . . . 13\n       2.4.1.  Delay Bound Calculation in Direct Time\n    \
    \           Synchronization Mode . . . . . . . . . . . . . . . . . 14\n      \
    \ 2.4.2.  Delay Bound Calculation in Indirect Time\n               Synchronization\
    \ Mode . . . . . . . . . . . . . . . . . 14\n     2.5.  Cryptographic Parameter\
    \ Values . . . . . . . . . . . . . . 15\n   3.  Sender Operations  . . . . . .\
    \ . . . . . . . . . . . . . . . . 16\n     3.1.  TESLA Parameters . . . . . .\
    \ . . . . . . . . . . . . . . . 16\n       3.1.1.  Time Intervals . . . . . .\
    \ . . . . . . . . . . . . . . 16\n       3.1.2.  Key Chains . . . . . . . . .\
    \ . . . . . . . . . . . . . 16\n       3.1.3.  Time Interval Schedule . . . .\
    \ . . . . . . . . . . . . 20\n       3.1.4.  Timing Parameters  . . . . . . .\
    \ . . . . . . . . . . . 20\n     3.2.  TESLA Signaling Messages . . . . . . .\
    \ . . . . . . . . . . 21\n       3.2.1.  Bootstrap Information  . . . . . . .\
    \ . . . . . . . . . 21\n       3.2.2.  Direct Time Synchronization Response .\
    \ . . . . . . . . 22\n     3.3.  TESLA Authentication Information . . . . . .\
    \ . . . . . . . 22\n       3.3.1.  Authentication Tags  . . . . . . . . . . .\
    \ . . . . . . 23\n       3.3.2.  Digital Signatures . . . . . . . . . . . . .\
    \ . . . . . 23\n       3.3.3.  Group MAC Tags . . . . . . . . . . . . . . . .\
    \ . . . . 24\n     3.4.  Format of TESLA Messages and Authentication Tags . .\
    \ . . . 25\n       3.4.1.  Format of a Bootstrap Information Message  . . . .\
    \ . . 26\n       3.4.2.  Format of a Direct Time Synchronization Response . .\
    \ . 31\n       3.4.3.  Format of a Standard Authentication Tag  . . . . . . .\
    \ 32\n       3.4.4.  Format of an Authentication Tag without Key\n           \
    \    Disclosure . . . . . . . . . . . . . . . . . . . . . . 33\n       3.4.5.\
    \  Format of an Authentication Tag with a \"New Key\n               Chain\" Commitment\
    \  . . . . . . . . . . . . . . . . . . 34\n       3.4.6.  Format of an Authentication\
    \ Tag with a \"Last Key\n               of Old Chain\" Disclosure . . . . . .\
    \ . . . . . . . . . 35\n   4.  Receiver Operations  . . . . . . . . . . . . .\
    \ . . . . . . . . 36\n     4.1.  Verification of the Authentication Information\
    \ . . . . . . 36\n       4.1.1.  Processing the Group MAC Tag . . . . . . . .\
    \ . . . . . 36\n       4.1.2.  Processing the Digital Signature . . . . . . .\
    \ . . . . 37\n       4.1.3.  Processing the Authentication Tag  . . . . . . .\
    \ . . . 37\n     4.2.  Initialization of a Receiver . . . . . . . . . . . . .\
    \ . . 38\n       4.2.1.  Processing the Bootstrap Information Message . . . .\
    \ . 38\n       4.2.2.  Performing Time Synchronization  . . . . . . . . . . .\
    \ 38\n     4.3.  Authentication of Received Packets . . . . . . . . . . . . 40\n\
    \       4.3.1.  Discarding Unnecessary Packets Earlier . . . . . . . . 43\n  \
    \   4.4.  Flushing the Non-Authenticated Packets of a Previous\n           Key\
    \ Chain  . . . . . . . . . . . . . . . . . . . . . . . . 43\n   5.  Integration\
    \ in the ALC and NORM Protocols  . . . . . . . . . . 44\n     5.1.  Authentication\
    \ Header Extension Format . . . . . . . . . . 44\n     5.2.  Use of Authentication\
    \ Header Extensions  . . . . . . . . . 45\n       5.2.1.  EXT_AUTH Header Extension\
    \ of Type Bootstrap\n               Information  . . . . . . . . . . . . . . .\
    \ . . . . . . 45\n       5.2.2.  EXT_AUTH Header Extension of Type Authentication\n\
    \               Tag  . . . . . . . . . . . . . . . . . . . . . . . . . 48\n  \
    \     5.2.3.  EXT_AUTH Header Extension of Type Direct Time\n               Synchronization\
    \ Request  . . . . . . . . . . . . . . . 49\n       5.2.4.  EXT_AUTH Header Extension\
    \ of Type Direct Time\n               Synchronization Response . . . . . . . .\
    \ . . . . . . . 49\n   6.  Security Considerations  . . . . . . . . . . . . .\
    \ . . . . . . 50\n     6.1.  Dealing with DoS Attacks . . . . . . . . . . . .\
    \ . . . . . 50\n     6.2.  Dealing With Replay Attacks  . . . . . . . . . . .\
    \ . . . . 51\n       6.2.1.  Impacts of Replay Attacks on TESLA . . . . . . .\
    \ . . . 51\n       6.2.2.  Impacts of Replay Attacks on NORM  . . . . . . . .\
    \ . . 52\n       6.2.3.  Impacts of Replay Attacks on ALC . . . . . . . . . .\
    \ . 53\n     6.3.  Security of the Back Channel . . . . . . . . . . . . . . .\
    \ 53\n   7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 54\n\
    \   8.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 55\n  \
    \ 9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 55\n    \
    \ 9.1.  Normative References . . . . . . . . . . . . . . . . . . . 55\n     9.2.\
    \  Informative References . . . . . . . . . . . . . . . . . . 56\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Many applications using multicast and broadcast communications\n\
    \   require that each receiver be able to authenticate the source of any\n   packet\
    \ it receives as well as the integrity of these packets.  This\n   is the case\
    \ with ALC [RFC5775] and NORM [RFC5740], two Content\n   Delivery Protocols (CDPs)\
    \ designed to transfer objects (e.g., files)\n   reliably between a session's\
    \ sender and several receivers.  The NORM\n   protocol is based on bidirectional\
    \ transmissions.  Each receiver\n   acknowledges data received or, in case of\
    \ packet erasures, asks for\n   retransmissions.  On the opposite, the ALC protocol\
    \ is based on\n   purely unidirectional transmissions.  Reliability is achieved\
    \ by\n   means of the cyclic transmission of the content within a carousel\n \
    \  and/or by the use of proactive Forward Error Correction (FEC) codes.\n   Both\
    \ protocols have in common the fact that they operate at the\n   application level,\
    \ on top of an erasure channel (e.g., the Internet)\n   where packets can be lost\
    \ (erased) during the transmission.\n   The goal of this document is to counter\
    \ attacks where an attacker\n   impersonates the ALC or NORM session's sender\
    \ and injects forged\n   packets to the receivers, thereby corrupting the objects\n\
    \   reconstructed by the receivers.\n   Preventing this attack is much more complex\
    \ in the case of group\n   communications than it is with unicast communications.\
    \  Indeed, with\n   unicast communications, a simple solution exists: the sender\
    \ and the\n   receiver share a secret key to compute a Message Authentication\
    \ Code\n   (MAC) of all messages exchanged.  This is no longer feasible in the\n\
    \   case of multicast and broadcast communications since sharing a group\n   key\
    \ between the sender and all receivers implies that any group\n   member can impersonate\
    \ the sender and send forged messages to other\n   receivers.\n   The usual solution\
    \ to provide the source authentication and message\n   integrity services in the\
    \ case of multicast and broadcast\n   communications consists of relying on asymmetric\
    \ cryptography and\n   using digital signatures.  Yet, this solution is limited\
    \ by high\n   computational costs and high transmission overheads.  The Timed\n\
    \   Efficient Stream Loss-tolerant Authentication (TESLA) protocol is an\n   alternative\
    \ solution that provides the two required services, while\n   being compatible\
    \ with high-rate transmissions over lossy channels.\n   This document explains\
    \ how to integrate the TESLA source\n   authentication and packet integrity protocol\
    \ to the ALC and NORM CDP.\n   Any application built on top of ALC and NORM will\
    \ directly benefit\n   from the services offered by TESLA at the transport layer.\
    \  In\n   particular, this is the case of File Delivery over Unidirectional\n\
    \   Transport (FLUTE).\n   For more information on the TESLA protocol and its\
    \ principles, please\n   refer to [RFC4082] and [Perrig04].  For more information\
    \ on ALC and\n   NORM, please refer to [RFC5775], [RFC5651], and [RFC5740],\n\
    \   respectively.  For more information on FLUTE, please refer to\n   [RMT-FLUTE].\n"
- title: 1.1.  Scope of This Document
  contents:
  - "1.1.  Scope of This Document\n   This specification only considers the authentication\
    \ and integrity\n   verification of the packets generated by the session's sender.\
    \  This\n   specification does not consider the packets that may be sent by\n\
    \   receivers, for instance, NORM's feedback packets.  [RMT-SIMPLE-AUTH]\n   describes\
    \ several techniques that can be used to that purpose.  Since\n   this is usually\
    \ a low-rate flow (unlike the downstream flow), using\n   computing intensive\
    \ techniques like digital signatures, possibly\n   combined with a Group MAC scheme,\
    \ is often acceptable.  Finally,\n   Section 5 explains how to use several authentication\
    \ schemes in a\n   given session thanks to the \"ASID\" (Authentication Scheme\
    \ IDentifier)\n   field.\n   This specification relies on several external mechanisms,\
    \ for\n   instance:\n   o  to communicate securely the public key or a certificate\
    \ for the\n      session's sender (Section 2.2.2);\n   o  to communicate securely\
    \ and confidentially the group key, K_g,\n      used by the Group MAC feature,\
    \ when applicable (Section 3.3.3).\n      In some situations, this group key will\
    \ have to be periodically\n      refreshed;\n   o  to perform secure time synchronization\
    \ in indirect mode\n      (Section 2.3.2) or in direct mode (Section 2.3.1) to\
    \ carry the\n      request/response messages with ALC, which is purely\n     \
    \ unidirectional;\n   These mechanisms are required in order to bootstrap TESLA\
    \ at a sender\n   and at a receiver and must be deployed in parallel to TESLA.\n\
    \   Besides, the randomness of the Primary Key of the key chain\n   (Section 3.1.2)\
    \ is vital to the security of TESLA.  Therefore, the\n   sender needs an appropriate\
    \ mechanism to generate this random key.\n   Several technical details of TESLA,\
    \ like the most appropriate way to\n   alternate between the transmission of a\
    \ key disclosure and a\n   commitment to a new key chain, or the transmission\
    \ of a key\n   disclosure and the last key of the previous key chain, or the\n\
    \   disclosure of a key and the compact flavor that does not disclose any\n  \
    \ key, are specific to the target use case (Section 3.1.2).  For\n   instance,\
    \ it depends on the number of packets sent per time interval,\n   on the desired\
    \ robustness and the acceptable transmission overhead,\n   which can only be optimized\
    \ after taking into account the use-case\n   specificities.\n"
- title: 1.2.  Conventions Used in This Document
  contents:
  - "1.2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 1.3.  Terminology and Notations
  contents:
  - "1.3.  Terminology and Notations\n   The following notations and definitions are\
    \ used throughout this\n   document.\n"
- title: 1.3.1.  Notations and Definitions Related to Cryptographic Functions
  contents:
  - "1.3.1.  Notations and Definitions Related to Cryptographic Functions\n   Notations\
    \ and definitions related to cryptographic functions\n   [RFC4082][RFC4383]:\n\
    \   o  PRF is the Pseudo Random Function;\n   o  MAC is the Message Authentication\
    \ Code;\n   o  HMAC is the keyed-Hash Message Authentication Code;\n   o  F is\
    \ the one-way function used to create the key chain\n      (Section 3.1.2.1);\n\
    \   o  F' is the one-way function used to derive the HMAC keys\n      (Section\
    \ 3.1.2.1);\n   o  n_p is the length, in bits, of the F function's output.  This\
    \ is\n      therefore the length of the keys in the key chain;\n   o  n_f is the\
    \ length, in bits, of the F' function's output.  This is\n      therefore the\
    \ length of the HMAC keys;\n   o  n_m is the length, in bits, of the truncated\
    \ output of the MAC\n      [RFC2104].  Only the n_m most significant bits of the\
    \ MAC output\n      are kept;\n   o  N is the length of a key chain.  There are\
    \ N+1 keys in a key\n      chain: K_0, K_1, ..., K_N.  When several chains are\
    \ used, all the\n      chains MUST have the same length and keys are numbered\n\
    \      consecutively, following the time interval numbering;\n   o  n_c is the\
    \ number of keys in a key chain.  Therefore, n_c = N+1;\n   o  n_tx_lastkey is\
    \ the number of additional intervals during which\n      the last key of the old\
    \ key chain SHOULD be sent, after switching\n      to a new key chain and after\
    \ waiting for the disclosure delay d.\n      These extra transmissions take place\
    \ after the interval during\n      which the last key is normally disclosed. \
    \ The n_tx_lastkey value\n      is either 0 (no extra disclosure) or larger. \
    \ This parameter is\n      sender specific and is not communicated to the receiver;\n\
    \   o  n_tx_newkcc is the number of intervals during which the commitment\n  \
    \    to a new key chain SHOULD be sent, before switching to the new key\n    \
    \  chain.  The n_tx_newkcc value is either 0 (no commitment sent\n      within\
    \ authentication tags) or larger.  This parameter is sender\n      specific and\
    \ is not communicated to the receiver;\n   o  K_g is a shared group key, communicated\
    \ to all group members,\n      confidentially, during the TESLA bootstrapping\
    \ (Section 2.2);\n   o  n_w is the length, in bits, of the truncated output of\
    \ the MAC of\n      the optional group authentication scheme: only the n_w most\n\
    \      significant bits of the MAC output are kept. n_w is typically\n      small,\
    \ a multiple of 32 bits (e.g., 32 bits).\n"
- title: 1.3.2.  Notations and Definitions Related to Time
  contents:
  - "1.3.2.  Notations and Definitions Related to Time\n   Notations and definitions\
    \ related to time:\n   o  i is the time interval index.  Interval numbering starts\
    \ at 0 and\n      increases consecutively.  Since the interval index is stored\
    \ as a\n      32-bit unsigned integer, wrapping to 0 might take place in long\n\
    \      sessions.\n   o  t_s is the sender local time value at some absolute time\
    \ (in NTP\n      timestamp format);\n   o  t_r is the receiver local time value\
    \ at the same absolute time (in\n      NTP timestamp format);\n   o  T_0 is the\
    \ start time corresponding to the beginning of the\n      session, i.e., the beginning\
    \ of time interval 0 (in NTP timestamp\n      format);\n   o  T_int is the interval\
    \ duration (in milliseconds);\n   o  d is the key disclosure delay (in number\
    \ of intervals);\n   o  D_t is the upper bound of the lag of the receiver's clock\
    \ with\n      respect to the clock of the sender;\n   o  S_sr is an estimated\
    \ bound of the clock drift between the sender\n      and a receiver throughout\
    \ the duration of the session;\n   o  D^O_t is the upper bound of the lag of the\
    \ sender's clock with\n      respect to the time reference in indirect time synchronization\n\
    \      mode;\n   o  D^R_t is the upper bound of the lag of the receiver's clock\
    \ with\n      respect to the time reference in indirect time synchronization\n\
    \      mode;\n   o  D_err is an upper bound of the time error between all the\
    \ time\n      references, in indirect time synchronization mode;\n   o  NTP timestamp\
    \ format consists in a 64-bit unsigned fixed-point\n      number, in seconds relative\
    \ to 0h on 1 January 1900.  The integer\n      part is in the first 32 bits, and\
    \ the fraction part in the last 32\n      bits [RFC1305].\n"
- title: '2.  Using TESLA with ALC and NORM: General Operations'
  contents:
  - '2.  Using TESLA with ALC and NORM: General Operations

    '
- title: 2.1.  ALC and NORM Specificities That Impact TESLA
  contents:
  - "2.1.  ALC and NORM Specificities That Impact TESLA\n   The ALC and NORM protocols\
    \ have features and requirements that\n   largely impact the way TESLA can be\
    \ used.\n   In the case of ALC:\n   o  ALC is massively scalable: nothing in the\
    \ protocol specification\n      limits the number of receivers that join a session.\
    \  Therefore, an\n      ALC session potentially includes a huge number (e.g.,\
    \ millions or\n      more) of receivers;\n   o  ALC can work on top of purely\
    \ unidirectional transport channels:\n      this is one of the assets of ALC,\
    \ and examples of unidirectional\n      channels include satellite (even if a\
    \ back channel might exist in\n      some use cases) and broadcasting networks\
    \ like Digital Video\n      Broadcasting - Handhelds / Satellite services to Handhelds\
    \ (DVB-\n      H/SH);\n   o  ALC defines an on-demand content delivery model [RFC5775]\
    \ where\n      receivers can arrive at any time, at their own discretion,\n  \
    \    download the content and leave the session.  Other models (e.g.,\n      push\
    \ or streaming) are also defined;\n   o  ALC sessions are potentially very long:\
    \ a session can last several\n      days or months during which the content is\
    \ continuously\n      transmitted within a carousel.  The content can be either\
    \ static\n      (e.g., a software update) or dynamic (e.g., a web site).\n   Depending\
    \ on the use case, some of the above features may not apply.\n   For instance,\
    \ ALC can also be used over a bidirectional channel or\n   with a limited number\
    \ of receivers.\n   In the case of NORM:\n   o  NORM has been designed for medium-size\
    \ sessions: indeed, NORM\n      relies on feedback messages and the sender may\
    \ collapse if the\n      feedback message rate is too high;\n   o  NORM requires\
    \ a bidirectional transport channel: the back channel\n      is not necessarily\
    \ a high-data rate channel since the control\n      traffic sent over it by a\
    \ single receiver is an order of magnitude\n      lower than the downstream traffic.\
    \  Networks with an asymmetric\n      connectivity (e.g., a high-rate satellite\
    \ downlink and a low-rate\n      return channel) are appropriate.\n"
- title: 2.2.  Bootstrapping TESLA
  contents:
  - "2.2.  Bootstrapping TESLA\n   In order to initialize the TESLA component at a\
    \ receiver, the sender\n   MUST communicate some key information in a secure way,\
    \ so that the\n   receiver can check the source of the information and its integrity.\n\
    \   Two general methods are possible:\n   o  by using an out-of-band mechanism,\
    \ or\n   o  by using an in-band mechanism.\n   The current specification does\
    \ not recommend any mechanism to\n   bootstrap TESLA.  Choosing between an in-band\
    \ and out-of-band scheme\n   is left to the implementer, depending on the target\
    \ use case.\n   However, it is RECOMMENDED that TESLA implementations support\
    \ the use\n   of the in-band mechanism for interoperability purposes.\n"
- title: 2.2.1.  Bootstrapping TESLA with an Out-Of-Band Mechanism
  contents:
  - "2.2.1.  Bootstrapping TESLA with an Out-Of-Band Mechanism\n   For instance, [RFC4442]\
    \ describes the use of the MIKEY (Multimedia\n   Internet Keying) protocol to\
    \ bootstrap TESLA.  As a side effect,\n   MIKEY also provides a loose time synchronization\
    \ feature from which\n   TESLA can benefit.  Other solutions, for instance, based\
    \ on an\n   extended session description, are possible, on the condition that\n\
    \   these solutions provide the required security level.\n"
- title: 2.2.2.  Bootstrapping TESLA with an In-Band Mechanism
  contents:
  - "2.2.2.  Bootstrapping TESLA with an In-Band Mechanism\n   This specification\
    \ describes an in-band mechanism.  In some use\n   cases, it might be desired\
    \ that bootstrapping take place without\n   requiring the use of an additional\
    \ external mechanism.  For instance,\n   each device may feature a clock with\
    \ a known time-drift that is\n   negligible in front of the time accuracy required\
    \ by TESLA, and each\n   device may embed the public key of the sender.  It is\
    \ also possible\n   that the use case does not feature a bidirectional channel\
    \ that\n   prevents the use of out-of-band protocols like MIKEY.  For these two\n\
    \   examples, the exchange of a bootstrap information message (described\n   in\
    \ Section 3.4.1) and the knowledge of a few additional parameters\n   (listed\
    \ below) are sufficient to bootstrap TESLA at a receiver.\n   Some parameters\
    \ cannot be communicated in-band.  In particular:\n   o  the sender or group controller\
    \ MUST either communicate the public\n      key of the sender or a certificate\
    \ (which also means that a PKI\n      has been set up) to all receivers, so that\
    \ each receiver be able\n      to verify the signature of the bootstrap message\
    \ and direct time\n      synchronization response messages (when applicable).\n\
    \   o  when time synchronization is performed with NTP/SNTP (Simple\n      Network\
    \ Time Protocol), the sender or group controller MUST\n      communicate the list\
    \ of valid NTP/SNTP servers to all the session\n      members (sender included),\
    \ so that they are all able to\n      synchronize themselves on the same NTP/SNTP\
    \ servers.\n   o  when the Group MAC feature is used, the sender or group controller\n\
    \      MUST communicate the K_g group key to all the session members\n      (sender\
    \ included).  This group key may be periodically refreshed.\n   The way these\
    \ parameters are communicated is out of the scope of this\n   document.\n"
- title: 2.3.  Setting Up a Secure Time Synchronization
  contents:
  - "2.3.  Setting Up a Secure Time Synchronization\n   The security offered by TESLA\
    \ heavily relies on time.  Therefore, the\n   session's sender and each receiver\
    \ need to be time synchronized in a\n   secure way.  To that purpose, two general\
    \ methods exist:\n   o  direct time synchronization, and\n   o  indirect time\
    \ synchronization.\n   It is also possible that a given session includes receivers\
    \ that use\n   the direct time synchronization mode while others use the indirect\n\
    \   time synchronization mode.\n"
- title: 2.3.1.  Direct Time Synchronization
  contents:
  - "2.3.1.  Direct Time Synchronization\n   When direct time synchronization is used,\
    \ each receiver asks the\n   sender for a time synchronization.  To that purpose,\
    \ a receiver sends\n   a direct time synchronization request (Section 4.2.2.1).\
    \  The sender\n   then directly answers each request with a direct time synchronization\n\
    \   response (Section 3.4.2), signing this reply.  Upon receiving this\n   response,\
    \ a receiver first verifies the signature, and then\n   calculates an upper bound\
    \ of the lag of his clock with respect to the\n   clock of the sender, D_t.  The\
    \ details on how to calculate D_t are\n   given in Section 2.4.1.\n   This synchronization\
    \ method is both simple and secure.  Yet, there\n   are two potential issues:\n\
    \   o  a bidirectional channel must exist between the sender and each\n      receiver,\
    \ and\n   o  the sender may collapse if the incoming request rate is too high.\n\
    \   Relying on direct time synchronization is not expected to be an issue\n  \
    \ with NORM since (1) bidirectional communications already take place,\n   and\
    \ (2) NORM scalability is anyway limited.  Yet, it can be required\n   that a\
    \ mechanism, that is out of the scope of this document, be used\n   to spread\
    \ the transmission of direct time synchronization request\n   messages over time\
    \ if there is a risk that the sender may collapse.\n   But direct time synchronization\
    \ is potentially incompatible with ALC\n   since (1) there might not be a back\
    \ channel, and (2) there are\n   potentially a huge number of receivers and therefore\
    \ a risk that the\n   sender will collapse.\n"
- title: 2.3.2.  Indirect Time Synchronization
  contents:
  - "2.3.2.  Indirect Time Synchronization\n   When indirect time synchronization\
    \ is used, the sender and each\n   receiver must synchronize securely via an external\
    \ time reference.\n   Several possibilities exist:\n   o  sender and receivers\
    \ can synchronize through an NTPv3 (Network\n      Time Protocol version 3) [RFC1305]\
    \ hierarchy of servers.  The\n      authentication mechanism of NTPv3 MUST be\
    \ used in order to\n      authenticate each NTP message individually.  It prevents,\
    \ for\n      instance, an attacker from impersonating an NTP server;\n   o  they\
    \ can synchronize through an NTPv4 (Network Time Protocol\n      version 4) [NTP-NTPv4]\
    \ hierarchy of servers.  The Autokey security\n      protocol of NTPv4 MUST be\
    \ used in order to authenticate each NTP\n      message individually;\n   o  they\
    \ can synchronize through an SNTPv4 (Simple Network Time\n      Protocol version\
    \ 4) [RFC4330] hierarchy of servers.  The\n      authentication features of SNTPv4\
    \ must then be used.  Note that\n      TESLA only needs a loose (but secure) time\
    \ synchronization, which\n      is in line with the time synchronization service\
    \ offered by SNTP;\n   o  they can synchronize through a GPS or Galileo (or similar)\
    \ device\n      that also provides a high precision time reference.  Spoofing\n\
    \      attacks on the GPS system have recently been reported.  Depending\n   \
    \   on the use case, the security achieved will or will not be\n      acceptable;\n\
    \   o  they can synchronize thanks to a dedicated hardware, embedded on\n    \
    \  each sender and receiver, that provides a clock with a time-drift\n      that\
    \ is negligible in front of the TESLA time accuracy\n      requirements.  This\
    \ feature enables a device to synchronize its\n      embedded clock with the official\
    \ time reference from time to time\n      (in an extreme case once, at manufacturing\
    \ time), and then to\n      remain autonomous for a duration that depends on the\
    \ known maximum\n      clock drift.\n   A bidirectional channel is required by\
    \ the NTP/SNTP schemes.  On the\n   opposite, with the GPS/Galileo and high precision\
    \ clock schemes, no\n   such assumption is made.  In situations where ALC is used\
    \ on purely\n   unidirectional transport channels (Section 2.1), using the NTP/SNTP\n\
    \   schemes is not possible.  Another aspect is the scalability\n   requirement\
    \ of ALC, and to a lesser extent of NORM.  From this point\n   of view, the above\
    \ mechanisms usually do not raise any problem,\n   unlike the direct time synchronization\
    \ schemes.  Therefore, using\n   indirect time synchronization can be a good choice.\
    \  It should be\n   noted that the NTP/SNTP schemes assume that each client trusts\
    \ the\n   sender and accepts aligning its NTP/SNTP configuration to that of the\n\
    \   sender.  If this assumption does not hold, the sender SHOULD offer an\n  \
    \ alternative solution.\n   The details on how to calculate an upper bound of\
    \ the lag of a\n   receiver's clock with respect to the clock of the sender, D_t,\
    \ are\n   given in Section 2.4.2.\n"
- title: 2.4.  Determining the Delay Bounds
  contents:
  - "2.4.  Determining the Delay Bounds\n   Let us assume that a secure time synchronization\
    \ has been set up.\n   This section explains how to define the various timing\
    \ parameters\n   that are used during the authentication of received packets.\n"
- title: 2.4.1.  Delay Bound Calculation in Direct Time Synchronization Mode
  contents:
  - "2.4.1.  Delay Bound Calculation in Direct Time Synchronization Mode\n   In direct\
    \ time synchronization mode, synchronization between a\n   receiver and the sender\
    \ follows the following protocol [RFC4082]:\n   o  The receiver sends a direct\
    \ time synchronization request message\n      to the sender, that includes t_r,\
    \ the receiver local time at the\n      moment of sending (Section 4.2.2.1).\n\
    \   o  Upon receipt of this message, the sender records its local time,\n    \
    \  t_s, and sends to the receiver a direct time synchronization\n      response\
    \ that includes t_r (taken from the request) and t_s,\n      signing this reply\
    \ (Section 3.4.2).\n   o  Upon receiving this response, the receiver first verifies\
    \ that he\n      actually sent a request with t_r and then checks the signature.\n\
    \      Then he calculates D_t = t_s - t_r + S_sr, where S_sr is an\n      estimated\
    \ bound of the clock drift between the sender and the\n      receiver throughout\
    \ the duration of the session.  This document\n      does not specify how S_sr\
    \ is estimated.\n   After this initial synchronization, at any point throughout\
    \ the\n   session, the receiver knows that: T_s < T_r + D_t, where T_s is the\n\
    \   current time at the sender and T_r is the current time at the\n   receiver.\n"
- title: 2.4.2.  Delay Bound Calculation in Indirect Time Synchronization Mode
  contents:
  - "2.4.2.  Delay Bound Calculation in Indirect Time Synchronization Mode\n   In\
    \ indirect time synchronization, the sender and the receivers must\n   synchronize\
    \ indirectly using one or several time references.\n"
- title: 2.4.2.1.  Single Time Reference
  contents:
  - "2.4.2.1.  Single Time Reference\n   Let us assume that there is a single time\
    \ reference.\n   1.  The sender calculates D^O_t, the upper bound of the lag of\
    \ the\n       sender's clock with respect to the time reference.  This D^O_t\n\
    \       value is then communicated to the receivers (Section 3.2.1).\n   2.  Similarly,\
    \ a receiver R calculates D^R_t, the upper bound of the\n       lag of the receiver's\
    \ clock with respect to the time reference.\n   3.  Then, for receiver R, the\
    \ overall upper bound of the lag of the\n       receiver's clock with respect\
    \ to the clock of the sender, D_t, is\n       the sum: D_t = D^O_t + D^R_t.\n\
    \   The D^O_t and D^R_t calculation depends on the time synchronization\n   mechanism\
    \ used (Section 2.3.2).  In some cases, the synchronization\n   scheme specifications\
    \ provide these values.  In other cases, these\n   parameters can be calculated\
    \ by means of a scheme similar to the one\n   specified in Section 2.4.1, for\
    \ instance, when synchronization is\n   achieved via a group controller [RFC4082].\n"
- title: 2.4.2.2.  Multiple Time References
  contents:
  - "2.4.2.2.  Multiple Time References\n   Let us now assume that there are several\
    \ time references (e.g.,\n   several NTP/SNTP servers).  The sender and receivers\
    \ first\n   synchronize with the various time references, independently.  It\n\
    \   results in D^O_t and D^R_t.  Let D_err be an upper bound of the time\n   error\
    \ between all of the time references.  Then, the overall value of\n   D_t within\
    \ receiver R is set to the sum: D_t = D^O_t + D^R_t + D_err.\n   In some cases,\
    \ the D_t value is part of the time synchronization\n   scheme specifications.\
    \  For instance, NTPv3 [RFC1305] defines\n   algorithms that are \"capable of\
    \ accuracies in the order of a\n   millisecond, even after extended periods when\
    \ synchronization to\n   primary reference sources has been lost\".  In practice,\
    \ depending on\n   the NTP server stratum, the accuracy might be a little bit\
    \ worse.  In\n   that case, D_t = security_factor * (1ms + 1ms), where the\n \
    \  security_factor is meant to compensate several sources of inaccuracy\n   in\
    \ NTP.  The choice of the security_factor value is left to the\n   implementer,\
    \ depending on the target use case.\n"
- title: 2.5.  Cryptographic Parameter Values
  contents:
  - "2.5.  Cryptographic Parameter Values\n   The F (resp. F') function output length\
    \ is given by the n_p (resp.\n   n_f) parameter.  The n_p and n_f values depend\
    \ on the PRF function\n   chosen, as specified below:\n             +------------------------+---------------------+\n\
    \             |        PRF name        |     n_p and n_f     |\n             +------------------------+---------------------+\n\
    \             |       HMAC-SHA-1       | 160 bits (20 bytes) |\n             |\
    \      HMAC-SHA-224      | 224 bits (28 bytes) |\n             | HMAC-SHA-256\
    \ (default) | 256 bits (32 bytes) |\n             |      HMAC-SHA-384      | 384\
    \ bits (48 bytes) |\n             |      HMAC-SHA-512      | 512 bits (64 bytes)\
    \ |\n             +------------------------+---------------------+\n   The computing\
    \ of regular MAC (resp. Group MAC) makes use of the n_m\n   (resp. n_w) parameter,\
    \ i.e., the length of the truncated output of\n   the function.  The n_m and n_w\
    \ values depend on the MAC function\n   chosen, as specified below:\n   +------------------------+---------------------+-------------------+\n\
    \   |        MAC name        |  n_m (regular MAC)  |  n_w (Group MAC)  |\n   +------------------------+---------------------+-------------------+\n\
    \   |       HMAC-SHA-1       |  80 bits (10 bytes) | 32 bits (4 bytes) |\n   |\
    \      HMAC-SHA-224      | 112 bits (14 bytes) | 32 bits (4 bytes) |\n   | HMAC-SHA-256\
    \ (default) | 128 bits (16 bytes) | 32 bits (4 bytes) |\n   |      HMAC-SHA-384\
    \      | 192 bits (24 bytes) | 32 bits (4 bytes) |\n   |      HMAC-SHA-512   \
    \   | 256 bits (32 bytes) | 32 bits (4 bytes) |\n   +------------------------+---------------------+-------------------+\n"
- title: 3.  Sender Operations
  contents:
  - "3.  Sender Operations\n   This section describes the TESLA operations at a sender.\
    \  For more\n   information on the TESLA protocol and its principles, please refer\
    \ to\n   [RFC4082][Perrig04].\n"
- title: 3.1.  TESLA Parameters
  contents:
  - '3.1.  TESLA Parameters

    '
- title: 3.1.1.  Time Intervals
  contents:
  - "3.1.1.  Time Intervals\n   The sender divides the time into uniform intervals\
    \ of duration T_int.\n   Time interval numbering starts at 0 and is incremented\
    \ consecutively.\n   The interval index MUST be stored in an unsigned 32-bit integer\
    \ so\n   that wrapping to 0 takes place only after 2^^32 intervals.  For\n   instance,\
    \ if T_int is equal to 0.5 seconds, then wrapping takes place\n   after approximately\
    \ 68 years.\n"
- title: 3.1.2.  Key Chains
  contents:
  - '3.1.2.  Key Chains

    '
- title: 3.1.2.1.  Principles
  contents:
  - "3.1.2.1.  Principles\n   The sender computes a one-way key chain of n_c = N+1\
    \ keys, and\n   assigns one key from the chain to each interval, consecutively\
    \ but in\n   reverse order.  Key numbering starts at 0 and is incremented\n  \
    \ consecutively, following the time interval numbering: K_0, K_1, ...,\n   K_N.\n\
    \   In order to compute this chain, the sender must first select a\n   Primary\
    \ Key, K_N, and a PRF function, f (Section 7, TESLA-PRF).  The\n   randomness\
    \ of the Primary Key, K_N, is vital to the security and no\n   one should be able\
    \ to guess it.\n   The function F is a one-way function that is defined as: F(k)\
    \ =\n   f_k(0), where f_k(0) is the result of the application of the PRF f to\n\
    \   k and 0.  When f is an HMAC (Section 7), k is used as the key, and 0\n   as\
    \ the message, using the algorithm described in [RFC2104].\n   Similarly, the\
    \ function F' is a one-way function that is defined as:\n   F'(k) = f_k(1), where\
    \ f_k(1) is the result of the application of the\n   same PRF f to k and 1.\n\
    \   The sender then computes all the keys of the chain, recursively,\n   starting\
    \ with K_N, using: K_{i-1} = F(K_i).  Therefore, K_i = F^{N-\n   i}(K_N), where\
    \ F^i(x) is the execution of function F with the\n   argument x, i times.  The\
    \ receiver can then compute any value in the\n   key chain from K_N, even if it\
    \ does not have intermediate values\n   [RFC4082].  The key for MAC calculation\
    \ can then be derived from the\n   corresponding K_i key by K'_i = F'(K_i).\n\
    \   The key chain has a finite length, N, which corresponds to a maximum\n   time\
    \ duration of (N + 1) * T_int.  The content delivery session has a\n   duration\
    \ T_delivery, which may either be known in advance, or not.  A\n   first solution\
    \ consists in having a single key chain of an\n   appropriate length, so that\
    \ the content delivery session finishes\n   before the end of the key chain, i.e.,\
    \ T_delivery <= (N + 1) * T_int.\n   But the longer the key chain, the higher\
    \ the memory and computation\n   required to cope with it.  Another solution consists\
    \ in switching to\n   a new key chain, of the same length, when necessary [Perrig04].\n"
- title: 3.1.2.2.  Using Multiple Key Chains
  contents:
  - "3.1.2.2.  Using Multiple Key Chains\n   When several key chains are needed, all\
    \ of them MUST be of the same\n   length.  Switching from the current key chain\
    \ to the next one\n   requires that a commitment to the new key chain be communicated\
    \ in a\n   secure way to the receiver.  This can be done by using either an out-\n\
    \   of-band mechanism or an in-band mechanism.  This document only\n   specifies\
    \ the in-band mechanism.\n   < -------- old key chain --------- >||< --------\
    \ new key chain --...\n   +-----+-----+ .. +-----+-----+-----+||+-----+-----+-----+-----+-----+\n\
    \      0     1    ..   N-2   N-1    N   ||  N+1   N+2   N+3   N+4   N+5\n    \
    \                                   ||\n   Key disclosures:                  \
    \  ||\n     N/A   N/A   ..  K_N-4 K_N-3 K_N-2 || K_N-1  K_N  K_N+1 K_N+2 K_N+3\n\
    \                    |                  ||            |                 |\n  \
    \                  |< -------------- >||            |< ------------- >|\n   Additional\
    \ key        F(K_N+1)      ||                   K_N\n   disclosures        (commitment\
    \ to   ||              (last key of the\n   (in parallel):      the new chain)\
    \  ||                 old chain)\n       Figure 1: Switching to the Second Key\
    \ Chain with the In-Band\n        Mechanism, Assuming That d=2, n_tx_newkcc=3,\
    \ n_tx_lastkey=3\n   Figure 1 illustrates the switch to the new key chain, using\
    \ the in-\n   band mechanism.  Let us say that the old key chain stops at K_N\
    \ and\n   the new key chain starts at K_{N+1} (i.e., F(K_{N+1}) and K_N are two\n\
    \   different keys).  Then, the sender includes the commitment F(K_{N+1})\n  \
    \ to the new key chain into packets authenticated with the old key\n   chain (see\
    \ Section 3.4.5).  This commitment SHOULD be sent during\n   n_tx_newkcc time\
    \ intervals before the end of the old key chain.\n   Since several packets are\
    \ usually sent during an interval, the sender\n   SHOULD alternate between sending\
    \ a disclosed key of the old key chain\n   and the commitment to the new key chain.\
    \  The details of how to\n   alternate between the disclosure and commitment are\
    \ out of the scope\n   of this document.\n   The receiver will keep the commitment\
    \ until the key K_{N+1} is\n   disclosed, at interval N+1+d.  Then, the receiver\
    \ will be able to\n   test the validity of that key by computing F(K_{N+1}) and\
    \ comparing\n   it to the commitment.\n   When the key chain is changed, it becomes\
    \ impossible to recover a\n   previous key from the old key chain.  This is a\
    \ problem if the\n   receiver lost the packets disclosing the last key of the\
    \ old key\n   chain.  A solution consists in re-sending the last key, K_N, of\
    \ the\n   old key chain (see Section 3.4.6).  This SHOULD be done during\n   n_tx_lastkey\
    \ additional time intervals after the end of the time\n   interval where K_N is\
    \ disclosed.  Since several packets are usually\n   sent during an interval, the\
    \ sender SHOULD alternate between sending\n   a disclosed key of the new key chain,\
    \ and the last key of the old key\n   chain.  The details of how to alternate\
    \ between the two disclosures\n   are out of the scope of this document.\n   In\
    \ some cases, a receiver having experienced a very long\n   disconnection might\
    \ have lost the commitment of the new chain.\n   Therefore, this receiver will\
    \ not be able to authenticate any packet\n   related to the new chain or any of\
    \ the following ones.  The only\n   solution for this receiver to catch up consists\
    \ in receiving an\n   additional bootstrap information message.  This can happen\
    \ by waiting\n   for the next periodic transmission (if sent in-band) or through\
    \ an\n   external mechanism (Section 3.2.1).\n"
- title: 3.1.2.3.  Values of the n_tx_lastkey and n_tx_newkcc Parameters
  contents:
  - "3.1.2.3.  Values of the n_tx_lastkey and n_tx_newkcc Parameters\n   When several\
    \ key chains and the in-band commitment mechanism are\n   used, a sender MUST\
    \ initialize the n_tx_lastkey and n_tx_newkcc\n   parameters in such a way that\
    \ no overlapping occurs.  In other words,\n   once a sender starts transmitting\
    \ commitments for a new key chain, he\n   MUST NOT send a disclosure for the last\
    \ key of the old key chain any\n   more.  Therefore, the following property MUST\
    \ be verified:\n      d + n_tx_lastkey + n_tx_newkcc <= N + 1\n   It is RECOMMENDED,\
    \ for robustness purposes, that, once n_tx_lastkey\n   has been chosen, then:\n\
    \      n_tx_newkcc = N + 1 - n_tx_lastkey - d\n   In other words, the sender starts\
    \ transmitting a commitment to the\n   following key chain immediately after having\
    \ sent all the disclosures\n   of the last key of the previous key chain.  Doing\
    \ so increases the\n   probability that a receiver gets a commitment for the following\
    \ key\n   chain.\n   In any case, these two parameters are sender specific and\
    \ need not be\n   transmitted to the receivers.  Of course, as explained above,\
    \ the\n   sender alternates between the disclosure of a key of the current key\n\
    \   chain and the commitment to the new key chain (or the last key of the\n  \
    \ old key chain).\n"
- title: 3.1.2.4.  The Particular Case of the Session Start
  contents:
  - "3.1.2.4.  The Particular Case of the Session Start\n   Since a key cannot be\
    \ disclosed before the disclosure delay, d, no\n   key will be disclosed during\
    \ the first d time intervals (intervals 0\n   and 1 in Figure 1) of the session.\
    \  To that purpose, the sender uses\n   the Authentication Tag without Key Disclosure,\
    \ Section 3.4.4.  The\n   following key chains, if any, are not concerned since\
    \ they will\n   disclose the last d keys of the previous chain.\n"
- title: 3.1.2.5.  Managing Silent Periods
  contents:
  - "3.1.2.5.  Managing Silent Periods\n   An ALC or NORM sender may stop transmitting\
    \ packets for some time.\n   For instance, it can be the end of the session and\
    \ all packets have\n   already been sent, or the use case may consist in a succession\
    \ of\n   busy periods (when fresh objects are available) followed by silent\n\
    \   periods.  In any case, this is an issue since the authentication of\n   the\
    \ packets sent during the last d intervals requires that the\n   associated keys\
    \ be disclosed, which will take place during d\n   additional time intervals.\n\
    \   To solve this problem, it is recommended that the sender transmit\n   empty\
    \ packets (i.e., without payload) containing the TESLA EXT_AUTH\n   Header Extension\
    \ along with a Standard Authentication Tag during at\n   least d time intervals\
    \ after the end of the regular ALC or NORM\n   packet transmissions.  The number\
    \ of such packets and the duration\n   during which they are sent must be sufficient\
    \ for all receivers to\n   receive, with a high probability, at least one packet\
    \ disclosing the\n   last useful key (i.e., the key used for the last non-empty\
    \ packet\n   sent).\n"
- title: 3.1.3.  Time Interval Schedule
  contents:
  - "3.1.3.  Time Interval Schedule\n   The sender must determine the following parameters:\n\
    \   o  T_0, the start time corresponding to the beginning of the session,\n  \
    \    i.e., the beginning of time interval 0 (in NTP timestamp format);\n   o \
    \ T_int, the interval duration (in milliseconds), usually ranging\n      from\
    \ 100 milliseconds to 1 second;\n   o  d, the key disclosure delay (in number\
    \ of intervals).  It is the\n      time to wait before disclosing a key;\n   o\
    \  N, the length of a key chain.\n   The correct choice of T_int, d, and N is\
    \ crucial for the efficiency\n   of the scheme.  For instance, a T_int * d product\
    \ that is too long\n   will cause excessive delay in the authentication process.\
    \  A T_int *\n   d product that is too short prevents many receivers from verifying\n\
    \   packets.  An N * T_int product that is too small will cause the\n   sender\
    \ to switch too often to new key chains.  An N that is too long\n   with respect\
    \ to the expected session duration (if known) will require\n   the sender to compute\
    \ too many useless keys.  Sections 3.2 and 3.6 of\n   [RFC4082] give general guidelines\
    \ for initializing these parameters.\n   The T_0, T_int, d, and N parameters MUST\
    \ NOT be changed during the\n   lifetime of the session.  This restriction is\
    \ meant to prevent\n   introducing vulnerabilities.  For instance, if a sender\
    \ was\n   authorized to change the key disclosure schedule, a receiver that did\n\
    \   not receive the change notification would still believe in the old\n   key\
    \ disclosure schedule, thereby creating vulnerabilities [RFC4082].\n"
- title: 3.1.4.  Timing Parameters
  contents:
  - "3.1.4.  Timing Parameters\n   In indirect time synchronization mode, the sender\
    \ must determine the\n   following parameter:\n   o  D^O_t, the upper bound of\
    \ the lag of the sender's clock with\n      respect to the time reference.\n \
    \  The D^O_t parameter MUST NOT be changed during the lifetime of the\n   session.\n"
- title: 3.2.  TESLA Signaling Messages
  contents:
  - "3.2.  TESLA Signaling Messages\n   At a sender, TESLA produces two types of signaling\
    \ information:\n   o  The bootstrap information: it can be either sent out-of-band\
    \ or\n      in-band.  In the latter case, a digitally signed packet contains\n\
    \      all the information required to bootstrap TESLA at a receiver;\n   o  The\
    \ direct time synchronization response, which enables a receiver\n      to finish\
    \ a direct time synchronization.\n"
- title: 3.2.1.  Bootstrap Information
  contents:
  - "3.2.1.  Bootstrap Information\n   In order to initialize the TESLA component\
    \ at a receiver, the sender\n   must communicate some key information in a secure\
    \ way.  This\n   information can be sent in-band or out-of-band, as discussed\
    \ in\n   Section 2.2.  In this section, we only consider the in-band scheme.\n\
    \   The TESLA bootstrap information message MUST be digitally signed\n   (Section\
    \ 3.3.2).  The goal is to enable a receiver to check the\n   packet source and\
    \ packet integrity.  Then, the bootstrap information\n   can be:\n   o  unicast\
    \ to a receiver during a direct time synchronization\n      request/response exchange;\n\
    \   o  broadcast to all receivers.  This is typically the case in\n      indirect\
    \ time synchronization mode.  It can also be used in direct\n      time synchronization\
    \ mode, for instance, when a large number of\n      clients arrive at the same\
    \ time, in which case it is more\n      efficient to answer globally.\n   Let\
    \ us consider situations where the bootstrap information is\n   broadcast.  This\
    \ message should be broadcast at the beginning of the\n   session, before data\
    \ packets are actually sent.  This is particularly\n   important with ALC or NORM\
    \ sessions in \"push\" mode, when all clients\n   join the session in advance.\
    \  For improved reliability, bootstrap\n   information might be sent a certain\
    \ number of times.\n   A periodic broadcast of the bootstrap information message\
    \ could also\n   be useful when:\n   o  the ALC session uses an \"on-demand\"\
    \ mode, clients arriving at\n      their own discretion;\n   o  some clients experience\
    \ an intermittent connectivity.  This is\n      particularly important when several\
    \ key chains are used in an ALC\n      or NORM session, since there is a risk\
    \ that a receiver loses all\n      the commitments to the new key chain.\n   A\
    \ balance must be found between the signaling overhead and the\n   maximum initial\
    \ waiting time at the receiver before starting the\n   delayed authentication\
    \ process.  A period of a few seconds for the\n   transmission of this bootstrap\
    \ information is often a reasonable\n   value.\n"
- title: 3.2.2.  Direct Time Synchronization Response
  contents:
  - "3.2.2.  Direct Time Synchronization Response\n   In direct time synchronization,\
    \ upon receipt of a synchronization\n   request, the sender records its local\
    \ time, t_s, and sends a response\n   message that contains both t_r and t_s (Section\
    \ 2.4.1).  This message\n   is unicast to the receiver.  This direct time synchronization\n\
    \   response message MUST be digitally signed in order to enable a\n   receiver\
    \ to check the packet source and packet integrity\n   (Section 3.3.2).  The receiver\
    \ MUST also be able to associate this\n   response and his request, which is the\
    \ reason why t_r is included in\n   the response message.\n"
- title: 3.3.  TESLA Authentication Information
  contents:
  - "3.3.  TESLA Authentication Information\n   At a sender, TESLA produces three\
    \ types of security tags:\n   o  an authentication tag, in case of data packets,\
    \ and which contains\n      the MAC of the packet;\n   o  a digital signature,\
    \ in case of one of the two TESLA signaling\n      packets, namely a bootstrap\
    \ information message or a direct time\n      synchronization response; and\n\
    \   o  an optional group authentication tag, that can be added to all the\n  \
    \    packets to mitigate attacks coming from outside of the group.\n   Because\
    \ of interdependencies, their computation MUST follow a strict\n   order:\n  \
    \ o  first of all, compute the authentication tag (with data packet) or\n    \
    \  the digital signature (with signaling packet);\n   o  finally, compute the\
    \ Group Mac.\n"
- title: 3.3.1.  Authentication Tags
  contents:
  - "3.3.1.  Authentication Tags\n   All the data packets sent MUST have an authentication\
    \ tag containing:\n   o  the interval index, i, which is also the index of the\
    \ key used for\n      computing the MAC of this packet;\n   o  the MAC of the\
    \ message: MAC(K'_i, M), where K'_i=F'(K_i);\n   o  either a disclosed key (which\
    \ belongs to the current key chain or\n      the previous key chain), or a commitment\
    \ to a new key chain, or no\n      key at all.\n   The computation of MAC(K'_i,\
    \ M) MUST include the ALC or NORM header\n   (with the various header extensions)\
    \ and the payload (when\n   applicable).  The UDP/IP headers MUST NOT be included.\
    \  During this\n   computation, the \"MAC(K'_i, M)\" field of the authentication\
    \ tag MUST\n   be set to 0.\n"
- title: 3.3.2.  Digital Signatures
  contents:
  - "3.3.2.  Digital Signatures\n   The bootstrap information message (with the in-band\
    \ bootstrap scheme)\n   and direct time synchronization response message (with\
    \ the indirect\n   time synchronization scheme) both need to be signed by the\
    \ sender.\n   These two messages contain a \"Signature\" field to hold the digital\n\
    \   signature.  The bootstrap information message also contains the\n   \"Signature\
    \ Encoding Algorithm\", the \"Signature Cryptographic\n   Function\", and the\
    \ \"Signature Length\" fields that enable a receiver\n   to process the \"Signature\"\
    \ field.  Note that there are no such\n   \"Signature Encoding Algorithm\", \"\
    Signature Cryptographic Function\",\n   and \"Signature Length\" fields in the\
    \ case of a direct time\n   synchronization response message since it is assumed\
    \ that these\n   parameters are already known (i.e., the receiver either received\
    \ a\n   bootstrap information message before or these values have been\n   communicated\
    \ out-of-band).\n   Several \"Signature Encoding Algorithms\" can be used, including\n\
    \   RSASSA-PKCS1-v1_5, the default, and RSASSA-PSS (Section 7).  With\n   these\
    \ encodings, SHA-256 is the default \"Signature Cryptographic\n   Function\".\n\
    \   The computation of the signature MUST include the ALC or NORM header\n   (with\
    \ the various header extensions) and the payload when applicable.\n   The UDP/IP\
    \ headers MUST NOT be included.  During this computation,\n   the \"Signature\"\
    \ field MUST be set to 0 as well as the optional Group\n   MAC, when present,\
    \ since this Group MAC is calculated later.\n   More specifically, from [RFC4359]:\
    \ Digital signature generation is\n   performed as described in [RFC3447], Section\
    \ 8.2.1 for RSASSA-PKCS1-\n   v1_5 and Section 8.1.1 for RSASSA-PSS.  The authenticated\
    \ portion of\n   the packet is used as the message M, which is passed to the signature\n\
    \   generation function.  The signer's RSA private key is passed as K.\n   In\
    \ summary, (when SHA-256 is used), the signature generation process\n   computes\
    \ a SHA-256 hash of the authenticated packet bytes, signs the\n   SHA-256 hash\
    \ using the private key, and encodes the result with the\n   specified RSA encoding\
    \ type.  This process results in a value S,\n   which is the digital signature\
    \ to be included in the packet.\n   With RSASSA-PKCS1-v1_5 and RSASSA-PSS signatures,\
    \ the size of the\n   signature is equal to the \"RSA modulus\", unless the \"\
    RSA modulus\" is\n   not a multiple of 8 bits.  In that case, the signature MUST\
    \ be\n   prepended with between 1 and 7 bits set to zero such that the\n   signature\
    \ is a multiple of 8 bits [RFC4359].  The key size, which in\n   practice is also\
    \ equal to the \"RSA modulus\", has major security\n   implications.  [RFC4359]\
    \ explains how to choose this value depending\n   on the maximum expected lifetime\
    \ of the session.  This choice is out\n   of the scope of this document.\n"
- title: 3.3.3.  Group MAC Tags
  contents:
  - "3.3.3.  Group MAC Tags\n   An optional Group MAC can be used to mitigate Denial-of-Service\
    \ (DoS)\n   attacks coming from attackers that are not group members [RFC4082].\n\
    \   This feature assumes that a group key, K_g, is shared by the sender\n   and\
    \ all receivers.  When the attacker is not a group member, the\n   benefits of\
    \ adding a Group MAC to every packet sent are threefold:\n   o  a receiver can\
    \ immediately drop faked packets, without having to\n      wait for the disclosure\
    \ delay, d;\n   o  a sender can immediately drop faked direct time synchronization\n\
    \      requests, and avoid checking the digital signature, a computation\n   \
    \   intensive task;\n   o  a receiver can immediately drop faked direct time synchronization\n\
    \      response and bootstrap messages, without having to verify the\n      digital\
    \ signature, a computation-intensive task.\n   The computation of the Group MAC,\
    \ MAC(K_g, M), MUST include the ALC\n   or NORM header (with the various header\
    \ extensions) and the payload\n   when applicable.  The UDP/IP headers MUST NOT\
    \ be included.  During\n   this computation, the \"Group MAC\" field MUST be set\
    \ to 0.  However,\n   the digital signature (e.g., of a bootstrap message) and\
    \ the \"MAC\"\n   fields (e.g., of an authentication tag), when present, MUST\
    \ have been\n   calculated since they are included in the Group MAC calculation\n\
    \   itself.  Then, the sender truncates the MAC output to keep the n_w\n   most\
    \ significant bits and stores the result in the \"Group MAC\" field.\n   This\
    \ scheme features a few limits:\n   o  it is of no help if a group member (who\
    \ knows K_g) impersonates\n      the sender and sends forged messages to other\
    \ receivers;\n   o  it requires an additional MAC computing for each packet, both\
    \ at\n      the sender and receiver sides;\n   o  it increases the size of the\
    \ TESLA authentication headers.  In\n      order to limit this problem, the length\
    \ of the truncated output of\n      the MAC, n_w, SHOULD be kept small (e.g.,\
    \ 32 bits) (see [RFC3711],\n      Section 9.5).  As a side effect, the authentication\
    \ service is\n      significantly weakened: the probability of any forged packet\
    \ being\n      successfully authenticated becomes one in 2^32.  Since the Group\n\
    \      MAC check is only a pre-check that must be followed by the\n      standard\
    \ TESLA authentication check, this is not considered to be\n      an issue.\n\
    \   For a given use case, the benefits brought by the Group MAC must be\n   balanced\
    \ against these limitations.\n   Note that the Group MAC function can be different\
    \ from the TESLA MAC\n   function (e.g., it can use a weaker but faster MAC function).\
    \  Note\n   also that the mechanism by which the group key, K_g, is communicated\n\
    \   to all group members, and perhaps periodically updated, is out of the\n  \
    \ scope of this document.\n"
- title: 3.4.  Format of TESLA Messages and Authentication Tags
  contents:
  - "3.4.  Format of TESLA Messages and Authentication Tags\n   This section specifies\
    \ the format of the various kinds of TESLA\n   messages and authentication tags\
    \ sent by the session's sender.\n   Because these TESLA messages are carried as\
    \ EXT_AUTH Header\n   Extensions of the ALC or NORM packets (Section 5), the following\n\
    \   formats do not start on 32-bit word boundaries.\n"
- title: 3.4.1.  Format of a Bootstrap Information Message
  contents:
  - "3.4.1.  Format of a Bootstrap Information Message\n   When bootstrap information\
    \ is sent in-band, the following message is\n   used:\n   0                  \
    \ 1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                        \
    \          +-+-+-+-+-+-+-+-+  ---\n                                          \
    \        | V |resvd|S|G|A|  ^\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  |\n  |       d       |    PRF Type   | MAC Func Type |Gr MAC Fun Type|  | f\n\
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | i\n  |\
    \   SigEncAlgo  | SigCryptoFunc |       Signature Length        |  | x\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  | e\n  |            Reserved           |             T_int             |  |\
    \ d\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |\n\
    \  |                                                               |  | l\n  +\
    \                  T_0 (NTP timestamp format)                   +  | e\n  |  \
    \                                                             |  | n\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  | g\n  |                      N (Key Chain Length)                     |  |\
    \ t\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | h\n\
    \  |                    Current Interval Index i                   |  v\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  ---\n  |                                                               |\n\
    \  ~                 Current Key Chain Commitment  +-+-+-+-+-+-+-+-+\n  |    \
    \                                           |   Padding     |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \  |                                                               |\n  +    \
    \                                                           +\n  ~           \
    \                Signature                           ~\n  +                  \
    \                             +-+-+-+-+-+-+-+-+\n  |                         \
    \                      |    Padding    |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \  |P|                                                             |\n  +-+  \
    \     D^O_t Extension (optional, present if A==1)           +\n  |    (NTP timestamp\
    \ diff, positive if P==1, negative if P==0)   |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \  ~                      Group MAC (optional)                     ~\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 2: Bootstrap Information Format\n   The format of the\
    \ bootstrap information is depicted in Figure 2.  The\n   fields are:\n   \"V\"\
    \ (Version) field (2 bits):\n      The \"V\" field contains the version number\
    \ of the protocol.  For\n      this specification, the value of 0 MUST be used.\n\
    \   \"Reserved\" field (3 bits):\n      This is a reserved field that MUST be\
    \ set to zero in this\n      specification.\n   \"S\" (Single Key Chain) flag\
    \ (1 bit):\n      The \"S\" flag indicates whether this TESLA session is restricted\
    \ to\n      a single key chain (S==1) or relies on one or multiple key chains\n\
    \      (S==0).\n   \"G\" (Group MAC Present) flag (1 bit):\n      The \"G\" flag\
    \ indicates whether the Group MAC feature is used\n      (G==1) or not (G==0).\
    \  When it is used, a \"Group MAC\" field is\n      added to all the packets containing\
    \ a TESLA EXT_AUTH Header\n      Extension (including this bootstrap message).\n\
    \   \"A\" flag (1 bit):\n      The \"A\" flag indicates whether the \"P\" flag\
    \ and \"D^O_t\" fields are\n      present (A==1) or not (A==0).  In indirect time\
    \ synchronization\n      mode, A MUST be equal to 1 since these fields are needed.\n\
    \   \"d\" field (8 bits):\n      \"d\" is an unsigned integer that defines the\
    \ key disclosure delay\n      (in number of intervals). d MUST be greater than\
    \ or equal to 2.\n   \"PRF Type\" field (8 bits):\n      The \"PRF Type\" is the\
    \ reference number of the f function used to\n      derive the F (for key chain)\
    \ and F' (for MAC keys) functions\n      (Section 7).\n   \"MAC Function Type\"\
    \ field (8 bits):\n      The \"MAC Function Type\" is the reference number of\
    \ the function\n      used to compute the MAC of the packets (Section 7).\n  \
    \ \"Group MAC Function Type\" field (8 bits):\n      When G==1, this field contains\
    \ the reference number of the\n      cryptographic MAC function used to compute\
    \ the Group MAC\n      (Section 7).  When G==0, this field MUST be set to zero.\n\
    \   \"Signature Encoding Algorithm\" field (8 bits):\n      The \"Signature Encoding\
    \ Algorithm\" is the reference number\n      (Section 7) of the digital signature\
    \ used to authenticate this\n      bootstrap information and included in the \"\
    Signature\" field.\n   \"Signature Cryptographic Function\" field (8 bits):\n\
    \      The \"Signature Cryptographic Function\" is the reference number\n    \
    \  (Section 7) of the cryptographic function used within the digital\n      signature.\n\
    \   \"Signature Length\" field (16 bits):\n      The \"Signature Length\" is an\
    \ unsigned integer that indicates the\n      \"Signature\" field size in bytes\
    \ in the \"Signature Extension\"\n      field.  This is also the signature key\
    \ length, since both\n      parameters are equal.\n   \"Reserved\" fields (16\
    \ bits):\n      This is a reserved field that MUST be set to zero in this\n  \
    \    specification.\n   \"T_int\" field (16 bits):\n      \"T_int\" is an unsigned\
    \ 16-bit integer that defines the interval\n      duration (in milliseconds).\n\
    \   \"T_0\" field (64 bits):\n      \"T_0\" is a timestamp in NTP timestamp format\
    \ that indicates the\n      beginning of the session, i.e., the beginning of time\
    \ interval 0.\n   \"N\" field (32 bits):\n      \"N\" is an unsigned integer that\
    \ indicates the key chain length.\n      There are N + 1 keys per chain.\n   \"\
    i\" (Interval Index of K_i) field (32 bits):\n      \"i\" is an unsigned integer\
    \ that indicates the current interval\n      index when this bootstrap information\
    \ message is sent.\n   \"Current Key Chain Commitment\" field (variable size,\
    \ padded if\n   necessary for 32-bit word alignment):\n      \"Key Chain Commitment\"\
    \ is the commitment to the current key chain,\n      i.e., the key chain corresponding\
    \ to interval i.  For instance,\n      with the first key chain, this commitment\
    \ is equal to F(K_0), with\n      the second key chain, this commitment is equal\
    \ to F(K_{N+1}),\n      etc.).  If need be, this field is padded (with 0) up to\
    \ a multiple\n      of 32 bits.\n   \"Signature\" field (variable size, padded\
    \ if necessary for 32-bit word\n   alignment):\n      The \"Signature\" field\
    \ is mandatory.  It contains a digital\n      signature of this message, as specified\
    \ by the encoding algorithm,\n      cryptographic function, and key length parameters.\
    \  If the\n      signature length is not a multiple of 32 bits, this field is\n\
    \      padded with 0.\n   \"P\" flag (optional, 1 bit if present):\n      The\
    \ \"P\" flag is optional and only present if the \"A\" flag is equal\n      to\
    \ 1.  It is only used in indirect time synchronization mode.\n      This flag\
    \ indicates whether the D^O_t NTP timestamp difference is\n      positive (P==1)\
    \ or negative (P==0).\n   \"D^O_t\" field (optional, 63 bits if present):\n  \
    \    The \"D^O_t\" field is optional and only present if the \"A\" flag is\n \
    \     equal to 1.  It is only used in indirect time synchronization\n      mode.\
    \  It is the upper bound of the lag of the sender's clock with\n      respect\
    \ to the time reference.  When several time references are\n      specified (e.g.,\
    \ several NTP servers), then D^O_t is the maximum\n      upper bound of the lag\
    \ with each time reference.  D^O_t is\n      composed of two unsigned integers,\
    \ as with NTP timestamps: the\n      first 31 bits give the time difference in\
    \ seconds and the\n      remaining 32 bits give the sub-second time difference.\n\
    \   \"Group MAC\" field (optional, variable length, multiple of 32 bits):\n  \
    \    This field contains the Group MAC, calculated with the group key,\n     \
    \ K_g, shared by all group members.  The field length, in bits, is\n      given\
    \ by n_w, which is known once the Group MAC function type is\n      known (Section\
    \ 7).\n   Note that the first byte and the following seven 32-bit words are\n\
    \   mandatory fixed-length fields.  The \"Current Key Chain Commitment\"\n   and\
    \ \"Signature\" fields are mandatory but variable-length fields.  The\n   remaining\
    \ \"D^O_t\" and \"Group MAC\" fields are optional.\n   In order to prevent attacks,\
    \ some parameters MUST NOT be changed\n   during the lifetime of the session (Sections\
    \ 3.1.3 and 3.1.4).  The\n   following table summarizes the parameter's status:\n\
    \   +--------------------------+----------------------------------------+\n  \
    \ |         Parameter        |                 Status                 |\n   +--------------------------+----------------------------------------+\n\
    \   |             V            |     set to 0 in this specification     |\n  \
    \ |             S            |      static (during whole session)     |\n   |\
    \             G            |      static (during whole session)     |\n   |  \
    \           A            |      static (during whole session)     |\n   |    \
    \        T_O           |      static (during whole session)     |\n   |      \
    \     T_int          |      static (during whole session)     |\n   |        \
    \     d            |      static (during whole session)     |\n   |          \
    \   N            |      static (during whole session)     |\n   |    D^O_t (if\
    \ present)    |      static (during whole session)     |\n   |         PRF Type\
    \         |      static (during whole session)     |\n   |     MAC Function Type\
    \    |      static (during whole session)     |\n   |    Signature Encoding  \
    \  |      static (during whole session)     |\n   |         Algorithm        |\
    \                                        |\n   |    Signature Crypto.     |  \
    \    static (during whole session)     |\n   |         Function         |    \
    \                                    |\n   |     Signature Length     |      static\
    \ (during whole session)     |\n   |   Group MAC Func.  Type  |      static (during\
    \ whole session)     |\n   |             i            | dynamic (related to current\
    \ key chain) |\n   |            K_i           | dynamic (related to current key\
    \ chain) |\n   |         signature        |        dynamic, packet dependent \
    \      |\n   |  Group MAC (if present)  |        dynamic, packet dependent   \
    \    |\n   +--------------------------+----------------------------------------+\n"
- title: 3.4.2.  Format of a Direct Time Synchronization Response
  contents:
  - "3.4.2.  Format of a Direct Time Synchronization Response\n     0            \
    \       1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                \
    \                    +-+-+-+-+-+-+-+-+\n                                     \
    \               |    Reserved   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                     t_s (NTP timestamp)                       +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                     t_r (NTP timestamp)                       +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                                                               +\n    ~     \
    \                      Signature                           ~\n    +          \
    \                                     +-+-+-+-+-+-+-+-+\n    |               \
    \                                |    Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ~                     Group MAC (optional)                      ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Figure 3: Format of a Direct Time Synchronization Response\n   The response\
    \ to a direct time synchronization request contains the\n   following information:\n\
    \   \"Reserved\" field (8 bits):\n      This is a reserved field that MUST be\
    \ set to zero in this\n      specification.\n   \"t_s\" (NTP timestamp, 64 bits):\n\
    \      \"t_s\" is a timestamp in NTP timestamp format that corresponds to\n  \
    \    the sender local time value when receiving the direct time\n      synchronization\
    \ request message.\n   \"t_r\" (NTP timestamp, 64 bits):\n      \"t_r\" is a timestamp\
    \ in NTP timestamp format that contains the\n      receiver local time value received\
    \ in the direct time\n      synchronization request message.\n   \"Signature\"\
    \ field (variable size, padded if necessary for 32-bit word\n   alignment):\n\
    \      The \"Signature\" field is mandatory.  It contains a digital\n      signature\
    \ of this message, as specified by the encoding algorithm,\n      cryptographic\
    \ function, and key length parameters communicated in\n      the bootstrap information\
    \ message (if applicable) or out-of-band.\n      If the signature length is not\
    \ a multiple of 32 bits, this field\n      is padded with 0.\n   \"Group MAC\"\
    \ field (optional, variable length, multiple of 32 bits):\n      This field contains\
    \ the Group MAC, calculated with the group key,\n      K_g, shared by all group\
    \ members.  The field length, in bits, is\n      given by n_w, which is known\
    \ once the Group MAC function type is\n      known (Section 7).\n"
- title: 3.4.3.  Format of a Standard Authentication Tag
  contents:
  - "3.4.3.  Format of a Standard Authentication Tag\n     0                   1 \
    \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                          \
    \          +-+-+-+-+-+-+-+-+\n                                               \
    \     |   Reserved    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                i (Interval Index of K'_i)                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    ~\
    \                    Disclosed Key K_{i-d}                      ~\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    ~\
    \                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+\n    |     \
    \                                          |   Padding     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ~                     Group MAC (optional)                      ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 4: Format of the Standard Authentication Tag\n   A Standard\
    \ Authentication Tag is composed of the following fields:\n   \"Reserved\" field\
    \ (8 bits):\n      The \"Reserved\" field is not used in the current specification\
    \ and\n      MUST be set to zero by the sender.\n   \"i\" (Interval Index) field\
    \ (32 bits):\n      \"i\" is the interval index associated with the key (K'_i)\
    \ used to\n      compute the MAC of this packet.\n   \"Disclosed Key\" (variable\
    \ size, non padded):\n      The \"Disclosed Key\" is the key used for interval\
    \ i-d: K_{i-d}.\n      There is no padding between the \"Disclosed Key\" and \"\
    MAC(K'_i, M)\"\n      fields, and the latter MAY not start on a 32-bit boundary,\n\
    \      depending on the n_p parameter.\n   \"MAC(K'_i, M)\" (variable size, padded\
    \ if necessary for 32-bit word\n   alignment):\n      \"MAC(K'_i, M)\" is the\
    \ truncated message authentication code of the\n      current packet.  Only the\
    \ n_m most significant bits of the MAC\n      output are kept [RFC2104].\n   \"\
    Group MAC\" field (optional, variable length, multiple of 32 bits):\n      This\
    \ field contains the Group MAC, calculated with a group key,\n      K_g, shared\
    \ by all group members.  The field length is given by\n      n_w, in bits.\n \
    \  Note that because a key cannot be disclosed before the disclosure\n   delay,\
    \ d, the sender MUST NOT use this tag during the first d\n   intervals of the\
    \ session: {0 .. d-1} (inclusive).  Instead, the\n   sender MUST use an Authentication\
    \ Tag without Key Disclosure.\n"
- title: 3.4.4.  Format of an Authentication Tag without Key Disclosure
  contents:
  - "3.4.4.  Format of an Authentication Tag without Key Disclosure\n   The Authentication\
    \ Tag without Key Disclosure is meant to be used in\n   situations where a high\
    \ number of packets are sent in a given time\n   interval.  In such a case, it\
    \ can be advantageous to disclose the\n   K_{i-d} key only in a subset of the\
    \ packets sent, using a Standard\n   Authentication Tag, and to use the shortened\
    \ version that does not\n   disclose the K_{i-d} key in the remaining packets.\
    \  It is left to the\n   implementer to decide how many packets should disclose\
    \ the K_{i-d}\n   key.  This Authentication Tag without Key Disclosure MUST also\
    \ be\n   used during the first d intervals: {0 .. d-1} (inclusive).\n     0  \
    \                 1                   2                   3\n     0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                      \
    \                              +-+-+-+-+-+-+-+-+\n                           \
    \                         |   Reserved    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                i (Interval Index of K'_i)                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    ~\
    \                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+\n    |     \
    \                                          |   Padding     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ~                     Group MAC (optional)                      ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 5: Format of the Authentication Tag without Key Disclosure\n"
- title: 3.4.5.  Format of an Authentication Tag with a "New Key Chain"
  contents:
  - "3.4.5.  Format of an Authentication Tag with a \"New Key Chain\"\n        Commitment\n\
    \   During the last n_tx_newkcc intervals of the current key chain, the\n   sender\
    \ SHOULD send commitments to the next key chain.  This is done\n   by replacing\
    \ the disclosed key of the Authentication Tag with a New\n   Key Chain Commitment,\
    \ F(K_{N+1}) (or F(K_{2N+2}) in case of a switch\n   between the second and third\
    \ key chains, etc.)  Figure 6 shows the\n   corresponding format.\n   Note that\
    \ since there is no padding between the \"F(K_{N+1})\" and\n   \"MAC(K'_i, M)\"\
    \ fields, the latter MAY not start on a 32-bit boundary,\n   depending on the\
    \ n_p parameter.\n     0                   1                   2             \
    \      3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \                                                    +-+-+-+-+-+-+-+-+\n     \
    \                                               |   Reserved    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                i (Interval Index of K'_i)                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    ~\
    \              New Key Commitment F(K_{N+1})                    ~\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    ~\
    \                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+\n    |     \
    \                                          |   Padding     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ~                     Group MAC (optional)                      ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 6: Format of the Authentication Tag\n                \
    \      with a New Key Chain Commitment\n"
- title: 3.4.6.  Format of an Authentication Tag with a "Last Key of Old Chain"
  contents:
  - "3.4.6.  Format of an Authentication Tag with a \"Last Key of Old Chain\"\n  \
    \      Disclosure\n   During the first n_tx_lastkey intervals of the new key chain\
    \ after\n   the disclosing interval, d, the sender SHOULD disclose the last key\n\
    \   of the old key chain.  This is done by replacing the disclosed key of\n  \
    \ the Authentication Tag with the Last Key of the Old Chain, K_N (or\n   K_{2N+1}\
    \ in case of a switch between the second and third key chains,\n   etc.).  Figure\
    \ 7 shows the corresponding format.\n   Note that since there is no padding between\
    \ the \"K_N\" and \"MAC(K'_i,\n   M)\" fields, the latter MAY not start on a 32-bit\
    \ boundary, depending\n   on the n_p parameter.\n     0                   1  \
    \                 2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                          \
    \          +-+-+-+-+-+-+-+-+\n                                               \
    \     |   Reserved    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                i (Interval Index of K'_i)                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    ~\
    \                  Last Key of Old Chain, K_N                   ~\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    ~\
    \                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+\n    |     \
    \                                          |   Padding     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ~                     Group MAC (optional)                      ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 7: Format of the Authentication Tag\n                \
    \   with an Old Chain Last Key Disclosure\n"
- title: 4.  Receiver Operations
  contents:
  - "4.  Receiver Operations\n   This section describes the TESLA operations at a\
    \ receiver.\n"
- title: 4.1.  Verification of the Authentication Information
  contents:
  - "4.1.  Verification of the Authentication Information\n   This section details\
    \ the computation steps required to verify each of\n   the three possible authentication\
    \ information of an incoming packet.\n   The verification MUST follow a strict\
    \ order:\n   o  first of all, if the Group MAC is present and if the session uses\n\
    \      this feature (e.g., if the G bit is set in the bootstrap\n      information\
    \ message), then verify the Group MAC.  A packet that\n      does not contain\
    \ a Group MAC tag, whereas the session uses this\n      feature, MUST be dropped\
    \ immediately.  On the opposite, if a\n      packet contains a Group MAC tag whereas\
    \ the session does not use\n      this feature, this tag MUST be ignored;\n  \
    \ o  then, verify the digital signature (with TESLA signaling packets)\n     \
    \ or enter the TESLA authentication process (with data packets).\n"
- title: 4.1.1.  Processing the Group MAC Tag
  contents:
  - "4.1.1.  Processing the Group MAC Tag\n   Upon receiving a packet containing a\
    \ Group MAC tag, the receiver\n   recomputes the Group MAC and compares it to\
    \ the value carried in the\n   packet.  If the check fails, the packet MUST be\
    \ dropped immediately.\n   More specifically, recomputing the Group MAC requires\
    \ saving the\n   value of the \"Group MAC\" field, setting this field to 0, and\
    \ doing\n   the same computation as a sender does (see Section 3.3.3).\n"
- title: 4.1.2.  Processing the Digital Signature
  contents:
  - "4.1.2.  Processing the Digital Signature\n   Upon receiving a packet containing\
    \ a digital signature, the receiver\n   verifies the signature as follows.\n \
    \  The computation of the signature MUST include the ALC or NORM header\n   (with\
    \ the various header extensions) and the payload when applicable.\n   The UDP/IP\
    \ headers MUST NOT be included.  During this computation,\n   the \"Signature\"\
    \ field MUST be set to 0 as well as the optional Group\n   MAC, when present.\n\
    \   From [RFC4359]: Digital signature verification is performed as\n   described\
    \ in [RFC3447], Section 8.2.2 (RSASSA-PKCS1-v1_5) and\n   [RFC3447], Section 8.1.2\
    \ (RSASSA-PSS).  Upon receipt, the digital\n   signature is passed to the verification\
    \ function as S.  The\n   authenticated portion of the packet is used as the message\
    \ M, and the\n   RSA public key is passed as (n, e).  In summary (when SHA-256\
    \ is\n   used), the verification function computes a SHA-256 hash of the\n   authenticated\
    \ packet bytes, decrypts the SHA-256 hash in the packet,\n   and validates that\
    \ the appropriate encoding was applied.  The two\n   SHA-256 hashes are compared,\
    \ and if they are identical the validation\n   is successful.\n   It is assumed\
    \ that the receivers have the possibility to retrieve the\n   sender's public\
    \ key required to check this digital signature\n   (Section 2.2).  This document\
    \ does not specify how the public key of\n   the sender is communicated reliably\
    \ and in a secure way to all\n   possible receivers.\n"
- title: 4.1.3.  Processing the Authentication Tag
  contents:
  - "4.1.3.  Processing the Authentication Tag\n   When a receiver wants to authenticate\
    \ a packet using an\n   authentication tag and when he has the key for the associated\
    \ time\n   interval (i.e., after the disclosing delay, d), the receiver\n   recomputes\
    \ the MAC and compares it to the value carried in the\n   packet.  If the check\
    \ fails, the packet MUST be immediately dropped.\n   More specifically, recomputing\
    \ the MAC requires saving the value of\n   the \"MAC\" field, setting this field\
    \ to 0, and doing the same\n   computation as a sender does (see Section 3.3.1).\n"
- title: 4.2.  Initialization of a Receiver
  contents:
  - "4.2.  Initialization of a Receiver\n   A receiver MUST be initialized before\
    \ being able to authenticate the\n   source of incoming packets.  This can be\
    \ done by an out-of-band\n   mechanism or an in-band mechanism (Section 2.2).\
    \  Let us focus on the\n   in-band mechanism.  Two actions must be performed:\n\
    \   o  receive and process a bootstrap information message, and\n   o  calculate\
    \ an upper bound of the sender's local time.  To that\n      purpose, the receiver\
    \ must perform time synchronization.\n"
- title: 4.2.1.  Processing the Bootstrap Information Message
  contents:
  - "4.2.1.  Processing the Bootstrap Information Message\n   A receiver must first\
    \ receive a packet containing the bootstrap\n   information, digitally signed\
    \ by the sender.  Once the bootstrap\n   information has been authenticated (see\
    \ Section 4.1), the receiver\n   can initialize its TESLA component.  The receiver\
    \ MUST then ignore\n   the following bootstrap information messages, if any. \
    \ There is an\n   exception though: when a new key chain is used and if a receiver\n\
    \   missed all the commitments for this new key chain, then this receiver\n  \
    \ MUST process one of the future bootstrap information messages (if\n   any) in\
    \ order to be able to authenticate the incoming packets\n   associated to this\
    \ new key chain.\n   Before TESLA has been initialized, a receiver MUST discard\
    \ incoming\n   packets other than the bootstrap information message and direct\
    \ time\n   synchronization response.\n"
- title: 4.2.2.  Performing Time Synchronization
  contents:
  - "4.2.2.  Performing Time Synchronization\n   First of all, the receiver must know\
    \ whether the ALC or NORM session\n   relies on direct or indirect time synchronization.\
    \  This information\n   is communicated by an out-of-band mechanism (for instance,\
    \ when\n   describing the various parameters of an ALC or NORM session).  In\n\
    \   some cases, both mechanisms might be available and the receiver can\n   choose\
    \ the preferred technique.\n"
- title: 4.2.2.1.  Direct Time Synchronization
  contents:
  - "4.2.2.1.  Direct Time Synchronization\n   In the case of a direct time synchronization,\
    \ a receiver MUST\n   synchronize with the sender.  To that purpose, the receiver\
    \ sends a\n   direct time synchronization request message.  This message includes\n\
    \   the local time (in NTP timestamp format) at the receiver when sending\n  \
    \ the message.  This timestamp will be copied in the sender's response\n   for\
    \ the receiver to associate the response to the request.\n   The direct time synchronization\
    \ request message format is the\n   following:\n     0                   1   \
    \                2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                     t_r (NTP timestamp)                       +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ~                     Group MAC (optional)                      ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 8: Format of a Direct Time Synchronization Request\n   The direct\
    \ time synchronization request (Figure 8) contains the\n   following information:\n\
    \   \"t_r\" (NTP timestamp, 64 bits):\n      \"t_r\" is a timestamp in NTP timestamp\
    \ format that contains the\n      receiver local time value when sending this\
    \ direct time\n      synchronization request message;\n   \"Group MAC\" field\
    \ (optional, variable length, multiple of 32 bits):\n      This field contains\
    \ the Group MAC, calculated with the group key,\n      K_g, shared by all group\
    \ members.  The field length, in bits, is\n      given by n_w, which is known\
    \ once the Group MAC function type is\n      known (Section 7).\n   The receiver\
    \ then awaits a response message (Section 3.4.2).  Upon\n   receiving this message,\
    \ the receiver:\n      checks that this response relates to the request, by comparing\
    \ the\n      \"t_r\" fields;\n      checks the Group MAC if present;\n      checks\
    \ the signature;\n      retrieves the t_s value and calculates D_t (Section 2.4.1).\n\
    \   Note that in an ALC session, the direct time synchronization request\n   message\
    \ is sent to the sender by an out-of-band mechanism that is not\n   specified\
    \ by the current document.\n"
- title: 4.2.2.2.  Indirect Time Synchronization
  contents:
  - "4.2.2.2.  Indirect Time Synchronization\n   With the indirect time synchronization\
    \ method, the sender MAY provide\n   out-of-band the URL or IP address of the\
    \ NTP server(s) he trusts\n   along with an OPTIONAL certificate for each NTP\
    \ server.  When several\n   NTP servers are specified, a receiver MUST choose\
    \ one of them.  This\n   document does not specify how the choice is made, but\
    \ for the sake of\n   scalability, the clients SHOULD NOT use the same server\
    \ if several\n   possibilities are offered.  The NTP synchronization between the\
    \ NTP\n   server and the receiver MUST be authenticated, either using the\n  \
    \ certificate provided by the server or another certificate the client\n   may\
    \ obtain for this NTP server.\n   Then the receiver computes the time offset between\
    \ itself and the NTP\n   server chosen.  Note that the receiver does not need\
    \ to update the\n   local time, (which often requires root privileges), computing\
    \ the\n   time offset is sufficient.\n   Since the offset between the server and\
    \ the time reference, D^O_t, is\n   indicated in the bootstrap information message\
    \ (or communicated out-\n   of-band), the receiver can now calculate an upper\
    \ bound of the\n   sender's local time (Section 2.4.2).\n   Note that this scenario\
    \ assumes that each client trusts the sender\n   and accepts aligning its NTP\
    \ configuration to that of the sender,\n   using one of the NTP server(s) suggested.\
    \  If this assumption does\n   not hold, the client MUST NOT use the NTP indirect\
    \ time\n   synchronization method (Section 2.3.2).\n"
- title: 4.3.  Authentication of Received Packets
  contents:
  - "4.3.  Authentication of Received Packets\n   The receiver can now authenticate\
    \ incoming packets (other than\n   bootstrap information and direct time synchronization\
    \ response\n   packets).  To that purpose, he MUST follow different steps (see\n\
    \   [RFC4082], Section 3.5):\n   1.  The receiver parses the different packet\
    \ headers.  If none of the\n       four TESLA authentication tags are present,\
    \ the receiver MUST\n       discard the packet.  If the session is in \"Single\
    \ Key Chain\" mode\n       (e.g., when the \"S\" flag is set in the bootstrap\
    \ information\n       message), then the receiver MUST discard any packet containing\
    \ an\n       Authentication Tag with a New Key Chain Commitment or an\n      \
    \ Authentication Tag with a Last Key of Old Chain Disclosure.\n   2.  Safe packet\
    \ test: When the receiver receives packet P_j, it first\n       records the local\
    \ time T at which the packet arrived.  The\n       receiver then computes an upper\
    \ bound t_j on the sender's clock\n       at the time when the packet arrived:\
    \ t_j = T + D_t.  The receiver\n       then computes the highest interval the\
    \ sender could possibly be\n       in: highest_i = floor((t_j - T_0) / T_int).\
    \  He also retrieves\n       the \"i\" interval index from the authentication\
    \ tag.  The receiver\n       can now proceed with the \"safe packet\" test.  If\
    \ highest_i < i +\n       d, then the sender is not yet in the interval during\
    \ which it\n       discloses the key K_i.  The packet is safe (but not necessarily\n\
    \       authentic).  If the test fails, the packet is unsafe, and the\n      \
    \ receiver MUST discard the packet.\n   3.  Group MAC test: if the optional Group\
    \ MAC tag is present and if\n       the session uses this feature, then verify\
    \ the Group MAC\n       (Section 4.1.1).  If the verification fails, the packet\
    \ MUST be\n       immediately dropped.  A packet that does not contain a Group\
    \ MAC\n       tag whereas the session uses this feature MUST be immediately\n\
    \       dropped.  On the opposite, if a packet contains a Group MAC tag\n    \
    \   whereas the session does not use this feature, this tag MUST be\n       ignored.\n\
    \   4.  Disclosed Key processing: When the packet discloses a key (i.e.,\n   \
    \    with a Standard Authentication Tag, or with an Authentication Tag\n     \
    \  with a Last Key of Old Chain Disclosure), the following tests are\n       performed:\n\
    \       *  New key index test: the receiver checks whether a legitimate\n    \
    \      key already exists with the same index (i.e., i-d).  If such a\n      \
    \    legitimate key exists, the receiver compares its value with\n          the\
    \ current disclosed key and if they are identical, skips the\n          \"Unverifiable\
    \ key test\" and \"Key verification test\".  If such\n          a legitimate key\
    \ exists but the values differ, the receiver\n          MUST discard the packet.\n\
    \       *  Unverifiable key test: when the disclosed key index is new, it\n  \
    \        is possible that no earlier disclosed and legitimate key\n          exists\
    \ for this key chain, thereby preventing the verification\n          of the disclosed\
    \ key.  This happens when the disclosed key\n          belongs to the old key\
    \ chain and no commitment to this old key\n          chain has ever been received\
    \ (e.g., because the first\n          bootstrap packet received by a latecomer\
    \ is for the current\n          key chain, and therefore includes a commitment\
    \ to the current\n          key chain, not the previous one).  When this happens,\
    \ the\n          receiver MUST ignore the disclosed key (anyway useless) and\n\
    \          skip the Key verification test.\n       *  Key verification test: If\
    \ the disclosed key index is new and\n          the key can be verified, the receiver\
    \ checks the legitimacy of\n          K_{i-d} by verifying, for some earlier disclosed\
    \ and\n          legitimate key K_v (with v < i-d), that K_v and F^{i-d-\n   \
    \       v}(K_{i-d}) are identical.  In other words, the receiver\n          checks\
    \ the disclosed key by computing the necessary number of\n          PRF functions\
    \ to obtain a previously disclosed and legitimate\n          (i.e., verified)\
    \ key.  If the key verification fails, the\n          receiver MUST discard the\
    \ packet.  If the key verification\n          succeeds, this key is said to be\
    \ legitimate and is stored by\n          the receiver, as well as all the keys\
    \ between indexes v and\n          i-d.\n   5.  When applicable, the receiver\
    \ performs any congestion control\n       related action (i.e., the ALC or NORM\
    \ headers are used by the\n       associated congestion control building block,\
    \ if any), even if\n       the packet has not yet been authenticated [RFC5651].\
    \  If this\n       feature leads to a potential DoS attack (the attacker can send\
    \ a\n       faked packet with a wrong sequence number to simulate packet\n   \
    \    losses), it does not compromise the security features offered by\n      \
    \ TESLA and enables a rapid reaction in front of actual congestion\n       problems.\n\
    \   6.  The receiver then buffers the packet for a later authentication,\n   \
    \    once the corresponding key will be disclosed (after d time\n       intervals)\
    \ or deduced from another key (if all packets disclosing\n       this key are\
    \ lost).  In some situations, this packet might also\n       be discarded later,\
    \ if it turns out that the receiver will never\n       be able to deduce the associated\
    \ key.\n   7.  Authentication test: Let v be the smallest index of the\n     \
    \  legitimate keys known by the receiver so far.  For all the new\n       keys\
    \ K_w, with v < w <= i-d, that have been either disclosed by\n       this packet\
    \ (i.e., K_{i-d}) or derived by K_{i-d} (i.e., keys in\n       interval {v+1,..\
    \ i-d-1}), the receiver verifies the authenticity\n       of the safe packets\
    \ buffered for the corresponding interval w.\n       To authenticate one of the\
    \ buffered packets P_h containing\n       message M_h protected with a MAC that\
    \ used key index w, the\n       receiver will compute K'_w = F'(K_w) from which\
    \ it can compute\n       MAC( K'_w, M_h).  If this MAC does not equal the MAC\
    \ stored in\n       the packet, the receiver MUST discard the packet.  If the\
    \ two\n       MACs are equal, the packet is successfully authenticated and the\n\
    \       receiver continues processing it.\n   8.  Authenticated new key chain\
    \ commitment processing: If the\n       authenticated packet contains a new key\
    \ chain commitment and if\n       no verified commitment already exists, then\
    \ the receiver stores\n       the commitment to the new key chain.  Then, if there\
    \ are non-\n       authenticated packets for a previous chain (i.e., the key chain\n\
    \       before the current one), all these packets can be discarded\n       (Section\
    \ 4.4).\n   9.  The receiver continues the ALC or NORM processing of all the\n\
    \       packets authenticated during the authentication test.\n   In this specification,\
    \ a receiver using TESLA MUST immediately drop\n   unsafe packets.  But the receiver\
    \ MAY also decide, at any time, to\n   continue an ALC or NORM session in unsafe\
    \ (insecure) mode, ignoring\n   TESLA extensions.  There SHOULD be an explicit\
    \ user action to that\n   purpose.\n"
- title: 4.3.1.  Discarding Unnecessary Packets Earlier
  contents:
  - "4.3.1.  Discarding Unnecessary Packets Earlier\n   Following strictly the above\
    \ steps can lead to excessive processing\n   overhead in certain situations. \
    \ This is the case when a receiver\n   receives packets for an unwanted object\
    \ with the ALC or NORM\n   protocols, i.e., an object in which the application\
    \ (or the end user)\n   explicitly mentioned it is not interested.  This is also\
    \ the case\n   when a receiver receives packets for an already decoded object,\
    \ or\n   when this object has been partitioned in several blocks, for an\n   already\
    \ decoded block.  When such a packet is received, which is\n   easily identified\
    \ by looking at the receiver's status for the\n   incoming ALC or NORM packet,\
    \ the receiver MUST also check that the\n   packet is a pure data packet that\
    \ does not contain any signaling\n   information of importance for the session.\n\
    \   With ALC, a packet containing an \"A\" flag (\"Close Session\") or a \"B\"\
    \n   flag (\"Close Object\") MUST NOT be discarded before having been\n   authenticated\
    \ and processed normally.  Otherwise, the receiver can\n   safely discard the\
    \ incoming packet for instance just after step 1 of\n   Section 4.3.  This optimization\
    \ can dramatically reduce the\n   processing overhead by avoiding many useless\
    \ authentication checks.\n"
- title: 4.4.  Flushing the Non-Authenticated Packets of a Previous Key Chain
  contents:
  - "4.4.  Flushing the Non-Authenticated Packets of a Previous Key Chain\n   In some\
    \ cases, a receiver having experienced a very long\n   disconnection might have\
    \ lost all the disclosures of the last key(s)\n   of a previous key chain.  Let\
    \ j be the index of this key chain for\n   which there remains non-authenticated\
    \ packets.  This receiver can\n   flush all the packets of the key chain j if\
    \ he determines that:\n   o  he has just switched to a chain of index j+2 (inclusive)\
    \ or\n      higher;\n   o  the sender has sent a commitment to the new key chain\
    \ of index j+2\n      (Section 3.1.2.3).  This situation requires that the receiver\
    \ has\n      received a packet containing such a commitment and that he has\n\
    \      been able to check its integrity.  In some cases, it might require\n  \
    \    receiving a bootstrap information message for the current key\n      chain.\n\
    \   If one of the above two tests succeeds, the sender can discard all\n   the\
    \ awaiting packets since there is no way to authenticate them.\n"
- title: 5.  Integration in the ALC and NORM Protocols
  contents:
  - '5.  Integration in the ALC and NORM Protocols

    '
- title: 5.1.  Authentication Header Extension Format
  contents:
  - "5.1.  Authentication Header Extension Format\n   The integration of TESLA in\
    \ ALC or NORM is similar and relies on the\n   header extension mechanism defined\
    \ in both protocols.  More\n   precisely, this document details the EXT_AUTH==1\
    \ header extension\n   defined in [RFC5651].\n   Several fields are added in addition\
    \ to the \"HET\" (Header Extension\n   Type) and \"HEL\" (Header Extension Length)\
    \ fields (Figure 9).\n     0                   1                   2         \
    \          3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |   HET (=1)    |      HEL      |  ASID |  Type |               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \               +\n    |                                                     \
    \          |\n    ~                                                          \
    \     ~\n    |                            Content                            |\n\
    \    ~                                                               ~\n    |\
    \                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 9: Format of the TESLA EXT_AUTH Header Extension\n   The fields\
    \ of the TESLA EXT_AUTH Header Extension are:\n   \"ASID\" (Authentication Scheme\
    \ IDentifier) field (4 bits):\n      The \"ASID\" identifies the source authentication\
    \ scheme or protocol\n      in use.  The association between the \"ASID\" value\
    \ and the actual\n      authentication scheme is defined out-of-band, at session\
    \ startup.\n   \"Type\" field (4 bits):\n      The \"Type\" field identifies the\
    \ type of TESLA information carried\n      in this header extension.  This specification\
    \ defines the\n      following types:\n      *  0: Bootstrap information, sent\
    \ by the sender periodically or\n         after a direct time synchronization\
    \ request;\n      *  1: Standard Authentication Tag for the ongoing key chain,\
    \ sent\n         by the sender along with a packet;\n      *  2: Authentication\
    \ Tag without Key Disclosure, sent by the\n         sender along with a packet;\n\
    \      *  3: Authentication Tag with a New Key Chain Commitment, sent by\n   \
    \      the sender when approaching the end of a key chain;\n      *  4: Authentication\
    \ Tag with a Last Key of Old Chain Disclosure,\n         sent by the sender some\
    \ time after moving to a new key chain;\n      *  5: Direct time synchronization\
    \ request, sent by a NORM\n         receiver.  This type of message is invalid\
    \ in the case of an\n         ALC session since ALC is restricted to unidirectional\n\
    \         transmissions.  Yet, an external mechanism may provide the\n       \
    \  direct time synchronization functionality;\n      *  6: Direct time synchronization\
    \ response, sent by a NORM sender.\n         This type of message is invalid in\
    \ the case of an ALC session\n         since ALC is restricted to unidirectional\
    \ transmissions.  Yet,\n         an external mechanism may provide the direct\
    \ time\n         synchronization functionality.\n   \"Content\" field (variable\
    \ length):\n      This is the TESLA information carried in the header extension,\n\
    \      whose type is given by the \"Type\" field.\n"
- title: 5.2.  Use of Authentication Header Extensions
  contents:
  - "5.2.  Use of Authentication Header Extensions\n   Each packet sent by the session's\
    \ sender MUST contain exactly one\n   TESLA EXT_AUTH Header Extension.\n   All\
    \ receivers MUST recognize EXT_AUTH but MAY not be able to parse\n   its content,\
    \ for instance, because they do not support TESLA.  In\n   that case, these receivers\
    \ MUST ignore the TESLA EXT_AUTH extensions.\n   In the case of NORM, the packets\
    \ sent by receivers MAY contain a\n   direct synchronization request but MUST\
    \ NOT contain any of the other\n   five TESLA EXT_AUTH Header Extensions.\n"
- title: 5.2.1.  EXT_AUTH Header Extension of Type Bootstrap Information
  contents:
  - "5.2.1.  EXT_AUTH Header Extension of Type Bootstrap Information\n   The \"bootstrap\
    \ information\" TESLA EXT_AUTH (Type==0) MUST be sent in\n   a stand-alone control\
    \ packet, rather than in a packet containing\n   application data.  The reason\
    \ for that is the large size of this\n   bootstrap information.  By using stand-alone\
    \ packets, the maximum\n   payload size of data packets is only affected by the\
    \ (mandatory)\n   authentication information header extension.\n   With ALC, the\
    \ \"bootstrap information\" TESLA EXT_AUTH MUST be sent in\n   a control packet,\
    \ i.e., containing no encoding symbol.\n   With NORM, the \"bootstrap information\"\
    \ TESLA EXT_AUTH MUST be sent in\n   a NORM_CMD(APPLICATION) message.\n   0  \
    \                 1                   2                   3\n   0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  ---\n  |   HET (=1)    |    HEL (=46)  |  ASID |   0   | 0 |  0  |0|1|0|  ^\n\
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |\n  | \
    \      d       |       2       |       2       |       2       |  |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  |\n  |       1       |       3       |              128              |  |\n\
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |\n  | \
    \        0 (reserved)          |             T_int             |  |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  |\n  |                                                               |  |\n\
    \  +                  T_0 (NTP timestamp format)                   +  | 5\n  |\
    \                                                               |  | 2\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  |\n  |                      N (Key Chain Length)                     |  | b\n\
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | y\n  |\
    \                    Current Interval Index i                   |  | t\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  | e\n  |                                                               |  |\
    \ s\n  +                                                               +  |\n\
    \  |                                                               |  |\n  + \
    \                Current Key Chain Commitment                  +  |\n  |     \
    \                     (20 bytes)                           |  |\n  +         \
    \                                                      +  |\n  |             \
    \                                                  |  |\n  +                 \
    \                                              +  |\n  |                     \
    \                                          |  v\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  ---\n  |                                                               |  ^\
    \ 1\n  +                                                               +  | 2\n\
    \  |                                                               |  | 8\n  .\
    \                                                               .  |\n  .    \
    \                       Signature                           .  | b\n  .      \
    \                    (128 bytes)                          .  | y\n  |        \
    \                                                       |  | t\n  +          \
    \                                                     +  | e\n  |            \
    \                                                   |  v s\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \  ---\n  |                           Group MAC                           |\n\
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Figure\
    \ 10: Example: Format of the Bootstrap Information Message\n                (Type\
    \ 0) Using SHA-256/1024-Bit Signatures,\n                 the Default HMAC-SHA-256,\
    \ and a Group MAC\n   For instance, Figure 10 shows the bootstrap information\
    \ message when\n   using the HMAC-SHA-256 transform for the PRF, MAC, and Group\
    \ MAC\n   functions, along with SHA-256/128 byte (1024 bit) key digital\n   signatures\
    \ (which also means that the \"Signature\" field is 128 bytes\n   long).  The\
    \ TESLA EXT_AUTH Header Extension is then 184 bytes long\n   (i.e., 46 words of\
    \ 32 bits).\n"
- title: 5.2.2.  EXT_AUTH Header Extension of Type Authentication Tag
  contents:
  - "5.2.2.  EXT_AUTH Header Extension of Type Authentication Tag\n   The four \"\
    authentication tag\" TESLA EXT_AUTH Header Extensions (Type\n   1, 2, 3, and 4)\
    \ MUST be attached to the ALC or NORM packet (data or\n   control packet) that\
    \ they protect.\n     0                   1                   2              \
    \     3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \   HET (=1)    |   HEL (=10)   |  ASID |   1   |   Reserved    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                i (Interval Index of K'_i)                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                                                               +\n    |     \
    \                                                          |\n    +          \
    \           Disclosed Key K_{i-d}                     +\n    |               \
    \           (20 bytes)                           |\n    +                    \
    \                                           +\n    |                         \
    \                                      |\n    +                              \
    \                                 +\n    |                                   \
    \                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                                                               +\n    |     \
    \                    MAC(K'_i, M)                          |\n    +          \
    \                (16 bytes)                           +\n    |               \
    \                                                |\n    +                    \
    \                                           +\n    |                         \
    \                                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       Figure 11: Example: Format of the Standard Authentication Tag\n      \
    \            (Type 1) Using the Default HMAC-SHA-256\n     0                 \
    \  1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |   HET (=1)    |   HEL (=5)    |  ASID |   2   |   Reserved    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                i (Interval Index of K'_i)                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                                                               +\n    |     \
    \                    MAC(K'_i, M)                          |\n    +          \
    \                (16 bytes)                           +\n    |               \
    \                                                |\n    +                    \
    \                                           +\n    |                         \
    \                                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       Figure 12: Example: Format of the Authentication Tag without\n       \
    \   Key Disclosure (Type 2) Using the Default HMAC-SHA-256\n   For instance, Figures\
    \ 11 and 12 show the format of the authentication\n   tags, respectively with\
    \ and without the K_{i-d} key disclosure, when\n   using the (default) HMAC-SHA-256\
    \ transform for the PRF and MAC\n   functions.  In these examples, the Group MAC\
    \ feature is not used.\n"
- title: 5.2.3.  EXT_AUTH Header Extension of Type Direct Time Synchronization
  contents:
  - "5.2.3.  EXT_AUTH Header Extension of Type Direct Time Synchronization\n     \
    \   Request\n   With NORM, the \"direct time synchronization request\" TESLA EXT_AUTH\n\
    \   (Type==7) MUST be sent by a receiver in a NORM_CMD(APPLICATION) NORM\n   packet.\n\
    \   With ALC, the \"direct time synchronization request\" TESLA EXT_AUTH\n   cannot\
    \ be included in an ALC packet, since ALC is restricted to\n   unidirectional\
    \ transmissions, from the session's sender to the\n   receivers.  An external\
    \ mechanism must be used with ALC for carrying\n   direct time synchronization\
    \ requests to the session's sender.\n   In the case of direct time synchronization,\
    \ it is RECOMMENDED that\n   the receivers spread the transmission of direct time\
    \ synchronization\n   requests over the time (Section 2.3.1).\n"
- title: 5.2.4.  EXT_AUTH Header Extension of Type Direct Time Synchronization
  contents:
  - "5.2.4.  EXT_AUTH Header Extension of Type Direct Time Synchronization\n     \
    \   Response\n   With NORM, the \"direct time synchronization response\" TESLA\
    \ EXT_AUTH\n   (Type==8) MUST be sent by the sender in a NORM_CMD(APPLICATION)\n\
    \   message.\n   With ALC, the \"direct time synchronization response\" TESLA\
    \ EXT_AUTH\n   can be sent in an ALC control packet (i.e., containing no encoding\n\
    \   symbol) or through the external mechanism used to carry the direct\n   time\
    \ synchronization request.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   [RFC4082] discusses the security of TESLA in\
    \ general.  These\n   considerations apply to the present specification, namely:\n\
    \   o  great care must be taken in the timing aspects.  In particular,\n     \
    \ the D_t parameter is critical and must be correctly initialized;\n   o  if the\
    \ sender realizes that the key disclosure schedule is not\n      appropriate,\
    \ then the current session MUST be closed and a new one\n      created.  Indeed,\
    \ Section 3.1.3 requires that these parameters be\n      fixed during the whole\
    \ session.\n   o  when the verifier that authenticates the incoming packets and\
    \ the\n      application that uses the data are two different components, there\n\
    \      is a risk that an attacker located between these components inject\n  \
    \    faked data.  Similarly, when the verifier and the secure timing\n      system\
    \ are two different components, there is a risk that an\n      attacker located\
    \ between these components inject faked timing\n      information.  For instance,\
    \ when the verifier reads the local time\n      by means of a dedicated system\
    \ call (e.g., gettimeofday()), if an\n      attacker controls the host, he may\
    \ catch the system call and\n      return a faked time information.\n   The current\
    \ specification discusses additional aspects with more\n   details.\n"
- title: 6.1.  Dealing with DoS Attacks
  contents:
  - "6.1.  Dealing with DoS Attacks\n   TESLA introduces new opportunities for an\
    \ attacker to mount DoS\n   attacks.  For instance, an attacker can try to saturate\
    \ the\n   processing capabilities of the receiver (faked packets are easy to\n\
    \   create but checking them requires computing a MAC over the packet or\n   sometimes\
    \ checking a digital signature as with the bootstrap and\n   direct time synchronization\
    \ response messages).  An attacker can also\n   try to saturate the receiver's\
    \ memory (since authentication is\n   delayed and non-authenticated packets will\
    \ accumulate), or to make\n   the receiver believe that a congestion has happened\
    \ (since congestion\n   control MUST be performed before authenticating incoming\
    \ packets,\n   Section 4.3).\n   In order to mitigate these attacks, it is RECOMMENDED\
    \ to use the\n   Group MAC scheme (Section 3.3.3).  No mitigation is possible\
    \ if a\n   group member acts as an attacker with Group MAC.\n   Generally, it\
    \ is RECOMMENDED that the amount of memory used to store\n   incoming packets\
    \ waiting to be authenticated be limited to a\n   reasonable value.\n"
- title: 6.2.  Dealing With Replay Attacks
  contents:
  - "6.2.  Dealing With Replay Attacks\n   Replay attacks, whereby an attacker stores\
    \ a valid message and\n   replays it later, can have significant impacts, depending\
    \ on the\n   message type.  Two levels of impacts must be distinguished:\n   o\
    \  within the TESLA protocol, and\n   o  within the ALC or NORM protocol.\n"
- title: 6.2.1.  Impacts of Replay Attacks on TESLA
  contents:
  - "6.2.1.  Impacts of Replay Attacks on TESLA\n   Replay attacks can impact the\
    \ TESLA component itself.  We review here\n   the potential impacts of such an\
    \ attack depending on the TESLA\n   message type:\n   o  bootstrap information:\
    \ Since most parameters contained in a\n      bootstrap information message are\
    \ static, replay attacks have no\n      consequences.  The fact that the \"i\"\
    \ and \"K_i\" fields can be\n      updated in subsequent bootstrap information\
    \ messages does not\n      create a problem either, since all \"i\" and \"K_i\"\
    \ fields sent\n      remain valid.  Finally, a receiver that successfully initialized\n\
    \      its TESLA component MUST ignore the following messages (see\n      Section\
    \ 4.2.1 for an exception to this rule), which voids replay\n      attacks, unless\
    \ he missed all the commitments to a new key chain\n      (e.g., after a long\
    \ disconnection) (Section 3.2.1).\n   o  direct time synchronization request:\
    \ If the Group MAC scheme is\n      used, an attacker that is not a member of\
    \ the group can replay a\n      packet and oblige the sender to respond, which\
    \ requires digitally\n      signing the response, a time-consuming process.  If\
    \ the Group MAC\n      scheme is not used, an attacker can easily forge a request\
    \ anyway.\n      In both cases, the attack will not compromise the TESLA component,\n\
    \      but might create a DoS.  If this is a concern, it is RECOMMENDED,\n   \
    \   when the Group MAC scheme is used, that the sender verify the\n      \"t_r\"\
    \ NTP timestamp contained in the request and respond only if\n      this value\
    \ is strictly larger than the previous one received from\n      this receiver.\
    \  When the Group MAC scheme is not used, this attack\n      can be mitigated\
    \ by limiting the number of requests per second\n      that will be processed.\n\
    \   o  direct time synchronization response: Upon receiving a response, a\n  \
    \    receiver who has no pending request MUST immediately drop the\n      packet.\
    \  If this receiver has previously issued a request, he\n      first checks the\
    \ Group MAC (if applicable), then the \"t_r\" field,\n      to be sure it is a\
    \ response to his request, and finally the\n      digital signature.  A replayed\
    \ packet will be dropped during these\n      verifications, without compromising\
    \ the TESLA component.\n   o  other messages, containing an authentication tag:\
    \ Replaying a\n      packet containing a TESLA authentication tag will never compromise\n\
    \      the TESLA component itself (but perhaps the underlying ALC or NORM\n  \
    \    component, see below).\n   To conclude, TESLA itself is robust in front of\
    \ replay attacks.\n"
- title: 6.2.2.  Impacts of Replay Attacks on NORM
  contents:
  - "6.2.2.  Impacts of Replay Attacks on NORM\n   We review here the potential impacts\
    \ of a replay attack on the NORM\n   component.  Note that we do not consider\
    \ here the protocols that\n   could be used along with NORM, for instance, the\
    \ congestion control\n   protocols.\n   First, let us consider replay attacks\
    \ within a given NORM session.\n   NORM defines a \"sequence\" field that can\
    \ be used to protect against\n   replay attacks [RFC5740] within a given NORM\
    \ session.  This\n   \"sequence\" field is a 16-bit value that is set by the message\n\
    \   originator (sender or receiver) as a monotonically increasing number\n   incremented\
    \ with each NORM message transmitted.  It is RECOMMENDED\n   that a receiver check\
    \ this \"sequence\" field and drop messages\n   considered as replayed.  Similarly,\
    \ it is RECOMMENDED that a sender\n   check this sequence, for each known receiver,\
    \ and drop messages\n   considered as replayed.  In both cases, checking this\
    \ \"sequence\"\n   field SHOULD be done before TESLA processing of the packet:\
    \ if the\n   \"sequence\" field has not been corrupted, the replay attack will\n\
    \   immediately be identified; otherwise, the packet will fail the TESLA\n   authentication\
    \ test.  This analysis shows that NORM itself is robust\n   in front of replay\
    \ attacks within the same session.\n   Now let us consider replay attacks across\
    \ several NORM sessions.\n   Since the key chain used in each session MUST differ,\
    \ a packet\n   replayed in a subsequent session will be identified as unauthentic.\n\
    \   Therefore, NORM is robust in front of replay attacks across different\n  \
    \ sessions.\n"
- title: 6.2.3.  Impacts of Replay Attacks on ALC
  contents:
  - "6.2.3.  Impacts of Replay Attacks on ALC\n   We review here the potential impacts\
    \ of a replay attack on the ALC\n   component.  Note that we do not consider here\
    \ the protocols that\n   could be used along with ALC, for instance, the layered\
    \ or wave-based\n   congestion control protocols.\n   First, let us consider replay\
    \ attacks within a given ALC session:\n   o  Regular packets containing an authentication\
    \ tag: a replayed\n      message containing an encoding symbol will be detected\
    \ once\n      authenticated, thanks to the object/block/symbol identifiers, and\n\
    \      will be silently discarded.  This kind of replay attack is only\n     \
    \ penalizing in terms of memory and processing load, but does not\n      compromise\
    \ the ALC behavior.\n   o  Control packets containing an authentication tag: ALC\
    \ control\n      packets, by definition, do not include any encoding symbol and\n\
    \      therefore do not include any object/block/symbol identifier that\n    \
    \  would enable a receiver to identify duplicates.  However, a sender\n      has\
    \ a very limited number of reasons to send control packets.\n      More precisely:\n\
    \      *  At the end of the session, a \"Close Session\" (\"A\" flag) packet\n\
    \         is sent.  Replaying this packet has no impact since the\n         receivers\
    \ already left.\n      *  Similarly, replaying a packet containing a \"Close Object\"\
    \ (\"B\"\n         flag) has no impact since this object is probably already\n\
    \         marked as closed by the receiver.\n   This analysis shows that ALC itself\
    \ is robust in front of replay\n   attacks within the same session.\n   Now let\
    \ us consider replay attacks across several ALC sessions.\n   Since the key chain\
    \ used in each session MUST differ, a packet\n   replayed in a subsequent session\
    \ will be identified as unauthentic.\n   Therefore, ALC is robust in front of\
    \ replay attacks across different\n   sessions.\n"
- title: 6.3.  Security of the Back Channel
  contents:
  - "6.3.  Security of the Back Channel\n   As specified in Section 1.1, this specification\
    \ does not consider the\n   packets that may be sent by receivers, for instance,\
    \ NORM's feedback\n   packets.  When a back channel is used, its security is critical\
    \ to\n   the global security, and an appropriate security mechanism MUST be\n\
    \   used.  [RMT-SIMPLE-AUTH] describes several techniques that can be\n   used\
    \ to that purpose.  However, the authentication and integrity\n   verification\
    \ of the packets sent by receivers on the back channel, if\n   any, is out of\
    \ the scope of this document.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   IANA has registered the following attributes according\
    \ to this\n   document.  The registries are provided by [RFC4442] under the \"\
    Timed\n   Efficient Stream Loss-tolerant Authentication (TESLA) Parameters\"\n\
    \   registry [TESLA-REG].  Following the policies outlined in [RFC4442],\n   the\
    \ values in the range up to 240 (including 240) for the following\n   attributes\
    \ are assigned after expert review by the MSEC working group\n   or its designated\
    \ successor.  The values in the range from 241 to 255\n   are reserved for private\
    \ use.\n   Cryptographic Pseudo-Random Function, TESLA-PRF: All implementations\n\
    \   MUST support HMAC-SHA-256 (default).\n                    +------------------------+-------+\n\
    \                    |        PRF name        | Value |\n                    +------------------------+-------+\n\
    \                    |        HMAC-SHA1       |   0   |\n                    |\
    \      HMAC-SHA-224      |   1   |\n                    | HMAC-SHA-256 (default)\
    \ |   2   |\n                    |      HMAC-SHA-384      |   3   |\n        \
    \            |      HMAC-SHA-512      |   4   |\n                    +------------------------+-------+\n\
    \   Cryptographic Message Authentication Code (MAC) Function, TESLA-MAC:\n   All\
    \ implementations MUST support HMAC-SHA-256 (default).  These MAC\n   schemes\
    \ are used both for the computing of regular MAC and the Group\n   MAC (if applicable).\n\
    \                    +------------------------+-------+\n                    |\
    \        MAC name        | Value |\n                    +------------------------+-------+\n\
    \                    |        HMAC-SHA1       |   0   |\n                    |\
    \      HMAC-SHA-224      |   1   |\n                    | HMAC-SHA-256 (default)\
    \ |   2   |\n                    |      HMAC-SHA-384      |   3   |\n        \
    \            |      HMAC-SHA-512      |   4   |\n                    +------------------------+-------+\n\
    \   Furthermore, IANA has created two new registries.  Here also, the\n   values\
    \ in the range up to 240 (including 240) for the following\n   attributes are\
    \ assigned after expert review by the MSEC working group\n   or its designated\
    \ successor.  The values in the range from 241 to 255\n   are reserved for private\
    \ use.\n   Signature Encoding Algorithm, TESLA-SIG-ALGO: All implementations\n\
    \   MUST support RSASSA-PKCS1-v1_5 (default).\n                  +-----------------------------+-------+\n\
    \                  |   Signature Algorithm Name  | Value |\n                 \
    \ +-----------------------------+-------+\n                  |           INVALID\
    \           |   0   |\n                  | RSASSA-PKCS1-v1_5 (default) |   1 \
    \  |\n                  |          RSASSA-PSS         |   2   |\n            \
    \      +-----------------------------+-------+\n   Signature Cryptographic Function,\
    \ TESLA-SIG-CRYPTO-FUNC: All\n   implementations MUST support SHA-256 (default).\n\
    \                  +-----------------------------+-------+\n                 \
    \ | Cryptographic Function Name | Value |\n                  +-----------------------------+-------+\n\
    \                  |           INVALID           |   0   |\n                 \
    \ |            SHA-1            |   1   |\n                  |           SHA-224\
    \           |   2   |\n                  |      SHA-256 (default)      |   3 \
    \  |\n                  |           SHA-384           |   4   |\n            \
    \      |           SHA-512           |   5   |\n                  +-----------------------------+-------+\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   The authors are grateful to Yaron Sheffer, Brian Weis,\
    \ Ramu\n   Panayappan, Ran Canetti, David L. Mills, Brian Adamson, and Lionel\n\
    \   Giraud for their valuable comments while preparing this document.\n   The\
    \ authors are also grateful to Brian Weis for the digital signature\n   details.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC1305]          Mills, D., \"Network Time Protocol\
    \ (Version 3)\n                      Specification, Implementation\", RFC 1305,\n\
    \                      March 1992.\n   [RFC2119]          Bradner, S., \"Key words\
    \ for use in RFCs to\n                      Indicate Requirement Levels\", BCP\
    \ 14, RFC 2119,\n                      March 1997.\n   [RFC4082]          Perrig,\
    \ A., Song, D., Canetti, R., Tygar, J., and\n                      B. Briscoe,\
    \ \"Timed Efficient Stream Loss-Tolerant\n                      Authentication\
    \ (TESLA): Multicast Source\n                      Authentication Transform Introduction\"\
    , RFC 4082,\n                      June 2005.\n   [RFC5651]          Luby, M.,\
    \ Watson, M., and L. Vicisano, \"Layered\n                      Coding Transport\
    \ (LCT) Building Block\", RFC 5651,\n                      October 2009.\n   [RFC5740]\
    \          Adamson, B., Bormann, C., Handley, M., and J.\n                   \
    \   Macker, \"NACK-Oriented Reliable Multicast (NORM)\n                      Transport\
    \ Protocol\", RFC 5740, November 2009.\n   [RFC5775]          Luby, M., Watson,\
    \ M., and L. Vicisano,\n                      \"Asynchronous Layered Coding (ALC)\
    \ Protocol\n                      Instantiation\", RFC 5775, April 2010.\n   [TESLA-REG]\
    \        \"TESLA Parameters IANA Registry\",\n                       http://www.iana.org.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [NTP-NTPv4]        Burbank, J., Kasch, W., Martin,\
    \ J., Ed., and D.\n                      Mills, \"The Network Time Protocol Version\
    \ 4\n                      Protocol And Algorithm Specification\", Work\n    \
    \                  in Progress, October 2009.\n   [Perrig04]         Perrig, A.\
    \ and J. Tygar, \"Secure Broadcast\n                      Communication in Wired\
    \ and Wireless Networks\",\n                      Kluwer Academic Publishers ISBN\
    \ 0-7923-7650-1,\n                      2004.\n   [RFC2104]          Krawczyk,\
    \ H., Bellare, M., and R. Canetti, \"HMAC:\n                      Keyed-Hashing\
    \ for Message Authentication\",\n                      RFC 2104, February 1997.\n\
    \   [RFC3447]          Jonsson, J. and B. Kaliski, \"Public-Key\n            \
    \          Cryptography Standards (PKCS) #1: RSA Cryptography\n              \
    \        Specifications Version 2.1\", RFC 3447,\n                      February\
    \ 2003.\n   [RFC3711]          Baugher, M., McGrew, D., Naslund, M., Carrara,\
    \ E.,\n                      and K. Norrman, \"The Secure Real-time Transport\n\
    \                      Protocol (SRTP)\", RFC 3711, March 2004.\n   [RFC4330]\
    \          Mills, D., \"Simple Network Time Protocol (SNTP)\n                \
    \      Version 4 for IPv4, IPv6 and OSI\", RFC 4330,\n                      January\
    \ 2006.\n   [RFC4359]          Weis, B., \"The Use of RSA/SHA-1 Signatures within\n\
    \                      Encapsulating Security Payload (ESP) and\n            \
    \          Authentication Header (AH)\", RFC 4359,\n                      January\
    \ 2006.\n   [RFC4383]          Baugher, M. and E. Carrara, \"The Use of Timed\n\
    \                      Efficient Stream Loss-Tolerant Authentication\n       \
    \               (TESLA) in the Secure Real-time Transport Protocol\n         \
    \             (SRTP)\", RFC 4383, February 2006.\n   [RFC4442]          Fries,\
    \ S. and H. Tschofenig, \"Bootstrapping Timed\n                      Efficient\
    \ Stream Loss-Tolerant Authentication\n                      (TESLA)\", RFC 4442,\
    \ March 2006.\n   [RMT-FLUTE]        Paila, T., Walsh, R., Luby, M., Lehtonen,\
    \ R., and\n                      V. Roca, \"FLUTE - File Delivery over\n     \
    \                 Unidirectional Transport\", Work in Progress,\n            \
    \          August 2009.\n   [RMT-SIMPLE-AUTH]  Roca, V., \"Simple Authentication\
    \ Schemes for the\n                      ALC and NORM Protocols\", Work in Progress,\n\
    \                      October 2009.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Vincent Roca\n   INRIA\n   655, av. de l'Europe\n   Inovallee;\
    \ Montbonnot\n   ST ISMIER cedex  38334\n   France\n   EMail: vincent.roca@inria.fr\n\
    \   URI:   http://planete.inrialpes.fr/~roca/\n   Aurelien Francillon\n   INRIA\n\
    \   655, av. de l'Europe\n   Inovallee; Montbonnot\n   ST ISMIER cedex  38334\n\
    \   France\n   EMail: aurelien.francillon@inria.fr\n   URI:   http://planete.inrialpes.fr/~francill/\n\
    \   Sebastien Faurite\n   INRIA\n   655, av. de l'Europe\n   Inovallee; Montbonnot\n\
    \   ST ISMIER cedex  38334\n   France\n   EMail: faurite@lcpc.fr\n"
