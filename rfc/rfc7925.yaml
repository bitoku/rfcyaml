- title: __initial_text__
  contents:
  - "                    Transport Layer Security (TLS) /\n                Datagram\
    \ Transport Layer Security (DTLS)\n                  Profiles for the Internet\
    \ of Things\n"
- title: Abstract
  contents:
  - "Abstract\n   A common design pattern in Internet of Things (IoT) deployments\
    \ is\n   the use of a constrained device that collects data via sensors or\n \
    \  controls actuators for use in home automation, industrial control\n   systems,\
    \ smart cities, and other IoT deployments.\n   This document defines a Transport\
    \ Layer Security (TLS) and Datagram\n   Transport Layer Security (DTLS) 1.2 profile\
    \ that offers\n   communications security for this data exchange thereby preventing\n\
    \   eavesdropping, tampering, and message forgery.  The lack of\n   communication\
    \ security is a common vulnerability in IoT products that\n   can easily be solved\
    \ by using these well-researched and widely\n   deployed Internet security protocols.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7925.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  Overview  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     3.1.  TLS and DTLS  . . . . . . . . . . . . . . . . . . . .\
    \ . .   5\n     3.2.  Communication Models  . . . . . . . . . . . . . . . . .\
    \ .   6\n     3.3.  The Ciphersuite Concept . . . . . . . . . . . . . . . . .\
    \  20\n   4.  Credential Types  . . . . . . . . . . . . . . . . . . . . . .  21\n\
    \     4.1.  Preconditions . . . . . . . . . . . . . . . . . . . . . .  21\n  \
    \   4.2.  Pre-Shared Secret . . . . . . . . . . . . . . . . . . . .  23\n    \
    \ 4.3.  Raw Public Key  . . . . . . . . . . . . . . . . . . . . .  25\n     4.4.\
    \  Certificates  . . . . . . . . . . . . . . . . . . . . . .  27\n   5.  Signature\
    \ Algorithm Extension . . . . . . . . . . . . . . . .  32\n   6.  Error Handling\
    \  . . . . . . . . . . . . . . . . . . . . . . .  32\n   7.  Session Resumption\
    \  . . . . . . . . . . . . . . . . . . . . .  34\n   8.  Compression . . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  35\n   9.  Perfect Forward Secrecy\
    \ . . . . . . . . . . . . . . . . . . .  35\n   10. Keep-Alive  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  36\n   11. Timeouts  . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  38\n   12. Random Number Generation  . .\
    \ . . . . . . . . . . . . . . . .  39\n   13. Truncated MAC and Encrypt-then-MAC\
    \ Extension  . . . . . . . .  40\n   14. Server Name Indication (SNI)  . . . .\
    \ . . . . . . . . . . . .  40\n   15. Maximum Fragment Length Negotiation . .\
    \ . . . . . . . . . . .  41\n   16. Session Hash  . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  41\n   17. Renegotiation Attacks . . . . . . . . . . .\
    \ . . . . . . . . .  42\n   18. Downgrading Attacks . . . . . . . . . . . . .\
    \ . . . . . . . .  42\n   19. Crypto Agility  . . . . . . . . . . . . . . . .\
    \ . . . . . . .  43\n   20. Key Length Recommendations  . . . . . . . . . . .\
    \ . . . . . .  44\n   21. False Start . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  45\n   22. Privacy Considerations  . . . . . . . . . . . . . . .\
    \ . . . .  45\n   23. Security Considerations . . . . . . . . . . . . . . . .\
    \ . . .  46\n   24. References  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  47\n     24.1.  Normative References . . . . . . . . . . . . . . . . .\
    \ .  47\n     24.2.  Informative References . . . . . . . . . . . . . . . . .\
    \  48\n   Appendix A.  Conveying DTLS over SMS  . . . . . . . . . . . . . .  56\n\
    \     A.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  56\n  \
    \   A.2.  Message Segmentation and Reassembly . . . . . . . . . . .  57\n    \
    \ A.3.  Multiplexing Security Associations  . . . . . . . . . . .  57\n     A.4.\
    \  Timeout . . . . . . . . . . . . . . . . . . . . . . . . .  58\n   Appendix\
    \ B.  DTLS Record Layer Per-Packet Overhead  . . . . . . .  59\n   Appendix C.\
    \  DTLS Fragmentation . . . . . . . . . . . . . . . . .  60\n   Acknowledgments\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  60\n   Authors' Addresses\
    \  . . . . . . . . . . . . . . . . . . . . . . .  61\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   An engineer developing an Internet of Things (IoT) device\
    \ needs to\n   investigate the security threats and decide about the security\n\
    \   services that can be used to mitigate these threats.\n   Enabling IoT devices\
    \ to exchange data often requires authentication\n   of the two endpoints and\
    \ the ability to provide integrity and\n   confidentiality protection of exchanged\
    \ data.  While these security\n   services can be provided at different layers\
    \ in the protocol stack,\n   the use of Transport Layer Security (TLS) / Datagram\
    \ Transport Layer\n   Security (DTLS) has been very popular with many application\n\
    \   protocols, and it is likely to be useful for IoT scenarios as well.\n   Fitting\
    \ Internet protocols into constrained devices can be difficult,\n   but thanks\
    \ to the standardization efforts, new profiles and protocols\n   are available,\
    \ such as the Constrained Application Protocol (CoAP)\n   [RFC7252].  CoAP messages\
    \ are mainly carried over UDP/DTLS, but other\n   transports can be utilized,\
    \ such as SMS (as described in Appendix A)\n   or TCP (as currently being proposed\
    \ with [COAP-TCP-TLS]).\n   While the main goal for this document is to protect\
    \ CoAP messages\n   using DTLS 1.2 [RFC6347], the information contained in the\
    \ following\n   sections is not limited to CoAP nor to DTLS itself.\n   Instead,\
    \ this document defines a profile of DTLS 1.2 [RFC6347] and\n   TLS 1.2 [RFC5246]\
    \ that offers communication security services for IoT\n   applications and is\
    \ reasonably implementable on many constrained\n   devices.  Profile thereby means\
    \ that available configuration options\n   and protocol extensions are utilized\
    \ to best support the IoT\n   environment.  This document does not alter TLS/DTLS\
    \ specifications\n   and does not introduce any new TLS/DTLS extension.\n   The\
    \ main target audience for this document is the embedded system\n   developer\
    \ configuring and using a TLS/DTLS stack.  This document may,\n   however, also\
    \ help those developing or selecting a suitable TLS/DTLS\n   stack for an IoT\
    \ product.  If you are familiar with (D)TLS, then skip\n   ahead to Section 4.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in RFC\n   2119 [RFC2119].\n   This specification refers to TLS as well as DTLS\
    \ and particularly to\n   version 1.2, which is the most recent version at the\
    \ time of writing.\n   We refer to TLS/DTLS whenever the text is applicable to\
    \ both versions\n   of the protocol and to TLS or DTLS when there are differences\
    \ between\n   the two protocols.  Note that TLS 1.3 is being developed, but it\
    \ is\n   not expected that this profile will \"just work\" due to the\n   significant\
    \ changes being done to TLS for version 1.3.\n   Note that \"client\" and \"server\"\
    \ in this document refer to TLS/DTLS\n   roles, where the client initiates the\
    \ handshake.  This does not\n   restrict the interaction pattern of the protocols\
    \ on top of DTLS\n   since the record layer allows bidirectional communication.\
    \  This\n   aspect is further described in Section 3.2.\n   RFC 7228 [RFC7228]\
    \ introduces the notion of constrained-node\n   networks, which are made of small\
    \ devices with severe constraints on\n   power, memory, and processing resources.\
    \  The terms constrained\n   devices and IoT devices are used interchangeably.\n\
    \   The terms \"certification authority\" (CA) and \"distinguished name\"\n  \
    \ (DN) are taken from [RFC5280].  The terms \"trust anchor\" and \"trust\n   anchor\
    \ store\" are defined in [RFC6024] as:\n      A trust anchor represents an authoritative\
    \ entity via a public key\n      and associated data.  The public key is used\
    \ to verify digital\n      signatures, and the associated data is used to constrain\
    \ the types\n      of information for which the trust anchor is authoritative.\n\
    \      A trust anchor store is a set of one or more trust anchors stored\n   \
    \   in a device.... A device may have more than one trust anchor\n      store,\
    \ each of which may be used by one or more applications.\n"
- title: 3.  Overview
  contents:
  - '3.  Overview

    '
- title: 3.1.  TLS and DTLS
  contents:
  - "3.1.  TLS and DTLS\n   The TLS protocol [RFC5246] provides authenticated, confidentiality-\n\
    \   and integrity-protected communication between two endpoints.  The\n   protocol\
    \ is composed of two layers: the Record Protocol and the\n   handshaking protocols.\
    \  At the lowest level, layered on top of a\n   reliable transport protocol (e.g.,\
    \ TCP), is the Record Protocol.  It\n   provides connection security by using\
    \ symmetric cryptography for\n   confidentiality, data origin authentication,\
    \ and integrity\n   protection.  The Record Protocol is used for encapsulation\
    \ of various\n   higher-level protocols.  The handshaking protocols consist of\
    \ three\n   subprotocols -- namely, the handshake protocol, the change cipher\n\
    \   spec protocol, and the alert protocol.  The handshake protocol allows\n  \
    \ the server and client to authenticate each other and to negotiate an\n   encryption\
    \ algorithm and cryptographic keys before the application\n   protocol transmits\
    \ or receives data.\n   The design of DTLS [RFC6347] is intentionally very similar\
    \ to TLS.\n   However, since DTLS operates on top of an unreliable datagram\n\
    \   transport, it must explicitly cope with the absence of reliable and\n   ordered\
    \ delivery assumptions made by TLS.  RFC 6347 explains these\n   differences in\
    \ great detail.  As a short summary, for those not\n   familiar with DTLS, the\
    \ differences are:\n   o  An explicit sequence number and an epoch field is included\
    \ in the\n      Record Protocol.  Section 4.1 of RFC 6347 explains the processing\n\
    \      rules for these two new fields.  The value used to compute the\n      Message\
    \ Authentication Code (MAC) is the 64-bit value formed by\n      concatenating\
    \ the epoch and the sequence number.\n   o  Stream ciphers must not be used with\
    \ DTLS.  The only stream cipher\n      defined for TLS 1.2 is RC4, and due to\
    \ cryptographic weaknesses,\n      it is not recommended anymore even for use\
    \ with TLS [RFC7465].\n      Note that the term \"stream cipher\" is a technical\
    \ term in the TLS\n      specification.  Section 4.7 of RFC 5246 defines stream\
    \ ciphers in\n      TLS as follows: \"In stream cipher encryption, the plaintext\
    \ is\n      exclusive-ORed with an identical amount of output generated from a\n\
    \      cryptographically secure keyed pseudorandom number generator.\"\n   o \
    \ The TLS handshake protocol has been enhanced to include a\n      stateless cookie\
    \ exchange for Denial-of-Service (DoS) resistance.\n      For this purpose, a\
    \ new handshake message, the HelloVerifyRequest,\n      was added to DTLS.  This\
    \ handshake message is sent by the server\n      and includes a stateless cookie,\
    \ which is returned in a\n      ClientHello message back to the server.  Although\
    \ the exchange is\n      optional for the server to execute, a client implementation\
    \ has to\n      be prepared to respond to it.  Furthermore, the handshake message\n\
    \      format has been extended to deal with message loss, reordering,\n     \
    \ and fragmentation.\n"
- title: 3.2.  Communication Models
  contents:
  - "3.2.  Communication Models\n   This document describes a profile of DTLS and,\
    \ to be useful, it has\n   to make assumptions about the envisioned communication\
    \ architecture.\n   Two communication architectures (and consequently two profiles)\
    \ are\n   described in this document.\n"
- title: 3.2.1.  Constrained TLS/DTLS Clients
  contents:
  - "3.2.1.  Constrained TLS/DTLS Clients\n   The communication architecture shown\
    \ in Figure 1 assumes a unicast\n   communication interaction with an IoT device\
    \ utilizing a constrained\n   TLS/DTLS client interacting with one or multiple\
    \ TLS/DTLS servers.\n   Before a client can initiate the TLS/DTLS handshake, it\
    \ needs to know\n   the IP address of that server and what credentials to use.\n\
    \   Application-layer protocols, such as CoAP, which is conveyed on top\n   of\
    \ DTLS, may be configured with URIs of the endpoints to which CoAP\n   needs to\
    \ register and publish data.  This configuration information\n   (including non-confidential\
    \ credentials, like certificates) may be\n   conveyed to clients as part of a\
    \ firmware/software package or via a\n   configuration protocol.  The following\
    \ credential types are supported\n   by this profile:\n   o  For authentication\
    \ based on the Pre-Shared Key (PSK) (see\n      Section 4.2), this includes the\
    \ paired \"PSK identity\" and shared\n      secret to be used with each server.\n\
    \   o  For authentication based on the raw public key (see Section 4.3),\n   \
    \   this includes either the server's public key or the hash of the\n      server's\
    \ public key.\n   o  For certificate-based authentication (see Section 4.4), this\n\
    \      includes a pre-populated trust anchor store that allows the DTLS\n    \
    \  stack to perform path validation for the certificate obtained\n      during\
    \ the handshake with the server.\n   Figure 1 shows example configuration information\
    \ stored at the\n   constrained client for use with respective servers.\n   This\
    \ document focuses on the description of the DTLS client-side\n   functionality\
    \ but, quite naturally, the equivalent server-side\n   support has to be available.\n\
    \              +////////////////////////////////////+\n              |       \
    \   Configuration             |\n              |////////////////////////////////////|\n\
    \              | Server A --> PSK Identity, PSK     |\n              |       \
    \                             |\n              | Server B --> Public Key (Server\
    \ B),|\n              |              Public/Private Key    |\n              |\
    \              (for Client)          |\n              |                      \
    \              |\n              | Server C --> Public/Private Key    |\n     \
    \         |              (for Client)          |\n              |            \
    \  Trust Anchor Store    |\n              +------------------------------------+\n\
    \                oo\n          oooooo\n         o\n   +-----------+\n   |Constrained|\n\
    \   |TLS/DTLS   |\n   |Client     |-\n   +-----------+ \\\n                  \\\
    \  ,-------.\n                   ,'         `.            +------+\n         \
    \         /  IP-Based   \\           |Server|\n                 (    Network \
    \   )          |  A   |\n                  \\             /           +------+\n\
    \                   `.         ,'\n                     '---+---'            \
    \      +------+\n                         |                      |Server|\n  \
    \                       |                      |  B   |\n                    \
    \     |                      +------+\n                         |\n          \
    \               |                  +------+\n                         +----------------->|Server|\n\
    \                                            |  C   |\n                      \
    \                      +------+\n                   Figure 1: Constrained Client\
    \ Profile\n"
- title: 3.2.1.1.  Examples of Constrained Client Exchanges
  contents:
  - '3.2.1.1.  Examples of Constrained Client Exchanges

    '
- title: 3.2.1.1.1.  Network Access Authentication Example
  contents:
  - "3.2.1.1.1.  Network Access Authentication Example\n   Reuse is a recurring theme\
    \ when considering constrained environments\n   and is behind a lot of the directions\
    \ taken in developments for\n   constrained environments.  The corollary of reuse\
    \ is to not add\n   functionality if it can be avoided.  An example relevant to\
    \ the use\n   of TLS is network access authentication, which takes place when\
    \ a\n   device connects to a network and needs to go through an\n   authentication\
    \ and access control procedure before it is allowed to\n   communicate with other\
    \ devices or connect to the Internet.\n   Figure 2 shows the network access architecture\
    \ with the IoT device\n   initiating the communication to an access point in the\
    \ network using\n   the procedures defined for a specific physical layer.  Since\n\
    \   credentials may be managed and stored centrally, in the\n   Authentication,\
    \ Authorization, and Accounting (AAA) server, the\n   security protocol exchange\
    \ may need to be relayed via the\n   Authenticator, i.e., functionality running\
    \ on the access point to the\n   AAA server.  The authentication and key exchange\
    \ protocol itself is\n   encapsulated within a container, the Extensible Authentication\n\
    \   Protocol (EAP) [RFC3748], and messages are conveyed back and forth\n   between\
    \ the EAP endpoints, namely the EAP peer located on the IoT\n   device and the\
    \ EAP server located on the AAA server or the access\n   point.  To route EAP\
    \ messages from the access point, acting as a AAA\n   client, to the AAA server\
    \ requires an adequate protocol mechanism,\n   namely RADIUS [RFC2865] or Diameter\
    \ [RFC6733].\n   More details about the concepts and a description about the\n\
    \   terminology can be found in RFC 5247 [RFC5247].\n                        \
    \                        +--------------+\n                                  \
    \              |Authentication|\n                                            \
    \    |Authorization |\n                                                |Accounting\
    \    |\n                                                |Server        |\n   \
    \                                             |(EAP Server)  |\n             \
    \                                   |              |\n                       \
    \                         +-^----------^-+\n                                 \
    \                 * EAP      o RADIUS/\n                                     \
    \             *          o Diameter\n                                        \
    \        --v----------v--\n                                             ///  \
    \              \\\\\\\n                                           //         \
    \             \\\\\n                                          |        Federation\
    \        |\n                                          |        Substrate     \
    \    |\n                                           \\\\                      //\n\
    \                                             \\\\\\                ///\n    \
    \                                            --^----------^--\n              \
    \                                    * EAP      o RADIUS/\n                  \
    \                                *          o Diameter\n    +-------------+  \
    \                           +-v----------v--+\n    |             |      EAP/EAP\
    \ Method         |               |\n    | Internet of |<***************************>|\
    \ Access Point  |\n    | Things      |                             |(Authenticator)|\n\
    \    | Device      |    EAP Lower Layer and      |(AAA Client)   |\n    | (EAP\
    \ Peer)  | Secure Association Protocol |               |\n    |             |<--------------------------->|\
    \               |\n    |             |                             |         \
    \      |\n    |             |      Physical Layer         |               |\n\
    \    |             |<===========================>|               |\n    +-------------+\
    \                             +---------------+\n      Legend:\n       <****>:\
    \ Device-to-AAA-Server Exchange\n       <---->: Device-to-Authenticator Exchange\n\
    \       <oooo>: AAA-Client-to-AAA-Server Exchange\n       <====>: Physical layer\
    \ like IEEE 802.11/802.15.4\n                   Figure 2: Network Access Architecture\n\
    \   One standardized EAP method is EAP-TLS, defined in RFC 5216\n   [RFC5216],\
    \ which reuses the TLS-based protocol exchange and\n   encapsulates it inside\
    \ the EAP payload.  In terms of reuse, this\n   allows many components of the\
    \ TLS protocol to be shared between the\n   network access security functionality\
    \ and the TLS functionality\n   needed for securing application-layer traffic.\
    \  In the EAP-TLS\n   exchange shown in Figure 3, the IoT device as the EAP peer\
    \ acts as a\n   TLS client.\n      Authenticating Peer     Authenticator\n   \
    \   -------------------     -------------\n                              <- EAP-Request/\n\
    \                              Identity\n      EAP-Response/\n      Identity (MyID)\
    \ ->\n                              <- EAP-Request/\n                        \
    \      EAP-Type=EAP-TLS\n                              (TLS Start)\n      EAP-Response/\n\
    \      EAP-Type=EAP-TLS\n      (TLS client_hello)->\n                        \
    \      <- EAP-Request/\n                              EAP-Type=EAP-TLS\n     \
    \                         (TLS server_hello,\n                               TLS\
    \ certificate,\n                               [TLS server_key_exchange,]\n  \
    \                             TLS certificate_request,\n                     \
    \          TLS server_hello_done)\n      EAP-Response/\n      EAP-Type=EAP-TLS\n\
    \      (TLS certificate,\n       TLS client_key_exchange,\n       TLS certificate_verify,\n\
    \       TLS change_cipher_spec,\n       TLS finished) ->\n                   \
    \           <- EAP-Request/\n                              EAP-Type=EAP-TLS\n\
    \                              (TLS change_cipher_spec,\n                    \
    \           TLS finished)\n      EAP-Response/\n      EAP-Type=EAP-TLS ->\n  \
    \                            <- EAP-Success\n                        Figure 3:\
    \ EAP-TLS Exchange\n   The guidance in this document also applies to the use of\
    \ EAP-TLS for\n   network access authentication.  An IoT device using a network\
    \ access\n   authentication solution based on TLS can reuse most parts of the\
    \ code\n   for the use of DTLS/TLS at the application layer, thereby saving a\n\
    \   significant amount of flash memory.  Note, however, that the\n   credentials\
    \ used for network access authentication and those used for\n   application-layer\
    \ security are very likely different.\n"
- title: 3.2.1.1.2.  CoAP-Based Data Exchange Example
  contents:
  - "3.2.1.1.2.  CoAP-Based Data Exchange Example\n   When a constrained client uploads\
    \ sensor data to a server\n   infrastructure, it may use CoAP by pushing the data\
    \ via a POST\n   message to a preconfigured endpoint on the server.  In certain\n\
    \   circumstances, this might be too limiting and additional\n   functionality\
    \ is needed, as shown in Figures 4 and 5, where the IoT\n   device itself runs\
    \ a CoAP server hosting the resource that is made\n   accessible to other entities.\
    \  Despite running a CoAP server on the\n   IoT device, it is still the DTLS client\
    \ on the IoT device that\n   initiates the interaction with the non-constrained\
    \ resource server in\n   our scenario.\n   Figure 4 shows a sensor starting a\
    \ DTLS exchange with a resource\n   directory and uses CoAP to register available\
    \ resources in Figure 5.\n   [CoRE-RD] defines the resource directory (RD) as\
    \ a web entity that\n   stores information about web resources and implements\n\
    \   Representational State Transfer (REST) interfaces for registration\n   and\
    \ lookup of those resources.  Note that the described exchange is\n   borrowed\
    \ from the Open Mobile Alliance (OMA) Lightweight\n   Machine-to-Machine (LWM2M)\
    \ specification [LWM2M] that uses RD but\n   adds proxy functionality.\n   The\
    \ initial DTLS interaction between the sensor, acting as a DTLS\n   client, and\
    \ the resource directory, acting as a DTLS server, will be\n   a full DTLS handshake.\
    \  Once this handshake is complete, both parties\n   have established the DTLS\
    \ record layer.  Subsequently, the CoAP\n   client can securely register at the\
    \ resource directory.\n   After some time (assuming that the client regularly\
    \ refreshes its\n   registration), the resource directory receives a request from\
    \ an\n   application to retrieve the temperature information from the sensor.\n\
    \   This request is relayed by the resource directory to the sensor using\n  \
    \ a GET message exchange.  The already established DTLS record layer\n   can be\
    \ used to secure the message exchange.\n                                     \
    \               Resource\n       Sensor                                      \
    \ Directory\n       ------                                       ---------\n \
    \    +---\n     |\n     | ClientHello             -------->\n     | #client_certificate_type#\n\
    \    F| #server_certificate_type#\n    U|\n    L|                         <-------\
    \    HelloVerifyRequest\n    L|\n     | ClientHello             -------->\n  \
    \  D| #client_certificate_type#\n    T| #server_certificate_type#\n    L|\n  \
    \  S|                                            ServerHello\n     |         \
    \                      #client_certificate_type#\n    H|                     \
    \          #server_certificate_type#\n    A|                                 \
    \           Certificate\n    N|                                      ServerKeyExchange\n\
    \    D|                                     CertificateRequest\n    S|       \
    \                  <--------      ServerHelloDone\n    H|\n    A| Certificate\n\
    \    K| ClientKeyExchange\n    E| CertificateVerify\n     | [ChangeCipherSpec]\n\
    \     | Finished                -------->\n     |\n     |                    \
    \                 [ChangeCipherSpec]\n     |                         <--------\
    \             Finished\n     +---\n      Note: Extensions marked with \"#\" were\
    \ introduced with\n            RFC 7250.\n          Figure 4: DTLS/CoAP Exchange\
    \ Using Resource Directory:\n                         Part 1 -- DTLS Handshake\n\
    \   Figure 5 shows the DTLS-secured communication between the sensor and\n   the\
    \ resource directory using CoAP.\n                                           \
    \         Resource\n       Sensor                                       Directory\n\
    \       ------                                       ---------\n   [[==============DTLS-Secured\
    \ Communication===================]]\n     +---                              \
    \                    ///+\n    C|                                            \
    \            \\ D\n    O| Req: POST coap://rd.example.com/rd?ep=node1        \
    \    \\ T\n    A| Payload:                                               \\ L\n\
    \    P| </temp>;ct=41;                                         \\ S\n     |  \
    \  rt=\"temperature-c\";if=\"sensor\",                     \\\n    R| </light>;ct=41;\
    \                                        \\ R\n    D|    rt=\"light-lux\";if=\"\
    sensor\"                          \\ E\n     |                         -------->\
    \                      \\ C\n    R|                                          \
    \              \\ O\n    E|                                                  \
    \      \\ R\n    G|                                     Res: 2.01 Created  \\\
    \ D\n     |                         <--------  Location: /rd/4521  \\\n     |\
    \                                                        \\ L\n     +---     \
    \                                                \\ A\n                      \
    \                                        \\ Y\n                              *\
    \                               \\ E\n                              * (time passes)\
    \                 \\ R\n                              *                      \
    \         \\\n     +---                                                     \\\
    \ P\n    C|                                                        \\ R\n    O|\
    \              Req: GET coaps://sensor.example.com/temp  \\ O\n    A|        \
    \                 <--------                      \\ T\n    P|                \
    \                                        \\ E\n     | Res:  2.05 Content     \
    \                                \\ C\n    G| Payload:                       \
    \                        \\ T\n    E| 25.5                     -------->     \
    \                \\ E\n    T|                                                \
    \        \\ D\n     +---                                                  ///+\n\
    \          Figure 5: DTLS/CoAP Exchange Using Resource Directory:\n          \
    \              Part 2 -- CoAP/RD Exchange\n   Note that the CoAP GET message transmitted\
    \ from the resource server\n   is protected using the previously established DTLS\
    \ record layer.\n"
- title: 3.2.2.  Constrained TLS/DTLS Servers
  contents:
  - "3.2.2.  Constrained TLS/DTLS Servers\n   Section 3.2.1 illustrates a deployment\
    \ model where the TLS/DTLS\n   client is constrained and efforts need to be taken\
    \ to improve memory\n   utilization, bandwidth consumption, reduce performance\
    \ impacts, etc.\n   In this section, we assume a scenario where constrained devices\
    \ run\n   TLS/DTLS servers to secure access to application-layer services\n  \
    \ running on top of CoAP, HTTP, or other protocols.  Figure 6\n   illustrates\
    \ a possible deployment whereby a number of constrained\n   servers are waiting\
    \ for regular clients to access their resources.\n   The entire process is likely,\
    \ but not necessarily, controlled by a\n   third party, the authentication and\
    \ authorization server.  This\n   authentication and authorization server is responsible\
    \ for holding\n   authorization policies that govern the access to resources and\n\
    \   distribution of keying material.\n            +////////////////////////////////////+\n\
    \            |          Configuration             |\n            |////////////////////////////////////|\n\
    \            | Credentials                        |\n            |    Client A\
    \  -> Public Key         |\n            |    Server S1 -> Symmetric Key      |\n\
    \            |    Server S2 -> Certificate        |\n            |    Server S3\
    \ -> Public Key         |\n            | Trust Anchor Store                 |\n\
    \            | Access Control Lists               |\n            |    Resource\
    \ X: Client A / GET      |\n            |    Resource Y: Client A / PUT      |\n\
    \            +------------------------------------+\n                oo\n    \
    \      oooooo\n         o\n   +---------------+                +-----------+\n\
    \   |Authentication |      +-------->|TLS/DTLS   |\n   |& Authorization|     \
    \ |         |Client A   |\n   |Server         |      |         +-----------+\n\
    \   +---------------+     ++\n                ^        |                  +-----------+\n\
    \                 \\       |                  |Constrained|\n                \
    \  \\  ,-------.              | Server S1 |\n                   ,'         `.\
    \            +-----------+\n                  /    Local    \\\n             \
    \    (    Network    )\n                  \\             /        +-----------+\n\
    \                   `.         ,'         |Constrained|\n                    \
    \ '---+---'           | Server S2 |\n                         |              \
    \ +-----------+\n                         |\n                         |      \
    \             +-----------+\n                         +-----------------> |Constrained|\n\
    \                                             | Server S3 |\n                \
    \                             +-----------+\n                   Figure 6: Constrained\
    \ Server Profile\n   A deployment with constrained servers has to overcome several\n\
    \   challenges.  Below we explain how these challenges can be solved with\n  \
    \ CoAP, as an example.  Other protocols may offer similar capabilities.\n   While\
    \ the requirements for the TLS/DTLS protocol profile change only\n   slightly\
    \ when run on a constrained server (in comparison to running\n   it on a constrained\
    \ client), several other ecosystem factors will\n   impact deployment.\n   There\
    \ are several challenges that need to be addressed:\n   Discovery and Reachability:\n\
    \      A client must first and foremost discover the server before\n      initiating\
    \ a connection to it.  Once it has been discovered,\n      reachability to the\
    \ device needs to be maintained.\n      In CoAP, the discovery of resources offered\
    \ by servers is\n      accomplished by sending a unicast or multicast CoAP GET\
    \ to a well-\n      known URI.  The Constrained RESTful Environments (CoRE) Link\n\
    \      Format specification [RFC6690] describes the use case (see\n      Section\
    \ 1.2.1) and reserves the URI (see Section 7.1).  Section 7\n      of the CoAP\
    \ specification [RFC7252] describes the discovery\n      procedure.  [RFC7390]\
    \ describes the use case for discovering CoAP\n      servers using multicast (see\
    \ Section 3.3) and specifies the\n      protocol processing rules for CoAP group\
    \ communications (see\n      Section 2.7).\n      The use of RD [CoRE-RD] is yet\
    \ another possibility for discovering\n      registered servers and their resources.\
    \  Since RD is usually not a\n      proxy, clients can discover links registered\
    \ with the RD and then\n      access them directly.\n   Authentication:\n    \
    \  The next challenge concerns the provisioning of authentication\n      credentials\
    \ to the clients as well as servers.  In Section 3.2.1,\n      we assume that\
    \ credentials (and other configuration information)\n      are provisioned to\
    \ the device, and that those can be used with the\n      authorization servers.\
    \  Of course, this leads to a very static\n      relationship between the clients\
    \ and their server-side\n      infrastructure but poses fewer challenges from\
    \ a deployment point\n      of view, as described in Section 2 of [RFC7452]. \
    \ In any case,\n      engineers and product designers have to determine how the\
    \ relevant\n      credentials are distributed to the respective parties.  For\n\
    \      example, shared secrets may need to be provisioned to clients and\n   \
    \   the constrained servers for subsequent use of TLS/DTLS PSK.  In\n      other\
    \ deployments, certificates, private keys, and trust anchors\n      for use with\
    \ certificate-based authentication may need to be\n      utilized.\n      Practical\
    \ solutions use either pairing (also called imprinting) or\n      a trusted third\
    \ party.  With pairing, two devices execute a\n      special protocol exchange\
    \ that is unauthenticated to establish a\n      shared key (for example, using\
    \ an unauthenticated Diffie-Hellman\n      (DH) exchange).  To avoid man-in-the-middle\
    \ attacks, an\n      out-of-band channel is used to verify that nobody has tampered\n\
    \      with the exchanged protocol messages.  This out-of-band channel\n     \
    \ can come in many forms, including:\n      *  Human involvement by comparing\
    \ hashed keys, entering passkeys,\n         and scanning QR codes\n      *  The\
    \ use of alternative wireless communication channels (e.g.,\n         infrared\
    \ communication in addition to Wi-Fi)\n      *  Proximity-based information\n\
    \      More details about these different pairing/imprinting techniques\n    \
    \  can be found in the Smart Object Security Workshop report\n      [RFC7397]\
    \ and various position papers submitted on that topic,\n      such as [ImprintingSurvey].\
    \  The use of a trusted third party\n      follows a different approach and is\
    \ subject to ongoing\n      standardization efforts in the Authentication and\
    \ Authorization\n      for Constrained Environments (ACE) working group [ACE-WG].\n\
    \   Authorization\n      The last challenge is the ability for the constrained\
    \ server to\n      make an authorization decision when clients access protected\n\
    \      resources.  Pre-provisioning access control information to\n      constrained\
    \ servers may be one option but works only in a small\n      scale, less dynamic\
    \ environment.  For a finer-grained and more\n      dynamic access control solution,\
    \ the reader is referred to the\n      ongoing work in the IETF ACE working group.\n\
    \   Figure 7 shows an example interaction whereby a device, a thermostat\n   in\
    \ our case, searches in the local network for discoverable resources\n   and accesses\
    \ those.  The thermostat starts the procedure using a\n   link-local discovery\
    \ message using the \"All CoAP Nodes\" multicast\n   address by utilizing the\
    \ link format per RFC 6690 [RFC6690].  The\n   IPv6 multicast address used for\
    \ CoAP link-local discovery is\n   FF02::FD.  As a result, a temperature sensor\
    \ and a fan respond.\n   These responses allow the thermostat to subsequently\
    \ read temperature\n   information from the temperature sensor with a CoAP GET\
    \ request\n   issued to the previously learned endpoint.  In this example we assume\n\
    \   that accessing the temperature sensor readings and controlling the\n   fan\
    \ requires authentication and authorization of the thermostat and\n   TLS is used\
    \ to authenticate both endpoints and to secure the\n   communication.\n      \
    \                           Temperature\n     Thermostat                     Sensor\
    \              Fan\n     ----------                   ---------             ---\n\
    \       Discovery\n       -------------------->\n       GET coap://[FF02::FD]/.well-known/core\n\
    \                     CoAP 2.05 Content\n      <-------------------------------\n\
    \      </3303/0/5700>;rt=\"temperature\";\n                     if=\"sensor\"\n\
    \                                        CoAP 2.05 Content\n      <--------------------------------------------------\n\
    \                           </fan>;rt=\"fan\";if=\"actuation\"\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   \\ Protocol steps to obtain access token or keying        /\n   \\ material\
    \ for access to the temperature sensor and fan. /\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \      Read Sensor Data\n      (authenticated/authorized)\n      ------------------------------->\n\
    \      GET /3303/0/5700\n                    CoAP 2.05 Content\n     <-------------------------------\n\
    \                               22.5 C\n     Configure Actuator\n     (authenticated/authorized)\n\
    \     ------------------------------------------------->\n     PUT /fan?on-off=true\n\
    \                                      CoAP 2.04 Changed\n     <-------------------------------------------------\n\
    \               Figure 7: Local Discovery and Resource Access\n"
- title: 3.3.  The Ciphersuite Concept
  contents:
  - "3.3.  The Ciphersuite Concept\n   TLS (and consequently DTLS) support ciphersuites,\
    \ and an IANA\n   registry [IANA-TLS] was created to register the suites.  A\n\
    \   ciphersuite (and the specification that defines it) contains the\n   following\
    \ information:\n   o  Authentication and key exchange algorithm (e.g., PSK)\n\
    \   o  Cipher and key length (e.g., Advanced Encryption Standard (AES)\n     \
    \ with 128-bit keys [AES])\n   o  Mode of operation (e.g., Counter with CBC-MAC\
    \ (CCM) mode for AES)\n      [RFC3610]\n   o  Hash algorithm for integrity protection,\
    \ such as the Secure Hash\n      Algorithm (SHA) in combination with Keyed-Hashing\
    \ for Message\n      Authentication (HMAC) (see [RFC2104] and [RFC6234])\n   o\
    \  Hash algorithm for use with pseudorandom functions (e.g., HMAC\n      with\
    \ the SHA-256)\n   o  Misc information (e.g., length of authentication tags)\n\
    \   o  Information whether the ciphersuite is suitable for DTLS or only\n    \
    \  for TLS\n   The TLS ciphersuite TLS_PSK_WITH_AES_128_CCM_8, for example, uses\
    \ a\n   pre-shared authentication and key exchange algorithm.  [RFC6655]\n   defines\
    \ this ciphersuite.  It uses the AES encryption algorithm,\n   which is a block\
    \ cipher.  Since the AES algorithm supports different\n   key lengths (such as\
    \ 128, 192, and 256 bits), this information has to\n   be specified as well, and\
    \ the selected ciphersuite supports 128-bit\n   keys.  A block cipher encrypts\
    \ plaintext in fixed-size blocks, and\n   AES operates on a block size of 128\
    \ bits.  For messages exceeding 128\n   bits, the message is partitioned into\
    \ 128-bit blocks, and the AES\n   cipher is applied to these input blocks with\
    \ appropriate chaining,\n   which is called mode of operation.\n   TLS 1.2 introduced\
    \ Authenticated Encryption with Associated Data\n   (AEAD) ciphersuites (see [RFC5116]\
    \ and [RFC6655]).  AEAD is a class\n   of block cipher modes that encrypt (parts\
    \ of) the message and\n   authenticate the message simultaneously.  AES-CCM [RFC6655]\
    \ is an\n   example of such a mode.\n   Some AEAD ciphersuites have shorter authentication\
    \ tags (i.e.,\n   message authentication codes) and are therefore more suitable\
    \ for\n   networks with low bandwidth where small message size matters.  The\n\
    \   TLS_PSK_WITH_AES_128_CCM_8 ciphersuite that ends in \"_8\" has an\n   8-octet\
    \ authentication tag, while the regular CCM ciphersuites have,\n   at the time\
    \ of writing, 16-octet authentication tags.  The design of\n   CCM and the security\
    \ properties are described in [CCM].\n   TLS 1.2 also replaced the combination\
    \ of MD5/SHA-1 hash functions in\n   the TLS pseudorandom function (PRF) used\
    \ in earlier versions of TLS\n   with ciphersuite-specified PRFs.  For this reason,\
    \ authors of more\n   recent TLS 1.2 ciphersuite specifications explicitly indicate\
    \ the MAC\n   algorithm and the hash functions used with the TLS PRF.\n"
- title: 4.  Credential Types
  contents:
  - "4.  Credential Types\n   The mandatory-to-implement functionality will depend\
    \ on the\n   credential type used with IoT devices.  The subsections below\n \
    \  describe the implications of three different credential types, namely\n   pre-shared\
    \ secrets, raw public keys, and certificates.\n"
- title: 4.1.  Preconditions
  contents:
  - "4.1.  Preconditions\n   All exchanges described in the subsequent sections assume\
    \ that some\n   information has been distributed before the TLS/DTLS interaction\n\
    \   starts.  The credentials are used to authenticate the client to the\n   server,\
    \ and vice versa.  What information items have to be\n   distributed depends on\
    \ the chosen credential types.  In all cases,\n   the IoT device needs to know\
    \ what algorithms to prefer, particularly\n   if there are multiple algorithm\
    \ choices available as part of the\n   implemented ciphersuites, as well as information\
    \ about the other\n   communication endpoint (for example, in the form of a URI)\
    \ a\n   particular credential has to be used with.\n   Pre-Shared Secrets:  In\
    \ this case, a shared secret together with an\n      identifier needs to be made\
    \ available to the device as well as to\n      the other communication party.\n\
    \   Raw Public Keys:  A public key together with a private key are stored\n  \
    \    on the device and typically associated with some identifier.  To\n      authenticate\
    \ the other communication party, the appropriate\n      credential has to be known.\
    \  If the other end uses raw public keys\n      as well, then their public key\
    \ needs to be provisioned (out of\n      band) to the device.\n   Certificates:\
    \  The use of certificates requires the device to store\n      the public key\
    \ (as part of the certificate) as well as the private\n      key.  The certificate\
    \ will contain the identifier of the device as\n      well as various other attributes.\
    \  Both communication parties are\n      assumed to be in possession of a trust\
    \ anchor store that contains\n      CA certificates and, in case of certificate\
    \ pinning, end-entity\n      certificates.  Similar to the other credentials,\
    \ the IoT device\n      needs information about which entity to use which certificate\n\
    \      with.  Without a trust anchor store on the IoT device, it will not\n  \
    \    be possible to perform certificate validation.\n   We call the above-listed\
    \ information \"device credentials\" and these\n   device credentials may be provisioned\
    \ to the device already during\n   the manufacturing time or later in the process,\
    \ depending on the\n   envisioned business and deployment model.  These initial\
    \ credentials\n   are often called \"root of trust\".  Whatever process is chosen\
    \ for\n   generating these initial device credentials, it MUST be ensured that\n\
    \   a different key pair is provisioned for each device and installed in\n   as\
    \ secure a manner as possible.  For example, it is preferable to\n   generate\
    \ public/private keys on the IoT device itself rather than\n   generating them\
    \ outside the device.  Since an IoT device is likely to\n   interact with various\
    \ other parties, the initial device credential\n   may only be used with some\
    \ dedicated entities, and configuring\n   further configuration and credentials\
    \ to the device is left to a\n   separate interaction.  An example of a dedicated\
    \ protocol used to\n   distribute credentials, access control lists, and configure\n\
    \   information is the LWM2M protocol [LWM2M].\n   For all the credentials listed\
    \ above, there is a chance that those\n   may need to be replaced or deleted.\
    \  While separate protocols have\n   been developed to check the status of these\
    \ credentials and to manage\n   these credentials, such as the Trust Anchor Management\
    \ Protocol\n   (TAMP) [RFC5934], their usage is, however, not envisioned in the\
    \ IoT\n   context so far.  IoT devices are assumed to have a software update\n\
    \   mechanism built-in, and it will allow updates of low-level device\n   information,\
    \ including credentials and configuration parameters.\n   This document does,\
    \ however, not mandate a specific software/firmware\n   update protocol.\n   With\
    \ all credentials used as input to TLS/DTLS authentication, it is\n   important\
    \ that these credentials have been generated with care.  When\n   using a pre-shared\
    \ secret, a critical consideration is using\n   sufficient entropy during the\
    \ key generation, as discussed in\n   [RFC4086].  Deriving a shared secret from\
    \ a password, some device\n   identifiers, or other low-entropy sources is not\
    \ secure.  A low-\n   entropy secret, or password, is subject to dictionary attacks.\n\
    \   Attention also has to be paid when generating public/private key\n   pairs\
    \ since the lack of randomness can result in the same key pair\n   being used\
    \ in many devices.  This topic is also discussed in\n   Section 12 since keys\
    \ are generated during the TLS/DTLS exchange\n   itself as well, and the same\
    \ considerations apply.\n"
- title: 4.2.  Pre-Shared Secret
  contents:
  - "4.2.  Pre-Shared Secret\n   The use of pre-shared secrets is one of the most\
    \ basic techniques for\n   TLS/DTLS since it is both computationally efficient\
    \ and bandwidth\n   conserving.  Authentication based on pre-shared secrets was\n\
    \   introduced to TLS in RFC 4279 [RFC4279].\n   Figure 8 illustrates the DTLS\
    \ exchange including the cookie exchange.\n   While the server is not required\
    \ to initiate a cookie exchange with\n   every handshake, the client is required\
    \ to implement and to react on\n   it when challenged, as defined in RFC 6347\
    \ [RFC6347].  The cookie\n   exchange allows the server to react to flooding attacks.\n\
    \         Client                                               Server\n      \
    \   ------                                               ------\n         ClientHello\
    \                 -------->\n                                     <--------  \
    \  HelloVerifyRequest\n                                                   (contains\
    \ cookie)\n         ClientHello                  -------->\n         (with cookie)\n\
    \                                                         ServerHello\n      \
    \                                            *ServerKeyExchange\n            \
    \                          <--------      ServerHelloDone\n         ClientKeyExchange\n\
    \         ChangeCipherSpec\n         Finished                     -------->\n\
    \                                                    ChangeCipherSpec\n      \
    \                                <--------             Finished\n         Application\
    \ Data             <------->     Application Data\n   Legend:\n   * indicates\
    \ an optional message payload\n      Figure 8: DTLS PSK Authentication Including\
    \ the Cookie Exchange\n   Note that [RFC4279] used the term \"PSK identity\" to\
    \ refer to the\n   identifier used to refer to the appropriate secret.  While\n\
    \   \"identifier\" would be more appropriate in this context, we reuse the\n \
    \  terminology defined in RFC 4279 to avoid confusion.  RFC 4279 does\n   not\
    \ mandate the use of any particular type of PSK identity, and the\n   client and\
    \ server have to agree on the identities and keys to be\n   used.  The UTF-8 encoding\
    \ of identities described in Section 5.1 of\n   RFC 4279 aims to improve interoperability\
    \ for those cases where the\n   identity is configured by a human using some management\
    \ interface\n   provided by a web browser.  However, many IoT devices do not have\
    \ a\n   user interface, and most of their credentials are bound to the device\n\
    \   rather than to the user.  Furthermore, credentials are often\n   provisioned\
    \ into hardware modules or provisioned alongside with\n   firmware.  As such,\
    \ the encoding considerations are not applicable to\n   this usage environment.\
    \  For use with this profile, the PSK\n   identities SHOULD NOT assume a structured\
    \ format (such as domain\n   names, distinguished names, or IP addresses), and\
    \ a byte-by-byte\n   comparison operation MUST be used by the server for any operation\n\
    \   related to the PSK identity.  These types of identifiers are called\n   \"\
    absolute\" per RFC 6943 [RFC6943].\n   Protocol-wise, the client indicates which\
    \ key it uses by including a\n   \"PSK identity\" in the ClientKeyExchange message.\
    \  As described in\n   Section 3.2, clients may have multiple pre-shared keys\
    \ with a single\n   server, for example, in a hosting context.  The TLS Server\
    \ Name\n   Indication (SNI) extension allows the client to convey the name of\n\
    \   the server it is contacting.  A server implementation needs to guide\n   the\
    \ selection based on a received SNI value from the client.\n   RFC 4279 requires\
    \ TLS implementations supporting PSK ciphersuites to\n   support arbitrary PSK\
    \ identities up to 128 octets in length and\n   arbitrary PSKs up to 64 octets\
    \ in length.  This is a useful\n   assumption for TLS stacks used in the desktop\
    \ and mobile environments\n   where management interfaces are used to provision\
    \ identities and\n   keys.  Implementations in compliance with this profile MAY\
    \ use PSK\n   identities up to 128 octets in length and arbitrary PSKs up to 64\n\
    \   octets in length.  The use of shorter PSK identities is RECOMMENDED.\n   \"\
    The Constrained Application Protocol (CoAP)\" [RFC7252] currently\n   specifies\
    \ TLS_PSK_WITH_AES_128_CCM_8 as the mandatory-to-implement\n   ciphersuite for\
    \ use with shared secrets.  This ciphersuite uses the\n   AES algorithm with 128\
    \ bit keys and CCM as the mode of operation.\n   The label \"_8\" indicates that\
    \ an 8-octet authentication tag is used.\n   Note that the shorted authentication\
    \ tag increases the chance that an\n   adversary with no knowledge of the secret\
    \ key can present a message\n   with a MAC that will pass the verification procedure.\
    \  The likelihood\n   of accepting forged data is explained in Section 5.3.5 of\n\
    \   [SP800-107-rev1] and depends on the lengths of the authentication tag\n  \
    \ and allowed numbers of MAC verifications using a given key.\n   This ciphersuite\
    \ makes use of the default TLS 1.2 PRF, which uses an\n   HMAC with the SHA-256\
    \ hash function.  Note: Starting with TLS 1.2\n   (and consequently DTLS 1.2),\
    \ ciphersuites have to specify the PRF.\n   RFC 5246 states that \"New cipher\
    \ suites MUST explicitly specify a PRF\n   and, in general, SHOULD use the TLS\
    \ PRF with SHA-256 or a stronger\n   standard hash function.\"  The ciphersuites\
    \ recommended in this\n   document use the SHA-256 construct defined in Section\
    \ 5 of RFC 5246.\n   A device compliant with the profile in this section MUST\
    \ implement\n   TLS_PSK_WITH_AES_128_CCM_8 and follow the guidance from this section.\n"
- title: 4.3.  Raw Public Key
  contents:
  - "4.3.  Raw Public Key\n   The use of raw public keys with TLS/DTLS, as defined\
    \ in [RFC7250], is\n   the first entry point into public key cryptography without\
    \ having to\n   pay the price of certificates and a public key infrastructure\
    \ (PKI).\n   The specification reuses the existing Certificate message to convey\n\
    \   the raw public key encoded in the SubjectPublicKeyInfo structure.  To\n  \
    \ indicate support, two new extensions had been defined, as shown in\n   Figure\
    \ 9, namely the server_certificate_type and the\n   client_certificate_type.\n\
    \    Client                                          Server\n    ------      \
    \                                    ------\n    ClientHello             -------->\n\
    \    #client_certificate_type#\n    #server_certificate_type#\n              \
    \                                 ServerHello\n                              \
    \   #client_certificate_type#\n                                 #server_certificate_type#\n\
    \                                               Certificate\n                \
    \                         ServerKeyExchange\n                                \
    \        CertificateRequest\n                            <--------      ServerHelloDone\n\
    \    Certificate\n    ClientKeyExchange\n    CertificateVerify\n    [ChangeCipherSpec]\n\
    \    Finished                -------->\n                                     \
    \   [ChangeCipherSpec]\n                            <--------             Finished\n\
    \   Note: Extensions marked with \"#\" were introduced with\n         RFC 7250.\n\
    \                  Figure 9: DTLS Raw Public Key Exchange\n   The CoAP-recommended\
    \ ciphersuite for use with this credential type is\n   TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\
    \ [RFC7251].  This AES-CCM TLS\n   ciphersuite based on elliptic curve cryptography\
    \ (ECC) uses the\n   Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) as the key\n\
    \   establishment mechanism and an Elliptic Curve Digital Signature\n   Algorithm\
    \ (ECDSA) for authentication.  The named DH groups\n   [FFDHE-TLS] are not applicable\
    \ to this profile since it relies on the\n   ECC-based counterparts.  This ciphersuite\
    \ makes use of the AEAD\n   capability in DTLS 1.2 and utilizes an 8-octet authentication\
    \ tag.\n   The use of a DH key exchange provides perfect forward secrecy (PFS).\n\
    \   More details about PFS can be found in Section 9.\n   [RFC6090] provides valuable\
    \ information for implementing ECC\n   algorithms, particularly for choosing methods\
    \ that have been\n   available in the literature for a long time (i.e., 20 years\
    \ and\n   more).\n   A device compliant with the profile in this section MUST\
    \ implement\n   TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from\
    \ this\n   section.\n"
- title: 4.4.  Certificates
  contents:
  - "4.4.  Certificates\n   The use of mutual certificate-based authentication is\
    \ shown in\n   Figure 10, which makes use of the \"cached_info\" extension [RFC7924].\n\
    \   Support of the \"cached_info\" extension is REQUIRED.  Caching\n   certificate\
    \ chains allows the client to reduce the communication\n   overhead significantly,\
    \ otherwise the server would provide the end-\n   entity certificate and the certificate\
    \ chain with every full DTLS\n   handshake.\n    Client                      \
    \                    Server\n    ------                                      \
    \    ------\n    ClientHello             -------->\n    *cached_info*\n      \
    \                                         ServerHello\n                      \
    \                       *cached_info*\n                                      \
    \         Certificate\n                                         ServerKeyExchange\n\
    \                                        CertificateRequest\n                \
    \            <--------      ServerHelloDone\n    Certificate\n    ClientKeyExchange\n\
    \    CertificateVerify\n    [ChangeCipherSpec]\n    Finished                -------->\n\
    \                                        [ChangeCipherSpec]\n                \
    \            <--------             Finished\n   Note: Extensions marked with \"\
    *\" were introduced with\n         RFC 7924.\n          Figure 10: DTLS Mutual\
    \ Certificate-Based Authentication\n   TLS/DTLS offers a lot of choices when selecting\
    \ ECC-based\n   ciphersuites.  This document restricts the use to named curves\n\
    \   defined in RFC 4492 [RFC4492].  At the time of writing, the\n   recommended\
    \ curve is secp256r1, and the use of uncompressed points\n   follows the recommendation\
    \ in CoAP.  Note that standardization for\n   Curve25519 (for ECDHE) is ongoing\
    \ (see [RFC7748]), and support for\n   this curve will likely be required in the\
    \ future.\n   A device compliant with the profile in this section MUST implement\n\
    \   TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from this\n   section.\n"
- title: 4.4.1.  Certificates Used by Servers
  contents:
  - "4.4.1.  Certificates Used by Servers\n   The algorithm for verifying the service\
    \ identity, as described in RFC\n   6125 [RFC6125], is essential for ensuring\
    \ proper security when\n   certificates are used.  As a summary, the algorithm\
    \ contains the\n   following steps:\n   1.  The client constructs a list of acceptable\
    \ reference identifiers\n       based on the source domain and, optionally, the\
    \ type of service\n       to which the client is connecting.\n   2.  The server\
    \ provides its identifiers in the form of a PKIX\n       certificate.\n   3. \
    \ The client checks each of its reference identifiers against the\n       presented\
    \ identifiers for the purpose of finding a match.\n   4.  When checking a reference\
    \ identifier against a presented\n       identifier, the client matches the source\
    \ domain of the\n       identifiers and, optionally, their application service\
    \ type.\n   For various terms used in the algorithm shown above, consult RFC\n\
    \   6125.  It is important to highlight that comparing the reference\n   identifier\
    \ against the presented identifier obtained from the\n   certificate is required\
    \ to ensure the client is communicating with\n   the intended server.\n   It is\
    \ worth noting that the algorithm description and the text in RFC\n   6125 assumes\
    \ that fully qualified DNS domain names are used.  If a\n   server node is provisioned\
    \ with a fully qualified DNS domain, then\n   the server certificate MUST contain\
    \ the fully qualified DNS domain\n   name or \"FQDN\" as dNSName [RFC5280].  For\
    \ CoAP, the coaps URI scheme\n   is described in Section 6.2 of [RFC7252].  This\
    \ FQDN is stored in the\n   SubjectAltName or in the leftmost Common Name (CN)\
    \ component of the\n   subject name, as explained in Section 9.1.3.3 of [RFC7252],\
    \ and used\n   by the client to match it against the FQDN used during the lookup\n\
    \   process, as described in [RFC6125].  For other protocols, the\n   appropriate\
    \ URI scheme specification has to be consulted.\n   The following recommendation\
    \ is provided:\n   1.  Certificates MUST NOT use DNS domain names in the CN of\n\
    \       certificates and instead use the subjectAltName attribute, as\n      \
    \ described in the previous paragraph.\n   2.  Certificates MUST NOT contain domain\
    \ names with wildcard\n       characters.\n   3.  Certificates MUST NOT contain\
    \ multiple names (e.g., more than one\n       dNSName field).\n   Note that there\
    \ will be servers that are not provisioned for use with\n   DNS domain names,\
    \ for example, IoT devices that offer resources to\n   nearby devices in a local\
    \ area network, as shown in Figure 7.  When\n   such constrained servers are used,\
    \ then the use of certificates as\n   described in Section 4.4.2 is applicable.\
    \  Note that the SNI\n   extension cannot be used in this case since SNI does\
    \ not offer the\n   ability to convey a 64-bit Extended Unique Identifier (EUI-64)\n\
    \   [EUI64].  Note that this document does not recommend use of IP\n   addresses\
    \ in certificates nor does it discuss the implications of\n   placing IP addresses\
    \ in certificates.\n"
- title: 4.4.2.  Certificates Used by Clients
  contents:
  - "4.4.2.  Certificates Used by Clients\n   For client certificates, the identifier\
    \ used in the SubjectAltName or\n   in the leftmost CN component of subject name\
    \ MUST be an EUI-64.\n"
- title: 4.4.3.  Certificate Revocation
  contents:
  - "4.4.3.  Certificate Revocation\n   For certificate revocation, neither the Online\
    \ Certificate Status\n   Protocol (OCSP) nor Certificate Revocation Lists (CRLs)\
    \ are used.\n   Instead, this profile relies on a software update mechanism to\n\
    \   provision information about revoked certificates.  While multiple\n   OCSP\
    \ stapling [RFC6961] has recently been introduced as a mechanism\n   to piggyback\
    \ OCSP request/responses inside the DTLS/TLS handshake (to\n   avoid the cost\
    \ of a separate protocol handshake), further\n   investigations are needed to\
    \ determine its suitability for the IoT\n   environment.\n   As stated earlier\
    \ in this section, modifications to the trust anchor\n   store depends on a software\
    \ update mechanism as well.  There are\n   limitations to the use of a software\
    \ update mechanism because of the\n   potential inability to change certain types\
    \ of keys, such as those\n   provisioned during manufacturing.  For this reason,\
    \ manufacturer-\n   provisioned credentials are typically employed only to obtain\
    \ further\n   certificates (for example, via a key distribution server) for use\n\
    \   with servers the IoT device is finally communicating with.\n"
- title: 4.4.4.  Certificate Content
  contents:
  - "4.4.4.  Certificate Content\n   All certificate elements listed in Table 1 MUST\
    \ be implemented by\n   clients and servers claiming support for certificate-based\n\
    \   authentication.  No other certificate elements are used by this\n   specification.\n\
    \   When using certificates, IoT devices MUST provide support for a\n   server\
    \ certificate chain of at least 3, not including the trust\n   anchor, and MAY\
    \ reject connections from servers offering chains\n   longer than 3.  IoT devices\
    \ MAY have client certificate chains of any\n   length.  Obviously, longer chains\
    \ require more digital signature\n   verification operations to perform and lead\
    \ to larger certificate\n   messages in the TLS handshake.\n   Table 1 provides\
    \ a summary of the elements in a certificate for use\n   with this profile.\n\
    \   +----------------------+--------------------------------------------+\n  \
    \ |       Element        |                   Notes                    |\n   +----------------------+--------------------------------------------+\n\
    \   |       version        |  This profile uses X.509 v3 certificates   |\n  \
    \ |                      |                 [RFC5280].                 |\n   |\
    \                      |                                            |\n   |  \
    \   serialNumber     |  Positive integer unique per certificate.  |\n   |    \
    \                  |                                            |\n   |      signature\
    \       |     This field contains the signature      |\n   |                 \
    \     |  algorithm, and this profile uses ecdsa-   |\n   |                   \
    \   |     with-SHA256 or stronger [RFC5758].     |\n   |                     \
    \ |                                            |\n   |        issuer        |\
    \     Contains the DN of the issuing CA.     |\n   |                      |  \
    \                                          |\n   |       validity       | Values\
    \ expressed as UTC time in notBefore  |\n   |                      |  and notAfter\
    \ fields.  No validity period  |\n   |                      |                \
    \ mandated.                  |\n   |                      |                  \
    \                          |\n   |       subject        |    See rules outlined\
    \ in this section.     |\n   |                      |                        \
    \                    |\n   | subjectPublicKeyInfo |     The SubjectPublicKeyInfo\
    \ structure     |\n   |                      | indicates the algorithm and any\
    \ associated |\n   |                      |  parameters for the ECC public key.\
    \  This  |\n   |                      | profile uses the id-ecPublicKey algorithm\
    \  |\n   |                      |  identifier for ECDSA signature keys, as   |\n\
    \   |                      |    defined and specified in [RFC5480].     |\n  \
    \ |                      |                                            |\n   |\
    \  signatureAlgorithm  | The ECDSA signature algorithm with ecdsa-  |\n   |  \
    \                    |          with-SHA256 or stronger.          |\n   |    \
    \                  |                                            |\n   |    signatureValue\
    \    |     Bit string containing the digital      |\n   |                    \
    \  |                 signature.                 |\n   |                      |\
    \                                            |\n   |      Extension:      |  \
    \  See rules outlined in this section.     |\n   |    subjectAltName    |    \
    \                                        |\n   |                      |      \
    \                                      |\n   |      Extension:      |    Indicates\
    \ whether the subject of the    |\n   |   BasicConstraints   | certificate is\
    \ a CA and the maximum depth  |\n   |                      | of valid certification\
    \ paths that include  |\n   |                      | this certificate.  This extension\
    \ is used  |\n   |                      |  for CA certs only, and then the value\
    \ of  |\n   |                      |    the \"cA\" field is set to TRUE.  The\
    \     |\n   |                      |             default is FALSE.           \
    \   |\n   |                      |                                           \
    \ |\n   | Extension: Key Usage | The KeyUsage field MAY have the following  |\n\
    \   |                      |   values in the context of this profile:   |\n  \
    \ |                      |     digitalSignature or keyAgreement,      |\n   |\
    \                      |  keyCertSign for verifying signatures on   |\n   |  \
    \                    |          public key certificates.          |\n   |    \
    \                  |                                            |\n   | Extension:\
    \ Extended  |  The ExtKeyUsageSyntax field MAY have the  |\n   |      Key Usage\
    \       |    following values in context of this     |\n   |                 \
    \     |    profile: id-kp-serverAuth for server    |\n   |                   \
    \   |    authentication, id-kp-clientAuth for    |\n   |                     \
    \ |  client authentication, id-kp-codeSigning  |\n   |                      |\
    \   for code signing (for software update    |\n   |                      |  \
    \ mechanism), and id-kp-OCSPSigning for    |\n   |                      |    \
    \     future OCSP usage in TLS.          |\n   +----------------------+--------------------------------------------+\n\
    \                       Table 1: Certificate Content\n   There are various cryptographic\
    \ algorithms available to sign digital\n   certificates; those algorithms include\
    \ RSA, the Digital Signature\n   Algorithm (DSA), and ECDSA.  As Table 1 shows,\
    \ certificates are\n   signed using ECDSA in this profile.  This is not only true\
    \ for the\n   end-entity certificates but also for all other certificates in the\n\
    \   chain, including CA certificates.  This profiling reduces the amount\n   of\
    \ flash memory needed on an IoT device to store the code of several\n   algorithm\
    \ implementations due to the smaller number of options.\n   Further details about\
    \ X.509 certificates can be found in\n   Section 9.1.3.3 of [RFC7252].\n"
- title: 4.4.5.  Client Certificate URLs
  contents:
  - "4.4.5.  Client Certificate URLs\n   RFC 6066 [RFC6066] allows the sending of\
    \ client-side certificates to\n   be avoided and uses URLs instead.  This reduces\
    \ the over-the-air\n   transmission.  Note that the TLS \"cached_info\" extension\
    \ does not\n   provide any help with caching client certificates.\n   TLS/DTLS\
    \ clients MUST implement support for client certificate URLs\n   for those environments\
    \ where client-side certificates are used and\n   the server-side is not constrained.\
    \  For constrained servers this\n   functionality is NOT RECOMMENDED since it\
    \ forces the server to\n   execute an additional protocol exchange, potentially\
    \ using a protocol\n   it does not even support.  The use of this extension also\
    \ increases\n   the risk of a DoS attack against the constrained server due to\
    \ the\n   additional workload.\n"
- title: 4.4.6.  Trusted CA Indication
  contents:
  - "4.4.6.  Trusted CA Indication\n   RFC 6066 [RFC6066] allows clients to indicate\
    \ what trust anchor they\n   support.  With certificate-based authentication,\
    \ a DTLS server\n   conveys its end-entity certificate to the client during the\
    \ DTLS\n   handshake.  Since the server does not necessarily know what trust\n\
    \   anchors the client has stored, to facilitate certification path\n   construction\
    \ and validation, it includes intermediate CA certs in the\n   certificate payload.\n\
    \   Today, in most IoT deployments there is a fairly static relationship\n   between\
    \ the IoT device (and the software running on them) and the\n   server-side infrastructure.\
    \  For these deployments where IoT devices\n   interact with a fixed, preconfigured\
    \ set of servers, this extension\n   is NOT RECOMMENDED.\n   In cases where clients\
    \ interact with dynamically discovered TLS/DTLS\n   servers, for example, in the\
    \ use cases described in Section 3.2.2,\n   the use of this extension is RECOMMENDED.\n"
- title: 5.  Signature Algorithm Extension
  contents:
  - "5.  Signature Algorithm Extension\n   The \"signature_algorithms\" extension,\
    \ defined in Section 7.4.1.4.1 of\n   RFC 5246 [RFC5246], allows the client to\
    \ indicate to the server which\n   signature/hash algorithm pairs may be used\
    \ in digital signatures.\n   The client MUST send this extension to select the\
    \ use of SHA-256,\n   otherwise if this extension is absent, RFC 5246 defaults\
    \ to SHA-1 /\n   ECDSA for the ECDH_ECDSA and the ECDHE_ECDSA key exchange algorithms.\n\
    \   The \"signature_algorithms\" extension is not applicable to the PSK-\n   based\
    \ ciphersuite described in Section 4.2.\n"
- title: 6.  Error Handling
  contents:
  - "6.  Error Handling\n   TLS/DTLS uses the alert protocol to convey errors and\
    \ specifies a\n   long list of error types.  However, not all error messages defined\
    \ in\n   the TLS/DTLS specification are applicable to this profile.  In\n   general,\
    \ there are two categories of errors (as defined in\n   Section 7.2 of RFC 5246),\
    \ namely fatal errors and warnings.  Alert\n   messages with a level of \"fatal\"\
    \ result in the immediate termination\n   of the connection.  If possible, developers\
    \ should try to develop\n   strategies to react to those fatal errors, such as\
    \ restarting the\n   handshake or informing the user using the (often limited)\
    \ user\n   interface.  Warnings may be ignored by the application since many IoT\n\
    \   devices will have either limited ways to log errors or no ability at\n   all.\
    \  In any case, implementers have to carefully evaluate the impact\n   of errors\
    \ and ways to remedy the situation since a commonly used\n   approach for delegating\
    \ decision making to users is difficult (or\n   impossible) to accomplish in a\
    \ timely fashion.\n   All error messages marked as RESERVED are only supported\
    \ for\n   backwards compatibility with the Secure Socket Layer (SSL) and MUST\n\
    \   NOT be used with this profile.  Those include\n   decryption_failed_RESERVED,\
    \ no_certificate_RESERVED, and\n   export_restriction_RESERVED.\n   A number of\
    \ the error messages MUST only be used for certificate-\n   based ciphersuites.\
    \  Hence, the following error messages MUST NOT be\n   used with PSK and raw public\
    \ key authentication:\n   o  bad_certificate,\n   o  unsupported_certificate,\n\
    \   o  certificate_revoked,\n   o  certificate_expired,\n   o  certificate_unknown,\n\
    \   o  unknown_ca, and\n   o  access_denied.\n   Since this profile does not make\
    \ use of compression at the TLS layer,\n   the decompression_failure error message\
    \ MUST NOT be used either.\n   RFC 4279 introduced the new alert message \"unknown_psk_identity\"\
    \ for\n   PSK ciphersuites.  As stated in Section 2 of RFC 4279, the\n   decrypt_error\
    \ error message may also be used instead.  For this\n   profile, the TLS server\
    \ MUST return the decrypt_error error message\n   instead of the unknown_psk_identity\
    \ since the two mechanisms exist\n   and provide the same functionality.\n   Furthermore,\
    \ the following errors should not occur with devices and\n   servers supporting\
    \ this specification, but implementations MUST be\n   prepared to process these\
    \ errors to deal with servers that are not\n   compliant to the profiles in this\
    \ document:\n   protocol_version:  While this document focuses only on one version\
    \ of\n      the TLS/DTLS protocol, namely version 1.2, ongoing work on TLS/\n\
    \      DTLS 1.3 is in progress at the time of writing.\n   insufficient_security:\
    \  This error message indicates that the server\n      requires ciphers to be\
    \ more secure.  This document specifies only\n      one ciphersuite per profile,\
    \ but it is likely that additional\n      ciphersuites will get added over time.\n\
    \   user_canceled:  Many IoT devices are unattended and hence this error\n   \
    \   message is unlikely to occur.\n"
- title: 7.  Session Resumption
  contents:
  - "7.  Session Resumption\n   Session resumption is a feature of the core TLS/DTLS\
    \ specifications\n   that allows a client to continue with an earlier established\
    \ session\n   state.  The resulting exchange is shown in Figure 11.  In addition,\n\
    \   the server may choose not to do a cookie exchange when a session is\n   resumed.\
    \  Still, clients have to be prepared to do a cookie exchange\n   with every handshake.\
    \  The cookie exchange is not shown in the\n   figure.\n         Client      \
    \                                         Server\n         ------            \
    \                                   ------\n         ClientHello             \
    \      -------->\n                                                          ServerHello\n\
    \                                                   [ChangeCipherSpec]\n     \
    \                                  <--------             Finished\n         [ChangeCipherSpec]\n\
    \         Finished                      -------->\n         Application Data \
    \             <------->     Application Data\n                    Figure 11: DTLS\
    \ Session Resumption\n   Constrained clients MUST implement session resumption\
    \ to improve the\n   performance of the handshake.  This will lead to a reduced\
    \ number of\n   message exchanges, lower computational overhead (since only symmetric\n\
    \   cryptography is used during a session resumption exchange), and\n   session\
    \ resumption requires less bandwidth.\n   For cases where the server is constrained\
    \ (but not the client), the\n   client MUST implement RFC 5077 [RFC5077].  Note\
    \ that the constrained\n   server refers to a device that has limitations in terms\
    \ of RAM and\n   flash memory, which place restrictions on the amount of TLS/DTLS\n\
    \   security state information that can be stored on such a device.  RFC\n   5077\
    \ specifies a version of TLS/DTLS session resumption that does not\n   require\
    \ per-session state information to be maintained by the\n   constrained server.\
    \  This is accomplished by using a ticket-based\n   approach.\n   If both the\
    \ client and the server are constrained devices, both\n   devices SHOULD implement\
    \ RFC 5077 and MUST implement basic session\n   resumption.  Clients that do not\
    \ want to use session resumption are\n   always able to send a ClientHello message\
    \ with an empty session_id to\n   revert to a full handshake.\n"
- title: 8.  Compression
  contents:
  - "8.  Compression\n   Section 3.3 of [RFC7525] recommends disabling TLS-/DTLS-level\n\
    \   compression due to attacks, such as CRIME [CRIME].  For IoT\n   applications,\
    \ compression at the TLS/DTLS layer is not needed since\n   application-layer\
    \ protocols are highly optimized, and the compression\n   algorithms at the DTLS\
    \ layer increases code size and complexity.\n   TLS/DTLS layer compression is\
    \ NOT RECOMMENDED by this TLS/DTLS\n   profile.\n"
- title: 9.  Perfect Forward Secrecy
  contents:
  - "9.  Perfect Forward Secrecy\n   PFS is a property that preserves the confidentiality\
    \ of past protocol\n   interactions even in situations where the long-term secret\
    \ is\n   compromised.\n   The PSK ciphersuite recommended in Section 4.2 does\
    \ not offer this\n   property since it does not utilize a DH exchange.  New ciphersuites\n\
    \   that support PFS for PSK-based authentication, such as proposed in\n   [PSK-AES-CCM-TLS],\
    \ might become available as a standardized\n   ciphersuite in the (near) future.\
    \  The recommended PSK-based\n   ciphersuite offers excellent performance, a very\
    \ small memory\n   footprint, and has the lowest on the wire overhead at the expense\
    \ of\n   not using any public cryptography.  For deployments where public key\n\
    \   cryptography is acceptable, the use of raw public keys might offer a\n   middle\
    \ ground between the PSK ciphersuite in terms of out-of-band\n   validation and\
    \ the functionality offered by asymmetric cryptography.\n   Physical attacks create\
    \ additional opportunities to gain access to\n   the crypto material stored on\
    \ IoT devices.  A PFS ciphersuite\n   prevents an attacker from obtaining the\
    \ communication content\n   exchanged prior to a successful long-term key compromise;\
    \ however, an\n   implementation that (for performance or energy efficiency reasons)\n\
    \   has been reusing the same ephemeral DH keys over multiple different\n   sessions\
    \ partially defeats PFS, thus increasing the damage extent.\n   For this reason,\
    \ implementations SHOULD NOT reuse ephemeral DH keys\n   over multiple protocol\
    \ exchanges.\n   The impact of the disclosure of past communication interactions\
    \ and\n   the desire to increase the cost for pervasive monitoring (as demanded\n\
    \   by [RFC7258]) has to be taken into account when selecting a\n   ciphersuite\
    \ that does not support the PFS property.\n   Client implementations claiming\
    \ support of this profile MUST\n   implement the ciphersuites listed in Section\
    \ 4 according to the\n   selected credential type.\n"
- title: 10.  Keep-Alive
  contents:
  - "10.  Keep-Alive\n   Application-layer communication may create state at the endpoints,\n\
    \   and this state may expire at some time.  For this reason,\n   applications\
    \ define ways to refresh state, if necessary.  While the\n   application-layer\
    \ exchanges are largely outside the scope of the\n   underlying TLS/DTLS exchange,\
    \ similar state considerations also play\n   a role at the level of TLS/DTLS.\
    \  While TLS/DTLS also creates state\n   in the form of a security context (see\
    \ the security parameter\n   described in Appendix A.6 in RFC 5246) at the client\
    \ and the server,\n   this state information does not expire.  However, network\n\
    \   intermediaries may also allocate state and require this state to be\n   kept\
    \ alive.  Failure to keep state alive at a stateful packet\n   filtering firewall\
    \ or at a NAT may result in the inability for one\n   node to reach the other\
    \ since packets will get blocked by these\n   middleboxes.  Periodic keep-alive\
    \ messages exchanged between the TLS/\n   DTLS client and server keep state at\
    \ these middleboxes alive.\n   According to measurements described in [HomeGateway],\
    \ there is some\n   variance in state management practices used in residential\
    \ gateways,\n   but the timeouts are heavily impacted by the choice of the transport-\n\
    \   layer protocol: timeouts for UDP are typically much shorter than\n   those\
    \ for TCP.\n   RFC 6520 [RFC6520] defines a heartbeat mechanism to test whether\
    \ the\n   other peer is still alive.  As an additional feature, the same\n   mechanism\
    \ can also be used to perform Path Maximum Transmission Unit\n   (MTU) Discovery.\n\
    \   A recommendation about the use of RFC 6520 depends on the type of\n   message\
    \ exchange an IoT device performs and the number of messages\n   the application\
    \ needs to exchange as part of their application\n   functionality.  There are\
    \ three types of exchanges that need to be\n   analyzed:\n   Client-Initiated,\
    \ One-Shot Messages\n      This is a common communication pattern where IoT devices\
    \ upload\n      data to a server on the Internet on an irregular basis.  The\n\
    \      communication may be triggered by specific events, such as opening\n  \
    \    a door.\n      The DTLS handshake may need to be restarted (ideally using\
    \ session\n      resumption, if possible) in case of an IP address change.\n \
    \     In this case, there is no use for a keep-alive extension for this\n    \
    \  scenario.\n   Client-Initiated, Regular Data Uploads\n      This is a variation\
    \ of the previous case whereby data gets\n      uploaded on a regular basis, for\
    \ example, based on frequent\n      temperature readings.  If neither NAT bindings\
    \ nor IP address\n      changes occurred, then the record layer will not notice\
    \ any\n      changes.  For the case where the IP address and port number\n   \
    \   changes, it is necessary to recreate the record layer using\n      session\
    \ resumption.\n      In this scenario, there is no use for a keep-alive extension.\
    \  It\n      is also very likely that the device will enter a sleep cycle in\n\
    \      between data transmissions to keep power consumption low.\n   Server-Initiated\
    \ Messages\n      In the two previous scenarios, the client initiates the protocol\n\
    \      interaction and maintains it.  Since messages to the client may\n     \
    \ get blocked by middleboxes, the initial connection setup is\n      triggered\
    \ by the client and then kept alive by the server.\n      For this message exchange\
    \ pattern, the use of DTLS heartbeat\n      messages is quite useful but may have\
    \ to be coordinated with\n      application exchanges (for example, when the CoAP\
    \ resource\n      directory is used) to avoid redundant keep-alive message\n \
    \     exchanges.  The MTU discovery mechanism, which is also part of\n      [RFC6520],\
    \ is less likely to be relevant since for many IoT\n      deployments, the most\
    \ constrained link is the wireless interface\n      between the IoT device and\
    \ the network itself (rather than some\n      links along the end-to-end path).\
    \  Only in more complex network\n      topologies, such as multi-hop mesh networks,\
    \ path MTU discovery\n      might be appropriate.  It also has to be noted that\
    \ DTLS itself\n      already provides a basic path discovery mechanism (see\n\
    \      Section 4.1.1.1 of RFC 6347) by using the fragmentation capability\n  \
    \    of the handshake protocol.\n   For server-initiated messages, the heartbeat\
    \ extension is\n   RECOMMENDED.\n"
- title: 11.  Timeouts
  contents:
  - "11.  Timeouts\n   A variety of wired and wireless technologies are available\
    \ to connect\n   devices to the Internet.  Many of the low-power radio technologies,\n\
    \   such as IEEE 802.15.4 or Bluetooth Smart, only support small frame\n   sizes\
    \ (e.g., 127 bytes in case of IEEE 802.15.4 as explained in\n   [RFC4919]).  Other\
    \ radio technologies, such as the Global System for\n   Mobile Communications\
    \ (GSM) using the short messaging service (SMS),\n   have similar constraints\
    \ in terms of payload sizes, such as 140 bytes\n   without the optional segmentation\
    \ and reassembly scheme known as\n   \"Concatenated SMS\", but show higher latency.\n\
    \   The DTLS handshake protocol adds a fragmentation and reassembly\n   mechanism\
    \ to the TLS handshake protocol since each DTLS record must\n   fit within a single\
    \ transport layer datagram, as described in\n   Section 4.2.3 of [RFC6347].  Since\
    \ handshake messages are potentially\n   bigger than the maximum record size,\
    \ the mechanism fragments a\n   handshake message over a number of DTLS records,\
    \ each of which can be\n   transmitted separately.\n   To deal with the unreliable\
    \ message delivery provided by UDP, DTLS\n   adds timeouts and \"per-flight\"\
    \ retransmissions, as described in\n   Section 4.2.4 of [RFC6347].  Although the\
    \ timeout values are\n   implementation specific, recommendations are provided\
    \ in\n   Section 4.2.4.1 of [RFC6347], with an initial timer value of 1 second\n\
    \   and double the value at each retransmission, up to no less than 60\n   seconds.\n\
    \   TLS protocol steps can take longer due to higher processing time on\n   the\
    \ constrained side.  On the other hand, the way DTLS handles\n   retransmission,\
    \ which is per-flight instead of per-segment, tends to\n   interact poorly with\
    \ low-bandwidth networks.\n   For these reasons, it's essential that the probability\
    \ of a spurious\n   retransmit is minimized and, on timeout, the sending endpoint\
    \ does\n   not react too aggressively.  The latter is particularly relevant when\n\
    \   the Wireless Sensor Network (WSN) is temporarily congested: if lost\n   packets\
    \ are reinjected too quickly, congestion worsens.\n   An initial timer value of\
    \ 9 seconds with exponential back off up to\n   no less then 60 seconds is therefore\
    \ RECOMMENDED.\n   This value is chosen big enough to absorb large latency variance\
    \ due\n   to either slow computation on constrained endpoints or intrinsic\n \
    \  network characteristics (e.g., GSM-SMS), as well as to produce a low\n   number\
    \ of retransmission events and relax the pacing between them.\n   Its worst case\
    \ wait time is the same as using 1s timeout (i.e., 63s),\n   while triggering\
    \ less than half of the retransmissions (2 instead of\n   5).\n   In order to\
    \ minimize the wake time during DTLS handshake, sleepy\n   nodes might decide\
    \ to select a lower threshold and, consequently, a\n   smaller initial timeout\
    \ value.  If this is the case, the\n   implementation MUST keep into account the\
    \ considerations about\n   network stability described in this section.\n"
- title: 12.  Random Number Generation
  contents:
  - "12.  Random Number Generation\n   The TLS/DTLS protocol requires random numbers\
    \ to be available during\n   the protocol run.  For example, during the ClientHello\
    \ and the\n   ServerHello exchange, the client and the server exchange random\n\
    \   numbers.  Also, the use of the DH exchange requires random numbers\n   during\
    \ the key pair generation.\n   It is important to note that sources contributing\
    \ to the randomness\n   pool on laptops or desktop PCs are not available on many\
    \ IoT devices,\n   such as mouse movement, timing of keystrokes, air turbulence\
    \ on the\n   movement of hard drive heads, etc.  Other sources have to be found\
    \ or\n   dedicated hardware has to be added.\n   Lacking sources of randomness\
    \ in an embedded system may lead to the\n   same keys generated again and again.\n\
    \   The ClientHello and the ServerHello messages contain the \"Random\"\n   structure,\
    \ which has two components: gmt_unix_time and a sequence of\n   28 random bytes.\
    \ gmt_unix_time holds the current time and date in\n   standard UNIX 32-bit format\
    \ (seconds since the midnight starting Jan\n   1, 1970, GMT).  Since many IoT\
    \ devices do not have access to an\n   accurate clock, it is RECOMMENDED that\
    \ the receiver of a ClientHello\n   or ServerHello does not assume that the value\
    \ in\n   \"Random.gmt_unix_time\" is an accurate representation of the current\n\
    \   time and instead treats it as an opaque random string.\n   When TLS is used\
    \ with certificate-based authentication, the\n   availability of time information\
    \ is needed to check the validity of a\n   certificate.  Higher-layer protocols\
    \ may provide secure time\n   information.  The gmt_unix_time component of the\
    \ ServerHello is not\n   used for this purpose.\n   IoT devices using TLS/DTLS\
    \ must offer ways to generate quality random\n   numbers.  There are various implementation\
    \ choices for integrating a\n   hardware-based random number generator into a\
    \ product: an\n   implementation inside the microcontroller itself is one option,\
    \ but\n   dedicated crypto chips are also reasonable choices.  The best choice\n\
    \   will depend on various factors outside the scope of this document.\n   Guidelines\
    \ and requirements for random number generation can be found\n   in RFC 4086 [RFC4086]\
    \ and in the NIST Special Publication 800-90a\n   [SP800-90A].\n   Chip manufacturers\
    \ are highly encouraged to provide sufficient\n   documentation of their design\
    \ for random number generators so that\n   customers can have confidence about\
    \ the quality of the generated\n   random numbers.  The confidence can be increased\
    \ by providing\n   information about the procedures that have been used to verify\
    \ the\n   randomness of numbers generated by the hardware modules.  For\n   example,\
    \ NIST Special Publication 800-22b [SP800-22b] describes\n   statistical tests\
    \ that can be used to verify random number\n   generators.\n"
- title: 13.  Truncated MAC and Encrypt-then-MAC Extension
  contents:
  - "13.  Truncated MAC and Encrypt-then-MAC Extension\n   The truncated MAC extension\
    \ was introduced in RFC 6066 [RFC6066] with\n   the goal to reduce the size of\
    \ the MAC used at the record layer.\n   This extension was developed for TLS ciphersuites\
    \ that used older\n   modes of operation where the MAC and the encryption operation\
    \ were\n   performed independently.\n   The recommended ciphersuites in this document\
    \ use the newer AEAD\n   construct, namely the CCM mode with 8-octet authentication\
    \ tags, and\n   are therefore not applicable to the truncated MAC extension.\n\
    \   RFC 7366 [RFC7366] introduced the encrypt-then-MAC extension (instead\n  \
    \ of the previously used MAC-then-encrypt) since the MAC-then-encrypt\n   mechanism\
    \ has been the subject of a number of security\n   vulnerabilities.  RFC 7366\
    \ is, however, also not applicable to the\n   AEAD ciphers recommended in this\
    \ document.\n   Implementations conformant to this specification MUST use AEAD\n\
    \   ciphers.  RFC 7366 (\"encrypt-then-MAC\") and RFC 6066 (\"truncated MAC\n\
    \   extension\") are not applicable to this specification and MUST NOT be\n  \
    \ used.\n"
- title: 14.  Server Name Indication (SNI)
  contents:
  - "14.  Server Name Indication (SNI)\n   The SNI extension [RFC6066] defines a mechanism\
    \ for a client to tell\n   a TLS/DTLS server the name of the server it wants to\
    \ contact.  This\n   is a useful extension for many hosting environments where\
    \ multiple\n   virtual servers are run on a single IP address.\n   Implementing\
    \ the Server Name Indication extension is REQUIRED unless\n   it is known that\
    \ a TLS/DTLS client does not interact with a server in\n   a hosting environment.\n"
- title: 15.  Maximum Fragment Length Negotiation
  contents:
  - "15.  Maximum Fragment Length Negotiation\n   This RFC 6066 extension lowers the\
    \ maximum fragment length support\n   needed for the record layer from 2^14 bytes\
    \ to 2^9 bytes.\n   This is a very useful extension that allows the client to\
    \ indicate to\n   the server how much maximum memory buffers it uses for incoming\n\
    \   messages.  Ultimately, the main benefit of this extension is to allow\n  \
    \ client implementations to lower their RAM requirements since the\n   client\
    \ does not need to accept packets of large size (such as 16K\n   packets as required\
    \ by plain TLS/DTLS).\n   Client implementations MUST support this extension.\n"
- title: 16.  Session Hash
  contents:
  - "16.  Session Hash\n   In order to begin connection protection, the Record Protocol\
    \ requires\n   specification of a suite of algorithms, a master secret, and the\n\
    \   client and server random values.  The algorithm for computing the\n   master\
    \ secret is defined in Section 8.1 of RFC 5246, but it only\n   includes a small\
    \ number of parameters exchanged during the handshake\n   and does not include\
    \ parameters like the client and server\n   identities.  This can be utilized\
    \ by an attacker to mount a\n   man-in-the-middle attack since the master secret\
    \ is not guaranteed to\n   be unique across sessions, as discovered in the \"\
    triple handshake\"\n   attack [Triple-HS].\n   [RFC7627] defines a TLS extension\
    \ that binds the master secret to a\n   log of the full handshake that computes\
    \ it, thus preventing such\n   attacks.\n   Client implementations SHOULD implement\
    \ this extension even though\n   the ciphersuites recommended by this profile\
    \ are not vulnerable to\n   this attack.  For DH-based ciphersuites, the keying\
    \ material is\n   contributed by both parties and in case of the pre-shared secret\
    \ key\n   ciphersuite, both parties need to be in possession of the shared\n \
    \  secret to ensure that the handshake completes successfully.  It is,\n   however,\
    \ possible that some application-layer protocols will tunnel\n   other authentication\
    \ protocols on top of DTLS making this attack\n   relevant again.\n"
- title: 17.  Renegotiation Attacks
  contents:
  - "17.  Renegotiation Attacks\n   TLS/DTLS allows a client and a server that already\
    \ have a TLS/DTLS\n   connection to negotiate new parameters, generate new keys,\
    \ etc., by\n   using the renegotiation feature.  Renegotiation happens in the\n\
    \   existing connection, with the new handshake packets being encrypted\n   along\
    \ with application data.  Upon completion of the renegotiation\n   procedure,\
    \ the new channel replaces the old channel.\n   As described in RFC 5746 [RFC5746],\
    \ there is no cryptographic binding\n   between the two handshakes, although the\
    \ new handshake is carried out\n   using the cryptographic parameters established\
    \ by the original\n   handshake.\n   To prevent the renegotiation attack [RFC5746],\
    \ this specification\n   REQUIRES the TLS renegotiation feature to be disabled.\
    \  Clients MUST\n   respond to server-initiated renegotiation attempts with an\
    \ alert\n   message (no_renegotiation), and clients MUST NOT initiate them.\n"
- title: 18.  Downgrading Attacks
  contents:
  - "18.  Downgrading Attacks\n   When a client sends a ClientHello with a version\
    \ higher than the\n   highest version known to the server, the server is supposed\
    \ to reply\n   with ServerHello.version equal to the highest version known to\
    \ the\n   server, and then the handshake can proceed.  This behavior is known\n\
    \   as version tolerance.  Version intolerance is when the server (or a\n   middlebox)\
    \ breaks the handshake when it sees a ClientHello.version\n   higher than what\
    \ it knows about.  This is the behavior that leads\n   some clients to rerun the\
    \ handshake with a lower version.  As a\n   result, a potential security vulnerability\
    \ is introduced when a\n   system is running an old TLS/SSL version (e.g., because\
    \ of the need\n   to integrate with legacy systems).  In the worst case, this\
    \ allows an\n   attacker to downgrade the protocol handshake to SSL 3.0.  SSL\
    \ 3.0 is\n   so broken that there is no secure cipher available for it (see\n\
    \   [RFC7568]).\n   The above-described downgrade vulnerability is solved by the\
    \ TLS\n   Fallback Signaling Cipher Suite Value (SCSV) [RFC7507] extension.\n\
    \   However, the solution is not applicable to implementations conforming\n  \
    \ to this profile since the version negotiation MUST use TLS/DTLS\n   version\
    \ 1.2 (or higher).  More specifically, this implies:\n   o  Clients MUST NOT send\
    \ a TLS/DTLS version lower than version 1.2 in\n      the ClientHello.\n   o \
    \ Clients MUST NOT retry a failed negotiation offering a TLS/DTLS\n      version\
    \ lower than 1.2.\n   o  Servers MUST fail the handshake by sending a protocol_version\n\
    \      fatal alert if a TLS/DTLS version >= 1.2 cannot be negotiated.\n      Note\
    \ that the aborted connection is non-resumable.\n"
- title: 19.  Crypto Agility
  contents:
  - "19.  Crypto Agility\n   This document recommends that software and chip manufacturers\n\
    \   implement AES and the CCM mode of operation.  This document\n   references\
    \ the CoAP-recommended ciphersuite choices, which have been\n   selected based\
    \ on implementation and deployment experience from the\n   IoT community.  Over\
    \ time, the preference for algorithms will,\n   however, change.  Not all components\
    \ of a ciphersuite are likely to\n   change at the same speed.  Changes are more\
    \ likely expected for\n   ciphers, the mode of operation, and the hash algorithms.\
    \  The\n   recommended key lengths have to be adjusted over time as well.  Some\n\
    \   deployment environments will also be impacted by local regulation,\n   which\
    \ might dictate a certain algorithm and key size combination.\n   Ongoing discussions\
    \ regarding the choice of specific ECC curves will\n   also likely impact implementations.\
    \  Note that this document does not\n   recommend or mandate a specific ECC curve.\n\
    \   The following recommendations can be made to chip manufacturers:\n   o  Make\
    \ any AES hardware-based crypto implementation accessible to\n      developers\
    \ working on security implementations at higher layers in\n      the protocol\
    \ stack.  Sometimes hardware implementations are added\n      to microcontrollers\
    \ to offer support for functionality needed at\n      the link layer and are only\
    \ available to the on-chip link-layer\n      protocol implementation.  Such a\
    \ setup does not allow application\n      developers to reuse the hardware-based\
    \ AES implementation.\n   o  Provide flexibility for the use of the crypto function\
    \ with future\n      extensibility in mind.  For example, making an AES-CCM\n\
    \      implementation available to developers is a first step but such an\n  \
    \    implementation may not be usable due to parameter differences\n      between\
    \ an AES-CCM implementation.  AES-CCM in IEEE 802.15.4 and\n      Bluetooth Smart\
    \ use a nonce length of 13 octets while DTLS uses a\n      nonce length of 12\
    \ octets.  Hardware implementations of AES-CCM\n      for IEEE 802.15.4 and Bluetooth\
    \ Smart are therefore not reusable\n      by a DTLS stack.\n   o  Offer access\
    \ to building blocks in addition (or as an alternative)\n      to the complete\
    \ functionality.  For example, a chip manufacturer\n      who gives developers\
    \ access to the AES crypto function can use it\n      to build an efficient AES-GCM\
    \ implementation.  Another example is\n      to make a special instruction available\
    \ that increases the speed\n      of speed-up carryless multiplications.\n   As\
    \ a recommendation for developers and product architects, we suggest\n   that\
    \ sufficient headroom is provided to allow an upgrade to a newer\n   cryptographic\
    \ algorithm over the lifetime of the product.  As an\n   example, while AES-CCM\
    \ is recommended throughout this specification,\n   future products might use\
    \ the ChaCha20 cipher in combination with the\n   Poly1305 authenticator [RFC7539].\
    \  The assumption is made that a\n   robust software update mechanism is offered.\n"
- title: 20.  Key Length Recommendations
  contents:
  - "20.  Key Length Recommendations\n   RFC 4492 [RFC4492] gives approximate comparable\
    \ key sizes for\n   symmetric- and asymmetric-key cryptosystems based on the best-known\n\
    \   algorithms for attacking them.  While other publications suggest\n   slightly\
    \ different numbers, such as [Keylength], the approximate\n   relationship still\
    \ holds true.  Figure 12 illustrates the comparable\n   key sizes in bits.\n \
    \                      Symmetric  |   ECC   |  DH/DSA/RSA\n                  \
    \    ------------+---------+-------------\n                           80     |\
    \   163   |     1024\n                          112     |   233   |     2048\n\
    \                          128     |   283   |     3072\n                    \
    \      192     |   409   |     7680\n                          256     |   571\
    \   |    15360\n        Figure 12: Comparable Key Sizes (in Bits) Based on RFC\
    \ 4492\n   At the time of writing, the key size recommendations for use with\n\
    \   TLS-based ciphers found in [RFC7525] recommend DH key lengths of at\n   least\
    \ 2048 bits, which corresponds to a 112-bit symmetric key and a\n   233-bit ECC\
    \ key.  These recommendations are roughly in line with\n   those from other organizations,\
    \ such as the National Institute of\n   Standards and Technology (NIST) or the\
    \ European Network and\n   Information Security Agency (ENISA).  The authors of\n\
    \   [ENISA-Report2013] add that a 80-bit symmetric key is sufficient for\n   legacy\
    \ applications for the coming years, but a 128-bit symmetric key\n   is the minimum\
    \ requirement for new systems being deployed.  The\n   authors further note that\
    \ one needs to also take into account the\n   length of time data needs to be\
    \ kept secure for.  The use of 80-bit\n   symmetric keys for transactional data\
    \ may be acceptable for the near\n   future while one has to insist on 128-bit\
    \ symmetric keys for long-\n   lived data.\n   Note that the recommendations for\
    \ 112-bit symmetric keys are chosen\n   conservatively under the assumption that\
    \ IoT devices have a long\n   expected lifetime (such as 10+ years) and that this\
    \ key length\n   recommendation refers to the long-term keys used for device\n\
    \   authentication.  Keys, which are provisioned dynamically, for the\n   protection\
    \ of transactional data (such as ephemeral DH keys used in\n   various TLS/DTLS\
    \ ciphersuites) may be shorter considering the\n   sensitivity of the exchanged\
    \ data.\n"
- title: 21.  False Start
  contents:
  - "21.  False Start\n   A full TLS handshake as specified in [RFC5246] requires\
    \ two full\n   protocol rounds (four flights) before the handshake is complete\
    \ and\n   the protocol parties may begin to send application data.\n   An abbreviated\
    \ handshake (resuming an earlier TLS session) is\n   complete after three flights,\
    \ thus adding just one round-trip time if\n   the client sends application data\
    \ first.\n   If the conditions outlined in [TLS-FALSESTART] are met, application\n\
    \   data can be transmitted when the sender has sent its own\n   \"ChangeCipherSpec\"\
    \ and \"Finished\" messages.  This achieves an\n   improvement of one round-trip\
    \ time for full handshakes if the client\n   sends application data first and\
    \ for abbreviated handshakes if the\n   server sends application data first.\n\
    \   The conditions for using the TLS False Start mechanism are met by the\n  \
    \ public-key-based ciphersuites in this document.  In summary, the\n   conditions\
    \ are:\n   o  Modern symmetric ciphers with an effective key length of 128 bits,\n\
    \      such as AES-128-CCM\n   o  Client certificate types, such as ecdsa_sign\n\
    \   o  Key exchange methods, such as ECDHE_ECDSA\n   Based on the improvement\
    \ over a full round-trip for the full TLS/DTLS\n   exchange, this specification\
    \ RECOMMENDS the use of the False Start\n   mechanism when clients send application\
    \ data first.\n"
- title: 22.  Privacy Considerations
  contents:
  - "22.  Privacy Considerations\n   The DTLS handshake exchange conveys various identifiers,\
    \ which can be\n   observed by an on-path eavesdropper.  For example, the DTLS\
    \ PSK\n   exchange reveals the PSK identity, the supported extensions, the\n \
    \  session ID, algorithm parameters, etc.  When session resumption is\n   used,\
    \ then individual TLS sessions can be correlated by an on-path\n   adversary.\
    \  With many IoT deployments, it is likely that keying\n   material and their\
    \ identifiers are persistent over a longer period of\n   time due to the cost\
    \ of updating software on these devices.\n   User participation poses a challenge\
    \ in many IoT deployments since\n   many of the IoT devices operate unattended,\
    \ even though they are\n   initially provisioned by a human.  The ability to control\
    \ data\n   sharing and to configure preferences will have to be provided at a\n\
    \   system level rather than at the level of the DTLS exchange itself,\n   which\
    \ is the scope of this document.  Quite naturally, the use of\n   DTLS with mutual\
    \ authentication will allow a TLS server to collect\n   authentication information\
    \ about the IoT device (likely over a long\n   period of time).  While this strong\
    \ form of authentication will\n   prevent misattribution, it also allows strong\
    \ identification.\n   Device-related data collection (e.g., sensor recordings)\
    \ associated\n   with other data types will prove to be truly useful, but this\
    \ extra\n   data might include personal information about the owner of the device\n\
    \   or data about the environment it senses.  Consequently, the data\n   stored\
    \ on the server side will be vulnerable to stored data\n   compromise.  For the\
    \ communication between the client and the server,\n   this specification prevents\
    \ eavesdroppers from gaining access to the\n   communication content.  While the\
    \ PSK-based ciphersuite does not\n   provide PFS, the asymmetric versions do.\
    \  This prevents an adversary\n   from obtaining past communication content when\
    \ access to a long-term\n   secret has been gained.  Note that no extra effort\
    \ to make traffic\n   analysis more difficult is provided by the recommendations\
    \ made in\n   this document.\n   Note that the absence or presence of communication\
    \ itself might\n   reveal information to an adversary.  For example, a presence\
    \ sensor\n   may initiate messaging when a person enters a building.  While TLS/\n\
    \   DTLS would offer confidentiality protection of the transmitted\n   information,\
    \ it does not help to conceal all communication patterns.\n   Furthermore, the\
    \ IP header, which is not protected by TLS/DTLS,\n   additionally reveals information\
    \ about the other communication\n   endpoint.  For applications where such privacy\
    \ concerns exist,\n   additional safeguards are required, such as injecting dummy\
    \ traffic\n   and onion routing.  A detailed treatment of such solutions is outside\n\
    \   the scope of this document and requires a system-level view.\n"
- title: 23.  Security Considerations
  contents:
  - "23.  Security Considerations\n   This entire document is about security.\n  \
    \ We would also like to point out that designing a software update\n   mechanism\
    \ into an IoT system is crucial to ensure that both\n   functionality can be enhanced\
    \ and that potential vulnerabilities can\n   be fixed.  This software update mechanism\
    \ is important for changing\n   configuration information, for example, trust\
    \ anchors and other\n   keying-related information.  Such a suitable software\
    \ update\n   mechanism is available with the LWM2M protocol published by the OMA\n\
    \   [LWM2M].\n"
- title: 24.  References
  contents:
  - '24.  References

    '
- title: 24.1.  Normative References
  contents:
  - "24.1.  Normative References\n   [EUI64]    IEEE, \"Guidelines for 64-bit Global\
    \ Identifier (EUI-64)\",\n              Registration Authority,\n            \
    \  <https://standards.ieee.org/regauth/\n              oui/tutorials/EUI64.html>.\n\
    \   [GSM-SMS]  ETSI, \"3rd Generation Partnership Project; Technical\n       \
    \       Specification Group Core Network and Terminals; Technical\n          \
    \    realization of the Short Message Service (SMS) (Release\n              13)\"\
    , 3GPP TS 23.040 V13.1.0, March 2016.\n   [RFC2119]  Bradner, S., \"Key words\
    \ for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC\
    \ 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC4279]  Eronen, P., Ed. and H. Tschofenig, Ed., \"Pre-Shared Key\n    \
    \          Ciphersuites for Transport Layer Security (TLS)\",\n              RFC\
    \ 4279, DOI 10.17487/RFC4279, December 2005,\n              <http://www.rfc-editor.org/info/rfc4279>.\n\
    \   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n  \
    \            (TLS) Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246,\
    \ August 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5746]\
    \  Rescorla, E., Ray, M., Dispensa, S., and N. Oskov,\n              \"Transport\
    \ Layer Security (TLS) Renegotiation Indication\n              Extension\", RFC\
    \ 5746, DOI 10.17487/RFC5746, February 2010,\n              <http://www.rfc-editor.org/info/rfc5746>.\n\
    \   [RFC6066]  Eastlake 3rd, D., \"Transport Layer Security (TLS)\n          \
    \    Extensions: Extension Definitions\", RFC 6066,\n              DOI 10.17487/RFC6066,\
    \ January 2011,\n              <http://www.rfc-editor.org/info/rfc6066>.\n   [RFC6125]\
    \  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification\
    \ of Domain-Based Application Service Identity\n              within Internet\
    \ Public Key Infrastructure Using X.509\n              (PKIX) Certificates in\
    \ the Context of Transport Layer\n              Security (TLS)\", RFC 6125, DOI\
    \ 10.17487/RFC6125, March\n              2011, <http://www.rfc-editor.org/info/rfc6125>.\n\
    \   [RFC6347]  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n    \
    \          Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n         \
    \     January 2012, <http://www.rfc-editor.org/info/rfc6347>.\n   [RFC6520]  Seggelmann,\
    \ R., Tuexen, M., and M. Williams, \"Transport\n              Layer Security (TLS)\
    \ and Datagram Transport Layer Security\n              (DTLS) Heartbeat Extension\"\
    , RFC 6520,\n              DOI 10.17487/RFC6520, February 2012,\n            \
    \  <http://www.rfc-editor.org/info/rfc6520>.\n   [RFC7250]  Wouters, P., Ed.,\
    \ Tschofenig, H., Ed., Gilmore, J.,\n              Weiler, S., and T. Kivinen,\
    \ \"Using Raw Public Keys in\n              Transport Layer Security (TLS) and\
    \ Datagram Transport\n              Layer Security (DTLS)\", RFC 7250, DOI 10.17487/RFC7250,\n\
    \              June 2014, <http://www.rfc-editor.org/info/rfc7250>.\n   [RFC7251]\
    \  McGrew, D., Bailey, D., Campagna, M., and R. Dugal, \"AES-\n              CCM\
    \ Elliptic Curve Cryptography (ECC) Cipher Suites for\n              TLS\", RFC\
    \ 7251, DOI 10.17487/RFC7251, June 2014,\n              <http://www.rfc-editor.org/info/rfc7251>.\n\
    \   [RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,\n       \
    \       Langley, A., and M. Ray, \"Transport Layer Security (TLS)\n          \
    \    Session Hash and Extended Master Secret Extension\",\n              RFC 7627,\
    \ DOI 10.17487/RFC7627, September 2015,\n              <http://www.rfc-editor.org/info/rfc7627>.\n\
    \   [RFC7924]  Santesson, S. and H. Tschofenig, \"Transport Layer Security\n \
    \             (TLS) Cached Information Extension\", RFC 7924,\n              DOI\
    \ 10.17487/RFC7924, July 2016,\n              <http://www.rfc-editor.org/info/rfc7924>.\n\
    \   [WAP-WDP]  Open Mobile Alliance, \"Wireless Datagram Protocol\",\n       \
    \       Wireless Application Protocol, WAP-259-WDP, June 2001.\n"
- title: 24.2.  Informative References
  contents:
  - "24.2.  Informative References\n   [ACE-WG]   IETF, \"Authentication and Authorization\
    \ for Constrained\n              Environments (ACE) Working Group\",\n       \
    \       <https://datatracker.ietf.org/wg/ace/charter>.\n   [AES]      National\
    \ Institute of Standards and Technology, \"Advanced\n              Encryption\
    \ Standard (AES)\", NIST FIPS PUB 197, November\n              2001, <http://csrc.nist.gov/publications/fips/fips197/\n\
    \              fips-197.pdf>.\n   [CCM]      National Institute of Standards and\
    \ Technology,\n              \"Recommendation for Block Cipher Modes of Operation:\
    \ The\n              CCM Mode for Authentication and Confidentiality\", NIST\n\
    \              Special Publication 800-38C, May 2004,\n              <http://csrc.nist.gov/publications/nistpubs/800-38C/\n\
    \              SP800-38C_updated-July20_2007.pdf>.\n   [COAP-TCP-TLS]\n      \
    \        Bormann, C., Lemay, S., Tschofenig, H., Hartke, K.,\n              Silverajan,\
    \ B., and B. Raymor, \"CoAP (Constrained\n              Application Protocol)\
    \ over TCP, TLS, and WebSockets\", Work\n              in Progress, draft-ietf-core-coap-tcp-tls-03,\
    \ July 2016.\n   [CoRE-RD]  Shelby, Z., Koster, M., Bormann, C., and P. Stok,\
    \ \"CoRE\n              Resource Directory\", Work in Progress, draft-ietf-core-\n\
    \              resource-directory-08, July 2016.\n   [CRIME]    Wikipedia, \"\
    CRIME\", May 2016, <https://en.wikipedia.org/w/\n              index.php?title=CRIME&oldid=721665716>.\n\
    \   [ENISA-Report2013]\n              ENISA, \"Algorithms, Key Sizes and Parameters\
    \ Report -\n              2013\", October 2013, <https://www.enisa.europa.eu/\n\
    \              activities/identity-and-trust/library/deliverables/\n         \
    \     algorithms-key-sizes-and-parameters-report>.\n   [FFDHE-TLS]\n         \
    \     Gillmor, D., \"Negotiated Finite Field Diffie-Hellman\n              Ephemeral\
    \ Parameters for TLS\", Work in Progress,\n              draft-ietf-tls-negotiated-ff-dhe-10,\
    \ June 2015.\n   [HomeGateway]\n              Eggert, L., Hatoen, S., Kojo, M.,\
    \ Nyrhinen, A., Sarolahti,\n              P., and S. Strowes, \"An Experimental\
    \ Study of Home Gateway\n              Characteristics\", In Proceedings of the\
    \ 10th ACM SIGCOMM\n              conference on Internet measurement,\n      \
    \        DOI 10.1145/1879141.1879174, 2010,\n              <http://conferences.sigcomm.org/imc/2010/papers/p260.pdf>.\n\
    \   [IANA-TLS] IANA, \"Transport Layer Security (TLS) Parameters\",\n        \
    \      <https://www.iana.org/assignments/tls-parameters>.\n   [ImprintingSurvey]\n\
    \              Chilton, E., \"A Brief Survey of Imprinting Options for\n     \
    \         Constrained Devices\", March 2012,\n              <http://www.lix.polytechnique.fr/hipercom/\n\
    \              SmartObjectSecurity/papers/EricRescorla.pdf>.\n   [Keylength]\n\
    \              Giry, D., \"Cryptographic Key Length Recommendations\",\n     \
    \         September 2015, <http://www.keylength.com>.\n   [LWM2M]    Open Mobile\
    \ Alliance, \"Lightweight Machine-to-Machine\n              Requirements\", Candidate\
    \ Version 1.0, OMA-RD-\n              LightweightM2M-V1_0-20131210-C, December\
    \ 2013,\n              <http://openmobilealliance.org/about-oma/work-program/\n\
    \              m2m-enablers>.\n   [PSK-AES-CCM-TLS]\n              Schmertmann,\
    \ L. and C. Bormann, \"ECDHE-PSK AES-CCM Cipher\n              Suites with Forward\
    \ Secrecy for Transport Layer Security\n              (TLS)\", Work in Progress,\
    \ draft-schmertmann-dice-ccm-\n              psk-pfs-01, August 2014.\n   [RFC1981]\
    \  McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery\n             \
    \ for IP version 6\", RFC 1981, DOI 10.17487/RFC1981, August\n              1996,\
    \ <http://www.rfc-editor.org/info/rfc1981>.\n   [RFC2104]  Krawczyk, H., Bellare,\
    \ M., and R. Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104,\n              DOI 10.17487/RFC2104, February 1997,\n            \
    \  <http://www.rfc-editor.org/info/rfc2104>.\n   [RFC2865]  Rigney, C., Willens,\
    \ S., Rubens, A., and W. Simpson,\n              \"Remote Authentication Dial\
    \ In User Service (RADIUS)\",\n              RFC 2865, DOI 10.17487/RFC2865, June\
    \ 2000,\n              <http://www.rfc-editor.org/info/rfc2865>.\n   [RFC3610]\
    \  Whiting, D., Housley, R., and N. Ferguson, \"Counter with\n              CBC-MAC\
    \ (CCM)\", RFC 3610, DOI 10.17487/RFC3610, September\n              2003, <http://www.rfc-editor.org/info/rfc3610>.\n\
    \   [RFC3748]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.\n   \
    \           Levkowetz, Ed., \"Extensible Authentication Protocol\n           \
    \   (EAP)\", RFC 3748, DOI 10.17487/RFC3748, June 2004,\n              <http://www.rfc-editor.org/info/rfc3748>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.\n  \
    \            Moeller, \"Elliptic Curve Cryptography (ECC) Cipher Suites\n    \
    \          for Transport Layer Security (TLS)\", RFC 4492,\n              DOI\
    \ 10.17487/RFC4492, May 2006,\n              <http://www.rfc-editor.org/info/rfc4492>.\n\
    \   [RFC4821]  Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n   \
    \           Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007,\n       \
    \       <http://www.rfc-editor.org/info/rfc4821>.\n   [RFC4919]  Kushalnagar,\
    \ N., Montenegro, G., and C. Schumacher, \"IPv6\n              over Low-Power\
    \ Wireless Personal Area Networks (6LoWPANs):\n              Overview, Assumptions,\
    \ Problem Statement, and Goals\",\n              RFC 4919, DOI 10.17487/RFC4919,\
    \ August 2007,\n              <http://www.rfc-editor.org/info/rfc4919>.\n   [RFC5077]\
    \  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,\n              \"Transport\
    \ Layer Security (TLS) Session Resumption without\n              Server-Side State\"\
    , RFC 5077, DOI 10.17487/RFC5077,\n              January 2008, <http://www.rfc-editor.org/info/rfc5077>.\n\
    \   [RFC5116]  McGrew, D., \"An Interface and Algorithms for Authenticated\n \
    \             Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008,\n  \
    \            <http://www.rfc-editor.org/info/rfc5116>.\n   [RFC5216]  Simon, D.,\
    \ Aboba, B., and R. Hurst, \"The EAP-TLS\n              Authentication Protocol\"\
    , RFC 5216, DOI 10.17487/RFC5216,\n              March 2008, <http://www.rfc-editor.org/info/rfc5216>.\n\
    \   [RFC5247]  Aboba, B., Simon, D., and P. Eronen, \"Extensible\n           \
    \   Authentication Protocol (EAP) Key Management Framework\",\n              RFC\
    \ 5247, DOI 10.17487/RFC5247, August 2008,\n              <http://www.rfc-editor.org/info/rfc5247>.\n\
    \   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n         \
    \     Housley, R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure\
    \ Certificate and Certificate Revocation List\n              (CRL) Profile\",\
    \ RFC 5280, DOI 10.17487/RFC5280, May 2008,\n              <http://www.rfc-editor.org/info/rfc5280>.\n\
    \   [RFC5288]  Salowey, J., Choudhury, A., and D. McGrew, \"AES Galois\n     \
    \         Counter Mode (GCM) Cipher Suites for TLS\", RFC 5288,\n            \
    \  DOI 10.17487/RFC5288, August 2008,\n              <http://www.rfc-editor.org/info/rfc5288>.\n\
    \   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,\n   \
    \           \"Elliptic Curve Cryptography Subject Public Key\n              Information\"\
    , RFC 5480, DOI 10.17487/RFC5480, March 2009,\n              <http://www.rfc-editor.org/info/rfc5480>.\n\
    \   [RFC5758]  Dang, Q., Santesson, S., Moriarty, K., Brown, D., and T.\n    \
    \          Polk, \"Internet X.509 Public Key Infrastructure:\n              Additional\
    \ Algorithms and Identifiers for DSA and ECDSA\",\n              RFC 5758, DOI\
    \ 10.17487/RFC5758, January 2010,\n              <http://www.rfc-editor.org/info/rfc5758>.\n\
    \   [RFC5934]  Housley, R., Ashmore, S., and C. Wallace, \"Trust Anchor\n    \
    \          Management Protocol (TAMP)\", RFC 5934,\n              DOI 10.17487/RFC5934,\
    \ August 2010,\n              <http://www.rfc-editor.org/info/rfc5934>.\n   [RFC6024]\
    \  Reddy, R. and C. Wallace, \"Trust Anchor Management\n              Requirements\"\
    , RFC 6024, DOI 10.17487/RFC6024, October\n              2010, <http://www.rfc-editor.org/info/rfc6024>.\n\
    \   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic\n \
    \             Curve Cryptography Algorithms\", RFC 6090,\n              DOI 10.17487/RFC6090,\
    \ February 2011,\n              <http://www.rfc-editor.org/info/rfc6090>.\n  \
    \ [RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n   \
    \           (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n              DOI\
    \ 10.17487/RFC6234, May 2011,\n              <http://www.rfc-editor.org/info/rfc6234>.\n\
    \   [RFC6655]  McGrew, D. and D. Bailey, \"AES-CCM Cipher Suites for\n       \
    \       Transport Layer Security (TLS)\", RFC 6655,\n              DOI 10.17487/RFC6655,\
    \ July 2012,\n              <http://www.rfc-editor.org/info/rfc6655>.\n   [RFC6690]\
    \  Shelby, Z., \"Constrained RESTful Environments (CoRE) Link\n              Format\"\
    , RFC 6690, DOI 10.17487/RFC6690, August 2012,\n              <http://www.rfc-editor.org/info/rfc6690>.\n\
    \   [RFC6733]  Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn,\n     \
    \         Ed., \"Diameter Base Protocol\", RFC 6733,\n              DOI 10.17487/RFC6733,\
    \ October 2012,\n              <http://www.rfc-editor.org/info/rfc6733>.\n   [RFC6943]\
    \  Thaler, D., Ed., \"Issues in Identifier Comparison for\n              Security\
    \ Purposes\", RFC 6943, DOI 10.17487/RFC6943, May\n              2013, <http://www.rfc-editor.org/info/rfc6943>.\n\
    \   [RFC6961]  Pettersen, Y., \"The Transport Layer Security (TLS)\n         \
    \     Multiple Certificate Status Request Extension\", RFC 6961,\n           \
    \   DOI 10.17487/RFC6961, June 2013,\n              <http://www.rfc-editor.org/info/rfc6961>.\n\
    \   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n   \
    \           Constrained-Node Networks\", RFC 7228,\n              DOI 10.17487/RFC7228,\
    \ May 2014,\n              <http://www.rfc-editor.org/info/rfc7228>.\n   [RFC7252]\
    \  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n              Application\
    \ Protocol (CoAP)\", RFC 7252,\n              DOI 10.17487/RFC7252, June 2014,\n\
    \              <http://www.rfc-editor.org/info/rfc7252>.\n   [RFC7258]  Farrell,\
    \ S. and H. Tschofenig, \"Pervasive Monitoring Is an\n              Attack\",\
    \ BCP 188, RFC 7258, DOI 10.17487/RFC7258, May\n              2014, <http://www.rfc-editor.org/info/rfc7258>.\n\
    \   [RFC7366]  Gutmann, P., \"Encrypt-then-MAC for Transport Layer\n         \
    \     Security (TLS) and Datagram Transport Layer Security\n              (DTLS)\"\
    , RFC 7366, DOI 10.17487/RFC7366, September 2014,\n              <http://www.rfc-editor.org/info/rfc7366>.\n\
    \   [RFC7390]  Rahman, A., Ed. and E. Dijk, Ed., \"Group Communication for\n \
    \             the Constrained Application Protocol (CoAP)\", RFC 7390,\n     \
    \         DOI 10.17487/RFC7390, October 2014,\n              <http://www.rfc-editor.org/info/rfc7390>.\n\
    \   [RFC7397]  Gilger, J. and H. Tschofenig, \"Report from the Smart\n       \
    \       Object Security Workshop\", RFC 7397, DOI 10.17487/RFC7397,\n        \
    \      December 2014, <http://www.rfc-editor.org/info/rfc7397>.\n   [RFC7400]\
    \  Bormann, C., \"6LoWPAN-GHC: Generic Header Compression for\n              IPv6\
    \ over Low-Power Wireless Personal Area Networks\n              (6LoWPANs)\",\
    \ RFC 7400, DOI 10.17487/RFC7400, November\n              2014, <http://www.rfc-editor.org/info/rfc7400>.\n\
    \   [RFC7452]  Tschofenig, H., Arkko, J., Thaler, D., and D. McPherson,\n    \
    \          \"Architectural Considerations in Smart Object Networking\",\n    \
    \          RFC 7452, DOI 10.17487/RFC7452, March 2015,\n              <http://www.rfc-editor.org/info/rfc7452>.\n\
    \   [RFC7465]  Popov, A., \"Prohibiting RC4 Cipher Suites\", RFC 7465,\n     \
    \         DOI 10.17487/RFC7465, February 2015,\n              <http://www.rfc-editor.org/info/rfc7465>.\n\
    \   [RFC7507]  Moeller, B. and A. Langley, \"TLS Fallback Signaling Cipher\n \
    \             Suite Value (SCSV) for Preventing Protocol Downgrade\n         \
    \     Attacks\", RFC 7507, DOI 10.17487/RFC7507, April 2015,\n              <http://www.rfc-editor.org/info/rfc7507>.\n\
    \   [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations\
    \ for Secure Use of Transport Layer\n              Security (TLS) and Datagram\
    \ Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\
    \ May\n              2015, <http://www.rfc-editor.org/info/rfc7525>.\n   [RFC7539]\
    \  Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF\n              Protocols\"\
    , RFC 7539, DOI 10.17487/RFC7539, May 2015,\n              <http://www.rfc-editor.org/info/rfc7539>.\n\
    \   [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,\n       \
    \       \"Deprecating Secure Sockets Layer Version 3.0\", RFC 7568,\n        \
    \      DOI 10.17487/RFC7568, June 2015,\n              <http://www.rfc-editor.org/info/rfc7568>.\n\
    \   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n  \
    \            for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n       \
    \       2016, <http://www.rfc-editor.org/info/rfc7748>.\n   [SP800-107-rev1]\n\
    \              National Institute of Standards and Technology,\n             \
    \ \"Recommendation for Applications Using Approved Hash\n              Algorithms\"\
    , NIST Special Publication 800-107, Revision 1,\n              DOI 10.6028/NIST.SP.800-107r1,\
    \ August 2012,\n              <http://csrc.nist.gov/publications/nistpubs/800-107-rev1/\n\
    \              sp800-107-rev1.pdf>.\n   [SP800-22b]\n              National Institute\
    \ of Standards and Technology, \"A\n              Statistical Test Suite for Random\
    \ and Pseudorandom Number\n              Generators for Cryptographic Applications\"\
    , NIST Special\n              Publication 800-22, Revision 1a, April 2010,\n \
    \             <http://csrc.nist.gov/publications/nistpubs/800-22-rev1a/\n    \
    \          SP800-22rev1a.pdf>.\n   [SP800-90A]\n              National Institute\
    \ of Standards and Technology,\n              \"Recommendation for Random Number\
    \ Generation Using\n              Deterministic Random Bit Generators\", NIST\
    \ Special\n              Publication 800-90A Revision 1,\n              DOI 10.6028/NIST.SP.800-90Ar1,\
    \ June 2015,\n              <http://csrc.nist.gov/publications/drafts/800-90/\n\
    \              sp800-90a_r1_draft_november2014_ver.pdf>.\n   [TLS-FALSESTART]\n\
    \              Langley, A., Modadugu, N., and B. Moeller, \"Transport\n      \
    \        Layer Security (TLS) False Start\", Work in Progress,\n             \
    \ draft-ietf-tls-falsestart-02, May 2016.\n   [Triple-HS]\n              Bhargavan,\
    \ K., Delignat-Lavaud, C., Pironti, A., and P.\n              Yves Strub, \"Triple\
    \ Handshakes and Cookie Cutters:\n              Breaking and Fixing Authentication\
    \ over TLS\", In\n              Proceedings of the IEEE Symposium on Security\
    \ and Privacy,\n              Pages 98-113, DOI 10.1109/SP.2014.14, 2014.\n"
- title: Appendix A.  Conveying DTLS over SMS
  contents:
  - "Appendix A.  Conveying DTLS over SMS\n   This section is normative for the use\
    \ of DTLS over SMS.  Timer\n   recommendations are already outlined in Section\
    \ 11 and also\n   applicable to the transport of DTLS over SMS.\n   This section\
    \ requires readers to be familiar with the terminology and\n   concepts described\
    \ in [GSM-SMS] and [WAP-WDP].\n   The remainder of this section assumes Mobile\
    \ Stations are capable of\n   producing and consuming Transport Protocol Data\
    \ Units (TPDUs) encoded\n   as 8-bit binary data.\n"
- title: A.1.  Overview
  contents:
  - "A.1.  Overview\n   DTLS adds an additional round-trip to the TLS [RFC5246] handshake\
    \ to\n   serve as a return-routability test for protection against certain\n \
    \  types of DoS attacks.  Thus, a full-blown DTLS handshake comprises up\n   to\
    \ 6 \"flights\" (i.e., logical message exchanges), each of which is\n   then mapped\
    \ on to one or more DTLS records using the segmentation and\n   reassembly (SaR)\
    \ scheme described in Section 4.2.3 of [RFC6347].  The\n   overhead for said scheme\
    \ is 6 bytes per handshake message which,\n   given a realistic 10+ messages handshake,\
    \ would amount to around 60\n   bytes across the whole handshake sequence.\n \
    \  Note that the DTLS SaR scheme is defined for handshake messages only.\n   In\
    \ fact, DTLS records are never fragmented and MUST fit within a\n   single transport\
    \ layer datagram.\n   SMS provides an optional segmentation and reassembly scheme\
    \ as well,\n   known as Concatenated short messages (see Section 9.2.3.24.1 of\n\
    \   [GSM-SMS]).  However, since the SaR scheme in DTLS cannot be\n   circumvented,\
    \ the Concatenated short messages mechanism SHOULD NOT be\n   used during handshake\
    \ to avoid redundant overhead.  Before starting\n   the handshake phase (either\
    \ actively or passively), the DTLS\n   implementation MUST be explicitly configured\
    \ with the Path MTU (PMTU)\n   of the SMS transport in order to correctly instrument\
    \ its SaR\n   function.  The PMTU SHALL be 133 bytes if multiplexing based on\
    \ the\n   Wireless Datagram Protocol (WDP) is used (see Appendix A.3); 140\n \
    \  bytes otherwise.\n   It is RECOMMENDED that the established security context\
    \ over the\n   longest possible period be used (possibly until a Closure Alert\n\
    \   message is received or after a very long inactivity timeout) to avoid\n  \
    \ the expensive re-establishment of the security association.\n"
- title: A.2.  Message Segmentation and Reassembly
  contents:
  - "A.2.  Message Segmentation and Reassembly\n   The content of an SMS message is\
    \ carried in the TP-UserData field,\n   and its size may be up to 140 bytes. \
    \ As already mentioned in\n   Appendix A.1, longer (i.e., up to 34170 bytes) messages\
    \ can be sent\n   using Concatenated SMS.\n   This scheme consumes 6-7 bytes (depending\
    \ on whether the short or\n   long segmentation format is used) of the TP-UserData\
    \ field, thus\n   reducing the space available for the actual content of the SMS\n\
    \   message to 133-134 bytes per TPDU.\n   Though in principle a PMTU value higher\
    \ than 140 bytes could be used,\n   which may look like an appealing option given\
    \ its more efficient use\n   of the transport, there are disadvantages to consider.\
    \  First, there\n   is an additional overhead of 7 bytes per TPDU to be paid to\
    \ the SaR\n   function (which is in addition to the overhead introduced by the\
    \ DTLS\n   SaR mechanism.  Second, some networks only partially support the\n\
    \   Concatenated SMS function, and others do not support it at all.\n   For these\
    \ reasons, the Concatenated short messages mechanism SHOULD\n   NOT be used, and\
    \ it is RECOMMENDED to leave the same PMTU settings\n   used during the handshake\
    \ phase, i.e., 133 bytes if WDP-based\n   multiplexing is enabled; 140 bytes otherwise.\n\
    \   Note that, after the DTLS handshake has completed, any fragmentation\n   and\
    \ reassembly logic that pertains the application layer (e.g.,\n   segmenting CoAP\
    \ messages into DTLS records and reassembling them\n   after the crypto operations\
    \ have been successfully performed) needs\n   to be handled by the application\
    \ that uses the established DTLS\n   tunnel.\n"
- title: A.3.  Multiplexing Security Associations
  contents:
  - "A.3.  Multiplexing Security Associations\n   Unlike IPsec Encapsulating Security\
    \ Payload (ESP) / Authentication\n   Header (AH), DTLS records do not contain\
    \ any association identifiers.\n   Applications must arrange to multiplex between\
    \ associations on the\n   same endpoint which, when using UDP/IP, is usually done\
    \ with the\n   host/port number.\n   If the DTLS server allows more than one client\
    \ to be active at any\n   given time, then the Wireless Application Protocol (WAP)\
    \ User\n   Datagram Protocol [WAP-WDP] can be used to achieve multiplexing of\n\
    \   the different security associations.  (The use of WDP provides the\n   additional\
    \ benefit that upper-layer protocols can operate\n   independently of the underlying\
    \ wireless network, hence achieving\n   application-agnostic transport handover.)\n\
    \   The total overhead cost for encoding the WDP source and destination\n   ports\
    \ is either 5 or 7 bytes out of the total available for the SMS\n   content depending\
    \ on if 1-byte or 2-byte port identifiers are used,\n   as shown in Figures 13\
    \ and 14.\n   0        1        2        3        4\n   +--------+--------+--------+--------+--------+\n\
    \   | ...    | 0x04   | 2      | ...    | ...    |\n   +--------+--------+--------+--------+--------+\n\
    \     UDH      IEI      IE       Dest     Source\n     Length            Length\
    \   Port     Port\n   Legend:\n   UDH = user data header\n   IEI = information\
    \ element identifier\n       Figure 13: Application Port Addressing Scheme (8-Bit\
    \ Address)\n   0        1        2        3        4        5        6\n   +--------+--------+--------+--------+--------+--------+--------+\n\
    \   | ...    | 0x05   | 4      |       ...       |       ...       |\n   +--------+--------+--------+--------+--------+--------+--------+\n\
    \     UDH      IEI      IE       Dest              Source\n     Length       \
    \     Length   Port              Port\n      Figure 14: Application Port Addressing\
    \ Scheme (16-Bit Address)\n   The receiving side of the communication gets the\
    \ source address from\n   the originator address (TP-OA) field of the SMS-DELIVER\
    \ TPDU.  This\n   way, a unique 4-tuple identifying the security association can\
    \ be\n   reconstructed at both ends.  (When replying to its DTLS peer, the\n \
    \  sender will swap the TP-OA and destination address (TP-DA) parameters\n   and\
    \ the source and destination ports in the WDP.)\n"
- title: A.4.  Timeout
  contents:
  - "A.4.  Timeout\n   If SMS-STATUS-REPORT messages are enabled, their receipt is\
    \ not to be\n   interpreted as the signal that the specific handshake message\
    \ has\n   been acted upon by the receiving party.  Therefore, it MUST NOT be\n\
    \   taken into account by the DTLS timeout and retransmission function.\n   Handshake\
    \ messages MUST carry a validity period (TP-VP parameter in a\n   SMS-SUBMIT TPDU)\
    \ that is not less than the current value of the\n   retransmission timeout. \
    \ In order to avoid persisting messages in the\n   network that will be discarded\
    \ by the receiving party, handshake\n   messages SHOULD carry a validity period\
    \ that is the same as, or just\n   slightly higher than, the current value of\
    \ the retransmission\n   timeout.\n"
- title: Appendix B.  DTLS Record Layer Per-Packet Overhead
  contents:
  - "Appendix B.  DTLS Record Layer Per-Packet Overhead\n   Figure 15 shows the overhead\
    \ for the DTLS record layer for protecting\n   data traffic when AES-128-CCM with\
    \ an 8-octet Integrity Check Value\n   (ICV) is used.\n   DTLS Record Layer Header................13\
    \ bytes\n   Nonce (Explicit).........................8 bytes\n   ICV.....................................\
    \ 8 bytes\n   ------------------------------------------------\n   Overhead................................29\
    \ bytes\n   ------------------------------------------------\n      Figure 15:\
    \ AES-128-CCM-8 DTLS Record Layer Per-Packet Overhead\n   The DTLS record layer\
    \ header has 13 octets and consists of:\n   o  1-octet content type field,\n \
    \  o  2-octet version field,\n   o  2-octet epoch field,\n   o  6-octet sequence\
    \ number, and\n   o  2-octet length field.\n   The \"nonce\" input to the AEAD\
    \ algorithm is exactly that of [RFC5288],\n   i.e., 12 bytes long.  It consists\
    \ of two values, namely a 4-octet\n   salt and an 8-octet nonce_explicit:\n  \
    \    The salt is the \"implicit\" part and is not sent in the packet.\n      Instead,\
    \ the salt is generated as part of the handshake process.\n      The nonce_explicit\
    \ value is 8 octets long and it is chosen by the\n      sender and carried in\
    \ each TLS record.  RFC 6655 [RFC6655] allows\n      the nonce_explicit to be\
    \ a sequence number or something else.\n      This document makes this use more\
    \ restrictive for use with DTLS:\n      the 64-bit none_explicit value MUST be\
    \ the 16-bit epoch\n      concatenated with the 48-bit seq_num.  The sequence\
    \ number\n      component of the nonce_explicit field at the AES-CCM layer is\
    \ an\n      exact copy of the sequence number in the record layer header\n   \
    \   field.  This leads to a duplication of 8-bytes per record.\n      To avoid\
    \ this 8-byte duplication, RFC 7400 [RFC7400] provides help\n      with the use\
    \ of the generic header compression technique for IPv6\n      over Low-Power Wireless\
    \ Personal Area Networks (6LoWPANs).  Note\n      that this header compression\
    \ technique is not available when DTLS\n      is exchanged over transports that\
    \ do not use IPv6 or 6LoWPAN, such\n      as the SMS transport described in Appendix\
    \ A of this document.\n"
- title: Appendix C.  DTLS Fragmentation
  contents:
  - "Appendix C.  DTLS Fragmentation\n   Section 4.2.3 of [RFC6347] advises DTLS implementations\
    \ to not\n   produce overlapping fragments.  However, it requires receivers to\
    \ be\n   able to cope with them.  The need for the latter requisite is\n   explained\
    \ in Section 4.1.1.1 of [RFC6347]: accurate PMTU estimation\n   may be traded\
    \ for shorter handshake completion time.\n   In many cases, the cost of handling\
    \ fragment overlaps has proved to\n   be unaffordable for constrained implementations,\
    \ particularly because\n   of the increased complexity in buffer management.\n\
    \   In order to reduce the likelihood of producing different fragment\n   sizes\
    \ and consequent overlaps within the same handshake, this\n   document RECOMMENDs:\n\
    \   o  clients (handshake initiators) to use reliable PMTU information\n     \
    \ for the intended destination; and\n   o  servers to mirror the fragment size\
    \ selected by their clients.\n   The PMTU information comes from either a \"fresh\
    \ enough\" discovery\n   performed by the client [RFC1981] [RFC4821] or some other\
    \ reliable\n   out-of-band channel.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Thanks to Derek Atkins, Paul Bakker, Olaf Bergmann, Carsten\
    \ Bormann,\n   Ben Campbell, Brian Carpenter, Robert Cragie, Spencer Dawkins,\
    \ Russ\n   Housley, Rene Hummen, Jayaraghavendran K, Sye Loong Keoh, Matthias\n\
    \   Kovatsch, Sandeep Kumar, Barry Leiba, Simon Lemay, Alexey Melnikov,\n   Gabriel\
    \ Montenegro, Manuel Pegourie-Gonnard, Akbar Rahman, Eric\n   Rescorla, Michael\
    \ Richardson, Ludwig Seitz, Zach Shelby, Michael\n   StJohns, Rene Struik, Tina\
    \ Tsou, and Sean Turner for their helpful\n   comments and discussions that have\
    \ shaped the document.\n   A big thanks also to Klaus Hartke, who wrote the initial\
    \ draft\n   version of this document.\n   Finally, we would like to thank our\
    \ area director (Stephen Farrell)\n   and our working group chairs (Zach Shelby\
    \ and Dorothy Gellert) for\n   their support.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Hannes Tschofenig (editor)\n   ARM Ltd.\n   110 Fulbourn\
    \ Rd\n   Cambridge  CB1 9NJ\n   United Kingdom\n   Email: Hannes.tschofenig@gmx.net\n\
    \   URI:   http://www.tschofenig.priv.at\n   Thomas Fossati\n   Nokia\n   3 Ely\
    \ Road\n   Milton, Cambridge  CB24 6DD\n   United Kingdom\n   Email: thomas.fossati@nokia.com\n"
