- contents:
  - '                 Certificate Management over CMS (CMC)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   This document defines the base syntax for CMC, a Certificate\n   Management
    protocol using the Cryptographic Message Syntax (CMS).\n   This protocol addresses
    two immediate needs within the Internet\n   Public Key Infrastructure (PKI) community:\n
    \  1.  The need for an interface to public key certification products\n       and
    services based on CMS and PKCS #10 (Public Key Cryptography\n       Standard),
    and\n   2.  The need for a PKI enrollment protocol for encryption only keys\n
    \      due to algorithm or hardware design.\n   CMC also requires the use of the
    transport document and the\n   requirements usage document along with this document
    for a full\n   definition.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n     1.1.  Protocol Requirements  . . . . . . . . . . . . . .
    . . . .  4\n     1.2.  Requirements Terminology . . . . . . . . . . . . . . .
    . .  5\n     1.3.  Changes since RFC 2797 . . . . . . . . . . . . . . . . . .
    \ 5\n   2.  Protocol Overview  . . . . . . . . . . . . . . . . . . . . . .  5\n
    \    2.1.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .  7\n     2.2.
    \ Protocol Requests/Responses  . . . . . . . . . . . . . . .  9\n   3.  PKI Requests
    . . . . . . . . . . . . . . . . . . . . . . . . . 10\n     3.1.  Simple PKI Request
    . . . . . . . . . . . . . . . . . . . . 10\n     3.2.  Full PKI Request . . .
    . . . . . . . . . . . . . . . . . . 12\n       3.2.1.  PKIData Content Type .
    . . . . . . . . . . . . . . . . 13\n         3.2.1.1.  Control Syntax . . . .
    . . . . . . . . . . . . . . 14\n         3.2.1.2.  Certification Request Formats
    \ . . . . . . . . . . 15\n           3.2.1.2.1.  PKCS #10 Certification Syntax
    \ . . . . . . . . 16\n           3.2.1.2.2.  CRMF Certification Syntax  . . .
    . . . . . . . 17\n           3.2.1.2.3.  Other Certification Request  . . . .
    . . . . . 18\n         3.2.1.3.  Content Info Objects . . . . . . . . . . . .
    . . . 19\n           3.2.1.3.1.  Authenticated Data . . . . . . . . . . . . .
    . 19\n           3.2.1.3.2.  Data . . . . . . . . . . . . . . . . . . . . . 20\n
    \          3.2.1.3.3.  Enveloped Data . . . . . . . . . . . . . . . . 20\n           3.2.1.3.4.
    \ Signed Data  . . . . . . . . . . . . . . . . . 20\n         3.2.1.4.  Other
    Message Bodies . . . . . . . . . . . . . . . 21\n       3.2.2.  Body Part Identification
    . . . . . . . . . . . . . . . 21\n       3.2.3.  CMC Unsigned Data Attribute  .
    . . . . . . . . . . . . 22\n   4.  PKI Responses  . . . . . . . . . . . . . .
    . . . . . . . . . . 23\n     4.1.  Simple PKI Response  . . . . . . . . . . .
    . . . . . . . . 23\n     4.2.  Full PKI Response  . . . . . . . . . . . . . .
    . . . . . . 24\n       4.2.1.  PKIResponse Content Type . . . . . . . . . . .
    . . . . 24\n   5.  Application of Encryption to a PKI Request/Response  . . .
    . . 25\n   6.  Controls . . . . . . . . . . . . . . . . . . . . . . . . . . .
    26\n     6.1.  CMC Status Info Controls . . . . . . . . . . . . . . . . . 28\n
    \      6.1.1.  Extended CMC Status Info Control . . . . . . . . . . . 28\n       6.1.2.
    \ CMC Status Info Control  . . . . . . . . . . . . . . . 30\n       6.1.3.  CMCStatus
    Values . . . . . . . . . . . . . . . . . . . 31\n       6.1.4.  CMCFailInfo  .
    . . . . . . . . . . . . . . . . . . . . 32\n     6.2.  Identification and Identity
    Proof Controls . . . . . . . . 33\n       6.2.1.  Identity Proof Version 2 Control
    . . . . . . . . . . . 33\n       6.2.2.  Identity Proof Control . . . . . . .
    . . . . . . . . . 35\n       6.2.3.  Identification Control . . . . . . . . .
    . . . . . . . 35\n       6.2.4.  Hardware Shared-Secret Token Generation  . .
    . . . . . 36\n     6.3.  Linking Identity and POP Information . . . . . . . .
    . . . 36\n       6.3.1.  Cryptographic Linkage  . . . . . . . . . . . . . . .
    . 37\n         6.3.1.1.  POP Link Witness Version 2 Controls  . . . . . . . 37\n
    \        6.3.1.2.  POP Link Witness Control . . . . . . . . . . . . . 38\n         6.3.1.3.
    \ POP Link Random Control  . . . . . . . . . . . . . 38\n       6.3.2.  Shared-Secret/Subject
    DN Linking . . . . . . . . . . . 39\n       6.3.3.  Renewal and Rekey Messages
    . . . . . . . . . . . . . . 39\n     6.4.  Data Return Control  . . . . . . .
    . . . . . . . . . . . . 40\n     6.5.  RA Certificate Modification Controls .
    . . . . . . . . . . 40\n       6.5.1.  Modify Certification Request Control .
    . . . . . . . . 41\n       6.5.2.  Add Extensions Control . . . . . . . . . .
    . . . . . . 42\n     6.6.  Transaction Identifier Control and Sender and\n           Recipient
    Nonce Controls . . . . . . . . . . . . . . . . . 44\n     6.7.  Encrypted and
    Decrypted POP Controls . . . . . . . . . . . 45\n     6.8.  RA POP Witness Control
    . . . . . . . . . . . . . . . . . . 48\n     6.9.  Get Certificate Control  .
    . . . . . . . . . . . . . . . . 49\n     6.10. Get CRL Control  . . . . . . .
    . . . . . . . . . . . . . . 49\n     6.11. Revocation Request Control . . . .
    . . . . . . . . . . . . 50\n     6.12. Registration and Response Information Controls
    . . . . . . 52\n     6.13. Query Pending Control  . . . . . . . . . . . . . .
    . . . . 53\n     6.14. Confirm Certificate Acceptance Control . . . . . . . .
    . . 53\n     6.15. Publish Trust Anchors Control  . . . . . . . . . . . . . .
    54\n     6.16. Authenticated Data Control . . . . . . . . . . . . . . . . 55\n
    \    6.17. Batch Request and Response Controls  . . . . . . . . . . . 56\n     6.18.
    Publication Information Control  . . . . . . . . . . . . . 57\n     6.19. Control
    Processed Control  . . . . . . . . . . . . . . . . 58\n   7.  Registration Authorities
    . . . . . . . . . . . . . . . . . . . 59\n     7.1.  Encryption Removal . . .
    . . . . . . . . . . . . . . . . . 60\n     7.2.  Signature Layer Removal  . .
    . . . . . . . . . . . . . . . 61\n   8.  Security Considerations  . . . . . .
    . . . . . . . . . . . . . 61\n   9.  IANA Considerations  . . . . . . . . . .
    . . . . . . . . . . . 62\n   10. Acknowledgments  . . . . . . . . . . . . . .
    . . . . . . . . . 63\n   11. References . . . . . . . . . . . . . . . . . . .
    . . . . . . . 63\n     11.1. Normative References . . . . . . . . . . . . . .
    . . . . . 63\n     11.2. Informative References . . . . . . . . . . . . . . .
    . . . 63\n   Appendix A.  ASN.1 Module  . . . . . . . . . . . . . . . . . . .
    . 65\n   Appendix B.  Enrollment Message Flows  . . . . . . . . . . . . . . 74\n
    \    B.1.  Request of a Signing Certificate . . . . . . . . . . . . . 74\n     B.2.
    \ Single Certification Request, But Modified by RA . . . . . 75\n     B.3.  Direct
    POP for an RSA Certificate  . . . . . . . . . . . . 78\n   Appendix C.  Production
    of Diffie-Hellman Public Key\n                Certification Requests  . . . .
    . . . . . . . . . . . 81\n     C.1.  No-Signature Signature Mechanism . . . .
    . . . . . . . . . 81\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines the base syntax for CMC, a Certificate\n
    \  Management protocol using the Cryptographic Message Syntax (CMS).\n   This
    protocol addresses two immediate needs within the Internet PKI\n   community:\n
    \  1.  The need for an interface to public key certification products\n       and
    services based on CMS and PKCS #10, and\n   2.  The need for a PKI enrollment
    protocol for encryption only keys\n       due to algorithm or hardware design.\n
    \  A small number of additional services are defined to supplement the\n   core
    certification request service.\n"
  - contents:
    - "1.1.  Protocol Requirements\n   The protocol must be based as much as possible
      on the existing CMS,\n   PKCS #10 [PKCS10] and CRMF (Certificate Request Message
      Format)\n   [CRMF] specifications.\n   The protocol must support the current
      industry practice of a PKCS #10\n   certification request followed by a PKCS#7
      \"certs-only\" response as a\n   subset of the protocol.\n   The protocol must
      easily support the multi-key enrollment protocols\n   required by S/MIME and
      other groups.\n   The protocol must supply a way of doing all enrollment operations
      in\n   a single round-trip.  When this is not possible the number of\n   round-trips
      is to be minimized.\n   The protocol must be designed such that all key generation
      can occur\n   on the client.\n   Support must exist for the mandatory algorithms
      used by S/MIME.\n   Support should exist for all other algorithms cited by the
      S/MIME\n   core documents.\n   The protocol must contain Proof-of-Possession
      (POP) methods.\n   Optional provisions for multiple-round-trip POP will be made
      if\n   necessary.\n   The protocol must support deferred and pending responses
      to\n   enrollment requests for cases where external procedures are required\n
      \  to issue a certificate.\n   The protocol must support arbitrary chains of
      Registration\n   Authorities (RAs) as intermediaries between certification requesters\n
      \  and Certification Authorities (CAs).\n"
    title: 1.1.  Protocol Requirements
  - contents:
    - "1.2.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n"
    title: 1.2.  Requirements Terminology
  - contents:
    - "1.3.  Changes since RFC 2797\n   We have done a major overhaul on the layout
      of the document.  This\n   included two different steps.  Firstly we removed
      some sections from\n   the document and moved them to two other documents.  Information
      on\n   how to transport our messages are now found in [CMC-TRANS].\n   Information
      on which controls and sections of this document must be\n   implemented along
      with which algorithms are required can now be found\n   in [CMC-COMPL].\n   A
      number of new controls have been added in this version:\n      Extended CMC
      Status Info Section 6.1.1\n      Publish Trust Anchors Section 6.15\n      Authenticate
      Data Section 6.16\n      Batch Request and Response Processing Section 6.17\n
      \     Publication Information Section 6.18\n      Modify Certification Request
      Section 6.5.1\n      Control Processed Section 6.19\n      Identity Proof Section
      6.2.2\n      Identity POP Link Witness V2 Section 6.3.1.1\n"
    title: 1.3.  Changes since RFC 2797
  title: 1.  Introduction
- contents:
  - "2.  Protocol Overview\n   A PKI enrollment transaction in this specification
    is generally\n   composed of a single round-trip of messages.  In the simplest
    case a\n   PKI enrollment request, henceforth referred to as a PKI Request, is\n
    \  sent from the client to the server and a PKI enrollment response,\n   henceforth
    referred to as a PKI Response, is then returned from the\n   server to the client.
    \ In more complicated cases, such as delayed\n   certificate issuance, more than
    one round-trip is required.\n   This specification defines two PKI Request types
    and two PKI Response\n   types.\n   PKI Requests are formed using either the PKCS
    #10 or CRMF structure.\n   The two PKI Requests are:\n   Simple PKI Request:  the
    bare PKCS #10 (in the event that no other\n      services are needed), and\n   Full
    PKI Request:  one or more PKCS #10, CRMF or Other Request\n      Messages structures
    wrapped in a CMS encapsulation as part of a\n      PKIData.\n   PKI Responses
    are based on SignedData or AuthenticatedData [CMS].\n   The two PKI Responses
    are\n   Simple PKI Response:  a \"certs-only\" SignedData (in the event no\n      other
    services are needed), or\n   Full PKI Response:  a PKIResponse content type wrapped
    in a\n      SignedData.\n   No special services are provided for either renewal
    (i.e., a new\n   certificate with the same key) or rekey (i.e., a new certificate
    with\n   a new key) of client certificates.  Instead renewal and rekey\n   requests
    look the same as any certification request, except that the\n   identity proof
    is supplied by existing certificates from a trusted\n   CA.  (This is usually
    the same CA, but could be a different CA in the\n   same organization where naming
    is shared.)\n   No special services are provided to distinguish between a rekey\n
    \  request and a new certification request (generally for a new\n   purpose).
    \ A control to unpublish a certificate would normally be\n   included in a rekey
    request, and be omitted in a new certification\n   request.  CAs or other publishing
    agents are also expected to have\n   policies for removing certificates from publication
    either based on\n   new certificates being added or the expiration or revocation
    of a\n   certificate.\n   A provision exists for RAs to participate in the protocol
    by taking\n   PKI Requests, wrapping them in a second layer of PKI Request with\n
    \  additional requirements or statements from the RA and then passing\n   this
    new expanded PKI Request on to the CA.\n   This specification makes no assumptions
    about the underlying\n   transport mechanism.  The use of CMS does not imply an
    email-based\n   transport.  Several different possible transport methods are defined\n
    \  in [CMC-TRANS].\n   Optional services available through this specification
    are\n   transaction management, replay detection (through nonces), deferred\n
    \  certificate issuance, certificate revocation requests and\n   certificate/certificate
    revocation list (CRL) retrieval.\n"
  - contents:
    - "2.1.  Terminology\n   There are several different terms, abbreviations, and
      acronyms used\n   in this document.  These are defined here, in no particular
      order,\n   for convenience and consistency of usage:\n   End-Entity  (EE) refers
      to the entity that owns a key pair and for\n      whom a certificate is issued.\n
      \  Registration Authority (RA)  or Local RA (LRA) refers to an entity\n      that
      acts as an intermediary between the EE and the CA.  Multiple\n      RAs can
      exist between the end-entity and the Certification\n      Authority.  RAs may
      perform additional services such as key\n      generation or key archival.  This
      document uses the term RA for\n      both RA and LRA.\n   Certification Authority
      \ (CA) refers to the entity that issues\n      certificates.\n   Client  refers
      to an entity that creates a PKI Request.  In this\n      document, both RAs
      and EEs can be clients.\n   Server  refers to the entities that process PKI
      Requests and create\n      PKI Responses.  In this document, both CAs and RAs
      can be servers.\n   PKCS #10  refers to the Public Key Cryptography Standard
      #10\n      [PKCS10], which defines a certification request syntax.\n   CRMF
      \ refers to the Certificate Request Message Format RFC [CRMF].\n      CMC uses
      this certification request syntax defined in this\n      document as part of
      the protocol.\n   CMS  refers to the Cryptographic Message Syntax RFC [CMS].
      \ This\n      document provides for basic cryptographic services including\n
      \     encryption and signing with and without key management.\n   PKI Request/Response
      \ refers to the requests/responses described in\n      this document.  PKI Requests
      include certification requests,\n      revocation requests, etc.  PKI Responses
      include certs-only\n      messages, failure messages, etc.\n   Proof-of-Identity
      \ refers to the client proving they are who they say\n      that they are to
      the server.\n   Enrollment or certification request  refers to the process of
      a\n      client requesting a certificate.  A certification request is a\n      subset
      of the PKI Requests.\n   Proof-of-Possession (POP)  refers to a value that can
      be used to\n      prove that the private key corresponding to a public key is
      in the\n      possession and can be used by an end-entity.  The different types\n
      \     of POP are:\n      Signature  provides the required POP by a signature
      operation over\n         some data.\n      Direct  provides the required POP
      operation by an encrypted\n         challenge/response mechanism.\n      Indirect
      \ provides the required POP operation by returning the\n         issued certificate
      in an encrypted state.  (This method is not\n         used by CMC.)\n      Publish
      \ provides the required POP operation by providing the\n         private key
      to the certificate issuer.  (This method is not\n         currently used by
      CMC.  It would be used by Key Generation or\n         Key Escrow extensions.)\n
      \     Attested  provides the required POP operation by allowing a\n         trusted
      entity to assert that the POP has been proven by one of\n         the above
      methods.\n   Object IDentifier (OID)  is a primitive type in Abstract Syntax\n
      \     Notation One (ASN.1).\n"
    title: 2.1.  Terminology
  - contents:
    - "2.2.  Protocol Requests/Responses\n   Figure 1 shows the Simple PKI Requests
      and Responses.  The contents\n   of Simple PKI Request and Response are detailed
      in Sections 3.1 and\n   4.1.\n   Simple PKI Request                      Simple
      PKI Response\n   -------------------------               --------------------------\n
      \   +----------+                            +------------------+\n    | PKCS
      #10 |                            | CMS ContentInfo  |\n    +----------+--------------+
      \            +------------------+------+\n    | Certification Request   |             |
      CMS Signed Data,        |\n    |                         |             |   no
      SignerInfo         |\n    | Subject Name            |             |\n    | Subject
      Public Key Info |             | SignedData contains one |\n    |   (K_PUB)               |
      \            | or more certificates in |\n    | Attributes              |             |
      the certificates field  |\n    |                         |             | Relevant
      CA certs and   |\n    +-----------+-------------+             | CRLs can be
      included    |\n                | signed with |             | as well.                |\n
      \               | matching    |             |                         |\n                |
      K_PRIV      |             | encapsulatedContentInfo |\n                +-------------+
      \            | is absent.              |\n                                            +--------------+----------+\n
      \                                                          | unsigned |\n                                                           +----------+\n
      \               Figure 1: Simple PKI Requests and Responses\n   Figure 2 shows
      the Full PKI Requests and Responses.  The contents of\n   the Full PKI Request
      and Response are detailed in Sections 3.2 and\n   4.2.\n    Full PKI Request
      \                       Full PKI Response\n    -----------------------                 ------------------------\n
      \   +----------------+                      +----------------+\n    | CMS ContentInfo|
      \                     | CMS ContentInfo|\n    | CMS SignedData |                      |
      CMS SignedData |\n    |   or Auth Data |                      |   or Auth Data
      |\n    |     object     |                      |     object     |\n    +----------------+--------+
      \            +----------------+--------+\n    |                         |             |
      \                        |\n    | PKIData                 |             | PKIResponseBody
      \        |\n    |                         |             |                         |\n
      \   | Sequence of:            |             | Sequence of:            |\n    |
      <enrollment control>*   |             | <enrollment control>*   |\n    | <certification
      request>*|             | <CMS object>*           |\n    | <CMS object>*           |
      \            | <other message>*        |\n    | <other message>*        |             |
      \                        |\n    |                         |             | where
      * == zero or more |\n    | where * == zero or more |             |                         |\n
      \   |                         |             | All certificates issued |\n    |
      Certification requests  |             | as part of the response |\n    | are
      CRMF, PKCS #10, or  |             | are included in the     |\n    | Other.
      \                 |             | \"certificates\" field    |\n    |                         |
      \            | of the SignedData.      |\n    +-------+-----------------+             |
      Relevant CA certs and   |\n            | signed (keypair |             | CRLs
      can be included as |\n            | used may be pre-|             | well.                   |\n
      \           | existing or     |             |                         |\n            |
      identified in   |             +---------+---------------+\n            | the
      request)    |                       | signed by the |\n            +-----------------+
      \                      | CA or an LRA  |\n                                                      +---------------+\n
      \              Figure 2: Full PKI Requests and Responses\n"
    title: 2.2.  Protocol Requests/Responses
  title: 2.  Protocol Overview
- contents:
  - "3.  PKI Requests\n   Two types of PKI Requests exist.  This section gives the
    details for\n   both types.\n"
  - contents:
    - "3.1.  Simple PKI Request\n   A Simple PKI Request uses the PKCS #10 syntax
      CertificationRequest\n   [PKCS10].\n   When a server processes a Simple PKI
      Request, the PKI Response\n   returned is:\n   Simple PKI Response  on success.\n
      \  Full PKI Response  on failure.  The server MAY choose not to return a\n      PKI
      Response in this case.\n   The Simple PKI Request MUST NOT be used if a proof-of-identity
      needs\n   to be included.\n   The Simple PKI Request cannot be used if the private
      key is not\n   capable of producing some type of signature (i.e., Diffie-Hellman\n
      \  (DH) keys can use the signature algorithms in [DH-POP] for production\n   of
      the signature).\n   The Simple PKI Request cannot be used for any of the advanced\n
      \  services specified in this document.\n   The client MAY incorporate one or
      more X.509v3 extensions in any\n   certification request based on PKCS #10 as
      an ExtensionReq attribute.\n   The ExtensionReq attribute is defined as:\n     ExtensionReq
      ::= SEQUENCE SIZE (1..MAX) OF Extension\n   where Extension is imported from
      [PKIXCERT] and ExtensionReq is\n   identified by:\n   id-ExtensionReq OBJECT
      IDENTIFIER ::= {iso(1) member-body(2) us(840)\n        rsadsi(113549) pkcs(1)
      pkcs-9(9) 14}\n   Servers MUST be able to process all extensions defined, but
      not\n   prohibited, in [PKIXCERT].  Servers are not required to be able to\n
      \  process other X.509v3 extensions transmitted using this protocol, nor\n   are
      they required to be able to process private extensions.  Servers\n   are not
      required to put all client-requested extensions into a\n   certificate.  Servers
      are permitted to modify client-requested\n   extensions.  Servers MUST NOT alter
      an extension so as to invalidate\n   the original intent of a client-requested
      extension.  (For example,\n   changing key usage from keyAgreement to digitalSignature.)
      \ If a\n   certification request is denied due to the inability to handle a\n
      \  requested extension and a PKI Response is returned, the server MUST\n   return
      a PKI Response with a CMCFailInfo value with the value\n   unsupportedExt.\n"
    title: 3.1.  Simple PKI Request
  - contents:
    - "3.2.  Full PKI Request\n   The Full PKI Request provides the most functionality
      and flexibility.\n   The Full PKI Request is encapsulated in either a SignedData
      or an\n   AuthenticatedData with an encapsulated content type of id-cct-PKIData\n
      \  (Section 3.2.1).\n   When a server processes a Full PKI Request, a PKI Response
      MUST be\n   returned.  The PKI Response returned is:\n   Simple PKI Response
      \ if the enrollment was successful and only\n      certificates are returned.
      \ (A CMCStatusInfoV2 control with\n      success is implied.)\n   Full PKI Response
      \ if the enrollment was successful and information\n      is returned in addition
      to certificates, if the enrollment is\n      pending, or if the enrollment failed.\n
      \  If SignedData is used, the signature can be generated using either\n   the
      private key material of an embedded signature certification\n   request (i.e.,
      included in the TaggedRequest tcr or crm fields) or a\n   previously certified
      signature key.  If the private key of a\n   signature certification request
      is used, then:\n   a.  The certification request containing the corresponding
      public key\n       MUST include a Subject Key Identifier extension.\n   b.  The
      subjectKeyIdentifier form of the signerIdentifier in\n       SignerInfo MUST
      be used.\n   c.  The value of the subjectKeyIdentifier form of SignerInfo MUST
      be\n       the Subject Key Identifier specified in the corresponding\n       certification
      request.  (The subjectKeyIdentifier form of\n       SignerInfo is used here
      because no certificates have yet been\n       issued for the signing key.)  If
      the request key is used for\n       signing, there MUST be only one SignerInfo
      in the SignedData.\n   If AuthenticatedData is used, then:\n   a.  The Password
      Recipient Info option of RecipientInfo MUST be used.\n   b.  A randomly generated
      key is used to compute the Message\n       Authentication Code (MAC) value on
      the encapsulated content.\n   c.  The input for the key derivation algorithm
      is a concatenation of\n       the identifier (encoded as UTF8) and the shared-secret.\n
      \  When creating a PKI Request to renew or rekey a certificate:\n   a.  The
      Identification and Identity Proof controls are absent.  The\n       same information
      is provided by the use of an existing\n       certificate from a CA when signing
      the PKI Request.  In this\n       case, the CA that issued the original certificate
      and the CA the\n       request is made to will usually be the same, but could
      have a\n       common operator.\n   b.  CAs and RAs can impose additional restrictions
      on the signing\n       certificate used.  They may require that the most recently
      issued\n       signing certificate for a client be used.\n   c.  Some CAs may
      prevent renewal operations (i.e., reuse of the same\n       keys).  In this
      case the CA MUST return a PKI Response with\n       noKeyReuse as the CMCFailInfo
      failure code.\n"
    - contents:
      - "3.2.1.  PKIData Content Type\n   The PKIData content type is used for the
        Full PKI Request.  A PKIData\n   content type is identified by:\n     id-cct-PKIData
        ::= {id-pkix id-cct(12) 2 }\n   The ASN.1 structure corresponding to the PKIData
        content type is:\n     PKIData ::= SEQUENCE {\n         controlSequence    SEQUENCE
        SIZE(0..MAX) OF TaggedAttribute,\n         reqSequence        SEQUENCE SIZE(0..MAX)
        OF TaggedRequest,\n         cmsSequence        SEQUENCE SIZE(0..MAX) OF TaggedContentInfo,\n
        \        otherMsgSequence   SEQUENCE SIZE(0..MAX) OF OtherMsg\n     }\n   The
        fields in PKIData have the following meaning:\n   controlSequence  is a sequence
        of controls.  The controls defined in\n      this document are found in Section
        6.  Controls can be defined by\n      other parties.  Details on the TaggedAttribute
        structure can be\n      found in Section 3.2.1.1.\n   reqSequence  is a sequence
        of certification requests.  The\n      certification requests can be a CertificationRequest
        (PKCS #10), a\n      CertReqMsg (CRMF), or an externally defined PKI request.
        \ Full\n      details are found in Section 3.2.1.2.  If an externally defined\n
        \     certification request is present, but the server does not\n      understand
        the certification request (or will not process it), a\n      CMCStatus of
        noSupport MUST be returned for the certification\n      request item and no
        other certification requests are processed.\n   cmsSequence  is a sequence
        of [CMS] message objects.  See\n      Section 3.2.1.3 for more details.\n
        \  otherMsgSequence  is a sequence of arbitrary data objects.  Data\n      objects
        placed here are referred to by one or more controls.  This\n      allows for
        controls to use large amounts of data without the data\n      being embedded
        in the control.  See Section 3.2.1.4 for more\n      details.\n   All certification
        requests encoded into a single PKIData SHOULD be\n   for the same identity.
        \ RAs that batch process (see Section 6.17) are\n   expected to place the
        PKI Requests received into the cmsSequence of a\n   PKIData.\n   Processing
        of the PKIData by a recipient is as follows:\n   1.  All controls should be
        examined and processed in an appropriate\n       manner.  The appropriate
        processing is to complete processing at\n       this time, to ignore the control,
        or to place the control on a\n       to-do list for later processing.  Controls
        can be processed in\n       any order; the order in the sequence is not significant.\n
        \  2.  Items in the reqSequence are not referenced by a control.  These\n
        \      items, which are certification requests, also need to be\n       processed.
        \ As with controls, the appropriate processing can be\n       either immediate
        processing or addition to a to-do list for later\n       processing.\n   3.
        \ Finally, the to-do list is processed.  In many cases, the to-do\n       list
        will be ordered by grouping specific tasks together.\n   No processing is
        required for cmsSequence or otherMsgSequence members\n   of PKIData if they
        are present and are not referenced by a control.\n   In this case, the cmsSequence
        and otherMsgSequence members are\n   ignored.\n"
      - contents:
        - "3.2.1.1.  Control Syntax\n   The actions to be performed for a PKI Request/Response
          are based on\n   the included controls.  Each control consists of an object
          identifier\n   and a value based on the object identifier.\n   The syntax
          of a control is:\n     TaggedAttribute ::= SEQUENCE {\n         bodyPartID
          \        BodyPartID,\n         attrType           OBJECT IDENTIFIER,\n         attrValues
          \        SET OF AttributeValue\n     }\n     AttributeValue ::= ANY\n   The
          fields in TaggedAttribute have the following meaning:\n   bodyPartID  is
          a unique integer that identifies this control.\n   attrType    is the OID
          that identifies the control.\n   attrValues  is the data values used in
          processing the control.  The\n               structure of the data is dependent
          on the specific\n               control.\n   The final server MUST fail
          the processing of an entire PKIData if any\n   included control is not recognized,
          that control is not already\n   marked as processed by a Control Processed
          control (see Section 6.19)\n   and no other error is generated.  The PKI
          Response MUST include a\n   CMCFailInfo value with the value badRequest
          and the bodyList MUST\n   contain the bodyPartID of the invalid or unrecognized
          control(s).  A\n   server is the final server if and only if it is not passing
          the PKI\n   Request on to another server.  A server is not considered to
          be the\n   final server if the server would have passed the PKI Request
          on, but\n   instead it returned a processing error.\n   The controls defined
          by this document are found in Section 6.\n"
        title: 3.2.1.1.  Control Syntax
      - contents:
        - "3.2.1.2.  Certification Request Formats\n   Certification Requests are
          based on PKCS #10, CRMF, or Other Request\n   formats.  Section 3.2.1.2.1
          specifies the requirements for clients\n   and servers dealing with PKCS
          #10.  Section 3.2.1.2.2 specifies the\n   requirements for clients and servers
          dealing with CRMF.\n   Section 3.2.1.2.3 specifies the requirements for
          clients and servers\n   dealing with Other Request.\n     TaggedRequest
          ::= CHOICE {\n        tcr               [0] TaggedCertificationRequest,\n
          \       crm               [1] CertReqMsg,\n        orm               [2]
          SEQUENCE {\n           bodyPartID            BodyPartID,\n           requestMessageType
          \   OBJECT IDENTIFIER,\n           requestMessageValue   ANY DEFINED BY
          requestMessageType\n        }\n     }\n   The fields in TaggedRequest have
          the following meaning:\n   tcr  is a certification request that uses the
          PKCS #10 syntax.\n      Details on PKCS #10 are found in Section 3.2.1.2.1.\n
          \  crm  is a certification request that uses the CRMF syntax.  Details\n
          \     on CRMF are found in Section 3.2.1.2.2.\n   orm  is an externally
          defined certification request.  One example is\n      an attribute certification
          request.  The fields of this structure\n      are:\n      bodyPartID  is
          the identifier number for this certification\n         request.  Details
          on body part identifiers are found in\n         Section 3.2.2.\n      requestMessageType
          \ identifies the other request type.  These\n         values are defined
          outside of this document.\n      requestMessageValue  is the data associated
          with the other request\n         type.\n"
        - contents:
          - "3.2.1.2.1.  PKCS #10 Certification Syntax\n   A certification request
            based on PKCS #10 uses the following ASN.1\n   structure:\n    TaggedCertificationRequest
            ::= SEQUENCE {\n        bodyPartID            BodyPartID,\n        certificationRequest
            \ CertificationRequest\n    }\n   The fields in TaggedCertificationRequest
            have the following meaning:\n   bodyPartID  is the identifier number for
            this certification request.\n      Details on body part identifiers are
            found in Section 3.2.2.\n   certificationRequest  contains the PKCS-#10-based
            certification\n      request.  Its fields are described in [PKCS10].\n
            \  When producing a certification request based on PKCS #10, clients\n
            \  MUST produce the certification request with a subject name and public\n
            \  key.  Some PKI products are operated using a central repository of\n
            \  information to assign subject names upon receipt of a certification\n
            \  request.  To accommodate this mode of operation, the subject field
            in\n   a CertificationRequest MAY be NULL, but MUST be present.  CAs that\n
            \  receive a CertificationRequest with a NULL subject field MAY reject\n
            \  such certification requests.  If rejected and a PKI Response is\n   returned,
            the CA MUST return a PKI Response with the CMCFailInfo\n   value with
            the value badRequest.\n"
          title: '3.2.1.2.1.  PKCS #10 Certification Syntax'
        - contents:
          - "3.2.1.2.2.  CRMF Certification Syntax\n   A CRMF message uses the following
            ASN.1 structure (defined in [CRMF]\n   and included here for convenience):\n
            \  CertReqMsg ::= SEQUENCE {\n     certReq   CertRequest,\n     popo      ProofOfPossession
            \ OPTIONAL,\n     -- content depends upon key type\n     regInfo   SEQUENCE
            SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }\n   CertRequest ::= SEQUENCE
            {\n     certReqId     INTEGER,        -- ID for matching request and reply\n
            \    certTemplate  CertTemplate, --Selected fields of cert to be issued\n
            \    controls      Controls OPTIONAL } -- Attributes affecting issuance\n
            \  CertTemplate ::= SEQUENCE {\n     version      [0] Version               OPTIONAL,\n
            \    serialNumber [1] INTEGER               OPTIONAL,\n     signingAlg
            \  [2] AlgorithmIdentifier   OPTIONAL,\n     issuer       [3] Name                  OPTIONAL,\n
            \    validity     [4] OptionalValidity      OPTIONAL,\n     subject      [5]
            Name                  OPTIONAL,\n     publicKey    [6] SubjectPublicKeyInfo
            \ OPTIONAL,\n     issuerUID    [7] UniqueIdentifier      OPTIONAL,\n     subjectUID
            \  [8] UniqueIdentifier      OPTIONAL,\n     extensions   [9] Extensions
            \           OPTIONAL }\n   The fields in CertReqMsg are explained in [CRMF].\n
            \  This document imposes the following additional restrictions on the\n
            \  construction and processing of CRMF certification requests:\n      When
            a Full PKI Request includes a CRMF certification request,\n      both
            the subject and publicKey fields in the CertTemplate MUST be\n      defined.
            \ The subject field can be encoded as NULL, but MUST be\n      present.\n
            \     When both CRMF and CMC controls exist with equivalent\n      functionality,
            the CMC control SHOULD be used.  The CMC control\n      MUST override
            the CRMF control.\n      The regInfo field MUST NOT be used on a CRMF
            certification\n      request.  Equivalent functionality is provided in
            the CMC regInfo\n      control (Section 6.12).\n      The indirect method
            of proving POP is not supported in this\n      protocol.  One of the other
            methods (including the direct method\n      described in this document)
            MUST be used.  The value of encrCert\n      in SubsequentMessage MUST
            NOT be used.\n      Since the subject and publicKeyValues are always present,
            the\n      POPOSigningKeyInput MUST NOT be used when computing the value
            for\n      POPSigningKey.\n   A server is not required to use all of the
            values suggested by the\n   client in the CRMF certification request.
            \ Servers MUST be able to\n   process all extensions defined, but not
            prohibited in [PKIXCERT].\n   Servers are not required to be able to process
            other X.509v3\n   extensions transmitted using this protocol, nor are
            they required to\n   be able to process private extensions.  Servers are
            permitted to\n   modify client-requested extensions.  Servers MUST NOT
            alter an\n   extension so as to invalidate the original intent of a client-\n
            \  requested extension.  (For example, change key usage from\n   keyAgreement
            to digitalSignature.)  If a certification request is\n   denied due to
            the inability to handle a requested extension, the\n   server MUST respond
            with a Full PKI Response with a CMCFailInfo value\n   with the value of
            unsupportedExt.\n"
          title: 3.2.1.2.2.  CRMF Certification Syntax
        - contents:
          - "3.2.1.2.3.  Other Certification Request\n   This document allows for
            other certification request formats to be\n   defined and used as well.
            \ An example of an other certification\n   request format is one for Attribute
            Certificates.  These other\n   certification request formats are defined
            by specifying an OID for\n   identification and the structure to contain
            the data to be passed.\n"
          title: 3.2.1.2.3.  Other Certification Request
        title: 3.2.1.2.  Certification Request Formats
      - contents:
        - "3.2.1.3.  Content Info Objects\n   The cmsSequence field of the PKIData
          and PKIResponse messages\n   contains zero or more tagged content info objects.
          \ The syntax for\n   this structure is:\n     TaggedContentInfo ::= SEQUENCE
          {\n         bodyPartID              BodyPartID,\n         contentInfo             ContentInfo\n
          \    }\n   The fields in TaggedContentInfo have the following meaning:\n
          \  bodyPartID  is a unique integer that identifies this content info\n      object.\n
          \  contentInfo  is a ContentInfo object (defined in [CMS]).\n   The four
          content types used in cmsSequence are AuthenticatedData,\n   Data, EnvelopedData,
          and SignedData.  All of these content types are\n   defined in [CMS].\n"
        - contents:
          - "3.2.1.3.1.  Authenticated Data\n   The AuthenticatedData content type
            provides a method of doing pre-\n   shared-secret-based validation of
            data being sent between two\n   parties.  Unlike SignedData, it does not
            specify which party actually\n   generated the information.\n   AuthenticatedData
            provides origination authentication in those\n   circumstances where a
            shared-secret exists, but a PKI-based trust has\n   not yet been established.
            \ No PKI-based trust may have been\n   established because a trust anchor
            has not been installed on the\n   client or no certificate exists for
            a signing key.\n   AuthenticatedData content type is used by this document
            for:\n      The id-cmc-authData control (Section 6.16), and\n      The
            top-level wrapper in environments where an encryption-only key\n      is
            being certified.\n   This content type can include both PKIData and PKIResponse
            as the\n   encapsulated content types.  These embedded content types can
            contain\n   additional controls that need to be processed.\n"
          title: 3.2.1.3.1.  Authenticated Data
        - contents:
          - "3.2.1.3.2.  Data\n   The Data content type allows for general transport
            of unstructured\n   data.\n   The Data content type is used by this document
            for:\n      Holding the encrypted random value y for POP proof in the\n
            \     encrypted POP control (see Section 6.7).\n"
          title: 3.2.1.3.2.  Data
        - contents:
          - "3.2.1.3.3.  Enveloped Data\n   The EnvelopedData content type provides
            for shrouding of data.\n   The EnvelopedData content type is the primary
            confidentiality method\n   for sensitive information in this protocol.
            \ EnvelopedData can\n   provide encryption of an entire PKI Request (see
            Section 5).\n   EnvelopedData can also be used to wrap private key material
            for key\n   archival.  If the decryption on an EnvelopedData fails, a
            Full PKI\n   Response is returned with a CMCFailInfo value of badMessageCheck
            and\n   a bodyPartID of 0.\n"
          title: 3.2.1.3.3.  Enveloped Data
        - contents:
          - "3.2.1.3.4.  Signed Data\n   The SignedData content type provides for
            authentication and\n   integrity.\n   The SignedData content type is used
            by this document for:\n      The outer wrapper for a PKI Request.\n      The
            outer wrapper for a PKI Response.\n   As part of processing a PKI Request/Response,
            the signature(s) MUST\n   be verified.  If the signature does not verify
            and the PKI Request/\n   Response contains anything other than a CMC Status
            Info control, a\n   Full PKI Response containing a CMC Status Info control
            MUST be\n   returned using a CMCFailInfo with a value of badMessageCheck
            and a\n   bodyPartID of 0.\n   For the PKI Response, SignedData allows
            the server to sign the\n   returning data, if any exists, and to carry
            the certificates and CRLs\n   corresponding to the PKI Request.  If no
            data is being returned\n   beyond the certificates and CRLs, the EncapsulatedInfo
            and SignerInfo\n   fields are not populated.\n"
          title: 3.2.1.3.4.  Signed Data
        title: 3.2.1.3.  Content Info Objects
      - contents:
        - "3.2.1.4.  Other Message Bodies\n   The otherMsgSequence field of the PKI
          Request/Response allows for\n   arbitrary data objects to be carried as
          part of a PKI Request/\n   Response.  This is intended to contain a data
          object that is not\n   already wrapped in a cmsSequence field (Section 3.2.1.3).
          \ The data\n   object is ignored unless a control references the data object
          by\n   bodyPartID.\n     OtherMsg ::= SEQUENCE {\n         bodyPartID        BodyPartID,\n
          \        otherMsgType      OBJECT IDENTIFIER,\n         otherMsgValue     ANY
          DEFINED BY otherMsgType }\n   The fields in OtherMsg have the following
          meaning:\n   bodyPartID  is the unique id identifying this data object.\n
          \  otherMsgType  is the OID that defines the type of message body.\n   otherMsgValue
          \ is the data.\n"
        title: 3.2.1.4.  Other Message Bodies
      title: 3.2.1.  PKIData Content Type
    - contents:
      - "3.2.2.  Body Part Identification\n   Each element of a PKIData or PKIResponse
        has an associated body part\n   identifier.  The body part identifier is a
        4-octet integer using the\n   ASN.1 of:\n      bodyIdMax INTEGER ::= 4294967295\n
        \     BodyPartID ::= INTEGER(0..bodyIdMax)\n   Body part identifiers are encoded
        in the certReqIds field for\n   CertReqMsg objects (in a TaggedRequest) or
        in the bodyPartID field of\n   the other objects.  The body part identifier
        MUST be unique within a\n   single PKIData or PKIResponse.  Body part identifiers
        can be\n   duplicated in different layers (for example, a PKIData embedded\n
        \  within another).\n   The bodyPartID value of 0 is reserved for use as the
        reference to the\n   current PKIData object.\n   Some controls, such as the
        Add Extensions control (Section 6.5.2),\n   use the body part identifier in
        the pkiDataReference field to refer\n   to a PKI Request in the current PKIData.
        \ Some controls, such as the\n   Extended CMC Status Info control (Section
        6.1.1), will also use body\n   part identifiers to refer to elements in the
        previous PKI Request/\n   Response.  This allows an error to be explicit about
        the control or\n   PKI Request to which the error applies.\n   A BodyPartList
        contains a list of body parts in a PKI Request/\n   Response (i.e., the Batch
        Request control in Section 6.17).  The\n   ASN.1 type BodyPartList is defined
        as:\n      BodyPartList ::= SEQUENCE SIZE (1..MAX) OF BodyPartID\n   A BodyPartPath
        contains a path of body part identifiers moving\n   through nesting (i.e.,
        the Modify Certification Request control in\n   Section 6.5.1).  The ASN.1
        type BodyPartPath is defined as:\n      BodyPartPath ::= SEQUENCE SIZE (1..MAX)
        OF BodyPartID\n"
      title: 3.2.2.  Body Part Identification
    - contents:
      - "3.2.3.  CMC Unsigned Data Attribute\n   There is sometimes a need to include
        data in a PKI Request designed\n   to be removed by an RA during processing.
        \ An example of this is the\n   inclusion of an encrypted private key, where
        a Key Archive Agent\n   removes the encrypted private key before sending it
        on to the CA.\n   One side effect of this desire is that every RA that encapsulates\n
        \  this information needs to move the data so that it is not covered by\n
        \  that RA's signature.  (A client PKI Request encapsulated by an RA\n   cannot
        have a signed control removed by the Key Archive Agent without\n   breaking
        the RA's signature.)  The CMC Unsigned Data attribute\n   addresses this problem.\n
        \  The CMC Unsigned Data attribute contains information that is not\n   directly
        signed by a client.  When an RA encounters this attribute in\n   the unsigned
        or unauthenticated attribute field of a request it is\n   aggregating, the
        CMC Unsigned Data attribute is removed from the\n   request prior to placing
        the request in a cmsSequence and placed in\n   the unsigned or unauthenticated
        attributes of the RA's signed or\n   authenticated data wrapper.\n   The CMC
        Unsigned Data attribute is identified by:\n   id-aa-cmc-unsignedData OBJECT
        IDENTIFIER ::= {id-aa 34}\n   The CMC Unsigned Data attribute has the ASN.1
        definition:\n      CMCUnsignedData ::= SEQUENCE {\n          bodyPartPath
        \       BodyPartPath,\n          identifier          OBJECT IDENTIFIER,\n
        \         content             ANY DEFINED BY identifier\n      }\n   The fields
        in CMCUnsignedData have the following meaning:\n   bodyPartPath  is the path
        pointing to the control associated with\n      this data.  When an RA moves
        the control in an unsigned or\n      unauthenticated attribute up one level
        as part of wrapping the\n      data in a new SignedData or AuthenticatedData,
        the body part\n      identifier of the embedded item in the PKIData is prepended
        to the\n      bodyPartPath sequence.\n   identifier  is the OID that defines
        the associated data.\n   content  is the data.\n   There MUST be at most one
        CMC Unsigned Data attribute in the\n   UnsignedAttribute sequence of a SignerInfo
        or in the\n   UnauthenticatedAttribute sequence of an AuthenticatedData.\n
        \  UnsignedAttribute consists of a set of values; the attribute can have\n
        \  any number of values greater than zero in that set.  If the CMC\n   Unsigned
        Data attribute is in one SignerInfo or AuthenticatedData, it\n   MUST appear
        with the same values(s) in all SignerInfo and\n   AuthenticatedData items.\n"
      title: 3.2.3.  CMC Unsigned Data Attribute
    title: 3.2.  Full PKI Request
  title: 3.  PKI Requests
- contents:
  - "4.  PKI Responses\n   Two types of PKI Responses exist.  This section gives the
    details on\n   both types.\n"
  - contents:
    - "4.1.  Simple PKI Response\n   Clients MUST be able to process the Simple PKI
      Response.  The Simple\n   PKI Response consists of a SignedData with no EncapsulatedContentInfo\n
      \  and no SignerInfo.  The certificates requested in the PKI Response\n   are
      returned in the certificate field of the SignedData.\n   Clients MUST NOT assume
      the certificates are in any order.  Servers\n   SHOULD include all intermediate
      certificates needed to form complete\n   certification paths to one or more
      trust anchors, not just the newly\n   issued certificate(s).  The server MAY
      additionally return CRLs in\n   the CRL bag.  Servers MAY include the self-signed
      certificates.\n   Clients MUST NOT implicitly trust included self-signed certificate(s)\n
      \  merely due to its presence in the certificate bag.  In the event\n   clients
      receive a new self-signed certificate from the server,\n   clients SHOULD provide
      a mechanism to enable the user to use the\n   certificate as a trust anchor.
      \ (The Publish Trust Anchors control\n   (Section 6.15) should be used in the
      event that the server intends\n   the client to accept one or more certificates
      as trust anchors.  This\n   requires the use of the Full PKI Response message.)\n"
    title: 4.1.  Simple PKI Response
  - contents:
    - "4.2.  Full PKI Response\n   Clients MUST be able to process a Full PKI Response.\n
      \  The Full PKI Response consists of a SignedData or AuthenticatedData\n   encapsulating
      a PKIResponse content type.  The certificates issued in\n   a PKI Response are
      returned in the certificates field of the\n   immediately encapsulating SignedData.\n
      \  Clients MUST NOT assume the certificates are in any order.  Servers\n   SHOULD
      include all intermediate certificates needed to form complete\n   chains to
      one or more trust anchors, not just the newly issued\n   certificate(s).  The
      server MAY additionally return CRLs in the CRL\n   bag.  Servers MAY include
      self-signed certificates.  Clients MUST NOT\n   implicitly trust included self-signed
      certificate(s) merely due to\n   its presence in the certificate bag.  In the
      event clients receive a\n   new self-signed certificate from the server, clients
      MAY provide a\n   mechanism to enable the user to explicitly use the certificate
      as a\n   trust anchor.  (The Publish Trust Anchors control (Section 6.15)\n
      \  exists for the purpose of allowing for distribution of trust anchor\n   certificates.
      \ If a trusted anchor publishes a new trusted anchor,\n   this is one case where
      automated trust of the new trust anchor could\n   be allowed.)\n"
    - contents:
      - "4.2.1.  PKIResponse Content Type\n   The PKIResponse content type is used
        for the Full PKI Response.  The\n   PKIResponse content type is identified
        by:\n     id-cct-PKIResponse ::= {id-pkix id-cct(12) 3  }\n   The ASN.1 structure
        corresponding to the PKIResponse content type is:\n      PKIResponse ::= SEQUENCE
        {\n          controlSequence   SEQUENCE SIZE(0..MAX) OF TaggedAttribute,\n
        \         cmsSequence       SEQUENCE SIZE(0..MAX) OF TaggedContentInfo,\n
        \         otherMsgSequence  SEQUENCE SIZE(0..MAX) OF OtherMsg\n      }\n      ReponseBody
        ::= PKIResponse\n   Note: In [RFC2797], this ASN.1 type was named ResponseBody.
        \ It has\n   been renamed to PKIResponse for clarity and the old name kept
        as a\n   synonym.\n   The fields in PKIResponse have the following meaning:\n
        \  controlSequence  is a sequence of controls.  The controls defined in\n
        \     this document are found in Section 6.  Controls can be defined by\n
        \     other parties.  Details on the TaggedAttribute structure are found\n
        \     in Section 3.2.1.1.\n   cmsSequence  is a sequence of [CMS] message
        objects.  See\n      Section 3.2.1.3 for more details.\n   otherMsgSequence
        \ is a sequence of arbitrary data objects.  Data\n      objects placed here
        are referred to by one or more controls.  This\n      allows for controls
        to use large amounts of data without the data\n      being embedded in the
        control.  See Section 3.2.1.4 for more\n      details.\n   Processing of PKIResponse
        by a recipient is as follows:\n   1.  All controls should be examined and
        processed in an appropriate\n       manner.  The appropriate processing is
        to complete processing at\n       this time, to ignore the control, or to
        place the control on a\n       to-do list for later processing.\n   2.  Additional
        processing of non-element items includes the saving of\n       certificates
        and CRLs present in wrapping layers.  This type of\n       processing is based
        on the consumer of the element and should not\n       be relied on by generators.\n
        \  No processing is required for cmsSequence or otherMsgSequence members\n
        \  of the PKIResponse, if items are present and are not referenced by a\n
        \  control.  In this case, the cmsSequence and otherMsgSequence members\n
        \  are to be ignored.\n"
      title: 4.2.1.  PKIResponse Content Type
    title: 4.2.  Full PKI Response
  title: 4.  PKI Responses
- contents:
  - "5.  Application of Encryption to a PKI Request/Response\n   There are occasions
    when a PKI Request or Response must be encrypted\n   in order to prevent disclosure
    of information in the PKI Request/\n   Response from being accessible to unauthorized
    entities.  This\n   section describes the means to encrypt Full PKI Requests and\n
    \  Responses (Simple PKI Requests cannot be encrypted).  Data portions\n   of
    PKI Requests and Responses that are placed in the cmsSequence\n   field can be
    encrypted separately.\n   Confidentiality is provided by wrapping the PKI Request/Response
    (a\n   SignedData) in an EnvelopedData.  The nested content type in the\n   EnvelopedData
    is id-SignedData.  Note that this is different from\n   S/MIME where there is
    a MIME layer placed between the encrypted and\n   signed data.  It is recommended
    that if an EnvelopedData layer is\n   applied to a PKI Request/Response, a second
    signature layer be placed\n   outside of the EnvelopedData layer.  The following
    figure shows how\n   this nesting would be done:\n     Normal              Option
    1                  Option 2\n     ------              --------                  --------\n
    \    SignedData          EnvelopedData             SignedData\n      PKIData             SignedData
    \               EnvelopedData\n                           PKIData                   SignedData\n
    \                                                     PKIData\n   Note: PKIResponse
    can be substituted for PKIData in the above figure.\n   Options 1 and 2 prevent
    leakage of sensitive data by encrypting the\n   Full PKI Request/Response.  An
    RA that receives a PKI Request that it\n   cannot decrypt MAY reject the PKI Request
    unless it can process the\n   PKI Request without knowledge of the contents (i.e.,
    all it does is\n   amalgamate multiple PKI Requests and forward them to a server).\n
    \  After the RA removes the envelope and completes processing, it may\n   then
    apply a new EnvelopedData layer to protect PKI Requests for\n   transmission to
    the next processing agent.  Section 7 contains more\n   information about RA processing.\n
    \  Full PKI Requests/Responses can be encrypted or transmitted in the\n   clear.
    \ Servers MUST provide support for all three options.\n   Alternatively, an authenticated,
    secure channel could exist between\n   the parties that require confidentiality.
    \ Clients and servers MAY\n   use such channels instead of the technique described
    above to provide\n   secure, private communication of Simple and Full PKI Requests/\n
    \  Responses.\n"
  title: 5.  Application of Encryption to a PKI Request/Response
- contents:
  - "6.  Controls\n   Controls are carried as part of both Full PKI Requests and Responses.\n
    \  Each control is encoded as a unique OID followed by the data for the\n   control
    (see syntax in Section 3.2.1.1.  The encoding of the data is\n   based on the
    control.  Processing systems would first detect the OID\n   (TaggedAttribute attrType)
    and process the corresponding control\n   value (TaggedAttribute attrValues) prior
    to processing the message\n   body.\n   The OIDs are all defined under the following
    arc:\n      id-pkix OBJECT IDENTIFIER  ::= { iso(1) identified-organization(3)\n
    \          dod(6) internet(1) security(5) mechanisms(5) pkix(7) }\n      id-cmc
    OBJECT IDENTIFIER ::= { id-pkix 7 }\n   The following table lists the names, OID,
    and syntactic structure for\n   each of the controls described in this document.\n
    \   Identifier  Description       OID       ASN.1 Structure      Section\n    --------------------------------------------------------------------\n
    \   id-cmc-statusInfo            id-cmc 1   CMCStatusInfo        6.1.2\n    id-cmc-identification
    \       id-cmc 2   UTF8String           6.2.3\n    id-cmc-identityProof         id-cmc
    3   OCTET STRING         6.2.2\n    id-cmc-dataReturn            id-cmc 4   OCTET
    STRING         6.4\n    id-cmc-transactionId         id-cmc 5   INTEGER              6.6\n
    \   id-cmc-senderNonce           id-cmc 6   OCTET STRING         6.6\n    id-cmc-recipientNonce
    \       id-cmc 7   OCTET STRING         6.6\n    id-cmc-addExtensions         id-cmc
    8   AddExtensions        6.5.2\n    id-cmc-encryptedPOP          id-cmc 9   EncryptedPOP
    \        6.7\n    id-cmc-decryptedPOP          id-cmc 10  DecryptedPOP         6.7\n
    \   id-cmc-lraPOPWitness         id-cmc 11  LraPOPWitness        6.8\n    id-cmc-getCert
    \              id-cmc 15  GetCert              6.9\n    id-cmc-getCRL                id-cmc
    16  GetCRL               6.10\n    id-cmc-revokeRequest         id-cmc 17  RevokeRequest
    \       6.11\n    id-cmc-regInfo               id-cmc 18  OCTET STRING         6.12\n
    \   id-cmc-responseInfo          id-cmc 19  OCTET STRING         6.12\n    id-cmc-queryPending
    \         id-cmc 21  OCTET STRING         6.13\n    id-cmc-popLinkRandom         id-cmc
    22  OCTET STRING         6.3.1\n    id-cmc-popLinkWitness        id-cmc 23  OCTET
    STRING         6.3.1\n    id-cmc-popLinkWitnessV2      id-cmc 33  OCTET STRING
    \        6.3.1.1\n    id-cmc-confirmCertAcceptance id-cmc 24  CMCCertId            6.14\n
    \   id-cmc-statusInfoV2          id-cmc 25  CMCStatusInfoV2      6.1.1\n    id-cmc-trustedAnchors
    \       id-cmc 26  PublishTrustAnchors  6.15\n    id-cmc-authData              id-cmc
    27  AuthPublish          6.16\n    id-cmc-batchRequests         id-cmc 28  BodyPartList
    \        6.17\n    id-cmc-batchResponses        id-cmc 29  BodyPartList         6.17\n
    \   id-cmc-publishCert           id-cmc 30  CMCPublicationInfo   6.18\n    id-cmc-modCertTemplate
    \      id-cmc 31  ModCertTemplate      6.5.1\n    id-cmc-controlProcessed      id-cmc
    32  ControlsProcessed    6.19\n    id-cmc-identityProofV2       id-cmc 34  IdentityProofV2
    \     6.2.1\n                 Table 1: CMC Control Attributes\n"
  - contents:
    - "6.1.  CMC Status Info Controls\n   The CMC Status Info controls return information
      about the status of a\n   client/server request/response.  Two controls are
      described in this\n   section.  The Extended CMC Status Info control is the
      preferred\n   control; the CMC Status Info control is included for backwards\n
      \  compatibility with RFC 2797.\n   Servers MAY emit multiple CMC status info
      controls referring to a\n   single body part.  Clients MUST be able to deal
      with multiple CMC\n   status info controls in a PKI Response.  Servers MUST
      use the\n   Extended CMC Status Info control, but MAY additionally use the CMC\n
      \  Status Info control.  Clients MUST be able to process the Extended\n   CMC
      Status Info control.\n"
    - contents:
      - "6.1.1.  Extended CMC Status Info Control\n   The Extended CMC Status Info
        control is identified by the OID:\n      id-cmc-statusInfoV2 ::= { id-cmc
        25 }\n   The Extended CMC Status Info control has the ASN.1 definition:\n
        \  CMCStatusInfoV2 ::= SEQUENCE {\n      cMCStatus             CMCStatus,\n
        \     bodyList              SEQUENCE SIZE (1..MAX) OF BodyPartReference,\n
        \     statusString          UTF8String OPTIONAL,\n      otherInfo             OtherStatusInfo
        OPTIONAL\n   }\n   OtherStatusInfo ::= CHOICE {\n      failInfo              CMCFailInfo,\n
        \     pendInfo              PendInfo,\n      extendedFailInfo      ExtendedFailInfo\n
        \  }\n   PendInfo ::= SEQUENCE {\n      pendToken           OCTET STRING,\n
        \     pendTime            GeneralizedTime\n   }\n   ExtendedFailInfo ::= SEQUENCE
        {\n      failInfoOID            OBJECT IDENTIFIER,\n      failInfoValue          ANY
        DEFINED BY failInfoOID\n   }\n   BodyPartReference ::= CHOICE {\n      bodyPartID
        \          BodyPartID,\n      bodyPartPath         BodyPartPath\n   }\n   The
        fields in CMCStatusInfoV2 have the following meaning:\n   cMCStatus  contains
        the returned status value.  Details are in\n      Section 6.1.3.\n   bodyList
        \ identifies the controls or other elements to which the\n      status value
        applies.  If an error is returned for a Simple PKI\n      Request, this field
        is the bodyPartID choice of BodyPartReference\n      with the single integer
        of value 1.\n   statusString  contains additional description information.
        \ This\n      string is human readable.\n   otherInfo  contains additional
        information that expands on the CMC\n      status code returned in the cMCStatus
        field.\n   The fields in OtherStatusInfo have the following meaning:\n   failInfo
        \ is described in Section 6.1.4.  It provides an error code\n      that details
        what failure occurred.  This choice is present only\n      if cMCStatus contains
        the value failed.\n   pendInfo  contains information about when and how the
        client should\n      request the result of this request.  It is present when
        the\n      cMCStatus is either pending or partial. pendInfo uses the\n      structure
        PendInfo, which has the fields:\n      pendToken  is the token used in the
        Query Pending control\n         (Section 6.13).\n      pendTime  contains
        the suggested time the server wants to be\n         queried about the status
        of the certification request.\n   extendedFailInfo  includes application-dependent
        detailed error\n      information.  This choice is present only if cMCStatus
        contains\n      the value failed.  Caution should be used when defining new
        values\n      as they may not be correctly recognized by all clients and\n
        \     servers.  The CMCFailInfo value of internalCAError may be assumed\n
        \     if the extended error is not recognized.  This field uses the type\n
        \     ExtendedFailInfo.  ExtendedFailInfo has the fields:\n      failInfoOID
        \ contains an OID that is associated with a set of\n         extended error
        values.\n      failInfoValue  contains an extended error code from the defined\n
        \        set of extended error codes.\n   If the cMCStatus field is success,
        the Extended CMC Status Info\n   control MAY be omitted unless it is the only
        item in the response.\n"
      title: 6.1.1.  Extended CMC Status Info Control
    - contents:
      - "6.1.2.  CMC Status Info Control\n   The CMC Status Info control is identified
        by the OID:\n      id-cmc-statusInfo ::= { id-cmc 1 }\n   The CMC Status Info
        control has the ASN.1 definition:\n         CMCStatusInfo ::= SEQUENCE {\n
        \             cMCStatus           CMCStatus,\n              bodyList            BodyPartList,\n
        \             statusString        UTF8String OPTIONAL,\n              otherInfo
        \          CHOICE {\n                failInfo            CMCFailInfo,\n                pendInfo
        \           PendInfo } OPTIONAL\n         }\n   The fields in CMCStatusInfo
        have the following meaning:\n   cMCStatus  contains the returned status value.
        \ Details are in\n      Section 6.1.3.\n   bodyList  contains the list of
        controls or other elements to which\n      the status value applies.  If an
        error is being returned for a\n      Simple PKI Request, this field contains
        a single integer of value\n      1.\n   statusString  contains additional
        description information.  This\n      string is human readable.\n   otherInfo
        \ provides additional information that expands on the CMC\n      status code
        returned in the cMCStatus field.\n      failInfo  is described in Section
        6.1.4.  It provides an error\n         code that details what failure occurred.
        \ This choice is\n         present only if cMCStatus is failed.\n      pendInfo
        \ uses the PendInfo ASN.1 structure in Section 6.1.1.  It\n         contains
        information about when and how the client should\n         request results
        of this request.  The pendInfo field MUST be\n         populated for a cMCStatus
        value of pending or partial.  Further\n         details can be found in Section
        6.1.1 (Extended CMC Status Info\n         Control) and Section 6.13 (Query
        Pending Control ).\n   If the cMCStatus field is success, the CMC Status Info
        control MAY be\n   omitted unless it is the only item in the response.  If
        no status\n   exists for a Simple or Full PKI Request, then the value of success
        is\n   assumed.\n"
      title: 6.1.2.  CMC Status Info Control
    - contents:
      - "6.1.3.  CMCStatus Values\n   CMCStatus is a field in the Extended CMC Status
        Info and CMC Status\n   Info controls.  This field contains a code representing
        the success\n   or failure of a specific operation.  CMCStatus has the ASN.1\n
        \  structure:\n      CMCStatus ::= INTEGER {\n           success                (0),\n
        \          -- reserved            (1),\n           failed                 (2),\n
        \          pending                (3),\n           noSupport              (4),\n
        \          confirmRequired        (5),\n           popRequired            (6),\n
        \          partial                (7)\n      }\n   The values of CMCStatus
        have the following meaning:\n   success  indicates the request was granted
        or the action was\n      completed.\n   failed  indicates the request was
        not granted or the action was not\n      completed.  More information is included
        elsewhere in the\n      response.\n   pending  indicates the PKI Request has
        yet to be processed.  The\n      requester is responsible to poll back on
        this Full PKI request.\n      pending may only be returned for certification
        request operations.\n   noSupport  indicates the requested operation is not
        supported.\n   confirmRequired  indicates a Confirm Certificate Acceptance
        control\n      (Section 6.14) must be returned before the certificate can
        be\n      used.\n   popRequired  indicates a direct POP operation is required\n
        \     (Section 6.3.1.3).\n   partial  indicates a partial PKI Response is
        returned.  The requester\n      is responsible to poll back for the unfulfilled
        portions of the\n      Full PKI Request.\n"
      title: 6.1.3.  CMCStatus Values
    - contents:
      - "6.1.4.   CMCFailInfo\n   CMCFailInfo is a field in the Extended CMC Status
        Info and CMC Status\n   Info controls.  CMCFailInfo conveys more detailed
        information\n   relevant to the interpretation of a failure condition.  The\n
        \  CMCFailInfo has the following ASN.1 structure:\n      CMCFailInfo ::= INTEGER
        {\n           badAlg            (0),\n           badMessageCheck   (1),\n
        \          badRequest        (2),\n           badTime           (3),\n           badCertId
        \        (4),\n           unsupportedExt     (5),\n           mustArchiveKeys
        \  (6),\n           badIdentity       (7),\n           popRequired       (8),\n
        \          popFailed         (9),\n           noKeyReuse        (10),\n           internalCAError
        \  (11),\n           tryLater          (12),\n           authDataFail      (13)\n
        \     }\n   The values of CMCFailInfo have the following meanings:\n   badAlg
        \ indicates unrecognized or unsupported algorithm.\n   badMessageCheck  indicates
        integrity check failed.\n   badRequest  indicates transaction was not permitted
        or supported.\n   badTime  indicates message time field was not sufficiently
        close to\n      the system time.\n   badCertId  indicates no certificate could
        be identified matching the\n      provided criteria.\n   unsupportedExt  indicates
        a requested X.509 extension is not\n      supported by the recipient CA.\n
        \  mustArchiveKeys  indicates private key material must be supplied.\n   badIdentity
        \ indicates identification control failed to verify.\n   popRequired  indicates
        server requires a POP proof before issuing\n      certificate.\n   popFailed
        \ indicates POP processing failed.\n   noKeyReuse  indicates server policy
        does not allow key reuse.\n   internalCAError  indicates that the CA had an
        unknown internal\n      failure.\n   tryLater  indicates that the server is
        not accepting requests at this\n      time and the client should try at a
        later time.\n   authDataFail  indicates failure occurred during processing
        of\n      authenticated data.\n   If additional failure reasons are needed,
        they SHOULD use the\n   ExtendedFailureInfo item in the Extended CMC Status
        Info control.\n   However, for closed environments they can be defined using
        this type.\n   Such codes MUST be in the range from 1000 to 1999.\n"
      title: 6.1.4.   CMCFailInfo
    title: 6.1.  CMC Status Info Controls
  - contents:
    - "6.2.  Identification and Identity Proof Controls\n   Some CAs and RAs require
      that a proof-of-identity be included in a\n   certification request.  Many different
      ways of doing this exist with\n   different degrees of security and reliability.
      \ Most are familiar\n   with a bank's request to provide your mother's maiden
      name as a form\n   of identity proof.  The reasoning behind requiring a proof-of-\n
      \  identity can be found in Appendix C of [CRMF].\n   CMC provides a method
      to prove the client's identity based on a\n   client/server shared-secret.  If
      clients support the Full PKI\n   Request, clients MUST implement this method
      of identity proof\n   (Section 6.2.2).  Servers MUST provide this method, but
      MAY\n   additionally support bilateral methods of similar strength.\n   This
      document also provides an Identification control\n   (Section 6.2.3).  This
      control is a simple method to allow a client\n   to state who they are to the
      server.  Generally, a shared-secret AND\n   an identifier of that shared-secret
      are passed from the server to the\n   client.  The identifier is placed in the
      Identification control, and\n   the shared-secret is used to compute the Identity
      Proof control.\n"
    - contents:
      - "6.2.1.  Identity Proof Version 2 Control\n   The Identity Proof Version 2
        control is identified by the OID:\n      id-cmc-identityProofV2 ::= { id-cmc
        34 }\n   The Identity Proof Version 2 control has the ASN.1 definition:\n
        \     IdentifyProofV2 ::= SEQUENCE {\n          hashAlgID        AlgorithmIdentifier,\n
        \         macAlgID         AlgorithmIdentifier,\n          witness          OCTET
        STRING\n      }\n   The fields of IdentityProofV2 have the following meaning:\n
        \  hashAlgID  is the identifier and parameters for the hash algorithm\n      used
        to convert the shared-secret into a key for the MAC\n      algorithm.\n   macAlgID
        \ is the identifier and the parameters for the message\n      authentication
        code algorithm used to compute the value of the\n      witness field.\n   witness
        \ is the identity proof.\n   The required method starts with an out-of-band
        transfer of a token\n   (the shared-secret).  The shared-secret should be
        generated in a\n   random manner.  The distribution of this token is beyond
        the scope of\n   this document.  The client then uses this token for an identity
        proof\n   as follows:\n   1.  The PKIData reqSequence field (encoded exactly
        as it appears in\n       the Full PKI Request including the sequence type
        and length) is\n       the value to be validated.\n   2.  A hash of the shared-secret
        as a UTF8 string is computed using\n       hashAlgID.\n   3.  A MAC is then
        computed using the value produced in Step 1 as the\n       message and the
        value from Step 2 as the key.\n   4.  The result from Step 3 is then encoded
        as the witness value in\n       the Identity Proof Version 2 control.\n   When
        the server verifies the Identity Proof Version 2 control, it\n   computes
        the MAC value in the same way and compares it to the witness\n   value contained
        in the PKI Request.\n   If a server fails the verification of an Identity
        Proof Version 2\n   control, the CMCFailInfo value MUST be present in the
        Full PKI\n   Response and MUST have a value of badIdentity.\n   Reuse of the
        shared-secret on certification request retries allows\n   the client and server
        to maintain the same view of acceptable\n   identity proof values.  However,
        reuse of the shared-secret can\n   potentially open the door for some types
        of attacks.\n   Implementations MUST be able to support tokens at least 16
        characters\n   long.  Guidance on the amount of entropy actually obtained
        from a\n   given length token based on character sets can be found in Appendix
        A\n   of [PASSWORD].\n"
      title: 6.2.1.  Identity Proof Version 2 Control
    - contents:
      - "6.2.2.  Identity Proof Control\n   The Identity Proof control is identified
        by the OID:\n      id-cmc-identityProof ::= { id-cmc 3 }\n   The Identity
        Proof control has the ASN.1 definition:\n      IdentifyProof ::= OCTET STRING\n
        \  This control is processed in the same way as the Identity Proof\n   Version
        2 control.  In this case, the hash algorithm is fixed to\n   SHA-1 and the
        MAC algorithm is fixed to HMAC-SHA1.\n"
      title: 6.2.2.  Identity Proof Control
    - contents:
      - "6.2.3.  Identification Control\n   Optionally, servers MAY require the inclusion
        of the unprotected\n   Identification control with an Identification Proof
        control.  The\n   Identification control is intended to contain a text string
        that\n   assists the server in locating the shared-secret needed to validate\n
        \  the contents of the Identity Proof control.  If the Identification\n   control
        is included in the Full PKI Request, the derivation of the\n   key in Step
        2 (from Section 6.2.1) is altered so that the hash of the\n   concatenation
        of the shared-secret and the UTF8 identity value\n   (without the type and
        length bytes) are hashed rather than just the\n   shared-secret.\n   The Identification
        control is identified by the OID:\n      id-cmc-identification ::= { id-cmc
        2 }\n   The Identification control has the ASN.1 definition:\n      Identification
        ::= UTF8String\n"
      title: 6.2.3.  Identification Control
    - contents:
      - "6.2.4.  Hardware Shared-Secret Token Generation\n   The shared-secret between
        the EE and the server is sometimes computed\n   using a hardware device that
        generates a series of tokens.  The EE\n   can therefore prove its identity
        by transferring this token in plain\n   text along with a name string.  The
        above protocol can be used with a\n   hardware shared-secret token generation
        device by the following\n   modifications:\n   1.  The Identification control
        MUST be included and MUST contain the\n       hardware-generated token.\n
        \  2.  The shared-secret value used above is the same hardware-generated\n
        \      token.\n   3.  All certification requests MUST have a subject name,
        and the\n       subject name MUST contain the fields required to identify
        the\n       holder of the hardware token device.\n   4.  The entire certification
        request MUST be shrouded in some fashion\n       to prevent eavesdropping.
        \ Although the token is time critical,\n       an active eavesdropper cannot
        be permitted to extract the token\n       and submit a different certification
        request with the same token\n       value.\n"
      title: 6.2.4.  Hardware Shared-Secret Token Generation
    title: 6.2.  Identification and Identity Proof Controls
  - contents:
    - "6.3.  Linking Identity and POP Information\n   In a Full PKI Request, identity
      information about the client is\n   carried in the signature of the SignedData
      containing all of the\n   certification requests.  Proof-of-possession information
      for key\n   pairs, however, is carried separately for each PKCS #10 or CRMF\n
      \  certification request.  (For keys capable of generating a digital\n   signature,
      the POP is provided by the signature on the PKCS #10 or\n   CRMF request.  For
      encryption-only keys, the controls described in\n   Section 6.7 are used.)  In
      order to prevent substitution-style\n   attacks, the protocol must guarantee
      that the same entity generated\n   both the POP and proof-of-identity information.\n
      \  This section describes two mechanisms for linking identity and POP\n   information:
      witness values cryptographically derived from the\n   shared-secret (Section
      6.3.1.3) and shared-secret/subject\n   distinguished name (DN) matching (Section
      6.3.2).  Clients and\n   servers MUST support the witness value technique.  Clients
      and\n   servers MAY support shared-secret/subject DN matching or other\n   bilateral
      techniques of similar strength.  The idea behind both\n   mechanisms is to force
      the client to sign some data into each\n   certification request that can be
      directly associated with the\n   shared-secret; this will defeat attempts to
      include certification\n   requests from different entities in a single Full
      PKI Request.\n"
    - contents:
      - "6.3.1.  Cryptographic Linkage\n   The first technique that links identity
        and POP information forces\n   the client to include a piece of information
        cryptographically\n   derived from the shared-secret as a signed extension
        within each\n   certification request (PKCS #10 or CRMF).\n"
      - contents:
        - "6.3.1.1.  POP Link Witness Version 2 Controls\n   The POP Link Witness
          Version 2 control is identified by the OID:\n      id-cmc-popLinkWitnessV2
          ::= { id-cmc 33 }\n   The POP Link Witness Version 2 control has the ASN.1
          definition:\n      PopLinkWitnessV2 ::= SEQUENCE {\n          keyGenAlgorithm
          \  AlgorithmIdentifier,\n          macAlgorithm      AlgorithmIdentifier,\n
          \         witness           OCTET STRING\n      }\n   The fields of PopLinkWitnessV2
          have the following meanings:\n   keyGenAlgorithm  contains the algorithm
          used to generate the key for\n      the MAC algorithm.  This will generally
          be a hash algorithm, but\n      could be a more complex algorithm.\n   macAlgorithm
          \ contains the algorithm used to create the witness\n      value.\n   witness
          \ contains the computed witness value.\n   This technique is useful if null
          subject DNs are used (because, for\n   example, the server can generate
          the subject DN for the certificate\n   based only on the shared-secret).
          \ Processing begins when the client\n   receives the shared-secret out-of-band
          from the server.  The client\n   then computes the following values:\n   1.
          \ The client generates a random byte-string, R, which SHOULD be at\n       least
          512 bits in length.\n   2.  The key is computed from the shared-secret using
          the algorithm in\n       keyGenAlgorithm.\n   3.  A MAC is then computed
          over the random value produced in Step 1,\n       using the key computed
          in Step 2.\n   4.  The random value produced in Step 1 is encoded as the
          value of a\n       POP Link Random control.  This control MUST be included
          in the\n       Full PKI Request.\n   5.  The MAC value produced in Step
          3 is placed in either the POP Link\n       Witness control or the witness
          field of the POP Link Witness V2\n       control.\n       *  For CRMF, the
          POP Link Witness/POP Link Witness V2 control is\n          included in the
          controls field of the CertRequest structure.\n       *  For PKCS #10, the
          POP Link Witness/POP Link Witness V2 control\n          is included in the
          attributes field of the\n          CertificationRequestInfo structure.\n
          \  Upon receipt, servers MUST verify that each certification request\n   contains
          a copy of the POP Link Witness/POP Link Witness V2 control\n   and that
          its value was derived using the above method from the\n   shared-secret
          and the random string included in the POP Link Random\n   control.\n   The
          Identification control (see Section 6.2.3) or the subject DN of a\n   certification
          request can be used to help identify which shared-\n   secret was used.\n"
        title: 6.3.1.1.  POP Link Witness Version 2 Controls
      - contents:
        - "6.3.1.2.  POP Link Witness Control\n   The POP Link Witness control is
          identified by the OID:\n      id-cmc-popLinkWitness ::= { id-cmc 23 }\n
          \  The POP Link Witness control has the ASN.1 definition:\n      PopLinkWitness
          ::= OCTET STRING\n   For this control, SHA-1 is used as the key generation
          algorithm.\n   HMAC-SHA1 is used as the mac algorithm.\n"
        title: 6.3.1.2.  POP Link Witness Control
      - contents:
        - "6.3.1.3.  POP Link Random Control\n   The POP Link Random control is identified
          by the OID:\n      id-cmc-popLinkRandom  ::= { id-cmc 22 }\n   The POP Link
          Random control has the ASN.1 definition:\n      PopLinkRandom ::= OCTET
          STRING\n"
        title: 6.3.1.3.  POP Link Random Control
      title: 6.3.1.  Cryptographic Linkage
    - contents:
      - "6.3.2.  Shared-Secret/Subject DN Linking\n   The second technique to link
        identity and POP information is to link\n   a particular subject distinguished
        name (subject DN) to the shared-\n   secrets that are distributed out-of-band
        and to require that clients\n   using the shared-secret to prove identity
        include that exact subject\n   DN in every certification request.  It is expected
        that many client-\n   server connections that use shared-secret-based proof-of-identity\n
        \  will use this mechanism.  (It is common not to omit the subject DN\n   information
        from the certification request.)\n   When the shared-secret is generated and
        transferred out-of-band to\n   initiate the registration process (Section
        6.2), a particular subject\n   DN is also associated with the shared-secret
        and communicated to the\n   client.  (The subject DN generated MUST be unique
        per entity in\n   accordance with the CA policy; a null subject DN cannot
        be used.  A\n   common practice could be to place the identification value
        as part of\n   the subject DN.)  When the client generates the Full PKI Request,
        it\n   MUST use these two pieces of information as follows:\n   1.  The client
        MUST include the specific subject DN that it received\n       along with the
        shared-secret as the subject name in every\n       certification request (PKCS
        #10 and/or CRMF) in the Full PKI\n       Request.  The subject names in the
        certification requests MUST\n       NOT be null.\n   2.  The client MUST include
        an Identity Proof control (Section 6.2.2)\n       or Identity Proof Version
        2 control (Section 6.2.1), derived from\n       the shared-secret, in the
        Full PKI Request.\n   The server receiving this message MUST (a) validate
        the Identity\n   Proof control and then, (b) check that the subject DN included
        in\n   each certification request matches that associated with the shared-\n
        \  secret.  If either of these checks fails, the certification request\n   MUST
        be rejected.\n"
      title: 6.3.2.  Shared-Secret/Subject DN Linking
    - contents:
      - "6.3.3.  Renewal and Rekey Messages\n   When doing a renewal or rekey certification
        request, linking identity\n   and POP information is simple.  The client copies
        the subject DN for\n   a current signing certificate into the subject name
        field of each\n   certification request that is made.  The POP for each certification\n
        \  request will now cover that information.  The outermost signature\n   layer
        is created using the current signing certificate, which allows\n   the original
        identity to be associated with the certification\n   request.  Since the name
        in the current signing certificate and the\n   names in the certification
        requests match, the necessary linking has\n   been achieved.\n"
      title: 6.3.3.  Renewal and Rekey Messages
    title: 6.3.  Linking Identity and POP Information
  - contents:
    - "6.4.  Data Return Control\n   The Data Return control allows clients to send
      arbitrary data\n   (usually some type of internal state information) to the
      server and\n   to have the data returned as part of the Full PKI Response.  Data\n
      \  placed in a Data Return control is considered to be opaque to the\n   server.
      \ The same control is used for both Full PKI Requests and\n   Responses.  If
      the Data Return control appears in a Full PKI Request,\n   the server MUST return
      it as part of the PKI Response.\n   In the event that the information in the
      Data Return control needs to\n   be confidential, it is expected that the client
      would apply some type\n   of encryption to the contained data, but the details
      of this are\n   outside the scope of this specification.\n   The Data Return
      control is identified by the OID:\n      id-cmc-dataReturn  ::= { id-cmc 4 }\n
      \  The Data Return control has the ASN.1 definition:\n      DataReturn ::= OCTET
      STRING\n   A client could use this control to place an identifier marking the\n
      \  exact source of the private key material.  This might be the\n   identifier
      of a hardware device containing the private key.\n"
    title: 6.4.  Data Return Control
  - contents:
    - "6.5.  RA Certificate Modification Controls\n   These controls exist for RAs
      to be able to modify the contents of a\n   certification request.  Modifications
      might be necessary for various\n   reasons.  These include addition of certificate
      extensions or\n   modification of subject and/or subject alternative names.\n
      \  Two controls exist for this purpose.  The first control, Modify\n   Certification
      Request (Section 6.5.1), allows the RA to replace or\n   remove any field in
      the certificate.  The second control, Add\n   Extensions (Section 6.5.2), only
      allows for the addition of\n   extensions.\n"
    - contents:
      - "6.5.1.  Modify Certification Request Control\n   The Modify Certification
        Request control is used by RAs to change\n   fields in a requested certificate.\n
        \  The Modify Certification Request control is identified by the OID:\n      id-cmc-modCertTemplate
        \ ::= { id-cmc 31 }\n   The Modify Certification Request has the ASN.1 definition:\n
        \    ModCertTemplate ::= SEQUENCE {\n         pkiDataReference             BodyPartPath,\n
        \        certReferences               BodyPartList,\n         replace                      BOOLEAN
        DEFAULT TRUE,\n         certTemplate                 CertTemplate\n     }\n
        \  The fields in ModCertTemplate have the following meaning:\n   pkiDataReference
        \ is the path to the PKI Request containing\n      certification request(s)
        to be modified.\n   certReferences  refers to one or more certification requests
        in the\n      PKI Request referenced by pkiDataReference to be modified.  Each\n
        \     BodyPartID of the certReferences sequence MUST be equal to either\n
        \     the bodyPartID of a TaggedCertificationRequest (PKCS #10) or the\n      certReqId
        of the CertRequest within a CertReqMsg (CRMF).  By\n      definition, the
        certificate extensions included in the\n      certTemplate field are applied
        to every certification request\n      referenced in the certReferences sequence.
        \ If a request\n      corresponding to bodyPartID cannot be found, the CMCFailInfo
        with\n      a value of badRequest is returned that references this control.\n
        \  replace  specifies if the target certification request is to be\n      modified
        by replacing or deleting fields.  If the value is TRUE,\n      the data in
        this control replaces the data in the target\n      certification request.
        \ If the value is FALSE, the data in the\n      target certification request
        is deleted.  The action is slightly\n      different for the extensions field
        of certTemplate; each extension\n      is treated individually rather than
        as a single unit.\n   certTemplate  is a certificate template object [CRMF].
        \ If a field is\n      present and replace is TRUE, it replaces that field
        in the\n      certification request.  If the field is present and replace
        is\n      FALSE, the field in the certification request is removed.  If the\n
        \     field is absent, no action is performed.  Each extension is\n      treated
        as a single field.\n   Servers MUST be able to process all extensions defined,
        but not\n   prohibited, in [PKIXCERT].  Servers are not required to be able
        to\n   process every X.509v3 extension transmitted using this protocol, nor\n
        \  are they required to be able to process other, private extensions.\n   Servers
        are not required to put all RA-requested extensions into a\n   certificate.
        \ Servers are permitted to modify RA-requested\n   extensions.  Servers MUST
        NOT alter an extension so as to reverse the\n   meaning of a client-requested
        extension.  If a certification request\n   is denied due to the inability
        to handle a requested extension and a\n   Full PKI Response is returned, the
        server MUST return a CMCFailInfo\n   value with the value of unsupportedExt.\n
        \  If a certification request is the target of multiple Modify\n   Certification
        Request controls, the behavior is:\n   o  If control A exists in a layer that
        contains the layer of control\n      B, control A MUST override control B.
        \ In other words, controls\n      should be applied from the innermost layer
        to the outermost layer.\n   o  If control A and control B are in the same
        PKIData (i.e., the same\n      wrapping layer), the order of application is
        non-determinate.\n   The same order of application is used if a certification
        request is\n   the target of both a Modify Certification Request control and
        an Add\n   Extensions control.\n"
      title: 6.5.1.  Modify Certification Request Control
    - contents:
      - "6.5.2.  Add Extensions Control\n   The Add Extensions control has been deprecated
        in favor of the Modify\n   Certification Request control.  It was replaced
        so that fields in the\n   certification request other than extensions could
        be modified.\n   The Add Extensions control is used by RAs to specify additional\n
        \  extensions that are to be included in certificates.\n   The Add Extensions
        control is identified by the OID:\n      id-cmc-addExtensions  ::= { id-cmc
        8 }\n   The Add Extensions control has the ASN.1 definition:\n     AddExtensions
        ::= SEQUENCE {\n         pkiDataReference             BodyPartID,\n         certReferences
        \              SEQUENCE OF BodyPartID,\n         extensions                   SEQUENCE
        OF Extension\n     }\n   The fields in AddExtensions have the following meaning:\n
        \  pkiDataReference  contains the body part identity of the embedded\n      certification
        request.\n   certReferences  is a list of references to one or more of the\n
        \     certification requests contained within a PKIData.  Each body part\n
        \     identifier of the certReferences sequence MUST be equal to either\n
        \     the bodyPartID of a TaggedCertificationRequest (PKCS #10) or the\n      certReqId
        of the CertRequest within a CertReqMsg (CRMF).  By\n      definition, the
        listed extensions are to be applied to every\n      certification request
        referenced in the certReferences sequence.\n      If a certification request
        corresponding to bodyPartID cannot be\n      found, the CMCFailInfo with a
        value of badRequest is returned\n      referencing this control.\n   extensions
        \ is a sequence of extensions to be applied to the\n      referenced certification
        requests.\n   Servers MUST be able to process all extensions defined, but
        not\n   prohibited, in [PKIXCERT].  Servers are not required to be able to\n
        \  process every X.509v3 extension transmitted using this protocol, nor\n
        \  are they required to be able to process other, private extensions.\n   Servers
        are not required to put all RA-requested extensions into a\n   certificate.
        \ Servers are permitted to modify RA-requested\n   extensions.  Servers MUST
        NOT alter an extension so as to reverse the\n   meaning of a client-requested
        extension.  If a certification request\n   is denied due to the inability
        to handle a requested extension and a\n   response is returned, the server
        MUST return a CMCFailInfo with the\n   value of unsupportedExt.\n   If multiple
        Add Extensions controls exist in a Full PKI Request, the\n   exact behavior
        is left up to the CA policy.  However, it is\n   recommended that the following
        policy be used.  These rules would be\n   applied to individual extensions
        within an Add Extensions control (as\n   opposed to an \"all or nothing\"
        approach).\n   1.  If the conflict is within a single PKIData, the certification\n
        \      request would be rejected with a CMCFailInfo value of badRequest.\n
        \  2.  If the conflict is between different PKIData, the outermost\n       version
        of the extension would be used (allowing an RA to\n       override the requested
        extension).\n"
      title: 6.5.2.  Add Extensions Control
    title: 6.5.  RA Certificate Modification Controls
  - contents:
    - "6.6.  Transaction Identifier Control and Sender and Recipient Nonce\n      Controls\n
      \  Transactions are identified and tracked with a transaction\n   identifier.
      \ If used, clients generate transaction identifiers and\n   retain their value
      until the server responds with a Full PKI Response\n   that completes the transaction.
      \ Servers correspondingly include\n   received transaction identifiers in the
      Full PKI Response.\n   The Transaction Identifier control is identified by the
      OID:\n      id-cmc-transactionId  ::= { id-cmc 5 }\n   The Transaction Identifier
      control has the ASN.1 definition:\n      TransactionId ::= INTEGER\n   The Transaction
      Identifier control identifies a given transaction.\n   It is used by client
      and server to manage the state of an operation.\n   Clients MAY include a Transaction
      Identifier control in a request.\n   If the original request contains a Transaction
      Identifier control,\n   all subsequent requests and responses MUST include the
      same\n   Transaction Identifier control.\n   Replay protection is supported
      through the use of the Sender and\n   Recipient Nonce controls.  If nonces are
      used, in the first message\n   of a transaction, a Recipient Nonce control is
      not transmitted; a\n   Sender Nonce control is included by the transaction originator
      and\n   retained for later reference.  The recipient of a Sender Nonce\n   control
      reflects this value back to the originator as a Recipient\n   Nonce control
      and includes its own Sender Nonce control.  Upon\n   receipt by the transaction
      originator of this response, the\n   transaction originator compares the value
      of Recipient Nonce control\n   to its retained value.  If the values match,
      the message can be\n   accepted for further security processing.  The received
      value for a\n   Sender Nonce control is also retained for inclusion in the next\n
      \  message associated with the same transaction.\n   The Sender Nonce and Recipient
      Nonce controls are identified by the\n   OIDs:\n      id-cmc-senderNonce     ::=
      { id-cmc 6 }\n      id-cmc-recipientNonce  ::= { id-cmc 7 }\n   The Sender Nonce
      control has the ASN.1 definition:\n      SenderNonce ::= OCTET STRING\n   The
      Recipient Nonce control has the ASN.1 definition:\n      RecipientNonce ::=
      OCTET STRING\n   Clients MAY include a Sender Nonce control in the initial PKI\n
      \  Request.  If a message includes a Sender Nonce control, the response\n   MUST
      include the transmitted value of the previously received Sender\n   Nonce control
      as a Recipient Nonce control and include a new value as\n   its Sender Nonce
      control.\n"
    title: 6.6.  Transaction Identifier Control and Sender and Recipient Nonce
  - contents:
    - "6.7.  Encrypted and Decrypted POP Controls\n   Servers MAY require that this
      POP method be used only if another POP\n   method is unavailable.  Servers SHOULD
      reject all certification\n   requests contained within a PKIData if any required
      POP is missing\n   for any element within the PKIData.\n   Many servers require
      proof that the entity that generated the\n   certification request actually
      possesses the corresponding private\n   component of the key pair.  For keys
      that can be used as signature\n   keys, signing the certification request with
      the private key serves\n   as a POP on that key pair.  With keys that can only
      be used for\n   encryption operations, POP MUST be performed by forcing the
      client to\n   decrypt a value.  See Section 5 of [CRMF] for a detailed discussion\n
      \  of POP.\n   By necessity, POP for encryption-only keys cannot be done in
      one\n   round-trip, since there are four distinct steps:\n   1.  Client tells
      the server about the public component of a new\n       encryption key pair.\n
      \  2.  Server sends the client a POP challenge, encrypted with the\n       presented
      public encryption key.\n   3.  Client decrypts the POP challenge using the private
      key that\n       corresponds to the presented public key and sends the plaintext\n
      \      back to the server.\n   4.  Server validates the decrypted POP challenge
      and continues\n       processing the certification request.\n   CMC defines
      two different controls.  The first deals with the\n   encrypted challenge sent
      from the server to the user in Step 2.  The\n   second deals with the decrypted
      challenge sent from the client to the\n   server in Step 3.\n   The Encrypted
      POP control is used to send the encrypted challenge\n   from the server to the
      client as part of the PKIResponse.  (Note that\n   it is assumed that the message
      sent in Step 1 above is a Full PKI\n   Request and that the response in Step
      2 is a Full PKI Response\n   including a CMCFailInfo specifying that a POP is
      explicitly required,\n   and providing the POP challenge in the encryptedPOP
      control.)\n   The Encrypted POP control is identified by the OID:\n      id-cmc-encryptedPOP
      \    ::= { id-cmc 9 }\n   The Encrypted POP control has the ASN.1 definition:\n
      \     EncryptedPOP ::= SEQUENCE {\n           request        TaggedRequest,\n
      \          cms            ContentInfo,\n           thePOPAlgID    AlgorithmIdentifier,\n
      \          witnessAlgID   AlgorithmIdentifier,\n           witness        OCTET
      STRING\n      }\n   The Decrypted POP control is identified by the OID:\n      id-cmc-decryptedPOP
      \    ::= { id-cmc 10 }\n   The Decrypted POP control has the ASN.1 definition:\n
      \     DecryptedPOP ::= SEQUENCE {\n           bodyPartID     BodyPartID,\n           thePOPAlgID
      \   AlgorithmIdentifier,\n           thePOP         OCTET STRING\n      }\n
      \  The encrypted POP algorithm works as follows:\n   1.  The server randomly
      generates the POP Proof Value and associates\n       it with the request.\n
      \  2.  The server returns the Encrypted POP control with the following\n       fields
      set:\n       request  is the original certification request (it is included\n
      \         here so the client need not keep a copy of the request).\n       cms
      \ is an EnvelopedData, the encapsulated content type being id-\n          data
      and the content being the POP Proof Value; this value\n          needs to be
      long enough that one cannot reverse the value from\n          the witness hash.
      \ If the certification request contains a\n          Subject Key Identifier
      (SKI) extension, then the recipient\n          identifier SHOULD be the SKI.
      \ If the issuerAndSerialNumber\n          form is used, the IssuerName MUST
      be encoded as NULL and the\n          SerialNumber as the bodyPartID of the
      certification request.\n       thePOPAlgID  identifies the algorithm to be used
      in computing the\n          return POP value.\n       witnessAlgID  identifies
      the hash algorithm used on the POP Proof\n          Value to create the field
      witness.\n       witness  is the hashed value of the POP Proof Value.\n   3.
      \ The client decrypts the cms field to obtain the POP Proof Value.\n       The
      client computes H(POP Proof Value) using the witnessAlgID and\n       compares
      to the value of witness.  If the values do not compare\n       or the decryption
      is not successful, the client MUST abort the\n       enrollment process.  The
      client aborts the process by sending a\n       request containing a CMC Status
      Info control with CMCFailInfo\n       value of popFailed.\n   4.  The client
      creates the Decrypted POP control as part of a new\n       PKIData.  The fields
      in the DecryptedPOP are:\n       bodyPartID  refers to the certification request
      in the new PKI\n          Request.\n       thePOPAlgID  is copied from the encryptedPOP.\n
      \      thePOP  contains the possession proof.  This value is computed by\n          thePOPAlgID
      using the POP Proof Value and the request.\n   5.  The server then re-computes
      the value of thePOP from its cached\n       value and the request and compares
      to the value of thePOP.  If\n       the values do not match, the server MUST
      NOT issue the\n       certificate.  The server MAY re-issue a new challenge
      or MAY fail\n       the request altogether.\n   When defining the algorithms
      for thePOPAlgID and witnessAlgID, care\n   must be taken to ensure that the
      result of witnessAlgID is not a\n   useful value to shortcut the computation
      with thePOPAlgID.  The POP\n   Proof Value is used as the secret value in the
      HMAC algorithm and the\n   request is used as the data.  If the POP Proof Value
      is greater than\n   64 bytes, only the first 64 bytes of the POP Proof Value
      is used as\n   the secret.\n   One potential problem with the algorithm above
      is the amount of state\n   that a CA needs to keep in order to verify the returned
      POP value.\n   The following describes one of many possible ways of addressing
      the\n   problem by reducing the amount of state kept on the CA to a single\n
      \  (or small set) of values.\n   1.  Server generates random seed x, constant
      across all requests.\n       (The value of x would normally be altered on a
      regular basis and\n       kept for a short time afterwards.)\n   2.  For certification
      request R, server computes y = F(x,R).  F can\n       be, for example, HMAC-SHA1(x,R).
      \ All that's important for\n       statelessness is that y be consistently computable
      with only\n       known state constant x and function F, other inputs coming
      from\n       the certification request structure. y should not be predictable\n
      \      based on knowledge of R, thus the use of a one-way function like\n       HMAC-SHA1.\n"
    title: 6.7.  Encrypted and Decrypted POP Controls
  - contents:
    - "6.8.  RA POP Witness Control\n   In a certification request scenario that involves
      an RA, the CA may\n   allow (or require) that the RA perform the POP protocol
      with the\n   entity that generated the certification request.  In this case,
      the\n   RA needs a way to inform the CA that it has done the POP.  The RA POP\n
      \  Witness control addresses this issue.\n   The RA POP Witness control is identified
      by the OID:\n      id-cmc-lraPOPWitness     ::= { id-cmc 11 }\n   The RA POP
      Witness control has the ASN.1 definition:\n      LraPopWitness ::= SEQUENCE
      {\n          pkiDataBodyid   BodyPartID,\n          bodyIds         SEQUENCE
      of BodyPartID\n      }\n   The fields in LraPOPWitness have the following meaning:\n
      \  pkiDataBodyid  contains the body part identifier of the nested\n      TaggedContentInfo
      containing the client's Full PKI Request.\n      pkiDataBodyid is set to 0 if
      the request is in the current\n      PKIData.\n   bodyIds  is a list of certification
      requests for which the RA has\n      performed an out-of-band authentication.
      \ The method of\n      authentication could be archival of private key material,\n
      \     challenge-response, or other means.\n   If a certification server does
      not allow an RA to do the POP\n   verification, it returns a CMCFailInfo with
      the value of popFailed.\n   The CA MUST NOT start a challenge-response to re-verify
      the POP\n   itself.\n"
    title: 6.8.  RA POP Witness Control
  - contents:
    - "6.9.  Get Certificate Control\n   Everything described in this section is optional
      to implement.\n   The Get Certificate control is used to retrieve a previously
      issued\n   certificate from a certificate repository.  A CA, an RA, or an\n
      \  independent service may provide this repository.  The clients\n   expected
      to use this facility are those where a fully deployed\n   directory is either
      infeasible or undesirable.\n   The Get Certificate control is identified by
      the OID:\n      id-cmc-getCert     ::= { id-cmc 15 }\n   The Get Certificate
      control has the ASN.1 definition:\n      GetCert ::= SEQUENCE {\n          issuerName
      \   GeneralName,\n          serialNumber  INTEGER }\n   The fields in GetCert
      have the following meaning:\n   issuerName  is the name of the certificate issuer.\n
      \  serialNumber  identifies the certificate to be retrieved.\n   The server
      that responds to this request places the requested\n   certificate in the certificates
      field of a SignedData.  If the Get\n   Certificate control is the only control
      in a Full PKI Request, the\n   response should be a Simple PKI Response.\n"
    title: 6.9.  Get Certificate Control
  - contents:
    - "6.10.  Get CRL Control\n   Everything described in this section is optional
      to implement.\n   The Get CRL control is used to retrieve CRLs from a repository
      of\n   CRLs.  A CA, an RA, or an independent service may provide this\n   repository.
      \ The clients expected to use this facility are those\n   where a fully deployed
      directory is either infeasible or undesirable.\n   The Get CRL control is identified
      by the OID:\n      id-cmc-getCRL     ::= { id-cmc 16 }\n   The Get CRL control
      has the ASN.1 definition:\n      GetCRL ::= SEQUENCE {\n          issuerName
      \   Name,\n          cRLName       GeneralName OPTIONAL,\n          time          GeneralizedTime
      OPTIONAL,\n          reasons       ReasonFlags OPTIONAL }\n   The fields in
      a GetCRL have the following meanings:\n   issuerName  is the name of the CRL
      issuer.\n   cRLName  may be the value of CRLDistributionPoints in the subject\n
      \     certificate or equivalent value in the event the certificate does\n      not
      contain such a value.\n   time  is used by the client to specify from among
      potentially several\n      issues of CRL that one whose thisUpdate value is
      less than but\n      nearest to the specified time.  In the absence of a time\n
      \     component, the CA always returns with the most recent CRL.\n   reasons
      \ is used to specify from among CRLs partitioned by revocation\n      reason.
      \ Implementers should bear in mind that while a specific\n      revocation request
      has a single CRLReason code -- and consequently\n      entries in the CRL would
      have a single CRLReason code value -- a\n      single CRL can aggregate information
      for one or more reasonFlags.\n   A server responding to this request places
      the requested CRL in the\n   crls field of a SignedData.  If the Get CRL control
      is the only\n   control in a Full PKI Request, the response should be a Simple
      PKI\n   Response.\n"
    title: 6.10.  Get CRL Control
  - contents:
    - "6.11.  Revocation Request Control\n   The Revocation Request control is used
      to request that a certificate\n   be revoked.\n   The Revocation Request control
      is identified by the OID:\n      id-cmc-revokeRequest ::= { id-cmc 17 }\n   The
      Revocation Request control has the ASN.1 definition:\n      RevokeRequest ::=
      SEQUENCE {\n          issuerName      Name,\n          serialNumber    INTEGER,\n
      \         reason          CRLReason,\n          invalidityDate  GeneralizedTime
      OPTIONAL,\n          sharedSecret    OCTET STRING OPTIONAL,\n          comment
      \        UTF8string OPTIONAL }\n   The fields of RevokeRequest have the following
      meaning:\n   issuerName  is the issuerName of the certificate to be revoked.\n
      \  serialNumber  is the serial number of the certificate to be revoked.\n   reason
      \ is the suggested CRLReason code for why the certificate is\n      being revoked.
      \ The CA can use this value at its discretion in\n      building the CRL.\n
      \  invalidityDate  is the suggested value for the Invalidity Date CRL\n      Extension.
      \ The CA can use this value at its discretion in\n      building the CRL.\n
      \  sharedSecret  is a secret value registered by the EE when the\n      certificate
      was obtained to allow for revocation of a certificate\n      in the event of
      key loss.\n   comment  is a human-readable comment.\n   For a revocation request
      to be reliable in the event of a dispute, a\n   strong proof-of-origin is required.
      \ However, in the instance when an\n   EE has lost use of its signature private
      key, it is impossible for\n   the EE to produce a digital signature (prior to
      the certification of\n   a new signature key pair).  The Revoke Request control
      allows the EE\n   to send the CA a shared-secret that may be used as an alternative\n
      \  authenticator in the instance of loss of use of the EE's signature\n   private
      key.  The acceptability of this practice is a matter of local\n   security policy.\n
      \  It is possible to sign the revocation for the lost certificate with a\n   different
      certificate in some circumstances.  A client can sign a\n   revocation for an
      encryption key with a signing certificate if the\n   name information matches.
      \ Similarly, an administrator or RA can be\n   assigned the ability to revoke
      the certificate of a third party.\n   Acceptance of the revocation by the server
      depends on local policy in\n   these cases.\n   Clients MUST provide the capability
      to produce a digitally signed\n   Revocation Request control.  Clients SHOULD
      be capable of producing\n   an unsigned Revocation Request control containing
      the EE shared-\n   secret (the unsigned message consisting of a SignedData with
      no\n   signatures).  If a client provides shared-secret-based self-\n   revocation,
      the client MUST be capable of producing a Revocation\n   Request control containing
      the shared-secret.  Servers MUST be\n   capable of accepting both forms of revocation
      requests.\n   The structure of an unsigned, shared-secret-based revocation request\n
      \  is a matter of local implementation.  The shared-secret does not need\n   to
      be encrypted when sent in a Revocation Request control.  The\n   shared-secret
      has a one-time use (i.e., it is used to request\n   revocation of the certificate),
      and public knowledge of the shared-\n   secret after the certificate has been
      revoked is not a problem.\n   Clients need to inform users that the same shared-secret
      SHOULD NOT\n   be used for multiple certificates.\n   A Full PKI Response MUST
      be returned for a revocation request.\n"
    title: 6.11.  Revocation Request Control
  - contents:
    - "6.12.  Registration and Response Information Controls\n   The Registration
      Information control allows for clients to pass\n   additional information as
      part of a Full PKI Request.\n   The Registration Information control is identified
      by the OID:\n      id-cmc-regInfo     ::= { id-cmc 18 }\n   The Registration
      Information control has the ASN.1 definition:\n      RegInfo ::= OCTET STRING\n
      \  The content of this data is based on bilateral agreement between the\n   client
      and server.\n   The Response Information control allows a server to return additional\n
      \  information as part of a Full PKI Response.\n   The Response Information
      control is identified by the OID:\n      id-cmc-responseInfo     ::= { id-cmc
      19 }\n   The Response Information control has the ASN.1 definition:\n      ResponseInfo
      ::= OCTET STRING\n   The content of this data is based on bilateral agreement
      between the\n   client and server.\n"
    title: 6.12.  Registration and Response Information Controls
  - contents:
    - "6.13.  Query Pending Control\n   In some environments, process requirements
      for manual intervention or\n   other identity checks can delay the return of
      the certificate.  The\n   Query Pending control allows clients to query a server
      about the\n   state of a pending certification request.  The server returns
      a\n   pendToken as part of the Extended CMC Status Info and the CMC Status\n
      \  Info controls (in the otherInfo field).  The client copies the\n   pendToken
      into the Query Pending control to identify the correct\n   certification request
      to the server.  The server returns a suggested\n   time for the client to query
      for the state of a pending certification\n   request.\n   The Query Pending
      control is identified by the OID:\n      id-cmc-queryPending     ::= { id-cmc
      21 }\n   The Query Pending control has the ASN.1 definition:\n      QueryPending
      ::= OCTET STRING\n   If a server returns a pending or partial CMCStatusInfo
      (the\n   transaction is still pending), the otherInfo MAY be omitted.  If the\n
      \  otherInfo is not omitted, the value of 'pendInfo' MUST be the same as\n   the
      original pendInfo value.\n"
    title: 6.13.  Query Pending Control
  - contents:
    - "6.14.  Confirm Certificate Acceptance Control\n   Some CAs require that clients
      give a positive confirmation that the\n   certificates issued to the EE are
      acceptable.  The Confirm\n   Certificate Acceptance control is used for that
      purpose.  If the CMC\n   Status Info on a PKI Response is confirmRequired, then
      the client\n   MUST return a Confirm Certificate Acceptance control contained
      in a\n   Full PKI Request.\n   Clients SHOULD wait for the PKI Response from
      the server that the\n   confirmation has been received before using the certificate
      for any\n   purpose.\n   The Confirm Certificate Acceptance control is identified
      by the OID:\n      id-cmc-confirmCertAcceptance     ::= { id-cmc 24 }\n   The
      Confirm Certificate Acceptance control has the ASN.1 definition:\n      CMCCertId
      ::= IssuerAndSerialNumber\n   CMCCertId contains the issuer and serial number
      of the certificate\n   being accepted.\n   Servers MUST return a Full PKI Response
      for a Confirm Certificate\n   Acceptance control.\n   Note that if the CA includes
      this control, there will be two full\n   round-trips of messages.\n   1.  The
      client sends the certification request to the CA.\n   2.  The CA returns a Full
      PKI Response with the certificate and this\n       control.\n   3.  The client
      sends a Full PKI Request to the CA with an Extended\n       CMC Status Info
      control accepting and a Confirm Certificate\n       Acceptance control or an
      Extended CMC Status Info control\n       rejecting the certificate.\n   4.  The
      CA sends a Full PKI Response to the client with an Extended\n       CMC Status
      Info of success.\n"
    title: 6.14.  Confirm Certificate Acceptance Control
  - contents:
    - "6.15.  Publish Trust Anchors Control\n   The Publish Trust Anchors control
      allows for the distribution of set\n   trust anchors from a central authority
      to an EE.  The same control is\n   also used to update the set of trust anchors.
      \ Trust anchors are\n   distributed in the form of certificates.  These are
      expected, but not\n   required, to be self-signed certificates.  Information
      is extracted\n   from these certificates to set the inputs to the certificates\n
      \  validation algorithm in Section 6.1.1 of [PKIXCERT].\n   The Publish Trust
      Anchors control is identified by the OID:\n      id-cmc-trustedAnchors     ::=
      { id-cmc 26 }\n   The Publish Trust Anchors control has the ASN.1 definition:\n
      \      PublishTrustAnchors ::= SEQUENCE {\n           seqNumber      INTEGER,\n
      \          hashAlgorithm  AlgorithmIdentifier,\n           anchorHashes   SEQUENCE
      OF OCTET STRING\n       }\n   The fields in PublishTrustAnchors have the following
      meaning:\n   seqNumber  is an integer indicating the location within a sequence
      of\n      updates.\n   hashAlgorithm  is the identifier and parameters for the
      hash\n      algorithm that is used in computing the values of the anchorHashes\n
      \     field.  All implementations MUST implement SHA-1 for this field.\n   anchorHashes
      \ are the hashes for the certificates that are to be\n      treated as trust
      anchors by the client.  The actual certificates\n      are transported in the
      certificate bag of the containing\n      SignedData structure.\n   While it
      is recommended that the sender place the certificates that\n   are to be trusted
      in the PKI Response, it is not required as the\n   certificates should be obtainable
      using normal discovery techniques.\n   Prior to accepting the trust anchors
      changes, a client MUST at least\n   do the following: validate the signature
      on the PKI Response to a\n   current trusted anchor, check with policy to ensure
      that the signer\n   is permitted to use the control, validate that the authenticated\n
      \  publish time in the signature is near to the current time, and\n   validate
      that the sequence number is greater than the previously used\n   one.\n   In
      the event that multiple agents publish a set of trust anchors, it\n   is up
      to local policy to determine how the different trust anchors\n   should be combined.
      \ Clients SHOULD be able to handle the update of\n   multiple trust anchors
      independently.\n   Note: Clients that handle this control must use extreme care
      in\n   validating that the operation is permissible.  Incorrect handling of\n
      \  this control allows for an attacker to change the set of trust\n   anchors
      on the client.\n"
    title: 6.15.  Publish Trust Anchors Control
  - contents:
    - "6.16.  Authenticated Data Control\n   The Authenticated Data control allows
      a server to provide data back\n   to the client in an authenticated manner.
      \ This control uses the\n   Authenticated Data structure to allow for validation
      of the data.\n   This control is used where the client has a shared-secret and
      a\n   secret identifier with the server, but where a trust anchor has not\n
      \  yet been downloaded onto the client so that a signing certificate for\n   the
      server cannot be validated.  The specific case that this control\n   was created
      for use with is the Publish Trust Anchors control\n   (Section 6.15), but it
      may be used in other cases as well.\n   The Authenticated Data control is identified
      by the OID:\n      id-cmc-authData     ::= { id-cmc 27 }\n   The Authenticated
      Data control has the ASN.1 definition:\n      AuthPublish ::= BodyPartID\n   AuthPublish
      is a body part identifier that refers to a member of the\n   cmsSequence element
      for the current PKI Response or PKI Data.  The\n   cmsSequence element is AuthenticatedData.
      \ The encapsulated content\n   is an id-cct-PKIData.  The controls in the controlSequence
      need to be\n   processed if the authentication succeeds.  (One example is the\n
      \  Publish Trust Anchors control in Section 6.15.)\n   If the authentication
      operation fails, the CMCFailInfo authDataFail\n   is returned.\n"
    title: 6.16.  Authenticated Data Control
  - contents:
    - "6.17.  Batch Request and Response Controls\n   These controls allow for an
      RA to collect multiple requests together\n   into a single Full PKI Request
      and forward it to a CA.  The server\n   would then process the requests and
      return the results in a Full PKI\n   Response.\n   The Batch Request control
      is identified by the OID:\n       id-cmc-batchRequests  ::= {id-cmc 28}\n   The
      Batch Response control is identified by the OID:\n       id-cmc-batchResponses
      ::= {id-cmc 29}\n   Both the Batch Request and Batch Response controls have
      the ASN.1\n   definition:\n      BodyPartList ::= SEQUENCE of BodyPartID\n   The
      data associated with these controls is a set of body part\n   identifiers.  Each
      request/response is placed as an individual entry\n   in the cmcSequence of
      the new PKIData/PKIResponse.  The body part\n   identifiers of these entries
      are then placed in the body part list\n   associated with the control.\n   When
      a server processes a Batch Request control, it MAY return the\n   responses
      in one or more PKI Responses.  A CMCStatus value of partial\n   is returned
      on all but the last PKI Response.  The CMCStatus would be\n   success if the
      Batch Requests control was processed; the responses\n   are created with their
      own CMCStatus code.  Errors on individual\n   requests are not propagated up
      to the top level.\n   When a PKI Response with a CMCStatus value of partial
      is returned,\n   the Query Pending control (Section 6.13) is used to retrieve\n
      \  additional results.  The returned status includes a suggested time\n   after
      which the client should ask for the additional results.\n"
    title: 6.17.  Batch Request and Response Controls
  - contents:
    - "6.18.  Publication Information Control\n   The Publication Information control
      allows for modifying publication\n   of already issued certificates, both for
      publishing and removal from\n   publication.  A common usage for this control
      is to remove an\n   existing certificate from publication during a rekey operation.
      \ This\n   control should always be processed after the issuance of new\n   certificates
      and revocation requests.  This control should not be\n   processed if a certificate
      failed to be issued.\n   The Publication Information control is identified by
      the OID:\n      id-cmc-publishCert     ::= { id-cmc 30 }\n   The Publication
      Information control has the ASN.1 definition:\n     CMCPublicationInfo ::= SEQUENCE
      {\n           hashAlg     AlgorithmIdentifier,\n           certHashes      SEQUENCE
      of OCTET STRING,\n           pubInfo         PKIPublicationInfo\n     PKIPublicationInfo
      ::= SEQUENCE {\n           action     INTEGER {\n                        dontPublish
      (0),\n                        pleasePublish (1) },\n           pubInfos  SEQUENCE
      SIZE (1..MAX) OF SinglePubInfo OPTIONAL }\n             -- pubInfos MUST NOT
      be present if action is \"dontPublish\"\n             -- (if action is \"pleasePublish\"
      and pubInfos is omitted,\n             -- \"dontCare\" is assumed)\n      SinglePubInfo
      ::= SEQUENCE {\n            pubMethod    INTEGER {\n                dontCare
      \   (0),\n                x500        (1),\n                web         (2),\n
      \               ldap        (3) },\n            pubLocation  GeneralName OPTIONAL
      }\n             }\n   The fields in CMCPublicationInfo have the following meaning:\n
      \  hashAlg  is the algorithm identifier of the hash algorithm used to\n      compute
      the values in certHashes.\n   certHashes  are the hashes of the certificates
      for which publication\n      is to change.\n   pubInfo  is the information where
      and how the certificates should be\n      published.  The fields in pubInfo
      (taken from [CRMF]) have the\n      following meanings:\n      action  indicates
      the action the service should take.  It has two\n         values:\n         dontPublish
      \ indicates that the PKI should not publish the\n            certificate (this
      may indicate that the requester intends to\n            publish the certificate
      him/herself). dontPublish has the\n            added connotation of removing
      from publication the\n            certificate if it is already published.\n
      \        pleasePublish  indicates that the PKI MAY publish the\n            certificate
      using whatever means it chooses unless pubInfos\n            is present.  Omission
      of the CMC Publication Info control\n            results in the same behavior.\n
      \     pubInfos  pubInfos indicates how (e.g., X500, Web, IP Address) the\n         PKI
      SHOULD publish the certificate.\n   A single certificate SHOULD NOT appear in
      more than one Publication\n   Information control.  The behavior is undefined
      in the event that it\n   does.\n"
    title: 6.18.  Publication Information Control
  - contents:
    - "6.19.  Control Processed Control\n   The Control Processed control allows an
      RA to indicate to subsequent\n   control processors that a specific control
      has already been\n   processed.  This permits an RA in the middle of a processing
      stream\n   to process a control defined either in a local context or in a\n
      \  subsequent document.\n   The Control Processed control is identified by the
      OID:\n      id-cmc-controlProcessed     ::= { id-cmc 32 }\n   The Control Processed
      control has the ASN.1 definition:\n       ControlList ::= SEQUENCE {\n           bodyList
      \       SEQUENCE SIZE (1..MAX) OF BodyPartReference\n       }\n   bodyList  is
      a series of body part identifiers that form a path to\n      each of the controls
      that were processed by the RA.  This control\n      is only needed for those
      controls that are not part of this\n      standard and thus would cause an error
      condition of a server\n      attempting to deal with a control not defined in
      this document.\n      No error status is needed since an error causes the RA
      to return\n      the request to the client with the error rather than passing
      the\n      request on to the next server in the processing list.\n"
    title: 6.19.  Control Processed Control
  title: 6.  Controls
- contents:
  - "7.  Registration Authorities\n   This specification permits the use of RAs.  An
    RA sits between the EE\n   and the CA.  From the EE's perspective, the RA appears
    to be the CA,\n   and from the server, the RA appears to be a client.  RAs receive
    the\n   PKI Requests, perform local processing and then forward them onto\n   CAs.
    \ Some of the types of local processing that an RA can perform\n   include:\n
    \  o  Batching multiple PKI Requests together,\n   o  Performing challenge/response
    POP proofs,\n   o  Adding private or standardized certificate extensions to all\n
    \     certification requests,\n   o  Archiving private key material,\n   o  Routing
    requests to different CAs.\n   When an RA receives a PKI Request, it has three
    options: it may\n   forward the PKI Request without modification, it may add a
    new\n   wrapping layer to the PKI Request, or it may remove one or more\n   existing
    layers and add a new wrapping layer.\n   When an RA adds a new wrapping layer
    to a PKI Request, it creates a\n   new PKIData.  The new layer contains any controls
    required (for\n   example, if the RA does the POP proof for an encryption key
    or the\n   Add Extension control to modify a PKI Request) and the client PKI\n
    \  Request.  The client PKI Request is placed in the cmsSequence if it\n   is
    a Full PKI Request and in the reqSequence if it is a Simple PKI\n   Request.  If
    an RA is batching multiple client PKI Requests together,\n   then each client
    PKI Request is placed into the appropriate location\n   in the RA's PKIData object
    along with all relevant controls.\n   If multiple RAs are in the path between
    the EE and the CA, this will\n   lead to multiple wrapping layers on the request.\n
    \  In processing a PKI Request, an RA MUST NOT alter any certification\n   requests
    (PKCS #10 or CRMF) as any alteration would invalidate the\n   signature on the
    certification request and thus the POP for the\n   private key.\n   An example
    of how this would look is illustrated by the following\n   figure:\n      SignedData
    (by RA)\n        PKIData\n          controlSequence\n               RA added control
    statements\n          reqSequence\n               Zero or more Simple PKI Requests
    from clients\n          cmsSequence\n               Zero or more Full PKI Requests
    from clients\n                  SignedData (signed by client)\n                      PKIData\n
    \  Under some circumstances, an RA is required to remove wrapping\n   layers.
    \ The following sections look at the processing required if\n   encryption layers
    and signing layers need to be removed.\n"
  - contents:
    - "7.1.  Encryption Removal\n   There are two cases that require an RA to remove
      or change encryption\n   in a PKI Request.  In the first case, the encryption
      was applied for\n   the purposes of protecting the entire PKI Request from unauthorized\n
      \  entities.  If the CA does not have a Recipient Info entry in the\n   encryption
      layer, the RA MUST remove the encryption layer.  The RA\n   MAY add a new encryption
      layer with or without adding a new signing\n   layer.\n   The second change
      of encryption that may be required is to change the\n   encryption inside of
      a signing layer.  In this case, the RA MUST\n   remove all signing layers containing
      the encryption.  All control\n   statements MUST be merged according to local
      policy rules as each\n   signing layer is removed and the resulting merged controls
      MUST be\n   placed in a new signing layer provided by the RA.  If the signing\n
      \  layer provided by the EE needs to also be removed, the RA can also\n   remove
      this layer.\n"
    title: 7.1.  Encryption Removal
  - contents:
    - "7.2.  Signature Layer Removal\n   Only two instances exist where an RA should
      remove a signature layer\n   on a Full PKI Request: if an encryption layer needs
      to be modified\n   within the request, or if a CA will not accept secondary
      delegation\n   (i.e., multiple RA signatures).  In all other situations, RAs
      SHOULD\n   NOT remove a signing layer from a PKI Request.\n   If an RA removes
      a signing layer from a PKI Request, all control\n   statements MUST be merged
      according to local policy rules.  The\n   resulting merged control statements
      MUST be placed in a new signing\n   layer provided by the RA.\n"
    title: 7.2.  Signature Layer Removal
  title: 7.  Registration Authorities
- contents:
  - "8.  Security Considerations\n   Mechanisms for thwarting replay attacks may be
    required in particular\n   implementations of this protocol depending on the operational\n
    \  environment.  In cases where the CA maintains significant state\n   information,
    replay attacks may be detectable without the inclusion\n   of the optional nonce
    mechanisms.  Implementers of this protocol need\n   to carefully consider environmental
    conditions before choosing\n   whether or not to implement the senderNonce and
    recipientNonce\n   controls described in Section 6.6.  Developers of state-constrained\n
    \  PKI clients are strongly encouraged to incorporate the use of these\n   controls.\n
    \  Extreme care needs to be taken when archiving a signing key.  The\n   holder
    of the archived key may have the ability to use the key to\n   generate forged
    signatures.  There are however reasons why a signing\n   key should be archived.
    \ An archived CA signing key can be recovered\n   in the event of failure to continue
    to produced CRLs following a\n   disaster.\n   Due care must be taken prior to
    archiving keys.  Once a key is given\n   to an archiving entity, the archiving
    entity could use the keys in a\n   way not conducive to the archiving entity.
    \ Users should be made\n   especially aware that proper verification is made of
    the certificate\n   used to encrypt the private key material.\n   Clients and
    servers need to do some checks on cryptographic\n   parameters prior to issuing
    certificates to make sure that weak\n   parameters are not used.  A description
    of the small subgroup attack\n   is provided in [X942].  Methods of avoiding the
    small subgroup attack\n   can be found in [SMALL-GROUP].  CMC implementations
    ought to be aware\n   of this attack when doing parameter validations.\n   When
    using a shared-secret for authentication purposes, the shared-\n   secret should
    be generated using good random number techniques\n   [RANDOM].  User selection
    of the secret allows for dictionary attacks\n   to be mounted.\n   Extreme care
    must be used when processing the Publish Trust Anchors\n   control.  Incorrect
    processing can lead to the practice of slamming\n   where an attacker changes
    the set of trusted anchors in order to\n   weaken security.\n   One method of
    controlling the use of the Publish Trust Anchors\n   control is as follows.  The
    client needs to associate with each trust\n   anchor accepted by the client the
    source of the trust anchor.\n   Additionally, the client should associate with
    each trust anchor the\n   types of messages for which the trust anchor is valid
    (i.e., is the\n   trust anchor used for validating S/MIME messages, TLS, or CMC\n
    \  enrollment messages?).\n   When a new message is received with a Publish Trust
    Anchors control,\n   the client would accept the set of new trust anchors for
    specific\n   applications only if the signature validates, the signer of the\n
    \  message has the required policy approval for updating the trust\n   anchors,
    and local policy also would allow updating the trust\n   anchors.\n   The CMS
    AuthenticatedData structure provides message integrity, it\n   does not provide
    message authentication in all cases.  When using\n   MACs in this document the
    following restrictions need to be observed.\n   All messages should be for a single
    entity.  If two entities are\n   placed in a single message, the entities can
    generate new messages\n   that have a valid MAC and might be assumed to be from
    the original\n   message sender.  All entities that have access to the shared-secret\n
    \  can generate messages that will have a successful MAC validation.\n   This
    means that care must be taken to keep this value secret.\n   Whenever possible,
    the SignedData structure should be used in\n   preference to the AuthenticatedData
    structure.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   This document defines a number of control objects.
    \ These are\n   identified by Object Identifiers (OIDs).  The objects are defined\n
    \  from an arc delegated by IANA to the PKIX Working Group.  No further\n   action
    by IANA is necessary for this document or any anticipated\n   updates.\n"
  title: 9.  IANA Considerations
- contents:
  - "10.  Acknowledgments\n   The authors and the PKIX Working Group are grateful
    for the\n   participation of Xiaoyi Liu and Jeff Weinstein in helping to author\n
    \  the original versions of this document.\n   The authors would like to thank
    Brian LaMacchia for his work in\n   developing and writing up many of the concepts
    presented in this\n   document.  The authors would also like to thank Alex Deacon
    and Barb\n   Fox for their contributions.\n"
  title: 10.  Acknowledgments
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [CMS]          Housley, R., \"Cryptographic
      Message Syntax (CMS)\",\n                  RFC 3852, July 2004.\n   [CRMF]         Schaad,
      J., \"Internet X.509 Certification Request\n                  Message Format\",
      RFC 4211, January 2005.\n   [DH-POP]       Prafullchandra, H. and J. Schaad,
      \"Diffie-Hellman\n                  Proof-of-Possession Algorithms\", RFC 2875,
      June 2000.\n   [PKCS10]       Kaliski, B., \"PKCS #10: Certification Request
      Syntax\n                  v1.5\", RFC 2314, October 1997.\n                  Note
      that this version of PKCS #10 is used for\n                  compatibility with
      the use of 1988 ASN.1 syntax.  An\n                  effort is currently underway
      in the PKIX working group\n                  to update to use 2003 ASN.1 syntax.\n
      \  [PKIXCERT]     Housley, R., Ford, W., Polk, W., and D. Solo,\n                  \"Internet
      X.509 Public Key Infrastructure Certificate\n                  and Certificate
      Revocation List (CRL) Profile\",\n                  RFC 3280, April 2002.\n
      \  [RFC2119]      Bradner, S., \"Key words for use in RFCs to Indicate\n                  Requirement
      Levels\", RFC 2119, BCP 14, March 1997.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [CMC-TRANS]    Schaad, J. and M. Myers, \"Certificate
      Management over\n                  CMS (CMC): Transport Protocols\", RFC 5273,
      June 2008.\n   [CMC-COMPL]    Schaad, J. and M. Myers, \"Certificate Management\n
      \                 Messages over CMS (CMC): Compliance Requirements\",\n                  RFC
      5274, June 2008.\n   [PASSWORD]     Burr, W., Dodson, D., and W. Polk, \"Electronic\n
      \                 Authentication Guideline\", NIST SP 800-63, April 2006.\n
      \  [RANDOM]       Eastlake, 3rd, D., Schiller, J., and S. Crocker,\n                  \"Randomness
      Requirements for Security\", BCP 106,\n                  RFC 4086, June 2005.\n
      \  [SMALL-GROUP]  Zuccherato, R., \"Methods for Avoiding the \"Small-\n                  Subgroup\"
      Attacks on the Diffie-Hellman Key Agreement\n                  Method for S/MIME\",
      RFC 2785, March 2000.\n   [X942]         Rescorla, E., \"Diffie-Hellman Key
      Agreement Method\",\n                  RFC 2631, June 1999.\n   [RFC2797]      Myers,
      M., Liu, X., Schaad, J., and J. Weinstein,\n                  \"Certificate
      Management Messages over CMS\", RFC 2797,\n                  April 2000.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  ASN.1 Module\n EnrollmentMessageSyntax\n { iso(1) identified-organization(3)
    dod(4) internet(1)\n security(5) mechansims(5) pkix(7) id-mod(0) id-mod-cmc2002(23)
    }\n DEFINITIONS IMPLICIT TAGS ::=\n BEGIN\n -- EXPORTS All --\n -- The types and
    values defined in this module are exported for use\n -- in the other ASN.1 modules.
    \ Other applications may use them for\n -- their own purposes.\n IMPORTS\n   --
    PKIX Part 1 - Implicit    From [PKIXCERT]\n      GeneralName, CRLReason, ReasonFlags\n
    \     FROM PKIX1Implicit88 {iso(1) identified-organization(3) dod(6)\n              internet(1)
    security(5) mechanisms(5) pkix(7) id-mod(0)\n              id-pkix1-implicit(19)}\n
    \  -- PKIX Part 1 - Explicit    From [PKIXCERT]\n      AlgorithmIdentifier, Extension,
    Name, CertificateSerialNumber\n      FROM PKIX1Explicit88 {iso(1) identified-organization(3)
    dod(6)\n              internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)\n
    \             id-pkix1-explicit(18)}\n   -- Cryptographic Message Syntax   FROM
    [CMS]\n      ContentInfo, Attribute, IssuerAndSerialNumber\n        FROM CryptographicMessageSyntax2004
    { iso(1) member-body(2)\n             us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
    smime(16)\n             modules(0) cms-2004(24)}\n -- CRMF                         FROM
    [CRMF]\n    CertReqMsg, PKIPublicationInfo, CertTemplate\n    FROM PKIXCRMF-2005
    {iso(1) identified-organization(3) dod(6)\n           internet(1) security(5)
    mechanisms(5) pkix(7) id-mod(0)\n           id-mod-crmf2005(36)};\n   -- Global
    Types\n      UTF8String ::= [UNIVERSAL 12] IMPLICIT OCTET STRING\n        -- The
    content of this type conforms to RFC 2279.\n  id-pkix OBJECT IDENTIFIER  ::= {
    iso(1) identified-organization(3)\n      dod(6) internet(1) security(5) mechanisms(5)
    pkix(7) }\n id-cmc OBJECT IDENTIFIER ::= {id-pkix 7}   -- CMC controls\n id-cct
    OBJECT IDENTIFIER ::= {id-pkix 12}  -- CMC content types\n -- The following controls
    have the type OCTET STRING\n id-cmc-identityProof OBJECT IDENTIFIER ::= {id-cmc
    3}\n id-cmc-dataReturn OBJECT IDENTIFIER ::= {id-cmc 4}\n id-cmc-regInfo OBJECT
    IDENTIFIER ::= {id-cmc 18}\n id-cmc-responseInfo OBJECT IDENTIFIER ::= {id-cmc
    19}\n id-cmc-queryPending OBJECT IDENTIFIER ::= {id-cmc 21}\n id-cmc-popLinkRandom
    OBJECT IDENTIFIER ::= {id-cmc 22}\n id-cmc-popLinkWitness OBJECT IDENTIFIER ::=
    {id-cmc 23}\n -- The following controls have the type UTF8String\n id-cmc-identification
    OBJECT IDENTIFIER ::= {id-cmc 2}\n -- The following controls have the type INTEGER\n
    id-cmc-transactionId OBJECT IDENTIFIER ::= {id-cmc 5}\n -- The following controls
    have the type OCTET STRING\n id-cmc-senderNonce OBJECT IDENTIFIER ::= {id-cmc
    6}\n id-cmc-recipientNonce OBJECT IDENTIFIER ::= {id-cmc 7}\n  -- This is the
    content type used for a request message in the protocol\n id-cct-PKIData OBJECT
    IDENTIFIER ::= { id-cct 2 }\n PKIData ::= SEQUENCE {\n     controlSequence    SEQUENCE
    SIZE(0..MAX) OF TaggedAttribute,\n     reqSequence        SEQUENCE SIZE(0..MAX)
    OF TaggedRequest,\n     cmsSequence        SEQUENCE SIZE(0..MAX) OF TaggedContentInfo,\n
    \    otherMsgSequence   SEQUENCE SIZE(0..MAX) OF OtherMsg\n }\n  bodyIdMax INTEGER
    ::= 4294967295\n  BodyPartID ::= INTEGER(0..bodyIdMax)\n TaggedAttribute ::= SEQUENCE
    {\n     bodyPartID         BodyPartID,\n     attrType           OBJECT IDENTIFIER,\n
    \    attrValues         SET OF AttributeValue\n }\n  AttributeValue ::= ANY\n
    \ TaggedRequest ::= CHOICE {\n      tcr               [0] TaggedCertificationRequest,\n
    \     crm               [1] CertReqMsg,\n      orm               [2] SEQUENCE
    {\n          bodyPartID            BodyPartID,\n          requestMessageType    OBJECT
    IDENTIFIER,\n          requestMessageValue   ANY DEFINED BY requestMessageType\n
    \     }\n  }\n  TaggedCertificationRequest ::= SEQUENCE {\n      bodyPartID            BodyPartID,\n
    \     certificationRequest  CertificationRequest\n  }\n  CertificationRequest
    ::= SEQUENCE {\n    certificationRequestInfo  SEQUENCE {\n      version                   INTEGER,\n
    \     subject                   Name,\n      subjectPublicKeyInfo      SEQUENCE
    {\n        algorithm                 AlgorithmIdentifier,\n        subjectPublicKey
    \         BIT STRING },\n      attributes                [0] IMPLICIT SET OF Attribute
    },\n    signatureAlgorithm        AlgorithmIdentifier,\n    signature                 BIT
    STRING\n  }\n TaggedContentInfo ::= SEQUENCE {\n     bodyPartID              BodyPartID,\n
    \    contentInfo             ContentInfo\n }\n OtherMsg ::= SEQUENCE {\n     bodyPartID
    \       BodyPartID,\n     otherMsgType      OBJECT IDENTIFIER,\n     otherMsgValue
    \    ANY DEFINED BY otherMsgType }\n --  This defines the response message in
    the protocol\n id-cct-PKIResponse OBJECT IDENTIFIER ::= { id-cct 3 }\n ResponseBody
    ::= PKIResponse\n PKIResponse ::= SEQUENCE {\n     controlSequence   SEQUENCE
    SIZE(0..MAX) OF TaggedAttribute,\n     cmsSequence       SEQUENCE SIZE(0..MAX)
    OF TaggedContentInfo,\n     otherMsgSequence  SEQUENCE SIZE(0..MAX) OF OtherMsg\n
    }\n -- Used to return status state in a response\n id-cmc-statusInfo OBJECT IDENTIFIER
    ::= {id-cmc 1}\n CMCStatusInfo ::= SEQUENCE {\n     cMCStatus       CMCStatus,\n
    \    bodyList        SEQUENCE SIZE (1..MAX) OF BodyPartID,\n     statusString
    \   UTF8String OPTIONAL,\n     otherInfo        CHOICE {\n       failInfo         CMCFailInfo,\n
    \      pendInfo         PendInfo } OPTIONAL\n }\n PendInfo ::= SEQUENCE {\n     pendToken
    \       OCTET STRING,\n     pendTime         GeneralizedTime\n }\n CMCStatus ::=
    INTEGER {\n     success         (0),\n     failed          (2),\n     pending
    \        (3),\n     noSupport       (4),\n     confirmRequired (5),\n     popRequired
    \    (6),\n     partial                (7)\n }\n -- Note:\n -- The spelling of
    unsupportedExt is corrected in this version.\n -- In RFC 2797, it was unsuportedExt.\n
    CMCFailInfo ::= INTEGER {\n     badAlg          (0),\n     badMessageCheck (1),\n
    \    badRequest      (2),\n     badTime         (3),\n     badCertId       (4),\n
    \    unsupportedExt  (5),\n     mustArchiveKeys (6),\n     badIdentity     (7),\n
    \    popRequired     (8),\n     popFailed       (9),\n     noKeyReuse      (10),\n
    \    internalCAError (11),\n     tryLater        (12),\n     authDataFail    (13)\n
    }\n -- Used for RAs to add extensions to certification requests\n id-cmc-addExtensions
    OBJECT IDENTIFIER ::= {id-cmc 8}\n AddExtensions ::= SEQUENCE {\n     pkiDataReference
    \   BodyPartID,\n     certReferences      SEQUENCE OF BodyPartID,\n     extensions
    \         SEQUENCE OF Extension\n }\n id-cmc-encryptedPOP OBJECT IDENTIFIER ::=
    {id-cmc 9}\n id-cmc-decryptedPOP OBJECT IDENTIFIER ::= {id-cmc 10}\n EncryptedPOP
    ::= SEQUENCE {\n     request       TaggedRequest,\n     cms             ContentInfo,\n
    \    thePOPAlgID     AlgorithmIdentifier,\n     witnessAlgID    AlgorithmIdentifier,\n
    \    witness         OCTET STRING\n }\n DecryptedPOP ::= SEQUENCE {\n     bodyPartID
    \     BodyPartID,\n     thePOPAlgID     AlgorithmIdentifier,\n     thePOP          OCTET
    STRING\n }\n  id-cmc-lraPOPWitness OBJECT IDENTIFIER ::= {id-cmc 11}\n  LraPopWitness
    ::= SEQUENCE {\n      pkiDataBodyid   BodyPartID,\n      bodyIds         SEQUENCE
    OF BodyPartID\n  }\n --\n id-cmc-getCert OBJECT IDENTIFIER ::= {id-cmc 15}\n GetCert
    ::= SEQUENCE {\n     issuerName      GeneralName,\n     serialNumber    INTEGER
    }\n id-cmc-getCRL OBJECT IDENTIFIER ::= {id-cmc 16}\n GetCRL ::= SEQUENCE {\n
    \    issuerName    Name,\n     cRLName       GeneralName OPTIONAL,\n     time
    \         GeneralizedTime OPTIONAL,\n     reasons       ReasonFlags OPTIONAL }\n
    id-cmc-revokeRequest OBJECT IDENTIFIER ::= {id-cmc 17}\n RevokeRequest ::= SEQUENCE
    {\n     issuerName            Name,\n     serialNumber          INTEGER,\n     reason
    \               CRLReason,\n     invalidityDate         GeneralizedTime OPTIONAL,\n
    \    passphrase            OCTET STRING OPTIONAL,\n     comment               UTF8String
    OPTIONAL }\n id-cmc-confirmCertAcceptance OBJECT IDENTIFIER ::= {id-cmc 24}\n
    CMCCertId ::= IssuerAndSerialNumber\n -- The following is used to request V3 extensions
    be added to a\n -- certificate\n id-ExtensionReq OBJECT IDENTIFIER ::= {iso(1)
    member-body(2) us(840)\n      rsadsi(113549) pkcs(1) pkcs-9(9) 14}\n ExtensionReq
    ::= SEQUENCE SIZE (1..MAX) OF Extension\n -- The following exists to allow Diffie-Hellman
    Certification Requests\n -- Messages to be well-formed\n id-alg-noSignature OBJECT
    IDENTIFIER ::= {id-pkix id-alg(6) 2}\n NoSignatureValue ::= OCTET STRING\n --
    \ Unauthenticated attribute to carry removable data.\n --    This could be used
    in an update of \"CMC Extensions: Server Side\n --    Key Generation and Key Escrow\"
    (February 2005) and in other\n --    documents.\n id-aa OBJECT IDENTIFIER ::=
    { iso(1) member-body(2) us(840)\n       rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)
    id-aa(2)}\n id-aa-cmc-unsignedData OBJECT IDENTIFIER ::= {id-aa 34}\n CMCUnsignedData
    ::= SEQUENCE {\n     bodyPartPath        BodyPartPath,\n     identifier          OBJECT
    IDENTIFIER,\n     content             ANY DEFINED BY identifier\n }\n --  Replaces
    CMC Status Info\n --\n id-cmc-statusInfoV2 OBJECT IDENTIFIER ::= {id-cmc 25}\n
    CMCStatusInfoV2 ::= SEQUENCE {\n    cMCStatus             CMCStatus,\n    bodyList
    \             SEQUENCE SIZE (1..MAX) OF\n                                   BodyPartReference,\n
    \   statusString          UTF8String OPTIONAL,\n    otherInfo             CHOICE
    {\n      failInfo               CMCFailInfo,\n      pendInfo               PendInfo,\n
    \     extendedFailInfo       SEQUENCE {\n         failInfoOID            OBJECT
    IDENTIFIER,\n         failInfoValue          AttributeValue\n      }\n    } OPTIONAL\n
    }\n BodyPartReference ::= CHOICE {\n    bodyPartID           BodyPartID,\n    bodyPartPath
    \        BodyPartPath\n }\n BodyPartPath ::= SEQUENCE SIZE (1..MAX) OF BodyPartID\n
    --  Allow for distribution of trust anchors\n --\n id-cmc-trustedAnchors OBJECT
    IDENTIFIER ::= {id-cmc 26}\n PublishTrustAnchors ::= SEQUENCE {\n     seqNumber
    \     INTEGER,\n     hashAlgorithm  AlgorithmIdentifier,\n     anchorHashes     SEQUENCE
    OF OCTET STRING\n }\n id-cmc-authData OBJECT IDENTIFIER ::= {id-cmc 27}\n AuthPublish
    ::= BodyPartID\n --   These two items use BodyPartList\n id-cmc-batchRequests
    OBJECT IDENTIFIER ::= {id-cmc 28}\n id-cmc-batchResponses OBJECT IDENTIFIER ::=
    {id-cmc 29}\n BodyPartList ::= SEQUENCE SIZE (1..MAX) OF BodyPartID\n --\n id-cmc-publishCert
    OBJECT IDENTIFIER ::= {id-cmc 30}\n CMCPublicationInfo ::= SEQUENCE {\n     hashAlg
    \                     AlgorithmIdentifier,\n     certHashes                   SEQUENCE
    OF OCTET STRING,\n     pubInfo                          PKIPublicationInfo\n }\n
    id-cmc-modCertTemplate OBJECT IDENTIFIER ::= {id-cmc 31}\n ModCertTemplate ::=
    SEQUENCE {\n     pkiDataReference             BodyPartPath,\n     certReferences
    \              BodyPartList,\n     replace                      BOOLEAN DEFAULT
    TRUE,\n     certTemplate                 CertTemplate\n }\n -- Inform follow on
    servers that one or more controls have already been\n -- processed\n id-cmc-controlProcessed
    OBJECT IDENTIFIER ::= {id-cmc 32}\n ControlsProcessed ::= SEQUENCE {\n     bodyList
    \             SEQUENCE SIZE(1..MAX) OF BodyPartReference\n }\n --  Identity Proof
    control w/ algorithm agility\n id-cmc-identityProofV2 OBJECT IDENTIFIER ::= {
    id-cmc 34 }\n IdentifyProofV2 ::= SEQUENCE {\n     proofAlgID       AlgorithmIdentifier,\n
    \    macAlgId         AlgorithmIdentifier,\n     witness          OCTET STRING\n
    }\n id-cmc-popLinkWitnessV2 OBJECT IDENTIFIER ::= { id-cmc 33 }\n PopLinkWitnessV2
    ::= SEQUENCE {\n     keyGenAlgorithm   AlgorithmIdentifier,\n     macAlgorithm
    \     AlgorithmIdentifier,\n     witness           OCTET STRING\n }\n END\n"
  title: Appendix A.  ASN.1 Module
- contents:
  - "Appendix B.  Enrollment Message Flows\n   This section is informational.  The
    purpose of this section is to\n   present, in an abstracted version, the messages
    that would flow\n   between the client and server for several different common
    cases.\n"
  - contents:
    - "B.1.  Request of a Signing Certificate\n   This section looks at the messages
      that would flow in the event that\n   an enrollment is occurring for a signing-only
      key.  If the\n   certificate was designed for both signing and encryption, the
      only\n   difference would be the key usage extension in the certification\n
      \  request.\n   Message #2 from client to server:\n   ContentInfo.contentType
      = id-signedData\n   ContentInfo.content\n     SignedData.encapContentInfo\n
      \      eContentType = id-ct-PKIData\n       eContent\n         controlSequence\n
      \          {102, id-cmc-identityProof, computed value}\n           {103, id-cmc-senderNonce,
      10001}\n         reqSequence\n           certRequest\n             certReqId
      = 201\n             certTemplate\n               subject = My Proposed DN\n
      \              publicKey = My Public Key\n               extensions\n                 {id-ce-subjectPublicKeyIdentifier,
      1000}\n                 {id-ce-keyUsage, digitalSignature}\n     SignedData.SignerInfos\n
      \      SignerInfo\n         sid.subjectKeyIdentifier = 1000\n   Response from
      server to client:\n   ContentInfo.contentType = id-signedData\n   ContentInfo.content\n
      \    SignedData.encapContentInfo\n       eContentType = id-ct-PKIResponse\n
      \      eContent\n         controlSequence\n           {102, id-cmc-statusInfoV2,
      {success, 201}}\n           {103, id-cmc-senderNonce, 10005}\n           {104,
      id-cmc-recipientNonce, 10001}\n     certificates\n       Newly issued certificate\n
      \      Other certificates\n     SignedData.SignerInfos\n       Signed by CA\n"
    title: B.1.  Request of a Signing Certificate
  - contents:
    - "B.2.  Single Certification Request, But Modified by RA\n   This section looks
      at the messages that would flow in the event that\n   an enrollment has one
      RA in the middle of the data flow.  That RA\n   will modify the certification
      request before passing it on to the CA.\n   Message from client to RA:\n   ContentInfo.contentType
      = id-signedData\n   ContentInfo.content\n     SignedData.encapContentInfo\n
      \      eContentType = id-ct-PKIData\n       eContent\n         controlSequence\n
      \          {102, id-cmc-identityProof, computed value}\n           {103, id-cmc-senderNonce,
      10001}\n         reqSequence\n           certRequest\n             certReqId
      = 201\n             certTemplate\n               subject = My Proposed DN\n
      \              publicKey = My Public Key\n               extensions\n                 {id-ce-subjectPublicKeyIdentifier,
      1000}\n                 {id-ce-keyUsage, digitalSignature}\n     SignedData.SignerInfos\n
      \      SignerInfo\n         sid.subjectKeyIdentifier = 1000\n   Message from
      RA to CA:\n   ContentInfo.contentType = id-signedData\n   ContentInfo.content\n
      \    SignedData.encapContentInfo\n       eContentType = id-ct-PKIData\n       eContent\n
      \        controlSequence\n           { 102, id-cmc-batchRequests, { 1, 2} }\n
      \          { 103, id-cmc-addExtensions,\n             { {1, 201, {id-ce-certificatePolicies,
      anyPolicy}}\n               {1, 201, {id-ce-subjectAltName, {extension data}}\n
      \              {2, XXX, {id-ce-subjectAltName, {extension data}}}\n                     The
      Value XXX is not known here; it would\n                     reference into the
      second client request,\n                     which is not displayed above.\n
      \        cmsSequence\n           { 1, <Message from client to RA #1> }\n           {
      2, <Message from client to RA #2> }\n     SignedData.SignerInfos\n       SignerInfo\n
      \        sid = RA key.\n   Response from CA to RA:\n   ContentInfo.contentType
      = id-signedData\n   ContentInfo.content\n     SignedData.encapContentInfo\n
      \      eContentType = id-ct-PKIResponse\n       eContent\n         controlSequence\n
      \          {102, id-cmc-BatchResponse, {999, 998}}\n           {103, id-cmc-statusInfoV2,
      {failed, 2, badIdentity}}\n         cmsSequence\n           { bodyPartID = 999\n
      \            contentInfo\n               ContentInfo.contentType = id-signedData\n
      \              ContentInfo.content\n                 SignedData.encapContentInfo\n
      \                  eContentType = id-ct-PKIResponse\n                   eContent\n
      \                    controlSequence\n                      {102, id-cmc-statusInfoV2,
      {success, 201}}\n                 certificates\n                   Newly issued
      certificate\n                   Other certificates\n                 SignedData.SignerInfos\n
      \                  Signed by CA\n           }\n           { bodyPartID = 998,\n
      \            contentInfo\n               ContentInfo.contentType = id-signedData\n
      \              ContentInfo.content\n                 SignedData.encapContentInfo\n
      \                  eContentType = id-ct-PKIResponse\n                   eContent\n
      \                    controlSequence\n                       {102, id-cmc-statusInfoV2,
      {failure, badAlg}}\n                 certificates\n                   Newly
      issued certificate\n                   Other certificates\n                 SignedData.SignerInfos\n
      \                  Signed by CA\n           }\n         SignedData.SignerInfos\n
      \          Signed by CA\n   Response from RA to client:\n   ContentInfo.contentType
      = id-signedData\n   ContentInfo.content\n     SignedData.encapContentInfo\n
      \      eContentType = id-ct-PKIResponse\n       eContent\n         controlSequence\n
      \          {102, id-cmc-statusInfoV2, {success, 201}}\n     certificates\n       Newly
      issued certificate\n       Other certificates\n     SignedData.SignerInfos\n
      \      Signed by CA\n"
    title: B.2.  Single Certification Request, But Modified by RA
  - contents:
    - "B.3.  Direct POP for an RSA Certificate\n   This section looks at the messages
      that would flow in the event that\n   an enrollment is done for an encryption
      only certificate using an\n   direct POP method.  For simplicity, it is assumed
      that the\n   certification requester already has a signing-only certificate.\n
      \  The fact that a second round-trip is required is implicit rather than\n   explicit.
      \ The server determines this based on the fact that no other\n   POP exists
      for the certification request.\n   Message #1 from client to server:\n   ContentInfo.contentType
      = id-signedData\n   ContentInfo.content\n     SignedData.encapContentInfo\n
      \      eContentType = id-ct-PKIData\n       eContent\n         controlSequence\n
      \          {102, id-cmc-transactionId, 10132985123483401}\n           {103,
      id-cmc-senderNonce, 10001}\n           {104, id-cmc-dataReturn, <packet of binary
      data identifying\n                                     where the key in question
      is.>}\n         reqSequence\n           certRequest\n             certReqId
      = 201\n             certTemplate\n               subject = <My DN from my signing
      cert>\n               publicKey = My Public Key\n               extensions\n
      \                {id-ce-keyUsage, keyEncipherment}\n             popo\n               keyEncipherment\n
      \                subsequentMessage\n     SignedData.SignerInfos\n       SignerInfo\n
      \        Signed by requester's signing cert\n   Response #1 from server to client:\n
      \  ContentInfo.contentType = id-signedData\n   ContentInfo.content\n     SignedData.encapContentInfo\n
      \      eContentType = id-ct-PKIResponse\n       eContent\n         controlSequence\n
      \          {101, id-cmc-statusInfoV2, {failed, 201, popRequired}}\n           {102,
      id-cmc-transactionId, 10132985123483401}\n           {103, id-cmc-senderNonce,
      10005}\n           {104, id-cmc-recipientNonce, 10001}\n           {105, id-cmc-encryptedPOP,
      {\n              request {\n                certRequest\n                  certReqId
      = 201\n                   certTemplate\n                     subject = <My DN
      from my signing cert>\n                     publicKey = My Public Key\n                     extensions\n
      \                      {id-ce-keyUsage, keyEncipherment}\n                   popo\n
      \                    keyEncipherment\n                     subsequentMessage\n
      \             }\n              cms\n                contentType = id-envelopedData\n
      \               content\n                  recipientInfos.riid.issuerSerialNumber
      = <NULL, 201>\n                  encryptedContentInfo\n                    eContentType
      = id-data\n                    eContent = <Encrypted value of 'y'>\n              thePOPAlgID
      = HMAC-SHA1\n              witnessAlgID = SHA-1\n              witness <hashed
      value of 'y'>}}\n           {106, id-cmc-dataReturn, <packet of binary data
      identifying\n                                     where the key in question
      is.>}\n     certificates\n       Other certificates (optional)\n     SignedData.SignerInfos\n
      \      Signed by CA\n   ContentInfo.contentType = id-signedData\n   ContentInfo.content\n
      \    SignedData.encapContentInfo\n       eContentType = id-ct-PKIData\n       eContent\n
      \        controlSequence\n           {102, id-cmc-transactionId, 10132985123483401}\n
      \          {103, id-cmc-senderNonce, 100101}\n           {104, id-cmc-dataReturn,
      <packet of binary data identifying\n                                     where
      the key in question is.>}\n           {105, id-cmc-recipientNonce, 10005}\n
      \          {107, id-cmc-decryptedPOP, {\n             bodyPartID 201,\n             thePOPAlgID
      HMAC-SHA1,\n             thePOP <HMAC computed value goes here>}}\n         reqSequence\n
      \          certRequest\n             certReqId = 201\n             certTemplate\n
      \              subject = <My DN from my signing cert>\n               publicKey
      = My Public Key\n               extensions\n                 {id-ce-keyUsage,
      keyEncipherment}\n             popo\n               keyEncipherment\n                 subsequentMessage\n
      \    SignedData.SignerInfos\n       SignerInfo\n         Signed by requester's
      signing cert\n   Response #2 from server to client:\n   ContentInfo.contentType
      = id-signedData\n   ContentInfo.content\n     SignedData.encapContentInfo\n
      \      eContentType = id-ct-PKIResponse\n       eContent\n         controlSequence\n
      \          {101, id-cmc-transactionId, 10132985123483401}\n           {102,
      id-cmc-statusInfoV2, {success, 201}}\n           {103, id-cmc-senderNonce, 10019}\n
      \          {104, id-cmc-recipientNonce, 100101}\n           {105, id-cmc-dataReturn,
      <packet of binary data identifying\n                                     where
      the key in question is.>}\n     certificates\n       Newly issued certificate\n
      \      Other certificates\n     SignedData.SignerInfos\n       Signed by CA\n"
    title: B.3.  Direct POP for an RSA Certificate
  title: Appendix B.  Enrollment Message Flows
- contents:
  - "Appendix C.  Production of Diffie-Hellman Public Key Certification\n             Requests\n
    \  Part of a certification request is a signature over the request;\n   Diffie-Hellman
    is a key agreement algorithm and cannot be used to\n   directly produce the required
    signature object.  [DH-POP] provides\n   two ways to produce the necessary signature
    value.  This document\n   also defines a signature algorithm that does not provide
    a POP value,\n   but can be used to produce the necessary signature value.\n"
  - contents:
    - "C.1.  No-Signature Signature Mechanism\n   Key management (encryption/decryption)
      private keys cannot always be\n   used to produce some type of signature value
      as they can be in a\n   decrypt-only device.  Certification requests require
      that the\n   signature field be populated.  This section provides a signature\n
      \  algorithm specifically for that purposes.  The following object\n   identifier
      and signature value are used to identify this signature\n   type:\n      id-alg-noSignature
      OBJECT IDENTIFIER ::= {id-pkix id-alg(6) 2}\n      NoSignatureValue ::= OCTET
      STRING\n   The parameters for id-alg-noSignature MUST be present and MUST be\n
      \  encoded as NULL.  NoSignatureValue contains the hash of the\n   certification
      request.  It is important to realize that there is no\n   security associated
      with this signature type.  If this signature type\n   is on a certification
      request and the Certification Authority policy\n   requires proof-of-possession
      of the private key, the POP mechanism\n   defined in Section 6.7 MUST be used.\n"
    title: C.1.  No-Signature Signature Mechanism
  title: Appendix C.  Production of Diffie-Hellman Public Key Certification
- contents:
  - "Authors' Addresses\n   Jim Schaad\n   Soaring Hawk Consulting\n   PO Box 675\n
    \  Gold Bar, WA  98251\n   Phone: (425) 785-1031\n   EMail: jimsch@nwlink.com\n
    \  Michael Myers\n   TraceRoute Security, Inc.\n   EMail: mmyers@fastq.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
