- contents:
  - '        A Generalized Framework for Kerberos Pre-Authentication

    '
  title: __initial_text__
- contents:
  - "Abstract\n   Kerberos is a protocol for verifying the identity of principals\n
    \  (e.g., a workstation user or a network server) on an open network.\n   The
    Kerberos protocol provides a facility called pre-authentication.\n   Pre-authentication
    mechanisms can use this facility to extend the\n   Kerberos protocol and prove
    the identity of a principal.\n   This document describes a more formal model for
    this facility.  The\n   model describes what state in the Kerberos request a pre-\n
    \  authentication mechanism is likely to change.  It also describes how\n   multiple
    pre-authentication mechanisms used in the same request will\n   interact.\n   This
    document also provides common tools needed by multiple pre-\n   authentication
    mechanisms.  One of these tools is a secure channel\n   between the client and
    the key distribution center with a reply key\n   strengthening mechanism; this
    secure channel can be used to protect\n   the authentication exchange and thus
    eliminate offline dictionary\n   attacks.  With these tools, it is relatively
    straightforward to chain\n   multiple authentication mechanisms, utilize a different
    key\n   management system, or support a new key agreement algorithm.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6113.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Conventions and Terminology Used in This Document ..........5\n      1.2.
    Conformance Requirements ...................................5\n   2. Model for
    Pre-Authentication ....................................6\n      2.1. Information
    Managed by the Pre-Authentication Model ........7\n      2.2. Initial Pre-Authentication
    Required Error ..................9\n      2.3. Client to KDC .............................................10\n
    \     2.4. KDC to Client .............................................11\n   3.
    Pre-Authentication Facilities ..................................12\n      3.1.
    Client Authentication Facility ............................13\n      3.2. Strengthening
    Reply Key Facility ..........................13\n      3.3. Replace Reply Key
    Facility ................................14\n      3.4. KDC Authentication Facility
    ...............................15\n   4. Requirements for Pre-Authentication Mechanisms
    .................15\n      4.1. Protecting Requests/Responses .............................16\n
    \  5. Tools for Use in Pre-Authentication Mechanisms .................17\n      5.1.
    Combining Keys ............................................17\n      5.2. Managing
    States for the KDC ...............................19\n      5.3. Pre-Authentication
    Set ....................................20\n      5.4. Definition of Kerberos
    FAST Padata ........................23\n           5.4.1. FAST Armors ........................................24\n
    \          5.4.2. FAST Request .......................................26\n           5.4.3.
    FAST Response ......................................30\n           5.4.4. Authenticated
    Kerberos Error Messages Using\n                  Kerberos FAST ......................................33\n
    \          5.4.5. Outer and Inner Requests ...........................34\n           5.4.6.
    The Encrypted Challenge FAST Factor ................34\n      5.5. Authentication
    Strength Indication ........................36\n   6. Assigned Constants .............................................37\n
    \     6.1. New Errors ................................................37\n      6.2.
    Key Usage Numbers .........................................37\n      6.3. Authorization
    Data Elements ...............................37\n      6.4. New PA-DATA Types
    .........................................37\n   7. IANA Considerations ............................................38\n
    \     7.1. Pre-Authentication and Typed Data .........................38\n      7.2.
    Fast Armor Types ..........................................40\n      7.3. FAST
    Options ..............................................40\n   8. Security Considerations
    ........................................41\n   9. Acknowledgements ...............................................42\n
    \  10. References ....................................................43\n      10.1.
    Normative References .....................................43\n      10.2. Informative
    References ...................................43\n   Appendix A. Test Vectors
    for KRB-FX-CF2 ...........................45\n   Appendix B. ASN.1 Module ..........................................46\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The core Kerberos specification [RFC4120] treats pre-authentication\n
    \  data (padata) as an opaque typed hole in the messages to the key\n   distribution
    center (KDC) that may influence the reply key used to\n   encrypt the KDC reply.
    \ This generality has been useful: pre-\n   authentication data is used for a
    variety of extensions to the\n   protocol, many outside the expectations of the
    initial designers.\n   However, this generality makes designing more common types
    of pre-\n   authentication mechanisms difficult.  Each mechanism needs to specify\n
    \  how it interacts with other mechanisms.  Also, tasks such as\n   combining
    a key with the long-term secrets or proving the identity of\n   the user are common
    to multiple mechanisms.  Where there are\n   generally well-accepted solutions
    to these problems, it is desirable\n   to standardize one of these solutions so
    mechanisms can avoid\n   duplication of work.  In other cases, a modular approach
    to these\n   problems is appropriate.  The modular approach will allow new and\n
    \  better solutions to common pre-authentication problems to be used by\n   existing
    mechanisms as they are developed.\n   This document specifies a framework for
    Kerberos pre-authentication\n   mechanisms.  It defines the common set of functions
    that pre-\n   authentication mechanisms perform as well as how these functions\n
    \  affect the state of the request and reply.  In addition, several\n   common
    tools needed by pre-authentication mechanisms are provided.\n   Unlike [RFC3961],
    this framework is not complete -- it does not\n   describe all the inputs and
    outputs for the pre-authentication\n   mechanisms.  Pre-authentication mechanism
    designers should try to be\n   consistent with this framework because doing so
    will make their\n   mechanisms easier to implement.  Kerberos implementations
    are likely\n   to have plug-in architectures for pre-authentication; such\n   architectures
    are likely to support mechanisms that follow this\n   framework plus commonly
    used extensions.  This framework also\n   facilitates combining multiple pre-authentication
    mechanisms, each of\n   which may represent an authentication factor, into a single
    multi-\n   factor pre-authentication mechanism.\n   One of these common tools
    is the flexible authentication secure\n   tunneling (FAST) padata type.  FAST
    provides a protected channel\n   between the client and the key distribution center
    (KDC), and it can\n   optionally deliver key material used to strengthen the reply
    key\n   within the protected channel.  Based on FAST, pre-authentication\n   mechanisms
    can extend Kerberos with ease, to support, for example,\n   password-authenticated
    key exchange (PAKE) protocols with zero-\n   knowledge password proof (ZKPP) [EKE]
    [IEEE1363.2].  Any pre-\n   authentication mechanism can be encapsulated in the
    FAST messages as\n   defined in Section 5.4.  A pre-authentication type carried
    within\n   FAST is called a \"FAST factor\".  Creating a FAST factor is the\n
    \  easiest path to create a new pre-authentication mechanism.  FAST\n   factors
    are significantly easier to analyze from a security\n   standpoint than other
    pre-authentication mechanisms.\n   Mechanism designers should design FAST factors,
    instead of new pre-\n   authentication mechanisms outside of FAST.\n"
  - contents:
    - "1.1.  Conventions and Terminology Used in This Document\n   The key words \"MUST\",
      \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD
      NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to
      be interpreted as described in [RFC2119].\n   This document should be read only
      after reading the documents\n   describing the Kerberos cryptography framework
      [RFC3961] and the core\n   Kerberos protocol [RFC4120].  This document may freely
      use\n   terminology and notation from these documents without reference or\n
      \  further explanation.\n   The word padata is used as a shorthand for pre-authentication
      data.\n   A conversation is the set of all authentication messages exchanged\n
      \  between the client and the client's Authentication Service (AS) in\n   order
      to authenticate the client principal.  A conversation as\n   defined here consists
      of all messages that are necessary to complete\n   the authentication between
      the client and the client's AS.  In the\n   Ticket Granting Service (TGS) exchange,
      a conversation consists of\n   the request message and the reply message.  The
      term conversation is\n   defined here for both AS and TGS for convenience of
      discussion.  See\n   Section 5.2 for specific rules on the extent of a conversation
      in the\n   AS-REQ case.  Prior to this framework, implementations needed to
      use\n   implementation-specific heuristics to determine the extent of a\n   conversation.\n
      \  If the KDC reply in an AS exchange is verified, the KDC is\n   authenticated
      by the client.  In this document, verification of the\n   KDC reply is used
      as a synonym of authentication of the KDC.\n"
    title: 1.1.  Conventions and Terminology Used in This Document
  - contents:
    - "1.2.  Conformance Requirements\n   This section summarizes the mandatory-to-implement
      subset of this\n   specification as a convenience to implementors.  The actual\n
      \  requirements and their context are stated in the body of the\n   document.\n
      \  Clients conforming to this specification MUST support the padata\n   defined
      in Section 5.2.\n   Conforming implementations MUST support Kerberos FAST padata\n
      \  (Section 5.4).  Conforming implementations MUST implement the\n   FX_FAST_ARMOR_AP_REQUEST
      armor type.\n   Conforming implementations MUST support the encrypted challenge
      FAST\n   factor (Section 5.4.6).\n"
    title: 1.2.  Conformance Requirements
  title: 1.  Introduction
- contents:
  - "2.  Model for Pre-Authentication\n   When a Kerberos client wishes to obtain
    a ticket, it sends an initial\n   Authentication Service (AS) request to the KDC.
    \ If pre-\n   authentication is required but not being used, then the KDC will\n
    \  respond with a KDC_ERR_PREAUTH_REQUIRED error [RFC4120].\n   Alternatively,
    if the client knows what pre-authentication to use, it\n   MAY optimize away a
    round trip and send an initial request with\n   padata included in the initial
    request.  If the client includes the\n   padata computed using the wrong pre-authentication
    mechanism or\n   incorrect keys, the KDC MAY return KDC_ERR_PREAUTH_FAILED with
    no\n   indication of what padata should have been included.  In that case,\n   the
    client MUST retry with no padata and examine the error data of\n   the KDC_ERR_PREAUTH_REQUIRED
    error.  If the KDC includes pre-\n   authentication information in the accompanying
    error data of\n   KDC_ERR_PREAUTH_FAILED, the client SHOULD process the error
    data and\n   then retry.\n   The conventional KDC maintains no state between two
    requests;\n   subsequent requests may even be processed by a different KDC.  On
    the\n   other hand, the client treats a series of exchanges with KDCs as a\n   single
    conversation.  Each exchange accumulates state and hopefully\n   brings the client
    closer to a successful authentication.\n   These models for state management are
    in apparent conflict.  For many\n   of the simpler pre-authentication scenarios,
    the client uses one\n   round trip to find out what mechanisms the KDC supports.
    \ Then, the\n   next request contains sufficient pre-authentication for the KDC
    to be\n   able to return a successful reply.  For these simple scenarios, the\n
    \  client only sends one request with pre-authentication data and so the\n   conversation
    is trivial.  For more complex conversations, the KDC\n   needs to provide the
    client with a cookie to include in future\n   requests to capture the current
    state of the authentication session.\n   Handling of multiple round-trip mechanisms
    is discussed in\n   Section 5.2.\n   This framework specifies the behavior of
    Kerberos pre-authentication\n   mechanisms used to identify users or to modify
    the reply key used to\n   encrypt the KDC reply.  The PA-DATA typed hole may be
    used to carry\n   extensions to Kerberos that have nothing to do with proving
    the\n   identity of the user or establishing a reply key.  Such extensions\n   are
    outside the scope of this framework.  However, mechanisms that do\n   accomplish
    these goals should follow this framework.\n   This framework specifies the minimum
    state that a Kerberos\n   implementation needs to maintain while handling a request
    in order to\n   process pre-authentication.  It also specifies how Kerberos\n
    \  implementations process the padata at each step of the AS request\n   process.\n"
  - contents:
    - "2.1.  Information Managed by the Pre-Authentication Model\n   The following
      information is maintained by the client and KDC as each\n   request is being
      processed:\n   o  The reply key used to encrypt the KDC reply\n   o  How strongly
      the identity of the client has been authenticated\n   o  Whether the reply key
      has been used in this conversation\n   o  Whether the reply key has been replaced
      in this conversation\n   o  Whether the origin of the KDC reply can be verified
      by the client\n      (i.e., whether the KDC is authenticated to the client)\n
      \  Conceptually, the reply key is initially the long-term key of the\n   principal.
      \ However, principals can have multiple long-term keys\n   because of support
      for multiple encryption types, salts, and\n   string2key parameters.  As described
      in Section 5.2.7.5 of the\n   Kerberos protocol [RFC4120], the KDC sends PA-ETYPE-INFO2
      to notify\n   the client what types of keys are available.  Thus, in full\n
      \  generality, the reply key in the pre-authentication model is actually\n   a
      set of keys.  At the beginning of a request, it is initialized to\n   the set
      of long-term keys advertised in the PA-ETYPE-INFO2 element on\n   the KDC.  If
      multiple reply keys are available, the client chooses\n   which one to use.
      \ Thus, the client does not need to treat the reply\n   key as a set.  At the
      beginning of a request, the client picks a key\n   to use.\n   KDC implementations
      MAY choose to offer only one key in the PA-ETYPE-\n   INFO2 element.  Since
      the KDC already knows the client's list of\n   supported enctypes from the request,
      no interoperability problems are\n   created by choosing a single possible reply
      key.  This way, the KDC\n   implementation avoids the complexity of treating
      the reply key as a\n   set.\n   When the padata in the request are verified
      by the KDC, then the\n   client is known to have that key; therefore, the KDC
      SHOULD pick the\n   same key as the reply key.\n   At the beginning of handling
      a message on both the client and the\n   KDC, the client's identity is not authenticated.
      \ A mechanism may\n   indicate that it has successfully authenticated the client's\n
      \  identity.  It is useful to keep track of this information on the\n   client
      in order to know what pre-authentication mechanisms should be\n   used.  The
      KDC needs to keep track of whether the client is\n   authenticated because the
      primary purpose of pre-authentication is to\n   authenticate the client identity
      before issuing a ticket.  The\n   handling of authentication strength using
      various authentication\n   mechanisms is discussed in Section 5.5.\n   Initially,
      the reply key is not used.  A pre-authentication mechanism\n   that uses the
      reply key to encrypt or checksum some data in the\n   generation of new keys
      MUST indicate that the reply key is used.\n   This state is maintained by the
      client and the KDC to enforce the\n   security requirement stated in Section
      3.3 that the reply key SHOULD\n   NOT be replaced after it is used.\n   Initially,
      the reply key is not replaced.  If a mechanism implements\n   the Replace Reply
      Key facility discussed in Section 3.3, then the\n   state MUST be updated to
      indicate that the reply key has been\n   replaced.  Once the reply key has been
      replaced, knowledge of the\n   reply key is insufficient to authenticate the
      client.  The reply key\n   is marked as replaced in exactly the same situations
      as the KDC reply\n   is marked as not being verified to the client principal.
      \ However,\n   while mechanisms can verify the KDC reply to the client, once
      the\n   reply key is replaced, then the reply key remains replaced for the\n
      \  remainder of the conversation.\n   Without pre-authentication, the client
      knows that the KDC reply is\n   authentic and has not been modified because
      it is encrypted in a\n   long-term key of the client.  Only the KDC and the
      client know that\n   key.  So, at the start of a conversation, the KDC reply
      is presumed\n   to be verified using the client's long-term key.  It should
      be noted\n   that in this document, verifying the KDC reply means authenticating\n
      \  the KDC, and these phrases are used interchangeably.  Any pre-\n   authentication
      mechanism that sets a new reply key not based on the\n   principal's long-term
      secret MUST either verify the KDC reply some\n   other way or indicate that
      the reply is not verified.  If a mechanism\n   indicates that the reply is not
      verified, then the client\n   implementation MUST return an error unless a subsequent
      mechanism\n   verifies the reply.  The KDC needs to track this state so it can\n
      \  avoid generating a reply that is not verified.\n   In this specification,
      KDC verification/authentication refers to the\n   level of authentication of
      the KDC to the client provided by RFC\n   4120.  There is a stronger form of
      KDC verification that, while\n   sometimes important in Kerberos deployments,
      is not addressed in this\n   specification: the typical Kerberos request does
      not provide a way\n   for the client machine to know that it is talking to the
      correct KDC.\n   Someone who can inject packets into the network between the
      client\n   machine and the KDC and who knows the password that the user will\n
      \  give to the client machine can generate a KDC reply that will decrypt\n   properly.
      \ So, if the client machine needs to authenticate that the\n   user is in fact
      the named principal, then the client machine needs to\n   do a TGS request for
      itself as a service.  Some pre-authentication\n   mechanisms may provide a way
      for the client machine to authenticate\n   the KDC.  Examples of this include
      signing the reply that can be\n   verified using a well-known public key or
      providing a ticket for the\n   client machine as a service.\n"
    title: 2.1.  Information Managed by the Pre-Authentication Model
  - contents:
    - "2.2.  Initial Pre-Authentication Required Error\n   Typically, a client starts
      a conversation by sending an initial\n   request with no pre-authentication.
      \ If the KDC requires pre-\n   authentication, then it returns a KDC_ERR_PREAUTH_REQUIRED
      message.\n   After the first reply with the KDC_ERR_PREAUTH_REQUIRED error code,\n
      \  the KDC returns the error code KDC_ERR_MORE_PREAUTH_DATA_REQUIRED\n   (defined
      in Section 5.2) for pre-authentication configurations that\n   use multi-round-trip
      mechanisms; see Section 2.4 for details of that\n   case.\n   The KDC needs
      to choose which mechanisms to offer the client.  The\n   client needs to be
      able to choose what mechanisms to use from the\n   first message.  For example,
      consider the KDC that will accept\n   mechanism A followed by mechanism B or
      alternatively the single\n   mechanism C.  A client that supports A and C needs
      to know that it\n   should not bother trying A.\n   Mechanisms can either be
      sufficient on their own or can be part of an\n   authentication set -- a group
      of mechanisms that all need to\n   successfully complete in order to authenticate
      a client.  Some\n   mechanisms may only be useful in authentication sets; others
      may be\n   useful alone or in authentication sets.  For the second group of\n
      \  mechanisms, KDC policy dictates whether the mechanism will be part of\n   an
      authentication set, offered alone, or both.  For each mechanism\n   that is
      offered alone (even if it is also offered in an\n   authentication set), the
      KDC includes the pre-authentication type ID\n   of the mechanism in the padata
      sequence returned in the\n   KDC_ERR_PREAUTH_REQUIRED error.  Mechanisms that
      are only offered as\n   part of an authentication set are not directly represented
      in the\n   padata sequence returned in the KDC_ERR_PREAUTH_REQUIRED error,\n
      \  although they are represented in the PA-AUTHENTICATION-SET sequence.\n   The
      KDC SHOULD NOT send data that is encrypted in the long-term\n   password-based
      key of the principal.  Doing so has the same security\n   exposures as the Kerberos
      protocol without pre-authentication.  There\n   are few situations where the
      KDC needs to expose cipher text\n   encrypted in a weak key before the client
      has proven knowledge of\n   that key, and where pre-authentication is desirable.\n"
    title: 2.2.  Initial Pre-Authentication Required Error
  - contents:
    - "2.3.  Client to KDC\n   This description assumes that a client has already
      received a\n   KDC_ERR_PREAUTH_REQUIRED from the KDC.  If the client performs\n
      \  optimistic pre-authentication, then the client needs to guess values\n   for
      the information it would normally receive from that error\n   response or use
      cached information obtained in prior interactions\n   with the KDC.\n   The
      client starts by initializing the pre-authentication state as\n   specified.
      \ It then processes the padata in the\n   KDC_ERR_PREAUTH_REQUIRED.\n   When
      processing the response to the KDC_ERR_PREAUTH_REQUIRED, the\n   client MAY
      ignore any padata it chooses unless doing so violates a\n   specification to
      which the client conforms.  Clients conforming to\n   this specification MUST
      NOT ignore the padata defined in Section 5.2.\n   Clients SHOULD choose one
      authentication set or mechanism that could\n   lead to authenticating the user
      and ignore other such mechanisms.\n   However, this rule does not affect the
      processing of padata unrelated\n   to this framework; clients SHOULD process
      such padata normally.\n   Since the list of mechanisms offered by the KDC is
      in the decreasing\n   preference order, clients typically choose the first mechanism
      or\n   authentication set that the client can usefully perform.  If a client\n
      \  chooses to ignore padata, it MUST NOT process the padata, allow the\n   padata
      to affect the pre-authentication state, or respond to the\n   padata.\n   For
      each instance of padata the client chooses to process, the client\n   processes
      the padata and modifies the pre-authentication state as\n   required by that
      mechanism.\n   After processing the padata in the KDC error, the client generates
      a\n   new request.  It processes the pre-authentication mechanisms in the\n
      \  order in which they will appear in the next request, updating the\n   state
      as appropriate.  The request is sent when it is complete.\n"
    title: 2.3.  Client to KDC
  - contents:
    - "2.4.  KDC to Client\n   When a KDC receives an AS request from a client, it
      needs to\n   determine whether it will respond with an error or an AS reply.\n
      \  There are many causes for an error to be generated that have nothing\n   to
      do with pre-authentication; they are discussed in the core\n   Kerberos specification.\n
      \  From the standpoint of evaluating the pre-authentication, the KDC\n   first
      starts by initializing the pre-authentication state.  If a PA-\n   FX-COOKIE
      pre-authentication data item is present, it is processed\n   first; see Section
      5.2 for a definition.  It then processes the\n   padata in the request.  As
      mentioned in Section 2.3, the KDC MAY\n   ignore padata that are inappropriate
      for the configuration and MUST\n   ignore padata of an unknown type.  The KDC
      MUST NOT ignore padata of\n   types used in previous messages.  For example,
      if a KDC issues a\n   KDC_ERR_PREAUTH_REQUIRED error including padata of type
      x, then the\n   KDC cannot ignore padata of type x received in an AS-REQ message
      from\n   the client.\n   At this point, the KDC decides whether it will issue
      an error or a\n   reply.  Typically, a KDC will issue a reply if the client's
      identity\n   has been authenticated to a sufficient degree.\n   In the case
      of a KDC_ERR_MORE_PREAUTH_DATA_REQUIRED error, the KDC\n   first starts by initializing
      the pre-authentication state.  Then, it\n   processes any padata in the client's
      request in the order provided by\n   the client.  Mechanisms that are not understood
      by the KDC are\n   ignored.  Next, it generates padata for the error response,
      modifying\n   the pre-authentication state appropriately as each mechanism is\n
      \  processed.  The KDC chooses the order in which it will generate\n   padata
      (and thus the order of padata in the response), but it needs\n   to modify the
      pre-authentication state consistently with the choice\n   of order.  For example,
      if some mechanism establishes an\n   authenticated client identity, then the
      subsequent mechanisms in the\n   generated response receive this state as input.
      \ After the padata are\n   generated, the error response is sent.  Typically,
      the errors with\n   the code KDC_ERR_MORE_PREAUTH_DATA_REQUIRED in a conversation
      will\n   include KDC state, as discussed in Section 5.2.\n   To generate a final
      reply, the KDC generates the padata modifying the\n   pre-authentication state
      as necessary.  Then, it generates the final\n   response, encrypting it in the
      current pre-authentication reply key.\n"
    title: 2.4.  KDC to Client
  title: 2.  Model for Pre-Authentication
- contents:
  - "3.  Pre-Authentication Facilities\n   Pre-authentication mechanisms can be thought
    of as providing various\n   conceptual facilities.  This serves two useful purposes.
    \ First,\n   mechanism authors can choose only to solve one specific small\n   problem.
    \ It is often useful for a mechanism designed to offer key\n   management not
    to directly provide client authentication but instead\n   to allow one or more
    other mechanisms to handle this need.  Secondly,\n   thinking about the abstract
    services that a mechanism provides yields\n   a minimum set of security requirements
    that all mechanisms providing\n   that facility must meet.  These security requirements
    are not\n   complete; mechanisms will have additional security requirements based\n
    \  on the specific protocol they employ.\n   A mechanism is not constrained to
    only offering one of these\n   facilities.  While such mechanisms can be designed
    and are sometimes\n   useful, many pre-authentication mechanisms implement several\n
    \  facilities.  It is often easier to construct a secure, simple\n   solution
    by combining multiple facilities in a single mechanism than\n   by solving the
    problem in full generality.  Even when mechanisms\n   provide multiple facilities,
    they need to meet the security\n   requirements for all the facilities they provide.
    \ If the FAST factor\n   approach is used, it is likely that one or a small number
    of\n   facilities can be provided by a single mechanism without complicating\n
    \  the security analysis.\n   According to Kerberos extensibility rules (Section
    1.5 of the\n   Kerberos specification [RFC4120]), an extension MUST NOT change
    the\n   semantics of a message unless a recipient is known to understand that\n
    \  extension.  Because a client does not know that the KDC supports a\n   particular
    pre-authentication mechanism when it sends an initial\n   request, a pre-authentication
    mechanism MUST NOT change the semantics\n   of the request in a way that will
    break a KDC that does not\n   understand that mechanism.  Similarly, KDCs MUST
    NOT send messages to\n   clients that affect the core semantics unless the client
    has\n   indicated support for the message.\n   The only state in this model that
    would break the interpretation of a\n   message is changing the expected reply
    key.  If one mechanism changed\n   the reply key and a later mechanism used that
    reply key, then a KDC\n   that interpreted the second mechanism but not the first
    would fail to\n   interpret the request correctly.  In order to avoid this problem,\n
    \  extensions that change core semantics are typically divided into two\n   parts.
    \ The first part proposes a change to the core semantic -- for\n   example, proposes
    a new reply key.  The second part acknowledges that\n   the extension is understood
    and that the change takes effect.\n   Section 3.2 discusses how to design mechanisms
    that modify the reply\n   key to be split into a proposal and acceptance without
    requiring\n   additional round trips to use the new reply key in subsequent pre-\n
    \  authentication.  Other changes in the state described in Section 2.1\n   can
    safely be ignored by a KDC that does not understand a mechanism.\n   Mechanisms
    that modify the behavior of the request outside the scope\n   of this framework
    need to carefully consider the Kerberos\n   extensibility rules to avoid similar
    problems.\n"
  - contents:
    - "3.1.  Client Authentication Facility\n   The Client Authentication facility
      proves the identity of a user to\n   the KDC before a ticket is issued.  Examples
      of mechanisms\n   implementing this facility include the encrypted timestamp
      facility,\n   defined in Section 5.2.7.2 of the Kerberos specification [RFC4120].\n
      \  Mechanisms that provide this facility are expected to mark the client\n   as
      authenticated.\n   Mechanisms implementing this facility SHOULD require the
      client to\n   prove knowledge of the reply key before transmitting a successful
      KDC\n   reply.  Otherwise, an attacker can intercept the pre-authentication\n
      \  exchange and get a reply to attack.  One way of proving the client\n   knows
      the reply key is to implement the Replace Reply Key facility\n   along with
      this facility.  The Public Key Cryptography for Initial\n   Authentication in
      Kerberos (PKINIT) mechanism [RFC4556] implements\n   Client Authentication alongside
      Replace Reply Key.\n   If the reply key has been replaced, then mechanisms such
      as\n   encrypted-timestamp that rely on knowledge of the reply key to\n   authenticate
      the client MUST NOT be used.\n"
    title: 3.1.  Client Authentication Facility
  - contents:
    - "3.2.  Strengthening Reply Key Facility\n   Particularly when dealing with keys
      based on passwords, it is\n   desirable to increase the strength of the key
      by adding additional\n   secrets to it.  Examples of sources of additional secrets
      include the\n   results of a Diffie-Hellman key exchange or key bits from the
      output\n   of a smart card [KRB-WG.SAM].  Typically, these additional secrets\n
      \  can be first combined with the existing reply key and then converted\n   to
      a protocol key using tools defined in Section 5.1.\n   Typically, a mechanism
      implementing this facility will know that the\n   other side of the exchange
      supports the facility before the reply key\n   is changed.  For example, a mechanism
      might need to learn the\n   certificate for a KDC before encrypting a new key
      in the public key\n   belonging to that certificate.  However, if a mechanism
      implementing\n   this facility wishes to modify the reply key before knowing
      that the\n   other party in the exchange supports the mechanism, it proposes\n
      \  modifying the reply key.  The other party then includes a message\n   indicating
      that the proposal is accepted if it is understood and\n   meets policy.  In
      many cases, it is desirable to use the new reply\n   key for client authentication
      and for other facilities.  Waiting for\n   the other party to accept the proposal
      and actually modify the reply\n   key state would add an additional round trip
      to the exchange.\n   Instead, mechanism designers are encouraged to include
      a typed hole\n   for additional padata in the message that proposes the reply
      key\n   change.  The padata included in the typed hole are generated assuming\n
      \  the new reply key.  If the other party accepts the proposal, then\n   these
      padata are considered as an inner level.  As with the outer\n   level, one authentication
      set or mechanism is typically chosen for\n   client authentication, along with
      auxiliary mechanisms such as KDC\n   cookies, and other mechanisms are ignored.
      \ When mechanisms include\n   such a container, the hint provided for use in
      authentication sets\n   (as defined in Section 5.3) MUST contain a sequence
      of inner\n   mechanisms along with hints for those mechanisms.  The party\n
      \  generating the proposal can determine whether the padata were\n   processed
      based on whether the proposal for the reply key is\n   accepted.\n   The specific
      formats of the proposal message, including where padata\n   are included, is
      a matter for the mechanism specification.\n   Similarly, the format of the message
      accepting the proposal is\n   mechanism specific.\n   Mechanisms implementing
      this facility and including a typed hole for\n   additional padata MUST checksum
      that padata using a keyed checksum or\n   encrypt the padata.  This requirement
      protects against modification\n   of the contents of the typed hole.  By modifying
      these contents, an\n   attacker might be able to choose which mechanism is used
      to\n   authenticate the client, or to convince a party to provide text\n   encrypted
      in a key that the attacker had manipulated.  It is\n   important that mechanisms
      strengthen the reply key enough that using\n   it to checksum padata is appropriate.\n"
    title: 3.2.  Strengthening Reply Key Facility
  - contents:
    - "3.3.  Replace Reply Key Facility\n   The Replace Reply Key facility replaces
      the key in which a successful\n   AS reply will be encrypted.  This facility
      can only be used in cases\n   where knowledge of the reply key is not used to
      authenticate the\n   client.  The new reply key MUST be communicated to the
      client and the\n   KDC in a secure manner.  This facility MUST NOT be used if
      there can\n   be a man-in-the-middle between the client and the KDC.  Mechanisms\n
      \  implementing this facility MUST mark the reply key as replaced in the\n   pre-authentication
      state.  Mechanisms implementing this facility MUST\n   either provide a mechanism
      to verify the KDC reply to the client or\n   mark the reply as unverified in
      the pre-authentication state.\n   Mechanisms implementing this facility SHOULD
      NOT be used if a\n   previous mechanism has used the reply key.\n   As with
      the Strengthening Reply Key facility, Kerberos extensibility\n   rules require
      that the reply key not be changed unless both sides of\n   the exchange understand
      the extension.  In the case of this facility,\n   it will likely be the case
      for both sides to know that the facility\n   is available by the time that the
      new key is available to be used.\n   However, mechanism designers can use a
      container for padata in a\n   proposal message, as discussed in Section 3.2,
      if appropriate.\n"
    title: 3.3.  Replace Reply Key Facility
  - contents:
    - "3.4.  KDC Authentication Facility\n   This facility verifies that the reply
      comes from the expected KDC.\n   In traditional Kerberos, the KDC and the client
      share a key, so if\n   the KDC reply can be decrypted, then the client knows
      that a trusted\n   KDC responded.  Note that the client machine cannot trust
      the client\n   unless the machine is presented with a service ticket for it\n
      \  (typically, the machine can retrieve this ticket by itself).\n   However,
      if the reply key is replaced, some mechanism is required to\n   verify the KDC.
      \ Pre-authentication mechanisms providing this\n   facility allow a client to
      determine that the expected KDC has\n   responded even after the reply key is
      replaced.  They mark the pre-\n   authentication state as having been verified.\n"
    title: 3.4.  KDC Authentication Facility
  title: 3.  Pre-Authentication Facilities
- contents:
  - "4.  Requirements for Pre-Authentication Mechanisms\n   This section lists requirements
    for specifications of pre-\n   authentication mechanisms.\n   For each message
    in the pre-authentication mechanism, the\n   specification describes the pa-type
    value to be used and the contents\n   of the message.  The processing of the message
    by the sender and\n   recipient is also specified.  This specification needs to
    include all\n   modifications to the pre-authentication state.\n   Generally,
    mechanisms have a message that can be sent in the error\n   data of the KDC_ERR_PREAUTH_REQUIRED
    error message or in an\n   authentication set.  If the client needs information,
    such as trusted\n   certificate authorities, in order to determine if it can use
    the\n   mechanism, then this information should be in that message.  In\n   addition,
    such mechanisms should also define a pa-hint to be included\n   in authentication
    sets.  Often, the same information included in the\n   padata-value is appropriate
    to include in the pa-hint (as defined in\n   Section 5.3).\n   In order to ease
    security analysis, the mechanism specification\n   should describe what facilities
    from this document are offered by the\n   mechanism.  For each facility, the security
    considerations section of\n   the mechanism specification should show that the
    security\n   requirements of that facility are met.  This requirement is\n   applicable
    to any FAST factor that provides authentication\n   information.\n   Significant
    problems have resulted in the specification of Kerberos\n   protocols because
    much of the KDC exchange is not protected against\n   alteration.  The security
    considerations section should discuss\n   unauthenticated plaintext attacks.  It
    should either show that\n   plaintext is protected or discuss what harm an attacker
    could do by\n   modifying the plaintext.  It is generally acceptable for an attacker\n
    \  to be able to cause the protocol negotiation to fail by modifying\n   plaintext.
    \ More significant attacks should be evaluated carefully.\n   As discussed in
    Section 5.2, there is no guarantee that a client will\n   use the same KDCs for
    all messages in a conversation.  The mechanism\n   specification needs to show
    why the mechanism is secure in this\n   situation.  The hardest problem to deal
    with, especially for\n   challenge/response mechanisms is to make sure that the
    same response\n   cannot be replayed against two KDCs while allowing the client
    to talk\n   to any KDC.\n"
  - contents:
    - "4.1.  Protecting Requests/Responses\n   Mechanism designers SHOULD protect
      cleartext portions of pre-\n   authentication data.  Various denial-of-service
      attacks and downgrade\n   attacks against Kerberos are possible unless plaintexts
      are somehow\n   protected against modification.  An early design goal of Kerberos\n
      \  Version 5 [RFC4120] was to avoid encrypting more of the\n   authentication
      exchange than was required.  (Version 4 doubly-\n   encrypted the encrypted
      part of a ticket in a KDC reply, for\n   example).  This minimization of encryption
      reduces the load on the\n   KDC and busy servers.  Also, during the initial
      design of Version 5,\n   the existence of legal restrictions on the export of
      cryptography\n   made it desirable to minimize of the number of uses of encryption
      in\n   the protocol.  Unfortunately, performing this minimization created\n
      \  numerous instances of unauthenticated security-relevant plaintext\n   fields.\n
      \  Mechanisms MUST guarantee that by the end of a successful\n   authentication
      exchange, both the client and the KDC have verified\n   all the plaintext sent
      by the other party.  If there is more than one\n   round trip in the exchange,
      mechanisms MUST additionally guarantee\n   that no individual messages were
      reordered or replayed from a\n   previous exchange.  Strategies for accomplishing
      this include using\n   message authentication codes (MACs) to protect the plaintext
      as it is\n   sent including some form of nonce or cookie to allow for the chaining\n
      \  of state from one message to the next or exchanging a MAC of the\n   entire
      conversation after a key is established.\n   Mechanism designers need to provide
      a strategy for updating\n   cryptographic algorithms, such as defining a new
      pre-authentication\n   type for each algorithm or taking advantage of the client's
      list of\n   supported RFC 3961 encryption types to indicate the client's support\n
      \  for cryptographic algorithms.\n   Primitives defined in [RFC3961] are RECOMMENDED
      for integrity\n   protection and confidentiality.  Mechanisms based on these
      primitives\n   are crypto-agile as the result of using [RFC3961] along with\n
      \  [RFC4120].  The advantage afforded by crypto-agility is the ability\n   to
      incrementally deploy a fix specific to a particular algorithm thus\n   avoid
      a multi-year standardization and deployment cycle, when real\n   attacks do
      arise against that algorithm.\n   Note that data used by FAST factors (defined
      in Section 5.4) is\n   encrypted in a protected channel; thus, they do not share
      the un-\n   authenticated-text issues with mechanisms designed as full-blown
      pre-\n   authentication mechanisms.\n"
    title: 4.1.  Protecting Requests/Responses
  title: 4.  Requirements for Pre-Authentication Mechanisms
- contents:
  - "5.  Tools for Use in Pre-Authentication Mechanisms\n   This section describes
    common tools needed by multiple pre-\n   authentication mechanisms.  By using
    these tools, mechanism designers\n   can use a modular approach to specify mechanism
    details and ease\n   security analysis.\n"
  - contents:
    - "5.1.  Combining Keys\n   Frequently, a weak key needs to be combined with a
      stronger key\n   before use.  For example, passwords are typically limited in
      size and\n   insufficiently random: therefore, it is desirable to increase the\n
      \  strength of the keys based on passwords by adding additional secrets.\n   An
      additional source of secrecy may come from hardware tokens.\n   This section
      provides standard ways to combine two keys into one.\n   KRB-FX-CF1() is defined
      to combine two passphrases.\n       KRB-FX-CF1(UTF-8 string, UTF-8 string) ->
      (UTF-8 string)\n       KRB-FX-CF1(x, y) := x || y\n   Where || denotes concatenation.
      \ The strength of the final key is\n   roughly the total strength of the individual
      keys being combined,\n   assuming that the string_to_key() function [RFC3961]
      uses all its\n   input evenly.\n   An example usage of KRB-FX-CF1() is when
      a device provides random but\n   short passwords, the password is often combined
      with a personal\n   identification number (PIN).  The password and the PIN can
      be\n   combined using KRB-FX-CF1().\n   KRB-FX-CF2() combines two protocol keys
      based on the pseudo-random()\n   function defined in [RFC3961].\n   Given two
      input keys, K1 and K2, where K1 and K2 can be of two\n   different enctypes,
      the output key of KRB-FX-CF2(), K3, is derived as\n   follows:\n       KRB-FX-CF2(protocol
      key, protocol key, octet string,\n                 octet string)  ->  (protocol
      key)\n       PRF+(K1, pepper1) -> octet-string-1\n       PRF+(K2, pepper2) ->
      octet-string-2\n       KRB-FX-CF2(K1, K2, pepper1, pepper2) :=\n              random-to-key(octet-string-1
      ^ octet-string-2)\n   Where ^ denotes the exclusive-OR operation.  PRF+() is
      defined as\n   follows:\n    PRF+(protocol key, octet string) -> (octet string)\n
      \   PRF+(key, shared-info) := pseudo-random( key,  1 || shared-info ) ||\n                  pseudo-random(
      key, 2 || shared-info ) ||\n                  pseudo-random( key, 3 || shared-info
      ) || ...\n   Here the counter value 1, 2, 3, and so on are encoded as a one-octet\n
      \  integer.  The pseudo-random() operation is specified by the enctype\n   of
      the protocol key.  PRF+() uses the counter to generate enough bits\n   as needed
      by the random-to-key() [RFC3961] function for the\n   encryption type specified
      for the resulting key; unneeded bits are\n   removed from the tail.  Unless
      otherwise specified, the resulting\n   enctype of KRB-FX-CF2 is the enctype
      of k1.  The pseudo-random()\n   operation is the RFC 3961 pseudo-random() operation
      for the\n   corresponding input key; the random-to-key() operation is the RFC\n
      \  3961 random-to-key operation for the resulting key.\n   Mechanism designers
      MUST specify the values for the input parameter\n   pepper1 and pepper2 when
      combining two keys using KRB-FX-CF2().  The\n   pepper1 and pepper2 MUST be
      distinct so that if the two keys being\n   combined are the same, the resulting
      key is not a trivial key.\n"
    title: 5.1.  Combining Keys
  - contents:
    - "5.2.  Managing States for the KDC\n   Kerberos KDCs are stateless in that there
      is no requirement that\n   clients will choose the same KDC for the second request
      in a\n   conversation.  Proxies or other intermediate nodes may also influence\n
      \  KDC selection.  So, each request from a client to a KDC must include\n   sufficient
      information that the KDC can regenerate any needed state.\n   This is accomplished
      by giving the client a potentially long opaque\n   cookie in responses to include
      in future requests in the same\n   conversation.  The KDC MAY respond that a
      conversation is too old and\n   needs to restart by responding with a KDC_ERR_PREAUTH_EXPIRED
      error.\n       KDC_ERR_PREAUTH_EXPIRED            90\n   When a client receives
      this error, the client SHOULD abort the\n   existing conversation, and restart
      a new one.\n   An example, where more than one message from the client is needed,
      is\n   when the client is authenticated based on a challenge/response\n   scheme.
      \ In that case, the KDC needs to keep track of the challenge\n   issued for
      a client authentication request.\n   The PA-FX-COOKIE padata type is defined
      in this section to facilitate\n   state management in the AS exchange.  These
      padata are sent by the\n   KDC when the KDC requires state for a future transaction.
      \ The client\n   includes this opaque token in the next message in the conversation.\n
      \  The token may be relatively large; clients MUST be prepared for\n   tokens
      somewhat larger than the size of all messages in a\n   conversation.\n       PA-FX-COOKIE
      \                      133\n           -- Stateless cookie that is not tied
      to a specific KDC.\n   The corresponding padata-value field [RFC4120] contains
      an opaque\n   token that will be echoed by the client in its response to an
      error\n   from the KDC.\n   The cookie token is generated by the KDC and transmitted
      in a PA-FX-\n   COOKIE pre-authentication data item of a KRB-ERROR message.
      \ The\n   client MUST copy the exact cookie encapsulated in a PA-FX-COOKIE data\n
      \  element into the next message of the same conversation.  The content\n   of
      the cookie field is a local matter of the KDC.  As a result, it is\n   not generally
      possible to mix KDC implementations from different\n   vendors in the same realm.
      \ However, the KDC MUST construct the\n   cookie token in such a manner that
      a malicious client cannot subvert\n   the authentication process by manipulating
      the token.  The KDC\n   implementation needs to consider expiration of tokens,
      key rollover,\n   and other security issues in token design.  The content of
      the cookie\n   field is likely specific to the pre-authentication mechanisms
      used to\n   authenticate the client.  If a client authentication response can
      be\n   replayed to multiple KDCs via the PA-FX-COOKIE mechanism, an\n   expiration
      in the cookie is RECOMMENDED to prevent the response being\n   presented indefinitely.
      \ Implementations need to consider replay both\n   of an entire conversation
      and of messages within a conversation when\n   designing what information is
      stored in a cookie and how pre-\n   authentication mechanisms are implemented.\n
      \  If at least one more message for a mechanism or a mechanism set is\n   expected
      by the KDC, the KDC returns a\n   KDC_ERR_MORE_PREAUTH_DATA_REQUIRED error with
      a PA-FX-COOKIE to\n   identify the conversation with the client, according to
      Section 2.2.\n   The cookie is not expected to stay constant for a conversation:
      the\n   KDC is expected to generate a new cookie for each message.\n        KDC_ERR_MORE_PREAUTH_DATA_REQUIRED
      \  91\n   A client MAY throw away the state associated with a conversation and\n
      \  begin a new conversation by discarding its state and not including a\n   cookie
      in the first message of a conversation.  KDCs that comply with\n   this specification
      MUST include a cookie in a response when the\n   client can continue the conversation.
      \ In particular, a KDC MUST\n   include a cookie in a KDC_ERR_PREAUTH_REQUIRED
      or\n   KDC_ERR_MORE_PREAUTH_DATA_REQUIRED.  KDCs SHOULD include a cookie in\n
      \  errors containing additional information allowing a client to retry.\n   One
      reasonable strategy for meeting these requirements is to always\n   include
      a cookie in KDC errors.\n   A KDC MAY indicate that it is terminating a conversation
      by not\n   including a cookie in a response.  When FAST is used, clients can\n
      \  assume that the absence of a cookie means that the KDC is ending the\n   conversation.
      \ Similarly, if a cookie is seen at all during a\n   conversation, clients MAY
      assume that the absence of a cookie in a\n   future message means that the KDC
      is ending the conversation.\n   Clients also need to deal with KDCs, prior to
      this specification,\n   that do not include cookies; if neither cookies nor
      FAST are used in\n   a conversation, the absence of a cookie is not a strong
      indication\n   that the KDC is terminating the conversation.\n"
    title: 5.2.  Managing States for the KDC
  - contents:
    - "5.3.  Pre-Authentication Set\n   If all mechanisms in a group need to successfully
      complete in order\n   to authenticate a client, the client and the KDC SHOULD
      use the PA-\n   AUTHENTICATION-SET padata element.\n        PA-AUTHENTICATION-SET
      \             134\n   A PA-AUTHENTICATION-SET padata element contains the ASN.1
      DER\n   encoding of the PA-AUTHENTICATION-SET structure:\n        PA-AUTHENTICATION-SET
      ::= SEQUENCE OF PA-AUTHENTICATION-SET-ELEM\n        PA-AUTHENTICATION-SET-ELEM
      ::= SEQUENCE {\n            pa-type      [0] Int32,\n                -- same
      as padata-type.\n            pa-hint      [1] OCTET STRING OPTIONAL,\n            pa-value
      \    [2] OCTET STRING OPTIONAL,\n            ...\n        }\n   The pa-type
      field of the PA-AUTHENTICATION-SET-ELEM structure\n   contains the corresponding
      value of padata-type in PA-DATA [RFC4120].\n   Associated with the pa-type is
      a pa-hint, which is an octet string\n   specified by the pre-authentication
      mechanism.  This hint may provide\n   information for the client that helps
      it determine whether the\n   mechanism can be used.  For example, a public-key
      mechanism might\n   include the certificate authorities it trusts in the hint
      info.  Most\n   mechanisms today do not specify hint info; if a mechanism does
      not\n   specify hint info, the KDC MUST NOT send a hint for that mechanism.\n
      \  To allow future revisions of mechanism specifications to add hint\n   info,
      clients MUST ignore hint info received for mechanisms that the\n   client believes
      do not support hint info.  The pa-value element of\n   the PA-AUTHENTICATION-SET-ELEM
      sequence is included to carry the\n   first padata-value from the KDC to the
      client.  If the client chooses\n   this authentication set, then the client
      MUST process this pa-value.\n   The pa-value element MUST be absent for all
      but the first entry in\n   the authentication set.  Clients MUST ignore the
      pa-value for the\n   second and following entries in the authentication set.\n
      \  If the client chooses an authentication set, then its first AS-REQ\n   message
      MUST contain a PA-AUTH-SET-SELECTED padata element.  This\n   element contains
      the encoding of the PA-AUTHENTICATION-SET sequence\n   received from the KDC
      corresponding to the authentication set that is\n   chosen.  The client MUST
      use the same octet values received from the\n   KDC; it cannot re-encode the
      sequence.  This allows KDCs to use bit-\n   wise comparison to identify the
      selected authentication set.\n   Permitting bit-wise comparison may limit the
      ability to use certain\n   pre-authentication mechanisms that generate a dynamic
      challenge in an\n   authentication set with optimistic selection of an authentication\n
      \  set.  As with other optimistic pre-authentication failures, the KDC\n   MAY
      return KDC_ERR_PREAUTH_FAILED with a new list of pre-\n   authentication mechanisms
      (including authentication sets) if\n   optimistic pre-authentication fails.
      \ The PA-AUTH-SET-SELECTED padata\n   element MUST come before any padata elements
      from the authentication\n   set in the padata sequence in the AS-REQ message.
      \ The client MAY\n   cache authentication sets from prior messages and use them
      to\n   construct an optimistic initial AS-REQ.  If the KDC receives a PA-\n
      \  AUTH-SET-SELECTED padata element that does not correspond to an\n   authentication
      set that it would offer, then the KDC returns the\n   KDC_ERR_PREAUTH_BAD_AUTHENTICATION_SET
      error.  The e-data in this\n   error contains a sequence of padata just as for
      the\n   KDC_ERR_PREAUTH_REQUIRED error.\n         PA-AUTH-SET-SELECTED                   135\n
      \        KDC_ERR_PREAUTH_BAD_AUTHENTICATION_SET 92\n   The PA-AUTHENTICATION-SET
      appears only in the first message from the\n   KDC to the client.  In particular,
      the client MAY fail if the\n   authentication mechanism sets change as the conversation
      progresses.\n   Clients MAY assume that the hints provided in the authentication
      set\n   contain enough information that the client knows what user interface\n
      \  elements need to be displayed during the entire authentication\n   conversation.
      \ Exceptional circumstances, such as expired passwords\n   or expired accounts,
      may require that additional user interface be\n   displayed.  Mechanism designers
      need to carefully consider the design\n   of their hints so that the client
      has this information.  This way,\n   clients can construct necessary dialogue
      boxes or wizards based on\n   the authentication set and can present a coherent
      user interface.\n   Current standards for user interfaces do not provide an
      acceptable\n   experience when the client has to ask additional questions later
      in\n   the conversation.\n   When indicating which sets of pre-authentication
      mechanisms are\n   supported, the KDC includes a PA-AUTHENTICATION-SET padata
      element\n   for each pre-authentication mechanism set.\n   The client sends
      the padata-value for the first mechanism it picks in\n   the pre-authentication
      set, when the first mechanism completes, the\n   client and the KDC will proceed
      with the second mechanism, and so on\n   until all mechanisms complete successfully.
      \ The PA-FX-COOKIE, as\n   defined in Section 5.2, MUST be sent by the KDC.
      \ One reason for this\n   requirement is so that the conversation can continue
      if the\n   conversation involves multiple KDCs.  KDCs MUST support clients that\n
      \  do not include a cookie because they optimistically choose an\n   authentication
      set, although they MAY always return a\n   KDC_ERR_PREAUTH_BAD_AUTHENTICATION_SET
      and include a cookie in that\n   message.  Clients that support PA-AUTHENTICATION-SET
      MUST support PA-\n   FX-COOKIE.\n   Before the authentication succeeds and a
      ticket is returned, the\n   message that the client sends is an AS-REQ and the
      message that the\n   KDC sends is a KRB-ERROR message.  The error code in the
      KRB-ERROR\n   message from the KDC is KDC_ERR_MORE_PREAUTH_DATA_REQUIRED as
      defined\n   in Section 5.2 and the accompanying e-data contains the DER encoding\n
      \  of ASN.1 type METHOD-DATA.  The KDC includes the padata elements in\n   the
      METHOD-DATA.  If there are no padata, the e-data field is absent\n   in the
      KRB-ERROR message.\n   If the client sends the last message for a given mechanism,
      then the\n   KDC sends the first message for the next mechanism.  If the next\n
      \  mechanism does not start with a KDC-side challenge, then the KDC\n   includes
      a padata item with the appropriate pa-type and an empty pa-\n   data.\n   If
      the KDC sends the last message for a particular mechanism, the KDC\n   also
      includes the first padata for the next mechanism.\n"
    title: 5.3.  Pre-Authentication Set
  - contents:
    - "5.4.  Definition of Kerberos FAST Padata\n   As described in [RFC4120], Kerberos
      is vulnerable to offline\n   dictionary attacks.  An attacker can request an
      AS-REP and try\n   various passwords to see if they can decrypt the resulting
      ticket.\n   RFC 4120 provides the encrypted timestamp pre-authentication method\n
      \  that ameliorates the situation somewhat by requiring that an attacker\n   observe
      a successful authentication.  However, stronger security is\n   desired in many
      environments.  The Kerberos FAST pre-authentication\n   padata defined in this
      section provides a tool to significantly\n   reduce vulnerability to offline
      dictionary attacks.  When combined\n   with encrypted challenge, FAST requires
      an attacker to mount a\n   successful man-in-the-middle attack to observe ciphertext.
      \ When\n   combined with host keys, FAST can even protect against active\n   attacks.
      \ FAST also provides solutions to common problems for pre-\n   authentication
      mechanisms such as binding of the request and the\n   reply and freshness guarantee
      of the authentication.  FAST itself,\n   however, does not authenticate the
      client or the KDC; instead, it\n   provides a typed hole to allow pre-authentication
      data be tunneled.\n   A pre-authentication data element used within FAST is
      called a \"FAST\n   factor\".  A FAST factor captures the minimal work required
      for\n   extending Kerberos to support a new pre-authentication scheme.\n   A
      FAST factor MUST NOT be used outside of FAST unless its\n   specification explicitly
      allows so.  The typed holes in FAST messages\n   can also be used as generic
      holes for other padata that are not\n   intended to prove the client's identity,
      or establish the reply key.\n   New pre-authentication mechanisms SHOULD be
      designed as FAST factors,\n   instead of full-blown pre-authentication mechanisms.\n
      \  FAST factors that are pre-authentication mechanisms MUST meet the\n   requirements
      in Section 4.\n   FAST employs an armoring scheme.  The armor can be a Ticket
      Granting\n   Ticket (TGT) obtained by the client's machine using the host keys
      to\n   pre-authenticate with the KDC, or an anonymous TGT obtained based on\n
      \  anonymous PKINIT [RFC6112] [RFC4556].\n   The rest of this section describes
      the types of armors and the syntax\n   of the messages used by FAST.  Conforming
      implementations MUST\n   support Kerberos FAST padata.\n   Any FAST armor scheme
      MUST provide a fresh armor key for each\n   conversation.  Clients and KDCs
      can assume that if a message is\n   encrypted and integrity protected with a
      given armor key, then it is\n   part of the conversation using that armor key.\n
      \  All KDCs in a realm MUST support FAST if FAST is offered by any KDC\n   as
      a pre-authentication mechanism.\n"
    - contents:
      - "5.4.1.  FAST Armors\n   An armor key is used to encrypt pre-authentication
        data in the FAST\n   request and the response.  The KrbFastArmor structure
        is defined to\n   identify the armor key.  This structure contains the following
        two\n   fields: the armor-type identifies the type of armors and the armor-\n
        \  value is an OCTET STRING that contains the description of the armor\n   scheme
        and the armor key.\n        KrbFastArmor ::= SEQUENCE {\n            armor-type
        \  [0] Int32,\n                -- Type of the armor.\n            armor-value
        \ [1] OCTET STRING,\n                -- Value of the armor.\n            ...\n
        \       }\n   The value of the armor key is a matter of the armor type\n   specification.
        \ Only one armor type is defined in this document.\n        FX_FAST_ARMOR_AP_REQUEST
        \          1\n   The FX_FAST_ARMOR_AP_REQUEST armor is based on Kerberos tickets.\n
        \  Conforming implementations MUST implement the\n   FX_FAST_ARMOR_AP_REQUEST
        armor type.  If a FAST KDC receives an\n   unknown armor type it MUST respond
        with KDC_ERR_PREAUTH_FAILED.\n   An armor type may be appropriate for use
        in armoring AS requests,\n   armoring TGS requests, or both.  TGS armor types
        MUST authenticate\n   the client to the KDC, typically by binding the TGT
        sub-session key\n   to the armor key.  As discussed below, it is desirable
        for AS armor\n   types to authenticate the KDC to the client, but this is
        not\n   required.\n   FAST implementations MUST maintain state about whether
        the armor\n   mechanism authenticates the KDC.  If it does not, then a FAST
        factor\n   that authenticates the KDC MUST be used if the reply key is replaced.\n"
      - contents:
        - "5.4.1.1.  Ticket-Based Armors\n   This is a ticket-based armoring scheme.
          \ The armor-type is\n   FX_FAST_ARMOR_AP_REQUEST, the armor-value contains
          an ASN.1 DER\n   encoded AP-REQ.  The ticket in the AP-REQ is called an
          armor ticket\n   or an armor TGT.  The subkey field in the AP-REQ MUST be
          present.\n   The armor key is defined by the following function:\n       armor_key
          = KRB-FX-CF2( subkey, ticket_session_key,\n                   \"subkeyarmor\",
          \"ticketarmor\" )\n   The 'ticket_session_key' is the session key from the
          ticket in the\n   ap-req.  The 'subkey' is the ap-req subkey.  This construction\n
          \  guarantees that both the KDC (through the session key) and the client\n
          \  (through the subkey) contribute to the armor key.\n   The server name
          field of the armor ticket MUST identify the TGS of\n   the target realm.
          \ Here are three common ways in the decreasing\n   preference order how
          an armor TGT SHOULD be obtained:\n   1.  If the client is authenticating
          from a host machine whose\n       Kerberos realm has an authentication path
          to the client's realm,\n       the host machine obtains a TGT by using the
          host keys.  If the\n       client's realm is different than the realm of
          the local host, the\n       machine then obtains a cross-realm TGT to the
          client's realm as\n       the armor ticket.  Otherwise, the host's primary
          TGT is the armor\n       ticket.\n   2.  If the client's host machine cannot
          obtain a host ticket strictly\n       based on RFC 4120, but the KDC has
          an asymmetric signing key\n       whose binding with the expected KDC can
          be verified by the\n       client, the client can use anonymous PKINIT [RFC6112]
          [RFC4556]\n       to authenticate the KDC and obtain an anonymous TGT as
          the armor\n       ticket.  The armor ticket can also be a cross-realm TGT
          obtained\n       based on the initial primary TGT obtained using anonymous
          PKINIT\n       with KDC authentication.\n   3.  Otherwise, the client uses
          anonymous PKINIT to get an anonymous\n       TGT without KDC authentication
          and that TGT is the armor ticket.\n       Note that this mode of operation
          is vulnerable to man-in-the-\n       middle attacks at the time of obtaining
          the initial anonymous\n       armor TGT.\n   If anonymous PKINIT is used
          to obtain the armor ticket, the KDC\n   cannot know whether its signing
          key can be verified by the client;\n   hence, the KDC MUST be marked as
          unverified from the KDC's point of\n   view while the client could be able
          to authenticate the KDC by\n   verifying the KDC's signing key is bound
          with the expected KDC.  The\n   client needs to carefully consider the risk
          and benefit tradeoffs\n   associated with active attacks before exposing
          cipher text encrypted\n   using the user's long-term secrets when the armor
          does not\n   authenticate the KDC.\n   The TGS MUST reject a request if
          there is an AD-fx-fast-armor (71)\n   element in the authenticator of the
          pa-tgs-req padata or if the\n   ticket in the authenticator of a pa-tgs-req
          contains the AD-fx-fast-\n   armor authorization data element.  These tickets
          and authenticators\n   MAY be used as FAST armor tickets but not to obtain
          a ticket via the\n   TGS.  This authorization data is used in a system where
          the\n   encryption of the user's pre-authentication data is performed in
          an\n   unprivileged user process.  A privileged process can provide to the\n
          \  user process a host ticket, an authenticator for use with that\n   ticket,
          and the sub-session key contained in the authenticator.  In\n   order for
          the host process to ensure that the host ticket is not\n   accidentally
          or intentionally misused, (i.e., the user process might\n   use the host
          ticket to authenticate as the host), it MUST include a\n   critical authorization
          data element of the type AD-fx-fast-armor when\n   providing the authenticator
          or in the enc-authorization-data field of\n   the TGS request used to obtain
          the TGT.  The corresponding ad-data\n   field of the AD-fx-fast-armor element
          is empty.\n   This armor type is only valid for AS requests; implicit armor,\n
          \  described below in TGS processing, is the only supported way to\n   establish
          an armor key for the TGS at this time.\n"
        title: 5.4.1.1.  Ticket-Based Armors
      title: 5.4.1.  FAST Armors
    - contents:
      - "5.4.2.  FAST Request\n   A padata type PA-FX-FAST is defined for the Kerberos
        FAST pre-\n   authentication padata.  The corresponding padata-value field\n
        \  [RFC4120] contains the DER encoding of the ASN.1 type PA-FX-FAST-\n   REQUEST.
        \ As with all pre-authentication types, the KDC SHOULD\n   advertise PA-FX-FAST
        in a PREAUTH_REQUIRED error.  KDCs MUST send the\n   advertisement of PA-FX-FAST
        with an empty pa-value.  Clients MUST\n   ignore the pa-value of PA-FX-FAST
        in an initial PREAUTH_REQUIRED\n   error.  FAST is not expected to be used
        in an authentication set:\n   clients will typically use FAST padata if available
        and this decision\n   should not depend on what other pre-authentication methods
        are\n   available.  As such, no pa-hint is defined for FAST at this time.\n
        \      PA-FX-FAST                         136\n           -- Padata type for
        Kerberos FAST\n       PA-FX-FAST-REQUEST ::= CHOICE {\n           armored-data
        [0] KrbFastArmoredReq,\n           ...\n       }\n       KrbFastArmoredReq
        ::= SEQUENCE {\n           armor        [0] KrbFastArmor OPTIONAL,\n               --
        Contains the armor that identifies the armor key.\n               -- MUST
        be present in AS-REQ.\n           req-checksum [1] Checksum,\n               --
        For AS, contains the checksum performed over the type\n               -- KDC-REQ-BODY
        for the req-body field of the KDC-REQ\n               -- structure;\n               --
        For TGS, contains the checksum performed over the type\n               --
        AP-REQ in the PA-TGS-REQ padata.\n               -- The checksum key is the
        armor key, the checksum\n               -- type is the required checksum type
        for the enctype of\n               -- the armor key, and the key usage number
        is\n               -- KEY_USAGE_FAST_REQ_CHKSUM.\n           enc-fast-req
        [2] EncryptedData, -- KrbFastReq --\n               -- The encryption key
        is the armor key, and the key usage\n               -- number is KEY_USAGE_FAST_ENC.\n
        \          ...\n       }\n       KEY_USAGE_FAST_REQ_CHKSUM          50\n       KEY_USAGE_FAST_ENC
        \                51\n   The PA-FX-FAST-REQUEST structure contains a KrbFastArmoredReq
        type.\n   The KrbFastArmoredReq encapsulates the encrypted padata.\n   The
        enc-fast-req field contains an encrypted KrbFastReq structure.\n   The armor
        key is used to encrypt the KrbFastReq structure, and the\n   key usage number
        for that encryption is KEY_USAGE_FAST_ENC.\n   The armor key is selected as
        follows:\n   o  In an AS request, the armor field in the KrbFastArmoredReq\n
        \     structure MUST be present and the armor key is identified\n      according
        to the specification of the armor type.\n   o  There are two possibilities
        for armor for a TGS request.  If the\n      ticket presented in the PA-TGS-REQ
        authenticator is a TGT, then\n      the client SHOULD NOT include the armor
        field in the Krbfastreq\n      and a subkey MUST be included in the PA-TGS-REQ
        authenticator.  In\n      this case, the armor key is the same armor key that
        would be\n      computed if the TGS-REQ authenticator was used in an\n      FX_FAST_ARMOR_AP_REQUEST
        armor.  Clients MAY present a non-TGT in\n      the PA-TGS-REQ authenticator
        and omit the armor field, in which\n      case the armor key is the same that
        would be computed if the\n      authenticator were used in an FX_FAST_ARMOR_AP_REQUEST
        armor.\n      This is the only case where a ticket other than a TGT can be
        used\n      to establish an armor key; even though the armor key is computed\n
        \     the same as an FX_FAST_ARMOR_AP_REQUEST, a non-TGT cannot be used\n
        \     as an armor ticket in FX_FAST_ARMOR_AP_REQUEST.  Alternatively, a\n
        \     client MAY use an armor type defined in the future for use with\n      the
        TGS request.\n   The req-checksum field contains a checksum computed differently
        for\n   AS and TGS.  For an AS-REQ, it is performed over the type KDC-REQ-\n
        \  BODY for the req-body field of the KDC-REQ structure of the\n   containing
        message; for a TGS-REQ, it is performed over the type AP-\n   REQ in the PA-TGS-REQ
        padata of the TGS request.  The checksum key is\n   the armor key, and the
        checksum type is the required checksum type\n   for the enctype of the armor
        key per [RFC3961].  This checksum MUST\n   be a keyed checksum and it is included
        in order to bind the FAST\n   padata to the outer request.  A KDC that implements
        FAST will ignore\n   the outer request, but including a checksum is relatively
        cheap and\n   may prevent confusing behavior.\n   The KrbFastReq structure
        contains the following information:\n        KrbFastReq ::= SEQUENCE {\n            fast-options
        [0] FastOptions,\n                -- Additional options.\n            padata
        \      [1] SEQUENCE OF PA-DATA,\n                -- padata typed holes.\n
        \           req-body     [2] KDC-REQ-BODY,\n                -- Contains the
        KDC request body as defined in Section\n                -- 5.4.1 of [RFC4120].\n
        \               -- This req-body field is preferred over the outer field\n
        \               -- in the KDC request.\n             ...\n        }\n   The
        fast-options field indicates various options that are to modify\n   the behavior
        of the KDC.  The following options are defined:\n        FastOptions ::= KerberosFlags\n
        \           -- reserved(0),\n            -- hide-client-names(1),\n       Bits
        \   Name                    Description\n      -----------------------------------------------------------------\n
        \      0     RESERVED              Reserved for future expansion of this\n
        \                                  field.\n       1     hide-client-names
        \    Requesting the KDC to hide client\n                                   names
        in the KDC response, as\n                                   described next
        in this section.\n       16    kdc-follow-referrals  reserved [REFERRALS].\n
        \  Bits 1 through 15 inclusive (with bit 1 and bit 15 included) are\n   critical
        options.  If the KDC does not support a critical option, it\n   MUST fail
        the request with KDC_ERR_UNKNOWN_CRITICAL_FAST_OPTIONS, and\n   there is no
        accompanying e-data defined in this document for this\n   error code.  Bit
        16 and onward (with bit 16 included) are non-\n   critical options.  KDCs
        conforming to this specification ignore\n   unknown non-critical options.\n
        \       KDC_ERR_UNKNOWN_CRITICAL_FAST_OPTIONS   93\n   The hide-client-names
        Option\n      The Kerberos response defined in [RFC4120] contains the client\n
        \     identity in cleartext.  This makes traffic analysis\n      straightforward.
        \ The hide-client-names option is designed to\n      complicate traffic analysis.
        \ If the hide-client-names option is\n      set, the KDC implementing PA-FX-FAST
        MUST identify the client as\n      the anonymous principal [RFC6112] in the
        KDC reply and the error\n      response.  Hence, this option is set by the
        client if it wishes to\n      conceal the client identity in the KDC response.
        \ A conforming KDC\n      ignores the client principal name in the outer KDC-REQ-BODY
        field,\n      and identifies the client using the cname and crealm fields
        in the\n      req-body field of the KrbFastReq structure.\n   The kdc-follow-referrals
        Option\n      This option is reserved for [REFERRALS].\n   The padata field
        contains a list of PA-DATA structures as described\n   in Section 5.2.7 of
        [RFC4120].  These PA-DATA structures can contain\n   FAST factors.  They can
        also be used as generic typed-holes to\n   contain data not intended for proving
        the client's identity or\n   establishing a reply key, but for protocol extensibility.
        \ If the KDC\n   supports the PA-FX-FAST-REQUEST padata, unless otherwise
        specified,\n   the client MUST place any padata that is otherwise in the outer
        KDC\n   request body into this field.  In a TGS request, PA-TGS-REQ padata
        is\n   not included in this field and it is present in the outer KDC request\n
        \  body.\n   The KDC-REQ-BODY in the FAST structure is used in preference
        to the\n   KDC-REQ-BODY outside of the FAST pre-authentication.  The outer
        KDC-\n   REQ-BODY structure SHOULD be filled in for backwards compatibility\n
        \  with KDCs that do not support FAST.  A conforming KDC ignores the\n   outer
        KDC-REQ-BODY field in the KDC request.  Pre-authentication data\n   methods
        such as [RFC4556] that include a checksum of the KDC-REQ-BODY\n   should checksum
        the KDC-REQ-BODY in the FAST structure.\n   In a TGS request, a client MAY
        include the AD-fx-fast-used authdata\n   either in the pa-tgs-req authenticator
        or in the authorization data\n   in the pa-tgs-req ticket.  If the KDC receives
        this authorization\n   data but does not find a FAST padata, then it MUST
        return\n   KRB_APP_ERR_MODIFIED.\n"
      title: 5.4.2.  FAST Request
    - contents:
      - "5.4.3.  FAST Response\n   The KDC that supports the PA-FX-FAST padata MUST
        include a PA-FX-FAST\n   padata element in the KDC reply.  In the case of
        an error, the PA-FX-\n   FAST padata is included in the KDC responses according
        to\n   Section 5.4.4.\n   The corresponding padata-value field [RFC4120] for
        the PA-FX-FAST in\n   the KDC response contains the DER encoding of the ASN.1
        type PA-FX-\n   FAST-REPLY.\n      PA-FX-FAST-REPLY ::= CHOICE {\n          armored-data
        [0] KrbFastArmoredRep,\n          ...\n      }\n      KrbFastArmoredRep ::=
        SEQUENCE {\n          enc-fast-rep      [0] EncryptedData, -- KrbFastResponse
        --\n              -- The encryption key is the armor key in the request, and\n
        \             -- the key usage number is KEY_USAGE_FAST_REP.\n          ...\n
        \     }\n      KEY_USAGE_FAST_REP                 52\n   The PA-FX-FAST-REPLY
        structure contains a KrbFastArmoredRep\n   structure.  The KrbFastArmoredRep
        structure encapsulates the padata\n   in the KDC reply in the encrypted form.
        \ The KrbFastResponse is\n   encrypted with the armor key used in the corresponding
        request, and\n   the key usage number is KEY_USAGE_FAST_REP.\n   The Kerberos
        client MUST support a local policy that rejects the\n   response if PA-FX-FAST-REPLY
        is not included in the response.\n   Clients MAY also support policies that
        fall back to other mechanisms\n   or that do not use pre-authentication when
        FAST is unavailable.  It\n   is important to consider the potential downgrade
        attacks when\n   deploying such a policy.\n   The KrbFastResponse structure
        contains the following information:\n       KrbFastResponse ::= SEQUENCE {\n
        \          padata         [0] SEQUENCE OF PA-DATA,\n               -- padata
        typed holes.\n           strengthen-key [1] EncryptionKey OPTIONAL,\n               --
        This, if present, strengthens the reply key for AS and\n               --
        TGS. MUST be present for TGS.\n               -- MUST be absent in KRB-ERROR.\n
        \          finished       [2] KrbFastFinished OPTIONAL,\n               --
        Present in AS or TGS reply; absent otherwise.\n           nonce          [3]
        UInt32,\n               -- Nonce from the client request.\n           ...\n
        \ }\n   The padata field in the KrbFastResponse structure contains a list
        of\n   PA-DATA structures as described in Section 5.2.7 of [RFC4120].  These\n
        \  PA-DATA structures are used to carry data advancing the exchange\n   specific
        for the FAST factors.  They can also be used as generic\n   typed-holes for
        protocol extensibility.  Unless otherwise specified,\n   the KDC MUST include
        any padata that are otherwise in the outer KDC-\n   REP or KDC-ERROR structure
        into this field.  The padata field in the\n   KDC reply structure outside
        of the PA-FX-FAST-REPLY structure\n   typically includes only the PA-FX-FAST-REPLY
        padata.\n   The strengthen-key field provides a mechanism for the KDC to\n
        \  strengthen the reply key.  If set, the strengthen-key value MUST be\n   randomly
        generated to have the same etype as that of the reply key\n   before being
        strengthened, and then the reply key is strengthened\n   after all padata
        items are processed.  Let padata-reply-key be the\n   reply key after padata
        processing.\n   reply-key = KRB-FX-CF2(strengthen-key, padata-reply-key,\n
        \                        \"strengthenkey\", \"replykey\")\n   The strengthen-key
        field MAY be set in an AS reply; it MUST be set in\n   a TGS reply; it must
        be absent in an error reply.  The strengthen key\n   is required in a TGS
        reply so that an attacker cannot remove the FAST\n   PADATA from a TGS reply,
        causing the KDC to appear not to support\n   FAST.\n   The finished field
        contains a KrbFastFinished structure.  It is\n   filled by the KDC in the
        final message in the conversation.  This\n   field is present in an AS-REP
        or a TGS-REP when a ticket is returned,\n   and it is not present in an error
        reply.\n   The KrbFastFinished structure contains the following information:\n
        \       KrbFastFinished ::= SEQUENCE {\n            timestamp       [0] KerberosTime,\n
        \           usec            [1] Microseconds,\n                -- timestamp
        and usec represent the time on the KDC when\n                -- the reply
        was generated.\n            crealm          [2] Realm,\n            cname
        \          [3] PrincipalName,\n                -- Contains the client realm
        and the client name.\n            ticket-checksum [4] Checksum,\n                --
        checksum of the ticket in the KDC-REP using the armor\n                --
        and the key usage is KEY_USAGE_FAST_FINISH.\n                -- The checksum
        type is the required checksum type\n                -- of the armor key.\n
        \           ...\n        }\n        KEY_USAGE_FAST_FINISHED            53\n
        \  The timestamp and usec fields represent the time on the KDC when the\n
        \  reply ticket was generated, these fields have the same semantics as\n   the
        corresponding identically named fields in Section 5.6.1 of\n   [RFC4120].
        \ The client MUST use the KDC's time in these fields\n   thereafter when using
        the returned ticket.  The client need not\n   confirm that the timestamp returned
        is within allowable clock skew:\n   the armor key guarantees that the reply
        is fresh.  The client MAY\n   trust the timestamp returned.\n   The cname
        and crealm fields identify the authenticated client.  If\n   facilities described
        in [REFERRALS] are used, the authenticated\n   client may differ from the
        client in the FAST request.\n   The ticket-checksum is a checksum of the issued
        ticket.  The checksum\n   key is the armor key, and the checksum type is the
        required checksum\n   type of the enctype of that key, and the key usage number
        is\n   KEY_USAGE_FAST_FINISHED.\n   When FAST padata is included, the PA-FX-COOKIE
        padata as defined in\n   Section 5.2 MUST be included in the padata sequence
        in the\n   KrbFastResponse sequence if the KDC expects at least one more message\n
        \  from the client in order to complete the authentication.\n   The nonce
        field in the KrbFastResponse contains the value of the\n   nonce field in
        the KDC-REQ of the corresponding client request and it\n   binds the KDC response
        with the client request.  The client MUST\n   verify that this nonce value
        in the reply matches with that of the\n   request and reject the KDC reply
        otherwise.  To prevent the response\n   from one message in a conversation
        from being replayed to a request\n   in another message, clients SHOULD use
        a new nonce for each message\n   in a conversation.\n"
      title: 5.4.3.  FAST Response
    - contents:
      - "5.4.4.  Authenticated Kerberos Error Messages Using Kerberos FAST\n   If
        the Kerberos FAST padata was included in the request, unless\n   otherwise
        specified, the e-data field of the KRB-ERROR message\n   [RFC4120] contains
        the ASN.1 DER encoding of the type METHOD-DATA\n   [RFC4120] and a PA-FX-FAST
        is included in the METHOD-DATA.  The KDC\n   MUST include all the padata elements
        such as PA-ETYPE-INFO2 and\n   padata elements that indicate acceptable pre-authentication\n
        \  mechanisms [RFC4120] in the KrbFastResponse structure.\n   The KDC MUST
        also include a PA-FX-ERROR padata item in the\n   KRBFastResponse structure.
        \ The padata-value element of this sequence\n   is the ASN.1 DER encoding
        of the type KRB-ERROR.  The e-data field\n   MUST be absent in the PA-FX-ERROR
        padata.  All other fields should be\n   the same as the outer KRB-ERROR.  The
        client ignores the outer error\n   and uses the combination of the padata
        in the KRBFastResponse and the\n   error information in the PA-FX-ERROR.\n
        \             PA-FX-ERROR                        137\n   If the Kerberos FAST
        padata is included in the request but not\n   included in the error reply,
        it is a matter of the local policy on\n   the client to accept the information
        in the error message without\n   integrity protection.  However, the client
        SHOULD process the KDC\n   errors as the result of the KDC's inability to
        accept the AP_REQ\n   armor and potentially retry another request with a different
        armor\n   when applicable.  The Kerberos client MAY process an error message\n
        \  without a PA-FX-FAST-REPLY, if that is only intended to return better\n
        \  error information to the application, typically for trouble-shooting\n
        \  purposes.\n   In the cases where the e-data field of the KRB-ERROR message
        is\n   expected to carry a TYPED-DATA [RFC4120] element, that information\n
        \  should be transmitted in a pa-data element within the KRBFastResponse\n
        \  structure.  The padata-type is the same as the data-type would be in\n
        \  the typed data element and the padata-value is the same as the data-\n
        \  value.  As discussed in Section 7, data-types and padata-types are\n   drawn
        from the same namespace.  For example, the\n   TD_TRUSTED_CERTIFIERS structure
        is expected to be in the KRB-ERROR\n   message when the error code is KDC_ERR_CANT_VERIFY_CERTIFICATE\n
        \  [RFC4556].\n"
      title: 5.4.4.  Authenticated Kerberos Error Messages Using Kerberos FAST
    - contents:
      - "5.4.5.  Outer and Inner Requests\n   Typically, a client will know that FAST
        is being used before a\n   request containing PA-FX-FAST is sent.  So, the
        outer AS request\n   typically only includes one pa-data item: PA-FX-FAST.
        \ The client MAY\n   include additional pa-data, but the KDC MUST ignore the
        outer request\n   body and any padata besides PA-FX-FAST if and only if PA-FX-FAST
        is\n   processed.  In the case of the TGS request, the outer request should\n
        \  include PA-FX-FAST and PA-TGS-REQ.\n   When an AS generates a response,
        all padata besides PA-FX-FAST should\n   be included in PA-FX-FAST.  The client
        MUST ignore other padata\n   outside of PA-FX-FAST.\n"
      title: 5.4.5.  Outer and Inner Requests
    - contents:
      - "5.4.6.  The Encrypted Challenge FAST Factor\n   The encrypted challenge FAST
        factor authenticates a client using the\n   client's long-term key.  This
        factor works similarly to the encrypted\n   timestamp pre-authentication option
        described in [RFC4120].  The word\n   \"challenge\" is used instead of \"timestamp\"
        because while the\n   timestamp is used as an initial challenge, if the KDC
        and client do\n   not have synchronized time, then the KDC can provide updated
        time to\n   the client to use as a challenge.  The client encrypts a structure\n
        \  containing a timestamp in the challenge key.  The challenge key used\n
        \  by the client to send a message to the KDC is KRB-FX-\n   CF2(armor_key,long_term_key,
        \"clientchallengearmor\",\n   \"challengelongterm\").  The challenge key used
        by the KDC encrypting\n   to the client is KRB-FX-CF2(armor_key, long_term_key,\n
        \  \"kdcchallengearmor\", \"challengelongterm\").  Because the armor key is\n
        \  fresh and random, the challenge key is fresh and random.  The only\n   purpose
        of the timestamp is to limit the validity of the\n   authentication so that
        a request cannot be replayed.  A client MAY\n   base the timestamp on the
        KDC time in a KDC error and need not\n   maintain accurate time synchronization
        itself.  If a client bases its\n   time on an untrusted source, an attacker
        may trick the client into\n   producing an authentication request that is
        valid at some future\n   time.  The attacker may be able to use this authentication
        request to\n   make it appear that a client has authenticated at that future
        time.\n   If ticket-based armor is used, then the lifetime of the ticket will\n
        \  limit the window in which an attacker can make the client appear to\n   have
        authenticated.  For many situations, the ability of an attacker\n   to cause
        a client to appear to have authenticated is not a\n   significant concern;
        the ability to avoid requiring time\n   synchronization on clients is more
        valuable.\n   The client sends a padata of type PA-ENCRYPTED-CHALLENGE.  The\n
        \  corresponding padata-value contains the DER encoding of ASN.1 type\n   EncryptedChallenge.\n
        \     EncryptedChallenge ::= EncryptedData\n              -- Encrypted PA-ENC-TS-ENC,
        encrypted in the challenge key\n              -- using key usage KEY_USAGE_ENC_CHALLENGE_CLIENT
        for the\n              -- client and KEY_USAGE_ENC_CHALLENGE_KDC for the KDC.\n
        \     PA-ENCRYPTED-CHALLENGE          138\n      KEY_USAGE_ENC_CHALLENGE_CLIENT
        \ 54\n      KEY_USAGE_ENC_CHALLENGE_KDC     55\n   The client includes some
        timestamp reasonably close to the KDC's\n   current time and encrypts it in
        the challenge key in a PA-ENC-TS-ENC\n   structure (see Section 5.2.7.2 in
        RFC 4120).  Clients MAY use the\n   current time; doing so prevents the exposure
        where an attacker can\n   cause a client to appear to authenticate in the
        future.  The client\n   sends the request including this factor.\n   On receiving
        an AS-REQ containing the PA-ENCRYPTED-CHALLENGE FAST\n   factor, the KDC decrypts
        the timestamp.  If the decryption fails the\n   KDC SHOULD return KDC_ERR_PREAUTH_FAILED,
        including PA-ETYPE-INFO2 in\n   the KRBFastResponse in the error.  The KDC
        confirms that the\n   timestamp falls within its current clock skew returning\n
        \  KRB_APP_ERR_SKEW if not.  The KDC then SHOULD check to see if the\n   encrypted
        challenge is a replay.  The KDC MUST NOT consider two\n   encrypted challenges
        replays simply because the timestamps are the\n   same; to be a replay, the
        ciphertext MUST be identical.  Allowing\n   clients to reuse timestamps avoids
        requiring that clients maintain\n   state about which timestamps have been
        used.\n   If the KDC accepts the encrypted challenge, it MUST include a padata\n
        \  element of type PA-ENCRYPTED-CHALLENGE.  The KDC encrypts its current\n
        \  time in the challenge key.  The KDC MUST strengthen the reply key\n   before
        issuing a ticket.  The client MUST check that the timestamp\n   decrypts properly.
        \ The client MAY check that the timestamp is within\n   the window of acceptable
        clock skew for the client.  The client MUST\n   NOT require that the timestamp
        be identical to the timestamp in the\n   issued credentials or the returned
        message.\n   The encrypted challenge FAST factor provides the following\n
        \  facilities: Client Authentication and KDC Authentication.  This FAST\n
        \  factor also takes advantage of the FAST facility to strengthen the\n   reply
        key.  It does not provide the Replace Reply Key facility.  The\n   Security
        Considerations section of this document provides an\n   explanation why the
        security requirements are met.\n   The encrypted challenge FAST factor can
        be useful in an\n   authentication set.  No pa-hint is defined because the
        only\n   information needed by this mechanism is information contained in
        the\n   PA-ETYPE-INFO2 pre-authentication data.  KDCs are already required
        to\n   send PA-ETYPE-INFO2.  If KDCs were not required to send PA-ETYPE-\n
        \  INFO2 then that information would need to be part of a hint for\n   encrypted
        challenge.\n   Conforming implementations MUST support the encrypted challenge
        FAST\n   factor.\n"
      title: 5.4.6.  The Encrypted Challenge FAST Factor
    title: 5.4.  Definition of Kerberos FAST Padata
  - contents:
    - "5.5.  Authentication Strength Indication\n   Implementations that have pre-authentication
      mechanisms offering\n   significantly different strengths of client authentication
      MAY choose\n   to keep track of the strength of the authentication used as an
      input\n   into policy decisions.  For example, some principals might require\n
      \  strong pre-authentication, while less sensitive principals can use\n   relatively
      weak forms of pre-authentication like encrypted timestamp.\n   An AuthorizationData
      data type AD-Authentication-Strength is defined\n   for this purpose.\n        AD-authentication-strength
      \        70\n   The corresponding ad-data field contains the DER encoding of
      the pre-\n   authentication data set as defined in Section 5.3.  This set contains\n
      \  all the pre-authentication mechanisms that were used to authenticate\n   the
      client.  If only one pre-authentication mechanism was used to\n   authenticate
      the client, the pre-authentication set contains one\n   element.  Unless otherwise
      specified, the hint and value fields of\n   the members of this sequence MUST
      be empty.  In order to permit\n   mechanisms to carry additional information
      about strength in these\n   fields in the future, clients and application servers
      MUST ignore\n   non-empty hint and value fields for mechanisms unless the\n
      \  implementation is updated with the interpretation of these fields for\n   a
      given pre-authentication mechanism in this authorization element.\n   The AD-authentication-strength
      element MUST be included in the AD-\n   KDC-ISSUED container so that the KDC
      integrity protects its contents.\n   This element can be ignored if it is unknown
      to the receiver.\n"
    title: 5.5.  Authentication Strength Indication
  title: 5.  Tools for Use in Pre-Authentication Mechanisms
- contents:
  - "6.  Assigned Constants\n   The pre-authentication framework and FAST involve
    using a number of\n   Kerberos protocol constants.  This section lists protocol
    constants\n   first introduced in this specification drawn from registries not\n
    \  managed by IANA.  Many of these registries would best be managed by\n   IANA;
    that is a known issue that is out of scope for this document.\n   The constants
    described in this section have been accounted for and\n   will appear in the next
    revision of the Kerberos core specification\n   or in a document creating IANA
    registries.\n   Section 7 creates IANA registries for a different set of constants\n
    \  used by the extensions described in this document.\n"
  - contents:
    - "6.1.  New Errors\n           KDC_ERR_PREAUTH_EXPIRED                 90\n           KDC_ERR_MORE_PREAUTH_DATA_REQUIRED
      \     91\n           KDC_ERR_PREAUTH_BAD_AUTHENTICATION_SET  92\n           KDC_ERR_UNKNOWN_CRITICAL_FAST_OPTIONS
      \  93\n"
    title: 6.1.  New Errors
  - contents:
    - "6.2.  Key Usage Numbers\n           KEY_USAGE_FAST_REQ_CHKSUM               50\n
      \          KEY_USAGE_FAST_ENC                      51\n           KEY_USAGE_FAST_REP
      \                     52\n           KEY_USAGE_FAST_FINISHED                 53\n
      \          KEY_USAGE_ENC_CHALLENGE_CLIENT          54\n           KEY_USAGE_ENC_CHALLENGE_KDC
      \            55\n"
    title: 6.2.  Key Usage Numbers
  - contents:
    - "6.3.  Authorization Data Elements\n           AD-authentication-strength              70\n
      \          AD-fx-fast-armor                        71\n           AD-fx-fast-used
      \                        72\n"
    title: 6.3.  Authorization Data Elements
  - contents:
    - "6.4.  New PA-DATA Types\n           PA-FX-COOKIE                            133\n
      \          PA-AUTHENTICATION-SET                   134\n           PA-AUTH-SET-SELECTED
      \                   135\n           PA-FX-FAST                              136\n
      \          PA-FX-ERROR                             137\n           PA-ENCRYPTED-CHALLENGE
      \                 138\n"
    title: 6.4.  New PA-DATA Types
  title: 6.  Assigned Constants
- contents:
  - "7.  IANA Considerations\n   This document creates a number of IANA registries.
    \ These registries\n   are all located under Kerberos Parameters on http://www.iana.org.\n
    \  See [RFC5226] for descriptions of the registration policies used in\n   this
    section.\n"
  - contents:
    - "7.1.  Pre-Authentication and Typed Data\n   RFC 4120 defines pre-authentication
      data, which can be included in a\n   KDC request or response in order to authenticate
      the client or extend\n   the protocol.  In addition, it defines Typed-Data,
      which is an\n   extension mechanism for errors.  Both pre-authentication data
      and\n   typed data are carried as a 32-bit signed integer along with an octet\n
      \  string.  The encoding of typed data and pre-authentication data is\n   slightly
      different.  However, the types for pre-authentication data\n   and typed-data
      are drawn from the same namespace.  By convention,\n   registrations starting
      with TD- are typed data and registrations\n   starting with PA- are pre-authentication
      data.  It is important that\n   these data types be drawn from the same namespace,
      because some\n   errors where it would be desirable to include typed data require
      the\n   e-data field to be formatted as pre-authentication data.\n   When Kerberos
      FAST is used, pre-authentication data encoding is\n   always used.\n   There
      is one apparently conflicting registration between typed data\n   and pre-authentication
      data.  PA-GET-FROM-TYPED-DATA and TD-PADATA\n   are both assigned the value
      22.  However, this registration is simply\n   a mechanism to include an element
      of the other encoding.  The use of\n   both should be deprecated.\n   This document
      creates a registry for pre-authentication and typed\n   data.  The registration
      procedures are as follows.  Expert review for\n   pre-authentication mechanisms
      designed to authenticate users, KDCs,\n   or establish the reply key.  The expert
      first determines that the\n   purpose of the method is to authenticate clients,
      KDCs, or to\n   establish the reply key.  If so, expert review is appropriate.
      \ The\n   expert evaluates the security and interoperability of the\n   specification.\n
      \  IETF review is required if the expert believes that the pre-\n   authentication
      method is broader than these three areas.  Pre-\n   authentication methods that
      change the Kerberos state machine or\n   otherwise make significant changes
      to the Kerberos protocol should be\n   Standards Track RFCs.  A concern that
      a particular method needs to be\n   a Standards Track RFC may be raised as an
      objection during IETF\n   review.\n   Several of the registrations indicated
      below were made at a time when\n   the Kerberos protocol was less mature and
      do not meet the current\n   requirements for this registry.  These registrations
      are included in\n   order to accurately document what is known about the use
      of these\n   protocol code points and to avoid conflicts.\n     Type                Value
      \   Reference\n ----------------------------------------------------------------------\n
      PA-TGS-REQ                 1    [RFC4120]\n PA-ENC-TIMESTAMP           2    [RFC4120]\n
      PA-PW-SALT                 3    [RFC4120]\n [reserved]                 4    [RFC6113]\n
      PA-ENC-UNIX-TIME           5    (deprecated) [RFC4120]\n PA-SANDIA-SECUREID
      \        6    [RFC4120]\n PA-SESAME                  7    [RFC4120]\n PA-OSF-DCE
      \                8    [RFC4120]\n PA-CYBERSAFE-SECUREID      9    [RFC4120]\n
      PA-AFS3-SALT               10   [RFC4120] [RFC3961]\n PA-ETYPE-INFO              11
      \  [RFC4120]\n PA-SAM-CHALLENGE           12   [KRB-WG.SAM]\n PA-SAM-RESPONSE
      \           13   [KRB-WG.SAM]\n PA-PK-AS-REQ_OLD           14   [PK-INIT-1999]\n
      PA-PK-AS-REP_OLD           15   [PK-INIT-1999]\n PA-PK-AS-REQ               16
      \  [RFC4556]\n PA-PK-AS-REP               17   [RFC4556]\n PA-PK-OCSP-RESPONSE
      \       18   [RFC4557]\n PA-ETYPE-INFO2             19   [RFC4120]\n PA-USE-SPECIFIED-KVNO
      \     20   [RFC4120]\n PA-SVR-REFERRAL-INFO       20   [REFERRALS]\n PA-SAM-REDIRECT
      \           21   [KRB-WG.SAM]\n PA-GET-FROM-TYPED-DATA     22   (embedded in
      typed data) [RFC4120]\n TD-PADATA                  22   (embeds padata) [RFC4120]\n
      PA-SAM-ETYPE-INFO          23   (sam/otp) [KRB-WG.SAM]\n PA-ALT-PRINC               24
      \  (crawdad@fnal.gov) [HW-AUTH]\n PA-SERVER-REFERRAL         25   [REFERRALS]\n
      PA-SAM-CHALLENGE2          30   (kenh@pobox.com) [KRB-WG.SAM]\n PA-SAM-RESPONSE2
      \          31   (kenh@pobox.com) [KRB-WG.SAM]\n PA-EXTRA-TGT               41
      \  Reserved extra TGT [RFC6113]\n TD-PKINIT-CMS-CERTIFICATES 101  CertificateSet
      from CMS\n TD-KRB-PRINCIPAL           102  PrincipalName\n TD-KRB-REALM               103
      \ Realm\n TD-TRUSTED-CERTIFIERS      104  [RFC4556]\n TD-CERTIFICATE-INDEX       105
      \ [RFC4556]\n TD-APP-DEFINED-ERROR       106  Application specific [RFC6113]\n
      TD-REQ-NONCE               107  INTEGER [RFC6113]\n TD-REQ-SEQ                 108
      \ INTEGER [RFC6113]\n TD_DH_PARAMETERS           109  [RFC4556]\n TD-CMS-DIGEST-ALGORITHMS
      \  111  [ALG-AGILITY]\n TD-CERT-DIGEST-ALGORITHMS  112  [ALG-AGILITY]\n PA-PAC-REQUEST
      \            128  [MS-KILE]\n PA-FOR_USER                129  [MS-KILE]\n PA-FOR-X509-USER
      \          130  [MS-KILE]\n PA-FOR-CHECK_DUPS          131  [MS-KILE]\n PA-AS-CHECKSUM
      \            132  [MS-KILE]\n PA-FX-COOKIE               133  [RFC6113]\n PA-AUTHENTICATION-SET
      \     134  [RFC6113]\n PA-AUTH-SET-SELECTED       135  [RFC6113]\n PA-FX-FAST
      \                136  [RFC6113]\n PA-FX-ERROR                137  [RFC6113]\n
      PA-ENCRYPTED-CHALLENGE     138  [RFC6113]\n PA-OTP-CHALLENGE           141  (gareth.richards@rsa.com)
      [OTP-PREAUTH]\n PA-OTP-REQUEST             142  (gareth.richards@rsa.com) [OTP-PREAUTH]\n
      PA-OTP-CONFIRM             143  (gareth.richards@rsa.com) [OTP-PREAUTH]\n PA-OTP-PIN-CHANGE
      \         144  (gareth.richards@rsa.com) [OTP-PREAUTH]\n PA-EPAK-AS-REQ             145
      \ (sshock@gmail.com) [RFC6113]\n PA-EPAK-AS-REP             146  (sshock@gmail.com)
      [RFC6113]\n PA_PKINIT_KX               147  [RFC6112]\n PA_PKU2U_NAME              148
      \ [PKU2U]\n PA-SUPPORTED-ETYPES        165  [MS-KILE]\n PA-EXTENDED_ERROR          166
      \ [MS-KILE]\n"
    title: 7.1.  Pre-Authentication and Typed Data
  - contents:
    - "7.2.  Fast Armor Types\n   FAST armor types are defined in Section 5.4.1.  A
      FAST armor type is\n   a signed 32-bit integer.  FAST armor types are assigned
      by standards\n   action.\n          Type    Name                   Description\n
      \       ------------------------------------------------------------\n          0
      \                             Reserved.\n          1   FX_FAST_ARMOR_AP_REQUEST
      \  Ticket armor using an ap-req.\n"
    title: 7.2.  Fast Armor Types
  - contents:
    - "7.3.  FAST Options\n   A FAST request includes a set of bit flags to indicate
      additional\n   options.  Bits 0-15 are critical; other bits are non-critical.\n
      \  Assigning bits greater than 31 may require special support in\n   implementations.
      \ Assignment of FAST options requires standards\n   action.\n      Type    Name
      \                  Description\n     -------------------------------------------------------------------\n
      \     0     RESERVED               Reserved for future expansion of this\n                                   field.\n
      \     1     hide-client-names      Requesting the KDC to hide client\n                                   names
      in the KDC response\n      16    kdc-follow-referrals   Reserved.\n"
    title: 7.3.  FAST Options
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   The kdc-referrals option in the Kerberos FAST
    padata requests the KDC\n   to act as the client to follow referrals.  This can
    overload the KDC.\n   To limit the damages of denial of service using this option,
    KDCs MAY\n   restrict the number of simultaneous active requests with this option\n
    \  for any given client principal.\n   Regarding the facilities provided by the
    Encrypted Challenge FAST\n   factor, the challenge key is derived from the client
    secrets and\n   because the client secrets are known only to the client and the
    KDC,\n   the verification of the EncryptedChallenge structure proves the\n   client's
    identity, the verification of the EncryptedChallenge\n   structure in the KDC
    reply proves that the expected KDC responded.\n   Therefore, the Encrypted Challenge
    FAST factor as a pre-\n   authentication mechanism offers the following facilities:
    Client\n   Authentication and KDC Authentication.  There is no un-authenticated\n
    \  cleartext introduced by the Encrypted Challenge FAST factor.\n   FAST provides
    an encrypted tunnel over which pre-authentication\n   conversations can take place.
    \ In addition, FAST optionally\n   authenticates the KDC to the client.  It is
    the responsibility of\n   FAST factors to authenticate the client to the KDC.
    \ Care MUST be\n   taken to design FAST factors such that they are bound to the\n
    \  conversation.  If this is not done, a man-in-the-middle may be able\n   to
    cut&paste a FAST factor from one conversation to another.  The\n   easiest way
    to do this is to bind each FAST factor to the armor key\n   that is guaranteed
    to be unique for each conversation.\n   The anonymous PKINIT mode for obtaining
    an armor ticket does not\n   always authenticate the KDC to the client before
    the conversation\n   begins.  Tracking the KDC verified state guarantees that
    by the end\n   of the conversation, the client has authenticated the KDC.  However,\n
    \  FAST factor designers need to consider the implications of using\n   their
    factor when the KDC has not yet been authenticated.  If this\n   proves problematic
    in an environment, then the particular FAST factor\n   should not be used with
    anonymous PKINIT.\n   Existing pre-authentication mechanisms are believed to be
    at least as\n   secure when used with FAST as they are when used outside of FAST.\n
    \  One part of this security is making sure that when pre-authentication\n   methods
    checksum the request, they checksum the inner request rather\n   than the outer
    request.  If the mechanism checksummed the outer\n   request, a man-in-the-middle
    could observe it outside a FAST tunnel\n   and then cut&paste it into a FAST exchange
    where the inner rather\n   than outer request would be used to select attributes
    of the issued\n   ticket.  Such attacks would typically invalidate auditing information\n
    \  or create a situation where the client and KDC disagree about what\n   ticket
    is issued.  However, such attacks are unlikely to allow an\n   attacker who would
    not be able to authenticate as a principal to do\n   so.  Even so, FAST is believed
    to defend against these attacks in\n   existing legacy mechanism.  However, since
    there is no standard for\n   how legacy mechanisms bind the request to the pre-authentication
    or\n   provide integrity protection, security analysis can be difficult.  In\n
    \  some cases, FAST may significantly improve the integrity protection\n   of
    legacy mechanisms.\n   The security of the TGS exchange depends on authenticating
    the client\n   to the KDC.  In the AS exchange, this is done using pre-\n   authentication
    data or FAST factors.  In the TGS exchange, this is\n   done by presenting a TGT
    and by using the session (or sub-session)\n   key in constructing the request.
    \ Because FAST uses a request body in\n   the inner request, encrypted in the
    armor key, rather than the\n   request body in the outer request, it is critical
    that establishing\n   the armor key be tied to the authentication of the client
    to the KDC.\n   If this is not done, an attacker could manipulate the options\n
    \  requested in the TGS request, for example, requesting a ticket with\n   different
    validity or addresses.  The easiest way to bind the armor\n   key to the authentication
    of the client to the KDC is for the armor\n   key to depend on the sub-session
    key of the TGT.  This is done with\n   the implicit TGS armor supported by this
    specification.  Future armor\n   types designed for use with the TGS MUST either
    bind their armor keys\n   to the TGT or provide another mechanism to authenticate
    the client to\n   the KDC.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Acknowledgements\n   Sam Hartman would like to thank the MIT Kerberos Consortium
    for its\n   funding of his time on this project.\n   Several suggestions from
    Jeffrey Hutzelman based on early revisions\n   of this documents led to significant
    improvements of this document.\n   The proposal to ask one KDC to chase down the
    referrals and return\n   the final ticket is based on requirements in [CROSS].\n
    \  Joel Weber had a proposal for a mechanism similar to FAST that\n   created
    a protected tunnel for Kerberos pre-authentication.\n   Srinivas Cheruku and Greg
    Hudson provided valuable review comments.\n"
  title: 9.  Acknowledgements
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]       Bradner, S., \"Key words for
      use in RFCs to Indicate\n                   Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC3961]       Raeburn, K., \"Encryption and Checksum
      Specifications\n                   for Kerberos 5\", RFC 3961, February 2005.\n
      \  [RFC4120]       Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The\n
      \                  Kerberos Network Authentication Service (V5)\",\n                   RFC
      4120, July 2005.\n   [RFC4556]       Zhu, L. and B. Tung, \"Public Key Cryptography
      for\n                   Initial Authentication in Kerberos (PKINIT)\",\n                   RFC
      4556, June 2006.\n   [RFC5226]       Narten, T. and H. Alvestrand, \"Guidelines
      for Writing\n                   an IANA Considerations Section in RFCs\", BCP
      26,\n                   RFC 5226, May 2008.\n   [RFC6112]       Zhu, L., Leach,
      P., and S. Hartman \"Anonymity Support\n                   for Kerberos\", RFC
      6112, April 2011.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [ALG-AGILITY]   Astrand, L. and L. Zhu, \"PK-INIT
      algorithm agility\",\n                   Work in Progress, August 2008.\n   [CROSS]
      \        Sakane, S., Zrelli, S., and M. Ishiyama , \"Problem\n                   statement
      on the cross-realm operation of Kerberos in\n                   a specific system\",
      Work in Progress, July 2007.\n   [EKE]           Bellovin, S. and M. Merritt,
      \"Augmented Encrypted Key\n                   Exchange: A Password-Based Protocol
      Secure Against\n                   Dictionary Attacks and Password File Compromise,\n
      \                  Proceedings of the 1st ACM Conference on Computer and\n                   Communications
      Security, ACM Press.\", November 1993.\n   [HW-AUTH]       Crawford, M., \"Passwordless
      Initial Authentication to\n                   Kerberos by Hardware  Preauthentication\",
      Work\n                   in Progress, October 2006.\n   [IEEE1363.2]    IEEE,
      \"IEEE P1363.2: Password-Based Public-Key\n                   Cryptography\",
      2004.\n   [KRB-WG.SAM]    Hornstein, K., Renard, K., Neuman, C., and G. Zorn,\n
      \                  \"Integrating Single-use Authentication Mechanisms\n                   with
      Kerberos\", Work in Progress, July 2004.\n   [MS-KILE]       Microsoft, \"Kerberos
      Protocol Extensions\", <http://\n                   msdn.microsoft.com/en-us/library/cc206927.aspx>.\n
      \  [OTP-PREAUTH]   Richards, G., \"OTP Pre-authentication\", Work\n                   in
      Progress, February 2011.\n   [PK-INIT-1999]  Tung, B., Neuman, C., Hur, M.,
      Medvinsky, A.,\n                   Medvinsky, S., Wray, J., and J. Trostle,
      \"Public Key\n                   Cryptography for Initial Authentication in
      Kerberos\",\n                   Work in Progress, July 1999.\n   [PKU2U]         Zhu,
      L., Altman, J., and N. Williams, \"Public Key\n                   Cryptography
      Based User-to-User Authentication -\n                   (PKU2U)\", Work in Progress,
      November 2008.\n   [REFERRALS]     Hartman, S., Ed., Raeburn, K., and L. Zhu,
      \"Kerberos\n                   Principal Name Canonicalization and KDC-Generated\n
      \                  Cross-Realm Referrals\", Work in Progress, March 2011.\n
      \  [RFC4557]       Zhu, L., Jaganathan, K., and N. Williams, \"Online\n                   Certificate
      Status Protocol (OCSP) Support for Public\n                   Key Cryptography
      for Initial Authentication in\n                   Kerberos (PKINIT)\", RFC 4557,
      June 2006.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Test Vectors for KRB-FX-CF2\n   This informative appendix presents
    test vectors for the KRB-FX-CF2\n   function.  Test vectors are presented for
    several encryption types.\n   In all cases, the first key (k1) is the result of
    string-to-\n   key(\"key1\", \"key1\", default_parameters) and the second key
    (k2) is\n   the result of string-to-key(\"key2\", \"key2\", default_parameters).\n
    \  Both keys are of the same enctype.  The presented test vector is the\n   hexadecimal
    encoding of the key produced by KRB-FX-CF2(k1, k2, \"a\",\n   \"b\").  The peppers
    are one-octet ASCII strings.\n   In performing interoperability testing, there
    was significant\n   ambiguity surrounding [RFC3961] pseudo-random operations.
    \ These test\n   vectors assume that the AES pseudo-random operation is\n   aes-ecb(trunc128(sha-1(input)))
    where trunc128 truncates its input to\n   128 bits.  The 3DES pseudo-random operation
    is assumed to be\n   des3-cbc(trunc128(sha-1(input))).  The DES pseudo-random
    operation is\n   assumed to be des-cbc(md5(input)).  As specified in RFC 4757,
    the RC4\n   pseudo-random operation is hmac-sha1(input).\n   Interoperability
    testing also demonstrated ambiguity surrounding the\n   DES random-to-key operation.
    \ The random-to-key operation is assumed\n   to be distribute 56 bits into high-7-bits
    of 8 octets and generate\n   parity.\n   These test vectors were produced with
    revision 22359 of the MIT\n   Kerberos sources.  The AES 256 and AES 128 test
    vectors have been\n   confirmed by multiple other implementors.  The RC4 test
    vectors have\n   been confirmed by one other implementor.  The DES and triple
    DES test\n   vectors have not been confirmed.\n   aes 128 (enctype 17): 97df97e4b798b29eb31ed7280287a92a\n
    \  AES256 (enctype 18): 4d6ca4e629785c1f01baf55e2e548566\n                        b9617ae3a96868c337cb93b5e72b1c7b\n
    \  DES (enctype 1): 43bae3738c9467e6\n   3DES (enctype 16): e58f9eb643862c13ad38e529313462a7f73e62834fe54a01\n
    \  RC4 (enctype 23): 24d7f6b6bae4e5c00d2082c5ebab3672\n"
  title: Appendix A.  Test Vectors for KRB-FX-CF2
- contents:
  - "Appendix B.  ASN.1 Module\n      KerberosPreauthFramework {\n            iso(1)
    identified-organization(3) dod(6) internet(1)\n            security(5) kerberosV5(2)
    modules(4) preauth-framework(3)\n      } DEFINITIONS EXPLICIT TAGS ::= BEGIN\n
    \     IMPORTS\n           KerberosTime, PrincipalName, Realm, EncryptionKey, Checksum,\n
    \          Int32, EncryptedData, PA-ENC-TS-ENC, PA-DATA, KDC-REQ-BODY,\n           Microseconds,
    KerberosFlags, UInt32\n                FROM KerberosV5Spec2 { iso(1) identified-organization(3)\n
    \                 dod(6) internet(1) security(5) kerberosV5(2)\n                  modules(4)
    krb5spec2(2) };\n                  -- as defined in RFC 4120.\n      PA-AUTHENTICATION-SET
    ::= SEQUENCE OF PA-AUTHENTICATION-SET-ELEM\n      PA-AUTHENTICATION-SET-ELEM ::=
    SEQUENCE {\n          pa-type      [0] Int32,\n              -- same as padata-type.\n
    \         pa-hint      [1] OCTET STRING OPTIONAL,\n          pa-value     [2]
    OCTET STRING OPTIONAL,\n          ...\n      }\n      KrbFastArmor ::= SEQUENCE
    {\n          armor-type   [0] Int32,\n              -- Type of the armor.\n          armor-value
    \ [1] OCTET STRING,\n              -- Value of the armor.\n          ...\n      }\n
    \     PA-FX-FAST-REQUEST ::= CHOICE {\n          armored-data [0] KrbFastArmoredReq,\n
    \         ...\n      }\n      KrbFastArmoredReq ::= SEQUENCE {\n          armor
    \       [0] KrbFastArmor OPTIONAL,\n              -- Contains the armor that identifies
    the armor key.\n              -- MUST be present in AS-REQ.\n          req-checksum
    [1] Checksum,\n              -- For AS, contains the checksum performed over the
    type\n              -- KDC-REQ-BODY for the req-body field of the KDC-REQ\n              --
    structure;\n              -- For TGS, contains the checksum performed over the
    type\n              -- AP-REQ in the PA-TGS-REQ padata.\n              -- The
    checksum key is the armor key, the checksum\n              -- type is the required
    checksum type for the enctype of\n              -- the armor key, and the key
    usage number is\n              -- KEY_USAGE_FAST_REQ_CHKSUM.\n          enc-fast-req
    [2] EncryptedData, -- KrbFastReq --\n              -- The encryption key is the
    armor key, and the key usage\n              -- number is KEY_USAGE_FAST_ENC.\n
    \         ...\n      }\n      KrbFastReq ::= SEQUENCE {\n          fast-options
    [0] FastOptions,\n              -- Additional options.\n          padata       [1]
    SEQUENCE OF PA-DATA,\n              -- padata typed holes.\n          req-body
    \    [2] KDC-REQ-BODY,\n              -- Contains the KDC request body as defined
    in Section\n              -- 5.4.1 of [RFC4120].\n              -- This req-body
    field is preferred over the outer field\n              -- in the KDC request.\n
    \          ...\n      }\n      FastOptions ::= KerberosFlags\n          -- reserved(0),\n
    \         -- hide-client-names(1),\n          -- kdc-follow-referrals(16)\n      PA-FX-FAST-REPLY
    ::= CHOICE {\n          armored-data [0] KrbFastArmoredRep,\n          ...\n      }\n
    \     KrbFastArmoredRep ::= SEQUENCE {\n          enc-fast-rep      [0] EncryptedData,
    -- KrbFastResponse --\n              -- The encryption key is the armor key in
    the request, and\n              -- the key usage number is KEY_USAGE_FAST_REP.\n
    \         ...\n      }\n      KrbFastResponse ::= SEQUENCE {\n          padata
    \        [0] SEQUENCE OF PA-DATA,\n              -- padata typed holes.\n          strengthen-key
    [1] EncryptionKey OPTIONAL,\n              -- This, if present, strengthens the
    reply key for AS and\n              -- TGS.  MUST be present for TGS\n              --
    MUST be absent in KRB-ERROR.\n          finished       [2] KrbFastFinished OPTIONAL,\n
    \             -- Present in AS or TGS reply; absent otherwise.\n          nonce
    \         [3] UInt32,\n              -- Nonce from the client request.\n          ...\n
    \     }\n      KrbFastFinished ::= SEQUENCE {\n          timestamp       [0] KerberosTime,\n
    \         usec            [1] Microseconds,\n              -- timestamp and usec
    represent the time on the KDC when\n              -- the reply was generated.\n
    \         crealm          [2] Realm,\n          cname           [3] PrincipalName,\n
    \             -- Contains the client realm and the client name.\n          ticket-checksum
    [4] Checksum,\n              -- checksum of the ticket in the KDC-REP  using the
    armor\n              -- and the key usage is KEY_USAGE_FAST_FINISH.\n              --
    The checksum type is the required checksum type\n              -- of the armor
    key.\n          ...\n      }\n      EncryptedChallenge ::= EncryptedData\n              --
    Encrypted PA-ENC-TS-ENC, encrypted in the challenge key\n              -- using
    key usage KEY_USAGE_ENC_CHALLENGE_CLIENT for the\n              -- client and
    KEY_USAGE_ENC_CHALLENGE_KDC for the KDC.\n      END\n"
  title: Appendix B.  ASN.1 Module
- contents:
  - "Authors' Addresses\n   Sam Hartman\n   Painless Security\n   EMail: hartmans-ietf@mit.edu\n
    \  Larry Zhu\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond, WA  98052\n
    \  US\n   EMail: larry.zhu@microsoft.com\n"
  title: Authors' Addresses
