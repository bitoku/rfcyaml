- title: __initial_text__
  contents:
  - '      Network File System (NFS) Version 4 Minor Version 2 Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes NFS version 4 minor version 2; it describes\n\
    \   the protocol extensions made from NFS version 4 minor version 1.\n   Major\
    \ extensions introduced in NFS version 4 minor version 2 include\n   the following:\
    \ Server-Side Copy, Application Input/Output (I/O)\n   Advise, Space Reservations,\
    \ Sparse Files, Application Data Blocks,\n   and Labeled NFS.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7862.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Requirements Language ......................................4\n  \
    \    1.2. Scope of This Document .....................................5\n    \
    \  1.3. NFSv4.2 Goals ..............................................5\n      1.4.\
    \ Overview of NFSv4.2 Features ...............................6\n           1.4.1.\
    \ Server-Side Clone and Copy ..........................6\n           1.4.2. Application\
    \ Input/Output (I/O) Advise ...............6\n           1.4.3. Sparse Files ........................................6\n\
    \           1.4.4. Space Reservation ...................................7\n  \
    \         1.4.5. Application Data Block (ADB) Support ................7\n    \
    \       1.4.6. Labeled NFS .........................................7\n      \
    \     1.4.7. Layout Enhancements .................................7\n      1.5.\
    \ Enhancements to Minor Versioning Model .....................7\n   2. Minor Versioning\
    \ ................................................8\n   3. pNFS Considerations\
    \ for New Operations ..........................9\n      3.1. Atomicity for ALLOCATE\
    \ and DEALLOCATE ......................9\n      3.2. Sharing of Stateids with\
    \ NFSv4.1 ...........................9\n      3.3. NFSv4.2 as a Storage Protocol\
    \ in pNFS: The File\n           Layout Type ................................................9\n\
    \           3.3.1. Operations Sent to NFSv4.2 Data Servers .............9\n  \
    \ 4. Server-Side Copy ...............................................10\n    \
    \  4.1. Protocol Overview .........................................10\n      \
    \     4.1.1. COPY Operations ....................................11\n        \
    \   4.1.2. Requirements for Operations ........................11\n      4.2.\
    \ Requirements for Inter-Server Copy ........................13\n      4.3. Implementation\
    \ Considerations .............................13\n           4.3.1. Locking the\
    \ Files ..................................13\n           4.3.2. Client Caches\
    \ ......................................14\n      4.4. Intra-Server Copy .........................................14\n\
    \      4.5. Inter-Server Copy .........................................16\n  \
    \    4.6. Server-to-Server Copy Protocol ............................19\n    \
    \       4.6.1. Considerations on Selecting a Copy Protocol ........19\n      \
    \     4.6.2. Using NFSv4.x as the Copy Protocol .................19\n        \
    \   4.6.3. Using an Alternative Copy Protocol .................20\n      4.7.\
    \ netloc4 - Network Locations ...............................21\n      4.8. Copy\
    \ Offload Stateids .....................................21\n      4.9. Security\
    \ Considerations for Server-Side Copy ..............22\n           4.9.1. Inter-Server\
    \ Copy Security .........................22\n   5. Support for Application I/O\
    \ Hints ..............................30\n   6. Sparse Files ...................................................30\n\
    \      6.1. Terminology ...............................................31\n  \
    \    6.2. New Operations ............................................32\n    \
    \       6.2.1. READ_PLUS ..........................................32\n      \
    \     6.2.2. DEALLOCATE .........................................32\n   7. Space\
    \ Reservation ..............................................32\n   8. Application\
    \ Data Block Support .................................34\n      8.1. Generic Framework\
    \ .........................................35\n           8.1.1. Data Block Representation\
    \ ..........................36\n      8.2. An Example of Detecting Corruption\
    \ ........................36\n      8.3. An Example of READ_PLUS ...................................38\n\
    \      8.4. An Example of Zeroing Space ...............................39\n  \
    \ 9. Labeled NFS ....................................................39\n    \
    \  9.1. Definitions ...............................................40\n      9.2.\
    \ MAC Security Attribute ....................................41\n           9.2.1.\
    \ Delegations ........................................41\n           9.2.2. Permission\
    \ Checking ................................42\n           9.2.3. Object Creation\
    \ ....................................42\n           9.2.4. Existing Objects ...................................42\n\
    \           9.2.5. Label Changes ......................................42\n  \
    \    9.3. pNFS Considerations .......................................43\n    \
    \  9.4. Discovery of Server Labeled NFS Support ...................43\n      9.5.\
    \ MAC Security NFS Modes of Operation .......................43\n           9.5.1.\
    \ Full Mode ..........................................44\n           9.5.2. Limited\
    \ Server Mode ................................45\n           9.5.3. Guest Mode\
    \ .........................................45\n      9.6. Security Considerations\
    \ for Labeled NFS ...................46\n   10. Sharing Change Attribute Implementation\
    \ Characteristics\n       with NFSv4 Clients ............................................46\n\
    \   11. Error Values ..................................................47\n  \
    \    11.1. Error Definitions ........................................47\n    \
    \       11.1.1. General Errors ....................................47\n      \
    \     11.1.2. Server-to-Server Copy Errors ......................47\n        \
    \   11.1.3. Labeled NFS Errors ................................48\n      11.2.\
    \ New Operations and Their Valid Errors ....................49\n      11.3. New\
    \ Callback Operations and Their Valid Errors ...........53\n   12. New File Attributes\
    \ ...........................................54\n      12.1. New RECOMMENDED Attributes\
    \ - List and Definition\n            References ...............................................54\n\
    \      12.2. Attribute Definitions ....................................54\n  \
    \ 13. Operations: REQUIRED, RECOMMENDED, or OPTIONAL ................57\n   14.\
    \ Modifications to NFSv4.1 Operations ...........................61\n      14.1.\
    \ Operation 42: EXCHANGE_ID - Instantiate the client ID ....61\n      14.2. Operation\
    \ 48: GETDEVICELIST - Get all device\n            mappings for a file system ...............................63\n\
    \   15. NFSv4.2 Operations ............................................64\n  \
    \    15.1. Operation 59: ALLOCATE - Reserve space in a\n            region of\
    \ a file .........................................64\n      15.2. Operation 60:\
    \ COPY - Initiate a server-side copy .........65\n      15.3. Operation 61: COPY_NOTIFY\
    \ - Notify a source\n            server of a future copy ..................................70\n\
    \      15.4. Operation 62: DEALLOCATE - Unreserve space in a\n            region\
    \ of a file .........................................72\n      15.5. Operation\
    \ 63: IO_ADVISE - Send client I/O access\n            pattern hints to the server\
    \ ..............................73\n      15.6. Operation 64: LAYOUTERROR - Provide\
    \ errors for\n            the layout ...............................................79\n\
    \      15.7. Operation 65: LAYOUTSTATS - Provide statistics\n            for the\
    \ layout ...........................................82\n      15.8. Operation\
    \ 66: OFFLOAD_CANCEL - Stop an offloaded\n            operation ................................................84\n\
    \      15.9. Operation 67: OFFLOAD_STATUS - Poll for the\n            status of\
    \ an asynchronous operation ......................85\n      15.10. Operation 68:\
    \ READ_PLUS - READ data or holes\n             from a file .............................................86\n\
    \      15.11. Operation 69: SEEK - Find the next data or hole .........91\n  \
    \    15.12. Operation 70: WRITE_SAME - WRITE an ADB multiple\n             times\
    \ to a file .........................................92\n      15.13. Operation\
    \ 71: CLONE - Clone a range of a file\n             into another file .......................................96\n\
    \   16. NFSv4.2 Callback Operations ...................................98\n  \
    \    16.1. Operation 15: CB_OFFLOAD - Report the results of\n            an asynchronous\
    \ operation ................................98\n   17. Security Considerations\
    \ .......................................99\n   18. IANA Considerations ...........................................99\n\
    \   19. References ...................................................100\n  \
    \    19.1. Normative References ....................................100\n    \
    \  19.2. Informative References ..................................101\n   Acknowledgments\
    \ ..................................................103\n   Author's Address .................................................104\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The NFS version 4 minor version 2 (NFSv4.2) protocol is\
    \ the third\n   minor version of the NFS version 4 (NFSv4) protocol.  The first\
    \ minor\n   version, NFSv4.0, is described in [RFC7530], and the second minor\n\
    \   version, NFSv4.1, is described in [RFC5661].\n   As a minor version, NFSv4.2\
    \ is consistent with the overall goals for\n   NFSv4, but NFSv4.2 extends the\
    \ protocol so as to better meet those\n   goals, based on experiences with NFSv4.1.\
    \  In addition, NFSv4.2 has\n   adopted some additional goals, which motivate\
    \ some of the major\n   extensions in NFSv4.2.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 1.2.  Scope of This Document
  contents:
  - "1.2.  Scope of This Document\n   This document describes the NFSv4.2 protocol\
    \ as a set of extensions\n   to the specification for NFSv4.1.  That specification\
    \ remains current\n   and forms the basis for the additions defined herein.  The\n\
    \   specification for NFSv4.0 remains current as well.\n   It is necessary to\
    \ implement all the REQUIRED features of NFSv4.1\n   before adding NFSv4.2 features\
    \ to the implementation.  With respect\n   to NFSv4.0 and NFSv4.1, this document\
    \ does not:\n   o  describe the NFSv4.0 or NFSv4.1 protocols, except where needed\
    \ to\n      contrast with NFSv4.2\n   o  modify the specification of the NFSv4.0\
    \ or NFSv4.1 protocols\n   o  clarify the NFSv4.0 or NFSv4.1 protocols -- that\
    \ is, any\n      clarifications made here apply only to NFSv4.2 and not to NFSv4.0\n\
    \      or NFSv4.1\n   NFSv4.2 is a superset of NFSv4.1, with all of the new features\
    \ being\n   optional.  As such, NFSv4.2 maintains the same compatibility that\n\
    \   NFSv4.1 had with NFSv4.0.  Any interactions of a new feature with\n   NFSv4.1\
    \ semantics is described in the relevant text.\n   The full External Data Representation\
    \ (XDR) [RFC4506] for NFSv4.2 is\n   presented in [RFC7863].\n"
- title: 1.3.  NFSv4.2 Goals
  contents:
  - "1.3.  NFSv4.2 Goals\n   A major goal of the enhancements provided in NFSv4.2\
    \ is to take\n   common local file system features that have not been available\n\
    \   through earlier versions of NFS and to offer them remotely.  These\n   features\
    \ might\n   o  already be available on the servers, e.g., sparse files\n   o \
    \ be under development as a new standard, e.g., SEEK pulls in both\n      SEEK_HOLE\
    \ and SEEK_DATA\n   o  be used by clients with the servers via some proprietary\
    \ means,\n      e.g., Labeled NFS\n   NFSv4.2 provides means for clients to leverage\
    \ these features on the\n   server in cases in which such leveraging had previously\
    \ not been\n   possible within the confines of the NFS protocol.\n"
- title: 1.4.  Overview of NFSv4.2 Features
  contents:
  - '1.4.  Overview of NFSv4.2 Features

    '
- title: 1.4.1.  Server-Side Clone and Copy
  contents:
  - "1.4.1.  Server-Side Clone and Copy\n   A traditional file copy of a remotely\
    \ accessed file, whether from one\n   server to another or between locations in\
    \ the same server, results in\n   the data being put on the network twice -- source\
    \ to client and then\n   client to destination.  New operations are introduced\
    \ to allow\n   unnecessary traffic to be eliminated:\n   o  The intra-server CLONE\
    \ feature allows the client to request a\n      synchronous cloning, perhaps by\
    \ copy-on-write semantics.\n   o  The intra-server COPY feature allows the client\
    \ to request the\n      server to perform the copy internally, avoiding unnecessary\n\
    \      network traffic.\n   o  The inter-server COPY feature allows the client\
    \ to authorize the\n      source and destination servers to interact directly.\n\
    \   As such copies can be lengthy, asynchronous support is also provided.\n"
- title: 1.4.2.  Application Input/Output (I/O) Advise
  contents:
  - "1.4.2.  Application Input/Output (I/O) Advise\n   Applications and clients want\
    \ to advise the server as to expected I/O\n   behavior.  Using IO_ADVISE (see\
    \ Section 15.5) to communicate future\n   I/O behavior such as whether a file\
    \ will be accessed sequentially or\n   randomly, and whether a file will or will\
    \ not be accessed in the near\n   future, allows servers to optimize future I/O\
    \ requests for a file by,\n   for example, prefetching or evicting data.  This\
    \ operation can be\n   used to support the posix_fadvise() [posix_fadvise] function.\
    \  In\n   addition, it may be helpful to applications such as databases and\n\
    \   video editors.\n"
- title: 1.4.3.  Sparse Files
  contents:
  - "1.4.3.  Sparse Files\n   Sparse files are files that have unallocated or uninitialized\
    \ data\n   blocks as holes in the file.  Such holes are typically transferred\
    \ as\n   zeros when read from the file.  READ_PLUS (see Section 15.10) allows\n\
    \   a server to send back to the client metadata describing the hole, and\n  \
    \ DEALLOCATE (see Section 15.4) allows the client to punch holes into a\n   file.\
    \  In addition, SEEK (see Section 15.11) is provided to scan for\n   the next\
    \ hole or data from a given location.\n"
- title: 1.4.4.  Space Reservation
  contents:
  - "1.4.4.  Space Reservation\n   When a file is sparse, one concern that applications\
    \ have is ensuring\n   that there will always be enough data blocks available\
    \ for the file\n   during future writes.  ALLOCATE (see Section 15.1) allows a\
    \ client to\n   request a guarantee that space will be available.  Also, DEALLOCATE\n\
    \   (see Section 15.4) allows the client to punch a hole into a file,\n   thus\
    \ releasing a space reservation.\n"
- title: 1.4.5.  Application Data Block (ADB) Support
  contents:
  - "1.4.5.  Application Data Block (ADB) Support\n   Some applications treat a file\
    \ as if it were a disk and as such want\n   to initialize (or format) the file\
    \ image.  The WRITE_SAME operation\n   (see Section 15.12) is introduced to send\
    \ this metadata to the server\n   to allow it to write the block contents.\n"
- title: 1.4.6.  Labeled NFS
  contents:
  - "1.4.6.  Labeled NFS\n   While both clients and servers can employ Mandatory Access\
    \ Control\n   (MAC) security models to enforce data access, there has been no\n\
    \   protocol support for interoperability.  A new file object attribute,\n   sec_label\
    \ (see Section 12.2.4), allows the server to store MAC labels\n   on files, which\
    \ the client retrieves and uses to enforce data access\n   (see Section 9.5.3).\
    \  The format of the sec_label accommodates any\n   MAC security system.\n"
- title: 1.4.7.  Layout Enhancements
  contents:
  - "1.4.7.  Layout Enhancements\n   In the parallel NFS implementations of NFSv4.1\
    \ (see Section 12 of\n   [RFC5661]), the client cannot communicate back to the\
    \ metadata server\n   any errors or performance characteristics with the storage\
    \ devices.\n   NFSv4.2 provides two new operations to do so: LAYOUTERROR (see\n\
    \   Section 15.6) and LAYOUTSTATS (see Section 15.7), respectively.\n"
- title: 1.5.  Enhancements to Minor Versioning Model
  contents:
  - "1.5.  Enhancements to Minor Versioning Model\n   In NFSv4.1, the only way to\
    \ introduce new variants of an operation\n   was to introduce a new operation.\
    \  For instance, READ would have to\n   be replaced or supplemented by, say, either\
    \ READ2 or READ_PLUS.  With\n   the use of discriminated unions as parameters\
    \ for such functions in\n   NFSv4.2, it is possible to add a new \"arm\" (i.e.,\
    \ a new entry in the\n   union and a corresponding new field in the structure)\
    \ in a subsequent\n   minor version.  It is also possible to move such an operation\
    \ from\n   OPTIONAL/RECOMMENDED to REQUIRED.  Forcing an implementation to adopt\n\
    \   each arm of a discriminated union at such a time does not meet the\n   spirit\
    \ of the minor versioning rules.  As such, new arms of a\n   discriminated union\
    \ MUST follow the same guidelines for minor\n   versioning as operations in NFSv4.1\
    \ -- i.e., they may not be made\n   REQUIRED.  To support this, a new error code,\
    \ NFS4ERR_UNION_NOTSUPP,\n   allows the server to communicate to the client that\
    \ the operation is\n   supported but the specific arm of the discriminated union\
    \ is not.\n"
- title: 2.  Minor Versioning
  contents:
  - "2.  Minor Versioning\n   NFSv4.2 is a minor version of NFSv4 and is built upon\
    \ NFSv4.1 as\n   documented in [RFC5661] and [RFC5662].\n   NFSv4.2 does not modify\
    \ the rules applicable to the NFSv4 versioning\n   process and follows the rules\
    \ set out in [RFC5661] or in\n   Standards Track documents updating that document\
    \ (e.g., in an RFC\n   based on [NFSv4-Versioning]).\n   NFSv4.2 only defines\
    \ extensions to NFSv4.1, each of which may be\n   supported (or not) independently.\
    \  It does not\n   o  introduce infrastructural features\n   o  make existing\
    \ features MANDATORY to NOT implement\n   o  change the status of existing features\
    \ (i.e., by changing their\n      status among OPTIONAL, RECOMMENDED, REQUIRED)\n\
    \   The following versioning-related considerations should be noted.\n   o  When\
    \ a new case is added to an existing switch, servers need to\n      report non-support\
    \ of that new case by returning\n      NFS4ERR_UNION_NOTSUPP.\n   o  As regards\
    \ the potential cross-minor-version transfer of stateids,\n      Parallel NFS\
    \ (pNFS) (see Section 12 of [RFC5661]) implementations\n      of the file-mapping\
    \ type may support the use of an NFSv4.2\n      metadata server (see Sections\
    \ 1.7.2.2 and 12.2.2 of [RFC5661])\n      with NFSv4.1 data servers.  In this\
    \ context, a stateid returned by\n      an NFSv4.2 COMPOUND will be used in an\
    \ NFSv4.1 COMPOUND directed\n      to the data server (see Sections 3.2 and 3.3).\n"
- title: 3.  pNFS Considerations for New Operations
  contents:
  - "3.  pNFS Considerations for New Operations\n   The interactions of the new operations\
    \ with non-pNFS functionality\n   are straightforward and are covered in the relevant\
    \ sections.\n   However, the interactions of the new operations with pNFS are\
    \ more\n   complicated.  This section provides an overview.\n"
- title: 3.1.  Atomicity for ALLOCATE and DEALLOCATE
  contents:
  - "3.1.  Atomicity for ALLOCATE and DEALLOCATE\n   Both ALLOCATE (see Section 15.1)\
    \ and DEALLOCATE (see Section 15.4)\n   are sent to the metadata server, which\
    \ is responsible for\n   coordinating the changes onto the storage devices.  In\
    \ particular,\n   both operations must either fully succeed or fail; it cannot\
    \ be the\n   case that one storage device succeeds whilst another fails.\n"
- title: 3.2.  Sharing of Stateids with NFSv4.1
  contents:
  - "3.2.  Sharing of Stateids with NFSv4.1\n   An NFSv4.2 metadata server can hand\
    \ out a layout to an NFSv4.1\n   storage device.  Section 13.9.1 of [RFC5661]\
    \ discusses how the client\n   gets a stateid from the metadata server to present\
    \ to a storage\n   device.\n"
- title: '3.3.  NFSv4.2 as a Storage Protocol in pNFS: The File Layout Type'
  contents:
  - "3.3.  NFSv4.2 as a Storage Protocol in pNFS: The File Layout Type\n   A file\
    \ layout provided by an NFSv4.2 server may refer to either (1) a\n   storage device\
    \ that only implements NFSv4.1 as specified in [RFC5661]\n   or (2) a storage\
    \ device that implements additions from NFSv4.2, in\n   which case the rules in\
    \ Section 3.3.1 apply.  As the file layout type\n   does not provide a means for\
    \ informing the client as to which minor\n   version a particular storage device\
    \ is providing, the client will\n   have to negotiate this with the storage device\
    \ via the normal Remote\n   Procedure Call (RPC) semantics of major and minor\
    \ version discovery.\n   For example, as per Section 16.2.3 of [RFC5661], the\
    \ client could try\n   a COMPOUND with a minorversion field value of 2; if it\
    \ gets\n   NFS4ERR_MINOR_VERS_MISMATCH, it would drop back to 1.\n"
- title: 3.3.1.  Operations Sent to NFSv4.2 Data Servers
  contents:
  - "3.3.1.  Operations Sent to NFSv4.2 Data Servers\n   In addition to the commands\
    \ listed in [RFC5661], NFSv4.2 data servers\n   MAY accept a COMPOUND containing\
    \ the following additional operations:\n   IO_ADVISE (see Section 15.5), READ_PLUS\
    \ (see Section 15.10),\n   WRITE_SAME (see Section 15.12), and SEEK (see Section\
    \ 15.11), which\n   will be treated like the subset specified as \"Operations\
    \ Sent to\n   NFSv4.1 Data Servers\" in Section 13.6 of [RFC5661].\n   Additional\
    \ details on the implementation of these operations in a\n   pNFS context are\
    \ documented in the operation-specific sections.\n"
- title: 4.  Server-Side Copy
  contents:
  - "4.  Server-Side Copy\n   The server-side copy features provide mechanisms that\
    \ allow an NFS\n   client to copy file data on a server or between two servers\
    \ without\n   the data being transmitted back and forth over the network through\n\
    \   the NFS client.  Without these features, an NFS client would copy\n   data\
    \ from one location to another by reading the data from the source\n   server\
    \ over the network and then writing the data back over the\n   network to the\
    \ destination server.\n   If the source object and destination object are on different\
    \ file\n   servers, the file servers will communicate with one another to\n  \
    \ perform the COPY operation.  The server-to-server protocol by which\n   this\
    \ is accomplished is not defined in this document.\n   The copy feature allows\
    \ the server to perform the copying either\n   synchronously or asynchronously.\
    \  The client can request synchronous\n   copying, but the server may not be able\
    \ to honor this request.  If\n   the server intends to perform asynchronous copying,\
    \ it supplies the\n   client with a request identifier that the client can use\
    \ to monitor\n   the progress of the copying and, if appropriate, cancel a request\
    \ in\n   progress.  The request identifier is a stateid representing the\n   internal\
    \ state held by the server while the copying is performed.\n   Multiple asynchronous\
    \ copies of all or part of a file may be in\n   progress in parallel on a server;\
    \ the stateid request identifier\n   allows monitoring and canceling to be applied\
    \ to the correct request.\n"
- title: 4.1.  Protocol Overview
  contents:
  - "4.1.  Protocol Overview\n   The server-side copy offload operations support both\
    \ intra-server and\n   inter-server file copies.  An intra-server copy is a copy\
    \ in which\n   the source file and destination file reside on the same server.\
    \  In\n   an inter-server copy, the source file and destination file are on\n\
    \   different servers.  In both cases, the copy may be performed\n   synchronously\
    \ or asynchronously.\n   In addition, the CLONE operation provides COPY-like functionality\
    \ in\n   the intra-server case, which is both synchronous and atomic in that\n\
    \   other operations may not see the target file in any state between the\n  \
    \ state before the CLONE operation and the state after it.\n   Throughout the\
    \ rest of this document, the NFS server containing the\n   source file is referred\
    \ to as the \"source server\" and the NFS server\n   to which the file is transferred\
    \ as the \"destination server\".  In the\n   case of an intra-server copy, the\
    \ source server and destination\n   server are the same server.  Therefore, in\
    \ the context of an\n   intra-server copy, the terms \"source server\" and \"\
    destination server\"\n   refer to the single server performing the copy.\n   The\
    \ new operations are designed to copy files or regions within them.\n   Other\
    \ file system objects can be copied by building on these\n   operations or using\
    \ other techniques.  For example, if a user wishes\n   to copy a directory, the\
    \ client can synthesize a directory COPY\n   operation by first creating the destination\
    \ directory and the\n   individual (empty) files within it and then copying the\
    \ contents of\n   the source directory's files to files in the new destination\n\
    \   directory.\n   For the inter-server copy, the operations are defined to be\n\
    \   compatible with the traditional copy authorization approach.  The\n   client\
    \ and user are authorized at the source for reading.  Then, they\n   are authorized\
    \ at the destination for writing.\n"
- title: 4.1.1.  COPY Operations
  contents:
  - "4.1.1.  COPY Operations\n   CLONE:  Used by the client to request a synchronous\
    \ atomic COPY-like\n      operation.  (Section 15.13)\n   COPY_NOTIFY:  Used by\
    \ the client to request the source server to\n      authorize a future file copy\
    \ that will be made by a given\n      destination server on behalf of the given\
    \ user.  (Section 15.3)\n   COPY:  Used by the client to request a file copy.\
    \  (Section 15.2)\n   OFFLOAD_CANCEL:  Used by the client to terminate an asynchronous\
    \ file\n      copy.  (Section 15.8)\n   OFFLOAD_STATUS:  Used by the client to\
    \ poll the status of an\n      asynchronous file copy.  (Section 15.9)\n   CB_OFFLOAD:\
    \  Used by the destination server to report the results of\n      an asynchronous\
    \ file copy to the client.  (Section 16.1)\n"
- title: 4.1.2.  Requirements for Operations
  contents:
  - "4.1.2.  Requirements for Operations\n   Inter-server copy, intra-server copy,\
    \ and intra-server clone are each\n   OPTIONAL features in the context of server-side\
    \ copy.  A server may\n   choose independently to implement any of them.  A server\
    \ implementing\n   any of these features may be REQUIRED to implement certain\n\
    \   operations.  Other operations are OPTIONAL in the context of a\n   particular\
    \ feature (see Table 5 in Section 13) but may become\n   REQUIRED, depending on\
    \ server behavior.  Clients need to use these\n   operations to successfully copy\
    \ a file.\n   For a client to do an intra-server file copy, it needs to use either\n\
    \   the COPY or the CLONE operation.  If COPY is used, the client MUST\n   support\
    \ the CB_OFFLOAD operation.  If COPY is used and it returns a\n   stateid, then\
    \ the client MAY use the OFFLOAD_CANCEL and\n   OFFLOAD_STATUS operations.\n \
    \  For a client to do an inter-server file copy, it needs to use the\n   COPY\
    \ and COPY_NOTIFY operations and MUST support the CB_OFFLOAD\n   operation.  If\
    \ COPY returns a stateid, then the client MAY use the\n   OFFLOAD_CANCEL and OFFLOAD_STATUS\
    \ operations.\n   If a server supports the intra-server COPY feature, then the\
    \ server\n   MUST support the COPY operation.  If a server's COPY operation\n\
    \   returns a stateid, then the server MUST also support these\n   operations:\
    \ CB_OFFLOAD, OFFLOAD_CANCEL, and OFFLOAD_STATUS.\n   If a server supports the\
    \ CLONE feature, then it MUST support the\n   CLONE operation and the clone_blksize\
    \ attribute on any file system on\n   which CLONE is supported (as either source\
    \ or destination file).\n   If a source server supports the inter-server COPY\
    \ feature, then it\n   MUST support the COPY_NOTIFY and OFFLOAD_CANCEL operations.\
    \  If a\n   destination server supports the inter-server COPY feature, then it\n\
    \   MUST support the COPY operation.  If a destination server's COPY\n   operation\
    \ returns a stateid, then the destination server MUST also\n   support these operations:\
    \ CB_OFFLOAD, OFFLOAD_CANCEL, COPY_NOTIFY,\n   and OFFLOAD_STATUS.\n   Each operation\
    \ is performed in the context of the user identified by\n   the Open Network Computing\
    \ (ONC) RPC credential in the RPC request\n   containing the COMPOUND or CB_COMPOUND\
    \ request.  For example, an\n   OFFLOAD_CANCEL operation issued by a given user\
    \ indicates that a\n   specified COPY operation initiated by the same user is\
    \ to be\n   canceled.  Therefore, an OFFLOAD_CANCEL MUST NOT interfere with a\n\
    \   copy of the same file initiated by another user.\n   An NFS server MAY allow\
    \ an administrative user to monitor or cancel\n   COPY operations using an implementation-specific\
    \ interface.\n"
- title: 4.2.  Requirements for Inter-Server Copy
  contents:
  - "4.2.  Requirements for Inter-Server Copy\n   The specification of the inter-server\
    \ copy is driven by several\n   requirements:\n   o  The specification MUST NOT\
    \ mandate the server-to-server protocol.\n   o  The specification MUST provide\
    \ guidance for using NFSv4.x as a\n      copy protocol.  For those source and\
    \ destination servers willing\n      to use NFSv4.x, there are specific security\
    \ considerations that\n      the specification MUST address.\n   o  The specification\
    \ MUST NOT mandate preconfiguration between the\n      source and destination\
    \ servers.  Requiring that the source and\n      destination servers first have\
    \ a \"copying relationship\" increases\n      the administrative burden.  However,\
    \ the specification MUST NOT\n      preclude implementations that require preconfiguration.\n\
    \   o  The specification MUST NOT mandate a trust relationship between\n     \
    \ the source and destination servers.  The NFSv4 security model\n      requires\
    \ mutual authentication between a principal on an NFS\n      client and a principal\
    \ on an NFS server.  This model MUST continue\n      with the introduction of\
    \ COPY.\n"
- title: 4.3.  Implementation Considerations
  contents:
  - '4.3.  Implementation Considerations

    '
- title: 4.3.1.  Locking the Files
  contents:
  - "4.3.1.  Locking the Files\n   Both the source file and the destination file may\
    \ need to be locked\n   to protect the content during the COPY operations.  A\
    \ client can\n   achieve this by a combination of OPEN and LOCK operations.  That\
    \ is,\n   either share locks or byte-range locks might be desired.\n   Note that\
    \ when the client establishes a lock stateid on the source,\n   the context of\
    \ that stateid is for the client and not the\n   destination.  As such, there\
    \ might already be an outstanding stateid,\n   issued to the destination as the\
    \ client of the source, with the same\n   value as that provided for the lock\
    \ stateid.  The source MUST\n   interpret the lock stateid as that of the client,\
    \ i.e., when the\n   destination presents it in the context of an inter-server\
    \ copy, it is\n   on behalf of the client.\n"
- title: 4.3.2.  Client Caches
  contents:
  - "4.3.2.  Client Caches\n   In a traditional copy, if the client is in the process\
    \ of writing to\n   the file before the copy (and perhaps with a write delegation),\
    \ it\n   will be straightforward to update the destination server.  With an\n\
    \   inter-server copy, the source has no insight into the changes cached\n   on\
    \ the client.  The client SHOULD write the data back to the source.\n   If it\
    \ does not do so, it is possible that the destination will\n   receive a corrupt\
    \ copy of the file.\n"
- title: 4.4.  Intra-Server Copy
  contents:
  - "4.4.  Intra-Server Copy\n   To copy a file on a single server, the client uses\
    \ a COPY operation.\n   The server may respond to the COPY operation with the\
    \ final results\n   of the copy, or it may perform the copy asynchronously and\
    \ deliver\n   the results using a CB_OFFLOAD callback operation.  If the copy\
    \ is\n   performed asynchronously, the client may poll the status of the copy\n\
    \   using OFFLOAD_STATUS or cancel the copy using OFFLOAD_CANCEL.\n   A synchronous\
    \ intra-server copy is shown in Figure 1.  In this\n   example, the NFS server\
    \ chooses to perform the copy synchronously.\n   The COPY operation is completed,\
    \ either successfully or\n   unsuccessfully, before the server replies to the\
    \ client's request.\n   The server's reply contains the final result of the operation.\n\
    \     Client                                  Server\n        +              \
    \                        +\n        |                                      |\n\
    \        |--- OPEN ---------------------------->| Client opens\n        |<------------------------------------/|\
    \ the source file\n        |                                      |\n        |---\
    \ OPEN ---------------------------->| Client opens\n        |<------------------------------------/|\
    \ the destination file\n        |                                      |\n   \
    \     |--- COPY ---------------------------->| Client requests\n        |<------------------------------------/|\
    \ a file copy\n        |                                      |\n        |---\
    \ CLOSE --------------------------->| Client closes\n        |<------------------------------------/|\
    \ the destination file\n        |                                      |\n   \
    \     |--- CLOSE --------------------------->| Client closes\n        |<------------------------------------/|\
    \ the source file\n        |                                      |\n        |\
    \                                      |\n                 Figure 1: A Synchronous\
    \ Intra-Server Copy\n   An asynchronous intra-server copy is shown in Figure 2.\
    \  In this\n   example, the NFS server performs the copy asynchronously.  The\n\
    \   server's reply to the copy request indicates that the COPY operation\n   was\
    \ initiated and the final result will be delivered at a later time.\n   The server's\
    \ reply also contains a copy stateid.  The client may use\n   this copy stateid\
    \ to poll for status information (as shown) or to\n   cancel the copy using an\
    \ OFFLOAD_CANCEL.  When the server completes\n   the copy, the server performs\
    \ a callback to the client and reports\n   the results.\n     Client         \
    \                         Server\n        +                                  \
    \    +\n        |                                      |\n        |--- OPEN ---------------------------->|\
    \ Client opens\n        |<------------------------------------/| the source file\n\
    \        |                                      |\n        |--- OPEN ---------------------------->|\
    \ Client opens\n        |<------------------------------------/| the destination\
    \ file\n        |                                      |\n        |--- COPY ---------------------------->|\
    \ Client requests\n        |<------------------------------------/| a file copy\n\
    \        |                                      |\n        |                 \
    \                     |\n        |--- OFFLOAD_STATUS ------------------>| Client\
    \ may poll\n        |<------------------------------------/| for status\n    \
    \    |                                      |\n        |                  .  \
    \                 | Multiple OFFLOAD_STATUS\n        |                  .    \
    \               | operations may be sent\n        |                  .       \
    \            |\n        |                                      |\n        |<--\
    \ CB_OFFLOAD -----------------------| Server reports results\n        |\\------------------------------------>|\n\
    \        |                                      |\n        |--- CLOSE --------------------------->|\
    \ Client closes\n        |<------------------------------------/| the destination\
    \ file\n        |                                      |\n        |--- CLOSE --------------------------->|\
    \ Client closes\n        |<------------------------------------/| the source file\n\
    \        |                                      |\n        |                 \
    \                     |\n                Figure 2: An Asynchronous Intra-Server\
    \ Copy\n"
- title: 4.5.  Inter-Server Copy
  contents:
  - "4.5.  Inter-Server Copy\n   A copy may also be performed between two servers.\
    \  The copy protocol\n   is designed to accommodate a variety of network topologies.\
    \  As shown\n   in Figure 3, the client and servers may be connected by multiple\n\
    \   networks.  In particular, the servers may be connected by a\n   specialized,\
    \ high-speed network (network 192.0.2.0/24 in the diagram)\n   that does not include\
    \ the client.  The protocol allows the client to\n   set up the copy between the\
    \ servers (over network 203.0.113.0/24 in\n   the diagram) and for the servers\
    \ to communicate on the high-speed\n   network if they choose to do so.\n    \
    \                         192.0.2.0/24\n                 +-------------------------------------+\n\
    \                 |                                     |\n                 |\
    \                                     |\n                 | 192.0.2.18       \
    \                   | 192.0.2.56\n         +-------+------+                  \
    \     +------+------+\n         |     Source   |                       | Destination\
    \ |\n         +-------+------+                       +------+------+\n       \
    \          | 203.0.113.18                        | 203.0.113.56\n            \
    \     |                                     |\n                 |            \
    \                         |\n                 |             203.0.113.0/24   \
    \       |\n                 +------------------+------------------+\n        \
    \                            |\n                                    |\n      \
    \                              | 203.0.113.243\n                             \
    \ +-----+-----+\n                              |   Client  |\n               \
    \               +-----------+\n            Figure 3: An Example Inter-Server Network\
    \ Topology\n   For an inter-server copy, the client notifies the source server\
    \ that\n   a file will be copied by the destination server using a COPY_NOTIFY\n\
    \   operation.  The client then initiates the copy by sending the COPY\n   operation\
    \ to the destination server.  The destination server may\n   perform the copy\
    \ synchronously or asynchronously.\n   A synchronous inter-server copy is shown\
    \ in Figure 4.  In this case,\n   the destination server chooses to perform the\
    \ copy before responding\n   to the client's COPY request.\n     Client      \
    \          Source         Destination\n        +                    +        \
    \         +\n        |                    |                 |\n        |--- OPEN\
    \        --->|                 | Returns\n        |<------------------/|     \
    \            | open state os1\n        |                    |                \
    \ |\n        |--- COPY_NOTIFY --->|                 |\n        |<------------------/|\
    \                 |\n        |                    |                 |\n      \
    \  |--- OPEN ---------------------------->| Returns\n        |<------------------------------------/|\
    \ open state os2\n        |                    |                 |\n        |---\
    \ COPY ---------------------------->|\n        |                    |        \
    \         |\n        |                    |                 |\n        |     \
    \               |<----- READ -----|\n        |                    |\\--------------->|\n\
    \        |                    |                 |\n        |                 \
    \   |        .        | Multiple READs may\n        |                    |   \
    \     .        | be necessary\n        |                    |        .       \
    \ |\n        |                    |                 |\n        |             \
    \       |                 |\n        |<------------------------------------/|\
    \ Destination replies\n        |                    |                 | to COPY\n\
    \        |                    |                 |\n        |--- CLOSE --------------------------->|\
    \ Release os2\n        |<------------------------------------/|\n        |   \
    \                 |                 |\n        |--- CLOSE       --->|        \
    \         | Release os1\n        |<------------------/|                 |\n  \
    \               Figure 4: A Synchronous Inter-Server Copy\n   An asynchronous\
    \ inter-server copy is shown in Figure 5.  In this\n   case, the destination server\
    \ chooses to respond to the client's COPY\n   request immediately and then perform\
    \ the copy asynchronously.\n     Client                Source         Destination\n\
    \       +                    +                 +\n       |                   \
    \ |                 |\n       |--- OPEN        --->|                 | Returns\n\
    \       |<------------------/|                 | open state os1\n       |    \
    \                |                 |\n       |--- LOCK        --->|          \
    \       | Optional; could be done\n       |<------------------/|             \
    \    | with a share lock\n       |                    |                 |\n  \
    \     |--- COPY_NOTIFY --->|                 | Need to pass in\n       |<------------------/|\
    \                 | os1 or lock state\n       |                    |         \
    \        |\n       |                    |                 |\n       |        \
    \            |                 |\n       |--- OPEN ---------------------------->|\
    \ Returns\n       |<------------------------------------/| open state os2\n  \
    \     |                    |                 |\n       |--- LOCK ---------------------------->|\
    \ Optional ...\n       |<------------------------------------/|\n       |    \
    \                |                 |\n       |--- COPY ---------------------------->|\
    \ Need to pass in\n       |<------------------------------------/| os2 or lock\
    \ state\n       |                    |                 |\n       |           \
    \         |                 |\n       |                    |<----- READ -----|\n\
    \       |                    |\\--------------->|\n       |                  \
    \  |                 |\n       |                    |        .        | Multiple\
    \ READs may\n       |                    |        .        | be necessary\n  \
    \     |                    |        .        |\n       |                    |\
    \                 |\n       |                    |                 |\n       |---\
    \ OFFLOAD_STATUS ------------------>| Client may poll\n       |<------------------------------------/|\
    \ for status\n       |                    |                 |\n       |      \
    \              |        .        | Multiple OFFLOAD_STATUS\n       |         \
    \           |        .        | operations may be sent\n       |             \
    \       |        .        |\n       |                    |                 |\n\
    \       |                    |                 |\n       |                   \
    \ |                 |\n       |<-- CB_OFFLOAD -----------------------| Destination\
    \ reports\n       |\\------------------------------------>| results\n       |\
    \                    |                 |\n       |--- LOCKU --------------------------->|\
    \ Only if LOCK was done\n       |<------------------------------------/|\n   \
    \    |                    |                 |\n       |--- CLOSE --------------------------->|\
    \ Release os2\n       |<------------------------------------/|\n       |     \
    \               |                 |\n       |--- LOCKU       --->|           \
    \      | Only if LOCK was done\n       |<------------------/|                \
    \ |\n       |                    |                 |\n       |--- CLOSE      \
    \ --->|                 | Release os1\n       |<------------------/|         \
    \        |\n       |                    |                 |\n                Figure\
    \ 5: An Asynchronous Inter-Server Copy\n"
- title: 4.6.  Server-to-Server Copy Protocol
  contents:
  - "4.6.  Server-to-Server Copy Protocol\n   The choice of what protocol to use in\
    \ an inter-server copy is\n   ultimately the destination server's decision.  However,\
    \ the\n   destination server has to be cognizant that it is working on behalf\n\
    \   of the client.\n"
- title: 4.6.1.  Considerations on Selecting a Copy Protocol
  contents:
  - "4.6.1.  Considerations on Selecting a Copy Protocol\n   The client can have requirements\
    \ over both the size of transactions\n   and error recovery semantics.  It may\
    \ want to split the copy up such\n   that each chunk is synchronously transferred.\
    \  It may want the copy\n   protocol to copy the bytes in consecutive order such\
    \ that upon an\n   error the client can restart the copy at the last known good\
    \ offset.\n   If the destination server cannot meet these requirements, the client\n\
    \   may prefer the traditional copy mechanism such that it can meet those\n  \
    \ requirements.\n"
- title: 4.6.2.  Using NFSv4.x as the Copy Protocol
  contents:
  - "4.6.2.  Using NFSv4.x as the Copy Protocol\n   The destination server MAY use\
    \ standard NFSv4.x (where x >= 1)\n   operations to read the data from the source\
    \ server.  If NFSv4.x is\n   used for the server-to-server copy protocol, the\
    \ destination server\n   can use the source filehandle and ca_src_stateid provided\
    \ in the COPY\n   request with standard NFSv4.x operations to read data from the\
    \ source\n   server.  Note that the ca_src_stateid MUST be the cnr_stateid\n \
    \  returned from the source via the COPY_NOTIFY (Section 15.3).\n"
- title: 4.6.3.  Using an Alternative Copy Protocol
  contents:
  - "4.6.3.  Using an Alternative Copy Protocol\n   In a homogeneous environment,\
    \ the source and destination servers\n   might be able to perform the file copy\
    \ extremely efficiently using\n   specialized protocols.  For example, the source\
    \ and destination\n   servers might be two nodes sharing a common file system\
    \ format for\n   the source and destination file systems.  Thus, the source and\n\
    \   destination are in an ideal position to efficiently render the image\n   of\
    \ the source file to the destination file by replicating the file\n   system formats\
    \ at the block level.  Another possibility is that the\n   source and destination\
    \ might be two nodes sharing a common storage\n   area network, and thus there\
    \ is no need to copy any data at all;\n   instead, ownership of the file and its\
    \ contents might simply be\n   reassigned to the destination.  To allow for these\
    \ possibilities, the\n   destination server is allowed to use a server-to-server\
    \ copy protocol\n   of its choice.\n   In a heterogeneous environment, using a\
    \ protocol other than NFSv4.x\n   (e.g., HTTP [RFC7230] or FTP [RFC959]) presents\
    \ some challenges.  In\n   particular, the destination server is presented with\
    \ the challenge of\n   accessing the source file given only an NFSv4.x filehandle.\n\
    \   One option for protocols that identify source files with pathnames is\n  \
    \ to use an ASCII hexadecimal representation of the source filehandle\n   as the\
    \ filename.\n   Another option for the source server is to use URLs to direct\
    \ the\n   destination server to a specialized service.  For example, the\n   response\
    \ to COPY_NOTIFY could include the URL\n   <ftp://s1.example.com:9999/_FH/0x12345>,\
    \ where 0x12345 is the ASCII\n   hexadecimal representation of the source filehandle.\
    \  When the\n   destination server receives the source server's URL, it would\
    \ use\n   \"_FH/0x12345\" as the filename to pass to the FTP server listening\
    \ on\n   port 9999 of s1.example.com.  On port 9999 there would be a special\n\
    \   instance of the FTP service that understands how to convert NFS\n   filehandles\
    \ to an open file descriptor (in many operating systems,\n   this would require\
    \ a new system call, one that is the inverse of the\n   makefh() function that\
    \ the pre-NFSv4 MOUNT service needs).\n   Authenticating and identifying the destination\
    \ server to the source\n   server is also a challenge.  One solution would be\
    \ to construct\n   unique URLs for each destination server.\n"
- title: 4.7.  netloc4 - Network Locations
  contents:
  - "4.7.  netloc4 - Network Locations\n   The server-side COPY operations specify\
    \ network locations using the\n   netloc4 data type shown below (see [RFC7863]):\n\
    \   <CODE BEGINS>\n   enum netloc_type4 {\n           NL4_NAME        = 1,\n \
    \          NL4_URL         = 2,\n           NL4_NETADDR     = 3\n   };\n   union\
    \ netloc4 switch (netloc_type4 nl_type) {\n           case NL4_NAME:         \
    \ utf8str_cis nl_name;\n           case NL4_URL:           utf8str_cis nl_url;\n\
    \           case NL4_NETADDR:       netaddr4    nl_addr;\n   };\n   <CODE ENDS>\n\
    \   If the netloc4 is of type NL4_NAME, the nl_name field MUST be\n   specified\
    \ as a UTF-8 string.  The nl_name is expected to be resolved\n   to a network\
    \ address via DNS, the Lightweight Directory Access\n   Protocol (LDAP), the Network\
    \ Information Service (NIS), /etc/hosts,\n   or some other means.  If the netloc4\
    \ is of type NL4_URL, a server URL\n   [RFC3986] appropriate for the server-to-server\
    \ COPY operation is\n   specified as a UTF-8 string.  If the netloc4 is of type\
    \ NL4_NETADDR,\n   the nl_addr field MUST contain a valid netaddr4 as defined\
    \ in\n   Section 3.3.9 of [RFC5661].\n   When netloc4 values are used for an inter-server\
    \ copy as shown in\n   Figure 3, their values may be evaluated on the source server,\n\
    \   destination server, and client.  The network environment in which\n   these\
    \ systems operate should be configured so that the netloc4 values\n   are interpreted\
    \ as intended on each system.\n"
- title: 4.8.  Copy Offload Stateids
  contents:
  - "4.8.  Copy Offload Stateids\n   A server may perform a copy offload operation\
    \ asynchronously.  An\n   asynchronous copy is tracked using a copy offload stateid.\
    \  Copy\n   offload stateids are included in the COPY, OFFLOAD_CANCEL,\n   OFFLOAD_STATUS,\
    \ and CB_OFFLOAD operations.\n   A copy offload stateid will be valid until either\
    \ (A) the client or\n   server restarts or (B) the client returns the resource\
    \ by issuing an\n   OFFLOAD_CANCEL operation or the client replies to a CB_OFFLOAD\n\
    \   operation.\n   A copy offload stateid's seqid MUST NOT be zero.  In the context\
    \ of a\n   copy offload operation, it is inappropriate to indicate \"the most\n\
    \   recent copy offload operation\" using a stateid with a seqid of zero\n   (see\
    \ Section 8.2.2 of [RFC5661]).  It is inappropriate because the\n   stateid refers\
    \ to internal state in the server and there may be\n   several asynchronous COPY\
    \ operations being performed in parallel on\n   the same file by the server. \
    \ Therefore, a copy offload stateid with\n   a seqid of zero MUST be considered\
    \ invalid.\n"
- title: 4.9.  Security Considerations for Server-Side Copy
  contents:
  - "4.9.  Security Considerations for Server-Side Copy\n   All security considerations\
    \ pertaining to NFSv4.1 [RFC5661] apply to\n   this section; as such, the standard\
    \ security mechanisms used by the\n   protocol can be used to secure the server-to-server\
    \ operations.\n   NFSv4 clients and servers supporting the inter-server COPY operations\n\
    \   described in this section are REQUIRED to implement the mechanism\n   described\
    \ in Section 4.9.1.1 and to support rejecting COPY_NOTIFY\n   requests that do\
    \ not use the RPC security protocol (RPCSEC_GSS)\n   [RFC7861] with privacy. \
    \ If the server-to-server copy protocol is\n   based on ONC RPC, the servers are\
    \ also REQUIRED to implement\n   [RFC7861], including the RPCSEC_GSSv3 \"copy_to_auth\"\
    ,\n   \"copy_from_auth\", and \"copy_confirm_auth\" structured privileges.\n \
    \  This requirement to implement is not a requirement to use; for\n   example,\
    \ a server may, depending on configuration, also allow\n   COPY_NOTIFY requests\
    \ that use only AUTH_SYS.\n   If a server requires the use of an RPCSEC_GSSv3\
    \ copy_to_auth,\n   copy_from_auth, or copy_confirm_auth privilege and it is not\
    \ used,\n   the server will reject the request with NFS4ERR_PARTNER_NO_AUTH.\n"
- title: 4.9.1.  Inter-Server Copy Security
  contents:
  - '4.9.1.  Inter-Server Copy Security

    '
- title: 4.9.1.1.  Inter-Server Copy via ONC RPC with RPCSEC_GSSv3
  contents:
  - "4.9.1.1.  Inter-Server Copy via ONC RPC with RPCSEC_GSSv3\n   When the client\
    \ sends a COPY_NOTIFY to the source server to expect\n   the destination to attempt\
    \ to copy data from the source server, it is\n   expected that this copy is being\
    \ done on behalf of the principal\n   (called the \"user principal\") that sent\
    \ the RPC request that encloses\n   the COMPOUND procedure that contains the COPY_NOTIFY\
    \ operation.  The\n   user principal is identified by the RPC credentials.  A\
    \ mechanism\n   that allows the user principal to authorize the destination server\
    \ to\n   perform the copy, lets the source server properly authenticate the\n\
    \   destination's copy, and does not allow the destination server to\n   exceed\
    \ this authorization is necessary.\n   An approach that sends delegated credentials\
    \ of the client's user\n   principal to the destination server is not used for\
    \ the following\n   reason.  If the client's user delegated its credentials, the\n\
    \   destination would authenticate as the user principal.  If the\n   destination\
    \ were using the NFSv4 protocol to perform the copy, then\n   the source server\
    \ would authenticate the destination server as the\n   user principal, and the\
    \ file copy would securely proceed.  However,\n   this approach would allow the\
    \ destination server to copy other files.\n   The user principal would have to\
    \ trust the destination server to not\n   do so.  This is counter to the requirements\
    \ and therefore is not\n   considered.\n   Instead, a feature of the RPCSEC_GSSv3\
    \ protocol [RFC7861] can be\n   used: RPC-application-defined structured privilege\
    \ assertion.  This\n   feature allows the destination server to authenticate to\
    \ the source\n   server as acting on behalf of the user principal and to authorize\
    \ the\n   destination server to perform READs of the file to be copied from the\n\
    \   source on behalf of the user principal.  Once the copy is complete,\n   the\
    \ client can destroy the RPCSEC_GSSv3 handles to end the\n   authorization of\
    \ both the source and destination servers to copy.\n   For each structured privilege\
    \ assertion defined by an RPC\n   application, RPCSEC_GSSv3 requires the application\
    \ to define a name\n   string and a data structure that will be encoded and passed\
    \ between\n   client and server as opaque data.  For NFSv4, the data structures\n\
    \   specified below MUST be serialized using XDR.\n   Three RPCSEC_GSSv3 structured\
    \ privilege assertions that work together\n   to authorize the copy are defined\
    \ here.  For each of the assertions,\n   the description starts with the name\
    \ string passed in the rp_name\n   field of the rgss3_privs structure defined\
    \ in Section 2.7.1.4 of\n   [RFC7861] and specifies the XDR encoding of the associated\
    \ structured\n   data passed via the rp_privilege field of the structure.\n  \
    \ copy_from_auth:  A user principal is authorizing a source principal\n      (\"\
    nfs@<source>\") to allow a destination principal\n      (\"nfs@<destination>\"\
    ) to set up the copy_confirm_auth privilege\n      required to copy a file from\
    \ the source to the destination on\n      behalf of the user principal.  This\
    \ privilege is established on\n      the source server before the user principal\
    \ sends a COPY_NOTIFY\n      operation to the source server, and the resultant\
    \ RPCSEC_GSSv3\n      context is used to secure the COPY_NOTIFY operation.\n \
    \     <CODE BEGINS>\n   struct copy_from_auth_priv {\n           secret4     \
    \        cfap_shared_secret;\n           netloc4             cfap_destination;\n\
    \           /* the NFSv4 user name that the user principal maps to */\n      \
    \     utf8str_mixed       cfap_username;\n   };\n      <CODE ENDS>\n      cfap_shared_secret\
    \ is an automatically generated random number\n      secret value.\n   copy_to_auth:\
    \  A user principal is authorizing a destination\n      principal (\"nfs@<destination>\"\
    ) to set up a copy_confirm_auth\n      privilege with a source principal (\"nfs@<source>\"\
    ) to allow it to\n      copy a file from the source to the destination on behalf\
    \ of the\n      user principal.  This privilege is established on the destination\n\
    \      server before the user principal sends a COPY operation to the\n      destination\
    \ server, and the resultant RPCSEC_GSSv3 context is used\n      to secure the\
    \ COPY operation.\n      <CODE BEGINS>\n   struct copy_to_auth_priv {\n      \
    \     /* equal to cfap_shared_secret */\n           secret4              ctap_shared_secret;\n\
    \           netloc4              ctap_source<>;\n           /* the NFSv4 user\
    \ name that the user principal maps to */\n           utf8str_mixed        ctap_username;\n\
    \   };\n      <CODE ENDS>\n      ctap_shared_secret is the automatically generated\
    \ secret value\n      used to establish the copy_from_auth privilege with the\
    \ source\n      principal.  See Section 4.9.1.1.1.\n   copy_confirm_auth:  A destination\
    \ principal (\"nfs@<destination>\") is\n      confirming with the source principal\
    \ (\"nfs@<source>\") that it is\n      authorized to copy data from the source.\
    \  This privilege is\n      established on the destination server before the file\
    \ is copied\n      from the source to the destination.  The resultant RPCSEC_GSSv3\n\
    \      context is used to secure the READ operations from the source to\n    \
    \  the destination server.\n      <CODE BEGINS>\n   struct copy_confirm_auth_priv\
    \ {\n           /* equal to GSS_GetMIC() of cfap_shared_secret */\n          \
    \ opaque              ccap_shared_secret_mic<>;\n           /* the NFSv4 user\
    \ name that the user principal maps to */\n           utf8str_mixed       ccap_username;\n\
    \   };\n      <CODE ENDS>\n"
- title: 4.9.1.1.1.  Establishing a Security Context
  contents:
  - "4.9.1.1.1.  Establishing a Security Context\n   When the user principal wants\
    \ to copy a file between two servers, if\n   it has not established copy_from_auth\
    \ and copy_to_auth privileges on\n   the servers, it establishes them as follows:\n\
    \   o  As noted in [RFC7861], the client uses an existing RPCSEC_GSSv3\n     \
    \ context termed the \"parent\" handle to establish and protect\n      RPCSEC_GSSv3\
    \ structured privilege assertion exchanges.  The\n      copy_from_auth privilege\
    \ will use the context established between\n      the user principal and the source\
    \ server used to OPEN the source\n      file as the RPCSEC_GSSv3 parent handle.\
    \  The copy_to_auth\n      privilege will use the context established between\
    \ the user\n      principal and the destination server used to OPEN the destination\n\
    \      file as the RPCSEC_GSSv3 parent handle.\n   o  A random number is generated\
    \ to use as a secret to be shared\n      between the two servers.  Note that the\
    \ random number SHOULD NOT\n      be reused between establishing different security\
    \ contexts.  The\n      resulting shared secret will be placed in the copy_from_auth_priv\n\
    \      cfap_shared_secret field and the copy_to_auth_priv\n      ctap_shared_secret\
    \ field.  Because of this shared_secret, the\n      RPCSEC_GSS3_CREATE control\
    \ messages for copy_from_auth and\n      copy_to_auth MUST use a Quality of Protection\
    \ (QoP) of\n      rpc_gss_svc_privacy.\n   o  An instance of copy_from_auth_priv\
    \ is filled in with the shared\n      secret, the destination server, and the\
    \ NFSv4 user id of the user\n      principal and is placed in rpc_gss3_create_args\n\
    \      assertions[0].privs.privilege.  The string \"copy_from_auth\" is\n    \
    \  placed in assertions[0].privs.name.  The source server unwraps the\n      rpc_gss_svc_privacy\
    \ RPCSEC_GSS3_CREATE payload and verifies that\n      the NFSv4 user id being\
    \ asserted matches the source server's\n      mapping of the user principal. \
    \ If it does, the privilege is\n      established on the source server as <copy_from_auth,\
    \ user id,\n      destination>.  The field \"handle\" in a successful reply is\
    \ the\n      RPCSEC_GSSv3 copy_from_auth \"child\" handle that the client will\n\
    \      use in COPY_NOTIFY requests to the source server.\n   o  An instance of\
    \ copy_to_auth_priv is filled in with the shared\n      secret, the cnr_source_server\
    \ list returned by COPY_NOTIFY, and\n      the NFSv4 user id of the user principal.\
    \  The copy_to_auth_priv\n      instance is placed in rpc_gss3_create_args\n \
    \     assertions[0].privs.privilege.  The string \"copy_to_auth\" is\n      placed\
    \ in assertions[0].privs.name.  The destination server\n      unwraps the rpc_gss_svc_privacy\
    \ RPCSEC_GSS3_CREATE payload and\n      verifies that the NFSv4 user id being\
    \ asserted matches the\n      destination server's mapping of the user principal.\
    \  If it does,\n      the privilege is established on the destination server as\n\
    \      <copy_to_auth, user id, source list>.  The field \"handle\" in a\n    \
    \  successful reply is the RPCSEC_GSSv3 copy_to_auth child handle\n      that\
    \ the client will use in COPY requests to the destination\n      server involving\
    \ the source server.\n   As noted in Section 2.7.1 of [RFC7861] (\"New Control\
    \ Procedure -\n   RPCSEC_GSS_CREATE\"), both the client and the source server\
    \ should\n   associate the RPCSEC_GSSv3 child handle with the parent RPCSEC_GSSv3\n\
    \   handle used to create the RPCSEC_GSSv3 child handle.\n"
- title: 4.9.1.1.2.  Starting a Secure Inter-Server Copy
  contents:
  - "4.9.1.1.2.  Starting a Secure Inter-Server Copy\n   When the client sends a COPY_NOTIFY\
    \ request to the source server, it\n   uses the privileged copy_from_auth RPCSEC_GSSv3\
    \ handle.\n   cna_destination_server in the COPY_NOTIFY MUST be the same as\n\
    \   cfap_destination specified in copy_from_auth_priv.  Otherwise, the\n   COPY_NOTIFY\
    \ will fail with NFS4ERR_ACCESS.  The source server\n   verifies that the privilege\
    \ <copy_from_auth, user id, destination>\n   exists and annotates it with the\
    \ source filehandle, if the user\n   principal has read access to the source file\
    \ and if administrative\n   policies give the user principal and the NFS client\
    \ read access to\n   the source file (i.e., if the ACCESS operation would grant\
    \ read\n   access).  Otherwise, the COPY_NOTIFY will fail with NFS4ERR_ACCESS.\n\
    \   When the client sends a COPY request to the destination server, it\n   uses\
    \ the privileged copy_to_auth RPCSEC_GSSv3 handle.\n   ca_source_server list in\
    \ the COPY MUST be the same as ctap_source\n   list specified in copy_to_auth_priv.\
    \  Otherwise, the COPY will fail\n   with NFS4ERR_ACCESS.  The destination server\
    \ verifies that the\n   privilege <copy_to_auth, user id, source list> exists\
    \ and annotates\n   it with the source and destination filehandles.  If the COPY\
    \ returns\n   a wr_callback_id, then this is an asynchronous copy and the\n  \
    \ wr_callback_id must also must be annotated to the copy_to_auth\n   privilege.\
    \  If the client has failed to establish the copy_to_auth\n   privilege, it will\
    \ reject the request with NFS4ERR_PARTNER_NO_AUTH.\n   If either the COPY_NOTIFY\
    \ operation or the COPY operations fail, the\n   associated copy_from_auth and\
    \ copy_to_auth RPCSEC_GSSv3 handles MUST\n   be destroyed.\n"
- title: 4.9.1.1.3.  Securing ONC RPC Server-to-Server Copy Protocols
  contents:
  - "4.9.1.1.3.  Securing ONC RPC Server-to-Server Copy Protocols\n   After a destination\
    \ server has a copy_to_auth privilege established\n   on it and it receives a\
    \ COPY request, if it knows it will use an ONC\n   RPC protocol to copy data,\
    \ it will establish a copy_confirm_auth\n   privilege on the source server prior\
    \ to responding to the COPY\n   operation, as follows:\n   o  Before establishing\
    \ an RPCSEC_GSSv3 context, a parent context\n      needs to exist between nfs@<destination>\
    \ as the initiator\n      principal and nfs@<source> as the target principal.\
    \  If NFS is to\n      be used as the copy protocol, this means that the destination\n\
    \      server must mount the source server using RPCSEC_GSSv3.\n   o  An instance\
    \ of copy_confirm_auth_priv is filled in with\n      information from the established\
    \ copy_to_auth privilege.  The\n      value of the ccap_shared_secret_mic field\
    \ is a GSS_GetMIC() of the\n      ctap_shared_secret in the copy_to_auth privilege\
    \ using the parent\n      handle context.  The ccap_username field is the mapping\
    \ of the\n      user principal to an NFSv4 user name (\"user\"@\"domain\" form)\
    \ and\n      MUST be the same as the ctap_username in the copy_to_auth\n     \
    \ privilege.  The copy_confirm_auth_priv instance is placed in\n      rpc_gss3_create_args\
    \ assertions[0].privs.privilege.  The string\n      \"copy_confirm_auth\" is placed\
    \ in assertions[0].privs.name.\n   o  The RPCSEC_GSS3_CREATE copy_from_auth message\
    \ is sent to the\n      source server with a QoP of rpc_gss_svc_privacy.  The\
    \ source\n      server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload\n\
    \      and verifies the cap_shared_secret_mic by calling GSS_VerifyMIC()\n   \
    \   using the parent context on the cfap_shared_secret from the\n      established\
    \ copy_from_auth privilege, and verifies that the\n      ccap_username equals\
    \ the cfap_username.\n   o  If all verifications succeed, the copy_confirm_auth\
    \ privilege is\n      established on the source server as <copy_confirm_auth,\n\
    \      shared_secret_mic, user id>.  Because the shared secret has been\n    \
    \  verified, the resultant copy_confirm_auth RPCSEC_GSSv3 child\n      handle\
    \ is noted to be acting on behalf of the user principal.\n   o  If the source\
    \ server fails to verify the copy_from_auth privilege,\n      the COPY_NOTIFY\
    \ operation will be rejected with\n      NFS4ERR_PARTNER_NO_AUTH.\n   o  If the\
    \ destination server fails to verify the copy_to_auth or\n      copy_confirm_auth\
    \ privilege, the COPY will be rejected with\n      NFS4ERR_PARTNER_NO_AUTH, causing\
    \ the client to destroy the\n      associated copy_from_auth and copy_to_auth\
    \ RPCSEC_GSSv3 structured\n      privilege assertion handles.\n   o  All subsequent\
    \ ONC RPC READ requests sent from the destination to\n      copy data from the\
    \ source to the destination will use the\n      RPCSEC_GSSv3 copy_confirm_auth\
    \ child handle.\n   Note that the use of the copy_confirm_auth privilege accomplishes\
    \ the\n   following:\n   o  If a protocol like NFS is being used with export policies,\
    \ the\n      export policies can be overridden if the destination server is not\n\
    \      authorized to act as an NFS client.\n   o  Manual configuration to allow\
    \ a copy relationship between the\n      source and destination is not needed.\n"
- title: 4.9.1.1.4.  Maintaining a Secure Inter-Server Copy
  contents:
  - "4.9.1.1.4.  Maintaining a Secure Inter-Server Copy\n   If the client determines\
    \ that either the copy_from_auth or the\n   copy_to_auth handle becomes invalid\
    \ during a copy, then the copy MUST\n   be aborted by the client sending an OFFLOAD_CANCEL\
    \ to both the source\n   and destination servers and destroying the respective\
    \ copy-related\n   context handles as described in Section 4.9.1.1.5.\n"
- title: 4.9.1.1.5.  Finishing or Stopping a Secure Inter-Server Copy
  contents:
  - "4.9.1.1.5.  Finishing or Stopping a Secure Inter-Server Copy\n   Under normal\
    \ operation, the client MUST destroy the copy_from_auth\n   and the copy_to_auth\
    \ RPCSEC_GSSv3 handle once the COPY operation\n   returns for a synchronous inter-server\
    \ copy or a CB_OFFLOAD reports\n   the result of an asynchronous copy.\n   The\
    \ copy_confirm_auth privilege is constructed from information held\n   by the\
    \ copy_to_auth privilege and MUST be destroyed by the\n   destination server (via\
    \ an RPCSEC_GSS3_DESTROY call) when the\n   copy_to_auth RPCSEC_GSSv3 handle is\
    \ destroyed.\n   The copy_confirm_auth RPCSEC_GSS3 handle is associated with a\n\
    \   copy_from_auth RPCSEC_GSS3 handle on the source server via the shared\n  \
    \ secret and MUST be locally destroyed (there is no\n   RPCSEC_GSS3_DESTROY, as\
    \ the source server is not the initiator) when\n   the copy_from_auth RPCSEC_GSSv3\
    \ handle is destroyed.\n   If the client sends an OFFLOAD_CANCEL to the source\
    \ server to rescind\n   the destination server's synchronous copy privilege, it\
    \ uses the\n   privileged copy_from_auth RPCSEC_GSSv3 handle, and the\n   cra_destination_server\
    \ in the OFFLOAD_CANCEL MUST be the same as the\n   name of the destination server\
    \ specified in copy_from_auth_priv.  The\n   source server will then delete the\
    \ <copy_from_auth, user id,\n   destination> privilege and fail any subsequent\
    \ copy requests sent\n   under the auspices of this privilege from the destination\
    \ server.\n   The client MUST destroy both the copy_from_auth and the copy_to_auth\n\
    \   RPCSEC_GSSv3 handles.\n   If the client sends an OFFLOAD_STATUS to the destination\
    \ server to\n   check on the status of an asynchronous copy, it uses the privileged\n\
    \   copy_to_auth RPCSEC_GSSv3 handle, and the osa_stateid in the\n   OFFLOAD_STATUS\
    \ MUST be the same as the wr_callback_id specified in\n   the copy_to_auth privilege\
    \ stored on the destination server.\n   If the client sends an OFFLOAD_CANCEL\
    \ to the destination server to\n   cancel an asynchronous copy, it uses the privileged\
    \ copy_to_auth\n   RPCSEC_GSSv3 handle, and the oaa_stateid in the OFFLOAD_CANCEL\
    \ MUST\n   be the same as the wr_callback_id specified in the copy_to_auth\n \
    \  privilege stored on the destination server.  The destination server\n   will\
    \ then delete the <copy_to_auth, user id, source list> privilege\n   and the associated\
    \ copy_confirm_auth RPCSEC_GSSv3 handle.  The client\n   MUST destroy both the\
    \ copy_to_auth and copy_from_auth RPCSEC_GSSv3\n   handles.\n"
- title: 4.9.1.2.  Inter-Server Copy via ONC RPC without RPCSEC_GSS
  contents:
  - "4.9.1.2.  Inter-Server Copy via ONC RPC without RPCSEC_GSS\n   ONC RPC security\
    \ flavors other than RPCSEC_GSS MAY be used with the\n   server-side copy offload\
    \ operations described in this section.  In\n   particular, host-based ONC RPC\
    \ security flavors such as AUTH_NONE and\n   AUTH_SYS MAY be used.  If a host-based\
    \ security flavor is used, a\n   minimal level of protection for the server-to-server\
    \ copy protocol is\n   possible.\n   The biggest issue is that there is a lack\
    \ of a strong security method\n   to allow the source server and destination server\
    \ to identify\n   themselves to each other.  A further complication is that in\
    \ a\n   multihomed environment the destination server might not contact the\n\
    \   source server from the same network address specified by the client\n   in\
    \ the COPY_NOTIFY.  The cnr_stateid returned from the COPY_NOTIFY\n   can be used\
    \ to uniquely identify the destination server to the source\n   server.  The use\
    \ of the cnr_stateid provides initial authentication\n   of the destination server\
    \ but cannot defend against man-in-the-middle\n   attacks after authentication\
    \ or against an eavesdropper that observes\n   the opaque stateid on the wire.\
    \  Other secure communication\n   techniques (e.g., IPsec) are necessary to block\
    \ these attacks.\n   Servers SHOULD reject COPY_NOTIFY requests that do not use\
    \ RPCSEC_GSS\n   with privacy, thus ensuring that the cnr_stateid in the COPY_NOTIFY\n\
    \   reply is encrypted.  For the same reason, clients SHOULD send COPY\n   requests\
    \ to the destination using RPCSEC_GSS with privacy.\n"
- title: 5.  Support for Application I/O Hints
  contents:
  - "5.  Support for Application I/O Hints\n   Applications can issue client I/O hints\
    \ via posix_fadvise()\n   [posix_fadvise] to the NFS client.  While this can help\
    \ the NFS\n   client optimize I/O and caching for a file, it does not allow the\
    \ NFS\n   server and its exported file system to do likewise.  The IO_ADVISE\n\
    \   procedure (Section 15.5) is used to communicate the client file\n   access\
    \ patterns to the NFS server.  The NFS server, upon receiving an\n   IO_ADVISE\
    \ operation, MAY choose to alter its I/O and caching behavior\n   but is under\
    \ no obligation to do so.\n   Application-specific NFS clients such as those used\
    \ by hypervisors\n   and databases can also leverage application hints to communicate\n\
    \   their specialized requirements.\n"
- title: 6.  Sparse Files
  contents:
  - "6.  Sparse Files\n   A sparse file is a common way of representing a large file\
    \ without\n   having to utilize all of the disk space for it.  Consequently, a\n\
    \   sparse file uses less physical space than its size indicates.  This\n   means\
    \ the file contains \"holes\", byte ranges within the file that\n   contain no\
    \ data.  Most modern file systems support sparse files,\n   including most UNIX\
    \ file systems and Microsoft's New Technology File\n   System (NTFS); however,\
    \ it should be noted that Apple's Hierarchical\n   File System Plus (HFS+) does\
    \ not.  Common examples of sparse files\n   include Virtual Machine (VM) OS/disk\
    \ images, database files, log\n   files, and even checkpoint recovery files most\
    \ commonly used by the\n   High-Performance Computing (HPC) community.\n   In\
    \ addition, many modern file systems support the concept of\n   \"unwritten\"\
    \ or \"uninitialized\" blocks, which have uninitialized space\n   allocated to\
    \ them on disk but will return zeros until data is written\n   to them.  Such\
    \ functionality is already present in the data model of\n   the pNFS block/volume\
    \ layout (see [RFC5663]).  Uninitialized blocks\n   can be thought of as holes\
    \ inside a space reservation window.\n   If an application reads a hole in a sparse\
    \ file, the file system must\n   return all zeros to the application.  For local\
    \ data access there is\n   little penalty, but with NFS these zeros must be transferred\
    \ back to\n   the client.  If an application uses the NFS client to read data\
    \ into\n   memory, this wastes time and bandwidth as the application waits for\n\
    \   the zeros to be transferred.\n   A sparse file is typically created by initializing\
    \ the file to be all\n   zeros.  Nothing is written to the data in the file; instead,\
    \ the hole\n   is recorded in the metadata for the file.  So, an 8G disk image\
    \ might\n   be represented initially by a few hundred bits in the metadata (on\n\
    \   UNIX file systems, the inode) and nothing on the disk.  If the VM\n   then\
    \ writes 100M to a file in the middle of the image, there would\n   now be two\
    \ holes represented in the metadata and 100M in the data.\n   No new operation\
    \ is needed to allow the creation of a sparsely\n   populated file; when a file\
    \ is created and a write occurs past the\n   current size of the file, the non-allocated\
    \ region will either be a\n   hole or be filled with zeros.  The choice of behavior\
    \ is dictated by\n   the underlying file system and is transparent to the application.\n\
    \   However, the abilities to read sparse files and to punch holes to\n   reinitialize\
    \ the contents of a file are needed.\n   Two new operations -- DEALLOCATE (Section\
    \ 15.4) and READ_PLUS\n   (Section 15.10) -- are introduced.  DEALLOCATE allows\
    \ for the hole\n   punching, where an application might want to reset the allocation\
    \ and\n   reservation status of a range of the file.  READ_PLUS supports all\n\
    \   the features of READ but includes an extension to support sparse\n   files.\
    \  READ_PLUS is guaranteed to perform no worse than READ and can\n   dramatically\
    \ improve performance with sparse files.  READ_PLUS does\n   not depend on pNFS\
    \ protocol features but can be used by pNFS to\n   support sparse files.\n"
- title: 6.1.  Terminology
  contents:
  - "6.1.  Terminology\n   Regular file:  An object of file type NF4REG or NF4NAMEDATTR.\n\
    \   Sparse file:  A regular file that contains one or more holes.\n   Hole:  A\
    \ byte range within a sparse file that contains all zeros.  A\n      hole might\
    \ or might not have space allocated or reserved to it.\n"
- title: 6.2.  New Operations
  contents:
  - '6.2.  New Operations

    '
- title: 6.2.1.  READ_PLUS
  contents:
  - "6.2.1.  READ_PLUS\n   READ_PLUS is a new variant of the NFSv4.1 READ operation\
    \ [RFC5661].\n   Besides being able to support all of the data semantics of the\
    \ READ\n   operation, it can also be used by the client and server to\n   efficiently\
    \ transfer holes.  Because the client does not know in\n   advance whether a hole\
    \ is present or not, if the client supports\n   READ_PLUS and so does the server,\
    \ then it should always use the\n   READ_PLUS operation in preference to the READ\
    \ operation.\n   READ_PLUS extends the response with a new arm representing holes\
    \ to\n   avoid returning data for portions of the file that are initialized to\n\
    \   zero and may or may not contain a backing store.  Returning actual\n   data\
    \ blocks corresponding to holes wastes computational and network\n   resources,\
    \ thus reducing performance.\n   When a client sends a READ operation, it is not\
    \ prepared to accept a\n   READ_PLUS-style response providing a compact encoding\
    \ of the scope of\n   holes.  If a READ occurs on a sparse file, then the server\
    \ must\n   expand such data to be raw bytes.  If a READ occurs in the middle of\n\
    \   a hole, the server can only send back bytes starting from that\n   offset.\
    \  By contrast, if a READ_PLUS occurs in the middle of a hole,\n   the server\
    \ can send back a range that starts before the offset and\n   extends past the\
    \ requested length.\n"
- title: 6.2.2.  DEALLOCATE
  contents:
  - "6.2.2.  DEALLOCATE\n   The client can use the DEALLOCATE operation on a range\
    \ of a file as a\n   hole punch, which allows the client to avoid the transfer\
    \ of a\n   repetitive pattern of zeros across the network.  This hole punch is\
    \ a\n   result of the unreserved space returning all zeros until overwritten.\n"
- title: 7.  Space Reservation
  contents:
  - "7.  Space Reservation\n   Applications want to be able to reserve space for a\
    \ file, report the\n   amount of actual disk space a file occupies, and free up\
    \ the backing\n   space of a file when it is not required.\n   One example is\
    \ the posix_fallocate() operation [posix_fallocate],\n   which allows applications\
    \ to ask for space reservations from the\n   operating system, usually to provide\
    \ a better file layout and reduce\n   overhead for random or slow-growing file-appending\
    \ workloads.\n   Another example is space reservation for virtual disks in a\n\
    \   hypervisor.  In virtualized environments, virtual disk files are\n   often\
    \ stored on NFS-mounted volumes.  When a hypervisor creates a\n   virtual disk\
    \ file, it often tries to preallocate the space for the\n   file so that there\
    \ are no future allocation-related errors during the\n   operation of the VM.\
    \  Such errors prevent a VM from continuing\n   execution and result in downtime.\n\
    \   Currently, in order to achieve such a guarantee, applications zero\n   the\
    \ entire file.  The initial zeroing allocates the backing blocks,\n   and all\
    \ subsequent writes are overwrites of already-allocated blocks.\n   This approach\
    \ is not only inefficient in terms of the amount of I/O\n   done; it is also not\
    \ guaranteed to work on file systems that are\n   log-structured or deduplicated.\
    \  An efficient way of guaranteeing\n   space reservation would be beneficial\
    \ to such applications.\n   The new ALLOCATE operation (see Section 15.1) allows\
    \ a client to\n   request a guarantee that space will be available.  The ALLOCATE\n\
    \   operation guarantees that any future writes to the region it was\n   successfully\
    \ called for will not fail with NFS4ERR_NOSPC.\n   Another useful feature is the\
    \ ability to report the number of blocks\n   that would be freed when a file is\
    \ deleted.  Currently, NFS reports\n   two size attributes:\n   size  The logical\
    \ file size of the file.\n   space_used  The size in bytes that the file occupies\
    \ on disk.\n   While these attributes are sufficient for space accounting in\n\
    \   traditional file systems, they prove to be inadequate in modern file\n   systems\
    \ that support block-sharing.  In such file systems, multiple\n   inodes (the\
    \ metadata portion of the file system object) can point to\n   a single block\
    \ with a block reference count to guard against\n   premature freeing.  Having\
    \ a way to tell the number of blocks that\n   would be freed if the file was deleted\
    \ would be useful to\n   applications that wish to migrate files when a volume\
    \ is low on\n   space.\n   Since virtual disks represent a hard drive in a VM,\
    \ a virtual disk\n   can be viewed as a file system within a file.  Since not\
    \ all blocks\n   within a file system are in use, there is an opportunity to reclaim\n\
    \   blocks that are no longer in use.  A call to deallocate blocks could\n   result\
    \ in better space efficiency; less space might be consumed for\n   backups after\
    \ block deallocation.\n   The following attribute and operation can be used to\
    \ resolve these\n   issues:\n   space_freed  This attribute reports the space\
    \ that would be freed\n      when a file is deleted, taking block-sharing into\
    \ consideration.\n   DEALLOCATE  This operation deallocates the blocks backing\
    \ a region of\n      the file.\n   If space_used of a file is interpreted to mean\
    \ the size in bytes of\n   all disk blocks pointed to by the inode of the file,\
    \ then shared\n   blocks get double-counted, over-reporting the space utilization.\n\
    \   This also has the adverse effect that the deletion of a file with\n   shared\
    \ blocks frees up less than space_used bytes.\n   On the other hand, if space_used\
    \ is interpreted to mean the size in\n   bytes of those disk blocks unique to\
    \ the inode of the file, then\n   shared blocks are not counted in any file, resulting\
    \ in\n   under-reporting of the space utilization.\n   For example, two files,\
    \ A and B, have 10 blocks each.  Let six of\n   these blocks be shared between\
    \ them.  Thus, the combined space\n   utilized by the two files is 14 * BLOCK_SIZE\
    \ bytes.  In the former\n   case, the combined space utilization of the two files\
    \ would be\n   reported as 20 * BLOCK_SIZE.  However, deleting either would only\n\
    \   result in 4 * BLOCK_SIZE being freed.  Conversely, the latter\n   interpretation\
    \ would report that the space utilization is only\n   8 * BLOCK_SIZE.\n   Using\
    \ the space_freed attribute (see Section 12.2.2) is helpful in\n   solving this\
    \ problem.  space_freed is the number of blocks that are\n   allocated to the\
    \ given file that would be freed on its deletion.  In\n   the example, both A\
    \ and B would report space_freed as 4 * BLOCK_SIZE\n   and space_used as 10 *\
    \ BLOCK_SIZE.  If A is deleted, B will report\n   space_freed as 10 * BLOCK_SIZE,\
    \ as the deletion of B would result in\n   the deallocation of all 10 blocks.\n\
    \   Using the space_freed attribute does not solve the problem of space\n   being\
    \ over-reported.  However, over-reporting is better than\n   under-reporting.\n"
- title: 8.  Application Data Block Support
  contents:
  - "8.  Application Data Block Support\n   At the OS level, files are contained on\
    \ disk blocks.  Applications\n   are also free to impose structure on the data\
    \ contained in a file and\n   thus can define an Application Data Block (ADB)\
    \ to be such a\n   structure.  From the application's viewpoint, it only wants\
    \ to handle\n   ADBs and not raw bytes (see [Strohm11]).  An ADB is typically\n\
    \   comprised of two sections: header and data.  The header describes the\n  \
    \ characteristics of the block and can provide a means to detect\n   corruption\
    \ in the data payload.  The data section is typically\n   initialized to all zeros.\n\
    \   The format of the header is application specific, but there are two\n   main\
    \ components typically encountered:\n   1.  An Application Data Block Number (ADBN),\
    \ which allows the\n       application to determine which data block is being\
    \ referenced.\n       This is useful when the client is not storing the blocks\
    \ in\n       contiguous memory, i.e., a logical block number.\n   2.  Fields to\
    \ describe the state of the ADB and a means to detect\n       block corruption.\
    \  For both pieces of data, a useful property\n       would be that the allowed\
    \ values are specially selected so that,\n       if passed across the network,\
    \ corruption due to translation\n       between big-endian and little-endian architectures\
    \ is detectable.\n       For example, 0xf0dedef0 has the same (32 wide) bit pattern\
    \ in\n       both architectures, making it inappropriate.\n   Applications already\
    \ impose structures on files [Strohm11] and detect\n   corruption in data blocks\
    \ [Ashdown08].  What they are not able to do\n   is efficiently transfer and store\
    \ ADBs.  To initialize a file with\n   ADBs, the client must send each full ADB\
    \ to the server, and that must\n   be stored on the server.\n   This section defines\
    \ a framework for transferring the ADB from client\n   to server and presents\
    \ one approach to detecting corruption in a\n   given ADB implementation.\n"
- title: 8.1.  Generic Framework
  contents:
  - "8.1.  Generic Framework\n   The representation of the ADB needs to be flexible\
    \ enough to support\n   many different applications.  The most basic approach\
    \ is no\n   imposition of a block at all, which entails working with the raw\n\
    \   bytes.  Such an approach would be useful for storing holes, punching\n   holes,\
    \ etc.  In more complex deployments, a server might be\n   supporting multiple\
    \ applications, each with their own definition of\n   the ADB.  One might store\
    \ the ADBN at the start of the block and then\n   have a guard pattern to detect\
    \ corruption [McDougall07].  The next\n   might store the ADBN at an offset of\
    \ 100 bytes within the block and\n   have no guard pattern at all, i.e., existing\
    \ applications might\n   already have well-defined formats for their data blocks.\n\
    \   The guard pattern can be used to represent the state of the block, to\n  \
    \ protect against corruption, or both.  Again, it needs to be able to\n   be placed\
    \ anywhere within the ADB.\n   Both the starting offset of the block and the size\
    \ of the block need\n   to be represented.  Note that nothing prevents the application\
    \ from\n   defining different-sized blocks in a file.\n"
- title: 8.1.1.  Data Block Representation
  contents:
  - "8.1.1.  Data Block Representation\n   <CODE BEGINS>\n   struct app_data_block4\
    \ {\n           offset4         adb_offset;\n           length4         adb_block_size;\n\
    \           length4         adb_block_count;\n           length4         adb_reloff_blocknum;\n\
    \           count4          adb_block_num;\n           length4         adb_reloff_pattern;\n\
    \           opaque          adb_pattern<>;\n   };\n   <CODE ENDS>\n   The app_data_block4\
    \ structure captures the abstraction presented for\n   the ADB.  The additional\
    \ fields present are to allow the transmission\n   of adb_block_count ADBs at\
    \ one time.  The adb_block_num is used to\n   convey the ADBN of the first block\
    \ in the sequence.  Each ADB will\n   contain the same adb_pattern string.\n \
    \  As both adb_block_num and adb_pattern are optional, if either\n   adb_reloff_pattern\
    \ or adb_reloff_blocknum is set to NFS4_UINT64_MAX,\n   then the corresponding\
    \ field is not set in any of the ADBs.\n"
- title: 8.2.  An Example of Detecting Corruption
  contents:
  - "8.2.  An Example of Detecting Corruption\n   In this section, an example ADB\
    \ format is defined in which corruption\n   can be detected.  Note that this is\
    \ just one possible format and\n   means to detect corruption.\n   Consider a\
    \ very basic implementation of an operating system's disk\n   blocks.  A block\
    \ is either data or an indirect block that allows for\n   files that are larger\
    \ than one block.  It is desired to be able to\n   initialize a block.  Lastly,\
    \ to quickly unlink a file, a block can be\n   marked invalid.  The contents remain\
    \ intact; this would enable the OS\n   application in question to undelete a file.\n\
    \   The application defines 4K-sized data blocks, with an 8-byte block\n   counter\
    \ occurring at offset 0 in the block, and with the guard\n   pattern occurring\
    \ at offset 8 inside the block.  Furthermore, the\n   guard pattern can take one\
    \ of four states:\n   0xfeedface -  This is the FREE state and indicates that\
    \ the ADB\n      format has been applied.\n   0xcafedead -  This is the DATA state\
    \ and indicates that real data has\n      been written to this block.\n   0xe4e5c001\
    \ -  This is the INDIRECT state and indicates that the block\n      contains block\
    \ counter numbers that are chained off of this block.\n   0xba1ed4a3 -  This is\
    \ the INVALID state and indicates that the block\n      contains data whose contents\
    \ are garbage.\n   Finally, it also defines an 8-byte checksum starting at byte\
    \ 16 that\n   applies to the remaining contents of the block (see [Baira08] for\
    \ an\n   example of using checksums to detect data corruption).  If the state\n\
    \   is FREE, then that checksum is trivially zero.  As such, the\n   application\
    \ has no need to transfer the checksum implicitly inside\n   the ADB -- it need\
    \ not make the transfer layer aware of the fact that\n   there is a checksum (see\
    \ [Ashdown08] for an example of checksums used\n   to detect corruption in application\
    \ data blocks).\n   Corruption in each ADB can thus be detected:\n   o  If the\
    \ guard pattern is anything other than one of the allowed\n      values, including\
    \ all zeros.\n   o  If the guard pattern is FREE and any other byte in the remainder\n\
    \      of the ADB is anything other than zero.\n   o  If the guard pattern is\
    \ anything other than FREE, then if the\n      stored checksum does not match\
    \ the computed checksum.\n   o  If the guard pattern is INDIRECT and one of the\
    \ stored indirect\n      block numbers has a value greater than the number of\
    \ ADBs in\n      the file.\n   o  If the guard pattern is INDIRECT and one of\
    \ the stored indirect\n      block numbers is a duplicate of another stored indirect\
    \ block\n      number.\n   As can be seen, the application can detect errors based\
    \ on the\n   combination of the guard pattern state and the checksum but also\
    \ can\n   detect corruption based on the state and the contents of the ADB.\n\
    \   This last point is important in validating the minimum amount of data\n  \
    \ incorporated into the generic framework.  That is, the guard pattern\n   is\
    \ sufficient in allowing applications to design their own corruption\n   detection.\n\
    \   Finally, it is important to note that none of these corruption checks\n  \
    \ occur in the transport layer.  The server and client components are\n   totally\
    \ unaware of the file format and might report everything as\n   being transferred\
    \ correctly, even in cases where the application\n   detects corruption.\n"
- title: 8.3.  An Example of READ_PLUS
  contents:
  - "8.3.  An Example of READ_PLUS\n   The hypothetical application presented in Section\
    \ 8.2 can be used to\n   illustrate how READ_PLUS would return an array of results.\
    \  A file is\n   created and initialized with 100 4K ADBs in the FREE state with\
    \ the\n   WRITE_SAME operation (see Section 15.12):\n      WRITE_SAME {0, 4K,\
    \ 100, 0, 0, 8, 0xfeedface}\n   Further, assume that the application writes a\
    \ single ADB at 16K,\n   changing the guard pattern to 0xcafedead; then there\
    \ would be in\n   memory:\n       0K ->   (4K - 1) : 00 00 00 00 ... fe ed fa\
    \ ce 00 00 ... 00\n       4K ->   (8K - 1) : 00 00 00 01 ... fe ed fa ce 00 00\
    \ ... 00\n       8K ->  (12K - 1) : 00 00 00 02 ... fe ed fa ce 00 00 ... 00\n\
    \      12K ->  (16K - 1) : 00 00 00 03 ... fe ed fa ce 00 00 ... 00\n      16K\
    \ ->  (20K - 1) : 00 00 00 04 ... ca fe de ad 00 00 ... 00\n      20K ->  (24K\
    \ - 1) : 00 00 00 05 ... fe ed fa ce 00 00 ... 00\n      24K ->  (28K - 1) : 00\
    \ 00 00 06 ... fe ed fa ce 00 00 ... 00\n         ...\n     396K -> (400K - 1)\
    \ : 00 00 00 63 ... fe ed fa ce 00 00 ... 00\n   And when the client did a READ_PLUS\
    \ of 64K at the start of the file,\n   it could get back a result of data:\n \
    \      0K ->   (4K - 1) : 00 00 00 00 ... fe ed fa ce 00 00 ... 00\n       4K\
    \ ->   (8K - 1) : 00 00 00 01 ... fe ed fa ce 00 00 ... 00\n       8K ->  (12K\
    \ - 1) : 00 00 00 02 ... fe ed fa ce 00 00 ... 00\n      12K ->  (16K - 1) : 00\
    \ 00 00 03 ... fe ed fa ce 00 00 ... 00\n      16K ->  (20K - 1) : 00 00 00 04\
    \ ... ca fe de ad 00 00 ... 00\n      20K ->  (24K - 1) : 00 00 00 05 ... fe ed\
    \ fa ce 00 00 ... 00\n      24K ->  (28K - 1) : 00 00 00 06 ... fe ed fa ce 00\
    \ 00 ... 00\n         ...\n      62K ->  (64K - 1) : 00 00 00 15 ... fe ed fa\
    \ ce 00 00 ... 00\n"
- title: 8.4.  An Example of Zeroing Space
  contents:
  - "8.4.  An Example of Zeroing Space\n   A simpler use case for WRITE_SAME is applications\
    \ that want to\n   efficiently zero out a file, but do not want to modify space\n\
    \   reservations.  This can easily be achieved by a call to WRITE_SAME\n   without\
    \ an ADB block numbers and pattern, e.g.:\n      WRITE_SAME {0, 1K, 10000, 0,\
    \ 0, 0, 0}\n"
- title: 9.  Labeled NFS
  contents:
  - "9.  Labeled NFS\n   Access control models such as UNIX permissions or Access\
    \ Control\n   Lists (ACLs) are commonly referred to as Discretionary Access Control\n\
    \   (DAC) models.  These systems base their access decisions on user\n   identity\
    \ and resource ownership.  In contrast, Mandatory Access\n   Control (MAC) models\
    \ base their access control decisions on the label\n   on the subject (usually\
    \ a process) and the object it wishes to access\n   [RFC4949].  These labels may\
    \ contain user identity information but\n   usually contain additional information.\
    \  In DAC systems, users are\n   free to specify the access rules for resources\
    \ that they own.  MAC\n   models base their security decisions on a system-wide\
    \ policy --\n   established by an administrator or organization -- that the users\
    \ do\n   not have the ability to override.  In this section, a MAC model is\n\
    \   added to NFSv4.2.\n   First, a method is provided for transporting and storing\
    \ security\n   label data on NFSv4 file objects.  Security labels have several\n\
    \   semantics that are met by NFSv4 recommended attributes such as the\n   ability\
    \ to set the label value upon object creation.  Access control\n   on these attributes\
    \ is done through a combination of two mechanisms.\n   As with other recommended\
    \ attributes on file objects, the usual DAC\n   checks, based on the ACLs and\
    \ permission bits, will be performed to\n   ensure that proper file ownership\
    \ is enforced.  In addition, a MAC\n   system MAY be employed on the client, server,\
    \ or both to enforce\n   additional policy on what subjects may modify security\
    \ label\n   information.\n   Second, a method is described for the client to determine\
    \ if an NFSv4\n   file object security label has changed.  A client that needs\
    \ to know\n   if a label on a file or set of files is going to change SHOULD\n\
    \   request a delegation on each labeled file.  In order to change such a\n  \
    \ security label, the server will have to recall delegations on any\n   file affected\
    \ by the label change, so informing clients of the label\n   change.\n   An additional\
    \ useful feature would be modification to the RPC layer\n   used by NFSv4 to allow\
    \ RPCs to assert client process subject security\n   labels and enable the enforcement\
    \ of Full Mode as described in\n   Section 9.5.1.  Such modifications are outside\
    \ the scope of this\n   document (see [RFC7861]).\n"
- title: 9.1.  Definitions
  contents:
  - "9.1.  Definitions\n   Label Format Specifier (LFS):  an identifier used by the\
    \ client to\n      establish the syntactic format of the security label and the\n\
    \      semantic meaning of its components.  LFSs exist in a registry\n      associated\
    \ with documents describing the format and semantics of\n      the label.\n  \
    \ Security Label Format Selection Registry:  the IANA registry (see\n      [RFC7569])\
    \ containing all registered LFSs, along with references\n      to the documents\
    \ that describe the syntactic format and semantics\n      of the security label.\n\
    \   Policy Identifier (PI):  an optional part of the definition of an\n      LFS.\
    \  The PI allows clients and servers to identify specific\n      security policies.\n\
    \   Object:  a passive resource within the system that is to be\n      protected.\
    \  Objects can be entities such as files, directories,\n      pipes, sockets,\
    \ and many other system resources relevant to the\n      protection of the system\
    \ state.\n   Subject:  an active entity, usually a process that is requesting\n\
    \      access to an object.\n   MAC-Aware:  a server that can transmit and store\
    \ object labels.\n   MAC-Functional:  a client or server that is Labeled NFS enabled.\n\
    \      Such a system can interpret labels and apply policies based on the\n  \
    \    security system.\n   Multi-Level Security (MLS):  a traditional model where\
    \ objects are\n      given a sensitivity level (Unclassified, Secret, Top Secret,\
    \ etc.)\n      and a category set (see [LB96], [RFC1108], [RFC2401], and\n   \
    \   [RFC4949]).\n      (Note: RFC 2401 has been obsoleted by RFC 4301, but we\
    \ list\n      RFC 2401 here because RFC 4301 does not discuss MLS.)\n"
- title: 9.2.  MAC Security Attribute
  contents:
  - "9.2.  MAC Security Attribute\n   MAC models base access decisions on security\
    \ attributes bound to\n   subjects (usually processes) and objects (for NFS, file\
    \ objects).\n   This information can range from a user identity for an identity-based\n\
    \   MAC model, sensitivity levels for MLS, or a type for type\n   enforcement.\
    \  These models base their decisions on different\n   criteria, but the semantics\
    \ of the security attribute remain the\n   same.  The semantics required by the\
    \ security attribute are listed\n   below:\n   o  MUST provide flexibility with\
    \ respect to the MAC model.\n   o  MUST provide the ability to atomically set\
    \ security information\n      upon object creation.\n   o  MUST provide the ability\
    \ to enforce access control decisions on\n      both the client and the server.\n\
    \   o  MUST NOT expose an object to either the client or server namespace\n  \
    \    before its security information has been bound to it.\n   NFSv4 implements\
    \ the MAC security attribute as a recommended\n   attribute.  This attribute has\
    \ a fixed format and semantics, which\n   conflicts with the flexible nature of\
    \ security attributes in general.\n   To resolve this, the MAC security attribute\
    \ consists of two\n   components.  The first component is an LFS, as defined in\
    \ [RFC7569],\n   to allow for interoperability between MAC mechanisms.  The second\n\
    \   component is an opaque field, which is the actual security attribute\n   data.\
    \  To allow for various MAC models, NFSv4 should be used solely\n   as a transport\
    \ mechanism for the security attribute.  It is the\n   responsibility of the endpoints\
    \ to consume the security attribute and\n   make access decisions based on their\
    \ respective models.  In addition,\n   creation of objects through OPEN and CREATE\
    \ allows the security\n   attribute to be specified upon creation.  By providing\
    \ an atomic\n   create and set operation for the security attribute, it is possible\n\
    \   to enforce the second and fourth requirements listed above.  The\n   recommended\
    \ attribute FATTR4_SEC_LABEL (see Section 12.2.4) will be\n   used to satisfy\
    \ this requirement.\n"
- title: 9.2.1.  Delegations
  contents:
  - "9.2.1.  Delegations\n   In the event that a security attribute is changed on\
    \ the server while\n   a client holds a delegation on the file, both the server\
    \ and the\n   client MUST follow the NFSv4.1 protocol (see Section 10 of [RFC5661])\n\
    \   with respect to attribute changes.  It SHOULD flush all changes back\n   to\
    \ the server and relinquish the delegation.\n"
- title: 9.2.2.  Permission Checking
  contents:
  - "9.2.2.  Permission Checking\n   It is not feasible to enumerate all possible\
    \ MAC models and even\n   levels of protection within a subset of these models.\
    \  This means\n   that the NFSv4 client and servers cannot be expected to directly\
    \ make\n   access control decisions based on the security attribute.  Instead,\n\
    \   NFSv4 should defer permission checking on this attribute to the host\n   system.\
    \  These checks are performed in addition to existing DAC and\n   ACL checks outlined\
    \ in the NFSv4 protocol.  Section 9.5 gives a\n   specific example of how the\
    \ security attribute is handled under a\n   particular MAC model.\n"
- title: 9.2.3.  Object Creation
  contents:
  - "9.2.3.  Object Creation\n   When creating files in NFSv4, the OPEN and CREATE\
    \ operations are\n   used.  One of the parameters for these operations is an fattr4\n\
    \   structure containing the attributes the file is to be created with.\n   This\
    \ allows NFSv4 to atomically set the security attribute of files\n   upon creation.\
    \  When a client is MAC-Functional, it must always\n   provide the initial security\
    \ attribute upon file creation.  In the\n   event that the server is MAC-Functional\
    \ as well, it should determine\n   by policy whether it will accept the attribute\
    \ from the client or\n   instead make the determination itself.  If the client\
    \ is not\n   MAC-Functional, then the MAC-Functional server must decide on a\n\
    \   default label.  A more in-depth explanation can be found in\n   Section 9.5.\n"
- title: 9.2.4.  Existing Objects
  contents:
  - "9.2.4.  Existing Objects\n   Note that under the MAC model, all objects must\
    \ have labels.\n   Therefore, if an existing server is upgraded to include Labeled\
    \ NFS\n   support, then it is the responsibility of the security system to\n \
    \  define the behavior for existing objects.\n"
- title: 9.2.5.  Label Changes
  contents:
  - "9.2.5.  Label Changes\n   Consider a Guest Mode system (Section 9.5.3) in which\
    \ the clients\n   enforce MAC checks and the server has only a DAC security system\
    \ that\n   stores the labels along with the file data.  In this type of system,\n\
    \   a user with the appropriate DAC credentials on a client with poorly\n   configured\
    \ or disabled MAC labeling enforcement is allowed access to\n   the file label\
    \ (and data) on the server and can change the label.\n   Clients that need to\
    \ know if a label on a file or set of files has\n   changed SHOULD request a delegation\
    \ on each labeled file so that a\n   label change by another client will be known\
    \ via the process\n   described in Section 9.2.1, which must be followed: the\
    \ delegation\n   will be recalled, which effectively notifies the client of the\n\
    \   change.\n   Note that the MAC security policies on a client can be such that\
    \ the\n   client does not have access to the file unless it has a delegation.\n"
- title: 9.3.  pNFS Considerations
  contents:
  - "9.3.  pNFS Considerations\n   The new FATTR4_SEC_LABEL attribute is metadata\
    \ information, and as\n   such the storage device is not aware of the value contained\
    \ on the\n   metadata server.  Fortunately, the NFSv4.1 protocol [RFC5661] already\n\
    \   has provisions for doing access-level checks from the storage device\n   to\
    \ the metadata server.  In order for the storage device to validate\n   the subject\
    \ label presented by the client, it SHOULD utilize this\n   mechanism.\n"
- title: 9.4.  Discovery of Server Labeled NFS Support
  contents:
  - "9.4.  Discovery of Server Labeled NFS Support\n   The server can easily determine\
    \ that a client supports Labeled NFS\n   when it queries for the FATTR4_SEC_LABEL\
    \ label for an object.\n   Further, it can then determine which LFS the client\
    \ understands.  The\n   client might want to discover whether the server supports\
    \ Labeled NFS\n   and which LFS the server supports.\n   The following COMPOUND\
    \ MUST NOT be denied by any MAC label check:\n        PUTROOTFH, GETATTR {FATTR4_SEC_LABEL}\n\
    \   Note that the server might have imposed a security flavor on the root\n  \
    \ that precludes such access.  That is, if the server requires\n   Kerberized\
    \ access and the client presents a COMPOUND with AUTH_SYS,\n   then the server\
    \ is allowed to return NFS4ERR_WRONGSEC in this case.\n   But if the client presents\
    \ a correct security flavor, then the server\n   MUST return the FATTR4_SEC_LABEL\
    \ attribute with the supported LFS\n   filled in.\n"
- title: 9.5.  MAC Security NFS Modes of Operation
  contents:
  - "9.5.  MAC Security NFS Modes of Operation\n   A system using Labeled NFS may\
    \ operate in three modes (see Section 4\n   of [RFC7204]).  The first mode provides\
    \ the most protection and is\n   called \"Full Mode\".  In this mode, both the\
    \ client and server\n   implement a MAC model allowing each end to make an access\
    \ control\n   decision.  The second mode is a subset of the Full Mode and is called\n\
    \   \"Limited Server Mode\".  In this mode, the server cannot enforce the\n  \
    \ labels, but it can store and transmit them.  The remaining mode is\n   called\
    \ the \"Guest Mode\"; in this mode, one end of the connection is\n   not implementing\
    \ a MAC model and thus offers less protection than\n   Full Mode.\n"
- title: 9.5.1.  Full Mode
  contents:
  - "9.5.1.  Full Mode\n   Full Mode environments consist of MAC-Functional NFSv4\
    \ servers and\n   clients and may be composed of mixed MAC models and policies.\
    \  The\n   system requires that both the client and server have an opportunity\n\
    \   to perform an access control check based on all relevant information\n   within\
    \ the network.  The file object security attribute is provided\n   using the mechanism\
    \ described in Section 9.2.\n   Fully MAC-Functional NFSv4 servers are not possible\
    \ in the absence of\n   RPCSEC_GSSv3 [RFC7861] support for client process subject\
    \ label\n   assertion.  However, servers may make decisions based on the RPC\n\
    \   credential information available.\n"
- title: 9.5.1.1.  Initial Labeling and Translation
  contents:
  - "9.5.1.1.  Initial Labeling and Translation\n   The ability to create a file is\
    \ an action that a MAC model may wish\n   to mediate.  The client is given the\
    \ responsibility to determine the\n   initial security attribute to be placed\
    \ on a file.  This allows the\n   client to make a decision as to the acceptable\
    \ security attribute to\n   create a file with before sending the request to the\
    \ server.  Once\n   the server receives the creation request from the client,\
    \ it may\n   choose to evaluate if the security attribute is acceptable.\n   Security\
    \ attributes on the client and server may vary based on MAC\n   model and policy.\
    \  To handle this, the security attribute field has\n   an LFS component.  This\
    \ component is a mechanism for the host to\n   identify the format and meaning\
    \ of the opaque portion of the security\n   attribute.  A Full Mode environment\
    \ may contain hosts operating in\n   several different LFSs.  In this case, a\
    \ mechanism for translating\n   the opaque portion of the security attribute is\
    \ needed.  The actual\n   translation function will vary based on MAC model and\
    \ policy and is\n   outside the scope of this document.  If a translation is unavailable\n\
    \   for a given LFS, then the request MUST be denied.  Another recourse\n   is\
    \ to allow the host to provide a fallback mapping for unknown\n   security attributes.\n"
- title: 9.5.1.2.  Policy Enforcement
  contents:
  - "9.5.1.2.  Policy Enforcement\n   In Full Mode, access control decisions are made\
    \ by both the clients\n   and servers.  When a client makes a request, it takes\
    \ the security\n   attribute from the requesting process and makes an access control\n\
    \   decision based on that attribute and the security attribute of the\n   object\
    \ it is trying to access.  If the client denies that access, an\n   RPC to the\
    \ server is never made.  If, however, the access is allowed,\n   the client will\
    \ make a call to the NFS server.\n   When the server receives the request from\
    \ the client, it uses any\n   credential information conveyed in the RPC request\
    \ and the attributes\n   of the object the client is trying to access to make\
    \ an access\n   control decision.  If the server's policy allows this access,\
    \ it will\n   fulfill the client's request; otherwise, it will return\n   NFS4ERR_ACCESS.\n\
    \   Future protocol extensions may also allow the server to factor into\n   the\
    \ decision a security label extracted from the RPC request.\n   Implementations\
    \ MAY validate security attributes supplied over the\n   network to ensure that\
    \ they are within a set of attributes permitted\n   from a specific peer and,\
    \ if not, reject them.  Note that a system\n   may permit a different set of attributes\
    \ to be accepted from\n   each peer.\n"
- title: 9.5.2.  Limited Server Mode
  contents:
  - "9.5.2.  Limited Server Mode\n   A Limited Server mode (see Section 4.2 of [RFC7204])\
    \ consists of a\n   server that is label aware but does not enforce policies.\
    \  Such a\n   server will store and retrieve all object labels presented by clients\n\
    \   and will utilize the methods described in Section 9.2.5 to allow the\n   clients\
    \ to detect changing labels, but may not factor the label into\n   access decisions.\
    \  Instead, it will expect the clients to enforce all\n   such access locally.\n"
- title: 9.5.3.  Guest Mode
  contents:
  - "9.5.3.  Guest Mode\n   Guest Mode implies that either the client or the server\
    \ does not\n   handle labels.  If the client is not Labeled NFS aware, then it\
    \ will\n   not offer subject labels to the server.  The server is the only\n \
    \  entity enforcing policy and may selectively provide standard NFS\n   services\
    \ to clients based on their authentication credentials and/or\n   associated network\
    \ attributes (e.g., IP address, network interface).\n   The level of trust and\
    \ access extended to a client in this mode is\n   configuration specific.  If\
    \ the server is not Labeled NFS aware, then\n   it will not return object labels\
    \ to the client.  Clients in this\n   environment may consist of groups implementing\
    \ different MAC model\n   policies.  The system requires that all clients in the\
    \ environment be\n   responsible for access control checks.\n"
- title: 9.6.  Security Considerations for Labeled NFS
  contents:
  - "9.6.  Security Considerations for Labeled NFS\n   Depending on the level of protection\
    \ the MAC system offers, there may\n   be a requirement to tightly bind the security\
    \ attribute to the data.\n   When only one of the client or server enforces labels,\
    \ it is\n   important to realize that the other side is not enforcing MAC\n  \
    \ protections.  Alternate methods might be in use to handle the lack of\n   MAC\
    \ support, and care should be taken to identify and mitigate\n   threats from\
    \ possible tampering outside of these methods.\n   An example of this is that\
    \ a server that modifies READDIR or LOOKUP\n   results based on the client's subject\
    \ label might want to always\n   construct the same subject label for a client\
    \ that does not present\n   one.  This will prevent a non-Labeled NFS client from\
    \ mixing entries\n   in the directory cache.\n"
- title: 10.  Sharing Change Attribute Implementation Characteristics with NFSv4
  contents:
  - "10.  Sharing Change Attribute Implementation Characteristics with NFSv4\n   \
    \  Clients\n   Although both the NFSv4 [RFC7530] and NFSv4.1 [RFC5661] protocols\n\
    \   define the change attribute as being mandatory to implement, there is\n  \
    \ little in the way of guidance as to its construction.  The only\n   mandated\
    \ constraint is that the value must change whenever the file\n   data or metadata\
    \ changes.\n   While this allows for a wide range of implementations, it also\
    \ leaves\n   the client with no way to determine which is the most recent value\n\
    \   for the change attribute in a case where several RPCs have been\n   issued\
    \ in parallel.  In other words, if two COMPOUNDs, both\n   containing WRITE and\
    \ GETATTR requests for the same file, have been\n   issued in parallel, how does\
    \ the client determine which of the two\n   change attribute values returned in\
    \ the replies to the GETATTR\n   requests corresponds to the most recent state\
    \ of the file?  In some\n   cases, the only recourse may be to send another COMPOUND\
    \ containing a\n   third GETATTR that is fully serialized with the first two.\n\
    \   NFSv4.2 avoids this kind of inefficiency by allowing the server to\n   share\
    \ details about how the change attribute is expected to evolve,\n   so that the\
    \ client may immediately determine which, out of the\n   several change attribute\
    \ values returned by the server, is the most\n   recent.  change_attr_type is\
    \ defined as a new recommended attribute\n   (see Section 12.2.3) and is a per-file\
    \ system attribute.\n"
- title: 11.  Error Values
  contents:
  - "11.  Error Values\n   NFS error numbers are assigned to failed operations within\
    \ a COMPOUND\n   (COMPOUND or CB_COMPOUND) request.  A COMPOUND request contains\
    \ a\n   number of NFS operations that have their results encoded in sequence\n\
    \   in a COMPOUND reply.  The results of successful operations will\n   consist\
    \ of an NFS4_OK status followed by the encoded results of the\n   operation. \
    \ If an NFS operation fails, an error status will be\n   entered in the reply\
    \ and the COMPOUND request will be terminated.\n"
- title: 11.1.  Error Definitions
  contents:
  - "11.1.  Error Definitions\n          +-------------------------+--------+------------------+\n\
    \          | Error                   | Number | Description      |\n         \
    \ +-------------------------+--------+------------------+\n          | NFS4ERR_BADLABEL\
    \        | 10093  | Section 11.1.3.1 |\n          | NFS4ERR_OFFLOAD_DENIED  |\
    \ 10091  | Section 11.1.2.1 |\n          | NFS4ERR_OFFLOAD_NO_REQS | 10094  |\
    \ Section 11.1.2.2 |\n          | NFS4ERR_PARTNER_NO_AUTH | 10089  | Section 11.1.2.3\
    \ |\n          | NFS4ERR_PARTNER_NOTSUPP | 10088  | Section 11.1.2.4 |\n     \
    \     | NFS4ERR_UNION_NOTSUPP   | 10090  | Section 11.1.1.1 |\n          | NFS4ERR_WRONG_LFS\
    \       | 10092  | Section 11.1.3.2 |\n          +-------------------------+--------+------------------+\n\
    \                    Table 1: Protocol Error Definitions\n"
- title: 11.1.1.  General Errors
  contents:
  - "11.1.1.  General Errors\n   This section deals with errors that are applicable\
    \ to a broad set of\n   different purposes.\n"
- title: 11.1.1.1.  NFS4ERR_UNION_NOTSUPP (Error Code 10090)
  contents:
  - "11.1.1.1.  NFS4ERR_UNION_NOTSUPP (Error Code 10090)\n   One of the arguments\
    \ to the operation is a discriminated union, and\n   while the server supports\
    \ the given operation, it does not support\n   the selected arm of the discriminated\
    \ union.\n"
- title: 11.1.2.  Server-to-Server Copy Errors
  contents:
  - "11.1.2.  Server-to-Server Copy Errors\n   These errors deal with the interaction\
    \ between server-to-server\n   copies.\n"
- title: 11.1.2.1.  NFS4ERR_OFFLOAD_DENIED (Error Code 10091)
  contents:
  - "11.1.2.1.  NFS4ERR_OFFLOAD_DENIED (Error Code 10091)\n   The COPY offload operation\
    \ is supported by both the source and the\n   destination, but the destination\
    \ is not allowing it for this file.\n   If the client sees this error, it should\
    \ fall back to the normal copy\n   semantics.\n"
- title: 11.1.2.2.  NFS4ERR_OFFLOAD_NO_REQS (Error Code 10094)
  contents:
  - "11.1.2.2.  NFS4ERR_OFFLOAD_NO_REQS (Error Code 10094)\n   The COPY offload operation\
    \ is supported by both the source and the\n   destination, but the destination\
    \ cannot meet the client requirements\n   for either consecutive byte copy or\
    \ synchronous copy.  If the client\n   sees this error, it should either relax\
    \ the requirements (if any) or\n   fall back to the normal copy semantics.\n"
- title: 11.1.2.3.  NFS4ERR_PARTNER_NO_AUTH (Error Code 10089)
  contents:
  - "11.1.2.3.  NFS4ERR_PARTNER_NO_AUTH (Error Code 10089)\n   The source server does\
    \ not authorize a server-to-server COPY offload\n   operation.  This may be due\
    \ to the client's failure to send the\n   COPY_NOTIFY operation to the source\
    \ server, the source server\n   receiving a server-to-server copy offload request\
    \ after the copy\n   lease time expired, or some other permission problem.\n \
    \  The destination server does not authorize a server-to-server COPY\n   offload\
    \ operation.  This may be due to an inter-server COPY request\n   where the destination\
    \ server requires RPCSEC_GSSv3 and it is not\n   used, or some other permissions\
    \ problem.\n"
- title: 11.1.2.4.  NFS4ERR_PARTNER_NOTSUPP (Error Code 10088)
  contents:
  - "11.1.2.4.  NFS4ERR_PARTNER_NOTSUPP (Error Code 10088)\n   The remote server does\
    \ not support the server-to-server COPY offload\n   protocol.\n"
- title: 11.1.3.  Labeled NFS Errors
  contents:
  - "11.1.3.  Labeled NFS Errors\n   These errors are used in Labeled NFS.\n"
- title: 11.1.3.1.  NFS4ERR_BADLABEL (Error Code 10093)
  contents:
  - "11.1.3.1.  NFS4ERR_BADLABEL (Error Code 10093)\n   The label specified is invalid\
    \ in some manner.\n"
- title: 11.1.3.2.  NFS4ERR_WRONG_LFS (Error Code 10092)
  contents:
  - "11.1.3.2.  NFS4ERR_WRONG_LFS (Error Code 10092)\n   The LFS specified in the\
    \ subject label is not compatible with the LFS\n   in the object label.\n"
- title: 11.2.  New Operations and Their Valid Errors
  contents:
  - "11.2.  New Operations and Their Valid Errors\n   This section contains a table\
    \ that gives the valid error returns for\n   each new NFSv4.2 protocol operation.\
    \  The error code NFS4_OK\n   (indicating no error) is not listed but should be\
    \ understood to be\n   returnable by all new operations.  The error values for\
    \ all other\n   operations are defined in Section 15.2 of [RFC5661].\n   +----------------+--------------------------------------------------+\n\
    \   | Operation      | Errors                                           |\n  \
    \ +----------------+--------------------------------------------------+\n   |\
    \ ALLOCATE       | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n   |  \
    \              | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |    \
    \            | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |      \
    \          | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |\n   |        \
    \        | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |\n   |          \
    \      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |\n   |            \
    \    | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,        |\n   |              \
    \  | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,             |\n   |                |\
    \ NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |\n   |                | NFS4ERR_OPENMODE,\
    \ NFS4ERR_OP_NOT_IN_SESSION,     |\n   |                | NFS4ERR_REP_TOO_BIG,\
    \                             |\n   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,\
    \                    |\n   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,\
    \ |\n   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |\n\
    \   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |\n  \
    \ |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |\n   +----------------+--------------------------------------------------+\n\
    \   | CLONE          | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n  \
    \ |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |\n   |    \
    \            | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |\n   |      \
    \          | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |\n   |        \
    \        | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,        |\n   |          \
    \      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,             |\n   |            \
    \    | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |\n   |              \
    \  | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |\n   |                |\
    \ NFS4ERR_REP_TOO_BIG,                             |\n   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,\
    \                    |\n   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,\
    \ |\n   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |\n\
    \   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |\n  \
    \ |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE,        |\n   |\
    \                | NFS4ERR_XDEV                                     |\n   +----------------+--------------------------------------------------+\n\
    \   | COPY           | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n  \
    \ |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |\n   |    \
    \            | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |\n   |      \
    \          | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |\n   |        \
    \        | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |\n   |          \
    \      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |            \
    \    | NFS4ERR_NOSPC, NFS4ERR_OFFLOAD_DENIED,           |\n   |              \
    \  | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |\n   |                |\
    \ NFS4ERR_OP_NOT_IN_SESSION,                       |\n   |                | NFS4ERR_PARTNER_NO_AUTH,\
    \                         |\n   |                | NFS4ERR_PARTNER_NOTSUPP, NFS4ERR_PNFS_IO_HOLE,\
    \   |\n   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,    \
    \ |\n   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |\n\
    \   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |\n  \
    \ |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |\n   |\
    \                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |\n   |  \
    \              | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |\n   +----------------+--------------------------------------------------+\n\
    \   | COPY_NOTIFY    | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n  \
    \ |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |\n   |    \
    \            | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |\n   |      \
    \          | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |\n   |        \
    \        | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |          \
    \      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |\n   |            \
    \    | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE, |\n   |              \
    \  | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |\n   |                |\
    \ NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |\n   |                | NFS4ERR_REQ_TOO_BIG,\
    \ NFS4ERR_RETRY_UNCACHED_REP, |\n   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,\
    \              |\n   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,\
    \           |\n   |                | NFS4ERR_WRONG_TYPE                      \
    \         |\n   +----------------+--------------------------------------------------+\n\
    \   | DEALLOCATE     | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n  \
    \ |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |\n   |    \
    \            | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,  |\n   |      \
    \          | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,        |\n   |        \
    \        | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |          \
    \      | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |\n   |            \
    \    | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |\n   |              \
    \  | NFS4ERR_REP_TOO_BIG,                             |\n   |                |\
    \ NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |\n   |                | NFS4ERR_REQ_TOO_BIG,\
    \ NFS4ERR_RETRY_UNCACHED_REP, |\n   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,\
    \               |\n   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,     \
    \             |\n   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE\
    \         |\n   +----------------+--------------------------------------------------+\n\
    \   | GETDEVICELIST  | NFS4ERR_NOTSUPP                                  |\n  \
    \ +----------------+--------------------------------------------------+\n   |\
    \ IO_ADVISE      | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n   |  \
    \              | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |    \
    \            | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |      \
    \          | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |\n   |        \
    \        | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,  |\n   |          \
    \      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,        |\n   |            \
    \    | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |              \
    \  | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |\n   |                |\
    \ NFS4ERR_OP_NOT_IN_SESSION,                       |\n   |                | NFS4ERR_RETRY_UNCACHED_REP,\
    \ NFS4ERR_SERVERFAULT, |\n   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,\
    \                  |\n   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE\
    \         |\n   +----------------+--------------------------------------------------+\n\
    \   | LAYOUTERROR    | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |\n  \
    \ |                | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,        |\n   |\
    \                | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,            |\n   |  \
    \              | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,              |\n   |    \
    \            | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_ISDIR,     |\n   |      \
    \          | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |        \
    \        | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,               |\n   |          \
    \      | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |\n   |            \
    \    | NFS4ERR_REP_TOO_BIG,                             |\n   |              \
    \  | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |\n   |                |\
    \ NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |\n   |                | NFS4ERR_SERVERFAULT,\
    \ NFS4ERR_STALE,              |\n   |                | NFS4ERR_TOO_MANY_OPS, \
    \                           |\n   |                | NFS4ERR_UNKNOWN_LAYOUTTYPE,\
    \ NFS4ERR_WRONG_CRED,  |\n   |                | NFS4ERR_WRONG_TYPE           \
    \                    |\n   +----------------+--------------------------------------------------+\n\
    \   | LAYOUTSTATS    | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |\n  \
    \ |                | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,        |\n   |\
    \                | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,            |\n   |  \
    \              | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,              |\n   |    \
    \            | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_ISDIR,     |\n   |      \
    \          | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |        \
    \        | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,               |\n   |          \
    \      | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |\n   |            \
    \    | NFS4ERR_REP_TOO_BIG,                             |\n   |              \
    \  | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |\n   |                |\
    \ NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |\n   |                | NFS4ERR_SERVERFAULT,\
    \ NFS4ERR_STALE,              |\n   |                | NFS4ERR_TOO_MANY_OPS, \
    \                           |\n   |                | NFS4ERR_UNKNOWN_LAYOUTTYPE,\
    \ NFS4ERR_WRONG_CRED,  |\n   |                | NFS4ERR_WRONG_TYPE           \
    \                    |\n   +----------------+--------------------------------------------------+\n\
    \   | OFFLOAD_CANCEL | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |\n  \
    \ |                | NFS4ERR_BAD_STATEID, NFS4ERR_COMPLETE_ALREADY,   |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_EXPIRED, NFS4ERR_GRACE, NFS4ERR_NOTSUPP, |\n   |    \
    \            | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |\n   |      \
    \          | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS        |\n   +----------------+--------------------------------------------------+\n\
    \   | OFFLOAD_STATUS | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |\n  \
    \ |                | NFS4ERR_BAD_STATEID, NFS4ERR_COMPLETE_ALREADY,   |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_EXPIRED, NFS4ERR_GRACE, NFS4ERR_NOTSUPP, |\n   |    \
    \            | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |\n   |      \
    \          | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS        |\n   +----------------+--------------------------------------------------+\n\
    \   | READ_PLUS      | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n  \
    \ |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |\n   |    \
    \            | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |\n   |      \
    \          | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |\n   |        \
    \        | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |          \
    \      | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |\n   |            \
    \    | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |\n   |              \
    \  | NFS4ERR_PARTNER_NO_AUTH, NFS4ERR_PNFS_IO_HOLE,   |\n   |                |\
    \ NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |\n   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,\
    \                    |\n   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,\
    \ |\n   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |\n\
    \   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |\n  \
    \ |                | NFS4ERR_WRONG_TYPE                               |\n   +----------------+--------------------------------------------------+\n\
    \   | SEEK           | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n  \
    \ |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |\n   |    \
    \            | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |\n   |      \
    \          | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |\n   |        \
    \        | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |          \
    \      | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |\n   |            \
    \    | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |\n   |              \
    \  | NFS4ERR_PNFS_IO_HOLE, NFS4ERR_PNFS_NO_LAYOUT,    |\n   |                |\
    \ NFS4ERR_REP_TOO_BIG,                             |\n   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,\
    \                    |\n   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,\
    \ |\n   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |\n\
    \   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |\n  \
    \ |                | NFS4ERR_UNION_NOTSUPP, NFS4ERR_WRONG_TYPE        |\n   +----------------+--------------------------------------------------+\n\
    \   | WRITE_SAME     | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |\n  \
    \ |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |\n   |\
    \                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |\n   |  \
    \              | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |\n   |    \
    \            | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |\n   |      \
    \          | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |\n   |        \
    \        | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |\n   |          \
    \      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |\n   |            \
    \    | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,                  |\n   |              \
    \  | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |\n   |                |\
    \ NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE, |\n   |                | NFS4ERR_PNFS_NO_LAYOUT,\
    \ NFS4ERR_REP_TOO_BIG,     |\n   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,\
    \                    |\n   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,\
    \ |\n   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |\n\
    \   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |\n  \
    \ |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |\n   +----------------+--------------------------------------------------+\n\
    \       Table 2: Valid Error Returns for Each New Protocol Operation\n"
- title: 11.3.  New Callback Operations and Their Valid Errors
  contents:
  - "11.3.  New Callback Operations and Their Valid Errors\n   This section contains\
    \ a table that gives the valid error returns for\n   each new NFSv4.2 callback\
    \ operation.  The error code NFS4_OK\n   (indicating no error) is not listed but\
    \ should be understood to be\n   returnable by all new callback operations.  The\
    \ error values for all\n   other callback operations are defined in Section 15.3\
    \ of [RFC5661].\n   +------------+------------------------------------------------------+\n\
    \   | Callback   | Errors                                               |\n  \
    \ | Operation  |                                                      |\n   +------------+------------------------------------------------------+\n\
    \   | CB_OFFLOAD | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,                   |\n  \
    \ |            | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,                  |\n   |\
    \            | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_REP_TOO_BIG,      |\n   |  \
    \          | NFS4ERR_REP_TOO_BIG_TO_CACHE, NFS4ERR_REQ_TOO_BIG,   |\n   |    \
    \        | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_SERVERFAULT,     |\n   |      \
    \      | NFS4ERR_TOO_MANY_OPS                                 |\n   +------------+------------------------------------------------------+\n\
    \   Table 3: Valid Error Returns for Each New Protocol Callback Operation\n"
- title: 12.  New File Attributes
  contents:
  - '12.  New File Attributes

    '
- title: 12.1.  New RECOMMENDED Attributes - List and Definition References
  contents:
  - "12.1.  New RECOMMENDED Attributes - List and Definition References\n   The list\
    \ of new RECOMMENDED attributes appears in Table 4.  The\n   meanings of the columns\
    \ of the table are:\n   Name:  The name of the attribute.\n   Id:  The number\
    \ assigned to the attribute.  In the event of conflicts\n      between the assigned\
    \ number and [RFC7863], the latter is\n      authoritative, but in such an event,\
    \ it should be resolved with\n      errata to this document and/or [RFC7863].\
    \  See [IESG08] for the\n      errata process.\n   Data Type:  The XDR data type\
    \ of the attribute.\n   Acc:  Access allowed to the attribute.\n      R  means\
    \ read-only (GETATTR may retrieve, SETATTR may not set).\n      W  means write-only\
    \ (SETATTR may set, GETATTR may not retrieve).\n      R W   means read/write (GETATTR\
    \ may retrieve, SETATTR may set).\n   Defined in:  The section of this specification\
    \ that describes the\n      attribute.\n   +------------------+----+-------------------+-----+----------------+\n\
    \   | Name             | Id | Data Type         | Acc | Defined in     |\n   +------------------+----+-------------------+-----+----------------+\n\
    \   | clone_blksize    | 77 | uint32_t          | R   | Section 12.2.1 |\n   |\
    \ space_freed      | 78 | length4           | R   | Section 12.2.2 |\n   | change_attr_type\
    \ | 79 | change_attr_type4 | R   | Section 12.2.3 |\n   | sec_label        | 80\
    \ | sec_label4        | R W | Section 12.2.4 |\n   +------------------+----+-------------------+-----+----------------+\n\
    \                    Table 4: New RECOMMENDED Attributes\n"
- title: 12.2.  Attribute Definitions
  contents:
  - '12.2.  Attribute Definitions

    '
- title: '12.2.1.  Attribute 77: clone_blksize'
  contents:
  - "12.2.1.  Attribute 77: clone_blksize\n   The clone_blksize attribute indicates\
    \ the granularity of a CLONE\n   operation.\n"
- title: '12.2.2.  Attribute 78: space_freed'
  contents:
  - "12.2.2.  Attribute 78: space_freed\n   space_freed gives the number of bytes\
    \ freed if the file is deleted.\n   This attribute is read-only and is of type\
    \ length4.  It is a per-file\n   attribute.\n"
- title: '12.2.3.  Attribute 79: change_attr_type'
  contents:
  - "12.2.3.  Attribute 79: change_attr_type\n   <CODE BEGINS>\n   enum change_attr_type4\
    \ {\n              NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR         = 0,\n         \
    \     NFS4_CHANGE_TYPE_IS_VERSION_COUNTER        = 1,\n              NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS\
    \ = 2,\n              NFS4_CHANGE_TYPE_IS_TIME_METADATA          = 3,\n      \
    \        NFS4_CHANGE_TYPE_IS_UNDEFINED              = 4\n   };\n   <CODE ENDS>\n\
    \   change_attr_type is a per-file system attribute that enables the\n   NFSv4.2\
    \ server to provide additional information about how it expects\n   the change\
    \ attribute value to evolve after the file data or metadata\n   has changed. \
    \ While Section 5.4 of [RFC5661] discusses\n   per-file system attributes, it\
    \ is expected that the value of\n   change_attr_type will not depend on the value\
    \ of \"homogeneous\" and\n   will only change in the event of a migration.\n \
    \  NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR:  The change attribute value MUST\n    \
    \  monotonically increase for every atomic change to the file\n      attributes,\
    \ data, or directory contents.\n   NFS4_CHANGE_TYPE_IS_VERSION_COUNTER:  The change\
    \ attribute value MUST\n      be incremented by one unit for every atomic change\
    \ to the file\n      attributes, data, or directory contents.  This property is\n\
    \      preserved when writing to pNFS data servers.\n   NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS:\
    \  The change attribute\n      value MUST be incremented by one unit for every\
    \ atomic change to\n      the file attributes, data, or directory contents.  In\
    \ the case\n      where the client is writing to pNFS data servers, the number\
    \ of\n      increments is not guaranteed to exactly match the number of\n    \
    \  WRITEs.\n   NFS4_CHANGE_TYPE_IS_TIME_METADATA:  The change attribute is\n \
    \     implemented as suggested in [RFC7530] in terms of the\n      time_metadata\
    \ attribute.\n   NFS4_CHANGE_TYPE_IS_UNDEFINED:  The change attribute does not\
    \ take\n      values that fit into any of these categories.\n   If either NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR,\n\
    \   NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, or\n   NFS4_CHANGE_TYPE_IS_TIME_METADATA\
    \ is set, then the client knows at\n   the very least that the change attribute\
    \ is monotonically increasing,\n   which is sufficient to resolve the question\
    \ of which value is the\n   most recent.\n   If the client sees the value NFS4_CHANGE_TYPE_IS_TIME_METADATA,\
    \ then\n   by inspecting the value of the \"time_delta\" attribute it additionally\n\
    \   has the option of detecting rogue server implementations that use\n   time_metadata\
    \ in violation of the specification.\n   If the client sees NFS4_CHANGE_TYPE_IS_VERSION_COUNTER,\
    \ it has the\n   ability to predict what the resulting change attribute value\
    \ should\n   be after a COMPOUND containing a SETATTR, WRITE, or CREATE.  This\n\
    \   again allows it to detect changes made in parallel by another client.\n  \
    \ The value NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS permits the\n   same, but\
    \ only if the client is not doing pNFS WRITEs.\n   Finally, if the server does\
    \ not support change_attr_type or if\n   NFS4_CHANGE_TYPE_IS_UNDEFINED is set,\
    \ then the server SHOULD make an\n   effort to implement the change attribute\
    \ in terms of the\n   time_metadata attribute.\n"
- title: '12.2.4.  Attribute 80: sec_label'
  contents:
  - "12.2.4.  Attribute 80: sec_label\n   <CODE BEGINS>\n   typedef uint32_t  policy4;\n\
    \   struct labelformat_spec4 {\n           policy4 lfs_lfs;\n           policy4\
    \ lfs_pi;\n   };\n   struct sec_label4 {\n           labelformat_spec4       slai_lfs;\n\
    \           opaque                  slai_data<>;\n   };\n   <CODE ENDS>\n   The\
    \ FATTR4_SEC_LABEL contains an array of two components, with the\n   first component\
    \ being an LFS.  It serves to provide the receiving end\n   with the information\
    \ necessary to translate the security attribute\n   into a form that is usable\
    \ by the endpoint.  Label Formats assigned\n   an LFS may optionally choose to\
    \ include a Policy Identifier field to\n   allow for complex policy deployments.\
    \  The LFS and the Security Label\n   Format Selection Registry are described\
    \ in detail in [RFC7569].  The\n   translation used to interpret the security\
    \ attribute is not specified\n   as part of the protocol, as it may depend on\
    \ various factors.  The\n   second component is an opaque section that contains\
    \ the data of the\n   attribute.  This component is dependent on the MAC model\
    \ to interpret\n   and enforce.\n   In particular, it is the responsibility of\
    \ the LFS specification to\n   define a maximum size for the opaque section, slai_data<>.\
    \  When\n   creating or modifying a label for an object, the client needs to be\n\
    \   guaranteed that the server will accept a label that is sized\n   correctly.\
    \  By both client and server being part of a specific MAC\n   model, the client\
    \ will be aware of the size.\n"
- title: '13.  Operations: REQUIRED, RECOMMENDED, or OPTIONAL'
  contents:
  - "13.  Operations: REQUIRED, RECOMMENDED, or OPTIONAL\n   Tables 5 and 6 summarize\
    \ the operations of the NFSv4.2 protocol and\n   the corresponding designations\
    \ of REQUIRED, RECOMMENDED, and OPTIONAL\n   to implement or MUST NOT implement.\
    \  The \"MUST NOT implement\"\n   designation is reserved for those operations\
    \ that were defined in\n   either NFSv4.0 or NFSv4.1 and MUST NOT be implemented\
    \ in NFSv4.2.\n   For the most part, the REQUIRED, RECOMMENDED, or OPTIONAL designation\n\
    \   for operations sent by the client is for the server implementation.\n   The\
    \ client is generally required to implement the operations needed\n   for the\
    \ operating environment that it serves.  For example, a\n   read-only NFSv4.2\
    \ client would have no need to implement the WRITE\n   operation and is not required\
    \ to do so.\n   The REQUIRED or OPTIONAL designation for callback operations sent\
    \ by\n   the server is for both the client and server.  Generally, the client\n\
    \   has the option of creating the backchannel and sending the operations\n  \
    \ on the forechannel that will be a catalyst for the server sending\n   callback\
    \ operations.  A partial exception is CB_RECALL_SLOT; the only\n   way the client\
    \ can avoid supporting this operation is by not creating\n   a backchannel.\n\
    \   Since this is a summary of the operations and their designation,\n   there\
    \ are subtleties that are not presented here.  Therefore, if\n   there is a question\
    \ regarding implementation requirements, the\n   operation descriptions themselves\
    \ must be consulted, along with other\n   relevant explanatory text within either\
    \ this specification or the\n   NFSv4.1 specification [RFC5661].\n   The abbreviations\
    \ used in the second and third columns of Tables 5\n   and 6 are defined as follows:\n\
    \   REQ:  REQUIRED to implement\n   REC:  RECOMMENDED to implement\n   OPT:  OPTIONAL\
    \ to implement\n   MNI:  MUST NOT implement\n   For the NFSv4.2 features that\
    \ are OPTIONAL, the operations that\n   support those features are OPTIONAL, and\
    \ the server MUST return\n   NFS4ERR_NOTSUPP in response to the client's use of\
    \ those operations\n   when those operations are not implemented by the server.\
    \  If an\n   OPTIONAL feature is supported, it is possible that a set of\n   operations\
    \ related to the feature become REQUIRED to implement.  The\n   third column of\
    \ the tables designates the feature(s) and if the\n   operation is REQUIRED or\
    \ OPTIONAL in the presence of support for the\n   feature.\n   The OPTIONAL features\
    \ identified and their abbreviations are as\n   follows:\n   pNFS:  Parallel NFS\n\
    \   FDELG:  File Delegations\n   DDELG:  Directory Delegations\n   COPYra:  Intra-server\
    \ Server-Side Copy\n   COPYer:  Inter-server Server-Side Copy\n   ADB:  Application\
    \ Data Blocks\n   +----------------------+--------------------+-----------------------+\n\
    \   | Operation            | REQ, REC, OPT, or  | Feature (REQ, REC, or |\n  \
    \ |                      | MNI                | OPT)                  |\n   +----------------------+--------------------+-----------------------+\n\
    \   | ACCESS               | REQ                |                       |\n  \
    \ | ALLOCATE             | OPT                |                       |\n   |\
    \ BACKCHANNEL_CTL      | REQ                |                       |\n   | BIND_CONN_TO_SESSION\
    \ | REQ                |                       |\n   | CLONE                |\
    \ OPT                |                       |\n   | CLOSE                | REQ\
    \                |                       |\n   | COMMIT               | REQ  \
    \              |                       |\n   | COPY                 | OPT    \
    \            | COPYer (REQ), COPYra  |\n   |                      |          \
    \          | (REQ)                 |\n   | COPY_NOTIFY          | OPT        \
    \        | COPYer (REQ)          |\n   | CREATE               | REQ          \
    \      |                       |\n   | CREATE_SESSION       | REQ            \
    \    |                       |\n   | DEALLOCATE           | OPT              \
    \  |                       |\n   | DELEGPURGE           | OPT                |\
    \ FDELG (REQ)           |\n   | DELEGRETURN          | OPT                | FDELG,\
    \ DDELG, pNFS    |\n   |                      |                    | (REQ)   \
    \              |\n   | DESTROY_CLIENTID     | REQ                |           \
    \            |\n   | DESTROY_SESSION      | REQ                |             \
    \          |\n   | EXCHANGE_ID          | REQ                |               \
    \        |\n   | FREE_STATEID         | REQ                |                 \
    \      |\n   | GETATTR              | REQ                |                   \
    \    |\n   | GETDEVICEINFO        | OPT                | pNFS (REQ)          \
    \  |\n   | GETDEVICELIST        | MNI                | pNFS (MNI)            |\n\
    \   | GETFH                | REQ                |                       |\n  \
    \ | GET_DIR_DELEGATION   | OPT                | DDELG (REQ)           |\n   |\
    \ ILLEGAL              | REQ                |                       |\n   | IO_ADVISE\
    \            | OPT                |                       |\n   | LAYOUTCOMMIT\
    \         | OPT                | pNFS (REQ)            |\n   | LAYOUTERROR   \
    \       | OPT                | pNFS (OPT)            |\n   | LAYOUTGET       \
    \     | OPT                | pNFS (REQ)            |\n   | LAYOUTRETURN      \
    \   | OPT                | pNFS (REQ)            |\n   | LAYOUTSTATS         \
    \ | OPT                | pNFS (OPT)            |\n   | LINK                 |\
    \ OPT                |                       |\n   | LOCK                 | REQ\
    \                |                       |\n   | LOCKT                | REQ  \
    \              |                       |\n   | LOCKU                | REQ    \
    \            |                       |\n   | LOOKUP               | REQ      \
    \          |                       |\n   | LOOKUPP              | REQ        \
    \        |                       |\n   | NVERIFY              | REQ          \
    \      |                       |\n   | OFFLOAD_CANCEL       | OPT            \
    \    | COPYer (OPT), COPYra  |\n   |                      |                  \
    \  | (OPT)                 |\n   | OFFLOAD_STATUS       | OPT                |\
    \ COPYer (OPT), COPYra  |\n   |                      |                    | (OPT)\
    \                 |\n   | OPEN                 | REQ                |        \
    \               |\n   | OPENATTR             | OPT                |          \
    \             |\n   | OPEN_CONFIRM         | MNI                |            \
    \           |\n   | OPEN_DOWNGRADE       | REQ                |              \
    \         |\n   | PUTFH                | REQ                |                \
    \       |\n   | PUTPUBFH             | REQ                |                  \
    \     |\n   | PUTROOTFH            | REQ                |                    \
    \   |\n   | READ                 | REQ                |                      \
    \ |\n   | READDIR              | REQ                |                       |\n\
    \   | READLINK             | OPT                |                       |\n  \
    \ | READ_PLUS            | OPT                |                       |\n   |\
    \ RECLAIM_COMPLETE     | REQ                |                       |\n   | RELEASE_LOCKOWNER\
    \    | MNI                |                       |\n   | REMOVE             \
    \  | REQ                |                       |\n   | RENAME               |\
    \ REQ                |                       |\n   | RENEW                | MNI\
    \                |                       |\n   | RESTOREFH            | REQ  \
    \              |                       |\n   | SAVEFH               | REQ    \
    \            |                       |\n   | SECINFO              | REQ      \
    \          |                       |\n   | SECINFO_NO_NAME      | REC        \
    \        | pNFS file layout      |\n   |                      |              \
    \      | (REQ)                 |\n   | SEEK                 | OPT            \
    \    |                       |\n   | SEQUENCE             | REQ              \
    \  |                       |\n   | SETATTR              | REQ                |\
    \                       |\n   | SETCLIENTID          | MNI                |  \
    \                     |\n   | SETCLIENTID_CONFIRM  | MNI                |    \
    \                   |\n   | SET_SSV              | REQ                |      \
    \                 |\n   | TEST_STATEID         | REQ                |        \
    \               |\n   | VERIFY               | REQ                |          \
    \             |\n   | WANT_DELEGATION      | OPT                | FDELG (OPT)\
    \           |\n   | WRITE                | REQ                |              \
    \         |\n   | WRITE_SAME           | OPT                | ADB (REQ)      \
    \       |\n   +----------------------+--------------------+-----------------------+\n\
    \                            Table 5: Operations\n   +-------------------------+------------------+----------------------+\n\
    \   | Operation               | REQ, REC, OPT,   | Feature (REQ, REC,   |\n  \
    \ |                         | or MNI           | or OPT)              |\n   +-------------------------+------------------+----------------------+\n\
    \   | CB_GETATTR              | OPT              | FDELG (REQ)          |\n  \
    \ | CB_ILLEGAL              | REQ              |                      |\n   |\
    \ CB_LAYOUTRECALL         | OPT              | pNFS (REQ)           |\n   | CB_NOTIFY\
    \               | OPT              | DDELG (REQ)          |\n   | CB_NOTIFY_DEVICEID\
    \      | OPT              | pNFS (OPT)           |\n   | CB_NOTIFY_LOCK      \
    \    | OPT              |                      |\n   | CB_OFFLOAD            \
    \  | OPT              | COPYer (REQ), COPYra |\n   |                         |\
    \                  | (REQ)                |\n   | CB_PUSH_DELEG           | OPT\
    \              | FDELG (OPT)          |\n   | CB_RECALL               | OPT  \
    \            | FDELG, DDELG, pNFS   |\n   |                         |        \
    \          | (REQ)                |\n   | CB_RECALL_ANY           | OPT      \
    \        | FDELG, DDELG, pNFS   |\n   |                         |            \
    \      | (REQ)                |\n   | CB_RECALL_SLOT          | REQ          \
    \    |                      |\n   | CB_RECALLABLE_OBJ_AVAIL | OPT            \
    \  | DDELG, pNFS (REQ)    |\n   | CB_SEQUENCE             | OPT              |\
    \ FDELG, DDELG, pNFS   |\n   |                         |                  | (REQ)\
    \                |\n   | CB_WANTS_CANCELLED      | OPT              | FDELG, DDELG,\
    \ pNFS   |\n   |                         |                  | (REQ)          \
    \      |\n   +-------------------------+------------------+----------------------+\n\
    \                       Table 6: Callback Operations\n"
- title: 14.  Modifications to NFSv4.1 Operations
  contents:
  - '14.  Modifications to NFSv4.1 Operations

    '
- title: '14.1.  Operation 42: EXCHANGE_ID - Instantiate the client ID'
  contents:
  - '14.1.  Operation 42: EXCHANGE_ID - Instantiate the client ID

    '
- title: 14.1.1.  ARGUMENT
  contents:
  - "14.1.1.  ARGUMENT\n   <CODE BEGINS>\n      /* new */\n      const EXCHGID4_FLAG_SUPP_FENCE_OPS\
    \      = 0x00000004;\n   <CODE ENDS>\n"
- title: 14.1.2.  RESULT
  contents:
  - "14.1.2.  RESULT\n      Unchanged\n"
- title: 14.1.3.  MOTIVATION
  contents:
  - "14.1.3.  MOTIVATION\n   Enterprise applications require guarantees that an operation\
    \ has\n   either aborted or completed.  NFSv4.1 provides this guarantee as long\n\
    \   as the session is alive: simply send a SEQUENCE operation on the same\n  \
    \ slot with a new sequence number, and the successful return of\n   SEQUENCE indicates\
    \ that the previous operation has completed.\n   However, if the session is lost,\
    \ there is no way to know when any\n   operations in progress have aborted or\
    \ completed.  In hindsight, the\n   NFSv4.1 specification should have mandated\
    \ that DESTROY_SESSION\n   either abort or complete all outstanding operations.\n"
- title: 14.1.4.  DESCRIPTION
  contents:
  - "14.1.4.  DESCRIPTION\n   A client SHOULD request the EXCHGID4_FLAG_SUPP_FENCE_OPS\
    \ capability\n   when it sends an EXCHANGE_ID operation.  The server SHOULD set\
    \ this\n   capability in the EXCHANGE_ID reply whether the client requests it\
    \ or\n   not.  It is the server's return that determines whether this\n   capability\
    \ is in effect.  When it is in effect, the following will\n   occur:\n   o  The\
    \ server will not reply to any DESTROY_SESSION invoked with the\n      client\
    \ ID until all operations in progress are completed or\n      aborted.\n   o \
    \ The server will not reply to subsequent EXCHANGE_ID operations\n      invoked\
    \ on the same client owner with a new verifier until all\n      operations in\
    \ progress on the client ID's session are completed or\n      aborted.\n   o \
    \ In implementations where the NFS server is deployed as a cluster,\n      it\
    \ does support client ID trunking, and the\n      EXCHGID4_FLAG_SUPP_FENCE_OPS\
    \ capability is enabled, then a\n      session ID created on one node of the storage\
    \ cluster MUST be\n      destroyable via DESTROY_SESSION.  In addition, DESTROY_CLIENTID\n\
    \      and an EXCHANGE_ID with a new verifier affect all sessions,\n      regardless\
    \ of what node the sessions were created on.\n"
- title: '14.2.  Operation 48: GETDEVICELIST - Get all device mappings for a file'
  contents:
  - "14.2.  Operation 48: GETDEVICELIST - Get all device mappings for a file\n   \
    \    system\n"
- title: 14.2.1.  ARGUMENT
  contents:
  - "14.2.1.  ARGUMENT\n   <CODE BEGINS>\n   struct GETDEVICELIST4args {\n       \
    \    /* CURRENT_FH: object belonging to the file system */\n           layouttype4\
    \     gdla_layout_type;\n           /* number of device IDs to return */\n   \
    \        count4          gdla_maxdevices;\n           nfs_cookie4     gdla_cookie;\n\
    \           verifier4       gdla_cookieverf;\n   };\n   <CODE ENDS>\n"
- title: 14.2.2.  RESULT
  contents:
  - "14.2.2.  RESULT\n   <CODE BEGINS>\n   struct GETDEVICELIST4resok {\n        \
    \   nfs_cookie4             gdlr_cookie;\n           verifier4               gdlr_cookieverf;\n\
    \           deviceid4               gdlr_deviceid_list<>;\n           bool   \
    \                 gdlr_eof;\n   };\n   union GETDEVICELIST4res switch (nfsstat4\
    \ gdlr_status) {\n   case NFS4_OK:\n           GETDEVICELIST4resok     gdlr_resok4;\n\
    \   default:\n           void;\n   };\n   <CODE ENDS>\n"
- title: 14.2.3.  MOTIVATION
  contents:
  - "14.2.3.  MOTIVATION\n   The GETDEVICELIST operation was introduced in [RFC5661]\
    \ specifically\n   to request a list of devices at file system mount time from\
    \ block\n   layout type servers.  However, the use of the GETDEVICELIST operation\n\
    \   introduces a race condition versus notification about changes to pNFS\n  \
    \ device IDs as provided by CB_NOTIFY_DEVICEID.  Implementation\n   experience\
    \ with block layout servers has shown that there is no need\n   for GETDEVICELIST.\
    \  Clients have to be able to request new devices\n   using GETDEVICEINFO at any\
    \ time in response to either a new deviceid\n   in LAYOUTGET results or the CB_NOTIFY_DEVICEID\
    \ callback operation.\n"
- title: 14.2.4.  DESCRIPTION
  contents:
  - "14.2.4.  DESCRIPTION\n   Clients and servers MUST NOT implement the GETDEVICELIST\
    \ operation.\n"
- title: 15.  NFSv4.2 Operations
  contents:
  - '15.  NFSv4.2 Operations

    '
- title: '15.1.  Operation 59: ALLOCATE - Reserve space in a region of a file'
  contents:
  - '15.1.  Operation 59: ALLOCATE - Reserve space in a region of a file

    '
- title: 15.1.1.  ARGUMENT
  contents:
  - "15.1.1.  ARGUMENT\n   <CODE BEGINS>\n   struct ALLOCATE4args {\n           /*\
    \ CURRENT_FH: file */\n           stateid4        aa_stateid;\n           offset4\
    \         aa_offset;\n           length4         aa_length;\n   };\n   <CODE ENDS>\n"
- title: 15.1.2.  RESULT
  contents:
  - "15.1.2.  RESULT\n   <CODE BEGINS>\n   struct ALLOCATE4res {\n           nfsstat4\
    \        ar_status;\n   };\n   <CODE ENDS>\n"
- title: 15.1.3.  DESCRIPTION
  contents:
  - "15.1.3.  DESCRIPTION\n   Whenever a client wishes to reserve space for a region\
    \ in a file, it\n   calls the ALLOCATE operation with the current filehandle set\
    \ to the\n   filehandle of the file in question, and with the start offset and\n\
    \   length in bytes of the region set in aa_offset and aa_length,\n   respectively.\n\
    \   CURRENT_FH must be a regular file.  If CURRENT_FH is not a regular\n   file,\
    \ the operation MUST fail and return NFS4ERR_WRONG_TYPE.\n   The aa_stateid MUST\
    \ refer to a stateid that is valid for a WRITE\n   operation and follows the rules\
    \ for stateids in Sections 8.2.5 and\n   18.32.3 of [RFC5661].\n   The server\
    \ will ensure that backing blocks are reserved to the region\n   specified by\
    \ aa_offset and aa_length, and that no future writes into\n   this region will\
    \ return NFS4ERR_NOSPC.  If the region lies partially\n   or fully outside the\
    \ current file size, the file size will be set to\n   aa_offset + aa_length implicitly.\
    \  If the server cannot guarantee\n   this, it must return NFS4ERR_NOSPC.\n  \
    \ The ALLOCATE operation can also be used to extend the size of a file\n   if\
    \ the region specified by aa_offset and aa_length extends beyond the\n   current\
    \ file size.  In that case, any data outside of the previous\n   file size will\
    \ return zeros when read before data is written to it.\n   It is not required\
    \ that the server allocate the space to the file\n   before returning success.\
    \  The allocation can be deferred; however,\n   it must be guaranteed that it\
    \ will not fail for lack of space.  The\n   deferral does not result in an asynchronous\
    \ reply.\n   The ALLOCATE operation will result in the space_used and space_freed\n\
    \   attributes being increased by the number of bytes reserved, unless\n   they\
    \ were previously reserved or written and not shared.\n"
- title: '15.2.  Operation 60: COPY - Initiate a server-side copy'
  contents:
  - '15.2.  Operation 60: COPY - Initiate a server-side copy

    '
- title: 15.2.1.  ARGUMENT
  contents:
  - "15.2.1.  ARGUMENT\n   <CODE BEGINS>\n   struct COPY4args {\n           /* SAVED_FH:\
    \ source file */\n           /* CURRENT_FH: destination file */\n           stateid4\
    \        ca_src_stateid;\n           stateid4        ca_dst_stateid;\n       \
    \    offset4         ca_src_offset;\n           offset4         ca_dst_offset;\n\
    \           length4         ca_count;\n           bool            ca_consecutive;\n\
    \           bool            ca_synchronous;\n           netloc4         ca_source_server<>;\n\
    \   };\n   <CODE ENDS>\n"
- title: 15.2.2.  RESULT
  contents:
  - "15.2.2.  RESULT\n   <CODE BEGINS>\n   struct write_response4 {\n           stateid4\
    \        wr_callback_id<1>;\n           length4         wr_count;\n          \
    \ stable_how4     wr_committed;\n           verifier4       wr_writeverf;\n  \
    \ };\n   struct copy_requirements4 {\n           bool            cr_consecutive;\n\
    \           bool            cr_synchronous;\n   };\n   struct COPY4resok {\n \
    \          write_response4         cr_response;\n           copy_requirements4\
    \      cr_requirements;\n   };\n   union COPY4res switch (nfsstat4 cr_status)\
    \ {\n   case NFS4_OK:\n           COPY4resok              cr_resok4;\n   case\
    \ NFS4ERR_OFFLOAD_NO_REQS:\n           copy_requirements4      cr_requirements;\n\
    \   default:\n           void;\n   };\n   <CODE ENDS>\n"
- title: 15.2.3.  DESCRIPTION
  contents:
  - "15.2.3.  DESCRIPTION\n   The COPY operation is used for both intra-server and\
    \ inter-server\n   copies.  In both cases, the COPY is always sent from the client\
    \ to\n   the destination server of the file copy.  The COPY operation requests\n\
    \   that a range in the file specified by SAVED_FH be copied to a range\n   in\
    \ the file specified by CURRENT_FH.\n   Both SAVED_FH and CURRENT_FH must be regular\
    \ files.  If either\n   SAVED_FH or CURRENT_FH is not a regular file, the operation\
    \ MUST fail\n   and return NFS4ERR_WRONG_TYPE.\n   SAVED_FH and CURRENT_FH must\
    \ be different files.  If SAVED_FH and\n   CURRENT_FH refer to the same file,\
    \ the operation MUST fail with\n   NFS4ERR_INVAL.\n   If the request is for an\
    \ inter-server copy, the source-fh is a\n   filehandle from the source server\
    \ and the COMPOUND procedure is being\n   executed on the destination server.\
    \  In this case, the source-fh is a\n   foreign filehandle on the server receiving\
    \ the COPY request.  If\n   either PUTFH or SAVEFH checked the validity of the\
    \ filehandle, the\n   operation would likely fail and return NFS4ERR_STALE.\n\
    \   If a server supports the inter-server copy feature, a PUTFH followed\n   by\
    \ a SAVEFH MUST NOT return NFS4ERR_STALE for either operation.\n   These restrictions\
    \ do not pose substantial difficulties for servers.\n   CURRENT_FH and SAVED_FH\
    \ may be validated in the context of the\n   operation referencing them and an\
    \ NFS4ERR_STALE error returned for an\n   invalid filehandle at that point.\n\
    \   The ca_dst_stateid MUST refer to a stateid that is valid for a WRITE\n   operation\
    \ and follows the rules for stateids in Sections 8.2.5 and\n   18.32.3 of [RFC5661].\
    \  For an inter-server copy, the ca_src_stateid\n   MUST be the cnr_stateid returned\
    \ from the earlier COPY_NOTIFY\n   operation, while for an intra-server copy ca_src_stateid\
    \ MUST refer\n   to a stateid that is valid for a READ operation and follows the\
    \ rules\n   for stateids in Sections 8.2.5 and 18.22.3 of [RFC5661].  If either\n\
    \   stateid is invalid, then the operation MUST fail.\n   The ca_src_offset is\
    \ the offset within the source file from which the\n   data will be read, the\
    \ ca_dst_offset is the offset within the\n   destination file to which the data\
    \ will be written, and the ca_count\n   is the number of bytes that will be copied.\
    \  An offset of 0 (zero)\n   specifies the start of the file.  A count of 0 (zero)\
    \ requests that\n   all bytes from ca_src_offset through EOF be copied to the\n\
    \   destination.  If concurrent modifications to the source file overlap\n   with\
    \ the source file region being copied, the data copied may include\n   all, some,\
    \ or none of the modifications.  The client can use standard\n   NFS operations\
    \ (e.g., OPEN with OPEN4_SHARE_DENY_WRITE or mandatory\n   byte-range locks) to\
    \ protect against concurrent modifications if\n   the client is concerned about\
    \ this.  If the source file's EOF is\n   being modified in parallel with a COPY\
    \ that specifies a count of\n   0 (zero) bytes, the amount of data copied is implementation\
    \ dependent\n   (clients may guard against this case by specifying a non-zero\
    \ count\n   value or preventing modification of the source file as mentioned\n\
    \   above).\n   If the source offset or the source offset plus count is greater\
    \ than\n   the size of the source file, the operation MUST fail with\n   NFS4ERR_INVAL.\
    \  The destination offset or destination offset plus\n   count may be greater\
    \ than the size of the destination file.  This\n   allows the client to issue\
    \ parallel copies to implement operations\n   such as\n   <CODE BEGINS>\n    \
    \  % cat file1 file2 file3 file4 > dest\n   <CODE ENDS>\n   If the ca_source_server\
    \ list is specified, then this is an\n   inter-server COPY operation and the source\
    \ file is on a remote\n   server.  The client is expected to have previously issued\
    \ a\n   successful COPY_NOTIFY request to the remote source server.  The\n   ca_source_server\
    \ list MUST be the same as the COPY_NOTIFY response's\n   cnr_source_server list.\
    \  If the client includes the entries from the\n   COPY_NOTIFY response's cnr_source_server\
    \ list in the ca_source_server\n   list, the source server can indicate a specific\
    \ copy protocol for the\n   destination server to use by returning a URL that\
    \ specifies both a\n   protocol service and server name.  Server-to-server copy\
    \ protocol\n   considerations are described in Sections 4.6 and 4.9.1.\n   If\
    \ ca_consecutive is set, then the client has specified that the copy\n   protocol\
    \ selected MUST copy bytes in consecutive order from\n   ca_src_offset to ca_count.\
    \  If the destination server cannot meet\n   this requirement, then it MUST return\
    \ an error of\n   NFS4ERR_OFFLOAD_NO_REQS and set cr_consecutive to be FALSE.\n\
    \   Likewise, if ca_synchronous is set, then the client has required that\n  \
    \ the copy protocol selected MUST perform a synchronous copy.  If the\n   destination\
    \ server cannot meet this requirement, then it MUST return\n   an error of NFS4ERR_OFFLOAD_NO_REQS\
    \ and set cr_synchronous to be\n   FALSE.\n   If both are set by the client, then\
    \ the destination SHOULD try to\n   determine if it can respond to both requirements\
    \ at the same time.\n   If it cannot make that determination, it must set to TRUE\
    \ the one it\n   can and set to FALSE the other.  The client, upon getting an\n\
    \   NFS4ERR_OFFLOAD_NO_REQS error, has to examine both cr_consecutive and\n  \
    \ cr_synchronous against the respective values of ca_consecutive and\n   ca_synchronous\
    \ to determine the possible requirement not met.  It\n   MUST be prepared for\
    \ the destination server not being able to\n   determine both requirements at\
    \ the same time.\n   Upon receiving the NFS4ERR_OFFLOAD_NO_REQS error, the client\
    \ has to\n   determine whether it wants to re-request the copy with a relaxed\
    \ set\n   of requirements or revert to manually copying the data.  If it\n   decides\
    \ to manually copy the data and this is a remote copy, then the\n   client is\
    \ responsible for informing the source that the earlier\n   COPY_NOTIFY is no\
    \ longer valid by sending it an OFFLOAD_CANCEL.\n   If the operation does not\
    \ result in an immediate failure, the server\n   will return NFS4_OK.\n   If the\
    \ wr_callback_id is returned, this indicates that an\n   asynchronous COPY operation\
    \ was initiated and a CB_OFFLOAD callback\n   will deliver the final results of\
    \ the operation.  The wr_callback_id\n   stateid is termed a \"copy stateid\"\
    \ in this context.  The server is\n   given the option of returning the results\
    \ in a callback because the\n   data may require a relatively long period of time\
    \ to copy.\n   If no wr_callback_id is returned, the operation completed\n   synchronously\
    \ and no callback will be issued by the server.  The\n   completion status of\
    \ the operation is indicated by cr_status.\n   If the copy completes successfully,\
    \ either synchronously or\n   asynchronously, the data copied from the source\
    \ file to the\n   destination file MUST appear identical to the NFS client.  However,\n\
    \   the NFS server's on-disk representation of the data in the source\n   file\
    \ and destination file MAY differ.  For example, the NFS server\n   might encrypt,\
    \ compress, deduplicate, or otherwise represent the\n   on-disk data in the source\
    \ and destination files differently.\n   If a failure does occur for a synchronous\
    \ copy, wr_count will be set\n   to the number of bytes copied to the destination\
    \ file before the\n   error occurred.  If cr_consecutive is TRUE, then the bytes\
    \ were\n   copied in order.  If the failure occurred for an asynchronous copy,\n\
    \   then the client will have gotten the notification of the consecutive\n   copy\
    \ order when it got the copy stateid.  It will be able to\n   determine the bytes\
    \ copied from the coa_bytes_copied in the\n   CB_OFFLOAD argument.\n   In either\
    \ case, if cr_consecutive was not TRUE, there is no assurance\n   as to exactly\
    \ which bytes in the range were copied.  The client MUST\n   assume that there\
    \ exists a mixture of the original contents of the\n   range and the new bytes.\
    \  If the COPY wrote past the end of the file\n   on the destination, then the\
    \ last byte written to will determine the\n   new file size.  The contents of\
    \ any block not written to and past\n   the original size of the file will be\
    \ as if a normal WRITE extended\n   the file.\n"
- title: '15.3.  Operation 61: COPY_NOTIFY - Notify a source server of a future'
  contents:
  - "15.3.  Operation 61: COPY_NOTIFY - Notify a source server of a future\n     \
    \  copy\n"
- title: 15.3.1.  ARGUMENT
  contents:
  - "15.3.1.  ARGUMENT\n   <CODE BEGINS>\n   struct COPY_NOTIFY4args {\n         \
    \  /* CURRENT_FH: source file */\n           stateid4        cna_src_stateid;\n\
    \           netloc4         cna_destination_server;\n   };\n   <CODE ENDS>\n"
- title: 15.3.2.  RESULT
  contents:
  - "15.3.2.  RESULT\n   <CODE BEGINS>\n   struct COPY_NOTIFY4resok {\n          \
    \ nfstime4        cnr_lease_time;\n           stateid4        cnr_stateid;\n \
    \          netloc4         cnr_source_server<>;\n   };\n   union COPY_NOTIFY4res\
    \ switch (nfsstat4 cnr_status) {\n   case NFS4_OK:\n           COPY_NOTIFY4resok\
    \       resok4;\n   default:\n           void;\n   };\n   <CODE ENDS>\n"
- title: 15.3.3.  DESCRIPTION
  contents:
  - "15.3.3.  DESCRIPTION\n   This operation is used for an inter-server copy.  A\
    \ client sends this\n   operation in a COMPOUND request to the source server to\
    \ authorize a\n   destination server identified by cna_destination_server to read\
    \ the\n   file specified by CURRENT_FH on behalf of the given user.\n   The cna_src_stateid\
    \ MUST refer to either open or locking states\n   provided earlier by the server.\
    \  If it is invalid, then the operation\n   MUST fail.\n   The cna_destination_server\
    \ MUST be specified using the netloc4\n   network location format.  The server\
    \ is not required to resolve the\n   cna_destination_server address before completing\
    \ this operation.\n   If this operation succeeds, the source server will allow\
    \ the\n   cna_destination_server to copy the specified file on behalf of the\n\
    \   given user as long as both of the following conditions are met:\n   o  The\
    \ destination server begins reading the source file before the\n      cnr_lease_time\
    \ expires.  If the cnr_lease_time expires while the\n      destination server\
    \ is still reading the source file, the\n      destination server is allowed to\
    \ finish reading the file.  If the\n      cnr_lease_time expires before the destination\
    \ server uses READ or\n      READ_PLUS to begin the transfer, the source server\
    \ can use\n      NFS4ERR_PARTNER_NO_AUTH to inform the destination server that\
    \ the\n      cnr_lease_time has expired.\n   o  The client has not issued an OFFLOAD_CANCEL\
    \ for the same\n      combination of user, filehandle, and destination server.\n\
    \   The cnr_lease_time is chosen by the source server.  A cnr_lease_time\n   of\
    \ 0 (zero) indicates an infinite lease.  To avoid the need for\n   synchronized\
    \ clocks, copy lease times are granted by the server as a\n   time delta.  To\
    \ renew the copy lease time, the client should resend\n   the same copy notification\
    \ request to the source server.\n   The cnr_stateid is a copy stateid that uniquely\
    \ describes the state\n   needed on the source server to track the proposed COPY.\
    \  As defined\n   in Section 8.2 of [RFC5661], a stateid is tied to the current\n\
    \   filehandle, and if the same stateid is presented by two different\n   clients,\
    \ it may refer to different states.  As the source does not\n   know which netloc4\
    \ network location the destination might use to\n   establish the COPY operation,\
    \ it can use the cnr_stateid to identify\n   that the destination is operating\
    \ on behalf of the client.  Thus, the\n   source server MUST construct copy stateids\
    \ such that they are\n   distinct from all other stateids handed out to clients.\
    \  These copy\n   stateids MUST denote the same set of locks as each of the earlier\n\
    \   delegation, locking, and open states for the client on the given file\n  \
    \ (see Section 4.3.1).\n   A successful response will also contain a list of netloc4\
    \ network\n   location formats called cnr_source_server, on which the source is\n\
    \   willing to accept connections from the destination.  These might not\n   be\
    \ reachable from the client and might be located on networks to\n   which the\
    \ client has no connection.\n   This operation is unnecessary for an intra-server\
    \ copy.\n"
- title: '15.4.  Operation 62: DEALLOCATE - Unreserve space in a region of a file'
  contents:
  - '15.4.  Operation 62: DEALLOCATE - Unreserve space in a region of a file

    '
- title: 15.4.1.  ARGUMENT
  contents:
  - "15.4.1.  ARGUMENT\n   <CODE BEGINS>\n   struct DEALLOCATE4args {\n          \
    \ /* CURRENT_FH: file */\n           stateid4        da_stateid;\n           offset4\
    \         da_offset;\n           length4         da_length;\n   };\n   <CODE ENDS>\n"
- title: 15.4.2.  RESULT
  contents:
  - "15.4.2.  RESULT\n   <CODE BEGINS>\n   struct DEALLOCATE4res {\n           nfsstat4\
    \        dr_status;\n   };\n   <CODE ENDS>\n"
- title: 15.4.3.  DESCRIPTION
  contents:
  - "15.4.3.  DESCRIPTION\n   Whenever a client wishes to unreserve space for a region\
    \ in a file,\n   it calls the DEALLOCATE operation with the current filehandle\
    \ set to\n   the filehandle of the file in question, and with the start offset\
    \ and\n   length in bytes of the region set in da_offset and da_length,\n   respectively.\
    \  If no space was allocated or reserved for all or parts\n   of the region, the\
    \ DEALLOCATE operation will have no effect for the\n   region that already is\
    \ in unreserved state.  All further READs from\n   the region passed to DEALLOCATE\
    \ MUST return zeros until overwritten.\n   CURRENT_FH must be a regular file.\
    \  If CURRENT_FH is not a regular\n   file, the operation MUST fail and return\
    \ NFS4ERR_WRONG_TYPE.\n   The da_stateid MUST refer to a stateid that is valid\
    \ for a WRITE\n   operation and follows the rules for stateids in Sections 8.2.5\
    \ and\n   18.32.3 of [RFC5661].\n   Situations may arise where da_offset and/or\
    \ da_offset + da_length\n   will not be aligned to a boundary for which the server\
    \ does\n   allocations or deallocations.  For most file systems, this is the\n\
    \   block size of the file system.  In such a case, the server can\n   deallocate\
    \ as many bytes as it can in the region.  The blocks that\n   cannot be deallocated\
    \ MUST be zeroed.\n   DEALLOCATE will result in the space_used attribute being\
    \ decreased by\n   the number of bytes that were deallocated.  The space_freed\
    \ attribute\n   may or may not decrease, depending on the support and whether\
    \ the\n   blocks backing the specified range were shared or not.  The size\n \
    \  attribute will remain unchanged.\n"
- title: '15.5.  Operation 63: IO_ADVISE - Send client I/O access pattern hints to'
  contents:
  - "15.5.  Operation 63: IO_ADVISE - Send client I/O access pattern hints to\n  \
    \     the server\n"
- title: 15.5.1.  ARGUMENT
  contents:
  - "15.5.1.  ARGUMENT\n   <CODE BEGINS>\n   enum IO_ADVISE_type4 {\n           IO_ADVISE4_NORMAL\
    \                       = 0,\n           IO_ADVISE4_SEQUENTIAL               \
    \    = 1,\n           IO_ADVISE4_SEQUENTIAL_BACKWARDS         = 2,\n         \
    \  IO_ADVISE4_RANDOM                       = 3,\n           IO_ADVISE4_WILLNEED\
    \                     = 4,\n           IO_ADVISE4_WILLNEED_OPPORTUNISTIC     \
    \  = 5,\n           IO_ADVISE4_DONTNEED                     = 6,\n           IO_ADVISE4_NOREUSE\
    \                      = 7,\n           IO_ADVISE4_READ                      \
    \   = 8,\n           IO_ADVISE4_WRITE                        = 9,\n          \
    \ IO_ADVISE4_INIT_PROXIMITY               = 10\n   };\n   struct IO_ADVISE4args\
    \ {\n           /* CURRENT_FH: file */\n           stateid4        iaa_stateid;\n\
    \           offset4         iaa_offset;\n           length4         iaa_count;\n\
    \           bitmap4         iaa_hints;\n   };\n   <CODE ENDS>\n"
- title: 15.5.2.  RESULT
  contents:
  - "15.5.2.  RESULT\n   <CODE BEGINS>\n   struct IO_ADVISE4resok {\n           bitmap4\
    \ ior_hints;\n   };\n   union IO_ADVISE4res switch (nfsstat4 ior_status) {\n \
    \  case NFS4_OK:\n           IO_ADVISE4resok resok4;\n   default:\n          \
    \ void;\n   };\n   <CODE ENDS>\n"
- title: 15.5.3.  DESCRIPTION
  contents:
  - "15.5.3.  DESCRIPTION\n   The IO_ADVISE operation sends an I/O access pattern\
    \ hint to the\n   server for the owner of the stateid for a given byte range specified\n\
    \   by iar_offset and iar_count.  The byte range specified by iaa_offset\n   and\
    \ iaa_count need not currently exist in the file, but the iaa_hints\n   will apply\
    \ to the byte range when it does exist.  If iaa_count is 0,\n   all data following\
    \ iaa_offset is specified.  The server MAY ignore\n   the advice.\n   The following\
    \ are the allowed hints for a stateid holder:\n   IO_ADVISE4_NORMAL  There is\
    \ no advice to give.  This is the default\n      behavior.\n   IO_ADVISE4_SEQUENTIAL\
    \  Expects to access the specified data\n      sequentially from lower offsets\
    \ to higher offsets.\n   IO_ADVISE4_SEQUENTIAL_BACKWARDS  Expects to access the\
    \ specified data\n      sequentially from higher offsets to lower offsets.\n \
    \  IO_ADVISE4_RANDOM  Expects to access the specified data in a random\n     \
    \ order.\n   IO_ADVISE4_WILLNEED  Expects to access the specified data in the\
    \ near\n      future.\n   IO_ADVISE4_WILLNEED_OPPORTUNISTIC  Expects to possibly\
    \ access the\n      data in the near future.  This is a speculative hint, and\n\
    \      therefore the server should prefetch data or indirect blocks only\n   \
    \   if it can be done at a marginal cost.\n   IO_ADVISE_DONTNEED  Expects that\
    \ it will not access the specified\n      data in the near future.\n   IO_ADVISE_NOREUSE\
    \  Expects to access the specified data once and then\n      not reuse it thereafter.\n\
    \   IO_ADVISE4_READ  Expects to read the specified data in the near\n      future.\n\
    \   IO_ADVISE4_WRITE  Expects to write the specified data in the near\n      future.\n\
    \   IO_ADVISE4_INIT_PROXIMITY  Informs the server that the data in the\n     \
    \ byte range remains important to the client.\n   Since IO_ADVISE is a hint, a\
    \ server SHOULD NOT return an error and\n   invalidate an entire COMPOUND request\
    \ if one of the sent hints in\n   iar_hints is not supported by the server.  Also,\
    \ the server MUST NOT\n   return an error if the client sends contradictory hints\
    \ to the\n   server, e.g., IO_ADVISE4_SEQUENTIAL and IO_ADVISE4_RANDOM in a single\n\
    \   IO_ADVISE operation.  In these cases, the server MUST return success\n   and\
    \ an ior_hints value that indicates the hint it intends to\n   implement.  This\
    \ may mean simply returning IO_ADVISE4_NORMAL.\n   The ior_hints returned by the\
    \ server is primarily for debugging\n   purposes, since the server is under no\
    \ obligation to carry out the\n   hints that it describes in the ior_hints result.\
    \  In addition, while\n   the server may have intended to implement the hints\
    \ returned in\n   ior_hints, the server may need to change its handling of a given\
    \ file\n   -- for example, because of memory pressure, additional IO_ADVISE\n\
    \   hints sent by other clients, or heuristically detected file access\n   patterns.\n\
    \   The server MAY return different advice than what the client\n   requested.\
    \  Some examples include another client advising of a\n   different I/O access\
    \ pattern, another client employing a different\n   I/O access pattern, or inability\
    \ of the server to support the\n   requested I/O access pattern.\n   Each issuance\
    \ of the IO_ADVISE operation overrides all previous\n   issuances of IO_ADVISE\
    \ for a given byte range.  This effectively\n   follows a strategy of \"last hint\
    \ wins\" for a given stateid and\n   byte range.\n   Clients should assume that\
    \ hints included in an IO_ADVISE operation\n   will be forgotten once the file\
    \ is closed.\n"
- title: 15.5.4.  IMPLEMENTATION
  contents:
  - "15.5.4.  IMPLEMENTATION\n   The NFS client may choose to issue an IO_ADVISE operation\
    \ to the\n   server in several different instances.\n   The most obvious is in\
    \ direct response to an application's execution\n   of posix_fadvise().  In this\
    \ case, IO_ADVISE4_WRITE and\n   IO_ADVISE4_READ may be set, based upon the type\
    \ of file access\n   specified when the file was opened.\n"
- title: 15.5.5.  IO_ADVISE4_INIT_PROXIMITY
  contents:
  - "15.5.5.  IO_ADVISE4_INIT_PROXIMITY\n   The IO_ADVISE4_INIT_PROXIMITY hint is\
    \ non-POSIX in origin and can be\n   used to convey that the client has recently\
    \ accessed the byte range\n   in its own cache.  That is, it has not accessed\
    \ it on the server but\n   has accessed it locally.  When the server reaches resource\n\
    \   exhaustion, knowing which data is more important allows the server to\n  \
    \ make better choices about which data to, for example, purge from a\n   cache\
    \ or move to secondary storage.  It also informs the server as to\n   which delegations\
    \ are more important, because if delegations are\n   working correctly, once delegated\
    \ to a client and the client has read\n   the content for that byte range, a server\
    \ might never receive another\n   READ request for that byte range.\n   The IO_ADVISE4_INIT_PROXIMITY\
    \ hint can also be used in a pNFS setting\n   to let the client inform the metadata\
    \ server as to the I/O statistics\n   between the client and the storage devices.\
    \  The metadata server is\n   then free to use this information about client I/O\
    \ to optimize the\n   data storage location.\n   This hint is also useful in the\
    \ case of NFS clients that are network-\n   booting from a server.  If the first\
    \ client to be booted sends this\n   hint, then it keeps the cache warm for the\
    \ remaining clients.\n"
- title: 15.5.6.  pNFS File Layout Data Type Considerations
  contents:
  - "15.5.6.  pNFS File Layout Data Type Considerations\n   The IO_ADVISE considerations\
    \ for pNFS are very similar to the COMMIT\n   considerations for pNFS (see Section\
    \ 13.7 of [RFC5661]).  That is, as\n   with COMMIT, some NFS server implementations\
    \ prefer that IO_ADVISE be\n   done on the storage device, and some prefer that\
    \ it be done on the\n   metadata server.\n   For the file's layout type, NFSv4.2\
    \ includes an additional hint,\n   NFL42_CARE_IO_ADVISE_THRU_MDS, which is valid\
    \ only on metadata\n   servers running NFSv4.2 or higher.  (\"NFL\" stands for\
    \ \"NFS File\n   Layout\".)  Any file's layout obtained from an NFSv4.1 metadata\
    \ server\n   MUST NOT have NFL42_UFLG_IO_ADVISE_THRU_MDS set.  Any file's layout\n\
    \   obtained with an NFSv4.2 metadata server MAY have\n   NFL42_UFLG_IO_ADVISE_THRU_MDS\
    \ set.  However, if the layout utilizes\n   NFSv4.1 storage devices, the IO_ADVISE\
    \ operation cannot be sent\n   to them.\n   If NFL42_UFLG_IO_ADVISE_THRU_MDS is\
    \ set, the client MUST send the\n   IO_ADVISE operation to the metadata server\
    \ in order for it to be\n   honored by the storage device.  Once the metadata\
    \ server receives the\n   IO_ADVISE operation, it will communicate the advice\
    \ to each storage\n   device.\n   If NFL42_UFLG_IO_ADVISE_THRU_MDS is not set,\
    \ then the client SHOULD\n   send an IO_ADVISE operation to the appropriate storage\
    \ device for the\n   specified byte range.  While the client MAY always send IO_ADVISE\
    \ to\n   the metadata server, if the server has not set\n   NFL42_UFLG_IO_ADVISE_THRU_MDS,\
    \ the client should expect that such an\n   IO_ADVISE is futile.  Note that a\
    \ client SHOULD use the same set of\n   arguments on each IO_ADVISE sent to a\
    \ storage device for the same\n   open file reference.\n   The server is not required\
    \ to support different advice for different\n   storage devices with the same\
    \ open file reference.\n"
- title: 15.5.6.1.  Dense and Sparse Packing Considerations
  contents:
  - "15.5.6.1.  Dense and Sparse Packing Considerations\n   The IO_ADVISE operation\
    \ MUST use the iar_offset and byte range as\n   dictated by the presence or absence\
    \ of NFL4_UFLG_DENSE (see\n   Section 13.4.4 of [RFC5661]).\n   For example, if\
    \ NFL4_UFLG_DENSE is present, then (1) a READ or WRITE\n   to the storage device\
    \ for iaa_offset 0 really means iaa_offset 10000\n   in the logical file and (2)\
    \ an IO_ADVISE for iaa_offset 0 means\n   iaa_offset 10000 in the logical file.\n\
    \   For example, if NFL4_UFLG_DENSE is absent, then (1) a READ or WRITE\n   to\
    \ the storage device for iaa_offset 0 really means iaa_offset 0 in\n   the logical\
    \ file and (2) an IO_ADVISE for iaa_offset 0 means\n   iaa_offset 0 in the logical\
    \ file.\n   For example, if NFL4_UFLG_DENSE is present, the stripe unit is\n \
    \  1000 bytes and the stripe count is 10, and the dense storage device\n   file\
    \ is serving iar_offset 0.  A READ or WRITE to the storage device\n   for iaa_offsets\
    \ 0, 1000, 2000, and 3000 really means iaa_offsets\n   10000, 20000, 30000, and\
    \ 40000 (implying a stripe count of 10 and a\n   stripe unit of 1000), and then\
    \ an IO_ADVISE sent to the same storage\n   device with an iaa_offset of 500 and\
    \ an iaa_count of 3000 means that\n   the IO_ADVISE applies to these byte ranges\
    \ of the dense storage\n   device file:\n     - 500 to 999\n     - 1000 to 1999\n\
    \     - 2000 to 2999\n     - 3000 to 3499\n   That is, the contiguous range 500\
    \ to 3499, as specified in IO_ADVISE.\n   It also applies to these byte ranges\
    \ of the logical file:\n     - 10500 to 10999  (500 bytes)\n     - 20000 to 20999\
    \ (1000 bytes)\n     - 30000 to 30999 (1000 bytes)\n     - 40000 to 40499  (500\
    \ bytes)\n     (total            3000 bytes)\n   For example, if NFL4_UFLG_DENSE\
    \ is absent, the stripe unit is\n   250 bytes, the stripe count is 4, and the\
    \ sparse storage device file\n   is serving iaa_offset 0.  Then, a READ or WRITE\
    \ to the storage device\n   for iaa_offsets 0, 1000, 2000, and 3000 really means\
    \ iaa_offsets 0,\n   1000, 2000, and 3000 in the logical file, keeping in mind\
    \ that in the\n   storage device file byte ranges 250 to 999, 1250 to 1999, 2250\
    \ to\n   2999, and 3250 to 3999 are not accessible.  Then, an IO_ADVISE sent\n\
    \   to the same storage device with an iaa_offset of 500 and an iaa_count\n  \
    \ of 3000 means that the IO_ADVISE applies to these byte ranges of the\n   logical\
    \ file and the sparse storage device file:\n     - 500 to 999   (500 bytes) -\
    \ no effect\n     - 1000 to 1249 (250 bytes) - effective\n     - 1250 to 1999\
    \ (750 bytes) - no effect\n     - 2000 to 2249 (250 bytes) - effective\n     -\
    \ 2250 to 2999 (750 bytes) - no effect\n     - 3000 to 3249 (250 bytes) - effective\n\
    \     - 3250 to 3499 (250 bytes) - no effect\n     (subtotal      2250 bytes)\
    \ - no effect\n     (subtotal       750 bytes) - effective\n     (grand total\
    \   3000 bytes) - no effect + effective\n   If neither the NFL42_UFLG_IO_ADVISE_THRU_MDS\
    \ flag nor the\n   NFL4_UFLG_DENSE flag is set in the layout, then any IO_ADVISE\
    \ request\n   sent to the data server with a byte range that overlaps stripe units\n\
    \   that the data server does not serve MUST NOT result in the status\n   NFS4ERR_PNFS_IO_HOLE.\
    \  Instead, the response SHOULD be successful,\n   and if the server applies IO_ADVISE\
    \ hints on any stripe units that\n   overlap with the specified range, those hints\
    \ SHOULD be indicated in\n   the response.\n"
- title: '15.6.  Operation 64: LAYOUTERROR - Provide errors for the layout'
  contents:
  - '15.6.  Operation 64: LAYOUTERROR - Provide errors for the layout

    '
- title: 15.6.1.  ARGUMENT
  contents:
  - "15.6.1.  ARGUMENT\n   <CODE BEGINS>\n   struct device_error4 {\n           deviceid4\
    \       de_deviceid;\n           nfsstat4        de_status;\n           nfs_opnum4\
    \      de_opnum;\n   };\n   struct LAYOUTERROR4args {\n           /* CURRENT_FH:\
    \ file */\n           offset4                 lea_offset;\n           length4\
    \                 lea_length;\n           stateid4                lea_stateid;\n\
    \           device_error4           lea_errors<>;\n   };\n   <CODE ENDS>\n"
- title: 15.6.2.  RESULT
  contents:
  - "15.6.2.  RESULT\n   <CODE BEGINS>\n   struct LAYOUTERROR4res {\n           nfsstat4\
    \        ler_status;\n   };\n   <CODE ENDS>\n"
- title: 15.6.3.  DESCRIPTION
  contents:
  - "15.6.3.  DESCRIPTION\n   The client can use LAYOUTERROR to inform the metadata\
    \ server about\n   errors in its interaction with the layout (see Section 12 of\n\
    \   [RFC5661]) represented by the current filehandle, client ID (derived\n   from\
    \ the session ID in the preceding SEQUENCE operation), byte range\n   (lea_offset\
    \ + lea_length), and lea_stateid.\n   Each individual device_error4 describes\
    \ a single error associated\n   with a storage device, which is identified via\
    \ de_deviceid.  If the\n   layout type (see Section 12.2.7 of [RFC5661]) supports\
    \ NFSv4\n   operations, then the operation that returned the error is identified\n\
    \   via de_opnum.  If the layout type does not support NFSv4 operations,\n   then\
    \ either (1) it MAY choose to map the operation onto one of the\n   allowed operations\
    \ that can be sent to a storage device with the file\n   layout type (see Section\
    \ 3.3) or (2) it can signal no support for\n   operations by marking de_opnum\
    \ with the ILLEGAL operation.  Finally,\n   the NFS error value (nfsstat4) encountered\
    \ is provided via de_status\n   and may consist of the following error codes:\n\
    \   NFS4ERR_NXIO:  The client was unable to establish any communication\n    \
    \  with the storage device.\n   NFS4ERR_*:  The client was able to establish communication\
    \ with the\n      storage device and is returning one of the allowed error codes\
    \ for\n      the operation denoted by de_opnum.\n   Note that while the metadata\
    \ server may return an error associated\n   with the layout stateid or the open\
    \ file, it MUST NOT return an error\n   in the processing of the errors.  If LAYOUTERROR\
    \ is in a COMPOUND\n   before LAYOUTRETURN, it MUST NOT introduce an error other\
    \ than what\n   LAYOUTRETURN would already encounter.\n"
- title: 15.6.4.  IMPLEMENTATION
  contents:
  - "15.6.4.  IMPLEMENTATION\n   There are two broad classes of errors: transient\
    \ and persistent.  The\n   client SHOULD strive to only use this new mechanism\
    \ to report\n   persistent errors.  It MUST be able to deal with transient issues\
    \ by\n   itself.  Also, while the client might consider an issue to be\n   persistent,\
    \ it MUST be prepared for the metadata server to consider\n   such issues to be\
    \ transient.  A prime example of this is if the\n   metadata server fences off\
    \ a client from either a stateid or a\n   filehandle.  The client will get an\
    \ error from the storage device and\n   might relay either NFS4ERR_ACCESS or NFS4ERR_BAD_STATEID\
    \ back to the\n   metadata server, with the belief that this is a hard error.\
    \  If the\n   metadata server is informed by the client that there is an error,\
    \ it\n   can safely ignore that.  For the metadata server, the mission is\n  \
    \ accomplished in that the client has returned a layout that the\n   metadata\
    \ server had most likely recalled.\n   The client might also need to inform the\
    \ metadata server that it\n   cannot reach one or more of the storage devices.\
    \  While the metadata\n   server can detect the connectivity of both of these\
    \ paths:\n   o  metadata server to storage device\n   o  metadata server to client\n\
    \   it cannot determine if the client and storage device path is working.\n  \
    \ As with the case of the storage device passing errors to the client,\n   it\
    \ must be prepared for the metadata server to consider such outages\n   as being\
    \ transitory.\n   Clients are expected to tolerate transient storage device errors,\
    \ and\n   hence clients SHOULD NOT use the LAYOUTERROR error handling for\n  \
    \ device access problems that may be transient.  The methods by which a\n   client\
    \ decides whether a device access problem is transient or\n   persistent are implementation\
    \ specific but may include retrying I/Os\n   to a data server under appropriate\
    \ conditions.\n   When an I/O to a storage device fails, the client SHOULD retry\
    \ the\n   failed I/O via the metadata server.  In this situation, before\n   retrying\
    \ the I/O, the client SHOULD return the layout, or the\n   affected portion thereof,\
    \ and SHOULD indicate which storage device or\n   devices was problematic.  The\
    \ client needs to do this when the\n   storage device is being unresponsive in\
    \ order to fence off any failed\n   write attempts and ensure that they do not\
    \ end up overwriting any\n   later data being written through the metadata server.\
    \  If the client\n   does not do this, the metadata server MAY issue a layout\
    \ recall\n   callback in order to perform the retried I/O.\n   The client needs\
    \ to be cognizant that since this error handling is\n   optional in the metadata\
    \ server, the metadata server may silently\n   ignore this functionality.  Also,\
    \ as the metadata server may consider\n   some issues the client reports to be\
    \ expected, the client might find\n   it difficult to detect a metadata server\
    \ that has not implemented\n   error handling via LAYOUTERROR.\n   If a metadata\
    \ server is aware that a storage device is proving\n   problematic to a client,\
    \ the metadata server SHOULD NOT include that\n   storage device in any pNFS layouts\
    \ sent to that client.  If the\n   metadata server is aware that a storage device\
    \ is affecting many\n   clients, then the metadata server SHOULD NOT include that\
    \ storage\n   device in any pNFS layouts sent out.  If a client asks for a new\n\
    \   layout for the file from the metadata server, it MUST be prepared for\n  \
    \ the metadata server to return that storage device in the layout.  The\n   metadata\
    \ server might not have any choice in using the storage\n   device, i.e., there\
    \ might only be one possible layout for the system.\n   Also, in the case of existing\
    \ files, the metadata server might have\n   no choice regarding which storage\
    \ devices to hand out to clients.\n   The metadata server is not required to indefinitely\
    \ retain per-client\n   storage device error information.  The metadata server\
    \ is also not\n   required to automatically reinstate the use of a previously\n\
    \   problematic storage device; administrative intervention may be\n   required\
    \ instead.\n"
- title: '15.7.  Operation 65: LAYOUTSTATS - Provide statistics for the layout'
  contents:
  - '15.7.  Operation 65: LAYOUTSTATS - Provide statistics for the layout

    '
- title: 15.7.1.  ARGUMENT
  contents:
  - "15.7.1.  ARGUMENT\n   <CODE BEGINS>\n   struct layoutupdate4 {\n           layouttype4\
    \             lou_type;\n           opaque                  lou_body<>;\n   };\n\
    \   struct io_info4 {\n           uint64_t        ii_count;\n           uint64_t\
    \        ii_bytes;\n   };\n   struct LAYOUTSTATS4args {\n           /* CURRENT_FH:\
    \ file */\n           offset4                 lsa_offset;\n           length4\
    \                 lsa_length;\n           stateid4                lsa_stateid;\n\
    \           io_info4                lsa_read;\n           io_info4           \
    \     lsa_write;\n           deviceid4               lsa_deviceid;\n         \
    \  layoutupdate4           lsa_layoutupdate;\n   };\n   <CODE ENDS>\n"
- title: 15.7.2.  RESULT
  contents:
  - "15.7.2.  RESULT\n   <CODE BEGINS>\n   struct LAYOUTSTATS4res {\n           nfsstat4\
    \        lsr_status;\n   };\n   <CODE ENDS>\n"
- title: 15.7.3.  DESCRIPTION
  contents:
  - "15.7.3.  DESCRIPTION\n   The client can use LAYOUTSTATS to inform the metadata\
    \ server about\n   its interaction with the layout (see Section 12 of [RFC5661])\n\
    \   represented by the current filehandle, client ID (derived from the\n   session\
    \ ID in the preceding SEQUENCE operation), byte range\n   (lsa_offset and lsa_length),\
    \ and lsa_stateid.  lsa_read and lsa_write\n   allow non-layout-type-specific\
    \ statistics to be reported.\n   lsa_deviceid allows the client to specify to\
    \ which storage device the\n   statistics apply.  The remaining information the\
    \ client is presenting\n   is specific to the layout type and presented in the\
    \ lsa_layoutupdate\n   field.  Each layout type MUST define the contents of lsa_layoutupdate\n\
    \   in their respective specifications.\n   LAYOUTSTATS can be combined with IO_ADVISE\
    \ (see Section 15.5) to\n   augment the decision-making process of how the metadata\
    \ server\n   handles a file.  That is, IO_ADVISE lets the server know that a byte\n\
    \   range has a certain characteristic, but not necessarily the intensity\n  \
    \ of that characteristic.\n   The statistics are cumulative, i.e., multiple LAYOUTSTATS\
    \ updates can\n   be in flight at the same time.  The metadata server can examine\
    \ the\n   packet's timestamp to order the different calls.  The first\n   LAYOUTSTATS\
    \ sent by the client SHOULD be from the opening of the\n   file.  The choice of\
    \ how often to update the metadata server is made\n   by the client.\n   Note\
    \ that while the metadata server may return an error associated\n   with the layout\
    \ stateid or the open file, it MUST NOT return an error\n   in the processing\
    \ of the statistics.\n"
- title: '15.8.  Operation 66: OFFLOAD_CANCEL - Stop an offloaded operation'
  contents:
  - '15.8.  Operation 66: OFFLOAD_CANCEL - Stop an offloaded operation

    '
- title: 15.8.1.  ARGUMENT
  contents:
  - "15.8.1.  ARGUMENT\n   <CODE BEGINS>\n   struct OFFLOAD_CANCEL4args {\n      \
    \     /* CURRENT_FH: file to cancel */\n           stateid4        oca_stateid;\n\
    \   };\n   <CODE ENDS>\n"
- title: 15.8.2.  RESULT
  contents:
  - "15.8.2.  RESULT\n   <CODE BEGINS>\n   struct OFFLOAD_CANCEL4res {\n         \
    \  nfsstat4        ocr_status;\n   };\n   <CODE ENDS>\n"
- title: 15.8.3.  DESCRIPTION
  contents:
  - "15.8.3.  DESCRIPTION\n   OFFLOAD_CANCEL is used by the client to terminate an\
    \ asynchronous\n   operation, which is identified by both CURRENT_FH and the\n\
    \   oca_stateid.  That is, there can be multiple OFFLOAD_CANCEL\n   operations\
    \ acting on the file, and the stateid will identify to the\n   server exactly\
    \ which one is to be stopped.  Currently, there are only\n   two operations that\
    \ can decide to be asynchronous: COPY and\n   WRITE_SAME.\n   In the context of\
    \ server-to-server copy, the client can send\n   OFFLOAD_CANCEL to either the\
    \ source or destination server, albeit\n   with a different stateid.  The client\
    \ uses OFFLOAD_CANCEL to inform\n   the destination to stop the active transfer\
    \ and uses the stateid it\n   got back from the COPY operation.  The client uses\
    \ OFFLOAD_CANCEL and\n   the stateid it used in the COPY_NOTIFY to inform the\
    \ source to not\n   allow any more copying from the destination.\n   OFFLOAD_CANCEL\
    \ is also useful in situations in which the source\n   server granted a very long\
    \ or infinite lease on the destination\n   server's ability to read the source\
    \ file and all COPY operations on\n   the source file have been completed.\n"
- title: '15.9.  Operation 67: OFFLOAD_STATUS - Poll for the status of an'
  contents:
  - "15.9.  Operation 67: OFFLOAD_STATUS - Poll for the status of an\n       asynchronous\
    \ operation\n"
- title: 15.9.1.  ARGUMENT
  contents:
  - "15.9.1.  ARGUMENT\n   <CODE BEGINS>\n   struct OFFLOAD_STATUS4args {\n      \
    \     /* CURRENT_FH: destination file */\n           stateid4        osa_stateid;\n\
    \   };\n   <CODE ENDS>\n"
- title: 15.9.2.  RESULT
  contents:
  - "15.9.2.  RESULT\n   <CODE BEGINS>\n   struct OFFLOAD_STATUS4resok {\n       \
    \    length4         osr_count;\n           nfsstat4        osr_complete<1>;\n\
    \   };\n   union OFFLOAD_STATUS4res switch (nfsstat4 osr_status) {\n   case NFS4_OK:\n\
    \           OFFLOAD_STATUS4resok            osr_resok4;\n   default:\n       \
    \    void;\n   };\n   <CODE ENDS>\n"
- title: 15.9.3.  DESCRIPTION
  contents:
  - "15.9.3.  DESCRIPTION\n   OFFLOAD_STATUS can be used by the client to query the\
    \ progress of an\n   asynchronous operation, which is identified by both CURRENT_FH\
    \ and\n   the osa_stateid.  If this operation is successful, the number of\n \
    \  bytes processed is returned to the client in the osr_count field.\n   If the\
    \ optional osr_complete field is present, the asynchronous\n   operation has completed.\
    \  In this case, the status value indicates\n   the result of the asynchronous\
    \ operation.  In all cases, the server\n   will also deliver the final results\
    \ of the asynchronous operation in\n   a CB_OFFLOAD operation.\n   The failure\
    \ of this operation does not indicate the result of the\n   asynchronous operation\
    \ in any way.\n"
- title: '15.10.  Operation 68: READ_PLUS - READ data or holes from a file'
  contents:
  - '15.10.  Operation 68: READ_PLUS - READ data or holes from a file

    '
- title: 15.10.1.  ARGUMENT
  contents:
  - "15.10.1.  ARGUMENT\n   <CODE BEGINS>\n   struct READ_PLUS4args {\n          \
    \ /* CURRENT_FH: file */\n           stateid4        rpa_stateid;\n          \
    \ offset4         rpa_offset;\n           count4          rpa_count;\n   };\n\
    \   <CODE ENDS>\n"
- title: 15.10.2.  RESULT
  contents:
  - "15.10.2.  RESULT\n   <CODE BEGINS>\n   enum data_content4 {\n           NFS4_CONTENT_DATA\
    \ = 0,\n           NFS4_CONTENT_HOLE = 1\n   };\n   struct data_info4 {\n    \
    \       offset4         di_offset;\n           length4         di_length;\n  \
    \ };\n   struct data4 {\n           offset4         d_offset;\n           opaque\
    \          d_data<>;\n   };\n   union read_plus_content switch (data_content4\
    \ rpc_content) {\n   case NFS4_CONTENT_DATA:\n           data4           rpc_data;\n\
    \   case NFS4_CONTENT_HOLE:\n           data_info4      rpc_hole;\n   default:\n\
    \           void;\n   };\n   /*\n    * Allow a return of an array of contents.\n\
    \    */\n   struct read_plus_res4 {\n           bool                    rpr_eof;\n\
    \           read_plus_content       rpr_contents<>;\n   };\n   union READ_PLUS4res\
    \ switch (nfsstat4 rp_status) {\n   case NFS4_OK:\n           read_plus_res4 \
    \ rp_resok4;\n   default:\n           void;\n   };\n   <CODE ENDS>\n"
- title: 15.10.3.  DESCRIPTION
  contents:
  - "15.10.3.  DESCRIPTION\n   The READ_PLUS operation is based upon the NFSv4.1 READ\
    \ operation (see\n   Section 18.22 of [RFC5661]) and similarly reads data from\
    \ the regular\n   file identified by the current filehandle.\n   The client provides\
    \ an rpa_offset of where the READ_PLUS is to start\n   and an rpa_count of how\
    \ many bytes are to be read.  An rpa_offset of\n   zero means that data will be\
    \ read starting at the beginning of the\n   file.  If rpa_offset is greater than\
    \ or equal to the size of the\n   file, the status NFS4_OK is returned with di_length\
    \ (the data length)\n   set to zero and eof set to TRUE.\n   The READ_PLUS result\
    \ is comprised of an array of rpr_contents, each\n   of which describes a data_content4\
    \ type of data.  For NFSv4.2, the\n   allowed values are data and hole.  A server\
    \ MUST support both the\n   data type and the hole if it uses READ_PLUS.  If it\
    \ does not want to\n   support a hole, it MUST use READ.  The array contents MUST\
    \ be\n   contiguous in the file.\n   Holes SHOULD be returned in their entirety\
    \ -- clients must be\n   prepared to get more information than they requested.\
    \  Both the start\n   and the end of the hole may exceed what was requested. \
    \ If data to be\n   returned is comprised entirely of zeros, then the server SHOULD\n\
    \   return that data as a hole instead.\n   The server may elect to return adjacent\
    \ elements of the same type.\n   For example, if the server has a range of data\
    \ comprised entirely of\n   zeros and then a hole, it might want to return two\
    \ adjacent holes to\n   the client.\n   If the client specifies an rpa_count value\
    \ of zero, the READ_PLUS\n   succeeds and returns zero bytes of data.  In all\
    \ situations, the\n   server may choose to return fewer bytes than specified by\
    \ the client.\n   The client needs to check for this condition and handle the\
    \ condition\n   appropriately.\n   If the client specifies data that is entirely\
    \ contained within a hole\n   of the file (i.e., both rpa_offset and rpa_offset\
    \ + rpa_count are\n   within the hole), then the di_offset and di_length returned\
    \ MAY be\n   for the entire hole.  If the owner has a locked byte range covering\n\
    \   rpa_offset and rpa_count entirely, the di_offset and di_length MUST\n   NOT\
    \ be extended outside the locked byte range.  This result is\n   considered valid\
    \ until the file is changed (detected via the change\n   attribute).  The server\
    \ MUST provide the same semantics for the hole\n   as if the client read the region\
    \ and received zeros; the implied\n   hole's contents lifetime MUST be exactly\
    \ the same as any other\n   read data.\n   If the client specifies data by an\
    \ rpa_offset that begins in a\n   non-hole of the file but extends into a hole\
    \ (the rpa_offset +\n   rpa_count is in the hole), the server should return an\
    \ array\n   comprised of both data and a hole.  The client MUST be prepared for\n\
    \   the server to return a short read describing just the data.  The\n   client\
    \ will then issue another READ_PLUS for the remaining bytes,\n   to which the\
    \ server will respond with information about the hole in\n   the file.\n   Except\
    \ when special stateids are used, the stateid value for a\n   READ_PLUS request\
    \ represents a value returned from a previous\n   byte-range lock or share reservation\
    \ request or the stateid\n   associated with a delegation.  The stateid identifies\
    \ the associated\n   owners, if any, and is used by the server to verify that\
    \ the\n   associated locks are still valid (e.g., have not been revoked).\n  \
    \ If the read ended at the end of the file (formally, in a correctly\n   formed\
    \ READ_PLUS operation, if rpa_offset + rpa_count is equal to the\n   size of the\
    \ file) or the READ_PLUS operation extends beyond the size\n   of the file (if\
    \ rpa_offset + rpa_count is greater than the size of\n   the file), eof is returned\
    \ as TRUE; otherwise, it is FALSE.  A\n   successful READ_PLUS of an empty file\
    \ will always return eof as TRUE.\n   If the current filehandle is not an ordinary\
    \ file, an error will be\n   returned to the client.  In the case that the current\
    \ filehandle\n   represents an object of type NF4DIR, NFS4ERR_ISDIR is returned.\
    \  If\n   the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is\n\
    \   returned.  In all other cases, NFS4ERR_WRONG_TYPE is returned.\n   For a READ_PLUS\
    \ with a stateid value of all bits equal to zero, the\n   server MAY allow the\
    \ READ_PLUS to be serviced subject to mandatory\n   byte-range locks or the current\
    \ share deny modes for the file.  For a\n   READ_PLUS with a stateid value of\
    \ all bits equal to one, the server\n   MAY allow READ_PLUS operations to bypass\
    \ locking checks at the\n   server.\n   On success, the current filehandle retains\
    \ its value.\n"
- title: 15.10.3.1.  Note on Client Support of Arms of the Union
  contents:
  - "15.10.3.1.  Note on Client Support of Arms of the Union\n   It was decided not\
    \ to add a means for the client to inform the server\n   as to which arms of READ_PLUS\
    \ it would support.  In a later minor\n   version, it may become necessary for\
    \ the introduction of a new\n   operation that would allow the client to inform\
    \ the server as to\n   whether it supported the new arms of the union of data\
    \ types\n   available in READ_PLUS.\n"
- title: 15.10.4.  IMPLEMENTATION
  contents:
  - "15.10.4.  IMPLEMENTATION\n   In general, the IMPLEMENTATION notes for READ in\
    \ Section 18.22.4 of\n   [RFC5661] also apply to READ_PLUS.\n"
- title: 15.10.4.1.  Additional pNFS Implementation Information
  contents:
  - "15.10.4.1.  Additional pNFS Implementation Information\n   With pNFS, the semantics\
    \ of using READ_PLUS remains the same.  Any\n   data server MAY return a hole\
    \ result for a READ_PLUS request that it\n   receives.  When a data server chooses\
    \ to return such a result, it has\n   the option of returning information for\
    \ the data stored on that data\n   server (as defined by the data layout), but\
    \ it MUST NOT return\n   results for a byte range that includes data managed by\
    \ another data\n   server.\n   If mandatory locking is enforced, then the data\
    \ server must also\n   ensure that only information that is within the owner's\
    \ locked byte\n   range is returned.\n"
- title: '15.10.5.  READ_PLUS with Sparse Files: Example'
  contents:
  - "15.10.5.  READ_PLUS with Sparse Files: Example\n   The following table describes\
    \ a sparse file.  For each byte range,\n   the file contains either non-zero data\
    \ or a hole.  In addition, the\n   server in this example will only create a hole\
    \ if it is greater\n   than 32K.\n                        +-------------+----------+\n\
    \                        | Byte Range  | Contents |\n                        +-------------+----------+\n\
    \                        | 0-15999     | Hole     |\n                        |\
    \ 16K-31999   | Non-Zero |\n                        | 32K-255999  | Hole     |\n\
    \                        | 256K-287999 | Non-Zero |\n                        |\
    \ 288K-353999 | Hole     |\n                        | 354K-417999 | Non-Zero |\n\
    \                        +-------------+----------+\n                        \
    \   Table 7: Sparse File\n   Under the given circumstances, if a client was to\
    \ read from the file\n   with a maximum read size of 64K, the following will be\
    \ the results\n   for the given READ_PLUS calls.  This assumes that the client\
    \ has\n   already opened the file, acquired a valid stateid (\"s\" in the\n  \
    \ example), and just needs to issue READ_PLUS requests.\n   1.  READ_PLUS(s, 0,\
    \ 64K) --> NFS_OK, eof = FALSE, <data[0,32K],\n       hole[32K,224K]>.  Since\
    \ the first hole is less than the server's\n       minimum hole size, the first\
    \ 32K of the file is returned as data\n       and the remaining 32K is returned\
    \ as a hole that actually extends\n       to 256K.\n   2.  READ_PLUS(s, 32K, 64K)\
    \ --> NFS_OK, eof = FALSE, <hole[32K,224K]>.\n       The requested range was all\
    \ zeros, and the current hole begins at\n       offset 32K and is 224K in length.\
    \  Note that the client should\n       not have followed up the previous READ_PLUS\
    \ request with this\n       one, as the hole information from the previous call\
    \ extended past\n       what the client was requesting.\n   3.  READ_PLUS(s, 256K,\
    \ 64K) --> NFS_OK, eof = FALSE, <data[256K,\n       288K], hole[288K, 354K]>.\
    \  Returns an array of the 32K data and\n       the hole, which extends to 354K.\n\
    \   4.  READ_PLUS(s, 354K, 64K) --> NFS_OK, eof = TRUE, <data[354K,\n       418K]>.\
    \  Returns the final 64K of data and informs the client\n       that there is\
    \ no more data in the file.\n"
- title: '15.11.  Operation 69: SEEK - Find the next data or hole'
  contents:
  - '15.11.  Operation 69: SEEK - Find the next data or hole

    '
- title: 15.11.1.  ARGUMENT
  contents:
  - "15.11.1.  ARGUMENT\n   <CODE BEGINS>\n   enum data_content4 {\n           NFS4_CONTENT_DATA\
    \ = 0,\n           NFS4_CONTENT_HOLE = 1\n   };\n   struct SEEK4args {\n     \
    \      /* CURRENT_FH: file */\n           stateid4        sa_stateid;\n      \
    \     offset4         sa_offset;\n           data_content4   sa_what;\n   };\n\
    \   <CODE ENDS>\n"
- title: 15.11.2.  RESULT
  contents:
  - "15.11.2.  RESULT\n   <CODE BEGINS>\n   struct seek_res4 {\n           bool  \
    \          sr_eof;\n           offset4         sr_offset;\n   };\n   union SEEK4res\
    \ switch (nfsstat4 sa_status) {\n   case NFS4_OK:\n           seek_res4      \
    \ resok4;\n   default:\n           void;\n   };\n   <CODE ENDS>\n"
- title: 15.11.3.  DESCRIPTION
  contents:
  - "15.11.3.  DESCRIPTION\n   SEEK is an operation that allows a client to determine\
    \ the location\n   of the next data_content4 in a file.  It allows an implementation\
    \ of\n   the emerging extension to the lseek(2) function to allow clients to\n\
    \   determine the next hole whilst in data or the next data whilst in\n   a hole.\n\
    \   From the given sa_offset, find the next data_content4 of type sa_what\n  \
    \ in the file.  If the server cannot find a corresponding sa_what, then\n   the\
    \ status will still be NFS4_OK, but sr_eof would be TRUE.  If the\n   server can\
    \ find the sa_what, then the sr_offset is the start of that\n   content.  If the\
    \ sa_offset is beyond the end of the file, then SEEK\n   MUST return NFS4ERR_NXIO.\n\
    \   All files MUST have a virtual hole at the end of the file.  That is,\n   if\
    \ a file system does not support sparse files, then a COMPOUND with\n   {SEEK\
    \ 0 NFS4_CONTENT_HOLE;} would return a result of {SEEK 1 X;},\n   where \"X\"\
    \ was the size of the file.\n   SEEK must follow the same rules for stateids as\
    \ READ_PLUS\n   (Section 15.10.3).\n"
- title: '15.12.  Operation 70: WRITE_SAME - WRITE an ADB multiple times to a file'
  contents:
  - '15.12.  Operation 70: WRITE_SAME - WRITE an ADB multiple times to a file

    '
- title: 15.12.1.  ARGUMENT
  contents:
  - "15.12.1.  ARGUMENT\n   <CODE BEGINS>\n   enum stable_how4 {\n           UNSTABLE4\
    \       = 0,\n           DATA_SYNC4      = 1,\n           FILE_SYNC4      = 2\n\
    \   };\n   struct app_data_block4 {\n           offset4         adb_offset;\n\
    \           length4         adb_block_size;\n           length4         adb_block_count;\n\
    \           length4         adb_reloff_blocknum;\n           count4          adb_block_num;\n\
    \           length4         adb_reloff_pattern;\n           opaque          adb_pattern<>;\n\
    \   };\n   struct WRITE_SAME4args {\n           /* CURRENT_FH: file */\n     \
    \      stateid4        wsa_stateid;\n           stable_how4     wsa_stable;\n\
    \           app_data_block4 wsa_adb;\n   };\n   <CODE ENDS>\n"
- title: 15.12.2.  RESULT
  contents:
  - "15.12.2.  RESULT\n   <CODE BEGINS>\n   struct write_response4 {\n           stateid4\
    \        wr_callback_id<1>;\n           length4         wr_count;\n          \
    \ stable_how4     wr_committed;\n           verifier4       wr_writeverf;\n  \
    \ };\n   union WRITE_SAME4res switch (nfsstat4 wsr_status) {\n   case NFS4_OK:\n\
    \           write_response4         resok4;\n   default:\n           void;\n \
    \  };\n   <CODE ENDS>\n"
- title: 15.12.3.  DESCRIPTION
  contents:
  - "15.12.3.  DESCRIPTION\n   The WRITE_SAME operation writes an application data\
    \ block to the\n   regular file identified by the current filehandle (see\n  \
    \ WRITE SAME (10) in [T10-SBC2]).  The target file is specified by the\n   current\
    \ filehandle.  The data to be written is specified by an\n   app_data_block4 structure\
    \ (Section 8.1.1).  The client specifies with\n   the wsa_stable parameter the\
    \ method of how the data is to be\n   processed by the server.  It is treated\
    \ like the stable parameter in\n   the NFSv4.1 WRITE operation (see Section 18.32.3\
    \ of [RFC5661]).\n   A successful WRITE_SAME will construct a reply for wr_count,\n\
    \   wr_committed, and wr_writeverf as per the NFSv4.1 WRITE operation\n   results.\
    \  If wr_callback_id is set, it indicates an asynchronous\n   reply (see Section\
    \ 15.12.3.1).\n   As it is an OPTIONAL operation, WRITE_SAME has to support\n\
    \   NFS4ERR_NOTSUPP.  As it is an extension of WRITE, it has to support\n   all\
    \ of the errors returned by WRITE.  If the client supports\n   WRITE_SAME, it\
    \ MUST support CB_OFFLOAD.\n   If the server supports ADBs, then it MUST support\
    \ the WRITE_SAME\n   operation.  The server has no concept of the structure imposed\
    \ by the\n   application.  It is only when the application writes to a section\
    \ of\n   the file does order get imposed.  In order to detect corruption even\n\
    \   before the application utilizes the file, the application will want\n   to\
    \ initialize a range of ADBs using WRITE_SAME.\n   When the client invokes the\
    \ WRITE_SAME operation, it wants to record\n   the block structure described by\
    \ the app_data_block4 into the file.\n   When the server receives the WRITE_SAME\
    \ operation, it MUST populate\n   adb_block_count ADBs in the file, starting at\
    \ adb_offset.  The block\n   size will be given by adb_block_size.  The ADBN (if\
    \ provided) will\n   start at adb_reloff_blocknum, and each block will be monotonically\n\
    \   numbered, starting from adb_block_num in the first block.  The\n   pattern\
    \ (if provided) will be at adb_reloff_pattern of each block and\n   will be provided\
    \ in adb_pattern.\n   The server SHOULD return an asynchronous result if it can\
    \ determine\n   that the operation will be long-running (see Section 15.12.3.1).\n\
    \   Once either the WRITE_SAME finishes synchronously or the server uses\n   CB_OFFLOAD\
    \ to inform the client of the asynchronous completion of the\n   WRITE_SAME, the\
    \ server MUST return the ADBs to clients as data.\n"
- title: 15.12.3.1.  Asynchronous Transactions
  contents:
  - "15.12.3.1.  Asynchronous Transactions\n   ADB initialization may cause a server\
    \ to decide to service the\n   operation asynchronously.  If it decides to do\
    \ so, it sets the\n   stateid in wr_callback_id to be that of the wsa_stateid.\
    \  If it does\n   not set the wr_callback_id, then the result is synchronous.\n\
    \   When the client determines that the reply will be given\n   asynchronously,\
    \ it should not assume anything about the contents of\n   what it wrote until\
    \ it is informed by the server that the operation\n   is complete.  It can use\
    \ OFFLOAD_STATUS (Section 15.9) to monitor the\n   operation and OFFLOAD_CANCEL\
    \ (Section 15.8) to cancel the operation.\n   An example of an asynchronous WRITE_SAME\
    \ is shown in Figure 6.  Note\n   that, as with the COPY operation, WRITE_SAME\
    \ must provide a stateid\n   for tracking the asynchronous operation.\n     Client\
    \                                  Server\n        +                         \
    \             +\n        |                                      |\n        |---\
    \ OPEN ---------------------------->| Client opens\n        |<------------------------------------/|\
    \ the file\n        |                                      |\n        |--- WRITE_SAME\
    \ ---------------------->| Client initializes\n        |<------------------------------------/|\
    \ an ADB\n        |                                      |\n        |        \
    \                              |\n        |--- OFFLOAD_STATUS ------------------>|\
    \ Client may poll\n        |<------------------------------------/| for status\n\
    \        |                                      |\n        |                 \
    \ .                   | Multiple OFFLOAD_STATUS\n        |                  .\
    \                   | operations may be sent.\n        |                  .  \
    \                 |\n        |                                      |\n      \
    \  |<-- CB_OFFLOAD -----------------------| Server reports results\n        |\\\
    ------------------------------------>|\n        |                            \
    \          |\n        |--- CLOSE --------------------------->| Client closes\n\
    \        |<------------------------------------/| the file\n        |        \
    \                              |\n        |                                  \
    \    |\n                   Figure 6: An Asynchronous WRITE_SAME\n   When CB_OFFLOAD\
    \ informs the client of the successful WRITE_SAME, the\n   write_response4 embedded\
    \ in the operation will provide the necessary\n   information that a synchronous\
    \ WRITE_SAME would have provided.\n   Regardless of whether the operation is asynchronous\
    \ or synchronous,\n   it MUST still support the COMMIT operation semantics as\
    \ outlined in\n   Section 18.3 of [RFC5661].  That is, COMMIT works on one or\
    \ more\n   WRITE operations, and the WRITE_SAME operation can appear as several\n\
    \   WRITE operations to the server.  The client can use locking\n   operations\
    \ to control the behavior on the server with respect to\n   long-running asynchronous\
    \ WRITE_SAME operations.\n"
- title: 15.12.3.2.  Error Handling of a Partially Complete WRITE_SAME
  contents:
  - "15.12.3.2.  Error Handling of a Partially Complete WRITE_SAME\n   WRITE_SAME\
    \ will clone adb_block_count copies of the given ADB in\n   consecutive order\
    \ in the file, starting at adb_offset.  An error can\n   occur after writing the\
    \ Nth ADB to the file.  WRITE_SAME MUST appear\n   to populate the range of the\
    \ file as if the client used WRITE to\n   transfer the instantiated ADBs.  That\
    \ is, the contents of the range\n   will be easy for the client to determine in\
    \ the case of a partially\n   complete WRITE_SAME.\n"
- title: '15.13.  Operation 71: CLONE - Clone a range of a file into another file'
  contents:
  - '15.13.  Operation 71: CLONE - Clone a range of a file into another file

    '
- title: 15.13.1.  ARGUMENT
  contents:
  - "15.13.1.  ARGUMENT\n   <CODE BEGINS>\n   struct CLONE4args {\n           /* SAVED_FH:\
    \ source file */\n           /* CURRENT_FH: destination file */\n           stateid4\
    \        cl_src_stateid;\n           stateid4        cl_dst_stateid;\n       \
    \    offset4         cl_src_offset;\n           offset4         cl_dst_offset;\n\
    \           length4         cl_count;\n   };\n   <CODE ENDS>\n"
- title: 15.13.2.  RESULT
  contents:
  - "15.13.2.  RESULT\n   <CODE BEGINS>\n   struct CLONE4res {\n           nfsstat4\
    \        cl_status;\n   };\n   <CODE ENDS>\n"
- title: 15.13.3.  DESCRIPTION
  contents:
  - "15.13.3.  DESCRIPTION\n   The CLONE operation is used to clone file content from\
    \ a source file\n   specified by the SAVED_FH value into a destination file specified\
    \ by\n   CURRENT_FH without actually copying the data, e.g., by using a\n   copy-on-write\
    \ mechanism.\n   Both SAVED_FH and CURRENT_FH must be regular files.  If either\n\
    \   SAVED_FH or CURRENT_FH is not a regular file, the operation MUST fail\n  \
    \ and return NFS4ERR_WRONG_TYPE.\n   The ca_dst_stateid MUST refer to a stateid\
    \ that is valid for a WRITE\n   operation and follows the rules for stateids in\
    \ Sections 8.2.5 and\n   18.32.3 of [RFC5661].  The ca_src_stateid MUST refer\
    \ to a stateid\n   that is valid for a READ operation and follows the rules for\
    \ stateids\n   in Sections 8.2.5 and 18.22.3 of [RFC5661].  If either stateid\
    \ is\n   invalid, then the operation MUST fail.\n   The cl_src_offset is the starting\
    \ offset within the source file from\n   which the data to be cloned will be obtained,\
    \ and the cl_dst_offset\n   is the starting offset of the target region into which\
    \ the cloned\n   data will be placed.  An offset of 0 (zero) indicates the start\
    \ of\n   the respective file.  The number of bytes to be cloned is obtained\n\
    \   from cl_count, except that a cl_count of 0 (zero) indicates that the\n   number\
    \ of bytes to be cloned is the count of bytes between\n   cl_src_offset and the\
    \ EOF of the source file.  Both cl_src_offset and\n   cl_dst_offset must be aligned\
    \ to the clone block size\n   (Section 12.2.1).  The number of bytes to be cloned\
    \ must be a\n   multiple of the clone block size, except in the case in which\n\
    \   cl_src_offset plus the number of bytes to be cloned is equal to the\n   source\
    \ file size.\n   If the source offset or the source offset plus count is greater\
    \ than\n   the size of the source file, the operation MUST fail with\n   NFS4ERR_INVAL.\
    \  The destination offset or destination offset plus\n   count may be greater\
    \ than the size of the destination file.\n   If SAVED_FH and CURRENT_FH refer\
    \ to the same file and the source and\n   target ranges overlap, the operation\
    \ MUST fail with NFS4ERR_INVAL.\n   If the target area of the CLONE operation\
    \ ends beyond the end of the\n   destination file, the offset at the end of the\
    \ target area will\n   determine the new size of the destination file.  The contents\
    \ of any\n   block not part of the target area will be the same as if the file\n\
    \   size were extended by a WRITE.\n   If the area to be cloned is not a multiple\
    \ of the clone block size\n   and the size of the destination file is past the\
    \ end of the target\n   area, the area between the end of the target area and\
    \ the next\n   multiple of the clone block size will be zeroed.\n   The CLONE\
    \ operation is atomic in that other operations may not see\n   any intermediate\
    \ states between the state of the two files before the\n   operation and after\
    \ the operation.  READs of the destination file\n   will never see some blocks\
    \ of the target area cloned without all of\n   them being cloned.  WRITEs of the\
    \ source area will either have no\n   effect on the data of the target file or\
    \ be fully reflected in the\n   target area of the destination file.\n   The completion\
    \ status of the operation is indicated by cr_status.\n"
- title: 16.  NFSv4.2 Callback Operations
  contents:
  - '16.  NFSv4.2 Callback Operations

    '
- title: '16.1.  Operation 15: CB_OFFLOAD - Report the results of an asynchronous'
  contents:
  - "16.1.  Operation 15: CB_OFFLOAD - Report the results of an asynchronous\n   \
    \    operation\n"
- title: 16.1.1.  ARGUMENT
  contents:
  - "16.1.1.  ARGUMENT\n   <CODE BEGINS>\n   struct write_response4 {\n          \
    \ stateid4        wr_callback_id<1>;\n           length4         wr_count;\n \
    \          stable_how4     wr_committed;\n           verifier4       wr_writeverf;\n\
    \   };\n   union offload_info4 switch (nfsstat4 coa_status) {\n   case NFS4_OK:\n\
    \           write_response4 coa_resok4;\n   default:\n           length4     \
    \    coa_bytes_copied;\n   };\n   struct CB_OFFLOAD4args {\n           nfs_fh4\
    \         coa_fh;\n           stateid4        coa_stateid;\n           offload_info4\
    \   coa_offload_info;\n   };\n   <CODE ENDS>\n"
- title: 16.1.2.  RESULT
  contents:
  - "16.1.2.  RESULT\n   <CODE BEGINS>\n   struct CB_OFFLOAD4res {\n           nfsstat4\
    \        cor_status;\n   };\n   <CODE ENDS>\n"
- title: 16.1.3.  DESCRIPTION
  contents:
  - "16.1.3.  DESCRIPTION\n   CB_OFFLOAD is used to report to the client the results\
    \ of an\n   asynchronous operation, e.g., server-side COPY or WRITE_SAME.  The\n\
    \   coa_fh and coa_stateid identify the transaction, and the coa_status\n   indicates\
    \ success or failure.  The coa_resok4.wr_callback_id MUST NOT\n   be set.  If\
    \ the transaction failed, then the coa_bytes_copied\n   contains the number of\
    \ bytes copied before the failure occurred.  The\n   coa_bytes_copied value indicates\
    \ the number of bytes copied but not\n   which specific bytes have been copied.\n\
    \   If the client supports any of the following operations:\n   COPY:  for both\
    \ intra-server and inter-server asynchronous copies\n   WRITE_SAME:  for ADB initialization\n\
    \   then the client is REQUIRED to support the CB_OFFLOAD operation.\n   There\
    \ is a potential race between the reply to the original\n   transaction on the\
    \ forechannel and the CB_OFFLOAD callback on the\n   backchannel.  Section 2.10.6.3\
    \ of [RFC5661] describes how to handle\n   this type of issue.\n   Upon success,\
    \ the coa_resok4.wr_count presents for each operation:\n   COPY:  the total number\
    \ of bytes copied\n   WRITE_SAME:  the same information that a synchronous WRITE_SAME\
    \ would\n      provide\n"
- title: 17.  Security Considerations
  contents:
  - "17.  Security Considerations\n   NFSv4.2 has all of the security concerns present\
    \ in NFSv4.1 (see\n   Section 21 of [RFC5661]), as well as those present in the\
    \ server-side\n   copy (see Section 4.9) and in Labeled NFS (see Section 9.6).\n"
- title: 18.  IANA Considerations
  contents:
  - "18.  IANA Considerations\n   The IANA considerations for Labeled NFS are addressed\
    \ in [RFC7569].\n"
- title: 19.  References
  contents:
  - '19.  References

    '
- title: 19.1.  Normative References
  contents:
  - "19.1.  Normative References\n   [posix_fadvise]\n              The Open Group,\
    \ \"Section 'posix_fadvise()' of System\n              Interfaces of The Open\
    \ Group Base Specifications Issue 7\",\n              IEEE Std 1003.1, 2016 Edition\
    \ (HTML Version),\n              ISBN 1937218812, September 2016,\n          \
    \    <http://www.opengroup.org/>.\n   [posix_fallocate]\n              The Open\
    \ Group, \"Section 'posix_fallocate()' of System\n              Interfaces of\
    \ The Open Group Base Specifications Issue 7\",\n              IEEE Std 1003.1,\
    \ 2016 Edition (HTML Version),\n              ISBN 1937218812, September 2016,\n\
    \              <http://www.opengroup.org/>.\n   [RFC2119]  Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,\
    \ RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, DOI 10.17487/RFC3986, January 2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n      \
    \        \"Network File System (NFS) Version 4 Minor Version 1\n             \
    \ Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010,\n              <http://www.rfc-editor.org/info/rfc5661>.\n\
    \   [RFC5662]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n      \
    \        \"Network File System (NFS) Version 4 Minor Version 1\n             \
    \ External Data Representation Standard (XDR) Description\",\n              RFC\
    \ 5662, DOI 10.17487/RFC5662, January 2010,\n              <http://www.rfc-editor.org/info/rfc5662>.\n\
    \   [RFC7569]  Quigley, D., Lu, J., and T. Haynes, \"Registry\n              Specification\
    \ for Mandatory Access Control (MAC) Security\n              Label Formats\",\
    \ RFC 7569, DOI 10.17487/RFC7569, July 2015,\n              <http://www.rfc-editor.org/info/rfc7569>.\n\
    \   [RFC7861]  Adamson, A. and N. Williams, \"Remote Procedure Call (RPC)\n  \
    \            Security Version 3\", RFC 7861, DOI 10.17487/RFC7861,\n         \
    \     November 2016, <http://www.rfc-editor.org/info/rfc7861>.\n   [RFC7863] \
    \ Haynes, T., \"Network File System (NFS) Version 4 Minor\n              Version\
    \ 2 External Data Representation Standard (XDR)\n              Description\",\
    \ RFC 7863, DOI 10.17487/RFC7863,\n              November 2016, <http://www.rfc-editor.org/info/rfc7863>.\n"
- title: 19.2.  Informative References
  contents:
  - "19.2.  Informative References\n   [Ashdown08]\n              Ashdown, L., \"\
    Chapter 15: Validating Database Files and\n              Backups\", Oracle Database\
    \ Backup and Recovery User's\n              Guide 11g Release 1 (11.1), August\
    \ 2008,\n              <http://download.oracle.com/docs/cd/B28359_01/backup.111/\n\
    \              b28270/rcmvalid.htm>.\n   [Baira08]  Bairavasundaram, L., Goodson,\
    \ G., Schroeder, B.,\n              Arpaci-Dusseau, A., and R. Arpaci-Dusseau,\
    \ \"An Analysis of\n              Data Corruption in the Storage Stack\", Proceedings\
    \ of the\n              6th USENIX Symposium on File and Storage Technologies\n\
    \              (FAST '08), 2008,\n              <http://www.usenix.org/events/fast08/tech/full_papers/\n\
    \              bairavasundaram/bairavasundaram.pdf>.\n   [IESG08]   IESG, \"IESG\
    \ Processing of RFC Errata for the IETF Stream\",\n              July 2008, <https://www.ietf.org/iesg/statement/\n\
    \              errata-processing.html>.\n   [LB96]     LaPadula, L. and D. Bell,\
    \ \"MITRE Technical Report 2547,\n              Volume II\", Journal of Computer\
    \ Security, Volume 4,\n              Issue 2-3, 239-263, IOS Press, Amsterdam,\
    \ The Netherlands,\n              January 1996.\n   [McDougall07]\n          \
    \    McDougall, R. and J. Mauro, \"Section 11.4.3: Detecting\n              Memory\
    \ Corruption\", Solaris Internals: Solaris 10 and\n              OpenSolaris Kernel\
    \ Architecture, 2nd Edition, 2007.\n   [NFSv4-Versioning]\n              Noveck,\
    \ D., \"Rules for NFSv4 Extensions and Minor\n              Versions\", Work in\
    \ Progress,\n              draft-ietf-nfsv4-versioning-07, October 2016.\n   [RFC959]\
    \   Postel, J. and J. Reynolds, \"File Transfer Protocol\",\n              STD\
    \ 9, RFC 959, DOI 10.17487/RFC0959, October 1985,\n              <http://www.rfc-editor.org/info/rfc959>.\n\
    \   [RFC1108]  Kent, S., \"U.S. Department of Defense Security Options for\n \
    \             the Internet Protocol\", RFC 1108, DOI 10.17487/RFC1108,\n     \
    \         November 1991, <http://www.rfc-editor.org/info/rfc1108>.\n   [RFC2401]\
    \  Kent, S. and R. Atkinson, \"Security Architecture for the\n              Internet\
    \ Protocol\", RFC 2401, DOI 10.17487/RFC2401,\n              November 1998, <http://www.rfc-editor.org/info/rfc2401>.\n\
    \   [RFC4506]  Eisler, M., Ed., \"XDR: External Data Representation\n        \
    \      Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506,\n              May\
    \ 2006, <http://www.rfc-editor.org/info/rfc4506>.\n   [RFC4949]  Shirey, R., \"\
    Internet Security Glossary, Version 2\",\n              FYI 36, RFC 4949, DOI\
    \ 10.17487/RFC4949, August 2007,\n              <http://www.rfc-editor.org/info/rfc4949>.\n\
    \   [RFC5663]  Black, D., Fridella, S., and J. Glasgow, \"Parallel NFS\n     \
    \         (pNFS) Block/Volume Layout\", RFC 5663,\n              DOI 10.17487/RFC5663,\
    \ January 2010,\n              <http://www.rfc-editor.org/info/rfc5663>.\n   [RFC7204]\
    \  Haynes, T., \"Requirements for Labeled NFS\", RFC 7204,\n              DOI\
    \ 10.17487/RFC7204, April 2014,\n              <http://www.rfc-editor.org/info/rfc7204>.\n\
    \   [RFC7230]  Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext\n         \
    \     Transfer Protocol (HTTP/1.1): Message Syntax and Routing\",\n          \
    \    RFC 7230, DOI 10.17487/RFC7230, June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7530]  Haynes, T., Ed., and D. Noveck, Ed., \"Network File System\n  \
    \            (NFS) Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530,\n   \
    \           March 2015, <http://www.rfc-editor.org/info/rfc7530>.\n   [Strohm11]\
    \ Strohm, R., \"Chapter 2: Data Blocks, Extents, and\n              Segments\"\
    , Oracle Database Concepts 11g Release 1 (11.1),\n              January 2011,\n\
    \              <http://download.oracle.com/docs/cd/B28359_01/server.111/\n   \
    \           b28318/logical.htm>.\n   [T10-SBC2] Elliott, R., Ed., \"ANSI INCITS\
    \ 405-2005, Information\n              Technology - SCSI Block Commands - 2 (SBC-2)\"\
    ,\n              November 2004,\n              <ftp://www.t10.org/t10/document.05/05-344r0.pdf>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Tom Haynes would like to thank NetApp, Inc. for its funding\
    \ of his\n   time on this project.\n   For the topic \"sharing change attribute\
    \ implementation\n   characteristics with NFSv4 clients\", the original document\
    \ was by\n   Trond Myklebust.\n   For the NFS server-side copy, the original document\
    \ was by James\n   Lentini, Mike Eisler, Deepak Kenchammana, Anshul Madan, and\
    \ Rahul\n   Iyer.  Tom Talpey co-authored an unpublished version of that\n   document.\
    \  It was also reviewed by a number of individuals: Pranoop\n   Erasani, Tom Haynes,\
    \ Arthur Lent, Trond Myklebust, Dave Noveck,\n   Theresa Lingutla-Raj, Manjunath\
    \ Shankararao, Satyam Vaghani, and Nico\n   Williams.  Anna Schumaker's early\
    \ prototyping experience helped us\n   avoid some traps.  Also, both Olga Kornievskaia\
    \ and Andy Adamson\n   brought implementation experience to the use of copy stateids\
    \ in the\n   inter-server copy.  Jorge Mora was able to optimize the handling\
    \ of\n   errors for the result of COPY.\n   For the NFS space reservation operations,\
    \ the original document was\n   by Mike Eisler, James Lentini, Manjunath Shankararao,\
    \ and Rahul Iyer.\n   For the sparse file support, the original document was by\
    \ Dean\n   Hildebrand and Marc Eshel.  Valuable input and advice was received\n\
    \   from Sorin Faibish, Bruce Fields, Benny Halevy, Trond Myklebust, and\n   Richard\
    \ Scheffenegger.\n   For the application I/O hints, the original document was\
    \ by Dean\n   Hildebrand, Mike Eisler, Trond Myklebust, and Sam Falkner.  Some\n\
    \   early reviewers included Benny Halevy and Pranoop Erasani.\n   For Labeled\
    \ NFS, the original document was by David Quigley, James\n   Morris, Jarrett Lu,\
    \ and Tom Haynes.  Peter Staubach, Trond Myklebust,\n   Stephen Smalley, Sorin\
    \ Faibish, Nico Williams, and David Black also\n   contributed in the final push\
    \ to get this accepted.\n   Christoph Hellwig was very helpful in getting the\
    \ WRITE_SAME\n   semantics to model more of what T10 was doing for WRITE SAME\
    \ (10)\n   [T10-SBC2].  And he led the push to get space reservations to more\n\
    \   closely model the posix_fallocate() operation.\n   Andy Adamson picked up\
    \ the RPCSEC_GSSv3 work, which enabled both\n   Labeled NFS and server-side copy\
    \ to provide more secure options.\n   Christoph Hellwig provided the update to\
    \ GETDEVICELIST.\n   Jorge Mora provided a very detailed review and caught some\
    \ important\n   issues with the tables.\n   During the review process, Talia Reyes-Ortiz\
    \ helped the sessions run\n   smoothly.  While many people contributed here and\
    \ there, the core\n   reviewers were Andy Adamson, Pranoop Erasani, Bruce Fields,\
    \ Chuck\n   Lever, Trond Myklebust, David Noveck, Peter Staubach, and Mike\n \
    \  Kupfer.\n   Elwyn Davies was the General Area Reviewer for this document, and\
    \ his\n   insights as to the relationship of this document and both [RFC5661]\n\
    \   and [RFC7530] were very much appreciated!\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Thomas Haynes\n   Primary Data, Inc.\n   4300 El Camino\
    \ Real Ste 100\n   Los Altos, CA  94022\n   United States of America\n   Phone:\
    \ +1 408 215 1519\n   Email: thomas.haynes@primarydata.com\n"
