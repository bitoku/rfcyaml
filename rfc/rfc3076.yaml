- title: __initial_text__
  contents:
  - '                       Canonical XML Version 1.0

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Any XML (Extensible Markup Language) document is part of a set of\
    \ XML\n   documents that are logically equivalent within an application\n   context,\
    \ but which vary in physical representation based on syntactic\n   changes permitted\
    \ by XML 1.0 and Namespaces in XML.  This\n   specification describes a method\
    \ for generating a physical\n   representation, the canonical form, of an XML\
    \ document that accounts\n   for the permissible changes.  Except for limitations\
    \ regarding a few\n   unusual cases, if two documents have the same canonical\
    \ form, then\n   the two documents are logically equivalent within the given\n\
    \   application context.  Note that two documents may have differing\n   canonical\
    \ forms yet still be equivalent in a given context based on\n   application-specific\
    \ equivalence rules for which no generalized XML\n   specification could account.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction...............................................\
    \  2\n   1.1 Terminology...............................................  3\n \
    \  1.2 Applications..............................................  4\n   1.3 Limitations...............................................\
    \  4\n   2. XML Canonicalization.......................................  6\n \
    \  2.1 Data Model................................................  6\n   2.2 Document\
    \ Order............................................ 10\n   2.3 Processing Model..........................................\
    \ 10\n   2.4 Document Subsets.......................................... 13\n \
    \  3. Examples of XML Canonicalization........................... 14\n   3.1 PIs,\
    \ Comments, and Outside of Document Element............ 14\n   3.2 Whitespace\
    \ in Document Content............................ 15\n   3.3 Start and End Tags........................................\
    \ 16\n   3.4 Character Modifications and Character References.......... 17\n \
    \  3.5 Entity References......................................... 19\n   3.6 UTF-8\
    \ Encoding............................................ 19\n   3.7 Document Subsets..........................................\
    \ 20\n   4. Resolutions................................................ 21\n \
    \  4.1 No XML Declaration........................................ 21\n   4.2 No\
    \ Character Model Normalization.......................... 21\n   4.3 Handling\
    \ of Whitespace Outside Document Element........... 22\n   4.4 No Namespace Prefix\
    \ Rewriting............................. 22\n   4.5 Order of Namespace Declarations\
    \ and Attributes............ 23\n   4.6 Superfluous Namespace Declarations........................\
    \ 23\n   4.7 Propagation of Default Namespace Declaration in Document\n      \
    \ Subsets................................................... 24\n   4.8 Sorting\
    \ Attributes by Namespace URI....................... 24\n   Security Considerations.......................................\
    \ 24\n   References.................................................... 25\n \
    \  Author's Address.............................................. 26\n   Acknowledgements..............................................\
    \ 27\n   Full Copyright Statement...................................... 28\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The XML 1.0 Recommendation [XML] specifies the syntax of\
    \ a class of\n   resources called XML documents.  The Namespaces in XML Recommendation\n\
    \   [Names] specifies additional syntax and semantics for XML documents.\n   It\
    \ is possible for XML documents which are equivalent for the\n   purposes of many\
    \ applications to differ in physical representation.\n   For example, they may\
    \ differ in their entity structure, attribute\n   ordering, and character encoding.\
    \  It is the goal of this\n   specification to establish a method for determining\
    \ whether two\n   documents are identical, or whether an application has not changed\
    \ a\n   document, except for transformations permitted by XML 1.0 and\n   Namespaces.\n"
- title: 1.1 Terminology
  contents:
  - "1.1 Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [Keywords].\n   See [Names] for the definition of QName.\n   A document\
    \ subset is a portion of an XML document indicated by a\n   node-set that may\
    \ not include all of the nodes in the document.\n   The canonical form of an XML\
    \ document is physical representation of\n   the document produced by the method\
    \ described in this specification.\n   The changes are summarized in the following\
    \ list:\n       * The document is encoded in UTF-8\n       * Line breaks normalized\
    \ to #xA on input, before parsing\n       * Attribute values are normalized, as\
    \ if by a validating\n         processor\n       * Character and parsed entity\
    \ references are replaced\n       * CDATA sections are replaced with their character\
    \ content\n       * The XML declaration and document type declaration (DTD) are\n\
    \         removed\n       * Empty elements are converted to start-end tag pairs\n\
    \       * Whitespace outside of the document element and within start and\n  \
    \       end tags is normalized\n       * All whitespace in character content is\
    \ retained (excluding\n         characters removed during line feed normalization)\n\
    \       * Attribute value delimiters are set to quotation marks (double\n    \
    \     quotes)\n       * Special characters in attribute values and character content\n\
    \         are replaced by character references\n       * Superfluous namespace\
    \ declarations are removed from each\n         element\n       * Default attributes\
    \ are added to each element\n       * Lexicographic order is imposed on the namespace\
    \ declarations\n         and attributes of each element\n   The term canonical\
    \ XML refers to XML that is in canonical form.  The\n   XML canonicalization method\
    \ is the algorithm defined by this\n   specification that generates the canonical\
    \ form of a given XML\n   document or document subset.  The term XML canonicalization\
    \ refers to\n   the process of applying the XML canonicalization method to an\
    \ XML\n   document or document subset.\n   The XPath 1.0 Recommendation [XPath]\
    \ defines the term node-set and\n   specifies a data model for representing an\
    \ input XML document as a\n   set of nodes of various types (element, attribute,\
    \ namespace, text,\n   comment, processing instruction, and root).  The nodes\
    \ are included\n   in or excluded from a node-set based on the evaluation of an\n\
    \   expression.  Within this specification, a node-set is used to\n   directly\
    \ indicate whether or not each node should be rendered in the\n   canonical form\
    \ (in this sense, it is used as a formal mathematical\n   set).  A node that is\
    \ excluded from the set is not rendered in the\n   canonical form being generated,\
    \ even if its parent node is included\n   in the node-set.  However, an omitted\
    \ node may still impact the\n   rendering of its descendants (e.g., by augmenting\
    \ the namespace\n   context of the descendants).\n"
- title: 1.2 Applications
  contents:
  - "1.2 Applications\n   Since the XML 1.0 Recommendation [XML] and the Namespaces\
    \ in XML\n   Recommendation [Names] define multiple syntactic methods for\n  \
    \ expressing the same information, XML applications tend to take\n   liberties\
    \ with changes that have no impact on the information content\n   of the document.\
    \  XML canonicalization is designed to be useful to\n   applications that require\
    \ the ability to test whether the information\n   content of a document or document\
    \ subset has been changed.  This is\n   done by comparing the canonical form of\
    \ the original document before\n   application processing with the canonical form\
    \ of the document result\n   of the application processing.\n   For example, a\
    \ digital signature over the canonical form of an XML\n   document or document\
    \ subset would allow the signature digest\n   calculations to be oblivious to\
    \ changes in the original document's\n   physical representation, provided that\
    \ the changes are defined to be\n   logically equivalent by the XML 1.0 or Namespaces\
    \ in XML.  During\n   signature generation, the digest is computed over the canonical\
    \ form\n   of the document.  The document is then transferred to the relying\n\
    \   party, which validates the signature by reading the document and\n   computing\
    \ a digest of the canonical form of the received document.\n   The equivalence\
    \ of the digests computed by the signing and relying\n   parties (and hence the\
    \ equivalence of the canonical forms over which\n   they were computed) ensures\
    \ that the information content of the\n   document has not been altered since\
    \ it was signed.\n"
- title: 1.3 Limitations
  contents:
  - "1.3 Limitations\n   Two XML documents may have differing information content\
    \ that is\n   nonetheless logically equivalent within a given application context.\n\
    \   Although two XML documents are equivalent (aside from limitations\n   given\
    \ in this section) if their canonical forms are identical, it is\n   not a goal\
    \ of this work to establish a method such that two XML\n   documents are equivalent\
    \ if and only if their canonical forms are\n   identical.  Such a method is unachievable,\
    \ in part due to\n   application-specific rules such as those governing unimportant\n\
    \   whitespace and equivalent data (e.g., <color>black</color> versus\n   <color>rgb(0,0,0)</color>).\
    \  There are also equivalencies established\n   by other W3C Recommendations and\
    \ Working Drafts.  Accounting for\n   these additional equivalence rules is beyond\
    \ the scope of this work.\n   They can be applied by the application or become\
    \ the subject of\n   future specifications.\n   The canonical form of an XML document\
    \ may not be completely\n   operational within the application context, though\
    \ the circumstances\n   under which this occurs are unusual.  This problem may\
    \ be of concern\n   in certain applications since the canonical form of a document\
    \ and\n   the canonical form of the canonical form of the document are\n   equivalent.\
    \  For example, in a digital signature application, the\n   canonical form can\
    \ be substituted for the original document without\n   changing the digest calculation.\
    \  However, the security risk only\n   occurs in the unusual circumstances described\
    \ below, which can all be\n   resolved or at least detected prior to digital signature\
    \ generation.\n   The difficulties arise due to the loss of the following information\n\
    \   not available in the data model:\n      1. base URI, especially in content\
    \ derived from the replacement\n         text of external general parsed entity\
    \ references\n      2. notations and external unparsed entity references\n   \
    \   3. attribute types in the document type declaration\n   In the first case,\
    \ note that a document containing a relative URI\n   [URI] is only operational\
    \ when accessed from a specific URI that\n   provides the proper base URI.  In\
    \ addition, if the document contains\n   external general parsed entity references\
    \ to content containing\n   relative URIs, then the relative URIs will not be\
    \ operational in the\n   canonical form, which replaces the entity reference with\
    \ internal\n   content (thereby implicitly changing the default base URI of that\n\
    \   content).  Both of these problems can typically be solved by adding\n   support\
    \ for the xml:base attribute [XBase] to the application, then\n   adding appropriate\
    \ xml:base attributes to document element and all\n   top-level elements in external\
    \ entities.  In addition, applications\n   often have an opportunity to resolve\
    \ relative URIs prior to the need\n   for a canonical form.  For example, in a\
    \ digital signature\n   application, a document is often retrieved and processed\
    \ prior to\n   signature generation.  The processing SHOULD create a new document\
    \ in\n   which relative URIs have been converted to absolute URIs, thereby\n \
    \  mitigating any security risk for the new document.\n   In the second case,\
    \ the loss of external unparsed entity references\n   and the notations that bind\
    \ them to applications means that canonical\n   forms cannot properly distinguish\
    \ among XML documents that\n   incorporate unparsed data via this mechanism. \
    \ This is an unusual\n   case precisely because most XML processors currently\
    \ discard the\n   document type declaration, which discards the notation, the\
    \ entity's\n   binding to a URI, and the attribute type that binds the attribute\n\
    \   value to an entity name.  For documents that must be subjected to\n   more\
    \ than one XML processor, the XML design typically indicates a\n   reference to\
    \ unparsed data using a URI in the attribute value.\n   In the third case, the\
    \ loss of attribute types can affect the\n   canonical form in different ways\
    \ depending on the type.  Attributes\n   of type ID cease to be ID attributes.\
    \  Hence, any XPath expressions\n   that refer to the canonical form using the\
    \ id() function cease to\n   operate.  The attribute types ENTITY and ENTITIES\
    \ are not part of\n   this case; they are covered in the second case above.  Attributes\
    \ of\n   enumerated type and of type ID, IDREF, IDREFS, NMTOKEN, NMTOKENS, and\n\
    \   NOTATION fail to be appropriately constrained during future attempts\n   to\
    \ change the attribute value if the canonical form replaces the\n   original document\
    \ during application processing.  Applications can\n   avoid the difficulties\
    \ of this case by ensuring that an appropriate\n   document type declaration is\
    \ prepended prior to using the canonical\n   form in further XML processing. \
    \ This is likely to be an easy task\n   since attribute lists are usually acquired\
    \ from a standard external\n   DTD subset, and any entity and notation declarations\
    \ not also in the\n   external DTD subset are typically constructed from application\n\
    \   configuration information and added to the internal DTD subset.\n   While\
    \ these limitations are not severe, it would be possible to\n   resolve them in\
    \ a future version of XML canonicalization if, for\n   example, a new version\
    \ of XPath were created based on the XML\n   Information Set [Infoset] currently\
    \ under development at the W3C.\n"
- title: 2. XML Canonicalization
  contents:
  - '2. XML Canonicalization

    '
- title: 2.1 Data Model
  contents:
  - "2.1 Data Model\n   The data model defined in the XPath 1.0 Recommendation [XPath]\
    \ is\n   used to represent the input XML document or document subset.\n   Implementations\
    \ SHOULD but need not be based on an XPath\n   implementation.  XML canonicalization\
    \ is defined in terms of the\n   XPath definition of a node-set, and implementations\
    \ MUST produce\n   equivalent results.\n   The first parameter of input to the\
    \ XML canonicalization method is\n   either an XPath node-set or an octet stream\
    \ containing a well-formed\n   XML document.  Implementations MUST support the\
    \ octet stream input\n   and SHOULD also support the document subset feature via\
    \ node-set\n   input.  For the purpose of describing canonicalization in terms\
    \ of an\n   XPath node-set, this section describes how an octet stream is\n  \
    \ converted to an XPath node-set.\n   The second parameter of input to the XML\
    \ canonicalization method is a\n   boolean flag indicating whether or not comments\
    \ should be included in\n   the canonical form output by the XML canonicalization\
    \ method.  If a\n   canonical form contains comments corresponding to the comment\
    \ nodes\n   in the input node-set, the result is called canonical XML with\n \
    \  comments.  Note that the XPath data model does not create comment\n   nodes\
    \ for comments appearing within the document type declaration\n   (DTD).  Implementations\
    \ are REQUIRED to be capable of producing\n   canonical XML excluding all comments\
    \ that may have appeared in the\n   input document or document subset.  Support\
    \ for canonical XML with\n   comments is RECOMMENDED.\n   If an XML document must\
    \ be converted to a node-set, XPath REQUIRES\n   that an XML processor be used\
    \ to create the nodes of its data model\n   to fully represent the document. \
    \ The XML processor performs the\n   following tasks in order:\n      1. normalize\
    \ line feeds\n      2. normalize attribute values\n      3. replace CDATA sections\
    \ with their character content\n      4. resolve character and parsed entity references\n\
    \   The input octet stream MUST contain a well-formed XML document, but\n   the\
    \ input need not be validated.  However, the attribute value\n   normalization\
    \ and entity reference resolution MUST be performed in\n   accordance with the\
    \ behaviors of a validating XML processor.  As\n   well, nodes for default attributes\
    \ (declared in the ATTLIST with an\n   AttValue but not specified) are created\
    \ in each element.  Thus, the\n   declarations in the document type declaration\
    \ are used to help create\n   the canonical form, even though the document type\
    \ declaration is not\n   retained in the canonical form.\n   The XPath data model\
    \ represents data using UCS characters.\n   Implementations MUST use XML processors\
    \ that support UTF-8 and UTF-16\n   and translate to the UCS character domain.\
    \  For UTF-16, the leading\n   byte order mark is treated as an artifact of encoding\
    \ and stripped\n   from the UCS character data (subsequent zero width non-breaking\n\
    \   spaces appearing within the UTF-16 data are not removed) [UTF-16,\n   Section\
    \ 3.2].  Support for ISO-8859-1 encoding is RECOMMENDED, and\n   all other character\
    \ encodings are OPTIONAL.\n   All whitespace within the root document element\
    \ MUST be preserved\n   (except for any #xD characters deleted by line delimiter\n\
    \   normalization).  This includes all whitespace in external entities.\n   Whitespace\
    \ outside of the root document element MUST be discarded.\n   In the XPath data\
    \ model, there exist the following node types: root,\n   element, comment, processing\
    \ instruction, text, attribute and\n   namespace.  There exists a single root\
    \ node whose children are\n   processing instruction nodes and comment nodes to\
    \ represent\n   information outside of the document element (and outside of the\n\
    \   document type declaration).  The root node also has a single element\n   node\
    \ representing the top-level document element.  Each element node\n   can have\
    \ child nodes of type element, text, processing instruction,\n   and comment.\
    \  The attributes and namespaces associated with an\n   element are not considered\
    \ to be child nodes of the element, but they\n   are associated with the element\
    \ by inclusion in the element's\n   attribute and namespace axes.  Note that attribute\
    \ and namespace axes\n   may not directly correspond to the text appearing in\
    \ the element's\n   start tag in the original document.\n   Note: An element has\
    \ attribute nodes to represent the non-namespace\n         attribute declarations\
    \ appearing in its start tag as well as\n         nodes to represent the default\
    \ attributes.\n   By virtue of the XPath data model, XML canonicalization is\n\
    \   namespace-aware [Names].  However, it cannot and therefore does not\n   account\
    \ for namespace equivalencies using namespace prefix rewriting\n   (see explanation\
    \ in Section 4).  In the XPath data model, each\n   element and attribute has\
    \ a name returned by the function name()\n   which can, at the discretion of the\
    \ application, be the QName\n   appearing in the original document.  XML canonicalization\
    \ REQUIRES\n   that the XML processor retain sufficient information such that\
    \ the\n   QName of the element as it appeared in the original document can be\n\
    \   provided.\n   Note: An element E has namespace nodes that represent its namespace\n\
    \         declarations as well as any namespace declarations made by its\n   \
    \      ancestors that have not been overridden in E's declarations,\n        \
    \ the default namespace if it is non-empty, and the declaration\n         of the\
    \ prefix xml.  nn Note: This specification supports the\n   recent XML plenary\
    \ decision to\n         deprecate relative namespace URIs as follows: implementations\n\
    \         of XML canonicalization MUST report an operation failure on\n      \
    \   documents containing relative namespace URIs.  XML\n         canonicalization\
    \ MUST NOT be implemented with an XML parser\n         that converts relative\
    \ URIs to absolute URIs.\n   Character content is represented in the XPath data\
    \ model with text\n   nodes.  All consecutive characters are placed into a single\
    \ text\n   node.  Furthermore, the text node's characters are represented in the\n\
    \   UCS character domain.  The XML canonicalization method does not\n   perform\
    \ character model normalization (see explanation in Section 4).\n   However, the\
    \ XML processor used to prepare the XPath data model input\n   is REQUIRED to\
    \ use Normalization Form C [NFC, NFC-Corrigendum] when\n   converting an XML document\
    \ to the UCS character domain from any\n   encoding that is not UCS-based (currently,\
    \ UCS-based encodings\n   include UTF-8, UTF-16, UTF-16BE, and UTF-16LE, UCS-2,\
    \ and UCS-4).\n   Since XML canonicalization converts an XPath node-set into a\n\
    \   canonical form, the first parameter MUST either be an XPath node-set\n   or\
    \ it must be converted from an octet stream to a node-set by\n   performing the\
    \ XML processing necessary to create the XPath nodes\n   described above, then\
    \ setting an initial XPath evaluation context of:\n      * A context node, initialized\
    \ to the root node of the input XML\n        document.\n      * A context position,\
    \ initialized to 1.\n      * A context size, initialized to 1.\n      * Any library\
    \ of functions conforming to the XPath Recommendation.\n      * An empty set of\
    \ variable bindings.\n      * An empty set of namespace declarations.\n   and\
    \ evaluating the following default expression:\n     Comment Parameter Value \
    \   Default XPath Expression\n     -----------------------    ------------------------\n\
    \     Without (false):\n                      (//. | //@* |//namespace::*)[not(self::comment())]\n\
    \     With (true):\n                      (//. | //@* | //namespace::*)\n   The\
    \ expressions in this table generate a node-set containing every\n   node of the\
    \ XML document (except the comments if the comment\n   parameter value is false).\n\
    \   If the input is an XPath node-set, then the node-set must explicitly\n   contain\
    \ every node to be rendered to the canonical form.  For\n   example, the result\
    \ of the XPath expression id(\"E\") is a node-set\n   containing only the node\
    \ corresponding to the element with an ID\n   attribute value of \"E\".  Since\
    \ none of its descendant nodes,\n   attribute nodes and namespace nodes are in\
    \ the set, the canonical\n   form would consist solely of the element's start\
    \ and end tags, less\n   the attribute and namespace declarations, with no internal\
    \ content.\n   Section 3.7 exemplifies how to serialize an identified element\
    \ along\n   with its internal content, attributes and namespace declarations.\n"
- title: 2.2 Document Order
  contents:
  - "2.2 Document Order\n   Although an XPath node-set is defined to be unordered,\
    \ the XPath 1.0\n   Recommendation [XPath] defines the term document order to\
    \ be the\n   order in which the first character of the XML representation of each\n\
    \   node occurs in the XML representation of the document after expansion\n  \
    \ of general entities, except for namespace and attribute nodes whose\n   document\
    \ order is application-dependent.\n   The XML canonicalization method processes\
    \ a node-set by imposing the\n   following additional document order rules on\
    \ the namespace and\n   attribute nodes of each element:\n       * An element's\
    \ namespace and attribute nodes have a document\n         order position greater\
    \ than the element but less than any child\n         node of the element.\n  \
    \     * Namespace nodes have a lesser document order position than\n         attribute\
    \ nodes.\n       * An element's namespace nodes are sorted lexicographically by\n\
    \         local name (the default namespace node, if one exists, has no\n    \
    \     local name and is therefore lexicographically least).\n       * An element's\
    \ attribute nodes are sorted lexicographically with\n         namespace URI as\
    \ the primary key and local name as the\n         secondary key (an empty namespace\
    \ URI is lexicographically\n         least).\n   Lexicographic comparison, which\
    \ orders strings from least to greatest\n   alphabetically, is based on the UCS\
    \ codepoint values, which is\n   equivalent to lexicographic ordering based on\
    \ UTF-8.\n"
- title: 2.3 Processing Model
  contents:
  - "2.3 Processing Model\n   The XPath node-set is converted into an octet stream,\
    \ the canonical\n   form, by generating the representative UCS characters for\
    \ each node\n   in the node-set in ascending document order, then encoding the\
    \ result\n   in UTF-8 (without a leading byte order mark).  No node is processed\n\
    \   more than once.  Note that processing an element node E includes the\n   processing\
    \ of all members of the node-set for which E is an ancestor.\n   Therefore, directly\
    \ after the representative text for E is generated,\n   E and all nodes for which\
    \ E is an ancestor are removed from the\n   node-set (or some logically equivalent\
    \ operation occurs such that the\n   node-set's next node in document order has\
    \ not been processed).\n   Note, however, that an element node is not removed\
    \ from the node-set\n   until after its children are processed.\n   The result\
    \ of processing a node depends on its type and on whether or\n   not it is in\
    \ the node-set.  If a node is not in the node-set, then no\n   text is generated\
    \ for the node except for the result of processing\n   its namespace and attribute\
    \ axes (elements only) and its children\n   (elements and the root node).  If\
    \ the node is in the node-set, then\n   text is generated to represent the node\
    \ in the canonical form in\n   addition to the text generated by processing the\
    \ node's namespace and\n   attribute axes and child nodes.\n   Note: The node-set\
    \ is treated as a set of nodes, not a list of\n         subtrees.  To canonicalize\
    \ an element including its namespaces,\n         attributes, and content, the\
    \ node-set must actually contain all\n         of the nodes corresponding to these\
    \ parts of the document, not\n         just the element node.\n   The text generated\
    \ for a node is dependent on the node type and given\n   in the following list:\n\
    \       * Root Node- The root node is the parent of the top-level\n         document\
    \ element.  The result of processing each of its child\n         nodes that is\
    \ in the node-set in document order.  The root node\n         does not generate\
    \ a byte order mark, XML declaration, nor\n         anything from within the document\
    \ type declaration.\n       * Element Nodes- If the element is not in the node-set,\
    \ then the\n         result is obtained by processing the namespace axis, then\
    \ the\n         attribute axis, then processing the child nodes of the element\n\
    \         that are in the node-set (in document order).  If the element\n    \
    \     is in the node-set, then the result is an open angle bracket\n         (<),\
    \ the element QName, the result of processing the namespace\n         axis, the\
    \ result of processing the attribute axis, a close\n         angle bracket (>),\
    \ the result of processing the child nodes of\n         the element that are in\
    \ the node-set (in document order), an\n         open angle bracket, a forward\
    \ slash (/), the element QName, and\n         a close angle bracket.\n       *\n\
    \         o Namespace Axis- Consider a list L containing only namespace\n    \
    \       nodes in the axis and in the node-set in lexicographic order\n       \
    \    (ascending).  To begin processing L, if the first node is not\n         \
    \  the default namespace node (a node with no namespace URI and\n           no\
    \ local name), then generate a space followed by xmlns=\"\" if\n           and\
    \ only if the following conditions are met:\n            + the element E that\
    \ owns the axis is in the node-set\n            + The nearest ancestor element\
    \ of E in the node-set has a\n              default namespace node in the node-set\
    \ (default namespace\n              nodes always have non-empty values in XPath)\n\
    \           The latter condition eliminates unnecessary occurrences of\n     \
    \      xmlns=\"\" in the canonical form since an element only receives\n     \
    \      an xmlns=\"\" if its default namespace is empty and if it has\n       \
    \    an immediate parent in the canonical form that has a non-\n           empty\
    \ default namespace.  To finish processing L, simply\n           process every\
    \ namespace node in L, except omit namespace node\n           with local name\
    \ xml, which defines the xml prefix, if its\n           string value is http://www.w3.org/XML/1998/namespace.\n\
    \         o Attribute Axis- In lexicographic order (ascending), process\n    \
    \       each node that is in the element's attribute axis and in the\n       \
    \    node-set.\n       * Namespace Nodes- A namespace node N is ignored if the\
    \ nearest\n         ancestor element of the node's parent element that is in the\n\
    \         node-set has a namespace node in the node-set with the same\n      \
    \   local name and value as N.  Otherwise, process the namespace\n         node\
    \ N in the same way as an attribute node, except assign the\n         local name\
    \ xmlns to the default namespace node if it exists (in\n         XPath, the default\
    \ namespace node has an empty URI and local\n         name).\n       * Attribute\
    \ Nodes- a space, the node's QName, an equals sign, an\n         open quotation\
    \ mark (double quote), the modified string value,\n         and a close quotation\
    \ mark (double quote).  The string value of\n         the node is modified by\
    \ replacing all ampersands (&) with\n         &amp;, all open angle brackets (<)\
    \ with &lt;, all quotation\n         mark (double quote) characters with &quot;,\
    \ and the whitespace\n         characters #x9, #xA, and #xD, with character references.\
    \  The\n         character references are written in uppercase hexadecimal with\n\
    \         no leading zeroes (for example, #xD is represented by the\n        \
    \ character reference &#xD;).\n       * Text Nodes- the string value, except all\
    \ ampersands are\n         replaced by &amp;, all open angle brackets (<) are\
    \ replaced by\n         &lt;, all closing angle brackets (>) are replaced by &gt;,\
    \ and\n         all #xD characters are replaced by &#xD;.\n       * Processing\
    \ Instruction (PI) Nodes- The opening PI symbol (<?),\n         the PI target\
    \ name of the node, a leading space and the string\n         value if it is not\
    \ empty, and the closing PI symbol (?>).  If\n         the string value is empty,\
    \ then the leading space is not added.\n         Also, a trailing #xA is rendered\
    \ after the closing PI symbol\n         for PI children of the root node with\
    \ a lesser document order\n         than the document element, and a leading #xA\
    \ is rendered before\n         the opening PI symbol of PI children of the root\
    \ node with a\n         greater document order than the document element.\n  \
    \     * Comment Nodes- Nothing if generating canonical XML without\n         comments.\
    \  For canonical XML with comments, generate the\n         opening comment symbol\
    \ (<!--), the string value of the node,\n         and the closing comment symbol\
    \ (-->).  Also, a trailing #xA is\n         rendered after the closing comment\
    \ symbol for comment children\n         of the root node with a lesser document\
    \ order than the document\n         element, and a leading #xA is rendered before\
    \ the opening\n         comment symbol of comment children of the root node with\
    \ a\n         greater document order than the document element.  (Comment\n  \
    \       children of the root node represent comments outside of the\n        \
    \ top-level document element and outside of the document type\n         declaration.)\n\
    \   The QName of a node is either the local name if the namespace prefix\n   string\
    \ is empty or the namespace prefix, a colon, then the local name\n   of the element.\
    \  The namespace prefix used in the QName MUST be the\n   same one which appeared\
    \ in the input document.\n"
- title: 2.4 Document Subsets
  contents:
  - "2.4 Document Subsets\n   Some applications require the ability to create a physical\n\
    \   representation for an XML document subset (other than the one\n   generated\
    \ by default, which can be a proper subset of the document if\n   the comments\
    \ are omitted).  Implementations of XML canonicalization\n   that are based on\
    \ XPath can provide this functionality with little\n   additional overhead by\
    \ accepting a node-set as input rather than an\n   octet stream.\n   The processing\
    \ of an element node E MUST be modified slightly when an\n   XPath node-set is\
    \ given as input and the element's parent is omitted\n   from the node-set.  The\
    \ method for processing the attribute axis of\n   an element E in the node-set\
    \ is enhanced.  All element nodes along\n   E's ancestor axis are examined for\
    \ nearest occurrences of attributes\n   in the xml namespace, such as xml:lang\
    \ and xml:space (whether or not\n   they are in the node-set).  From this list\
    \ of attributes, remove any\n   that are in E's attribute axis (whether or not\
    \ they are in the node-\n   set).  Then, lexicographically merge this attribute\
    \ list with the\n   nodes of E's attribute axis that are in the node-set.  The\
    \ result of\n   visiting the attribute axis is computed by processing the attribute\n\
    \   nodes in this merged attribute list.\n      Note: XML entities can derive\
    \ application-specific meaning from\n            anywhere in the XML markup as\
    \ well as by rules not expressed\n            in XML 1.0 and the Namespaces Recommendations.\
    \  Clearly,\n            these rules cannot be specified in this document, so\
    \ the\n            creator of the input node-set must be responsible for\n   \
    \         preserving the information necessary to capture the full\n         \
    \   semantics of the members of the resulting node-set.\n   The canonical XML\
    \ generated for an entire XML document is well-\n   formed.  The canonical form\
    \ of an XML document subset may not be\n   well-formed XML.  However, since the\
    \ canonical form may be subjected\n   to further XML processing, most XPath node-sets\
    \ provided for\n   canonicalization will be designed to produce a canonical form\
    \ that is\n   a well-formed XML document or external general parsed entity.\n\
    \   Whether from a full document or a document subset, if the canonical\n   form\
    \ is well-formed XML, then subsequent applications of the same XML\n   canonicalization\
    \ method to the canonical form make no changes.\n"
- title: 3. Examples of XML Canonicalization
  contents:
  - "3. Examples of XML Canonicalization\n   The examples in this section assume a\
    \ non-validating processor,\n   primarily so that a document type declaration\
    \ can be used to declare\n   entities as well as default attributes and attributes\
    \ of various\n   types (such as ID and enumerated) without having to declare all\n\
    \   attributes for all elements in the document.  As well, one example\n   contains\
    \ an element that deliberately violates a validity constraint\n   (because it\
    \ is still well-formed).\n"
- title: 3.1 PIs, Comments, and Outside of Document Element
  contents:
  - "3.1 PIs, Comments, and Outside of Document Element\n   Input Document\n   --------------\n\
    \   <?xml version=\"1.0\"?>\n   <?xml-stylesheet   href=\"doc.xsl\"\n      type=\"\
    text/xsl\"   ?>\n   <!DOCTYPE doc SYSTEM \"doc.dtd\">\n   <doc>Hello, world!<!--\
    \ Comment 1 --></doc>\n   <?pi-without-data     ?>\n   <!-- Comment 2 -->\n  \
    \ <!-- Comment 3 -->\n   Canonical Form (uncommented)\n   ----------------------------\n\
    \   <?xml-stylesheet href=\"doc.xsl\"\n      type=\"text/xsl\"   ?>\n   <doc>Hello,\
    \ world!</doc>\n   <?pi-without-data?>\n   Canonical Form (commented)\n   --------------------------\n\
    \   <?xml-stylesheet href=\"doc.xsl\"\n      type=\"text/xsl\"   ?>\n   <doc>Hello,\
    \ world!<!-- Comment 1 --></doc>\n   <?pi-without-data?>\n   <!-- Comment 2 -->\n\
    \   <!-- Comment 3 -->\n   Demonstrates:\n       * Loss of XML declaration\n \
    \      * Loss of DTD\n       * Normalization of whitespace outside of document\
    \ element (first\n         character of both canonical forms is '<'; single line\
    \ breaks\n         separate PIs and comments outside of document element)\n  \
    \     * Loss of whitespace between PITarget and its data * Retention of\n    \
    \     whitespace inside PI data\n       * Comment removal from uncommented canonical\
    \ form, including\n         delimiter for comments outside document element (the\
    \ last\n         character in both canonical forms is '>')\n"
- title: 3.2 Whitespace in Document Content
  contents:
  - "3.2 Whitespace in Document Content\n   Input Document\n   --------------\n  \
    \ <doc>\n      <clean>   </clean>\n      <dirty>   A   B   </dirty>\n      <mixed>\n\
    \         A\n         <clean>   </clean>\n         B\n         <dirty>   A   B\
    \   </dirty>\n         C\n      </mixed>\n   </doc>\n   Canonical Form\n   --------------\n\
    \   <doc>\n      <clean>   </clean>\n      <dirty>   A   B   </dirty>\n      <mixed>\n\
    \         A\n         <clean>   </clean>\n         B\n         <dirty>   A   B\
    \   </dirty>\n         C\n      </mixed>\n   </doc>\n   Demonstrates:\n      \
    \ * Retain all whitespace between consecutive start tags, clean or\n         dirty\n\
    \       * Retain all whitespace between consecutive end tags, clean or\n     \
    \    dirty\n       * Retain all whitespace between end tag/start tag pair, clean\
    \ or\n         dirty\n       * Retain all whitespace in character content, clean\
    \ or dirty\n   Note: In this example, the input document and canonical form are\n\
    \         identical.  Both end with '>' character.\n"
- title: 3.3 Start and End Tags
  contents:
  - '3.3 Start and End Tags

    '
- title: Input Document
  contents:
  - 'Input Document

    '
- title: '--------------'
  contents:
  - '--------------

    '
- title: <!DOCTYPE doc [<!ATTLIST e9 attr CDATA "default">]>
  contents:
  - '<!DOCTYPE doc [<!ATTLIST e9 attr CDATA "default">]>

    '
- title: <doc>
  contents:
  - "<doc>\n   <e1   />\n   <e2   ></e2>\n   <e3    name = \"elem3\"   id=\"elem3\"\
    \    />\n   <e4    name=\"elem4\"   id=\"elem4\"    ></e4>\n   <e5 a:attr=\"out\"\
    \ b:attr=\"sorted\" attr2=\"all\" attr=\"I'm\"\n       xmlns:b=\"http://www.ietf.org\"\
    \n       xmlns:a=\"http://www.w3.org\"\n       xmlns=\"http://example.org\"/>\n\
    \   <e6 xmlns=\"\" xmlns:a=\"http://www.w3.org\">\n       <e7 xmlns=\"http://www.ietf.org\"\
    >\n           <e8 xmlns=\"\" xmlns:a=\"http://www.w3.org\">\n               <e9\
    \ xmlns=\"\" xmlns:a=\"http://www.ietf.org\"/>\n           </e8>\n       </e7>\n\
    \   </e6>\n"
- title: </doc>
  contents:
  - '</doc>

    '
- title: Canonical Form
  contents:
  - 'Canonical Form

    '
- title: '--------------'
  contents:
  - '--------------

    '
- title: <doc>
  contents:
  - "<doc>\n   <e1></e1>\n   <e2></e2>\n   <e3 id=\"elem3\" name=\"elem3\"></e3>\n\
    \   <e4 id=\"elem4\" name=\"elem4\"></e4>\n   <e5 xmlns=\"http://example.org\"\
    \ xmlns:a=\"http://www.w3.org\"\n"
- title: xmlns:b="http://www.ietf.org" attr="I'm" attr2="all"
  contents:
  - 'xmlns:b="http://www.ietf.org" attr="I''m" attr2="all"

    '
- title: b:attr="sorted" a:attr="out"></e5>
  contents:
  - "b:attr=\"sorted\" a:attr=\"out\"></e5>\n   <e6 xmlns:a=\"http://www.w3.org\"\
    >\n       <e7 xmlns=\"http://www.ietf.org\">\n           <e8 xmlns=\"\">\n   \
    \            <e9 xmlns:a=\"http://www.ietf.org\" attr=\"default\"></e9>\n    \
    \       </e8>\n       </e7>\n   </e6>\n"
- title: </doc>
  contents:
  - "</doc>\n   Demonstrates:\n         * Empty element conversion to start-end tag\
    \ pair\n         * Normalization of whitespace in start and end tags\n       \
    \  * Relative order of namespace and attribute axes\n         * Lexicographic\
    \ ordering of namespace and attribute axes\n         * Retention of namespace\
    \ prefixes from original document\n         * Elimination of superfluous namespace\
    \ declarations\n         * Addition of default attribute\n   Note: Some start\
    \ tags in the canonical form are very long, but each\n         start tag in this\
    \ example is entirely on a single line.\n   Note: In e5, b:attr precedes a:attr\
    \ because the primary key is\n         namespace URI not namespace prefix, and\
    \ attr2 precedes b:attr\n         because the default namespace is not applied\
    \ to unqualified\n         attributes (so the namespace URI for attr2 is empty).\n"
- title: 3.4 Character Modifications and Character References
  contents:
  - '3.4 Character Modifications and Character References

    '
- title: Input Document
  contents:
  - 'Input Document

    '
- title: '--------------'
  contents:
  - '--------------

    '
- title: <!DOCTYPE doc [
  contents:
  - '<!DOCTYPE doc [

    '
- title: '<!ATTLIST normId id ID #IMPLIED>'
  contents:
  - '<!ATTLIST normId id ID #IMPLIED>

    '
- title: '<!ATTLIST normNames attr NMTOKENS #IMPLIED>'
  contents:
  - '<!ATTLIST normNames attr NMTOKENS #IMPLIED>

    '
- title: ']>'
  contents:
  - ']>

    '
- title: <doc>
  contents:
  - "<doc>\n   <text>First line&#x0d;&#10;Second line</text>\n   <value>&#x32;</value>\n\
    \   <compute><![CDATA[value>\"0\" && value<\"10\" ?\"valid\":\"error\"]]>\n  \
    \ </compute>\n   <compute expr='value>\"0\" &amp;&amp; value&lt;\"10\"\n"
- title: ?"valid":"error"'>valid</compute>
  contents:
  - "?\"valid\":\"error\"'>valid</compute>\n   <norm attr=' &apos;   &#x20;&#13;&#xa;&#9;\
    \   &apos; '/>\n   <normNames attr='   A   &#x20;&#13;&#xa;&#9;   B   '/>\n  \
    \ <normId id=' &apos;   &#x20;&#13;&#xa;&#9;   &apos; '/>\n"
- title: </doc>
  contents:
  - '</doc>

    '
- title: Canonical Form
  contents:
  - 'Canonical Form

    '
- title: '--------------'
  contents:
  - '--------------

    '
- title: <doc>
  contents:
  - "<doc>\n   <text>First line&#xD;\n"
- title: Second line</text>
  contents:
  - "Second line</text>\n   <value>2</value>\n   <compute>value&gt;\"0\" &amp;&amp;\
    \ value&lt;\"10\" ?\"valid\":\"error\"\n   </compute>\n   <compute expr=\"value>&quot;0&quot;\
    \ &amp;&amp; value&lt;&quot;10&quot;\n"
- title: ?&quot;
  contents:
  - '?&quot;

    '
- title: valid&quot;:&quot;error&quot;">valid</compute>
  contents:
  - "valid&quot;:&quot;error&quot;\">valid</compute>\n   <norm attr=\" '    &#xD;&#xA;&#x9;\
    \   ' \"></norm>\n   <normNames attr=\"A &#xD;&#xA;&#x9; B\"></normNames>\n  \
    \ <normId id=\"' &#xD;&#xA;&#x9; '\"></normId>\n"
- title: </doc>
  contents:
  - "</doc>\n   Demonstrates:\n       * Character reference replacement\n       *\
    \ Attribute value delimiters set to quotation marks (double\n         quotes)\n\
    \       * Attribute value normalization\n       * CDATA section replacement\n\
    \       * Encoding of special characters as character references in\n        \
    \ attribute values (&amp;, &lt;, &quot;, &#xD;, &#xA;, &#x9;)\n       * Encoding\
    \ of special characters as character references in text\n         (&amp;, &lt;,\
    \ &gt;, &#xD;)\n   Note: The last element, normId, is well-formed but violates\
    \ a\n         validity constraint for attributes of type ID.  For testing\n  \
    \       canonical XML implementations based on validating processors,\n      \
    \   remove the line containing this element from the input and\n         canonical\
    \ form.  In general, XML consumers should be\n         discouraged from using\
    \ this feature of XML.\n   Note: Whitespace characters references other than &#x20;\
    \ are not\n         affected by attribute value normalization [XML].\n   Note:\
    \ In the canonical form, the value of the attribute named attr in\n         the\
    \ element norm begins with a space, a single quote, then four\n         spaces\
    \ before the first character reference.\n   Note: The expr attribute of the second\
    \ compute element contains no\n         line breaks.\n"
- title: 3.5 Entity References
  contents:
  - "3.5 Entity References\n   Input Document\n   --------------\n   <!DOCTYPE doc\
    \ [\n   <!ATTLIST doc attrExtEnt ENTITY #IMPLIED>\n   <!ENTITY ent1 \"Hello\"\
    >\n   <!ENTITY ent2 SYSTEM \"world.txt\">\n   <!ENTITY entExt SYSTEM \"earth.gif\"\
    \ NDATA gif>\n   <!NOTATION gif SYSTEM \"viewgif.exe\">\n   ]>\n   <doc attrExtEnt=\"\
    entExt\">\n      &ent1;, &ent2;!\n   </doc>\n   <!-- Let world.txt contain \"\
    world\" (excluding the quotes) -->\n   Canonical Form (uncommented)\n   ----------------------------\n\
    \   <doc attrExtEnt=\"entExt\">\n      Hello, world!\n   </doc>\n   Demonstrates:\n\
    \       * Internal parsed entity reference replacement\n       * External parsed\
    \ entity reference replacement (including\n         whitespace outside elements\
    \ and PIs)\n       * External unparsed entity reference\n"
- title: 3.6 UTF-8 Encoding
  contents:
  - "3.6 UTF-8 Encoding\n   Input Document\n   --------------\n   <?xml version=\"\
    1.0\" encoding=\"ISO-8859-1\"?>\n   <doc>&#169;</doc>\n   Canonical Form\n   --------------\n\
    \   <doc>#xC2#xA9</doc>\n   Demonstrates:\n         * Effect of transcoding from\
    \ a sample encoding to UTF-8\n   Note: The content of the doc element is NOT the\
    \ string #xC2#xA9 but\n         rather the two octets whose hexadecimal values\
    \ are C2 and A9,\n         which is the UTF-8 encoding of the UCS codepoint for\
    \ the\n         copyright symbol (c).\n"
- title: 3.7 Document Subsets
  contents:
  - '3.7 Document Subsets

    '
- title: Input Document
  contents:
  - 'Input Document

    '
- title: '--------------'
  contents:
  - '--------------

    '
- title: <!DOCTYPE doc [
  contents:
  - '<!DOCTYPE doc [

    '
- title: <!ATTLIST e2 xml:space (default|preserve) 'preserve'>
  contents:
  - '<!ATTLIST e2 xml:space (default|preserve) ''preserve''>

    '
- title: '<!ATTLIST e3 id ID #IMPLIED>'
  contents:
  - '<!ATTLIST e3 id ID #IMPLIED>

    '
- title: ']>'
  contents:
  - ']>

    '
- title: <doc xmlns="http://www.ietf.org" xmlns:w3c="http://www.w3.org">
  contents:
  - "<doc xmlns=\"http://www.ietf.org\" xmlns:w3c=\"http://www.w3.org\">\n   <e1>\n\
    \      <e2 xmlns=\"\">\n         <e3 id=\"E3\"/>\n      </e2>\n   </e1>\n"
- title: </doc>
  contents:
  - '</doc>

    '
- title: Document Subset Expression
  contents:
  - 'Document Subset Expression

    '
- title: '--------------------------'
  contents:
  - '--------------------------

    '
- title: (//. | //@* | //namespace::*)
  contents:
  - '(//. | //@* | //namespace::*)

    '
- title: '[ <br/>'
  contents:
  - "[ <br/>\n   self::ietf:e1 or (parent::ietf:e1 and not(self::text() or self::e2))\n\
    \   or\n   count(id(\"E3\")|ancestor-or-self::node()) =\n"
- title: count(ancestor-or-self::node())
  contents:
  - 'count(ancestor-or-self::node())

    '
- title: ']'
  contents:
  - ']

    '
- title: Canonical Form
  contents:
  - 'Canonical Form

    '
- title: '--------------'
  contents:
  - '--------------

    '
- title: <e1 xmlns="http://www.ietf.org" xmlns:w3c="http://www.w3.org"><e3
  contents:
  - '<e1 xmlns="http://www.ietf.org" xmlns:w3c="http://www.w3.org"><e3

    '
- title: xmlns="" id="E3" xml:space="preserve"></e3></e1>
  contents:
  - "xmlns=\"\" id=\"E3\" xml:space=\"preserve\"></e3></e1>\n   Demonstrates:\n  \
    \       * Empty default namespace propagation from omitted parent\n         element\
    \ * Propagation of attributes in xml namespace in\n         document subsets *\
    \ Persistence of omitted namespace\n         declarations in descendants\n   Note:\
    \ In the document subset expression, the subexpression (//. |\n         //@* |\
    \ //namespace::*) selects all nodes in the input document,\n         subjecting\
    \ each to the predicate expression in square brackets.\n         The expression\
    \ is true for e1 and its implicit namespace nodes,\n         and it is true if\
    \ the element identified by E3 is in the\n         ancestor-or-self path of the\
    \ context node (such that ancestor-\n         or-self stays the same size under\
    \ union with the element\n         identified by E3).\n   Note: The canonical\
    \ form contains no line delimiters.\n"
- title: 4. Resolutions
  contents:
  - "4. Resolutions\n   This section discusses a number of key decision points as\
    \ well as a\n   rationale for each decision.  Although this specification now\
    \ defines\n   XML canonicalization in terms of the XPath data model rather than\
    \ XML\n   Infoset, the canonical form described in this document is quite\n  \
    \ similar in most respects to the canonical form described in the\n   January\
    \ 2000 Canonical XML draft [C14N-20000119].  However, some\n   differences exist,\
    \ and a number of the subsections discuss the\n   changes.\n"
- title: 4.1 No XML Declaration
  contents:
  - "4.1 No XML Declaration\n   The XML declaration, including version number and\
    \ character encoding\n   is omitted from the canonical form.  The encoding is\
    \ not needed since\n   the canonical form is encoded in UTF-8.  The version is\
    \ not needed\n   since the absence of a version number unambiguously indicates\
    \ XML\n   1.0.\n   Future versions of XML will be required to include an XML declaration\n\
    \   to indicate the version number.  However, canonicalization method\n   described\
    \ in this specification may not be applicable to future\n   versions of XML without\
    \ some modifications.  When canonicalization of\n   a new version of XML is required,\
    \ this specification could be updated\n   to include the XML declaration as presumably\
    \ the absence of the XML\n   declaration from the XPath data model can be remedied\
    \ by that time\n   (e.g., by reissuing a new XPath based on the Infoset data model).\n"
- title: 4.2 No Character Model Normalization
  contents:
  - "4.2 No Character Model Normalization\n   The Unicode standard [Unicode] allows\
    \ multiple different\n   representations of certain \"precomposed characters\"\
    \ (a simple example\n   is +U00E7, \"LATIN SMALL LETTER C WITH CEDILLA\").  Thus\
    \ two XML\n   documents with content that is equivalent for the purposes of most\n\
    \   applications may contain differing character sequences.  The W3C is\n   preparing\
    \ a normalized representation [CharModel].  The C14N-20000119\n   Canonical XML\
    \ draft used this normalized form.  However, many XML 1.0\n   processors do not\
    \ perform this normalization.  Furthermore,\n   applications that must solve this\
    \ problem typically enforce character\n   model normalization at all times starting\
    \ when character content is\n   created in order to avoid processing failures\
    \ that could otherwise\n   result (e.g., see example from Cowan).  Therefore,\
    \ character model\n   normalization has been moved out of scope for XML canonicalization.\n\
    \   However, the XML processor used to prepare the XPath data model input\n  \
    \ is required (by the Data Model) to use Normalization Form C [NFC,\n   NFC-Corrigendum]\
    \ when converting an XML document to the UCS character\n   domain from any encoding\
    \ that is not UCS-based (currently, UCS-based\n   encodings include UTF-8, UTF-16,\
    \ UTF-16BE, and UTF-16LE, UCS-2, and\n   UCS-4).\n"
- title: 4.3 Handling of Whitespace Outside Document Element
  contents:
  - "4.3 Handling of Whitespace Outside Document Element\n   The C14N-20000119 Canonical\
    \ XML draft placed a #xA after each PI\n   outside of the document element as\
    \ well as a #xA after the end tag of\n   the document element.  The method in\
    \ this specification performs the\n   same function except for omitting the final\
    \ #xA after the last PI (or\n   comment or end tag of the document element). \
    \ This technique ensures\n   that PI (and comment) children of the root are separated\
    \ from markup\n   by a line feed even if root node or the document element are\
    \ omitted\n   from the output node-set.\n"
- title: 4.4 No Namespace Prefix Rewriting
  contents:
  - "4.4 No Namespace Prefix Rewriting\n   The C14N-20000119 Canonical XML draft described\
    \ a method for\n   rewriting namespace prefixes such that two documents having\
    \ logically\n   equivalent namespace declarations would also have identical namespace\n\
    \   prefixes.  The goal was to eliminate dependence on the particular\n   namespace\
    \ prefixes in a document when testing for logical\n   equivalence.  However, there\
    \ now exist a number of contexts in which\n   namespace prefixes can impart information\
    \ value in an XML document.\n   For example, an XPath expression in an attribute\
    \ value or element\n   content can reference a namespace prefix.  Thus, rewriting\
    \ the\n   namespace prefixes would damage such a document by changing its\n  \
    \ meaning (and it cannot be logically equivalent if its meaning has\n   changed).\n\
    \   More formally, let D1 be a document containing an XPath in an\n   attribute\
    \ value or element content that refers to namespace prefixes\n   used in D1. \
    \ Further assume that the namespace prefixes in D1 will\n   all be rewritten by\
    \ the canonicalization method.  Let D23D D1, then\n   modify the namespace prefixes\
    \ in D2 and modify the XPath expression's\n   references to namespace prefixes\
    \ such that D2 and D1 remain logically\n   equivalent.  Since namespace rewriting\
    \ does not include occurrences\n   of namespace references in attribute values\
    \ and element content, the\n   canonical form of D1 does not equal the canonical\
    \ form of D2 because\n   the XPath will be different.  Thus, although namespace\
    \ rewriting\n   normalizes the namespace declarations, the goal eliminating\n\
    \   dependence on the particular namespace prefixes in the document is\n   not\
    \ achieved.\n   Moreover, it is possible to prove that namespace rewriting is\n\
    \   harmful, rather than simply ineffective.  Let D1 be a document\n   containing\
    \ an XPath in an attribute value or element content that\n   refers to namespace\
    \ prefixes used in D1.  Further assume that the\n   namespace prefixes in D1 will\
    \ all be rewritten by the\n   canonicalization method.  Now let D2 be the canonical\
    \ form of D1.\n   Clearly, the canonical forms of D1 and D2 are equivalent (since\
    \ D2 is\n   the canonical form of the canonical form of D1), yet D1 and D2 are\n\
    \   not logically equivalent because the aforementioned XPath works in D1\n  \
    \ and doesn't work in D2.\n   Note that an argument similar to this can be leveled\
    \ against the XML\n   canonicalization method based on any of the cases in the\
    \ Limitations,\n   the problems cannot easily be fixed in those cases, whereas\
    \ here we\n   have an opportunity to avoid purposefully introducing such a\n \
    \  limitation.\n   Applications that must test for logical equivalence must perform\
    \ more\n   sophisticated tests than mere octet stream comparison.  However, this\n\
    \   is quite likely to be necessary in any case in order to test for\n   logical\
    \ equivalencies based on application rules as well as rules\n   from other XML-related\
    \ recommendations, working drafts, and future\n   works.\n"
- title: 4.5 Order of Namespace Declarations and Attributes
  contents:
  - "4.5 Order of Namespace Declarations and Attributes\n   The C14N-20000119 Canonical\
    \ XML draft alternated between namespace\n   declarations and attribute declarations.\
    \  This is part of the\n   namespace prefix rewriting scheme, which this specification\n\
    \   eliminates.  This specification follows the XPath data model of\n   putting\
    \ all namespace nodes before all attribute nodes.\n"
- title: 4.6 Superfluous Namespace Declarations
  contents:
  - "4.6 Superfluous Namespace Declarations\n   Unnecessary namespace declarations\
    \ are not made in the canonical\n   form.  Whether for an empty default namespace,\
    \ a non-empty default\n   namespace, or a namespace prefix binding, the XML canonicalization\n\
    \   method omits a declaration if it determines that the immediate parent\n  \
    \ element in the canonical form has an equivalent declaration in scope.\n   The\
    \ root document element is handled specially since it has no parent\n   element.\
    \  All namespace declarations in it are retained, except the\n   declaration of\
    \ an empty default namespace is automatically omitted.\n   Relative to the method\
    \ of simply rendering the entire namespace\n   context of each element, implementations\
    \ are not hindered by more\n   than a constant factor in processing time and memory\
    \ use.  The\n   advantages include:\n       * Eliminates overrun of xmlns=\"\"\
    \ from canonical forms of\n         applications that may not even use namespaces,\
    \ or support them\n         only minimally.\n       * Eliminates namespace declarations\
    \ from elements where they may\n         not belong according to the application's\
    \ content model,\n         thereby simplifying the task of reattaching a document\
    \ type\n         declaration to a canonical form.\n   Note that in document subsets,\
    \ an element with omissions from its\n   ancestral element chain will be rendered\
    \ to the canonical form with\n   namespace declarations that may have been made\
    \ in its omitted\n   ancestors, thus preserving the meaning of the element.\n"
- title: 4.7 Propagation of Default Namespace Declaration in Document Subsets
  contents:
  - "4.7 Propagation of Default Namespace Declaration in Document Subsets\n   The\
    \ XPath data model represents an empty default namespace with the\n   absence\
    \ of a node, not with the presence of a default namespace node\n   having an empty\
    \ value.  Thus, with respect to the fact that element\n   e3 in the following\
    \ examples is not namespace qualified, we cannot\n   tell the difference between\
    \ <e1 xmlns=\"a:b\"><e2\n   xmlns=\"\"><e3/></e2></e1> versus <e1 xmlns=\"a:b\"\
    ><e2><e3\n   xmlns=\"\"/></e2></e1>.  All we know is that e3 was not namespace\n\
    \   qualified on input, so we preserve this information on output if e2\n   is\
    \ omitted so that e3 does not take on the default namespace\n   qualification\
    \ of e1.\n"
- title: 4.8 Sorting Attributes by Namespace URI
  contents:
  - "4.8 Sorting Attributes by Namespace URI\n   Given the requirement to preserve\
    \ the namespace prefixes declared in\n   a document, sorting attributes with the\
    \ prefix, rather than the\n   namespace URI, as the primary key is viable and\
    \ easier to implement.\n   However, the namespace URI was selected as the primary\
    \ key because\n   this is closer to the intent of the XML Names specification,\
    \ which is\n   to identify namespaces by URI and local name, not by a prefix and\n\
    \   local name.  The effect of the sort is to group together all\n   attributes\
    \ that are in the same namespace.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are discussed in section 1.3.\n"
- title: References
  contents:
  - "References\n   [C14N-20000119]        Canonical XML Version 1.0, W3C Working\
    \ Draft.\n                          T.  Bray, J. Clark, J.  Tauber, and J. Cowan.\n\
    \                          January 19, 2000.\n                          http://www.w3.org/TR/2000/WD-xml-c14n-\n\
    \                          20000119.html.\n   [CharModel]            Working Draft.\
    \ eds.  Martin J. Durst, Francois\n                          Yergeau, Misha Wolf,\
    \ Asmus Freytag, Tex Texin.\n                          http://www.w3.org/TR/charmod/.\n\
    \   [Cowan]                Example of Harmful Effect of Character Model\n    \
    \                      Normalization, Letter in XML Signature Working\n      \
    \                    Group Mail Archive. John Cowan, July 7, 2000\n          \
    \                http://lists.w3.org/Archives/Public/w3c-ietf-\n             \
    \             xmldsig/2000JulSep/0038.html.\n   [Infoset]              XML Information\
    \ Set, W3C Working Draft.  John\n                          Cowan, Richard Tobin.\n\
    \                          http://www.w3.org/TR/xml-infoset.\n   [ISO-8859-1]\
    \           ISO-8859-1 Latin 1 Character Set.\n                          http://www.utoronto.ca/webdocs/HTMLdocs/\n\
    \                          NewHTML/iso_table.html or\n                       \
    \   http://www.iso.ch/cate/cat.html.\n   [Keywords]             Bradner, S., \"\
    Key words for use in RFCs to\n                          Indicate Requirement Levels\"\
    , BCP 14, RFC\n                          2119, March 1997.\n   [Namespaces]  \
    \         Namespaces in XML, W3C Recommendation. eds.\n                      \
    \    Tim Bray, Dave Hollander, and Andrew Layman.\n                          http://www.w3.org/TR/REC-xml-names/\n\
    \   [NFC]                  TR15, Unicode Normalization Forms. M. Davis,\n    \
    \                      M. Durst. Revision 18: November 1999.\n               \
    \           http://www.unicode.org/unicode/reports/tr15/\n                   \
    \       tr15-18.html.\n   [NFC-Corrigendum]      NFC-Corrigendum.  The Unicode\
    \ Consortium.\n                          http://www.unicode.org/unicode/uni2errata/\n\
    \                          Normalization_Corrigendum.html.\n   [Unicode]     \
    \         The Unicode Standard, version 3.0. The Unicode\n                   \
    \       Consortium. ISBN 0-201-61633-5.\n                          http://www.unicode.org/unicode/standard/\n\
    \                          versions/Unicode3.0.html.\n   [UTF-16]            \
    \   Hoffman, P. and F. Yergeau, \"UTF-16, an\n                          encoding\
    \ of ISO 10646\", RFC 2781, February\n                          2000.\n   [UTF-8]\
    \                Yergeau, F., \"UTF-8, a transformation format\n             \
    \             of ISO 10646\", RFC 2279, January 1998.\n   [URI]              \
    \    Berners-Lee, T., Fielding, R. and L. Masinter,\n                        \
    \  \"Uniform Resource Identifiers (URI): Generic\n                          Syntax\"\
    , RFC 2396, August 1998.\n   [XBase]                XML Base ed. Jonathan Marsh.\
    \ 07 June 2000.\n                          http://www.w3.org/TR/xmlbase/.\n  \
    \ [XML]                  Extensible Markup Language (XML) 1.0 (Second\n      \
    \                    Edition), W3C=20 Recommendation. eds. Tim\n             \
    \             Bray, Jean Paoli, C. M. Sperberg-McQueen and\n                 \
    \         Eve Maler. 6 October 2000.\n                          http://www.w3.org/TR/REC-xml.\n\
    \   [XML DSig]             Eastlake, D., Reagle, J. and D. Solo, \"XML-\n    \
    \                      Signature Syntax and Processing\", RFC 3075,\n        \
    \                  July 2000.\n   [XML Plenary Decision] W3C XML Plenary Decision\
    \ on relative URI\n                          References In namespace declarations,\
    \ W3C\n                          Document. 11 September 2000.\n              \
    \            http://lists.w3.org/Archives/Public/xml-\n                      \
    \    uri/2000Sep/0083.html.\n   [XPath]                XML Path Language (XPath)\
    \ Version 1.0, , W3C\n                          Recommendation. eds.  James Clark\
    \ and Steven\n                          DeRose. 16 November 1999.\n          \
    \                http://www.w3.org/TR/1999/REC-xpath-19991116.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   John Boyer\n   PureEdge Solutions Inc.\n   Phone: 1-888-517-2675\n\
    \   EMail: jboyer@PureEdge.com\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The following people provided valuable feedback that improved\
    \ the\n   quality of this specification:\n            * Doug Bunting, Ariba\n\
    \            * John Cowan, Reuters\n            * Martin J. Durst, W3C\n     \
    \       * Donald Eastlake 3rd, Motorola\n            * Merlin Hughes, Baltimore\n\
    \            * Gregor Karlinger, IAIK TU Graz\n            * Susan Lesch, W3C\n\
    \            * Jonathan Marsh, Microsoft\n            * Joseph Reagle, W3C\n \
    \           * Petteri Stenius, Done360\n            * Kent Tamura, IBM\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2001).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
