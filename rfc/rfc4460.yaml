- title: __initial_text__
  contents:
  - "       Stream Control Transmission Protocol (SCTP) Specification\n          \
    \                 Errata and Issues\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document is a compilation of issues found during six\n   interoperability\
    \ events and 5 years of experience with implementing,\n   testing, and using Stream\
    \ Control Transmission Protocol (SCTP) along\n   with the suggested fixes.  This\
    \ document provides deltas to RFC 2960\n   and is organized in a time-based way.\
    \  The issues are listed in the\n   order they were brought up.  Because some\
    \ text is changed several\n   times, the last delta in the text is the one that\
    \ should be applied.\n   In addition to the delta, a description of the problem\
    \ and the\n   details of the solution are also provided.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n      2.2. Parameter Processing Issue .................................7\n\
    \           2.2.1. Description of the Problem ..........................7\n  \
    \         2.2.2. Text Changes to the Document ........................8\n    \
    \       2.2.3. Solution Description ................................8\n      2.3.\
    \ Padding Issues .............................................8\n           2.3.1.\
    \ Description of the Problem ..........................8\n           2.3.2. Text\
    \ Changes to the Document ........................9\n           2.3.3. Solution\
    \ Description ...............................10\n      2.4. Parameter Types across\
    \ All Chunk Types ....................10\n           2.4.1. Description of the\
    \ Problem .........................10\n           2.4.2. Text Changes to the Document\
    \ .......................10\n           2.4.3. Solution Description ...............................12\n\
    \      2.5. Stream Parameter Clarification ............................12\n  \
    \         2.5.1. Description of the problem .........................12\n    \
    \       2.5.2. Text Changes to the Document .......................12\n      \
    \     2.5.3. Solution Description ...............................13\n      2.6.\
    \ Restarting Association Security Issue .....................13\n           2.6.1.\
    \ Description of the Problem .........................13\n           2.6.2. Text\
    \ Changes to the Document .......................14\n           2.6.3. Solution\
    \ Description ...............................18\n      2.7. Implicit Ability to\
    \ Exceed cwnd by PMTU-1 Bytes ...........19\n           2.7.1. Description of\
    \ the Problem .........................19\n           2.7.2. Text Changes to the\
    \ Document .......................19\n           2.7.3. Solution Description ...............................19\n\
    \      2.8. Issues with Fast Retransmit ...............................19\n  \
    \         2.8.1. Description of the Problem .........................19\n    \
    \       2.8.2. Text Changes to the Document .......................20\n      \
    \     2.8.3. Solution Description ...............................23\n      2.9.\
    \ Missing Statement about partial_bytes_acked Update ........24\n           2.9.1.\
    \ Description of the Problem .........................24\n           2.9.2. Text\
    \ Changes to the Document .......................24\n           2.9.3. Solution\
    \ Description ...............................25\n      2.10. Issues with Heartbeating\
    \ and Failure Detection ...........25\n           2.10.1. Description of the Problem\
    \ ........................25\n           2.10.2. Text Changes to the Document\
    \ ......................26\n           2.10.3. Solution Description ..............................28\n\
    \      2.11. Security interactions with firewalls .....................29\n  \
    \         2.11.1. Description of the Problem ........................29\n    \
    \       2.11.2. Text Changes to the Document ......................29\n      \
    \     2.11.3. Solution Description ..............................31\n      2.12.\
    \ Shutdown Ambiguity .......................................31\n           2.12.1.\
    \ Description of the Problem ........................31\n           2.12.2. Text\
    \ Changes to the Document ......................31\n           2.12.3. Solution\
    \ Description ..............................32\n      2.13. Inconsistency in ABORT\
    \ Processing ........................32\n           2.13.1. Description of the\
    \ Problem ........................32\n           2.13.2. Text changes to the document\
    \ ......................33\n           2.13.3. Solution Description ..............................33\n\
    \      2.14. Cwnd Gated by Its Full Use ...............................34\n  \
    \         2.14.1. Description of the Problem ........................34\n    \
    \       2.14.2. Text Changes to the Document ......................34\n      \
    \     2.14.3. Solution Description ..............................36\n      2.15.\
    \ Window Probes in SCTP ....................................36\n           2.15.1.\
    \ Description of the Problem ........................36\n           2.15.2. Text\
    \ Changes to the Document ......................36\n           2.15.3. Solution\
    \ Description ..............................38\n      2.16. Fragmentation and\
    \ Path MTU Issues ........................39\n           2.16.1. Description of\
    \ the Problem ........................39\n           2.16.2. Text Changes to the\
    \ Document ......................39\n           2.16.3. Solution Description ..............................40\n\
    \      2.17. Initial Value of the Cumulative TSN Ack ..................40\n  \
    \         2.17.1. Description of the Problem ........................40\n    \
    \       2.17.2. Text Changes to the Document ......................40\n      \
    \     2.17.3. Solution Description ..............................41\n      2.18.\
    \ Handling of Address Parameters within the INIT or\n            INIT-ACK .................................................41\n\
    \           2.18.1. Description of the Problem ........................41\n  \
    \         2.18.2. Text Changes to the Document ......................41\n    \
    \       2.18.3. Solution description ..............................42\n      2.19.\
    \ Handling of Stream Shortages .............................42\n           2.19.1.\
    \ Description of the Problem ........................42\n           2.19.2. Text\
    \ Changes to the Document ......................42\n           2.19.3. Solution\
    \ Description ..............................43\n      2.20. Indefinite Postponement\
    \ ..................................43\n           2.20.1. Description of the\
    \ Problem ........................43\n           2.20.2. Text Changes to the Document\
    \ ......................43\n           2.20.3. Solution Description ..............................44\n\
    \      2.21. User-Initiated Abort of an Association ...................44\n  \
    \         2.21.1. Description of the Problem ........................44\n    \
    \       2.21.2. Text changes to the document ......................44\n      \
    \     2.21.3. Solution Description ..............................50\n      2.22.\
    \ Handling of Invalid Initiate Tag of INIT-ACK .............50\n           2.22.1.\
    \ Description of the Problem ........................50\n           2.22.2. Text\
    \ Changes to the Document ......................50\n           2.22.3. Solution\
    \ Description ..............................51\n      2.23. Sending an ABORT in\
    \ Response to an INIT ..................51\n           2.23.1. Description of\
    \ the Problem ........................51\n           2.23.2. Text Changes to the\
    \ Document ......................51\n           2.23.3. Solution Description ..............................52\n\
    \      2.24. Stream Sequence Number (SSN) Initialization ..............52\n  \
    \         2.24.1. Description of the Problem ........................52\n    \
    \       2.24.2. Text Changes to the Document ......................52\n      \
    \     2.24.3. Solution Description ..............................53\n      2.25.\
    \ SACK Packet Format .......................................53\n           2.25.1.\
    \ Description of the Problem ........................53\n           2.25.2. Text\
    \ Changes to the Document ......................53\n           2.25.3. Solution\
    \ Description ..............................53\n      2.26. Protocol Violation\
    \ Error Cause ...........................53\n           2.26.1. Description of\
    \ the Problem ........................53\n           2.26.2. Text Changes to the\
    \ Document ......................54\n           2.26.3. Solution Description ..............................56\n\
    \      2.27. Reporting of Unrecognized Parameters .....................56\n  \
    \         2.27.1. Description of the Problem ........................56\n    \
    \       2.27.2. Text Changes to the Document ......................56\n      \
    \     2.27.3. Solution Description ..............................57\n      2.28.\
    \ Handling of IP Address Parameters ........................58\n           2.28.1.\
    \ Description of the Problem ........................58\n           2.28.2. Text\
    \ Changes to the Document ......................58\n           2.28.3. Solution\
    \ Description ..............................58\n      2.29. Handling of COOKIE\
    \ ECHO Chunks When a TCB Exists .........59\n           2.29.1. Description of\
    \ the Problem ........................59\n           2.29.2. Text Changes to the\
    \ Document ......................59\n           2.29.3. Solution Description ..............................59\n\
    \      2.30. The Initial Congestion Window Size .......................59\n  \
    \         2.30.1. Description of the Problem ........................59\n    \
    \       2.30.2. Text Changes to the Document ......................60\n      \
    \     2.30.3. Solution Description ..............................61\n      2.31.\
    \ Stream Sequence Numbers in Figures .......................62\n           2.31.1.\
    \ Description of the Problem ........................62\n           2.31.2. Text\
    \ Changes to the Document ......................63\n           2.31.3. Solution\
    \ description ..............................67\n      2.32. Unrecognized Parameters\
    \ ..................................67\n           2.32.1. Description of the\
    \ Problem ........................67\n           2.32.2. Text Changes to the Document\
    \ ......................67\n           2.32.3. Solution Description ..............................68\n\
    \      2.33. Handling of Unrecognized Parameters ......................68\n  \
    \         2.33.1. Description of the Problem ........................68\n    \
    \       2.33.2. Text Changes to the Document ......................68\n      \
    \     2.33.3. Solution Description ..............................70\n      2.34.\
    \ Tie Tags .................................................70\n           2.34.1.\
    \ Description of the Problem ........................70\n           2.34.2. Text\
    \ Changes to the Document ......................70\n           2.34.3. Solution\
    \ Description ..............................72\n      2.35. Port Number Verification\
    \ in the COOKIE-ECHO ..............72\n           2.35.1. Description of the Problem\
    \ ........................72\n           2.35.2. Text Changes to the Document\
    \ ......................72\n           2.35.3. Solution Description ..............................73\n\
    \      2.36. Path Initialization ......................................74\n  \
    \         2.36.1. Description of the Problem ........................74\n    \
    \       2.36.2. Text Changes to the Document ......................74\n      \
    \     2.36.3. Solution Description ..............................76\n      2.37.\
    \ ICMP Handling Procedures .................................76\n           2.37.1.\
    \ Description of the Problem ........................76\n           2.37.2. Text\
    \ Changes to the Document ......................77\n           2.37.3. Solution\
    \ Description ..............................79\n      2.38. Checksum .................................................79\n\
    \           2.38.1. Description of the problem ........................79\n  \
    \         2.38.2. Text Changes to the Document ......................79\n    \
    \       2.38.3. Solution Description ..............................86\n      2.39.\
    \ Retransmission Policy ....................................86\n           2.39.1.\
    \ Description of the Problem ........................86\n           2.39.2. Text\
    \ Changes to the Document ......................87\n           2.39.3. Solution\
    \ Description ..............................87\n      2.40. Port Number 0 ............................................88\n\
    \           2.40.1. Description of the Problem ........................88\n  \
    \         2.40.2. Text Changes to the Document ......................88\n    \
    \       2.40.3. Solution Description ..............................89\n      2.41.\
    \ T Bit ....................................................89\n           2.41.1.\
    \ Description of the Problem ........................89\n           2.41.2. Text\
    \ Changes to the Document ......................89\n           2.41.3. Solution\
    \ Description ..............................93\n      2.42. Unknown Parameter\
    \ Handling ...............................93\n           2.42.1. Description of\
    \ the Problem ........................93\n           2.42.2. Text Changes to the\
    \ Document ......................93\n           2.42.3. Solution Description ..............................95\n\
    \      2.43. Cookie Echo Chunk ........................................95\n  \
    \         2.43.1. Description of the Problem ........................95\n    \
    \       2.43.2. Text Changes to the Document ......................95\n      \
    \     2.43.3. Solution Description ..............................96\n      2.44.\
    \ Partial Chunks ...........................................96\n           2.44.1.\
    \ Description of the Problem ........................96\n           2.44.2. Text\
    \ Changes to the Document ......................96\n           2.44.3. Solution\
    \ Description ..............................97\n      2.45. Non-unicast Addresses\
    \ ....................................97\n           2.45.1. Description of the\
    \ Problem ........................97\n           2.45.2. Text Changes to the Document\
    \ ......................97\n           2.45.3. Solution Description ..............................98\n\
    \      2.46. Processing of ABORT Chunks ...............................98\n  \
    \         2.46.1. Description of the Problem ........................98\n    \
    \       2.46.2. Text Changes to the Document ......................98\n      \
    \     2.46.3. Solution Description ..............................98\n      2.47.\
    \ Sending of ABORT Chunks ..................................99\n           2.47.1.\
    \ Description of the Problem ........................99\n           2.47.2. Text\
    \ Changes to the Document ......................99\n           2.47.3. Solution\
    \ Description ..............................99\n      2.48. Handling of Supported\
    \ Address Types Parameter ............99\n           2.48.1. Description of the\
    \ Problem ........................99\n           2.48.2. Text Changes to the Document\
    \ .....................100\n           2.48.3. Solution Description .............................100\n\
    \      2.49. Handling of Unexpected Parameters .......................101\n  \
    \         2.49.1. Description of the Problem .......................101\n    \
    \       2.49.2. Text Changes to the Document .....................101\n      \
    \     2.49.3. Solution Description .............................102\n      2.50.\
    \ Payload Protocol Identifier .............................102\n           2.50.1.\
    \ Description of the Problem .......................102\n           2.50.2. Text\
    \ Changes to the Document .....................103\n           2.50.3. Solution\
    \ Description .............................103\n      2.51. Karn's Algorithm ........................................104\n\
    \           2.51.1. Description of the Problem .......................104\n  \
    \         2.51.2. Text Changes to the Document .....................104\n    \
    \       2.51.3. Solution Description .............................104\n      2.52.\
    \ Fast Retransmit Algorithm ...............................104\n           2.52.1.\
    \ Description of the Problem .......................104\n           2.52.2. Text\
    \ Changes to the Document .....................105\n           2.52.3. Solution\
    \ Description .............................105\n   3. Security Considerations\
    \ .......................................105\n   4. Acknowledgements ..............................................106\n\
    \   5. IANA Considerations ...........................................106\n  \
    \ 6. Normative References ..........................................106\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document contains a compilation of all defects found\
    \ up until\n   the publishing of this document for the Stream Control Transmission\n\
    \   Protocol (SCTP), RFC 2960 [5].  These defects may be of an editorial\n   or\
    \ technical nature.  This document may be thought of as a companion\n   document\
    \ to be used in the implementation of SCTP to clarify errors\n   in the original\
    \ SCTP document.\n   This document provides a history of the changes that will\
    \ be compiled\n   into RFC 2960's [5] BIS document.  Each error will be detailed\
    \ within\n   this document in the form of\n   o  the problem description,\n  \
    \ o  the text quoted from RFC 2960 [5],\n   o  the replacement text that should\
    \ be placed into the BIS document,\n      and\n   o  a description of the solution.\n\
    \   This document is a historical record of sequential changes what have\n   been\
    \ found necessary at various interop events and through discussion\n   on this\
    \ list.\n   Note that because some text is changed several times, the last delta\n\
    \   for a text in the document is the erratum for that text in RFC 2960.\n"
- title: 1.1.  Conventions
  contents:
  - "1.1.  Conventions\n   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT,\
    \ SHOULD,\n   SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL, when\n\
    \   they appear in this document, are to be interpreted as described in\n   RFC\
    \ 2119 [2].\n"
- title: 2.  Corrections to RFC 2960
  contents:
  - '2.  Corrections to RFC 2960

    '
- title: 2.1.  Incorrect Error Type During Chunk Processing.
  contents:
  - '2.1.  Incorrect Error Type During Chunk Processing.

    '
- title: 2.1.1.  Description of the Problem
  contents:
  - "2.1.1.  Description of the Problem\n   A typo was discovered in RFC 2960 [5]\
    \ that incorrectly specifies an\n   action to be taken when processing chunks\
    \ of unknown identity.\n"
- title: 2.1.2.  Text changes to the document
  contents:
  - "2.1.2.  Text changes to the document\n   ---------\n   Old text: (Section 3.2)\n\
    \   ---------\n   01 - Stop processing this SCTP packet and discard it, do not\
    \ process\n        any further chunks within it, and report the unrecognized\n\
    \        parameter in an 'Unrecognized Parameter Type' (in either an\n       \
    \ ERROR or in the INIT ACK).\n   ---------\n   New text: (Section 3.2)\n   ---------\n\
    \   01 - Stop processing this SCTP packet and discard it, do not process\n   \
    \     any further chunks within it, and report the unrecognized\n        chunk\
    \ in an 'Unrecognized Chunk Type'.\n"
- title: 2.1.3.  Solution Description
  contents:
  - "2.1.3.  Solution Description\n   The receiver of an unrecognized chunk should\
    \ not send a 'parameter'\n   error but instead should send the appropriate chunk\
    \ error as\n   described above.\n"
- title: 2.2.  Parameter Processing Issue
  contents:
  - '2.2.  Parameter Processing Issue

    '
- title: 2.2.1.  Description of the Problem
  contents:
  - "2.2.1.  Description of the Problem\n   A typographical error was introduced through\
    \ an improper cut and\n   paste in the use of the upper two bits to describe proper\
    \ handling of\n   unknown parameters.\n"
- title: 2.2.2.  Text Changes to the Document
  contents:
  - "2.2.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.2.1)\n\
    \   ---------\n   00 - Stop processing this SCTP packet and discard it; do not\
    \ process\n        any further chunks within it.\n   01 - Stop processing this\
    \ SCTP packet and discard it, do not process\n        any further chunks within\
    \ it, and report the unrecognized\n        parameter in an 'Unrecognized Parameter\
    \ Type' (in either an\n        ERROR or in the INIT ACK).\n   ---------\n   New\
    \ text: (Section 3.2.1)\n   ---------\n   00 - Stop processing this SCTP chunk\
    \ and discard it, do not process\n        any further parameters within this chunk.\n\
    \   01 - Stop processing this SCTP chunk and discard it, do not process\n    \
    \    any further parameters within this chunk, and report the\n        unrecognized\
    \ parameter in an 'Unrecognized Parameter Type' (in\n        either an ERROR or\
    \ in the INIT ACK).\n"
- title: 2.2.3.  Solution Description
  contents:
  - "2.2.3.  Solution Description\n   It was always the intent to stop processing\
    \ at the level one was at\n   in an unknown chunk or parameter with the upper\
    \ bit set to 0.  Thus,\n   if you are processing a chunk, you should drop the\
    \ packet.  If you\n   are processing a parameter, you should drop the chunk.\n"
- title: 2.3.  Padding Issues
  contents:
  - '2.3.  Padding Issues

    '
- title: 2.3.1.  Description of the Problem
  contents:
  - "2.3.1.  Description of the Problem\n   A problem was found when a Chunk terminated\
    \ in a TLV parameter.  If\n   this last TLV was not on a 32-bit boundary (as required),\
    \ there was\n   confusion as to whether the last padding was included in the chunk\n\
    \   length.\n"
- title: 2.3.2.  Text Changes to the Document
  contents:
  - "2.3.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.2)\n\
    \   ---------\n   Chunk Length: 16 bits (unsigned integer)\n      This value represents\
    \ the size of the chunk in bytes including the\n      Chunk Type, Chunk Flags,\
    \ Chunk Length, and Chunk Value fields.\n      Therefore, if the Chunk Value field\
    \ is zero-length, the Length\n      field will be set to 4.  The Chunk Length\
    \ field does not count any\n      padding.\n   Chunk Value: variable length\n\
    \      The Chunk Value field contains the actual information to be\n      transferred\
    \ in the chunk.  The usage and format of this field is\n      dependent on the\
    \ Chunk Type.\n   The total length of a chunk (including Type, Length and Value\
    \ fields)\n   MUST be a multiple of 4 bytes.  If the length of the chunk is not\
    \ a\n   multiple of 4 bytes, the sender MUST pad the chunk with all zero\n   bytes\
    \ and this padding is not included in the chunk length field.\n   The sender should\
    \ never pad with more than 3 bytes.  The receiver\n   MUST ignore the padding\
    \ bytes.\n   ---------\n   New text: (Section 3.2)\n   ---------\n   Chunk Length:\
    \ 16 bits (unsigned integer)\n      This value represents the size of the chunk\
    \ in bytes, including\n      the Chunk Type, Chunk Flags, Chunk Length, and Chunk\
    \ Value fields.\n      Therefore, if the Chunk Value field is zero-length, the\
    \ Length\n      field will be set to 4.  The Chunk Length field does not count\
    \ any\n      chunk padding.\n      Chunks (including Type, Length, and Value fields)\
    \ are padded out\n      by the sender with all zero bytes to be a multiple of\
    \ 4 bytes\n      long.  This padding MUST NOT be more than 3 bytes in total. \
    \ The\n      Chunk Length value does not include terminating padding of the\n\
    \      chunk.  However, it does include padding of any variable-length\n     \
    \ parameter except the last parameter in the chunk.  The receiver\n      MUST\
    \ ignore the padding.\n      Note: A robust implementation should accept the Chunk\
    \ whether or\n      not the final padding has been included in the Chunk Length.\n\
    \   Chunk Value: variable length\n      The Chunk Value field contains the actual\
    \ information to be\n      transferred in the chunk.  The usage and format of\
    \ this field is\n      dependent on the Chunk Type.\n   The total length of a\
    \ chunk (including Type, Length, and Value\n   fields) MUST be a multiple of 4\
    \ bytes.  If the length of the chunk is\n   not a multiple of 4 bytes, the sender\
    \ MUST pad the chunk with all\n   zero bytes, and this padding is not included\
    \ in the chunk length\n   field.  The sender should never pad with more than 3\
    \ bytes.  The\n   receiver MUST ignore the padding bytes.\n"
- title: 2.3.3.  Solution Description
  contents:
  - "2.3.3.  Solution Description\n   The above text makes clear that the padding\
    \ of the last parameter is\n   not included in the Chunk Length field.  It also\
    \ clarifies that the\n   padding of parameters that are not the last one must\
    \ be counted in\n   the Chunk Length field.\n"
- title: 2.4.  Parameter Types across All Chunk Types
  contents:
  - '2.4.  Parameter Types across All Chunk Types

    '
- title: 2.4.1.  Description of the Problem
  contents:
  - "2.4.1.  Description of the Problem\n   A problem was noted when multiple errors\
    \ are needed to be sent\n   regarding unknown or unrecognized parameters.  Since\
    \ often the error\n   type does not hold the chunk type field, it may become difficult\
    \ to\n   tell which error was associated with which chunk.\n"
- title: 2.4.2.  Text Changes to the Document
  contents:
  - "2.4.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.2.1)\n\
    \   ---------\n   The actual SCTP parameters are defined in the specific SCTP\
    \ chunk\n   sections.  The rules for IETF-defined parameter extensions are\n \
    \  defined in Section 13.2.\n   ---------\n   New text: (Section 3.2.1)\n   ---------\n\
    \   The actual SCTP parameters are defined in the specific SCTP chunk\n   sections.\
    \  The rules for IETF-defined parameter extensions are\n   defined in Section\
    \ 13.2.  Note that a parameter type MUST be unique\n   across all chunks.  For\
    \ example, the parameter type '5' is used to\n   represent an IPv4 address (see\
    \ Section 3.3.2).  The value '5' then is\n   reserved across all chunks to represent\
    \ an IPv4 address and MUST NOT\n   be reused with a different meaning in any other\
    \ chunk.\n   ---------\n   Old text: (Section 13.2)\n   ---------\n   13.2 IETF-defined\
    \ Chunk Parameter Extension\n   The assignment of new chunk parameter type codes\
    \ is done through an\n   IETF Consensus action as defined in [RFC2434].  Documentation\
    \ of the\n   chunk parameter MUST contain the following information:\n   a) Name\
    \ of the parameter type.\n   b) Detailed description of the structure of the parameter\
    \ field.\n      This structure MUST conform to the general type-length-value\n\
    \      format described in Section 3.2.1.\n   c) Detailed definition of each component\
    \ of the parameter type.\n   d) Detailed description of the intended use of this\
    \ parameter type,\n      and an indication of whether and under what circumstances\
    \ multiple\n      instances of this parameter type may be found within the same\n\
    \      chunk.\n   ---------\n   New text: (Section 13.2)\n   ---------\n   13.2.\
    \  IETF-defined Chunk Parameter Extension\n   The assignment of new chunk parameter\
    \ type codes is done through an\n   IETF Consensus action, as defined in [RFC2434].\
    \  Documentation of the\n   chunk parameter MUST contain the following information:\n\
    \   a) Name of the parameter type.\n   b) Detailed description of the structure\
    \ of the parameter field.\n      This structure MUST conform to the general type-length-value\n\
    \      format described in Section 3.2.1.\n   c) Detailed definition of each component\
    \ of the parameter type.\n   d) Detailed description of the intended use of this\
    \ parameter type,\n      and an indication of whether and under what circumstances\
    \ multiple\n      instances of this parameter type may be found within the same\n\
    \      chunk.\n   e) Each parameter type MUST be unique across all chunks.\n"
- title: 2.4.3.  Solution Description
  contents:
  - "2.4.3.  Solution Description\n   By having all parameters unique across all chunk\
    \ assignments (the\n   current assignment policy), no ambiguity exists as to what\
    \ a\n   parameter means in different contexts.  The trade-off for this is a\n\
    \   smaller parameter space, i.e., 65,536 parameters versus 65,536 *\n   Number-of-\
    \ chunks.\n"
- title: 2.5.  Stream Parameter Clarification
  contents:
  - '2.5.  Stream Parameter Clarification

    '
- title: 2.5.1.  Description of the problem
  contents:
  - "2.5.1.  Description of the problem\n   A problem was found where the specification\
    \ is unclear on the\n   legality of an endpoint asking for more stream resources\
    \ than were\n   allowed in the MIS value of the INIT.  In particular, the value\
    \ in\n   the INIT ACK requested in its OS value was larger than the MIS value\n\
    \   received in the INIT chunk.  This behavior is illegal, yet it was\n   unspecified\
    \ in RFC 2960 [5]\n"
- title: 2.5.2.  Text Changes to the Document
  contents:
  - "2.5.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.3)\n\
    \   ---------\n   Number of Outbound Streams (OS):  16 bits (unsigned integer)\n\
    \      Defines the number of outbound streams the sender of this INIT ACK\n  \
    \    chunk wishes to create in this association.  The value of 0 MUST\n      NOT\
    \ be used.\n      Note: A receiver of an INIT ACK with the OS value set to 0 SHOULD\n\
    \      destroy the association discarding its TCB.\n   ---------\n   New text:\
    \ (Section 3.3.3)\n   ---------\n   Number of Outbound Streams (OS): 16 bits (unsigned\
    \ integer)\n      Defines the number of outbound streams the sender of this INIT\
    \ ACK\n      chunk wishes to create in this association.  The value of 0 MUST\n\
    \      NOT be used, and the value MUST NOT be greater than the MIS value\n   \
    \   sent in the INIT chunk.\n      Note: A receiver of an INIT ACK with the OS\
    \ value set to 0 SHOULD\n      destroy the association, discarding its TCB.\n"
- title: 2.5.3.  Solution Description
  contents:
  - "2.5.3.  Solution Description\n   The change in wording, above, changes it so\
    \ that a responder to an\n   INIT chunk does not specify more streams in its OS\
    \ value than were\n   represented to it in the MIS value, i.e., its maximum.\n"
- title: 2.6.  Restarting Association Security Issue
  contents:
  - '2.6.  Restarting Association Security Issue

    '
- title: 2.6.1.  Description of the Problem
  contents:
  - "2.6.1.  Description of the Problem\n   A security problem was found when a restart\
    \ occurs.  It is possible\n   for an intruder to send an INIT to an endpoint of\
    \ an existing\n   association.  In the INIT the intruder would list one or more\
    \ of the\n   current addresses of an association and its own.  The normal restart\n\
    \   procedures would then occur, and the intruder would have hijacked an\n   association.\n"
- title: 2.6.2.  Text Changes to the Document
  contents:
  - "2.6.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.10)\n\
    \   ---------\n      Cause Code\n      Value           Cause Code\n      ---------\
    \      ----------------\n       1              Invalid Stream Identifier\n   \
    \    2              Missing Mandatory Parameter\n       3              Stale Cookie\
    \ Error\n       4              Out of Resource\n       5              Unresolvable\
    \ Address\n       6              Unrecognized Chunk Type\n       7           \
    \   Invalid Mandatory Parameter\n       8              Unrecognized Parameters\n\
    \       9              No User Data\n      10              Cookie Received While\
    \ Shutting Down\n   Cause Length: 16 bits (unsigned integer)\n      Set to the\
    \ size of the parameter in bytes, including the Cause\n      Code, Cause Length,\
    \ and Cause-Specific Information fields\n   Cause-specific Information: variable\
    \ length\n      This field carries the details of the error condition.\n   Sections\
    \ 3.3.10.1 - 3.3.10.10 define error causes for SCTP.\n   Guidelines for the IETF\
    \ to define new error cause values are\n   discussed in Section 13.3.\n   ---------\n\
    \   New text: (Section 3.3.10)\n   ---------\n      Cause Code\n      Value  \
    \         Cause Code\n      ---------      ----------------\n       1        \
    \      Invalid Stream Identifier\n       2              Missing Mandatory Parameter\n\
    \       3              Stale Cookie Error\n       4              Out of Resource\n\
    \       5              Unresolvable Address\n       6              Unrecognized\
    \ Chunk Type\n       7              Invalid Mandatory Parameter\n       8    \
    \          Unrecognized Parameters\n       9              No User Data\n     \
    \ 10              Cookie Received While Shutting Down\n      11              Restart\
    \ of an Association with New Addresses\n   Cause Length: 16 bits (unsigned integer)\n\
    \      Set to the size of the parameter in bytes, including the Cause\n      Code,\
    \ Cause Length, and Cause-Specific Information fields.\n   Cause-specific Information:\
    \ variable length\n      This field carries the details of the error condition.\n\
    \   Sections 3.3.10.1 - 3.3.10.11 define error causes for SCTP.\n   Guidelines\
    \ for the IETF to define new error cause values are\n   discussed in Section 13.3.\n\
    \   ---------\n   New text: (Note no old text, new error cause added in section\
    \ 3.3.10)\n   ---------\n   3.3.10.11.  Restart of an Association with New Addresses\
    \ (11)\n    Cause of error\n    --------------\n    Restart of an association\
    \ with new addresses: An INIT was received\n    on an existing association.  But\
    \ the INIT added addresses to the\n    association that were previously NOT part\
    \ of the association.  The\n    new addresses are listed in the error code.  This\
    \ ERROR is normally\n    sent as part of an ABORT refusing the INIT (see Section\
    \ 5.2).\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |         Cause Code=11         |      Cause Length=Variable    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                       New Address TLVs                        /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Note: Each New Address TLV is an exact copy of the TLV\n      that was\
    \ found in the INIT chunk that was new, including the\n      Parameter Type and\
    \ the Parameter length.\n   ---------\n   Old text: (Section 5.2.1)\n   ---------\n\
    \   Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n  \
    \ endpoint MUST respond with an INIT ACK using the same parameters it\n   sent\
    \ in its original INIT chunk (including its Initiation Tag,\n   unchanged).  These\
    \ original parameters are combined with those from\n   the newly received INIT\
    \ chunk.  The endpoint shall also generate a\n   State Cookie with the INIT ACK.\
    \  The endpoint uses the parameters\n   sent in its INIT to calculate the State\
    \ Cookie.\n   ---------\n   New text: (Section 5.2.1)\n   ---------\n   Upon receipt\
    \ of an INIT in the COOKIE-WAIT state, an endpoint MUST\n   respond with an INIT\
    \ ACK using the same parameters it sent in its\n   original INIT chunk (including\
    \ its Initiation Tag, unchanged).  When\n   responding, the endpoint MUST send\
    \ the INIT ACK back to the same\n   address that the original INIT (sent by this\
    \ endpoint) was sent to.\n   Upon receipt of an INIT in the COOKIE-ECHOED state,\
    \ an endpoint MUST\n   respond with an INIT ACK using the same parameters it sent\
    \ in its\n   original INIT chunk (including its Initiation Tag, unchanged),\n\
    \   provided that no NEW address has been added to the forming\n   association.\
    \  If the INIT message indicates that a new address has\n   been added to the\
    \ association, then the entire INIT MUST be\n   discarded, and NO changes should\
    \ be made to the existing association.\n   An ABORT SHOULD be sent in response\
    \ that MAY include the error\n   'Restart of an association with new addresses'.\
    \  The error SHOULD\n   list the addresses that were added to the restarting association.\n\
    \   When responding in either state (COOKIE-WAIT or COOKIE-ECHOED) with\n   an\
    \ INIT ACK, the original parameters are combined with those from the\n   newly\
    \ received INIT chunk.  The endpoint shall also generate a State\n   Cookie with\
    \ the INIT ACK.  The endpoint uses the parameters sent in\n   its INIT to calculate\
    \ the State Cookie.\n   ---------\n   Old text: (Section 5.2.2)\n   ---------\n\
    \   5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n      \
    \   COOKIE-WAIT and SHUTDOWN-ACK-SENT\n   Unless otherwise stated, upon reception\
    \ of an unexpected INIT for\n   this association, the endpoint shall generate\
    \ an INIT ACK with a\n   State Cookie.  In the outbound INIT ACK the endpoint\
    \ MUST copy its\n   current Verification Tag and peer's Verification Tag into\
    \ a reserved\n   place within the state cookie.  We shall refer to these locations\
    \ as\n   the Peer's-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet\n\
    \   containing this INIT ACK MUST carry a Verification Tag value equal to\n  \
    \ the Initiation Tag found in the unexpected INIT.  And the INIT ACK\n   MUST\
    \ contain a new Initiation Tag (randomly generated see Section\n   5.3.1).  Other\
    \ parameters for the endpoint SHOULD be copied from the\n   existing parameters\
    \ of the association (e.g., number of outbound\n   streams) into the INIT ACK\
    \ and cookie.\n   After sending out the INIT ACK, the endpoint shall take no further\n\
    \   actions, i.e., the existing association, including its current state,\n  \
    \ and the corresponding TCB MUST NOT be changed.\n   Note: Only when a TCB exists\
    \ and the association is not in a COOKIE-\n   WAIT state are the Tie-Tags populated.\
    \  For a normal association INIT\n   (i.e., the endpoint is in a COOKIE-WAIT state),\
    \ the Tie-Tags MUST be\n   set to 0 (indicating that no previous TCB existed).\
    \  The INIT ACK and\n   State Cookie are populated as specified in section 5.2.1.\n\
    \   ---------\n   New text: (Section 5.2.2)\n   ---------\n   5.2.2.  Unexpected\
    \ INIT in States Other Than CLOSED, COOKIE-ECHOED,\n           COOKIE-WAIT, and\
    \ SHUTDOWN-ACK-SENT\n   Unless otherwise stated, upon receipt of an unexpected\
    \ INIT for this\n   association, the endpoint shall generate an INIT ACK with\
    \ a State\n   Cookie.  Before responding, the endpoint MUST check to see if the\n\
    \   unexpected INIT adds new addresses to the association.  If new\n   addresses\
    \ are added to the association, the endpoint MUST respond\n   with an ABORT, copying\
    \ the 'Initiation Tag' of the unexpected INIT\n   into the 'Verification Tag'\
    \ of the outbound packet carrying the\n   ABORT.  In the ABORT response, the cause\
    \ of error MAY be set to\n   'restart of an association with new addresses'. \
    \ The error SHOULD\n   list the addresses that were added to the restarting association.\n\
    \   If no new addresses are added, when responding to the INIT in the\n   outbound\
    \ INIT ACK, the endpoint MUST copy its current Verification\n   Tag and peer's\
    \ Verification Tag into a reserved place within the\n   state cookie.  We shall\
    \ refer to these locations as the Peer's-Tie-\n   Tag and the Local-Tie-Tag. \
    \ The outbound SCTP packet containing this\n   INIT ACK MUST carry a Verification\
    \ Tag value equal to the Initiation\n   Tag found in the unexpected INIT.  And\
    \ the INIT ACK MUST contain a\n   new Initiation Tag (randomly generated; see\
    \ Section 5.3.1).  Other\n   parameters for the endpoint SHOULD be copied from\
    \ the existing\n   parameters of the association (e.g., number of outbound streams)\
    \ into\n   the INIT ACK and cookie.\n   After sending out the INIT ACK or ABORT,\
    \ the endpoint shall take no\n   further actions; i.e., the existing association,\
    \ including its\n   current state, and the corresponding TCB MUST NOT be changed.\n\
    \   Note: Only when a TCB exists and the association is not in a COOKIE-\n   WAIT\
    \ or SHUTDOWN-ACK-SENT state are the Tie-Tags populated with a\n   value other\
    \ than 0.  For a normal association INIT (i.e., the\n   endpoint is in the CLOSED\
    \ state), the Tie-Tags MUST be set to 0\n   (indicating that no previous TCB existed).\n"
- title: 2.6.3.  Solution Description
  contents:
  - "2.6.3.  Solution Description\n   A new error code is being added, along with\
    \ specific instructions to\n   send back an ABORT to a new association in a restart\
    \ case or\n   collision case, where new addresses have been added.  The error\
    \ code\n   can be used by a legitimate restart to inform the endpoint that it\n\
    \   has made a software error in adding a new address.  The endpoint then\n  \
    \ can choose to wait until the OOTB ABORT tears down the old\n   association,\
    \ or to restart without the new address.\n   Also, the note at the end of Section\
    \ 5.2.2 explaining the use of the\n   Tie-Tags was modified to properly explain\
    \ the states in which the\n   Tie-Tags should be set to a value different than\
    \ 0.\n"
- title: 2.7.  Implicit Ability to Exceed cwnd by PMTU-1 Bytes
  contents:
  - '2.7.  Implicit Ability to Exceed cwnd by PMTU-1 Bytes

    '
- title: 2.7.1.  Description of the Problem
  contents:
  - "2.7.1.  Description of the Problem\n   Some implementations were having difficulty\
    \ growing their cwnd.  This\n   was due to an improper enforcement of the congestion\
    \ control rules.\n   The rules, as written, provided for a slop over of the cwnd\
    \ value.\n   Without this slop over, the sender would appear NOT to be using its\n\
    \   full cwnd value and thus would never increase it.\n"
- title: 2.7.2.  Text Changes to the Document
  contents:
  - "2.7.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.1)\n\
    \   ---------\n   B) At any given time, the sender MUST NOT transmit new data\
    \ to a\n      given transport address if it has cwnd or more bytes of data\n \
    \     outstanding to that transport address.\n   ---------\n   New text: (Section\
    \ 6.1)\n   ---------\n   B) At any given time, the sender MUST NOT transmit new\
    \ data to a\n      given transport address if it has cwnd or more bytes of data\n\
    \      outstanding to that transport address.  The sender may exceed cwnd\n  \
    \    by up to (PMTU-1) bytes on a new transmission if the cwnd is not\n      currently\
    \ exceeded.\n"
- title: 2.7.3.  Solution Description
  contents:
  - "2.7.3.  Solution Description\n   The text changes make clear the ability to go\
    \ over the cwnd value by\n   no more than (PMTU-1) bytes.\n"
- title: 2.8.  Issues with Fast Retransmit
  contents:
  - '2.8.  Issues with Fast Retransmit

    '
- title: 2.8.1.  Description of the Problem
  contents:
  - "2.8.1.  Description of the Problem\n   Several problems were found in the current\
    \ specification of fast\n   retransmit.  The current wording did not require GAP\
    \ ACK blocks to be\n   sent, even though they are essential to the workings of\
    \ SCTP's\n   congestion control.  The specification left unclear how to handle\
    \ the\n   fast retransmit cycle, having the implementation wait on the cwnd to\n\
    \   retransmit a TSN that was marked for fast retransmit.  No limit was\n   placed\
    \ on how many times a TSN could be fast retransmitted.  Fast\n   Recovery was\
    \ not specified, causing the congestion window to be\n   reduced drastically when\
    \ there are multiple losses in a single RTT.\n"
- title: 2.8.2.  Text Changes to the Document
  contents:
  - "2.8.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.2)\n\
    \   ---------\n   Acknowledgements MUST be sent in SACK chunks unless shutdown\
    \ was\n   requested by the ULP in which case an endpoint MAY send an\n   acknowledgement\
    \ in the SHUTDOWN chunk.  A SACK chunk can acknowledge\n   the reception of multiple\
    \ DATA chunks.  See Section 3.3.4 for SACK\n   chunk format.  In particular, the\
    \ SCTP endpoint MUST fill in the\n   Cumulative TSN Ack field to indicate the\
    \ latest sequential TSN (of a\n   valid DATA chunk) it has received.  Any received\
    \ DATA chunks with TSN\n   greater than the value in the Cumulative TSN Ack field\
    \ SHOULD also be\n   reported in the Gap Ack Block fields.\n   ---------\n   New\
    \ text: (Section 6.2)\n   ---------\n   Acknowledegments MUST be sent in SACK\
    \ chunks unless shutdown was\n   requested by the ULP, in which case an endpoint\
    \ MAY send an\n   acknowledgement in the SHUTDOWN chunk.  A SACK chunk can acknowledge\n\
    \   the reception of multiple DATA chunks.  See Section 3.3.4 for SACK\n   chunk\
    \ format.  In particular, the SCTP endpoint MUST fill in the\n   Cumulative TSN\
    \ Ack field to indicate the latest sequential TSN (of a\n   valid DATA chunk)\
    \ it has received.  Any received DATA chunks with\n   TSN greater than the value\
    \ in the Cumulative TSN Ack field are\n   reported in the Gap Ack Block fields.\
    \  The SCTP endpoint MUST\n   report as many Gap Ack Blocks as can fit in a single\
    \ SACK\n   chunk limited by the current path MTU.\n   ---------\n   Old text:\
    \ (Section 6.2.1)\n   ---------\n      D) Any time a SACK arrives, the endpoint\
    \ performs the following:\n            i) If Cumulative TSN Ack is less than the\
    \ Cumulative TSN Ack\n            Point, then drop the SACK.  Since Cumulative\
    \ TSN Ack is\n            monotonically increasing, a SACK whose Cumulative TSN\
    \ Ack is\n            less than the Cumulative TSN Ack Point indicates an out-of-\n\
    \            order SACK.\n            ii) Set rwnd equal to the newly received\
    \ a_rwnd minus the\n            number of bytes still outstanding after processing\
    \ the\n            Cumulative TSN Ack and the Gap Ack Blocks.\n            iii)\
    \ If the SACK is missing a TSN that was previously\n            acknowledged via\
    \ a Gap Ack Block (e.g., the data receiver\n            reneged on the data),\
    \ then mark the corresponding DATA chunk\n            as available for retransmit:\
    \  Mark it as missing for fast\n            retransmit as described in Section\
    \ 7.2.4 and if no\n            retransmit timer is running for the destination\
    \ address\n            to which the DATA chunk was originally transmitted, then\n\
    \            T3-rtx is started for that destination address.\n   ---------\n \
    \  New text: (Section 6.2.1)\n   ---------\n      D) Any time a SACK arrives,\
    \ the endpoint performs the following:\n            i) If Cumulative TSN Ack is\
    \ less than the Cumulative TSN Ack\n            Point, then drop the SACK.  Since\
    \ Cumulative TSN Ack is\n            monotonically increasing, a SACK whose Cumulative\
    \ TSN Ack is\n            less than the Cumulative TSN Ack Point indicates an\
    \ out-of-\n            order SACK.\n            ii) Set rwnd equal to the newly\
    \ received a_rwnd minus the\n            number of bytes still outstanding after\
    \ processing the\n            Cumulative TSN Ack and the Gap Ack Blocks.\n   \
    \         iii) If the SACK is missing a TSN that was previously\n            acknowledged\
    \ via a Gap Ack Block (e.g., the data receiver\n            reneged on the data),\
    \ then consider the corresponding DATA\n            that might be possibly missing:\
    \ Count one miss indication\n            towards fast retransmit as described\
    \ in Section 7.2.4, and\n            if no retransmit timer is running for the\
    \ destination\n            address to which the DATA chunk was originally transmitted,\n\
    \            then T3-rtx is started for that destination address.\n          \
    \  iv) If the Cumulative TSN Ack matches or exceeds the Fast\n            Recovery\
    \ exitpoint (Section 7.2.4), Fast Recovery is exited.\n   ---------\n   Old text:\
    \ (Section 7.2.4)\n   ---------\n   Whenever an endpoint receives a SACK that\
    \ indicates some TSN(s)\n   missing, it SHOULD wait for 3 further miss indications\
    \ (via\n   subsequent SACK's) on the same TSN(s) before taking action with\n \
    \  regard to Fast Retransmit.\n   When the TSN(s) is reported as missing in the\
    \ fourth consecutive\n   SACK, the data sender shall:\n   1) Mark the missing\
    \ DATA chunk(s) for retransmission,\n   2) Adjust the ssthresh and cwnd of the\
    \ destination address(es) to\n      which the missing DATA chunks were last sent,\
    \ according to the\n      formula described in Section 7.2.3.\n   3) Determine\
    \ how many of the earliest (i.e., lowest TSN) DATA chunks\n      marked for retransmission\
    \ will fit into a single packet, subject\n      to constraint of the path MTU\
    \ of the destination transport address\n      to which the packet is being sent.\
    \  Call this value K.  Retransmit\n      those K DATA chunks in a single packet.\n\
    \   4) Restart T3-rtx timer only if the last SACK acknowledged the lowest\n  \
    \    outstanding TSN number sent to that address, or the endpoint is\n      retransmitting\
    \ the first outstanding DATA chunk sent to that\n      address.\n   Note: Before\
    \ the above adjustments, if the received SACK also\n   acknowledges new DATA chunks\
    \ and advances the Cumulative TSN Ack\n   Point, the cwnd adjustment rules defined\
    \ in Sections 7.2.1 and 7.2.2\n   must be applied first.\n   A straightforward\
    \ implementation of the above keeps a counter for\n   each TSN hole reported by\
    \ a SACK.  The counter increments for each\n   consecutive SACK reporting the\
    \ TSN hole.  After reaching 4 and\n   starting the fast retransmit procedure,\
    \ the counter resets to 0.\n   Because cwnd in SCTP indirectly bounds the number\
    \ of outstanding\n   TSN's, the effect of TCP fast-recovery is achieved automatically\
    \ with\n   no adjustment to the congestion control window size.\n   ---------\n\
    \   New text: (Section 7.2.4)\n   ---------\n   Whenever an endpoint receives\
    \ a SACK that indicates that some TSNs\n   are missing, it SHOULD wait for 3 further\
    \ miss indications (via\n   subsequent SACKs) on the same TSN(s) before taking\
    \ action with\n   regard to Fast Retransmit.\n   Miss indications SHOULD follow\
    \ the HTNA (Highest TSN Newly\n   Acknowledged) algorithm.  For each incoming\
    \ SACK, miss\n   indications are incremented only for missing TSNs prior to\n\
    \   the highest TSN newly acknowledged in the SACK.  A newly\n   acknowledged\
    \ DATA chunk is one not previously acknowledged\n   in a SACK.  If an endpoint\
    \ is in Fast Recovery and a SACK\n   arrives that advances the Cumulative TSN\
    \ Ack Point, the\n   miss indications are incremented for all TSNs reported\n\
    \   missing in the SACK.\n   When the fourth consecutive miss indication is received\
    \ for a TSN(s),\n   the data sender shall do the following:\n   1) Mark the DATA\
    \ chunk(s) with four miss indications for\n      retransmission.\n   2) If not\
    \ in Fast Recovery, adjust the ssthresh and cwnd of the\n      destination address(es)\
    \ to which the missing DATA chunks were\n      last sent, according to the formula\
    \ described in Section 7.2.3.\n   3) Determine how many of the earliest (i.e.,\
    \ lowest TSN) DATA chunks\n      marked for retransmission will fit into a single\
    \ packet, subject\n      to constraint of the path MTU of the destination transport\
    \ address\n      to which the packet is being sent.  Call this value K.  Retransmit\n\
    \      those K DATA chunks in a single packet.  When a Fast Retransmit is\n  \
    \    being performed, the sender SHOULD ignore the value of cwnd and\n      SHOULD\
    \ NOT delay retransmission for this single packet.\n   4) Restart T3-rtx timer\
    \ only if the last SACK acknowledged the lowest\n      outstanding TSN number\
    \ sent to that address, or the endpoint is\n      retransmitting the first outstanding\
    \ DATA chunk sent to that\n      address.\n   5) Mark the DATA chunk(s) as being\
    \ fast retransmitted and thus\n      ineligible for a subsequent fast retransmit.\
    \  Those TSNs marked\n      for retransmission due to the Fast Retransmit algorithm\
    \ that\n      did not fit in the sent datagram carrying K other TSNs are also\n\
    \      marked as ineligible for a subsequent fast retransmit.  However,\n    \
    \  as they are marked for retransmission they will be retransmitted\n      later\
    \ on as soon as cwnd allows.\n   6) If not in Fast Recovery, enter Fast Recovery\
    \ and mark the highest\n      outstanding TSN as the Fast Recovery exit point.\
    \  When a SACK\n      acknowledges all TSNs up to and including this exit point,\
    \ Fast\n      Recovery is exited.  While in Fast Recovery, the ssthresh and cwnd\n\
    \      SHOULD NOT change for any destinations due to a subsequent Fast\n     \
    \ Recovery event (i.e., one SHOULD NOT reduce the cwnd further due\n      to a\
    \ subsequent fast retransmit).\n   Note: Before the above adjustments, if the\
    \ received SACK also\n   acknowledges new DATA chunks and advances the Cumulative\
    \ TSN Ack\n   Point, the cwnd adjustment rules defined in Sections 7.2.1 and 7.2.2\n\
    \   must be applied first.\n"
- title: 2.8.3.  Solution Description
  contents:
  - "2.8.3.  Solution Description\n   The effect of the above wording changes are\
    \ as follows:\n   o  It requires with a MUST the sending of GAP Ack blocks instead\
    \ of\n      the current RFC 2960 [5] SHOULD.\n   o  It allows a TSN being Fast\
    \ Retransmitted (FR) to be sent only once\n      via FR.\n   o  It ends the delay\
    \ in waiting for the flight size to drop when a\n      TSN is identified as being\
    \ ready to FR.\n   o  It changes the way chunks are marked during fast retransmit,\
    \ so\n      that only new reports are counted.\n   o  It introduces a Fast Recovery\
    \ period to avoid multiple congestion\n      window reductions when there are\
    \ multiple losses in a single RTT\n      (as shown by Caro et al. [3]).\n   These\
    \ changes will effectively allow SCTP to follow a similar model\n   as TCP+SACK\
    \ in the handling of Fast Retransmit.\n"
- title: 2.9.  Missing Statement about partial_bytes_acked Update
  contents:
  - '2.9.  Missing Statement about partial_bytes_acked Update

    '
- title: 2.9.1.  Description of the Problem
  contents:
  - "2.9.1.  Description of the Problem\n   SCTP uses four control variables to regulate\
    \ its transmission rate:\n   rwnd, cwnd, ssthresh, and partial_bytes_acked.  Upon\
    \ detection of\n   packet losses from SACK, or when the T3-rtx timer expires on\
    \ an\n   address, cwnd and ssthresh should be updated as stated in Section\n \
    \  7.2.3.  However, that section should also clarify that\n   partial_bytes_acked\
    \ must be updated as well; it has to be reset to 0.\n"
- title: 2.9.2.  Text Changes to the Document
  contents:
  - "2.9.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 7.2.3)\n\
    \   ---------\n   7.2.3 Congestion Control\n   Upon detection of packet losses\
    \ from SACK  (see Section 7.2.4), An\n   endpoint should do the following:\n \
    \     ssthresh = max(cwnd/2, 2*MTU)\n      cwnd = ssthresh\n   Basically, a packet\
    \ loss causes cwnd to be cut in half.\n   When the T3-rtx timer expires on an\
    \ address, SCTP should perform slow\n   start by:\n      ssthresh = max(cwnd/2,\
    \ 2*MTU)\n      cwnd = 1*MTU\n   ---------\n   New text: (Section 7.2.3)\n   ---------\n\
    \   7.2.3.  Congestion Control\n   Upon detection of packet losses from SACK (see\
    \ Section 7.2.4), an\n   endpoint should do the following if not in Fast Recovery:\n\
    \      ssthresh = max(cwnd/2, 2*MTU)\n      cwnd = ssthresh\n      partial_bytes_acked\
    \ = 0\n   Basically, a packet loss causes cwnd to be cut in half.\n   When the\
    \ T3-rtx timer expires on an address, SCTP should perform slow\n   start by\n\
    \      ssthresh = max(cwnd/2, 2*MTU)\n      cwnd = 1*MTU\n      partial_bytes_acked\
    \ = 0\n"
- title: 2.9.3.  Solution Description
  contents:
  - "2.9.3.  Solution Description\n   The missing text added solves the doubts about\
    \ what to do with\n   partial_bytes_acked in the situations stated in Section\
    \ 7.2.3, making\n   clear that, along with ssthresh and cwnd, partial_bytes_acked\
    \ should\n   also be updated by being reset to 0.\n"
- title: 2.10.  Issues with Heartbeating and Failure Detection
  contents:
  - '2.10.  Issues with Heartbeating and Failure Detection

    '
- title: 2.10.1.  Description of the Problem
  contents:
  - "2.10.1.  Description of the Problem\n   Five basic problems have been discovered\
    \ with the current heartbeat\n   procedures:\n   o  The current specification\
    \ does not specify that you should count a\n      failed heartbeat as an error\
    \ against the overall association.\n   o  The current specification is not specific\
    \ as to when you start\n      sending heartbeats and when you should stop.\n \
    \  o  The current specification is not specific as to when you should\n      respond\
    \ to heartbeats.\n   o  When responding to a Heartbeat, it is unclear what to\
    \ do if more\n      than a single TLV is present.\n   o  The jitter applied to\
    \ a heartbeat was meant to be a small variance\n      of the RTO and is currently\
    \ a wide variance, due to the default\n      delay time and incorrect wording\
    \ within the RFC.\n"
- title: 2.10.2.  Text Changes to the Document
  contents:
  - "2.10.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 8.1)\n\
    \   ---------\n   8.1 Endpoint Failure Detection\n   An endpoint shall keep a\
    \ counter on the total number of consecutive\n   retransmissions to its peer (including\
    \ retransmissions to all the\n   destination transport addresses of the peer if\
    \ it is multi-homed).\n   If the value of this counter exceeds the limit indicated\
    \ in the\n   protocol parameter 'Association.Max.Retrans', the endpoint shall\n\
    \   consider the peer endpoint unreachable and shall stop transmitting\n   any\
    \ more data to it (and thus the association enters the CLOSED\n   state).  In\
    \ addition, the endpoint shall report the failure to the\n   upper layer, and\
    \ optionally report back all outstanding user data\n   remaining in its outbound\
    \ queue.  The association is automatically\n   closed when the peer endpoint becomes\
    \ unreachable.\n   The counter shall be reset each time a DATA chunk sent to that\
    \ peer\n   endpoint is acknowledged (by the reception of a SACK), or a\n   HEARTBEAT-ACK\
    \ is received from the peer endpoint.\n   ---------\n   New text: (Section 8.1)\n\
    \   ---------\n   8.1.  Endpoint Failure Detection\n   An endpoint shall keep\
    \ a counter on the total number of consecutive\n   retransmissions to its peer\
    \ (this includes retransmissions to all the\n   destination transport addresses\
    \ of the peer if it is multi-homed),\n   including unacknowledged HEARTBEAT Chunks.\
    \  If the value of this\n   counter exceeds the limit indicated in the protocol\
    \ parameter\n   'Association.Max.Retrans', the endpoint shall consider the peer\n\
    \   endpoint unreachable and shall stop transmitting any more data to it\n   (and\
    \ thus the association enters the CLOSED state).  In addition, the\n   endpoint\
    \ MAY report the failure to the upper layer and optionally\n   report back all\
    \ outstanding user data remaining in its outbound\n   queue.  The association\
    \ is automatically closed when the peer\n   endpoint becomes unreachable.\n  \
    \ The counter shall be reset each time a DATA chunk sent to that peer\n   endpoint\
    \ is acknowledged (by the reception of a SACK), or a\n   HEARTBEAT-ACK is received\
    \ from the peer endpoint.\n   ---------\n   Old text: (Section 8.3)\n   ---------\n\
    \   8.3 Path Heartbeat\n   By default, an SCTP endpoint shall monitor the reachability\
    \ of the\n   idle destination transport address(es) of its peer by sending a\n\
    \   HEARTBEAT chunk periodically to the destination transport\n   address(es).\n\
    \   ---------\n   New text: (Section 8.3)\n   ---------\n   8.3 Path Heartbeat\n\
    \   By default, an SCTP endpoint SHOULD monitor the reachability of the\n   idle\
    \ destination transport address(es) of its peer by sending a\n   HEARTBEAT chunk\
    \ periodically to the destination transport\n   address(es).  HEARTBEAT sending\
    \ MAY begin upon reaching the\n   ESTABLISHED state and is discontinued after\
    \ sending either SHUTDOWN\n   or SHUTDOWN-ACK.  A receiver of a HEARTBEAT MUST\
    \ respond to a\n   HEARTBEAT with a HEARTBEAT-ACK after entering the COOKIE-ECHOED\
    \ state\n   (INIT sender) or the ESTABLISHED state (INIT receiver), up until\n\
    \   reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-\n   ACK-SENT\
    \ state (SHUTDOWN receiver).\n   ---------\n   Old text: (Section 8.3)\n   ---------\n\
    \   The receiver of the HEARTBEAT should immediately respond with a\n   HEARTBEAT\
    \ ACK that contains the Heartbeat Information field copied\n   from the received\
    \ HEARTBEAT chunk.\n   ---------\n   New text: (Section 8.3)\n   ---------\n \
    \  The receiver of the HEARTBEAT should immediately respond with a\n   HEARTBEAT\
    \ ACK that contains the Heartbeat Information TLV, together\n   with any other\
    \ received TLVs, copied unchanged from the received\n   HEARTBEAT chunk.\n   ---------\n\
    \   Old text: (Section 8.3)\n   ---------\n   On an idle destination address that\
    \ is allowed to heartbeat, a\n   HEARTBEAT chunk is RECOMMENDED to be sent once\
    \ per RTO of that\n   destination address plus the protocol parameter 'HB.interval'\
    \ , with\n   jittering of +/- 50%, and exponential back-off of the RTO if the\n\
    \   previous HEARTBEAT is unanswered.\n   ---------\n   New text: (Section 8.3)\n\
    \   ---------\n   On an idle destination address that is allowed to heartbeat,\
    \ it is\n   recommended that a HEARTBEAT chunk is sent once per RTO of that\n\
    \   destination address plus the protocol parameter 'HB.interval', with\n   jittering\
    \ of +/- 50% of the RTO value, and exponential back-off of\n   the RTO if the\
    \ previous HEARTBEAT is unanswered.\n"
- title: 2.10.3.  Solution Description
  contents:
  - "2.10.3.  Solution Description\n   The above text provides guidance as to how\
    \ to respond to the five\n   issues mentioned in Section 2.10.1.  In particular,\
    \ the wording\n   changes provide guidance as to when to start and stop heartbeating,\n\
    \   how to respond to a heartbeat with extra parameters, and it clarifies\n  \
    \ the error counting procedures for the association.\n"
- title: 2.11.  Security interactions with firewalls
  contents:
  - '2.11.  Security interactions with firewalls

    '
- title: 2.11.1.  Description of the Problem
  contents:
  - "2.11.1.  Description of the Problem\n   When dealing with firewalls, it is advantageous\
    \ for the firewall to\n   be able to properly determine the initial startup sequence\
    \ of a\n   reliable transport protocol.  With this in mind, the following text\n\
    \   is to be added to SCTP's security section.\n"
- title: 2.11.2.  Text Changes to the Document
  contents:
  - "2.11.2.  Text Changes to the Document\n   ---------\n   New text: (no old text,\
    \ new section added)\n   ---------\n   11.4 SCTP Interactions with Firewalls\n\
    \   It is helpful for some firewalls if they can inspect\n   just the first fragment\
    \ of a fragmented SCTP packet and unambiguously\n   determine whether it corresponds\
    \ to an INIT chunk (for further\n   information, please refer to RFC1858).  Accordingly,\
    \ we\n   stress the requirements, stated in 3.1, that (1) an INIT chunk MUST\n\
    \   NOT be bundled with any other chunk in a packet, and (2) a packet\n   containing\
    \ an INIT chunk MUST have a zero Verification Tag.\n   Furthermore, we require\
    \ that the receiver of an INIT chunk MUST\n   enforce these rules by silently\
    \ discarding an arriving packet with an\n   INIT chunk that is bundled with other\
    \ chunks.\n   ---------\n   Old text: (Section 18)\n   ---------\n   18.  Bibliography\n\
    \   [ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End\n       \
    \       Network Path Properties\", Proc. SIGCOMM'99, 1999.\n   [FALL96]   Fall,\
    \ K. and Floyd, S., Simulation-based Comparisons of\n              Tahoe, Reno,\
    \ and SACK TCP, Computer Communications Review,\n              V. 26 N. 3, July\
    \ 1996, pp. 5-21.\n   [RFC1750]  Eastlake, D. (ed.), \"Randomness Recommendations\
    \ for\n              Security\", RFC 1750, December 1994.\n   [RFC1950]  Deutsch\
    \ P. and J. Gailly, \"ZLIB Compressed Data Format\n              Specification\
    \ version 3.3\", RFC 1950, May 1996.\n   [RFC2104]  Krawczyk, H., Bellare, M.\
    \ and R. Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104, March 1997.\n   [RFC2196]  Fraser, B., \"Site Security Handbook\"\
    , FYI 8, RFC 2196,\n              September 1997.\n   [RFC2522]  Karn, P. and\
    \ W. Simpson, \"Photuris: Session-Key Management\n              Protocol\", RFC\
    \ 2522, March 1999.\n   [SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and\
    \ Anderson, T.,\n              \"TCP Congestion Control with a Misbehaving Receiver\"\
    , ACM\n              Computer Communication Review, 29(5), October 1999.\n   ---------\n\
    \   New text: (Section 18)\n   ---------\n   18.  Bibliography\n   [ALLMAN99]\
    \ Allman, M. and Paxson, V., \"On Estimating End-to-End\n              Network\
    \ Path Properties\", Proc. SIGCOMM'99, 1999.\n   [FALL96]   Fall, K. and Floyd,\
    \ S., Simulation-based Comparisons of\n              Tahoe, Reno, and SACK TCP,\
    \ Computer Communications Review,\n              V. 26 N. 3, July 1996, pp.  5-21.\n\
    \   [RFC1750]  Eastlake, D. (ed.), \"Randomness Recommendations for\n        \
    \      Security\", RFC 1750, December 1994.\n   [RFC1858]  Ziemba, G., Reed, D.\
    \ and Traina P., \"Security\n              Considerations for IP Fragment Filtering\"\
    , RFC 1858,\n              October 1995.\n   [RFC1950]  Deutsch P. and J. Gailly,\
    \ \"ZLIB Compressed Data Format\n              Specification version 3.3\", RFC\
    \ 1950, May 1996.\n   [RFC2104]  Krawczyk, H., Bellare, M. and R. Canetti, \"\
    HMAC:  Keyed-\n              Hashing for Message Authentication\", RFC 2104, March\
    \ 1997.\n   [RFC2196]  Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196,\n\
    \              September 1997.\n   [RFC2522]  Karn, P. and W. Simpson, \"Photuris:\
    \ Session-Key Management\n              Protocol\", RFC 2522, March 1999.\n  \
    \ [SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T.,\n    \
    \          \"TCP Congestion Control with a Misbehaving Receiver\", ACM\n     \
    \         Computer Communication Review, 29(5), October 1999.\n"
- title: 2.11.3.  Solution Description
  contents:
  - "2.11.3.  Solution Description\n   The above text, which adds a new subsection\
    \ to the Security\n   Considerations section of RFC 2960 [5] makes clear that,\
    \ to make\n   easier the interaction with firewalls, an INIT chunk must not be\n\
    \   bundled in any case with any other chunk that will silently discard\n   the\
    \ packets that do not follow this rule (this rule is enforced by\n   the packet\
    \ receiver).\n"
- title: 2.12.  Shutdown Ambiguity
  contents:
  - '2.12.  Shutdown Ambiguity

    '
- title: 2.12.1.  Description of the Problem
  contents:
  - "2.12.1.  Description of the Problem\n   Currently, there is an ambiguity between\
    \ the statements in Sections\n   6.2 and 9.2.  Section 6.2 allows the sending\
    \ of a SHUTDOWN chunk in\n   place of a SACK when the sender is in the process\
    \ of shutting down,\n   while section 9.2 requires that both a SHUTDOWN chunk\
    \ and a SACK\n   chunk be sent.\n   Along with this ambiguity there is a problem\
    \ wherein an errant\n   SHUTDOWN receiver may fail to stop accepting user data.\n"
- title: 2.12.2.  Text Changes to the Document
  contents:
  - "2.12.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 9.2)\n\
    \   ---------\n   If there are still outstanding DATA chunks left, the SHUTDOWN\n\
    \   receiver shall continue to follow normal data transmission procedures\n  \
    \ defined in Section 6 until all outstanding DATA chunks are\n   acknowledged;\
    \ however, the SHUTDOWN receiver MUST NOT accept new data\n   from its SCTP user.\n\
    \   While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n   respond\
    \ to each received packet containing one or more DATA chunk(s)\n   with a SACK,\
    \ a SHUTDOWN chunk, and restart the T2-shutdown timer.  If\n   it has no more\
    \ outstanding DATA chunks, the SHUTDOWN receiver shall\n   send a SHUTDOWN ACK\
    \ and start a T2-shutdown timer of its own,\n   entering the SHUTDOWN-ACK-SENT\
    \ state.  If the timer expires, the\n   endpoint must re-send the SHUTDOWN ACK.\n\
    \   ---------\n   New text: (Section 9.2)\n   ---------\n   If there are still\
    \ outstanding DATA chunks left, the SHUTDOWN\n   receiver MUST continue to follow\
    \ normal data transmission procedures\n   defined in Section 6, until all outstanding\
    \ DATA chunks are\n   acknowledged; however, the SHUTDOWN receiver MUST NOT accept\
    \ new data\n   from its SCTP user.\n   While in SHUTDOWN-SENT state, the SHUTDOWN\
    \ sender MUST immediately\n   respond to each received packet containing one or\
    \ more DATA chunks\n   with a SHUTDOWN chunk and restart the T2-shutdown timer.\
    \  If a\n   SHUTDOWN chunk by itself cannot acknowledge all of the received DATA\n\
    \   chunks (i.e., there are TSNs that can be acknowledged that are larger\n  \
    \ than the cumulative TSN, and thus gaps exist in the TSN sequence), or\n   if\
    \ duplicate TSNs have been received, then a SACK chunk MUST also be\n   sent.\n\
    \   The sender of the SHUTDOWN MAY also start an overall guard timer\n   'T5-shutdown-guard'\
    \ to bound the overall time for shutdown sequence.\n   At the expiration of this\
    \ timer, the sender SHOULD abort the\n   association by sending an ABORT chunk.\
    \  If the 'T5-shutdown-guard'\n   timer is used, it SHOULD be set to the recommended\
    \ value of 5 times\n   'RTO.Max'.\n   If the receiver of the SHUTDOWN has no more\
    \ outstanding DATA chunks,\n   the SHUTDOWN receiver MUST send a SHUTDOWN ACK\
    \ and start a\n   T2-shutdown timer of its own, entering the SHUTDOWN-ACK-SENT\
    \ state.\n   If the timer expires, the endpoint must re-send the SHUTDOWN ACK.\n"
- title: 2.12.3.  Solution Description
  contents:
  - "2.12.3.  Solution Description\n   The above text clarifies the use of a SACK\
    \ in conjunction with a\n   SHUTDOWN chunk.  It also adds a guard timer to the\
    \ SCTP shutdown\n   sequence to protect against errant receivers of SHUTDOWN chunks.\n"
- title: 2.13.  Inconsistency in ABORT Processing
  contents:
  - '2.13.  Inconsistency in ABORT Processing

    '
- title: 2.13.1.  Description of the Problem
  contents:
  - "2.13.1.  Description of the Problem\n   It was noted that the wording in Section\
    \ 8.5.1 did not give proper\n   directions in the use of the 'T bit' with the\
    \ Verification Tags.\n"
- title: 2.13.2.  Text changes to the document
  contents:
  - "2.13.2.  Text changes to the document\n   ---------\n   Old text: (Section 8.5.1)\n\
    \   ---------\n   B) Rules for packet carrying ABORT:\n      -  The endpoint shall\
    \ always fill in the Verification Tag field\n         of the outbound packet with\
    \ the destination endpoint's tag\n         value if it is known.\n      -  If\
    \ the ABORT is sent in response to an OOTB packet, the\n         endpoint MUST\
    \ follow the procedure described in Section 8.4.\n      -  The receiver MUST accept\
    \ the packet if the Verification Tag\n         matches either its own tag, OR\
    \ the tag of its peer.  Otherwise,\n         the receiver MUST silently discard\
    \ the packet and take no\n         further action.\n   ---------\n   New text:\
    \ (Section 8.5.1)\n   ---------\n   B) Rules for packet carrying ABORT:\n    \
    \  -  The endpoint MUST always fill in the Verification Tag field of\n       \
    \  the outbound packet with the destination endpoint's tag value,\n         if\
    \ it is known.\n      -  If the ABORT is sent in response to an OOTB packet, the\n\
    \         endpoint MUST follow the procedure described in Section 8.4.\n     \
    \ -  The receiver of a ABORT MUST accept the packet if the\n         Verification\
    \ Tag field of the packet matches its own tag OR if\n         it is set to its\
    \ peer's tag and the T bit is set in the Chunk\n         Flags.  Otherwise, the\
    \ receiver MUST silently discard the\n         packet and take no further action.\n"
- title: 2.13.3.  Solution Description
  contents:
  - "2.13.3.  Solution Description\n   The above text change clarifies that the T\
    \ bit must be set before an\n   implementation looks for the peer's tag.\n"
- title: 2.14.  Cwnd Gated by Its Full Use
  contents:
  - '2.14.  Cwnd Gated by Its Full Use

    '
- title: 2.14.1.  Description of the Problem
  contents:
  - "2.14.1.  Description of the Problem\n   A problem was found with the current\
    \ specification of the growth and\n   decay of cwnd.  The cwnd should only be\
    \ increased if it is being\n   fully utilized, and after periods of underutilization,\
    \ the cwnd\n   should be decreased.  In some sections, the current wording is\
    \ weak\n   and is not clearly defined.  Also, the current specification\n   unnecessarily\
    \ introduces the need for special case code to ensure\n   cwnd degradation.  Plus,\
    \ the cwnd should not be increased during Fast\n   Recovery, since a full cwnd\
    \ during Fast Recovery does not qualify the\n   cwnd as being fully utilized.\
    \  Additionally, multiple loss scenarios\n   in a single window may cause the\
    \ cwnd to grow more rapidly as the\n   number of losses in a window increases\
    \ [3].\n"
- title: 2.14.2.  Text Changes to the Document
  contents:
  - "2.14.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.1)\n\
    \   ---------\n   D) Then, the sender can send out as many new DATA chunks as\
    \ Rule A\n      and Rule B above allow.\n   ---------\n   New text: (Section 6.1)\n\
    \   ---------\n   D) When the time comes for the sender to transmit new DATA chunks,\n\
    \      the protocol parameter Max.Burst SHOULD be used to limit the\n      number\
    \ of packets sent.  The limit MAY be applied by adjusting\n      cwnd as follows:\n\
    \      if((flightsize + Max.Burst*MTU) < cwnd)\n         cwnd = flightsize + Max.Burst*MTU\n\
    \      Or it MAY be applied by strictly limiting the number of packets\n     \
    \ emitted by the output routine.\n   E) Then, the sender can send out as many\
    \ new DATA chunks as Rule A\n      and Rule B allow.\n   ---------\n   Old text:\
    \ (Section 7.2.1)\n   ---------\n   o  When cwnd is less than or equal to ssthresh\
    \ an SCTP endpoint MUST\n      use the slow start algorithm to increase cwnd (assuming\
    \ the\n      current congestion window is being fully utilized).  If an\n    \
    \  incoming SACK advances the Cumulative TSN Ack Point, cwnd MUST be\n      increased\
    \ by at most the lesser of 1) the total size of the\n      previously outstanding\
    \ DATA chunk(s) acknowledged, and 2) the\n      destination's path MTU.  This\
    \ protects against the ACK-Splitting\n      attack outlined in [SAVAGE99].\n \
    \  ---------\n   New text: (Section 7.2.1)\n   ---------\n   o  When cwnd is less\
    \ than or equal to ssthresh, an SCTP endpoint MUST\n      use the slow start algorithm\
    \ to increase cwnd only if the current\n      congestion window is being fully\
    \ utilized, an incoming SACK\n      advances the Cumulative TSN Ack Point, and\
    \ the data sender is not\n      in Fast Recovery.  Only when these three conditions\
    \ are met can\n      the cwnd be increased; otherwise, the cwnd MUST not be increased.\n\
    \      If these conditions are met, then cwnd MUST be increased by, at\n     \
    \ most, the lesser of 1) the total size of the previously\n      outstanding DATA\
    \ chunk(s) acknowledged, and 2) the destination's\n      path MTU.  This upper\
    \ bound protects against the ACK-Splitting\n      attack outlined in [SAVAGE99].\n\
    \   ---------\n   Old text: (Section 14)\n   ---------\n   14.  Suggested SCTP\
    \ Protocol Parameter Values\n   The following protocol parameters are RECOMMENDED:\n\
    \   RTO.Initial              - 3  seconds\n   RTO.Min                  - 1  second\n\
    \   RTO.Max                 -  60 seconds\n   RTO.Alpha                - 1/8\n\
    \   RTO.Beta                 - 1/4\n   Valid.Cookie.Life        - 60  seconds\n\
    \   Association.Max.Retrans  - 10 attempts\n   Path.Max.Retrans         - 5  attempts\
    \ (per destination address)\n   Max.Init.Retransmits     - 8  attempts\n   HB.interval\
    \              - 30 seconds\n   ---------\n   New text: (Section 14)\n   ---------\n\
    \   14.  Suggested SCTP Protocol Parameter Values\n   The following protocol parameters\
    \ are RECOMMENDED:\n   RTO.Initial              - 3  seconds\n   RTO.Min     \
    \             - 1  second\n   RTO.Max                  - 60 seconds\n   Max.Burst\
    \                - 4\n   RTO.Alpha                - 1/8\n   RTO.Beta         \
    \        - 1/4\n   Valid.Cookie.Life        - 60 seconds\n   Association.Max.Retrans\
    \  - 10 attempts\n   Path.Max.Retrans         - 5  attempts (per destination address)\n\
    \   Max.Init.Retransmits     - 8  attempts\n   HB.Interval              - 30 seconds\n"
- title: 2.14.3.  Solution Description
  contents:
  - "2.14.3.  Solution Description\n   The above changes strengthen the rules and\
    \ make it much more apparent\n   as to the need to block cwnd growth when the\
    \ full cwnd is not being\n   utilized.  The changes also apply cwnd degradation\
    \ without\n   introducing the need for complex special case code.\n"
- title: 2.15.  Window Probes in SCTP
  contents:
  - '2.15.  Window Probes in SCTP

    '
- title: 2.15.1.  Description of the Problem
  contents:
  - "2.15.1.  Description of the Problem\n   When a receiver clamps its rwnd to 0\
    \ to flow control the peer, the\n   specification implies that one must continue\
    \ to accept data from the\n   remote peer.  This is incorrect and needs clarification.\n"
- title: 2.15.2.  Text Changes to the Document
  contents:
  - "2.15.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.2)\n\
    \   ---------\n   The SCTP endpoint MUST always acknowledge the receipt of each\
    \ valid\n   DATA chunk.\n   ---------\n   New text: (Section 6.2)\n   ---------\n\
    \   The SCTP endpoint MUST always acknowledge the reception of each valid\n  \
    \ DATA chunk when the DATA chunk received is inside its receive window.\n   When\
    \ the receiver's advertised window is 0, the receiver MUST drop\n   any new incoming\
    \ DATA chunk with a TSN larger than the largest TSN\n   received so far.  If the\
    \ new incoming DATA chunk holds a TSN value\n   less than the largest TSN received\
    \ so far, then the receiver SHOULD\n   drop the largest TSN held for reordering\
    \ and accept the new incoming\n   DATA chunk.  In either case, if such a DATA\
    \ chunk is dropped, the\n   receiver MUST immediately send back a SACK with the\
    \ current receive\n   window showing only DATA chunks received and accepted so\
    \ far.  The\n   dropped DATA chunk(s) MUST NOT be included in the SACK, as they\
    \ were\n   not accepted.  The receiver MUST also have an algorithm for\n   advertising\
    \ its receive window to avoid receiver silly window\n   syndrome (SWS), as described\
    \ in RFC 813.  The algorithm can be\n   similar to the one described in Section\
    \ 4.2.3.3 of RFC 1122.\n   ---------\n   Old text: (Section 6.1)\n   ---------\n\
    \   A) At any given time, the data sender MUST NOT transmit new data to\n    \
    \  any destination transport address if its peer's rwnd indicates\n      that\
    \ the peer has no buffer space (i.e., rwnd is 0, see Section\n      6.2.1).  However,\
    \ regardless of the value of rwnd (including if it\n      is 0), the data sender\
    \ can always have one DATA chunk in flight to\n      the receiver if allowed by\
    \ cwnd (see rule B below).  This rule\n      allows the sender to probe for a\
    \ change in rwnd that the sender\n      missed due to the SACK having been lost\
    \ in transit from the data\n      receiver to the data sender.\n   ---------\n\
    \   New text: (Section 6.1)\n   ---------\n   A) At any given time, the data sender\
    \ MUST NOT transmit new data to\n      any destination transport address if its\
    \ peer's rwnd indicates\n      that the peer has no buffer space (i.e., rwnd is\
    \ 0; see Section\n      6.2.1).  However, regardless of the value of rwnd (including\
    \ if it\n      is 0), the data sender can always have one DATA chunk in flight\
    \ to\n      the receiver if allowed by cwnd (see rule B, below).  This rule\n\
    \      allows the sender to probe for a change in rwnd that the sender\n     \
    \ missed due to the SACK's having been lost in transit from the data\n      receiver\
    \ to the data sender.\n      When the receiver's advertised window is zero, this\
    \ probe is\n      called a zero window probe.  Note that a zero window probe\n\
    \      SHOULD only be sent when all outstanding DATA chunks have\n      been cumulatively\
    \ acknowledged and no DATA chunks are in\n      flight.  Zero window probing MUST\
    \ be supported.\n      If the sender continues to receive new packets from the\
    \ receiver\n      while doing zero window probing, the unacknowledged window probes\n\
    \      should not increment the error counter for the association or any\n   \
    \   destination transport address.This is because the receiver MAY\n      keep\
    \ its window closed for an indefinite time.  Refer to\n      Section 6.2 on the\
    \ receiver behavior when it advertises a zero\n      window.  The sender SHOULD\
    \ send the first zero window probe after\n      1 RTO when it detects that the\
    \ receiver has closed its window\n      and SHOULD increase the probe interval\
    \ exponentially afterwards.\n      Also note that the cwnd SHOULD be adjusted\
    \ according to\n      Section 7.2.1.  Zero window probing does not affect the\n\
    \      calculation of cwnd.\n      The sender MUST also have an algorithm for\
    \ sending new DATA chunks\n      to avoid silly window syndrome (SWS) as described\
    \ in RFC 813.  The\n      algorithm can be similar to the one described in Section\
    \ 4.2.3.4\n      of RFC 1122.\n"
- title: 2.15.3.  Solution Description
  contents:
  - "2.15.3.  Solution Description\n   The above allows a receiver to drop new data\
    \ that arrives and yet\n   still requires the receiver to send a SACK showing\
    \ the conditions\n   unchanged (with the possible exception of a new a_rwnd) and\
    \ the\n   dropped chunk as missing.  This will allow the association to\n   continue\
    \ until the rwnd condition clears.\n"
- title: 2.16.  Fragmentation and Path MTU Issues
  contents:
  - '2.16.  Fragmentation and Path MTU Issues

    '
- title: 2.16.1.  Description of the Problem
  contents:
  - "2.16.1.  Description of the Problem\n   The current wording of the Fragmentation\
    \ and Reassembly forces an\n   implementation that supports fragmentation to always\
    \ fragment.  This\n   prohibits an implementation from offering its users an option\
    \ to\n   disable sends that exceed the SCTP fragmentation point.\n   The restriction\
    \ in RFC 2960 [5], Section 6.9, was never meant to\n   restrict an implementations\
    \ API from this behavior.\n"
- title: 2.16.2.  Text Changes to the Document
  contents:
  - "2.16.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.1)\n\
    \   ---------\n   6.9 Fragmentation and Reassembly\n   An endpoint MAY support\
    \ fragmentation when sending DATA chunks, but\n   MUST support reassembly when\
    \ receiving DATA chunks.  If an endpoint\n   supports fragmentation, it MUST fragment\
    \ a user message if the size\n   of the user message to be sent causes the outbound\
    \ SCTP packet size\n   to exceed the current MTU.  If an implementation does not\
    \ support\n   fragmentation of outbound user messages, the endpoint must return\
    \ an\n   error to its upper layer and not attempt to send the user message.\n\
    \   IMPLEMENTATION NOTE:  In this error case, the Send primitive\n   discussed\
    \ in Section 10.1 would need to return an error to the upper\n   layer.\n   ---------\n\
    \   New text: (Section 6.1)\n   ---------\n   6.9.  Fragmentation and Reassembly\n\
    \   An endpoint MAY support fragmentation when sending DATA chunks, but\n   it\
    \ MUST support reassembly when receiving DATA chunks.  If an\n   endpoint supports\
    \ fragmentation, it MUST fragment a user message if\n   the size of the user message\
    \ to be sent causes the outbound SCTP\n   packet size to exceed the current MTU.\
    \  If an implementation does not\n   support fragmentation of outbound user messages,\
    \ the endpoint MUST\n   return an error to its upper layer and not attempt to\
    \ send the user\n   message.\n   Note: If an implementation that supports fragmentation\
    \ makes\n   available to its upper layer a mechanism to turn off fragmentation\
    \ it\n   may do so.  However, in so doing, it MUST react just like an\n   implementation\
    \ that does NOT support fragmentation, i.e., it MUST\n   reject sends that exceed\
    \ the current P-MTU.\n   IMPLEMENTATION NOTE:  In this error case, the Send primitive\n\
    \   discussed in Section 10.1 would need to return an error to the upper\n   layer.\n"
- title: 2.16.3.  Solution Description
  contents:
  - "2.16.3.  Solution Description\n   The above wording will allow an implementation\
    \ to offer the option of\n   rejecting sends that exceed the P-MTU size even when\
    \ the\n   implementation supports fragmentation.\n"
- title: 2.17.  Initial Value of the Cumulative TSN Ack
  contents:
  - '2.17.  Initial Value of the Cumulative TSN Ack

    '
- title: 2.17.1.  Description of the Problem
  contents:
  - "2.17.1.  Description of the Problem\n   The current description of the SACK chunk\
    \ within the RFC does not\n   clearly state the value that would be put within\
    \ a SACK when no DATA\n   chunk has been received.\n"
- title: 2.17.2.  Text Changes to the Document
  contents:
  - "2.17.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.4)\n\
    \   ---------\n   Cumulative TSN Ack: 32 bits (unsigned integer)\n      This parameter\
    \ contains the TSN of the last DATA chunk received in\n      sequence before a\
    \ gap.\n   ---------\n   New text: (Section 3.3.4)\n   ---------\n   Cumulative\
    \ TSN Ack: 32 bits (unsigned integer)\n      This parameter contains the TSN of\
    \ the last DATA chunk received in\n      sequence before a gap.  In the case where\
    \ no DATA chunk has\n      been received, this value is set to the peer's Initial\
    \ TSN minus\n      one.\n"
- title: 2.17.3.  Solution Description
  contents:
  - "2.17.3.  Solution Description\n   This change clearly states what the initial\
    \ value will be for a SACK\n   sender.\n"
- title: 2.18.  Handling of Address Parameters within the INIT or INIT-ACK
  contents:
  - '2.18.  Handling of Address Parameters within the INIT or INIT-ACK

    '
- title: 2.18.1.  Description of the Problem
  contents:
  - "2.18.1.  Description of the Problem\n   The current description on handling address\
    \ parameters contained\n   within the INIT and INIT-ACK does not fully describe\
    \ a requirement\n   for their handling.\n"
- title: 2.18.2.  Text Changes to the Document
  contents:
  - "2.18.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 5.1.2)\n\
    \   ---------\n   C) If there are only IPv4/IPv6 addresses present in the received\
    \ INIT\n      or INIT ACK chunk, the receiver shall derive and record all the\n\
    \      transport address(es) from the received chunk AND the source IP\n     \
    \ address that sent the INIT or INIT ACK.  The transport address(es)\n      are\
    \ derived by the combination of SCTP source port (from the\n      common header)\
    \ and the IP address parameter(s) carried in the INIT\n      or INIT ACK chunk\
    \ and the source IP address of the IP datagram.\n      The receiver should use\
    \ only these transport addresses as\n      destination transport addresses when\
    \ sending subsequent packets to\n      its peer.\n   ---------\n   New text: (Section\
    \ 5.1.2)\n   ---------\n   C) If there are only IPv4/IPv6 addresses present in\
    \ the received INIT\n      or INIT ACK chunk, the receiver MUST derive and record\
    \ all the\n      transport addresses from the received chunk AND the source IP\n\
    \      address that sent the INIT or INIT ACK.  The transport addresses\n    \
    \  are derived by the combination of SCTP source port (from the\n      common\
    \ header) and the IP address parameter(s) carried in the INIT\n      or INIT ACK\
    \ chunk and the source IP address of the IP datagram.\n      The receiver should\
    \ use only these transport addresses as\n      destination transport addresses\
    \ when sending subsequent packets to\n      its peer.\n   D) An INIT or INIT ACK\
    \ chunk MUST be treated as belonging\n      to an already established association\
    \ (or one in the\n      process of being established) if the use of any of the\n\
    \      valid address parameters contained within the chunk\n      would identify\
    \ an existing TCB.\n"
- title: 2.18.3.  Solution description
  contents:
  - "2.18.3.  Solution description\n   This new text clearly specifies to an implementor\
    \ the need to look\n   within the INIT or INIT ACK.  Any implementation that does\
    \ not do\n   this may (for example) not be able to recognize an INIT chunk coming\n\
    \   from an already established association that adds new addresses (see\n   Section\
    \ 2.6) or an incoming INIT ACK chunk sent from a source address\n   different\
    \ from the destination address used to send the INIT chunk.\n"
- title: 2.19.  Handling of Stream Shortages
  contents:
  - '2.19.  Handling of Stream Shortages

    '
- title: 2.19.1.  Description of the Problem
  contents:
  - "2.19.1.  Description of the Problem\n   The current wording in the RFC places\
    \ the choice of sending an ABORT\n   upon the SCTP stack when a stream shortage\
    \ occurs.  This decision\n   should really be made by the upper layer, not the\
    \ SCTP stack.\n"
- title: 2.19.2.  Text Changes to the Document
  contents:
  - "2.19.2.  Text Changes to the Document\n   ---------\n   Old text:\n   ---------\n\
    \   5.1.1 Handle Stream Parameters\n   In the INIT and INIT ACK chunks, the sender\
    \ of the chunk shall\n   indicate the number of outbound streams (OS) it wishes\
    \ to have in\n   the association, as well as the maximum inbound streams (MIS)\
    \ it\n   will accept from the other endpoint.\n   After receiving the stream configuration\
    \ information from the other\n   side, each endpoint shall perform the following\
    \ check:  If the peer's\n   MIS is less than the endpoint's OS, meaning that the\
    \ peer is\n   incapable of supporting all the outbound streams the endpoint wants\n\
    \   to configure, the endpoint MUST either use MIS outbound streams, or\n   abort\
    \ the association and report to its upper layer the resources\n   shortage at\
    \ its peer.\n   ---------\n   New text: (Section 5.1.2)\n   ---------\n   5.1.1.\
    \  Handle Stream Parameters\n   In the INIT and INIT ACK chunks, the sender of\
    \ the chunk MUST\n   indicate the number of outbound streams (OS) it wishes to\
    \ have in\n   the association, as well as the maximum inbound streams (MIS) it\
    \ will\n   accept from the other endpoint.\n   After receiving the stream configuration\
    \ information from the other\n   side, each endpoint MUST perform the following\
    \ check:  If the peer's\n   MIS is less than the endpoint's OS, meaning that the\
    \ peer is\n   incapable of supporting all the outbound streams the endpoint wants\n\
    \   to configure, the endpoint MUST use MIS outbound streams and MAY\n   report\
    \ any shortage to the upper layer.  The upper layer can then\n   choose to abort\
    \ the association if the resource shortage\n   is unacceptable.\n"
- title: 2.19.3.  Solution Description
  contents:
  - "2.19.3.  Solution Description\n   The above changes take the decision to ABORT\
    \ out of the realm of the\n   SCTP stack and place it into the user's hands.\n"
- title: 2.20.  Indefinite Postponement
  contents:
  - '2.20.  Indefinite Postponement

    '
- title: 2.20.1.  Description of the Problem
  contents:
  - "2.20.1.  Description of the Problem\n   The current RFC does not provide any\
    \ guidance on the assignment of\n   TSN sequence numbers to outbound messages\
    \ nor reception of these\n   messages.  This could lead to a possible indefinite\
    \ postponement.\n"
- title: 2.20.2.  Text Changes to the Document
  contents:
  - "2.20.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.1)\n\
    \   ---------\n   Note: The data sender SHOULD NOT use a TSN that is more than\
    \ 2**31 -\n   1 above the beginning TSN of the current send window.\n   6.2  Acknowledgement\
    \ on Reception of DATA Chunks\n   ---------\n   New text: (Section 6.1)\n   ---------\n\
    \   Note: The data sender SHOULD NOT use a TSN that is more than 2**31 -\n   1\
    \ above the beginning TSN of the current send window.\n   The algorithm by which\
    \ an implementation assigns sequential TSNs to\n   messages on a particular association\
    \ MUST ensure that no user\n   message that has been accepted by SCTP is indefinitely\
    \ postponed\n   from being assigned a TSN.  Acceptable algorithms for assigning\
    \ TSNs\n   include\n   (a) assigning TSNs in round-robin order over all streams\
    \ with\n       pending data; and\n   (b) preserving the linear order in which\
    \ the user messages were\n       submitted to the SCTP association.\n   When an\
    \ upper layer requests to read data on an SCTP association,\n   the SCTP receiver\
    \ SHOULD choose the message with the lowest TSN from\n   among all deliverable\
    \ messages.  In SCTP implementations that allow a\n   user to request data on\
    \ a specific stream, this operation SHOULD NOT\n   block if data is not available,\
    \ since this can lead to a deadlock\n   under certain conditions.\n   6.2.  Acknowledgement\
    \ on Receipt of DATA Chunks\n"
- title: 2.20.3.  Solution Description
  contents:
  - "2.20.3.  Solution Description\n   The above wording clarifies how TSNs SHOULD\
    \ be assigned by the\n   sender.\n"
- title: 2.21.  User-Initiated Abort of an Association
  contents:
  - '2.21.  User-Initiated Abort of an Association

    '
- title: 2.21.1.  Description of the Problem
  contents:
  - "2.21.1.  Description of the Problem\n   It is not possible for an upper layer\
    \ to abort the association and\n   provide the peer with an indication of why\
    \ the association is\n   aborted.\n"
- title: 2.21.2.  Text changes to the document
  contents:
  - "2.21.2.  Text changes to the document\n   Some of the changes given here already\
    \ include changes suggested in\n   Section 2.6 of this document.\n   ---------\n\
    \   Old text: (Section 3.3.10)\n   ---------\n      Cause Code\n      Value  \
    \         Cause Code\n      ---------      ----------------\n       1        \
    \      Invalid Stream Identifier\n       2              Missing Mandatory Parameter\n\
    \       3              Stale Cookie Error\n       4              Out of Resource\n\
    \       5              Unresolvable Address\n       6              Unrecognized\
    \ Chunk Type\n       7              Invalid Mandatory Parameter\n       8    \
    \          Unrecognized Parameters\n       9              No User Data\n     \
    \ 10              Cookie Received While Shutting Down\n   Cause Length: 16 bits\
    \ (unsigned integer)\n      Set to the size of the parameter in bytes, including\
    \ the Cause\n      Code, Cause Length, and Cause-Specific Information fields\n\
    \   Cause-specific Information: variable length\n      This field carries the\
    \ details of the error condition.\n   Sections 3.3.10.1 - 3.3.10.10 define error\
    \ causes for SCTP.\n   Guidelines for the IETF to define new error cause values\
    \ are\n   discussed in Section 13.3.\n   ---------\n   New text: (Section 3.3.10)\n\
    \   ---------\n      Cause Code\n      Value           Cause Code\n      ---------\
    \      ----------------\n       1              Invalid Stream Identifier\n   \
    \    2              Missing Mandatory Parameter\n       3              Stale Cookie\
    \ Error\n       4              Out of Resource\n       5              Unresolvable\
    \ Address\n       6              Unrecognized Chunk Type\n       7           \
    \   Invalid Mandatory Parameter\n       8              Unrecognized Parameters\n\
    \       9              No User Data\n      10              Cookie Received While\
    \ Shutting Down\n      11              Restart of an Association with New Addresses\n\
    \      12              User-Initiated Abort\n   Cause Length: 16 bits (unsigned\
    \ integer)\n      Set to the size of the parameter in bytes, including the Cause\n\
    \      Code, Cause Length, and Cause-Specific Information fields\n   Cause-specific\
    \ Information: variable length\n      This field carries the details of the error\
    \ condition.\n   Sections 3.3.10.1 - 3.3.10.12 define error causes for SCTP.\n\
    \   Guidelines for the IETF to define new error cause values are\n   discussed\
    \ in Section 13.3.\n   ---------\n   New text: (Note: no old text, new error added\
    \ in Section 3.3.10)\n   ---------\n   3.3.10.12.  User-Initiated Abort (12)\n\
    \    Cause of error\n    --------------\n    This error cause MAY be included\
    \ in ABORT chunks that are sent\n    because of an upper layer request.  The upper\
    \ layer can specify\n    an Upper Layer Abort Reason that is transported by SCTP\n\
    \    transparently and MAY be delivered to the upper layer protocol\n    at the\
    \ peer.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |         Cause Code=12         |      Cause Length=Variable    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                    Upper Layer Abort Reason                   /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ---------\n   Old text: (Section 9.1)\n   ---------\n   9.1 Abort of an Association\n\
    \      When an endpoint decides to abort an existing association, it\n      shall\
    \ send an ABORT chunk to its peer endpoint.  The sender MUST\n      fill in the\
    \ peer's Verification Tag in the outbound packet and\n      MUST NOT bundle any\
    \ DATA chunk with the ABORT.\n      An endpoint MUST NOT respond to any received\
    \ packet that contains\n      an ABORT chunk (also see Section 8.4).\n      An\
    \ endpoint receiving an ABORT shall apply the special\n      Verification Tag\
    \ check rules described in Section 8.5.1.\n      After checking the Verification\
    \ Tag, the receiving endpoint shall\n      remove the association from its record\
    \ and shall report the\n      termination to its upper layer.\n      ---------\n\
    \      New text: (Section 9.1)\n      ---------\n      9.1.  Abort of an Association\n\
    \      When an endpoint decides to abort an existing association, it MUST\n  \
    \    send an ABORT chunk to its peer endpoint.  The sender MUST fill in\n    \
    \  the peer's Verification Tag in the outbound packet and MUST NOT\n      bundle\
    \ any DATA chunk with the ABORT.  If the association is\n      aborted on request\
    \ of the upper layer, a User-Initiated Abort\n      error cause (see 3.3.10.12)\
    \ SHOULD be present in the ABORT chunk.\n      An endpoint MUST NOT respond to\
    \ any received packet that contains\n      an ABORT chunk (also see Section 8.4).\n\
    \      An endpoint receiving an ABORT MUST apply the special Verification\n  \
    \    Tag check rules described in Section 8.5.1.\n      After checking the Verification\
    \ Tag, the receiving endpoint MUST\n      remove the association from its record\
    \ and SHOULD report the\n      termination to its upper layer.  If a User-Initiated\
    \ Abort error\n      cause is present in the ABORT chunk, the Upper Layer Abort\
    \ Reason\n      SHOULD be made available to the upper layer.\n   ---------\n \
    \  Old text: (Section 10.1)\n   ---------\n      D) Abort\n      Format: ABORT(association\
    \ id [, cause code])\n      -> result\n      Ungracefully closes an association.\
    \  Any locally queued user\n      data will be discarded and an ABORT chunk is\
    \ sent to the peer.\n      A success code will be returned on successful abortion\
    \ of the\n      association.  If attempting to abort the association results\n\
    \      in a failure, an error code shall be returned.\n      Mandatory attributes:\n\
    \      o  association id - local handle to the SCTP association\n      Optional\
    \ attributes:\n      o  cause code - reason of the abort to be passed to the peer.\n\
    \   ---------\n   New text: (Section 10.1)\n   ---------\n      D) Abort\n   \
    \   Format: ABORT(association id [, Upper Layer Abort Reason])\n      -> result\n\
    \      Ungracefully closes an association.  Any locally queued user\n      data\
    \ will be discarded, and an ABORT chunk is sent to the peer.\n      A success\
    \ code will be returned on successful abortion of the\n      association.  If\
    \ attempting to abort the association results\n      in a failure, an error code\
    \ shall be returned.\n      Mandatory attributes:\n      o  association id - Local\
    \ handle to the SCTP association.\n      Optional attributes:\n      o  Upper\
    \ Layer Abort Reason - Reason of the abort to be passed\n         to the peer.\n\
    \      None.\n   ---------\n   Old text: (Section 10.2)\n   ---------\n      E)\
    \ COMMUNICATION LOST notification\n      When SCTP loses communication to an endpoint\
    \ completely (e.g., via\n      Heartbeats) or detects that the endpoint has performed\
    \ an abort\n      operation, it shall invoke this notification on the ULP.\n \
    \     The following shall be passed with the notification:\n      o  association\
    \ id - local handle to the SCTP association\n      o status - This indicates what\
    \ type of event has occurred; The\n                 status may indicate a failure\
    \ OR a normal termination\n                 event occurred in response to a shutdown\
    \ or abort\n                 request.\n      The following may be passed with\
    \ the notification:\n      o  data retrieval id - an identification used to retrieve\n\
    \         unsent and unacknowledged data.\n      o  last-acked - the TSN last\
    \ acked by that peer endpoint;\n      o  last-sent - the TSN last sent to that\
    \ peer endpoint;\n   ---------\n   New text: (Section 10.2)\n   ---------\n  \
    \    E) COMMUNICATION LOST notification\n      When SCTP loses communication to\
    \ an endpoint completely (e.g., via\n      Heartbeats) or detects that the endpoint\
    \ has performed an abort\n      operation, it shall invoke this notification on\
    \ the ULP.\n      The following shall be passed with the notification:\n     \
    \ o  association id - Local handle to the SCTP association.\n      o  status -\
    \ This indicates what type of event has occurred; The\n                  status\
    \ may indicate that a failure OR a normal\n                  termination event\
    \ occurred in response to a shutdown\n                  or abort request.\n  \
    \    The following may be passed with the notification:\n      o  data retrieval\
    \ id - An identification used to retrieve unsent\n         and unacknowledged\
    \ data.\n      o  last-acked - The TSN last acked by that peer endpoint.\n   \
    \   o  last-sent - The TSN last sent to that peer endpoint.\n      o  Upper Layer\
    \ Abort Reason - The abort reason specified in\n                             \
    \       case of a user-initiated abort.\n"
- title: 2.21.3.  Solution Description
  contents:
  - "2.21.3.  Solution Description\n   The above allows an upper layer to provide\
    \ its peer with an\n   indication of why the association was aborted.  Therefore,\
    \ an\n   addition error cause was introduced.\n"
- title: 2.22.  Handling of Invalid Initiate Tag of INIT-ACK
  contents:
  - '2.22.  Handling of Invalid Initiate Tag of INIT-ACK

    '
- title: 2.22.1.  Description of the Problem
  contents:
  - "2.22.1.  Description of the Problem\n   RFC 2960 requires that the receiver of\
    \ an INIT-ACK with the Initiate\n   Tag set to zero handles this as an error and\
    \ sends back an ABORT.\n   But the sender of the INIT-ACK normally has no TCB,\
    \ and thus the\n   ABORT is useless.\n"
- title: 2.22.2.  Text Changes to the Document
  contents:
  - "2.22.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.3)\n\
    \   ---------\n      Initiate Tag: 32 bits (unsigned integer)\n         The receiver\
    \ of the INIT ACK records the value of the\n         Initiate Tag parameter. \
    \ This value MUST be placed into\n         the Verification Tag field of every\
    \ SCTP packet that the\n         INIT ACK receiver transmits within this association.\n\
    \         The Initiate Tag MUST NOT take the value 0.  See Section 5.3.1\n   \
    \      for more on the selection of the Initiate Tag value.\n         If the value\
    \ of the Initiate Tag in a received INIT ACK chunk\n         is found to be 0,\
    \ the receiver MUST treat it as an error and\n         close the association by\
    \ transmitting an ABORT.\n   ---------\n   New text: (Section 3.3.3)\n   ---------\n\
    \      Initiate Tag: 32 bits (unsigned integer)\n         The receiver of the\
    \ INIT ACK records the value of the\n         Initiate Tag parameter.  This value\
    \ MUST be placed into\n         the Verification Tag field of every SCTP packet\
    \ that the\n         INIT ACK receiver transmits within this association.\n  \
    \       The Initiate Tag MUST NOT take the value 0.  See Section 5.3.1\n     \
    \    for more on the selection of the Initiate Tag value.\n         If the value\
    \ of the Initiate Tag in a received INIT ACK\n         chunk is found to be 0,\
    \ the receiver MUST destroy the\n         association discarding its TCB.  The\
    \ receiver MAY send an\n         ABORT for debugging purpose.\n"
- title: 2.22.3.  Solution Description
  contents:
  - "2.22.3.  Solution Description\n   The new text does not require that the receiver\
    \ of the invalid INIT-\n   ACK send the ABORT.  This behavior is in tune with\
    \ the error case of\n   invalid stream numbers in the INIT-ACK.  However, sending\
    \ an ABORT\n   for debugging purposes is allowed.\n"
- title: 2.23.  Sending an ABORT in Response to an INIT
  contents:
  - '2.23.  Sending an ABORT in Response to an INIT

    '
- title: 2.23.1.  Description of the Problem
  contents:
  - "2.23.1.  Description of the Problem\n   Whenever the receiver of an INIT chunk\
    \ has to send an ABORT chunk in\n   response, for whatever reason, it is not stated\
    \ clearly which\n   Verification Tag and value of the T-bit should be used.\n"
- title: 2.23.2.  Text Changes to the Document
  contents:
  - "2.23.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 8.4)\n\
    \   ---------\n      3) If the packet contains an INIT chunk with a Verification\
    \ Tag\n         set to '0', process it as described in Section 5.1.\n        \
    \ Otherwise,\n   ---------\n   New text: (Section 8.4)\n   ---------\n      3)\
    \ If the packet contains an INIT chunk with a Verification Tag\n         set to\
    \ '0', process it as described in Section 5.1.  If, for\n         whatever reason,\
    \ the INIT cannot be processed normally and\n         an ABORT has to be sent\
    \ in response, the Verification Tag\n         of the packet containing the ABORT\
    \ chunk MUST be the\n         Initiate tag of the received INIT chunk, and the\
    \ T-Bit of\n         the ABORT chunk has to be set to 0, indicating that\n   \
    \      a TCB was destroyed.  Otherwise,\n"
- title: 2.23.3.  Solution Description
  contents:
  - "2.23.3.  Solution Description\n   The new text stated clearly which value of\
    \ the Verification Tag and\n   T-bit have to be used.\n"
- title: 2.24.  Stream Sequence Number (SSN) Initialization
  contents:
  - '2.24.  Stream Sequence Number (SSN) Initialization

    '
- title: 2.24.1.  Description of the Problem
  contents:
  - "2.24.1.  Description of the Problem\n   RFC 2960 does not describe the fact that\
    \ the SSN has to be\n   initialized to 0, as required by RFC 2119.\n"
- title: 2.24.2.  Text Changes to the Document
  contents:
  - "2.24.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.5)\n\
    \   ---------\n      The stream sequence number in all the streams shall start\
    \ from 0\n      when the association is established.  Also, when the stream\n\
    \      sequence number reaches the value 65535 the next stream sequence\n    \
    \  number shall be set to 0.\n   ---------\n   New text: (Section 6.5)\n   ---------\n\
    \      The stream sequence number in all the streams MUST start from 0\n     \
    \ when the association is established.  Also, when the stream\n      sequence\
    \ number reaches the value 65535 the next stream sequence\n      number MUST be\
    \ set to 0.\n"
- title: 2.24.3.  Solution Description
  contents:
  - "2.24.3.  Solution Description\n   The 'shall' in the text is replaced by a 'MUST'\
    \ to clearly state the\n   required behavior.\n"
- title: 2.25.  SACK Packet Format
  contents:
  - '2.25.  SACK Packet Format

    '
- title: 2.25.1.  Description of the Problem
  contents:
  - "2.25.1.  Description of the Problem\n   It is not clear in RFC 2960 whether a\
    \ SACK must contain the fields\n   Number of Gap Ack Blocks and Number of Duplicate\
    \ TSNs.\n"
- title: 2.25.2.  Text Changes to the Document
  contents:
  - "2.25.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.4)\n\
    \   ---------\n      The SACK MUST contain the Cumulative TSN Ack and\n      Advertised\
    \ Receiver Window Credit (a_rwnd) parameters.\n   ---------\n   New text: (Section\
    \ 3.3.4)\n   ---------\n      The SACK MUST contain the Cumulative TSN Ack,\n\
    \      Advertised Receiver Window Credit (a_rwnd), Number\n      of Gap Ack Blocks,\
    \ and Number of Duplicate TSNs fields.\n"
- title: 2.25.3.  Solution Description
  contents:
  - "2.25.3.  Solution Description\n   The text has been modified.  It is now clear\
    \ that a SACK always\n   contains the fields Number of Gap Ack Blocks and Number\
    \ of Duplicate\n   TSNs.\n"
- title: 2.26.  Protocol Violation Error Cause
  contents:
  - '2.26.  Protocol Violation Error Cause

    '
- title: 2.26.1.  Description of the Problem
  contents:
  - "2.26.1.  Description of the Problem\n   There are many situations where an SCTP\
    \ endpoint may detect that its\n   peer violates the protocol.  The result of\
    \ such detection often\n   results in the association being destroyed by the sending\
    \ of an\n   ABORT.  Currently, there are only some error causes that could be\n\
    \   used to indicate the reason for the abort, but these do not cover all\n  \
    \ cases.\n"
- title: 2.26.2.  Text Changes to the Document
  contents:
  - "2.26.2.  Text Changes to the Document\n   Some of the changes given here already\
    \ include changes suggested in\n   Section 2.6 and 2.21 of this document.\n  \
    \ ---------\n   Old text: (Section 3.3.10)\n   ---------\n      Cause Code\n \
    \     Value           Cause Code\n      ---------      ----------------\n    \
    \   1              Invalid Stream Identifier\n       2              Missing Mandatory\
    \ Parameter\n       3              Stale Cookie Error\n       4              Out\
    \ of Resource\n       5              Unresolvable Address\n       6          \
    \    Unrecognized Chunk Type\n       7              Invalid Mandatory Parameter\n\
    \       8              Unrecognized Parameters\n       9              No User\
    \ Data\n      10              Cookie Received While Shutting Down\n   Cause Length:\
    \ 16 bits (unsigned integer)\n      Set to the size of the parameter in bytes,\
    \ including the Cause\n      Code, Cause Length, and Cause-Specific Information\
    \ fields\n   Cause-specific Information: variable length\n      This field carries\
    \ the details of the error condition.\n   Sections 3.3.10.1 - 3.3.10.10 define\
    \ error causes for SCTP.\n   Guidelines for the IETF to define new error cause\
    \ values are\n   discussed in Section 13.3.\n   ---------\n   New text: (Section\
    \ 3.3.10)\n   ---------\n      Cause Code\n      Value           Cause Code\n\
    \      ---------      ----------------\n       1              Invalid Stream Identifier\n\
    \       2              Missing Mandatory Parameter\n       3              Stale\
    \ Cookie Error\n       4              Out of Resource\n       5              Unresolvable\
    \ Address\n       6              Unrecognized Chunk Type\n       7           \
    \   Invalid Mandatory Parameter\n       8              Unrecognized Parameters\n\
    \       9              No User Data\n      10              Cookie Received While\
    \ Shutting Down\n      11              Restart of an Association with New Addresses\n\
    \      12              User Initiated Abort\n      13              Protocol Violation\n\
    \   Cause Length: 16 bits (unsigned integer)\n      Set to the size of the parameter\
    \ in bytes, including the Cause\n      Code, Cause Length, and Cause-Specific\
    \ Information fields\n   Cause-specific Information: variable length\n      This\
    \ field carries the details of the error condition.\n   Sections 3.3.10.1 - 3.3.10.13\
    \ define error causes for SCTP.\n   Guidelines for the IETF to define new error\
    \ cause values are\n   discussed in Section 13.3.\n   ---------\n   New text:\
    \ (Note: no old text; new error added in section 3.3.10)\n   ---------\n   3.3.10.13.\
    \  Protocol Violation (13)\n    Cause of error\n    --------------\n    This error\
    \ cause MAY be included in ABORT chunks that are sent\n    because an SCTP endpoint\
    \ detects a protocol violation of the peer\n    that is not covered by the error\
    \ causes described in 3.3.10.1 to\n    3.3.10.12.  An implementation MAY provide\
    \ additional information\n    specifying what kind of protocol violation has been\
    \ detected.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |         Cause Code=13         |      Cause Length=Variable    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                    Additional Information                     /\n      \\  \
    \                                                             \\\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 2.26.3.  Solution Description
  contents:
  - "2.26.3.  Solution Description\n   An additional error cause has been defined\
    \ that can be used by an\n   endpoint to indicate a protocol violation of the\
    \ peer.\n"
- title: 2.27.  Reporting of Unrecognized Parameters
  contents:
  - '2.27.  Reporting of Unrecognized Parameters

    '
- title: 2.27.1.  Description of the Problem
  contents:
  - "2.27.1.  Description of the Problem\n   It is not stated clearly in RFC 2960\
    \ [5] how unrecognized parameters\n   should be reported.  Unrecognized parameters\
    \ in an INIT chunk could\n   be reported in the INIT-ACK chunk or in a separate\
    \ ERROR chunk, which\n   can get lost.  Unrecognized parameters in an INIT-ACK\
    \ chunk have to\n   be reported in an ERROR-chunk.  This can be bundled with the\
    \ COOKIE-\n   ERROR chunk or sent separately.  If it is sent separately and\n\
    \   received before the COOKIE-ECHO, it will be handled as an OOTB\n   packet,\
    \ resulting in sending out an ABORT chunk.  Therefore, the\n   association would\
    \ not be established.\n"
- title: 2.27.2.  Text Changes to the Document
  contents:
  - "2.27.2.  Text Changes to the Document\n   Some of the changes given here already\
    \ include changes suggested in\n   Section 2.2 of this document.\n   ---------\n\
    \   Old text: (Section 3.2.1)\n   ---------\n   00 - Stop processing this SCTP\
    \ packet and discard it, do not process\n        any further chunks within it.\n\
    \   01 - Stop processing this SCTP packet and discard it, do not process\n   \
    \     any further chunks within it, and report the unrecognized\n        parameter\
    \ in an 'Unrecognized Parameter Type' (in either an\n        ERROR or in the INIT\
    \ ACK).\n   10 - Skip this parameter and continue processing.\n   11 - Skip this\
    \ parameter and continue processing but report the\n        unrecognized parameter\
    \ in an 'Unrecognized Parameter Type' (in\n        either an ERROR or in the INIT\
    \ ACK).\n   ---------\n   New text: (Section 3.2.1)\n   ---------\n   00 - Stop\
    \ processing this SCTP chunk and discard it; do not process\n        any further\
    \ parameters within this chunk.\n   01 - Stop processing this SCTP chunk and discard\
    \ it, do not process\n        any further parameters within this chunk, and report\
    \ the\n        unrecognized parameter in an 'Unrecognized Parameter Type', as\n\
    \        described in 3.2.2.\n   10 - Skip this parameter and continue processing.\n\
    \   11 - Skip this parameter and continue processing but report the\n        unrecognized\
    \ parameter in an 'Unrecognized Parameter Type', as\n        described in 3.2.2.\n\
    \   ---------\n   New text: (Note: no old text; clarification added in Section\
    \ 3.2)\n   ---------\n   3.2.2.  Reporting of Unrecognized Parameters\n      If\
    \ the receiver of an INIT chunk detects unrecognized parameters\n      and has\
    \ to report them according to Section 3.2.1, it MUST put\n      the 'Unrecognized\
    \ Parameter' parameter(s) in the INIT-ACK chunk\n      sent in response to the\
    \ INIT-chunk.  Note that if the receiver\n      of the INIT chunk is NOT going\
    \ to establish an association (e.g.,\n      due to lack of resources), then no\
    \ report would be sent back.\n      If the receiver of an INIT-ACK chunk detects\
    \ unrecognized\n      parameters and has to report them according to Section 3.2.1,\n\
    \      it SHOULD bundle the ERROR chunk containing the\n      'Unrecognized Parameter'\
    \ error cause with the COOKIE-ECHO\n      chunk sent in response to the INIT-ACK\
    \ chunk.  If the\n      receiver of the INIT-ACK cannot bundle the COOKIE-ECHO\
    \ chunk\n      with the ERROR chunk, the ERROR chunk MAY be sent separately\n\
    \      but not before the COOKIE-ACK has been received.\n      Note: Any time\
    \ a COOKIE-ECHO is sent in a packet, it MUST be the\n      first chunk.\n"
- title: 2.27.3.  Solution Description
  contents:
  - "2.27.3.  Solution Description\n   The procedure of reporting unrecognized parameters\
    \ has been described\n   clearly.\n"
- title: 2.28.  Handling of IP Address Parameters
  contents:
  - '2.28.  Handling of IP Address Parameters

    '
- title: 2.28.1.  Description of the Problem
  contents:
  - "2.28.1.  Description of the Problem\n   It is not stated clearly in RFC 2960\
    \ [5] how an SCTP endpoint that\n   supports either IPv4 addresses or IPv6 addresses\
    \ should respond if\n   IPv4 and IPv6 addresses are presented by the peer in the\
    \ INIT or\n   INIT-ACK chunk.\n"
- title: 2.28.2.  Text Changes to the Document
  contents:
  - "2.28.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 5.1.2)\n\
    \   ---------\n      IMPLEMENTATION NOTE: In the case that the receiver of an\
    \ INIT ACK\n      fails to resolve the address parameter due to an unsupported\
    \ type,\n      it can abort the initiation process and then attempt a\n      re-initiation\
    \ by using a 'Supported Address Types' parameter in\n      the new INIT to indicate\
    \ what types of address it prefers.\n   ---------\n   New text: (Section 5.1.2)\n\
    \   ---------\n      IMPLEMENTATION NOTE: In the case that the receiver of an\
    \ INIT ACK\n      fails to resolve the address parameter due to an unsupported\
    \ type,\n      it can abort the initiation process and then attempt a re-\n  \
    \    initiation by using a 'Supported Address Types' parameter in the\n      new\
    \ INIT to indicate what types of address it prefers.\n      IMPLEMENTATION NOTE:\
    \ If an SCTP endpoint that only supports either\n      IPv4 or IPv6 receives IPv4\
    \ and IPv6 addresses in an INIT or INIT-\n      ACK chunk from its peer, it MUST\
    \ use all the addresses belonging\n      to the supported address family.  The\
    \ other addresses MAY be\n      ignored.  The endpoint SHOULD NOT respond with\
    \ any kind of error\n      indication.\n"
- title: 2.28.3.  Solution Description
  contents:
  - "2.28.3.  Solution Description\n   The procedure of handling IP address parameters\
    \ has been described\n   clearly.\n"
- title: 2.29.  Handling of COOKIE ECHO Chunks When a TCB Exists
  contents:
  - '2.29.  Handling of COOKIE ECHO Chunks When a TCB Exists

    '
- title: 2.29.1.  Description of the Problem
  contents:
  - "2.29.1.  Description of the Problem\n   The description of the behavior in RFC\
    \ 2960 [5] when a COOKIE ECHO\n   chunk and a TCB exist could be misunderstood.\
    \  When a COOKIE ECHO is\n   received, a TCB exists and the local tag and peer's\
    \ tag match, it is\n   stated that the endpoint should enter the ESTABLISHED state\
    \ if it has\n   not already done so and send a COOKIE ACK.  It was not clear that,\
    \ in\n   the case the endpoint has already left the ESTABLISHED state again,\n\
    \   then it should not go back to established.  In case D, the endpoint\n   can\
    \ only enter state ESTABLISHED from COOKIE-ECHOED because in state\n   CLOSED\
    \ it has no TCB and in state COOKIE-WAIT it has a TCB but knows\n   nothing about\
    \ the peer's tag, which is requested to match in this\n   case.\n"
- title: 2.29.2.  Text Changes to the Document
  contents:
  - "2.29.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 5.2.4)\n\
    \   ---------\n      D) When both local and remote tags match the endpoint should\n\
    \         always enter the ESTABLISHED state, if it has not already\n        \
    \ done so.  It should stop any init or cookie timers that may\n         be running\
    \ and send a COOKIE ACK.\n   ---------\n   New text: (Section 5.2.4)\n   ---------\n\
    \      D) When both local and remote tags match, the endpoint should\n       \
    \  enter the ESTABLISHED state, if it is in the COOKIE-ECHOED\n         state.\
    \  It should stop any cookie timer that may\n         be running and send a COOKIE\
    \ ACK.\n"
- title: 2.29.3.  Solution Description
  contents:
  - "2.29.3.  Solution Description\n   The procedure of handling of COOKIE-ECHO chunks\
    \ when a TCB exists has\n   been described clearly.\n"
- title: 2.30.  The Initial Congestion Window Size
  contents:
  - '2.30.  The Initial Congestion Window Size

    '
- title: 2.30.1.  Description of the Problem
  contents:
  - "2.30.1.  Description of the Problem\n   RFC 2960 was published with the intention\
    \ of having the same\n   congestion control properties as TCP.  Since the publication\
    \ of RFC\n   2960, TCP's initial congestion window size has been increased via\
    \ RFC\n   3390.  This same update will be needed for SCTP to keep SCTP's\n   congestion\
    \ control properties equivalent to that of TCP.\n"
- title: 2.30.2.  Text Changes to the Document
  contents:
  - "2.30.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 7.2.1)\n\
    \   ---------\n      o  The initial cwnd before DATA transmission or after a\n\
    \         sufficiently long idle period MUST be <= 2*MTU.\n   ---------\n   New\
    \ text: (Section 7.2.1)\n   ---------\n      o  The initial cwnd before DATA transmission\
    \ or after a\n         sufficiently long idle period MUST be set to\n        \
    \ min(4*MTU, max (2*MTU, 4380 bytes)).\n   ---------\n   Old text: (Section 7.2.1)\n\
    \   ---------\n      o  When the endpoint does not transmit data on a given transport\n\
    \         address, the cwnd of the transport address should be adjusted\n    \
    \     to max(cwnd/2, 2*MTU) per RTO.\n   ---------\n   New text: (Section 7.2.1)\n\
    \   ---------\n      o  When the endpoint does not transmit data on a given transport\n\
    \         address, the cwnd of the transport address should be adjusted\n    \
    \     to max(cwnd/2, 4*MTU) per RTO.\n   ---------\n   Old text: (Section 7.2.2)\n\
    \   ---------\n      o  Same as in the slow start, when the sender does not transmit\n\
    \         DATA on a given transport address, the cwnd of the transport\n     \
    \    address should be adjusted to max(cwnd / 2, 2*MTU) per RTO.\n   ---------\n\
    \   New text: (Section 7.2.2)\n   ---------\n      o  Same as in the slow start,\
    \ when the sender does not transmit\n         DATA on a given transport address,\
    \ the cwnd of the transport\n         address should be adjusted to max(cwnd /\
    \ 2, 4*MTU) per RTO.\n   ---------\n   Old text: (Section 7.2.3)\n   ---------\n\
    \   7.2.3.  Congestion Control\n      Upon detection of packet losses from SACK\
    \  (see Section 7.2.4), an\n      endpoint should do the following:\n        \
    \ ssthresh = max(cwnd/2, 2*MTU)\n         cwnd = ssthresh\n      Basically, a\
    \ packet loss causes cwnd to be cut in half.\n      When the T3-rtx timer expires\
    \ on an address, SCTP should perform\n      slow start by\n         ssthresh =\
    \ max(cwnd/2, 2*MTU)\n         cwnd = 1*MTU\n   ---------\n   New text: (Section\
    \ 7.2.3)\n   ---------\n   7.2.3 Congestion Control\n      Upon detection of packet\
    \ losses from SACK  (see Section 7.2.4), An\n      endpoint should do the following:\n\
    \         ssthresh = max(cwnd/2, 4*MTU)\n         cwnd = ssthresh\n      Basically,\
    \ a packet loss causes cwnd to be cut in half.\n      When the T3-rtx timer expires\
    \ on an address, SCTP should perform\n      slow start by:\n         ssthresh\
    \ = max(cwnd/2, 4*MTU)\n         cwnd = 1*MTU\n"
- title: 2.30.3.  Solution Description
  contents:
  - "2.30.3.  Solution Description\n   The change to SCTP's initial congestion window\
    \ will allow it to\n   continue to maintain the same congestion control properties\
    \ as TCP.\n"
- title: 2.31.  Stream Sequence Numbers in Figures
  contents:
  - '2.31.  Stream Sequence Numbers in Figures

    '
- title: 2.31.1.  Description of the Problem
  contents:
  - "2.31.1.  Description of the Problem\n   In Section 2.24 of this document, it\
    \ is clarified that the SSN are\n   initialized with 0.  Two figures in RFC 2960\
    \ [5] illustrate that they\n   start with 1.\n"
- title: 2.31.2.  Text Changes to the Document
  contents:
  - "2.31.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 7.2.1)\n\
    \   ---------\n    Endpoint A                                          Endpoint\
    \ Z\n    {app sets association with Z}\n    (build TCB)\n    INIT [I-Tag=Tag_A\n\
    \          & other info]  ------\\\n    (Start T1-init timer)       \\\n    (Enter\
    \ COOKIE-WAIT state)    \\---> (compose temp TCB and Cookie_Z)\n             \
    \                      /-- INIT ACK [Veri Tag=Tag_A,\n                       \
    \           /             I-Tag=Tag_Z,\n    (Cancel T1-init timer) <-----/   \
    \            Cookie_Z, & other info]\n                                       \
    \    (destroy temp TCB)\n    COOKIE ECHO [Cookie_Z] ------\\\n    (Start T1-init\
    \ timer)         \\\n    (Enter COOKIE-ECHOED state)    \\---> (build TCB enter\
    \ ESTABLISHED\n                                          state)\n            \
    \                       /---- COOKIE-ACK\n                                  /\n\
    \    (Cancel T1-init timer, <-----/\n     Enter ESTABLISHED state)\n    {app sends\
    \ 1st user data; strm 0}\n     DATA [TSN=initial TSN_A\n         Strm=0,Seq=1\
    \ & user data]--\\\n     (Start T3-rtx timer)            \\\n                \
    \                      \\->\n                                  /----- SACK [TSN\
    \ Ack=init\n                                 /              TSN_A,Block=0]\n \
    \  (Cancel T3-rtx timer) <------/\n                                          ...\n\
    \                                          {app sends 2 messages;strm 0}\n   \
    \                                 /---- DATA\n                               \
    \    /        [TSN=init TSN_Z\n                               <--/          Strm=0,Seq=1\
    \ & user data 1]\n   SACK [TSN Ack=init TSN_Z,     /    ---- DATA\n          \
    \  Block=0]     --------\\  /        [TSN=init TSN_Z +1,\n                   \
    \               \\/         Strm=0,Seq=2 & user data 2]\n                    \
    \       <------/\\\n                                    \\\n                 \
    \                    \\------>\n                        Figure 4: INITiation Example\n\
    \   ---------\n   New text: (Section 7.2.1)\n   ---------\n    Endpoint A    \
    \                                      Endpoint Z\n    {app sets association with\
    \ Z}\n    (build TCB)\n    INIT [I-Tag=Tag_A\n          & other info]  ------\\\
    \n    (Start T1-init timer)       \\\n    (Enter COOKIE-WAIT state)    \\--->\
    \ (compose temp TCB and Cookie_Z)\n                                    /-- INIT\
    \ ACK [Veri Tag=Tag_A,\n                                   /             I-Tag=Tag_Z,\n\
    \    (Cancel T1-init timer) <------/              Cookie_Z, & other info]\n  \
    \                                       (destroy temp TCB)\n    COOKIE ECHO [Cookie_Z]\
    \ ------\\\n    (Start T1-init timer)         \\\n    (Enter COOKIE-ECHOED state)\
    \    \\---> (build TCB enter ESTABLISHED\n                                   \
    \       state)\n                                   /---- COOKIE-ACK\n        \
    \                          /\n    (Cancel T1-init timer, <-----/\n     Enter ESTABLISHED\
    \ state)\n    {app sends 1st user data; strm 0}\n    DATA [TSN=initial TSN_A\n\
    \        Strm=0,Seq=0 & user data]--\\\n    (Start T3-rtx timer)            \\\
    \n                                     \\->\n                                \
    \   /----- SACK [TSN Ack=init\n                                  /           TSN_A,Block=0]\n\
    \    (Cancel T3-rtx timer) <------/\n                                        \
    \  ...\n                                         {app sends 2 messages;strm 0}\n\
    \                                   /---- DATA\n                             \
    \     /        [TSN=init TSN_Z\n                              <--/          Strm=0,Seq=0\
    \ & user data 1]\n    SACK [TSN Ack=init TSN_Z,      /---- DATA\n          Block=0]\
    \     --------\\  /        [TSN=init TSN_Z +1,\n                             \
    \   \\/          Strm=0,Seq=1 & user data 2]\n                         <------/\\\
    \n                                  \\\n                                   \\\
    ------>\n                       Figure 4: INITiation Example\n   ---------\n \
    \  Old text: (Section 5.2.4.1)\n   ---------\n   Endpoint A                  \
    \                        Endpoint Z\n   <------------ Association is established---------------------->\n\
    \   Tag=Tag_A                                             Tag=Tag_Z\n   <------------------------------------------------------------->\n\
    \   {A crashes and restarts}\n   {app sets up a association with Z}\n   (build\
    \ TCB)\n   INIT [I-Tag=Tag_A'\n         & other info]  --------\\\n   (Start T1-init\
    \ timer)         \\\n   (Enter COOKIE-WAIT state)      \\---> (find a existing\
    \ TCB\n                                         compose temp TCB and Cookie_Z\n\
    \                                         with Tie-Tags to previous\n        \
    \                                 association)\n                             \
    \      /--- INIT ACK [Veri Tag=Tag_A',\n                                  /  \
    \             I-Tag=Tag_Z',\n   (Cancel T1-init timer) <------/              \
    \  Cookie_Z[TieTags=\n                                                  Tag_A,Tag_Z\n\
    \                                                   & other info]\n          \
    \                              (destroy temp TCB,leave original\n            \
    \                             in place)\n   COOKIE ECHO [Veri=Tag_Z',\n      \
    \          Cookie_Z\n                Tie=Tag_A,\n                Tag_Z]----------\\\
    \n   (Start T1-init timer)         \\\n   (Enter COOKIE-ECHOED state)    \\--->\
    \ (Find existing association,\n                                         Tie-Tags\
    \ match old tags,\n                                         Tags do not match\
    \ i.e.,\n                                         case X X M M above,\n      \
    \                                   Announce Restart to ULP\n                \
    \                         and reset association).\n                          \
    \        /---- COOKIE-ACK\n   (Cancel T1-init timer, <------/\n    Enter ESTABLISHED\
    \ state)\n   {app sends 1st user data; strm 0}\n   DATA [TSN=initial TSN_A\n \
    \      Strm=0,Seq=1 & user data]--\\\n   (Start T3-rtx timer)            \\\n\
    \                                    \\->\n                                 /---\
    \ SACK [TSN Ack=init TSN_A,Block=0]\n   (Cancel T3-rtx timer) <------/\n     \
    \                Figure 5: A Restart Example\n   ---------\n   New text: (Section\
    \ 5.2.4.1)\n   ---------\n   Endpoint A                                      \
    \    Endpoint Z\n   <-------------- Association is established---------------------->\n\
    \   Tag=Tag_A                                             Tag=Tag_Z\n   <--------------------------------------------------------------->\n\
    \   {A crashes and restarts}\n   {app sets up a association with Z}\n   (build\
    \ TCB)\n   INIT [I-Tag=Tag_A'\n         & other info]  --------\\\n   (Start T1-init\
    \ timer)         \\\n   (Enter COOKIE-WAIT state)      \\---> (find a existing\
    \ TCB\n                                         compose temp TCB and Cookie_Z\n\
    \                                         with Tie-Tags to previous\n        \
    \                                 association)\n                             \
    \      /--- INIT ACK [Veri Tag=Tag_A',\n                                  /  \
    \             I-Tag=Tag_Z',\n   (Cancel T1-init timer) <------/              \
    \  Cookie_Z[TieTags=\n                                                  Tag_A,Tag_Z\n\
    \                                                   & other info]\n          \
    \                              (destroy temp TCB,leave original\n            \
    \                             in place)\n   COOKIE ECHO [Veri=Tag_Z',\n      \
    \          Cookie_Z\n                Tie=Tag_A,\n                Tag_Z]----------\\\
    \n   (Start T1-init timer)         \\\n   (Enter COOKIE-ECHOED state)    \\--->\
    \ (Find existing association,\n                                         Tie-Tags\
    \ match old tags,\n                                         Tags do not match\
    \ i.e.,\n                                         case X X M M above,\n      \
    \                                   Announce Restart to ULP\n                \
    \                         and reset association).\n                          \
    \        /---- COOKIE-ACK\n   (Cancel T1-init timer, <------/\n    Enter ESTABLISHED\
    \ state)\n   {app sends 1st user data; strm 0}\n   DATA [TSN=initial TSN_A\n \
    \      Strm=0,Seq=0 & user data]--\\\n   (Start T3-rtx timer)            \\\n\
    \                                    \\->\n                                 /---\
    \ SACK [TSN Ack=init TSN_A,Block=0]\n   (Cancel T3-rtx timer) <------/\n     \
    \                Figure 5: A Restart Example\n"
- title: 2.31.3.  Solution description
  contents:
  - "2.31.3.  Solution description\n   Figure 4 and 5 were changed so that the SSN\
    \ starts with 0 instead of\n   1.\n"
- title: 2.32.  Unrecognized Parameters
  contents:
  - '2.32.  Unrecognized Parameters

    '
- title: 2.32.1.  Description of the Problem
  contents:
  - "2.32.1.  Description of the Problem\n   The RFC does not state clearly in Section\
    \ 3.3.3.1 whether one or\n   multiple unrecognized parameters are included in\
    \ the 'Unrecognized\n   Parameter' parameter.\n"
- title: 2.32.2.  Text Changes to the Document
  contents:
  - "2.32.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.3)\n\
    \   ---------\n         Variable Parameters                  Status     Type Value\n\
    \         -------------------------------------------------------------\n    \
    \     State Cookie                        Mandatory   7\n         IPv4 Address\
    \ (Note 1)               Optional    5\n         IPv6 Address (Note 1)       \
    \        Optional    6\n         Unrecognized Parameters             Optional\
    \    8\n         Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\n\
    \         Host Name Address (Note 3)          Optional    11\n   ---------\n \
    \  New text: (Section 3.3.3)\n   ---------\n         Variable Parameters     \
    \             Status     Type Value\n         -------------------------------------------------------------\n\
    \         State Cookie                        Mandatory   7\n         IPv4 Address\
    \ (Note 1)               Optional    5\n         IPv6 Address (Note 1)       \
    \        Optional    6\n         Unrecognized Parameter              Optional\
    \    8\n         Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\n\
    \         Host Name Address (Note 3)          Optional    11\n   ---------\n \
    \  Old text: (Section 3.3.3.1)\n   ---------\n      Unrecognized Parameters:\n\
    \         Parameter Type Value: 8\n         Parameter Length:  Variable Size.\n\
    \         Parameter Value:\n            This parameter is returned to the originator\
    \ of the INIT\n            chunk when the INIT contains an unrecognized parameter\n\
    \            which has a value that indicates that it should be reported\n   \
    \         to the sender.  This parameter value field will contain\n          \
    \  unrecognized parameters copied from the INIT chunk complete\n            with\
    \ Parameter Type, Length and Value fields.\n   ---------\n   New text: (Section\
    \ 3.3.3.1)\n   ---------\n      Unrecognized Parameter:\n         Parameter Type\
    \ Value: 8\n         Parameter Length:  Variable Size.\n         Parameter Value:\n\
    \            This parameter is returned to the originator of the INIT\n      \
    \      chunk when the INIT contains an unrecognized parameter\n            that\
    \ has a value that indicates that it should be reported\n            to the sender.\
    \  This parameter value field will contain the\n            unrecognized parameter\
    \ copied from the INIT chunk complete\n            with Parameter Type, Length,\
    \ and Value fields.\n"
- title: 2.32.3.  Solution Description
  contents:
  - "2.32.3.  Solution Description\n   The new text states clearly that only one unrecognized\
    \ parameter is\n   reported per parameter.\n"
- title: 2.33.  Handling of Unrecognized Parameters
  contents:
  - '2.33.  Handling of Unrecognized Parameters

    '
- title: 2.33.1.  Description of the Problem
  contents:
  - "2.33.1.  Description of the Problem\n   It is not stated clearly in RFC 2960\
    \ [5] how unrecognized parameters\n   should be handled.  The problem comes up\
    \ when an INIT contains an\n   unrecognized parameter with highest bits 00.  It\
    \ was not clear\n   whether an INIT-ACK should be sent.\n"
- title: 2.33.2.  Text Changes to the Document
  contents:
  - "2.33.2.  Text Changes to the Document\n   Some of the changes given here already\
    \ include changes suggested in\n   Section 2.27 of this document.\n   ---------\n\
    \   Old text: (Section 3.2.1)\n   ---------\n   00 - Stop processing this SCTP\
    \ packet and discard it, do not process\n        any further chunks within it.\n\
    \   01 - Stop processing this SCTP packet and discard it, do not process\n   \
    \     any further chunks within it, and report the unrecognized\n        parameter\
    \ in an 'Unrecognized Parameter Type' (in either an\n        ERROR or in the INIT\
    \ ACK).\n   10 - Skip this parameter and continue processing.\n   11 - Skip this\
    \ parameter and continue processing but report the\n        unrecognized parameter\
    \ in an 'Unrecognized Parameter Type' (in\n        either an ERROR or in the INIT\
    \ ACK).\n   ---------\n   New text: (Section 3.2.1)\n   ---------\n   00 - Stop\
    \ processing this parameter; do not process\n        any further parameters within\
    \ this chunk.\n   01 - Stop processing this parameter, do not process\n      \
    \  any further parameters within this chunk, and report the\n        unrecognized\
    \ parameter in an 'Unrecognized Parameter Type', as\n        described in 3.2.2.\n\
    \   10 - Skip this parameter and continue processing.\n   11 - Skip this parameter\
    \ and continue processing but report the\n        unrecognized parameter in an\
    \ 'Unrecognized Parameter Type', as\n        described in 3.2.2.\n   ---------\n\
    \   New text: (Note: no old text; clarification added in section 3.2)\n   ---------\n\
    \   3.2.2.  Reporting of Unrecognized Parameters\n   If the receiver of an INIT\
    \ chunk detects unrecognized parameters and\n   has to report them according to\
    \ Section 3.2.1, it MUST put the\n   'Unrecognized Parameter' parameter(s) in\
    \ the INIT-ACK chunk sent in\n   response to the INIT-chunk.  Note that if the\
    \ receiver of the INIT\n   chunk is NOT going to establish an association (e.g.,\
    \ due to lack of\n   resources), an 'Unrecognized Parameter' would NOT be included\
    \ with\n   any ABORT being sent to the sender of the INIT.\n   If the receiver\
    \ of an INIT-ACK chunk detects unrecognized parameters\n   and has to report them\
    \ according to Section 3.2.1, it SHOULD bundle\n   the ERROR chunk containing\
    \ the 'Unrecognized Parameter' error cause\n   with the COOKIE-ECHO chunk sent\
    \ in response to the INIT-ACK chunk.\n   If the receiver of the INIT-ACK cannot\
    \ bundle the COOKIE-ECHO chunk\n   with the ERROR chunk, the ERROR chunk MAY be\
    \ sent separately but not\n   before the COOKIE-ACK has been received.\n   Note:\
    \ Any time a COOKIE-ECHO is sent in a packet, it MUST be the\n   first chunk.\n"
- title: 2.33.3.  Solution Description
  contents:
  - "2.33.3.  Solution Description\n   The procedure of handling unrecognized parameters\
    \ has been described\n   clearly.\n"
- title: 2.34.  Tie Tags
  contents:
  - '2.34.  Tie Tags

    '
- title: 2.34.1.  Description of the Problem
  contents:
  - "2.34.1.  Description of the Problem\n   RFC 2960 requires that Tie-Tags be included\
    \ in the COOKIE.  The\n   cookie may not be encrypted.  An attacker could discover\
    \ the value of\n   the Verification Tags by analyzing cookies received after sending\
    \ an\n   INIT.\n"
- title: 2.34.2.  Text Changes to the Document
  contents:
  - "2.34.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 1.4)\n\
    \   ---------\n      o  Tie-Tags: Verification Tags from a previous association.\
    \  These\n         Tags are used within a State Cookie so that the newly\n   \
    \      restarting association can be linked to the original\n         association\
    \ within the endpoint that did not restart.\n   ---------\n   New text: (Section\
    \ 1.4)\n   ---------\n      o  Tie-Tags: Two 32-bit random numbers that together\
    \ make a 64-\n         bit nonce.  These Tags are used within a State Cookie and\
    \ TCB\n         so that a newly restarting association can be linked to the\n\
    \         original association within the endpoint that did not restart\n    \
    \     and yet not reveal the true Verification Tags of an existing\n         association.\n\
    \   ---------\n   Old text: (Section 5.2.1)\n   ---------\n      For an endpoint\
    \ that is in the COOKIE-ECHOED state it MUST\n      populate its Tie-Tags with\
    \ the Tag information of itself and\n      its peer (see Section 5.2.2 for a description\
    \ of the Tie-Tags).\n   ---------\n   New text: (Section 5.2.1)\n   ---------\n\
    \      For an endpoint that is in the COOKIE-ECHOED state it MUST\n      populate\
    \ its Tie-Tags within both the association TCB and\n      inside the State Cookie\
    \ (see section 5.2.2 for a description\n      of the Tie-Tags).\n   ---------\n\
    \   Old text: (Section 5.2.2)\n   ---------\n      Unless otherwise stated, upon\
    \ reception of an unexpected INIT for\n      this association, the endpoint shall\
    \ generate an INIT ACK with a\n      State Cookie.  In the outbound INIT ACK the\
    \ endpoint MUST copy its\n      current Verification Tag and peer's Verification\
    \ Tag into a\n      reserved place within the state cookie.  We shall refer to\
    \ these\n      locations as the Peer's-Tie-Tag and the Local-Tie-Tag.  The\n \
    \     outbound SCTP packet containing this INIT ACK MUST carry a\n      Verification\
    \ Tag value equal to the Initiation Tag found in the\n      unexpected INIT. \
    \ And the INIT ACK MUST contain a new Initiation\n      Tag (randomly generated\
    \ see Section 5.3.1).  Other parameters\n      for the endpoint SHOULD be copied\
    \ from the existing parameters\n      of the association (e.g., number of outbound\
    \ streams) into the\n      INIT ACK and cookie.\n   ---------\n   New text: (Section\
    \ 5.2.2)\n   ---------\n      Unless otherwise stated, upon receipt of an unexpected\
    \ INIT for\n      this association, the endpoint MUST generate an INIT ACK with\
    \ a\n      State Cookie.  In the outbound INIT ACK, the endpoint MUST copy\n \
    \     its current Tie-Tags to a reserved place within the State Cookie\n     \
    \ and the association's TCB.  We shall refer to these locations\n      inside\
    \ the cookie as the Peer's-Tie-Tag and the Local-Tie-Tag.  We\n      will refer\
    \ to the copy within an association's TCB as the Local\n      Tag and Peer's Tag.\
    \  The outbound SCTP packet containing this INIT\n      ACK MUST carry a Verification\
    \ Tag value equal to the Initiation\n      Tag found in the unexpected INIT. \
    \ And the INIT ACK MUST contain a\n      new Initiation Tag (randomly generated;\
    \ see Section 5.3.1).  Other\n      parameters for the endpoint SHOULD be copied\
    \ from the existing\n      parameters of the association (e.g., number of outbound\
    \ streams)\n      into the INIT ACK and cookie.\n"
- title: 2.34.3.  Solution Description
  contents:
  - "2.34.3.  Solution Description\n   The solution to this problem is not to use\
    \ the real Verification Tags\n   within the State Cookie as tie-tags.  Instead,\
    \ two 32-bit random\n   numbers are created to form one 64-bit nonce and stored\
    \ both in the\n   State Cookie and the existing association TCB.  This prevents\n\
    \   exposing the Verification Tags inadvertently.\n"
- title: 2.35.  Port Number Verification in the COOKIE-ECHO
  contents:
  - '2.35.  Port Number Verification in the COOKIE-ECHO

    '
- title: 2.35.1.  Description of the Problem
  contents:
  - "2.35.1.  Description of the Problem\n   The State Cookie sent by a listening\
    \ SCTP endpoint may not contain\n   the original port numbers or the local Verification\
    \ Tag.  It is then\n   possible that the endpoint, on receipt of the COOKIE-ECHO,\
    \ will not\n   be able to verify that these values match the original values found\n\
    \   in the INIT and INIT-ACK that began the association setup.\n"
- title: 2.35.2.  Text Changes to the Document
  contents:
  - "2.35.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 5.1.5)\n\
    \   ---------\n      3) Compare the creation timestamp in the State Cookie to\
    \ the\n         current local time.  If the elapsed time is longer than the\n\
    \         lifespan carried in the State Cookie, then the packet,\n         including\
    \ the COOKIE ECHO and any attached DATA chunks,\n         SHOULD be discarded\
    \ and the endpoint MUST transmit an ERROR\n         chunk with a \"Stale Cookie\"\
    \ error cause to the peer endpoint,\n      4) If the State Cookie is valid, create\
    \ an association to the\n         sender of the COOKIE ECHO chunk with the information\
    \ in the\n         TCB data carried in the COOKIE ECHO, and enter the\n      \
    \   ESTABLISHED state,\n      5) Send a COOKIE ACK chunk to the peer acknowledging\
    \ reception\n         of the COOKIE ECHO.  The COOKIE ACK MAY be bundled with\
    \ an\n         outbound DATA chunk or SACK chunk; however, the COOKIE ACK\n  \
    \       MUST be the first chunk in the SCTP packet.\n      6) Immediately acknowledge\
    \ any DATA chunk bundled with the COOKIE\n         ECHO with a SACK (subsequent\
    \ DATA chunk acknowledgement should\n         follow the rules defined in Section\
    \ 6.2).  As mentioned in step\n         5), if the SACK is bundled with the COOKIE\
    \ ACK, the COOKIE ACK\n         MUST appear first in the SCTP packet.\n   ---------\n\
    \   New text: (Section 5.1.5)\n   ---------\n      3) Compare the port numbers\
    \ and the Verification Tag contained\n         within the COOKIE ECHO chunk to\
    \ the actual port numbers and the\n         Verification Tag within the SCTP common\
    \ header of the received\n         packet.  If these values do not match, the\
    \ packet MUST be\n         silently discarded.\n      4) Compare the creation\
    \ timestamp in the State Cookie to the\n         current local time.  If the elapsed\
    \ time is longer than the\n         lifespan carried in the State Cookie, then\
    \ the packet,\n         including the COOKIE ECHO and any attached DATA chunks,\n\
    \         SHOULD be discarded, and the endpoint MUST transmit an\n         ERROR\
    \ chunk with a \"Stale Cookie\" error cause to the peer\n         endpoint.\n\
    \      5) If the State Cookie is valid, create an association to the\n       \
    \  sender of the COOKIE ECHO chunk with the information in the\n         TCB data\
    \ carried in the COOKIE ECHO and enter the\n         ESTABLISHED state.\n    \
    \  6) Send a COOKIE ACK chunk to the peer acknowledging receipt of\n         the\
    \ COOKIE ECHO.  The COOKIE ACK MAY be bundled with an\n         outbound DATA\
    \ chunk or SACK chunk; however, the COOKIE ACK\n         MUST be the first chunk\
    \ in the SCTP packet.\n      7) Immediately acknowledge any DATA chunk bundled\
    \ with the COOKIE\n         ECHO with a SACK (subsequent DATA chunk acknowledgement\
    \ should\n         follow the rules defined in Section 6.2).  As mentioned in\
    \ step\n         5, if the SACK is bundled with the COOKIE ACK, the COOKIE ACK\n\
    \         MUST appear first in the SCTP packet.\n"
- title: 2.35.3.  Solution Description
  contents:
  - "2.35.3.  Solution Description\n   By including both port numbers and the local\
    \ Verification Tag within\n   the State Cookie and verifying these during COOKIE-ECHO\
    \ processing,\n   this issue is resolved.\n"
- title: 2.36.  Path Initialization
  contents:
  - '2.36.  Path Initialization

    '
- title: 2.36.1.  Description of the Problem
  contents:
  - "2.36.1.  Description of the Problem\n   When an association enters the ESTABLISHED\
    \ state, the endpoint has no\n   verification that all of the addresses presented\
    \ by the peer do in\n   fact belong to the peer.  This could cause various forms\
    \ of denial of\n   service attacks.\n"
- title: 2.36.2.  Text Changes to the Document
  contents:
  - "2.36.2.  Text Changes to the Document\n   ---------\n   Old text: None\n   ---------\n\
    \   ---------\n   New text: (Section 5.4)\n   ---------\n   5.4.  Path Verification\n\
    \   During association establishment, the two peers exchange a list of\n   addresses.\
    \  In the predominant case, these lists accurately represent\n   the addresses\
    \ owned by each peer.  However, it is possible that a\n   misbehaving peer may\
    \ supply addresses that it does not own.  To\n   prevent this, the following rules\
    \ are applied to all addresses of the\n   new association:\n   1) Any address\
    \ passed to the sender of the INIT by its upper layer is\n      automatically\
    \ considered to be CONFIRMED.\n   2) For the receiver of the COOKIE-ECHO the only\
    \ CONFIRMED address is\n      the one that the INIT-ACK was sent to.\n   3) All\
    \ other addresses not covered by rules 1 and 2 are considered\n      UNCONFIRMED\
    \ and are subject to probing for verification.\n   To probe an address for verification,\
    \ an endpoint will send\n   HEARTBEATs including a 64-bit random nonce and a path\
    \ indicator (to\n   identify the address that the HEARTBEAT is sent to) within\
    \ the\n   HEARTBEAT parameter.\n   Upon receipt of the HEARTBEAT-ACK, a verification\
    \ is made that the\n   nonce included in the HEARTBEAT parameter is the one sent\
    \ to the\n   address indicated inside the HEARTBEAT parameter.  When this match\n\
    \   occurs, the address that the original HEARTBEAT was sent to is now\n   considered\
    \ CONFIRMED and available for normal data transfer.\n   These probing procedures\
    \ are started when an association moves to the\n   ESTABLISHED state and are ended\
    \ when all paths are confirmed.\n   Each RTO a probe may be sent on an active\
    \ UNCONFIRMED path in an\n   attempt to move it to the CONFIRMED state.  If during\
    \ this probing\n   the path becomes inactive, this rate is lowered to the normal\n\
    \   HEARTBEAT rate.  At the expiration of the RTO timer, the error\n   counter\
    \ of any path that was probed but not CONFIRMED is incremented\n   by one and\
    \ subjected to path failure detection, as defined in section\n   8.2.  When probing\
    \ UNCONFIRMED addresses, however, the association\n   overall error count is NOT\
    \ incremented.\n   The number of HEARTBEATS sent at each RTO SHOULD be limited\
    \ by the\n   HB.Max.Burst parameter.  It is an implementation decision as to how\n\
    \   to distribute HEARTBEATS to the peer's addresses for path\n   verification.\n\
    \   Whenever a path is confirmed, an indication MAY be given to the upper\n  \
    \ layer.\n   An endpoint MUST NOT send any chunks to an UNCONFIRMED address, with\n\
    \   the following exceptions:\n   - A HEARTBEAT including a nonce MAY be sent\
    \ to an UNCONFIRMED\n     address.\n   - A HEARTBEAT-ACK MAY be sent to an UNCONFIRMED\
    \ address.\n   - A COOKIE-ACK MAY be sent to an UNCONFIRMED address, but it MUST\
    \ be\n     bundled with a HEARTBEAT including a nonce.  An implementation that\n\
    \     does NOT support bundling MUST NOT send a COOKIE-ACK to an\n     UNCONFIRMED\
    \ address.\n   - A COOKE-ECHO MAY be sent to an UNCONFIRMED address, but it MUST\
    \ be\n     bundled with a HEARTBEAT including a nonce, and the packet MUST NOT\n\
    \     exceed the path MTU.  If the implementation does NOT support\n     bundling\
    \ or if the bundled COOKIE-ECHO plus HEARTBEAT (including\n     nonce) would exceed\
    \ the path MTU, then the implementation MUST NOT\n     send a COOKIE-ECHO to an\
    \ UNCONFIRMED address.\n   ---------\n   Old text: (Section 14)\n   ---------\n\
    \   14.  Suggested SCTP Protocol Parameter Values\n   The following protocol parameters\
    \ are RECOMMENDED:\n   RTO.Initial              - 3  seconds\n   RTO.Min     \
    \             - 1  second\n   RTO.Max                 -  60 seconds\n   RTO.Alpha\
    \                - 1/8\n   RTO.Beta                 - 1/4\n   Valid.Cookie.Life\
    \        - 60  seconds\n   Association.Max.Retrans  - 10 attempts\n   Path.Max.Retrans\
    \         - 5  attempts (per destination address)\n   Max.Init.Retransmits   \
    \  - 8  attempts\n   HB.interval              - 30 seconds\n   ---------\n   New\
    \ text: (Section 14)\n   ---------\n   14.  Suggested SCTP Protocol Parameter\
    \ Values\n   The following protocol parameters are RECOMMENDED:\n   RTO.Initial\
    \              - 3 seconds\n   RTO.Min                  - 1 second\n   RTO.Max\
    \                  - 60 seconds\n   Max.Burst                - 4\n   RTO.Alpha\
    \                - 1/8\n   RTO.Beta                 - 1/4\n   Valid.Cookie.Life\
    \        - 60 seconds\n   Association.Max.Retrans  - 10 attempts\n   Path.Max.Retrans\
    \         - 5 attempts (per destination address)\n   Max.Init.Retransmits    \
    \ - 8 attempts\n   HB.Interval              - 30 seconds\n   HB.Max.Burst    \
    \         - 1\n"
- title: 2.36.3.  Solution Description
  contents:
  - "2.36.3.  Solution Description\n   By properly setting up initial path state and\
    \ accelerated probing via\n   HEARTBEAT's, a new association can verify that all\
    \ addresses\n   presented by a peer belong to that peer.\n"
- title: 2.37.  ICMP Handling Procedures
  contents:
  - '2.37.  ICMP Handling Procedures

    '
- title: 2.37.1.  Description of the Problem
  contents:
  - "2.37.1.  Description of the Problem\n   RFC 2960 does not describe how ICMP messages\
    \ should be processed by\n   an SCTP endpoint.\n"
- title: 2.37.2.  Text Changes to the Document
  contents:
  - "2.37.2.  Text Changes to the Document\n   --------\n   Old text: None\n   --------\n\
    \   ---------\n   New text\n   ---------\n   11.5.  Protection of Non-SCTP Capable\
    \ Hosts.\n   To provide a non-SCTP capable host with the same level of protection\n\
    \   against attacks as for SCTP-capable ones, all SCTP stacks MUST\n   implement\
    \ the ICMP handling described in Appendix C.\n   When an SCTP stack receives a\
    \ packet containing multiple control or\n   DATA chunks and the processing of\
    \ the packet requires the sending of\n   multiple chunks in response, the sender\
    \ of the response chunk(s) MUST\n   NOT send more than one packet.  If bundling\
    \ is supported, multiple\n   response chunks that fit into a single packet MAY\
    \ be bundled together\n   into one single response packet.  If bundling is not\
    \ supported, then\n   the sender MUST NOT send more than one response chunk and\
    \ MUST\n   discard all other responses.  Note that this rule does NOT apply to\
    \ a\n   SACK chunk, since a SACK chunk is, in itself, a response to DATA and\n\
    \   a SACK does not require a response of more DATA.\n   An SCTP implementation\
    \ SHOULD abort the association if it receives a\n   SACK acknowledging a TSN that\
    \ has not been sent.\n   An SCTP implementation that receives an INIT that would\
    \ require a\n   large packet in response, due to the inclusion of multiple ERROR\n\
    \   parameters, MAY (at its discretion) elect to omit some or all of the\n   ERROR\
    \ parameters to reduce the size of the INIT-ACK.  Due to a\n   combination of\
    \ the size of the COOKIE parameter and the number of\n   addresses a receiver\
    \ of an INIT may be indicating to a peer, it is\n   always possible that the INIT-ACK\
    \ will be larger than the original\n   INIT.  An SCTP implementation SHOULD attempt\
    \ to make the INIT-ACK as\n   small as possible to reduce the possibility of byte\
    \ amplification\n   attacks.\n   ---------\n   Old text: None\n   ---------\n\
    \   ---------\n   New text: (Appendix C)\n   ---------\n   Appendix C ICMP Handling\n\
    \   Whenever an ICMP message is received by an SCTP endpoint the\n   following\
    \ procedures MUST be followed to ensure proper utilization of\n   the information\
    \ being provided by layer 3.\n   ICMP1) An implementation MAY ignore all ICMPv4\
    \ messages where the\n          type field is not set to \"Destination Unreachable\"\
    .\n   ICMP2) An implementation MAY ignore all ICMPv6 messages where the\n    \
    \      type field is not \"Destination Unreachable, \"Parameter\n          Problem\"\
    \ or \"Packet Too Big\".\n   ICMP3) An implementation MAY ignore any ICMPv4 messages\
    \ where the\n          code does not indicate \"Protocol Unreachable\" or\n  \
    \        \"Fragmentation Needed\".\n   ICMP4) An implementation MAY ignore all\
    \ ICMPv6 messages of type\n          \"Parameter Problem\" if the code is not\
    \ \"Unrecognized next\n          header type encountered\".\n   ICMP5) An implementation\
    \ MUST use the payload of the ICMP message (V4\n          or V6) to locate the\
    \ association that sent the message that\n          ICMP is responding to.  If\
    \ the association cannot be found, an\n          implementation SHOULD ignore\
    \ the ICMP message.\n   ICMP6) An implementation MUST validate that the Verification\
    \ Tag\n          contained in the ICMP message matches the verification tag of\n\
    \          the peer.  If the Verification Tag is not 0 and does NOT\n        \
    \  match, discard the ICMP message.  If it is 0 and the ICMP\n          message\
    \ contains enough bytes to verify that the chunk type is\n          an INIT chunk\
    \ and that the initiate tag matches the tag of the\n          peer, continue with\
    \ ICMP7.  If the ICMP message is too short\n          or the chunk type or the\
    \ initiate tag does not match, silently\n          discard the packet.\n   ICMP7)\
    \ If the ICMP message is either a V6 \"Packet Too Big\" or a V4\n          \"\
    Fragmentation Needed\", an implementation MAY process this\n          information\
    \ as defined for PATH MTU discovery.\n   ICMP8) If the ICMP code is a \"Unrecognized\
    \ next header type\n          encountered\" or a \"Protocol Unreachable\", an\
    \ implementation\n          MUST treat this message as an abort with the T bit\
    \ set if it\n          does not contain an INIT chunk.  If it does contain an\
    \ INIT\n          chunk and the association is in COOKIE-WAIT state, handle the\n\
    \          ICMP message like an ABORT.\n   ICMP9) If the ICMPv6 code is \"Destination\
    \ Unreachable\", the\n          implementation MAY mark the destination into the\
    \ unreachable\n          state or alternatively increment the path error counter.\n\
    \   Note that these procedures differ from RFC 1122 [1] and from its\n   requirements\
    \ for processing of port-unreachable messages and the\n   requirements that an\
    \ implementation MUST abort associations in\n   response to a \"protocol unreachable\"\
    \ message.  Port unreachable\n   messages are not processed, since an implementation\
    \ will send an\n   ABORT, not a port unreachable.  The stricter handling of the\n\
    \   \"protocol unreachable\" message is due to security concerns for hosts\n \
    \  that do NOT support SCTP.\n"
- title: 2.37.3.  Solution Description
  contents:
  - "2.37.3.  Solution Description\n   The new appendix now describes proper handling\
    \ of ICMP messages in\n   conjunction with SCTP.\n"
- title: 2.38.  Checksum
  contents:
  - '2.38.  Checksum

    '
- title: 2.38.1.  Description of the problem
  contents:
  - "2.38.1.  Description of the problem\n   RFC 3309 [6] changes the SCTP checksum\
    \ due to weaknesses in the\n   original Adler 32 checksum for small messages.\
    \  This document, being\n   used as a guide for a cut and paste replacement to\
    \ update RFC 2960,\n   thus also needs to incorporate the checksum changes.  The\
    \ idea is\n   that one could apply all changes found in this guide to a copy of\
    \ RFC\n   2960 and have a \"new\" document that has ALL changes (including RFC\n\
    \   3309).\n"
- title: 2.38.2.  Text Changes to the Document
  contents:
  - "2.38.2.  Text Changes to the Document\n   ---------\n   Old text:\n   ---------\n\
    \   6.8 Adler-32 Checksum Calculation\n      When sending an SCTP packet, the\
    \ endpoint MUST strengthen the data\n      integrity of the transmission by including\
    \ the Adler-32 checksum\n      value calculated on the packet, as described below.\n\
    \      After the packet is constructed (containing the SCTP common header\n  \
    \    and one or more control or DATA chunks), the transmitter shall:\n      1)\
    \ Fill in the proper Verification Tag in the SCTP common header\n         and\
    \ initialize the checksum field to 0's.\n      2) Calculate the Adler-32 checksum\
    \ of the whole packet, including\n         the SCTP common header and all the\
    \ chunks.  Refer to\n         appendix B for details of the Adler-32 algorithm.\
    \  And,\n      3) Put the resultant value into the checksum field in the common\n\
    \         header, and leave the rest of the bits unchanged.\n      When an SCTP\
    \ packet is received, the receiver MUST first check the\n      Adler-32 checksum:\n\
    \      1) Store the received Adler-32 checksum value aside,\n      2) Replace\
    \ the 32 bits of the checksum field in the received SCTP\n         packet with\
    \ all '0's and calculate an Adler-32 checksum value\n         of the whole received\
    \ packet.  And,\n      3) Verify that the calculated Adler-32 checksum is the\
    \ same as the\n         received Adler-32 checksum.  If not, the receiver MUST\
    \ treat\n         the packet as an invalid SCTP packet.\n      The default procedure\
    \ for handling invalid SCTP packets is to\n      silently discard them.\n   ---------\n\
    \   New text:\n   ---------\n   6.8 CRC-32c Checksum Calculation\n      When sending\
    \ an SCTP packet, the endpoint MUST strengthen the data\n      integrity of the\
    \ transmission by including the CRC32c checksum\n      value calculated on the\
    \ packet, as described below.\n      After the packet is constructed (containing\
    \ the SCTP common header\n      and one or more control or DATA chunks), the transmitter\
    \ MUST\n      1) fill in the proper Verification Tag in the SCTP common header\n\
    \         and initialize the checksum field to '0's,\n      2) calculate the CRC32c\
    \ checksum of the whole packet, including\n         the SCTP common header and\
    \ all the chunks (refer to\n         appendix B for details of the CRC32c algorithm);\
    \ and\n      3) put the resultant value into the checksum field in the common\n\
    \         header, and leave the rest of the bits unchanged.\n      When an SCTP\
    \ packet is received, the receiver MUST first check the\n      CRC32c checksum\
    \ as follows:\n      1) Store the received CRC32c checksum value aside.\n    \
    \  2) Replace the 32 bits of the checksum field in the received SCTP\n       \
    \  packet with all '0's and calculate a CRC32c checksum value of\n         the\
    \ whole received packet.\n      3) Verify that the calculated CRC32c checksum\
    \ is the same as the\n         received CRC32c checksum.  If it is not, the receiver\
    \ MUST\n         treat the packet as an invalid SCTP packet.\n      The default\
    \ procedure for handling invalid SCTP packets is to\n      silently discard them.\n\
    \      Any hardware implementation SHOULD be done in a way that is\n      verifiable\
    \ by the software.\n   ---------\n   Old text:\n   ---------\n   Appendix B Alder\
    \ 32 bit checksum calculation\n      The Adler-32 checksum calculation given in\
    \ this appendix is\n      copied from [RFC1950].\n      Adler-32 is composed of\
    \ two sums accumulated per byte: s1 is the\n      sum of all bytes, s2 is the\
    \ sum of all s1 values.  Both sums are\n      done modulo 65521.  s1 is initialized\
    \ to 1, s2 to zero.  The\n      Adler-32 checksum is stored as s2*65536 + s1 in\
    \ network byte\n      order.\n      The following C code computes the Adler-32\
    \ checksum of a data\n      buffer.  It is written for clarity, not for speed.\
    \  The sample\n      code is in the ANSI C programming language.  Non C users\
    \ may\n      find it easier to read with these hints:\n      &      Bitwise AND\
    \ operator.\n      >>     Bitwise right shift operator.  When applied to an\n\
    \             unsigned quantity, as here, right shift inserts zero bit(s)\n  \
    \           at the left.\n      <<     Bitwise left shift operator.  Left shift\
    \ inserts zero\n             bit(s) at the right.\n      ++     \"n++\" increments\
    \ the variable n.\n      %      modulo operator: a % b is the remainder of a divided\
    \ by b.\n       #define BASE 65521 /* largest prime smaller than 65536 */\n  \
    \     /*\n         Update a running Adler-32 checksum with the bytes buf[0..len-1]\n\
    \         and return the updated checksum.  The Adler-32 checksum should\n   \
    \      be initialized to 1.\n          Usage example:\n            unsigned long\
    \ adler = 1L;\n            while (read_buffer(buffer, length) != EOF) {\n    \
    \          adler = update_adler32(adler, buffer, length);\n             }\n  \
    \          if (adler != original_adler) error();\n         */\n         unsigned\
    \ long update_adler32(unsigned long adler,\n            unsigned char *buf, int\
    \ len)\n         {\n           unsigned long s1 = adler & 0xffff;\n          \
    \ unsigned long s2 = (adler >> 16) & 0xffff;\n           int n;\n           for\
    \ (n = 0; n < len; n++) {\n             s1 = (s1 + buf[n]) % BASE;\n         \
    \    s2 = (s2 + s1)     % BASE;\n           }\n           return (s2 << 16) +\
    \ s1;\n         }\n         /* Return the adler32 of the bytes buf[0..len-1] */\n\
    \         unsigned long adler32(unsigned char *buf, int len)\n         {\n   \
    \        return update_adler32(1L, buf, len);\n         }\n   ---------\n   New\
    \ text:\n   ---------\n   Appendix B CRC32c Checksum Calculation\n      We define\
    \ a 'reflected value' as one that is the opposite of the\n      normal bit order\
    \ of the machine.  The 32-bit CRC is calculated as\n      described for CRC-32c\
    \ and uses the polynomial code 0x11EDC6F41\n      (Castagnoli93) or x^32+x^28+x^27+x^26+x^25\n\
    \      +x^23+x^22+x^20+x^19+x^18+x^14+x^13+x^11+x^10+x^9+x^8+x^6+x^0.\n      The\
    \ CRC is computed using a procedure similar to ETHERNET CRC\n      [ITU32], modified\
    \ to reflect transport level usage.\n      CRC computation uses polynomial division.\
    \  A message\n      bit-string M is transformed to a polynomial, M(X), and the\
    \ CRC\n      is calculated from M(X) using polynomial arithmetic [PETERSON 72].\n\
    \      When CRCs are used at the link layer, the polynomial is derived\n     \
    \ from on-the-wire bit ordering: the first bit 'on the wire' is the\n      high-order\
    \ coefficient.  Since SCTP is a transport-level protocol,\n      it cannot know\
    \ the actual serial-media bit ordering.  Moreover,\n      different links in the\
    \ path between SCTP endpoints may use\n      different link-level bit orders.\n\
    \      A convention must therefore be established for mapping SCTP\n      transport\
    \ messages to polynomials for purposes of CRC computation.\n      The bit-ordering\
    \ for mapping SCTP messages to polynomials is that\n      bytes are taken most-significant\
    \ first; but within each byte, bits\n      are taken least-significant first.\
    \  The first byte of the message\n      provides the eight highest coefficients.\
    \  Within each byte,\n      the least-significant SCTP bit gives the most significant\n\
    \      polynomial coefficient within that byte, and the most-significant\n   \
    \   SCTP bit is the least significant polynomial coefficient in that\n      byte.\
    \  (This bit ordering is sometimes called 'mirrored' or\n      'reflected' [WILLIAMS93].)\
    \  CRC polynomials are to be transformed\n      back into SCTP transport-level\
    \ byte values, using a consistent\n      mapping.\n      The SCTP transport-level\
    \ CRC value should be calculated as\n      follows:\n         -  CRC input data\
    \ are assigned to a byte stream, numbered from\n            0 to N-1.\n      \
    \   -  The transport-level byte-stream is mapped to a polynomial\n           \
    \ value.  An N-byte PDU with j bytes numbered 0 to N-1 is\n            considered\
    \ as coefficients of a polynomial M(x) of order\n            8N-1, with bit 0\
    \ of byte j being coefficient x^(8(N-j)-8),\n            and bit 7 of byte j being\
    \ coefficient x^(8(N-j)-1).\n         -  The CRC remainder register is initialized\
    \ with all 1s and\n            the CRC is computed with an algorithm that simultaneously\n\
    \            multiplies by x^32 and divides by the CRC polynomial.\n         -\
    \  The polynomial is multiplied by x^32 and divided by G(x),\n            the\
    \ generator polynomial, producing a remainder R(x) of\n            degree less\
    \ than or equal to 31.\n         -  The coefficients of R(x) are considered a\
    \ 32-bit sequence.\n         -  The bit sequence is complemented.  The result\
    \ is the CRC\n            polynomial.\n         -  The CRC polynomial is mapped\
    \ back into SCTP transport-level\n            bytes.  The coefficient of x^31\
    \ gives the value of bit 7 of\n            SCTP byte 0, and the coefficient of\
    \ x^24 gives the value of\n            bit 0 of byte 0.  The coefficient of x^7\
    \ gives bit 7 of\n            byte 3, and the coefficient of x^0 gives bit 0 of\
    \ byte 3.\n            The resulting four-byte transport-level sequence is the\n\
    \            32-bit SCTP checksum value.\n      IMPLEMENTATION NOTE: Standards\
    \ documents, textbooks, and vendor\n      literature on CRCs often follow an alternative\
    \ formulation, in\n      which the register used to hold the remainder of the\n\
    \      long-division algorithm is initialized to zero rather than\n      all-1s,\
    \ and instead the first 32 bits of the message are\n      complemented.  The long-division\
    \ algorithm used in our\n      formulation is specified such that the initial\n\
    \      multiplication by 2^32 and the long-division are combined into\n      one\
    \ simultaneous operation.  For such algorithms, and for\n      messages longer\
    \ than 64 bits, the two specifications are\n      precisely equivalent.  That\
    \ equivalence is the intent of\n      this document.\n      Implementors of SCTP\
    \ are warned that both specifications are to be\n      found in the literature,\
    \ sometimes with no restriction on the\n      long-division algorithm.  The choice\
    \ of formulation in this\n      document is to permit non-SCTP usage, where the\
    \ same CRC\n      algorithm may be used to protect messages shorter than 64 bits.\n\
    \      There may be a computational advantage in validating the\n      Association\
    \ against the Verification Tag, prior to performing a\n      checksum, as invalid\
    \ tags will result in the same action as a bad\n      checksum in most cases.\
    \  The exceptions for this technique would\n      be INIT and some SHUTDOWN-COMPLETE\
    \ exchanges, as well as a stale\n      COOKIE-ECHO.  These special case exchanges\
    \ must represent small\n      packets and will minimize the effect of the checksum\
    \ calculation.\n   ---------\n   Old text: (Section 18)\n   ---------\n   18.\
    \  Bibliography\n   [ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End\n\
    \              Network Path Properties\", Proc. SIGCOMM'99, 1999.\n   [FALL96]\
    \   Fall, K. and Floyd, S., Simulation-based Comparisons of\n              Tahoe,\
    \ Reno, and SACK TCP, Computer Communications Review,\n              V. 26 N.\
    \ 3, July 1996, pp.  5-21.\n   [RFC1750]  Eastlake, D. (ed.), \"Randomness Recommendations\
    \ for\n              Security\", RFC 1750, December 1994.\n   [RFC1950]  Deutsch\
    \ P. and J. Gailly, \"ZLIB Compressed Data Format\n              Specification\
    \ version 3.3\", RFC 1950, May 1996.\n   [RFC2104]  Krawczyk, H., Bellare, M.\
    \ and R. Canetti, \"HMAC:  Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104, March 1997.\n   [RFC2196]  Fraser, B., \"Site Security Handbook\"\
    , FYI 8, RFC 2196,\n              September 1997.\n   [RFC2522]  Karn, P. and\
    \ W. Simpson, \"Photuris: Session-Key Management\n              Protocol\", RFC\
    \ 2522, March 1999.\n   [SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and\
    \ Anderson, T.,\n              \"TCP Congestion Control with a Misbehaving Receiver\"\
    ,  ACM\n              Computer Communication Review, 29(5), October 1999.\n  \
    \ ---------\n   New text: (Section 18, including changes from 2.11)\n   ---------\n\
    \   18.  Bibliography\n   [ALLMAN99] Allman, M. and Paxson, V., \"On Estimating\
    \ End-to-End\n              Network Path Properties\", Proc. SIGCOMM'99, 1999.\n\
    \   [FALL96]   Fall, K. and Floyd, S., Simulation-based Comparisons of\n     \
    \         Tahoe, Reno, and SACK TCP, Computer Communications Review,\n       \
    \       V. 26 N. 3, July 1996, pp.  5-21.\n   [ITU32]         ITU-T Recommendation\
    \ V.42, \"Error-correcting\n                   procedures for DCEs using asynchronous-to-synchronous\n\
    \                   conversion\", Section 8.1.1.6.2, October 1996.\n   [PETERSON\
    \ 1972] W. W. Peterson and E.J Weldon, Error Correcting\n                   Codes,\
    \ 2nd Edition, MIT Press, Cambridge,\n                   Massachusetts.\n   [RFC1750]\
    \  Eastlake, D., Ed., \"Randomness Recommendations for\n              Security\"\
    , RFC 1750, December 1994.\n   [RFC1858]  Ziemba, G., Reed, D. and Traina P.,\
    \ \"Security\n              Considerations for IP Fragment Filtering\", RFC 1858,\n\
    \              October 1995.\n   [RFC1950]  Deutsch P. and J. Gailly, \"ZLIB Compressed\
    \ Data Format\n              Specification version 3.3\", RFC 1950, May 1996.\n\
    \   [RFC2104]  Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC:  Keyed-\n   \
    \           Hashing for Message Authentication\", RFC 2104, March 1997.\n   [RFC2196]\
    \  Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196,\n              September\
    \ 1997.\n   [RFC2522]  Karn, P. and W. Simpson, \"Photuris: Session-Key Management\n\
    \              Protocol\", RFC 2522, March 1999.\n   [SAVAGE99] Savage, S., Cardwell,\
    \ N., Wetherall, D., and Anderson, T.,\n              \"TCP Congestion Control\
    \ with a Misbehaving Receiver\", ACM\n              Computer Communication Review,\
    \ 29(5), October 1999.\n   [WILLIAMS93]    Williams, R., \"A PAINLESS GUIDE TO\
    \ CRC ERROR\n                   DETECTION ALGORITHMS\" - Internet publication,\
    \ August\n                   1993,\n                   http://www.geocities.com/SiliconValley/Pines/\n\
    \                   8659/crc.htm.\n"
- title: 2.38.3.  Solution Description
  contents:
  - "2.38.3.  Solution Description\n   This change adds to the implementor's guide\
    \ the complete set of\n   changes that, when combined with RFC 2960 [5], encompasses\
    \ the\n   changes from RFC 3309 [6].\n"
- title: 2.39.  Retransmission Policy
  contents:
  - '2.39.  Retransmission Policy

    '
- title: 2.39.1.  Description of the Problem
  contents:
  - "2.39.1.  Description of the Problem\n   The current retransmission policy (send\
    \ all retransmissions an\n   alternate destination) in the specification has performance\
    \ issues\n   under certain loss conditions with multihomed endpoints.  Instead,\n\
    \   fast retransmissions should be sent to the same destination, and only\n  \
    \ timeout retransmissions should be sent to an alternate destination\n   [4].\n"
- title: 2.39.2.  Text Changes to the Document
  contents:
  - "2.39.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.4)\n\
    \   ---------\n   Furthermore, when its peer is multi-homed, an endpoint SHOULD\
    \ try to\n   retransmit a chunk to an active destination transport address that\
    \ is\n   different from the last destination address to which the DATA chunk\n\
    \   was sent.\n   ---------\n   New text: (Section 6.4)\n   ---------\n   Furthermore,\
    \ when its peer is multi-homed, an endpoint SHOULD try to\n   retransmit a chunk\
    \ that timed out to an active destination transport\n   address that is different\
    \ from the last destination address to which\n   the DATA chunk was sent.\n  \
    \ ---------\n   Old text: (Section 6.4.1)\n   ---------\n   When retransmitting\
    \ data, if the endpoint is multi-homed, it should\n   consider each source-destination\
    \ address pair in its retransmission\n   selection policy.  When retransmitting\
    \ the endpoint should attempt to\n   pick the most divergent source-destination\
    \ pair from the original\n   source-destination pair to which the packet was transmitted.\n\
    \   ---------\n   New text: (Section 6.4.1)\n   ---------\n   When retransmitting\
    \ data that timed out, if the endpoint is\n   multi-homed, it should consider\
    \ each source-destination address\n   pair in its retransmission selection policy.\
    \  When retransmitting\n   timed out data, the endpoint should attempt to pick\
    \ the most\n   divergent source-destination pair from the original\n   source-destination\
    \ pair to which the packet was transmitted.\n"
- title: 2.39.3.  Solution Description
  contents:
  - "2.39.3.  Solution Description\n   The above wording changes clarify that only\
    \ timeout retransmissions\n   should be sent to an alternate active destination.\n"
- title: 2.40.  Port Number 0
  contents:
  - '2.40.  Port Number 0

    '
- title: 2.40.1.  Description of the Problem
  contents:
  - "2.40.1.  Description of the Problem\n   The port number 0 has a special semantic\
    \ in various APIs.  For\n   example, in the socket API, if the user specifies\
    \ 0, the SCTP\n   implementation chooses an appropriate port number for the user.\n\
    \   Therefore, the port number 0 should not be used on the wire.\n"
- title: 2.40.2.  Text Changes to the Document
  contents:
  - "2.40.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.1)\n\
    \   ---------\n      Source Port Number: 16 bits (unsigned integer)\n        \
    \ This is the SCTP sender's port number.  It can be used by the\n         receiver\
    \ in combination with the source IP address, the SCTP\n         destination port,\
    \ and possibly the destination IP address to\n         identify the association\
    \ to which this packet belongs.\n      Destination Port Number: 16 bits (unsigned\
    \ integer)\n         This is the SCTP port number to which this packet is destined.\n\
    \         The receiving host will use this port number to de-multiplex\n     \
    \    the SCTP packet to the correct receiving endpoint/application.\n   ---------\n\
    \   New text: (Section 3.1)\n   ---------\n      Source Port Number: 16 bits (unsigned\
    \ integer)\n         This is the SCTP sender's port number.  It can be used by\
    \ the\n         receiver in combination with the source IP address, the SCTP\n\
    \         destination port and possibly the destination IP address to\n      \
    \   identify the association to which this packet belongs.\n         The port\
    \ number 0 MUST NOT be used.\n      Destination Port Number: 16 bits (unsigned\
    \ integer)\n         This is the SCTP port number to which this packet is destined.\n\
    \         The receiving host will use this port number to de-multiplex\n     \
    \    the SCTP packet to the correct receiving endpoint/application.\n        \
    \ The port number 0 MUST NOT be used.\n"
- title: 2.40.3.  Solution Description
  contents:
  - "2.40.3.  Solution Description\n   It is clearly stated that the port number 0\
    \ is an invalid value on\n   the wire.\n"
- title: 2.41.  T Bit
  contents:
  - '2.41.  T Bit

    '
- title: 2.41.1.  Description of the Problem
  contents:
  - "2.41.1.  Description of the Problem\n   The description of the T bit as the bit\
    \ describing whether a TCB has\n   been destroyed is misleading.  In addition,\
    \ the procedure described\n   in Section 2.13 is not as precise as needed.\n"
- title: 2.41.2.  Text Changes to the Document
  contents:
  - "2.41.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.7)\n\
    \   ---------\n      T bit:  1 bit\n         The T bit is set to 0 if the sender\
    \ had a TCB that it\n         destroyed.  If the sender did not have a TCB it\
    \ should set\n         this bit to 1.\n   ---------\n   New text: (Section 3.3.7)\n\
    \   ---------\n      T bit:  1 bit\n         The T bit is set to 0 if the sender\
    \ filled in the\n         Verification Tag expected by the peer.  If the Verification\n\
    \         Tag is reflected, the T bit MUST be set to 1.  Reflecting means\n  \
    \       that the sent Verification Tag is the same as the received\n         one.\n\
    \   ---------\n   Old text: (Section 3.3.13)\n   ---------\n      T bit:  1 bit\n\
    \         The T bit is set to 0 if the sender had a TCB that it\n         destroyed.\
    \  If the sender did not have a TCB it should set\n         this bit to 1.\n \
    \  ---------\n   New text: (Section 3.3.13)\n   ---------\n      T bit:  1 bit\n\
    \         The T bit is set to 0 if the sender filled in the\n         Verification\
    \ Tag expected by the peer.  If the Verification\n         Tag is reflected, the\
    \ T bit MUST be set to 1.  Reflecting means\n         that the sent Verification\
    \ Tag is the same as the received\n         one.\n   ---------\n   Old text: (Section\
    \ 8.4)\n   ---------\n       3) If the packet contains an INIT chunk with a Verification\
    \ Tag\n          set to '0', process it as described in Section 5.1.\n       \
    \   Otherwise,\n   ---------\n   New text: (Section 8.4)\n   ---------\n     \
    \  3) If the packet contains an INIT chunk with a Verification Tag\n         set\
    \ to '0', process it as described in Section 5.1.  If, for\n         whatever\
    \ reason, the INIT cannot be processed normally and\n         an ABORT has to\
    \ be sent in response, the Verification Tag of\n         the packet containing\
    \ the ABORT chunk MUST be the Initiate\n         tag of the received INIT chunk,\
    \ and the T-Bit of the ABORT\n         chunk has to be set to 0, indicating that\
    \ the Verification\n         Tag is NOT reflected.\n   ---------\n   Old text:\
    \ (Section 8.4)\n   ---------\n      5) If the packet contains a SHUTDOWN ACK\
    \ chunk, the receiver\n         should respond to the sender of the OOTB packet\
    \ with a\n         SHUTDOWN COMPLETE.  When sending the SHUTDOWN COMPLETE, the\n\
    \         receiver of the OOTB packet must fill in the Verification\n        \
    \ Tag field of the outbound packet with the Verification Tag\n         received\
    \ in the SHUTDOWN ACK and set the T-bit in the Chunk\n         Flags to indicate\
    \ that no TCB was found.  Otherwise,\n   ---------\n   New text: (Section 8.4)\n\
    \   ---------\n      5) If the packet contains a SHUTDOWN ACK chunk, the receiver\n\
    \         should respond to the sender of the OOTB packet with a\n         SHUTDOWN\
    \ COMPLETE.  When sending the SHUTDOWN COMPLETE, the\n         receiver of the\
    \ OOTB packet must fill in the Verification\n         Tag field of the outbound\
    \ packet with the Verification Tag\n         received in the SHUTDOWN ACK and\
    \ set the T-bit in the\n         Chunk Flags to indicate that the Verification\
    \ Tag is\n         reflected.  Otherwise,\n   ---------\n   Old text: (Section\
    \ 8.4)\n   ---------\n      8) The receiver should respond to the sender of the\
    \ OOTB packet\n         with an ABORT.  When sending the ABORT, the receiver of\
    \ the\n         OOTB packet MUST fill in the Verification Tag field of the\n \
    \        outbound packet with the value found in the Verification\n         Tag\
    \ field of the OOTB packet and set the T-bit in the Chunk\n         Flags to indicate\
    \ that no TCB was found.  After sending this\n         ABORT, the receiver of\
    \ the OOTB packet shall discard the\n         OOTB packet and take no further\
    \ action.\n   ---------\n   New text: (Section 8.4)\n   ---------\n      8) The\
    \ receiver should respond to the sender of the OOTB packet\n         with an ABORT.\
    \  When sending the ABORT, the receiver of the\n         OOTB packet MUST fill\
    \ in the Verification Tag field of the\n         outbound packet with the value\
    \ found in the Verification Tag\n         field of the OOTB packet and set the\
    \ T-bit in the Chunk Flags\n         to indicate that the Verification Tag is\
    \ reflected.  After\n         sending this ABORT, the receiver of the OOTB packet\
    \ shall\n         discard the OOTB packet and take no further action.\n   ---------\n\
    \   Old text: (Section 8.5.1)\n   ---------\n      B) Rules for packet carrying\
    \ ABORT:\n         -  The endpoint shall always fill in the Verification Tag\n\
    \            field of the outbound packet with the destination\n            endpoint's\
    \ tag value if it is known.\n         -  If the ABORT is sent in response to an\
    \ OOTB packet, the\n            endpoint MUST follow the procedure described in\n\
    \            Section 8.4.\n         -  The receiver MUST accept the packet if\
    \ the Verification\n            Tag matches either its own tag, OR the tag of\
    \ its peer.\n            Otherwise, the receiver MUST silently discard the packet\n\
    \            and take no further action.\n   ---------\n   New text: (Section\
    \ 8.5.1)\n   ---------\n     B) Rules for packet carrying ABORT:\n         - \
    \ The endpoint MUST always fill in the Verification Tag\n            field of\
    \ the outbound packet with the destination\n            endpoint's tag value,\
    \ if it is known.\n         -  If the ABORT is sent in response to an OOTB packet,\
    \ the\n            endpoint MUST follow the procedure described in\n         \
    \   Section 8.4.\n         -  The receiver of an ABORT MUST accept the packet\n\
    \            if the Verification Tag field of the packet matches its\n       \
    \     own tag and the T bit is not set\n            OR\n            if it is set\
    \ to its peer's tag and the T bit is set in\n            the Chunk Flags.\n  \
    \          Otherwise, the receiver MUST silently discard the packet\n        \
    \    and take no further action.\n   ---------\n   Old text: (Section 8.5.1)\n\
    \   ---------\n      C) Rules for packet carrying SHUTDOWN COMPLETE:\n       \
    \  -  When sending a SHUTDOWN COMPLETE, if the receiver of the\n            SHUTDOWN\
    \ ACK has a TCB then the destination endpoint's\n            tag MUST be used.\
    \  Only where no TCB exists should the\n            sender use the Verification\
    \ Tag from the SHUTDOWN ACK.\n         -  The receiver of a SHUTDOWN COMPLETE\
    \ shall accept the\n            packet if the Verification Tag field of the packet\
    \ matches\n            its own tag OR it is set to its peer's tag and the T bit\n\
    \            is set in the Chunk Flags.  Otherwise, the receiver MUST\n      \
    \      silently discard the packet and take no further action.\n            An\
    \ endpoint MUST ignore the SHUTDOWN COMPLETE if it is\n            not in the\
    \ SHUTDOWN-ACK-SENT state.\n   ---------\n   New text: (Section 8.5.1)\n   ---------\n\
    \      C) Rules for packet carrying SHUTDOWN COMPLETE:\n         -  When sending\
    \ a SHUTDOWN COMPLETE, if the receiver of the\n            SHUTDOWN ACK has a\
    \ TCB, then the destination endpoint's tag\n            MUST be used, and the\
    \ T-bit MUST NOT be set.  Only where no\n            TCB exists should the sender\
    \ use the Verification Tag from\n            the SHUTDOWN ACK, and MUST set the\
    \ T-bit.\n         -  The receiver of a SHUTDOWN COMPLETE shall accept the packet\n\
    \            if the Verification Tag field of the packet matches its own\n   \
    \         tag and the T bit is not set\n            OR\n            if it is set\
    \ to its peer's tag and the T bit is set in the\n            Chunk Flags.\n  \
    \          Otherwise, the receiver MUST silently discard the packet\n        \
    \    and take no further action.  An endpoint MUST ignore the\n            SHUTDOWN\
    \ COMPLETE if it is not in the SHUTDOWN-ACK-SENT\n            state.\n"
- title: 2.41.3.  Solution Description
  contents:
  - "2.41.3.  Solution Description\n   The description of the T bit now clearly describes\
    \ the semantic of\n   the bit.  The procedures for receiving the T bit have been\
    \ clarified.\n"
- title: 2.42.  Unknown Parameter Handling
  contents:
  - '2.42.  Unknown Parameter Handling

    '
- title: 2.42.1.  Description of the Problem
  contents:
  - "2.42.1.  Description of the Problem\n   The description given in Section 2.33\
    \ does not state clearly whether\n   an INIT-ACK or COOKIE-ECHO is sent.\n"
- title: 2.42.2.  Text Changes to the Document
  contents:
  - "2.42.2.  Text Changes to the Document\n   The changes given here already include\
    \ changes suggested in Section\n   2.2, 2.27, and 2.33 of this document.\n   ---------\n\
    \   Old text: (Section 3.2.1)\n   ---------\n   00 - Stop processing this SCTP\
    \ packet and discard it do not process\n        any further chunks within it.\n\
    \   01 - Stop processing this SCTP packet and discard it, do not process\n   \
    \     any further chunks within it, and report the unrecognized\n        parameter\
    \ in an 'Unrecognized Parameter Type' (in either an\n        ERROR or in the INIT\
    \ ACK).\n   10 - Skip this parameter and continue processing.\n   11 - Skip this\
    \ parameter and continue processing but report the\n        unrecognized parameter\
    \ in an 'Unrecognized Parameter Type' (in\n        either an ERROR or in the INIT\
    \ ACK).\n   ---------\n   New text: (Section 3.2.1)\n   ---------\n   00 - Stop\
    \ processing this parameter; do not process\n        any further parameters within\
    \ this chunk.\n   01 - Stop processing this parameter, do not process\n      \
    \  any further parameters within this chunk, and report the\n        unrecognized\
    \ parameter in an 'Unrecognized Parameter', as\n        described in 3.2.2.\n\
    \   10 - Skip this parameter and continue processing.\n   11 - Skip this parameter\
    \ and continue processing but report the\n        unrecognized parameter in an\
    \ 'Unrecognized Parameter', as\n        described in 3.2.2.\n   Please note that\
    \ in all four cases an INIT-ACK or COOKIE-ECHO\n   chunk is sent.  In the 00 or\
    \ 01 case the processing of the\n   parameters after the unknown parameter is\
    \ canceled, but no\n   processing already done is rolled back.\n   ---------\n\
    \   New text: (Note: no old text; clarification added in Section 3.2)\n   ---------\n\
    \   3.2.2.  Reporting of Unrecognized Parameters\n      If the receiver of an\
    \ INIT chunk detects unrecognized parameters\n      and has to report them according\
    \ to Section 3.2.1, it MUST put\n      the 'Unrecognized Parameter' parameter(s)\
    \ in the INIT-ACK chunk\n      sent in response to the INIT-chunk.  Note that\
    \ if the receiver\n      of the INIT chunk is NOT going to establish an association\
    \ (e.g.,\n      due to lack of resources), an 'Unrecognized Parameter' would NOT\n\
    \      be included with any ABORT being sent to the sender of the INIT.\n    \
    \  If the receiver of an INIT-ACK chunk detects unrecognized\n      parameters\
    \ and has to report them according to Section 3.2.1, it\n      SHOULD bundle the\
    \ ERROR chunk containing the 'Unrecognized\n      Parameters' error cause with\
    \ the COOKIE-ECHO chunk sent in\n      response to the INIT-ACK chunk.  If the\
    \ receiver of the INIT-ACK\n      cannot bundle the COOKIE-ECHO chunk with the\
    \ ERROR chunk, the\n      ERROR chunk MAY be sent separately but not before the\
    \ COOKIE-ACK\n      has been received.\n      Note: Any time a COOKIE-ECHO is\
    \ sent in a packet, it MUST be the\n      first chunk.\n"
- title: 2.42.3.  Solution Description
  contents:
  - "2.42.3.  Solution Description\n   The new text clearly states that an INIT-ACK\
    \ or COOKIE-ECHO has to be\n   sent.\n"
- title: 2.43.  Cookie Echo Chunk
  contents:
  - '2.43.  Cookie Echo Chunk

    '
- title: 2.43.1.  Description of the Problem
  contents:
  - "2.43.1.  Description of the Problem\n   The description given in Section 3.3.11\
    \ of RFC 2960 [5] is unclear as\n   to how the COOKIE-ECHO is composed.\n"
- title: 2.43.2.  Text Changes to the Document
  contents:
  - "2.43.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.11)\n\
    \   ---------\n      Cookie: variable size\n         This field must contain the\
    \ exact cookie received in the State\n         Cookie parameter from the previous\
    \ INIT ACK.\n         An implementation SHOULD make the cookie as small as possible\n\
    \         to insure interoperability.\n   ---------\n   New text: (Section 3.3.11)\n\
    \   ---------\n      Cookie: variable size\n         This field must contain the\
    \ exact cookie received in the State\n         Cookie parameter from the previous\
    \ INIT ACK.\n         An implementation SHOULD make the cookie as small as possible\n\
    \         to ensure interoperability.\n         Note: A Cookie Echo does NOT contain\
    \ a State Cookie\n         Parameter; instead, the data within the State Cookie's\n\
    \         Parameter Value becomes the data within the Cookie Echo's\n        \
    \ Chunk Value.  This allows an implementation to change only\n         the first\
    \ two bytes of the State Cookie parameter to become\n         a Cookie Echo Chunk.\n"
- title: 2.43.3.  Solution Description
  contents:
  - "2.43.3.  Solution Description\n   The new text adds a note that helps clarify\
    \ that a Cookie Echo chunk\n   is nothing more than the State Cookie parameter\
    \ with only two bytes\n   modified.\n"
- title: 2.44.  Partial Chunks
  contents:
  - '2.44.  Partial Chunks

    '
- title: 2.44.1.  Description of the Problem
  contents:
  - "2.44.1.  Description of the Problem\n   Section 6.10 of RFC 2960 [5] uses the\
    \ notion of 'partial chunks'\n   without defining it.\n"
- title: 2.44.2.  Text Changes to the Document
  contents:
  - "2.44.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.10)\n\
    \   ---------\n   Partial chunks MUST NOT be placed in an SCTP packet.\n   ---------\n\
    \   New text: (Section 6.10)\n   ---------\n   Partial chunks MUST NOT be placed\
    \ in an SCTP packet.  A partial\n   chunk is a chunk that is not completely contained\
    \ in the SCTP\n   packet; i.e., the SCTP packet is too short to contain all the\
    \ bytes\n   of the chunk as indicated by the chunk length.\n"
- title: 2.44.3.  Solution Description
  contents:
  - "2.44.3.  Solution Description\n   The new text adds a definition of 'partial\
    \ chunks'.\n"
- title: 2.45.  Non-unicast Addresses
  contents:
  - '2.45.  Non-unicast Addresses

    '
- title: 2.45.1.  Description of the Problem
  contents:
  - "2.45.1.  Description of the Problem\n   Section 8.4 of RFC 2960 [5] forces the\
    \ OOTB handling to discard all\n   non-unicast addresses.  This leaves future\
    \ use of anycast addresses\n   in question.  With the addition of the add-ip feature,\
    \ SCTP should be\n   able to easily handle anycast INIT s that can be followed,\
    \ after\n   association setup, with a delete of the anycast address from the\n\
    \   association.\n"
- title: 2.45.2.  Text Changes to the Document
  contents:
  - "2.45.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 8.4)\n\
    \   ---------\n   8.4 Handle \"Out of the blue\" Packets\n      An SCTP packet\
    \ is called an \"out of the blue\" (OOTB) packet if\n      it is correctly formed,\
    \ i.e., passed the receiver's Adler-32\n      check (see Section 6.8), but the\
    \ receiver is not able to\n      identify the association to which this packet\
    \ belongs.\n      The receiver of an OOTB packet MUST do the following:\n    \
    \  1) If the OOTB packet is to or from a non-unicast address,\n         silently\
    \ discard the packet.  Otherwise,\n   ---------\n   New text: (Section 8.4)\n\
    \   ---------\n   8.4.  Handle \"Out of the Blue\" Packets\n      An SCTP packet\
    \ is called an \"out of the blue\" (OOTB) packet if\n      it is correctly formed\
    \ (i.e., passed the receiver's CRC32c\n      check; see Section 6.8), but the\
    \ receiver is not able to identify\n      the association to which this packet\
    \ belongs.\n      The receiver of an OOTB packet MUST do the following:\n    \
    \  1) If the OOTB packet is to or from a non-unicast address, a\n         receiver\
    \ SHOULD silently discard the packet.  Otherwise,\n"
- title: 2.45.3.  Solution Description
  contents:
  - "2.45.3.  Solution Description\n   The loosening of the wording to a SHOULD will\
    \ now allow future use of\n   anycast addresses.  Note that no changes are made\
    \ to Section\n   11.2.4.1, since responding to broadcast addresses could lead\
    \ to\n   flooding attacks and implementors should pay careful attention to\n \
    \  these words.\n"
- title: 2.46.  Processing of ABORT Chunks
  contents:
  - '2.46.  Processing of ABORT Chunks

    '
- title: 2.46.1.  Description of the Problem
  contents:
  - "2.46.1.  Description of the Problem\n   Section 3.3.7 of RFC 2960 [5] requires\
    \ an SCTP endpoint to silently\n   discard ABORT chunks received for associations\
    \ that do not exist.  It\n   is not clear what this means in the COOKIE-WAIT state,\
    \ for example.\n   Therefore, it was not clear whether an ABORT sent in response\
    \ to an\n   INIT should be processed or silently discarded.\n"
- title: 2.46.2.  Text Changes to the Document
  contents:
  - "2.46.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.7)\n\
    \   ---------\n      If an endpoint receives an ABORT with a format error or for\
    \ an\n      association that doesn't exist, it MUST silently discard it.\n   ---------\n\
    \   New text: (Section 3.3.7)\n   ---------\n      If an endpoint receives an\
    \ ABORT with a format error or no\n      TCB is found, it MUST silently discard\
    \ it.\n"
- title: 2.46.3.  Solution Description
  contents:
  - "2.46.3.  Solution Description\n   It is now clearly stated that an ABORT chunk\
    \ should be processed\n   whenever a TCB is found.\n"
- title: 2.47.  Sending of ABORT Chunks
  contents:
  - '2.47.  Sending of ABORT Chunks

    '
- title: 2.47.1.  Description of the Problem
  contents:
  - "2.47.1.  Description of the Problem\n   Section 5.1 of RFC 2960 [5] requires\
    \ that an ABORT chunk be sent in\n   response to an INIT chunk when there is no\
    \ listening end point.  To\n   make port scanning harder, someone might not want\
    \ these ABORTs to be\n   received by the sender of the INIT chunks.  Currently,\
    \ the only way\n   to enforce this is by using a firewall that discards the packets\n\
    \   containing the INIT chunks or the packets containing the ABORT\n   chunks.\
    \  It is desirable that the same can be done without a middle\n   box.\n"
- title: 2.47.2.  Text Changes to the Document
  contents:
  - "2.47.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 5.1)\n\
    \   ---------\n      If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO\
    \ chunk\n      but decides not to establish the new association due to missing\n\
    \      mandatory parameters in the received INIT or INIT ACK, invalid\n      parameter\
    \ values, or lack of local resources, it MUST respond with\n      an ABORT chunk.\n\
    \   ---------\n   New text: (Section 5.1)\n   ---------\n      If an endpoint\
    \ receives an INIT, INIT ACK, or COOKIE ECHO chunk\n      but decides not to establish\
    \ the new association due to missing\n      mandatory parameters in the received\
    \ INIT or INIT ACK, invalid\n      parameter values, or lack of local resources,\
    \ it SHOULD respond\n      with an ABORT chunk.\n"
- title: 2.47.3.  Solution Description
  contents:
  - "2.47.3.  Solution Description\n   The requirement of sending ABORT chunks is\
    \ relaxed such that an\n   implementation can decide not to send ABORT chunks.\n"
- title: 2.48.  Handling of Supported Address Types Parameter
  contents:
  - '2.48.  Handling of Supported Address Types Parameter

    '
- title: 2.48.1.  Description of the Problem
  contents:
  - "2.48.1.  Description of the Problem\n   The sender of the INIT chunk can include\
    \ a 'Supported Address Types'\n   parameter to indicate which address families\
    \ are supported.  It is\n   unclear how an INIT chunk should be processed where\
    \ the source\n   address of the packet containing the INIT chunk or listed addresses\n\
    \   within the INIT chunk indicate that more address types are supported\n   than\
    \ those listed in the 'Supported Address Types' parameter.\n"
- title: 2.48.2.  Text Changes to the Document
  contents:
  - "2.48.2.  Text Changes to the Document\n   The changes given here already include\
    \ changes suggested in Section\n   2.28 of this document.\n   ---------\n   Old\
    \ text: (Section 5.1.2)\n   ---------\n      IMPLEMENTATION NOTE: In the case\
    \ that the receiver of an INIT ACK\n      fails to resolve the address parameter\
    \ due to an unsupported type,\n      it can abort the initiation process and then\
    \ attempt a\n      re-initiation by using a 'Supported Address Types' parameter\
    \ in\n      the new INIT to indicate what types of address it prefers.\n   ---------\n\
    \   New text: (Section 5.1.2)\n   ---------\n      IMPLEMENTATION NOTE: In the\
    \ case that the receiver of an INIT ACK\n      fails to resolve the address parameter\
    \ due to an unsupported type,\n      it can abort the initiation process and then\
    \ attempt a re-\n      initiation by using a 'Supported Address Types' parameter\
    \ in the\n      new INIT to indicate what types of address it prefers.\n     \
    \ IMPLEMENTATION NOTE: If an SCTP endpoint that only supports either\n      IPv4\
    \ or IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT-\n      ACK chunk\
    \ from its peer, it MUST use all the addresses belonging\n      to the supported\
    \ address family.  The other addresses MAY be\n      ignored.  The endpoint SHOULD\
    \ NOT respond with any kind of error\n      indication.\n      IMPLEMENTATION\
    \ NOTE: If an SCTP endpoint lists in the 'Supported\n      Address Types' parameter\
    \ either IPv4 or IPv6, but uses the other\n      family for sending the packet\
    \ containing the INIT chunk, or if it\n      also lists addresses of the other\
    \ family in the INIT chunk, then\n      the address family that is not listed\
    \ in the 'Supported Address\n      Types' parameter SHOULD also be considered\
    \ as supported by the\n      receiver of the INIT chunk.  The receiver of the\
    \ INIT chunk SHOULD\n      NOT respond with any kind of error indication.\n"
- title: 2.48.3.  Solution Description
  contents:
  - "2.48.3.  Solution Description\n   It is now clearly described how these Supported\
    \ Address Types\n   parameters with incorrect data should be handled.\n"
- title: 2.49.  Handling of Unexpected Parameters
  contents:
  - '2.49.  Handling of Unexpected Parameters

    '
- title: 2.49.1.  Description of the Problem
  contents:
  - "2.49.1.  Description of the Problem\n   RFC 2960 [5] clearly describes how unknown\
    \ parameters in the INIT and\n   INIT-ACK chunk should be processed.  But it is\
    \ not described how\n   unexpected parameters should be processed.  A parameter\
    \ is unexpected\n   if it is known and is an optional parameter in either the\
    \ INIT or\n   INIT-ACK chunk but is received in the chunk for which it is not\
    \ an\n   optional parameter.  For example, the 'Supported Address Types'\n   parameter\
    \ would be an unexpected parameter if contained in an INIT-\n   ACK chunk.\n"
- title: 2.49.2.  Text Changes to the Document
  contents:
  - "2.49.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.2)\n\
    \   ---------\n      Note 4: This parameter, when present, specifies all the address\n\
    \      types the sending endpoint can support.  The absence of this\n      parameter\
    \ indicates that the sending endpoint can support any\n      address type.\n \
    \  ---------\n   New text: (Section 3.3.2)\n   ---------\n      Note 4: This parameter,\
    \ when present, specifies all the address\n      types the sending endpoint can\
    \ support.  The absence of this\n      parameter indicates that the sending endpoint\
    \ can support any\n      address type.\n      IMPLEMENTATION NOTE: If an INIT\
    \ chunk is received with known\n      parameters that are not optional parameters\
    \ of the INIT chunk\n      then the receiver SHOULD process the INIT chunk and\
    \ send back\n      an INIT-ACK.  The receiver of the INIT chunk MAY bundle an\
    \ ERROR\n      chunk with the COOKIE-ACK chunk later.  However, restrictive\n\
    \      implementations MAY send back an ABORT chunk in response to\n      the\
    \ INIT chunk.\n   ---------\n   Old text: (Section 3.3.3)\n   ---------\n    \
    \  IMPLEMENTATION NOTE: An implementation MUST be prepared to receive\n      a\
    \ INIT ACK that is quite large (more than 1500 bytes) due to the\n      variable\
    \ size of the state cookie AND the variable address list.\n      For example if\
    \ a responder to the INIT has 1000 IPv4 addresses\n      it wishes to send, it\
    \ would need at least 8,000 bytes to encode\n      this in the INIT ACK.\n   ---------\n\
    \   New text: (Section 3.3.3)\n   ---------\n      IMPLEMENTATION NOTE: An implementation\
    \ MUST be prepared to receive\n      a INIT ACK that is quite large (more than\
    \ 1500 bytes) due to the\n      variable size of the state cookie AND the variable\
    \ address list.\n      For example, if a responder to the INIT has 1000 IPv4 addresses\n\
    \      it wishes to send, it would need at least 8,000 bytes to encode\n     \
    \ this in the INIT ACK.\n      IMPLEMENTATION NOTE: If an INIT-ACK chunk is received\
    \ with known\n      parameters that are not optional parameters of the INIT-ACK\n\
    \      chunk, then the receiver SHOULD process the INIT-ACK chunk and\n      send\
    \ back a COOKIE-ECHO.  The receiver of the INIT-ACK chunk\n      MAY bundle an\
    \ ERROR chunk with the COOKIE-ECHO chunk.  However,\n      restrictive implementations\
    \ MAY send back an ABORT chunk in\n      response to the INIT-ACK chunk.\n"
- title: 2.49.3.  Solution Description
  contents:
  - "2.49.3.  Solution Description\n   It is now stated how unexpected parameters\
    \ should be processed.\n"
- title: 2.50.  Payload Protocol Identifier
  contents:
  - '2.50.  Payload Protocol Identifier

    '
- title: 2.50.1.  Description of the Problem
  contents:
  - "2.50.1.  Description of the Problem\n   The current description of the payload\
    \ protocol identifier does NOT\n   highlight the fact that the field is NOT necessarily\
    \ in network byte\n   order.\n"
- title: 2.50.2.  Text Changes to the Document
  contents:
  - "2.50.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 3.3.1)\n\
    \   ---------\n      Payload Protocol Identifier: 32 bits (unsigned integer)\n\
    \         This value represents an application (or upper layer) specified\n  \
    \       protocol identifier.  This value is passed to SCTP by its upper\n    \
    \     layer and sent to its peer.  This identifier is not used by\n         SCTP\
    \ but can be used by certain network entities as well as\n         the peer application\
    \ to identify the type of information being\n         carried in this DATA chunk.\
    \  This field must be sent even in\n         fragmented DATA chunks (to make sure\
    \ it is available for agents\n         in the middle of the network).\n      \
    \   The value 0 indicates no application identifier is specified by\n        \
    \ the upper layer for this payload data.\n   ---------\n   New text: (Section\
    \ 3.3.1)\n   ---------\n      Payload Protocol Identifier: 32 bits (unsigned integer)\n\
    \         This value represents an application (or upper layer) specified\n  \
    \       protocol identifier.  This value is passed to SCTP by its upper\n    \
    \     layer and sent to its peer.  This identifier is not used by\n         SCTP\
    \ but can be used by certain network entities, as well as by\n         the peer\
    \ application, to identify the type of information being\n         carried in\
    \ this DATA chunk.  This field must be sent even in\n         fragmented DATA\
    \ chunks (to make sure it is available for agents\n         in the middle of the\
    \ network).  Note that this field is NOT\n         touched by an SCTP implementation,\
    \ therefore its byte order is\n         NOT necessarily Big Endian.  The upper\
    \ layer is responsible\n         for any byte order conversions to this field.\n\
    \         The value 0 indicates that no application identifier is\n         specified\
    \ by the upper layer for this payload data.\n"
- title: 2.50.3.  Solution Description
  contents:
  - "2.50.3.  Solution Description\n   It is now explicitly stated that the upper\
    \ layer is responsible for\n   the byte order of this field.\n"
- title: 2.51.  Karn's Algorithm
  contents:
  - '2.51.  Karn''s Algorithm

    '
- title: 2.51.1.  Description of the Problem
  contents:
  - "2.51.1.  Description of the Problem\n   The current wording of the use of Karn's\
    \ algorithm is not descriptive\n   enough to ensure that an implementation in\
    \ a multi-homed association\n   does not incorrectly mismeasure the RTT.\n"
- title: 2.51.2.  Text Changes to the Document
  contents:
  - "2.51.2.  Text Changes to the Document\n   ---------\n   Old text: (Section 6.3.1)\n\
    \   ---------\n      C5) Karn's algorithm: RTT measurements MUST NOT be made using\n\
    \          packets that were retransmitted (and thus for which it is\n       \
    \   ambiguous whether the reply was for the first instance of the\n          packet\
    \ or a later instance)\n   ---------\n   New text: (Section 6.3.1)\n   ---------\n\
    \      C5) Karn's algorithm: RTT measurements MUST NOT be made using\n       \
    \   chunks that were retransmitted (and thus for which it is\n          ambiguous\
    \ whether the reply was for the first instance of\n          the chunk or for\
    \ a later instance)\n          IMPLEMENTATION NOTE: RTT measurements should only\
    \ be\n          made using a chunk with TSN r if no chunk\n          with TSN\
    \ less than or equal to r is retransmitted\n          since r is first sent.\n"
- title: 2.51.3.  Solution Description
  contents:
  - "2.51.3.  Solution Description\n   The above clarification adds an implementation\
    \ note that will provide\n   additional guidance in the application of Karn's\
    \ algorithm.\n"
- title: 2.52.  Fast Retransmit Algorithm
  contents:
  - '2.52.  Fast Retransmit Algorithm

    '
- title: 2.52.1.  Description of the Problem
  contents:
  - "2.52.1.  Description of the Problem\n   The original SCTP specification is overly\
    \ conservative in requiring 4\n   missing reports before fast retransmitting a\
    \ segment.  TCP uses 3\n   missing reports or 4 acknowledgements indicating that\
    \ the same\n   segment was received.\n"
- title: 2.52.2.  Text Changes to the Document
  contents:
  - "2.52.2.  Text Changes to the Document\n   ---------\n   Old text:\n   ---------\n\
    \   7.2.4 Fast Retransmit on Gap Reports\n      In the absence of data loss, an\
    \ endpoint performs delayed\n      acknowledgement.  However, whenever an endpoint\
    \ notices a hole in\n      the arriving TSN sequence, it SHOULD start sending\
    \ a SACK back\n      every time a packet arrives carrying data until the\n   \
    \   hole is filled.\n      Whenever an endpoint receives a SACK that indicates\
    \ some TSN(s)\n      missing, it SHOULD wait for 3 further miss indications (via\n\
    \      subsequent SACK's) on the same TSN(s) before taking action with\n     \
    \ regard to Fast Retransmit.\n   ---------\n   New text:\n   ---------\n   7.2.4.\
    \  Fast Retransmit on Gap Reports\n      In the absence of data loss, an endpoint\
    \ performs delayed\n      acknowledgement.  However, whenever an endpoint notices\
    \ a hole in\n      the arriving TSN sequence, it SHOULD start sending a SACK back\n\
    \      every time a packet arrives carrying data until the\n      hole is filled.\n\
    \      Whenever an endpoint receives a SACK that indicates that some\n      TSNs\
    \ are missing, it SHOULD wait for 2 further miss indications\n      (via subsequent\
    \ SACKs for a total of 3 missing reports) on the\n      same TSNs before taking\
    \ action with regard to Fast Retransmit.\n"
- title: 2.52.3.  Solution Description
  contents:
  - "2.52.3.  Solution Description\n   The above changes will make SCTP and TCP behave\
    \ similarly in terms of\n   how fast they engage the Fast Retransmission algorithm\
    \ upon receiving\n   missing reports.\n"
- title: 3.  Security Considerations
  contents:
  - "3.  Security Considerations\n   This document should add no additional security\
    \ risks to SCTP and in\n   fact SHOULD correct some original security flaws within\
    \ the original\n   document once it is incorporated into a RFC 2960 [5] BIS document.\n"
- title: 4.  Acknowledgements
  contents:
  - "4.  Acknowledgements\n   The authors would like to thank the following people\
    \ who have\n   provided comments and input for this document:\n   Barry Zuckerman,\
    \ La Monte Yarroll, Qiaobing Xie, Wang Xiaopeng,\n   Jonathan Wood, Jeff Waskow,\
    \ Mike Turner, John Townsend, Sabina\n   Torrente, Cliff Thomas, Yuji Suzuki,\
    \ Manoj Solanki, Sverre Slotte,\n   Keyur Shah, Jan Rovins, Ben Robinson, Renee\
    \ Revis, Ian Periam, RC\n   Monee, Sanjay Rao, Sujith Radhakrishnan, Heinz Prantner,\
    \ Biren Patel,\n   Nathalie Mouellic, Mitch Miers, Bernward Meyknecht, Stan McClellan,\n\
    \   Oliver Mayor, Tomas Orti Martin, Sandeep Mahajan, David Lehmann,\n   Jonathan\
    \ Lee, Philippe Langlois, Karl Knutson, Joe Keller, Gareth\n   Keily, Andreas\
    \ Jungmaier, Janardhan Iyengar, Mutsuya Irie, John\n   Hebert, Kausar Hassan,\
    \ Fred Hasle, Dan Harrison, Jon Grim, Laurent\n   Glaude, Steven Furniss, Atsushi\
    \ Fukumoto, Ken Fujita, Steve Dimig,\n   Thomas Curran, Serkan Cil, Melissa Campbell,\
    \ Peter Butler, Rob\n   Brennan, Harsh Bhondwe, Brian Bidulock, Caitlin Bestler,\
    \ Jon Berger,\n   Robby Benedyk, Stephen Baucke, Sandeep Balani, and Ronnie Sellar.\n\
    \   A special thanks to Mark Allman, who should actually be a co-author\n   for\
    \ his work on the max-burst, but managed to wiggle out due to a\n   technicality.\
    \  Also, we would like to acknowledge Lyndon Ong and Phil\n   Conrad for their\
    \ valuable input and many contributions.\n"
- title: 5.  IANA Considerations
  contents:
  - "5.  IANA Considerations\n   This document recommends changes for the RFC 2960\
    \ [5] BIS document.\n   As such, even though it lists new error cause code, this\
    \ document in\n   itself does NOT define those new codes.  Instead, the BIS document\n\
    \   will make the needed changes to RFC 2960 [5] and thus its IANA\n   section\
    \ will require changes to be made.\n"
- title: 6.  Normative References
  contents:
  - "6.  Normative References\n   [1]  Braden, R., \"Requirements for Internet Hosts\
    \ - Communication\n        Layers\", STD 3, RFC 1122, October 1989.\n   [2]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [3]  Caro, A., Shah, K., Iyengar, J., Amer, P.,\
    \ and R. Stewart, \"SCTP\n        and TCP Variants: Congestion Control Under Multiple\
    \ Losses\",\n        Technical Report TR2003-04, Computer and Information Sciences\n\
    \        Department, University of Delaware, February 2003,\n        <http://www.armandocaro.net/papers>.\n\
    \   [4]  Caro, A., Amer, P., and R. Stewart, \"Retransmission Schemes for\n  \
    \      End-to-end Failover with Transport Layer Multihoming\", GLOBECOM,\n   \
    \     November 2004., <http://www.armandocaro.net/papers>.\n   [5]  Stewart, R.,\
    \ Xie, Q., Morneault, K., Sharp, C., Schwarzbauer,\n        H., Taylor, T., Rytina,\
    \ I., Kalla, M., Zhang, L., and V.\n        Paxson, \"Stream Control Transmission\
    \ Protocol\", RFC 2960,\n        October 2000.\n   [6]  Stone, J., Stewart, R.,\
    \ and D. Otis, \"Stream Control\n        Transmission Protocol (SCTP) Checksum\
    \ Change\", RFC 3309,\n        September 2002.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Randall R. Stewart\n   Cisco Systems, Inc.\n   4875 Forest\
    \ Drive\n   Suite 200\n   Columbia, SC  29206\n   USA\n   EMail: rrs@cisco.com\n\
    \   Ivan Arias-Rodriguez\n   Nokia Research Center\n   PO Box 407\n   FIN-00045\
    \ Nokia Group\n   Finland\n   EMail: ivan.arias-rodriguez@nokia.com\n   Kacheong\
    \ Poon\n   Sun Microsystems, Inc.\n   3571 N. First St.\n   San Jose, CA  95134\n\
    \   USA\n   EMail: kacheong.poon@sun.com\n   Armando L. Caro Jr.\n   BBN Technologies\n\
    \   10 Moulton St.\n   Cambridge, MA 02138\n   EMail: acaro@bbn.com\n   URI: \
    \  http://www.armandocaro.net\n   Michael Tuexen\n   Muenster Univ. of Applied\
    \ Sciences\n   Stegerwaldstr. 39\n   48565 Steinfurt\n   Germany\n   EMail: tuexen@fh-muenster.de\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
