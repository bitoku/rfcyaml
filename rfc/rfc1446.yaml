- title: __initial_text__
  contents:
  - "          Network Working Group                                J. Galvin\n  \
    \        Request for Comments: 1446         Trusted Information Systems\n    \
    \                           for version 2 of the\n                   Simple Network\
    \ Management Protocol (SNMPv2)\n          Status of this Memo\n          This\
    \ RFC specifes an IAB standards track protocol for the\n          Internet community,\
    \ and requests discussion and suggestions\n          for improvements.  Please\
    \ refer to the current edition of the\n          \"IAB Official Protocol Standards\"\
    \ for the standardization\n          state and status of this protocol.  Distribution\
    \ of this memo\n          is unlimited.\n          Table of Contents\n       \
    \   RFC 1446        Security Protocols for SNMPv2       April 1993\n         \
    \ 6.3.1 Clock Monotonicity Mechanism ......................   43\n          6.3.2\
    \ Data Integrity Mechanism ..........................   43\n          6.3.3 Data\
    \ Origin Authentication Mechanism ..............   44\n          6.3.4 Restricted\
    \ Administration Mechanism ...............   44\n          6.3.5 Message Timeliness\
    \ Mechanism ......................   45\n          6.3.6 Selective Clock Acceleration\
    \ Mechanism ............   46\n          6.3.7 Confidentiality Mechanism .........................\
    \   47\n          7 Acknowledgements ......................................  \
    \ 48\n          8 References ............................................   49\n\
    \          9 Authors' Addresses ....................................   51\n  \
    \        RFC 1446        Security Protocols for SNMPv2       April 1993\n    \
    \      1.  Introduction\n          A network management system contains: several\
    \ (potentially\n          many) nodes, each with a processing entity, termed an\
    \ agent,\n          which has access to management instrumentation; at least one\n\
    \          management station; and, a management protocol, used to convey\n  \
    \        management information between the agents and management\n          stations.\
    \  Operations of the protocol are carried out under an\n          administrative\
    \ framework which defines both authentication and\n          authorization policies.\n\
    \          Network management stations execute management applications\n     \
    \     which monitor and control network elements.  Network elements\n        \
    \  are devices such as hosts, routers, terminal servers, etc.,\n          which\
    \ are monitored and controlled through access to their\n          management information.\n\
    \          In the Administrative Model for SNMPv2 document [1], each\n       \
    \   SNMPv2 party is, by definition, associated with a single\n          authentication\
    \ protocol and a single privacy protocol.  It is\n          the purpose of this\
    \ document, Security Protocols for SNMPv2,\n          to define one such authentication\
    \ and one such privacy\n          protocol.\n          The authentication protocol\
    \ provides a mechanism by which\n          SNMPv2 management communications transmitted\
    \ by the party may\n          be reliably identified as having originated from\
    \ that party.\n          The authentication protocol defined in this memo also\
    \ reliably\n          determines that the message received is the message that\
    \ was\n          sent.\n          The privacy protocol provides a mechanism by\
    \ which SNMPv2\n          management communications transmitted to said party\
    \ are\n          protected from disclosure.  The privacy protocol in this memo\n\
    \          specifies that only authenticated messages may be protected\n     \
    \     from disclosure.\n          These protocols are secure alternatives to the\
    \ so-called\n          \"trivial\" protocol defined in [2].\n               USE\
    \ OF THE TRIVIAL PROTOCOL ALONE DOES NOT CONSTITUTE\n               SECURE NETWORK\
    \ MANAGEMENT.  THEREFORE, A NETWORK\n               MANAGEMENT SYSTEM THAT IMPLEMENTS\
    \ ONLY THE TRIVIAL\n               PROTOCOL IS NOT CONFORMANT TO THIS SPECIFICATION.\n\
    \          RFC 1446        Security Protocols for SNMPv2       April 1993\n  \
    \        The Digest Authentication Protocol is described in Section 3.\n     \
    \     It provides a data integrity service by transmitting a message\n       \
    \   digest - computed by the originator and verified by the\n          recipient\
    \ - with each SNMPv2 message.  The data origin\n          authentication service\
    \ is provided by prefixing the message\n          with a secret value known only\
    \ to the originator and\n          recipient, prior to computing the digest. \
    \ Thus, data\n          integrity is supported explicitly while data origin\n\
    \          authentication is supported implicitly in the verification of\n   \
    \       the digest.\n          The Symmetric Privacy Protocol is described in\
    \ Section 4.  It\n          protects messages from disclosure by encrypting their\
    \ contents\n          according to a secret cryptographic key known only to the\n\
    \          originator and recipient.  The additional functionality\n         \
    \ afforded by this protocol is assumed to justify its additional\n          computational\
    \ cost.\n          The Digest Authentication Protocol depends on the existence\
    \ of\n          loosely synchronized clocks between the originator and\n     \
    \     recipient of a message.  The protocol specification makes no\n         \
    \ assumptions about the strategy by which such clocks are\n          synchronized.\
    \  Section 5.3 presents one strategy that is\n          particularly suited to\
    \ the demands of SNMP network management.\n          Both protocols described\
    \ here require the sharing of secret\n          information between the originator\
    \ of a message and its\n          recipient.  The protocol specifications assume\
    \ the existence\n          of the necessary secrets.  The selection of such secrets\
    \ and\n          their secure distribution to appropriate parties may be\n   \
    \       accomplished by a variety of strategies.  Section 5.4 presents\n     \
    \     one such strategy that is particularly suited to the demands\n         \
    \ of SNMP network management.\n          1.1.  A Note on Terminology\n       \
    \   For the purpose of exposition, the original Internet-standard\n          Network\
    \ Management Framework, as described in RFCs 1155, 1157,\n          and 1212,\
    \ is termed the SNMP version 1 framework (SNMPv1).\n          The current framework\
    \ is termed the SNMP version 2 framework\n          (SNMPv2).\n          RFC 1446\
    \        Security Protocols for SNMPv2       April 1993\n          1.2.  Threats\n\
    \          Several of the classical threats to network protocols are\n       \
    \   applicable to the network management problem and therefore\n          would\
    \ be applicable to any SNMPv2 security protocol.  Other\n          threats are\
    \ not applicable to the network management problem.\n          This section discusses\
    \ principal threats, secondary threats,\n          and threats which are of lesser\
    \ importance.\n          The principal threats against which any SNMPv2 security\n\
    \          protocol should provide protection are:\n          Modification of\
    \ Information\n               The SNMPv2 protocol provides the means for management\n\
    \               stations to interrogate and to manipulate the value of\n     \
    \          objects in a managed agent.  The modification threat is\n         \
    \      the danger that some party may alter in-transit messages\n            \
    \   generated by an authorized party in such a way as to\n               effect\
    \ unauthorized management operations, including\n               falsifying the\
    \ value of an object.\n          Masquerade\n               The SNMPv2 administrative\
    \ model includes an access\n               control model.  Access control necessarily\
    \ depends on\n               knowledge of the origin of a message.  The masquerade\n\
    \               threat is the danger that management operations not\n        \
    \       authorized for some party may be attempted by that party\n           \
    \    by assuming the identity of another party that has the\n               appropriate\
    \ authorizations.\n          Two secondary threats are also identified.  The security\n\
    \          protocols defined in this memo do provide protection against:\n   \
    \       Message Stream Modification\n               The SNMPv2 protocol is based\
    \ upon a connectionless\n               transport service which may operate over\
    \ any subnetwork\n               service.  The re-ordering, delay or replay of\
    \ messages\n               can and does occur through the natural operation of\
    \ many\n               such subnetwork services.  The message stream\n       \
    \        modification threat is the danger that messages may be\n            \
    \   maliciously re-ordered, delayed or replayed to an extent\n               which\
    \ is greater than can occur through the natural\n               operation of a\
    \ subnetwork service, in order to effect\n               unauthorized management\
    \ operations.\n          RFC 1446        Security Protocols for SNMPv2       April\
    \ 1993\n          Disclosure\n               The disclosure threat is the danger\
    \ of eavesdropping on\n               the exchanges between managed agents and\
    \ a management\n               station.  Protecting against this threat is mandatory\n\
    \               when the SNMPv2 is used to create new SNMPv2 parties [1]\n   \
    \            on which subsequent secure operation might be based.\n          \
    \     Protecting against the disclosure threat may also be\n               required\
    \ as a matter of local policy.\n          There are at least two threats that\
    \ a SNMPv2 security protocol\n          need not protect against.  The security\
    \ protocols defined in\n          this memo do not provide protection against:\n\
    \          Denial of Service\n               A SNMPv2 security protocol need not\
    \ attempt to address\n               the broad range of attacks by which service\
    \ to authorized\n               parties is denied.  Indeed, such denial-of-service\n\
    \               attacks are in many cases indistinguishable from the type\n  \
    \             of network failures with which any viable network\n            \
    \   management protocol must cope as a matter of course.\n          Traffic Analysis\n\
    \               In addition, a SNMPv2 security protocol need not attempt\n   \
    \            to address traffic analysis attacks.  Indeed, many\n            \
    \   traffic patterns are predictable - agents may be managed\n               on\
    \ a regular basis by a relatively small number of\n               management stations\
    \ - and therefore there is no\n               significant advantage afforded by\
    \ protecting against\n               traffic analysis.\n          1.3.  Goals\
    \ and Constraints\n          Based on the foregoing account of threats in the\
    \ SNMP network\n          management environment, the goals of a SNMPv2 security\n\
    \          protocol are enumerated below.\n          (1)  The protocol should\
    \ provide for verification that each\n               received SNMPv2 message has\
    \ not been modified during its\n               transmission through the network\
    \ in such a way that an\n               unauthorized management operation might\
    \ result.\n          (2)  The protocol should provide for verification of the\n\
    \               identity of the originator of each received SNMPv2\n         \
    \      message.\n          RFC 1446        Security Protocols for SNMPv2     \
    \  April 1993\n          (3)  The protocol should provide that the apparent time\
    \ of\n               generation for each received SNMPv2 message is recent.\n\
    \          (4)  The protocol should provide, when necessary, that the\n      \
    \         contents of each received SNMPv2 message are protected\n           \
    \    from disclosure.\n          In addition to the principal goal of supporting\
    \ secure network\n          management, the design of any SNMPv2 security protocol\
    \ is also\n          influenced by the following constraints:\n          (1) \
    \ When the requirements of effective management in times of\n               network\
    \ stress are inconsistent with those of security,\n               the former are\
    \ preferred.\n          (2)  Neither the security protocol nor its underlying\
    \ security\n               mechanisms should depend upon the ready availability\
    \ of\n               other network services (e.g., Network Time Protocol (NTP)\n\
    \               or secret/key management protocols).\n          (3)  A security\
    \ mechanism should entail no changes to the\n               basic SNMP network\
    \ management philosophy.\n          1.4.  Security Services\n          The security\
    \ services necessary to support the goals of a\n          SNMPv2 security protocol\
    \ are as follows.\n          Data Integrity\n               is the provision of\
    \ the property that data has not been\n               altered or destroyed in\
    \ an unauthorized manner, nor have\n               data sequences been altered\
    \ to an extent greater than can\n               occur non-maliciously.\n     \
    \     Data Origin Authentication\n               is the provision of the property\
    \ that the claimed origin\n               of received data is corroborated.\n\
    \          Data Confidentiality\n               is the provision of the property\
    \ that information is not\n               made available or disclosed to unauthorized\
    \ individuals,\n               entities, or processes.\n          RFC 1446   \
    \     Security Protocols for SNMPv2       April 1993\n          The protocols\
    \ specified in this memo require both data\n          integrity and data origin\
    \ authentication to be used at all\n          times.  For these protocols, it\
    \ is not possible to realize\n          data integrity without data origin authentication,\
    \ nor is it\n          possible to realize data origin authentication without\
    \ data\n          integrity.\n          Further, there is no provision for data\
    \ confidentiality\n          without both data integrity and data origin authentication.\n\
    \          1.5.  Mechanisms\n          The security protocols defined in this\
    \ memo employ several\n          types of mechanisms in order to realize the goals\
    \ and security\n          services described above:\n          o    In support\
    \ of data integrity, a message digest algorithm\n               is required. \
    \ A digest is calculated over an appropriate\n               portion of a SNMPv2\
    \ message and included as part of the\n               message sent to the recipient.\n\
    \          o    In support of data origin authentication and data\n          \
    \     integrity, the portion of a SNMPv2 message that is\n               digested\
    \ is first prefixed with a secret value shared by\n               the originator\
    \ of that message and its intended\n               recipient.\n          o   \
    \ To protect against the threat of message delay or replay,\n               (to\
    \ an extent greater than can occur through normal\n               operation),\
    \ a timestamp value is included in each message\n               generated.  A\
    \ recipient evaluates the timestamp to\n               determine if the message\
    \ is recent.  This protection\n               against the threat of message delay\
    \ or replay does not\n               imply nor provide any protection against\
    \ unauthorized\n               deletion or suppression of messages.  Other mechanisms\n\
    \               defined independently of the security protocol can also\n    \
    \           be used to detect message replay (e.g., the request-id\n         \
    \      [2]), or for set operations, the re-ordering, replay,\n               deletion,\
    \ or suppression of messages (e.g., the MIB\n               variable snmpSetSerialNo\
    \ [14]).\n          o    In support of data confidentiality, a symmetric\n   \
    \            encryption algorithm is required.  An appropriate portion\n     \
    \          of the message is encrypted prior to being transmitted to\n       \
    \   RFC 1446        Security Protocols for SNMPv2       April 1993\n         \
    \      its recipient.\n          The security protocols in this memo are defined\
    \ independently\n          of the particular choice of a message digest and encryption\n\
    \          algorithm - owing principally to the lack of a suitable metric\n  \
    \        by which to evaluate the security of particular algorithm\n         \
    \ choices.  However, in the interests of completeness and in\n          order\
    \ to guarantee interoperability, Sections 1.5.1 and 1.5.2\n          specify particular\
    \ choices, which are considered acceptably\n          secure as of this writing.\
    \  In the future, this memo may be\n          updated by the publication of a\
    \ memo specifying substitute or\n          alternate choices of algorithms, i.e.,\
    \ a replacement for or\n          addition to the sections below.\n          1.5.1.\
    \  Message Digest Algorithm\n          In support of data integrity, the use of\
    \ the MD5 [3] message\n          digest algorithm is chosen.  A 128-bit digest\
    \ is calculated\n          over the designated portion of a SNMPv2 message and\
    \ included\n          as part of the message sent to the recipient.\n        \
    \  An appendix of [3] contains a C Programming Language\n          implementation\
    \ of the algorithm.  This code was written with\n          portability being the\
    \ principal objective.  Implementors may\n          wish to optimize the implementation\
    \ with respect to the\n          characteristics of their hardware and software\
    \ platforms.\n          The use of this algorithm in conjunction with the Digest\n\
    \          Authentication Protocol (see Section 3) is identified by the\n    \
    \      ASN.1 object identifier value v2md5AuthProtocol, defined in\n         \
    \ [4].  (Note that this protocol is a modified version of the\n          md5AuthProtocol\
    \ protocol defined in RFC 1352.)\n          For any SNMPv2 party for which the\
    \ authentication protocol is\n          v2md5AuthProtocol, the size of its private\
    \ authentication key\n          is 16 octets.\n          Within an authenticated\
    \ management communication generated by\n          such a party, the size of the\
    \ authDigest component of that\n          communication (see Section 3) is 16\
    \ octets.\n          RFC 1446        Security Protocols for SNMPv2       April\
    \ 1993\n          1.5.2.  Symmetric Encryption Algorithm\n          In support\
    \ of data confidentiality, the use of the Data\n          Encryption Standard\
    \ (DES) in the Cipher Block Chaining mode of\n          operation is chosen. \
    \ The designated portion of a SNMPv2\n          message is encrypted and included\
    \ as part of the message sent\n          to the recipient.\n          Two organizations\
    \ have published specifications defining the\n          DES: the National Institute\
    \ of Standards and Technology (NIST)\n          [5] and the American National\
    \ Standards Institute [6].  There\n          is a companion Modes of Operation\
    \ specification for each\n          definition (see [7] and [8], respectively).\n\
    \          The NIST has published three additional documents that\n          implementors\
    \ may find useful.\n          o    There is a document with guidelines for implementing\
    \ and\n               using the DES, including functional specifications for\n\
    \               the DES and its modes of operation [9].\n          o    There\
    \ is a specification of a validation test suite for\n               the DES [10].\
    \  The suite is designed to test all aspects\n               of the DES and is\
    \ useful for pinpointing specific\n               problems.\n          o    There\
    \ is a specification of a maintenance test for the\n               DES [11]. \
    \ The test utilizes a minimal amount of data and\n               processing to\
    \ test all components of the DES.  It\n               provides a simple yes-or-no\
    \ indication of correct\n               operation and is useful to run as part\
    \ of an\n               initialization step, e.g., when a computer reboots.\n\
    \          The use of this algorithm in conjunction with the Symmetric\n     \
    \     Privacy Protocol (see Section 4) is identified by the ASN.1\n          object\
    \ identifier value desPrivProtocol, defined in [4].\n          For any SNMPv2\
    \ party for which the privacy protocol is\n          desPrivProtocol, the size\
    \ of the private privacy key is 16\n          octets, of which the first 8 octets\
    \ are a DES key and the\n          second 8 octets are a DES Initialization Vector.\
    \  The 64-bit\n          DES key in the first 8 octets of the private key is a\
    \ 56 bit\n          quantity used directly by the algorithm plus 8 parity bits\
    \ -\n          arranged so that one parity bit is the least significant bit\n\
    \          of each octet.  The setting of the parity bits is ignored.\n      \
    \    RFC 1446        Security Protocols for SNMPv2       April 1993\n        \
    \  The length of the octet sequence to be encrypted by the DES\n          must\
    \ be an integral multiple of 8.  When encrypting, the data\n          should be\
    \ padded at the end as necessary; the actual pad value\n          is insignificant.\n\
    \          If the length of the octet sequence to be decrypted is not an\n   \
    \       integral multiple of 8 octets, the processing of the octet\n         \
    \ sequence should be halted and an appropriate exception noted.\n          Upon\
    \ decrypting, the padding should be ignored.\n          RFC 1446        Security\
    \ Protocols for SNMPv2       April 1993\n          2.  SNMPv2 Party\n        \
    \  Recall from [1] that a SNMPv2 party is a conceptual, virtual\n          execution\
    \ context whose operation is restricted (for security\n          or other purposes)\
    \ to an administratively defined subset of\n          all possible operations\
    \ of a particular SNMPv2 entity.  A\n          SNMPv2 entity is an actual process\
    \ which performs network\n          management operations by generating and/or\
    \ responding to\n          SNMPv2 protocol messages in the manner specified in\
    \ [12].\n          Architecturally, every SNMPv2 entity maintains a local\n  \
    \        database that represents all SNMPv2 parties known to it.\n          RFC\
    \ 1446        Security Protocols for SNMPv2       April 1993\n          A SNMPv2\
    \ party may be represented by an ASN.1 value with the\n          following syntax:\n\
    \               SnmpParty ::= SEQUENCE {\n                 partyIdentity\n   \
    \                 OBJECT IDENTIFIER,\n                 partyTDomain\n        \
    \            OBJECT IDENTIFIER,\n                 partyTAddress\n            \
    \        OCTET STRING,\n                 partyMaxMessageSize\n               \
    \     INTEGER,\n                 partyAuthProtocol\n                    OBJECT\
    \ IDENTIFIER,\n                 partyAuthClock\n                    INTEGER,\n\
    \                 partyAuthPrivate\n                    OCTET STRING,\n      \
    \           partyAuthPublic\n                    OCTET STRING,\n             \
    \    partyAuthLifetime\n                    INTEGER,\n                 partyPrivProtocol\n\
    \                    OBJECT IDENTIFIER,\n                 partyPrivPrivate\n \
    \                   OCTET STRING,\n                 partyPrivPublic\n        \
    \            OCTET STRING\n               }\n          For each SnmpParty value\
    \ that represents a SNMPv2 party, the\n          generic significance of each\
    \ of its components is defined in\n          [1].  For each SNMPv2 party that\
    \ supports the generation of\n          messages using the Digest Authentication\
    \ Protocol, additional,\n          special significance is attributed to certain\
    \ components of\n          that party's representation:\n          o    Its partyAuthProtocol\
    \ component is called the\n               authentication protocol and identifies\
    \ a combination of\n               the Digest Authentication Protocol with a particular\n\
    \               digest algorithm (such as that defined in Section 1.5.1).\n  \
    \             This combined mechanism is used to authenticate the\n          \
    \     origin and integrity of all messages generated by the\n               party.\n\
    \          RFC 1446        Security Protocols for SNMPv2       April 1993\n  \
    \        o    Its partyAuthClock component is called the authentication\n    \
    \           clock and represents a notion of the current time that is\n      \
    \         specific to the party.\n          o    Its partyAuthPrivate component\
    \ is called the private\n               authentication key and represents any\
    \ secret value needed\n               to support the Digest Authentication Protocol\
    \ and\n               associated digest algorithm.\n          o    Its partyAuthPublic\
    \ component is called the public\n               authentication key and represents\
    \ any public value that\n               may be needed to support the authentication\
    \ protocol.\n               This component is not significant except as suggested\
    \ in\n               Section 5.4.\n          o    Its partyAuthLifetime component\
    \ is called the lifetime\n               and represents an administrative upper\
    \ bound on\n               acceptable delivery delay for protocol messages generated\n\
    \               by the party.\n          For each SNMPv2 party that supports the\
    \ receipt of messages\n          via the Symmetric Privacy Protocol, additional,\
    \ special\n          significance is attributed to certain components of that\n\
    \          party's representation:\n          o    Its partyPrivProtocol component\
    \ is called the privacy\n               protocol and identifies a combination\
    \ of the Symmetric\n               Privacy Protocol with a particular encryption\
    \ algorithm\n               (such as that defined in Section 1.5.2).  This combined\n\
    \               mechanism is used to protect from disclosure all protocol\n  \
    \             messages received by the party.\n          o    Its partyPrivPrivate\
    \ component is called the private\n               privacy key and represents any\
    \ secret value needed to\n               support the Symmetric Privacy Protocol\
    \ and associated\n               encryption algorithm.\n          o    Its partyPrivPublic\
    \ component is called the public\n               privacy key and represents any\
    \ public value that may be\n               needed to support the privacy protocol.\
    \  This component\n               is not significant except as suggested in Section\
    \ 5.4.\n          RFC 1446        Security Protocols for SNMPv2       April 1993\n\
    \          3.  Digest Authentication Protocol\n          This section describes\
    \ the Digest Authentication Protocol.  It\n          provides both for verifying\
    \ the integrity of a received\n          message (i.e., the message received is\
    \ the message sent) and\n          for verifying the origin of a message (i.e.,\
    \ the reliable\n          identification of the originator).  The integrity of\
    \ the\n          message is protected by computing a digest over an appropriate\n\
    \          portion of a message.  The digest is computed by the\n          originator\
    \ of the message, transmitted with the message, and\n          verified by the\
    \ recipient of the message.\n          A secret value known only to the originator\
    \ and recipient of\n          the message is prefixed to the message prior to\
    \ the digest\n          computation.  Thus, the origin of the message is known\n\
    \          implicitly with the verification of the digest.\n          A requirement\
    \ on parties using this Digest Authentication\n          Protocol is that they\
    \ shall not originate messages for\n          transmission to any destination\
    \ party which does not also use\n          this Digest Authentication Protocol.\
    \  This restriction\n          excludes undesirable side effects of communication\
    \ between a\n          party which uses these security protocols and a party which\n\
    \          does not.\n          Recall from [1] that a SNMPv2 management communication\
    \ is\n          represented by an ASN.1 value with the following syntax:\n   \
    \            SnmpMgmtCom ::= [2] IMPLICIT SEQUENCE {\n                 dstParty\n\
    \                    OBJECT IDENTIFIER,\n                 srcParty\n         \
    \           OBJECT IDENTIFIER,\n                 context\n                   \
    \ OBJECT IDENTIFIER,\n                 pdu\n                    PDUs\n       \
    \        }\n          For each SnmpMgmtCom value that represents a SNMPv2 management\n\
    \          communication, the following statements are true:\n          o    Its\
    \ dstParty component is called the destination and\n               identifies\
    \ the SNMPv2 party to which the communication is\n               directed.\n \
    \         RFC 1446        Security Protocols for SNMPv2       April 1993\n   \
    \       o    Its srcParty component is called the source and\n               identifies\
    \ the SNMPv2 party from which the communication\n               is originated.\n\
    \          o    Its context component identifies the SNMPv2 context\n        \
    \       containing the management information referenced by the\n            \
    \   communication.\n          o    Its pdu component has the form and significance\n\
    \               attributed to it in [12].\n          Recall from [1] that a SNMPv2\
    \ authenticated management\n          communication is represented by an ASN.1\
    \ value with the\n          following syntax:\n               SnmpAuthMsg ::=\
    \ [1] IMPLICIT SEQUENCE {\n                 authInfo\n                    ANY,\
    \ - defined by authentication protocol\n                 authData\n          \
    \          SnmpMgmtCom\n               }\n          For each SnmpAuthMsg value\
    \ that represents a SNMPv2\n          authenticated management communication,\
    \ the following\n          statements are true:\n          o    Its authInfo component\
    \ is called the authentication\n               information and represents information\
    \ required in\n               support of the authentication protocol used by both\
    \ the\n               SNMPv2 party originating the message, and the SNMPv2\n \
    \              party receiving the message.  The detailed significance\n     \
    \          of the authentication information is specific to the\n            \
    \   authentication protocol in use; it has no effect on the\n               application\
    \ semantics of the communication other than its\n               use by the authentication\
    \ protocol in determining whether\n               the communication is authentic\
    \ or not.\n          o    Its authData component is called the authentication\
    \ data\n          RFC 1446        Security Protocols for SNMPv2       April 1993\n\
    \               and represents a SNMPv2 management communication.\n          In\
    \ support of the Digest Authentication Protocol, an authInfo\n          component\
    \ is of type AuthInformation:\n               AuthInformation ::= [2] IMPLICIT\
    \ SEQUENCE {\n                 authDigest\n                    OCTET STRING,\n\
    \                 authDstTimestamp\n                    UInteger32,\n        \
    \         authSrcTimestamp\n                    UInteger32\n               }\n\
    \          For each AuthInformation value that represents authentication\n   \
    \       information, the following statements are true:\n          o    Its authDigest\
    \ component is called the authentication\n               digest and represents\
    \ the digest computed over an\n               appropriate portion of the message,\
    \ where the message is\n               temporarily prefixed with a secret value\
    \ for the purposes\n               of computing the digest.\n          o    Its\
    \ authSrcTimestamp component is called the\n               authentication timestamp\
    \ and represents the time of the\n               generation of the message according\
    \ to the partyAuthClock\n               of the SNMPv2 party that originated it.\
    \  Note that the\n               granularity of the authentication timestamp is\
    \ 1 second.\n          o    Its authDstTimestamp component is called the\n   \
    \            authentication timestamp and represents the time of the\n       \
    \        generation of the message according to the partyAuthClock\n         \
    \      of the SNMPv2 party that is to receive it.  Note that the\n           \
    \    granularity of the authentication timestamp is 1 second.\n          3.1.\
    \  Generating a Message\n          This section describes the behavior of a SNMPv2\
    \ entity when it\n          acts as a SNMPv2 party for which the authentication\
    \ protocol\n          is administratively specified as the Digest Authentication\n\
    \          Protocol.  Insofar as the behavior of a SNMPv2 entity when\n      \
    \    transmitting protocol messages is defined generically in [1],\n         \
    \ only those aspects of that behavior that are specific to the\n          Digest\
    \ Authentication Protocol are described below.  In\n          RFC 1446       \
    \ Security Protocols for SNMPv2       April 1993\n          particular, this section\
    \ describes the encapsulation of a\n          SNMPv2 management communication\
    \ into a SNMPv2 authenticated\n          management communication.\n         \
    \ According to Section 3.1 of [1], a SnmpAuthMsg value is\n          constructed\
    \ during Step 3 of generic processing.  In\n          particular, it states the\
    \ authInfo component is constructed\n          according to the authentication\
    \ protocol identified for the\n          SNMPv2 party originating the message.\
    \  When the relevant\n          authentication protocol is the Digest Authentication\
    \ Protocol,\n          the procedure performed by a SNMPv2 entity whenever a\n\
    \          management communication is to be transmitted by a SNMPv2\n       \
    \   party is as follows.\n          (1)  The local database is consulted to determine\
    \ the\n               authentication clock and private authentication key\n  \
    \             (extracted, for example, according to the conventions\n        \
    \       defined in Section 1.5.1) of the SNMPv2 party originating\n          \
    \     the message.  The local database is also consulted to\n               determine\
    \ the authentication clock of the receiving\n               SNMPv2 party.\n  \
    \        (2)  The authSrcTimestamp component is set to the retrieved\n       \
    \        authentication clock value of the message's source.  The\n          \
    \     authDstTimestamp component is set to the retrieved\n               authentication\
    \ clock value of the message's intended\n               recipient.\n         \
    \ (3)  The authentication digest is temporarily set to the\n               private\
    \ authentication key of the SNMPv2 party\n               originating the message.\
    \  The SnmpAuthMsg value is\n               serialized according to the conventions\
    \ of [13] and [12].\n               A digest is computed over the octet sequence\
    \ representing\n               that serialized value using, for example, the algorithm\n\
    \               specified in Section 1.5.1.  The authDigest component is\n   \
    \            set to the computed digest value.\n          As set forth in [1],\
    \ the SnmpAuthMsg value is then\n          encapsulated according to the appropriate\
    \ privacy protocol\n          into a SnmpPrivMsg value.  This latter value is\
    \ then\n          serialized and transmitted to the receiving SNMPv2 party.\n\
    \          RFC 1446        Security Protocols for SNMPv2       April 1993\n  \
    \        3.2.  Receiving a Message\n          This section describes the behavior\
    \ of a SNMPv2 entity upon\n          receipt of a protocol message from a SNMPv2\
    \ party for which\n          the authentication protocol is administratively specified\
    \ as\n          the Digest Authentication Protocol.  Insofar as the behavior\n\
    \          of a SNMPv2 entity when receiving protocol messages is defined\n  \
    \        generically in [1], only those aspects of that behavior that\n      \
    \    are specific to the Digest Authentication Protocol are\n          described\
    \ below.\n          According to Section 3.2 of [1], a SnmpAuthMsg value is\n\
    \          evaluated during Step 9 of generic processing.  In particular,\n  \
    \        it states the SnmpAuthMsg value is evaluated according to the\n     \
    \     authentication protocol identified for the SNMPv2 party that\n         \
    \ originated the message.  When the relevant authentication\n          protocol\
    \ is the Digest Authentication Protocol, the procedure\n          performed by\
    \ a SNMPv2 entity whenever a management\n          communication is received by\
    \ a SNMPv2 party is as follows.\n          (1)  If the ASN.1 type of the authInfo\
    \ component is not\n               AuthInformation, the message is evaluated as\
    \ unauthentic,\n               and the snmpStatsBadAuths counter [14] is incremented.\n\
    \               Otherwise, the authSrcTimestamp, authDstTimestamp, and\n     \
    \          authDigest components are extracted from the SnmpAuthMsg\n        \
    \       value.\n          (2)  The local database is consulted to determine the\n\
    \               authentication clock, private authentication key\n           \
    \    (extracted, for example, according to the conventions\n               defined\
    \ in Section 1.5.1), and lifetime of the SNMPv2\n               party that originated\
    \ the message.\n          (3)  If the authSrcTimestamp component plus the lifetime\
    \ is\n               less than the authentication clock, the message is\n    \
    \           evaluated as unauthentic, and the snmpStatsNotInLifetimes\n      \
    \         counter [14] is incremented.\n          (4)  The authDigest component\
    \ is extracted and temporarily\n               recorded.\n          (5)  A new\
    \ SnmpAuthMsg value is constructed such that its\n               authDigest component\
    \ is set to the private authentication\n               key and its other components\
    \ are set to the value of the\n               corresponding components in the\
    \ received SnmpAuthMsg\n          RFC 1446        Security Protocols for SNMPv2\
    \       April 1993\n               value.  This new SnmpAuthMsg value is serialized\n\
    \               according to the conventions of [13] and [12].  A digest\n   \
    \            is computed over the octet sequence representing that\n         \
    \      serialized value using, for example, the algorithm\n               specified\
    \ in Section 1.5.1.\n                                            NOTE\n      \
    \              Because serialization rules are unambiguous but may\n         \
    \           not be unique, great care must be taken in\n                    reconstructing\
    \ the serialized value prior to\n                    computing the digest.  Implementations\
    \ may find it\n                    useful to keep a copy of the original serialized\n\
    \                    value and then simply modify the octets which\n         \
    \           directly correspond to the placement of the\n                    authDigest\
    \ component, rather than re-applying the\n                    serialization algorithm\
    \ to the new SnmpAuthMsg\n                    value.\n          (6)  If the computed\
    \ digest value is not equal to the digest\n               value temporarily recorded\
    \ in step 4 above, the message\n               is evaluated as unauthentic, and\
    \ the\n               snmpStatsWrongDigestValues counter [14] is incremented.\n\
    \          (7)  The message is evaluated as authentic.\n          (8)  The local\
    \ database is consulted for access privileges\n               permitted by the\
    \ local access policy to the originating\n               SNMPv2 party with respect\
    \ to the receiving SNMPv2 party.\n               If any level of access is permitted,\
    \ then:\n                 the authentication clock value locally recorded for\
    \ the\n                 originating SNMPv2 party is advanced to the\n        \
    \         authSrcTimestamp value if this latter exceeds the\n                \
    \ recorded value; and,\n                 the authentication clock value locally\
    \ recorded for the\n                 receiving SNMPv2 party is advanced to the\n\
    \                 authDstTimestamp value if this latter exceeds the\n        \
    \         recorded value.\n              (Note that this step is conceptually\
    \ independent from\n              Steps 15-17 of Section 3.2 in [1]).\n      \
    \    If the SnmpAuthMsg value is evaluated as unauthentic, an\n          authentication\
    \ failure is noted and the received message is\n          RFC 1446        Security\
    \ Protocols for SNMPv2       April 1993\n          discarded without further processing.\
    \  Otherwise, processing\n          of the received message continues as specified\
    \ in [1].\n          RFC 1446        Security Protocols for SNMPv2       April\
    \ 1993\n          4.  Symmetric Privacy Protocol\n          This section describes\
    \ the Symmetric Privacy Protocol.  It\n          provides for protection from\
    \ disclosure of a received message.\n          An appropriate portion of the message\
    \ is encrypted according\n          to a secret key known only to the originator\
    \ and recipient of\n          the message.\n          This protocol assumes the\
    \ underlying mechanism is a symmetric\n          encryption algorithm.  In addition,\
    \ the message to be\n          encrypted must be protected according to the conventions\
    \ of\n          the Digest Authentication Protocol.\n          Recall from [1]\
    \ that a SNMPv2 private management communication\n          is represented by\
    \ an ASN.1 value with the following syntax:\n               SnmpPrivMsg ::= [1]\
    \ IMPLICIT SEQUENCE {\n                 privDst\n                    OBJECT IDENTIFIER,\n\
    \                 privData\n                    [1] IMPLICIT OCTET STRING\n  \
    \             }\n          For each SnmpPrivMsg value that represents a SNMPv2\
    \ private\n          management communication, the following statements are true:\n\
    \          o    Its privDst component is called the privacy destination\n    \
    \           and identifies the SNMPv2 party to which the\n               communication\
    \ is directed.\n          o    Its privData component is called the privacy data\
    \ and\n               represents the (possibly encrypted) serialization\n    \
    \           (according to the conventions of [13] and [12]) of a\n           \
    \    SNMPv2 authenticated management communication.\n          4.1.  Generating\
    \ a Message\n          This section describes the behavior of a SNMPv2 entity\
    \ when it\n          communicates with a SNMPv2 party for which the privacy\n\
    \          protocol is administratively specified as the Symmetric\n         \
    \ Privacy Protocol.  Insofar as the behavior of a SNMPv2 entity\n          when\
    \ transmitting a protocol message is defined generically in\n          [1], only\
    \ those aspects of that behavior that are specific to\n          the Symmetric\
    \ Privacy Protocol are described below.  In\n          RFC 1446        Security\
    \ Protocols for SNMPv2       April 1993\n          particular, this section describes\
    \ the encapsulation of a\n          SNMPv2 authenticated management communication\
    \ into a SNMPv2\n          private management communication.\n          According\
    \ to Section 3.1 of [1], a SnmpPrivMsg value is\n          constructed during\
    \ Step 5 of generic processing.  In\n          particular, it states the privData\
    \ component is constructed\n          according to the privacy protocol identified\
    \ for the SNMPv2\n          party receiving the message.  When the relevant privacy\n\
    \          protocol is the Symmetric Privacy Protocol, the procedure\n       \
    \   performed by a SNMPv2 entity whenever a management\n          communication\
    \ is to be transmitted by a SNMPv2 party is as\n          follows.\n         \
    \ (1)  If the SnmpAuthMsg value is not authenticated according\n             \
    \  to the conventions of the Digest Authentication Protocol,\n               the\
    \ generation of the private management communication\n               fails according\
    \ to a local procedure, without further\n               processing.\n        \
    \  (2)  The local database is consulted to determine the private\n           \
    \    privacy key of the SNMPv2 party receiving the message\n               (represented,\
    \ for example, according to the conventions\n               defined in Section\
    \ 1.5.2).\n          (3)  The SnmpAuthMsg value is serialized according to the\n\
    \               conventions of [13] and [12].\n          (4)  The octet sequence\
    \ representing the serialized\n               SnmpAuthMsg value is encrypted using,\
    \ for example, the\n               algorithm specified in Section 1.5.2 and the\
    \ extracted\n               private privacy key.\n          (5)  The privData\
    \ component is set to the encrypted value.\n          As set forth in [1], the\
    \ SnmpPrivMsg value is then serialized\n          and transmitted to the receiving\
    \ SNMPv2 party.\n          4.2.  Receiving a Message\n          This section describes\
    \ the behavior of a SNMPv2 entity when it\n          acts as a SNMPv2 party for\
    \ which the privacy protocol is\n          administratively specified as the Symmetric\
    \ Privacy Protocol.\n          Insofar as the behavior of a SNMPv2 entity when\
    \ receiving a\n          RFC 1446        Security Protocols for SNMPv2       April\
    \ 1993\n          protocol message is defined generically in [1], only those\n\
    \          aspects of that behavior that are specific to the Symmetric\n     \
    \     Privacy Protocol are described below.\n          According to Section 3.2\
    \ of [1], the privData component of a\n          received SnmpPrivMsg value is\
    \ evaluated during Step 4 of\n          generic processing.  In particular, it\
    \ states the privData\n          component is evaluated according to the privacy\
    \ protocol\n          identified for the SNMPv2 party receiving the message. \
    \ When\n          the relevant privacy protocol is the Symmetric Privacy\n   \
    \       Protocol, the procedure performed by a SNMPv2 entity whenever\n      \
    \    a management communication is received by a SNMPv2 party is as\n        \
    \  follows.\n          (1)  The local database is consulted to determine the private\n\
    \               privacy key of the SNMPv2 party receiving the message\n      \
    \         (represented, for example, according to the conventions\n          \
    \     defined in Section 1.5.2).\n          (2)  The contents octets of the privData\
    \ component are\n               decrypted using, for example, the algorithm specified\
    \ in\n               Section 1.5.2 and the extracted private privacy key.\n  \
    \        Processing of the received message continues as specified in\n      \
    \    [1].\n          RFC 1446        Security Protocols for SNMPv2       April\
    \ 1993\n          5.  Clock and Secret Distribution\n          The protocols described\
    \ in Sections 3 and 4 assume the\n          existence of loosely synchronized\
    \ clocks and shared secret\n          values.  Three requirements constrain the\
    \ strategy by which\n          clock values and secrets are distributed.\n   \
    \       o    If the value of an authentication clock is decreased, the\n     \
    \          private authentication key must be changed concurrently.\n        \
    \       When the value of an authentication clock is decreased,\n            \
    \   messages that have been sent with a timestamp value\n               between\
    \ the value of the authentication clock and its new\n               value may\
    \ be replayed.  Changing the private\n               authentication key obviates\
    \ this threat.\n          o    The private authentication key and private privacy\
    \ key\n               must be known only to the parties requiring knowledge of\n\
    \               them.\n               Protecting the secrets from disclosure is\
    \ critical to the\n               security of the protocols.  Knowledge of the\
    \ secrets must\n               be as restricted as possible within an implementation.\n\
    \               In particular, although the secrets may be known to one\n    \
    \           or more persons during the initial configuration of a\n          \
    \     device, the secrets should be changed immediately after\n              \
    \ configuration such that their actual value is known only\n               to\
    \ the software.  A management station has the additional\n               responsibility\
    \ of recovering the state of all parties\n               whenever it boots, and\
    \ it may address this responsibility\n               by recording the secrets\
    \ on a long-term storage device.\n               Access to information on this\
    \ device must be as\n               restricted as is practically possible.\n \
    \         o    There must exist at least one SNMPv2 entity that assumes\n    \
    \           the role of a responsible management station.\n               This\
    \ management station is responsible for ensuring that\n               all authentication\
    \ clocks are synchronized and for\n               changing the secret values when\
    \ necessary.  Although more\n               than one management station may share\
    \ this\n               responsibility, their coordination is essential to the\n\
    \               secure management of the network.  The mechanism by which\n  \
    \             multiple management stations ensure that no more than one\n    \
    \           of them attempts to synchronize the clocks or update the\n       \
    \   RFC 1446        Security Protocols for SNMPv2       April 1993\n         \
    \      secrets at any one time is a local implementation issue.\n            \
    \   A responsible management station may either support clock\n              \
    \ synchronization and secret distribution as separate\n               functions,\
    \ or combine them into a single functional unit.\n          The first section\
    \ below specifies the procedures by which a\n          SNMPv2 entity is initially\
    \ configured.  The next two sections\n          describe one strategy for distributing\
    \ clock values and one\n          for determining a synchronized clock value among\
    \ SNMPv2\n          parties supporting the Digest Authentication Protocol.  For\n\
    \          SNMPv2 parties supporting the Symmetric Privacy Protocol, the\n   \
    \       next section describes a strategy for distributing secret\n          values.\
    \  The last section specifies the procedures by which a\n          SNMPv2 entity\
    \ recovers from a \"crash.\"\n          5.1.  Initial Configuration\n        \
    \  This section describes the initial configuration of a SNMPv2\n          entity\
    \ that supports the Digest Authentication Protocol or\n          both the Digest\
    \ Authentication Protocol and the Symmetric\n          Privacy Protocol.\n   \
    \       When a network device is first installed, its initial, secure\n      \
    \    configuration must be done manually, i.e., a person must\n          physically\
    \ visit the device and enter the initial secret\n          values for at least\
    \ its first secure SNMPv2 party.  This\n          requirement suggests that the\
    \ person will have knowledge of\n          the initial secret values.\n      \
    \    In general, the security of a system is enhanced as the number\n        \
    \  of entities that know a secret is reduced.  Requiring a person\n          to\
    \ physically visit a device every time a SNMPv2 party is\n          configured\
    \ not only exposes the secrets unnecessarily but is\n          administratively\
    \ prohibitive.  In particular, when MD5 is\n          used, the initial authentication\
    \ secret is 128 bits long and\n          when DES is used an additional 128 bits\
    \ are needed - 64 bits\n          each for the key and initialization vector.\
    \  Clearly, these\n          values will need to be recorded on a medium in order\
    \ to be\n          transported between a responsible management station and a\n\
    \          managed agent.  The recommended procedure is to configure a\n     \
    \     small set of initial SNMPv2 parties for each SNMPv2 entity,\n          one\
    \ pair of which may be used initially to configure all other\n          SNMPv2\
    \ parties.\n          RFC 1446        Security Protocols for SNMPv2       April\
    \ 1993\n          In fact, there is a minimal, useful set of SNMPv2 parties that\n\
    \          could be configured between each responsible management\n         \
    \ station and managed agent.  This minimal set includes one of\n          each\
    \ of the following for both the responsible management\n          station and\
    \ the managed agent:\n          o    a SNMPv2 party for which the authentication\
    \ protocol and\n               privacy protocol are the values noAuth and noPriv,\n\
    \               respectively,\n          o    a SNMPv2 party for which the authentication\
    \ protocol\n               identifies the mechanism defined in Section 1.5.1 and\
    \ its\n               privacy protocol is the value noPriv, and\n          o \
    \   a SNMPv2 party for which the authentication protocol and\n               privacy\
    \ protocol identify the mechanisms defined in\n               Section 1.5.1 and\
    \ Section 1.5.2, respectively.\n          The last of these SNMPv2 parties in\
    \ both the responsible\n          management station and the managed agent could\
    \ be used to\n          create all other SNMPv2 parties.\n          Configuring\
    \ one pair of SNMPv2 parties to be used to configure\n          all other parties\
    \ has the advantage of exposing only one pair\n          of secrets - the secrets\
    \ used to configure the minimal, useful\n          set identified above.  To limit\
    \ this exposure, the responsible\n          management station should change these\
    \ values as its first\n          operation upon completion of the initial configuration.\
    \  In\n          this way, secrets are known only to the peers requiring\n   \
    \       knowledge of them in order to communicate.\n          The Management Information\
    \ Base (MIB) document [4] supporting\n          these security protocols specifies\
    \ 6 initial party identities\n          and initial values, which, by convention,\
    \ are assigned to the\n          parties and their associated parameters.\n  \
    \        These 6 initial parties are required to exist as part of the\n      \
    \    configuration of implementations when first installed, with\n          the\
    \ exception that implementations not providing support for a\n          privacy\
    \ protocol only need the 4 initial parties for which the\n          privacy protocol\
    \ is noPriv.  When installing a managed agent,\n          these parties need to\
    \ be configured with their initial\n          secrets, etc., both in the responsible\
    \ management station and\n          in the new agent.\n          RFC 1446    \
    \    Security Protocols for SNMPv2       April 1993\n          If the responsible\
    \ management station is configured first, it\n          can be used to generate\
    \ the initial secrets and provide them\n          to a person, on a suitable medium,\
    \ for distribution to the\n          managed agent.  The following sequence of\
    \ steps describes the\n          initial configuration of a managed agent and\
    \ its responsible\n          management station.\n          (1)  Determine the\
    \ initial values for each of the attributes\n               of the SNMPv2 party\
    \ to be configured.  Some of these\n               values may be computed by the\
    \ responsible management\n               station, some may be specified in the\
    \ MIB document, and\n               some may be administratively determined.\n\
    \          (2)  Configure the parties in the responsible management\n        \
    \       station, according to the set of initial values.  If the\n           \
    \    management station is computing some initial values to be\n             \
    \  entered into the agent, an appropriate medium must be\n               present\
    \ to record the values.\n          (3)  Configure the parties in the managed agent,\
    \ according to\n               the set of initial values.\n          (4)  The\
    \ responsible management station must synchronize the\n               authentication\
    \ clock values for each party it shares with\n               each managed agent.\
    \  Section 5.3 specifies one strategy\n               by which this could be accomplished.\n\
    \          (5)  The responsible management station should change the\n       \
    \        secret values manually configured to ensure the actual\n            \
    \   values are known only to the peers requiring knowledge of\n              \
    \ them in order to communicate.  To do this, the management\n               station\
    \ generates new secrets for each party to be\n               reconfigured and\
    \ distributes the updates using any\n               strategy which protects the\
    \ new values from disclosure;\n               use of a SNMPv2 set operation acting\
    \ on the managed\n               objects defined in [4] is such a strategy.  Upon\n\
    \               receiving positive acknowledgement that the new values\n     \
    \          have been distributed, the management station should\n            \
    \   update its local database with the new values.\n          If the managed agent\
    \ does not support a protocol that protects\n          messages from disclosure,\
    \ e.g., the Symmetric Privacy Protocol\n          (see section 5.4), then the\
    \ distribution of new secrets, after\n          the compromise of existing secrets,\
    \ is not possible.  In this\n          case, the new secrets can only be distributed\
    \ by a physical\n          RFC 1446        Security Protocols for SNMPv2     \
    \  April 1993\n          visit to the device.\n          If there are other SNMPv2\
    \ protocol entities requiring\n          knowledge of the secrets, the responsible\
    \ management station\n          must distribute the information upon completion\
    \ of the initial\n          configuration.  The considerations, mentioned above,\n\
    \          concerning the protection of secrets from disclosure, also\n      \
    \    apply in this case.\n          5.2.  Clock Distribution\n          A responsible\
    \ management station must ensure that the\n          authentication clock value\
    \ for each SNMPv2 party for which it\n          is responsible\n          o  \
    \  is loosely synchronized among all the local databases in\n               which\
    \ it appears,\n          o    is reset, as indicated below, upon reaching its\
    \ maximal\n               value, and\n          o    is non-decreasing, except\
    \ as indicated below.\n          The skew among the clock values must be accounted\
    \ for in the\n          lifetime value, in addition to the expected communication\n\
    \          delivery delay.\n          A skewed authentication clock may be detected\
    \ by a number of\n          strategies, including knowledge of the accuracy of\
    \ the system\n          clock, unauthenticated queries of the party database,\
    \ and\n          recognition of authentication failures originated by the\n  \
    \        party.\n          Whenever clock skew is detected, and whenever the SNMPv2\n\
    \          entities at both the responsible management station and the\n     \
    \     relevant managed agent support an appropriate privacy protocol\n       \
    \   (e.g., the Symmetric Privacy Protocol), a straightforward\n          strategy\
    \ for the correction of clock skew is simultaneous\n          alteration of authentication\
    \ clock and private key for the\n          relevant SNMPv2 party.  If the request\
    \ to alter the key and\n          clock for a particular party originates from\
    \ that same party,\n          then, prior to transmitting that request, the local\
    \ notion of\n          the authentication clock is artificially advanced to assure\n\
    \          acceptance of the request as authentic.\n          RFC 1446       \
    \ Security Protocols for SNMPv2       April 1993\n          More generally, however,\
    \ since an authentication clock value\n          need not be protected from disclosure,\
    \ it is not necessary\n          that a managed agent support a privacy protocol\
    \ in order for a\n          responsible management station to correct skewed clock\
    \ values.\n          The procedure for correcting clock skew in the general case\
    \ is\n          presented in Section 5.3.\n          In addition to correcting\
    \ skewed notions of authentication\n          clocks, every SNMPv2 entity must\
    \ react correctly as an\n          authentication clock approaches its maximal\
    \ value.  If the\n          authentication clock for a particular SNMPv2 party\
    \ ever\n          reaches the maximal time value, the clock must halt at that\n\
    \          value.  (The value of interest may be the maximum less\n          lifetime.\
    \  When authenticating a message, its authentication\n          timestamp is added\
    \ to lifetime and compared to the\n          authentication clock.  A SNMPv2 entity\
    \ must guarantee that the\n          sum is never greater than the maximal time\
    \ value.) In this\n          state, the only authenticated request a management\
    \ station\n          should generate for this party is one that alters the value\
    \ of\n          at least its authentication clock and private authentication\n\
    \          key.  In order to reset these values, the responsible\n          management\
    \ station may set the authentication timestamp in the\n          message to the\
    \ maximal time value.\n          The value of the authentication clock for a particular\
    \ SNMPv2\n          party must never be altered such that its new value is less\n\
    \          than its old value, unless its private authentication key is\n    \
    \      also altered at the same time.\n          5.3.  Clock Synchronization\n\
    \          Unless the secrets are changed at the same time, the correct\n    \
    \      way to synchronize clocks is to advance the slower clock to be\n      \
    \    equal to the faster clock.  Suppose that party agentParty is\n          realized\
    \ by the SNMPv2 entity in a managed agent; suppose that\n          party mgrParty\
    \ is realized by the SNMPv2 entity in the\n          corresponding responsible\
    \ management station.  For any pair of\n          parties, there are four possible\
    \ conditions of the\n          authentication clocks that could require correction:\n\
    \          (1)  The management station's notion of the value of the\n        \
    \       authentication clock for agentParty exceeds the agent's\n            \
    \   notion.\n          RFC 1446        Security Protocols for SNMPv2       April\
    \ 1993\n          (2)  The management station's notion of the value of the\n \
    \              authentication clock for mgrParty exceeds the agent's\n       \
    \        notion.\n          (3)  The agent's notion of the value of the authentication\n\
    \               clock for agentParty exceeds the management station's\n      \
    \         notion.\n          (4)  The agent's notion of the value of the authentication\n\
    \               clock for mgrParty exceeds the management station's\n        \
    \       notion.\n          The selective clock acceleration mechanism intrinsic\
    \ to the\n          protocol corrects conditions 1, 2 and 3 as part of the normal\n\
    \          processing of an authentic message.  Therefore, the clock\n       \
    \   adjustment procedure below does not provide for any\n          adjustments\
    \ in those cases.  Rather, the following sequence of\n          steps specifies\
    \ how the clocks may be synchronized when\n          condition 4 is manifest.\n\
    \          (1)  The responsible management station saves its existing\n      \
    \         notion of the authentication clock for the party\n               mgrParty.\n\
    \          (2)  The responsible management station retrieves the\n           \
    \    authentication clock value for mgrParty from the agent.\n               This\
    \ retrieval must be an unauthenticated request, since\n               the management\
    \ station does not know if the clocks are\n               synchronized.  If the\
    \ request fails, the clocks cannot be\n               synchronized, and the clock\
    \ adjustment procedure is\n               aborted without further processing.\n\
    \          (3)  If the notion of the authentication clock for mgrParty\n     \
    \          just retrieved from the agent exceeds the management\n            \
    \   station's notion, then condition 4 is manifest, and the\n               responsible\
    \ management station advances its notion of the\n               authentication\
    \ clock for mgrParty to match the agent's\n               notion.\n          (4)\
    \  The responsible management station retrieves the\n               authentication\
    \ clock value for mgrParty from the agent.\n               This retrieval must\
    \ be an authenticated request, in order\n               that the management station\
    \ may verify that the clock\n               value is properly synchronized.  If\
    \ this authenticated\n               query fails, then the management station\
    \ restores its\n          RFC 1446        Security Protocols for SNMPv2      \
    \ April 1993\n               previously saved notion of the clock value, and the\
    \ clock\n               adjustment procedure is aborted without further\n    \
    \           processing.  Otherwise, clock synchronization has been\n         \
    \      successfully realized.\n          Administrative advancement of a clock\
    \ as described above does\n          not introduce any new vulnerabilities, since\
    \ the value of the\n          clock is intended to increase with the passage of\
    \ time.  A\n          potential operational problem is the rejection of authentic\n\
    \          management operations that were authenticated using a previous\n  \
    \        value of the relevant party clock.  This possibility may be\n       \
    \   avoided if a management station suppresses generation of\n          management\
    \ traffic between relevant parties while this clock\n          adjustment procedure\
    \ is in progress.\n          5.4.  Secret Distribution\n          This section\
    \ describes one strategy by which a SNMPv2 entity\n          that supports both\
    \ the Digest Authentication Protocol and the\n          Symmetric Privacy Protocol\
    \ can change the secrets for a\n          particular SNMPv2 party.\n         \
    \ The frequency with which the secrets of a SNMPv2 party should\n          be\
    \ changed is a local administrative issue.  However, the more\n          frequently\
    \ a secret is used, the more frequently it should be\n          changed.  At a\
    \ minimum, the secrets must be changed whenever\n          the associated authentication\
    \ clock approaches its maximal\n          value (see Section 6).  Note that, owing\
    \ to both\n          administrative and automatic advances of the authentication\n\
    \          clock described in this memo, the authentication clock for a\n    \
    \      SNMPv2 party may well approach its maximal value sooner than\n        \
    \  might otherwise be expected.\n          The following sequence of steps specifies\
    \ how a responsible\n          management station alters a secret value (i.e.,\
    \ the private\n          authentication key or the private privacy key) for a\n\
    \          particular SNMPv2 party.  There are two cases.\n          First, setting\
    \ the initial secret for a new party:\n          (1)  The responsible management\
    \ station generates a new secret\n               value.\n          RFC 1446  \
    \      Security Protocols for SNMPv2       April 1993\n          (2)  The responsible\
    \ management station encapsulates a SNMPv2\n               setRequest in a SNMPv2\
    \ private management communication\n               with at least the following\
    \ properties.\n                    Its source supports the Digest Authentication\n\
    \                    Protocol and the Symmetric Privacy Protocol.\n          \
    \          Its destination supports the Symmetric Privacy\n                  \
    \  Protocol and the Digest Authentication Protocol.\n          (3)  The SNMPv2\
    \ private management communication is\n               transmitted to its destination.\n\
    \          (4)  Upon receiving the request, the recipient processes the\n    \
    \           message according to [12] and [1].\n          (5)  The recipient encapsulates\
    \ a SNMPv2 response in a SNMPv2\n               private management communication\
    \ with at least the\n               following properties.\n                  \
    \  Its source supports the Digest Authentication\n                    Protocol\
    \ and the Symmetric Privacy Protocol.\n                    Its destination supports\
    \ the Symmetric Privacy\n                    Protocol and the Digest Authentication\
    \ Protocol.\n          (6)  The SNMPv2 private management communication is\n \
    \              transmitted to its destination.\n          (7)  Upon receiving\
    \ the response, the responsible management\n               station updates its\
    \ local database with the new value.\n          Second, modifying the current\
    \ secret of an existing party:\n          (1)  The responsible management station\
    \ generates a new secret\n               value.\n          (2)  The responsible\
    \ management station encapsulates a SNMPv2\n               setRequest in a SNMPv2\
    \ management communication with at\n               least the following properties.\n\
    \                    Its source and destination supports the Digest\n        \
    \            Authentication Protocol.\n          RFC 1446        Security Protocols\
    \ for SNMPv2       April 1993\n          (3)  The SNMPv2 private management communication\
    \ is\n               transmitted to its destination.\n          (4)  Upon receiving\
    \ the request, the recipient processes the\n               message according to\
    \ [12] and [1].\n          (5)  The recipient encapsulates a SNMPv2 response in\
    \ a SNMPv2\n               management communication with at least the following\n\
    \               properties.\n                    Its source and destination supports\
    \ the Digest\n                    Authentication Protocol.\n          (6)  The\
    \ SNMPv2 management communication is transmitted to its\n               destination.\n\
    \          (7)  Upon receiving the response, the responsible management\n    \
    \           station updates its local database with the new value.\n         \
    \ If the responsible management station does not receive a\n          response\
    \ to its request, there are two possible causes.\n          o    The request may\
    \ not have been delivered to the\n               destination.\n          o   \
    \ The response may not have been delivered to the\n               originator of\
    \ the request.\n          In order to distinguish the two possible error conditions,\
    \ a\n          responsible management station could check the destination to\n\
    \          see if the change has occurred.  Unfortunately, since the\n       \
    \   secret values are unreadable, this is not directly possible.\n          The\
    \ recommended strategy for verifying key changes is to set\n          the public\
    \ value corresponding to the secret being changed to\n          a recognizable,\
    \ novel value: that is, alter the public\n          authentication key value for\
    \ the relevant party when changing\n          its private authentication key,\
    \ or alter its public privacy\n          key value when changing its private privacy\
    \ key.  In this way,\n          the responsible management station may retrieve\
    \ the public\n          value when a response is not received, and verify whether\
    \ or\n          not the change has taken place.  (This strategy is available\n\
    \          since the public values are not used by the protocols defined\n   \
    \       in this memo.  If this strategy is employed, then the public\n       \
    \   values are significant in this context.  Of course, protocols\n          RFC\
    \ 1446        Security Protocols for SNMPv2       April 1993\n          using\
    \ the public values may make use of this strategy\n          directly.)\n    \
    \      One other scenario worthy of mention is using a SNMPv2 party\n        \
    \  to change its own secrets.  In this case, the destination will\n          change\
    \ its local database prior to generating a response.\n          Thus, the response\
    \ will be constructed according to the new\n          value.  However, the responsible\
    \ management station will not\n          update its local database until after\
    \ the response is\n          received.  This suggests the responsible management\
    \ station\n          may receive a response which will be evaluated as unauthentic,\n\
    \          unless the correct secret is used.  The responsible management\n  \
    \        station may either account for this scenario as a special\n         \
    \ case, or use an alteration of the relevant public values (as\n          described\
    \ above) to verify the key change.\n          Note, during the period of time\
    \ after the request has been\n          sent and before the response is received,\
    \ the management\n          station must keep track of both the old and new secret\
    \ values.\n          Since the delay may be the result of a network failure, the\n\
    \          management station must be prepared to retain both values for\n   \
    \       an extended period of time, including across reboots.\n          5.5.\
    \  Crash Recovery\n          This section describes the requirements for SNMPv2\
    \ protocol\n          entities in connection with recovery from system crashes\
    \ or\n          other service interruptions.\n          For each SNMPv2 party\
    \ in the local database for a particular\n          SNMPv2 entity, its identity,\
    \ authentication clock, private\n          authentication key, and private privacy\
    \ key must enjoy non-\n          volatile, incorruptible representations.  If\
    \ possible,\n          lifetime should also enjoy a non-volatile, incorruptible\n\
    \          representation.  If said SNMPv2 entity supports other security\n  \
    \        protocols or algorithms in addition to the two defined in this\n    \
    \      memo, then the authentication protocol and the privacy\n          protocol\
    \ for each party also require non-volatile,\n          incorruptible representation.\n\
    \          The authentication clock of a SNMPv2 party is a critical\n        \
    \  component of the overall security of the protocols.  The\n          inclusion\
    \ of a reliable representation of a clock in a SNMPv2\n          entity is required\
    \ for overall security.  A reliable clock\n          RFC 1446        Security\
    \ Protocols for SNMPv2       April 1993\n          representation ensures that\
    \ a clock's value is monotonically\n          increasing, even across a power\
    \ loss or other system failure\n          of the local SNMPv2 entity.  One example\
    \ of a reliable clock\n          representation is that provided by battery-powered\
    \ clock-\n          calendar devices incorporated into some contemporary systems.\n\
    \          Another example is storing and updating a clock value in non-\n   \
    \       volatile storage at a frequency of once per U (e.g., 24)\n          hours,\
    \ and re-initialising that clock value on every reboot as\n          the stored\
    \ value plus U+1 hours.  It is assumed that\n          management stations always\
    \ support reliable clock\n          representations, where clock adjustment by\
    \ a human operator\n          during crash recovery may contribute to that reliability.\n\
    \          If a managed agent crashes and does not reboot in time for its\n  \
    \        responsible management station to prevent its authentication\n      \
    \    clock from reaching its maximal value, upon reboot the clock\n          must\
    \ be halted at its maximal value.  The procedures specified\n          in Section\
    \ 5.3 would then apply.\n          Upon recovery, those attributes of each SNMPv2\
    \ party that do\n          not enjoy non-volatile or reliable representation are\n\
    \          initialized as follows.\n          o    If the private authentication\
    \ key is not the OCTET STRING\n               of zero length, the authentication\
    \ protocol is set to\n               identify use of the Digest Authentication\
    \ Protocol in\n               conjunction with the algorithm specified in Section\n\
    \               1.5.1.\n          o    If the lifetime is not retained, it should\
    \ be initialized\n               to zero.\n          o    If the private privacy\
    \ key is not the OCTET STRING of\n               zero length, the privacy protocol\
    \ is set to identify use\n               of the Symmetric Privacy Protocol in\
    \ conjunction with the\n               algorithm specified in Section 1.5.2.\n\
    \          Upon detecting that a managed agent has rebooted, a\n          responsible\
    \ management station must reset all other party\n          attributes, including\
    \ the lifetime if it was not retained.  In\n          order to reset the lifetime,\
    \ the responsible management\n          station should set the authentication\
    \ timestamp in the message\n          to the sum of the authentication clock and\
    \ desired lifetime.\n          This is an artificial advancement of the authentication\n\
    \          timestamp in order to guarantee the message will be authentic\n   \
    \       RFC 1446        Security Protocols for SNMPv2       April 1993\n     \
    \     when received by the recipient.\n          RFC 1446        Security Protocols\
    \ for SNMPv2       April 1993\n          6.  Security Considerations\n       \
    \   This section highlights security considerations relevant to\n          the\
    \ protocols and procedures defined in this memo.  Practices\n          that contribute\
    \ to secure, effective operation of the\n          mechanisms defined here are\
    \ described first.  Constraints on\n          implementation behavior that are\
    \ necessary to the security of\n          the system are presented next.  Finally,\
    \ an informal account\n          of the contribution of each mechanism of the\
    \ protocols to the\n          required goals is presented.\n          6.1.  Recommended\
    \ Practices\n          This section describes practices that contribute to the\n\
    \          secure, effective operation of the mechanisms defined in this\n   \
    \       memo.\n          o    A management station should discard SNMPv2 responses\
    \ for\n               which neither the request-id component nor the\n       \
    \        represented management information corresponds to any\n             \
    \  currently outstanding request.\n               Although it would be typical\
    \ for a management station to\n               do this as a matter of course, in\
    \ the context of these\n               security protocols it is significant owing\
    \ to the\n               possibility of message duplication (malicious or\n  \
    \             otherwise).\n          o    A management station should not interpret\
    \ an agent's lack\n               of response to an authenticated SNMPv2 management\n\
    \               communication as a conclusive indication of agent or\n       \
    \        network failure.\n               It is possible for authentication failure\
    \ traps to be\n               lost or suppressed as a result of authentication\
    \ clock\n               skew or inconsistent notions of shared secrets.  In order\n\
    \               either to facilitate administration of such SNMPv2\n         \
    \      parties or to provide for continued management in times\n             \
    \  of network stress, a management station implementation\n               may\
    \ provide for arbitrary, artificial advancement of the\n               timestamp\
    \ or selection of shared secrets on locally\n               generated messages.\n\
    \          RFC 1446        Security Protocols for SNMPv2       April 1993\n  \
    \        o    The lifetime value for a SNMPv2 party should be chosen\n       \
    \        (by the local administration) to be as small as possible,\n         \
    \      given the accuracy of clock devices available, relevant\n             \
    \  round-trip communications delays, and the frequency with\n               which\
    \ a responsible management station will be able to\n               verify all\
    \ clock values.\n               A large lifetime increases the vulnerability to\
    \ malicious\n               delays of SNMPv2 messages.  The implementation of\
    \ a\n               management station may accommodate changing network\n    \
    \           conditions during periods of network stress by\n               effectively\
    \ increasing the lifetimes of the source and\n               destination parties.\
    \  The management station accomplishes\n               this by artificially advancing\
    \ its notion of the source\n               party's clock on messages it sends,\
    \ and by artificially\n               increasing its notion of the source party`s\
    \ lifetime on\n               messages it receives.\n          o    When sending\
    \ state altering messages to a managed agent,\n               a management station\
    \ should delay sending successive\n               messages to the managed agent\
    \ until a positive\n               acknowledgement is received for the previous\
    \ message or\n               until the previous message expires.\n           \
    \    No message ordering is imposed by the SNMPv2.  Messages\n               may\
    \ be received in any order relative to their time of\n               generation\
    \ and each will be processed in the ordered\n               received.  Note that\
    \ when an authenticated message is\n               sent to a managed agent, it\
    \ will be valid for a period of\n               time that does not exceed lifetime\
    \ under normal\n               circumstances, and is subject to replay during\
    \ this\n               period.\n               Indeed, a management station must\
    \ cope with the loss and\n               re-ordering of messages resulting from\
    \ anomalies in the\n               network as a matter of course.\n          \
    \     However, a managed object, snmpSetSerialNo [14], is\n               specifically\
    \ defined for use with SNMPv2 set operations\n               in order to provide\
    \ a mechanism to ensure the processing\n               of SNMPv2 messages occurs\
    \ in a specific order.\n          o    The frequency with which the secrets of\
    \ a SNMPv2 party\n               should be changed is indirectly related to the\
    \ frequency\n               of their use.\n          RFC 1446        Security\
    \ Protocols for SNMPv2       April 1993\n               Protecting the secrets\
    \ from disclosure is critical to the\n               overall security of the protocols.\
    \  Frequent use of a\n               secret provides a continued source of data\
    \ that may be\n               useful to a cryptanalyst in exploiting known or\
    \ perceived\n               weaknesses in an algorithm.  Frequent changes to the\n\
    \               secret avoid this vulnerability.\n               Changing a secret\
    \ after each use is generally regarded as\n               the most secure practice,\
    \ but a significant amount of\n               overhead may be associated with\
    \ that approach.\n               Note, too, in a local environment the threat\
    \ of\n               disclosure may be insignificant, and as such the changing\n\
    \               of secrets may be less frequent.  However, when public\n     \
    \          data networks are the communication paths, more caution\n         \
    \      is prudent.\n          o    In order to foster the greatest degree of security,\
    \ a\n               management station implementation must support\n         \
    \      constrained, pairwise sharing of secrets among SNMPv2\n               entities\
    \ as its default mode of operation.\n               Owing to the use of symmetric\
    \ cryptography in the\n               protocols defined here, the secrets associated\
    \ with a\n               particular SNMPv2 party must be known to all other SNMPv2\n\
    \               parties with which that party may wish to communicate.\n     \
    \          As the number of locations at which secrets are known and\n       \
    \        used increases, the likelihood of their disclosure also\n           \
    \    increases, as does the potential impact of that\n               disclosure.\
    \  Moreover, if the set of SNMPv2 protocol\n               entities with knowledge\
    \ of a particular secret numbers\n               more than two, data origin cannot\
    \ be reliably\n               authenticated because it is impossible to determine\
    \ with\n               any assurance which entity of that set may be the\n   \
    \            originator of a particular SNMPv2 message.  Thus, the\n         \
    \      greatest degree of security is afforded by configurations\n           \
    \    in which the secrets for each SNMPv2 party are known to\n               at\
    \ most two protocol entities.\n          6.2.  Conformance\n          A SNMPv2\
    \ entity implementation that claims conformance to this\n          memo must satisfy\
    \ the following requirements:\n          RFC 1446        Security Protocols for\
    \ SNMPv2       April 1993\n          (1)  It must implement the noAuth and noPriv\
    \ protocols whose\n               object identifiers are defined in [4].\n   \
    \                 noAuth  This protocol signifies that messages\n            \
    \        generated by a party using it are not protected as\n                \
    \    to origin or integrity.  It is required to ensure\n                    that\
    \ a party's authentication clock is always\n                    accessible.\n\
    \                    noPriv  This protocol signifies that messages\n         \
    \           received by a party using it are not protected from\n            \
    \        disclosure.  It is required to ensure that a party's\n              \
    \      authentication clock is always accessible.\n          (2)  It must implement\
    \ the Digest Authentication Protocol in\n               conjunction with the algorithm\
    \ defined in Section 1.5.1.\n          (3)  It must include in its local database\
    \ at least one SNMPv2\n               party with the following parameters set\
    \ as follows:\n                    partyAuthProtocol is set to noAuth and\n  \
    \                  partyPrivProtocol is set to noPriv.\n               This party\
    \ must have a MIB view [1] specified that\n               includes at least the\
    \ authentication clock of all other\n               parties.  Alternatively, the\
    \ authentication clocks of the\n               other parties may be partitioned\
    \ among several similarly\n               configured parties according to a local\
    \ implementation\n               convention.\n          (4)  For each SNMPv2 party\
    \ about which it maintains\n               information in a local database, an\
    \ implementation must\n               satisfy the following requirements:\n  \
    \                  (a) It must not allow a party's parameters to be set\n    \
    \                to a value inconsistent with its expected syntax.\n         \
    \           In particular, Section 1.4 specifies constraints for\n           \
    \         the chosen mechanisms.\n                    (b) It must, to the maximal\
    \ extent possible,\n                    prohibit read-access to the private authentication\n\
    \                    key and private encryption key under all\n              \
    \      circumstances except as required to generate and/or\n                 \
    \   validate SNMPv2 messages with respect to that party.\n          RFC 1446 \
    \       Security Protocols for SNMPv2       April 1993\n                    This\
    \ prohibition includes prevention of read-access\n                    by the entity's\
    \ human operators.\n                    (c) It must allow the party's authentication\
    \ clock\n                    to be publicly accessible.  The correct operation\
    \ of\n                    the Digest Authentication Protocol requires that it\n\
    \                    be possible to determine this value at all times in\n   \
    \                 order to guarantee that skewed authentication clocks\n     \
    \               can be resynchronized.\n                    (d) It must prohibit\
    \ alterations to its record of\n                    the authentication clock for\
    \ that party\n                    independently of alterations to its record of\
    \ the\n                    private authentication key (unless the clock\n    \
    \                alteration is an advancement).\n                    (e) It must\
    \ never allow its record of the\n                    authentication clock for\
    \ that party to be\n                    incremented beyond the maximal time value\
    \ and so\n                    \"roll-over\" to zero.\n                    (f)\
    \ It must never increase its record of the\n                    lifetime for that\
    \ party except as may be explicitly\n                    authorized (via imperative\
    \ command or securely\n                    represented configuration information)\
    \ by the\n                    responsible network administrator.\n           \
    \         (g) In the event that the non-volatile,\n                    incorruptible\
    \ representations of a party's\n                    parameters (in particular,\
    \ either the private\n                    authentication key or private encryption\
    \ key) are\n                    lost or destroyed, it must alter its record of\
    \ these\n                    quantities to random values so subsequent\n     \
    \               interaction with that party requires manual\n                \
    \    redistribution of new secrets and other parameters.\n          (5)  If it\
    \ selects new value(s) for a party's secret(s), it\n               must avoid\
    \ bad or obvious choices for said secret(s).\n               Choices to be avoided\
    \ are boundary values (such as all-\n               zeros) and predictable values\
    \ (such as the same value as\n               previously or selecting from a predetermined\
    \ set).\n          (6)  It must ensure that a received message for which the\n\
    \               originating party uses the Digest Authentication Protocol\n  \
    \             but the receiving party does not, is always declared to\n      \
    \    RFC 1446        Security Protocols for SNMPv2       April 1993\n        \
    \       be unauthentic.  This may be achieved explicitly via an\n            \
    \   additional step in the procedure for processing a\n               received\
    \ message, or implicitly by verifying that all\n               local access control\
    \ policies enforce this requirement.\n          6.3.  Protocol Correctness\n \
    \         The correctness of these SNMPv2 security protocols with\n          respect\
    \ to the stated goals depends on the following\n          assumptions:\n     \
    \     (1)  The chosen message digest algorithm satisfies its design\n        \
    \       criteria.  In particular, it must be computationally\n               infeasible\
    \ to discover two messages that share the same\n               digest value.\n\
    \          (2)  It is computationally infeasible to determine the secret\n   \
    \            used in calculating a digest on the concatenation of the\n      \
    \         secret and a message when both the digest and the message\n        \
    \       are known.\n          (3)  The chosen symmetric encryption algorithm satisfies\
    \ its\n               design criteria.  In particular, it must be\n          \
    \     computationally infeasible to determine the cleartext\n               message\
    \ from the ciphertext message without knowledge of\n               the key used\
    \ in the transformation.\n          (4)  Local notions of a party's authentication\
    \ clock while it\n               is associated with a specific private key value\
    \ are\n               monotonically non-decreasing (i.e., they never run\n   \
    \            backwards) in the absence of administrative\n               manipulations.\n\
    \          (5)  The secrets for a particular SNMPv2 party are known only\n   \
    \            to authorized SNMPv2 protocol entities.\n          (6)  Local notions\
    \ of the authentication clock for a\n               particular SNMPv2 party are\
    \ never altered such that the\n               authentication clock's new value\
    \ is less than the current\n               value without also altering the private\
    \ authentication\n               key.\n          For each mechanism of the protocol,\
    \ an informal account of its\n          contribution to the required goals is\
    \ presented below.\n          RFC 1446        Security Protocols for SNMPv2  \
    \     April 1993\n          Pseudocode fragments are provided where appropriate\
    \ to\n          exemplify possible implementations; they are intended to be\n\
    \          self-explanatory.\n          6.3.1.  Clock Monotonicity Mechanism\n\
    \          By pairing each sequence of a clock's values with a unique\n      \
    \    key, the protocols partially realize goal 3, and the\n          conjunction\
    \ of this property with assumption 6 above is\n          sufficient for the claim\
    \ that, with respect to a specific\n          private key value, all local notions\
    \ of a party's\n          authentication clock are, in general, non-decreasing\
    \ with\n          time.\n          6.3.2.  Data Integrity Mechanism\n        \
    \  The protocols require computation of a message digest computed\n          over\
    \ the SNMPv2 message prepended by the secret for the\n          relevant party.\
    \  By virtue of this mechanism and assumptions 1\n          and 2, the protocols\
    \ realize goal 1.\n          Normally, the inclusion of the message digest value\
    \ with the\n          digested message would not be sufficient to guarantee data\n\
    \          integrity, since the digest value can be modified in addition\n   \
    \       to the message while it is enroute.  However, since not all of\n     \
    \     the digested message is included in the transmission to the\n          destination,\
    \ it is not possible to substitute both a message\n          and a digest value\
    \ while enroute to a destination.\n          Strictly speaking, the specified\
    \ strategy for data integrity\n          does not detect a SNMPv2 message modification\
    \ which appends\n          extraneous material to the end of such messages.  However,\n\
    \          owing to the representation of SNMPv2 messages as ASN.1\n         \
    \ values, such modifications cannot - consistent with goal 1 -\n          result\
    \ in unauthorized management operations.\n          The data integrity mechanism\
    \ specified in this memo protects\n          only against unauthorized modification\
    \ of individual SNMPv2\n          messages.  A more general data integrity service\
    \ that affords\n          protection against the threat of message stream modification\n\
    \          is not realized by this mechanism, although limited protection\n  \
    \        against reordering, delay, and duplication of messages within\n     \
    \     a message stream are provided by other mechanisms of the\n          RFC\
    \ 1446        Security Protocols for SNMPv2       April 1993\n          protocol.\n\
    \          6.3.3.  Data Origin Authentication Mechanism\n          The data integrity\
    \ mechanism requires the use of a secret\n          value known only to communicating\
    \ parties.  By virtue of this\n          mechanism and assumptions 1 and 2, the\
    \ protocols explicitly\n          prevent unauthorized modification of messages.\
    \  Data origin\n          authentication is implicit if the message digest value\
    \ can be\n          verified.  That is, the protocols realize goal 2.\n      \
    \    6.3.4.  Restricted Administration Mechanism\n          This memo requires\
    \ that implementations preclude\n          administrative alterations of the authentication\
    \ clock for a\n          particular party independently from its private authentication\n\
    \          key (unless that clock alteration is an advancement).  An\n       \
    \   example of an efficient implementation of this restriction is\n          provided\
    \ in a pseudocode fragment below.  This pseudocode\n          fragment meets the\
    \ requirements of assumption 6.  Observe that\n          the requirement is not\
    \ for simultaneous alteration but to\n          preclude independent alteration.\
    \  This latter requirement is\n          fairly easily realized in a way that\
    \ is consistent with the\n          defined semantics of the SNMPv2 set operation.\n\
    \          RFC 1446        Security Protocols for SNMPv2       April 1993\n  \
    \             Void partySetKey (party, newKeyValue)\n               {\n      \
    \             if (party->clockAltered) {\n                      party->clockAltered\
    \ = FALSE;\n                      party->keyAltered = FALSE;\n               \
    \       party->keyInUse = newKeyValue;\n                      party->clockInUse\
    \ = party->clockCache;\n                   }\n                   else {\n    \
    \                  party->keyAltered = TRUE;\n                      party->keyCache\
    \ = newKeyValue;\n                   }\n               }\n               Void\
    \ partySetClock (party, newClockValue)\n               {\n                   if\
    \ (party->keyAltered) {\n                      party->keyAltered = FALSE;\n  \
    \                    party->clockAltered = FALSE;\n                      party->clockInUse\
    \ = newClockValue;\n                      party->keyInUse = party->keyCache;\n\
    \                   }\n                   else {\n                      party->clockAltered\
    \ = TRUE;\n                      party->clockCache = newClockValue;\n        \
    \           }\n               }\n          6.3.5.  Message Timeliness Mechanism\n\
    \          The definition of the SNMPv2 security protocols requires that,\n  \
    \        if the authentication timestamp value on a received message -\n     \
    \     augmented by an administratively chosen lifetime value - is\n          less\
    \ than the local notion of the clock for the originating\n          SNMPv2 party,\
    \ the message is not delivered.\n               if (timestampOfReceivedMsg +\n\
    \                      party->administrativeLifetime <=\n                    \
    \  party->localNotionOfClock) {\n                      msgIsValidated = FALSE;\n\
    \               }\n          RFC 1446        Security Protocols for SNMPv2   \
    \    April 1993\n          By virtue of this mechanism, the protocols realize\
    \ goal 3.  In\n          cases in which the local notions of a particular SNMPv2\
    \ party\n          clock are moderately well-synchronized, the timeliness\n  \
    \        mechanism effectively limits the age of validly delivered\n         \
    \ messages.  Thus, if an attacker diverts all validated messages\n          for\
    \ replay much later, the delay introduced by this attack is\n          limited\
    \ to a period that is proportional to the skew among\n          local notions\
    \ of the party clock.\n          6.3.6.  Selective Clock Acceleration Mechanism\n\
    \          The definition of the SNMPv2 security protocols requires that,\n  \
    \        if either of the timestamp values for the originating or\n          receiving\
    \ parties on a received, validated message exceeds the\n          corresponding\
    \ local notion of the clock for that party, then\n          the local notion of\
    \ the clock for that party is adjusted\n          forward to correspond to said\
    \ timestamp value.  This mechanism\n          is neither strictly necessary nor\
    \ sufficient to the security\n          of the protocol; rather, it fosters the\
    \ clock synchronization\n          on which valid message delivery depends - thereby\
    \ enhancing\n          the effectiveness of the protocol in a management context.\n\
    \               if (msgIsValidated) {\n                      if (timestampOfReceivedMsg\
    \ >\n                            party->localNotionOfClock) {\n              \
    \              party->localNotionOfClock =\n                                 \
    \ timestampOfReceivedMsg;\n                      }\n               }\n       \
    \   The effect of this mechanism is to synchronize local notions\n          of\
    \ a party clock more closely in the case where a sender's\n          notion is\
    \ more advanced than a receiver's.  In the opposite\n          case, this mechanism\
    \ has no effect on local notions of a party\n          clock and either the received\
    \ message is validly delivered or\n          not according to other mechanisms\
    \ of the protocol.\n          Operation of this mechanism does not, in general,\
    \ improve the\n          probability of validated delivery for messages generated\
    \ by\n          party participants whose local notion of the party clock is\n\
    \          relatively less advanced.  In this case, queries from a\n         \
    \ management station may not be validly delivered and the\n          RFC 1446\
    \        Security Protocols for SNMPv2       April 1993\n          management\
    \ station needs to react appropriately (e.g., by use\n          of the strategy\
    \ described in section 5.3).  In contrast, the\n          delivery of SNMPv2 trap\
    \ messages generated by an agent that\n          suffers from a less advanced\
    \ notion of a party clock is more\n          problematic, for an agent may lack\
    \ the capacity to recognize\n          and react to security failures that prevent\
    \ delivery of its\n          messages.  Thus, the inherently unreliable character\
    \ of trap\n          messages is likely to be compounded by attempts to provide\
    \ for\n          their validated delivery.\n          6.3.7.  Confidentiality\
    \ Mechanism\n          The protocols require the use of a symmetric encryption\n\
    \          algorithm when the data confidentiality service is required.\n    \
    \      By virtue of this mechanism and assumption 3, the protocols\n         \
    \ realize goal 4.\n          RFC 1446        Security Protocols for SNMPv2   \
    \    April 1993\n          7.  Acknowledgements\n          This document is based,\
    \ almost entirely, on RFC 1352.\n          RFC 1446        Security Protocols\
    \ for SNMPv2       April 1993\n          8.  References\n          [1]  Galvin,\
    \ J., and McCloghrie, K., \"Administrative Model for\n               version 2\
    \ of the Simple Network Management Protocol\n               (SNMPv2)\", RFC 1445,\
    \ Trusted Information Systems, Hughes\n               LAN Systems, April 1993.\n\
    \          [2]  Case, J., Fedor, M., Schoffstall, M., Davin, J., \"Simple\n  \
    \             Network Management Protocol\", STD 15, RFC 1157, SNMP\n        \
    \       Research, Performance Systems International, MIT\n               Laboratory\
    \ for Computer Science, May 1990.\n          [3]  Rivest, R., \"The MD5 Message-Digest\
    \ Algorithm\", RFC 1321,\n               MIT Laboratory for Computer Science,\
    \ April 1992.\n          [4]  McCloghrie, K., and Galvin, J., \"Party MIB for\
    \ version 2\n               of the Simple Network Management Protocol (SNMPv2)\"\
    , RFC\n               1447, Hughes LAN Systems, Trusted Information Systems,\n\
    \               April 1993.\n          [5]  Data Encryption Standard, National\
    \ Institute of Standards\n               and Technology.  Federal Information\
    \ Processing Standard\n               (FIPS) Publication 46-1.  Supersedes FIPS\
    \ Publication 46,\n               (January, 1977; reaffirmed January, 1988).\n\
    \          [6]  Data Encryption Algorithm, American National Standards\n     \
    \          Institute.  ANSI X3.92-1981, (December, 1980).\n          [7]  DES\
    \ Modes of Operation, National Institute of Standards\n               and Technology.\
    \  Federal Information Processing Standard\n               (FIPS) Publication\
    \ 81, (December, 1980).\n          [8]  Data Encryption Algorithm - Modes of Operation,\
    \ American\n               National Standards Institute.  ANSI X3.106-1983, (May\n\
    \               1983).\n          [9]  Guidelines for Implementing and Using the\
    \ NBS Data\n               Encryption Standard, National Institute of Standards\
    \ and\n               Technology.  Federal Information Processing Standard\n \
    \              (FIPS) Publication 74, (April, 1981).\n          [10] Validating\
    \ the Correctness of Hardware Implementations of\n               the NBS Data\
    \ Encryption Standard, National Institute of\n               Standards and Technology.\
    \  Special Publication 500-20.\n          RFC 1446        Security Protocols for\
    \ SNMPv2       April 1993\n          [11] Maintenance Testing for the Data Encryption\
    \ Standard,\n               National Institute of Standards and Technology.  Special\n\
    \               Publication 500-61, (August, 1980).\n          [12] Case, J.,\
    \ McCloghrie, K., Rose, M., and Waldbusser, S.,\n               \"Protocol Operations\
    \ for version 2 of the Simple Network\n               Management Protocol (SNMPv2)\"\
    , RFC 1448, SNMP Research,\n               Inc., Hughes LAN Systems, Dover Beach\
    \ Consulting, Inc.,\n               Carnegie Mellon University, April 1993.\n\
    \          [13] Case, J., McCloghrie, K., Rose, M., and Waldbusser, S.,\n    \
    \           \"Transport Mappings for version 2 of the Simple Network\n       \
    \        Management Protocol (SNMPv2)\", RFC 1449, SNMP Research,\n          \
    \     Inc., Hughes LAN Systems, Dover Beach Consulting, Inc.,\n              \
    \ Carnegie Mellon University, April 1993.\n          [14] Case, J., McCloghrie,\
    \ K., Rose, M., and Waldbusser, S.,\n               \"Management Information Base\
    \ for version 2 of the Simple\n               Network Management Protocol (SNMPv2)\"\
    , RFC 1450, SNMP\n               Research, Inc., Hughes LAN Systems, Dover Beach\n\
    \               Consulting, Inc., Carnegie Mellon University, April 1993.\n  \
    \        RFC 1446        Security Protocols for SNMPv2       April 1993\n    \
    \      9.  Authors' Addresses\n               James M. Galvin\n              \
    \ Trusted Information Systems, Inc.\n               3060 Washington Road, Route\
    \ 97\n               Glenwood, MD 21738\n               Phone:  +1 301 854-6889\n\
    \               EMail:  galvin@tis.com\n               Keith McCloghrie\n    \
    \           Hughes LAN Systems\n               1225 Charleston Road\n        \
    \       Mountain View, CA  94043\n               US\n               Phone: +1\
    \ 415 966 7934\n               Email: kzm@hls.com\n"
