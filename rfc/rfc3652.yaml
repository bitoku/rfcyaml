- title: __initial_text__
  contents:
  - '            Handle System Protocol (ver 2.1) Specification

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   Several groups within the IETF and IRTF have discussed the Handle\n\
    \   System and its relationship to existing systems of identifiers.  The\n   IESG\
    \ wishes to point out that these discussions have not resulted in\n   IETF consensus\
    \ on the described Handle System, nor on how it might\n   fit into the IETF architecture\
    \ for identifiers.  Though there has\n   been discussion of handles as a form\
    \ of URI, specifically as a URN,\n   these documents describe an alternate view\
    \ of how namespaces and\n   identifiers might work on the Internet and include\
    \ characterizations\n   of existing systems which may not match the IETF consensus\
    \ view.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Handle System is a general-purpose global name service that\n\
    \   allows secured name resolution and administration over the public\n   Internet.\
    \  This document describes the protocol used for client\n   software to access\
    \ the Handle System for both handle resolution and\n   administration.  The protocol\
    \ specifies the procedure for a client\n   software to locate the responsible\
    \ handle server of any given handle.\n   It also defines the messages exchanged\
    \ between the client and server\n   for any handle operation.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Overview . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Protocol Elements. . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n       2.1.  Conventions. . . . . . . . . . . . . . . . . . .\
    \ . . . .  4\n             2.1.1.  Data Transmission Order. . . . . . . . . .\
    \ . . .  4\n             2.1.2.  Transport Layer. . . . . . . . . . . . . . .\
    \ . .  5\n             2.1.3.  Character Case . . . . . . . . . . . . . . . .\
    \ .  6\n             2.1.4.  Standard String Type: UTF8-String. . . . . . . .\
    \  7\n       2.2.  Common Elements. . . . . . . . . . . . . . . . . . . . .  7\n\
    \             2.2.1.  Message Envelope . . . . . . . . . . . . . . . .  8\n  \
    \           2.2.2.  Message Header . . . . . . . . . . . . . . . . . 11\n    \
    \         2.2.3.  Message Body . . . . . . . . . . . . . . . . . . 17\n      \
    \       2.2.4.  Message Credential . . . . . . . . . . . . . . . 18\n       2.3.\
    \  Message Transmission . . . . . . . . . . . . . . . . . . 20\n   3.  Handle\
    \ Protocol Operations . . . . . . . . . . . . . . . . . . 21\n       3.1.  Client\
    \ Bootstrapping . . . . . . . . . . . . . . . . . . 21\n             3.1.1.  Global\
    \ Handle Registry and its Service\n                     Information. . . . . .\
    \ . . . . . . . . . . . . . 21\n             3.1.2.  Locating the Handle System\
    \ Service Component . . 22\n             3.1.3.  Selecting the Responsible Server\
    \ . . . . . . . . 23\n       3.2.  Query Operation. . . . . . . . . . . . . .\
    \ . . . . . . . 23\n             3.2.1.  Query Request. . . . . . . . . . . .\
    \ . . . . . . 24\n             3.2.2.  Successful Query Response. . . . . . .\
    \ . . . . . 25\n             3.2.3.  Unsuccessful Query Response. . . . . . .\
    \ . . . . 26\n       3.3.  Error Response from Server . . . . . . . . . . . .\
    \ . . . 26\n       3.4.  Service Referral . . . . . . . . . . . . . . . . . .\
    \ . . 27\n       3.5.  Client Authentication. . . . . . . . . . . . . . . . .\
    \ . 28\n             3.5.1.  Challenge from Server to Client. . . . . . . . .\
    \ 29\n             3.5.2.  Challenge-Response from Client to Server . . . . 30\n\
    \             3.5.3.  Challenge-Response Verification-Request. . . . . 33\n  \
    \           3.5.4.  Challenge-Response Verification-Response . . . . 33\n    \
    \   3.6.  Handle Administration. . . . . . . . . . . . . . . . . . 34\n      \
    \       3.6.1.  Add Handle Value(s). . . . . . . . . . . . . . . 34\n        \
    \     3.6.2.  Remove Handle Value(s) . . . . . . . . . . . . . 35\n          \
    \   3.6.3.  Modify Handle Value(s) . . . . . . . . . . . . . 36\n            \
    \ 3.6.4.  Create Handle. . . . . . . . . . . . . . . . . . 37\n             3.6.5.\
    \  Delete Handle. . . . . . . . . . . . . . . . . . 39\n       3.7.  Naming Authority\
    \ (NA) Administration . . . . . . . . . . 40\n             3.7.1.  List Handle(s)\
    \ under a Naming Authority. . . . . 40\n             3.7.2.  List Sub-Naming Authorities\
    \ under a Naming\n                     Authority. . . . . . . . . . . . . . .\
    \ . . . . . 41\n       3.8.  Session and Session Management . . . . . . . . .\
    \ . . . . 42\n             3.8.1.  Session Setup Request. . . . . . . . . . .\
    \ . . . 43\n             3.8.2.  Session Setup Response . . . . . . . . . . .\
    \ . . 46\n             3.8.3.  Session Key Exchange . . . . . . . . . . . . .\
    \ . 47\n             3.8.4.  Session Termination. . . . . . . . . . . . . . .\
    \ 48\n   4.  Implementation Guidelines. . . . . . . . . . . . . . . . . . . 48\n\
    \       4.1.  Server Implementation. . . . . . . . . . . . . . . . . . 48\n  \
    \     4.2.  Client Implementation. . . . . . . . . . . . . . . . . . 49\n   5.\
    \  Security Considerations. . . . . . . . . . . . . . . . . . . . 49\n   6.  Acknowledgements\
    \ . . . . . . . . . . . . . . . . . . . . . . . 50\n   7.  Informative References\
    \ . . . . . . . . . . . . . . . . . . . . 50\n   8.  Authors' Addresses . . .\
    \ . . . . . . . . . . . . . . . . . . . 52\n   9.  Full Copyright Statement .\
    \ . . . . . . . . . . . . . . . . . . 53\n"
- title: 1.  Overview
  contents:
  - "1.  Overview\n   The Handle System provides a general-purpose, secured global\
    \ name\n   service for the Internet.  It was originally conceived and described\n\
    \   in a paper by Robert Kahn and Robert Wilensky [18] in 1995.  The\n   Handle\
    \ System defines a client server protocol in which client\n   software submits\
    \ requests via a network to handle servers.  Each\n   request describes the operation\
    \ to be performed on the server.  The\n   server will process the request and\
    \ return a message indicating the\n   result of the operation.  This document\
    \ specifies the protocol for\n   client software to access a handle server for\
    \ handle resolution and\n   administration.  It does not include the description\
    \ of the protocol\n   used to manage handle servers.  A discussion of the management\n\
    \   protocol is out of the scope of this document and will be made\n   available\
    \ in a separate document.  The document assumes that readers\n   are familiar\
    \ with the basic concepts of the Handle System as\n   introduced in the \"Handle\
    \ System Overview\" [1], as well as the data\n   model and service definition\
    \ given in the \"Handle System Namespace\n   and Service Definition\" [2].\n \
    \  The Handle System consists of a set of service components as defined\n   in\
    \ [2].  From the client's point of view, the Handle System is a\n   distributed\
    \ database for handles.  Different handles under the Handle\n   System may be\
    \ maintained by different handle servers at different\n   network locations. \
    \ The Handle protocol specifies the procedure for a\n   client to locate the responsible\
    \ handle server of any given handle.\n   It also defines the messages exchanged\
    \ between the client and server\n   for any handle operation.\n   Some key aspects\
    \ of the Handle protocol include:\n      o  The Handle protocol supports both\
    \ handle resolution and\n         administration.  The protocol follows the data\
    \ and service\n         model defined in [2].\n      o  A client may authenticate\
    \ any server response based on the\n         server's digital signature.\n   \
    \   o  A server may authenticate its client as handle administrator\n        \
    \ via the Handle authentication protocol.  The Handle\n         authentication\
    \ protocol is a challenge-response protocol that\n         supports both public-key\
    \ and secret-key based authentication.\n      o  A session may be established\
    \ between the client and server so\n         that authentication information and\
    \ network resources (e.g.,\n         TCP connection) may be shared among multiple\
    \ operations.  A\n         session key can be established to achieve data integrity\
    \ and\n         confidentiality.\n      o  The protocol can be extended to support\
    \ new operations.\n         Controls can be used to extend the existing operations.\
    \  The\n         protocol is defined to allow future backward compatibility.\n\
    \      o  Distributed service architecture.  Support service referral\n      \
    \   among different service components.\n      o  Handles and their data types\
    \ are based on the ISO-10646\n         (Unicode 2.0) character set.  UTF-8 [3]\
    \ is the mandated\n         encoding under the Handle protocol.\n   The Handle\
    \ protocol (version 2.1) specified in this document has\n   changed significantly\
    \ from its earlier versions.  These changes are\n   necessary due to changes made\
    \ in the Handle System data model and the\n   service model.  Servers that implement\
    \ this protocol may continue to\n   support earlier versions of the protocol by\
    \ checking the protocol\n   version specified in the Message Envelope (see section\
    \ 2.2.1).\n"
- title: 2.  Protocol Elements
  contents:
  - '2.  Protocol Elements

    '
- title: 2.1.  Conventions
  contents:
  - "2.1.  Conventions\n   The following conventions are followed by the Handle protocol\
    \ to\n   ensure interoperability among different implementations.\n"
- title: 2.1.1.  Data Transmission Order
  contents:
  - "2.1.1.  Data Transmission Order\n   The order of transmission of data packets\
    \ follows the network byte\n   order (also called the Big-Endian [11]).  That\
    \ is, when a data-gram\n   consists of a group of octets, the order of transmission\
    \ of those\n   octets follows their natural order from left to right and from\
    \ top to\n   bottom, as they are read in English.  For example, in the following\n\
    \   diagram, the octets are transmitted in the order they are numbered.\n    \
    \      0                   1\n          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n    \
    \     .-------------------------------.\n         |       1       |       2  \
    \     |\n         |-------------------------------|\n         |       3      \
    \ |       4       |\n         |-------------------------------|\n         |  \
    \     5       |       6       |\n         '-------------------------------'\n\
    \   If an octet represents a numeric quantity, the left most bit is the\n   most\
    \ significant bit.  For example, the following diagram represents\n   the value\
    \ 170 (decimal).\n          0 1 2 3 4 5 6 7\n         .---------------.\n    \
    \     |1 0 1 0 1 0 1 0|\n         '---------------'\n   Similarly, whenever a\
    \ multi-octet field represents a numeric\n   quantity, the left most bit is the\
    \ most significant bit and the most\n   significant octet of the whole field is\
    \ transmitted first.\n"
- title: 2.1.2.  Transport Layer
  contents:
  - "2.1.2.  Transport Layer\n   The Handle protocol is designed so that messages\
    \ may be transmitted\n   either as separate data-grams over UDP or as a continuous\
    \ byte stream\n   via a TCP connection.  The recommended port number for both\
    \ UDP and\n   TCP is 2641.\n   UDP Usage\n      Messages carried by UDP are restricted\
    \ to 512 bytes (not including\n      the IP or UDP header).  Longer messages must\
    \ be fragmented into\n      UDP packets where each packet carries a proper sequence\
    \ number in\n      the Message Envelope (see Section 2.2.1).\n      The optimum\
    \ retransmission policy will vary depending on the\n      network or server performance,\
    \ but the following are recommended:\n         o  The client should try other\
    \ servers or service interfaces\n            before repeating a request to the\
    \ same server address.\n         o  The retransmission interval should be based\
    \ on prior\n            statistics if possible.  Overly aggressive retransmission\n\
    \            should be avoided to prevent network congestion.  The\n         \
    \   recommended retransmission interval is 2-5 seconds.\n         o  When transmitting\
    \ large amounts of data, TCP-friendly\n            congestion control, such as\
    \ an interface to the Congestion\n            Manager [12], should be implemented\
    \ whenever possible to\n            avoid unfair consumption of the bandwidth\
    \ against TCP-based\n            applications.  Details of the congestion control\
    \ will be\n            discussed in a separate document.\n   TCP Usage\n     \
    \ Messages under the Handle protocol can be mapped directly into a\n      TCP\
    \ byte-stream.  However, the size of each message is limited by\n      the range\
    \ of a 4-byte unsigned integer.  Longer messages may be\n      fragmented into\
    \ multiple messages before the transmission and\n      reassembled at the receiving\
    \ end.\n      Several connection management policies are recommended:\n      \
    \   o  The server should support multiple connections and should\n           \
    \ not block other activities waiting for TCP data.\n         o  By default, the\
    \ server should close the connection after\n            completing the request.\
    \  However, if the request asks to\n            keep the connection open, the\
    \ server should assume that the\n            client will initiate connection closing.\n"
- title: 2.1.3.  Character Case
  contents:
  - "2.1.3.  Character Case\n   Handles are character strings based on the ISO-10646\
    \ character set\n   and must be encoded in UTF-8.  By default, handle characters\
    \ are\n   treated as case-sensitive under the Handle protocol.  A handle\n   service,\
    \ however, may be implemented in such a way that ASCII\n   characters are processed\
    \ case-insensitively.  For example, the Global\n   Handle Registry (GHR) provides\
    \ a handle service where ASCII\n   characters are processed in a case-insensitive\
    \ manner.  This suggests\n   that ASCII characters in any naming authority are\
    \ case-insensitive.\n   When handles are created under a case-insensitive handle\
    \ server,\n   their original case should be preserved.  To avoid any confusion,\
    \ the\n   server should avoid creating any handle whose character string\n   matches\
    \ that of an existing handle, ignoring the case difference.\n   For example, if\
    \ the handle \"X/Y\" was already created, the server\n   should refuse any request\
    \ to create the handle \"x/y\" or any of its\n   case variations.\n"
- title: '2.1.4.  Standard String Type: UTF8-String'
  contents:
  - "2.1.4.  Standard String Type: UTF8-String\n   Handles are transmitted as UTF8-Strings\
    \ under the Handle protocol.\n   Throughout this document, UTF8-String stands\
    \ for the data type that\n   consists of a 4-byte unsigned integer followed by\
    \ a character string\n   in UTF-8 encoding.  The leading integer specifies the\
    \ number of\n   octets of the character string.\n"
- title: 2.2.  Common Elements
  contents:
  - "2.2.  Common Elements\n   Each message exchanged under the system protocol consists\
    \ of four\n   sections (see Fig. 2.2).  Some of these sections (e.g., the Message\n\
    \   Body) may be empty depending on the protocol operation.\n   The Message Envelope\
    \ must always be present.  It has a fixed size of\n   20 octets.  The Message\
    \ Envelope does not carry any application layer\n   information and is primarily\
    \ used to help deliver the message.\n   Content in the Message Envelope is not\
    \ protected by the digital\n   signature in the Message Credential.\n   The Message\
    \ Header must always be present as well.  It has a fixed\n   size of 24 octets\
    \ and holds the common data fields of all messages\n   exchanged between client\
    \ and server.  These include the operation\n   code, the response code, and the\
    \ control options for each protocol\n   operation.  Content in the Message Header\
    \ is protected by the digital\n   signature in the Message Credential.\n   The\
    \ Message Body contains data specific to each protocol operation.\n   Its format\
    \ varies according to the operation code and the response\n   code in the Message\
    \ Header.  The Message Body may be empty.  Content\n   in the Message Body is\
    \ protected by the digital signature in the\n   Message Credential.\n   The Message\
    \ Credential provides a mechanism for transport security\n   for any message exchanged\
    \ between the client and server.  A non-empty\n   Message Credential may contain\
    \ the digital signature from the\n   originator of the message or the one-way\
    \ Message Authentication Code\n   (MAC) based on a pre-established session key.\
    \  The Message Credential\n   may be used to authenticate the message between\
    \ the client and\n   server.  It can also be used to check data integrity after\
    \ its\n   transmission.\n      .----------------------.\n      |             \
    \         |  ; Message wrapper for proper message\n      |   Message Envelope\
    \   |  ; delivery.  Not protected by the\n      |                      |  ; digital\
    \ signature in the Message\n      |                      |  ; Credential.\n  \
    \    |----------------------|\n      |                      |  ; Common data fields\
    \ for all handle\n      |   Message Header     |  ; operations.\n      |     \
    \                 |\n      |----------------------|\n      |                 \
    \     |  ; Specific data fields for each\n      |   Message Body       |  ; request/response.\n\
    \      |                      |\n      |----------------------|\n      |     \
    \                 |  ; Contains digital signature or\n      |  Message Credential\
    \  |  ; message authentication code (MAC)\n      |                      |  ; upon\
    \ Message Header and Message\n      '----------------------'  ; Body.\n      \
    \   Fig 2.2: Message format under the Handle protocol\n"
- title: 2.2.1.  Message Envelope
  contents:
  - "2.2.1.  Message Envelope\n   Each message begins with a Message Envelope under\
    \ the Handle\n   protocol.  If a message has to be truncated before its transmission,\n\
    \   each truncated portion must also begin with a Message Envelope.\n   The Message\
    \ Envelope allows the reassembly of the message at the\n   receiving end.  It\
    \ has a fixed size of 20 octets and consists of\n   seven fields:\n       0  \
    \                 1                   2                   3\n       0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      .---------------------------------------------------------------.\n\
    \      | MajorVersion  | MinorVersion  |       MessageFlag             |\n   \
    \   |---------------------------------------------------------------|\n      |\
    \               SessionId                                       |\n      |---------------------------------------------------------------|\n\
    \      |               RequestId                                       |\n   \
    \   |---------------------------------------------------------------|\n      |\
    \               SequenceNumber                                  |\n      |---------------------------------------------------------------|\n\
    \      |               MessageLength                                   |\n   \
    \   '---------------------------------------------------------------'\n"
- title: 2.2.1.1.  <MajorVersion> and <MinorVersion>
  contents:
  - "2.2.1.1.  <MajorVersion> and <MinorVersion>\n   The <MajorVersion> and <MinorVersion>\
    \ are used to identify the\n   version of the Handle protocol.  Each of them is\
    \ defined as a one-\n   byte unsigned integer.  This specification defines the\
    \ protocol\n   version whose <MajorVersion> is 2 and <MinorVersion> is 1.\n  \
    \ <MajorVersion> and <MinorVersion> are designed to allow future\n   backward\
    \ compatibility.  A difference in <MajorVersion> indicates\n   major variation\
    \ in the protocol format and the party with the lower\n   <MajorVersion> will\
    \ have to upgrade its software to ensure precise\n   communication.  An increment\
    \ in <MinorVersion> is made when\n   additional capabilities are added to the\
    \ protocol without any major\n   change to the message format.\n"
- title: 2.2.1.2.  <MessageFlag>
  contents:
  - "2.2.1.2.  <MessageFlag>\n   The <MessageFlag> consists of two octets defined\
    \ as follows:\n                                               1   1   1   1  \
    \ 1   1\n       0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5\n\
    \      .---------------------------------------------------------------.\n   \
    \   |CP |EC |TC |       Reserved                                    |\n      '---------------------------------------------------------------'\n\
    \   Bit 0 is the CP (ComPressed) flag that indicates whether the message\n   (excluding\
    \ the Message Envelope) is compressed.  If the CP bit is set\n   (to 1), the message\
    \ is compressed.  Otherwise, the message is not\n   compressed.  The Handle protocol\
    \ uses the same compression method as\n   used by the FTP protocol[8].\n   Bit\
    \ 1 is the EC (EnCrypted) flag that indicates whether the message\n   (excluding\
    \ the Message Envelope) is encrypted.  The EC bit should\n   only be set under\
    \ an established session where a session key is in\n   place.  If the EC bit is\
    \ set (to 1), the message is encrypted using\n   the session key.  Otherwise the\
    \ message is not encrypted.\n   Bit 2 is the TC (TrunCated) flag that indicates\
    \ whether this is a\n   truncated message.  Message truncation happens most often\
    \ when\n   transmitting a large message over the UDP protocol.  Details of\n \
    \  message truncation (or fragmentation) will be discussed in section\n   2.3.\n\
    \   Bits 3 to 15 are currently reserved and must be set to zero.\n"
- title: 2.2.1.3.  <SessionId>
  contents:
  - "2.2.1.3.  <SessionId>\n   The <SessionId> is a four-byte unsigned integer that\
    \ identifies a\n   communication session between the client and server.\n   Session\
    \ and its <SessionId> are assigned by a server, either upon an\n   explicit request\
    \ from a client or when multiple message exchanges are\n   expected to fulfill\
    \ the client's request.  For example, the server\n   will assign a unique <SessionId>\
    \ in its response if it has to\n   authenticate the client.  A client may explicitly\
    \ ask the server to\n   set up a session as a virtually private communication\
    \ channel like\n   SSL [4].  Requests from clients without an established session\
    \ must\n   have their <SessionId> set to zero.  The server must assign a unique\n\
    \   non-zero <SessionId> for each new session.  It is also responsible\n   for\
    \ terminating those sessions that are not in use after some period\n   of time.\n\
    \   Both clients and servers must maintain the same <SessionId> for\n   messages\
    \ exchanged under an established session.  A message whose\n   <SessionId> is\
    \ zero indicates that no session has been established.\n   The session and its\
    \ state information may be shared among multiple\n   handle operations.  They\
    \ may also be shared over multiple TCP\n   connections as well.  Once a session\
    \ is established, both client and\n   server must maintain their state information\
    \ according to the\n   <SessionId>.  The state information may include the stage\
    \ of the\n   conversation, the other party's authentication information, and the\n\
    \   session key that was established for message encryption or\n   authentication.\
    \  Details of these are discussed in section 3.8.\n"
- title: 2.2.1.4.  <RequestId>
  contents:
  - "2.2.1.4.  <RequestId>\n   Each request from a client is identified by a <RequestId>,\
    \ a 4-byte\n   unsigned integer set by the client.  Each <RequestId> must be unique\n\
    \   from all other outstanding requests from the same client.  The\n   <RequestId>\
    \ allows the client to keep track of its requests, and any\n   response from the\
    \ server must include the correct <RequestId>.\n"
- title: 2.2.1.5.  <SequenceNumber>
  contents:
  - "2.2.1.5.  <SequenceNumber>\n   Messages under the Handle protocol may be truncated\
    \ during their\n   transmission (e.g., under UDP).  The <SequenceNumber> is a\
    \ 4-byte\n   unsigned integer used as a counter to keep track of each truncated\n\
    \   portion of the original message.  The message recipient can\n   reassemble\
    \ the original message based on the <SequenceNumber>.  The\n   <SequenceNumber>\
    \ must start with 0 for each message.  Each truncated\n   message must set its\
    \ TC flag in the Message Envelope.  Messages that\n   are not truncated must set\
    \ their <SequenceNumber> to zero.\n"
- title: 2.2.1.6.  <MessageLen>
  contents:
  - "2.2.1.6.  <MessageLen>\n   A 4-byte unsigned integer that specifies the total\
    \ number of octets\n   of any message, excluding those in the Message Envelope.\
    \  The length\n   of any single message exchanged under the Handle protocol is\
    \ limited\n   by the range of a 4-byte unsigned integer.  Longer data can be\n\
    \   transmitted as multiple messages with a common <RequestId>.\n"
- title: 2.2.2.   Message Header
  contents:
  - "2.2.2.   Message Header\n   The Message Header contains the common data elements\
    \ among any\n   protocol operation.  It has a fixed size of 24 octets and consists\
    \ of\n   eight fields.\n       0                   1                   2     \
    \              3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      .---------------------------------------------------------------.\n\
    \      |                     OpCode                                    |\n   \
    \   |---------------------------------------------------------------|\n      |\
    \                     ResponseCode                              |\n      |---------------------------------------------------------------|\n\
    \      |                     OpFlag                                    |\n   \
    \   |---------------------------------------------------------------|\n      |\
    \     SiteInfoSerialNumber      | RecursionCount|               |\n      |---------------------------------------------------------------|\n\
    \      |                     ExpirationTime                            |\n   \
    \   |---------------------------------------------------------------|\n      |\
    \                     BodyLength                                |\n      '---------------------------------------------------------------'\n\
    \   Every message that is not truncated must have a Message Header.  If a\n  \
    \ message has to be truncated for its transmission, the Message Header\n   must\
    \ appear in the first truncated portion of the message.\n   This is different\
    \ from the Message Envelope, which appears in each\n   truncated portion of the\
    \ message.\n"
- title: 2.2.2.1.  <OpCode>
  contents:
  - "2.2.2.1.  <OpCode>\n   The <OpCode> stands for operation code, which is a four-byte\
    \ unsigned\n   integer that specifies the intended operation.  The following table\n\
    \   lists the <OpCode>s that MUST be supported by all implementations in\n   order\
    \ to conform to the base protocol specification.  Each operation\n   code is given\
    \ a symbolic name that is used throughout this document\n   for easy reference.\n\
    \       Op_Code    Symbolic Name            Remark\n      ---------   -------------\
    \            ------\n          0       OC_RESERVED              Reserved\n   \
    \       1       OC_RESOLUTION            Handle query\n          2       OC_GET_SITEINFO\
    \          Get HS_SITE values\n        100       OC_CREATE_HANDLE         Create\
    \ new handle\n        101       OC_DELETE_HANDLE         Delete existing handle\n\
    \        102       OC_ADD_VALUE             Add handle value(s)\n        103 \
    \      OC_REMOVE_VALUE          Remove handle value(s)\n        104       OC_MODIFY_VALUE\
    \          Modify handle value(s)\n        105       OC_LIST_HANDLE          \
    \ List handles\n        106       OC_LIST_NA               List sub-naming authorities\n\
    \        200       OC_CHALLENGE_RESPONSE    Response to challenge\n        201\
    \       OC_VERIFY_RESPONSE       Verify challenge response\n        300\n    \
    \     :        { Reserved for handle server administration }\n        399\n  \
    \      400       OC_SESSION_SETUP         Session setup request\n        401 \
    \      OC_SESSION_TERMINATE     Session termination request\n        402     \
    \  OC_SESSION_EXCHANGEKEY   Session key exchange\n   A detailed description of\
    \ each of these <OpCode>s can be found in\n   section 3 of this document.  In\
    \ general, clients use the <OpCode> to\n   tell the server what kind of handle\
    \ operation they want to\n   accomplish.  Response from the server must maintain\
    \ the same <OpCode>\n   as the original request and use the <ResponseCode> to\
    \ indicate the\n   result.\n"
- title: 2.2.2.2.  <ResponseCode>
  contents:
  - "2.2.2.2.  <ResponseCode>\n   The <ResponseCode> is a 4-byte unsigned integer\
    \ that is given by a\n   server to indicate the result of any service request.\
    \  The list of\n   <ResponseCode>s used in the Handle protocol is defined in the\n\
    \   following table.  Each response code is given a symbolic name that is\n  \
    \ used throughout this document for easy reference.\n      Res. Code   Symbolic\
    \ Name            Remark\n      ---------   -------------            ------\n\
    \         0        RC_RESERVED              Reserved for request\n         1 \
    \       RC_SUCCESS               Success response\n         2        RC_ERROR\
    \                 General error\n         3        RC_SERVER_BUSY           Server\
    \ too busy to respond\n         4        RC_PROTOCOL_ERROR        Corrupted or\n\
    \                                           unrecognizable message\n         5\
    \        RC_OPERATION_DENIED      Unsupported operation\n         6        RC_RECUR_LIMIT_EXCEEDED\
    \  Too many recursions for\n                                           the request\n\
    \         100      RC_HANDLE_NOT_FOUND      Handle not found\n         101   \
    \   RC_HANDLE_ALREADY_EXIST  Handle already exists\n         102      RC_INVALID_HANDLE\
    \        Encoding (or syntax) error\n         200      RC_VALUE_NOT_FOUND    \
    \   Value not found\n         201      RC_VALUE_ALREADY_EXIST   Value already\
    \ exists\n         202      RC_VALUE_INVALID         Invalid handle value\n  \
    \       300      RC_EXPIRED_SITE_INFO     SITE_INFO out of date\n         301\
    \      RC_SERVER_NOT_RESP       Server not responsible\n         302      RC_SERVICE_REFERRAL\
    \      Server referral\n         303      RC_NA_DELEGATE           Naming authority\
    \ delegation\n                                           takes place.\n      \
    \   400      RC_NOT_AUTHORIZED        Not authorized/permitted\n         401 \
    \     RC_ACCESS_DENIED         No access to data\n         402      RC_AUTHEN_NEEDED\
    \         Authentication required\n         403      RC_AUTHEN_FAILED        \
    \ Failed to authenticate\n         404      RC_INVALID_CREDENTIAL    Invalid credential\n\
    \         405      RC_AUTHEN_TIMEOUT        Authentication timed out\n       \
    \  406      RC_UNABLE_TO_AUTHEN      Unable to authenticate\n         500    \
    \  RC_SESSION_TIMEOUT       Session expired\n         501      RC_SESSION_FAILED\
    \        Unable to establish session\n         502      RC_NO_SESSION_KEY    \
    \    No session yet available\n         503      RC_SESSION_NO_SUPPORT    Session\
    \ not supported\n         504      RC_SESSION_KEY_INVALID   Invalid session key\n\
    \         900      RC_TRYING                Request under processing\n       \
    \  901      RC_FORWARDED             Request forwarded to\n                  \
    \                         another server\n         902      RC_QUEUED        \
    \        Request queued for later\n                                          \
    \ processing\n   Response codes under 10000 are reserved for system use.  Any\
    \ message\n   with a response code under 10000 but not listed above should be\n\
    \   treated as an unknown error.  Response codes above 10000 are user\n   defined\
    \ and can be used for application specific purposes.\n   Detailed descriptions\
    \ of these <ResponseCode>s can be found in\n   section 3 of this document.  In\
    \ general, any request from a client\n   must have its <ResponseCode> set to 0.\
    \  The response message from the\n   server must have a non-zero <ResponseCode>\
    \ to indicate the result.\n   For example, a response message from a server with\
    \ <ResponseCode> set\n   to RC_SUCCESS indicates that the server has successfully\
    \ fulfilled\n   the client's request.\n"
- title: 2.2.2.3.  <OpFlag>
  contents:
  - "2.2.2.3.  <OpFlag>\n   The <OpFlag> is a 32-bit bit-mask that defines various\
    \ control\n   options for protocol operation.  The following figure shows the\n\
    \   location of each option flag in the <OpFlag> field.\n                    \
    \                          1   1   1   1   1   1\n      0   1   2   3   4   5\
    \   6   7   8   9   0   1   2   3   4   5\n      .---------------------------------------------------------------.\n\
    \      |AT |CT |ENC|REC|CA |CN |KC |PO |RD |    Reserved               |\n   \
    \   |---------------------------------------------------------------|\n      |\
    \                              Reserved                         |\n      '---------------------------------------------------------------'\n\
    \       AT   -  AuThoritative bit.  A request with the AT bit set (to 1)\n   \
    \            indicates that the request should be directed to the\n          \
    \     primary service site (instead of any mirroring sites).  A\n            \
    \   response message with the AT bit set (to 1) indicates\n               that\
    \ the message is returned from a primary server\n               (within the primary\
    \ service site).\n       CT   -  CerTified bit.  A request with the CT bit set\
    \ (to 1) asks\n               the server to sign its response with its digital\n\
    \               signature.  A response with the CT bit set (to 1)\n          \
    \     indicates that the message is signed.  The server must\n               sign\
    \ its response if the request has its CT bit set (to\n               1).  If the\
    \ server fails to provide a valid signature in\n               its response, the\
    \ client should discard the response and\n               treat the request as\
    \ failed.\n       ENC  -  ENCryption bit.  A request with the ENC bit set (to\
    \ 1)\n               requires the server to encrypt its response using the\n \
    \              pre-established session key.\n       REC  -  RECursive bit.  A\
    \ request with the REC bit set (to 1)\n               asks the server to forward\
    \ the query on behalf of the\n               client if the request has to be processed\
    \ by another\n               handle server.  The server may honor the request\
    \ by\n               forwarding the request to the appropriate handle server\n\
    \               and passing on any result back to the client.  The server\n  \
    \             may also deny any such request by sending a response\n         \
    \      with <ResponseCode> set to RC_SERVER_NOT_RESP.\n       CA   -  Cache Authentication.\
    \  A request with the CA bit set (to\n               1) asks the caching server\
    \ (if any) to authenticate any\n               server response (e.g., verifying\
    \ the server's signature)\n               on behalf of the client.  A response\
    \ with the CA bit set\n               (to 1) indicates that the response has been\n\
    \               authenticated by the caching server.\n       CN   -  ContiNuous\
    \ bit.  A message with the CN bit set (to 1)\n               tells the message\
    \ recipient that more messages that are\n               part of the same request\
    \ (or response) will follow.  This\n               happens if a request (or response)\
    \ has data that is too\n               large to fit into any single message and\
    \ has to be\n               fragmented into multiple messages.\n       KC   -\
    \  Keep Connection bit.  A message with the KC bit set\n               requires\
    \ the message recipient to keep the TCP\n               connection open (after\
    \ the response is sent back).  This\n               allows the same TCP connection\
    \ to be used for multiple\n               handle operations.\n       PO   -  Public\
    \ Only bit.  Used by query operations only.  A query\n               request with\
    \ the PO bit set (to 1) indicates that the\n               client is only asking\
    \ for handle values that have the\n               PUB_READ permission.  A request\
    \ with PO bit set to zero\n               asks for all the handle values regardless\
    \ of their read\n               permission.  If any of the handle values require\n\
    \               ADMIN_READ permission, the server must authenticate the\n    \
    \           client as the handle administrator.\n       RD   -  Request-Digest\
    \ bit.  A request with the RD bit set (to 1)\n               asks the server to\
    \ include in its response the message\n               digest of the request. \
    \ A response message with the RD\n               bit set (to 1) indicates that\
    \ the first field in the\n               Message Body contains the message digest\
    \ of the original\n               request.  The message digest can be used to\
    \ check the\n               integrity of the server response.  Details of these\
    \ are\n               discussed later in this document.\n   All other bits in\
    \ the <OpFlag> field are reserved and must be set to\n   zero.\n   In general,\
    \ servers must honor the <OpFlag> specified in the request.\n   If a requested\
    \ option cannot be met, the server should return an\n   error message with the\
    \ proper <ResponseCode> as defined in the\n   previous section.\n"
- title: 2.2.2.4.  <SiteInfoSerialNumber>
  contents:
  - "2.2.2.4.  <SiteInfoSerialNumber>\n   The <SiteInfoSerialNumber> is a two-byte\
    \ unsigned integer.  The\n   <SiteInfoSerialNumber> in a request refers to the\
    \ <SerialNumber> of\n   the HS_SITE value used by the client (to access the server).\
    \  Servers\n   can check the <SiteInfoSerialNumber> in the request to find out\
    \ if\n   the client has up-to-date service information.\n   When possible, the\
    \ server should fulfill a client's request even if\n   the service information\
    \ used by the client is out-of-date.  However,\n   the response message should\
    \ specify the latest version of service\n   information in the <SiteInforSerialNumber>\
    \ field.  Clients with out-\n   of-date service information can update the service\
    \ information from\n   the Global Handle Registry.  If the server cannot fulfill\
    \ a client's\n   request due to expired service information, it should reject\
    \ the\n   request and return an error message with <ResponseCode> set to\n   RC_EXPIRED_SITE_INFO.\n"
- title: 2.2.2.5.  <RecursionCount>
  contents:
  - "2.2.2.5.  <RecursionCount>\n   The <RecursionCount> is a one-byte unsigned integer\
    \ that specifies\n   the number of service recursions.  Service recursion happens\
    \ if the\n   server has to forward the client's request to another server.  Any\n\
    \   request directly from the client must have its <RecursionCount> set\n   to\
    \ 0.  If the server has to send a recursive request on behalf of the\n   client,\
    \ it must increment the <RecursionCount> by 1.  Any response\n   from the server\
    \ must maintain the same <RecursionCount> as the one in\n   the request.  To prevent\
    \ an infinite loop of service recursion, the\n   server should be configurable\
    \ to stop sending a recursive request\n   when the <RecursionCount> reaches a\
    \ certain value.\n"
- title: 2.2.2.6.  <ExpirationTime>
  contents:
  - "2.2.2.6.  <ExpirationTime>\n   The <ExpirationTime> is a 4-byte unsigned integer\
    \ that specifies the\n   time when the message should be considered expired, relative\
    \ to\n   January 1st, 1970 GMT, in seconds.  It is set to zero if no\n   expiration\
    \ is expected.\n"
- title: 2.2.2.7.  <BodyLength>
  contents:
  - "2.2.2.7.  <BodyLength>\n   The <BodyLength> is a 4-byte unsigned integer that\
    \ specifies the\n   number of octets in the Message Body.  The <BodyLength> does\
    \ not\n   count the octets in the Message Header or those in the Message\n   Credential.\n"
- title: 2.2.3.  Message Body
  contents:
  - "2.2.3.  Message Body\n   The Message Body always follows the Message Header.\
    \  The number of\n   octets in the Message Body can be determined from the <BodyLength>\
    \ in\n   the Message Header.  The Message Body may be empty.  The exact format\n\
    \   of the Message Body depends on the <OpCode> and the <ResponseCode> in\n  \
    \ the Message Header.  Details of the Message Body under each <OpCode>\n   and\
    \ <ResponseCode> are described in section 3 of this document.\n   For any response\
    \ message, if the Message Header has its RD bit (in\n   <OpFlag>) set to 1, the\
    \ Message Body must begin with the message\n   digest of the original request.\
    \  The message digest is defined as\n   follows:\n      <RequestDigest> ::= <DigestAlgorithmIdentifier>\n\
    \                          <MessageDigest>\n         where\n            <DigestAlgorithmIdentifier>\n\
    \            An octet that identifies the algorithm used to generate the\n   \
    \         message digest.  If the octet is set to 1, the digest is\n         \
    \   generated using the MD5 [9] algorithm.  If the octet is set\n            to\
    \ 2, SHA-1 [10] algorithm is used.\n            <MessageDigest>\n            The\
    \ message digest itself.  It is calculated upon the\n            Message Header\
    \ and the Message Body of the original request.\n            The length of the\
    \ field is fixed according to the digest\n            algorithm.  For MD5 algorithm,\
    \ the length is 16 octets.  For\n            SHA-1, the length is 20 octets.\n\
    \   The Message Body may be truncated into multiple portions during its\n   transmission\
    \ (e.g., over UDP).  Recipients of such a message may\n   reassemble the Message\
    \ Body from each portion based on the\n   <SequenceNumber> in the Message Envelope.\n"
- title: 2.2.4.  Message Credential
  contents:
  - "2.2.4.  Message Credential\n   The Message Credential is primarily used to carry\
    \ any digital\n   signatures signed by the message issuer.  It may also carry\
    \ the\n   Message Authentication Code (MAC) if a session key has been\n   established.\
    \  The Message Credential is used to protect contents in\n   the Message Header\
    \ and the Message Body from being tampered with\n   during transmission.  The\
    \ format of the Message Credential is\n   designed to be semantically compatible\
    \ with PKCS#7 [5].  Each Message\n   Credential consists of the following fields:\n\
    \      0                   1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      .---------------------------------------------------------------.\n\
    \      |           CredentialLength                                    |\n   \
    \   |---------------------------------------------------------------|\n      |\
    \   Version     |    Reserved   |       Options                 |\n      |---------------------------------------------------------------|\n\
    \      |\n      |   Signer: <Handle, Index>\n      |\n      |---------------------------------------------------------------|\n\
    \      |           Type      (UTF8-String)                             |\n   \
    \   |---------------------------------------------------------------|\n      |\n\
    \      |   SignedInfo: <Length> : 4-byte unsigned integer\n      |           \
    \    DigestAlgorithm: <UTF8-String>\n      |               SignedData: <Length,\
    \ Signature>\n      |\n      '---------------------------------------------------------------'\n\
    \   where\n      <CredentialLength>\n      A 4-byte unsigned integer that specifies\
    \ the number of octets in\n      the Message Credential.  It must be set to zero\
    \ if the message has\n      no Message Credential.\n      <Version>\n      An\
    \ octet that identifies the version number of the Message\n      Credential. \
    \ The version number specified in this document is\n      zero.\n      <Reserved>\n\
    \      An octet that must be set to zero.\n      <Options>\n      Two octets reserved\
    \ for various cryptography options.\n      <Signer> ::= <HANDLE>\n           \
    \        <INDEX>\n      A reference to a handle value in terms of the <HANDLE>\
    \ and the\n      <INDEX> of the handle value.  The handle value may contain the\n\
    \      public key, or the X.509 certificate, that can be used to\n      validate\
    \ the digital signature.\n      <Type>\n      A UTF8-String that indicates the\
    \ type of content in the\n      <SignedInfo> field (described below).  It may\
    \ contain HS_DIGEST if\n      <SignedInfo> contains the message digest, or HS_MAC\
    \ if\n      <SignedInfo> contains the Message Authentication Code (MAC).  The\n\
    \      <Type> field will specify the signature algorithm identifier if\n     \
    \ <SignedInfo> contains a digital signature.  For example, with the\n      <Type>\
    \ field set to HS_SIGNED_PSS, the <SignedInfo> field will\n      contain the digital\
    \ signature generated using the RSA-PSS\n      algorithm [16].  If the <Type>\
    \ field is set to HS_SIGNED, the\n      <SignedInfo> field will contain the digital\
    \ signature generated\n      from a DSA public key pair.\n      <SignedInfo> ::=\
    \  <Length>\n                        <DigestAlgorithm>\n                     \
    \   <SignedData>\n         where\n            <Length>\n            A 4-byte unsigned\
    \ integer that specifies the number of\n            octets in the <SignedInfo>\
    \ field.\n            <DigestAlgorithm>\n            A UTF8-String that refers\
    \ to the digest algorithm used to\n            generate the digital signature.\
    \  For example, the value\n            \"SHA-1\" indicates that the SHA-1 algorithm\
    \ is used to\n            generate the message digest for the signature.\n   \
    \         <SignedData> ::=  <LENGTH>\n                            <SIGNATURE>\n\
    \               where\n                  <LENGTH>\n                  A 4-byte\
    \ unsigned integer that specifies the number of\n                  octets in the\
    \ <SIGNATURE>.\n                  <SIGNATURE>\n                  Contains the\
    \ digital signature or the MAC over the\n                  Message Header and\
    \ Message Body.  The syntax and\n                  semantics of the signature\
    \ depend on the <Type> field\n                  and the public key referenced\
    \ in the <Signer> field.\n                  For example, if the <Type> field is\
    \ \"HS_SIGNED\" and\n                  the public key referred to by the <Signer>\
    \ field is\n                  a DSA [6] public key, the signature will be the\n\
    \                  ASN.1 octet string representation of the parameter R\n    \
    \              and S as described in [7].  If the <Signer> field\n           \
    \       refers to a handle value that contains a X.509\n                  certificate,\
    \ the signature should be encoded according\n                  to RFC 3279 and\
    \ RFC 3280 [14, 15].\n   The Message Credential may contain the message authentication\
    \ code\n   (MAC) generated using a pre-established session key.  In this case,\n\
    \   the <Signer> field must set its <HANDLE> to a zero-length UTF8-String\n  \
    \ and its <INDEX> to the <SessionId> specified in the Message Envelope.\n   The\
    \ <Signature> field must contain the MAC in its <SIGNATURE> field.\n   The MAC\
    \ is the result of the one-way hash over the concatenation of\n   the session\
    \ key, the <Message Header>, the <MessageBody>, and the\n   session key again.\n\
    \   The Message Credential in a response message may contain the digital\n   signature\
    \ signed by the server.  The server's public key can be found\n   in the service\
    \ information used by the client to send the request to\n   the server.  In this\
    \ case, the client should ignore any reference in\n   the <Signer> field and use\
    \ the public key in the service information\n   to verify the signature.\n   The\
    \ Message Credential can also be used for non-repudiation purposes.\n   This happens\
    \ if the Message Credential contains a server's digital\n   signature.  The signature\
    \ may be used as evidence to demonstrate that\n   the server has rendered its\
    \ service in response to a client's\n   request.\n   The Message Credential provides\
    \ a mechanism for safe transmission of\n   any message between the client and\
    \ server.  Any message whose Message\n   Header and Message Body complies with\
    \ its Message Credential suggests\n   that the message indeed comes from its originator\
    \ and assures that\n   the message has not been tampered with during its transmission.\n"
- title: 2.3.  Message Transmission
  contents:
  - "2.3.  Message Transmission\n   A large message may be truncated into multiple\
    \ packets during its\n   transmission.  For example, to fit the size limit of\
    \ a UDP packet,\n   the message issuer must truncate any large message into multiple\
    \ UDP\n   packets before its transmission.  The message recipient must\n   reassemble\
    \ the message from these truncated packets before further\n   processing.  Message\
    \ truncation must be carried out over the entire\n   message except the Message\
    \ Envelope.  A new Message Envelope has to\n   be inserted in front of each truncated\
    \ packet before its\n   transmission.  For example, a large message that consists\
    \ of\n      .--------------------------------------------------------.\n     \
    \ |  Message Envelope  |  Message Header, Body, Credential |\n      '--------------------------------------------------------'\n\
    \   may be truncated into:\n         .--------------------------------------------.\n\
    \         |  Message Envelope 1 |  Truncated_Packet 1  |\n         '--------------------------------------------'\n\
    \         .--------------------------------------------.\n         |  Message\
    \ Envelope 2 |  Truncated_Packet 2  |\n         '--------------------------------------------'\n\
    \            ......\n         .--------------------------------------------.\n\
    \         |  Message Envelope N |  Truncated Packet N  |\n         '--------------------------------------------'\n\
    \   where the \"Truncated_packet 1\", \"Truncated_packet 2\", ..., and\n   \"\
    Truncated_packet N\" result from truncating the Message Header, the\n   Message\
    \ Body and the Message Credential.  Each \"Message Envelope i\"\n   (inserted\
    \ before each truncation) must set its TC flag to 1 and\n   maintain the proper\
    \ sequence count (in the <SequenceNumber>).  Each\n   \"Message Envelope i\" must\
    \ also set its <MessageLength> to reflect the\n   size of the packet.  The recipient\
    \ of these truncated packets can\n   reassemble the message by concatenating these\
    \ packets based on their\n   <SequenceNumber>.\n"
- title: 3.  Handle Protocol Operations
  contents:
  - "3.  Handle Protocol Operations\n   This section describes the details of each\
    \ protocol operation in\n   terms of messages exchanged between the client and\
    \ server.  It also\n   defines the format of the Message Body according to each\
    \ <OpCode> and\n   <ResponseCode> in the Message Header.\n"
- title: 3.1.  Client Bootstrapping
  contents:
  - '3.1.  Client Bootstrapping

    '
- title: 3.1.1.  Global Handle Registry and its Service Information
  contents:
  - "3.1.1.  Global Handle Registry and its Service Information\n   The service information\
    \ for the Global Handle Registry (GHR) allows\n   clients to contact the GHR to\
    \ find out the responsible service\n   components for their handles.  The service\
    \ information is a set of\n   HS_SITE values assigned to the root handle \"0.NA/0.NA\"\
    \ and is also\n   called the root service information.  The root service information\n\
    \   may be distributed along with the client software, or be downloaded\n   from\
    \ the Handle System website at http://www.handle.net.\n   Changes to the root\
    \ service information are identified by the\n   <SerialNumber> in the HS_SITE\
    \ values.  A server at GHR can find out\n   if the root service information used\
    \ by the client is outdated by\n   checking the <SerialNumber> in the client's\
    \ request.  The client\n   should update the root service information if the <ResponseCode>\
    \ of\n   the response message is RC_EXPIRED_SITE_INFO.  Clients may obtain the\n\
    \   most up-to-date root service information from the root handle.  The\n   GHR\
    \ must sign the root service information using the public key\n   specified in\
    \ the outdated service information (identified in the\n   client's request) so\
    \ that the client can validate the signature.\n"
- title: 3.1.2.  Locating the Handle System Service Component
  contents:
  - "3.1.2.  Locating the Handle System Service Component\n   Each handle under the\
    \ Handle System is managed by a unique handle\n   service component (e.g., LHS).\
    \  For any given handle, the responsible\n   service component (and its service\
    \ information) can be found from its\n   naming authority handle.  Before resolving\
    \ any given handle, the\n   client needs to find the responsible service component\
    \ by querying\n   the naming authority handle from the GHR.\n   For example, to\
    \ find the responsible LHS for the handle \"1000/abc\",\n   client software can\
    \ query the GHR for the HS_SITE (or HS_SERV) values\n   assigned to the naming\
    \ authority handle \"0.NA/1000\".  The set of\n   HS_SITE values provides the\
    \ service information of the LHS that\n   manages every handle under the naming\
    \ authority \"1000\".  If no\n   HS_SITE values are found, the client can check\
    \ if there is any\n   HS_SERV value assigned to the naming authority handle. \
    \ The HS_SERV\n   value provides the service handle that maintains the service\n\
    \   information for the LHS.  Service handles are used to manage the\n   service\
    \ information shared by different naming authorities.\n   It is possible that\
    \ the naming authority handle requested by the\n   client does not reside at the\
    \ GHR.  This happens when naming\n   authority delegation takes place.  Naming\
    \ authority delegation\n   happens when a naming authority delegates an LHS to\
    \ manage all its\n   child naming authorities.  In this case, the delegating naming\n\
    \   authority must contain the service information, a set of\n   HS_NA_DELEGATE\
    \ values, of the LHS that manages its child naming\n   authorities.\n   All top-level\
    \ naming authority handles must be registered and managed\n   by the GHR.  When\
    \ a server at the GHR receives a request for a naming\n   authority that has been\
    \ delegated to an LHS, it must return a message\n   with the <ResponseCode> set\
    \ to RC_NA_DELEGATE, along with the\n   HS_NA_DELAGATE values from the nearest\
    \ ancestor naming authority.\n   The client can query the LHS described by the\
    \ HS_NA_DELAGATE values\n   for the delegated naming authority handle.  In practice,\
    \ the ancestor\n   naming authority should make itself available to any handle\
    \ server\n   within the GHR, by replicating itself at the time of delegation.\n\
    \   This will prevent any cross-queries among handle servers (within a\n   service\
    \ site) when the naming authority in query and the ancestor\n   naming authority\
    \ do not hash into the same handle server.\n"
- title: 3.1.3.  Selecting the Responsible Server
  contents:
  - "3.1.3.  Selecting the Responsible Server\n   Each handle service component is\
    \ defined in terms of a set of HS_SITE\n   values.  Each of these HS_SITE values\
    \ defines a service site within\n   the service component.  A service site may\
    \ consist of a group of\n   handle servers.  For any given handle, the responsible\
    \ handle server\n   within the service component can be found following this procedure:\n\
    \      1. Select a preferred service site.\n         Each service site is defined\
    \ in terms of an HS_SITE value.  The\n         HS_SITE value may contain a <Description>\
    \ or other attributes\n         (under the <AttributeList>) to help the selection.\
    \  Clients\n         must select the primary service site for any administrative\n\
    \         operations.\n      2. Locate the responsible server within the service\
    \ site.\n         This can be done as follows: Convert every ASCII character in\n\
    \         the handle to its upper case.  Calculate the MD5 hash of the\n     \
    \    converted handle string according to the <HashOption> given in\n        \
    \ the HS_SITE value.  Take the last 4 bytes of the hash result as\n         a\
    \ signed integer.  Modulo the absolute value of the integer by\n         the <NumOfServer>\
    \ given in the HS_SITE value.  The result is\n         the sequence number of\
    \ the <ServerRecord> listed in the HS_SITE\n         value.  For example, if the\
    \ result of the modulation is 2, the\n         third <ServerRecord> listed in\
    \ the <HS_SITE> should be\n         selected.  The <ServerRecord> defines the\
    \ responsible handle\n         server for the given handle.\n"
- title: 3.2.  Query Operation
  contents:
  - "3.2.  Query Operation\n   A query operation consists of a client sending a query\
    \ request to the\n   responsible handle server and the server returning the query\
    \ result\n   to the client.  Query requests are used to retrieve handle values\n\
    \   assigned to any given handle.\n"
- title: 3.2.1.  Query Request
  contents:
  - "3.2.1.  Query Request\n   The Message Header of any query request must set its\
    \ <OpCode> to\n   OC_RESOLUTION (defined in section 2.2.2.1) and <ResponseCode>\
    \ to 0.\n   The Message Body for any query request is defined as follows:\n  \
    \    <Message Body of Query Request>  ::=  <Handle>\n                        \
    \                    <IndexList>\n                                           \
    \ <TypeList>\n         where\n            <Handle>\n            A UTF8-String\
    \ (as defined in section 2.1.4) that specifies\n            the handle to be resolved.\n\
    \            <IndexList>\n            A 4-byte unsigned integer followed by an\
    \ array of 4-byte\n            unsigned integers.  The first integer indicates\
    \ the number\n            of integers in the integer array.  Each number in the\n\
    \            integer array is a handle value index and refers to a handle\n  \
    \          value to be retrieved.  The client sets the first integer to\n    \
    \        zero (followed by an empty array) to ask for all the handle\n       \
    \     values regardless of their index.\n            <TypeList>\n            A\
    \ 4-byte unsigned integer followed by a list of UTF8-\n            Strings.  The\
    \ first integer indicates the number of\n            UTF8-Strings in the list\
    \ that follows.  Each UTF8-String in\n            the list specifies a data type.\
    \  This tells the server to\n            return all handle values whose data type\
    \ is listed in the\n            list.  If a UTF8-String ends with the '.' (0x2E)\
    \ character,\n            the server must return all handle values whose data\
    \ type is\n            under the type hierarchy specified in the UTF8-String.\
    \  The\n            <TypeList> may contain no UTF8-String if the first integer\n\
    \            is 0.  In this case, the server must return all handle\n        \
    \    values regardless of their data type.\n   If a query request does not specify\
    \ any index or data type and the PO\n   flag (in the Message Header) is set, the\
    \ server will return all the\n   handle values that have the PUBLIC_READ permission.\
    \  Clients can also\n   send queries without the PO flag set.  In this case, the\
    \ server will\n   return all the handle values with PUBLIC_READ permission and\
    \ all the\n   handle values with ADMIN_READ permission.  If the query requests\
    \ a\n   specific handle value via the value index and the value does not have\n\
    \   PUBLIC_READ permission, the server should accept the request (and\n   authenticate\
    \ the client) even if the request has its PO flag set.\n   If a query consists\
    \ of a non-empty <IndexList> but an empty\n   <TypeList>, the server should only\
    \ return those handle values whose\n   indexes are listed in the <IndexList>.\
    \  Likewise, if a query consists\n   of a non-empty <TypeList> but an empty <IndexList>,\
    \ the server should\n   only return those handle values whose data types are listed\
    \ in the\n   <TypeList>.\n   When both <IndexList> and <TypeList> fields are non-empty,\
    \ the server\n   should return all handle values whose indexes are listed in the\n\
    \   <IndexList> AND all handle values whose data types are listed in the\n   <TypeList>.\n"
- title: 3.2.2.  Successful Query Response
  contents:
  - "3.2.2.  Successful Query Response\n   The Message Header of any query response\
    \ must set its <OpCode> to\n   OC_RESOLUTION.  A successful query response must\
    \ set its\n   <ResponseCode> to RC_SUCCESS.\n   The message body of the successful\
    \ query response is defined as\n   follows:\n      <Message Body of Successful\
    \ Query Response> ::= [<RequestDigest>]\n                                    \
    \                   <Handle>\n                                               \
    \        <ValueList>\n         where\n            <RequestDigest>\n          \
    \  Optional field as defined in section 2.2.3.\n            <Handle>\n       \
    \     A UTF8-String that specifies the handle queried by the\n            client.\n\
    \            <ValueList>\n            A 4-byte unsigned integer followed by a\
    \ list of handle\n            values.  The integer specifies the number of handle\
    \ values\n            in the list.  The encoding of each handle value follows\
    \ the\n            specification given in [2] (see section 3.1).  The integer\n\
    \            is set to zero if there is no handle value that satisfies\n     \
    \       the query.\n"
- title: 3.2.3.  Unsuccessful Query Response
  contents:
  - "3.2.3.  Unsuccessful Query Response\n   If a server cannot fulfill a client's\
    \ request, it must return an\n   error message.  The general format for any error\
    \ message from the\n   server is specified in section 3.3 of this document.\n\
    \   For example, a server must return an error message if the queried\n   handle\
    \ does not exist in its database.  The error message will have\n   an empty message\
    \ body and have its <ResponseCode> set to\n   RC_HANDLE_NOT_FOUND.\n   Note that\
    \ a server should NOT return an RC_HANDLE_NOT_FOUND message\n   if the server\
    \ is not responsible for the handle being queried.  It is\n   possible that the\
    \ queried handle exists but is managed by another\n   handle server (under some\
    \ other handle service).  When this happens,\n   the server should either send\
    \ a service referral (see section 3.4) or\n   simply return an error message with\
    \ <ResponseCode> set to\n   RC_SERVER_NOT_RESP.\n   The server may return an error\
    \ message with <ResponseCode> set to\n   RC_SERVER_BUSY if the server is too busy\
    \ to process the request.\n   Like RC_HANDLE_NOT_FOUND, an RC_SERVER_BUSY message\
    \ also has an empty\n   message body.\n   Servers should return an RC_ACCESS_DENIED\
    \ message if the request asks\n   for a specific handle value (via the handle\
    \ value index) that has\n   neither PUBLIC_READ nor ADMIN_READ permission.\n \
    \  A handle Server may ask its client to authenticate itself as the\n   handle\
    \ administrator during the resolution.  This happens if any\n   handle value in\
    \ query has ADMIN_READ permission, but no PUBLIC_READ\n   permission.  Details\
    \ of client authentication are described later in\n   this document.\n"
- title: 3.3.  Error Response from Server
  contents:
  - "3.3.  Error Response from Server\n   A handle server will return an error message\
    \ if it encounters an\n   error when processing a request.  Any error response\
    \ from the server\n   must maintain the same <OpCode> (in the message header)\
    \ as the one in\n   the original request.  Each error condition is identified\
    \ by a unique\n   <ResponseCode> as defined in section 2.2.2.2 of this document.\n\
    \   The Message Body of an error message may be empty.  Otherwise it\n   consists\
    \ of the following data fields (unless otherwise specified):\n      <Message Body\
    \ of Error Response from Server> ::= [<RequestDigest>]\n                     \
    \                                   <ErrorMessage>\n                         \
    \                              [ <IndexList> ]\n         where\n            <RequestDigest>\n\
    \            Optional field as defined in section 2.2.3.\n            <ErrorMessage>\n\
    \            A UTF8-String that explains the error.\n            <IndexList>\n\
    \            An optional field.  When not empty, it consists of a 4-byte\n   \
    \         unsigned integer followed by a list of handle value indexes.\n     \
    \       The first integer indicates the number of indexes in the\n           \
    \ list.  Each index in the list is a 4-byte unsigned integer\n            that\
    \ refers to a handle value that contributed to the error.\n            An example\
    \ would be a server that is asked to add three\n            handle values, with\
    \ indexes 1, 2, and 3, and handle values\n            with indexes of 1 and 2\
    \ already in existence.  In this case,\n            the server could return an\
    \ error message with <REsponseCode>\n            set to RC_VALUE_ALREADY_EXIST\
    \ and add index 1 and 2 to the\n            <IndexList>.  Note that the server\
    \ is not obligated to\n            return the complete list of handle value indexes\
    \ that may\n            have caused the error.\n"
- title: 3.4.  Service Referral
  contents:
  - "3.4.  Service Referral\n   A handle server may receive requests for handles that\
    \ are managed by\n   some other handle server or service.  When this happens,\
    \ the server\n   has the option to either return a referral message that directs\
    \ the\n   client to the proper handle service, or simply return an error\n   message\
    \ with <ResponseCode> set to RC_SERVER_NOT_RESP.  Service\n   referral also happens\
    \ when ownership of handles moves from one handle\n   service to another.  It\
    \ may also be used by any local handle service\n   to delegate its service into\
    \ multiple service layers.\n   The Message Header of a service referral must maintain\
    \ the same\n   <OpCode> as the one in the original request and set its\n   <ResponseCode>\
    \ to RC_SERVICE_REFERRAL.\n   The Message Body of any service referral is defined\
    \ as follows:\n      <Message Body of Service Referral> ::= [ <RequestDigest>\
    \ ]\n                                               <ReferralHandle>\n       \
    \                                      [ <ValueList> ]\n         where\n     \
    \       <RequestDigest>\n            Optional field as defined in section 2.2.3.\n\
    \            <ReferralHandle>\n            A UTF8-String that identifies the handle\
    \ (e.g., a service\n            handle) that maintains the referral information\
    \ (i.e., the\n            service information of the handle service in which this\n\
    \            refers).  If the <ReferralHandle> is set to \"0.NA/0.NA\",\n    \
    \        it is referring the client to the GHR.\n            <ValueList>\n   \
    \         An optional field that must be empty if the <ReferralHandle>\n     \
    \       is provided.  When not empty, it consists of a 4-byte\n            unsigned\
    \ integer, followed by a list of HS_SITE values.  The\n            integer specifies\
    \ the number of HS_SITE values in the list.\n   Unlike regular query responses\
    \ that may consist of handle values of\n   any data type, a service referral can\
    \ only have zero or more HS_SITE\n   values in its <ValueList>.  The <ReferralHandle>\
    \ may contain an empty\n   UTF8-String if the HS_SITE values in the <ValueList>\
    \ are not\n   maintained by any handle.\n   Care must be taken by clients to avoid\
    \ any loops caused by service\n   referrals.  It is also the client's responsibility\
    \ to authenticate\n   the service information obtained from the service referral.\
    \  A client\n   should always use its own copy of the GHR service information\
    \ if the\n   <ReferralHandle> is set to \"0.NA/0.NA\".\n"
- title: 3.5.  Client Authentication
  contents:
  - "3.5.  Client Authentication\n   Clients are asked to authenticate themselves\
    \ as handle administrators\n   when querying for any handle value with ADMIN_READ\
    \ but no PUBLIC_READ\n   permission.  Client authentication is also required for\
    \ any handle\n   administration requests that require administrator privileges.\
    \  This\n   includes adding, removing, or modifying handles or handle values.\n\
    \   Client authentication consists of multiple messages exchanged between\n  \
    \ the client and server.  Such messages include the challenge from the\n   server\
    \ to the client to authenticate the client, the challenge-\n   response from the\
    \ client in response to the server's challenge, and\n   the verification request\
    \ and response message if secret key\n   authentication takes place.  Messages\
    \ exchanged during the\n   authentication are correlated via a unique <SessionId>\
    \ assigned by\n   the server.  For each authentication session, the server needs\
    \ to\n   maintain the state information that includes the server's challenge,\n\
    \   the challenge-response from the client, as well as the original\n   client\
    \ request.\n   The authentication starts with a response message from the server\n\
    \   that contains a challenge to the client.  The client must respond to\n   the\
    \ challenge with a challenge-response message.  The server\n   validates the challenge-response,\
    \ either by verifying the digital\n   signature inside the challenge-response,\
    \ or by sending a verification\n   request to another handle server (herein referred\
    \ to as the\n   verification server), that maintains the secret key for the\n\
    \   administrator.  The purpose of the challenge and the challenge-\n   response\
    \ is to prove to the server that the client possesses the\n   private key (or\
    \ the secret key) of the handle administrator.  If the\n   authentication fails,\
    \ an error response will be sent back with the\n   <ResponseCode> set to RC_AUTHEN_FAILED.\n\
    \   Upon successful client authentication, the server must also make sure\n  \
    \ that the administrator is authorized for the request.  If the\n   administrator\
    \ has sufficient privileges, the server will process the\n   request and send\
    \ back the result.  If the administrator does not have\n   sufficient privileges,\
    \ the server will return an error message with\n   <ResponseCode> set to RC_NOT_AUTHORIZED.\n\
    \   The following sections provide details of each message exchanged\n   during\
    \ the authentication process.\n"
- title: 3.5.1.  Challenge from Server to Client
  contents:
  - "3.5.1.  Challenge from Server to Client\n   The Message Header of the CHALLENGE\
    \ must keep the same <OpCode> as\n   the original request and set the <ResponseCode>\
    \ to RC_AUTH_NEEDED.\n   The server must assign a non-zero unique <SessionId>\
    \ in the Message\n   Envelope to keep track of the authentication.  It must also\
    \ set the\n   RD flag of the <OpFlag> (see section 2.2.2.3) in the Message Header,\n\
    \   regardless of whether the original request had the RD bit set or not.\n  \
    \ The Message Body of the server's CHALLENGE is defined as follows:\n      <Message\
    \ Body of Server's Challenge> ::=  <RequestDigest>\n                         \
    \                       <Nonce>\n         where\n            <RequestDigest>\n\
    \            Message Digest of the request message, as defined in section\n  \
    \          2.2.3.\n            <Nonce>\n            A 4-byte unsigned integer\
    \ followed by a random string\n            generated by the server via a secure\
    \ random number\n            generator.  The integer specifies the number of octets\
    \ in\n            the random string.  The size of the random string should be\n\
    \            no less than 20 octets.\n   Note that the server will not sign the\
    \ challenge if the client did\n   not request the server to do so.  If the client\
    \ worries about whether\n   it is speaking to the right server, it may ask the\
    \ server to sign the\n   <Challenge>.  If the client requested the server to sign\
    \ the\n   <Challenge> but failed to validate the server's signature, the client\n\
    \   should discard the server's response and reissue the request to the\n   server.\n"
- title: 3.5.2.  Challenge-Response from Client to Server
  contents:
  - "3.5.2.  Challenge-Response from Client to Server\n   The Message Header of the\
    \ CHALLENGE_RESPONSE must set its <OpCode> to\n   OC_CHALLENGE_RESPONSE and its\
    \ <ResponseCode> to 0.  It must also keep\n   the same <SessionId> (in the Message\
    \ Envelope) as specified in the\n   challenge from the server.\n   The Message\
    \ Body of the CHALLENGE_RESPONSE request is defines as\n   follows:\n      <Message\
    \ Body of CHALLENGE_RESPONSE> ::=  <AuthenticationType>\n                    \
    \                            <KeyHandle>\n                                   \
    \             <KeyIndex>\n                                                <ChallengeResponse>\n\
    \         where\n            <AuthenticationType>\n            A UTF8-String that\
    \ identifies the type of authentication key\n            used by the client. \
    \ For example, the field is set to\n            \"HS_SECKEY\" if the client chooses\
    \ to use a secret key for\n            its authentication.  The field is set to\
    \ \"HS_PUBKEY\" if a\n            public key is used instead.\n            <KeyHandle>\n\
    \            A UTF8-String that identifies the handle that holds the\n       \
    \     public or secret key of the handle administrator.\n            <KeyIndex>\n\
    \            A 4-byte unsigned integer that specifies the index of the\n     \
    \       handle value (of the <KeyHandle>) that holds the public or\n         \
    \   secret key of the administrator.\n            <ChallengeResponse>\n      \
    \      Contains either the Message Authentication Code (MAC) or the\n        \
    \    digital signature over the challenge from the server.  If\n            the\
    \ <AuthenticationType> is \"HS_SECKEY\", the\n            <ChallengeResponse>\
    \ consists of an octet followed by the\n            MAC.  The octet identifies\
    \ the algorithm used to generate\n            the MAC.  For example, if the first\
    \ octet is set to 0x01,\n            the MAC is generated by\n               MD5_Hash(<SecretKey>\
    \ + <ServerChallenge> + <SecretKey>)\n            where the <SecretKey> is the\
    \ administrator's secret key\n            referenced by the <KeyHandle> and <KeyIndex>.\
    \  The\n            <ServerChallenge> is the Message Body portion of the\n   \
    \         server's challenge.  If the first octet in the\n            <ChallengeResponse>\
    \ is set to 0x02, the MAC is generated\n            using\n               SHA-1_Hash(<SecretKey>\
    \ + <ServerChallenge> + <SecretKey>)\n            A more secure approach is to\
    \ use HMAC [17] for the\n            <ChallengeResponse>.  The HMAC can be generated\
    \ using the\n            <SecretKey> and <ServerChallenge>.  A <ChallengeResponse>\n\
    \            with its first octet set to 0x11 indicates that the HMAC\n      \
    \      is generated using the MD5 algorithm.  Likewise, a\n            <ChallengeResponse>\
    \ with its first octet set to 0x12\n            indicates that the HMAC is generated\
    \ using the SHA-1\n            algorithm.\n            If the <AuthenticationType>\
    \ is \"HS_PUBKEY\", the\n            <ChallengeResponse> contains the digital\
    \ signature over the\n            Message Body portion of the server's challenge.\
    \  The\n            signature is generated in two steps: First, a one-way hash\n\
    \            value is computed over the blob that is to be signed.\n         \
    \   Second, the hash value is signed using the private key.\n            The signature\
    \ consists of a UTF8-String that specifies the\n            digest algorithm used\
    \ for the signature, followed by the\n            signature over the server's\
    \ challenge.  The <KeyHandle> and\n            <KeyIndex> refers to the administrator's\
    \ public key that can\n            be used to verify the signature.\n   Handle\
    \ administrators are defined in terms of HS_ADMIN values\n   assigned to the handle.\
    \  Each HS_ADMIN value defines the set of\n   privileges granted to the administrator.\
    \  It also provides the\n   reference to the authentication key that can be used\
    \ to authenticate\n   the administrator.  The reference can be made directly if\
    \ the\n   <AdminRef> field of the HS_ADMIN value refers to the handle value\n\
    \   that holds the authentication key.  Indirect reference to the\n   authentication\
    \ key can also be made via administrator groups.  In\n   this case, the <AdminRef>\
    \ field may refer to a handle value of type\n   HS_VLIST.  An HS_VLIST value defines\
    \ an administrator group via a\n   list of handle value references, each of which\
    \ refers to the\n   authentication key of a handle administrator.\n   For handles\
    \ with multiple HS_ADMIN values, the server will have to\n   check each of those\
    \ with sufficient privileges to see if its\n   <AdminRef> field matches the <KeyHandle>\
    \ and <KeyIndex>.  If no match\n   is found, but there are administrator groups\
    \ defined, the server must\n   check if the <KeyHandle> and <KeyIndex> belong\
    \ to any of the\n   administrator groups that have sufficient privileges.  An\n\
    \   administrator group may contain another administrator group as a\n   member.\
    \  Servers must be careful to avoid infinite loops when\n   navigating these groups.\n\
    \   If the <KeyHandle> and <KeyIndex> are not referenced by any of the\n   HS_ADMIN\
    \ values, or the administrator group that has sufficient\n   privileges, the server\
    \ will return an error message with\n   <ResponseCode> set to RC_NOT_AUTHORIZED.\
    \  Otherwise, the server will\n   continue to authenticate the client as follows:\n\
    \   If the <AuthenticationType> is \"HS_PUBKEY\", the server will retrieve\n \
    \  the administrator's public key based on the <KeyHandle> and\n   <KeyIndex>.\
    \  The public key can be used to verify the\n   <ChallengeResponse> against the\
    \ server's <Challenge>.  If the\n   <ChallengeResponse> matches the <Challenge>,\
    \ the server will continue\n   to process the original request and return the\
    \ result.  Otherwise,\n   the server will return an error message with <ResponseCode>\
    \ set to\n   RC_AUTHENTICATION_FAILED.\n   If the <AuthenticationType> is \"HS_SECKEY\"\
    , the server will have to\n   send a verification request to the verification\
    \ server; that is, the\n   handle server that manages the handle referenced by\
    \ the <KeyHandle>.\n   The verification request and its response are defined in\
    \ the\n   following sections.  The verification server will verify the\n   <ChallengeResponse>\
    \ against the <Challenge> on behalf of the handle\n   server.\n"
- title: 3.5.3.  Challenge-Response Verification-Request
  contents:
  - "3.5.3.  Challenge-Response Verification-Request\n   The message header of the\
    \ VERIFICATION_REQUEST must set its <OpCode>\n   to OC_VERIFY_CHALLENGE and the\
    \ <ResponseCode> to 0.\n   The message body of the Verification-Request is defined\
    \ as follows:\n      <Message Body of VERIFICATION_REQUEST> ::=  <KeyHandle>\n\
    \                                                 <KeyIndex>\n               \
    \                                  <Challenge>\n                             \
    \                    <ChallengeResponse>\n         where\n            <KeyHandle>\n\
    \            A UTF8-String that refers to the handle that holds the\n        \
    \    secret key of the administrator.\n            <KeyIndex>\n            A 4-byte\
    \ unsigned integer that is the index of the handle\n            value that holds\
    \ the secret key of the administrator.\n            <Challenge>\n            The\
    \ message body of the server's challenge, as described in\n            section\
    \ 3.5.1.\n            <ChallengeResponse>\n            The <ChallengeResponse>\
    \ from the client in response to\n            the server's <Challenge>, as defined\
    \ in section 3.5.2.\n   Any Challenge-Response Verification-Request must set its\
    \ CT bit in\n   the message header.  This is to ensure that the verification server\n\
    \   will sign the Verification-Response as specified in the next section.\n"
- title: 3.5.4.  Challenge-Response Verification-Response
  contents:
  - "3.5.4.  Challenge-Response Verification-Response\n   The Verification-Response\
    \ tells the requesting handle server whether\n   the <ChallengeResponse> matches\
    \ the <Challenge> in the Verification-\n   Request.\n   The Message Header of\
    \ the Verification-Response must set its\n   <ResponseCode> to RC_SUCCESS whether\
    \ or not the <ChallengeResponse>\n   matches the <Challenge>.  The RD flag in\
    \ the <OpFlag> field should\n   also be set (to 1) since the <RequestDigist> will\
    \ be mandatory in the\n   Message Body.\n   The Message Body of the Verification-Response\
    \ is defined as follows:\n      <Challenge-Response Verification-Response>\n \
    \                               ::= <RequestDigest>\n                        \
    \            <VerificationResult>\n         where\n            <RequestDigest>\n\
    \            Contains the message digest of the Verification-Request.\n      \
    \      <VerificationResult>\n            An octet that is set to 1 if the <ChallengeResponse>\n\
    \            matches the <Challenge>.  Otherwise it must be set to\n         \
    \   0.\n   The verification server may return an error with <ResponseCode> set\n\
    \   to RC_AUTHEN_FAILED if it cannot perform the verification (e.g., the\n   <KeyHandle>\
    \ does not exist, or the <KeyHandle> and <KeyIndex> refer\n   to an invalid handle\
    \ value).  When this happens, the server that\n   performs the client authentication\
    \ should relay the same error\n   message back to the client.\n"
- title: 3.6.  Handle Administration
  contents:
  - "3.6.  Handle Administration\n   The Handle System protocol supports a set of\
    \ handle administration\n   functions that include adding, deleting, and modifying\
    \ handles or\n   handle values.  Before fulfilling any administration request,\
    \ the\n   server must authenticate the client as the handle administrator that\n\
    \   is authorized for the administrative operation.  Handle\n   administration\
    \ can only be carried out by the primary handle server.\n"
- title: 3.6.1.  Add Handle Value(s)
  contents:
  - "3.6.1.  Add Handle Value(s)\n   Clients add values to existing handles by sending\
    \ ADD_VALUE requests\n   to the responsible handle server.  The Message Header\
    \ of the\n   ADD_VALUE request must set its <OpCode> to OC_ADD_VALUE.\n   The\
    \ Message Body of the ADD_VALUE request is encoded as follows:\n      <Message\
    \ Body of ADD_VALUE Request> ::=  <Handle>\n                                 \
    \              <ValueList>\n         where\n            <Handle>\n           \
    \ A UTF8-String that specifies the handle.\n            <ValueList>\n        \
    \    A 4-byte unsigned integer followed by a list of handle\n            values.\
    \  The integer indicates the number of handle values\n            in the list.\n\
    \   The server that receives the ADD_VALUE request must first\n   authenticate\
    \ the client as the administrator with the ADD_VALUE\n   privilege.  Upon successful\
    \ authentication, the server will proceed\n   to add each value in the <ValueList>\
    \ to the <Handle>.  If successful,\n   the server will return an RC_SUCCESS message\
    \ to the client.\n   Each ADD_VALUE request must be carried out as a transaction.\
    \  If\n   adding any value in the <ValueList> raises an error, the entire\n  \
    \ operation must be rolled back.  For any failed ADD_VALUE request,\n   none of\
    \ the values in the <ValueList> should be added to the\n   <Handle>.  The server\
    \ must also send a response to the client that\n   explains the error.  For example,\
    \ if a value in the <ValueList> has\n   the same index as one of the existing\
    \ handle values, the server will\n   return an error message that has the <ResponseCode>\
    \ set to\n   RC_VALUE_ALREADY_EXISTS.\n   ADD_VALUE requests can also be used\
    \ to add handle administrators.\n   This happens if the <ValueList> in the ADD_VALUE\
    \ request contains any\n   HS_ADMIN values.  The server must authenticate the\
    \ client as an\n   administrator with the ADD_ADMIN privilege before fulfilling\
    \ such\n   requests.\n   An ADD_VALUE request will result in an error if the requested\
    \ handle\n   does not exist.  When this happens, the server will return an error\n\
    \   message with <ResponseCode> set to RC_HANDLE_NOT_EXIST.\n"
- title: 3.6.2.  Remove Handle Value(s)
  contents:
  - "3.6.2.  Remove Handle Value(s)\n   Clients remove existing handle values by sending\
    \ REMOVE_VALUE\n   requests to the responsible handle server.  The Message Header\
    \ of the\n   REMOVE_VALUE request must set its <OpCode> to OC_REMOVE_VALUE.\n\
    \   The Message Body of any REMOVE_VALUE request is encoded as follows:\n    \
    \  <Message Body of REMOVE_VALUE Request> ::=  <Handle>\n                    \
    \                              <IndexList>\n         where\n            <Handle>\n\
    \            A UTF8-String that specifies the handle whose value(s) needs\n  \
    \          to be removed.\n            <IndexList>\n            A 4-byte unsigned\
    \ integer followed by a list of handle value\n            indexes.  Each index\
    \ refers to a handle value to be removed\n            from the <Handle>.  The\
    \ integer specifies the number of\n            indexes in the list.  Each index\
    \ is also encoded as a 4-byte\n            unsigned integer.\n   The server that\
    \ receives the REMOVE_VALUE request must first\n   authenticate the client as\
    \ the administrator with the REMOVE VALUE\n   privilege.  Upon successful authentication,\
    \ the server will proceed\n   to remove the handle values specified in the <IndexList>\
    \ from the\n   <Handle>.  If successful, the server will return an RC_SUCCESS\n\
    \   message to the client.\n   Each REMOVE_VALUE request must be carried out as\
    \ a transaction.  If\n   removing any value specified in the <IndexList> raises\
    \ an error, the\n   entire operation must be rolled back.  For any failed REMOVE_VALUE\n\
    \   request, none of values referenced in the <IndexList> should be\n   removed\
    \ from the <Handle>.  The server must also send a response to\n   the client that\
    \ explains the error.  For example, attempts to remove\n   any handle value with\
    \ neither PUB_WRITE nor ADMIN_WRITE permission\n   will result in an RC_ACCESS_DENIED\
    \ error.  Note that a REMOVE_VALUE\n   request asking to remove a non-existing\
    \ handle value will not be\n   treated as an error.\n   REMOVE_VALUE requests\
    \ can also be used to remove handle\n   administrators.  This happens if any of\
    \ the indexes in the\n   <IndexList> refer to an HS_ADMIN value.  Servers must\
    \ authenticate\n   the client as an administrator with the REMOVE_ADMIN privilege\
    \ before\n   fulfilling such requests.\n"
- title: 3.6.3.  Modify Handle Value(s)
  contents:
  - "3.6.3.  Modify Handle Value(s)\n   Clients can make modifications to an existing\
    \ handle value by sending\n   MODIFY_VALUE requests to the responsible handle\
    \ server.  The Message\n   Header of the MODIFY_VALUE request must set its <OpCode>\
    \ to\n   OC_MODIFY_VALUE.\n   The Message Body of any MODIFY_VALUE request is\
    \ defined as follows:\n      <Message Body of MODIFY_VALUE Response> ::= <Handle>\n\
    \                                                  <ValueList>\n         where\n\
    \            <Handle>\n            A UTF8-String that specifies the handle whose\
    \ value(s) needs\n            to be modified.\n            <ValueList>\n     \
    \       A 4-byte unsigned integer followed by a list of handle\n            values.\
    \  The integer specifies the number of handle values\n            in the list.\
    \  Each value in the <ValueList> specifies a\n            handle value that will\
    \ replace the existing handle value\n            with the same index.\n   The\
    \ server that receives the MODIFY_VALUE request must first\n   authenticate the\
    \ client as an administrator with the MODIFY_VALUE\n   privilege.  Upon successful\
    \ authentication, the server will proceed\n   to replace those handle values listed\
    \ in the <ValueList>, provided\n   each handle value has PUB_WRITE or ADMIN_WRITE\
    \ permission.  If\n   successful, the server must notify the client with an RC_SUCCESS\n\
    \   message.\n   Each MODIFY_VALUE request must be carried out as a transaction.\
    \  If\n   replacing any value listed in the <ValueList> raises an error, the\n\
    \   entire operation must be rolled back.  For any failed MODIFY_VALUE\n   request,\
    \ none of values in the <ValueList> should be replaced.  The\n   server must also\
    \ return a response to the client that explains the\n   error.  For example, if\
    \ a MODIFY_VALUE requests to remove a handle\n   value that has neither PUB_WRITE\
    \ nor ADMIN_WRITE permission, the\n   server must return an error message with\
    \ the <ResponseCode> set to\n   RC_ACCESS_DENIED.  Any MODIFY_VALUE request to\
    \ replace non- existing\n   handle values is also treated as an error.  In this\
    \ case, the server\n   will return an error message with <ResponseCode> set to\n\
    \   RC_VALUE_NOT_FOUND.\n   MODIFY_VALUE requests can also be used to update handle\n\
    \   administrators.  This happens if both the values in the <ValueList>\n   and\
    \ the value to be replaced are HS_ADMIN values.  Servers must\n   authenticate\
    \ the client as an administrator with the MODIFY_ADMIN\n   privilege before fulfilling\
    \ such a request.  It is an error to\n   replace a non-HS_ADMIN value with an\
    \ HS_ADMIN value.  In this case,\n   the server will return an error message with\
    \ <ResponseCode> set to\n   RC_VALUE_INVALID.\n"
- title: 3.6.4.  Create Handle
  contents:
  - "3.6.4.  Create Handle\n   Clients can create new handles by sending CREATE_HANDLE\
    \ requests to\n   the responsible handle server.  The Message Header of any\n\
    \   CREATE_HANDLE request must set its <OpCode> to OC_CREATE_HANDLE.\n   The Message\
    \ Body of any CREATE_HANDLE request is defined as follows:\n      <Message Body\
    \ of CREATE_HANDLE Response> ::= <Handle>\n                                  \
    \                 <ValueList>\n         where\n            <Handle>\n        \
    \    A UTF8-String that specifies the handle.\n            <ValueList>\n     \
    \       A 4-byte unsigned integer followed by a list of handle\n            values.\
    \  The integer indicates the number of handle values\n            in the list.\
    \  The <ValueList> should at least include one\n            HS_ADMIN value that\
    \ defines the handle administrator.\n   Only naming authority administrators with\
    \ the CREATE_HANDLE privilege\n   are allowed to create new handles under the\
    \ naming authority.  The\n   server that receives a CREATE_HANDLE request must\
    \ authenticate the\n   client as the administrator of the corresponding naming\
    \ authority\n   handle and make certain that the administrator is authorized to\n\
    \   create handles under the naming authority.  This is different from\n   the\
    \ ADD_VALUE request where the server authenticates the client as an\n   administrator\
    \ of the handle.  Upon successful authentication, the\n   server will proceed\
    \ to create the new handle and add each value in\n   the <ValueList> to the new\
    \ <Handle>.  If successful, the server will\n   return an RC_SUCCESS message to\
    \ the client.\n   Each CREATE_HANDLE request must be carried out as a transaction.\
    \  If\n   any part of the CREATE_HANDLE process fails, the entire operation can\n\
    \   be rolled back.  For example, if the server fails to add values in\n   the\
    \ <ValueList> to the new handle, it must return an error message\n   without creating\
    \ the new handle.  Any CREATE_HANDLE request that asks\n   to create a handle\
    \ that already exists will be treated as an error.\n   In this case, the server\
    \ will return an error message with the\n   <ResponseCode> set to RC_HANDLE_ALREADY_EXIST.\n\
    \   CREATE_HANDLE requests can also be used to create naming authorities.\n  \
    \ Naming authorities are created as naming authority handles at the\n   GHR. \
    \ Before creating a new naming authority handle, the server must\n   authenticate\
    \ the client as the administrator of the parent naming\n   authority.  Only administrators\
    \ with the CREATE_NA privilege are\n   allowed to create any sub-naming authority.\
    \  Root level naming\n   authorities may be created by the administrator of the\
    \ root handle\n   \"0.NA/0.NA\".\n"
- title: 3.6.5.  Delete Handle
  contents:
  - "3.6.5.  Delete Handle\n   Clients delete existing handles by sending DELETE_HANDLE\
    \ requests to\n   the responsible handle server.  The Message Header of the\n\
    \   DELETE_HANDLE request must set its <OpCode> to OC_DELETE_HANDLE.\n   The Message\
    \ Body of any DELETE_HANDLE request is defined as follows:\n      <Message Body\
    \ of DELETE_HANDLE Request> ::= <Handle>\n         where\n            <Handle>\n\
    \            A UTF8-String that specifies the handle.\n   The server that receives\
    \ the DELETE_HANDLE request must first\n   authenticate the client as the administrator\
    \ with the DELETE_HANDLE\n   privilege.  Upon successful authentication, the server\
    \ will proceed\n   to delete the handle along with any handle values assigned\
    \ to the\n   handle.  If successful, the server will return an RC_SUCCESS message\n\
    \   to the client.\n   Each DELETE_HANDLE request must be carried out as a transaction.\
    \  If\n   any part of the DELETE_HANDLE process fails, the entire operation\n\
    \   must be rolled back.  For example, if the server fails to remove any\n   handle\
    \ values assigned to the handle (before deleting the handle), it\n   must return\
    \ an error message without deleting the handle.  This may\n   happen if the handle\
    \ contains a value that has neither PUB_WRITE nor\n   ADMIN_WRITE permission.\
    \  In this case, the server will return an\n   error message with the <ResponseCode>\
    \ set to RC_PERMISSION_DENIED.  A\n   DELETE_HANDLE request that asks to delete\
    \ a non-existing handle will\n   also be treated as an error.  The server will\
    \ return an error message\n   with the <ResponseCode> set to RC_HANDLE_NOT_EXIST.\n\
    \   DELETE_HANDLE requests can also be used to delete naming authorities.\n  \
    \ This is achieved by deleting the corresponding naming authority\n   handle on\
    \ the GHR.  Before deleting a naming authority handle, the\n   server must authenticate\
    \ the client as the administrator of the\n   naming authority handle.  Only administrators\
    \ with the DELETE_NA\n   privilege are allowed to delete the naming authority.\
    \  Root level\n   naming authorities may be deleted by the administrator of the\
    \ root\n   handle \"0.NA/0.NA\".\n"
- title: 3.7.  Naming Authority (NA) Administration
  contents:
  - "3.7.  Naming Authority (NA) Administration\n   The Handle System manages naming\
    \ authorities via naming authority\n   handles.  Naming authority handles are\
    \ managed by the GHR.  Clients\n   can change the service information of any naming\
    \ authority by\n   changing the HS_SITE values assigned to the corresponding naming\n\
    \   authority handle.  Creating or deleting naming authorities is done by\n  \
    \ creating or deleting the corresponding naming authority handles.\n   Root level\
    \ naming authorities may be created or deleted by the\n   administrator of the\
    \ root handle \"0.NA/0.NA\".  Non-root-level naming\n   authorities may be created\
    \ by the administrator of its parent naming\n   authority.\n   For example, the\
    \ administrator of the naming authority handle\n   \"0.NA/10\" may create the\
    \ naming authority \"10.1000\" by sending a\n   CREATE_HANDLE request to the GHR\
    \ to create the naming authority\n   handle \"0.NA/10.1000\".  Before fulfilling\
    \ the request, the server at\n   the GHR must authenticate the client as the administrator\
    \ of the\n   parent naming authority, that is, the administrator of the naming\n\
    \   authority handle \"0.NA/10\".  The server must also make sure that the\n \
    \  administrator has the NA_CREATE privilege.\n   The Handle protocol also allows\
    \ clients to list handles or sub-naming\n   authorities under a naming authority.\
    \  Details of these operations\n   are described in the following sections.\n"
- title: 3.7.1.  List Handle(s) under a Naming Authority
  contents:
  - "3.7.1.  List Handle(s) under a Naming Authority\n   Clients send LIST_HANDLE\
    \ requests to handle servers to get a list of\n   handles under a naming authority.\
    \  The Message Header of the\n   LIST_HANDLE request must set its <OpCode> to\
    \ OC_LIST_HANDLE.\n   The Message Body of any LIST_HANDLE request is defined as\
    \ follows:\n      <Message Body of LIST_HANDLE Request> ::= <NA_Handle>\n    \
    \     where\n            <NA_Handle>\n            A UTF8-String that specifies\
    \ the naming authority handle.\n   To obtain a complete list of the handles, the\
    \ request must be sent to\n   every handle server listed in one of the service\
    \ sites of the\n   responsible handle service.  Each server within the service\
    \ site will\n   return its own list of handles under the naming authority.  The\n\
    \   Message Body of a successful LIST_HANDLE response (from each handle\n   server)\
    \ is defined as follows:\n      <Message Body of LIST_HANDLE Response>  ::=  <Num_Handles>\n\
    \                                                   <HandleList>\n         where\n\
    \            <Num_Handles>\n            Number of handles (managed by the handle\
    \ server) under the\n            naming authority.\n            <HandleList>\n\
    \            A list of UTF8-Strings, each of which identify a handle\n       \
    \     under the naming authority.\n   The LIST_HANDLE request may potentially\
    \ slow down the overall system\n   performance.  A handle service (or its service\
    \ site) has the option\n   of whether or not to support such request.  The server\
    \ will return an\n   RC_OPERATION_DENIED message if LIST_HANDLE is not supported.\
    \  The\n   server that receives a LIST_HANDLE request should authenticate the\n\
    \   client as a naming authority administrator with the LIST_HANDLE\n   privilege\
    \ before fulfilling the request.\n"
- title: 3.7.2.  List Sub-Naming Authorities under a Naming Authority
  contents:
  - "3.7.2.  List Sub-Naming Authorities under a Naming Authority\n   Clients send\
    \ LIST_NA requests to handle servers to get a list of\n   sub-naming authorities\
    \ under a naming authority.  The Message Header\n   of the LIST_NA request must\
    \ set its <OpCode> to OC_LIST_NA.\n   The Message Body of any LIST_NA request\
    \ is defined as follows:\n      <Message Body of LIST_HANDLE Request> ::= <NA_Handle>\n\
    \        where\n          <NA_Handle>\n          A UTF8-String that specifies\
    \ the naming authority handle.\n   To obtain a complete list of the sub-naming\
    \ authorities, the request\n   must be sent to every handle server listed in any\
    \ one of the service\n   sites of the GHR.  Each server within the service site\
    \ will return\n   its own list of sub-naming authority handles under the given\
    \ naming\n   authority.  The Message Body of a successful LIST_NA response (from\n\
    \   each handle server) is defined as follows:\n      <Message Body of LIST_HANDLE\
    \ Response> ::=  <Num_Handles>\n                                             \
    \     <HandleList>\n         where\n            <Num_Handles>\n            Number\
    \ of handles (managed by the handle server) under the\n            naming authority.\n\
    \            <HandleList>\n            A list of UTF8-Strings, each of which identifies\
    \ a sub-\n            naming authority user-specified naming authority.\n   LIST_NA\
    \ requests must be sent to servers under the GHR that manages\n   all the naming\
    \ authority handles.  The LIST_NA request may\n   potentially slow down the overall\
    \ system performance, especially the\n   GHS.  A server (or service sites) under\
    \ the GHR has the option of\n   whether or not to support such requests.  The\
    \ server will return an\n   RC_OPERATION_DENIED message if LIST_NA is not supported.\
    \  The server\n   that receives a LIST_HANDLE request should authenticate the\
    \ client as\n   a naming authority administrator with the LIST_NA privilege before\n\
    \   fulfilling the request.\n"
- title: 3.8.  Session and Session Management
  contents:
  - "3.8.  Session and Session Management\n   Sessions are used to allow sharing of\
    \ authentication information or\n   network resources among multiple protocol\
    \ operations.  For example, a\n   naming authority administrator may authenticate\
    \ itself once through\n   the session setup, and then register multiple handles\
    \ under the\n   session.\n   A client may ask the server to establish a session\
    \ key and use it for\n   subsequent requests.  A session key is a secret key that\
    \ is shared by\n   the client and server.  It can be used to authenticate or encrypt\
    \ any\n   message exchanged under the session.  A session is encrypted if every\n\
    \   message exchanged within the session is encrypted using the session\n   key.\n\
    \   Sessions may be established as the result of an explicit\n   OC_SESSION_SETUP\
    \ request from a client.  A server may also\n   automatically setup a session\
    \ when multiple message exchanges are\n   expected to fulfill a request.  For\
    \ example, the server will\n   automatically establish a session if it receives\
    \ a CREATE_HANDLE\n   request that requires client authentication.\n   Every session\
    \ is identified by a non-zero Session ID that appears in\n   the Message Header.\
    \  Servers are responsible for generating a unique\n   Session ID for each outstanding\
    \ session.  Each session may have a set\n   of state information associated with\
    \ it.  The state information may\n   include the session key and the information\
    \ obtained from client\n   authentication, as well as any communication options.\
    \  Servers and\n   clients are responsible for keeping the state information in\
    \ sync\n   until the session is terminated.\n   A session may be terminated with\
    \ an OC_SESSION_TERMINATE request from\n   the client.  Servers may also terminate\
    \ a session that has been idle\n   for a significant amount of time.\n"
- title: 3.8.1.  Session Setup Request
  contents:
  - "3.8.1.  Session Setup Request\n   Clients establish a session with a handle server\
    \ with a SESSION_SETUP\n   request.  A SESSION_SETUP request can also be used\
    \ to update any\n   state information associated to an existing session.  The\
    \ Message\n   Header of the SESSION_SETUP request must have its <OpCode> set to\n\
    \   OC_SESSION_SETUP and <ResponseCode> to 0.\n   The Message Body of any SESSION_SETUP\
    \ request is defined as follows:\n      <SESSION_SETUP Request Message Body> ::=\
    \ <SessionAttributes>\n         where\n            <SessionAttributes>\n     \
    \       A 4-byte unsigned integer followed by a list of session\n            attributes.\
    \  The integer indicates the number of session\n            attributes in the\
    \ list.  Possible session attributes include\n            the <HS_SESSION_IDENTITY>,\
    \ the <HS_SESSION_TIMEOUT>, and the\n            <HS_SESSION_KEY_EXCHANGE>.  Each\
    \ of these attributes is\n            defined as follows:\n               <HS_SESSION_IDENTITY>\
    \ ::= <Key>\n                                         <Handle>\n             \
    \                            <ValueIndex>\n                  where\n         \
    \            <Key>\n                     A UTF-8 string constant \"HS_SESSION_IDENTITY\"\
    .\n                     <Handle>\n                     <ValueIndex>\n        \
    \             A UTF-8 string followed by a 4-byte unsigned\n                 \
    \    integer that specifies the handle and the handle\n                     value\
    \ used for client authentication.  It must\n                     refer to a handle\
    \ value that contains the public\n                     key of the client.  The\
    \ public key is used by\n                     the server to authenticate the client.\n\
    \               <HS_SESSION_KEY_EXCHANGE> ::= <Key>\n                        \
    \                     <KeyExchangeData>\n                  where\n           \
    \          <Key>\n                     A UTF-8 string constant \"HS_SESSION_KEY_EXCHANGE\"\
    .\n                     <KeyExchangeData>\n                     One of the these\
    \ tuples: <ClientCipher\n                     <ClientCipher KeyExchange>,\n  \
    \                   <HdlCipher KeyExchange>, or\n                     <ServerCipher\
    \ KeyExchange>.\n                     Each of these tuples is defined as follows:\n\
    \                     <ClientCipher KeyExchange> ::= <Key>\n                 \
    \                                <PubKey>\n                        where\n   \
    \                        <Key>\n                           A UTF-8 string constant\
    \ \"CLIENT_CIPHER\".\n                           <PubKey>\n                  \
    \         A public key provided by the client and used\n                     \
    \      by the server to encrypt the session key.\n                     <HdlCipher\
    \ KeyExchange> ::= <Key>\n                                                 <ExchangeKeyHdl>\n\
    \                                                 <ExchangeKeyIndex>\n       \
    \                 where\n                           <Key>\n                  \
    \         A UTF-8 string constant \"HDL_CIPHER\".\n                          \
    \ <ExchangeKeyHdl>\n                           <ExchangeKeyIndex>\n          \
    \                 A UTF-8 string followed by a 4-byte unsigned\n             \
    \              integer.  The <ExchangeKeyHdl> and\n                          \
    \ <ExchangeKeyIndex> refers to a handle value\n                           used\
    \ for session key exchange.  The handle\n                           value must\
    \ contain the public key of the\n                           client.  The public\
    \ key will be used by the\n                           server to encrypt the session\
    \ key before\n                           sending it to the client.\n         \
    \            <ServerCipher KeyExchange> ::= <Key>\n                        where\n\
    \                        <Key>\n                        A UTF-8 string constant\
    \ \"SERVER_CIPHER\".  This\n                        tells the server that the\
    \ client will be\n                        responsible for generating the session\
    \ key.  The\n                        server will have to provide its public key\
    \ in\n                        the response message and set the <ResponseCode>\n\
    \                        to RC_SESSION_EXCHANGEKEY.  The client can use\n    \
    \                    the server's public key to encrypt the session\n        \
    \                key and send it to the server via a subsequent\n            \
    \            SESSION_EXCHANGEKEY request.\n                     <DiffieHellman\
    \ KeyExchange> ::= <Key>\n                                                   \
    \  <DHParams>\n                        where\n                           <Key>\n\
    \                           A UTF-8 string constant \"DIFFIE_HELLMAN\"\n     \
    \                      <DHParams>\n                           The values used\
    \ as input in the Diffie-\n                           Hellman algorithm.  It consists\
    \ of three big\n                           integers of variable length.  Each\
    \ big\n                           integer is encoded in terms of a 4-byte\n  \
    \                         unsigned integer followed by an octet string.\n    \
    \                       The octet string contains the big integer\n          \
    \                 itself.  The 4-byte unsigned integer\n                     \
    \      specifies the number of octets of the octet\n                         \
    \  string.\n          <HS_SESSION_TIMEOUT> ::=  <Key>\n                      \
    \              <TimeOut>\n             where\n                <Key>\n        \
    \        A UTF-8 string constant \"HS_SESSION_TIMEOUT\".\n                <TimeOut>\n\
    \                A 4-byte unsigned integer that specifies the desired\n      \
    \          duration of the session in seconds.\n   Note that it should be treated\
    \ as an error if the same session\n   attribute is listed multiple times in the\
    \ <SessionAttribute> field.\n   When this happens, the server should return an\
    \ error message with\n   <ResponseCode> set to RC_PROTOCOL_ERROR.\n   A SESSION_SETUP_REQUEST\
    \ can be used to change session attributes of\n   any established session.  This\
    \ happens if the <SessionId> is non-zero\n   and matches one of the established\
    \ sessions.  Care must be taken by\n   the server to prevent any unauthorized\
    \ request from changing the\n   session attributes.  For example, an encrypted\
    \ session may only be\n   changed into an unencrypted session by a SESSION_SETUP_REQUEST\
    \ with\n   an appropriate MAC in its Message Credential.\n"
- title: 3.8.2.  Session Setup Response
  contents:
  - "3.8.2.  Session Setup Response\n   The Message Header of the SESSION_SETUP response\
    \ must set its\n   <OpCode> to OC_SESSION_SETUP.  The <ResponseCode> of the\n\
    \   SESSION_SETUP response varies according to the SESSION_SETUP request.\n  \
    \ It must be set to RC_SUCCESS if the SESSION_SETUP request is\n   successful\
    \ and the server does not expect a session key to be\n   returned by the client.\n\
    \   The Message Body of the SESSION_SETUP response is empty unless the\n   request\
    \ is asking for <HS_SESSION_KEY_EXCHANGE>.  In this case, the\n   Message Body\
    \ of the SESSION_SETUP response may contain the encrypted\n   session key from\
    \ the server, or the server's public key, to be used\n   for session key exchange.\
    \  The exact format depends on the content of\n   the <HS_SESSION_KEY_EXCHANGE>\
    \ in the SESSION_SETUP request.  If\n   <ClientCipher KeyExchange> or <HdlCipher\
    \ KeyExchange> is given in the\n   SESSION_SETUP request, the Message Body of\
    \ the SESSION_SETUP response\n   will contain the encrypted session key from the\
    \ server and is defined\n   as follows:\n      <Message Body of SESSION_SETUP\
    \ Response>\n                                        ::= <RequestDigest>\n   \
    \                                         <EncryptedSessionKey>\n            \
    \                              [ <EncryptionAlgorithm> ]\n        where\n    \
    \      <RequestDigest>\n          Message digest of the SESSION_SETUP request\
    \ is as specified in\n          section 2.2.3.\n          <EncryptedSessionKey>\n\
    \          Session key is encrypted using the public key provided in the\n   \
    \       SESSION_SETUP request.  The session key is a randomly\n          generated\
    \ octet string from the server.  The server will only\n          return the <EncryptedSessionKey>\
    \ if the <KeyExchangeData> in\n          the SESSION_SETUP request provides the\
    \ public key from the\n          client.\n          <EncryptionAlgorithm>\n  \
    \        (optional) UTF-8 string that identifies the encryption\n          algorithm\
    \ used by the session key.\n   If <ServerCipher KeyExchange> is given in the SESSION_SETUP\
    \ request,\n   the server must provide its public key in the SESSION_SETUP response.\n\
    \   The public key can be used by the client in a subsequent\n   SESSION_EXCHANGEKEY\
    \ request (defined below) for session key exchange.\n   In this case, the Message\
    \ Header of the SESSION_SETUP response must\n   set its <ResponseCode> to RC_SESSION_EXCHANGEKEY.\
    \  The Message Body\n   of the SESSION_SETUP response must include the server's\
    \ public key\n   and is defined as follows:\n      <Message Body of SESSION_SETUP\
    \ response>\n                              ::= <RequestDigest>\n             \
    \                     <Public Key for Session Key Exchange>\n        where\n \
    \         <RequestDigest>\n          Message digest of the SESSION_SETUP request\
    \ as specified in\n          section 2.2.3.\n          <Public Key for Session\
    \ Key Exchange>\n          Public key from the server to be used for session key\n\
    \          exchange.  It is encoded in the same format as the <PublicKey>\n  \
    \        record in the HS_SITE value (see section 3.2.2 in [2]).\n"
- title: 3.8.3.  Session Key Exchange
  contents:
  - "3.8.3.  Session Key Exchange\n   If the <ResponseCode> of a SESSION_SETUP response\
    \ is\n   RC_SESSION_EXCHANGEKEY, the client is responsible for generating the\n\
    \   session key and sending it to the server.  In this case, the client\n   can\
    \ generate a session key, encrypt it with the public key provided\n   by the server\
    \ in the SESSION_SETUP response, and send the encrypted\n   session key to the\
    \ server in a SESSION_EXCHANGEKEY request.\n   The Message Header of the SESSION_EXCHANGEKEY\
    \ request must set its\n   <OpCode> to OC_SESSION_EXCHANGEKEY and its <ResponseCode>\
    \ to 0.  The\n   Message Body of the SESSION_EXCHANGEKEY request is defined as\n\
    \   follows:\n      <Message Body of OC_SESSION_EXCHANGEKEY>\n               \
    \       ::=   <Encrypted Session Key>\n                          [ <EncryptionAlgorithm>\
    \ ]\n        where\n          <EncryptedSessionKey>\n          Session key encrypted\
    \ using the public key provided in the\n          SESSION_SETUP response.  The\
    \ session key is a randomly\n          generated octet string by the client.\n\
    \          <EncryptionAlgorithm>\n          (optional) UTF-8 string that identifies\
    \ the encryption\n          algorithm used by the session key.\n   During the\
    \ session key exchange, the server receiving the exchange\n   key or session key\
    \ has the responsibility of ensuring that the key\n   meets the security requirements\
    \ defined in its local policy.  If the\n   server considers the key being volunable,\
    \ it must return an error\n   message to the client with <ResponseCode> set to\n\
    \   RC_SESSION_KEY_INVALID.\n"
- title: 3.8.4.  Session Termination
  contents:
  - "3.8.4.  Session Termination\n   Clients can terminate a session with a SESSION_TERMINATE\
    \ request.\n   The Message Header of a SESSION_TERMINATE request must have its\n\
    \   <OpCode> set to OC_SESSION_TERMINATE and its <ResponseCode> to 0.\n   The\
    \ message body of any SESSION_TERMINATE request must be empty.\n   The server\
    \ must send a SESSION_TERMINATE response to the client after\n   the session is\
    \ terminated.  The server should only terminate the\n   session after it has finished\
    \ processing all the requests (under the\n   session) that were submitted before\
    \ the Session Termination request.\n   The message header of the SESSION_TERMINATE\
    \ response must set its\n   <OpCode> to OC_SESSION_TERMINATE.  A successful SESSION_TERMINATE\n\
    \   response must have its <ResponseCode> set to RC_SUCCESS, and an empty\n  \
    \ message body.\n"
- title: 4.  Implementation Guidelines
  contents:
  - '4.  Implementation Guidelines

    '
- title: 4.1.  Server Implementation
  contents:
  - "4.1.  Server Implementation\n   The optimal structure for any handle server will\
    \ depend on the host\n   operating system.  This section only addresses those\
    \ implementation\n   considerations that are common to most handle servers.\n\
    \   A good server implementation should allow easy configuration or\n   fine-tuning.\
    \  A suggested list of configurable items includes the\n   server's network interface(s)\
    \ (e.g., IP address, port number, etc.),\n   the number of concurrent processes/threads\
    \ allowed, time-out\n   intervals for any TCP connection and/or authentication\
    \ process, re-\n   try policy under UDP connection, policies on whether to support\n\
    \   recursive service, case-sensitivity for ASCII characters, and\n   different\
    \ levels of transaction logging, etc.\n   All handle server implementations must\
    \ support all the handle data\n   types as defined in the \"Handle System Namespace\
    \ and Service\n   Definition\" [2].  They should also be able to store handle\
    \ values of\n   any application defined data type.\n   A handle server must support\
    \ multiple concurrent activities, whether\n   they are implemented as separate\
    \ processes or threads in the host's\n   operating system, or multiplexed inside\
    \ a single name server program.\n   A handle server should not block the service\
    \ of UDP requests while it\n   waits for TCP data or other query activities. \
    \ Similarly, a handle\n   server should not attempt to provide recursive service\
    \ without\n   processing such requests in parallel, though it may choose to\n\
    \   serialize requests from a single client, or to regard identical\n   requests\
    \ from the same client as duplicates.\n"
- title: 4.2.  Client Implementation
  contents:
  - "4.2.  Client Implementation\n   Clients should be prepared to receive handle\
    \ values of any data type.\n   Clients may choose to implement a callback interface\
    \ to allow new\n   modules or plug-ins to be added to support any application-defined\n\
    \   data types.\n   Clients that follow service referrals or handle aliases must\
    \ avoid\n   falling into an infinite loop.  They should not repeatedly contact\n\
    \   the same server for the same request with the same target entry.  A\n   client\
    \ may choose to use a counter that is incremented each time it\n   follows a service\
    \ referral or handle alias.  There should be a\n   configurable upper limit to\
    \ the counter to control the levels of\n   service referrals or handle aliases\
    \ followed by the client.\n   Clients that provide some caching can expect much\
    \ better performance\n   than those that do not.  Client implementations should\
    \ always\n   consider caching the service information associated with a naming\n\
    \   authority.  This will reduce the number of roundtrips for subsequent\n   handle\
    \ requests under the same naming authority.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   The overall Handle System security considerations\
    \ are discussed in\n   \"Handle System Overview\" [1]; that discussion applies\
    \ equally to this\n   document.  Security considerations regarding the Handle\
    \ System data\n   model and service model are discussed in \"Handle System Namespace\
    \ and\n   Service Definition\" [2].\n   For efficiency, the Handle protocol includes\
    \ a simple challenge-\n   response authentication protocol for basic client authentication.\n\
    \   Handle servers are free to provide additional authentication\n   mechanisms\
    \ (e.g., SASL) as needed.  Details of this will be discussed\n   in a separate\
    \ document.\n   Data integrity under the Handle protocol is achieved via the server's\n\
    \   digital signature.  Care must be taken to protect the server's\n   private\
    \ key from any impersonation attack.  Any change to the\n   server's public key\
    \ pair must be registered (in terms of service\n   information) with the GHR.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   This work is derived from the earlier versions of the\
    \ Handle System\n   implementation. The overall digital object architecture, including\n\
    \   the Handle System, was described in a paper by Robert Kahn and Robert\n  \
    \ Wilensky [22] in 1995. Development continued at CNRI as part of the\n   Computer\
    \ Science Technical Reports (CSTR) project, funded by the\n   Defense Advanced\
    \ Projects Agency (DARPA) under Grant Number MDA-972-\n   92-J-1029 and MDA-972-99-1-0018.\
    \  Design ideas are based on those\n   discussed within the Handle System development\
    \ team, including David\n   Ely, Charles Orth, Allison Yu, Sean Reilly, Jane Euler,\
    \ Catherine\n   Rey, Stephanie Nguyen, Jason Petrone, and Helen She.  Their\n\
    \   contributions to this work are gratefully acknowledged.\n   The authors also\
    \ thank Russ Housley (housley@vigilsec.com), Ted\n   Hardie (hardie@qualcomm.com),\
    \ and Mark Baugher (mbaugher@cisco.com)\n   for their extensive review and comments,\
    \ as well as recommendations\n   received from other members of the IETF/IRTF\
    \ community.\n"
- title: 7.  Informative References
  contents:
  - "7.  Informative References\n   [1]  Sun, S. and L. Lannom, \"Handle System Overview\"\
    , RFC 3650,\n        November 2003.\n   [2]  Sun, S., Reilly, S. and L. Lannom,\
    \ \"Handle System Namespace and\n        Service Definition\", RFC 3651, November\
    \ 2003.\n   [3]  Yergeau, F., \"UTF-8, a transformation format of ISO 10646\"\
    , RFC\n        2279, January 1998.\n   [4]  A. Freier, P. Karlton, P. Kocher \"\
    The SSL Protocol Version 3.0\"\n   [5]  RSA Laboratories, \"Public-Key Cryptography\
    \ Standard PKCS#7\"\n        http://www.rsasecurity.com/rsalabs/pkcs/\n   [6]\
    \  U.S. Federal Information Processing Standard: Digital Signature\n        Standard.\n\
    \   [7]  Housley, R., \"Cryptographic Message Syntax (CMS) Algorithms\",\n   \
    \     RFC 3370, August 2002.\n   [8]  Braden, R., \"FTP Data Compression\", RFC\
    \ 468, March 1973.\n   [9]  Rivest, R., \"The MD5 Message-Digest Algorithm\",\
    \ RFC 1321, April\n        1992.\n   [10] NIST, FIPS PUB 180-1: Secure Hash Standard,\
    \ April 1995.\n   [11] D. Cohen, \"On Holy Wars and a Plea for Peace\", Internet\n\
    \        Experiment, Note IEN 137, 1 April 1980.\n   [12] Balakrishnan, H. and\
    \ S. Seshan, \"The Congestion Manager\", RFC\n        3124, June 2001.\n   [13]\
    \ R. Kahn, R. Wilensky, \"A Framework for Distributed Digital\n        Object\
    \ Services, May 1995, http://www.cnri.reston.va.us/k-w.html\n   [14] Polk, W.,\
    \ Housley, R. and L. Bassham, \"Algorithms and\n        Identifiers for the Internet\
    \ X.509 Public Key Infrastructure\n        Certificate and Certificate Revocation\
    \ List (CRL) Profile\", RFC\n        3279, April 2002.\n   [15] Housley, R., Polk,\
    \ W., Ford, W. and D. Solo, \"Internet X.509\n        Public Key Infrastructure\
    \ Certificate and Certificate Revocation\n        List (CRL) Profile\", RFC 3280,\
    \ April 2002.\n   [16] M. Bellare and P. Rogaway. The Exact Security of Digital\n\
    \        Signatures - How to Sign with RSA and Rabin. In Advances in\n       \
    \ Cryptology-Eurocrypt '96, pp.399-416, Springer-Verlag, 1996.\n   [17] Krawczyk,\
    \ H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing\n        for Message Authentication\"\
    , RFC 2104, February 1997.\n   [18] R. Kahn, R. Wilensky, \"A Framework for Distributed\
    \ Digital\n        Object Services, May 1995, http://www.cnri.reston.va.us/k-w.html\n"
- title: 8.  Authors' Addresses
  contents:
  - "8.  Authors' Addresses\n   Sam X. Sun\n   Corporation for National Research Initiatives\
    \ (CNRI)\n   1895 Preston White Dr., Suite 100\n   Reston, VA 20191\n   Phone:\
    \ 703-262-5316\n   EMail: ssun@cnri.reston.va.us\n   Sean Reilly\n   Corporation\
    \ for National Research Initiatives (CNRI)\n   1895 Preston White Dr., Suite 100\n\
    \   Reston, VA 20191\n   Phone: 703-620-8990\n   EMail: sreilly@cnri.reston.va.us\n\
    \   Larry Lannom\n   Corporation for National Research Initiatives (CNRI)\n  \
    \ 1895 Preston White Dr., Suite 100\n   Reston, VA 20191\n   Phone: 703-262-5307\n\
    \   EMail: llannom@cnri.reston.va.us\n   Jason Petrone\n   Corporation for National\
    \ Research Initiatives (CNRI)\n   1895 Preston White Dr., Suite 100\n   Reston,\
    \ VA 20191\n   Phone: 703-262-5340\n   EMail: jpetrone@cnri.reston.va.us\n"
- title: 9.  Full Copyright Statement
  contents:
  - "9.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assignees.\n\
    \   This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
