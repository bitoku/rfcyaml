Abstract This document specifies a speech codec suitable for robust voice communication over IP.
The codec is developed by Global IP Sound (GIPS).
It is designed for narrow band speech and results in a payload bit rate of 13.33 kbit/s for 30 ms frames and 15.20 kbit/s for 20 ms frames.
The codec enables graceful speech quality degradation in the case of lost frames, which occurs in connection with lost or delayed IP packets.
This document contains the description of an algorithm for the coding of speech signals sampled at 8 kHz.
The algorithm, called iLBC, uses a block independent linear predictive coding (LPC) algorithm and has support for two basic frame lengths: 20 ms at 15.2 kbit/s and 30 ms at 13.33 kbit/s.
When the codec operates at block lengths of 20 ms, it produces 304 bits per block, which SHOULD be packetized as in [1].
Similarly, for block lengths of 30 ms it produces 400 bits per block, which SHOULD be packetized as in [1].
The two modes for the different frame sizes operate in a very similar way.
When they differ it is explicitly stated in the text, usually with
the notation x/y, where x refers to the 20 ms mode and y refers to the 30 ms mode.
The described algorithm results in a speech coding system with a controlled response to packet losses similar to what is known from pulse code modulation (PCM) with packet loss concealment (PLC), such as the ITU T G.711 standard [4], which operates at a fixed bit rate of 64 kbit/s.
At the same time, the described algorithm enables fixed bit rate coding with a quality versus bit rate tradeoff close to state of the art.
A suitable RTP payload format for the iLBC codec is specified in [1].
Some of the applications for which this coder is suitable are real time communications such as telephony and videoconferencing, streaming audio, archival, and messaging.
Cable Television Laboratories (CableLabs(R)) has adopted iLBC as a mandatory PacketCable(TM) audio codec standard for VoIP over Cable applications [3].
This document is organized as follows.
Section 2 gives a brief outline of the codec.
The specific encoder and decoder algorithms are explained in sections 3 and 4, respectively.
Appendix A provides a c code reference implementation.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14, RFC 2119 [2].
The codec consists of an encoder and a decoder as described in sections 2.1 and 2.2, respectively.
The essence of the codec is LPC and block based coding of the LPC residual signal.
For each 160/240 (20 ms/30 ms) sample block, the following major steps are performed: A set of LPC filters are computed, and the speech signal is filtered through them to produce the residual signal.
The codec uses scalar quantization of the dominant part, in terms of energy, of the residual signal for the block.
The dominant state is of length 57/58 (20 ms/30 ms) samples and forms a start state for dynamic codebooks constructed from the already coded parts of the residual signal.
These dynamic codebooks are used to code the remaining parts of the residual signal.
By this method, coding independence between blocks is achieved, resulting in elimination of propagation of perceptual degradations due to packet loss.
The method facilitates high quality packet loss concealment (PLC).
The input to the encoder SHOULD be 16 bit uniform PCM sampled at 8 kHz.
It SHOULD be partitioned into blocks of BLOCKL 160/240 samples for the 20/30 ms frame size.
Each block is divided into NSUB 4/6 consecutive sub blocks of SUBL 40 samples each.
For 30 ms frame size, the encoder performs two LPC FILTERORDER 10 linear predictive coding (LPC) analyses.
The first analysis applies a smooth window centered over the second sub block and extending to the middle of the fifth sub block.
The second LPC analysis applies a smooth asymmetric window centered over the fifth sub block and extending to the end of the sixth sub block.
For 20 ms frame size, one LPC FILTERORDER 10 linear predictive coding
(LPC) analysis is performed with a smooth window centered over the third sub frame.
For each of the LPC analyses, a set of line spectral frequencies (LSFs) are obtained, quantized, and interpolated to obtain LSF coefficients for each sub block.
Subsequently, the LPC residual is computed by using the quantized and interpolated LPC analysis filters.
The two consecutive sub blocks of the residual exhibiting the maximal weighted energy are identified.
Within these two sub blocks, the start state (segment) is selected from two choices: the first 57/58 samples or the last 57/58 samples of the two consecutive sub blocks.
The selected segment is the one of higher energy.
The start state is encoded with scalar quantization.
A dynamic codebook encoding procedure is used to encode 1)
the 23/22 (20 ms/30 ms) remaining samples in the two sub blocks containing the start state; 2) the sub blocks after the start state in time; and 3)
the sub blocks before the start state in time.
Thus, the encoding target can be either the 23/22 samples remaining of the two sub  blocks containing the start state or a 40 sample sub block.
This target can consist of samples indexed forward in time or backward in time, depending on the location of the start state.
The codebook coding is based on an adaptive codebook built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block.
These samples are indexed in the same time direction as the target vector, ending at the sample instant prior to the first sample instant represented in the target vector.
The codebook is used in CB NSTAGES 3 stages in a successive refinement approach, and the resulting three code vector gains are encoded with 5 , 4 , and 3 bit scalar quantization, respectively.
The codebook search method employs noise shaping derived from the LPC filters, and the main decision criterion is to minimize the squared error between the target vector and the code vectors.
Each code vector in this codebook comes from one of CB EXPAND 2 codebook sections.
The first section is filled with delayed, already encoded residual vectors.
The code vectors of the second codebook section are constructed by predefined linear combinations of vectors in the first section of the codebook.
As codebook encoding with squared error matching is known to produce a coded signal of less power than does the scalar quantized start state signal, a gain re scaling method is implemented by a refined search for a better set of codebook gains in terms of power matching after encoding.
This is done by searching for a higher value of the gain factor for the first stage codebook, as the subsequent stage codebook gains are scaled by the first stage gain.
Typically for packet communications, a jitter buffer placed at the receiving end decides whether the packet containing an encoded signal block has been received or lost.
This logic is not part of the codec described here.
For each encoded signal block received the decoder performs a decoding.
For each lost signal block, the decoder performs a PLC operation.
The decoding for each block starts by decoding and interpolating the LPC coefficients.
Subsequently the start state is decoded.
For codebook encoded segments, each segment is decoded by constructing the three code vectors given by the received codebook indices in the same way that the code vectors were constructed in the encoder.
The three gain factors are also decoded and the resulting decoded signal is given by the sum of the three codebook vectors scaled with respective gain.
An enhancement algorithm is applied to the reconstructed excitation signal.
This enhancement augments the periodicity of voiced speech regions.
The enhancement is optimized under the constraint that the modification signal (defined as the difference between the enhanced excitation and the excitation signal prior to enhancement) has a short time energy that does not exceed a preset fraction of the short time energy of the excitation signal prior to enhancement.
A packet loss concealment (PLC) operation is easily embedded in the decoder.
The PLC operation can, e.g., be based on repeating LPC filters and obtaining the LPC residual signal by using a long term prediction estimate from previous residual blocks.
The following block diagram is an overview of all the components of the iLBC encoding procedure.
The description of the blocks contains references to the section where that particular procedure is further described.
2/4 (20 ms/30 ms) Figure 3.1.
Flow chart of the iLBC encoder 1.
Pre process speech with a HP filter, if needed (section 3.1).
Compute LPC parameters, quantize, and interpolate (section 3.2).
Use analysis filters on speech to compute residual (section 3.3).
Select position of 57/58 sample start state (section 3.5).
Quantize the 57/58 sample start state with scalar quantization (section 3.5).
Search the codebook for each sub frame.
Start with 23/22 sample block, then encode sub blocks forward in time, and then encode sub blocks backward in time.
For each block, the steps in Figure 3.4 are performed (section 3.6).
Packetize the bits into the payload specified in Table 3.2.
The input to the encoder SHOULD be 16 bit uniform PCM sampled at 8 kHz.
Also it SHOULD be partitioned into blocks of BLOCKL 160/240 samples.
Each block input to the encoder is divided into NSUB 4/6 consecutive sub blocks of SUBL 40 samples each. 0
One input block to the encoder for 20 ms (with four sub  frames) and 30 ms (with six sub frames).
Pre processing In some applications, the recorded speech signal contains DC level and/or 50/60 Hz noise.
If these components have not been removed prior to the encoder call, they should be removed by a high pass filter.
A reference implementation of this, using a filter with a cutoff frequency of 90 Hz, can be found in Appendix A.28.
The input to the LPC analysis module is a possibly high pass filtered speech buffer, speech hp, that contains 240/300 (LPC LOOKBACK
speech samples, where samples 0 through 79/59 are from the previous block and samples 80/60 through 239/299 are from the current block.
No look ahead into the next block is used.
For the very first block processed, the look back samples are assumed to be zeros.
For each input block, the LPC analysis calculates one/two set(s) of LPC FILTERORDER 10 LPC filter coefficients using the autocorrelation method and the Levinson Durbin recursion.
These coefficients are converted to the Line Spectrum Frequency representation.
In the 20 ms case, the single lsf set represents the spectral characteristics as measured at the center of the third sub block.
For 30 ms frames, the first set, lsf1, represents the spectral properties of the input signal at the center of the second sub block, and the other set, lsf2, represents the spectral characteristics as measured at the center of the fifth sub block.
The details of the computation for 30 ms frames are described in sections 3.2.1 through 3.2.6.
Section 3.2.7 explains how the LPC Analysis and Quantization differs for 20 ms frames.
The first step in the LPC analysis procedure is to calculate autocorrelation coefficients by using windowed speech samples.
This windowing is the only difference in the LPC analysis procedure for the two sets of coefficients.
For the first set, a 240 sample long standard symmetric Hanning window is applied to samples 0 through 239 of the input data.
The first window, lpc winTbl, is defined as lpc winTbl[i]  0.5
The windowed speech speech hp win1 is then obtained by multiplying the first 240 samples of the input speech buffer with the window coefficients: speech hp win1[i]   speech
From these 240 windowed speech samples, 11 (LPC FILTERORDER   1) autocorrelation coefficients, acf1, are calculated: acf1[lag]
In order to make the analysis more robust against numerical precision problems, a spectral smoothing procedure is applied by windowing the autocorrelation coefficients before the LPC coefficients are computed.
Also, a white noise floor is added to the autocorrelation function by multiplying coefficient zero by 1.0001 (40dB below the energy of the windowed speech signal).
These two steps are implemented by multiplying the autocorrelation coefficients with the following window: lpc lagwinTbl[0]   1.0001; lpc lagwinTbl[i]
Then, the windowed acf function acf1 win is obtained by acf1 win[i]   acf1[i]
The second set of autocorrelation coefficients, acf2 win, are obtained in a similar manner.
The window, lpc asymwinTbl, is applied to samples 60 through 299, i.e., the entire current block.
The window consists of two segments, the first (samples 0 to 219) being half a Hanning window with length 440 and the second a quarter of a cycle of a cosine wave.
By using this asymmetric window, an LPC analysis centered in the fifth sub block is obtained without the need for any look ahead, which would add delay.
The asymmetric window is defined as lpc asymwinTbl[i]
(i   1) / 441))^2; i 0,...
and the windowed speech is computed by speech hp win2[i]   speech
The windowed autocorrelation coefficients are then obtained in exactly the same way as for the first analysis instance.
The generation of the windows lpc winTbl, lpc asymwinTbl, and lpc lagwinTbl are typically done in advance, and the arrays are stored in ROM rather than repeating the calculation for every block.
Computation of LPC Coefficients From the 2 x 11 smoothed autocorrelation coefficients
, acf1 win and acf2 win, the 2 x 11 LPC coefficients, lp1 and lp2, are calculated in the same way for both analysis locations by using the well known Levinson Durbin recursion.
The first LPC coefficient is always 1.0, resulting in ten unique coefficients.
After determining the LPC coefficients, a bandwidth expansion procedure is applied to smooth the spectral peaks in the short term spectrum.
The bandwidth addition is obtained by the following modification of the LPC coefficients: lp1 bw[i]
FILTERORDER where "chirp" is a real number between 0 and 1.
It is RECOMMENDED to use a value of 0.9.
Computation of LSF Coefficients from LPC Coefficients
Thus far, two sets of LPC coefficients that represent the short term spectral characteristics of the speech signal for two different time locations within the current block have been determined.
These coefficients SHOULD be quantized and interpolated.
Before this is done, it is advantageous to convert the LPC parameters into another type of representation called Line Spectral Frequencies (LSF).
The LSF parameters are used because they are better suited for quantization and interpolation than the regular LPC coefficients.
Many computationally efficient methods for calculating the LSFs from the LPC coefficients have been proposed in the literature.
The detailed implementation of one applicable method can be found in Appendix A.26.
The two arrays of LSF coefficients obtained, lsf1 and lsf2, are of dimension 10 (LPC FILTERORDER).
Quantization of LSF Coefficients Because the LPC filters defined by the two sets of LSFs are also needed in the decoder, the LSF parameters need to be quantized and transmitted as side information.
The total number of bits required to represent the quantization of the two LSF representations for one block of speech is 40, with 20 bits used for each of lsf1 and lsf2.
For computational and storage reasons, the LSF vectors are quantized using three split vector quantization (VQ).
That is, the LSF vectors are split into three sub vectors that are each quantized with a regular VQ.
The quantized versions of lsf1 and lsf2, qlsf1 and qlsf2, are obtained by using the same memoryless split VQ.
The length of each of these two LSF vectors is 10, and they are split into three sub vectors containing 3, 3, and 4 values, respectively.
For each of the sub vectors, a separate codebook of quantized values has been designed with a standard VQ training method for a large database containing speech from a large number of speakers recorded under various conditions.
Both sets of LSF coefficients, lsf1 and lsf2, are quantized with a standard memoryless split vector quantization (VQ) structure using the squared error criterion in the LSF domain.
The split VQ quantization consists of the following steps: 1) Quantize the first three LSF coefficients (1 3) with a VQ codebook of size 64.
2) Quantize the next three LSF coefficients 4 6 with VQ a codebook of size 128.
Quantize the last four LSF coefficients (7 10) with a VQ codebook of size 128.
This procedure, repeated for lsf1 and lsf2, gives six quantization indices and the quantized sets of LSF coefficients qlsf1 and qlsf2.
Each set of three indices is encoded with 6
The total number of bits used for LSF quantization in a block is thus 40 bits.
Stability Check of LSF Coefficients
The LSF representation of the LPC filter has the convenient property that the coefficients are ordered by increasing value, i.e., lsf(n 1) < lsf(n), 0 < n < 10, if the corresponding synthesis filter is stable.
As we are employing a split VQ scheme, it is possible that at the split boundaries the LSF coefficients are not ordered correctly and hence that the corresponding LP filter is unstable.
To ensure that the filter used is stable, a stability check is performed for the quantized LSF vectors.
If it turns out that the coefficients are not ordered appropriately (with a safety margin of 50 Hz to ensure that formant peaks are not too narrow), they will be moved apart.
The detailed method for this can be found in Appendix A.40.
The same procedure is performed in the decoder.
This ensures that exactly the same LSF representations are used in both encoder and decoder.
Interpolation of LSF Coefficients From the two sets of LSF coefficients that are computed for each block of speech, different LSFs are obtained for each sub block by means of interpolation.
This procedure is performed for the original LSFs (lsf1 and lsf2), as well as the quantized versions qlsf1 and qlsf2, as both versions are used in the encoder.
Here follows a brief summary of the interpolation scheme; the details are found in the c code of Appendix A.
In the first sub block, the average of the second LSF vector from the previous block and the first LSF vector in the current block is used.
For sub blocks two through five, the LSFs used are obtained by linear interpolation from lsf1 (and qlsf1) to lsf2 (and qlsf2), with lsf1 used in sub block two and lsf2 in sub  block five.
In the last sub block, lsf2 is used.
For the very first block it is assumed that the last LSF vector of the previous block is equal to a predefined vector, lsfmeanTbl, obtained by calculating the mean LSF vector of the LSF design database.
The interpolation method is standard linear interpolation in the LSF domain.
The interpolated LSF values are converted to LPC coefficients for each sub block.
The unquantized and quantized LPC coefficients form two sets of filters respectively.
The unquantized analysis filter for sub block k is defined as follows
The quantized analysis filter for sub block k is defined as follows
LPC FILTERORDER A reference implementation of the lsf encoding is given in Appendix A.38.
A reference implementation of the corresponding decoding can be found in Appendix A.36.
LPC Analysis and Quantization for 20 ms Frames As previously stated, the codec only calculates one set of LPC parameters for the 20 ms frame size as opposed to two sets for 30 ms frames.
A single set of autocorrelation coefficients is calculated on the LPC LOOKBACK   BLOCKL   80
These samples are windowed with the asymmetric window lpc asymwinTbl, centered over the third sub frame, to form speech hp win.
Autocorrelation coefficients, acf, are calculated on the 240 samples in speech hp win and then windowed exactly as in section 3.2.1 (resulting in acf win).
This single set of windowed autocorrelation coefficients is used to calculate LPC coefficients, LSF coefficients, and quantized LSF coefficients in exactly the same manner as in sections 3.2.3 through 3.2.4.
As for the 30 ms frame size, the ten LSF coefficients are divided into three sub vectors of size 3, 3, and 4 and quantized by using the same scheme and codebook as in section 3.2.4 to finally get 3 quantization indices.
The quantized LSF coefficients are stabilized with the algorithm described in section 3.2.5.
From the set of LSF coefficients computed for this block and those from the previous block, different LSFs are obtained for each sub  block by means of interpolation.
The interpolation is done linearly in the LSF domain over the four sub blocks, so that the n th sub  frame uses the weight (4 n)/4 for the LSF from old frame and the weight n/4 of the LSF from the current frame.
For the very first block the mean LSF, lsfmeanTbl, is used as the LSF from the previous block.
Similarly as seen in section 3.2.6, both unquantized, A(z), and quantized, A~(z), analysis filters are calculated for each of the four sub blocks.
The block of speech samples is filtered by the quantized and interpolated LPC analysis filters to yield the residual signal.
In particular, the corresponding LPC analysis filter for each 40 sample sub block is used to filter the speech samples for the same sub  block.
The filter memory at the end of each sub block is carried over to the LPC filter of the next sub block.
The signal at the output of each LP analysis filter constitutes the residual signal for the corresponding sub block.
A reference implementation of the LPC analysis filters is given in Appendix A.10.
In principle any good design of a perceptual weighting filter can be applied in the encoder without compromising this codec definition.
However, it is RECOMMENDED to use the perceptual weighting filter Wk for sub block k specified below
Ak(z/LPC CHIRP WEIGHTDENUM), where LPC CHIRP WEIGHTDENUM   0.4222
This is a simple design with low complexity that is applied in the LPC residual domain.
Here Ak(z) is the filter obtained for sub block k from unquantized but interpolated LSF coefficients.
The start state is quantized by using a common 6 bit scalar quantizer for the block and a 3 bit scalar quantizer operating on scaled samples in the weighted speech domain.
In the following we describe the state encoding in greater detail.
The two sub blocks containing the start state are determined by finding the two consecutive sub blocks in the block having the highest power.
Advantageously, down weighting is used in the beginning and end of the sub frames, i.e., the following measure is computed (NSUB 4/6 for 20/30 ms frame size):
,NSUB 1 ssqn[nsub]   0.0; for (i (nsub 1) SUBL; i<(nsub 1) SUBL 5; i ) ssqn[nsub]
sampEn win[i (nsub 1) SUBL]
for (i (nsub 1) SUBL 5; i<(nsub 1) SUBL 5
for (i (nsub 1) SUBL 5; i<(nsub 1) SUBL
SUBL i 1]  residual[i] residual[i];
where sampEn win[5] {1/6, 2/6, 3/6, 4/6, 5/6}; MAY be used.
The sub frame number corresponding to the maximum value of ssqEn win[nsub 1] ssqn[nsub] is selected as the start state indicator.
A weighting of ssqEn win[] {0.8,0.9,1.0,0.9,0.8} for 30 ms frames and ssqEn win[] {0.9,1.0,0.9} for 20 ms frames; MAY advantageously be used to bias the start state towards the middle of the frame.
For 20 ms frames there are three possible positions for the two sub  block length maximum power segment; the start state position is encoded with 2 bits.
The start state position, start, MUST be encoded as start 1: start state in sub frame 0 and 1 start 2: start state in sub frame 1 and 2 start 3: start state in sub frame 2 and 3 For 30 ms frames there are five possible positions of the two sub  block length maximum power segment, the start state position is encoded with 3 bits.
The start state position, start, MUST be encoded as start 1: start state in sub frame 0 and 1 start 2: start state in sub frame 1 and 2 start 3: start state in sub frame 2 and 3 start 4: start state in sub frame 3 and 4 start 5:
start state in sub frame
4 and 5 Hence, in both cases, index 0 is not used.
In order to shorten the start state for bit rate efficiency, the start state is brought down to STATE SHORT LEN 57 samples for 20 ms frames and STATE SHORT LEN 58 samples for 30 ms frames.
The power of the first 23/22 and last 23/22 samples of the two sub frame blocks identified above is computed as the sum of the squared signal sample values, and the 23/22 sample segment with the lowest power is excluded from the start state.
One bit is transmitted to indicate which of the two possible 57/58 sample segments is used.
The start state position within the two sub frames determined above, state first, MUST be encoded as state first 1:
state is first STATE SHORT LEN samples state first 0:
start state is last STATE SHORT LEN samples 3.5.2.
All Pass Filtering and Scale Quantization
The block of residual samples in the start state is first filtered by an all pass filter with the quantized LPC coefficients as denominator and reversed quantized LPC coefficients as numerator.
The purpose of this phase dispersion filter is to get a more even distribution of the sample values in the residual signal.
The filtering is performed by circular convolution, where the initial filter memory is set to zero.
(2 STATE SHORT LEN 1))
FILTERORDER 1) and A~k(z) is taken from the block where the start state begins res   Pk(z)
filtered(k STATE SHORT LEN), k 0..(STATE SHORT LEN 1)
filtered block is searched for its largest magnitude sample.
The 10 logarithm of this magnitude is quantized with a 6 bit quantizer, state frgqTbl, by finding the nearest representation.
This results in an index, idxForMax, corresponding to a quantized value, qmax.
The all pass filtered residual samples in the block are then multiplied with a scaling factor scal 4.5/(10^qmax) to yield normalized samples.
{1.000085, 1.071695, 1.140395, 1.206868, 1.277188, 1.351503, 1.429380, 1.500727, 1.569049, 1.639599, 1.707071, 1.781531, 1.840799, 1.901550, 1.956695, 2.006750, 2.055474, 2.102787, 2.142819, 2.183592, 2.217962, 2.257177, 2.295739, 2.332967, 2.369248, 2.402792, 2.435080, 2.468598, 2.503394, 2.539284, 2.572944, 2.605036, 2.636331, 2.668939, 2.698780, 2.729101, 2.759786, 2.789834, 2.818679, 2.848074, 2.877470, 2.906899, 2.936655, 2.967804, 3.000115, 3.033367, 3.066355, 3.104231, 3.141499, 3.183012, 3.222952, 3.265433, 3.308441, 3.350823, 3.395275, 3.442793, 3.490801, 3.542514, 3.604064, 3.666050, 3.740994, 3.830749, 3.938770, 4.101764} 3.5.3.
The normalized samples are quantized in the perceptually weighted speech domain by a sample by sample scalar DPCM quantization as depicted in Figure 3.3.
Each sample in the block is filtered by a weighting filter Wk(z), specified in section 3.4, to form a weighted speech sample x[n].
The target sample d[n] is formed by subtracting a predicted sample y[n], where the prediction filter is given by Pk(z)   1 1 / Wk(z).
Quantization of start state samples by DPCM in weighted speech domain.
The coded state sample u[n] is obtained by quantizing d[n] with a 3  bit quantizer with quantization table state sq3Tbl.
{ 3.719849,  2.177490,  1.130005,  0.309692, 0.444214, 1.329712, 2.436279, 3.983887} The quantized samples are transformed back to the residual domain by 1) scaling with 1/scal; 2) time reversing the scaled samples; 3) filtering the time reversed samples by the same all pass filter, as in section 3.5.2, by using circular convolution; and 4) time  reversing the filtered samples.
(More detail is in section 4.2.)
A reference implementation of the start state encoding can be found in Appendix A.46.
Encoding the Remaining Samples A dynamic codebook is used to encode 1)
the 23/22 remaining samples in the two sub blocks containing the start state; 2) the sub blocks after the start state in time; and 3)
the sub blocks before the start state in time.
Thus, the encoding target can be either the 23/22 samples remaining of the 2 sub blocks containing the start state, or a 40 sample sub block.
This target can consist of samples that are indexed forward in time or backward in time, depending on the location of the start state.
The length of the target is denoted by lTarget.
The coding is based on an adaptive codebook that is built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block.
These samples are indexed in the same time direction as is the target vector and end at the sample instant prior to the first sample instant represented in the target vector.
The codebook memory has length lMem, which is equal to CB MEML 147 for the two/four 40 sample sub blocks and 85 for the 23/22 sample sub block.
The following figure shows an overview of the encoding procedure.
Flow chart of the codebook search in the iLBC encoder.
Decode the part of the residual that has been encoded so far, using the codebook without perceptual weighting.
Set up the memory by taking data from the decoded residual.
This memory is used to construct codebooks.
For blocks preceding the start state, both the decoded residual and the target are time reversed (section 3.6.1).
Filter the memory   target with the perceptual weighting filter (section 3.6.2).
Search for the best match between the target and the codebook vector.
Compute the optimal gain for this match and quantize that gain (section 3.6.4).
Update the perceptually weighted target by subtracting the contribution from the selected codebook vector from the perceptually weighted memory (quantized gain times selected vector).
Repeat 4 and 5 for the two additional stages.
Calculate the energy loss due to encoding of the residual.
If needed, compensate for this loss by an upscaling and requantization of the gain for the first stage (section 3.7).
The following sections provide an in depth description of the different blocks of Figure 3.4.
The codebook memory is based on the already encoded sub blocks, so the available data for encoding increases for each new sub block that has been encoded.
Until enough sub blocks have been encoded to fill the codebook memory with data, it is padded with zeros.
The following figure shows an example of the order in which the sub  blocks are encoded for the 30 ms frame size if the start state is located in the last 58 samples of sub block 2 and 3.
The order from 1 to 5 in which the sub blocks are encoded.
The slashed area is the start state.
The first target sub block to be encoded is number 1, and the corresponding codebook memory is shown in the following figure.
As the target vector comes before the start state in time, the codebook memory and target vector are time reversed; thus, after the block has been time reversed the search algorithm can be reused.
As only the start state has been encoded so far, the last samples of the codebook memory are padded with zeros.
The codebook memory, length lMem 85 samples, and the target vector 1, length 22 samples.
The next step is to encode sub block 2 by using the memory that now has increased since sub block 1 has been encoded.
The following figure shows the codebook memory for encoding of sub block 2.
The codebook memory, length lMem 147 samples, and the target vector 2, length 40 samples.
The next step is to encode sub block 3 by using the memory which has been increased yet again since sub blocks 1 and 2 have been encoded, but the sub block still has to be padded with a few zeros.
The following figure shows the codebook memory for encoding of sub block 3.
The codebook memory, length lMem 147 samples, and the target vector 3, length 40 samples.
The next step is to encode sub block 4 by using the memory which now has increased yet again since sub blocks 1, 2, and 3 have been encoded.
This time, the memory does not have to be padded with zeros.
The following figure shows the codebook memory for encoding of sub block 4.
The codebook memory, length lMem 147 samples, and the target vector 4, length 40 samples.
The final target sub block to be encoded is number 5, and the following figure shows the corresponding codebook memory.
As the target vector comes before the start state in time, the codebook memory and target vector are time reversed.
The codebook memory, length lMem 147 samples, and the target vector 5, length 40 samples.
For the case of 20 ms frames, the encoding procedure looks almost exactly the same.
The only difference is that the size of the start state is 57 samples and that there are only three sub blocks to be encoded.
The encoding order is the same as above, starting with the 23 sample target and then encoding the two remaining 40 sample sub  blocks, first going forward in time and then going backward in time relative to the start state.
Perceptual Weighting of Codebook Memory and Target
To provide a perceptual weighting of the coding error, a concatenation of the codebook memory and the target to be coded is all pole filtered with the perceptual weighting filter specified in section 3.4.
The filter state of the weighting filter is set to zero.
unweighted target signal in   Wk(z)
filtered, where Wk(z) is taken from the sub block of the target weighted codebook memory
(lMem 1)) weighted target signal   filtered(lMem..
The codebook search is done with the weighted codebook memory and the weighted target, whereas the decoding and the codebook memory update uses the unweighted codebook memory.
The codebook for the search is created from the perceptually weighted codebook memory.
It consists of two sections, where the first is referred to as the base codebook and the second as the expanded codebook, as it is created by linear combinations of the first.
Each of these two sections also has a subsection referred to as the augmented codebook.
The augmented codebook is only created and used for the coding of the 40 sample sub blocks and not for the 23/22  sample sub block case.
The codebook size used for the different sub blocks and different stages are summarized in the table below.
Codebook sizes for the 30 ms mode.
Table 3.1 shows the codebook size for the different sub blocks and stages for 30 ms frames.
Inside the parentheses it shows how the number of codebook vectors is distributed, within the two sections, between the base/expanded codebook and the augmented base/expanded codebook.
It should be interpreted in the following way: (base/expanded cb
The total number of codebook vectors for a specific sub block and stage is given by the following formula: Tot.
The corresponding values to Figure 3.1 for 20 ms frames are only slightly modified.
The short sub block is 23 instead of 22 samples, and the 3:rd and 4:th sub frame are not present.
Creation of a Base Codebook
The base codebook is given by the perceptually weighted codebook memory that is mentioned in section 3.5.3.
The different codebook vectors are given by sliding a window of length 23/22 or 40, given by variable lTarget, over the lMem long perceptually weighted codebook memory.
The indices are ordered so that the codebook vector containing sample (lMem lTarget n) to (lMem n 1) of the codebook memory vector has index n, where n 0..lMem lTarget.
Thus the total number of base codebook vectors is lMem lTarget 1, and the indices are ordered from sample delay lTarget (23/22 or 40) to lMem 1 (86 or 148).
The base codebook is expanded by a factor of 2, creating an additional section in the codebook.
This new section is obtained by filtering the base codebook, base cb, with a FIR filter with filter length CB FILTERLEN 8.
The construction of the expanded codebook compensates for the delay of four samples introduced by the FIR filter.
where x(j)   base cb(j) for j 0..lMem 1 and 0
otherwise The individual codebook vectors of the new filtered codebook, exp cb, and their indices are obtained in the same fashion as described above for the base codebook.
For cases where encoding entire sub blocks, i.e., cbveclen 40, the base and expanded codebooks are augmented to increase codebook richness.
The codebooks are augmented by vectors produced by interpolation of segments.
The base and expanded codebook, constructed above, consists of vectors corresponding to sample delays in the range from cbveclen to lMem.
The codebook augmentation attempts to augment these codebooks with vectors corresponding to sample delays from 20 to 39.
However, not all of these samples are present in the base codebook and expanded codebook, respectively.
Therefore, the augmentation vectors are constructed as linear combinations between samples corresponding to sample delays in the range 20 to 39.
The general idea of this procedure is presented in the following figures and text.
The procedure is performed for both the base codebook and the expanded codebook.
Generation of the first augmented codebook.
Figure 3.11 shows the codebook memory with pointers pi, pp, and po, where pi points to sample 25, pp to sample 20, and po to sample 5.
Below the codebook memory, the augmented codebook vector corresponding to sample delay 20 is drawn.
Segment i consists of fifteen samples from pointer pp and forward in time.
Segment ii consists of five interpolated samples from pi and forward and from po and forward.
The samples are linearly interpolated with weights [0.0, 0.2, 0.4, 0.6, 0.8] for pi and weights [1.0, 0.8, 0.6, 0.4, 0.2] for po.
Segment iii consists of twenty samples from pp and forward.
The augmented codebook vector corresponding to sample delay 21 is produced by moving pointers pp and pi one sample backward in time.
This gives us the following figure.
Generation of the second augmented codebook.
Figure 3.12 shows the codebook memory with pointers pi, pp and po where pi points to sample 26, pp to sample 21, and po to sample 5.
Below the codebook memory, the augmented codebook vector corresponding to sample delay 21 is drawn.
Segment i now consists of sixteen samples from pp and forward.
Segment ii consists of five interpolated samples from pi and forward and from po and forward, and the interpolation weights are the same throughout the procedure.
Segment iii consists of nineteen samples from pp and forward.
The same procedure of moving the two pointers is continued until the last augmented vector corresponding to sample delay 39 has been created.
This gives a total of twenty new codebook vectors to each of the two sections.
Thus the total number of codebook vectors for each of the two sections, when including the augmented codebook, becomes lMem  SUBL 1 SUBL/2.
This is provided that augmentation is evoked, i.e., that lTarget SUBL.
The codebook search uses the codebooks described in the sections above to find the best match of the perceptually weighted target, see section 3.6.2.
The search method is a multi stage gain shape matching performed as follows.
At each stage the best shape vector is identified, then the gain is calculated and quantized, and finally the target is updated in preparation for the next codebook search stage.
The number of stages is CB NSTAGES 3.
If the target is the 23/22 sample vector the codebooks are indexed so that the base codebook is followed by the expanded codebook.
If the target is 40 samples the order is as follows: base codebook, augmented base codebook, expanded codebook, and augmented expanded codebook.
The size of each codebook section and its corresponding augmented section is given by Table 3.1 in section 3.6.3.
For example, when the second 40 sample sub block is coded, indices 0 107 correspond to the base codebook, 108 127 correspond to the augmented base codebook, 128 235 correspond to the expanded codebook, and indices 236 255 correspond to the augmented expanded codebook.
The indices are divided in the same fashion for all stages in the example.
Only in the case of coding the first 40 sample sub  block is there a difference between stages (see Table 3.1).
Codebook Search at Each Stage
The codebooks are searched to find the best match to the target at each stage.
When the best match is found, the target is updated and the next stage search is started.
The three chosen codebook vectors and their corresponding gains constitute the encoded sub block.
The best match is decided by the following three criteria: 1.
The expression (target cbvec) is the dot product between the target vector to be coded and the codebook vector for which we compute the measure.
The norm,   x  , is defined as the square root of (x x).
The absolute value of the gain, corresponding to the chosen codebook vector, cbvec, must be smaller than a fixed limit, CB MAXGAIN 1.3:
For the first stage, the dot product of the chosen codebook vector and target must be positive: target cbvec > 0
In practice the above criteria are used in a sequential search through all codebook vectors.
The best match is found by registering a new max measure and index whenever the previously registered max measure is surpassed and all other criteria are fulfilled.
If none of the codebook vectors fulfill (2) and (3), the first codebook vector is selected.
Gain Quantization at Each Stage
The gain follows as a result of the computation gain   (target cbvec) /
^2 for the optimal codebook vector found by the procedure in section 3.6.4.1.
The three stages quantize the gain, using 5, 4, and 3 bits, respectively.
In the first stage, the gain is limited to positive values.
This gain is quantized by finding the nearest value in the quantization table gain sq5Tbl.
gain sq5Tbl[32] {0.037476, 0.075012, 0.112488, 0.150024, 0.187500, 0.224976, 0.262512, 0.299988, 0.337524, 0.375000, 0.412476, 0.450012, 0.487488, 0.525024, 0.562500, 0.599976, 0.637512, 0.674988, 0.712524, 0.750000, 0.787476, 0.825012, 0.862488, 0.900024, 0.937500, 0.974976, 1.012512, 1.049988, 1.087524, 1.125000, 1.162476, 1.200012}
The gains of the subsequent two stages can be either positive or negative.
The gains are quantized by using a quantization table times a scale factor.
The second stage uses the table gain sq4Tbl, and the third stage uses gain
The scale factor equates 0.1 or the absolute value of the quantized gain representation value obtained in the previous stage, whichever is larger.
Again, the resulting gain index is the index to the nearest value of the quantization table times the scale factor.
gain sq4Tbl[16] { 1.049988,  0.900024,  0.750000,  0.599976,  0.450012,  0.299988,  0.150024, 0.000000, 0.150024, 0.299988, 0.450012, 0.599976, 0.750000, 0.900024, 1.049988, 1.200012}
{ 1.000000,  0.659973,  0.330017,0.000000, 0.250000, 0.500000, 0.750000, 1.00000} 3.6.4.3.
Preparation of Target for Next Stage Before performing the search for the next stage, the perceptually weighted target vector is updated by subtracting from it the selected codebook vector (from the perceptually weighted codebook) times the corresponding quantized gain.
gainQ   selected vec[i]; A reference implementation of the codebook encoding is found in Appendix A.34.
The start state is quantized in a relatively model independent manner using 3 bits per sample.
In contrast, the remaining parts of the block are encoded by using an adaptive codebook.
This codebook will produce high matching accuracy whenever there is a high correlation between the target and the best codebook vector.
For unvoiced speech segments and background noises, this is not necessarily so, which, due to the nature of the squared error criterion, results in a coded signal with less power than the target signal.
As the coded start state has good power matching to the target, the result is a power fluctuation within the encoded frame.
Perceptually, the main problem with this is that the time envelope of the signal energy becomes unsteady.
To overcome this problem, the gains for the codebooks are re scaled after the codebook encoding by searching for a new gain factor for the first stage codebook that provides better power matching.
First, the energy for the target signal, tene, is computed along with the energy for the coded signal, cene, given by the addition of the three gain scaled codebook vectors.
Because the gains of the second and third stage scale with the gain of the first stage, when the first stage gain is changed from gain[0] to gain sq5Tbl[i] the energy of the coded signal changes from cene to cene (gain sq5Tbl[i] gain sq5Tbl[i])/(gain[0
where gain[0] is the gain for the first stage found in the original codebook search.
A refined search is performed by testing the gain indices i 0 to 31, and as long as the new codebook energy as given above is less than tene, the gain index for stage 1 is increased.
A restriction is applied so that the new gain value for stage 1 cannot be more than two times higher than the original value found in the codebook search.
Note that by using this method we do not change the shape of the encoded vector, only the gain or amplitude.
The total number of bits used to describe one frame of 20 ms speech is 304, which fits in 38 bytes and results in a bit rate of 15.20 kbit/s.
For the case of a frame length of 30 ms speech, the total number of bits used is 400, which fits in 50 bytes and results in a bit rate of 13.33 kbit/s.
In the bitstream definition, the bits are distributed into three classes according to their bit error or loss sensitivity.
The most sensitive bits (class 1) are placed first in the bitstream for each frame.
The less sensitive bits (class 2) are placed after the class 1 bits.
The least sensitive bits (class 3) are placed at the end of the bitstream for each frame.
In the 20/30 ms frame length cases for each class, the following hold true: The class 1 bits occupy a total of 6/8 bytes (48/64 bits), the class 2 bits occupy 8/12 bytes (64/96 bits), and the class 3 bits occupy 24/30 bytes (191/239 bits).
This distribution of the bits enables the use of uneven level protection (ULP) as is exploited in the payload format definition for iLBC [1].
The detailed bit allocation is shown in the table below.
When a quantization index is distributed between more classes, the more significant bits belong to the lowest class.
Split 1    NA (Not Appl.)
The bitstream definition for iLBC for both the 20 ms frame size mode and the 30 ms frame size mode.
When packetized into the payload, the bits MUST be sorted as follows:
All the class 1 bits in the order (from top to bottom) as specified in the table, all the class 2 bits (from top to bottom), and all the class 3 bits in the same sequential order.
The last bit, the empty frame indicator, SHOULD be set to zero by the encoder.
If this bit is set to 1 the decoder SHOULD treat the data as a lost frame.
For example, this bit can be set to 1 to indicate lost frame for file storage format, as in [1].
This section describes the principles of each component of the decoder algorithm.
Flow chart of the iLBC decoder.
If a frame was lost, steps 1 to 5 SHOULD be replaced by a PLC algorithm.
Extract the parameters from the bitstream.
Decode the LPC and interpolate (section 4.1).
Construct the 57/58 sample start state (section 4.2).
Set up the memory by using data from the decoded residual.
This memory is used for codebook construction.
For blocks preceding the start state, both the decoded residual and the target are time reversed.
Sub frames are decoded in the same order as they were encoded.
Construct the residuals of this sub frame (gain[0] cbvec[0]
Repeat 4 and 5 until the residual of all sub blocks has been constructed.
Enhance the residual with the post filter (section 4.6).
Synthesis of the residual (section 4.7).
Post process with HP filter, if desired (section 4.8).
The decoding of the LP filter parameters is very straightforward.
For a set of three/six indices, the corresponding LSF vector(s) are found by simple table lookup.
For each of the LSF vectors, the three split vectors are concatenated to obtain qlsf1 and qlsf2, respectively (in the 20 ms mode only one LSF vector, qlsf, is constructed).
The next step is the stability check described in section 3.2.5 followed by the interpolation scheme described in section 3.2.6 (3.2.7 for 20 ms frames).
The only difference is that only the quantized LSFs are known at the decoder, and hence the unquantized LSFs are not processed.
A reference implementation of the LPC filter reconstruction is given in Appendix A.36.
The scalar encoded STATE SHORT LEN 58 (STATE SHORT LEN 57 in
the 20 ms mode) state samples are reconstructed by 1) forming a set of samples (by table lookup) from the index stream idxVec[n], 2) multiplying the set with 1/scal (10^qmax)/4.5, 3) time reversing the 57/58 samples, 4) filtering the time reversed block with the dispersion (all pass) filter used in the encoder (as described in section 3.5.2); this compensates for the phase distortion of the earlier filter operation, and 5 reversing the 57/58 samples from the previous step.
time reversed samples from table look up, idxVecDec((STATE SHORT LEN 1)..0) in(STATE
(2 STATE SHORT LEN 1))
a~ki z^(i (LPC FILTERORDER 1))
FILTERORDER 1) and A~k(z) is taken from the block where the start state begins in   Pk(z)
filtered(2 STATE SHORT LEN 1 k), k 0..(STATE SHORT LEN 1)
The remaining 23/22 samples in the state are reconstructed by the same adaptive codebook technique described in section 4.3.
The location bit determines whether these are the first or the last 23/22 samples of the 80 sample state vector.
If the remaining 23/22 samples are the first samples, then the scalar encoded STATE SHORT LEN state samples are time reversed before initialization of the adaptive codebook memory vector.
A reference implementation of the start state reconstruction is given in Appendix A.44.
The decoding of the LPC excitation vector proceeds in the same order in which the residual was encoded at the encoder.
That is, after the decoding of the entire 80 sample state vector, the forward sub blocks (corresponding to samples occurring after the state vector samples) are decoded, and then the backward sub blocks (corresponding to samples occurring before the state vector) are decoded, resulting in a fully decoded block of excitation signal samples.
In particular, each sub block is decoded by using the multistage
adaptive codebook decoding module described in section 4.4.
This module relies upon an adaptive codebook memory constructed before each run of the adaptive codebook decoding.
The construction of the adaptive codebook memory in the decoder is identical to the method outlined in section 3.6.3, except that it is done on the codebook memory without perceptual weighting.
For the initial forward sub block, the last STATE LEN 80 samples of the length CB LMEM 147 adaptive codebook memory are filled with the samples of the state vector.
For subsequent forward sub blocks, the first SUBL 40 samples of the adaptive codebook memory are discarded, the remaining samples are shifted by SUBL samples toward the beginning of the vector, and the newly decoded SUBL 40 samples are placed at the end of the adaptive codebook memory.
For backward sub blocks, the construction is similar, except that every vector of samples involved is first time reversed.
A reference implementation of the excitation decoding loop is found in Appendix A.5.
The Multistage Adaptive Codebook Decoding module is used at both the sender (encoder) and the receiver (decoder) ends to produce a synthetic signal in the residual domain that is eventually used to produce synthetic speech.
The module takes the index values used to construct vectors that are scaled and summed together to produce a synthetic signal that is the output of the module.
Construction of the Decoded Excitation Signal
The unpacked index values provided at the input to the module are references to extended codebooks, which are constructed as described in section 3.6.3, except that they are based on the codebook memory without the perceptual weighting.
The unpacked three indices are used to look up three codebook vectors.
The unpacked three gain indices are used to decode the corresponding 3 gains.
In this decoding, the successive rescaling, as described in section 3.6.4.2, is applied.
A reference implementation of the adaptive codebook decoding is listed in Appendix A.32. 4.5.
If packet loss occurs, the decoder receives a signal saying that information regarding a block is lost.
For such blocks it is RECOMMENDED to use a Packet Loss Concealment (PLC) unit to create a decoded signal that masks the effect of that packet loss.
In the following we will describe an example of a PLC unit that can be used with the iLBC codec.
As the PLC unit is used only at the decoder, the PLC unit does not affect interoperability between implementations.
Other PLC implementations MAY therefore be used.
The PLC described operates on the LP filters and the excitation signals and is based on the following principles: 4.5.1.
Block Received Correctly and Previous Block
If the block is received correctly, the PLC only records state information of the current block that can be used in case the next block is lost.
The LP filter coefficients for each sub block and the entire decoded excitation signal are all saved in the decoder state structure.
All of this information will be needed if the following block is lost.
Block Not Received If the block is not received, the block substitution is based on a pitch synchronous repetition of the excitation signal, which is filtered by the last LP filter of the previous block.
The previous block's information is stored in the decoder state structure.
A correlation analysis is performed on the previous block's excitation signal in order to detect the amount of pitch periodicity and a pitch value.
The correlation measure is also used to decide on the voicing level (the degree to which the previous block's excitation was a voiced or roughly periodic signal).
The excitation in the previous block is used to create an excitation for the block to be substituted, such that the pitch of the previous block is maintained.
Therefore, the new excitation is constructed in a pitch synchronous manner.
In order to avoid a buzzy sounding substituted block, a random excitation is mixed with the new pitch periodic excitation, and the relative use of the two components is computed from the correlation measure (voicing level).
For the block to be substituted, the newly constructed excitation signal is then passed through the LP filter to produce the speech that will be substituted for the lost block.
For several consecutive lost blocks, the packet loss concealment continues in a similar manner.
The correlation measure of the last block received is still used along with the same pitch value.
The LP filters of the last block received are also used again.
The energy of the substituted excitation for consecutive lost blocks is decreased, leading to a dampened excitation, and therefore to dampened speech.
When Previous Block Not Received For the case in which a block is received correctly when the previous block was not, the correctly received block's directly decoded speech (based solely on the received block) is not used as the actual output.
The reason for this is that the directly decoded speech does not necessarily smoothly merge into the synthetic speech generated for the previous lost block.
If the two signals are not smoothly merged, an audible discontinuity is accidentally produced.
Therefore, a correlation analysis between the two blocks of excitation signal (the excitation of the previous concealed block and that of the current received block) is performed to find the best phase match.
Then a simple overlap add procedure is performed to merge the previous excitation smoothly into the current block's excitation.
The exact implementation of the packet loss concealment does not influence interoperability of the codec.
A reference implementation of the packet loss concealment is suggested in Appendix A.14.
Exact compliance with this suggested algorithm is not needed for a reference implementation to be fully compatible with the overall codec specification.
The decoder contains an enhancement unit that operates on the reconstructed excitation signal.
The enhancement unit increases the perceptual quality of the reconstructed signal by reducing the speech correlated noise in the voiced speech segments.
Compared to traditional postfilters, the enhancer has an advantage in that it can only modify the excitation signal slightly.
This means that there is no risk of over enhancement.
The enhancer works very similarly for both the 20 ms frame size mode and the 30 ms frame size mode.
For the mode with 20 ms frame size, the enhancer uses a memory of six 80 sample excitation blocks prior in time plus the two new 80 sample excitation blocks.
For each block of 160 new unenhanced excitation samples, 160 enhanced excitation samples are produced.
The enhanced excitation is 40 sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.
For the mode with 30 ms frame size, the enhancer uses a memory of five 80 sample excitation blocks prior in time plus the three new 80 sample excitation blocks.
For each block of 240 new unenhanced excitation samples, 240 enhanced excitation samples are produced.
The enhanced excitation is 80 sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.
The speech enhancement unit operates on sub blocks of 80 samples, which means that there are two/three 80 sample sub blocks per frame.
Each of these two/three sub blocks is enhanced separately, but in an analogous manner.
Flow chart of the enhancer.
Pitch estimation of each of the two/three new 80 sample blocks.
Find the pitch period synchronous sequence n (for block k) by a search around the estimated pitch value.
Do this for n 1,2,3,  1, 2, 3.
Calculate the smoothed residual generated by the six pitch  period synchronous sequences from prior step.
Check if the smoothed residual satisfies the criterion (section 4.6.4).
Use constraint to calculate mixing factor (section 4.6.5).
Mix smoothed signal with unenhanced residual (pssq(n) n 0).
The main idea of the enhancer is to find three 80 sample blocks before and three 80 sample blocks after the analyzed unenhanced sub  block and to use these to improve the quality of the excitation in that sub block.
The six blocks are chosen so that they have the highest possible correlation with the unenhanced sub block that is being enhanced.
In other words, the six blocks are pitch period  synchronous sequences to the unenhanced sub block.
A linear combination of the six pitch period synchronous sequences is calculated that approximates the sub block.
If the squared error between the approximation and the unenhanced sub block is small enough, the enhanced residual is set equal to this approximation.
For the cases when the squared error criterion is not fulfilled, a linear combination of the approximation and the unenhanced residual forms the enhanced residual.
Estimating the Pitch Pitch estimates are needed to determine the locations of the pitch  period synchronous sequences in a complexity efficient way.
For each of the new two/three sub blocks, a pitch estimate is calculated by finding the maximum correlation in the range from lag 20 to lag 120.
These pitch estimates are used to narrow down the search for the best possible pitch period synchronous sequences.
Determination of the Pitch Synchronous Sequences Upon receiving the pitch estimates from the prior step
, the enhancer analyzes and enhances one 80 sample sub block at a time.
The pitch  period synchronous sequences pssq(n) can be viewed as vectors of length 80 samples each shifted n lag samples from the current sub  block.
The six pitch period synchronous sequences, pssq( 3) to pssq( 1) and pssq(1) to pssq(3), are found one at a time by the steps below: 1) Calculate the estimate of the position of the pssq(n).
For pssq(n) in front of pssq(0) (n > 0), the location of the pssq(n) is estimated by moving one pitch estimate forward in time from the exact location of pssq(n 1).
behind pssq(0) (n < 0) is estimated by moving one pitch estimate backward in time from the exact location of pssq(n 1).
If the estimated pssq(n) vector location is totally within the enhancer memory (Figure 4.3), steps 2, 3, and 4 are performed, otherwise the pssq(n) is set to zeros.
2) Compute the correlation between the unenhanced excitation and vectors around the estimated location interval of pssq(n).
This results in five correlation values.
The five correlation values are upsampled by a factor of 4, by using four simple upsampling filters (MA filters with coefficients upsFilter1.. upsFilter4).
Within these the maximum value is found, which specifies the best pitch period with a resolution of a quarter of a sample.
0.000000 0.000000 0.000000} upsFilter2[7] {0.015625
0.106445 0.018799  0.015625} upsFilter3[7] {
0.018799} 4) Generate the pssq(n) vector by upsampling of the excitation memory and extracting the sequence that corresponds to the lag delay that was calculated in prior step.
With the steps above, all the pssq(n) can be found in an iterative manner, first moving backward in time from pssq(0) and then forward in time from pssq(0).
Enhancement for 20 ms frame size.
Figure 4.3 depicts pitch period synchronous sequences in the enhancement of the first 80 sample block in the 20 ms frame size mode.
The unenhanced signal input is stored in the last two sub  blocks (1 2), and the six other sub blocks contain unenhanced residual prior in time.
We perform the enhancement algorithm on two blocks of 80 samples, where the first of the two blocks consists of the last 40 samples of sub block 0 and the first 40 samples of sub  block 1.
The second 80 sample block consists of the last 40 samples of sub block 1 and the first 40 samples of sub block 2. 0
Enhancement for 30 ms frame size.
Figure 4.4 depicts pitch period synchronous sequences in the enhancement of the first 80 sample block in the 30 ms frame size mode.
The unenhanced signal input is stored in the last three sub  blocks (1 3).
The five other sub blocks contain unenhanced residual prior in time.
The enhancement algorithm is performed on the three 80 sample sub blocks 0, 1, and 2.
Calculation of the Smoothed Excitation
A linear combination of the six pssq(n)
(n! 0) form a smoothed approximation, z, of pssq(0).
Most of the weight is put on the sequences that are close to pssq(0), as these are likely to be most similar to pssq(0).
The smoothed vector is also rescaled so that the energy of z is the same as the energy of pssq(0).
i  3, 2, 1,1,2,3 pssq weight(i)
The criterion of the enhancer is that the enhanced excitation is not allowed to differ much from the unenhanced excitation.
This criterion is checked for each 80 sample sub block.
Enhancing the excitation From the criterion in the previous section, it is clear that the excitation is not allowed to change much.
The purpose of this constraint is to prevent the creation of an enhanced signal significantly different from the original signal.
This also means that the constraint limits the numerical size of the errors that the enhancement procedure can make.
That is especially important in unvoiced segments and background noise segments for which increased periodicity could lead to lower perceived quality.
When the constraint in the prior section is not met, the enhanced residual is instead calculated through a constrained optimization by using the Lagrange multiplier technique.
In the first case, where the second constraint is not needed, the optimized re estimated vector is simply z, the energy scaled version of y.
In the second case, where the second constraint is activated and becomes an equality constraint, we have z
where A   sqrt((b b^2/4) (w00 w00)/ (w11 w00   w10 w10)) and w11
(  symbolizes the dot product) and B   1 b/2 A
w10/w00 Appendix A.16 contains a listing of a reference implementation for the enhancement method.
Synthesis Filtering Upon decoding or PLC of the LP excitation block, the decoded speech block is obtained by running the decoded LP synthesis filter, 1/A~k(z), over the block.
The synthesis filters have to be shifted to compensate for the delay in the enhancer.
For 20 ms frame size mode, they SHOULD be shifted one 40 sample sub block, and for 30 ms frame size mode, they SHOULD be shifted two 40 sample sub blocks.
The LP coefficients SHOULD be changed at the first sample of every sub block while keeping the filter state.
For PLC blocks, one solution is to apply the last LP coefficients of the last decoded speech block for all sub blocks.
The reference implementation for the synthesis filtering can be found in Appendix A.48.
If desired, the decoded block can be filtered by a high pass filter.
This removes the low frequencies of the decoded signal.
A reference implementation of this, with cutoff at 65 Hz, is shown in Appendix A.30.
This algorithm for the coding of speech signals is not subject to any known security consideration; however, its RTP payload format [1] is subject to several considerations, which are addressed there.
Confidentiality of the media streams is achieved by encryption; therefore external mechanisms, such as SRTP [5], MAY be used for that purpose.
It is possible and suggested to evaluate certain iLBC implementation by utilizing methodology and tools available at http://www.ilbcfreeware.org/evaluation.html APPENDIX A.  Reference Implementation
This appendix contains the complete c code for a reference implementation of encoder and decoder for the specified codec.
The c code consists of the following files with highest level functions:
iLBC test.c: main function for evaluation purpose
decoder function The following files contain global defines and constants:
iLBC define.h: global defines constants.h: global constants header constants.c:
global constants memory allocations The following files contain subroutines:
anaFilter.h: lpc analysis filter header anaFilter.c:
lpc analysis filter function createCB.h: codebook construction header createCB.c: codebook construction function
packet loss concealment header doCPLC.c:
packet loss concealment function enhancer.h:
signal enhancement header enhancer.c: signal enhancement function filter.h: general filter header filter.c: general filter functions FrameClassify.h: start state classification header FrameClassify.c: start state classification function gainquant.h:
codebook vector construction header getCBvec.c:
codebook vector construction function helpfun.h: general purpose header helpfun.c:
hpInput.h: input high pass filter header
hpInput.c: input high pass filter function
hpOutput.h: output high pass filter header
hpOutput.c: output high pass filter function iCBConstruct.h:
excitation decoding header iCBConstruct.c: excitation decoding function iCBSearch.h: excitation encoding header iCBSearch.c: excitation encoding function LPCdecode.h: lpc decoding header LPCdecode.c: lpc decoding function LPCencode.h: lpc encoding header LPCencode.c: lpc encoding function lsf.h: line spectral frequencies header lsf.c: line spectral frequencies functions
: bitstream packetization functions StateConstructW.h:
state encoding header StateSearchW.c: state encoding function syntFilter.h:
lpc synthesis filter header syntFilter.c: lpc synthesis filter function
The implementation is portable and should work on many different platforms.
However, it is not difficult to optimize the implementation on particular platforms, an exercise left to the reader.
iLBC Speech Coder ANSI C Source Code iLBC
#include <math.h> #include <stdlib.h> #include <stdio.h
> #include <string.h> #include "
The signal block to encode / )
/  do the actual encoding
/ iLBC encode((unsigned char  )encoded data, block,
float decblock[BLOCKL MAX], dtmp; /
check if mode is valid  /
k<iLBCdec inst blockl; k ){ dtmp decblock[k]; if (dtmp<MIN SAMPLE) dtmp MIN SAMPLE; else if (dtmp>MAX SAMPLE)
dtmp MAX SAMPLE; decoded data[k]
decoded : Decoded speech (16 bit pcm file)\n");
{ fprintf(stderr, "Cannot open encoded file %s\n", argv[3])
; exit(1);} if ( (ofileid fopen(argv[4],"wb"))
{ fprintf(stderr, "Cannot open channel file %s\n", argv[5])
Enc Inst.blockl) { blockcount ; /
iLBC Speech Coder ANSI C Source Code iLBC encode.h
iLBC ILBCENCODE H #include "iLBC define.h" short initEncode(
/  (o) Number of bytes encoded  /
iLBC Speech Coder ANSI C Source Code iLBC
#include <math.h> #include <stdlib.h> #include <string.h> #include "
" #include "LPCencode.h" #include "FrameClassify.h
{ iLBCenc inst mode   mode; if (mode 30) { iLBCenc inst blockl
; iLBCenc inst lpc n
inst ULP inst &ULP 30msTbl; } else if (mode 20) { iLBCenc
inst ULP inst &ULP 20msTbl
; } else { exit(2)
; } memset(( iLBCenc inst).anaMem, 0, LPC FILTERORDER sizeof(float)); memcpy(( iLBCenc inst).lsfold, lsfmeanTbl, LPC FILTERORDER sizeof(float)); memcpy(( iLBCenc inst).lsfdeqold, lsfmeanTbl, LPC FILTERORDER sizeof(float)); memset(( iLBCenc inst).lpc buffer, 0, (LPC LOOKBACK BLOCKL MAX) sizeof(float))
; float residual[BLOCKL MAX], reverseResidual[BLOCKL MAX]; int start, idxForMax, idxVec[STATE LEN]; float reverseDecresidual[BLOCKL MAX], mem[CB MEML]; int n, k, meml gotten, Nfor, Nback, i, pos;
int gain index[CB NSTAGES NASUB MAX], extra gain index[CB NSTAGES]; int cb index[CB NSTAGES NASUB MAX],extra cb index[CB NSTAGES]; int lsf i[LSF NSPLIT LPC N MAX]; unsigned char  pbytes; int diff, start pos, state first; float en1, en2; int index, ulp, firstpart; int subcount, subframe; float weightState[LPC FILTERORDER]; float syntdenum[NSUB MAX (LPC FILTERORDER 1)]; float weightdenum[NSUB MAX (LPC FILTERORDER 1)]; float decresidual[BLOCKL MAX];
/  high pass filtering of input signal if such is not done prior to calling this function
inst blockl, data, ( iLBCenc inst).hpimem)
en1   0; index   (start 1) SUBL;
for (i   0; i < iLBCenc inst state short len
{ state first   1; start pos
(start 1) SUBL; } else { state first   0;
/ memset(mem, 0, (CB MEML iLBCenc inst state short len)
inst state short len, decresidual start pos, iLBCenc inst state short len
inst, extra cb index, extra gain index, &residual[start
pos iLBCenc inst state short len], mem CB MEML stMemLTbl, stMemLTbl, diff, CB NSTAGES, &weightdenum[start
inst state short len], extra cb index, extra gain index,
inst, extra cb index, extra gain index, reverseResidual,
mem CB MEML stMemLTbl, stMemLTbl, diff, CB NSTAGES, &weightdenum[(start 1)
mem CB MEML stMemLTbl, stMemLTbl, diff, CB NSTAGES)
/ memset(mem, 0, (CB MEML STATE LEN) sizeof(float))
CB MEML STATE LEN, decresidual (start 1) SUBL,
inst, cb index subcount CB NSTAGES, gain index subcount CB NSTAGES, &residual[(start 1 subframe) SUBL], mem CB MEML memLfTbl[subcount], memLfTbl[subcount], SUBL, CB NSTAGES, &weightdenum[(start 1 subframe)
/ memcpy(mem, mem SUBL, (CB MEML SUBL)
SUBL 1 n SUBL k]; reverseDecresidual[n SUBL k]
SUBL (iLBCenc inst nsub 1 start)
inst, cb index subcount CB NSTAGES, gain index subcount CB NSTAGES, &reverseResidual[subframe SUBL], mem CB MEML memLfTbl[subcount], memLfTbl[subcount], SUBL, CB NSTAGES, &weightdenum[(start 2 subframe)
/ memcpy(mem, mem SUBL, (CB MEML SUBL)
inst ULP inst lsf bits[k][ulp], iLBCenc inst ULP inst lsf bits[k][ulp]
inst ULP inst lsf bits[k][ulp 1]
], iLBCenc inst ULP inst start bits[ulp]
bits[ulp 2]); dopack( &pbytes, firstpart, iLBCenc inst ULP
packsplit(&state first, &firstpart, &state first, iLBCenc
], iLBCenc inst ULP inst startfirst
bits[ulp 2]); dopack( &pbytes, firstpart, iLBCenc
; packsplit(&idxForMax, &firstpart, &idxForMax, iLBCenc inst ULP inst scale bits[ulp]
inst ULP inst scale bits[ulp]
], iLBCenc inst ULP inst state bits[ulp]
inst ULP inst state bits[ulp
bits[ulp 2]); dopack( &pbytes, firstpart, iLBCenc
inst ULP inst extra cb
inst extra cb index[k][ulp 2]); dopack( &pbytes, firstpart, iLBCenc
inst extra cb index[k][ulp], &pos)
inst extra cb gain[k][ulp], iLBCenc
inst ULP inst extra cb
inst extra cb gain[k][ulp 2]); dopack( &pbytes, firstpart, iLBCenc
{ packsplit(cb index i CB NSTAGES k, &firstpart, cb index i CB
NSTAGES k, iLBCenc inst ULP inst cb index[i][k][ulp], iLBCenc
inst ULP inst cb index[i][k][ulp]
cb index[i][k][ulp 2]); dopack( &pbytes, firstpart, iLBCenc
{ packsplit(gain index i CB NSTAGES k, &firstpart, gain index i CB NSTAGES k, iLBCenc
inst ULP inst cb gain[i][k][ulp], iLBCenc
inst ULP inst cb gain[i][k][ulp]
inst ULP inst cb gain[i][k][ulp 1]
set the last bit to zero
(otherwise the decoder will treat it as a lost frame)
ANSI C Source Code iLBC decode.h
(i) encoded signal bits  /
iLBC Speech Coder ANSI C Source Code iLBC
iLBCdec inst mode   mode; if (mode 30) { iLBCdec
; } memset(iLBCdec inst syntMem, 0, LPC FILTERORDER sizeof(float)); memcpy(( iLBCdec inst).lsfdeqold, lsfmeanTbl, LPC FILTERORDER sizeof(float)); memset(iLBCdec inst old syntdenum, 0, ((LPC FILTERORDER   1) NSUB MAX)
sizeof(float)); for (i 0; i<NSUB MAX; i ) iLBCdec
iLBCdec inst last lag   20; iLBCdec inst
; iLBCdec inst per   0.0; iLBCdec
(i) codebook indexes for the samples  in the start state
the decoded synthesis filter coefficients
the indexes for the adaptive codebook
the indexes for the corresponding gains
the indexes for the adaptive codebook part of start state
the indexes for the corresponding gains
if (state first   1) { start pos
; } else { start pos
inst state short len, decresidual start pos, iLBCdec inst state short len sizeof(float))
inst state short len; for (k 0; k<meml gotten; k ){ mem[CB MEML 1 k]
/ memset(mem, 0, (CB MEML STATE LEN) sizeof(float))
CB MEML STATE LEN, decresidual (start 1) SUBL,
/ memcpy(mem, mem SUBL, (CB MEML SUBL)
1]; float zeros[BLOCKL MAX], one[LPC FILTERORDER
1]; int k, i, start, idxForMax, pos, lastpart, ulp; int lag, ilag; float cc, maxcc; int idxVec[STATE LEN]; int check;
int gain index[NASUB MAX CB NSTAGES], extra gain index[CB NSTAGES]; int cb index[CB NSTAGES NASUB MAX], extra cb index[CB NSTAGES]; int lsf i[LSF NSPLIT LPC N MAX]; int state first; int last bit; unsigned char  pbytes;
NSUB MAX]; int order plus one; float syntdenum[NSUB MAX (LPC FILTERORDER 1)]; float decresidual[BLOCKL
/ pbytes bytes; pos 0;
/  Set everything to zero before decoding  / for (k 0; k<LSF NSPLIT LPC N MAX; k )
k ){ unpack( &pbytes, &lastpart,
iLBCdec inst ULP inst lsf bits[k][ulp], &pos)
; packcombine(&state first, lastpart, iLBCdec inst ULP inst startfirst bits[ulp]); unpack( &pbytes, &lastpart, iLBCdec inst ULP inst scale bits[ulp], &pos); packcombine(&idxForMax, lastpart,
iLBCdec inst ULP inst scale bits[ulp])
iLBCdec inst ULP inst state
inst extra cb gain[k][ulp], &pos)
packcombine(extra gain index k, lastpart,
iLBCdec inst ULP inst cb index[i][k][ulp], &pos); packcombine(cb index i CB NSTAGES k, lastpart, iLBCdec
iLBCdec inst ULP inst cb gain[i][k][ulp], &pos)
; packcombine(gain index i CB NSTAGES k, lastpart, iLBCdec
/ if (start<1) mode   0; if (iLBCdec
inst mode 20 && start>3
) mode   0; if (iLBCdec
inst mode 30 && start>5)
/ doThePLC(PLCresidual, PLClpc, 0, decresidual, syntdenum
( iLBCdec inst).last lag, iLBCdec inst); memcpy(decresidual, PLCresidual, iLBCdec
/  the data is bad (either a PLC call   was made or a severe bit error was detected)
; one[0]   1; memset(one 1, 0, LPC FILTERORDER sizeof(float))
; start 0; doThePLC(PLCresidual, PLClpc, 1, zeros, one, ( iLBCdec
inst).last lag, iLBCdec inst); memcpy(decresidual, PLCresidual, iLBCdec
inst blockl sizeof(float)); order plus one   LPC FILTERORDER   1; for (i   0; i < iLBCdec
(LPC FILTERORDER 1), SUBL, iLBCdec inst syntMem); for (i 1; i < iLBCdec
/ lag   20; maxcc   xCorrCoef(&decresidual[BLOCKL
MAX ENH BLOCKL ilag], ENH BLOCKL); if (cc > maxcc) { maxcc   cc; lag   ilag; }
, decresidual, iLBCdec inst blockl sizeof(float)); for (i 0; i < iLBCdec
/ memcpy(iLBCdec inst old syntdenum, syntdenum
iLBC Speech Coder ANSI C Source Code iLBC
iLBC ILBCDEFINE H /  general codec settings  /
STATE SHORT LEN 30MS    58
#define STATE SHORT LEN 20MS    57 /  LPC settings  /
(ENH BLOCKL 2 ENH FL0)
38 #define NO OF BYTES 30MS
NO OF WORDS 30MS    25
ULP Inst t  { int lsf bits[6][ULP CLASSES 2]; int start bits[ULP CLASSES 2]
/ typedef struct iLBC Enc
int no of bytes, no of words; int lpc n; int state short len;
const iLBC ULP Inst t
signal buffer for LP analysis
/ typedef struct iLBC Dec
int no of bytes, no of words; int lpc n; int state short len;
const iLBC ULP Inst t
/  previous synthesis filter parameters
/ float old syntdenum[(LPC FILTERORDER
iLBC Speech Coder ANSI C Source Code
Inst t ULP 20msTbl; extern const iLBC ULP Inst t ULP 30msTbl;
/ extern float lpc winTbl
[]; extern float lpc asymwinTbl[]; extern float lpc lagwinTbl[]; extern float lsfCbTbl[]; extern float lsfmeanTbl[]; extern int
/ extern float gain sq3Tbl[];
iLBC Speech Coder ANSI C Source Code
{ (float) 3.719849, (float) 2.177490, (float) 1.130005,
(float) 0.309692, (float)0.444214, (float)1.329712, (float)2.436279, (float)3.983887 }; float state frgqTbl[64]
Enhancer Upsamling a factor 4 (ENH UPS0   4)
/ float polyphaserTbl[ENH UPS0 (
(float)0.042084, (float)0.044983, (float)0.047974, (float)0.051086, (float)0.054260, (float)0.057526, (float)0.060883, (float)0.064331, (float)0.067871, (float)0.071503, (float)0.075226, (float)0.079010, (float)0.082916, (float)0.086884, (float)0.090942, (float)0.095062, (float)0.099304, (float)0.103607, (float)0.107971, (float)0.112427, (float)0.116974, (float)0.121582, (float)0.126282, (float)0.131073, (float)0.135895, (float)0.140839, (float)0.145813, (float)0.150879, (float)0.156006, (float)0.161224, (float)0.166504, (float)0.171844, (float)0.177246, (float)0.182709, (float)0.188263, (float)0.193848, (float)0.199524, (float)0.205231, (float)0.211029, (float)0.216858, (float)0.222778, (float)0.228729, (float)0.234741, (float)0.240814, (float)0.246918, (float)0.253082, (float)0.259308, (float)0.265564, (float)0.271881, (float)0.278259, (float)0.284668, (float)0.291107, (float)0.297607, (float)0.304138, (float)0.310730, (float)0.317322, (float)0.323975, (float)0.330658, (float)0.337372, (float)0.344147, (float)0.350922, (float)0.357727, (float)0.364594, (float)0.371460, (float)0.378357, (float)0.385284, (float)0.392212, (float)0.399170, (float)0.406158, (float)0.413177, (float)0.420197, (float)0.427246, (float)0.434296, (float)0.441376, (float)0.448456, (float)0.455536, (float)0.462646, (float)0.469757, (float)0.476868, (float)0.483978, (float)0.491089, (float)0.498230, (float)0.505341, (float)0.512451, (float)0.519592, (float)0.526703, (float)0.533813, (float)0.540924, (float)0.548004, (float)0.555084, (float)0.562164, (float)0.569244, (float)0.576294, (float)0.583313, (float)0.590332, (float)0.597321, (float)0.604309, (float)0.611267, (float)0.618195, (float)0.625092, (float)0.631989, (float)0.638855, (float)0.645660, (float)0.652466, (float)0.659241, (float)0.665985, (float)0.672668, (float)0.679352, (float)0.685974, (float)0.692566, (float)0.699127, (float)0.705658, (float)0.712128, (float)0.718536, (float)0.724945, (float)0.731262, (float)0.737549, (float)0.743805, (float)0.750000, (float)0.756134, (float)0.762238, (float)0.768280, (float)0.774261, (float)0.780182, (float)0.786072, (float)0.791870, (float)0.797638, (float)0.803314, (float)0.808960, (float)0.814514, (float)0.820038, (float)0.825470, (float)0.830841, (float)0.836151, (float)0.841400, (float)0.846558, (float)0.851654, (float)0.856689, (float)0.861633, (float)0.866516, (float)0.871338, (float)0.876068, (float)0.880737, (float)0.885315, (float)0.889801, (float)0.894226, (float)0.898560, (float)0.902832, (float)0.907013, (float)0.911102, (float)0.915100,
(float)2.813477, (float)1.849365, (float)2.190918, (float)2.611572, (float)2.835083, (float)1.657959, (float)1.854370, (float)2.159058, (float)2.726196, (float)1.437744, (float)1.897705, (float)2.253174, (float)2.655396, (float)2.028687, (float)2.247314, (float)2.542358, (float)2.875854, (float)1.736938, (float)1.922119, (float)2.185913, (float)2.743408, (float)1.521606, (float)1.870972, (float)2.526855, (float)2.786987, (float)1.841431, (float)2.050659, (float)2.463623, (float)2.857666, (float)1.590088, (float)2.067261, (float)2.427979, (float)2.794434, (float)1.746826, (float)2.057373, (float)2.320190, (float)2.800781, (float)1.734619, (float)1.940552, (float)2.306030, (float)2.826416, (float)1.786255, (float)2.204468, (float)2.457520, (float)2.795288, (float)1.861084, (float)2.170532, (float)2.414551, (float)2.763672, (float)2.001465,
(float)2.307617, (float)2.552734, (float)2.811890, (float)1.784424, (float)2.124146, (float)2.381592, (float)2.645508, (float)1.888794, (float)2.135864, (float)2.418579, (float)2.861206, (float)2.301147, (float)2.531250, (float)2.724976, (float)2.913086, (float)1.837769, (float)2.051270, (float)2.261963, (float)2.553223, (float)2.012939, (float)2.221191, (float)2.440186, (float)2.678101, (float)1.429565, (float)1.858276, (float)2.582275, (float)2.845703, (float)1.622803, (float)1.897705, (float)2.367310, (float)2.621094, (float)1.581543, (float)1.960449, (float)2.515869, (float)2.736450, (float)1.419434,
(float)1.933960, (float)2.394653, (float)2.746704, (float)1.721924, (float)2.059570, (float)2.421753, (float)2.769653, (float)1.911011, (float)2.220703, (float)2.461060, (float)2.740723, (float)1.581177, (float)1.860840, (float)2.516968, (float)2.874634, (float)1.870361, (float)2.098755, (float)2.432373, (float)2.656494, (float)2.059692, (float)2.279785, (float)2.495605, (float)2.729370, (float)1.815674, (float)2.181519, (float)2.451538, (float)2.680542, (float)1.407959, (float)1.768311, (float)2.343018, (float)2.668091, (float)2.168701, (float)2.394653, (float)2.604736, (float)2.829346, (float)1.636230, (float)1.865723, (float)2.329102, (float)2.824219, (float)1.878906, (float)2.139526, (float)2.376709, (float)2.679810, (float)1.765381, (float)1.971802, (float)2.195435, (float)2.586914, (float)2.164795, (float)2.410889, (float)2.673706, (float)2.903198, (float)2.071899, (float)2.331055, (float)2.645874, (float)2.907104, (float)2.026001, (float)2.311523, (float)2.594849, (float)2.863892, (float)1.948975, (float)2.180786, (float)2.514893, (float)2.797852, (float)1.881836, (float)2.130859, (float)2.478149, (float)2.804199, (float)2.238159, (float)2.452759, (float)2.652832, (float)2.868286, (float)1.897949, (float)2.101685, (float)2.524292, (float)2.880127, (float)1.856445, (float)2.074585, (float)2.541016, (float)2.791748, (float)1.695557, (float)2.199097, (float)2.506226, (float)2.742676, (float)1.612671, (float)1.877075, (float)2.435425, (float)2.732910, (float)1.568848, (float)1.786499, (float)2.194580, (float)2.768555, (float)1.953369, (float)2.164551, (float)2.486938, (float)2.874023, (float)1.388306, (float)1.725342, (float)2.384521, (float)2.771851, (float)2.115356, (float)2.337769, (float)2.592896, (float)2.864014, (float)1.905762, (float)2.111328, (float)2.363525, (float)2.789307, (float)1.882568, (float)2.332031, (float)2.598267, (float)2.827637, (float)1.683594, (float)2.088745, (float)2.361938, (float)2.608643, (float)1.874023, (float)2.182129, (float)2.536133, (float)2.766968, (float)1.861938, (float)2.070435, (float)2.309692, (float)2.700562, (float)1.722168, (float)2.107422, (float)2.477295, (float)2.837646, (float)1.926880, (float)2.184692, (float)2.442627, (float)2.663818, (float)2.123901, (float)2.337280, (float)2.553101, (float)2.777466, (float)1.588135, (float)1.911499, (float)2.212769, (float)2.543945, (float)2.053955, (float)2.370850, (float)2.712158, (float)2.939941, (float)2.210449, (float)2.519653, (float)2.770386, (float)2.958618, (float)2.199463, (float)2.474731, (float)2.718262, (float)2.919922, (float)1.960083, (float)2.175415, (float)2.608032, (float)2.888794, (float)1.953735, (float)2.185181, (float)2.428223, (float)2.809570, (float)1.615234, (float)2.036499, (float)2.576538, (float)2.834595, (float)1.621094, (float)2.028198, (float)2.431030, (float)2.664673, (float)1.824951, (float)2.267456, (float)2.514526, (float)2.747925, (float)1.994263, (float)2.229126, (float)2.475220, (float)2.833984, (float)1.746338, (float)2.011353, (float)2.588257, (float)2.826904, (float)1.562866, (float)2.135986, (float)2.471680, (float)2.687256, (float)1.748901, (float)2.083496, (float)2.460938, (float)2.686279, (float)1.758057, (float)2.131470, (float)2.636597, (float)2.891602, (float)2.071289, (float)2.299072, (float)2.550781, (float)2.814331, (float)1.839600, (float)2.094360, (float)2.496460, (float)2.723999, (float)1.882202, (float)2.088257, (float)2.636841, (float)2.923096, (float)1.957886, (float)2.153198, (float)2.384399, (float)2.615234, (float)1.992920, (float)2.351196, (float)2.654419, (float)2.889771, (float)2.012817, (float)2.262451, (float)2.643799, (float)2.903076, (float)2.025635, (float)2.254761, (float)2.508423, (float)2.784058, (float)2.316040, (float)2.589355, (float)2.794189, (float)2.963623, (float)1.741211, (float)2.279541, (float)2.578491, (float)2.816284, (float)1.845337, (float)2.055786, (float)2.348511, (float)2.822021, (float)1.679932, (float)1.926514, (float)2.499756, (float)2.835693, (float)1.722534, (float)1.946899, (float)2.448486, (float)2.728760, (float)1.829834, (float)2.043213, (float)2.580444, (float)2.867676, (float)1.676636, (float)2.071655, (float)2.322510, (float)2.704834, (float)1.791504, (float)2.113525, (float)2.469727, (float)2.784058, (float)1.977051, (float)2.215088, (float)2.497437, (float)2.726929, (float)1.800171, (float)2.106689, (float)2.357788, (float)2.738892, (float)1.827759, (float)2.170166, (float)2.525879, (float)2.852417, (float)1.918335, (float)2.132813, (float)2.488403, (float)2.728149, (float)1.916748, (float)2.225098, (float)2.542603, (float)2.857666, (float)1.761230, (float)1.976074, (float)2.507446, (float)2.884521, (float)2.053711, (float)2.367432, (float)2.608032, (float)2.837646, (float)1.595337, (float)2.000977, (float)2.307129, (float)2.578247, (float)1.470581, (float)2.031250, (float)2.375854, (float)2.647583, (float)1.801392, (float)2.128052, (float)2.399780, (float)2.822876, (float)1.853638, (float)2.066650, (float)2.429199, (float)2.751465, (float)1.956299, (float)2.163696, (float)2.394775, (float)2.734253, (float)1.963623, (float)2.275757, (float)2.585327, (float)2.865234, (float)1.887451, (float)2.105469, (float)2.331787, (float)2.587402, (float)2.120117, (float)2.443359, (float)2.733887, (float)2.941406, (float)1.506348, (float)1.766968, (float)2.400513, (float)2.851807, (float)1.664551, (float)1.981079, (float)2.375732, (float)2.774414, (float)1.720703, (float)1.978882, (float)2.391479, (float)2.640991, (float)1.483398, (float)1.814819, (float)2.434448, (float)2.722290, (float)1.769043, (float)2.136597, (float)2.563721, (float)2.774414, (float)1.810791, (float)2.049316, (float)2.373901, (float)2.613647, (float)1.788330, (float)2.005981, (float)2.359131, (float)2.723145, (float)1.785156, (float)1.993164, (float)2.399780, (float)2.832520, (float)1.695313, (float)2.022949, (float)2.522583, (float)2.745117, (float)1.584106, (float)1.965576, (float)2.299927, (float)2.715576, (float)1.894897, (float)2.249878, (float)2.655884, (float)2.897705, (float)1.720581, (float)1.995728, (float)2.299438, (float)2.557007, (float)1.619385, (float)2.173950, (float)2.574219, (float)2.787964, (float)1.883179, (float)2.220459, (float)2.474365, (float)2.825073, (float)1.447632, (float)2.045044, (float)2.555542, (float)2.744873, (float)1.502686, (float)2.156616, (float)2.653320, (float)2.846558, (float)1.711548, (float)1.944092, (float)2.282959, (float)2.685791, (float)1.499756, (float)1.867554, (float)2.341064, (float)2.578857, (float)1.916870, (float)2.135132, (float)2.568237, (float)2.826050, (float)1.498047, (float)1.711182, (float)2.223267, (float)2.755127, (float)1.808716, (float)1.997559, (float)2.256470, (float)2.758545, (float)2.088501, (float)2.402710, (float)2.667358, (float)2.890259, (float)1.545044, (float)1.819214, (float)2.324097, (float)2.692993, (float)1.796021, (float)2.012573, (float)2.505737, (float)2.784912, (float)1.786499, (float)2.041748, (float)2.290405, (
float)2.650757, (float)1.938232, (float)2.264404, (float)2.529053, (float)2.796143 }; A.9.
iLBC Speech Coder ANSI C Source Code
iLBC ANAFILTER H void anaFilter
iLBC Speech Coder ANSI C Source Code
/ memcpy(mem, &In[len LPC FILTERORDER], LPC FILTERORDER
iLBC Speech Coder ANSI C Source Code
(o) Codebook vector for the higher section
iLBC Speech Coder ANSI C Source Code
This vector is then used to expand    the codebook with an additional section.
Codebook vectors for the higher section
{ int j, k; float
pp,  pp1; float tempbuff2[CB MEML CB FILTERLEN]; float  pos;
memset(tempbuff2, 0, (CB HALFFILTERLEN 1)
(i) Codebook index for the first aug vector
pp,  ppo,  ppi,  ppe, crossDot, alfa; float weighted, measure, nrjRecursive; float ftmp; /
Compute the energy for the first (low 5) noninterpolated samples
( ( pp) ( pp) )
( ppe) ( ppe); ppe ; energy[tmpIndex]
alfa ( ppi); ppo ; ppi ; energy[tmpIndex]
(float) 0.0; } if (stage 0) { measure   (float)
pp,  ppo,  ppi, alfa, alfa1, weighted;
iLBC Speech Coder ANSI C Source Code
iLBC Speech Coder ANSI C Source Code
#include <math.h> #include <string.h> #include <stdio.h
> #include "iLBC define.h" /
Compute cross correlation and pitch gain for pitch prediction    of last subframe at given lag.
sRange i lag]; ftmp3    buffer[bLen sRange i]
Conceals a residual signal    and LP parameters.
If no packet loss, update state.
if (PLI   1) { iLBCdec
if previous frame not lost, determine pitch pred.
blockl>2 320) use gain (float)0.7; else
if (iLBCdec inst consPLICount  iLBCdec
consPLICount  iLBCdec inst blockl>4 320)
float)1.0; else if (ftmp>(float)0.4) pitchfact (
i randlag; if (pick < 0) { randvec[i]   iLBCdec
i use lag; if (pick < 0) { PLCresidual[i]
[ iLBCdec inst blockl pick]
((float)1.0 pitchfact)   randvec[i]); else if (i<160)
sqrt(energy/(float)iLBCdec inst blockl) < 30.0) { gain 0.0; for (i 0; i<iLBCdec
iLBCdec inst per max per; } iLBCdec
inst prevPLI   PLI; memcpy(iLBCdec inst prevLpc, PLClpc, (LPC FILTERORDER 1)
sizeof(float)); memcpy(iLBCdec inst prevResidual, PLCresidual, iLBCdec
iLBC Speech Coder ANSI C Source Code enhancer.h
ENHANCER H #include "iLBC define.h"
the recidual signal to enhance  /
iLBC Speech Coder ANSI C Source Code enhancer.c
#include <math.h> #include <string.h> #include "
Find index in array such that the array element with said   index is the element of said array closest to "value"
(i) estimated beginning other segment
{ int estSegPosRounded,searchSegStartPos,searchSegEndPos,corrdim; int tloc,tloc2,i,st,en,fraction; float vect[ENH VECTL],corrVec[ENH CORRDIM],maxv;
if (st<0) { memset(vect,0, st sizeof(float)); memcpy(&vect[ st],idata, (ENH VECTL st)
(i) said second sequence of waveforms
2 hl 1 is sseq dimension
{ int i,k; float w00,w10,w11,A,B,C, psseq,err,errs;
/ A   (float)sqrt( (alpha0  alpha0 alpha0/4)/denom); B    alpha0/2
A   w10/w00; B   B 1; } else { /
essentially no difference between cycles; smoothing not needed  /
ENH HL 1]; float plocs2[ENH PLOCSL]; float  psseq; centerEndPos centerStartPos
; blockStartPos[hl] (float)centerStartPos; psseq sseq ENH BLOCKL hl; memcpy(psseq, idata centerStartPos, ENH BLOCKL sizeof(float));
/  past  / for (q hl 1; q> 0; q )
{ blockStartPos[q] blockStartPos[q 1] period[lagBlock[q 1]]
NearestNeighbor(lagBlock q,plocs, blockStartPos[q]  ENH BLOCKL HALF period[lagBlock[q 1]], periodl); if (blockStartPos[q] ENH OVERHANG> 0) {
refiner(sseq q ENH BLOCKL, blockStartPos q, idata, idatal, centerStartPos, blockStartPos[q],
smoothed block, dimension blockl  / float
(i) dimension idata  / int
first sample current block within idata
) locations where period array values valid
{ int i; float ftmp1, ftmp2;
enh buf,  enh period; int iblock, isample; int lag 0, ilag, i, ioffset; float cc, maxcc; float ftmp1, ftmp2; float  inPtr,
enh bufPtr1,  enh bufPtr2; float plc pred[ENH BLOCKL]; float lpState[6], downsampled[(ENH NBLOCKS ENH BLOCKL 120)/2]; int inLen ENH NBLOCKS ENH BLOCKL 120;
int start, plc blockl, inlag; enh buf iLBCdec
inst enh period; memmove(enh buf, &enh buf[iLBCdec inst blockl], (ENH BUFL iLBCdec
sizeof(float)); memcpy(&enh buf[ENH BUFL iLBCdec
inst blockl sizeof(float)); if (iLBCdec inst mode 30
; i 3 ioffset; memmove(enh
period, &enh period[i], (ENH NBLOCKS TOT i)
ENH BLOCKL 126, 6 sizeof(float));
/  Down sample a factor 2 to save computations
ENH BLOCKL 120, lpFilt coefsTbl, inLen ioffset ENH BLOCKL,
60 iblock  ENH BLOCKL HALF, downsampled 60 iblock
/ enh period[iblock ENH NBLOCKS EXTRA ioffset]
; } else { start lag; } for (isample   start;
enh buf[ENH BUFL 1 iLBCdec
(plc blockl 1);  enh bufPtr1    ftmp1;
iblock ENH BLOCKL, enh buf, ENH BUFL, (5 iblock)
iblock ENH BLOCKL, enh buf, ENH BUFL, (4 iblock)
ANSI C Source Code filter.h
on entrance InOut[ orderCoef] to InOut[ 1] contain the state of the filter (delayed samples).
InOut[0] to InOut[lengthInOut 1] contain the filter input, on en exit InOut[ orderCoef] to
InOut[ 1] is unchanged and InOut[0] to InOut[lengthInOut 1] contain filtered samples
(i) filter coefficients, Coef[0] is assumed to be 1.0  / int
(i) number of input/output samples
(i) filter coefficients (Coef[0] is assumed to be 1.0)
(i) number of input/output samples
to In[ 1] contain state of all zero section
(i) filter coefficients for all zero section (ZeroCoef[0] is assumed to be 1.0)
(i) filter coefficients for all pole section (ZeroCoef[0] is assumed to be 1.0)
(i) number of input/output samples
on entrance Out[ orderCoef] to Out[ 1] contain state of all pole section.
(i) number of input samples
(i) filter state  / float
iLBC Speech Coder ANSI C Source Code filter.c
InOut[ orderCoef] to InOut[ 1] contain the state of the filter (delayed samples).
InOut[0] to InOut[lengthInOut 1] contain the filter input, on en exit InOut[ orderCoef] to
InOut[ 1] is unchanged and InOut[0] to InOut[lengthInOut 1] contain filtered samples
(i) filter coefficients, Coef[0] is assumed to be 1.0  / int
(i) number of input/output samples
{ int n,k; for(n 0;n
(i) filter coefficients (Coef[0] is assumed to be 1.0)
(i) number of input/output samples
{ int n,k; for(n 0;n
to In[ 1] contain state of all zero section
(i) filter coefficients for all zero section (ZeroCoef[0] is assumed to be 1.0)
(i) filter coefficients for all pole section (ZeroCoef[0] is assumed to be 1.0)
(i) number of input/output samples
on entrance Out[ orderCoef] to Out[ 1] contain state of all pole section.
(i) number of input samples
(i) filter state  / float
{ float   o; float  Out ptr   Out; float
iLBC Speech Coder ANSI C Source Code FrameClassify.h
iLBC Speech Coder ANSI C Source Code FrameClassify.c
{ float max ssqEn, fssqEn[NSUB MAX], bssqEn[NSUB MAX],  pp; int n, l,
; const float sampEn win[5] {(float)1.0/(float)6.0, (float)2.0/(float)6.0, (float)3.0/(float)6.0, (float)4.0/(float)6.0, (float)5.0/(float)6.0}; /
init the front and back energies to zero
/ n 0; pp residual; for (l 0; l<5; l )
nsub 1; pp residual n SUBL; for (l 0; l<SUBL 5; l )
if (iLBCenc inst mode 20)
; for (n 2; n<iLBCenc
iLBC Speech Coder ANSI C Source Code
iLBC GAINQUANT H float gainquant(/
(i) gain value  / float
iLBC Speech Coder ANSI C Source Code
#include <string.h> #include <math.h> #include "constants.h"
iLBC Speech Coder ANSI C Source Code
iLBC Speech Coder ANSI C Source Code
; } else if (index < base size) { k 2 (index (lMem cbveclen 1))
ihigh, mem lMem k ihigh, (cbveclen ihigh)
memset(tempbuff2, 0, CB HALFFILTERLEN sizeof(float)); memcpy(&tempbuff2[CB HALFFILTERLEN], mem, lMem sizeof(float)); memset(&tempbuff2[lMem CB HALFFILTERLEN], 0, (CB HALFFILTERLEN 1)
sizeof(float)); k 2 (index base size  (lMem cbveclen 1))
cbveclen; sFilt lMem k; memInd sFilt 1 CB HALFFILTERLEN;
memcpy(cbvec ihigh, tmpbuf lMem k ihigh, (cbveclen ihigh)
iLBC Speech Coder ANSI C Source Code helpfun.h Copyright (C)
(o) autocorrelation vector  / const float
lpc coefficient vector starting with 1.0
the first vector for the interpolation
the second vector for the interpolation
the bandwidth expanded lpc coefficients
the lpc coefficients before bandwidth expansion
the number of vector splits
the value to quantize  / const float
the dimension of each lsf vector
iLBC Speech Coder ANSI C Source Code helpfun.c
(o) autocorrelation vector  / const float
lpc coefficient vector starting with 1.0
m h, i; a[0]   1.0;
<  0, set LPC coeff.
r[1]/r[0]; alpha   r[0]   r[1]   k[0]; for (m   1; m < order; m )
r[m   1]; for (i   0; i < m
; i ){ sum    a[i 1]   r[m
; for (i   0; i < m h; i ){ sum
the first vector for the interpolation
the second vector for the interpolation
the bandwidth expanded lpc coefficients
the lpc coefficients before bandwidth expansion
CB[pos   i]; dist    tmp tmp; } if (dist < mindist) { mindist   dist; minindex   j; } pos    dim; } for (i   0; i < dim;
the number of vector splits
the value to quantize  / const float
the dimension of each lsf vector
eps2; } else { lsf[pos]  eps2; lsf[pos 1]  eps2; } change 1; } if (lsf[pos]<minlsf)
{ lsf[pos] minlsf; change 1; } if (lsf[pos]>maxlsf)
iLBC Speech Coder ANSI C Source Code
iLBC HPINPUT H void hpInput( float
(i) length of vector to filter
iLBC Speech Coder ANSI C Source Code
(i) length of vector to filter
iLBC Speech Coder ANSI C Source Code
HPOUTPUT H void hpOutput( float
(i) length of vector to filter
(i) length of vector to filter
iLBC Speech Coder ANSI C Source Code iCBConstruct.h Copyright (C)
iLBC Speech Coder ANSI C Source Code iCBConstruct.c
{ int k; for (k 1; k<CB NSTAGES;
{ index[k]  64; } else if (index[k]
{ int k; for (k 1; k<CB NSTAGES;
gaindequant(gain index[0], 1.0, 32); if (nStages > 1) { gain[1]
iLBC Speech Coder ANSI C Source Code iCBSearch.h
iLBC ICBSEARCH H void iCBSearch( iLBC Enc
(i) Number of codebook stages
iLBC Speech Coder ANSI C Source Code iCBSearch.c
#include <math.h> #include <string.h> #include "
(i) Number of codebook stages
{ int i, j, icount, stage, best index, range, counter; float max measure, gain, measure, crossDot, ftmp; float gains[CB NSTAGES]; float target[SUBL]; int base index, sInd, eInd, base size; int sIndAug 0, eIndAug 0;
float buf[CB MEML SUBL 2 LPC FILTERORDER]; float invenergy[CB
energy[CB EXPAND 128]; float  pp,  ppi 0,  ppo 0,  ppe 0; float cbvectors[CB MEML]
This section is created by filtering the original buffer with a filter.
; pp buf LPC FILTERORDER lMem lTarget;
(float) 0.0; } ppe ; measure (float)
10000000.0; if (crossDot > 0.0) { measure   crossDot crossDot invenergy[0]
; ppo ; ppi ;
(float) 0.0; } measure (float) 10000000.0; if (crossDot > 0.0)
/ sIndAug 0; eIndAug 0; sInd base index CB RESRANGE/2; eInd sInd CB RESRANGE; if (lTarget SUBL) { if (sInd<0) { sIndAug   40   sInd
; eIndAug   39; sInd 0; } else if
sInd < 0) { eInd    sInd; sInd   0; } if(eInd > range)
/ counter   sInd; sInd    base size; eInd    base size; if (stage 0) { ppe   energy base size;  ppe 0.0; pp cbvectors lMem lTarget;
/ crossDot 0.0; pp cbvectors   lMem (counter )
10000000.0; if (crossDot > 0.0) { measure
gainquant(gain, 1.0, 32, &gain index[stage])
; } else { if (stage 1) { gain   gainquant(gain,
according to measure) codebook vector
} j gain index[0]; for (i gain index[0]; i<32; i ) {
iLBC Speech Coder ANSI C Source Code LPC decode.h
(i) first lsf coefficient vector
quantization index  / int lpc n
iLBC Speech Coder ANSI C Source Code LPC decode.c
#include <math.h> #include <string.h> #include "helpfun.h" #include "lsf.h
(i) first lsf coefficient vector
quantization index  / int lpc n
, lsf weightTbl 30ms[0], length); memcpy(syntdenum,lp,lp length
iLBC Speech Coder ANSI C Source Code
iLBC LPCENCOD H void LPCencode
lsf coefficients to quantize  /
iLBC Speech Coder ANSI C Source Code LPCencode.c Copyright (C)
" #include "helpfun.h" #include "lsf.h
last window is asymmetric  / for (
; k < iLBCenc inst lpc n; k )
{ is   LPC LOOKBACK; if (k < (iLBCenc inst lpc n 1)) {
LPC FILTERORDER   1); levdurb(lp, temp, r, LPC FILTERORDER); bwexpand(lp2, lp, LPC CHIRP SYNTDENUM,
LPC FILTERORDER 1); a2lsf(lsf   k LPC FILTERORDER, lp2)
; } is LPC LOOKBACK BLOCKL
inst blockl; memmove(iLBCenc inst lpc buffer
(i) first set of lsf coefficients
second set of lsf coefficients
the synthesis filter denominator resulting from the quantized interpolated lsf
the weighting filter denominator resulting from the unquantized interpolated lsf
the unquantized lsf coefficients of the previous signal frame
(i) should equate LPC FILTERORDER  /
Interpolation between first and second set of lsf coefficients
(o) dequantized lsf coefficients (dimension FILTERORDER)
the lsf coefficient vector to be quantized (dimension FILTERORDER )
lsf coefficients to quantize  /
iLBC Speech Coder ANSI C Source Code lsf.h
iLBC LSF H #define  iLBC
iLBC Speech Coder ANSI C Source Code lsf.c
#include <string.h> #include <math.h> #include "
pq coef; float omega, old omega; int i; float hlp, hlp1, hlp2, hlp3, hlp4, hlp5; for (i 0; i<LPC HALFORDER; i )
(float) 1.0 p[0]; p pre[1]
p pre[2] p[3]; p pre[4]
q pre[1] q[2]; q pre[3]
q pre[2] q[3]; q pre[4]
q pre[3] q[4]; q pre[4]
omega   0.0; old omega   0.0; old p   FLOAT MAX; old q
if ((lsp index & 0x1)   0)
{ pq coef   p pre; old   &old p; } else
/ hlp   (float)cos(omega   TWO PI); hlp1   (float)2.0   hlp   pq coef[0]; hlp2   (float)2.0   hlp   hlp1 (float)1.0   pq coef[1]; hlp3   (float)2.0   hlp
if (step idx   (LSF NUMBER OF STEPS 1)){ if (fabs(hlp5)
freq[lsp index]   omega step; } else { freq[lsp index]   omega; } if (( old)
FLOAT MAX; } else {  old   FLOAT MAX; } omega   old omega;
{ int i, j; float hlp; float p[LPC HALFORDER], q[LPC HALFORDER]; float a[LPC HALFORDER   1], a1[LPC HALFORDER], a2[LPC HALFORDER]; float b[LPC HALFORDER   1], b1[LPC HALFORDER], b2[LPC HALFORDER]; for (i 0; i<LPC FILTERORDER; i )
This part is not found in the TIA standard.
It involves the following 2 IF blocks.
If "freq" is judged ill conditioned, then we first modify freq[0] and freq[LPC HALFORDER 1]
4.2.2.2 1 and 4.2.2.2 2.
Note that for this code p[i] specifies the coefficients used in .Q A(z) while q[i] specifies the coefficients used in .P
ANSI C Source Code packing.h
the value specified by most significant bits
the value specified by least significant bits
the msb value in the combined value out
the number of bits that the value will fit within
iLBC Speech Coder ANSI C Source Code packing.c Copyright (C)
the value specified by most significant bits
the value specified by least significant bits
the msb value in the combined value out
/ void dopack( unsigned char   bitstream,
/  (i/o) on entrance pointer to place in bitstream to pack new data, on exit pointer to place in bitstream to pack future data
the number of bits that the value will fit within
/ void unpack( unsigned char
iLBC Speech Coder ANSI C Source Code
iLBC STATECONSTRUCTW H void StateConstructW
iLBC Speech Coder ANSI C Source Code
#include <math.h> #include <string.h> #include "
decoding of the maximum value
; for (k 0; k<LPC FILTERORDER; k )
iLBC Speech Coder ANSI C Source Code
iLBC STATESEARCHW H void AbsQuantW
(i) denominator of synthesis filter
iLBC Speech Coder ANSI C Source Code
#include <math.h> #include <string.h> #include "
(i) denominator of synthesis filter
/ memcpy(tmp, residual, len sizeof(float)); memset(tmp len, 0, len sizeof(float)); ZeroPoleFilter(tmp, numerator, syntDenum, 2 len, LPC FILTERORDER, fout); for (k 0; k<len; k )
if (maxVal < 10.0) { maxVal   10.0
/ maxVal state frgqTbl[ idxForMax]; qmax   (float)pow(10,maxVal); scal
iLBC Speech Coder ANSI C Source Code syntFilter.h
iLBC SYNTFILTER H void syntFilter
iLBC Speech Coder ANSI C Source Code syntFilter.c
first part using memory from past  / for (i 0;
