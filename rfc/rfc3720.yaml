- title: __initial_text__
  contents:
  - '           Internet Small Computer Systems Interface (iSCSI)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a transport protocol for Internet Small\n\
    \   Computer Systems Interface (iSCSI) that works on top of TCP.  The\n   iSCSI\
    \ protocol aims to be fully compliant with the standardized SCSI\n   architecture\
    \ model.\n   SCSI is a popular family of protocols that enable systems to\n  \
    \ communicate with I/O devices, especially storage devices.  SCSI\n   protocols\
    \ are request/response application protocols with a common\n   standardized architecture\
    \ model and basic command set, as well as\n   standardized command sets for different\
    \ device classes (disks, tapes,\n   media-changers etc.).\n   As system interconnects\
    \ move from the classical bus structure to a\n   network structure, SCSI has to\
    \ be mapped to network transport\n   protocols.  IP networks now meet the performance\
    \ requirements of fast\n   system interconnects and as such are good candidates\
    \ to \"carry\" SCSI.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction. . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   9\n   2.  Definitions and Acronyms. . . . . . . . . . . . . . .\
    \ . . . .  10\n       2.1.   Definitions. . . . . . . . . . . . . . . . . . .\
    \ . . .  10\n       2.2.   Acronyms . . . . . . . . . . . . . . . . . . . . .\
    \ . .  14\n       2.3.   Conventions. . . . . . . . . . . . . . . . . . . . .\
    \ .  16\n              2.3.1.    Word Rule. . . . . . . . . . . . . . . . . .\
    \  16\n              2.3.2.    Half-Word Rule . . . . . . . . . . . . . . .  17\n\
    \              2.3.3.    Byte Rule. . . . . . . . . . . . . . . . . .  17\n  \
    \ 3.  Overview. . . . . . . . . . . . . . . . . . . . . . . . . . .  17\n    \
    \   3.1.   SCSI Concepts. . . . . . . . . . . . . . . . . . . . .  17\n      \
    \ 3.2.   iSCSI Concepts and Functional Overview . . . . . . . .  18\n        \
    \      3.2.1.    Layers and Sessions. . . . . . . . . . . . .  19\n          \
    \    3.2.2.    Ordering and iSCSI Numbering . . . . . . . .  19\n            \
    \            3.2.2.1.   Command Numbering and\n                              \
    \     Acknowledging . . . . . . . . . .  20\n                        3.2.2.2.\
    \   Response/Status Numbering and\n                                   Acknowledging\
    \ . . . . . . . . . .  23\n                        3.2.2.3.   Data Sequencing\
    \   . . . . . . . .  24\n              3.2.3.    iSCSI Login. . . . . . . . .\
    \ . . . . . . . .  24\n              3.2.4.    iSCSI Full Feature Phase . . .\
    \ . . . . . . .  25\n                        3.2.4.1.   Command Connection Allegiance\
    \ . .  26\n                        3.2.4.2.   Data Transfer Overview. . . . .\
    \ .  27\n                        3.2.4.3.   Tags and Integrity Checks . . . .\
    \  28\n                        3.2.4.4.   Task Management . . . . . . . . .  28\n\
    \              3.2.5.    iSCSI Connection Termination . . . . . . . .  29\n  \
    \            3.2.6.    iSCSI Names. . . . . . . . . . . . . . . . .  29\n    \
    \                    3.2.6.1.   iSCSI Name Properties . . . . . .  30\n      \
    \                  3.2.6.2.   iSCSI Name Encoding . . . . . . .  31\n        \
    \                3.2.6.3.   iSCSI Name Structure. . . . . . .  32\n          \
    \                         3.2.6.3.1.  Type \"iqn.\" (iSCSI\n                 \
    \                              Qualified Name) . . .  32\n                   \
    \                3.2.6.3.2.  Type \"eui.\" (IEEE\n                           \
    \                    EUI-64 format). . . .  34\n              3.2.7.    Persistent\
    \ State . . . . . . . . . . . . . .  34\n              3.2.8.    Message Synchronization\
    \ and Steering . . . .  35\n                        3.2.8.1.   Sync/Steering and\
    \ iSCSI PDU\n                                   Length  . . . . . . . . . . .\
    \ . .  36\n       3.3.   iSCSI Session Types. . . . . . . . . . . . . . . . .\
    \ .  36\n       3.4.   SCSI to iSCSI Concepts Mapping Model . . . . . . . . .\
    \  37\n              3.4.1.    iSCSI Architecture Model . . . . . . . . . .  37\n\
    \              3.4.2.    SCSI Architecture Model. . . . . . . . . . .  39\n  \
    \            3.4.3.    Consequences of the Model. . . . . . . . . .  41\n    \
    \                    3.4.3.1.   I_T Nexus State . . . . . . . . .  42\n      \
    \ 3.5.   Request/Response Summary . . . . . . . . . . . . . . .  42\n        \
    \      3.5.1.    Request/Response Types Carrying SCSI Payload  43\n          \
    \              3.5.1.1.   SCSI-Command  . . . . . . . . . .  43\n            \
    \            3.5.1.2.   SCSI-Response   . . . . . . . . .  43\n              \
    \          3.5.1.3.   Task Management Function Request.  44\n                \
    \        3.5.1.4.   Task Management Function Response  44\n                  \
    \      3.5.1.5.   SCSI Data-Out and SCSI Data-In. .  44\n                    \
    \    3.5.1.6.   Ready To Transfer (R2T) . . . . .  45\n              3.5.2.  \
    \  Requests/Responses carrying SCSI and iSCSI\n                        Payload.\
    \ . . . . . . . . . . . . . . . . . .  46\n                        3.5.2.1.  \
    \ Asynchronous Message. . . . . . .  46\n              3.5.3.    Requests/Responses\
    \ Carrying iSCSI Only\n                        Payload. . . . . . . . . . . .\
    \ . . . . . . .  46\n                        3.5.3.1.   Text Request and Text\
    \ Response. .  46\n                        3.5.3.2.   Login Request and Login\
    \ Response.  47\n                        3.5.3.3.   Logout Request and Response\
    \ . . .  47\n                        3.5.3.4.   SNACK Request . . . . . . . .\
    \ . .  48\n                        3.5.3.5.   Reject. . . . . . . . . . . . .\
    \ .  48\n                        3.5.3.6.   NOP-Out Request and NOP-In\n     \
    \                              Response  . . . . . . . . . . . .  48\n   4.  SCSI\
    \ Mode Parameters for iSCSI. . . . . . . . . . . . . . . .  48\n   5.  Login and\
    \ Full Feature Phase Negotiation. . . . . . . . . . .  48\n       5.1.   Text\
    \ Format. . . . . . . . . . . . . . . . . . . . . .  50\n       5.2.   Text Mode\
    \ Negotiation. . . . . . . . . . . . . . . . .  53\n              5.2.1.    List\
    \ negotiations. . . . . . . . . . . . . .  56\n              5.2.2.    Simple-value\
    \ Negotiations. . . . . . . . . .  56\n       5.3.   Login Phase. . . . . . .\
    \ . . . . . . . . . . . . . . .  57\n              5.3.1.    Login Phase Start.\
    \ . . . . . . . . . . . . .  60\n              5.3.2.    iSCSI Security Negotiation\
    \ . . . . . . . . .  62\n              5.3.3.    Operational Parameter Negotiation\
    \ During\n                        the Login Phase. . . . . . . . . . . . . . .\
    \  63\n              5.3.4.    Connection Reinstatement . . . . . . . . . .  64\n\
    \              5.3.5.    Session Reinstatement, Closure, and Timeout.  64\n  \
    \                                 5 5.3.5.1.  Loss of Nexus\n                \
    \                               Notification. . . . .  65\n              5.3.6.\
    \    Session Continuation and Failure . . . . . .  65\n       5.4.   Operational\
    \ Parameter Negotiation Outside the Login\n              Phase. . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  66\n   6.  iSCSI Error Handling and Recovery\
    \ . . . . . . . . . . . . . .  67\n       6.1.   Overview . . . . . . . . . .\
    \ . . . . . . . . . . . . .  67\n              6.1.1.    Background . . . . .\
    \ . . . . . . . . . . . .  67\n              6.1.2.    Goals. . . . . . . . .\
    \ . . . . . . . . . . .  67\n              6.1.3.    Protocol Features and State\
    \ Expectations . .  68\n              6.1.4.    Recovery Classes . . . . . . .\
    \ . . . . . . .  69\n                        6.1.4.1.   Recovery Within-command\
    \ . . . . .  69\n                        6.1.4.2.   Recovery Within-connection.\
    \ . . .  70\n                        6.1.4.3.   Connection Recovery . . . . .\
    \ . .  71\n                        6.1.4.4.   Session Recovery. . . . . . . .\
    \ .  72\n              6.1.5.  Error Recovery Hierarchy . . . . . . . . . . .\
    \  72\n       6.2.   Retry and Reassign in Recovery . . . . . . . . . . . .  74\n\
    \              6.2.1.    Usage of Retry . . . . . . . . . . . . . . .  74\n  \
    \            6.2.2.    Allegiance Reassignment. . . . . . . . . . .  75\n    \
    \   6.3.   Usage Of Reject PDU in Recovery. . . . . . . . . . . .  76\n      \
    \ 6.4.   Connection Timeout Management. . . . . . . . . . . . .  76\n        \
    \      6.4.1.    Timeouts on Transport Exception Events . . .  77\n          \
    \    6.4.2.    Timeouts on Planned Decommissioning. . . . .  77\n       6.5. \
    \  Implicit Termination of Tasks. . . . . . . . . . . . .  77\n       6.6.   Format\
    \ Errors. . . . . . . . . . . . . . . . . . . . .  78\n       6.7.   Digest Errors.\
    \ . . . . . . . . . . . . . . . . . . . .  78\n       6.8.   Sequence Errors.\
    \ . . . . . . . . . . . . . . . . . . .  80\n       6.9.   SCSI Timeouts. . .\
    \ . . . . . . . . . . . . . . . . . .  81\n       6.10.  Negotiation Failures\
    \ . . . . . . . . . . . . . . . . .  81\n       6.11.  Protocol Errors. . . .\
    \ . . . . . . . . . . . . . . . .  82\n       6.12.  Connection Failures. . .\
    \ . . . . . . . . . . . . . . .  82\n       6.13.  Session Errors . . . . . .\
    \ . . . . . . . . . . . . . .  83\n   7.  State Transitions . . . . . . . . .\
    \ . . . . . . . . . . . . .  84\n       7.1.   Standard Connection State Diagrams\
    \ . . . . . . . . . .  84\n              7.1.1.    State Descriptions for Initiators\
    \ and\n                        Targets. . . . . . . . . . . . . . . . . . .  84\n\
    \              7.1.2.    State Transition Descriptions for Initiators\n      \
    \                  and Targets. . . . . . . . . . . . . . . . .  85\n        \
    \      7.1.3.    Standard Connection State Diagram for an\n                  \
    \      Initiator. . . . . . . . . . . . . . . . . .  88\n              7.1.4.\
    \    Standard Connection State Diagram for a\n                        Target .\
    \ . . . . . . . . . . . . . . . . . .  90\n       7.2.   Connection Cleanup State\
    \ Diagram for Initiators and\n              Targets. . . . . . . . . . . . . .\
    \ . . . . . . . . . .  92\n              7.2.1.    State Descriptions for Initiators\
    \ and\n                        Targets. . . . . . . . . . . . . . . . . . .  94\n\
    \              7.2.2.    State Transition Descriptions for Initiators\n      \
    \                  and Targets. . . . . . . . . . . . . . . . .  94\n       7.3.\
    \   Session State Diagrams . . . . . . . . . . . . . . . .  95\n             \
    \ 7.3.1.    Session State Diagram for an Initiator . . .  95\n              7.3.2.\
    \    Session State Diagram for a Target . . . . .  96\n              7.3.3.  \
    \  State Descriptions for Initiators and\n                        Targets. . .\
    \ . . . . . . . . . . . . . . . .  97\n              7.3.4.    State Transition\
    \ Descriptions for Initiators\n                        and Targets. . . . . .\
    \ . . . . . . . . . . .  98\n   8.  Security Considerations . . . . . . . . .\
    \ . . . . . . . . . .  99\n       8.1.   iSCSI Security Mechanisms. . . . . .\
    \ . . . . . . . . . 100\n       8.2.   In-band Initiator-Target Authentication.\
    \ . . . . . . . 100\n              8.2.1.    CHAP Considerations. . . . . . .\
    \ . . . . . . 101\n              8.2.2.    SRP Considerations . . . . . . . .\
    \ . . . . . 103\n       8.3.   IPsec. . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 104\n              8.3.1.    Data Integrity and Authentication. . .\
    \ . . . 104\n              8.3.2.    Confidentiality. . . . . . . . . . . . .\
    \ . . 105\n              8.3.3.    Policy, Security Associations, and\n      \
    \                  Cryptographic Key Management . . . . . . . . 105\n   9.  Notes\
    \ to Implementers . . . . . . . . . . . . . . . . . . . . 106\n       9.1.   Multiple\
    \ Network Adapters. . . . . . . . . . . . . . . 106\n              9.1.1.    Conservative\
    \ Reuse of ISIDs. . . . . . . . . 107\n              9.1.2.    iSCSI Name, ISID,\
    \ and TPGT Use . . . . . . . 107\n       9.2.   Autosense and Auto Contingent\
    \ Allegiance (ACA) . . . . 109\n       9.3.   iSCSI Timeouts . . . . . . . . .\
    \ . . . . . . . . . . . 109\n       9.4.   Command Retry and Cleaning Old Command\
    \ Instances . . . 110\n       9.5.   Synch and Steering Layer and Performance\
    \ . . . . . . . 110\n       9.6.   Considerations for State-dependent Devices\
    \ and\n              Long-lasting SCSI Operations . . . . . . . . . . . . . 111\n\
    \              9.6.1.    Determining the Proper ErrorRecoveryLevel. . 112\n  \
    \ 10. iSCSI PDU Formats . . . . . . . . . . . . . . . . . . . . . . 112\n    \
    \   10.1.  iSCSI PDU Length and Padding . . . . . . . . . . . . . 113\n      \
    \ 10.2.  PDU Template, Header, and Opcodes. . . . . . . . . . . 113\n        \
    \      10.2.1.   Basic Header Segment (BHS) . . . . . . . . . 114\n          \
    \              10.2.1.1.  I . . . . . . . . . . . . . . . . 115\n            \
    \            10.2.1.2.  Opcode. . . . . . . . . . . . . . 115\n              \
    \          10.2.1.3.  Final (F) bit . . . . . . . . . . 116\n                \
    \        10.2.1.4.  Opcode-specific Fields. . . . . . 116\n                  \
    \      10.2.1.5.  TotalAHSLength. . . . . . . . . . 116\n                    \
    \    10.2.1.6.  DataSegmentLength . . . . . . . . 116\n                      \
    \  10.2.1.7.  LUN . . . . . . . . . . . . . . . 116\n                        10.2.1.8.\
    \  Initiator Task Tag. . . . . . . . 117\n              10.2.2.  Additional Header\
    \ Segment (AHS) . . . . . . . 117\n                        10.2.2.1.  AHSType\
    \ . . . . . . . . . . . . . 117\n                        10.2.2.2.  AHSLength\
    \ . . . . . . . . . . . . 117\n                        10.2.2.3.  Extended CDB\
    \ AHS. . . . . . . . . 118\n                        10.2.2.4.  Bidirectional Expected\
    \ Read-Data\n                                   Length AHS. . . . . . . . . .\
    \ . . 118\n              10.2.3.   Header Digest and Data Digest. . . . . . .\
    \ . 118\n              10.2.4.   Data Segment . . . . . . . . . . . . . . . .\
    \ 119\n       10.3.  SCSI Command . . . . . . . . . . . . . . . . . . . . . 119\n\
    \              10.3.1.   Flags and Task Attributes (byte 1) . . . . . 120\n  \
    \            10.3.2.   CmdSN - Command Sequence Number. . . . . . . 120\n    \
    \          10.3.3.   ExpStatSN. . . . . . . . . . . . . . . . . . 120\n      \
    \        10.3.4.   Expected Data Transfer Length. . . . . . . . 121\n        \
    \      10.3.5.   CDB - SCSI Command Descriptor Block. . . . . 121\n          \
    \    10.3.6.   Data Segment - Command Data. . . . . . . . . 121\n       10.4.\
    \  SCSI Response. . . . . . . . . . . . . . . . . . . . . 122\n              10.4.1.\
    \   Flags (byte 1) . . . . . . . . . . . . . . . 123\n              10.4.2.  \
    \ Status . . . . . . . . . . . . . . . . . . . 123\n              10.4.3.   Response\
    \ . . . . . . . . . . . . . . . . . . 124\n              10.4.4.   SNACK Tag.\
    \ . . . . . . . . . . . . . . . . . 125\n              10.4.5.   Residual Count\
    \ . . . . . . . . . . . . . . . 125\n              10.4.6.   Bidirectional Read\
    \ Residual Count. . . . . . 125\n              10.4.7.   Data Segment - Sense\
    \ and Response Data\n                        Segment. . . . . . . . . . . . .\
    \ . . . . . . 125\n                        10.4.7.1.  SenseLength . . . . . .\
    \ . . . . . 126\n                        10.4.7.2.  Sense Data. . . . . . . .\
    \ . . . . 126\n              10.4.8.   ExpDataSN. . . . . . . . . . . . . . .\
    \ . . . 127\n              10.4.9.   StatSN - Status Sequence Number. . . . .\
    \ . . 127\n              10.4.10.  ExpCmdSN - Next Expected CmdSN from this\n\
    \                        Initiator. . . . . . . . . . . . . . . . . . 128\n  \
    \            10.4.11.  MaxCmdSN - Maximum CmdSN from this Initiator 128\n    \
    \   10.5.  Task Management Function Request . . . . . . . . . . . 129\n      \
    \        10.5.1.   Function . . . . . . . . . . . . . . . . . . 129\n        \
    \      10.5.2.   TotalAHSLength and DataSegmentLength . . . . 132\n          \
    \    10.5.3.   LUN. . . . . . . . . . . . . . . . . . . . . 132\n            \
    \  10.5.4.   Referenced Task Tag. . . . . . . . . . . . . 132\n              10.5.5.\
    \   RefCmdSN . . . . . . . . . . . . . . . . . . 132\n              10.5.6.  \
    \ ExpDataSN. . . . . . . . . . . . . . . . . . 133\n       10.6.  Task Management\
    \ Function Response. . . . . . . . . . . 134\n              10.6.1.   Response\
    \ . . . . . . . . . . . . . . . . . . 134\n              10.6.2.   Task Management\
    \ Actions on Task Sets . . . . 136\n              10.6.3.   TotalAHSLength and\
    \ DataSegmentLength . . . . 137\n       10.7.  SCSI Data-Out & SCSI Data-In .\
    \ . . . . . . . . . . . . 137\n              10.7.1.   F (Final) Bit. . . . .\
    \ . . . . . . . . . . . 139\n              10.7.2.   A (Acknowledge) Bit. . .\
    \ . . . . . . . . . . 139\n              10.7.3.   Flags (byte 1) . . . . . .\
    \ . . . . . . . . . 140\n              10.7.4.   Target Transfer Tag and LUN.\
    \ . . . . . . . . 140\n              10.7.5.   DataSN . . . . . . . . . . . .\
    \ . . . . . . . 141\n              10.7.6.   Buffer Offset. . . . . . . . . .\
    \ . . . . . . 141\n              10.7.7.   DataSegmentLength. . . . . . . . .\
    \ . . . . . 141\n       10.8.  Ready To Transfer (R2T). . . . . . . . . . . .\
    \ . . . . 142\n              10.8.1.   TotalAHSLength and DataSegmentLength .\
    \ . . . 143\n              10.8.2.   R2TSN. . . . . . . . . . . . . . . . . .\
    \ . . 143\n              10.8.3.   StatSN . . . . . . . . . . . . . . . . . .\
    \ . 144\n              10.8.4.   Desired Data Transfer Length and Buffer\n   \
    \                     Offset . . . . . . . . . . . . . . . . . . . 144\n     \
    \         10.8.5.   Target Transfer Tag. . . . . . . . . . . . . 144\n       10.9.\
    \  Asynchronous Message . . . . . . . . . . . . . . . . . 145\n              10.9.1.\
    \   AsyncEvent . . . . . . . . . . . . . . . . . 146\n              10.9.2.  \
    \ AsyncVCode . . . . . . . . . . . . . . . . . 147\n              10.9.3.   LUN.\
    \ . . . . . . . . . . . . . . . . . . . . 147\n              10.9.4.   Sense Data\
    \ and iSCSI Event Data. . . . . . . 148\n                        10.9.4.1.  SenseLength\
    \ . . . . . . . . . . . 148\n       10.10. Text Request . . . . . . . . . . .\
    \ . . . . . . . . . . 149\n              10.10.1.  F (Final) Bit. . . . . . .\
    \ . . . . . . . . . 150\n              10.10.2.  C (Continue) Bit . . . . . .\
    \ . . . . . . . . 150\n              10.10.3.  Initiator Task Tag . . . . . .\
    \ . . . . . . . 150\n              10.10.4.  Target Transfer Tag. . . . . . .\
    \ . . . . . . 150\n              10.10.5.  Text . . . . . . . . . . . . . . .\
    \ . . . . . 151\n       10.11. Text Response. . . . . . . . . . . . . . . . .\
    \ . . . . 152\n              10.11.1.  F (Final) Bit. . . . . . . . . . . . .\
    \ . . . 152\n              10.11.2.  C (Continue) Bit . . . . . . . . . . . .\
    \ . . 153\n              10.11.3.  Initiator Task Tag . . . . . . . . . . . .\
    \ . 153\n              10.11.4.  Target Transfer Tag. . . . . . . . . . . . .\
    \ 153\n              10.11.5.  StatSN . . . . . . . . . . . . . . . . . . . 154\n\
    \              10.11.6.  Text Response Data . . . . . . . . . . . . . 154\n  \
    \     10.12. Login Request. . . . . . . . . . . . . . . . . . . . . 154\n    \
    \          10.12.1.  T (Transit) Bit. . . . . . . . . . . . . . . 155\n      \
    \        10.12.2.  C (Continue) Bit . . . . . . . . . . . . . . 155\n        \
    \      10.12.3.  CSG and NSG. . . . . . . . . . . . . . . . . 156\n          \
    \    10.12.4.  Version. . . . . . . . . . . . . . . . . . . 156\n            \
    \            10.12.4.1.  Version-max. . . . . . . . . . . 156\n              \
    \          10.12.4.2.  Version-min. . . . . . . . . . . 156\n              10.12.5.\
    \  ISID . . . . . . . . . . . . . . . . . . . . 157\n              10.12.6.  TSIH\
    \ . . . . . . . . . . . . . . . . . . . . 158\n              10.12.7.  Connection\
    \ ID - CID. . . . . . . . . . . . . 158\n              10.12.8.  CmdSN. . . .\
    \ . . . . . . . . . . . . . . . . 159\n              10.12.9.  ExpStatSN. . .\
    \ . . . . . . . . . . . . . . . 159\n              10.12.10. Login Parameters\
    \ . . . . . . . . . . . . . . 159\n       10.13. Login Response . . . . . . .\
    \ . . . . . . . . . . . . . 160\n              10.13.1.  Version-max. . . . .\
    \ . . . . . . . . . . . . 160\n              10.13.2.  Version-active . . . .\
    \ . . . . . . . . . . . 161\n              10.13.3.  TSIH . . . . . . . . . .\
    \ . . . . . . . . . . 161\n              10.13.4.  StatSN . . . . . . . . . .\
    \ . . . . . . . . . 161\n              10.13.5.  Status-Class and Status-Detail\
    \ . . . . . . . 161\n              10.13.6.  T (Transit) Bit. . . . . . . . .\
    \ . . . . . . 164\n              10.13.7.  C (Continue) Bit . . . . . . . . .\
    \ . . . . . 164\n              10.13.8.  Login Parameters . . . . . . . . . .\
    \ . . . . 164\n       10.14. Logout Request . . . . . . . . . . . . . . . . .\
    \ . . . 165\n              10.14.1.  Reason Code. . . . . . . . . . . . . . .\
    \ . . 167\n              10.14.2.  TotalAHSLength and DataSegmentLength . . .\
    \ . 168\n              10.14.3.  CID. . . . . . . . . . . . . . . . . . . . .\
    \ 168\n              10.14.4.  ExpStatSN. . . . . . . . . . . . . . . . . . 168\n\
    \              10.14.5.  Implicit termination of tasks. . . . . . . . 168\n  \
    \     10.15. Logout Response. . . . . . . . . . . . . . . . . . . . 169\n    \
    \          10.15.1.  Response . . . . . . . . . . . . . . . . . . 170\n      \
    \        10.15.2.  TotalAHSLength and DataSegmentLength . . . . 170\n        \
    \      10.15.3.  Time2Wait. . . . . . . . . . . . . . . . . . 170\n          \
    \    10.15.4.  Time2Retain. . . . . . . . . . . . . . . . . 170\n       10.16.\
    \ SNACK Request. . . . . . . . . . . . . . . . . . . . . 171\n              10.16.1.\
    \  Type . . . . . . . . . . . . . . . . . . . . 172\n              10.16.2.  Data\
    \ Acknowledgement . . . . . . . . . . . . 173\n              10.16.3.  Resegmentation\
    \ . . . . . . . . . . . . . . . 173\n              10.16.4.  Initiator Task Tag\
    \ . . . . . . . . . . . . . 174\n              10.16.5.  Target Transfer Tag or\
    \ SNACK Tag . . . . . . 174\n              10.16.6.  BegRun . . . . . . . . .\
    \ . . . . . . . . . . 174\n              10.16.7.  RunLength. . . . . . . . .\
    \ . . . . . . . . . 174\n       10.17. Reject . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 175\n              10.17.1.  Reason . . . . . . . . . . . .\
    \ . . . . . . . 176\n              10.17.2.  DataSN/R2TSN . . . . . . . . . .\
    \ . . . . . . 177\n              10.17.3.  StatSN, ExpCmdSN and MaxCmdSN. . .\
    \ . . . . . 177\n              10.17.4.  Complete Header of Bad PDU . . . . .\
    \ . . . . 177\n       10.18. NOP-Out. . . . . . . . . . . . . . . . . . . . .\
    \ . . . 178\n              10.18.1.  Initiator Task Tag . . . . . . . . . . .\
    \ . . 179\n              10.18.2.  Target Transfer Tag. . . . . . . . . . . .\
    \ . 179\n              10.18.3.  Ping Data. . . . . . . . . . . . . . . . . .\
    \ 179\n       10.19. NOP-In . . . . . . . . . . . . . . . . . . . . . . . . 180\n\
    \              10.19.1.  Target Transfer Tag. . . . . . . . . . . . . 181\n  \
    \            10.19.2.  StatSN . . . . . . . . . . . . . . . . . . . 181\n    \
    \          10.19.3.  LUN. . . . . . . . . . . . . . . . . . . . . 181\n   11.\
    \ iSCSI Security Text Keys and Authentication Methods . . . . . 181\n       11.1.\
    \  AuthMethod . . . . . . . . . . . . . . . . . . . . . . 182\n              11.1.1.\
    \   Kerberos . . . . . . . . . . . . . . . . . . 184\n              11.1.2.  \
    \ Simple Public-Key Mechanism (SPKM) . . . . . 184\n              11.1.3.   Secure\
    \ Remote Password (SRP) . . . . . . . . 185\n              11.1.4.   Challenge\
    \ Handshake Authentication Protocol\n                        (CHAP) . . . . .\
    \ . . . . . . . . . . . . . . 186\n   12. Login/Text Operational Text Keys. .\
    \ . . . . . . . . . . . . . 187\n       12.1.  HeaderDigest and DataDigest. .\
    \ . . . . . . . . . . . . 188\n       12.2.  MaxConnections . . . . . . . . .\
    \ . . . . . . . . . . . 190\n       12.3.  SendTargets. . . . . . . . . . . .\
    \ . . . . . . . . . . 191\n       12.4.  TargetName . . . . . . . . . . . . .\
    \ . . . . . . . . . 191\n       12.5.  InitiatorName. . . . . . . . . . . . .\
    \ . . . . . . . . 192\n       12.6.  TargetAlias. . . . . . . . . . . . . . .\
    \ . . . . . . . 192\n       12.7.  InitiatorAlias . . . . . . . . . . . . . .\
    \ . . . . . . 193\n       12.8.  TargetAddress. . . . . . . . . . . . . . . .\
    \ . . . . . 193\n       12.9.  TargetPortalGroupTag . . . . . . . . . . . . .\
    \ . . . . 194\n       12.10. InitialR2T . . . . . . . . . . . . . . . . . . .\
    \ . . . 194\n       12.11. ImmediateData. . . . . . . . . . . . . . . . . . .\
    \ . . 195\n       12.12. MaxRecvDataSegmentLength . . . . . . . . . . . . . .\
    \ . 196\n       12.13. MaxBurstLength . . . . . . . . . . . . . . . . . . . .\
    \ 196\n       12.14. FirstBurstLength . . . . . . . . . . . . . . . . . . . 197\n\
    \       12.15. DefaultTime2Wait . . . . . . . . . . . . . . . . . . . 197\n  \
    \     12.16. DefaultTime2Retain . . . . . . . . . . . . . . . . . . 198\n    \
    \   12.17. MaxOutstandingR2T. . . . . . . . . . . . . . . . . . . 198\n      \
    \ 12.18. DataPDUInOrder . . . . . . . . . . . . . . . . . . . . 198\n       12.19.\
    \ DataSequenceInOrder. . . . . . . . . . . . . . . . . . 199\n       12.20. ErrorRecoveryLevel\
    \ . . . . . . . . . . . . . . . . . . 199\n       12.21. SessionType. . . . .\
    \ . . . . . . . . . . . . . . . . . 200\n       12.22. The Private or Public Extension\
    \ Key Format . . . . . . 200\n   13. IANA Considerations . . . . . . . . . . .\
    \ . . . . . . . . . . 201\n       13.1.  Naming Requirements. . . . . . . . .\
    \ . . . . . . . . . 203\n       13.2.  Mechanism Specification Requirements .\
    \ . . . . . . . . 203\n       13.3.  Publication Requirements . . . . . . . .\
    \ . . . . . . . 203\n       13.4.  Security Requirements. . . . . . . . . . .\
    \ . . . . . . 203\n       13.5.  Registration Procedure . . . . . . . . . . .\
    \ . . . . . 204\n              13.5.1.   Present the iSCSI extension item to the\n\
    \                        Community. . . . . . . . . . . . . . . . . . 204\n  \
    \            13.5.2.   iSCSI extension item review and IESG\n                \
    \        approval . . . . . . . . . . . . . . . . . . 204\n              13.5.3.\
    \   IANA Registration. . . . . . . . . . . . . . 204\n              13.5.4.  \
    \ Standard iSCSI extension item-label format . 204\n       13.6.  IANA Procedures\
    \ for Registering iSCSI extension items. 205\n   References. . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 205\n   Appendix A. Sync and Steering with\
    \ Fixed Interval Markers . . . . 209\n       A.1.   Markers At Fixed Intervals\
    \ . . . . . . . . . . . . . . 209\n       A.2.   Initial Marker-less Interval\
    \ . . . . . . . . . . . . . 210\n       A.3.   Negotiation. . . . . . . . . .\
    \ . . . . . . . . . . . . 210\n              A.3.1.    OFMarker, IFMarker . .\
    \ . . . . . . . . . . . 210\n              A.3.2.    OFMarkInt, IFMarkInt . .\
    \ . . . . . . . . . . 211\n   Appendix B.  Examples . . . . . . . . . . . . .\
    \ . . . . . . . . . 212\n       B.1.   Read Operation Example . . . . . . . .\
    \ . . . . . . . . 212\n       B.2.   Write Operation Example. . . . . . . . .\
    \ . . . . . . . 213\n       B.3.   R2TSN/DataSN Use Examples. . . . . . . . .\
    \ . . . . . . 214\n       B.4.   CRC Examples . . . . . . . . . . . . . . . .\
    \ . . . . . 217\n   Appendix C.  Login Phase Examples . . . . . . . . . . . .\
    \ . . . . 219\n   Appendix D.  SendTargets Operation. . . . . . . . . . . . .\
    \ . . . 229\n   Appendix E.  Algorithmic Presentation of Error Recovery Classes\
    \ . 233\n       E.1.   General Data Structure and Procedure Description . . .\
    \ 233\n       E.2.   Within-command Error Recovery Algorithms . . . . . . . 234\n\
    \              E.2.1.    Procedure Descriptions . . . . . . . . . . . 234\n  \
    \            E.2.2.    Initiator Algorithms . . . . . . . . . . . . 235\n    \
    \          E.2.3.    Target Algorithms. . . . . . . . . . . . . . 237\n      \
    \ E.3.   Within-connection Recovery Algorithms. . . . . . . . . 240\n        \
    \      E.3.1.    Procedure Descriptions . . . . . . . . . . . 240\n          \
    \    E.3.2.    Initiator Algorithms . . . . . . . . . . . . 241\n            \
    \  E.3.3.    Target Algorithms. . . . . . . . . . . . . . 243\n       E.4.   Connection\
    \ Recovery Algorithms . . . . . . . . . . . . 243\n              E.4.1.    Procedure\
    \ Descriptions . . . . . . . . . . . 243\n              E.4.2.    Initiator Algorithms\
    \ . . . . . . . . . . . . 244\n              E.4.3.    Target Algorithms. . .\
    \ . . . . . . . . . . . 246\n   Appendix F.  Clearing Effects of Various Events\
    \ on Targets. . . . 249\n       F.1.   Clearing Effects on iSCSI Objects. . .\
    \ . . . . . . . . 249\n       F.2.   Clearing Effects on SCSI Objects . . . .\
    \ . . . . . . . 253\n   Acknowledgements. . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 254\n   Authors' Addresses. . . . . . . . . . . . . . . . . . .\
    \ . . . . . 256\n   Full Copyright Statement. . . . . . . . . . . . . . . . .\
    \ . . . . 257\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Small Computer Systems Interface (SCSI) is a popular\
    \ family of\n   protocols for communicating with I/O devices, especially storage\n\
    \   devices.  SCSI is a client-server architecture.  Clients of a SCSI\n   interface\
    \ are called \"initiators\".  Initiators issue SCSI \"commands\"\n   to request\
    \ services from components, logical units of a server known\n   as a \"target\"\
    .  A \"SCSI transport\" maps the client-server SCSI\n   protocol to a specific\
    \ interconnect.  An Initiator is one endpoint of\n   a SCSI transport and a target\
    \ is the other endpoint.\n   The SCSI protocol has been mapped over various transports,\
    \ including\n   Parallel SCSI, IPI, IEEE-1394 (firewire) and Fibre Channel.  These\n\
    \   transports are I/O specific and have limited distance capabilities.\n   The\
    \ iSCSI protocol defined in this document describes a means of\n   transporting\
    \ SCSI packets over TCP/IP (see [RFC791], [RFC793],\n   [RFC1035], [RFC1122]),\
    \ providing for an interoperable solution which\n   can take advantage of existing\
    \ Internet infrastructure, Internet\n   management facilities, and address distance\
    \ limitations.\n"
- title: 2.  Definitions and Acronyms
  contents:
  - '2.  Definitions and Acronyms

    '
- title: 2.1.  Definitions
  contents:
  - "2.1.  Definitions\n   - Alias: An alias string can also be associated with an\
    \ iSCSI Node.\n     The alias allows an organization to associate a user-friendly\n\
    \     string with the iSCSI Name.  However, the alias string is not a\n     substitute\
    \ for the iSCSI Name.\n   - CID (Connection ID): Connections within a session\
    \ are identified by\n     a connection ID.  It is a unique ID for this connection\
    \ within the\n     session for the initiator.  It is generated by the initiator\
    \ and\n     presented to the target during login requests and during logouts\n\
    \     that close connections.\n   - Connection: A connection is a TCP connection.\
    \  Communication\n     between the initiator and target occurs over one or more\
    \ TCP\n     connections.  The TCP connections carry control messages, SCSI\n \
    \    commands, parameters, and data within iSCSI Protocol Data Units\n     (iSCSI\
    \ PDUs).\n   - iSCSI Device: A SCSI Device using an iSCSI service delivery\n \
    \    subsystem.  Service Delivery Subsystem is defined by [SAM2] as a\n     transport\
    \ mechanism for SCSI commands and responses.\n   - iSCSI Initiator Name: The iSCSI\
    \ Initiator Name specifies the\n     worldwide unique name of the initiator.\n\
    \   - iSCSI Initiator Node: The \"initiator\".  The word \"initiator\" has\n \
    \    been appropriately qualified as either a port or a device in the\n     rest\
    \ of the document when the context is ambiguous.  All\n     unqualified usages\
    \ of \"initiator\" refer to an initiator port (or\n     device) depending on the\
    \ context.\n   - iSCSI Layer: This layer builds/receives iSCSI PDUs and\n    \
    \ relays/receives them to/from one or more TCP connections that form\n     an\
    \ initiator-target \"session\".\n   - iSCSI Name: The name of an iSCSI initiator\
    \ or iSCSI target.\n   - iSCSI Node: The iSCSI Node represents a single iSCSI\
    \ initiator or\n     iSCSI target.  There are one or more iSCSI Nodes within a\
    \ Network\n     Entity.  The iSCSI Node is accessible via one or more Network\n\
    \     Portals.  An iSCSI Node is identified by its iSCSI Name.  The\n     separation\
    \ of the iSCSI Name from the addresses used by and for the\n     iSCSI Node allows\
    \ multiple iSCSI Nodes to use the same address, and\n     the same iSCSI Node\
    \ to use multiple addresses.\n   - iSCSI Target Name: The iSCSI Target Name specifies\
    \ the worldwide\n     unique name of the target.\n   - iSCSI Target Node: The\
    \ \"target\".\n   - iSCSI Task: An iSCSI task is an iSCSI request for which a\
    \ response\n     is expected.\n   - iSCSI Transfer Direction: The iSCSI transfer\
    \ direction is defined\n     with regard to the initiator.  Outbound or outgoing\
    \ transfers are\n     transfers from the initiator to the target, while inbound\
    \ or\n     incoming transfers are from the target to the initiator.\n   - ISID:\
    \ The initiator part of the Session Identifier.  It is\n     explicitly specified\
    \ by the initiator during Login.\n   - I_T nexus: According to [SAM2], the I_T\
    \ nexus is a relationship\n     between a SCSI Initiator Port and a SCSI Target\
    \ Port.  For iSCSI,\n     this relationship is a session, defined as a relationship\
    \ between\n     an iSCSI Initiator's end of the session (SCSI Initiator Port)\
    \ and\n     the iSCSI Target's Portal Group.  The I_T nexus can be identified\n\
    \     by the conjunction of the SCSI port names; that is, the I_T nexus\n    \
    \ identifier is the tuple (iSCSI Initiator Name + ',i,'+ ISID, iSCSI\n     Target\
    \ Name + ',t,'+ Portal Group Tag).\n   - Network Entity: The Network Entity represents\
    \ a device or gateway\n     that is accessible from the IP network.  A Network\
    \ Entity must have\n     one or more Network Portals, each of which can be used\
    \ to gain\n     access to the IP network by some iSCSI Nodes contained in that\n\
    \     Network Entity.\n   - Network Portal: The Network Portal is a component\
    \ of a Network\n     Entity that has a TCP/IP network address and that may be\
    \ used by an\n     iSCSI Node within that Network Entity for the connection(s)\
    \ within\n     one of its iSCSI sessions.  A Network Portal in an initiator is\n\
    \     identified by its IP address.  A Network Portal in a target is\n     identified\
    \ by its IP address and its listening TCP port.\n   - Originator: In a negotiation\
    \ or exchange, the party that initiates\n     the negotiation or exchange.\n \
    \  - PDU (Protocol Data Unit): The initiator and target divide their\n     communications\
    \ into messages.  The term \"iSCSI protocol data unit\"\n     (iSCSI PDU) is used\
    \ for these messages.\n   - Portal Groups: iSCSI supports multiple connections\
    \ within the same\n     session; some implementations will have the ability to\
    \ combine\n     connections in a session across multiple Network Portals.  A Portal\n\
    \     Group defines a set of Network Portals within an iSCSI Network\n     Entity\
    \ that collectively supports the capability of coordinating a\n     session with\
    \ connections spanning these portals.  Not all Network\n     Portals within a\
    \ Portal Group need participate in every session\n     connected through that\
    \ Portal Group.  One or more Portal Groups may\n     provide access to an iSCSI\
    \ Node.  Each Network Portal, as utilized\n     by a given iSCSI Node, belongs\
    \ to exactly one portal group within\n     that node.\n   - Portal Group Tag:\
    \ This 16-bit quantity identifies a Portal Group\n     within an iSCSI Node. \
    \ All Network Portals with the same portal\n     group tag in the context of a\
    \ given iSCSI Node are in the same\n     Portal Group.\n   - Recovery R2T: An\
    \ R2T generated by a target upon detecting the loss\n     of one or more Data-Out\
    \ PDUs through one of the following means: a\n     digest error, a sequence error,\
    \ or a sequence reception timeout.  A\n     recovery R2T carries the next unused\
    \ R2TSN, but requests all or\n     part of the data burst that an earlier R2T\
    \ (with a lower R2TSN) had\n     already requested.\n   - Responder: In a negotiation\
    \ or exchange, the party that responds to\n     the originator of the negotiation\
    \ or exchange.\n   - SCSI Device: This is the SAM2 term for an entity that contains\
    \ one\n     or more SCSI ports that are connected to a service delivery\n    \
    \ subsystem and supports a SCSI application protocol.  For example, a\n     SCSI\
    \ Initiator Device contains one or more SCSI Initiator Ports and\n     zero or\
    \ more application clients.  A Target Device contains one or\n     more SCSI Target\
    \ Ports and one or more device servers and\n     associated logical units.  For\
    \ iSCSI, the SCSI Device is the\n     component within an iSCSI Node that provides\
    \ the SCSI\n     functionality.  As such, there can be at most, one SCSI Device\n\
    \     within a given iSCSI Node.  Access to the SCSI Device can only be\n    \
    \ achieved in an iSCSI normal operational session.  The SCSI Device\n     Name\
    \ is defined to be the iSCSI Name of the node.\n   - SCSI Layer: This builds/receives\
    \ SCSI CDBs (Command Descriptor\n     Blocks) and relays/receives them with the\
    \ remaining command execute\n     [SAM2] parameters to/from the iSCSI Layer.\n\
    \   - Session: The group of TCP connections that link an initiator with a\n  \
    \   target form a session (loosely equivalent to a SCSI I-T nexus).\n     TCP\
    \ connections can be added and removed from a session.  Across\n     all connections\
    \ within a session, an initiator sees one and the\n     same target.\n   - SCSI\
    \ Initiator Port: This maps to the endpoint of an iSCSI normal\n     operational\
    \ session.  An iSCSI normal operational session is\n     negotiated through the\
    \ login process between an iSCSI initiator\n     node and an iSCSI target node.\
    \  At successful completion of this\n     process, a SCSI Initiator Port is created\
    \ within the SCSI Initiator\n     Device.  The SCSI Initiator Port Name and SCSI\
    \ Initiator Port\n     Identifier are both defined to be the iSCSI Initiator Name\
    \ together\n     with (a) a label that identifies it as an initiator port\n  \
    \   name/identifier and (b) the ISID portion of the session identifier.\n   -\
    \ SCSI Port: This is the SAM2 term for an entity in a SCSI Device\n     that provides\
    \ the SCSI functionality to interface with a service\n     delivery subsystem.\
    \  For iSCSI, the definition of the SCSI\n     Initiator Port and the SCSI Target\
    \ Port are different.\n   - SCSI Port Name: A name made up as UTF-8 [RFC2279]\
    \ characters and\n     includes the iSCSI Name + 'i' or 't' + ISID or Portal Group\
    \ Tag.\n   - SCSI Target Port: This maps to an iSCSI Target Portal Group.\n  \
    \ - SCSI Target Port Name and SCSI Target Port Identifier: These are\n     both\
    \ defined to be the iSCSI Target Name together with (a) a label\n     that identifies\
    \ it as a target port name/identifier and (b) the\n     portal group tag.\n  \
    \ - SSID (Session ID): A session between an iSCSI initiator and an\n     iSCSI\
    \ target is defined by a session ID that is a tuple composed of\n     an initiator\
    \ part (ISID) and a target part (Target Portal Group\n     Tag).  The ISID is\
    \ explicitly specified by the initiator at session\n     establishment.  The Target\
    \ Portal Group Tag is implied by the\n     initiator through the selection of\
    \ the TCP endpoint at connection\n     establishment.  The TargetPortalGroupTag\
    \ key must also be returned\n     by the target as a confirmation during connection\
    \ establishment\n     when TargetName is given.\n   - Target Portal Group Tag:\
    \ A numerical identifier (16-bit) for an\n     iSCSI Target Portal Group.\n  \
    \ - TSIH (Target Session Identifying Handle): A target assigned tag for\n    \
    \ a session with a specific named initiator.  The target generates it\n     during\
    \ session establishment.  Its internal format and content are\n     not defined\
    \ by this protocol, except for the value 0 that is\n     reserved and used by\
    \ the initiator to indicate a new session.  It\n     is given to the target during\
    \ additional connection establishment\n     for the same session.\n"
- title: 2.2.  Acronyms
  contents:
  - "2.2.  Acronyms\n   Acronym     Definition\n   ------------------------------------------------------------\n\
    \   3DES        Triple Data Encryption Standard\n   ACA         Auto Contingent\
    \ Allegiance\n   AEN         Asynchronous Event Notification\n   AES         Advanced\
    \ Encryption Standard\n   AH          Additional Header (not the IPsec AH!)\n\
    \   AHS         Additional Header Segment\n   API         Application Programming\
    \ Interface\n   ASC         Additional Sense Code\n   ASCII       American Standard\
    \ Code for Information Interchange\n   ASCQ        Additional Sense Code Qualifier\n\
    \   BHS         Basic Header Segment\n   CBC         Cipher Block Chaining\n \
    \  CD          Compact Disk\n   CDB         Command Descriptor Block\n   CHAP\
    \        Challenge Handshake Authentication Protocol\n   CID         Connection\
    \ ID\n   CO          Connection Only\n   CRC         Cyclic Redundancy Check\n\
    \   CRL         Certificate Revocation List\n   CSG         Current Stage\n  \
    \ CSM         Connection State Machine\n   DES         Data Encryption Standard\n\
    \   DNS         Domain Name Server\n   DOI         Domain of Interpretation\n\
    \   DVD         Digital Versatile Disk\n   ESP         Encapsulating Security\
    \ Payload\n   EUI         Extended Unique Identifier\n   FFP         Full Feature\
    \ Phase\n   FFPO        Full Feature Phase Only\n   FIM         Fixed Interval\
    \ Marker\n   Gbps        Gigabits per Second\n   HBA         Host Bus Adapter\n\
    \   HMAC        Hashed Message Authentication Code\n   I_T         Initiator_Target\n\
    \   I_T_L       Initiator_Target_LUN\n   IANA        Internet Assigned Numbers\
    \ Authority\n   ID          Identifier\n   IDN         Internationalized Domain\
    \ Name\n   IEEE        Institute of Electrical & Electronics Engineers\n   IETF\
    \        Internet Engineering Task Force\n   IKE         Internet Key Exchange\n\
    \   I/O         Input - Output\n   IO          Initialize Only\n   IP        \
    \  Internet Protocol\n   IPsec       Internet Protocol Security\n   IPv4     \
    \   Internet Protocol Version 4\n   IPv6        Internet Protocol Version 6\n\
    \   IQN         iSCSI Qualified Name\n   ISID        Initiator Session ID\n  \
    \ ITN         iSCSI Target Name\n   ITT         Initiator Task Tag\n   KRB5  \
    \      Kerberos V5\n   LFL         Lower Functional Layer\n   LTDS        Logical-Text-Data-Segment\n\
    \   LO          Leading Only\n   LU          Logical Unit\n   LUN         Logical\
    \ Unit Number\n   MAC         Message Authentication Codes\n   NA          Not\
    \ Applicable\n   NIC         Network Interface Card\n   NOP         No Operation\n\
    \   NSG         Next Stage\n   OS          Operating System\n   PDU         Protocol\
    \ Data Unit\n   PKI         Public Key Infrastructure\n   R2T         Ready To\
    \ Transfer\n   R2TSN       Ready To Transfer Sequence Number\n   RDMA        Remote\
    \ Direct Memory Access\n   RFC         Request For Comments\n   SAM         SCSI\
    \ Architecture Model\n   SAM2        SCSI Architecture Model - 2\n   SAN     \
    \    Storage Area Network\n   SCSI        Small Computer Systems Interface\n \
    \  SN          Sequence Number\n   SNACK       Selective Negative Acknowledgment\
    \ - also\n               Sequence Number Acknowledgement for data\n   SPKM   \
    \     Simple Public-Key Mechanism\n   SRP         Secure Remote Password\n   SSID\
    \        Session ID\n   SW          Session Wide\n   TCB         Task Control\
    \ Block\n   TCP         Transmission Control Protocol\n   TPGT        Target Portal\
    \ Group Tag\n   TSIH        Target Session Identifying Handle\n   TTT        \
    \ Target Transfer Tag\n   UFL         Upper Functional Layer\n   ULP         Upper\
    \ Level Protocol\n   URN         Uniform Resource Names [RFC2396]\n   UTF    \
    \     Universal Transformation Format\n   WG          Working Group\n"
- title: 2.3.  Conventions
  contents:
  - "2.3.  Conventions\n   In examples, \"I->\" and \"T->\" show iSCSI PDUs sent by\
    \ the initiator\n   and target respectively.\n   The key words \"MUST\", \"MUST\
    \ NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\"\
    , \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted\
    \ as described in BCP 14 [RFC2119].\n   iSCSI messages - PDUs - are represented\
    \ by diagrams as in the\n   following example:\n    Byte/     0       |      \
    \ 1       |       2       |       3       |\n       /              |         \
    \      |               |               |\n      |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n      +---------------+---------------+---------------+---------------+\n\
    \     0| Basic Header Segment (BHS)                                    |\n   \
    \   +---------------+---------------+---------------+---------------+\n    ----------\n\
    \     +|                                                               |\n   \
    \   +---------------+---------------+---------------+---------------+\n   The\
    \ diagrams include byte and bit numbering.\n   The following representation and\
    \ ordering rules are observed in this\n   document:\n     - Word Rule\n     -\
    \ Half-word Rule\n     - Byte Rule\n"
- title: 2.3.1.  Word Rule
  contents:
  - "2.3.1.  Word Rule\n   A word holds four consecutive bytes.  Whenever a word has\
    \ numeric\n   content, it is considered an unsigned number in base 2 positional\n\
    \   representation with the lowest numbered byte (e.g., byte 0) bit 0\n   representing\
    \ 2**31 and bit 1 representing 2**30 through lowest\n   numbered byte + 3 (e.g.,\
    \ byte 3) bit 7 representing 2**0.\n   Decimal and hexadecimal representation\
    \ of word values map this\n   representation to decimal or hexadecimal positional\
    \ notation.\n"
- title: 2.3.2.  Half-Word Rule
  contents:
  - "2.3.2.  Half-Word Rule\n   A half-word holds two consecutive bytes.  Whenever\
    \ a half-word has\n   numeric content it is considered an unsigned number in base\
    \ 2\n   positional representation with the lowest numbered byte (e.g., byte\n\
    \   0), bit 0 representing 2**15 and bit 1 representing 2**14 through\n   lowest\
    \ numbered byte + 1 (e.g., byte 1), bit 7 representing 2**0.\n   Decimal and hexadecimal\
    \ representation of half-word values map this\n   representation to decimal or\
    \ hexadecimal positional notation.\n"
- title: 2.3.3.  Byte Rule
  contents:
  - "2.3.3.  Byte Rule\n   For every PDU, bytes are sent and received in increasing\
    \ numbered\n   order (network order).\n   Whenever a byte has numerical content,\
    \ it is considered an unsigned\n   number in base 2 positional representation\
    \ with bit 0 representing\n   2**7 and bit 1 representing 2**6 through bit 7 representing\
    \ 2**0.\n"
- title: 3.  Overview
  contents:
  - '3.  Overview

    '
- title: 3.1.  SCSI Concepts
  contents:
  - "3.1.  SCSI Concepts\n   The SCSI Architecture Model-2 [SAM2] describes in detail\
    \ the\n   architecture of the SCSI family of I/O protocols.  This section\n  \
    \ provides a brief background of the SCSI architecture and is intended\n   to\
    \ familiarize readers with its terminology.\n   At the highest level, SCSI is\
    \ a family of interfaces for requesting\n   services from I/O devices, including\
    \ hard drives, tape drives, CD and\n   DVD drives, printers, and scanners.  In\
    \ SCSI terminology, an\n   individual I/O device is called a \"logical unit\"\
    \ (LU).\n   SCSI is a client-server architecture.  Clients of a SCSI interface\n\
    \   are called \"initiators\".  Initiators issue SCSI \"commands\" to request\n\
    \   services from components, logical units, of a server known as a\n   \"target\"\
    .  The \"device server\" on the logical unit accepts SCSI\n   commands and processes\
    \ them.\n   A \"SCSI transport\" maps the client-server SCSI protocol to a specific\n\
    \   interconnect.  Initiators are one endpoint of a SCSI transport.  The\n   \"\
    target\" is the other endpoint.  A target can contain multiple\n   Logical Units\
    \ (LUs).  Each Logical Unit has an address within a\n   target called a Logical\
    \ Unit Number (LUN).\n   A SCSI task is a SCSI command or possibly a linked set\
    \ of SCSI\n   commands.  Some LUs support multiple pending (queued) tasks, but\
    \ the\n   queue of tasks is managed by the logical unit.  The target uses an\n\
    \   initiator provided \"task tag\" to distinguish between tasks.  Only one\n\
    \   command in a task can be outstanding at any given time.\n   Each SCSI command\
    \ results in an optional data phase and a required\n   response phase.  In the\
    \ data phase, information can travel from the\n   initiator to target (e.g., WRITE),\
    \ target to initiator (e.g., READ),\n   or in both directions.  In the response\
    \ phase, the target returns the\n   final status of the operation, including any\
    \ errors.\n   Command Descriptor Blocks (CDB) are the data structures used to\n\
    \   contain the command parameters that an initiator sends to a target.\n   The\
    \ CDB content and structure is defined by [SAM2] and device-type\n   specific\
    \ SCSI standards.\n"
- title: 3.2.  iSCSI Concepts and Functional Overview
  contents:
  - "3.2.  iSCSI Concepts and Functional Overview\n   The iSCSI protocol is a mapping\
    \ of the SCSI remote procedure\n   invocation model (see [SAM2]) over the TCP\
    \ protocol.  SCSI commands\n   are carried by iSCSI requests and SCSI responses\
    \ and status are\n   carried by iSCSI responses.  iSCSI also uses the request\
    \ response\n   mechanism for iSCSI protocol mechanisms.\n   For the remainder\
    \ of this document, the terms \"initiator\" and\n   \"target\" refer to \"iSCSI\
    \ initiator node\" and \"iSCSI target node\",\n   respectively (see Section 3.4.1\
    \ iSCSI Architecture Model) unless\n   otherwise qualified.\n   In keeping with\
    \ similar protocols, the initiator and target divide\n   their communications\
    \ into messages.  This document uses the term\n   \"iSCSI protocol data unit\"\
    \ (iSCSI PDU) for these messages.\n   For performance reasons, iSCSI allows a\
    \ \"phase-collapse\".  A command\n   and its associated data may be shipped together\
    \ from initiator to\n   target, and data and responses may be shipped together\
    \ from targets.\n   The iSCSI transfer direction is defined with respect to the\n\
    \   initiator.  Outbound or outgoing transfers are transfers from an\n   initiator\
    \ to a target, while inbound or incoming transfers are from a\n   target to an\
    \ initiator.\n   An iSCSI task is an iSCSI request for which a response is expected.\n\
    \   In this document \"iSCSI request\", \"iSCSI command\", request, or\n   (unqualified)\
    \ command have the same meaning.  Also, unless otherwise\n   specified, status,\
    \ response, or numbered response have the same\n   meaning.\n"
- title: 3.2.1.  Layers and Sessions
  contents:
  - "3.2.1.  Layers and Sessions\n   The following conceptual layering model is used\
    \ to specify initiator\n   and target actions and the way in which they relate\
    \ to transmitted\n   and received Protocol Data Units:\n      a) the SCSI layer\
    \ builds/receives SCSI CDBs (Command Descriptor\n         Blocks) and passes/receives\
    \ them with the remaining command\n         execute parameters ([SAM2]) to/from\n\
    \      b) the iSCSI layer that builds/receives iSCSI PDUs and\n         relays/receives\
    \ them to/from one or more TCP connections; the\n         group of connections\
    \ form an initiator-target \"session\".\n   Communication between the initiator\
    \ and target occurs over one or\n   more TCP connections.  The TCP connections\
    \ carry control messages,\n   SCSI commands, parameters, and data within iSCSI\
    \ Protocol Data Units\n   (iSCSI PDUs).  The group of TCP connections that link\
    \ an initiator\n   with a target form a session (loosely equivalent to a SCSI\
    \ I_T nexus,\n   see Section 3.4.2 SCSI Architecture Model).  A session is defined\
    \ by\n   a session ID that is composed of an initiator part and a target part.\n\
    \   TCP connections can be added and removed from a session.  Each\n   connection\
    \ within a session is identified by a connection ID (CID).\n   Across all connections\
    \ within a session, an initiator sees one\n   \"target image\".  All target identifying\
    \ elements, such as LUN, are\n   the same.  A target also sees one \"initiator\
    \ image\" across all\n   connections within a session.  Initiator identifying\
    \ elements, such\n   as the Initiator Task Tag, are global across the session\
    \ regardless\n   of the connection on which they are sent or received.\n   iSCSI\
    \ targets and initiators MUST support at least one TCP connection\n   and MAY\
    \ support several connections in a session.  For error recovery\n   purposes,\
    \ targets and initiators that support a single active\n   connection in a session\
    \ SHOULD support two connections during\n   recovery.\n"
- title: 3.2.2.  Ordering and iSCSI Numbering
  contents:
  - "3.2.2.  Ordering and iSCSI Numbering\n   iSCSI uses Command and Status numbering\
    \ schemes and a Data sequencing\n   scheme.\n   Command numbering is session-wide\
    \ and is used for ordered command\n   delivery over multiple connections.  It\
    \ can also be used as a\n   mechanism for command flow control over a session.\n\
    \   Status numbering is per connection and is used to enable missing\n   status\
    \ detection and recovery in the presence of transient or\n   permanent communication\
    \ errors.\n   Data sequencing is per command or part of a command (R2T triggered\n\
    \   sequence) and is used to detect missing data and/or R2T PDUs due to\n   header\
    \ digest errors.\n   Typically, fields in the iSCSI PDUs communicate the Sequence\
    \ Numbers\n   between the initiator and target.  During periods when traffic on\
    \ a\n   connection is unidirectional, iSCSI NOP-Out/In PDUs may be utilized\n\
    \   to synchronize the command and status ordering counters of the target\n  \
    \ and initiator.\n   The iSCSI session abstraction is equivalent to the SCSI I_T\
    \ nexus,\n   and the iSCSI session provides an ordered command delivery from the\n\
    \   SCSI initiator to the SCSI target.  For detailed design\n   considerations\
    \ that led to the iSCSI session model as it is defined\n   here and how it relates\
    \ the SCSI command ordering features defined in\n   SCSI specifications to the\
    \ iSCSI concepts see [CORD].\n"
- title: 3.2.2.1.  Command Numbering and Acknowledging
  contents:
  - "3.2.2.1.  Command Numbering and Acknowledging\n   iSCSI performs ordered command\
    \ delivery within a session.  All\n   commands (initiator-to-target PDUs) in transit\
    \ from the initiator to\n   the target are numbered.\n   iSCSI considers a task\
    \ to be instantiated on the target in response\n   to every request issued by\
    \ the initiator.  A set of task management\n   operations including abort and\
    \ reassign (see Section 10.5 Task\n   Management Function Request) may be performed\
    \ on any iSCSI task.\n   Some iSCSI tasks are SCSI tasks, and many SCSI activities\
    \ are related\n   to a SCSI task ([SAM2]).  In all cases, the task is identified\
    \ by the\n   Initiator Task Tag for the life of the task.\n   The command number\
    \ is carried by the iSCSI PDU as CmdSN\n   (Command Sequence Number).  The numbering\
    \ is session-wide.  Outgoing\n   iSCSI PDUs carry this number.  The iSCSI initiator\
    \ allocates CmdSNs\n   with a 32-bit unsigned counter (modulo 2**32).  Comparisons\
    \ and\n   arithmetic on CmdSN use Serial Number Arithmetic as defined in\n   [RFC1982]\
    \ where SERIAL_BITS = 32.\n   Commands meant for immediate delivery are marked\
    \ with an immediate\n   delivery flag; they MUST also carry the current CmdSN.\
    \  CmdSN does\n   not advance after a command marked for immediate delivery is\
    \ sent.\n   Command numbering starts with the first login request on the first\n\
    \   connection of a session (the leading login on the leading connection)\n  \
    \ and command numbers are incremented by 1 for every non-immediate\n   command\
    \ issued afterwards.\n   If immediate delivery is used with task management commands,\
    \ these\n   commands may reach the target before the tasks on which they are\n\
    \   supposed to act.  However their CmdSN serves as a marker of their\n   position\
    \ in the stream of commands.  The initiator and target must\n   ensure that the\
    \ task management commands act as specified by [SAM2].\n   For example, both commands\
    \ and responses appear as if delivered in\n   order.  Whenever CmdSN for an outgoing\
    \ PDU is not specified by an\n   explicit rule, CmdSN will carry the current value\
    \ of the local CmdSN\n   variable (see later in this section).\n   The means by\
    \ which an implementation decides to mark a PDU for\n   immediate delivery or\
    \ by which iSCSI decides by itself to mark a PDU\n   for immediate delivery are\
    \ beyond the scope of this document.\n   The number of commands used for immediate\
    \ delivery is not limited and\n   their delivery for execution is not acknowledged\
    \ through the\n   numbering scheme.  Immediate commands MAY be rejected by the\
    \ iSCSI\n   target layer due to a lack of resources.  An iSCSI target MUST be\n\
    \   able to handle at least one immediate task management command and one\n  \
    \ immediate non-task-management iSCSI command per connection at any\n   time.\n\
    \   In this document, delivery for execution means delivery to the SCSI\n   execution\
    \ engine or an iSCSI protocol specific execution engine\n   (e.g., for text requests\
    \ with public or private extension keys\n   involving an execution component).\
    \  With the exception of the\n   commands marked for immediate delivery, the iSCSI\
    \ target layer MUST\n   deliver the commands for execution in the order specified\
    \ by CmdSN.\n   Commands marked for immediate delivery may be delivered by the\
    \ iSCSI\n   target layer for execution as soon as detected.  iSCSI may avoid\n\
    \   delivering some commands to the SCSI target layer if required by a\n   prior\
    \ SCSI or iSCSI action (e.g., CLEAR TASK SET Task Management\n   request received\
    \ before all the commands on which it was supposed to\n   act).\n   On any connection,\
    \ the iSCSI initiator MUST send the commands in\n   increasing order of CmdSN,\
    \ except for commands that are retransmitted\n   due to digest error recovery\
    \ and connection recovery.\n   For the numbering mechanism, the initiator and\
    \ target maintain the\n   following three variables for each session:\n      -\
    \  CmdSN - the current command Sequence Number, advanced by 1 on\n         each\
    \ command shipped except for commands marked for immediate\n         delivery.\
    \  CmdSN always contains the number to be assigned to\n         the next Command\
    \ PDU.\n      -  ExpCmdSN - the next expected command by the target.  The target\n\
    \         acknowledges all commands up to, but not including, this\n         number.\
    \  The initiator treats all commands with CmdSN less than\n         ExpCmdSN as\
    \ acknowledged.  The target iSCSI layer sets the\n         ExpCmdSN to the largest\
    \ non-immediate CmdSN that it can deliver\n         for execution plus 1 (no holes\
    \ in the CmdSN sequence).\n      -  MaxCmdSN - the maximum number to be shipped.\
    \  The queuing\n         capacity of the receiving iSCSI layer is MaxCmdSN - ExpCmdSN\
    \ +\n         1.\n   The initiator's ExpCmdSN and MaxCmdSN are derived from\n\
    \   target-to-initiator PDU fields.  Comparisons and arithmetic on\n   ExpCmdSN\
    \ and MaxCmdSN MUST use Serial Number Arithmetic as defined in\n   [RFC1982] where\
    \ SERIAL_BITS = 32.\n   The target MUST NOT transmit a MaxCmdSN that is less than\n\
    \   ExpCmdSN-1.  For non-immediate commands, the CmdSN field can take any\n  \
    \ value from ExpCmdSN to MaxCmdSN inclusive.  The target MUST silently\n   ignore\
    \ any non-immediate command outside of this range or non-\n   immediate duplicates\
    \ within the range.  The CmdSN carried by\n   immediate commands may lie outside\
    \ the ExpCmdSN to MaxCmdSN range.\n   For example, if the initiator has previously\
    \ sent a non-immediate\n   command carrying the CmdSN equal to MaxCmdSN, the target\
    \ window is\n   closed.  For group task management commands issued as immediate\n\
    \   commands, CmdSN indicates the scope of the group action (e.g., on\n   ABORT\
    \ TASK SET indicates which commands are aborted).\n   MaxCmdSN and ExpCmdSN fields\
    \ are processed by the initiator as\n   follows:\n      -  If the PDU MaxCmdSN\
    \ is less than the PDU ExpCmdSN-1 (in Serial\n         Arithmetic Sense), they\
    \ are both ignored.\n      -  If the PDU MaxCmdSN is greater than the local MaxCmdSN\
    \ (in\n         Serial Arithmetic Sense), it updates the local MaxCmdSN;\n   \
    \      otherwise, it is ignored.\n      -  If the PDU ExpCmdSN is greater than\
    \ the local ExpCmdSN (in\n         Serial Arithmetic Sense), it updates the local\
    \ ExpCmdSN;\n         otherwise, it is ignored.\n   This sequence is required\
    \ because updates may arrive out of order\n   (e.g., the updates are sent on different\
    \ TCP connections).\n   iSCSI initiators and targets MUST support the command\
    \ numbering\n   scheme.\n   A numbered iSCSI request will not change its allocated\
    \ CmdSN,\n   regardless of the number of times and circumstances in which it is\n\
    \   reissued (see Section 6.2.1 Usage of Retry).  At the target, CmdSN is\n  \
    \ only relevant when the command has not created any state related to\n   its\
    \ execution (execution state); afterwards, CmdSN becomes\n   irrelevant.  Testing\
    \ for the execution state (represented by\n   identifying the Initiator Task Tag)\
    \ MUST precede any other action at\n   the target.  If no execution state is found,\
    \ it is followed by\n   ordering and delivery.  If an execution state is found,\
    \ it is\n   followed by delivery.\n   If an initiator issues a command retry for\
    \ a command with CmdSN R on\n   a connection when the session CmdSN value is Q,\
    \ it MUST NOT advance\n   the CmdSN past R + 2**31 -1 unless the connection is\
    \ no longer\n   operational (i.e., it has returned to the FREE state, see Section\n\
    \   7.1.3 Standard Connection State Diagram for an Initiator), the\n   connection\
    \ has been reinstated (see Section 5.3.4 Connection\n   Reinstatement), or a non-immediate\
    \ command with CmdSN equal or\n   greater than Q was issued subsequent to the\
    \ command retry on the same\n   connection and the reception of that command is\
    \ acknowledged by the\n   target (see Section 9.4 Command Retry and Cleaning Old\
    \ Command\n   Instances).\n   A target MUST NOT issue a command response or Data-In\
    \ PDU with status\n   before acknowledging the command.  However, the acknowledgement\
    \ can\n   be included in the response or Data-In PDU.\n"
- title: 3.2.2.2.  Response/Status Numbering and Acknowledging
  contents:
  - "3.2.2.2.  Response/Status Numbering and Acknowledging\n   Responses in transit\
    \ from the target to the initiator are numbered.\n   The StatSN (Status Sequence\
    \ Number) is used for this purpose.  StatSN\n   is a counter maintained per connection.\
    \  ExpStatSN is used by the\n   initiator to acknowledge status.  The status sequence\
    \ number space is\n   32-bit unsigned-integers and the arithmetic operations are\
    \ the\n   regular mod(2**32) arithmetic.\n   Status numbering starts with the\
    \ Login response to the first Login\n   request of the connection.  The Login\
    \ response includes an initial\n   value for status numbering (any initial value\
    \ is valid).\n   To enable command recovery, the target MAY maintain enough state\n\
    \   information for data and status recovery after a connection failure.\n   A\
    \ target doing so can safely discard all of the state information\n   maintained\
    \ for recovery of a command after the delivery of the status\n   for the command\
    \ (numbered StatSN) is acknowledged through ExpStatSN.\n   A large absolute difference\
    \ between StatSN and ExpStatSN may indicate\n   a failed connection.  Initiators\
    \ MUST undertake recovery actions if\n   the difference is greater than an implementation\
    \ defined constant\n   that MUST NOT exceed 2**31-1.\n   Initiators and Targets\
    \ MUST support the response-numbering scheme.\n"
- title: 3.2.2.3.  Data Sequencing
  contents:
  - "3.2.2.3.  Data Sequencing\n   Data and R2T PDUs transferred as part of some command\
    \ execution MUST\n   be sequenced.  The DataSN field is used for data sequencing.\
    \  For\n   input (read) data PDUs, DataSN starts with 0 for the first data PDU\n\
    \   of an input command and advances by 1 for each subsequent data PDU.\n   For\
    \ output data PDUs, DataSN starts with 0 for the first data PDU of\n   a sequence\
    \ (the initial unsolicited sequence or any data PDU sequence\n   issued to satisfy\
    \ an R2T) and advances by 1 for each subsequent data\n   PDU.  R2Ts are also sequenced\
    \ per command.  For example, the first\n   R2T has an R2TSN of 0 and advances\
    \ by 1 for each subsequent R2T.  For\n   bidirectional commands, the target uses\
    \ the DataSN/R2TSN to sequence\n   Data-In and R2T PDUs in one continuous sequence\
    \ (undifferentiated).\n   Unlike command and status, data PDUs and R2Ts are not\
    \ acknowledged by\n   a field in regular outgoing PDUs.  Data-In PDUs can be acknowledged\n\
    \   on demand by a special form of the SNACK PDU.  Data and R2T PDUs are\n   implicitly\
    \ acknowledged by status for the command.  The DataSN/R2TSN\n   field enables\
    \ the initiator to detect missing data or R2T PDUs.\n   For any read or bidirectional\
    \ command, a target MUST issue less than\n   2**32 combined R2T and Data-In PDUs.\
    \  Any output data sequence MUST\n   contain less than 2**32 Data-Out PDUs.\n"
- title: 3.2.3.  iSCSI Login
  contents:
  - "3.2.3.  iSCSI Login\n   The purpose of the iSCSI login is to enable a TCP connection\
    \ for\n   iSCSI use, authentication of the parties, negotiation of the\n   session's\
    \ parameters and marking of the connection as belonging to an\n   iSCSI session.\n\
    \   A session is used to identify to a target all the connections with a\n   given\
    \ initiator that belong to the same I_T nexus.  (For more details\n   on how a\
    \ session relates to an I_T nexus, see Section 3.4.2 SCSI\n   Architecture Model).\n\
    \   The targets listen on a well-known TCP port or other TCP port for\n   incoming\
    \ connections.  The initiator begins the login process by\n   connecting to one\
    \ of these TCP ports.\n   As part of the login process, the initiator and target\
    \ SHOULD\n   authenticate each other and MAY set a security association protocol\n\
    \   for the session.  This can occur in many different ways and is\n   subject\
    \ to negotiation.\n   To protect the TCP connection, an IPsec security association\
    \ MAY be\n   established before the Login request.  For information on using IPsec\n\
    \   security for iSCSI see Chapter 8 and [RFC3723].\n   The iSCSI Login Phase\
    \ is carried through Login requests and\n   responses.  Once suitable authentication\
    \ has occurred and operational\n   parameters have been set, the session transitions\
    \ to the Full Feature\n   Phase and the initiator may start to send SCSI commands.\
    \  The\n   security policy for whether, and by what means, a target chooses to\n\
    \   authorize an initiator is beyond the scope of this document.  For a\n   more\
    \ detailed description of the Login Phase, see Chapter 5.\n   The login PDU includes\
    \ the ISID part of the session ID (SSID).  The\n   target portal group that services\
    \ the login is implied by the\n   selection of the connection endpoint.  For a\
    \ new session, the TSIH is\n   zero.  As part of the response, the target generates\
    \ a TSIH.\n   During session establishment, the target identifies the SCSI\n \
    \  initiator port (the \"I\" in the \"I_T nexus\") through the value pair\n  \
    \ (InitiatorName, ISID).  We describe InitiatorName later in this\n   section.\
    \  Any persistent state (e.g., persistent reservations) on the\n   target that\
    \ is associated with a SCSI initiator port is identified\n   based on this value\
    \ pair.  Any state associated with the SCSI target\n   port (the \"T\" in the\
    \ \"I_T nexus\") is identified externally by the\n   TargetName and portal group\
    \ tag (see Section 3.4.1 iSCSI Architecture\n   Model).  ISID is subject to reuse\
    \ restrictions because it is used to\n   identify a persistent state (see Section\
    \ 3.4.3 Consequences of the\n   Model).\n   Before the Full Feature Phase is established,\
    \ only Login Request and\n   Login Response PDUs are allowed.  Login requests\
    \ and responses MUST\n   be used exclusively during Login.  On any connection,\
    \ the login phase\n   MUST immediately follow TCP connection establishment and\
    \ a subsequent\n   Login Phase MUST NOT occur before tearing down a connection.\n\
    \   A target receiving any PDU except a Login request before the Login\n   phase\
    \ is started MUST immediately terminate the connection on which\n   the PDU was\
    \ received.  Once the Login phase has started, if the\n   target receives any\
    \ PDU except a Login request, it MUST send a Login\n   reject (with Status \"\
    invalid during login\") and then disconnect.  If\n   the initiator receives any\
    \ PDU except a Login response, it MUST\n   immediately terminate the connection.\n"
- title: 3.2.4.  iSCSI Full Feature Phase
  contents:
  - "3.2.4.  iSCSI Full Feature Phase\n   Once the initiator is authorized to do so,\
    \ the iSCSI session is in\n   the iSCSI Full Feature Phase.  A session is in Full\
    \ Feature Phase\n   after successfully finishing the Login Phase on the first\
    \ (leading)\n   connection of a session.  A connection is in Full Feature Phase\
    \ if\n   the session is in Full Feature Phase and the connection login has\n \
    \  completed successfully.  An iSCSI connection is not in Full Feature\n   Phase\n\
    \      a) when it does not have an established transport connection,\n       \
    \  OR\n      b) when it has a valid transport connection, but a successful\n \
    \        login was not performed or the connection is currently logged\n     \
    \    out.\n   In a normal Full Feature Phase, the initiator may send SCSI commands\n\
    \   and data to the various LUs on the target by encapsulating them in\n   iSCSI\
    \ PDUs that go over the established iSCSI session.\n"
- title: 3.2.4.1.  Command Connection Allegiance
  contents:
  - "3.2.4.1.  Command Connection Allegiance\n   For any iSCSI request issued over\
    \ a TCP connection, the corresponding\n   response and/or other related PDU(s)\
    \ MUST be sent over the same\n   connection.  We call this \"connection allegiance\"\
    .  If the original\n   connection fails before the command is completed, the connection\n\
    \   allegiance of the command may be explicitly reassigned to a different\n  \
    \ transport connection as described in detail in Section 6.2 Retry and\n   Reassign\
    \ in Recovery.\n   Thus, if an initiator issues a READ command, the target MUST\
    \ send the\n   requested data, if any, followed by the status to the initiator\
    \ over\n   the same TCP connection that was used to deliver the SCSI command.\n\
    \   If an initiator issues a WRITE command, the initiator MUST send the\n   data,\
    \ if any, for that command over the same TCP connection that was\n   used to deliver\
    \ the SCSI command.  The target MUST return Ready To\n   Transfer (R2T), if any,\
    \ and the status over the same TCP connection\n   that was used to deliver the\
    \ SCSI command.  Retransmission requests\n   (SNACK PDUs) and the data and status\
    \ that they generate MUST also use\n   the same connection.\n   However, consecutive\
    \ commands that are part of a SCSI linked\n   command-chain task (see [SAM2])\
    \ MAY use different connections.\n   Connection allegiance is strictly per-command\
    \ and not per-task.\n   During the iSCSI Full Feature Phase, the initiator and\
    \ target MAY\n   interleave unrelated SCSI commands, their SCSI Data, and responses\n\
    \   over the session.\n"
- title: 3.2.4.2.  Data Transfer Overview
  contents:
  - "3.2.4.2.  Data Transfer Overview\n   Outgoing SCSI data (initiator to target\
    \ user data or command\n   parameters) is sent as either solicited data or unsolicited\
    \ data.\n   Solicited data are sent in response to R2T PDUs.  Unsolicited data\n\
    \   can be sent as part of an iSCSI command PDU (\"immediate data\") or in\n \
    \  separate iSCSI data PDUs.\n   Immediate data are assumed to originate at offset\
    \ 0 in the initiator\n   SCSI write-buffer (outgoing data buffer).  All other\
    \ Data PDUs have\n   the buffer offset set explicitly in the PDU header.\n   An\
    \ initiator may send unsolicited data up to FirstBurstLength as\n   immediate\
    \ (up to the negotiated maximum PDU length), in a separate\n   PDU sequence or\
    \ both.  All subsequent data MUST be solicited.  The\n   maximum length of an\
    \ individual data PDU or the immediate-part of the\n   first unsolicited burst\
    \ MAY be negotiated at login.\n   The maximum amount of unsolicited data that\
    \ can be sent with a\n   command is negotiated at login through the FirstBurstLength\
    \ key.  A\n   target MAY separately enable immediate data (through the\n   ImmediateData\
    \ key) without enabling the more general (separate data\n   PDUs) form of unsolicited\
    \ data (through the InitialR2T key).\n   Unsolicited data on write are meant to\
    \ reduce the effect of latency\n   on throughput (no R2T is needed to start sending\
    \ data).  In addition,\n   immediate data is meant to reduce the protocol overhead\
    \ (both\n   bandwidth and execution time).\n   An iSCSI initiator MAY choose not\
    \ to send unsolicited data, only\n   immediate data or FirstBurstLength bytes\
    \ of unsolicited data with a\n   command.  If any non-immediate unsolicited data\
    \ is sent, the total\n   unsolicited data MUST be either FirstBurstLength, or\
    \ all of the data\n   if the total amount is less than the FirstBurstLength.\n\
    \   It is considered an error for an initiator to send unsolicited data\n   PDUs\
    \ to a target that operates in R2T mode (only solicited data are\n   allowed).\
    \  It is also an error for an initiator to send more\n   unsolicited data, whether\
    \ immediate or as separate PDUs, than\n   FirstBurstLength.\n   An initiator MUST\
    \ honor an R2T data request for a valid outstanding\n   command (i.e., carrying\
    \ a valid Initiator Task Tag) and deliver all\n   the requested data provided\
    \ the command is supposed to deliver\n   outgoing data and the R2T specifies data\
    \ within the command bounds.\n   The initiator action is unspecified for receiving\
    \ an R2T request that\n   specifies data, all or part, outside of the bounds of\
    \ the command.\n   A target SHOULD NOT silently discard data and then request\n\
    \   retransmission through R2T.  Initiators SHOULD NOT keep track of the\n   data\
    \ transferred to or from the target (scoreboarding).  SCSI targets\n   perform\
    \ residual count calculation to check how much data was\n   actually transferred\
    \ to or from the device by a command.  This may\n   differ from the amount the\
    \ initiator sent and/or received for reasons\n   such as retransmissions and errors.\
    \  Read or bidirectional commands\n   implicitly solicit the transmission of the\
    \ entire amount of data\n   covered by the command.  SCSI data packets are matched\
    \ to their\n   corresponding SCSI commands by using tags specified in the protocol.\n\
    \   In addition, iSCSI initiators and targets MUST enforce some ordering\n   rules.\
    \  When unsolicited data is used, the order of the unsolicited\n   data on each\
    \ connection MUST match the order in which the commands on\n   that connection\
    \ are sent.  Command and unsolicited data PDUs may be\n   interleaved on a single\
    \ connection as long as the ordering\n   requirements of each are maintained (e.g.,\
    \ command N+1 MAY be sent\n   before the unsolicited Data-Out PDUs for command\
    \ N, but the\n   unsolicited Data-Out PDUs for command N MUST precede the unsolicited\n\
    \   Data-Out PDUs of command N+1).  A target that receives data out of\n   order\
    \ MAY terminate the session.\n"
- title: 3.2.4.3.  Tags and Integrity Checks
  contents:
  - "3.2.4.3.  Tags and Integrity Checks\n   Initiator tags for pending commands are\
    \ unique initiator-wide for a\n   session.  Target tags are not strictly specified\
    \ by the protocol.  It\n   is assumed that target tags are used by the target\
    \ to tag (alone or\n   in combination with the LUN) the solicited data.  Target\
    \ tags are\n   generated by the target and \"echoed\" by the initiator.  These\n\
    \   mechanisms are designed to accomplish efficient data delivery along\n   with\
    \ a large degree of control over the data flow.\n   As the Initiator Task Tag\
    \ is used to identify a task during its\n   execution, the iSCSI initiator and\
    \ target MUST verify that all other\n   fields used in task-related PDUs have\
    \ values that are consistent with\n   the values used at the task instantiation\
    \ based on the Initiator Task\n   Tag (e.g., the LUN used in an R2T PDU MUST be\
    \ the same as the one\n   used in the SCSI command PDU used to instantiate the\
    \ task).  Using\n   inconsistent field values is considered a protocol error.\n"
- title: 3.2.4.4.  Task Management
  contents:
  - "3.2.4.4.  Task Management\n   SCSI task management assumes that individual tasks\
    \ and task groups\n   can be aborted solely based on the task tags (for individual\
    \ tasks)\n   or the timing of the task management command (for task groups), and\n\
    \   that the task management action is executed synchronously - i.e., no\n   message\
    \ involving an aborted task will be seen by the SCSI initiator\n   after receiving\
    \ the task management response.  In iSCSI initiators\n   and targets interact\
    \ asynchronously over several connections.  iSCSI\n   specifies the protocol mechanism\
    \ and implementation requirements\n   needed to present a synchronous view while\
    \ using an asynchronous\n   infrastructure.\n"
- title: 3.2.5.  iSCSI Connection Termination
  contents:
  - "3.2.5.  iSCSI Connection Termination\n   An iSCSI connection may be terminated\
    \ by use of a transport\n   connection shutdown or a transport reset.  Transport\
    \ reset is assumed\n   to be an exceptional event.\n   Graceful TCP connection\
    \ shutdowns are done by sending TCP FINs.  A\n   graceful transport connection\
    \ shutdown SHOULD only be initiated by\n   either party when the connection is\
    \ not in iSCSI Full Feature Phase.\n   A target MAY terminate a Full Feature Phase\
    \ connection on internal\n   exception events, but it SHOULD announce the fact\
    \ through an\n   Asynchronous Message PDU.  Connection termination with outstanding\n\
    \   commands may require recovery actions.\n   If a connection is terminated while\
    \ in Full Feature Phase, connection\n   cleanup (see section 7) is required prior\
    \ to recovery.  By doing\n   connection cleanup before starting recovery, the\
    \ initiator and target\n   will avoid receiving stale PDUs after recovery.\n"
- title: 3.2.6.  iSCSI Names
  contents:
  - "3.2.6.  iSCSI Names\n   Both targets and initiators require names for the purpose\
    \ of\n   identification.  In addition, names enable iSCSI storage resources to\n\
    \   be managed regardless of location (address).  An iSCSI node name is\n   also\
    \ the SCSI device name of an iSCSI device.  The iSCSI name of a\n   SCSI device\
    \ is the principal object used in authentication of targets\n   to initiators\
    \ and initiators to targets.  This name is also used to\n   identify and manage\
    \ iSCSI storage resources.\n   iSCSI names must be unique within the operational\
    \ domain of the end\n   user.  However, because the operational domain of an IP\
    \ network is\n   potentially worldwide, the iSCSI name formats are architected\
    \ to be\n   worldwide unique.  To assist naming authorities in the construction\n\
    \   of worldwide unique names, iSCSI provides two name formats for\n   different\
    \ types of naming authorities.\n   iSCSI names are associated with iSCSI nodes,\
    \ and not iSCSI network\n   adapter cards, to ensure that the replacement of network\
    \ adapter\n   cards does not require reconfiguration of all SCSI and iSCSI resource\n\
    \   allocation information.\n   Some SCSI commands require that protocol-specific\
    \ identifiers be\n   communicated within SCSI CDBs.  See Section 3.4.2 SCSI Architecture\n\
    \   Model for the definition of the SCSI port name/identifier for iSCSI\n   ports.\n\
    \   An initiator may discover the iSCSI Target Names to which it has\n   access,\
    \ along with their addresses, using the SendTargets text\n   request, or other\
    \ techniques discussed in [RFC3721].\n"
- title: 3.2.6.1.  iSCSI Name Properties
  contents:
  - "3.2.6.1.  iSCSI Name Properties\n   Each iSCSI node, whether an initiator or\
    \ target, MUST have an iSCSI\n   name.\n   Initiators and targets MUST support\
    \ the receipt of iSCSI names of up\n   to the maximum length of 223 bytes.\n \
    \  The initiator MUST present both its iSCSI Initiator Name and the\n   iSCSI\
    \ Target Name to which it wishes to connect in the first login\n   request of\
    \ a new session or connection.  The only exception is if a\n   discovery session\
    \ (see Section 2.3 iSCSI Session Types) is to be\n   established.  In this case,\
    \ the iSCSI Initiator Name is still\n   required, but the iSCSI Target Name MAY\
    \ be omitted.\n   iSCSI names have the following properties:\n      a) iSCSI names\
    \ are globally unique.  No two initiators or targets\n         can have the same\
    \ name.\n      b) iSCSI names are permanent.  An iSCSI initiator node or target\n\
    \         node has the same name for its lifetime.\n      c) iSCSI names do not\
    \ imply a location or address.  An iSCSI\n         initiator or target can move,\
    \ or have multiple addresses.  A\n         change of address does not imply a\
    \ change of name.\n      d) iSCSI names do not rely on a central name broker;\
    \ the naming\n         authority is distributed.\n      e) iSCSI names support\
    \ integration with existing unique naming\n         schemes.\n      f) iSCSI names\
    \ rely on existing naming authorities.  iSCSI does\n         not create any new\
    \ naming authority.\n   The encoding of an iSCSI name has the following properties:\n\
    \      a) iSCSI names have the same encoding method regardless of the\n      \
    \   underlying protocols.\n      b) iSCSI names are relatively simple to compare.\
    \  The algorithm\n         for comparing two iSCSI names for equivalence does\
    \ not rely on\n         an external server.\n      c) iSCSI names are composed\
    \ only of displayable characters.  iSCSI\n         names allow the use of international\
    \ character sets but are not\n         case sensitive.  No whitespace characters\
    \ are used in iSCSI\n         names.\n      d) iSCSI names may be transported\
    \ using both binary and\n         ASCII-based protocols.\n   An iSCSI name really\
    \ names a logical software entity, and is not tied\n   to a port or other hardware\
    \ that can be changed.  For instance, an\n   initiator name should name the iSCSI\
    \ initiator node, not a particular\n   NIC or HBA.  When multiple NICs are used,\
    \ they should generally all\n   present the same iSCSI initiator name to the targets,\
    \ because they\n   are simply paths to the same SCSI layer.  In most operating\
    \ systems,\n   the named entity is the operating system image.\n   Similarly,\
    \ a target name should not be tied to hardware interfaces\n   that can be changed.\
    \  A target name should identify the logical\n   target and must be the same for\
    \ the target regardless of the physical\n   portion being addressed.  This assists\
    \ iSCSI initiators in\n   determining that the two targets it has discovered are\
    \ really two\n   paths to the same target.\n   The iSCSI name is designed to fulfill\
    \ the functional requirements for\n   Uniform Resource Names (URN) [RFC1737].\
    \  For example, it is required\n   that the name have a global scope, be independent\
    \ of address or\n   location, and be persistent and globally unique.  Names must\
    \ be\n   extensible and scalable with the use of naming authorities.  The name\n\
    \   encoding should be both human and machine readable.  See [RFC1737]\n   for\
    \ further requirements.\n"
- title: 3.2.6.2.  iSCSI Name Encoding
  contents:
  - "3.2.6.2.  iSCSI Name Encoding\n   An iSCSI name MUST be a UTF-8 encoding of a\
    \ string of Unicode\n   characters with the following properties:\n      -  It\
    \ is in Normalization Form C (see \"Unicode Normalization\n         Forms\" [UNICODE]).\n\
    \      -  It only contains characters allowed by the output of the iSCSI\n   \
    \      stringprep template (described in [RFC3722]).\n      -  The following characters\
    \ are used for formatting iSCSI names:\n            - dash ('-'=U+002d)\n    \
    \        - dot ('.'=U+002e)\n            - colon (':'=U+003a)\n      -  The UTF-8\
    \ encoding of the name is not larger than 223 bytes.\n   The stringprep process\
    \ is described in [RFC3454]; iSCSI's use of the\n   stringprep process is described\
    \ in [RFC3722].  Stringprep is a method\n   designed by the Internationalized\
    \ Domain Name (IDN) working group to\n   translate human-typed strings into a\
    \ format that can be compared as\n   opaque strings.  Strings MUST NOT include\
    \ punctuation, spacing,\n   diacritical marks, or other characters that could\
    \ get in the way of\n   readability.  The stringprep process also converts strings\
    \ into\n   equivalent strings of lower-case characters.\n   The stringprep process\
    \ does not need to be implemented if the names\n   are only generated using numeric\
    \ and lower-case (any character set)\n   alphabetic characters.\n   Once iSCSI\
    \ names encoded in UTF-8 are \"normalized\" they may be safely\n   compared byte-for-byte.\n"
- title: 3.2.6.3.  iSCSI Name Structure
  contents:
  - "3.2.6.3.  iSCSI Name Structure\n   An iSCSI name consists of two parts--a type\
    \ designator followed by a\n   unique name string.\n   The iSCSI name does not\
    \ define any new naming authorities.  Instead,\n   it supports two existing ways\
    \ of designating naming authorities: an\n   iSCSI-Qualified Name, using domain\
    \ names to identify a naming\n   authority, and the EUI format, where the IEEE\
    \ Registration Authority\n   assists in the formation of worldwide unique names\
    \ (EUI-64 format).\n   The type designator strings currently defined are:\n  \
    \   iqn.       - iSCSI Qualified name\n     eui.       - Remainder of the string\
    \ is an IEEE EUI-64\n                  identifier, in ASCII-encoded hexadecimal.\n\
    \   These two naming authority designators were considered sufficient at\n   the\
    \ time of writing this document.  The creation of additional naming\n   type designators\
    \ for iSCSI may be considered by the IETF and detailed\n   in separate RFCs.\n"
- title: 3.2.6.3.1.  Type "iqn." (iSCSI Qualified Name)
  contents:
  - "3.2.6.3.1.  Type \"iqn.\" (iSCSI Qualified Name)\n   This iSCSI name type can\
    \ be used by any organization that owns a\n   domain name.  This naming format\
    \ is useful when an end user or\n   service provider wishes to assign iSCSI names\
    \ for targets and/or\n   initiators.\n   To generate names of this type, the person\
    \ or organization generating\n   the name must own a registered domain name. \
    \ This domain name does\n   not have to be active, and does not have to resolve\
    \ to an address; it\n   just needs to be reserved to prevent others from generating\
    \ iSCSI\n   names using the same domain name.\n   Since a domain name can expire,\
    \ be acquired by another entity, or may\n   be used to generate iSCSI names by\
    \ both owners, the domain name must\n   be additionally qualified by a date during\
    \ which the naming authority\n   owned the domain name.  For this reason, a date\
    \ code is provided as\n   part of the \"iqn.\" format.\n   The iSCSI qualified\
    \ name string consists of:\n      -  The string \"iqn.\", used to distinguish\
    \ these names from \"eui.\"\n         formatted names.\n      -  A date code,\
    \ in yyyy-mm format.  This date MUST be a date\n         during which the naming\
    \ authority owned the domain name used in\n         this format, and SHOULD be\
    \ the first month in which the domain\n         name was owned by this naming\
    \ authority at 00:01 GMT of the\n         first day of the month.  This date code\
    \ uses the Gregorian\n         calendar.  All four digits in the year must be\
    \ present.  Both\n         digits of the month must be present, with January ==\
    \ \"01\" and\n         December == \"12\".  The dash must be included.\n     \
    \ -  A dot \".\"\n      -  The reversed domain name of the naming authority (person\
    \ or\n         organization) creating this iSCSI name.\n      -  An optional,\
    \ colon (:) prefixed, string within the character\n         set and length boundaries\
    \ that the owner of the domain name\n         deems appropriate.  This may contain\
    \ product types, serial\n         numbers, host identifiers, or software keys\
    \ (e.g., it may\n         include colons to separate organization boundaries).\
    \  With the\n         exception of the colon prefix, the owner of the domain name\
    \ can\n         assign everything after the reversed domain name as desired.\n\
    \         It is the responsibility of the entity that is the naming\n        \
    \ authority to ensure that the iSCSI names it assigns are\n         worldwide\
    \ unique.  For example, \"Example Storage Arrays, Inc.\",\n         might own\
    \ the domain name \"example.com\".\n   The following are examples of iSCSI qualified\
    \ names that might be\n   generated by \"EXAMPLE Storage Arrays, Inc.\"\n    \
    \               Naming     String defined by\n      Type  Date    Auth      \"\
    example.com\" naming authority\n     +--++-----+ +---------+ +--------------------------------+\n\
    \     |  ||     | |         | |                                |\n     iqn.2001-04.com.example:storage:diskarrays-sn-a8675309\n\
    \     iqn.2001-04.com.example\n     iqn.2001-04.com.example:storage.tape1.sys1.xyz\n\
    \     iqn.2001-04.com.example:storage.disk2.sys1.xyz\n"
- title: 3.2.6.3.2.  Type "eui." (IEEE EUI-64 format)
  contents:
  - "3.2.6.3.2.  Type \"eui.\" (IEEE EUI-64 format)\n   The IEEE Registration Authority\
    \ provides a service for assigning\n   globally unique identifiers [EUI].  The\
    \ EUI-64 format is used to\n   build a global identifier in other network protocols.\
    \  For example,\n   Fibre Channel defines a method of encoding it into a WorldWideName.\n\
    \   For more information on registering for EUI identifiers, see [OUI].\n   The\
    \ format is \"eui.\" followed by an EUI-64 identifier (16\n   ASCII-encoded hexadecimal\
    \ digits).\n   Example iSCSI name:\n        Type  EUI-64 identifier (ASCII-encoded\
    \ hexadecimal)\n        +--++--------------+\n        |  ||              |\n \
    \       eui.02004567A425678D\n   The IEEE EUI-64 iSCSI name format might be used\
    \ when a manufacturer\n   is already registered with the IEEE Registration Authority\
    \ and uses\n   EUI-64 formatted worldwide unique names for its products.\n   More\
    \ examples of name construction are discussed in [RFC3721].\n"
- title: 3.2.7.  Persistent State
  contents:
  - "3.2.7.  Persistent State\n   iSCSI does not require any persistent state maintenance\
    \ across\n   sessions.  However, in some cases, SCSI requires persistent\n   identification\
    \ of the SCSI initiator port name (See Section 3.4.2\n   SCSI Architecture Model\
    \ and Section 3.4.3 Consequences of the Model).\n   iSCSI sessions do not persist\
    \ through power cycles and boot\n   operations.\n   All iSCSI session and connection\
    \ parameters are re-initialized upon\n   session and connection creation.\n  \
    \ Commands persist beyond connection termination if the session\n   persists and\
    \ command recovery within the session is supported.\n   However, when a connection\
    \ is dropped, command execution, as\n   perceived by iSCSI (i.e., involving iSCSI\
    \ protocol exchanges for the\n   affected task), is suspended until a new allegiance\
    \ is established by\n   the 'task reassign' task management function.  (See Section\
    \ 10.5 Task\n   Management Function Request.)\n"
- title: 3.2.8.  Message Synchronization and Steering
  contents:
  - "3.2.8.  Message Synchronization and Steering\n   iSCSI presents a mapping of\
    \ the SCSI protocol onto TCP.  This\n   encapsulation is accomplished by sending\
    \ iSCSI PDUs of varying\n   lengths.  Unfortunately, TCP does not have a built-in\
    \ mechanism for\n   signaling message boundaries at the TCP layer.  iSCSI overcomes\
    \ this\n   obstacle by placing the message length in the iSCSI message header.\n\
    \   This serves to delineate the end of the current message as well as\n   the\
    \ beginning of the next message.\n   In situations where IP packets are delivered\
    \ in order from the\n   network, iSCSI message framing is not an issue and messages\
    \ are\n   processed one after the other.  In the presence of IP packet\n   reordering\
    \ (i.e., frames being dropped), legacy TCP implementations\n   store the \"out\
    \ of order\" TCP segments in temporary buffers until the\n   missing TCP segments\
    \ arrive, upon which the data must be copied to\n   the application buffers. \
    \ In iSCSI, it is desirable to steer the SCSI\n   data within these out of order\
    \ TCP segments into the pre-allocated\n   SCSI buffers rather than store them\
    \ in temporary buffers.  This\n   decreases the need for dedicated reassembly\
    \ buffers as well as the\n   latency and bandwidth related to extra copies.\n\
    \   Relying solely on the \"message length\" information from the iSCSI\n   message\
    \ header may make it impossible to find iSCSI message\n   boundaries in subsequent\
    \ TCP segments due to the loss of a TCP\n   segment that contains the iSCSI message\
    \ length.  The missing TCP\n   segment(s) must be received before any of the following\
    \ segments can\n   be steered to the correct SCSI buffers (due to the inability\
    \ to\n   determine the iSCSI message boundaries).  Since these segments cannot\n\
    \   be steered to the correct location, they must be saved in temporary\n   buffers\
    \ that must then be copied to the SCSI buffers.\n   Different schemes can be used\
    \ to recover synchronization.  To make\n   these schemes work, iSCSI implementations\
    \ have to make sure that the\n   appropriate protocol layers are provided with\
    \ enough information to\n   implement a synchronization and/or data steering mechanism.\
    \  One of\n   these schemes is detailed in Appendix A.  - Sync and Steering with\n\
    \   Fixed Interval Markers -.\n   The Fixed Interval Markers (FIM) scheme works\
    \ by inserting markers in\n   the payload stream at fixed intervals that contain\
    \ the offset for the\n   start of the next iSCSI PDU.\n   Under normal circumstances\
    \ (no PDU loss or data reception out of\n   order), iSCSI data steering can be\
    \ accomplished by using the\n   identifying tag and the data offset fields in\
    \ the iSCSI header in\n   addition to the TCP sequence number from the TCP header.\
    \  The\n   identifying tag helps associate the PDU with a SCSI buffer address\n\
    \   while the data offset and TCP sequence number are used to determine\n   the\
    \ offset within the buffer.\n   When the part of the TCP data stream containing\
    \ an iSCSI PDU header\n   is delayed or lost, markers may be used to minimize\
    \ the damage as\n   follows:\n     - Markers indicate where the next iSCSI PDU\
    \ starts and enable\n       continued processing when iSCSI headers have to be\
    \ dropped due to\n       data errors discovered at the iSCSI level (e.g., iSCSI\
    \ header CRC\n       errors).\n     - Markers help minimize the amount of data\
    \ that has to be kept by\n       the TCP/iSCSI layer while waiting for a late\
    \ TCP packet arrival\n       or recovery, because later they might help find iSCSI\
    \ PDU headers\n       and use the information contained in those to steer data\
    \ to SCSI\n       buffers.\n"
- title: 3.2.8.1.  Sync/Steering and iSCSI PDU Length
  contents:
  - "3.2.8.1.  Sync/Steering and iSCSI PDU Length\n   When a large iSCSI message is\
    \ sent, the TCP segment(s) that contain\n   the iSCSI header may be lost.  The\
    \ remaining TCP segment(s), up to\n   the next iSCSI message, must be buffered\
    \ (in temporary buffers)\n   because the iSCSI header that indicates to which\
    \ SCSI buffers the\n   data are to be steered was lost.  To minimize the amount\
    \ of\n   buffering, it is recommended that the iSCSI PDU length be restricted\n\
    \   to a small value (perhaps a few TCP segments in length).  During\n   login,\
    \ each end of the iSCSI session specifies the maximum iSCSI PDU\n   length it\
    \ will accept.\n"
- title: 3.3.  iSCSI Session Types
  contents:
  - "3.3.  iSCSI Session Types\n   iSCSI defines two types of sessions:\n       a)\
    \ Normal operational session - an unrestricted session.\n       b) Discovery-session\
    \ - a session only opened for target\n          discovery.  The target MUST ONLY\
    \ accept text requests with the\n          SendTargets key and a logout request\
    \ with the reason \"close\n          the session\".  All other requests MUST be\
    \ rejected.\n   The session type is defined during login with the key=value parameter\n\
    \   in the login command.\n"
- title: 3.4.  SCSI to iSCSI Concepts Mapping Model
  contents:
  - "3.4.  SCSI to iSCSI Concepts Mapping Model\n   The following diagram shows an\
    \ example of how multiple iSCSI Nodes\n   (targets in this case) can coexist within\
    \ the same Network Entity and\n   can share Network Portals (IP addresses and\
    \ TCP ports).  Other more\n   complex configurations are also possible.  For detailed\
    \ descriptions\n   of the components of these diagrams, see Section 3.4.1 iSCSI\n\
    \   Architecture Model.\n                  +-----------------------------------+\n\
    \                  |  Network Entity (iSCSI Client)    |\n                  |\
    \                                   |\n                  |         +-------------+\
    \           |\n                  |         | iSCSI Node  |           |\n     \
    \             |         | (Initiator) |           |\n                  |     \
    \    +-------------+           |\n                  |            |       |   \
    \           |\n                  | +--------------+ +--------------+ |\n     \
    \             | |Network Portal| |Network Portal| |\n                  | |   10.1.30.4\
    \  | |   10.1.40.6  | |\n                  +-+--------------+-+--------------+-+\n\
    \                           |               |\n                           |  IP\
    \ Networks  |\n                           |               |\n                \
    \  +-+--------------+-+--------------+-+\n                  | |Network Portal|\
    \ |Network Portal| |\n                  | |  10.1.30.21  | |   10.1.40.3  | |\n\
    \                  | | TCP Port 3260| | TCP Port 3260| |\n                  |\
    \ +--------------+ +--------------+ |\n                  |        |          \
    \     |          |\n                  |        -----------------          |\n\
    \                  |           |         |             |\n                  |\
    \  +-------------+ +--------------+ |\n                  |  | iSCSI Node  | |\
    \ iSCSI Node   | |\n                  |  |  (Target)   | |  (Target)    | |\n\
    \                  |  +-------------+ +--------------+ |\n                  |\
    \                                   |\n                  |   Network Entity (iSCSI\
    \ Server)   |\n                  +-----------------------------------+\n"
- title: 3.4.1.  iSCSI Architecture Model
  contents:
  - "3.4.1.  iSCSI Architecture Model\n   This section describes the part of the iSCSI\
    \ architecture model that\n   has the most bearing on the relationship between\
    \ iSCSI and the SCSI\n   Architecture Model.\n      a)  Network Entity - represents\
    \ a device or gateway that is\n          accessible from the IP network.  A Network\
    \ Entity must have\n          one or more Network Portals (see item d), each of\
    \ which can be\n          used by some iSCSI Nodes (see item (b)) contained in\
    \ that\n          Network Entity to gain access to the IP network.\n      b) \
    \ iSCSI Node - represents a single iSCSI initiator or iSCSI\n          target.\
    \  There are one or more iSCSI Nodes within a Network\n          Entity.  The\
    \ iSCSI Node is accessible via one or more Network\n          Portals (see item\
    \ d).  An iSCSI Node is identified by its\n          iSCSI Name (see Section 3.2.6\
    \ iSCSI Names and Chapter 12).\n          The separation of the iSCSI Name from\
    \ the addresses used by\n          and for the iSCSI node allows multiple iSCSI\
    \ nodes to use the\n          same addresses, and the same iSCSI node to use multiple\n\
    \          addresses.\n      c)  An alias string may also be associated with an\
    \ iSCSI Node.\n          The alias allows an organization to associate a user\
    \ friendly\n          string with the iSCSI Name.  However, the alias string is\
    \ not\n          a substitute for the iSCSI Name.\n      d)  Network Portal -\
    \ a component of a Network Entity that has a\n          TCP/IP network address\
    \ and that may be used by an iSCSI Node\n          within that Network Entity\
    \ for the connection(s) within one of\n          its iSCSI sessions.  In an initiator,\
    \ it is identified by its\n          IP address.  In a target, it is identified\
    \ by its IP address\n          and its listening TCP port.\n      e)  Portal Groups\
    \ - iSCSI supports multiple connections within the\n          same session; some\
    \ implementations will have the ability to\n          combine connections in a\
    \ session across multiple Network\n          Portals.  A Portal Group defines\
    \ a set of Network Portals\n          within an iSCSI Node that collectively supports\
    \ the capability\n          of coordinating a session with connections that span\
    \ these\n          portals.  Not all Network Portals within a Portal Group need\n\
    \          to participate in every session connected through that Portal\n   \
    \       Group.  One or more Portal Groups may provide access to an\n         \
    \ iSCSI Node.  Each Network Portal, as utilized by a given iSCSI\n          Node,\
    \ belongs to exactly one portal group within that node.\n          Portal Groups\
    \ are identified within an iSCSI Node by a portal\n          group tag, a simple\
    \ unsigned-integer between 0 and 65535 (see\n          Section 12.3 SendTargets).\
    \  All Network Portals with the same\n          portal group tag in the context\
    \ of a given iSCSI Node are in\n          the same Portal Group.\n          Both\
    \ iSCSI Initiators and iSCSI Targets have portal groups,\n          though only\
    \ the iSCSI Target Portal Groups are used directly\n          in the iSCSI protocol\
    \ (e.g., in SendTargets).  For references\n          to the initiator Portal Groups,\
    \ see Section 9.1.1 Conservative\n          Reuse of ISIDs.\n      f)  Portals\
    \ within a Portal Group should support similar session\n          parameters,\
    \ because they may participate in a common session.\n   The following diagram\
    \ shows an example of one such configuration on a\n   target and how a session\
    \ that shares Network Portals within a Portal\n   Group may be established.\n\
    \     ----------------------------IP Network---------------------\n          \
    \  |               |                    |\n       +----|---------------|-----+\
    \         +----|---------+\n       | +---------+  +---------+ |         | +---------+\
    \  |\n       | | Network |  | Network | |         | | Network |  |\n       | |\
    \ Portal  |  | Portal  | |         | | Portal  |  |\n       | +--|------+  +---------+\
    \ |         | +---------+  |\n       |    |               |     |         |  \
    \  |         |\n       |    |    Portal     |     |         |    | Portal  |\n\
    \       |    |    Group 1    |     |         |    | Group 2 |\n       +--------------------------+\
    \         +--------------+\n            |               |                    |\n\
    \   +--------|---------------|--------------------|--------------------+\n   |\
    \        |               |                    |                    |\n   |  +----------------------------+\
    \  +-----------------------------+ |\n   |  | iSCSI Session (Target side)|  |\
    \ iSCSI Session (Target side) | |\n   |  |                            |  |   \
    \                          | |\n   |  |       (TSIH = 56)          |  |      \
    \ (TSIH = 48)           | |\n   |  +----------------------------+  +-----------------------------+\
    \ |\n   |                                                                  |\n\
    \   |                     iSCSI Target Node                            |\n   |\
    \             (within Network Entity, not shown)                   |\n   +------------------------------------------------------------------+\n"
- title: 3.4.2.  SCSI Architecture Model
  contents:
  - "3.4.2.  SCSI Architecture Model\n   This section describes the relationship between\
    \ the SCSI Architecture\n   Model [SAM2] and the constructs of the SCSI device,\
    \ SCSI port and I_T\n   nexus, and the iSCSI constructs described in Section 3.4.1\
    \ iSCSI\n   Architecture Model.\n   This relationship implies implementation requirements\
    \ in order to\n   conform to the SAM2 model and other SCSI operational functions.\n\
    \   These requirements are detailed in Section 3.4.3 Consequences of the\n   Model.\n\
    \   The following list outlines mappings of SCSI architectural elements\n   to\
    \ iSCSI.\n      a)  SCSI Device - the SAM2 term for an entity that contains one\
    \ or\n          more SCSI ports that are connected to a service delivery\n   \
    \       subsystem and supports a SCSI application protocol.  For\n          example,\
    \ a SCSI Initiator Device contains one or more SCSI\n          Initiator Ports\
    \ and zero or more application clients.  A SCSI\n          Target Device contains\
    \ one or more SCSI Target Ports and one\n          or more logical units.  For\
    \ iSCSI, the SCSI Device is the\n          component within an iSCSI Node that\
    \ provides the SCSI\n          functionality.  As such, there can be one SCSI\
    \ Device, at\n          most, within an iSCSI Node.  Access to the SCSI Device\
    \ can\n          only be achieved in an iSCSI normal operational session (see\n\
    \          Section 3.3 iSCSI Session Types).  The SCSI Device Name is\n      \
    \    defined to be the iSCSI Name of the node and MUST be used in\n          the\
    \ iSCSI protocol.\n      b)  SCSI Port - the SAM2 term for an entity in a SCSI\
    \ Device that\n          provides the SCSI functionality to interface with a service\n\
    \          delivery subsystem or transport.  For iSCSI, the definition of\n  \
    \        SCSI Initiator Port and SCSI Target Port are different.\n          SCSI\
    \ Initiator Port: This maps to one endpoint of an iSCSI\n          normal operational\
    \ session (see Section 3.3 iSCSI Session\n          Types).  An iSCSI normal operational\
    \ session is negotiated\n          through the login process between an iSCSI\
    \ initiator node and\n          an iSCSI target node.  At successful completion\
    \ of this\n          process, a SCSI Initiator Port is created within the SCSI\n\
    \          Initiator Device.  The SCSI Initiator Port Name and SCSI\n        \
    \  Initiator Port Identifier are both defined to be the iSCSI\n          Initiator\
    \ Name together with (a) a label that identifies it as\n          an initiator\
    \ port name/identifier and (b) the ISID portion of\n          the session identifier.\n\
    \          SCSI Target Port: This maps to an iSCSI Target Portal Group.\n    \
    \      The SCSI Target Port Name and the SCSI Target Port Identifier\n       \
    \   are both defined to be the iSCSI Target Name together with (a)\n         \
    \ a label that identifies it as a target port name/identifier\n          and (b)\
    \ the portal group tag.\n          The SCSI Port Name MUST be used in iSCSI. \
    \ When used in SCSI\n          parameter data, the SCSI port name MUST be encoded\
    \ as:\n           - The iSCSI Name in UTF-8 format, followed by\n           -\
    \ a comma separator (1 byte), followed by\n           - the ASCII character 'i'\
    \ (for SCSI Initiator Port) or the\n             ASCII character 't' (for SCSI\
    \ Target Port) (1 byte),\n             followed by\n           - a comma separator\
    \ (1 byte), followed by\n           - a text encoding as a hex-constant (see Section\
    \ 5.1 Text\n             Format) of the ISID (for SCSI initiator port) or the\
    \ portal\n             group tag (for SCSI target port) including the initial\
    \ 0X\n             or 0x and the terminating null (15 bytes).\n          The ASCII\
    \ character 'i' or 't' is the label that identifies\n          this port as either\
    \ a SCSI Initiator Port or a SCSI Target\n          Port.\n      c)  I_T nexus\
    \ - a relationship between a SCSI Initiator Port and a\n          SCSI Target\
    \ Port, according to [SAM2].  For iSCSI, this\n          relationship is a session,\
    \ defined as a relationship between\n          an iSCSI Initiator's end of the\
    \ session (SCSI Initiator Port)\n          and the iSCSI Target's Portal Group.\
    \  The I_T nexus can be\n          identified by the conjunction of the SCSI port\
    \ names or by the\n          iSCSI session identifier SSID.  iSCSI defines the\
    \ I_T nexus\n          identifier to be the tuple (iSCSI Initiator Name + 'i'\
    \ + ISID,\n          iSCSI Target Name + 't' + Portal Group Tag).\n          NOTE:\
    \ The I_T nexus identifier is not equal to the session\n          identifier (SSID).\n"
- title: 3.4.3.  Consequences of the Model
  contents:
  - "3.4.3.  Consequences of the Model\n   This section describes implementation and\
    \ behavioral requirements\n   that result from the mapping of SCSI constructs\
    \ to the iSCSI\n   constructs defined above.  Between a given SCSI initiator port\
    \ and a\n   given SCSI target port, only one I_T nexus (session) can exist.  No\n\
    \   more than one nexus relationship (parallel nexus) is allowed by\n   [SAM2].\
    \  Therefore, at any given time, only one session can exist\n   between a given\
    \ iSCSI initiator node and an iSCSI target node, with\n   the same session identifier\
    \ (SSID).\n   These assumptions lead to the following conclusions and requirements:\n\
    \   ISID RULE: Between a given iSCSI Initiator and iSCSI Target Portal\n   Group\
    \ (SCSI target port), there can only be one session with a given\n   value for\
    \ ISID that identifies the SCSI initiator port.  See Section\n   10.12.5 ISID.\n\
    \   The structure of the ISID that contains a naming authority component\n   (see\
    \ Section 10.12.5 ISID and [RFC3721]) provides a mechanism to\n   facilitate compliance\
    \ with the ISID rule.  (See Section 9.1.1\n   Conservative Reuse of ISIDs.)\n\
    \   The iSCSI Initiator Node should manage the assignment of ISIDs prior\n   to\
    \ session initiation.  The \"ISID RULE\" does not preclude the use of\n   the\
    \ same ISID from the same iSCSI Initiator with different Target\n   Portal Groups\
    \ on the same iSCSI target or on other iSCSI targets (see\n   Section 9.1.1 Conservative\
    \ Reuse of ISIDs).  Allowing this would be\n   analogous to a single SCSI Initiator\
    \ Port having relationships\n   (nexus) with multiple SCSI target ports on the\
    \ same SCSI target\n   device or SCSI target ports on other SCSI target devices.\
    \  It is also\n   possible to have multiple sessions with different ISIDs to the\
    \ same\n   Target Portal Group.  Each such session would be considered to be\n\
    \   with a different initiator even when the sessions originate from the\n   same\
    \ initiator device.  The same ISID may be used by a different\n   iSCSI initiator\
    \ because it is the iSCSI Name together with the ISID\n   that identifies the\
    \ SCSI Initiator Port.\n   NOTE: A consequence of the ISID RULE and the specification\
    \ for the\n   I_T nexus identifier is that two nexus with the same identifier\n\
    \   should never exist at the same time.\n   TSIH RULE: The iSCSI Target selects\
    \ a non-zero value for the TSIH at\n   session creation (when an initiator presents\
    \ a 0 value at Login).\n   After being selected, the same TSIH value MUST be used\
    \ whenever the\n   initiator or target refers to the session and a TSIH is required.\n"
- title: 3.4.3.1.  I_T Nexus State
  contents:
  - "3.4.3.1.  I_T Nexus State\n   Certain nexus relationships contain an explicit\
    \ state (e.g.,\n   initiator-specific mode pages) that may need to be preserved\
    \ by the\n   device server [SAM2] in a logical unit through changes or failures\
    \ in\n   the iSCSI layer (e.g., session failures).  In order for that state to\n\
    \   be restored, the iSCSI initiator should reestablish its session\n   (re-login)\
    \ to the same Target Portal Group using the previous ISID.\n   That is, it should\
    \ perform session recovery as described in Chapter\n   6. This is because the\
    \ SCSI initiator port identifier and the SCSI\n   target port identifier (or relative\
    \ target port) form the datum that\n   the SCSI logical unit device server uses\
    \ to identify the I_T nexus.\n"
- title: 3.5.  Request/Response Summary
  contents:
  - "3.5.  Request/Response Summary\n   This section lists and briefly describes all\
    \ the iSCSI PDU types\n   (request and responses).\n   All iSCSI PDUs are built\
    \ as a set of one or more header segments\n   (basic and auxiliary) and zero or\
    \ one data segments.  The header\n   group and the data segment may each be followed\
    \ by a CRC (digest).\n   The basic header segment has a fixed length of 48 bytes.\n"
- title: 3.5.1.  Request/Response Types Carrying SCSI Payload
  contents:
  - '3.5.1.  Request/Response Types Carrying SCSI Payload

    '
- title: 3.5.1.1.  SCSI-Command
  contents:
  - "3.5.1.1.  SCSI-Command\n   This request carries the SCSI CDB and all the other\
    \ SCSI execute\n   command procedure call (see [SAM2]) IN arguments such as task\n\
    \   attributes, Expected Data Transfer Length for one or both transfer\n   directions\
    \ (the latter for bidirectional commands), and Task Tag (as\n   part of the I_T_L_x\
    \ nexus).  The I_T_L nexus is derived by the\n   initiator and target from the\
    \ LUN field in the request and the I_T\n   nexus is implicit in the session identification.\n\
    \   In addition, the SCSI-command PDU carries information required for\n   the\
    \ proper operation of the iSCSI protocol - the command sequence\n   number (CmdSN)\
    \ for the session and the expected status number\n   (ExpStatSN) for the connection.\n\
    \   All or part of the SCSI output (write) data associated with the SCSI\n   command\
    \ may be sent as part of the SCSI-Command PDU as a data\n   segment.\n"
- title: 3.5.1.2.  SCSI-Response
  contents:
  - "3.5.1.2.  SCSI-Response\n   The SCSI-Response carries all the SCSI execute-command\
    \ procedure call\n   (see [SAM2]) OUT arguments and the SCSI execute-command procedure\n\
    \   call return value.\n   The SCSI-Response contains the residual counts from\
    \ the operation, if\n   any, an indication of whether the counts represent an\
    \ overflow or an\n   underflow, and the SCSI status if the status is valid or\
    \ a response\n   code (a non-zero return value for the execute-command procedure\
    \ call)\n   if the status is not valid.\n   For a valid status that indicates\
    \ that the command has been\n   processed, but resulted in an exception (e.g.,\
    \ a SCSI CHECK\n   CONDITION), the PDU data segment contains the associated sense\
    \ data.\n   The use of Autosense ([SAM2]) is REQUIRED by iSCSI.\n   Some data\
    \ segment content may also be associated (in the data\n   segment) with a non-zero\
    \ response code.\n   In addition, the SCSI-Response PDU carries information required\
    \ for\n   the proper operation of the iSCSI protocol:\n     - The number of Data-In\
    \ PDUs that a target has sent (to enable\n       the initiator to check that all\
    \ have arrived).\n     - StatSN - the Status Sequence Number on this connection.\n\
    \     - ExpCmdSN - the next Expected Command Sequence Number at the\n       target.\n\
    \     - MaxCmdSN - the maximum CmdSN acceptable at the target from\n       this\
    \ initiator.\n"
- title: 3.5.1.3  Task Management Function Request
  contents:
  - "3.5.1.3  Task Management Function Request\n   The Task Management function request\
    \ provides an initiator with a way\n   to explicitly control the execution of\
    \ one or more SCSI Tasks or\n   iSCSI functions.  The PDU carries a function identifier\
    \ (which task\n   management function to perform) and enough information to\n\
    \   unequivocally identify the task or task-set on which to perform the\n   action,\
    \ even if the task(s) to act upon has not yet arrived or has\n   been discarded\
    \ due to an error.\n   The referenced tag identifies an individual task if the\
    \ function\n   refers to an individual task.\n   The I_T_L nexus identifies task\
    \ sets.  In iSCSI the I_T_L nexus is\n   identified by the LUN and the session\
    \ identification (the session\n   identifies an I_T nexus).\n   For task sets,\
    \ the CmdSN of the Task Management function request\n   helps identify the tasks\
    \ upon which to act, namely all tasks\n   associated with a LUN and having a CmdSN\
    \ preceding the Task\n   Management function request CmdSN.\n   For a Task Management\
    \ function, the coordination between responses to\n   the tasks affected and the\
    \ Task Management function response is done\n   by the target.\n"
- title: 3.5.1.4.  Task Management Function Response
  contents:
  - "3.5.1.4.  Task Management Function Response\n   The Task Management function\
    \ response carries an indication of\n   function completion for a Task Management\
    \ function request including\n   how it was completed (response and qualifier)\
    \ and additional\n   information for failure responses.\n   After the Task Management\
    \ response indicates Task Management function\n   completion, the initiator will\
    \ not receive any additional responses\n   from the affected tasks.\n"
- title: 3.5.1.5.  SCSI Data-Out and SCSI Data-In
  contents:
  - "3.5.1.5.  SCSI Data-Out and SCSI Data-In\n   SCSI Data-Out and SCSI Data-In are\
    \ the main vehicles by which SCSI\n   data payload is carried between initiator\
    \ and target.  Data payload\n   is associated with a specific SCSI command through\
    \ the Initiator Task\n   Tag.  For target convenience, outgoing solicited data\
    \ also carries a\n   Target Transfer Tag (copied from R2T) and the LUN.  Each\
    \ PDU contains\n   the payload length and the data offset relative to the buffer\
    \ address\n   contained in the SCSI execute command procedure call.\n   In each\
    \ direction, the data transfer is split into \"sequences\".  An\n   end-of-sequence\
    \ is indicated by the F bit.\n   An outgoing sequence is either unsolicited (only\
    \ the first sequence\n   can be unsolicited) or consists of all the Data-Out PDUs\
    \ sent in\n   response to an R2T.\n   Input sequences are built to enable the\
    \ direction switching for\n   bidirectional commands.\n   For input, the target\
    \ may request positive acknowledgement of input\n   data.  This is limited to\
    \ sessions that support error recovery and is\n   implemented through the A bit\
    \ in the SCSI Data-In PDU header.\n   Data-In and Data-Out PDUs also carry the\
    \ DataSN to enable the\n   initiator and target to detect missing PDUs (discarded\
    \ due to an\n   error).\n   In addition, StatSN is carried by the Data-In PDUs.\n\
    \   To enable a SCSI command to be processed while involving a minimum\n   number\
    \ of messages, the last SCSI Data-In PDU passed for a command\n   may also contain\
    \ the status if the status indicates termination with\n   no exceptions (no sense\
    \ or response involved).\n"
- title: 3.5.1.6.  Ready To Transfer (R2T)
  contents:
  - "3.5.1.6.  Ready To Transfer (R2T)\n   R2T is the mechanism by which the SCSI\
    \ target \"requests\" the\n   initiator for output data.  R2T specifies to the\
    \ initiator the offset\n   of the requested data relative to the buffer address\
    \ from the execute\n   command procedure call and the length of the solicited\
    \ data.\n   To help the SCSI target associate the resulting Data-Out with an R2T,\n\
    \   the R2T carries a Target Transfer Tag that will be copied by the\n   initiator\
    \ in the solicited SCSI Data-Out PDUs.  There are no protocol\n   specific requirements\
    \ with regard to the value of these tags, but it\n   is assumed that together\
    \ with the LUN, they will enable the target to\n   associate data with an R2T.\n\
    \   R2T also carries information required for proper operation of the\n   iSCSI\
    \ protocol, such as:\n     - R2TSN (to enable an initiator to detect a missing\
    \ R2T)\n     - StatSN\n     - ExpCmdSN\n     - MaxCmdSN\n"
- title: 3.5.2.  Requests/Responses carrying SCSI and iSCSI Payload
  contents:
  - '3.5.2.  Requests/Responses carrying SCSI and iSCSI Payload

    '
- title: 3.5.2.1.  Asynchronous Message
  contents:
  - "3.5.2.1.  Asynchronous Message\n   Asynchronous Messages are used to carry SCSI\
    \ asynchronous events\n   (AEN) and iSCSI asynchronous messages.\n   When carrying\
    \ an AEN, the event details are reported as sense data in\n   the data segment.\n"
- title: 3.5.3.  Requests/Responses Carrying iSCSI Only Payload
  contents:
  - '3.5.3.  Requests/Responses Carrying iSCSI Only Payload

    '
- title: 3.5.3.1.  Text Request and Text Response
  contents:
  - "3.5.3.1.  Text Request and Text Response\n   Text requests and responses are\
    \ designed as a parameter negotiation\n   vehicle and as a vehicle for future\
    \ extension.\n   In the data segment, Text Requests/Responses carry text information\n\
    \   using a simple \"key=value\" syntax.\n   Text Request/Responses may form extended\
    \ sequences using the same\n   Initiator Task Tag.  The initiator uses the F (Final)\
    \ flag bit in the\n   text request header to indicate its readiness to terminate\
    \ a\n   sequence.  The target uses the F (Final) flag bit in the text\n   response\
    \ header to indicate its consent to sequence termination.\n   Text Request and\
    \ Responses also use the Target Transfer Tag to\n   indicate continuation of an\
    \ operation or a new beginning.  A target\n   that wishes to continue an operation\
    \ will set the Target Transfer Tag\n   in a Text Response to a value different\
    \ from the default 0xffffffff.\n   An initiator willing to continue will copy\
    \ this value into the Target\n   Transfer Tag of the next Text Request.  If the\
    \ initiator wants to\n   restart the current target negotiation (start fresh)\
    \ will set the\n   Target Transfer Tag to 0xffffffff.\n   Although a complete\
    \ exchange is always started by the initiator,\n   specific parameter negotiations\
    \ may be initiated by the initiator or\n   target.\n"
- title: 3.5.3.2.  Login Request and Login Response
  contents:
  - "3.5.3.2.  Login Request and Login Response\n   Login Requests and Responses are\
    \ used exclusively during the Login\n   Phase of each connection to set up the\
    \ session and connection\n   parameters.  (The Login Phase consists of a sequence\
    \ of login\n   requests and responses carrying the same Initiator Task Tag.)\n\
    \   A connection is identified by an arbitrarily selected connection-ID\n   (CID)\
    \ that is unique within a session.\n   Similar to the Text Requests and Responses,\
    \ Login Requests/Responses\n   carry key=value text information with a simple\
    \ syntax in the data\n   segment.\n   The Login Phase proceeds through several\
    \ stages (security\n   negotiation, operational parameter negotiation) that are\
    \ selected\n   with two binary coded fields in the header -- the \"current stage\"\
    \n   (CSG) and the \"next stage\" (NSG) with the appearance of the latter\n  \
    \ being signaled by the \"transit\" flag (T).\n   The first Login Phase of a session\
    \ plays a special role, called the\n   leading login, which determines some header\
    \ fields (e.g., the version\n   number, the maximum number of connections, and\
    \ the session\n   identification).\n   The CmdSN initial value is also set by\
    \ the leading login.\n   StatSN for each connection is initiated by the connection\
    \ login.\n   A login request may indicate an implied logout (cleanup) of the\n\
    \   connection to be logged in (a connection restart) by using the same\n   Connection\
    \ ID (CID) as an existing connection, as well as the same\n   session identifying\
    \ elements of the session to which the old\n   connection was associated.\n"
- title: 3.5.3.3.  Logout Request and Response
  contents:
  - "3.5.3.3.  Logout Request and Response\n   Logout Requests and Responses are used\
    \ for the orderly closing of\n   connections for recovery or maintenance.  The\
    \ logout request may be\n   issued following a target prompt (through an asynchronous\
    \ message) or\n   at an initiators initiative.  When issued on the connection\
    \ to be\n   logged out, no other request may follow it.\n   The Logout Response\
    \ indicates that the connection or session cleanup\n   is completed and no other\
    \ responses will arrive on the connection (if\n   received on the logging out\
    \ connection).  In addition, the Logout\n   Response indicates how long the target\
    \ will continue to hold\n   resources for recovery (e.g., command execution that\
    \ continues on a\n   new connection) in the text key Time2Retain and how long\
    \ the\n   initiator must wait before proceeding with recovery in the text key\n\
    \   Time2Wait.\n"
- title: 3.5.3.4.  SNACK Request
  contents:
  - "3.5.3.4.  SNACK Request\n   With the SNACK Request, the initiator requests retransmission\
    \ of\n   numbered-responses or data from the target.  A single SNACK request\n\
    \   covers a contiguous set of missing items, called a run, of a given\n   type\
    \ of items.  The type is indicated in a type field in the PDU\n   header.  The\
    \ run is composed of an initial item (StatSN, DataSN,\n   R2TSN) and the number\
    \ of missed Status, Data, or R2T PDUs.  For long\n   Data-In sequences, the target\
    \ may request (at predefined minimum\n   intervals) a positive acknowledgement\
    \ for the data sent.  A SNACK\n   request with a type field that indicates ACK\
    \ and the number of\n   Data-In PDUs acknowledged conveys this positive acknowledgement.\n"
- title: 3.5.3.5.  Reject
  contents:
  - "3.5.3.5.  Reject\n   Reject enables the target to report an iSCSI error condition\
    \ (e.g.,\n   protocol, unsupported option) that uses a Reason field in the PDU\n\
    \   header and includes the complete header of the bad PDU in the Reject\n   PDU\
    \ data segment.\n"
- title: 3.5.3.6.  NOP-Out Request and NOP-In Response
  contents:
  - "3.5.3.6.  NOP-Out Request and NOP-In Response\n   This request/response pair\
    \ may be used by an initiator and target as\n   a \"ping\" mechanism to verify\
    \ that a connection/session is still\n   active and all of its components are\
    \ operational.  Such a ping may be\n   triggered by the initiator or target. \
    \ The triggering party indicates\n   that it wants a reply by setting a value\
    \ different from the default\n   0xffffffff in the corresponding Initiator/Target\
    \ Transfer Tag.\n   NOP-In/NOP-Out may also be used \"unidirectional\" to convey\
    \ to the\n   initiator/target command, status or data counter values when there\
    \ is\n   no other \"carrier\" and there is a need to update the initiator/\n \
    \  target.\n"
- title: 4.  SCSI Mode Parameters for iSCSI
  contents:
  - "4.  SCSI Mode Parameters for iSCSI\n   There are no iSCSI specific mode pages.\n"
- title: 5.  Login and Full Feature Phase Negotiation
  contents:
  - "5.  Login and Full Feature Phase Negotiation\n   iSCSI parameters are negotiated\
    \ at session or connection\n   establishment by using Login Requests and Responses\
    \ (see Section\n   3.2.3 iSCSI Login) and during the Full Feature Phase (Section\
    \ 3.2.4\n   iSCSI Full Feature Phase) by using Text Requests and Responses.  In\n\
    \   both cases the mechanism used is an exchange of iSCSI-text-key=value\n   pairs.\
    \  For brevity iSCSI-text-keys are called just keys in the rest\n   of this document.\n\
    \   Keys are either declarative or require negotiation and the key\n   description\
    \ indicates if the key is declarative or requires\n   negotiation.\n   For the\
    \ declarative keys, the declaring party sets a value for the\n   key.  The key\
    \ specification indicates if the key can be declared by\n   the initiator, target\
    \ or both.\n   For the keys that require negotiation one of the parties (the\n\
    \   proposing party) proposes a value or set of values by including the\n   key=value\
    \ in the data part of a Login or Text Request or Response\n   PDUs.  The other\
    \ party (the accepting party) makes a selection based\n   on the value or list\
    \ of values proposed and includes the selected\n   value in a key=value in the\
    \ data part of one of the following Login\n   or Text Response or Request PDUs.\
    \  For most of the keys both the\n   initiator and target can be proposing parties.\n\
    \   The login process proceeds in two stages - the security negotiation\n   stage\
    \ and the operational parameter negotiation stage.  Both stages\n   are optional\
    \ but at least one of them has to be present to enable the\n   setting of some\
    \ mandatory parameters.\n   If present, the security negotiation stage precedes\
    \ the operational\n   parameter negotiation stage.\n   Progression from stage\
    \ to stage is controlled by the T (Transition)\n   bit in the Login Request/Response\
    \ PDU header.  Through the T bit set\n   to 1, the initiator indicates that it\
    \ would like to transition.  The\n   target agrees to the transition (and selects\
    \ the next stage) when\n   ready.  A field in the Login PDU header indicates the\
    \ current stage\n   (CSG) and during transition, another field indicates the next\
    \ stage\n   (NSG) proposed (initiator) and selected (target).\n   The text negotiation\
    \ process is used to negotiate or declare\n   operational parameters.  The negotiation\
    \ process is controlled by the\n   F (final) bit in the PDU header.  During text\
    \ negotiations, the F bit\n   is used by the initiator to indicate that it is\
    \ ready to finish the\n   negotiation and by the Target to acquiesce the end of\
    \ negotiation.\n   Since some key=value pairs may not fit entirely in a single\
    \ PDU, the\n   C (continuation) bit is used (both in Login and Text) to indicate\n\
    \   that \"more follows\".\n   The text negotiation uses an additional mechanism\
    \ by which a target\n   may deliver larger amounts of data to an enquiring initiator.\
    \  The\n   target sets a Target Task Tag to be used as a bookmark that when\n\
    \   returned by the initiator, means \"go on\".  If reset to a \"neutral\n   value\"\
    , it means \"forget about the rest\".\n   This chapter details types of keys and\
    \ values used, the syntax rules\n   for parameter formation, and the negotiation\
    \ schemes to be used with\n   different types of parameters.\n"
- title: 5.1.  Text Format
  contents:
  - "5.1.  Text Format\n   The initiator and target send a set of key=value pairs\
    \ encoded in\n   UTF-8 Unicode.  All the text keys and text values specified in\
    \ this\n   document are to be presented and interpreted in the case in which\n\
    \   they appear in this document.  They are case sensitive.\n   The following\
    \ character symbols are used in this document for text\n   items (the hexadecimal\
    \ values represent Unicode code points):\n   (a-z, A-Z) - letters\n   (0-9) -\
    \ digits\n   \" \"  (0x20) - space\n   \".\"  (0x2e) - dot\n   \"-\"  (0x2d) -\
    \ minus\n   \"+\"  (0x2b) - plus\n   \"@\"  (0x40) - commercial at\n   \"_\" \
    \ (0x5f) - underscore\n   \"=\"  (0x3d) - equal\n   \":\"  (0x3a) - colon\n  \
    \ \"/\"  (0x2f) - solidus or slash\n   \"[\"  (0x5b) - left bracket\n   \"]\"\
    \  (0x5d) - right bracket\n   null (0x00) - null separator\n   \",\"  (0x2c) -\
    \ comma\n   \"~\"  (0x7e) - tilde\n   Key=value pairs may span PDU boundaries.\
    \  An initiator or target that\n   sends partial key=value text within a PDU indicates\
    \ that more text\n   follows by setting the C bit in the Text or Login Request\
    \ or Text or\n   Login Response to 1.  Data segments in a series of PDUs that\
    \ have the\n   C bit set to 1 and end with a PDU that have the C bit set to 0,\
    \ or\n   include a single PDU that has the C bit set to 0, have to be\n   considered\
    \ as forming a single logical-text-data-segment (LTDS).\n   Every key=value pair,\
    \ including the last or only pair in a LTDS, MUST\n   be followed by one null\
    \ (0x00) delimiter.\n   A key-name is whatever precedes the first \"=\" in the\
    \ key=value pair.\n   The term key is used frequently in this document in place\
    \ of\n   key-name.\n   A value is whatever follows the first \"=\" in the key=value\
    \ pair up to\n   the end of the key=value pair, but not including the null delimiter.\n\
    \   The following definitions will be used in the rest of this document:\n   \
    \  standard-label: A string of one or more characters that consist of\n      \
    \ letters, digits, dot, minus, plus, commercial at, or underscore.\n       A standard-label\
    \ MUST begin with a capital letter and must not\n       exceed 63 characters.\n\
    \     key-name: A standard-label.\n     text-value: A string of zero or more characters\
    \ that consist of\n       letters, digits, dot, minus, plus, commercial at, underscore,\n\
    \       slash, left bracket, right bracket, or colon.\n     iSCSI-name-value:\
    \ A string of one or more characters that consist\n       of minus, dot, colon,\
    \ or any character allowed by the output of\n       the iSCSI string-prep template\
    \ as specified in [RFC3722] (see\n       also Section 3.2.6.2 iSCSI Name Encoding).\n\
    \     iSCSI-local-name-value: A UTF-8 string; no null characters are\n       allowed\
    \ in the string.  This encoding is to be used for localized\n       (internationalized)\
    \ aliases.\n     boolean-value: The string \"Yes\" or \"No\".\n     hex-constant:\
    \ A hexadecimal constant encoded as a string that\n       starts with \"0x\" or\
    \ \"0X\" followed by one or more digits or the\n       letters a, b, c, d, e,\
    \ f, A, B, C, D, E, or F.  Hex-constants are\n       used to encode numerical\
    \ values or binary strings.  When used to\n       encode numerical values, the\
    \ excessive use of leading 0 digits is\n       discouraged.  The string following\
    \ 0X (or 0x) represents a base16\n       number that starts with the most significant\
    \ base16 digit,\n       followed by all other digits in decreasing order of significance\n\
    \       and ending with the least-significant base16 digit.  When used to\n  \
    \     encode binary strings, hexadecimal constants have an implicit\n       byte-length\
    \ that includes four bits for every hexadecimal digit\n       of the constant,\
    \ including leading zeroes.  For example, a\n       hex-constant of n hexadecimal\
    \ digits has a byte-length of (the\n       integer part of) (n+1)/2.\n     decimal-constant:\
    \ An unsigned decimal number with the digit 0 or a\n       string of one or more\
    \ digits that start with a non-zero digit.\n       Decimal-constants are used\
    \ to encode numerical values or binary\n       strings.  Decimal constants can\
    \ only be used to encode binary\n       strings if the string length is explicitly\
    \ specified.  There is\n       no implicit length for decimal strings.  Decimal-constant\
    \ MUST\n       NOT be used for parameter values if the values can be equal or\n\
    \       greater than 2**64 (numerical) or for binary strings that can be\n   \
    \    longer than 64 bits.\n     base64-constant: base64 constant encoded as a\
    \ string that starts\n       with \"0b\" or \"0B\" followed by 1 or more digits\
    \ or letters or plus\n       or slash or equal.  The encoding is done according\
    \ to [RFC2045]\n       and each character, except equal, represents a base64 digit\
    \ or a\n       6-bit binary string.  Base64-constants are used to encode\n   \
    \    numerical-values or binary strings.  When used to encode\n       numerical\
    \ values, the excessive use of leading 0 digits (encoded\n       as A) is discouraged.\
    \  The string following 0B (or 0b) represents\n       a base64 number that starts\
    \ with the most significant base64\n       digit, followed by all other digits\
    \ in decreasing order of\n       significance and ending with the least-significant\
    \ base64 digit;\n       the least significant base64 digit may be optionally followed\
    \ by\n       pad digits (encoded as equal) that are not considered as part of\n\
    \       the number.  When used to encode binary strings, base64-constants\n  \
    \     have an implicit\n       byte-length that includes six bits for every character\
    \ of the\n       constant, excluding trailing equals (i.e., a base64-constant\
    \ of n\n       base64 characters excluding the trailing equals has a byte-length\n\
    \       of ((the integer part of) (n*3/4)).  Correctly encoded base64\n      \
    \ strings cannot have n values of 1, 5 ... k*4+1.\n     numerical-value: An unsigned\
    \ integer always less than 2**64 encoded\n       as a decimal-constant or a hex-constant.\
    \  Unsigned integer\n       arithmetic applies to numerical-values.\n     large-numerical-value:\
    \ An unsigned integer that can be larger than\n       or equal to 2**64 encoded\
    \ as a hex constant, or\n       base64-constant.  Unsigned integer arithmetic\
    \ applies to\n       large-numeric-values.\n     numeric-range: Two numerical-values\
    \ separated by a tilde where the\n       value to the right of tilde must not\
    \ be lower than the value to\n       the left.\n     regular-binary-value: A binary\
    \ string not longer than 64 bits\n       encoded as a decimal constant, hex constant,\
    \ or base64-constant.\n       The length of the string is either specified by\
    \ the key\n       definition or is the implicit byte-length of the encoded string.\n\
    \     large-binary-value: A binary string longer than 64 bits encoded as\n   \
    \    a hex-constant or base64-constant.  The length of the string is\n       either\
    \ specified by the key definition or is the implicit\n       byte-length of the\
    \ encoded string.\n     binary-value: A regular-binary-value or a large-binary-value.\n\
    \       Operations on binary values are key specific.\n     simple-value: Text-value,\
    \ iSCSI-name-value, boolean-value,\n       numeric-value, a numeric-range, or\
    \ a binary-value.\n     list-of-values: A sequence of text-values separated by\
    \ a comma.\n   If not otherwise specified, the maximum length of a simple-value\
    \ (not\n   its encoded representation) is 255 bytes, not including the delimiter\n\
    \   (comma or zero byte).\n   Any iSCSI target or initiator MUST support receiving\
    \ at least 8192\n   bytes of key=value data in a negotiation sequence.  When proposing\
    \ or\n   accepting authentication methods that explicitly require support for\n\
    \   very long authentication items, the initiator and target MUST support\n  \
    \ receiving of at least 64 kilobytes of key=value data (see Appendix\n   11.1.2\
    \ - Simple Public-Key Mechanism (SPKM) - that require support\n   for public key\
    \ certificates).\n"
- title: 5.2.  Text Mode Negotiation
  contents:
  - "5.2.  Text Mode Negotiation\n   During login, and thereafter, some session or\
    \ connection parameters\n   are either declared or negotiated through an exchange\
    \ of textual\n   information.\n   The initiator starts the negotiation and/or\
    \ declaration through a\n   Text or Login Request and indicates when it is ready\
    \ for completion\n   (by setting the F bit to 1 and keeping it to 1 in a Text\
    \ Request or\n   the T bit in the Login Request).  As negotiation text may span\
    \ PDU\n   boundaries, a Text or Login Request or Text or Login Response PDU\n\
    \   that has the C bit set to 1 MUST NOT have the F/T bit set to 1.\n   A target\
    \ receiving a Text or Login Request with the C bit set to 1\n   MUST answer with\
    \ a Text or Login Response with no data segment\n   (DataSegmentLength 0).  An\
    \ initiator receiving a Text or Login\n   Response with the C bit set to 1 MUST\
    \ answer with a Text or Login\n   Request with no data segment (DataSegmentLength\
    \ 0).\n   A target or initiator SHOULD NOT use a Text or Login Response or Text\n\
    \   or Login Request with no data segment (DataSegmentLength 0) unless\n   explicitly\
    \ required by a general or a key-specific negotiation rule.\n   The format of\
    \ a declaration is:\n     Declarer-> <key>=<valuex>\n   The general format of\
    \ text negotiation is:\n     Proposer-> <key>=<valuex>\n     Acceptor-> <key>={<valuey>|NotUnderstood|Irrelevant|Reject}\n\
    \   Thus a declaration is a one-way textual exchange while a negotiation\n   is\
    \ a two-way exchange.\n   The proposer or declarer can either be the initiator\
    \ or the target,\n   and the acceptor can either be the target or initiator, respectively.\n\
    \   Targets are not limited to respond to key=value pairs as proposed by\n   the\
    \ initiator.  The target may propose key=value pairs of its own.\n   All negotiations\
    \ are explicit (i.e., the result MUST only be based on\n   newly exchanged or\
    \ declared values).  There are no implicit\n   proposals.  If a proposal is not\
    \ made, then a reply cannot be\n   expected.  Conservative design also requires\
    \ that default values\n   should not be relied upon when use of some other value\
    \ has serious\n   consequences.\n   The value proposed or declared can be a numerical-value,\
    \ a\n   numerical-range defined by lower and upper values with both integers\n\
    \   separated by a tilde, a binary value, a text-value, an\n   iSCSI-name-value,\
    \ an iSCSI-local-name-value, a boolean-value (Yes or\n   No), or a list of comma\
    \ separated text-values.  A range, a\n   large-numerical-value, an iSCSI-name-value\
    \ and an\n   iSCSI-local-name-value MAY ONLY be used if it is explicitly allowed.\n\
    \   An accepted value can be a numerical-value, a large-numerical-value,\n   a\
    \ text-value, or a boolean-value.\n   If a specific key is not relevant for the\
    \ current negotiation, the\n   acceptor may answer with the constant \"Irrelevant\"\
    \ for all types of\n   negotiation.  However the negotiation is not considered\
    \ as failed if\n   the answer is \"Irrelevant\".  The \"Irrelevant\" answer is\
    \ meant for\n   those cases in which several keys are presented by a proposing\
    \ party\n   but the selection made by the acceptor for one of the keys makes\n\
    \   other keys irrelevant.  The following example illustrates the use of\n   \"\
    Irrelevant\":\n   I->T OFMarker=Yes,OFMarkInt=2048~8192\n   T->I OFMarker=No,OFMarkInt=Irrelevant\n\
    \   I->T X#vkey1=(bla,alb,None),X#vkey2=(bla,alb)\n   T->I X#vkey1=None,X#vkey2=Irrelevant\n\
    \   Any key not understood by the acceptor may be ignored by the acceptor\n  \
    \ without affecting the basic function.  However, the answer for a key\n   not\
    \ understood MUST be key=NotUnderstood.\n   The constants \"None\", \"Reject\"\
    , \"Irrelevant\", and \"NotUnderstood\" are\n   reserved and MUST ONLY be used\
    \ as described here.  Violation of this\n   rule is a protocol error (in particular\
    \ the use of \"Reject\",\n   \"Irrelevant\", and \"NotUnderstood\" as proposed\
    \ values).\n   Reject or Irrelevant are legitimate negotiation options where allowed\n\
    \   but their excessive use is discouraged.  A negotiation is considered\n   complete\
    \ when the acceptor has sent the key value pair even if the\n   value is \"Reject\"\
    , \"Irrelevant\", or \"NotUnderstood.  Sending the key\n   again would be a re-negotiation\
    \ and is forbidden for many keys.\n   If the acceptor sends \"Reject\" as an answer\
    \ the negotiated key is\n   left at its current value (or default if no value\
    \ was set).  If the\n   current value is not acceptable to the proposer on the\
    \ connection or\n   to the session it is sent, the proposer MAY choose to terminate\
    \ the\n   connection or session.\n   All keys in this document, except for the\
    \ X extension formats, MUST\n   be supported by iSCSI initiators and targets when\
    \ used as specified\n   here.  If used as specified, these keys MUST NOT be answered\
    \ with\n   NotUnderstood.\n   Implementers may introduce new keys by prefixing\
    \ them with\n   \"X-\", followed by their (reversed) domain name, or with new\
    \ keys\n   registered with IANA prefixing them with X#.  For example, the entity\n\
    \   owning the domain example.com can issue:\n         X-com.example.bar.foo.do_something=3\n\
    \   or a new registered key may be used as in:\n         X#SuperCalyPhraGilistic=Yes\n\
    \   Implementers MAY also introduce new values, but ONLY for new keys or\n   authentication\
    \ methods (see Section 11 iSCSI Security Text Keys and\n   Authentication Methods),\
    \ or digests (see Section 12.1 HeaderDigest\n   and DataDigest).\n   Whenever\
    \ parameter action or acceptance is dependent on other\n   parameters, the dependency\
    \ rules and parameter sequence must be\n   specified with the parameters.\n  \
    \ In the Login Phase (see Section 5.3 Login Phase), every stage is a\n   separate\
    \ negotiation.  In the FullFeaturePhase, a Text Request\n   Response sequence\
    \ is a negotiation.  Negotiations MUST be handled as\n   atomic operations.  For\
    \ example, all negotiated values go into effect\n   after the negotiation concludes\
    \ in agreement or are ignored if the\n   negotiation fails.\n   Some parameters\
    \ may be subject to integrity rules (e.g., parameter-x\n   must not exceed parameter-y\
    \ or parameter-u not 1 implies parameter-v\n   be Yes).  Whenever required, integrity\
    \ rules are specified with the\n   keys.  Checking for compliance with the integrity\
    \ rule must only be\n   performed after all the parameters are available (the\
    \ existent and\n   the newly negotiated).  An iSCSI target MUST perform integrity\n\
    \   checking before the new parameters take effect.  An initiator MAY\n   perform\
    \ integrity checking.\n   An iSCSI initiator or target MAY terminate a negotiation\
    \ that does\n   not end within a reasonable time or number of exchanges.\n"
- title: 5.2.1.  List negotiations
  contents:
  - "5.2.1.  List negotiations\n   In list negotiation, the originator sends a list\
    \ of values (which may\n   include \"None\") in its order of preference.\n   The\
    \ responding party MUST respond with the same key and the first\n   value that\
    \ it supports (and is allowed to use for the specific\n   originator) selected\
    \ from the originator list.\n   The constant \"None\" MUST always be used to indicate\
    \ a missing\n   function.  However, \"None\" is only a valid selection if it is\n\
    \   explicitly proposed.\n   If an acceptor does not understand any particular\
    \ value in a list, it\n   MUST ignore it.  If an acceptor does not support, does\
    \ not\n   understand, or is not allowed to use any of the proposed options with\n\
    \   a specific originator, it may use the constant \"Reject\" or terminate\n \
    \  the negotiation.  The selection of a value not proposed MUST be\n   handled\
    \ as a protocol error.\n"
- title: 5.2.2.  Simple-value Negotiations
  contents:
  - "5.2.2.  Simple-value Negotiations\n   For simple-value negotiations, the accepting\
    \ party MUST answer with\n   the same key.  The value it selects becomes the negotiation\
    \ result.\n   Proposing a value not admissible (e.g., not within the specified\n\
    \   bounds) MAY be answered with the constant \"Reject\" or the acceptor\n   MAY\
    \ select an admissible value.\n   The selection by the acceptor, of a value not\
    \ admissible under the\n   selection rules is considered a protocol error.  The\
    \ selection rules\n   are key-specific.\n   For a numerical range, the value selected\
    \ must be an integer within\n   the proposed range or \"Reject\" (if the range\
    \ is unacceptable).\n   In Boolean negotiations (i.e., those that result in keys\
    \ taking the\n   values Yes or No), the accepting party MUST answer with the same\
    \ key\n   and the result of the negotiation when the received value does not\n\
    \   determine that result by itself.  The last value transmitted becomes\n   the\
    \ negotiation result.  The rules for selecting the value to answer\n   with are\
    \ expressed as Boolean functions of the value received, and\n   the value that\
    \ the accepting party would have selected if given a\n   choice.\n   Specifically,\
    \ the two cases in which answers are OPTIONAL are:\n      -  The Boolean function\
    \ is \"AND\" and the value \"No\" is received.\n         The outcome of the negotiation\
    \ is \"No\".\n      -  The Boolean function is \"OR\" and the value \"Yes\" is\
    \ received.\n         The outcome of the negotiation is \"Yes\".\n   Responses\
    \ are REQUIRED in all other cases, and the value chosen and\n   sent by the acceptor\
    \ becomes the outcome of the negotiation.\n"
- title: 5.3.  Login Phase
  contents:
  - "5.3.  Login Phase\n   The Login Phase establishes an iSCSI connection between\
    \ an initiator\n   and a target; it also creates a new session or associates the\n\
    \   connection to an existing session.  The Login Phase sets the iSCSI\n   protocol\
    \ parameters, security parameters, and authenticates the\n   initiator and target\
    \ to each other.\n   The Login Phase is only implemented via Login Request and\
    \ Responses.\n   The whole Login Phase is considered as a single task and has\
    \ a single\n   Initiator Task Tag (similar to the linked SCSI commands).\n   The\
    \ default MaxRecvDataSegmentLength is used during Login.\n   The Login Phase sequence\
    \ of requests and responses proceeds as\n   follows:\n      - Login initial request\n\
    \      - Login partial response (optional)\n      - More Login Requests and Responses\
    \ (optional)\n      - Login Final-Response (mandatory)\n   The initial Login Request\
    \ of any connection MUST include the\n   InitiatorName key=value pair.  The initial\
    \ Login Request of the first\n   connection of a session MAY also include the\
    \ SessionType key=value\n   pair.  For any connection within a session whose type\
    \ is not\n   \"Discovery\", the first Login Request MUST also include the TargetName\n\
    \   key=value pair.\n   The Login Final-response accepts or rejects the Login\
    \ Request.\n   The Login Phase MAY include a SecurityNegotiation stage and a\n\
    \   LoginOperationalNegotiation stage or both, but MUST include at least\n   one\
    \ of them.  The included stage MAY be empty except for the\n   mandatory names.\n\
    \   The Login Requests and Responses contain a field (CSG) that indicates\n  \
    \ the current negotiation stage (SecurityNegotiation or\n   LoginOperationalNegotiation).\
    \  If both stages are used, the\n   SecurityNegotiation MUST precede the LoginOperationalNegotiation.\n\
    \   Some operational parameters can be negotiated outside the login\n   through\
    \ Text Requests and Responses.\n   Security MUST be completely negotiated within\
    \ the Login Phase.  The\n   use of underlying IPsec security is specified in Chapter\
    \ 8 and in\n   [RFC3723].  iSCSI support for security within the protocol only\n\
    \   consists of authentication in the Login Phase.\n   In some environments, a\
    \ target or an initiator is not interested in\n   authenticating its counterpart.\
    \  It is possible to bypass\n   authentication through the Login Request and Response.\n\
    \   The initiator and target MAY want to negotiate iSCSI authentication\n   parameters.\
    \  Once this negotiation is completed, the channel is\n   considered secure.\n\
    \   Most of the negotiation keys are only allowed in a specific stage.\n   The\
    \ SecurityNegotiation keys appear in Chapter 11 and the\n   LoginOperationalNegotiation\
    \ keys appear in Chapter 12.  Only a\n   limited set of keys (marked as Any-Stage\
    \ in Chapter 12) may be used\n   in any of the two stages.\n   Any given Login\
    \ Request or Response belongs to a specific stage; this\n   determines the negotiation\
    \ keys allowed with the request or response.\n   It is considered to be a protocol\
    \ error to send a key that is not\n   allowed in the current stage.\n   Stage\
    \ transition is performed through a command exchange (request/\n   response) that\
    \ carries the T bit and the same CSG code.  During this\n   exchange, the next\
    \ stage is selected by the target through the \"next\n   stage\" code (NSG). \
    \ The selected NSG MUST NOT exceed the value stated\n   by the initiator.  The\
    \ initiator can request a transition whenever it\n   is ready, but a target can\
    \ only respond with a transition after one\n   is proposed by the initiator.\n\
    \   In a negotiation sequence, the T bit settings in one pair of Login\n   Request-Responses\
    \ have no bearing on the T bit settings of the next\n   pair.  An initiator that\
    \ has a T bit set to 1 in one pair and is\n   answered with a T bit setting of\
    \ 0, may issue the next request with\n   the T bit set to 0.\n   When a transition\
    \ is requested by the initiator and acknowledged by\n   the target, both the initiator\
    \ and target switch to the selected\n   stage.\n   Targets MUST NOT submit parameters\
    \ that require an additional\n   initiator Login Request in a Login Response with\
    \ the T bit set to 1.\n   Stage transitions during login (including entering and\
    \ exit) are only\n   possible as outlined in the following table:\n   +-----------------------------------------------------------+\n\
    \   |From     To ->   | Security    | Operational | FullFeature |\n   | |    \
    \           |             |             |             |\n   | V              \
    \ |             |             |             |\n   +-----------------------------------------------------------+\n\
    \   | (start)         |  yes        |  yes        |  no         |\n   +-----------------------------------------------------------+\n\
    \   | Security        |  no         |  yes        |  yes        |\n   +-----------------------------------------------------------+\n\
    \   | Operational     |  no         |  no         |  yes        |\n   +-----------------------------------------------------------+\n\
    \   The Login Final-Response that accepts a Login Request can only come\n   as\
    \ a response to a Login Request with the T bit set to 1, and both\n   the request\
    \ and response MUST indicate FullFeaturePhase as the next\n   phase via the NSG\
    \ field.\n   Neither the initiator nor the target should attempt to declare or\n\
    \   negotiate a parameter more than once during login except for\n   responses\
    \ to specific keys that explicitly allow repeated key\n   declarations (e.g.,\
    \ TargetAddress).  An attempt to\n   renegotiate/redeclare parameters not specifically\
    \ allowed MUST be\n   detected by the initiator and target.  If such an attempt\
    \ is detected\n   by the target, the target MUST respond with Login reject (initiator\n\
    \   error); if detected by the initiator, the initiator MUST drop the\n   connection.\n"
- title: 5.3.1.  Login Phase Start
  contents:
  - "5.3.1.  Login Phase Start\n   The Login Phase starts with a Login Request from\
    \ the initiator to the\n   target.  The initial Login Request includes:\n    \
    \  - Protocol version supported by the initiator.\n      - iSCSI Initiator Name\
    \ and iSCSI Target Name\n      - ISID, TSIH, and connection Ids\n      - Negotiation\
    \ stage that the initiator is ready to enter.\n   A login may create a new session\
    \ or it may add a connection to an\n   existing session.  Between a given iSCSI\
    \ Initiator Node (selected\n   only by an InitiatorName) and a given iSCSI target\
    \ defined by an\n   iSCSI TargetName and a Target Portal Group Tag, the login\
    \ results are\n   defined by the following table:\n   +------------------------------------------------------------------+\n\
    \   |ISID      | TSIH        | CID    |     Target action              |\n   +------------------------------------------------------------------+\n\
    \   |new       | non-zero    | any    |     fail the login             |\n   |\
    \          |             |        |     (\"session does not exist\") |\n   +------------------------------------------------------------------+\n\
    \   |new       | zero        | any    |     instantiate a new session  |\n   +------------------------------------------------------------------+\n\
    \   |existing  | zero        | any    |     do session reinstatement   |\n   |\
    \          |             |        |     (see section 5.3.5)        |\n   +------------------------------------------------------------------+\n\
    \   |existing  | non-zero    | new    |     add a new connection to    |\n   |\
    \          | existing    |        |     the session                |\n   +------------------------------------------------------------------+\n\
    \   |existing  | non-zero    |existing|     do connection reinstatement|\n   |\
    \          | existing    |        |    (see section 5.3.4)         |\n   +------------------------------------------------------------------+\n\
    \   |existing  | non-zero    | any    |         fail the login         |\n   |\
    \          | new         |        |     (\"session does not exist\") |\n   +------------------------------------------------------------------+\n\
    \   Determination of \"existing\" or \"new\" are made by the target.\n   Optionally,\
    \ the Login Request may include:\n      - Security parameters\n      OR\n    \
    \  - iSCSI operational parameters\n      AND/OR\n      - The next negotiation\
    \ stage that the initiator is ready to\n      enter.\n   The target can answer\
    \ the login in the following ways:\n     - Login Response with Login reject. \
    \ This is an immediate rejection\n       from the target that causes the connection\
    \ to terminate and the\n       session to terminate if this is the first (or only)\
    \ connection of\n       a new session.  The T bit and the CSG and NSG fields are\n\
    \       reserved.\n     - Login Response with Login Accept as a final response\
    \ (T bit set\n       to 1 and the NSG in both request and response are set to\n\
    \       FullFeaturePhase).  The response includes the protocol version\n     \
    \  supported by the target and the session ID, and may include iSCSI\n       operational\
    \ or security parameters (that depend on the current\n       stage).\n     - Login\
    \ Response with Login Accept as a partial response (NSG not\n       set to FullFeaturePhase\
    \ in both request and response) that\n       indicates the start of a negotiation\
    \ sequence.  The response\n       includes the protocol version supported by the\
    \ target and either\n       security or iSCSI parameters (when no security mechanism\
    \ is\n       chosen) supported by the target.\n   If the initiator decides to\
    \ forego the SecurityNegotiation stage, it\n   issues the Login with the CSG set\
    \ to LoginOperationalNegotiation and\n   the target may reply with a Login Response\
    \ that indicates that it is\n   unwilling to accept the connection (see Section\
    \ 10.13 Login Response)\n   without SecurityNegotiation and will terminate the\
    \ connection with a\n   response of Authentication failure (see Section 10.13.5\
    \ Status-Class\n   and Status-Detail).\n   If the initiator is willing to negotiate\
    \ iSCSI security, but is\n   unwilling to make the initial parameter proposal\
    \ and may accept a\n   connection without iSCSI security, it issues the Login\
    \ with the T bit\n   set to 1, the CSG set to SecurityNegotiation, and the NSG\
    \ set to\n   LoginOperationalNegotiation.  If the target is also ready to skip\n\
    \   security, the Login Response only contains the TargetPortalGroupTag\n   key\
    \ (see Section 12.9 TargetPortalGroupTag), the T bit set to 1, the\n   CSG set\
    \ to SecurityNegotiation, and the NSG set to\n   LoginOperationalNegotiation.\n\
    \   An initiator that chooses to operate without iSCSI security, with all\n  \
    \ the operational parameters taking the default values, issues the\n   Login with\
    \ the T bit set to 1, the CSG set to\n   LoginOperationalNegotiation, and the\
    \ NSG set to FullFeaturePhase.  If\n   the target is also ready to forego security\
    \ and can finish its\n   LoginOperationalNegotiation, the Login Response has T\
    \ bit set to 1,\n   the CSG set to LoginOperationalNegotiation, and the NSG set\
    \ to\n   FullFeaturePhase in the next stage.\n   During the Login Phase the iSCSI\
    \ target MUST return the\n   TargetPortalGroupTag key with the first Login Response\
    \ PDU with which\n   it is allowed to do so (i.e., the first Login Response issued\
    \ after\n   the first Login Request with the C bit set to 0) for all session\n\
    \   types when TargetName is given and the response is not a redirection.\n  \
    \ The TargetPortalGroupTag key value indicates the iSCSI portal group\n   servicing\
    \ the Login Request PDU.  If the reconfiguration of iSCSI\n   portal groups is\
    \ a concern in a given environment, the iSCSI\n   initiator should use this key\
    \ to ascertain that it had indeed\n   initiated the Login Phase with the intended\
    \ target portal group.\n"
- title: 5.3.2.  iSCSI Security Negotiation
  contents:
  - "5.3.2.  iSCSI Security Negotiation\n   The security exchange sets the security\
    \ mechanism and authenticates\n   the initiator user and the target to each other.\
    \  The exchange\n   proceeds according to the authentication method chosen in\
    \ the\n   negotiation phase and is conducted using the Login Requests' and\n \
    \  responses' key=value parameters.\n   An initiator directed negotiation proceeds\
    \ as follows:\n     - The initiator sends a Login Request with an ordered list\
    \ of the\n       options it supports (authentication algorithm).  The options\
    \ are\n       listed in the initiator's order of preference.  The initiator MAY\n\
    \       also send private or public extension options.\n     - The target MUST\
    \ reply with the first option in the list it\n       supports and is allowed to\
    \ use for the specific initiator unless\n       it does not support any, in which\
    \ case it MUST answer with\n       \"Reject\" (see Section 5.2 Text Mode Negotiation).\
    \  The parameters\n       are encoded in UTF8 as key=value.  For security parameters,\
    \ see\n       Chapter 11.\n     - When the initiator considers that it is ready\
    \ to conclude the\n       SecurityNegotiation stage, it sets the T bit to 1 and\
    \ the NSG to\n       what it would like the next stage to be.  The target will\
    \ then\n       set the T bit to 1 and set the NSG to the next stage in the Login\n\
    \       Response when it finishes sending its security keys.  The next\n     \
    \  stage selected will be the one the target selected.  If the next\n       stage\
    \ is FullFeaturePhase, the target MUST respond with a Login\n       Response with\
    \ the TSIH value.\n   If the security negotiation fails at the target, then the\
    \ target MUST\n   send the appropriate Login Response PDU.  If the security negotiation\n\
    \   fails at the initiator, the initiator SHOULD close the connection.\n   It\
    \ should be noted that the negotiation might also be directed by the\n   target\
    \ if the initiator does support security, but is not ready to\n   direct the negotiation\
    \ (propose options).\n"
- title: 5.3.3.  Operational Parameter Negotiation During the Login Phase
  contents:
  - "5.3.3.  Operational Parameter Negotiation During the Login Phase\n   Operational\
    \ parameter negotiation during the login MAY be done:\n     - Starting with the\
    \ first Login Request if the initiator does not\n       propose any security/integrity\
    \ option.\n     - Starting immediately after the security negotiation if the\n\
    \       initiator and target perform such a negotiation.\n   Operational parameter\
    \ negotiation MAY involve several Login\n   Request-Response exchanges started\
    \ and terminated by the initiator.\n   The initiator MUST indicate its intent\
    \ to terminate the negotiation\n   by setting the T bit to 1; the target sets\
    \ the T bit to 1 on the last\n   response.\n   If the target responds to a Login\
    \ Request that has the T bit set to 1\n   with a Login Response that has the T\
    \ bit set to 0, the initiator\n   should keep sending the Login Request (even\
    \ empty) with the T bit set\n   to 1, while it still wants to switch stage, until\
    \ it receives the\n   Login Response that has the T bit set to 1 or it receives\
    \ a key that\n   requires it to set the T bit to 0.\n   Some session specific\
    \ parameters can only be specified during the\n   Login Phase of the first connection\
    \ of a session (i.e., begun by a\n   Login Request that contains a zero-valued\
    \ TSIH) - the leading Login\n   Phase (e.g., the maximum number of connections\
    \ that can be used for\n   this session).\n   A session is operational once it\
    \ has at least one connection in\n   FullFeaturePhase.  New or replacement connections\
    \ can only be added\n   to a session after the session is operational.\n   For\
    \ operational parameters, see Chapter 12.\n"
- title: 5.3.4.  Connection Reinstatement
  contents:
  - "5.3.4.  Connection Reinstatement\n   Connection reinstatement is the process\
    \ of an initiator logging in\n   with an ISID-TSIH-CID combination that is possibly\
    \ active from the\n   target's perspective, which causes the implicit logging\
    \ out of the\n   connection corresponding to the CID,  and reinstating a new Full\n\
    \   Feature Phase iSCSI connection in its place (with the same CID).\n   Thus,\
    \ the TSIH in the Login PDU MUST be non-zero and the CID does not\n   change during\
    \ a connection reinstatement.  The Login Request performs\n   the logout function\
    \ of the old connection if an explicit logout was\n   not performed earlier. \
    \ In sessions with a single connection, this\n   may imply the opening of a second\
    \ connection with the sole purpose of\n   cleaning up the first.  Targets MUST\
    \ support opening a second\n   connection even when they do not support multiple\
    \ connections in Full\n   Feature Phase if ErrorRecoveryLevel is 2 and SHOULD\
    \ support opening a\n   second connection if ErrorRecoveryLevel is less than 2.\n\
    \   If the operational ErrorRecoveryLevel is 2, connection reinstatement\n   enables\
    \ future task reassignment.  If the operational\n   ErrorRecoveryLevel is less\
    \ than 2, connection reinstatement is the\n   replacement of the old CID without\
    \ enabling task reassignment.  In\n   this case, all the tasks that were active\
    \ on the old CID must be\n   immediately terminated without further notice to\
    \ the initiator.\n   The initiator connection state MUST be CLEANUP_WAIT (section\
    \ 7.1.3)\n   when the initiator attempts a connection reinstatement.\n   In practical\
    \ terms, in addition to the implicit logout of the old\n   connection, reinstatement\
    \ is equivalent to a new connection login.\n"
- title: 5.3.5.  Session Reinstatement, Closure, and Timeout
  contents:
  - "5.3.5.  Session Reinstatement, Closure, and Timeout\n   Session reinstatement\
    \ is the process of the initiator logging in with\n   an ISID that is possibly\
    \ active from the target's perspective.  Thus\n   implicitly logging out the session\
    \ that corresponds to the ISID and\n   reinstating a new iSCSI session in its\
    \ place (with the same ISID).\n   Therefore, the TSIH in the Login PDU MUST be\
    \ zero to signal session\n   reinstatement.  Session reinstatement causes all\
    \ the tasks that were\n   active on the old session to be immediately terminated\
    \ by the target\n   without further notice to the initiator.\n   The initiator\
    \ session state MUST be FAILED (Section 7.3 Session State\n   Diagrams) when the\
    \ initiator attempts a session reinstatement.\n   Session closure is an event\
    \ defined to be one of the following:\n     - A successful \"session close\" logout.\n\
    \     - A successful \"connection close\" logout for the last Full Feature\n \
    \      Phase connection when no other connection in the session is\n       waiting\
    \ for cleanup (Section 7.2 Connection Cleanup State Diagram\n       for Initiators\
    \ and Targets) and no tasks in the session are\n       waiting for reassignment.\n\
    \   Session timeout is an event defined to occur when the last connection\n  \
    \ state timeout expires and no tasks are waiting for reassignment.\n   This takes\
    \ the session to the FREE state (N6 transition in the\n   session state diagram).\n"
- title: 5.3.5.1.  Loss of Nexus Notification
  contents:
  - "5.3.5.1.  Loss of Nexus Notification\n   The iSCSI layer provides the SCSI layer\
    \ with the \"I_T nexus loss\"\n   notification when any one of the following events\
    \ happens:\n      a)  Successful completion of session reinstatement.\n      b)\
    \  Session closure event.\n      c)  Session timeout event.\n   Certain SCSI object\
    \ clearing actions may result due to the\n   notification in the SCSI end nodes,\
    \ as documented in Appendix F.\n   - Clearing Effects of Various Events on Targets\
    \ -.\n"
- title: 5.3.6.  Session Continuation and Failure
  contents:
  - "5.3.6.  Session Continuation and Failure\n   Session continuation is the process\
    \ by which the state of a\n   preexisting session continues to be used by connection\
    \ reinstatement\n   (Section 5.3.4 Connection Reinstatement), or by adding a connection\n\
    \   with a new CID.  Either of these actions associates the new transport\n  \
    \ connection with the session state.\n   Session failure is an event where the\
    \ last Full Feature Phase\n   connection reaches the CLEANUP_WAIT state (Section\
    \ 7.2 Connection\n   Cleanup State Diagram for Initiators and Targets), or completes\
    \ a\n   successful recovery logout, thus causing all active tasks (that are\n\
    \   formerly allegiant to the connection) to start waiting for task\n   reassignment.\n"
- title: 5.4.  Operational Parameter Negotiation Outside the Login Phase
  contents:
  - "5.4.  Operational Parameter Negotiation Outside the Login Phase\n   Some operational\
    \ parameters MAY be negotiated outside (after) the\n   Login Phase.\n   Parameter\
    \ negotiation in Full Feature Phase is done through Text\n   requests and responses.\
    \  Operational parameter negotiation MAY\n   involve several Text request-response\
    \ exchanges, which the initiator\n   always starts and terminates using the same\
    \ Initiator Task Tag.  The\n   initiator MUST indicate its intent to terminate\
    \ the negotiation by\n   setting the F bit to 1; the target sets the F bit to\
    \ 1 on the last\n   response.\n   If the target responds to a Text request with\
    \ the F bit set to 1 and\n   with a Text response with the F bit set to 0, the\
    \ initiator should\n   keep sending the Text request (even empty) with the F bit\
    \ set to 1,\n   while it still wants to finish the negotiation, until it receives\
    \ the\n   Text response with the F bit set to 1.  Responding to a Text request\n\
    \   with the F bit set to 1 with an empty (no key=value pairs) response\n   with\
    \ the F bit set to 0 is discouraged.\n   Targets MUST NOT submit parameters that\
    \ require an additional\n   initiator Text request in a Text response with the\
    \ F bit set to 1.\n   In a negotiation sequence, the F bit settings in one pair\
    \ of Text\n   request-responses have no bearing on the F bit settings of the next\n\
    \   pair.  An initiator that has the F bit set to 1 in a request and is\n   being\
    \ answered with an F bit setting of 0 may issue the next request\n   with the\
    \ F bit set to 0.\n   Whenever the target responds with the F bit set to 0, it\
    \ MUST set the\n   Target Transfer Tag to a value other than the default 0xffffffff.\n\
    \   An initiator MAY reset an operational parameter negotiation by\n   issuing\
    \ a Text request with the Target Transfer Tag set to the value\n   0xffffffff\
    \ after receiving a response with the Target Transfer Tag\n   set to a value other\
    \ than 0xffffffff.  A target may reset an\n   operational parameter negotiation\
    \ by answering a Text request with a\n   Reject PDU.\n   Neither the initiator\
    \ nor the target should attempt to declare or\n   negotiate a parameter more than\
    \ once during any negotiation sequence\n   without an intervening operational\
    \ parameter negotiation reset,\n   except for responses to specific keys that\
    \ explicitly allow repeated\n   key declarations (e.g., TargetAddress).  If detected\
    \ by the target,\n   this MUST result in a Reject PDU with a reason of \"protocol\
    \ error\".\n   The initiator MUST reset the negotiation as outlined above.\n \
    \  Parameters negotiated by a text exchange negotiation sequence only\n   become\
    \ effective after the negotiation sequence is completed.\n"
- title: 6.  iSCSI Error Handling and Recovery
  contents:
  - '6.  iSCSI Error Handling and Recovery

    '
- title: 6.1.  Overview
  contents:
  - '6.1.  Overview

    '
- title: 6.1.1.  Background
  contents:
  - "6.1.1.  Background\n   The following two considerations prompted the design of\
    \ much of the\n   error recovery functionality in iSCSI:\n      i)  An iSCSI PDU\
    \ may fail the digest check and be dropped, despite\n          being received\
    \ by the TCP layer.  The iSCSI layer must\n          optionally be allowed to\
    \ recover such dropped PDUs.\n      ii) A TCP connection may fail at any time\
    \ during the data\n          transfer.  All the active tasks must optionally be\
    \ allowed to\n          continue on a different TCP connection within the same\n\
    \          session.\n   Implementations have considerable flexibility in deciding\
    \ what degree\n   of error recovery to support, when to use it and by which mechanisms\n\
    \   to achieve the required behavior.  Only the externally visible\n   actions\
    \ of the error recovery mechanisms must be standardized to\n   ensure interoperability.\n\
    \   This chapter describes a general model for recovery in support of\n   interoperability.\
    \  See Appendix E.  - Algorithmic Presentation of\n   Error Recovery Classes -\
    \ for further detail on how the described\n   model may be implemented.  Compliant\
    \ implementations do not have to\n   match the implementation details of this\
    \ model as presented, but the\n   external behavior of such implementations must\
    \ correspond to the\n   externally observable characteristics of the presented\
    \ model.\n"
- title: 6.1.2.  Goals
  contents:
  - "6.1.2.  Goals\n   The major design goals of the iSCSI error recovery scheme are\
    \ as\n   follows:\n      a)  Allow iSCSI implementations to meet different requirements\
    \ by\n          defining a collection of error recovery mechanisms that\n    \
    \      implementations may choose from.\n      b)  Ensure interoperability between\
    \ any two implementations\n          supporting different sets of error recovery\
    \ capabilities.\n      c)  Define the error recovery mechanisms to ensure command\n\
    \          ordering even in the face of errors, for initiators that\n        \
    \  demand ordering.\n      d)  Do not make additions in the fast path, but allow\
    \ moderate\n          complexity in the error recovery path.\n      e)  Prevent\
    \ both the initiator and target from attempting to\n          recover the same\
    \ set of PDUs at the same time.  For example,\n          there must be a clear\
    \ \"error recovery functionality\n          distribution\" between the initiator\
    \ and target.\n"
- title: 6.1.3.  Protocol Features and State Expectations
  contents:
  - "6.1.3.  Protocol Features and State Expectations\n   The initiator mechanisms\
    \ defined in connection with error recovery\n   are:\n      a)  NOP-OUT to probe\
    \ sequence numbers of the target (section\n          10.18)\n      b)  Command\
    \ retry (section 6.2.1)\n      c)  Recovery R2T support (section 6.7)\n      d)\
    \  Requesting retransmission of status/data/R2T using the SNACK\n          facility\
    \ (section 10.16)\n      e)  Acknowledging the receipt of the data (section 10.16)\n\
    \      f)  Reassigning the connection allegiance of a task to a different\n  \
    \        TCP connection (section 6.2.2)\n      g)  Terminating the entire iSCSI\
    \ session to start afresh (section\n          6.1.4.4)\n   The target mechanisms\
    \ defined in connection with error recovery are:\n      a)  NOP-IN to probe sequence\
    \ numbers of the initiator (section\n          10.19)\n      b)  Requesting retransmission\
    \ of data using the recovery R2T\n          feature (section 6.7)\n      c)  SNACK\
    \ support (section 10.16) d)  Requesting that parts of\n          read data be\
    \ acknowledged (section 10.7.2)\n      e)  Allegiance reassignment support (section\
    \ 6.2.2)\n      f)  Terminating the entire iSCSI session to force the initiator\
    \ to\n          start over (section 6.1.4.4)\n   For any outstanding SCSI command,\
    \ it is assumed that iSCSI, in\n   conjunction with SCSI at the initiator, is\
    \ able to keep enough\n   information to be able to rebuild the command PDU, and\
    \ that outgoing\n   data is available (in host memory) for retransmission while\
    \ the\n   command is outstanding.  It is also assumed that at the target,\n  \
    \ incoming data (read data) MAY be kept for recovery or it can be\n   reread from\
    \ a device server.\n   It is further assumed that a target will keep the \"status\
    \ & sense\"\n   for a command it has executed if it supports status retransmission.\n\
    \   A target that agrees to support data retransmission is expected to be\n  \
    \ prepared to retransmit the outgoing data (i.e., Data-In) on request\n   until\
    \ either the status for the completed command is acknowledged, or\n   the data\
    \ in question has been separately acknowledged.\n"
- title: 6.1.4.  Recovery Classes
  contents:
  - "6.1.4.  Recovery Classes\n   iSCSI enables the following classes of recovery\
    \ (in the order of\n   increasing scope of affected iSCSI tasks):\n      - Within\
    \ a command (i.e., without requiring command restart).\n      - Within a connection\
    \ (i.e., without requiring the connection to\n        be rebuilt, but perhaps\
    \ requiring command restart).\n      - Connection recovery (i.e., perhaps requiring\
    \ connections to be\n        rebuilt and commands to be reissued).\n      - Session\
    \ recovery.\n   The recovery scenarios detailed in the rest of this section are\n\
    \   representative rather than exclusive.  In every case, they detail the\n  \
    \ lowest class recovery that MAY be attempted.  The implementer is left\n   to\
    \ decide under which circumstances to escalate to the next recovery\n   class\
    \ and/or what recovery classes to implement.  Both the iSCSI\n   target and initiator\
    \ MAY escalate the error handling to an error\n   recovery class, which impacts\
    \ a larger number of iSCSI tasks in any\n   of the cases identified in the following\
    \ discussion.\n   In all classes, the implementer has the choice of deferring\
    \ errors to\n   the SCSI initiator (with an appropriate response code), in which\
    \ case\n   the task, if any, has to be removed from the target and all the side\n\
    \   effects, such as ACA, must be considered.\n   Use of within-connection and\
    \ within-command recovery classes MUST NOT\n   be attempted before the connection\
    \ is in Full Feature Phase.\n   In the detailed description of the recovery classes,\
    \ the mandating\n   terms (MUST, SHOULD, MAY, etc.) indicate normative actions\
    \ to be\n   executed if the recovery class is supported and used.\n"
- title: 6.1.4.1.  Recovery Within-command
  contents:
  - "6.1.4.1.  Recovery Within-command\n   At the target, the following cases lend\
    \ themselves to\n   within-command recovery:\n    -  Lost data PDU - realized\
    \ through one of the following:\n       a)  Data digest error - dealt with as\
    \ specified in Section 6.7\n           Digest Errors, using the option of a recovery\
    \ R2T.\n       b)  Sequence reception timeout (no data or\n           partial-data-and-no-F-bit)\
    \ - considered an implicit sequence\n           error and dealt with as specified\
    \ in Section 6.8 Sequence\n           Errors, using the option of a recovery R2T.\n\
    \       c)  Header digest error, which manifests as a sequence reception\n   \
    \        timeout or a sequence error - dealt with as specified in\n          \
    \ Section 6.8 Sequence Errors, using the option of a recovery\n           R2T.\n\
    \   At the initiator, the following cases lend themselves to\n   within-command\
    \ recovery:\n       Lost data PDU or lost R2T - realized through one of the\n\
    \       following:\n       a)  Data digest error - dealt with as specified in\
    \ Section 6.7\n           Digest Errors, using the option of a SNACK.\n      \
    \ b)  Sequence reception timeout (no status) or response reception\n         \
    \  timeout - dealt with as specified in Section 6.8 Sequence\n           Errors,\
    \ using the option of a SNACK.\n       c)  Header digest error, which manifests\
    \ as a sequence reception\n           timeout or a sequence error - dealt with\
    \ as specified in\n           Section 6.8 Sequence Errors, using the option of\
    \ a SNACK.\n   To avoid a race with the target, which may already have a recovery\n\
    \   R2T or a termination response on its way, an initiator SHOULD NOT\n   originate\
    \ a SNACK for an R2T based on its internal timeouts (if any).\n   Recovery in\
    \ this case is better left to the target.\n   The timeout values used by the initiator\
    \ and target are outside the\n   scope of this document.  Sequence reception timeout\
    \ is generally a\n   large enough value to allow the data sequence transfer to\
    \ be\n   complete.\n"
- title: 6.1.4.2.  Recovery Within-connection
  contents:
  - "6.1.4.2.  Recovery Within-connection\n   At the initiator, the following cases\
    \ lend themselves to\n   within-connection recovery:\n    -  Requests not acknowledged\
    \ for a long time.  Requests are\n       acknowledged explicitly through ExpCmdSN\
    \ or implicitly by\n       receiving data and/or status.  The initiator MAY retry\n\
    \       non-acknowledged commands as specified in Section 6.2 Retry and\n    \
    \   Reassign in Recovery.\n    -  Lost iSCSI numbered Response.  It is recognized\
    \ by either\n       identifying a data digest error on a Response PDU or a Data-In\n\
    \       PDU carrying the status, or by receiving a Response PDU with a\n     \
    \  higher StatSN than expected.  In the first case, digest error\n       handling\
    \ is done as specified in Section 6.7 Digest Errors using\n       the option of\
    \ a SNACK.  In the second case, sequence error\n       handling is done as specified\
    \ in Section 6.8 Sequence Errors,\n       using the option of a SNACK.\n   At\
    \ the target, the following cases lend themselves to\n   within-connection recovery:\n\
    \    -  Status/Response not acknowledged for a long time.  The target MAY\n  \
    \     issue a NOP-IN (with a valid Target Transfer Tag or otherwise)\n       that\
    \ carries the next status sequence number it is going to use\n       in the StatSN\
    \ field.  This helps the initiator detect any missing\n       StatSN(s) and issue\
    \ a SNACK for the status.\n   The timeout values used by the initiator and the\
    \ target are outside\n   the scope of this document.\n"
- title: 6.1.4.3.  Connection Recovery
  contents:
  - "6.1.4.3.  Connection Recovery\n   At an iSCSI initiator, the following cases\
    \ lend themselves to\n   connection recovery:\n    - TCP connection failure: The\
    \ initiator MUST close the connection.\n      It then MUST either implicitly or\
    \ explicitly logout the failed\n      connection with the reason code \"remove\
    \ the connection for\n      recovery\" and reassign connection allegiance for\
    \ all commands\n      still in progress associated with the failed connection\
    \ on one or\n      more connections (some or all of which MAY be newly established\n\
    \      connections) using the \"Task reassign\" task management function\n   \
    \   (see Section 10.5.1 Function). For an initiator, a command is in\n      progress\
    \ as long as it has not received a response or a Data-In\n      PDU including\
    \ status.\n      Note: The logout function is mandatory. However, a new connection\n\
    \      establishment is only mandatory if the failed connection was the\n    \
    \  last or only connection in the session.\n    - Receiving an Asynchronous Message\
    \ that indicates one or all\n      connections in a session has been dropped.\
    \  The initiator MUST\n      handle it as a TCP connection failure for the connection(s)\n\
    \      referred to in the Message.\n   At an iSCSI target, the following cases\
    \ lend themselves to connection\n   recovery:\n    - TCP connection failure. The\
    \ target MUST close the connection and,\n      if more than one connection is\
    \ available, the target SHOULD send\n      an Asynchronous Message that indicates\
    \ it has dropped the\n      connection. Then, the target will wait for the initiator\
    \ to\n      continue recovery.\n"
- title: 6.1.4.4.  Session Recovery
  contents:
  - "6.1.4.4.  Session Recovery\n   Session recovery should be performed when all\
    \ other recovery attempts\n   have failed.  Very simple initiators and targets\
    \ MAY perform session\n   recovery on all iSCSI errors and rely on recovery on\
    \ the SCSI layer\n   and above.\n   Session recovery implies the closing of all\
    \ TCP connections,\n   internally aborting all executing and queued tasks for\
    \ the given\n   initiator at the target, terminating all outstanding SCSI commands\n\
    \   with an appropriate SCSI service response at the initiator, and\n   restarting\
    \ a session on a new set of connection(s) (TCP connection\n   establishment and\
    \ login on all new connections).\n   For possible clearing effects of session\
    \ recovery on SCSI and iSCSI\n   objects, refer to Appendix F. - Clearing Effects\
    \ of Various Events on\n   Targets -.\n"
- title: 6.1.5.  Error Recovery Hierarchy
  contents:
  - "6.1.5.  Error Recovery Hierarchy\n   The error recovery classes described so\
    \ far are organized into a\n   hierarchy for ease in understanding and to limit\
    \ the implementation\n   complexity. With few and well defined recovery levels\n\
    \   interoperability is easier to achieve.  The attributes of this\n   hierarchy\
    \ are as follows:\n      a)  Each level is a superset of the capabilities of the\
    \ previous\n          level. For example, Level 1 support implies supporting all\n\
    \          capabilities of Level 0 and more.\n      b)  As a corollary, supporting\
    \ a higher error recovery level means\n          increased sophistication and\
    \ possibly an increase in resource\n          requirements.\n      c)  Supporting\
    \ error recovery level \"n\" is advertised and\n          negotiated by each iSCSI\
    \ entity by exchanging the text key\n          \"ErrorRecoveryLevel=n\".  The\
    \ lower of the two exchanged values\n          is the operational ErrorRecoveryLevel\
    \ for the session.\n   The following diagram represents the error recovery hierarchy.\n\
    \                         +\n                        /\n                     \
    \  / 2 \\       <-- Connection recovery\n                      +-----+\n     \
    \                /   1   \\     <-- Digest failure recovery\n                \
    \    +---------+\n                   /     0     \\   <-- Session failure recovery\n\
    \                  +-------------+\n   The following table lists the error recovery\
    \ capabilities expected\n   from the implementations that support each error recovery\
    \ level.\n   +-------------------+--------------------------------------------+\n\
    \   |ErrorRecoveryLevel |  Associated Error recovery capabilities    |\n   +-------------------+--------------------------------------------+\n\
    \   |        0          |  Session recovery class                    |\n   | \
    \                  |  (Section 6.1.4.4 Session Recovery)        |\n   +-------------------+--------------------------------------------+\n\
    \   |        1          |  Digest failure recovery (See Note below.) |\n   | \
    \                  |  plus the capabilities of ER Level 0       |\n   +-------------------+--------------------------------------------+\n\
    \   |        2          |  Connection recovery class                 |\n   | \
    \                  |  (Section 6.1.4.3 Connection Recovery)     |\n   |      \
    \             |  plus the capabilities of ER Level 1       |\n   +-------------------+--------------------------------------------+\n\
    \   Note: Digest failure recovery is comprised of two recovery classes:\n   Within-Connection\
    \ recovery class (Section 6.1.4.2 Recovery Within-\n   connection) and Within-Command\
    \ recovery class (Section 6.1.4.1\n   Recovery Within-command).\n   When a defined\
    \ value of ErrorRecoveryLevel is proposed by an\n   originator in a text negotiation,\
    \ the originator MUST support the\n   functionality defined for the proposed value\
    \ and additionally, the\n   functionality corresponding to any defined value numerically\
    \ less\n   than the proposed.  When a defined value of ErrorRecoveryLevel is\n\
    \   returned by a responder in a text negotiation, the responder MUST\n   support\
    \ the functionality corresponding to the ErrorRecoveryLevel it\n   is accepting.\n\
    \   When either party attempts to use error recovery functionality beyond\n  \
    \ what is negotiated, the recovery attempts MAY fail unless an a priori\n   agreement\
    \ outside the scope of this document exists between the two\n   parties to provide\
    \ such support.\n   Implementations MUST support error recovery level \"0\", while\
    \ the rest\n   are OPTIONAL to implement.  In implementation terms, the above\n\
    \   striation means that the following incremental sophistication with\n   each\
    \ level is required.\n   +-------------------+---------------------------------------------+\n\
    \   |Level transition   |  Incremental requirement                    |\n   +-------------------+---------------------------------------------+\n\
    \   |        0->1       |  PDU retransmissions on the same connection |\n   +-------------------+---------------------------------------------+\n\
    \   |        1->2       |  Retransmission across connections and      |\n   |\
    \                   |  allegiance reassignment                    |\n   +-------------------+---------------------------------------------+\n"
- title: 6.2.  Retry and Reassign in Recovery
  contents:
  - "6.2.  Retry and Reassign in Recovery\n   This section summarizes two important\
    \ and somewhat related iSCSI\n   protocol features used in error recovery.\n"
- title: 6.2.1.  Usage of Retry
  contents:
  - "6.2.1.  Usage of Retry\n   By resending the same iSCSI command PDU (\"retry\"\
    ) in the absence of a\n   command acknowledgement (by way of an ExpCmdSN update)\
    \ or a response,\n   an initiator attempts to \"plug\" (what it thinks are) the\n\
    \   discontinuities in CmdSN ordering on the target end.  Discarded\n   command\
    \ PDUs, due to digest errors, may have created these\n   discontinuities.\n  \
    \ Retry MUST NOT be used for reasons other than plugging command\n   sequence\
    \ gaps, and in particular, cannot be used for requesting PDU\n   retransmissions\
    \ from a target.  Any such PDU retransmission requests\n   for a currently allegiant\
    \ command in progress may be made using the\n   SNACK mechanism described in section\
    \ 10.16, although the usage of\n   SNACK is OPTIONAL.\n   If initiators, as part\
    \ of plugging command sequence gaps as described\n   above, inadvertently issue\
    \ retries for allegiant commands already in\n   progress (i.e., targets did not\
    \ see the discontinuities in CmdSN\n   ordering), the duplicate commands are silently\
    \ ignored by targets as\n   specified in section 3.2.2.1.\n   When an iSCSI command\
    \ is retried, the command PDU MUST carry the\n   original Initiator Task Tag and\
    \ the original operational attributes\n   (e.g., flags, function names, LUN, CDB\
    \ etc.) as well as the original\n   CmdSN.  The command being retried MUST be\
    \ sent on the same connection\n   as the original command unless the original\
    \ connection was already\n   successfully logged out.\n"
- title: 6.2.2.  Allegiance Reassignment
  contents:
  - "6.2.2.  Allegiance Reassignment\n   By issuing a \"task reassign\" task management\
    \ request (Section 10.5.1\n   Function), the initiator signals its intent to continue\
    \ an already\n   active command (but with no current connection allegiance) as\
    \ part of\n   connection recovery.  This means that a new connection allegiance\
    \ is\n   requested for the command, which seeks to associate it to the\n   connection\
    \ on which the task management request is being issued.\n   Before the allegiance\
    \ reassignment is attempted for a task, an\n   implicit or explicit Logout with\
    \ the reason code \"remove the\n   connection for recovery\" ( see section 10.14)\
    \ MUST be successfully\n   completed for the previous connection to which the\
    \ task was\n   allegiant.\n   In reassigning connection allegiance for a command,\
    \ the targets\n   SHOULD continue the command from its current state.  For example,\n\
    \   when reassigning read commands, the target SHOULD take advantage of\n   the\
    \ ExpDataSN field provided by the Task Management function request\n   (which\
    \ must be set to zero if there was no data transfer) and bring\n   the read command\
    \ to completion by sending the remaining data and\n   sending (or resending) the\
    \ status.  ExpDataSN acknowledges all data\n   sent up to, but not including,\
    \ the Data-In PDU and or R2T with DataSN\n   (or R2TSN) equal to ExpDataSN.  However,\
    \ targets may choose to\n   send/receive all unacknowledged data or all of the\
    \ data on a\n   reassignment of connection allegiance if unable to recover or\n\
    \   maintain an accurate state.  Initiators MUST not subsequently request\n  \
    \ data retransmission through Data SNACK for PDUs numbered less than\n   ExpDataSN\
    \ (i.e., prior to the acknowledged sequence number).  For all\n   types of commands,\
    \ a reassignment request implies that the task is\n   still considered in progress\
    \ by the initiator and the target must\n   conclude the task appropriately if\
    \ the target returns the \"Function\n   Complete\" response to the reassignment\
    \ request.  This might possibly\n   involve retransmission of data/R2T/status\
    \ PDUs as necessary, but MUST\n   involve the (re)transmission of the status PDU.\n\
    \   It is OPTIONAL for targets to support the allegiance reassignment.\n   This\
    \ capability is negotiated via the ErrorRecoveryLevel text key\n   during the\
    \ login time.  When a target does not support allegiance\n   reassignment, it\
    \ MUST respond with a Task Management response code of\n   \"Allegiance reassignment\
    \ not supported\".  If allegiance reassignment\n   is supported by the target,\
    \ but the task is still allegiant to a\n   different connection, or a successful\
    \ recovery Logout of the\n   previously allegiant connection was not performed,\
    \ the target MUST\n   respond with a Task Management response code of \"Task still\n\
    \   allegiant\".\n   If allegiance reassignment is supported by the target, the\
    \ Task\n   Management response to the reassignment request MUST be issued before\n\
    \   the reassignment becomes effective.\n   If a SCSI Command that involves data\
    \ input is reassigned, any SNACK\n   Tag it holds for a final response from the\
    \ original connection is\n   deleted and the default value of 0 MUST be used instead.\n"
- title: 6.3.  Usage Of Reject PDU in Recovery
  contents:
  - "6.3.  Usage Of Reject PDU in Recovery\n   Targets MUST NOT implicitly terminate\
    \ an active task by sending a\n   Reject PDU for any PDU exchanged during the\
    \ life of the task.  If the\n   target decides to terminate the task, a Response\
    \ PDU (SCSI, Text,\n   Task, etc.) must be returned by the target to conclude\
    \ the task.  If\n   the task had never been active before the Reject (i.e., the\
    \ Reject is\n   on the command PDU), targets should not send any further responses\n\
    \   because the command itself is being discarded.\n   The above rule means that\
    \ the initiator can eventually expect a\n   response on receiving Rejects, if\
    \ the received Reject is for a PDU\n   other than the command PDU itself.  The\
    \ non-command Rejects only have\n   diagnostic value in logging the errors, and\
    \ they can be used for\n   retransmission decisions by the initiators.\n   The\
    \ CmdSN of the rejected command PDU (if it is a non-immediate\n   command) MUST\
    \ NOT be considered received by the target (i.e., a\n   command sequence gap must\
    \ be assumed for the CmdSN), even though the\n   CmdSN of the rejected command\
    \ PDU may be reliably ascertained.  Upon\n   receiving the Reject, the initiator\
    \ MUST plug the CmdSN gap in order\n   to continue to use the session.  The gap\
    \ may be plugged either by\n   transmitting a command PDU with the same CmdSN,\
    \ or by aborting the\n   task (see section 6.9 on how an abort may plug a CmdSN\
    \ gap).\n   When a data PDU is rejected and its DataSN can be ascertained, a\n\
    \   target MUST advance ExpDataSN for the current data burst if a\n   recovery\
    \ R2T is being generated.  The target MAY advance its\n   ExpDataSN if it does\
    \ not attempt to recover the lost data PDU.\n"
- title: 6.4.  Connection Timeout Management
  contents:
  - "6.4.  Connection Timeout Management\n   iSCSI defines two session-global timeout\
    \ values (in seconds)\n   - Time2Wait and Time2Retain - that are applicable when\
    \ an iSCSI Full\n   Feature Phase connection is taken out of service either intentionally\n\
    \   or by an exception.  Time2Wait is the initial \"respite time\" before\n  \
    \ attempting an explicit/implicit Logout for the CID in question or\n   task reassignment\
    \ for the affected tasks (if any).  Time2Retain is\n   the maximum time after\
    \ the initial respite interval that the task\n   and/or connection state(s) is/are\
    \ guaranteed to be maintained on the\n   target to cater to a possible recovery\
    \ attempt.  Recovery attempts\n   for the connection and/or task(s) SHOULD NOT\
    \ be made before Time2Wait\n   seconds, but MUST be completed within Time2Retain\
    \ seconds after that\n   initial Time2Wait waiting period.\n"
- title: 6.4.1.  Timeouts on Transport Exception Events
  contents:
  - "6.4.1.  Timeouts on Transport Exception Events\n   A transport connection shutdown\
    \ or a transport reset without any\n   preceding iSCSI protocol interactions informing\
    \ the end-points of the\n   fact causes a Full Feature Phase iSCSI connection\
    \ to be abruptly\n   terminated.  The timeout values to be used in this case are\
    \ the\n   negotiated values of defaultTime2Wait (Section 12.15\n   DefaultTime2Wait)\
    \ and DefaultTime2Retain (Section 12.16\n   DefaultTime2Retain) text keys for\
    \ the session.\n"
- title: 6.4.2.  Timeouts on Planned Decommissioning
  contents:
  - "6.4.2.  Timeouts on Planned Decommissioning\n   Any planned decommissioning of\
    \ a Full Feature Phase iSCSI connection\n   is preceded by either a Logout Response\
    \ PDU, or an Async Message PDU.\n   The Time2Wait and Time2Retain field values\
    \ (section 10.15) in a\n   Logout Response PDU, and the Parameter2 and Parameter3\
    \ fields of an\n   Async Message (AsyncEvent types \"drop the connection\" or\
    \ \"drop all\n   the connections\"; section 10.9.1) specify the timeout values\
    \ to be\n   used in each of these cases.\n   These timeout values are only applicable\
    \ for the affected connection,\n   and the tasks active on that connection.  These\
    \ timeout values have\n   no bearing on initiator timers (if any) that are already\
    \ running on\n   connections or tasks associated with that session.\n"
- title: 6.5.  Implicit Termination of Tasks
  contents:
  - "6.5.  Implicit Termination of Tasks\n   A target implicitly terminates the active\
    \ tasks due to iSCSI protocol\n   dynamics in the following cases:\n      a) \
    \ When a connection is implicitly or explicitly logged out with\n          the\
    \ reason code of \"Close the connection\" and there are active\n          tasks\
    \ allegiant to that connection.\n      b)  When a connection fails and the connection\
    \ state eventually\n          times out (state transition M1 in Section 7.2.2\
    \ State\n          Transition Descriptions for Initiators and Targets) and there\n\
    \          are active tasks allegiant to that connection.\n      c)  When a successful\
    \ Logout with the reason code of \"remove the\n          connection for recovery\"\
    \ is performed while there are active\n          tasks allegiant to that connection,\
    \ and those tasks eventually\n          time out after the Time2Wait and Time2Retain\
    \ periods without\n          allegiance reassignment.\n      d)  When a connection\
    \ is implicitly or explicitly logged out with\n          the reason code of \"\
    Close the session\" and there are active\n          tasks in that session.\n \
    \  If the tasks terminated in the above cases a), b, c) and d)are SCSI\n   tasks,\
    \ they must be internally terminated as if with CHECK CONDITION\n   status.  This\
    \ status is only meaningful for appropriately handling\n   the internal SCSI state\
    \ and SCSI side effects with respect to\n   ordering because this status is never\
    \ communicated back as a\n   terminating status to the initiator.  However additional\
    \ actions may\n   have to be taken at SCSI level depending on the SCSI context\
    \ as\n   defined by the SCSI standards (e.g., queued commands and ACA, in\n  \
    \ cases a), b), and c), after the tasks are terminated, the target MUST\n   report\
    \ a Unit Attention condition on the next command processed on\n   any connection\
    \ for each affected I_T_L nexus with the status of CHECK\n   CONDITION, and the\
    \ ASC/ASCQ value of 47h/7Fh - \"SOME COMMANDS CLEARED\n   BY ISCSI PROTOCOL EVENT\"\
    \ , etc. - see [SAM2] and [SPC3]).\n"
- title: 6.6.  Format Errors
  contents:
  - "6.6.  Format Errors\n   The following two explicit violations of PDU layout rules\
    \ are format\n   errors:\n      a)  Illegal contents of any PDU header field except\
    \ the Opcode\n          (legal values are specified in Section 10 iSCSI PDU Formats).\n\
    \      b)  Inconsistent field contents (consistent field contents are\n      \
    \    specified in Section 10 iSCSI PDU Formats).\n   Format errors indicate a\
    \ major implementation flaw in one of the\n   parties.\n   When a target or an\
    \ initiator receives an iSCSI PDU with a format\n   error, it MUST immediately\
    \ terminate all transport connections in the\n   session either with a connection\
    \ close or with a connection reset and\n   escalate the format error to session\
    \ recovery (see Section 6.1.4.4\n   Session Recovery).\n"
- title: 6.7.  Digest Errors
  contents:
  - "6.7.  Digest Errors\n   The discussion of the legal choices in handling digest\
    \ errors below\n   excludes session recovery as an explicit option, but either\
    \ party\n   detecting a digest error may choose to escalate the error to session\n\
    \   recovery.\n   When a target or an initiator receives any iSCSI PDU, with a\
    \ header\n   digest error, it MUST either discard the header and all data up to\n\
    \   the beginning of a later PDU or close the connection.  Because the\n   digest\
    \ error indicates that the length field of the header may have\n   been corrupted,\
    \ the location of the beginning of a later PDU needs to\n   be reliably ascertained\
    \ by other means such as the operation of a\n   sync and steering layer.\n   When\
    \ a target receives any iSCSI PDU with a payload digest error, it\n   MUST answer\
    \ with a Reject PDU with a reason code of\n   Data-Digest-Error and discard the\
    \ PDU.\n      -  If the discarded PDU is a solicited or unsolicited iSCSI data\n\
    \         PDU (for immediate data in a command PDU, non-data PDU rule\n      \
    \   below applies), the target MUST do one of the following:\n         a) Request\
    \ retransmission with a recovery R2T.\n         b) Terminate the task with a response\
    \ PDU with a CHECK\n            CONDITION Status and an iSCSI Condition of \"\
    protocol service\n            CRC error\" (Section 10.4.7.2 Sense Data).  If the\
    \ target\n            chooses to implement this option, it MUST wait to receive\n\
    \            all the data (signaled by a Data PDU with the final bit set\n   \
    \         for all outstanding R2Ts) before sending the response PDU.\n       \
    \     A task management command (such as an abort task) from the\n           \
    \ initiator during this wait may also conclude the task.\n      -  No further\
    \ action is necessary for targets if the discarded PDU\n         is a non-data\
    \ PDU.  In case of immediate data being present on\n         a discarded command,\
    \ the immediate data is implicitly recovered\n         when the task is retried\
    \ (see section 6.2.1), followed by the\n         entire data transfer for the\
    \ task.\n   When an initiator receives any iSCSI PDU with a payload digest error,\n\
    \   it MUST discard the PDU.\n   -  If the discarded PDU is an iSCSI data PDU,\
    \ the initiator MUST do\n      one of the following:\n      a) Request the desired\
    \ data PDU through SNACK.  In response to the\n         SNACK, the target MUST\
    \ either resend the data PDU or reject the\n         SNACK with a Reject PDU with\
    \ a reason code of \"SNACK reject\" in\n         which case:\n         i)  If\
    \ the status has not already been sent for the command,\n             the target\
    \ MUST terminate the command with a CHECK\n             CONDITION Status and an\
    \ iSCSI Condition of \"SNACK rejected\"\n             (Section 10.4.7.2 Sense\
    \ Data).\n         ii) If the status was already sent, no further action is\n\
    \             necessary for the target.  The initiator in this case MUST\n   \
    \          wait for the status to be received and then discard it, so\n      \
    \       as to internally signal the completion with CHECK CONDITION\n        \
    \     Status and an iSCSI Condition of \"protocol service CRC\n             error\"\
    \ (Section 10.4.7.2 Sense Data).\n      b) Abort the task and terminate the command\
    \ with an error.\n   -  If the discarded PDU is a response PDU, the initiator\
    \ MUST do one\n      of the following:\n      a) Request PDU retransmission with\
    \ a status SNACK.\n      b) Logout the connection for recovery and continue the\
    \ tasks on a\n         different connection instance as described in Section 6.2\
    \ Retry\n         and Reassign in Recovery.\n      c) Logout to close the connection\
    \ (abort all the commands\n         associated with the connection).\n   -  No\
    \ further action is necessary for initiators if the discarded PDU\n      is an\
    \ unsolicited PDU (e.g., Async, Reject).  Task timeouts as in\n      the initiator\
    \ waiting for a command completion, or process\n      timeouts, as in the target\
    \ waiting for a Logout, will ensure that\n      the correct operational behavior\
    \ will result in these cases\n      despite the discarded PDU.\n"
- title: 6.8.  Sequence Errors
  contents:
  - "6.8.  Sequence Errors\n   When an initiator receives an iSCSI R2T/data PDU with\
    \ an out of order\n   R2TSN/DataSN or a SCSI response PDU with an ExpDataSN that\
    \ implies\n   missing data PDU(s), it means that the initiator must have detected\
    \ a\n   header or payload digest error on one or more earlier R2T/data PDUs.\n\
    \   The initiator MUST address these implied digest errors as described\n   in\
    \ Section 6.7 Digest Errors.  When a target receives a data PDU with\n   an out\
    \ of order DataSN, it means that the target must have hit a\n   header or payload\
    \ digest error on at least one of the earlier data\n   PDUs.  The target MUST\
    \ address these implied digest errors as\n   described in Section 6.7 Digest Errors.\n\
    \   When an initiator receives an iSCSI status PDU with an out of order\n   StatSN\
    \ that implies missing responses, it MUST address the one or\n   more missing\
    \ status PDUs as described in Section 6.7 Digest Errors.\n   As a side effect\
    \ of receiving the missing responses, the initiator\n   may discover missing data\
    \ PDUs.  If the initiator wants to recover\n   the missing data for a command,\
    \ it MUST NOT acknowledge the received\n   responses that start from the StatSN\
    \ of the relevant command, until\n   it has completed receiving all the data PDUs\
    \ of the command.\n   When an initiator receives duplicate R2TSNs (due to proactive\n\
    \   retransmission of R2Ts by the target) or duplicate DataSNs (due to\n   proactive\
    \ SNACKs by the initiator), it MUST discard the duplicates.\n"
- title: 6.9.  SCSI Timeouts
  contents:
  - "6.9.  SCSI Timeouts\n   An iSCSI initiator MAY attempt to plug a command sequence\
    \ gap on the\n   target end (in the absence of an acknowledgement of the command\
    \ by\n   way of ExpCmdSN) before the ULP timeout by retrying the\n   unacknowledged\
    \ command, as described in Section 6.2 Retry and\n   Reassign in Recovery.\n \
    \  On a ULP timeout for a command (that carried a CmdSN of n), if the\n   iSCSI\
    \ initiator intends to continue the session, it MUST abort the\n   command by\
    \ either using an appropriate Task Management function\n   request for the specific\
    \ command, or a \"close the connection\" Logout.\n   When using an ABORT TASK,\
    \ if the ExpCmdSN is still less than (n+1),\n   the target may see the abort request\
    \ while missing the original\n   command itself due to one of the following reasons:\n\
    \      -  Original command was dropped due to digest error.\n      -  Connection\
    \ on which the original command was sent was\n         successfully logged out.\
    \  Upon logout, the unacknowledged\n         commands issued on the connection\
    \ being logged out are\n         discarded.\n   If the abort request is received\
    \ and the original command is missing,\n   targets MUST consider the original\
    \ command with that RefCmdSN to be\n   received and issue a Task Management response\
    \ with the response code:\n   \"Function Complete\".  This response concludes\
    \ the task on both ends.\n   If the abort request is received and the target can\
    \ determine (based\n   on the Referenced Task Tag) that the command was received\
    \ and\n   executed and also that the response was sent prior to the abort, then\n\
    \   the target MUST respond with the response code of \"Task Does Not\n   Exist\"\
    .\n"
- title: 6.10.  Negotiation Failures
  contents:
  - "6.10.  Negotiation Failures\n   Text request and response sequences, when used\
    \ to set/negotiate\n   operational parameters, constitute the negotiation/parameter\
    \ setting.\n   A negotiation failure is considered to be one or more of the\n\
    \   following:\n      -  None of the choices, or the stated value, is acceptable\
    \ to one\n         of the sides in the negotiation.\n      -  The text request\
    \ timed out and possibly terminated.\n      -  The text request was answered with\
    \ a Reject PDU.\n   The following two rules should be used to address negotiation\n\
    \   failures:\n      -  During Login, any failure in negotiation MUST be considered\
    \ a\n         login process failure and the Login Phase must be terminated,\n\
    \         and with it, the connection.  If the target detects the\n         failure,\
    \ it must terminate the login with the appropriate Login\n         Response code.\n\
    \      -  A failure in negotiation, while in the Full Feature Phase, will\n  \
    \       terminate the entire negotiation sequence that may consist of a\n    \
    \     series of text requests that use the same Initiator Task Tag.\n        \
    \ The operational parameters of the session or the connection\n         MUST continue\
    \ to be the values agreed upon during an earlier\n         successful negotiation\
    \ (i.e., any partial results of this\n         unsuccessful negotiation MUST NOT\
    \ take effect and MUST be\n         discarded).\n"
- title: 6.11.  Protocol Errors
  contents:
  - "6.11.  Protocol Errors\n   Mapping framed messages over a \"stream\" connection,\
    \ such as TCP,\n   makes the proposed mechanisms vulnerable to simple software\
    \ framing\n   errors.  On the other hand, the introduction of framing mechanisms\
    \ to\n   limit the effects of these errors may be onerous on performance for\n\
    \   simple implementations.  Command Sequence Numbers and the above\n   mechanisms\
    \ for connection drop and reestablishment help handle this\n   type of mapping\
    \ errors.\n   All violations of iSCSI PDU exchange sequences specified in this\n\
    \   document are also protocol errors.  This category of errors can only\n   be\
    \ addressed by fixing the implementations; iSCSI defines Reject and\n   response\
    \ codes to enable this.\n"
- title: 6.12.  Connection Failures
  contents:
  - "6.12.  Connection Failures\n   iSCSI can keep a session in operation if it is\
    \ able to\n   keep/establish at least one TCP connection between the initiator\
    \ and\n   the target in a timely fashion.  Targets and/or initiators may\n   recognize\
    \ a failing connection by either transport level means (TCP),\n   a gap in the\
    \ command sequence number, a response stream that is not\n   filled for a long\
    \ time, or by a failing iSCSI NOP (acting as a ping).\n   The latter MAY be used\
    \ periodically to increase the speed and\n   likelihood of detecting connection\
    \ failures.  Initiators and targets\n   MAY also use the keep-alive option on\
    \ the TCP connection to enable\n   early link failure detection on otherwise idle\
    \ links.\n   On connection failure, the initiator and target MUST do one of the\n\
    \   following:\n      -  Attempt connection recovery within the session (Section\
    \ 6.1.4.3\n         Connection Recovery).\n      -  Logout the connection with\
    \ the reason code \"closes the\n         connection\" (Section 10.14.5 Implicit\
    \ termination of tasks),\n         re-issue missing commands, and implicitly terminate\
    \ all active\n         commands.  This option requires support for the\n     \
    \    within-connection recovery class (Section 6.1.4.2 Recovery\n         Within-connection).\n\
    \      -  Perform session recovery (Section 6.1.4.4 Session Recovery).\n   Either\
    \ side may choose to escalate to session recovery (via the\n   initiator dropping\
    \ all the connections, or via an Async Message that\n   announces the similar\
    \ intent from a target), and the other side MUST\n   give it precedence.  On a\
    \ connection failure, a target MUST terminate\n   and/or discard all of the active\
    \ immediate commands regardless of\n   which of the above options is used (i.e.,\
    \ immediate commands are not\n   recoverable across connection failures).\n"
- title: 6.13.  Session Errors
  contents:
  - "6.13.  Session Errors\n   If all of the connections of a session fail and cannot\
    \ be\n   reestablished in a short time, or if initiators detect protocol\n   errors\
    \ repeatedly, an initiator may choose to terminate a session and\n   establish\
    \ a new session.\n   In this case, the initiator takes the following actions:\n\
    \      -  Resets or closes all the transport connections.\n      -  Terminates\
    \ all outstanding requests with an appropriate\n         response before initiating\
    \ a new session.  If the same I_T\n         nexus is intended to be reestablished,\
    \ the initiator MUST\n         employ session reinstatement (see section 5.3.5).\n\
    \   When the session timeout (the connection state timeout for the last\n   failed\
    \ connection) happens on the target, it takes the following\n   actions:\n   \
    \   -  Resets or closes the TCP connections (closes the session).\n      -  Terminates\
    \ all active tasks that were allegiant to the\n         connection(s) that constituted\
    \ the session.\n   A target MUST also be prepared to handle a session reinstatement\n\
    \   request from the initiator, that may be addressing session errors.\n"
- title: 7.  State Transitions
  contents:
  - "7.  State Transitions\n   iSCSI connections and iSCSI sessions go through several\
    \ well-defined\n   states from the time they are created to the time they are\
    \ cleared.\n   The connection state transitions are described in two separate\
    \ but\n   dependent state diagrams for ease in understanding.  The first\n   diagram,\
    \ \"standard connection state diagram\", describes the\n   connection state transitions\
    \ when the iSCSI connection is not waiting\n   for, or undergoing, a cleanup by\
    \ way of an explicit or implicit\n   Logout.  The second diagram, \"connection\
    \ cleanup state diagram\",\n   describes the connection state transitions while\
    \ performing the iSCSI\n   connection cleanup.\n   The \"session state diagram\"\
    \ describes the state transitions an iSCSI\n   session would go through during\
    \ its lifetime, and it depends on the\n   states of possibly multiple iSCSI connections\
    \ that participate in the\n   session.\n   States and state transitions are described\
    \ in the text, tables and\n   diagrams.  The diagrams are used for illustration.\
    \  The text and the\n   tables are the governing specification.\n"
- title: 7.1.  Standard Connection State Diagrams
  contents:
  - '7.1.  Standard Connection State Diagrams

    '
- title: 7.1.1.  State Descriptions for Initiators and Targets
  contents:
  - "7.1.1.  State Descriptions for Initiators and Targets\n   State descriptions\
    \ for the standard connection state diagram are as\n   follows:\n   -S1: FREE\n\
    \        -initiator: State on instantiation, or after successful\n         connection\
    \ closure.\n        -target: State on instantiation, or after successful connection\n\
    \         closure.\n   -S2: XPT_WAIT\n        -initiator: Waiting for a response\
    \ to its transport connection\n         establishment request.\n        -target:\
    \ Illegal\n   -S3: XPT_UP\n        -initiator: Illegal\n        -target: Waiting\
    \ for the Login process to commence.\n   -S4: IN_LOGIN\n        -initiator: Waiting\
    \ for the Login process to conclude, possibly\n         involving several PDU\
    \ exchanges.\n        -target: Waiting for the Login process to conclude, possibly\n\
    \         involving several PDU exchanges.\n   -S5: LOGGED_IN\n        -initiator:\
    \ In Full Feature Phase, waiting for all internal,\n         iSCSI, and transport\
    \ events.\n        -target: In Full Feature Phase, waiting for all internal, iSCSI,\n\
    \         and transport events.\n   -S6: IN_LOGOUT\n        -initiator: Waiting\
    \ for a Logout response.\n        -target: Waiting for an internal event signaling\
    \ completion of\n         logout processing.\n   -S7: LOGOUT_REQUESTED\n     \
    \   -initiator: Waiting for an internal event signaling readiness to\n       \
    \  proceed with Logout.\n        -target: Waiting for the Logout process to start\
    \ after having\n         requested a Logout via an Async Message.\n   -S8: CLEANUP_WAIT\n\
    \        -initiator: Waiting for the context and/or resources to initiate\n  \
    \       the cleanup processing for this CSM.\n        -target: Waiting for the\
    \ cleanup process to start for this CSM.\n"
- title: 7.1.2.  State Transition Descriptions for Initiators and Targets
  contents:
  - "7.1.2.  State Transition Descriptions for Initiators and Targets\n   -T1:\n \
    \       -initiator: Transport connect request was made (e.g., TCP SYN\n      \
    \      sent).\n        -target: Illegal\n   -T2:\n        -initiator: Transport\
    \ connection request timed out, a transport\n            reset was received, or\
    \ an internal event of receiving a\n            Logout response (success) on another\
    \ connection for a\n            \"close the session\"  Logout request was received.\n\
    \        -target:Illegal\n   -T3:\n        -initiator: Illegal\n        -target:\
    \ Received a valid transport connection request that\n            establishes\
    \ the transport connection.\n   -T4:\n        -initiator: Transport connection\
    \ established, thus prompting the\n            initiator to start the iSCSI Login.\n\
    \        -target: Initial iSCSI Login Request was received.\n   -T5:\n       \
    \ -initiator: The final iSCSI Login Response with a Status-Class\n           \
    \ of zero was received.\n        -target: The final iSCSI Login Request to conclude\
    \ the Login\n            Phase was received, thus prompting the target to send\
    \ the\n            final iSCSI Login Response with a Status-Class of zero.\n \
    \  -T6:\n        -initiator: Illegal\n        -target: Timed out waiting for an\
    \ iSCSI Login, transport\n            disconnect indication was received, transport\
    \ reset was\n            received, or an internal event indicating a transport\n\
    \            timeout was received.  In all these cases, the connection is\n  \
    \          to be closed.\n   -T7:\n        -initiator - one of the following events\
    \ caused the transition:\n            - The final iSCSI Login Response was received\
    \ with a\n              non-zero Status-Class.\n            - Login timed out.\n\
    \            - A transport disconnect indication was received.\n            -\
    \ A transport reset was received.\n            - An internal event was received\
    \ indicating a transport\n              timeout.\n            - An internal event\
    \ of receiving a Logout response (success)\n              on another connection\
    \ for a \"close the session\" Logout\n              request was received.\n  \
    \      In all these cases, the transport connection is closed.\n        -target\
    \ - one of the following events caused the transition:\n            - The final\
    \ iSCSI Login Request to conclude the Login Phase\n              was received,\
    \ prompting the target to send the final iSCSI\n              Login Response with\
    \ a non-zero Status-Class.\n            - Login timed out.\n            - Transport\
    \ disconnect indication was received.\n            - Transport reset was received.\n\
    \            - An internal event indicating a transport timeout was\n        \
    \      received.\n            - On another connection a \"close the session\"\
    \ Logout request\n              was received.\n        In all these cases, the\
    \ connection is to be closed.\n   -T8:\n        -initiator: An internal event\
    \ of receiving a Logout response\n            (success) on another connection\
    \ for a \"close the session\"\n            Logout request was received, thus closing\
    \ this connection\n            requiring no further cleanup.\n        -target:\
    \ An internal event of sending a Logout response\n            (success) on another\
    \ connection for a \"close the session\"\n            Logout request was received,\
    \ or an internal event of a\n            successful connection/session reinstatement\
    \ is received,\n            thus prompting the target to close this connection\
    \ cleanly.\n   -T9, T10:\n        -initiator: An internal event that indicates\
    \ the readiness to\n            start the Logout process was received, thus prompting\
    \ an\n            iSCSI Logout to be sent by the initiator.\n        -target:\
    \ An iSCSI Logout request was received.\n   -T11, T12:\n        -initiator: Async\
    \ PDU with AsyncEvent \"Request Logout\" was\n            received.\n        -target:\
    \ An internal event that requires the decommissioning of\n            the connection\
    \ is received, thus causing an Async PDU with\n            an AsyncEvent \"Request\
    \ Logout\" to be sent.\n   -T13:\n        -initiator: An iSCSI Logout response\
    \ (success) was received, or\n            an internal event of receiving a Logout\
    \ response (success)\n            on another connection for a \"close the session\"\
    \ Logout\n            request was received.\n        -target: An internal event\
    \ was received that indicates\n            successful processing of the Logout,\
    \ which prompts an iSCSI\n            Logout response (success) to be sent; an\
    \ internal event of\n            sending a Logout response (success) on another\
    \ connection\n            for a \"close the session\" Logout request was received;\
    \ or an\n            internal event of a successful connection/session\n     \
    \       reinstatement is received.  In all these cases, the\n            transport\
    \ connection is closed.\n   -T14:\n        -initiator: Async PDU with AsyncEvent\
    \ \"Request Logout\" was\n            received again.\n        -target: Illegal\n\
    \   -T15, T16:\n        -initiator: One or more of the following events caused\
    \ this\n            transition:\n            -Internal event that indicates a\
    \ transport connection\n               timeout was received thus prompting transport\
    \ RESET or\n               transport connection closure.\n            -A transport\
    \ RESET.\n            -A transport disconnect indication.\n            -Async\
    \ PDU with AsyncEvent \"Drop connection\" (for this CID).\n            -Async\
    \ PDU with AsyncEvent \"Drop all connections\".\n        -target: One or more\
    \ of the following events caused this\n            transition:\n            -Internal\
    \ event that indicates a transport connection\n               timeout was received,\
    \ thus prompting transport RESET or\n               transport connection closure.\n\
    \            -An internal event of a failed connection/session\n             \
    \  reinstatement is received.\n            -A transport RESET.\n            -A\
    \ transport disconnect indication.\n            -Internal emergency cleanup event\
    \ was received which prompts\n               an Async PDU with AsyncEvent \"Drop\
    \ connection\" (for this\n               CID), or event \"Drop all connections\"\
    .\n   -T17:\n        -initiator: One or more of the following events caused this\n\
    \            transition:\n            -Logout response, (failure i.e., a non-zero\
    \ status) was\n               received, or Logout timed out.\n            -Any\
    \ of the events specified for T15 and T16.\n        -target:  One or more of the\
    \ following events caused this\n            transition:\n            -Internal\
    \ event that indicates a failure of the Logout\n               processing was\
    \ received, which prompts a Logout response\n               (failure, i.e., a\
    \ non-zero status) to be sent.\n            -Any of the events specified for T15\
    \ and T16.\n   -T18:\n        -initiator: An internal event of receiving a Logout\
    \ response\n            (success) on another connection for a \"close the session\"\
    \n            Logout request was received.\n        -target: An internal event\
    \ of sending a Logout response\n            (success) on another connection for\
    \ a \"close the session\"\n            Logout request was received, or an internal\
    \ event of a\n            successful connection/session reinstatement is received.\
    \  In\n            both these cases, the connection is closed.\n   The CLEANUP_WAIT\
    \ state (S8) implies that there are possible iSCSI\n   tasks that have not reached\
    \ conclusion and are still considered busy.\n"
- title: 7.1.3.  Standard Connection State Diagram for an Initiator
  contents:
  - "7.1.3.  Standard Connection State Diagram for an Initiator\n   Symbolic names\
    \ for States:\n      S1: FREE\n      S2: XPT_WAIT\n      S4: IN_LOGIN\n      S5:\
    \ LOGGED_IN\n      S6: IN_LOGOUT\n      S7: LOGOUT_REQUESTED\n      S8: CLEANUP_WAIT\n\
    \   States S5, S6, and S7 constitute the Full Feature Phase operation of\n   the\
    \ connection.\n   The state diagram is as follows:\n                     -------<-------------+\n\
    \         +--------->/ S1    \\<----+       |\n      T13|       +->\\       /<-+\
    \   \\      |\n         |      /    ---+---    \\   \\     |\n         |     /\
    \        |     T2 \\   |    |\n         |  T8 |        |T1       |  |    |\n \
    \        |     |        |        /   |T7  |\n         |     |        |       /\
    \    |    |\n         |     |        |      /     |    |\n         |     |   \
    \     V     /     /     |\n         |     |     ------- /     /      |\n     \
    \    |     |    / S2    \\     /       |\n         |     |    \\       /    /\
    \        |\n         |     |     ---+---    /         |\n         |     |    \
    \    |T4    /          |\n         |     |        V     /           | T18\n  \
    \       |     |     ------- /            |\n         |     |    / S4    \\   \
    \          |\n         |     |    \\       /             |\n         |     | \
    \    ---+---              |         T15\n         |     |        |T5      +--------+---------+\n\
    \         |     |        |       /T16+-----+------+  |\n         |     |     \
    \   |      /   -+-----+--+   |  |\n         |     |        |     /   /  S7   \\\
    \  |T12|  |\n         |     |        |    / +->\\       /<-+   V  V\n        \
    \ |     |        |   / /    -+-----       -------\n         |     |        | \
    \ / /T11   |T10        /  S8   \\\n         |     |        V / /       V  +----+\
    \   \\       /\n         |     |      ---+-+-      ----+--  |    -------\n   \
    \      |     |     / S5    \\T9  / S6    \\<+    ^\n         |     +-----\\  \
    \     /--->\\       / T14  |\n         |            -------      --+----+------+T17\n\
    \         +---------------------------+\n   The following state transition table\
    \ represents the above diagram.\n   Each row represents the starting state for\
    \ a given transition, which\n   after taking a transition marked in a table cell\
    \ would end in the\n   state represented by the column of the cell.  For example,\
    \ from state\n   S1, the connection takes the T1 transition to arrive at state\
    \ S2.\n   The fields marked \"-\" correspond to undefined transitions.\n     \
    \    +----+---+---+---+---+----+---+\n         |S1  |S2 |S4 |S5 |S6 |S7  |S8 |\n\
    \      ---+----+---+---+---+---+----+---+\n       S1| -  |T1 | - | - | - | - \
    \ | - |\n      ---+----+---+---+---+---+----+---+\n       S2|T2  |-  |T4 | - |\
    \ - | -  | - |\n      ---+----+---+---+---+---+----+---+\n       S4|T7  |-  |-\
    \  |T5 | - | -  | - |\n      ---+----+---+---+---+---+----+---+\n       S5|T8\
    \  |-  |-  | - |T9 |T11 |T15|\n      ---+----+---+---+---+---+----+---+\n    \
    \   S6|T13 |-  |-  | - |T14|-   |T17|\n      ---+----+---+---+---+---+----+---+\n\
    \       S7|T18 |-  |-  | - |T10|T12 |T16|\n      ---+----+---+---+---+---+----+---+\n\
    \       S8| -  |-  |-  | - | - | -  | - |\n      ---+----+---+---+---+---+----+---+\n"
- title: 7.1.4.  Standard Connection State Diagram for a Target
  contents:
  - "7.1.4.  Standard Connection State Diagram for a Target\n   Symbolic names for\
    \ States:\n      S1: FREE\n      S3: XPT_UP\n      S4: IN_LOGIN\n      S5: LOGGED_IN\n\
    \      S6: IN_LOGOUT\n      S7: LOGOUT_REQUESTED\n      S8: CLEANUP_WAIT\n   States\
    \ S5, S6, and S7 constitute the Full Feature Phase operation of\n   the connection.\n\
    \   The state diagram is as follows:\n                        -------<-------------+\n\
    \            +--------->/ S1    \\<----+       |\n         T13|       +->\\  \
    \     /<-+   \\      |\n            |      /    ---+---    \\   \\     |\n   \
    \         |     /        |     T6 \\   |    |\n            |  T8 |        |T3\
    \       |  |    |\n            |     |        |        /   |T7  |\n          \
    \  |     |        |       /    |    |\n            |     |        |      /   \
    \  |    |\n            |     |        V     /     /     |\n            |     |\
    \     ------- /     /      |\n            |     |    / S3    \\     /       |\n\
    \            |     |    \\       /    /        | T18\n            |     |    \
    \ ---+---    /         |\n            |     |        |T4    /          |\n   \
    \         |     |        V     /           |\n            |     |     -------\
    \ /            |\n            |     |    / S4    \\             |\n          \
    \  |     |    \\       /             |\n            |     |     ---+---      \
    \   T15  |\n            |     |        |T5      +--------+---------+\n       \
    \     |     |        |       /T16+-----+------+  |\n            |     |      \
    \  |      /  -+-----+---+   |  |\n            |     |        |     /   /  S7 \
    \  \\  |T12|  |\n            |     |        |    / +->\\       /<-+   V  V\n \
    \           |     |        |   / /    -+-----       -------\n            |   \
    \  |        |  / /T11   |T10        /  S8   \\\n            |     |        V /\
    \ /       V           \\       /\n            |     |      ---+-+-      -------\
    \       -------\n            |     |     / S5    \\T9  / S6    \\        ^\n \
    \           |     +-----\\       /--->\\       /        |\n            |     \
    \       -------      --+----+--------+T17\n            +---------------------------+\n\
    \   The following state transition table represents the above diagram,\n   and\
    \ follows the conventions described for the initiator diagram.\n      +----+---+---+---+---+----+---+\n\
    \      |S1  |S3 |S4 |S5 |S6 |S7  |S8 |\n   ---+----+---+---+---+---+----+---+\n\
    \    S1| -  |T3 | - | - | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n\
    \    S3|T6  |-  |T4 | - | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n\
    \    S4|T7  |-  |-  |T5 | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n\
    \    S5|T8  |-  |-  | - |T9 |T11 |T15|\n   ---+----+---+---+---+---+----+---+\n\
    \    S6|T13 |-  |-  | - |-  |-   |T17|\n   ---+----+---+---+---+---+----+---+\n\
    \    S7|T18 |-  |-  | - |T10|T12 |T16|\n   ---+----+---+---+---+---+----+---+\n\
    \    S8| -  |-  |-  | - | - | -  | - |\n   ---+----+---+---+---+---+----+---+\n"
- title: 7.2.  Connection Cleanup State Diagram for Initiators and Targets
  contents:
  - "7.2.  Connection Cleanup State Diagram for Initiators and Targets\n   Symbolic\
    \ names for states:\n      R1: CLEANUP_WAIT (same as S8)\n      R2: IN_CLEANUP\n\
    \      R3: FREE (same as S1)\n   Whenever a connection state machine (e.g., CSM-C)\
    \ enters the\n   CLEANUP_WAIT state (S8), it must go through the state transitions\n\
    \   described in the connection cleanup state diagram either a) using a\n   separate\
    \ full-feature phase connection (let's call it CSM-E) in the\n   LOGGED_IN state\
    \ in the same session, or b) using a new transport\n   connection (let's call\
    \ it CSM-I) in the FREE state that is to be\n   added to the same session.  In\
    \ the CSM-E case, an explicit logout for\n   the CID that corresponds to CSM-C\
    \ (either as a connection or session\n   logout) needs to be performed to complete\
    \ the cleanup.  In the CSM-I\n   case, an implicit logout for the CID that corresponds\
    \ to CSM-C needs\n   to be performed by way of connection reinstatement (section\
    \ 5.3.4)\n   for that CID.  In either case, the protocol exchanges on CSM-E or\n\
    \   CSM-I determine the state transitions for CSM-C.  Therefore, this\n   cleanup\
    \ state diagram is only applicable to the instance of the\n   connection in cleanup\
    \ (i.e., CSM-C).  In the case of an implicit\n   logout for example, CSM-C reaches\
    \ FREE (R3) at the time CSM-I reaches\n   LOGGED_IN.  In the case of an explicit\
    \ logout, CSM-C reaches FREE\n   (R3) when CSM-E receives a successful logout\
    \ response while\n   continuing to be in the LOGGED_IN state.\n   An initiator\
    \ must initiate an explicit or implicit connection logout\n   for a connection\
    \ in the CLEANUP_WAIT state, if the initiator intends\n   to continue using the\
    \ associated iSCSI session.\n   The following state diagram applies to both initiators\
    \ and targets.\n                        -------\n                       / R1 \
    \   \\\n                    +--\\       /<-+\n                   /    ---+---\n\
    \                  /        |        \\ M3\n               M1 |        |M2   \
    \    |\n                  |        |        /\n                  |        |  \
    \     /\n                  |        |      /\n                  |        V   \
    \  /\n                  |     ------- /\n                  |    / R2    \\\n \
    \                 |    \\       /\n                  |     -------\n         \
    \         |        |\n                  |        |M4\n                  |    \
    \    |\n                  |        |\n                  |        |\n         \
    \         |        V\n                  |      -------\n                  |  \
    \   / R3    \\\n                  +---->\\       /\n                         -------\n\
    \   The following state transition table represents the above diagram,\n   and\
    \ follows the same conventions as in earlier sections.\n        +----+----+----+\n\
    \        |R1  |R2  |R3  |\n   -----+----+----+----+\n    R1  | -  |M2  |M1  |\n\
    \   -----+----+----+----+\n    R2  |M3  | -  |M4  |\n   -----+----+----+----+\n\
    \    R3  | -  | -  | -  |\n   -----+----+----+----+\n"
- title: 7.2.1.  State Descriptions for Initiators and Targets
  contents:
  - "7.2.1.  State Descriptions for Initiators and Targets\n   -R1: CLEANUP_WAIT (Same\
    \ as S8)\n        -initiator: Waiting for the internal event to initiate the\n\
    \            cleanup processing for CSM-C.\n        -target: Waiting for the cleanup\
    \ process to start for CSM-C.\n   -R2: IN_CLEANUP\n        -initiator: Waiting\
    \ for the connection cleanup process to\n            conclude for CSM-C.\n   \
    \     -target: Waiting for the connection cleanup process to conclude\n      \
    \      for CSM-C.\n   -R3: FREE (Same as S1)\n        -initiator: End state for\
    \ CSM-C.\n        -target: End state for CSM-C.\n"
- title: 7.2.2.  State Transition Descriptions for Initiators and Targets
  contents:
  - "7.2.2.  State Transition Descriptions for Initiators and Targets\n   -M1: One\
    \ or more of the following events was received:\n        -initiator:\n       \
    \     -An internal event that indicates connection state timeout.\n          \
    \  -An internal event of receiving a successful Logout response\n            \
    \   on a different connection for a \"close the session\"\n               Logout.\n\
    \        -target:\n            -An internal event that indicates connection state\
    \ timeout.\n            -An internal event of sending a Logout response (success)\
    \ on\n               a different connection for a \"close the session\" Logout\n\
    \               request.\n   -M2: An implicit/explicit logout process was initiated\
    \ by the\n        initiator.\n        -In CSM-I usage:\n            -initiator:\
    \ An internal event requesting the connection (or\n               session) reinstatement\
    \ was received, thus prompting a\n               connection (or session) reinstatement\
    \ Login to be sent\n               transitioning CSM-I to state IN_LOGIN.\n  \
    \          -target: A connection/session reinstatement Login was\n           \
    \    received while in state XPT_UP.\n        -In CSM-E usage:\n            -initiator:\
    \ An internal event that indicates that an\n               explicit logout was\
    \ sent for this CID in state LOGGED_IN.\n            -target: An explicit logout\
    \ was received for this CID in\n               state LOGGED_IN.\n   -M3: Logout\
    \ failure detected\n        -In CSM-I usage:\n            -initiator: CSM-I failed\
    \ to reach LOGGED_IN and arrived into\n               FREE instead.\n        \
    \    -target: CSM-I failed to reach LOGGED_IN and arrived into\n             \
    \  FREE instead.\n        -In CSM-E usage:\n            -initiator: CSM-E either\
    \ moved out of LOGGED_IN, or Logout\n               timed out and/or aborted,\
    \ or Logout response (failure)\n               was received.\n            -target:\
    \ CSM-E either moved out of LOGGED_IN,  Logout timed\n               out and/or\
    \ aborted, or an internal event that indicates a\n               failed Logout\
    \ processing was received.  A Logout response\n               (failure) was sent\
    \ in the last case.\n   -M4: Successful implicit/explicit logout was performed.\n\
    \        - In CSM-I usage:\n            -initiator: CSM-I reached state LOGGED_IN,\
    \ or an internal\n               event of receiving a Logout response (success)\
    \ on another\n               connection for a \"close the session\" Logout request\
    \ was\n               received.\n            -target: CSM-I reached state LOGGED_IN,\
    \ or an internal event\n               of sending a Logout response (success)\
    \ on a different\n               connection for a \"close the session\" Logout\
    \ request was\n               received.\n        - In CSM-E usage:\n         \
    \   -initiator: CSM-E stayed in LOGGED_IN and received a Logout\n            \
    \   response (success), or an internal event of receiving a\n               Logout\
    \ response (success) on another connection for a\n               \"close the session\"\
    \ Logout request was received.\n            -target: CSM-E stayed in LOGGED_IN\
    \ and an internal event\n               indicating a successful Logout processing\
    \ was received,\n               or an internal event of sending a Logout response\n\
    \               (success) on a different connection for a \"close the\n      \
    \         session\" Logout request was received.\n"
- title: 7.3.  Session State Diagrams
  contents:
  - '7.3.  Session State Diagrams

    '
- title: 7.3.1.  Session State Diagram for an Initiator
  contents:
  - "7.3.1.  Session State Diagram for an Initiator\n   Symbolic Names for States:\n\
    \        Q1: FREE\n        Q3: LOGGED_IN\n        Q4: FAILED\n   State Q3 represents\
    \ the Full Feature Phase operation of the session.\n   The state diagram is as\
    \ follows:\n                          -------\n                         / Q1 \
    \   \\\n                 +------>\\       /<-+\n                /         ---+---\
    \   |\n               /             |      |N3\n           N6 |              |N1\
    \    |\n              |              |      |\n              |    N4        |\
    \      |\n              |  +--------+  |     /\n              |  |        |  |\
    \    /\n              |  |        |  |   /\n              |  |        V  V  /\n\
    \             -+--+--      -----+-\n            / Q4    \\ N5 / Q3    \\\n   \
    \         \\       /<---\\       /\n             -------      -------\n   The\
    \ state transition table is as follows:\n        +----+----+----+\n        |Q1\
    \  |Q3  |Q4  |\n   -----+----+----+----+\n    Q1  | -  |N1  | -  |\n   -----+----+----+----+\n\
    \    Q3  |N3  | -  |N5  |\n   -----+----+----+----+\n    Q4  |N6  |N4  | -  |\n\
    \   -----+----+----+----+\n"
- title: 7.3.2.  Session State Diagram for a Target
  contents:
  - "7.3.2.  Session State Diagram for a Target\n   Symbolic Names for States:\n \
    \    Q1: FREE\n     Q2: ACTIVE\n     Q3: LOGGED_IN\n     Q4: FAILED\n     Q5:\
    \ IN_CONTINUE\n   State Q3 represents the Full Feature Phase operation of the\
    \ session.\n   The state diagram is as follows:\n                            \
    \        -------\n               +------------------>/ Q1    \\\n            \
    \  /    +-------------->\\       /<-+\n              |    |                ---+---\
    \   |\n              |    |                ^  |      |N3\n           N6 |    |N11\
    \           N9|  V N1   |\n              |    |                +------   |\n \
    \             |    |               / Q2    \\  |\n              |    |       \
    \        \\       /  |\n              |  --+----            +--+---   |\n    \
    \          | / Q5    \\              |      |\n              | \\       / N10\
    \          |      |\n              |  +-+---+------------+  |N2   /\n        \
    \      |  ^ |                |  |    /\n              |N7| |N8              |\
    \  |   /\n              |  | |                |  V  /\n             -+--+-V  \
    \              V----+-\n            / Q4    \\ N5           / Q3    \\\n     \
    \       \\       /<-------------\\       /\n             -------             \
    \   -------\n   The state transition table is as follows:\n        +----+----+----+----+----+\n\
    \        |Q1  |Q2  |Q3  |Q4  |Q5  |\n   -----+----+----+----+----+----+\n    Q1\
    \  | -  |N1  | -  | -  | -  |\n   -----+----+----+----+----+----+\n    Q2  |N9\
    \  | -  |N2  | -  | -  |\n   -----+----+----+----+----+----+\n    Q3  |N3  | -\
    \  | -  |N5  | -  |\n   -----+----+----+----+----+----+\n    Q4  |N6  | -  | -\
    \  | -  |N7  |\n   -----+----+----+----+----+----+\n    Q5  |N11 | -  |N10 |N8\
    \  | -  |\n   -----+----+----+----+----+----+\n"
- title: 7.3.3.  State Descriptions for Initiators and Targets
  contents:
  - "7.3.3.  State Descriptions for Initiators and Targets\n   -Q1: FREE\n       \
    \ -initiator: State on instantiation or after cleanup.\n        -target: State\
    \ on instantiation or after cleanup.\n   -Q2: ACTIVE\n        -initiator: Illegal.\n\
    \        -target: The first iSCSI connection in the session transitioned\n   \
    \         to IN_LOGIN, waiting for it to complete the login process.\n   -Q3:\
    \ LOGGED_IN\n        -initiator: Waiting for all session events.\n        -target:\
    \ Waiting for all session events.\n   -Q4: FAILED\n        -initiator: Waiting\
    \ for session recovery or session\n            continuation.\n        -target:\
    \ Waiting for session recovery or session continuation.\n   -Q5: IN_CONTINUE\n\
    \        -initiator: Illegal.\n        -target: Waiting for session continuation\
    \ attempt to reach a\n            conclusion.\n"
- title: 7.3.4.  State Transition Descriptions for Initiators and Targets
  contents:
  - "7.3.4.  State Transition Descriptions for Initiators and Targets\n   -N1:\n \
    \       -initiator: At least one transport connection reached the\n          \
    \  LOGGED_IN state.\n        -target: The first iSCSI connection in the session\
    \ had reached\n            the IN_LOGIN state.\n   -N2:\n        -initiator: Illegal.\n\
    \        -target: At least one iSCSI connection reached the LOGGED_IN\n      \
    \      state.\n   -N3:\n        -initiator: Graceful closing of the session via\
    \ session closure\n            (Section 5.3.6 Session Continuation and Failure).\n\
    \        -target: Graceful closing of the session via session closure\n      \
    \      (Section 5.3.6 Session Continuation and Failure) or a\n            successful\
    \ session reinstatement cleanly closed the session.\n   -N4:\n        -initiator:\
    \ A session continuation attempt succeeded.\n        -target: Illegal.\n   -N5:\n\
    \        -initiator: Session failure (Section 5.3.6 Session Continuation\n   \
    \         and Failure) occurred.\n        -target: Session failure (Section 5.3.6\
    \ Session Continuation and\n            Failure) occurred.\n   -N6:\n        -initiator:\
    \ Session state timeout occurred, or a session\n            reinstatement cleared\
    \ this session instance.  This results\n            in the freeing of all associated\
    \ resources and the session\n            state is discarded.\n        -target:\
    \ Session state timeout occurred, or a session\n            reinstatement cleared\
    \ this session instance.  This results\n            in the freeing of all associated\
    \ resources and the session\n            state is discarded.\n   -N7:\n      \
    \  -initiator: Illegal.\n        -target: A session continuation attempt is initiated.\n\
    \   -N8:\n        -initiator: Illegal.\n        -target: The last session continuation\
    \ attempt failed.\n   -N9:\n        -initiator: Illegal.\n        -target: Login\
    \ attempt on the leading connection failed.\n   -N10:\n        -initiator: Illegal.\n\
    \        -target: A session continuation attempt succeeded.\n   -N11:\n      \
    \  -initiator: Illegal.\n        -target: A successful session reinstatement cleanly\
    \ closed the\n            session.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Historically, native storage systems have not\
    \ had to consider\n   security because their environments offered minimal security\
    \ risks.\n   That is, these environments consisted of storage devices either\n\
    \   directly attached to hosts or connected via a Storage Area Network\n   (SAN)\
    \ distinctly separate from the communications network.  The use\n   of storage\
    \ protocols, such as SCSI, over IP-networks requires that\n   security concerns\
    \ be addressed.  iSCSI implementations MUST provide\n   means of protection against\
    \ active attacks (e.g., pretending to be\n   another identity, message insertion,\
    \ deletion, modification, and\n   replaying) and passive attacks (e.g., eavesdropping,\
    \ gaining\n   advantage by analyzing the data sent over the line).\n   Although\
    \ technically possible, iSCSI SHOULD NOT be configured without\n   security. \
    \ iSCSI configured without security should be confined, in\n   extreme cases,\
    \ to closed environments without any security risk.\n   [RFC3723] specifies the\
    \ mechanisms that must be used in order to\n   mitigate risks fully described\
    \ in that document.\n   The following section describes the security mechanisms\
    \ provided by\n   an iSCSI implementation.\n"
- title: 8.1.  iSCSI Security Mechanisms
  contents:
  - "8.1.  iSCSI Security Mechanisms\n   The entities involved in iSCSI security are\
    \ the initiator, target,\n   and the IP communication end points.  iSCSI scenarios\
    \ in which\n   multiple initiators or targets share a single communication end\
    \ point\n   are expected.  To accommodate such scenarios, iSCSI uses two separate\n\
    \   security mechanisms: In-band authentication between the initiator and\n  \
    \ the target at the iSCSI connection level (carried out by exchange of\n   iSCSI\
    \ Login PDUs), and packet protection (integrity, authentication,\n   and confidentiality)\
    \ by IPsec at the IP level.  The two security\n   mechanisms complement each other.\
    \  The in-band authentication\n   provides end-to-end trust (at login time) between\
    \ the iSCSI initiator\n   and the target while IPsec provides a secure channel\
    \ between the IP\n   communication end points.\n   Further details on typical\
    \ iSCSI scenarios and the relation between\n   the initiators, targets, and the\
    \ communication end points can be\n   found in [RFC3723].\n"
- title: 8.2.  In-band Initiator-Target Authentication
  contents:
  - "8.2.  In-band Initiator-Target Authentication\n   During login, the target MAY\
    \ authenticate the initiator and the\n   initiator MAY authenticate the target.\
    \  The authentication is\n   performed on every new iSCSI connection by an exchange\
    \ of iSCSI Login\n   PDUs using a negotiated authentication method.\n   The authentication\
    \ method cannot assume an underlying IPsec\n   protection, because IPsec is optional\
    \ to use.  An attacker should\n   gain as little advantage as possible by inspecting\
    \ the authentication\n   phase PDUs.  Therefore, a method using clear text (or\
    \ equivalent)\n   passwords is not acceptable; on the other hand, identity protection\n\
    \   is not strictly required.\n   The authentication mechanism protects against\
    \ an unauthorized login\n   to storage resources by using a false identity (spoofing).\
    \  Once the\n   authentication phase is completed, if the underlying IPsec is\
    \ not\n   used, all PDUs are sent and received in clear.  The authentication\n\
    \   mechanism alone (without underlying IPsec) should only be used when\n   there\
    \ is no risk of eavesdropping, message insertion, deletion,\n   modification,\
    \ and replaying.\n   Section 11 iSCSI Security Text Keys and Authentication Methods\n\
    \   defines several authentication methods and the exact steps that must\n   be\
    \ followed in each of them, including the iSCSI-text-keys and their\n   allowed\
    \ values in each step.  Whenever an iSCSI initiator gets a\n   response whose\
    \ keys, or their values, are not according to the step\n   definition, it MUST\
    \ abort the connection.  Whenever an iSCSI target\n   gets a response whose keys,\
    \ or their values, are not according to the\n   step definition, it MUST answer\
    \ with a Login reject with the\n   \"Initiator Error\" or \"Missing Parameter\"\
    \ status.  These statuses are\n   not intended for cryptographically incorrect\
    \ values such as the CHAP\n   response, for which \"Authentication Failure\" status\
    \ MUST be\n   specified.  The importance of this rule can be illustrated in CHAP\n\
    \   with target authentication (see Section 11.1.4 Challenge Handshake\n   Authentication\
    \ Protocol (CHAP)) where the initiator would have been\n   able to conduct a reflection\
    \ attack by omitting his response key\n   (CHAP_R) using the same CHAP challenge\
    \ as the target and reflecting\n   the target's response back to the target. \
    \ In CHAP, this is prevented\n   because the target must answer the missing CHAP_R\
    \ key with a Login\n   reject with the \"Missing Parameter\" status.\n   For some\
    \ of the authentication methods, a key specifies the identity\n   of the iSCSI\
    \ initiator or target for authentication purposes.  The\n   value associated with\
    \ that key MAY be different from the iSCSI name\n   and SHOULD be configurable.\
    \  (CHAP_N, see Section 11.1.4 Challenge\n   Handshake Authentication Protocol\
    \ (CHAP) and SRP_U, see Section\n   11.1.3 Secure Remote Password (SRP)).\n"
- title: 8.2.1.  CHAP Considerations
  contents:
  - "8.2.1.  CHAP Considerations\n   Compliant iSCSI initiators and targets MUST implement\
    \ the CHAP\n   authentication method [RFC1994] (according to Section 11.1.4\n\
    \   Challenge Handshake Authentication Protocol (CHAP) including the\n   target\
    \ authentication option).\n   When CHAP is performed over a non-encrypted channel,\
    \ it is vulnerable\n   to an off-line dictionary attack.  Implementations MUST\
    \ support use\n   of up to 128 bit random CHAP secrets, including the means to\
    \ generate\n   such secrets and to accept them from an external generation source.\n\
    \   Implementations MUST NOT provide secret generation (or expansion)\n   means\
    \ other than random generation.\n   An administrative entity of an environment\
    \ in which CHAP is used with\n   a secret that has less than 96 random bits MUST\
    \ enforce IPsec\n   encryption (according to the implementation requirements in\
    \ Section\n   8.3.2 Confidentiality) to protect the connection.  Moreover, in\
    \ this\n   case IKE authentication with group pre-shared cryptographic keys\n\
    \   SHOULD NOT be used unless it is not essential to protect group\n   members\
    \ against off-line dictionary attacks by other members.\n   CHAP secrets MUST\
    \ be an integral number of bytes (octets). A\n   compliant implementation SHOULD\
    \ NOT continue with the login step in\n   which it should send a CHAP response\
    \ (CHAP_R, Section 11.1.4\n   Challenge Handshake Authentication Protocol (CHAP))\
    \ unless it can\n   verify that the CHAP secret is at least 96 bits, or that IPsec\n\
    \   encryption is being used to protect the connection.\n   Any CHAP secret used\
    \ for initiator authentication MUST NOT be\n   configured for authentication of\
    \ any target, and any CHAP secret used\n   for target authentication MUST NOT\
    \ be configured for authentication\n   of any initiator.  If the CHAP response\
    \ received by one end of an\n   iSCSI connection is the same as the CHAP response\
    \ that the receiving\n   endpoint would have generated for the same CHAP challenge,\
    \ the\n   response MUST be treated as an authentication failure and cause the\n\
    \   connection to close (this ensures that the same CHAP secret is not\n   used\
    \ for authentication in both directions).  Also, if an iSCSI\n   implementation\
    \ can function as both initiator and target, different\n   CHAP secrets and identities\
    \ MUST be configured for these two roles.\n   The following is an example of the\
    \ attacks prevented by the above\n   requirements:\n     Rogue wants to impersonate\
    \ Storage to Alice, and knows that a\n      single secret is used for both directions\
    \ of Storage-Alice\n      authentication.\n     Rogue convinces Alice to open\
    \ two connections to Rogue, and Rogue\n      identifies itself as Storage on both\
    \ connections.\n     Rogue issues a CHAP challenge on connection 1, waits for\
    \ Alice to\n      respond, and then reflects Alice's challenge as the initial\n\
    \      challenge to Alice on connection 2.\n     If Alice doesn't check for the\
    \ reflection across connections,\n      Alice's response on connection 2 enables\
    \ Rogue to impersonate\n      Storage on connection 1, even though Rogue does\
    \ not know the\n      Alice-Storage CHAP secret.\n   Originators MUST NOT reuse\
    \ the CHAP challenge sent by the Responder\n   for the other direction of a bidirectional\
    \ authentication.\n   Responders MUST check for this condition and close the iSCSI\
    \ TCP\n   connection if it occurs.\n   The same CHAP secret SHOULD NOT be configured\
    \ for authentication of\n   multiple initiators or multiple targets, as this enables\
    \ any of them\n   to impersonate any other one of them, and compromising one of\
    \ them\n   enables the attacker to impersonate any of them.  It is recommended\n\
    \   that iSCSI implementations check for use of identical CHAP secrets by\n  \
    \ different peers when this check is feasible, and take appropriate\n   measures\
    \ to warn users and/or administrators when this is detected.\n   When an iSCSI\
    \ initiator or target authenticates itself to\n   counterparts in multiple administrative\
    \ domains, it SHOULD use a\n   different CHAP secret for each administrative domain\
    \ to avoid\n   propagating security compromises across domains.\n   Within a single\
    \ administrative domain:\n   - A single CHAP secret MAY be used for authentication\
    \ of an initiator\n   to multiple targets.\n   - A single CHAP secret MAY be used\
    \ for an authentication of a target\n   to multiple initiators when the initiators\
    \ use an external server\n   (e.g., RADIUS) to verify the target's CHAP responses\
    \ and do not know\n   the target's CHAP secret.\n   If an external response verification\
    \ server (e.g., RADIUS) is not\n   used, employing a single CHAP secret for authentication\
    \ of a target\n   to multiple initiators requires that all such initiators know\
    \ that\n   target secret.  Any of these initiators can impersonate the target\
    \ to\n   any other such initiator, and compromise of such an initiator enables\n\
    \   an attacker to impersonate the target to all such initiators.\n   Targets\
    \ SHOULD use separate CHAP secrets for authentication to each\n   initiator when\
    \ such risks are of concern; in this situation it may be\n   useful to configure\
    \ a separate logical iSCSI target with its own\n   iSCSI Node Name for each initiator\
    \ or group of initiators among which\n   such separation is desired.\n"
- title: 8.2.2.  SRP Considerations
  contents:
  - "8.2.2.  SRP Considerations\n   The strength of the SRP authentication method\
    \ (specified in\n   [RFC2945]) is dependent on the characteristics of the group\
    \ being\n   used (i.e., the prime modulus N and generator g).  As described in\n\
    \   [RFC2945], N is required to be a Sophie-German prime (of the form\n   N =\
    \ 2q + 1, where q is also prime) and the generator g is a primitive\n   root of\
    \ GF(n).  In iSCSI authentication, the prime modulus N MUST be\n   at least 768\
    \ bits.\n   The list of allowed SRP groups is provided in [RFC3723].\n"
- title: 8.3.  IPsec
  contents:
  - "8.3.  IPsec\n   iSCSI uses the IPsec mechanism for packet protection (cryptographic\n\
    \   integrity, authentication, and confidentiality) at the IP level\n   between\
    \ the iSCSI communicating end points.  The following sections\n   describe the\
    \ IPsec protocols that must be implemented for data\n   integrity and authentication,\
    \ confidentiality, and cryptographic key\n   management.\n   An iSCSI initiator\
    \ or target may provide the required IPsec support\n   fully integrated or in\
    \ conjunction with an IPsec front-end device.\n   In the latter case, the compliance\
    \ requirements with regard to IPsec\n   support apply to the \"combined device\"\
    .  Only the \"combined device\"\n   is to be considered an iSCSI device.\n   Detailed\
    \ considerations and recommendations for using IPsec for iSCSI\n   are provided\
    \ in [RFC3723].\n"
- title: 8.3.1.  Data Integrity and Authentication
  contents:
  - "8.3.1.  Data Integrity and Authentication\n   Data authentication and integrity\
    \ is provided by a cryptographic\n   keyed Message Authentication Code in every\
    \ sent packet.  This code\n   protects against message insertion, deletion, and\
    \ modification.\n   Protection against message replay is realized by using a sequence\n\
    \   counter.\n   An iSCSI compliant initiator or target MUST provide data integrity\n\
    \   and authentication by implementing IPsec [RFC2401] with ESP [RFC2406]\n  \
    \ in tunnel mode and MAY provide data integrity and authentication by\n   implementing\
    \ IPsec with ESP in transport mode.  The IPsec\n   implementation MUST fulfill\
    \ the following iSCSI specific\n   requirements:\n     - HMAC-SHA1 MUST be implemented\
    \ [RFC2404].\n     - AES CBC MAC with XCBC extensions SHOULD be implemented\n\
    \       [RFC3566].\n   The ESP anti-replay service MUST also be implemented.\n\
    \   At the high speeds iSCSI is expected to operate, a single IPsec SA\n   could\
    \ rapidly cycle through the 32-bit IPsec sequence number space.\n   In view of\
    \ this, it may be desirable in the future for an iSCSI\n   implementation that\
    \ operates at speeds of 1 Gbps or greater to\n   implement the IPsec sequence\
    \ number extension [SEQ-EXT].\n"
- title: 8.3.2.  Confidentiality
  contents:
  - "8.3.2.  Confidentiality\n   Confidentiality is provided by encrypting the data\
    \ in every packet.\n   When confidentiality is used it MUST be accompanied by\
    \ data integrity\n   and authentication to provide comprehensive protection against\n\
    \   eavesdropping, message insertion, deletion, modification, and\n   replaying.\n\
    \   An iSCSI compliant initiator or target MUST provide confidentiality\n   by\
    \ implementing IPsec [RFC2401] with ESP [RFC2406] in tunnel mode and\n   MAY provide\
    \ confidentiality by implementing IPsec with ESP in\n   transport mode, with the\
    \ following iSCSI specific requirements:\n     - 3DES in CBC mode MUST be implemented\
    \ [RFC2451].\n     - AES in Counter mode SHOULD be implemented [RFC3686].\n  \
    \ DES in CBC mode SHOULD NOT be used due to its inherent weakness.  The\n   NULL\
    \ encryption algorithm MUST also be implemented.\n"
- title: 8.3.3.  Policy, Security Associations, and Cryptographic Key Management
  contents:
  - "8.3.3.  Policy, Security Associations, and Cryptographic Key Management\n   A\
    \ compliant iSCSI implementation MUST meet the cryptographic key\n   management\
    \ requirements of the IPsec protocol suite.  Authentication,\n   security association\
    \ negotiation, and cryptographic key management\n   MUST be provided by implementing\
    \ IKE [RFC2409] using the IPsec DOI\n   [RFC2407] with the following iSCSI specific\
    \ requirements:\n    -  Peer authentication using a pre-shared cryptographic key\
    \ MUST be\n       supported.  Certificate-based peer authentication using digital\n\
    \       signatures MAY be supported.  Peer authentication using the\n       public\
    \ key encryption methods outlined in IKE sections 5.2 and\n       5.3[7] SHOULD\
    \ NOT be used.\n    -  When digital signatures are used to achieve authentication,\
    \ an\n       IKE negotiator SHOULD use IKE Certificate Request Payload(s) to\n\
    \       specify the certificate authority.  IKE negotiators SHOULD check\n   \
    \    the pertinent Certificate Revocation List (CRL) before accepting\n      \
    \ a PKI certificate for use in IKE authentication procedures.\n    -  Conformant\
    \ iSCSI implementations MUST support IKE Main Mode and\n       SHOULD support\
    \ Aggressive Mode.  IKE main mode with pre-shared\n       key authentication method\
    \ SHOULD NOT be used when either the\n       initiator or the target uses dynamically\
    \ assigned IP addresses.\n       While in many cases pre-shared keys offer good\
    \ security,\n       situations in which dynamically assigned addresses are used\
    \ force\n       the use of a group pre-shared key, which creates vulnerability\
    \ to\n       a man-in-the-middle attack.\n    -  In the IKE Phase 2 Quick Mode,\
    \ exchanges for creating the Phase 2\n       SA, the Identity Payload, fields\
    \ MUST be present.  ID_IPV4_ADDR,\n       ID_IPV6_ADDR (if the protocol stack\
    \ supports IPv6) and ID_FQDN\n       Identity payloads MUST be supported; ID_USER_FQDN\
    \ SHOULD be\n       supported.  The IP Subnet, IP Address Range, ID_DER_ASN1_DN,\
    \ and\n       ID_DER_ASN1_GN formats SHOULD NOT be used.  The ID_KEY_ID\n    \
    \   Identity Payload MUST NOT be used.\n   Manual cryptographic keying MUST NOT\
    \ be used because it does not\n   provide the necessary re-keying support.\n \
    \  When IPsec is used, the receipt of an IKE Phase 2 delete message\n   SHOULD\
    \ NOT be interpreted as a reason for tearing down the iSCSI TCP\n   connection.\
    \  If additional traffic is sent on it, a new IKE Phase 2\n   SA will be created\
    \ to protect it.\n   The method used by the initiator to determine whether the\
    \ target\n   should be connected using IPsec is regarded as an issue of IPsec\n\
    \   policy administration, and thus not defined in the iSCSI standard.\n   If\
    \ an iSCSI target is discovered via a SendTargets request in a\n   discovery session\
    \ not using IPsec, the initiator should assume that\n   it does not need IPsec\
    \ to establish a session to that target.  If an\n   iSCSI target is discovered\
    \ using a discovery session that does use\n   IPsec, the initiator SHOULD use\
    \ IPsec when establishing a session to\n   that target.\n"
- title: 9.  Notes to Implementers
  contents:
  - "9.  Notes to Implementers\n   This section notes some of the performance and\
    \ reliability\n   considerations of the iSCSI protocol.  This protocol was designed\
    \ to\n   allow efficient silicon and software implementations.  The iSCSI task\n\
    \   tag mechanism was designed to enable Direct Data Placement (DDP - a\n   DMA\
    \ form) at the iSCSI level or lower.\n   The guiding assumption made throughout\
    \ the design of this protocol is\n   that targets are resource constrained relative\
    \ to initiators.\n   Implementers are also advised to consider the implementation\n\
    \   consequences of the iSCSI to SCSI mapping model as outlined in\n   Section\
    \ 3.4.3 Consequences of the Model.\n"
- title: 9.1.  Multiple Network Adapters
  contents:
  - "9.1.  Multiple Network Adapters\n   The iSCSI protocol allows multiple connections,\
    \ not all of which need\n   to go over the same network adapter.  If multiple\
    \ network connections\n   are to be utilized with hardware support, the iSCSI\
    \ protocol\n   command-data-status allegiance to one TCP connection ensures that\n\
    \   there is no need to replicate information across network adapters or\n   otherwise\
    \ require them to cooperate.\n   However, some task management commands may require\
    \ some loose form of\n   cooperation or replication at least on the target.\n"
- title: 9.1.1.  Conservative Reuse of ISIDs
  contents:
  - "9.1.1.  Conservative Reuse of ISIDs\n   Historically, the SCSI model (and implementations\
    \ and applications\n   based on that model) has assumed that SCSI ports are static,\
    \ physical\n   entities.  Recent extensions to the SCSI model have taken advantage\n\
    \   of persistent worldwide unique names for these ports.  In iSCSI\n   however,\
    \ the SCSI initiator ports are the endpoints of dynamically\n   created sessions,\
    \ so the presumptions of \"static and physical\" do not\n   apply.  In any case,\
    \ the model clauses (particularly, Section 3.4.2\n   SCSI Architecture Model)\
    \ provide for persistent, reusable names for\n   the iSCSI-type SCSI initiator\
    \ ports even though there does not need\n   to be any physical entity bound to\
    \ these names.\n   To both minimize the disruption of legacy applications and\
    \ to better\n   facilitate the SCSI features that rely on persistent names for\
    \ SCSI\n   ports, iSCSI implementations SHOULD attempt to provide a stable\n \
    \  presentation of SCSI Initiator Ports (both to the upper OS-layers and\n   to\
    \ the targets to which they connect).  This can be achieved in an\n   initiator\
    \ implementation by conservatively reusing ISIDs.  In other\n   words, the same\
    \ ISID should be used in the Login process to multiple\n   target portal groups\
    \ (of the same iSCSI Target or different iSCSI\n   Targets).  The ISID RULE (Section\
    \ 3.4.3 Consequences of the Model)\n   only prohibits reuse to the same target\
    \ portal group.  It does not\n   \"preclude\" reuse to other target portal groups.\
    \  The principle of\n   conservative reuse \"encourages\" reuse to other target\
    \ portal groups.\n   When a SCSI target device sees the same (InitiatorName, ISID)\
    \ pair in\n   different sessions to different target portal groups, it can identify\n\
    \   the underlying SCSI Initiator Port on each session as the same SCSI\n   port.\
    \  In effect, it can recognize multiple paths from the same\n   source.\n"
- title: 9.1.2.  iSCSI Name, ISID, and TPGT Use
  contents:
  - "9.1.2.  iSCSI Name, ISID, and TPGT Use\n   The designers of the iSCSI protocol\
    \ envisioned there being one iSCSI\n   Initiator Node Name per operating system\
    \ image on a machine.  This\n   enables SAN resource configuration and authentication\
    \ schemes based\n   on a  system's identity.  It supports the notion that it should\
    \ be\n   possible to assign access to storage resources based on \"initiator\n\
    \   device\" identity.\n   When there are multiple hardware or software components\
    \ coordinated\n   as a single iSCSI Node, there must be some (logical) entity\
    \ that\n   represents the iSCSI Node that makes the iSCSI Node Name available\
    \ to\n   all components involved in session creation and login.  Similarly,\n\
    \   this entity that represents the iSCSI Node must be able to coordinate\n  \
    \ session identifier resources (ISID for initiators) to enforce both\n   the ISID\
    \ and TSIH RULES (see Section 3.4.3 Consequences of the\n   Model).\n   For targets,\
    \ because of the closed environment, implementation of\n   this entity should\
    \ be straightforward.  However, vendors of iSCSI\n   hardware (e.g., NICs or HBAs)\
    \ intended for targets, SHOULD provide\n   mechanisms for configuration of the\
    \ iSCSI Node Name across the portal\n   groups instantiated by multiple instances\
    \ of these components within\n   a target.\n   However, complex targets making\
    \ use of multiple Target Portal Group\n   Tags may reconfigure them to achieve\
    \ various quality goals.  The\n   initiators have two mechanisms at their disposal\
    \ to discover and/or\n   check reconfiguring targets - the discovery session type\
    \ and a key\n   returned by the target during login to confirm the TPGT.  An\n\
    \   initiator should attempt to \"rediscover\" the target configuration\n   anytime\
    \ a session is terminated unexpectedly.\n   For initiators, in the long term,\
    \ it is expected that operating\n   system vendors will take on the role of this\
    \ entity and provide\n   standard APIs that can inform components of their iSCSI\
    \ Node Name and\n   can configure and/or coordinate ISID allocation, use, and\
    \ reuse.\n   Recognizing that such initiator APIs are not available today, other\n\
    \   implementations of the role of this entity are possible.  For\n   example,\
    \ a human may instantiate the (common) Node name as part of\n   the installation\
    \ process of each iSCSI component involved in session\n   creation and login.\
    \  This may be done either by pointing the\n   component to a vendor-specific\
    \ location for this datum or to a\n   system-wide location.  The structure of\
    \ the ISID namespace (see\n   Section 10.12.5 ISID and [RFC3721]) facilitates\
    \ implementation of the\n   ISID coordination by allowing each component vendor\
    \ to independently\n   (of other vendor's components) coordinate allocation, use,\
    \ and reuse\n   of its own partition of the ISID namespace in a vendor-specific\n\
    \   manner.  Partitioning of the ISID namespace within initiator portal\n   groups\
    \ managed by that vendor allows each such initiator portal group\n   to act independently\
    \ of all other portal groups when selecting an\n   ISID for a login; this facilitates\
    \ enforcement of the ISID RULE (see\n   Section 3.4.3 Consequences of the Model)\
    \ at the initiator.\n   A vendor of iSCSI hardware (e.g., NICs or HBAs) intended\
    \ for use in\n   initiators MUST implement a mechanism for configuring the iSCSI\
    \ Node\n   Name.  Vendors, and administrators must ensure that iSCSI Node Names\n\
    \   are unique worldwide.  It is therefore important that when one\n   chooses\
    \ to reuse the iSCSI Node Name of a disabled unit, not to\n   re-assign that name\
    \ to the original unit unless its worldwide\n   uniqueness can be ascertained\
    \ again.\n   In addition, a vendor of iSCSI hardware must implement a mechanism\
    \ to\n   configure and/or coordinate ISIDs for all sessions managed by\n   multiple\
    \ instances of that hardware within a given iSCSI Node.  Such\n   configuration\
    \ might be either permanently pre-assigned at the factory\n   (in a necessarily\
    \ globally unique way), statically assigned (e.g.,\n   partitioned across all\
    \ the NICs at initialization in a locally unique\n   way), or dynamically assigned\
    \ (e.g., on-line allocator, also in a\n   locally unique way).  In the latter\
    \ two cases, the configuration may\n   be via public APIs (perhaps driven by an\
    \ independent vendor's\n   software, such as the OS vendor) or via private APIs\
    \ driven by the\n   vendor's own software.\n"
- title: 9.2.  Autosense and Auto Contingent Allegiance (ACA)
  contents:
  - "9.2.  Autosense and Auto Contingent Allegiance (ACA)\n   Autosense refers to\
    \ the automatic return of sense data to the\n   initiator in case a command did\
    \ not complete successfully.  iSCSI\n   initiators and targets MUST support and\
    \ use autosense.\n   ACA helps preserve ordered command execution in the presence\
    \ of\n   errors.  As iSCSI can have many commands in-flight between initiator\n\
    \   and target, iSCSI initiators and targets SHOULD support ACA.\n"
- title: 9.3.  iSCSI Timeouts
  contents:
  - "9.3.  iSCSI Timeouts\n   iSCSI recovery actions are often dependent on iSCSI\
    \ time-outs being\n   recognized and acted upon before SCSI time-outs.  Determining\
    \ the\n   right time-outs to use for various iSCSI actions (command\n   acknowledgements\
    \ expected, status acknowledgements, etc.) is very\n   much dependent on infrastructure\
    \ (hardware, links, TCP/IP stack,\n   iSCSI driver).  As a guide, the implementer\
    \ may use an average\n   Nop-Out/Nop-In turnaround delay multiplied by a \"safety\
    \ factor\"\n   (e.g., 4) as a good estimate for the basic delay of the iSCSI stack\n\
    \   for a given connection.  The safety factor should account for the\n   network\
    \ load variability.  For connection teardown the implementer\n   may want to consider\
    \ also the TCP common practice for the given\n   infrastructure.\n   Text negotiations\
    \ MAY also be subject to either time-limits or limits\n   in the number of exchanges.\
    \  Those SHOULD be generous enough to avoid\n   affecting interoperability (e.g.,\
    \ allowing each key to be negotiated\n   on a separate exchange).\n   The relation\
    \ between iSCSI timeouts and SCSI timeouts should also be\n   considered.  SCSI\
    \ timeouts should be longer than iSCSI timeouts plus\n   the time required for\
    \ iSCSI recovery whenever iSCSI recovery is\n   planned.  Alternatively, an implementer\
    \ may choose to interlock iSCSI\n   timeouts and recovery with SCSI timeouts so\
    \ that SCSI recovery will\n   become active only where iSCSI is not planned to,\
    \ or failed to,\n   recover.\n   The implementer may also want to consider the\
    \ interaction between\n   various iSCSI exception events - such as a digest failure\
    \ - and\n   subsequent timeouts.  When iSCSI error recovery is active, a digest\n\
    \   failure is likely to result in discovering a missing command or data\n   PDU.\
    \  In these cases, an implementer may want to lower the timeout\n   values to\
    \ enable faster initiation for recovery procedures.\n"
- title: 9.4.  Command Retry and Cleaning Old Command Instances
  contents:
  - "9.4.  Command Retry and Cleaning Old Command Instances\n   To avoid having old,\
    \ retried command instances appear in a valid\n   command window after a command\
    \ sequence number wrap around, the\n   protocol requires (see Section 3.2.2.1\
    \ Command Numbering and\n   Acknowledging) that on every connection on which a\
    \ retry has been\n   issued, a non-immediate command be issued and acknowledged\
    \ within a\n   2**31-1 commands interval from the CmdSN of the retried command.\n\
    \   This requirement can be fulfilled by an implementation in several\n   ways.\n\
    \   The simplest technique to use is to send a (non-retry) non-immediate\n   SCSI\
    \ command (or a NOP if no SCSI command is available for a while)\n   after every\
    \ command retry on the connection on which the retry was\n   attempted.  As errors\
    \ are deemed rare events, this technique is\n   probably the most effective, as\
    \ it does not involve additional checks\n   at the initiator when issuing commands.\n"
- title: 9.5.  Synch and Steering Layer and Performance
  contents:
  - "9.5.  Synch and Steering Layer and Performance\n   While a synch and steering\
    \ layer is optional, an initiator/target\n   that does not have it working against\
    \ a target/initiator that demands\n   synch and steering may experience performance\
    \ degradation caused by\n   packet reordering and loss.  Providing a synch and\
    \ steering mechanism\n   is recommended for all high-speed implementations.\n"
- title: 9.6.  Considerations for State-dependent Devices and Long-lasting SCSI
  contents:
  - "9.6.  Considerations for State-dependent Devices and Long-lasting SCSI\n    \
    \  Operations\n   Sequential access devices operate on the principle that the\
    \ position\n   of the device is based on the last command processed.  As such,\n\
    \   command processing order and knowledge of whether or not the previous\n  \
    \ command was processed is of the utmost importance to maintain data\n   integrity.\
    \  For example, inadvertent retries of SCSI commands when it\n   is not known\
    \ if the previous SCSI command was processed is a\n   potential data integrity\
    \ risk.\n   For a sequential access device, consider the scenario in which a SCSI\n\
    \   SPACE command to backspace one filemark is issued and then re-issued\n   due\
    \ to no status received for the command.  If the first SPACE\n   command was actually\
    \ processed, the re-issued SPACE command, if\n   processed, will cause the position\
    \ to change.  Thus, a subsequent\n   write operation will write data to the wrong\
    \ position and any\n   previous data at that position will be overwritten.\n \
    \  For a medium changer device, consider the scenario in which an\n   EXCHANGE\
    \ MEDIUM command (the SOURCE ADDRESS and DESTINATION ADDRESS\n   are the same\
    \ thus performing a swap) is issued and then re-issued due\n   to no status received\
    \ for the command.  If the first EXCHANGE MEDIUM\n   command was actually processed,\
    \ the re-issued EXCHANGE MEDIUM\n   command, if processed, will perform the swap\
    \ again.  The net effect\n   is that a swap was not performed thus leaving a data\
    \ integrity\n   exposure.\n   All commands that change the state of the device\
    \ (as in SPACE\n   commands for sequential access devices, and EXCHANGE MEDIUM\
    \ for\n   medium changer device), MUST be issued as non-immediate commands for\n\
    \   deterministic and in order delivery to iSCSI targets.\n   For many of those\
    \ state changing commands, the execution model also\n   assumes that the command\
    \ is executed exactly once.  Devices\n   implementing READ POSITION and LOCATE\
    \ provide a means for SCSI level\n   command recovery and new tape-class  devices\
    \ should support those\n   commands.  In their absence a retry at SCSI level is\
    \ difficult and\n   error recovery at iSCSI level is advisable.\n   Devices operating\
    \ on long latency delivery subsystems and performing\n   long lasting SCSI operations\
    \ may need mechanisms that enable\n   connection replacement while commands are\
    \ running (e.g., during an\n   extended copy operation).\n"
- title: 9.6.1.  Determining the Proper ErrorRecoveryLevel
  contents:
  - "9.6.1.  Determining the Proper ErrorRecoveryLevel\n   The implementation and\
    \ use of a specific ErrorRecoveryLevel should be\n   determined based on the deployment\
    \ scenarios of a given iSCSI\n   implementation.  Generally, the following factors\
    \ must be considered\n   before deciding on the proper level of recovery:\n  \
    \    a)  Application resilience to I/O failures.\n      b)  Required level of\
    \ availability in the face of transport\n          connection failures.\n    \
    \  c)  Probability of transport layer \"checksum escape\".  This in\n        \
    \  turn decides the iSCSI digest failure frequency, and thus the\n          criticality\
    \ of iSCSI-level error recovery.  The details of\n          estimating this probability\
    \ are outside the scope of this\n          document.\n   A consideration of the\
    \ above factors for SCSI tape devices as an\n   example suggests that implementations\
    \ SHOULD use ErrorRecoveryLevel=1\n   when transport connection failure is not\
    \ a concern and SCSI level\n   recovery is unavailable, and ErrorRecoveryLevel=2\
    \ when the connection\n   failure is also of high likelihood during a backup/retrieval.\n\
    \   For extended copy operations, implementations SHOULD use\n   ErrorRecoveryLevel=2\
    \ whenever there is a relatively high likelihood\n   of connection failure.\n"
- title: 10.  iSCSI PDU Formats
  contents:
  - "10.  iSCSI PDU Formats\n   All multi-byte integers that are specified in formats\
    \ defined in this\n   document are to be represented in network byte order (i.e.,\
    \ big\n   endian).  Any field that appears in this document assumes that the\n\
    \   most significant byte is the lowest numbered byte and the most\n   significant\
    \ bit (within byte or field) is the lowest numbered bit\n   unless specified otherwise.\n\
    \   Any compliant sender MUST set all bits not defined and all reserved\n   fields\
    \ to zero unless specified otherwise.  Any compliant receiver\n   MUST ignore\
    \ any bit not defined and all reserved fields unless\n   specified otherwise.\
    \  Receipt of reserved code values in defined\n   fields MUST be reported as a\
    \ protocol error.\n   Reserved fields are marked by the word \"reserved\", some\
    \ abbreviation\n   of \"reserved\", or by \".\" for individual bits when no other\
    \ form of\n   marking is technically feasible.\n"
- title: 10.1.  iSCSI PDU Length and Padding
  contents:
  - "10.1.  iSCSI PDU Length and Padding\n   iSCSI PDUs are padded to the closest\
    \ integer number of four byte\n   words.  The padding bytes SHOULD be sent as\
    \ 0.\n"
- title: 10.2.  PDU Template, Header, and Opcodes
  contents:
  - "10.2.  PDU Template, Header, and Opcodes\n   All iSCSI PDUs have one or more\
    \ header segments and, optionally, a\n   data segment.  After the entire header\
    \ segment group a header-digest\n   MAY follow.  The data segment MAY also be\
    \ followed by a data-digest.\n   The Basic Header Segment (BHS) is the first segment\
    \ in all of the\n   iSCSI PDUs.  The BHS is a fixed-length 48-byte header segment.\
    \  It\n   MAY be followed by Additional Header Segments (AHS), a Header-Digest,\n\
    \   a Data Segment, and/or a Data-Digest.\n   The overall structure of an iSCSI\
    \  PDU is as follows:\n   Byte/     0       |       1       |       2       |\
    \       3       |\n      /              |               |               |    \
    \           |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4\
    \ 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0/ Basic Header Segment (BHS)                                    /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48/ Additional Header Segment 1 (AHS)  (optional)                 /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     / Additional Header Segment 2 (AHS)  (optional)                 /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   ----\n     +---------------+---------------+---------------+---------------+\n\
    \     / Additional Header Segment n (AHS)  (optional)                 /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   ----\n     +---------------+---------------+---------------+---------------+\n\
    \    k/ Header-Digest (optional)                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \    l/ Data Segment(optional)                                        /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \    m/ Data-Digest (optional)                                        /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   All PDU segments and digests are padded to the closest integer number\n  \
    \ of four byte words.  For example, all PDU segments and digests start\n   at\
    \ a four byte word boundary and the padding ranges from 0 to 3\n   bytes.  The\
    \ padding bytes SHOULD be sent as 0.\n   iSCSI response PDUs do not have AH Segments.\n"
- title: 10.2.1.  Basic Header Segment (BHS)
  contents:
  - "10.2.1.  Basic Header Segment (BHS)\n   The BHS is 48 bytes long.  The Opcode\
    \ and DataSegmentLength fields\n   appear in all iSCSI PDUs.  In addition, when\
    \ used, the Initiator Task\n   Tag and Logical Unit Number always appear in the\
    \ same location in the\n   header.\n   The format of the BHS is:\n   Byte/   \
    \  0       |       1       |       2       |       3       |\n      /        \
    \      |               |               |               |\n     |0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|I| Opcode    |F|  Opcode-specific fields                     |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Opcode-specific fields                                 |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20/ Opcode-specific\
    \ fields                                        /\n    +/                    \
    \                                           /\n     +---------------+---------------+---------------+---------------+\n\
    \   48\n"
- title: 10.2.1.1  I
  contents:
  - "10.2.1.1  I\n   For request PDUs, the I bit set to 1 is an immediate delivery\
    \ marker.\n"
- title: 10.2.1.2.  Opcode
  contents:
  - "10.2.1.2.  Opcode\n   The Opcode indicates the type of iSCSI PDU the header encapsulates.\n\
    \   The Opcodes are divided into two categories: initiator opcodes and\n   target\
    \ opcodes.  Initiator opcodes are in PDUs sent by the initiator\n   (request PDUs).\
    \  Target opcodes are in PDUs sent by the target\n   (response PDUs).\n   Initiators\
    \ MUST NOT use target opcodes and targets MUST NOT use\n   initiator opcodes.\n\
    \   Initiator opcodes defined in this specification are:\n     0x00 NOP-Out\n\
    \     0x01 SCSI Command (encapsulates a SCSI Command Descriptor Block)\n     0x02\
    \ SCSI Task Management function request\n     0x03 Login Request\n     0x04 Text\
    \ Request\n     0x05 SCSI Data-Out (for WRITE operations)\n     0x06 Logout Request\n\
    \     0x10 SNACK Request\n     0x1c-0x1e Vendor specific codes\n   Target opcodes\
    \ are:\n     0x20 NOP-In\n     0x21 SCSI Response - contains SCSI status and possibly\
    \ sense\n      information or other response information.\n     0x22 SCSI Task\
    \ Management function response\n     0x23 Login Response\n     0x24 Text Response\n\
    \     0x25 SCSI Data-In - for READ operations.\n     0x26 Logout Response\n  \
    \   0x31 Ready To Transfer (R2T) - sent by target when it is ready\n      to receive\
    \ data.\n     0x32 Asynchronous Message - sent by target to indicate certain\n\
    \      special conditions.\n     0x3c-0x3e Vendor specific codes\n     0x3f Reject\n\
    \   All other opcodes are reserved.\n"
- title: 10.2.1.3.  Final (F) bit
  contents:
  - "10.2.1.3.  Final (F) bit\n   When set to 1 it indicates the final (or only) PDU\
    \ of a sequence.\n"
- title: 10.2.1.4.  Opcode-specific Fields
  contents:
  - "10.2.1.4.  Opcode-specific Fields\n   These fields have different meanings for\
    \ different opcode types.\n"
- title: 10.2.1.5.  TotalAHSLength
  contents:
  - "10.2.1.5.  TotalAHSLength\n   Total length of all AHS header segments in units\
    \ of four byte words\n   including padding, if any.\n   The TotalAHSLength is\
    \ only used in PDUs that have an AHS and MUST be\n   0 in all other PDUs.\n"
- title: 10.2.1.6.  DataSegmentLength
  contents:
  - "10.2.1.6.  DataSegmentLength\n   This is the data segment payload length in bytes\
    \ (excluding padding).\n   The DataSegmentLength MUST be 0 whenever the PDU has\
    \ no data segment.\n"
- title: 10.2.1.7.  LUN
  contents:
  - "10.2.1.7.  LUN\n   Some opcodes operate on a specific Logical Unit.  The Logical\
    \ Unit\n   Number (LUN) field identifies which Logical Unit.  If the opcode does\n\
    \   not relate to a Logical Unit, this field is either ignored or may be\n   used\
    \ in an opcode specific way.  The LUN field is 64-bits and should\n   be formatted\
    \ in accordance with [SAM2].  For example, LUN[0] from\n   [SAM2] is BHS byte\
    \ 8 and so on up to LUN[7] from [SAM2], which is BHS\n   byte 15.\n"
- title: 10.2.1.8.  Initiator Task Tag
  contents:
  - "10.2.1.8.  Initiator Task Tag\n   The initiator assigns a Task Tag to each iSCSI\
    \ task it issues.  While\n   a task exists, this tag MUST uniquely identify the\
    \ task session-wide.\n   SCSI may also use the initiator task tag as part of the\
    \ SCSI task\n   identifier when the timespan during which an iSCSI initiator task\
    \ tag\n   must be unique extends over the timespan during which a SCSI task tag\n\
    \   must be unique.  However, the iSCSI Initiator Task Tag must exist and\n  \
    \ be unique even for untagged SCSI commands.\n"
- title: 10.2.2.  Additional Header Segment (AHS)
  contents:
  - "10.2.2.  Additional Header Segment (AHS)\n   The general format of an AHS is:\n\
    \   Byte/     0       |       1       |       2       |       3       |\n    \
    \  /              |               |               |               |\n     |0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0| AHSLength                     | AHSType       | AHS-Specific  |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4/ AHS-Specific\
    \                                                  /\n    +/                 \
    \                                              /\n     +---------------+---------------+---------------+---------------+\n\
    \    x\n"
- title: 10.2.2.1.  AHSType
  contents:
  - "10.2.2.1.  AHSType\n   The AHSType field is coded as follows:\n       bit 0-1\
    \ - Reserved\n       bit 2-7 - AHS code\n        0 - Reserved\n        1 - Extended\
    \ CDB\n        2 - Expected Bidirectional Read Data Length\n        3 - 63 Reserved\n"
- title: 10.2.2.2.  AHSLength
  contents:
  - "10.2.2.2.  AHSLength\n   This field contains the effective length in bytes of\
    \ the AHS\n   excluding AHSType and AHSLength and padding, if any.  The AHS is\n\
    \   padded to the smallest integer number of 4 byte words (i.e., from 0\n   up\
    \ to 3 padding bytes).\n"
- title: 10.2.2.3.  Extended CDB AHS
  contents:
  - "10.2.2.3.  Extended CDB AHS\n   The format of the Extended CDB AHS is:\n   Byte/\
    \     0       |       1       |       2       |       3       |\n      /     \
    \         |               |               |               |\n     |0 1 2 3 4 5\
    \ 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0| AHSLength (CDBLength-15)      | 0x01          | Reserved      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4/ ExtendedCDB...+padding\
    \                                        /\n    +/                           \
    \                                    /\n     +---------------+---------------+---------------+---------------+\n\
    \    x\n   This type of AHS MUST NOT be used if the CDBLength is less than 17.\n\
    \   The length includes the reserved byte 3.\n"
- title: 10.2.2.4.  Bidirectional Expected Read-Data Length AHS
  contents:
  - "10.2.2.4.  Bidirectional Expected Read-Data Length AHS\n   The format of the\
    \ Bidirectional Read Expected Data Transfer Length\n   AHS is:\n   Byte/     0\
    \       |       1       |       2       |       3       |\n      /           \
    \   |               |               |               |\n     |0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0| AHSLength (0x0005)            | 0x02          | Reserved      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4| Expected\
    \ Read-Data Length                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \    8\n"
- title: 10.2.3.  Header Digest and Data Digest
  contents:
  - "10.2.3.  Header Digest and Data Digest\n   Optional header and data digests protect\
    \ the integrity of the header\n   and data, respectively.  The digests, if present,\
    \ are located,\n   respectively, after the header and PDU-specific data, and cover\n\
    \   respectively the header and the PDU data, each including the padding\n   bytes,\
    \ if any.\n   The existence and type of digests are negotiated during the Login\n\
    \   Phase.\n   The separation of the header and data digests is useful in iSCSI\n\
    \   routing applications, in which only the header changes when a message\n  \
    \ is forwarded.  In this case, only the header digest should be\n   recalculated.\n\
    \   Digests are not included in data or header length fields.\n   A zero-length\
    \ Data Segment also implies a zero-length data-digest.\n"
- title: 10.2.4.  Data Segment
  contents:
  - "10.2.4.  Data Segment\n   The (optional) Data Segment contains PDU associated\
    \ data.  Its\n   payload effective length is provided in the BHS field -\n   DataSegmentLength.\
    \  The Data Segment is also padded to an integer\n   number of 4 byte words.\n"
- title: 10.3.  SCSI Command
  contents:
  - "10.3.  SCSI Command\n   The format of the SCSI Command PDU is:\n   Byte/    \
    \ 0       |       1       |       2       |       3       |\n      /         \
    \     |               |               |               |\n     |0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|I| 0x01      |F|R|W|. .|ATTR | Reserved                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| Logical Unit Number (LUN)                                     |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Expected\
    \ Data Transfer Length                                 |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| CmdSN                                                         |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \                                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32/ SCSI Command Descriptor Block (CDB)                           /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48/ AHS (Optional)                                                /\n    \
    \ +---------------+---------------+---------------+---------------+\n    x/ Header\
    \ Digest (Optional)                                      /\n     +---------------+---------------+---------------+---------------+\n\
    \    y/ (DataSegment, Command Data) (Optional)                        /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \    z/ Data Digest (Optional)                                        /\n    \
    \ +---------------+---------------+---------------+---------------+\n"
- title: 10.3.1.  Flags and Task Attributes (byte 1)
  contents:
  - "10.3.1.  Flags and Task Attributes (byte 1)\n   The flags for a SCSI Command\
    \ are:\n   bit 0   (F) is set to 1 when no unsolicited SCSI Data-Out PDUs follow\n\
    \            this PDU.  When F=1 for a write and if Expected Data\n          \
    \  Transfer Length is larger than the DataSegmentLength, the\n            target\
    \ may solicit additional data through R2T.\n   bit 1   (R) is set to 1 when the\
    \ command is expected to input data.\n   bit 2   (W) is set to 1 when the command\
    \ is expected to output data.\n   bit 3-4 Reserved.\n   bit 5-7 contains Task\
    \ Attributes.\n   Task Attributes (ATTR) have one of the following integer values\
    \ (see\n   [SAM2] for details):\n     0 - Untagged\n     1 - Simple\n     2 -\
    \ Ordered\n     3 - Head of Queue\n     4 - ACA\n     5-7 - Reserved\n   Setting\
    \ both the W and the F bit to 0 is an error.  Either or both of\n   R and W MAY\
    \ be 1 when either the Expected Data Transfer Length and/or\n   Bidirectional\
    \ Read Expected Data Transfer Length are 0, but they MUST\n   NOT both be 0 when\
    \ the Expected Data Transfer Length and/or\n   Bidirectional Read Expected Data\
    \ Transfer Length are not 0 (i.e.,\n   when some data transfer is expected the\
    \ transfer direction is\n   indicated by the R and/or W bit).\n"
- title: 10.3.2.  CmdSN - Command Sequence Number
  contents:
  - "10.3.2.  CmdSN - Command Sequence Number\n   Enables ordered delivery across\
    \ multiple connections in a single\n   session.\n"
- title: 10.3.3.  ExpStatSN
  contents:
  - "10.3.3.  ExpStatSN\n   Command responses up to ExpStatSN-1 (mod 2**32) have been\
    \ received\n   (acknowledges status) on the connection.\n"
- title: 10.3.4.  Expected Data Transfer Length
  contents:
  - "10.3.4.  Expected Data Transfer Length\n   For unidirectional operations, the\
    \ Expected Data Transfer Length\n   field contains the number of bytes of data\
    \ involved in this SCSI\n   operation.  For a unidirectional write operation (W\
    \ flag set to 1 and\n   R flag set to 0), the initiator uses this field to specify\
    \ the number\n   of bytes of data it expects to transfer for this operation. \
    \ For a\n   unidirectional read operation (W flag set to 0 and R flag set to 1),\n\
    \   the initiator uses this field to specify the number of bytes of data\n   it\
    \ expects the target to transfer to the initiator.  It corresponds\n   to the\
    \ SAM2 byte count.\n   For bidirectional operations (both R and W flags are set\
    \ to 1), this\n   field contains the number of data bytes involved in the write\n\
    \   transfer.  For bidirectional operations, an additional header segment\n  \
    \ MUST be present in the header sequence that indicates the\n   Bidirectional\
    \ Read Expected Data Transfer Length.  The Expected Data\n   Transfer Length field\
    \ and the Bidirectional Read Expected Data\n   Transfer Length field correspond\
    \ to the SAM2 byte count\n   If the Expected Data Transfer Length for a write\
    \ and the length of\n   the immediate data part that follows the command (if any)\
    \ are the\n   same, then no more data PDUs are expected to follow.  In this case,\n\
    \   the F bit MUST be set to 1.\n   If the Expected Data Transfer Length is higher\
    \ than the\n   FirstBurstLength (the negotiated maximum amount of unsolicited\
    \ data\n   the target will accept), the initiator MUST send the maximum amount\n\
    \   of unsolicited data OR ONLY the immediate data, if any.\n   Upon completion\
    \ of a data transfer, the target informs the initiator\n   (through residual counts)\
    \ of how many bytes were actually processed\n   (sent and/or received) by the\
    \ target.\n"
- title: 10.3.5.  CDB - SCSI Command Descriptor Block
  contents:
  - "10.3.5.  CDB - SCSI Command Descriptor Block\n   There are 16 bytes in the CDB\
    \ field to accommodate the commonly used\n   CDBs.  Whenever the CDB is larger\
    \ than 16 bytes, an Extended CDB AHS\n   MUST be used to contain the CDB spillover.\n"
- title: 10.3.6.  Data Segment - Command Data
  contents:
  - "10.3.6.  Data Segment - Command Data\n   Some SCSI commands require additional\
    \ parameter data to accompany the\n   SCSI command.  This data may be placed beyond\
    \ the boundary of the\n   iSCSI header in a data segment.  Alternatively, user\
    \ data (e.g., from\n   a WRITE operation) can be placed in the data segment (both\
    \ cases are\n   referred to as immediate data).  These data are governed by the\
    \ rules\n   for solicited vs. unsolicited data outlined in Section 3.2.4.2 Data\n\
    \   Transfer Overview.\n"
- title: 10.4.  SCSI Response
  contents:
  - "10.4.  SCSI Response\n   The format of the SCSI Response PDU is:\n   Byte/  \
    \   0       |       1       |       2       |       3       |\n      /       \
    \       |               |               |               |\n     |0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x21      |1|. .|o|u|O|U|.| Response      | Status        |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| Reserved                                                      |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| SNACK\
    \ Tag or Reserved                                         |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| ExpDataSN\
    \ or Reserved                                         |\n     +---------------+---------------+---------------+---------------+\n\
    \   40| Bidirectional Read Residual Count or Reserved                 |\n    \
    \ +---------------+---------------+---------------+---------------+\n   44| Residual\
    \ Count or Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / Data\
    \ Segment (Optional)                                       /\n    +/         \
    \                                                      /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n"
- title: 10.4.1.  Flags (byte 1)
  contents:
  - "10.4.1.  Flags (byte 1)\n     bit 1-2 Reserved.\n     bit 3 - (o) set for Bidirectional\
    \ Read Residual Overflow.  In this\n       case, the Bidirectional Read Residual\
    \ Count indicates the number\n       of bytes that were not transferred to the\
    \ initiator because the\n       initiator's Expected Bidirectional Read Data Transfer\
    \ Length was\n       not sufficient.\n     bit 4 - (u) set for Bidirectional Read\
    \ Residual Underflow.  In this\n       case, the Bidirectional Read Residual Count\
    \ indicates the number\n       of bytes that were not transferred to the initiator\
    \ out of the\n       number of bytes expected to be transferred.\n     bit 5 -\
    \ (O) set for Residual Overflow.  In this case, the Residual\n       Count indicates\
    \ the number of bytes that were not transferred\n       because the initiator's\
    \ Expected Data Transfer Length was not\n       sufficient.  For a bidirectional\
    \ operation, the Residual Count\n       contains the residual for the write operation.\n\
    \     bit 6 - (U) set for Residual Underflow.  In this case, the Residual\n  \
    \     Count indicates the number of bytes that were not transferred out\n    \
    \   of the number of bytes that were expected to be transferred.  For\n      \
    \ a bidirectional operation, the Residual Count contains the\n       residual\
    \ for the write operation.\n     bit 7 - (0) Reserved.\n   Bits O and U and bits\
    \ o and u are mutually exclusive (i.e., having\n   both o and u or O and U set\
    \ to 1 is a protocol error).  For a\n   response other than \"Command Completed\
    \ at Target\", bits 3-6 MUST be\n   0.\n"
- title: 10.4.2.  Status
  contents:
  - "10.4.2.  Status\n   The Status field is used to report the SCSI status of the\
    \ command (as\n   specified in [SAM2]) and is only valid if the Response Code\
    \ is\n   Command Completed at target.\n   Some of the status codes defined in\
    \ [SAM2] are:\n     0x00 GOOD\n     0x02 CHECK CONDITION\n     0x08 BUSY\n   \
    \  0x18 RESERVATION CONFLICT\n     0x28 TASK SET FULL\n     0x30 ACA ACTIVE\n\
    \     0x40 TASK ABORTED\n   See [SAM2] for the complete list and definitions.\n\
    \   If a SCSI device error is detected while data from the initiator is\n   still\
    \ expected (the command PDU did not contain all the data and the\n   target has\
    \ not received a Data PDU with the final bit Set), the\n   target MUST wait until\
    \ it receives a Data PDU with the F bit set in\n   the last expected sequence\
    \ before sending the Response PDU.\n"
- title: 10.4.3.  Response
  contents:
  - "10.4.3.  Response\n   This field contains the iSCSI service response.\n   iSCSI\
    \ service response codes defined in this specification are:\n     0x00 - Command\
    \ Completed at Target\n     0x01 - Target Failure\n     0x80-0xff - Vendor specific\n\
    \   All other response codes are reserved.\n   The Response is used to report\
    \ a Service Response.  The mapping of\n   the response code into a SCSI service\
    \ response code value, if needed,\n   is outside the scope of this document. \
    \ However, in symbolic terms\n   response value 0x00 maps to the SCSI service\
    \ response (see [SAM2] and\n   [SPC3]) of TASK COMPLETE or LINKED COMMAND COMPLETE.\
    \  All other\n   Response values map to the SCSI service response of SERVICE DELIVERY\n\
    \   OR TARGET FAILURE.\n   If a PDU that includes SCSI status (Response PDU or\
    \ Data-In PDU\n   including status) does not arrive before the session is terminated,\n\
    \   the SCSI service response is SERVICE DELIVERY OR TARGET FAILURE.\n   A non-zero\
    \ Response field indicates a failure to execute the command\n   in which case\
    \ the Status and Flag fields are undefined.\n"
- title: 10.4.4.  SNACK Tag
  contents:
  - "10.4.4.  SNACK Tag\n   This field contains a copy of the SNACK Tag of the last\
    \ SNACK Tag\n   accepted by the target on the same connection and for the command\
    \ for\n   which the response is issued.  Otherwise it is reserved and should be\n\
    \   set to 0.\n   After issuing a R-Data SNACK the initiator must discard any\
    \ SCSI\n   status unless contained in an SCSI Response PDU carrying the same\n\
    \   SNACK Tag as the last issued R-Data SNACK for the SCSI command on the\n  \
    \ current connection.\n   For a detailed discussion on R-Data SNACK see Section\
    \ 10.16 SNACK\n   Request.\n"
- title: 10.4.5.  Residual Count
  contents:
  - "10.4.5.  Residual Count\n   The Residual Count field MUST be valid in the case\
    \ where either the U\n   bit or the O bit is set.  If neither bit is set, the\
    \ Residual Count\n   field is reserved.  Targets may set the residual count and\
    \ initiators\n   may use it when the response code is \"completed at target\"\
    \ (even if\n   the status returned is not GOOD).  If the O bit is set, the Residual\n\
    \   Count indicates the number of bytes that were not transferred because\n  \
    \ the initiator's Expected Data Transfer Length was not sufficient.  If\n   the\
    \ U bit is set, the Residual Count indicates the number of bytes\n   that were\
    \ not transferred out of the number of bytes expected to be\n   transferred.\n"
- title: 10.4.6.  Bidirectional Read Residual Count
  contents:
  - "10.4.6.  Bidirectional Read Residual Count\n   The Bidirectional Read Residual\
    \ Count field MUST be valid in the case\n   where either the u bit or the o bit\
    \ is set.  If neither bit is set,\n   the Bidirectional Read Residual Count field\
    \ is reserved.  Targets may\n   set the Bidirectional Read Residual Count and\
    \ initiators may use it\n   when the response code is \"completed at target\"\
    .  If the o bit is\n   set, the Bidirectional Read Residual Count indicates the\
    \ number of\n   bytes that were not transferred to the initiator because the\n\
    \   initiator's Expected Bidirectional Read Transfer Length was not\n   sufficient.\
    \  If the u bit is set, the Bidirectional Read Residual\n   Count indicates the\
    \ number of bytes that were not transferred to the\n   initiator out of the number\
    \ of bytes expected to be transferred.\n"
- title: 10.4.7.  Data Segment - Sense and Response Data Segment
  contents:
  - "10.4.7.  Data Segment - Sense and Response Data Segment\n   iSCSI targets MUST\
    \ support and enable autosense.  If Status is CHECK\n   CONDITION (0x02), then\
    \ the Data Segment MUST contain sense data for\n   the failed command.\n   For\
    \ some iSCSI responses, the response data segment MAY contain some\n   response\
    \ related information, (e.g., for a target failure, it may\n   contain a vendor\
    \ specific detailed description of the failure).\n   If the DataSegmentLength\
    \ is not 0, the format of the Data Segment is\n   as follows:\n   Byte/     0\
    \       |       1       |       2       |       3       |\n      /           \
    \   |               |               |               |\n     |0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|SenseLength                    | Sense Data                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n    x/ Sense\
    \ Data                                                    /\n     +---------------+---------------+---------------+---------------+\n\
    \    y/ Response Data                                                 /\n    \
    \ /                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \    z|\n"
- title: 10.4.7.1.  SenseLength
  contents:
  - "10.4.7.1.  SenseLength\n   Length of Sense Data.\n"
- title: 10.4.7.2.  Sense Data
  contents:
  - "10.4.7.2.  Sense Data\n   The Sense Data contains detailed information about\
    \ a check condition\n   and [SPC3] specifies the format and content of the Sense\
    \ Data.\n   Certain iSCSI conditions result in the command being terminated at\n\
    \   the target (response Command Completed at Target) with a SCSI Check\n   Condition\
    \ Status as outlined in the next table:\n   +--------------------------+----------+---------------------------+\n\
    \   | iSCSI Condition          |Sense     | Additional Sense Code &   |\n   |\
    \                          |Key       | Qualifier                 |\n   +--------------------------+----------+---------------------------+\n\
    \   | Unexpected unsolicited   |Aborted   | ASC = 0x0c ASCQ = 0x0c    |\n   |\
    \ data                     |Command-0B| Write Error               |\n   +--------------------------+----------+---------------------------+\n\
    \   | Incorrect amount of data |Aborted   | ASC = 0x0c ASCQ = 0x0d    |\n   |\
    \                          |Command-0B| Write Error               |\n   +--------------------------+----------+---------------------------+\n\
    \   | Protocol Service CRC     |Aborted   | ASC = 0x47 ASCQ = 0x05    |\n   |\
    \ error                    |Command-0B| CRC Error Detected        |\n   +--------------------------+----------+---------------------------+\n\
    \   | SNACK rejected           |Aborted   | ASC = 0x11 ASCQ = 0x13    |\n   |\
    \                          |Command-0B| Read Error                |\n   +--------------------------+----------+---------------------------+\n\
    \   The target reports the \"Incorrect amount of data\" condition if during\n\
    \   data output the total data length to output is greater than\n   FirstBurstLength\
    \ and the initiator sent unsolicited non-immediate\n   data but the total amount\
    \ of unsolicited data is different than\n   FirstBurstLength.  The target reports\
    \ the same error when the amount\n   of data sent as a reply to an R2T does not\
    \ match the amount\n   requested.\n"
- title: 10.4.8.  ExpDataSN
  contents:
  - "10.4.8.  ExpDataSN\n   The number of R2T and Data-In (read) PDUs the target has\
    \ sent for the\n   command.\n   This field MUST be 0 if the response code is not\
    \ Command Completed at\n   Target or the target sent no Data-In PDUs for the command.\n"
- title: 10.4.9.  StatSN - Status Sequence Number
  contents:
  - "10.4.9.  StatSN - Status Sequence Number\n   StatSN is a Sequence Number that\
    \ the target iSCSI layer generates per\n   connection and that in turn, enables\
    \ the initiator to acknowledge\n   status reception.  StatSN is incremented by\
    \ 1 for every\n   response/status sent on a connection except for responses sent\
    \ as a\n   result of a retry or SNACK.  In the case of responses sent due to a\n\
    \   retransmission request, the StatSN MUST be the same as the first time\n  \
    \ the PDU was sent unless the connection has since been restarted.\n"
- title: 10.4.10.  ExpCmdSN - Next Expected CmdSN from this Initiator
  contents:
  - "10.4.10.  ExpCmdSN - Next Expected CmdSN from this Initiator\n   ExpCmdSN is\
    \ a Sequence Number that the target iSCSI returns to the\n   initiator to acknowledge\
    \ command reception.  It is used to update a\n   local variable with the same\
    \ name.  An ExpCmdSN equal to MaxCmdSN+1\n   indicates that the target cannot\
    \ accept new commands.\n"
- title: 10.4.11.  MaxCmdSN - Maximum CmdSN from this Initiator
  contents:
  - "10.4.11.  MaxCmdSN - Maximum CmdSN from this Initiator\n   MaxCmdSN is a Sequence\
    \ Number that the target iSCSI returns to the\n   initiator to indicate the maximum\
    \ CmdSN the initiator can send.  It\n   is used to update a local variable with\
    \ the same name.  If MaxCmdSN\n   is equal to ExpCmdSN-1, this indicates to the\
    \ initiator that the\n   target cannot receive any additional commands.  When\
    \ MaxCmdSN changes\n   at the target while the target has no pending PDUs to convey\
    \ this\n   information to the initiator, it MUST generate a NOP-IN to carry the\n\
    \   new MaxCmdSN.\n"
- title: 10.5.  Task Management Function Request
  contents:
  - "10.5.  Task Management Function Request\n   Byte/     0       |       1     \
    \  |       2       |       3       |\n      /              |               | \
    \              |               |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|I| 0x02      |1| Function    | Reserved                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| Logical Unit Number (LUN) or Reserved                         |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Referenced\
    \ Task Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| CmdSN                                                         |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \                                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| RefCmdSN or Reserved                                          |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| ExpDataSN\
    \ or Reserved                                         |\n     +---------------+---------------+---------------+---------------+\n\
    \   40/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n"
- title: 10.5.1.  Function
  contents:
  - "10.5.1.  Function\n   The Task Management functions provide an initiator with\
    \ a way to\n   explicitly control the execution of one or more Tasks (SCSI and\
    \ iSCSI\n   tasks).  The Task Management function codes are listed below.  For\
    \ a\n   more detailed description of SCSI task management, see [SAM2].\n   1 -\
    \  ABORT TASK - aborts the task identified by the Referenced Task\n        Tag\
    \ field.\n   2 -  ABORT TASK SET - aborts all Tasks issued via this session on\
    \ the\n        logical unit.\n   3 -  CLEAR ACA - clears the Auto Contingent Allegiance\
    \ condition.\n   4 -  CLEAR TASK SET - aborts all Tasks in the appropriate task\
    \ set as\n        defined by the TST field in the Control mode page (see [SPC3]).\n\
    \   5 -  LOGICAL UNIT RESET\n   6 -  TARGET WARM RESET\n   7 -  TARGET COLD RESET\n\
    \   8 -  TASK REASSIGN - reassigns connection allegiance for the task\n      \
    \  identified by the Referenced Task Tag field to this connection,\n        thus\
    \ resuming the iSCSI exchanges for the task.\n   For all these functions, the\
    \ Task Management function response MUST\n   be returned as detailed in Section\
    \ 10.6 Task Management Function\n   Response.  All these functions apply to the\
    \ referenced tasks\n   regardless of whether they are proper SCSI tasks or tagged\
    \ iSCSI\n   operations.  Task management requests must act on all the commands\n\
    \   from the same session having a CmdSN lower than the task management\n   CmdSN.\
    \  LOGICAL UNIT RESET, TARGET WARM RESET and TARGET COLD RESET\n   may affect\
    \ commands from other sessions or commands from the same\n   session with CmdSN\
    \ equal or exceeding CmdSN.\n   If the task management request is marked for immediate\
    \ delivery, it\n   must be considered immediately for execution, but the operations\n\
    \   involved (all or part of them) may be postponed to allow the target\n   to\
    \ receive all relevant tasks.  According to [SAM2], for all the\n   tasks covered\
    \ by the Task Management response (i.e., with CmdSN lower\n   than the task management\
    \ command CmdSN) but except the Task\n   Management response to a TASK REASSIGN,\
    \ additional responses MUST NOT\n   be delivered to the SCSI layer after the Task\
    \ Management response.\n   The iSCSI initiator MAY deliver to the SCSI layer all\
    \ responses\n   received before the Task Management response (i.e., it is a matter\
    \ of\n   implementation if the SCSI responses, received before the Task\n   Management\
    \ response but after the task management request was issued,\n   are delivered\
    \ to the SCSI layer by the iSCSI layer in the initiator).\n   The iSCSI target\
    \ MUST ensure that no responses for the tasks covered\n   by a task management\
    \ function are delivered to the iSCSI initiator\n   after the Task Management\
    \ response except for a task covered by a\n   TASK REASSIGN.\n   For ABORT TASK\
    \ SET and CLEAR TASK SET, the issuing initiator MUST\n   continue to respond to\
    \ all valid target transfer tags (received via\n   R2T, Text Response, NOP-In,\
    \ or SCSI Data-In PDUs) related to the\n   affected task set, even after issuing\
    \ the task management request.\n   The issuing initiator SHOULD however terminate\
    \ (i.e., by setting the\n   F-bit to 1) these response sequences as quickly as\
    \ possible.  The\n   target on its part MUST wait for responses on all affected\
    \ target\n   transfer tags before acting on either of these two task management\n\
    \   requests.  In case all or part of the response sequence is not\n   received\
    \ (due to digest errors) for a valid TTT, the target MAY treat\n   it as a case\
    \ of within-command error recovery class (see Section\n   6.1.4.1 Recovery Within-command)\
    \ if it is supporting\n   ErrorRecoveryLevel >= 1, or alternatively may drop the\
    \ connection to\n   complete the requested task set function.\n   If an ABORT\
    \ TASK is issued for a task created by an immediate command\n   then RefCmdSN\
    \ MUST be that of the Task Management request itself\n   (i.e., CmdSN and RefCmdSN\
    \ are equal); otherwise RefCmdSN MUST be set\n   to the CmdSN of the task to be\
    \ aborted (lower than CmdSN).\n   If the connection is still active (it is not\
    \ undergoing an implicit\n   or explicit logout), ABORT TASK MUST be issued on\
    \ the same connection\n   to which the task to be aborted is allegiant at the\
    \ time the Task\n   Management Request is issued.  If the connection is implicitly\
    \ or\n   explicitly logged out (i.e., no other request will be issued on the\n\
    \   failing connection and no other response will be received on the\n   failing\
    \ connection), then an ABORT TASK function request may be\n   issued on another\
    \ connection.  This Task Management request will then\n   establish a new allegiance\
    \ for the command to be aborted as well as\n   abort it (i.e., the task to be\
    \ aborted will not have to be retried or\n   reassigned, and its status, if issued\
    \ but not acknowledged, will be\n   reissued followed by the Task Management response).\n\
    \   At the target an ABORT TASK function MUST NOT be executed on a Task\n   Management\
    \ request; such a request MUST result in Task Management\n   response of \"Function\
    \ rejected\".\n   For the LOGICAL UNIT RESET function, the target MUST behave\
    \ as\n   dictated by the Logical Unit Reset function in [SAM2].\n   The implementation\
    \ of the TARGET WARM RESET function and the TARGET\n   COLD RESET function is\
    \ OPTIONAL and when implemented, should act as\n   described below.  The TARGET\
    \ WARM RESET is also subject to SCSI\n   access controls on the requesting initiator\
    \ as defined in [SPC3].\n   When authorization fails at the target, the appropriate\
    \ response as\n   described in Section 10.6 Task Management Function Response\
    \ MUST be\n   returned by the target.  The TARGET COLD RESET function is not\n\
    \   subject to SCSI access controls, but its execution privileges may be\n   managed\
    \ by iSCSI mechanisms such as login authentication.\n   When executing the TARGET\
    \ WARM RESET and TARGET COLD RESET functions,\n   the target cancels all pending\
    \ operations on all Logical Units known\n   by the issuing initiator.  Both functions\
    \ are equivalent to the\n   Target Reset function specified by [SAM2].  They can\
    \ affect many\n   other initiators logged in with the servicing SCSI target port.\n\
    \   The target MUST treat the TARGET COLD RESET function additionally as\n   a\
    \ power on event, thus terminating all of its TCP connections to all\n   initiators\
    \ (all sessions are terminated).  For this reason, the\n   Service Response (defined\
    \ by [SAM2]) for this SCSI task management\n   function may not be reliably delivered\
    \ to the issuing initiator port.\n   For the TASK REASSIGN function, the target\
    \ should reassign the\n   connection allegiance to this new connection (and thus\
    \ resume iSCSI\n   exchanges for the task).  TASK REASSIGN MUST ONLY be received\
    \ by the\n   target after the connection on which the command was previously\n\
    \   executing has been successfully logged-out.  The Task Management\n   response\
    \ MUST be issued before the reassignment becomes effective.\n   For additional\
    \ usage semantics see Section 6.2 Retry and Reassign in\n   Recovery.\n   At the\
    \ target a TASK REASSIGN function request MUST NOT be executed\n   to reassign\
    \ the connection allegiance of a Task Management function\n   request, an active\
    \ text negotiation task, or a Logout task; such a\n   request MUST result in Task\
    \ Management response of \"Function\n   rejected\".\n   TASK REASSIGN MUST be\
    \ issued as an immediate command.\n"
- title: 10.5.2.  TotalAHSLength and DataSegmentLength
  contents:
  - "10.5.2.  TotalAHSLength and DataSegmentLength\n   For this PDU TotalAHSLength\
    \ and DataSegmentLength MUST be 0.\n"
- title: 10.5.3.  LUN
  contents:
  - "10.5.3.  LUN\n   This field is required for functions that address a specific\
    \ LU\n   (ABORT TASK, CLEAR TASK SET, ABORT TASK SET, CLEAR ACA, LOGICAL UNIT\n\
    \   RESET) and is reserved in all others.\n"
- title: 10.5.4.  Referenced Task Tag
  contents:
  - "10.5.4.  Referenced Task Tag\n   The Initiator Task Tag of the task to be aborted\
    \ for the ABORT TASK\n   function or reassigned for the TASK REASSIGN function.\
    \  For all the\n   other functions this field MUST be set to the reserved value\n\
    \   0xffffffff.\n"
- title: 10.5.5.  RefCmdSN
  contents:
  - "10.5.5.  RefCmdSN\n   If an ABORT TASK is issued for a task created by an immediate\
    \ command\n   then RefCmdSN MUST be that of the Task Management request itself\n\
    \   (i.e., CmdSN and RefCmdSN are equal).\n   For an ABORT TASK of a task created\
    \ by non-immediate command RefCmdSN\n   MUST be set to the CmdSN of the task identified\
    \ by the Referenced\n   Task Tag field.  Targets must use this field as described\
    \ in section\n   10.6.1 when the task identified by the Referenced Task Tag field\
    \ is\n   not with the target.\n   Otherwise, this field is reserved.\n"
- title: 10.5.6.  ExpDataSN
  contents:
  - "10.5.6.  ExpDataSN\n   For recovery purposes, the iSCSI target and initiator\
    \ maintain a data\n   acknowledgement reference number - the first input DataSN\
    \ number\n   unacknowledged by the initiator.  When issuing a new command, this\n\
    \   number is set to 0.  If the function is TASK REASSIGN, which\n   establishes\
    \ a new connection allegiance for a previously issued Read\n   or Bidirectional\
    \ command, ExpDataSN will contain  an updated data\n   acknowledgement reference\
    \ number or the value 0; the latter\n   indicating that the data acknowledgement\
    \ reference number is\n   unchanged.  The initiator MUST discard any data PDUs\
    \ from the\n   previous execution that it did not acknowledge and the target MUST\n\
    \   transmit all Data-In PDUs (if any) starting with the data\n   acknowledgement\
    \ reference number.  The number of retransmitted PDUs\n   may or may not be the\
    \ same as the original transmission depending on\n   if there was a change in\
    \ MaxRecvDataSegmentLength in the\n   reassignment.  The target MAY also send\
    \ no more Data-In PDUs if all\n   data has been acknowledged.\n   The value of\
    \ ExpDataSN  MUST be 0 or higher than the DataSN of the\n   last acknowledged\
    \ Data-In PDU, but not larger than DataSN+1 of the\n   last Data-In PDU sent by\
    \ the target.  Any other value MUST be ignored\n   by the target.\n   For other\
    \ functions this field is reserved.\n"
- title: 10.6.  Task Management Function Response
  contents:
  - "10.6.  Task Management Function Response\n   Byte/     0       |       1    \
    \   |       2       |       3       |\n      /              |               |\
    \               |               |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x22      |1| Reserved    | Response      | Reserved      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------------------------------------------------------+\n\
    \    8/ Reserved                                                      /\n    \
    \ /                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36/ Reserved\
    \                                                      /\n    +/             \
    \                                                  /\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   For the\
    \ functions ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK\n   SET, LOGICAL\
    \ UNIT RESET, TARGET COLD RESET, TARGET WARM RESET and\n   TASK REASSIGN, the\
    \ target performs the requested Task Management\n   function and sends a Task\
    \ Management response back to the initiator.\n   For TASK REASSIGN, the new connection\
    \ allegiance MUST ONLY become\n   effective at the target after the target issues\
    \ the Task Management\n   Response.\n"
- title: 10.6.1.  Response
  contents:
  - "10.6.1.  Response\n   The target provides a Response, which may take on the following\n\
    \   values:\n      a)    0 - Function complete.\n      b)    1 - Task does not\
    \ exist.\n      c)    2 - LUN does not exist.\n      d)    3 - Task still allegiant.\n\
    \      e)    4 - Task allegiance reassignment not supported.\n      f)    5 -\
    \ Task management function not supported.\n      g)    6 - Function authorization\
    \ failed.\n      h)  255 - Function rejected.\n   All other values are reserved.\n\
    \   For a discussion on usage of response codes 3 and 4, see Section\n   6.2.2\
    \ Allegiance Reassignment.\n   For the TARGET COLD RESET and TARGET WARM RESET\
    \ functions, the target\n   cancels all pending operations across all Logical\
    \ Units known to the\n   issuing initiator.  For the TARGET COLD RESET function,\
    \ the target\n   MUST then close all of its TCP connections to all initiators\n\
    \   (terminates all sessions).\n   The mapping of the response code into a SCSI\
    \ service response code\n   value, if needed, is outside the scope of this document.\
    \  However, in\n   symbolic terms Response values 0 and 1 map to the SCSI service\n\
    \   response of FUNCTION COMPLETE.  All other Response values map to the\n   SCSI\
    \ service response of FUNCTION REJECTED.  If a Task Management\n   function response\
    \ PDU does not arrive before the session is\n   terminated, the SCSI service response\
    \ is SERVICE DELIVERY OR TARGET\n   FAILURE.\n   The response to ABORT TASK SET\
    \ and CLEAR TASK SET MUST only be issued\n   by the target after all of the commands\
    \ affected have been received\n   by the target, the corresponding task management\
    \ functions have been\n   executed by the SCSI target, and the delivery of all\
    \ responses\n   delivered until the task management function completion have been\n\
    \   confirmed (acknowledged through ExpStatSN) by the initiator on all\n   connections\
    \ of this session.  For the exact timeline of events, refer\n   to Section 10.6.2\
    \ Task Management Actions on Task Sets.\n   For the ABORT TASK function,\n   \
    \   a)  If the Referenced Task Tag identifies a valid task leading to\n      \
    \    a successful termination, then targets must return the\n          \"Function\
    \ complete\" response.\n      b)  If the Referenced Task Tag does not identify\
    \ an existing task,\n          but if the CmdSN indicated by the RefCmdSN field\
    \ in the Task\n          Management function request is within the valid CmdSN\
    \ window\n          and less than the CmdSN of the Task Management function\n\
    \          request itself, then targets must consider the CmdSN received\n   \
    \       and return the \"Function complete\" response.\n      c)  If the Referenced\
    \ Task Tag does not identify an existing task\n          and if the CmdSN indicated\
    \ by the RefCmdSN field in the Task\n          Management function request is\
    \ outside the valid CmdSN window,\n          then targets must return the \"Task\
    \ does not exist\" response.\n"
- title: 10.6.2.  Task Management Actions on Task Sets
  contents:
  - "10.6.2.  Task Management Actions on Task Sets\n   The execution of ABORT TASK\
    \ SET and CLEAR TASK SET Task Management\n   function requests consists of the\
    \ following sequence of events in the\n   specified order on each of the entities.\n\
    \   The initiator:\n         a) Issues ABORT TASK SET/CLEAR TASK SET request.\n\
    \         b) Continues to respond to each target transfer tag received\n     \
    \       for the affected task set.\n         c) Receives any responses for the\
    \ tasks in the affected task\n            set (may process them as usual because\
    \ they are guaranteed\n            to be valid).\n         d) Receives the task\
    \ set management response, thus concluding\n            all the tasks in the affected\
    \ task set.\n   The target:\n         a) Receives the ABORT TASK SET/CLEAR TASK\
    \ SET request.\n         b) Waits for all target transfer tags to be responded\
    \ to and\n            for all affected tasks in the task set to be received.\n\
    \         c) Propagates the command to and receives the response from the\n  \
    \          target SCSI layer.\n         d) Takes note of last-sent StatSN on each\
    \ of the connections in\n            the iSCSI sessions (one or more) sharing\
    \ the affected task\n            set, and waits for acknowledgement of each StatSN\
    \ (may\n            solicit for acknowledgement by way of a NOP-In).  If some\n\
    \            tasks originate from non-iSCSI I_T_L nexi then the means by\n   \
    \         which the target insures that all affected tasks have\n            returned\
    \ their status to the initiator are defined by the\n            specific protocol.\n\
    \         e) Sends the task set management response to the issuing\n         \
    \   initiator.\n"
- title: 10.6.3.  TotalAHSLength and DataSegmentLength
  contents:
  - "10.6.3.  TotalAHSLength and DataSegmentLength\n   For this PDU TotalAHSLength\
    \ and DataSegmentLength MUST be 0.\n"
- title: 10.7.  SCSI Data-Out & SCSI Data-In
  contents:
  - "10.7.  SCSI Data-Out & SCSI Data-In\n   The SCSI Data-Out PDU for WRITE operations\
    \ has the following format:\n   Byte/     0       |       1       |       2  \
    \     |       3       |\n      /              |               |              \
    \ |               |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1\
    \ 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x05      |F| Reserved                                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Reserved                                               |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| Reserved                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \                                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| Reserved                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| DataSN\
    \                                                        |\n     +---------------+---------------+---------------+---------------+\n\
    \   40| Buffer Offset                                                 |\n    \
    \ +---------------+---------------+---------------+---------------+\n   44| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / DataSegment\
    \                                                   /\n    +/                \
    \                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   The SCSI\
    \ Data-In PDU for READ operations has the following format:\n   Byte/     0  \
    \     |       1       |       2       |       3       |\n      /             \
    \ |               |               |               |\n     |0 1 2 3 4 5 6 7|0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x25      |F|A|0 0 0|O|U|S| Reserved      |Status or Rsvd |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Reserved                                               |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN or Reserved                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| DataSN\
    \                                                        |\n     +---------------+---------------+---------------+---------------+\n\
    \   40| Buffer Offset                                                 |\n    \
    \ +---------------+---------------+---------------+---------------+\n   44| Residual\
    \ Count                                                |\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / DataSegment\
    \                                                   /\n    +/                \
    \                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   Status\
    \ can accompany the last Data-In PDU if the command did not end\n   with an exception\
    \ (i.e., the status is \"good status\" - GOOD,\n   CONDITION MET or INTERMEDIATE\
    \ CONDITION MET).  The presence of status\n   (and of a residual count) is signaled\
    \ though the S flag bit.\n   Although targets MAY choose to send even non-exception\
    \ status in\n   separate responses, initiators MUST support non-exception status\
    \ in\n   Data-In PDUs.\n"
- title: 10.7.1.  F (Final) Bit
  contents:
  - "10.7.1.  F (Final) Bit\n   For outgoing data, this bit is 1 for the last PDU\
    \ of unsolicited data\n   or the last PDU of a sequence that answers an R2T.\n\
    \   For incoming data, this bit is 1 for the last input (read) data PDU\n   of\
    \ a sequence.  Input can be split into several sequences, each\n   having its\
    \ own F bit.  Splitting the data stream into sequences does\n   not affect DataSN\
    \ counting on Data-In PDUs.  It MAY be used as a\n   \"change direction\" indication\
    \ for Bidirectional operations that need\n   such a change.\n   DataSegmentLength\
    \ MUST not exceed MaxRecvDataSegmentLength for the\n   direction it is sent and\
    \ the total of all the DataSegmentLength of\n   all PDUs in a sequence MUST not\
    \ exceed MaxBurstLength (or\n   FirstBurstLength for unsolicited data).  However\
    \ the number of\n   individual PDUs in a sequence (or in total) may be higher\
    \ than the\n   MaxBurstLength (or FirstBurstLength) to MaxRecvDataSegmentLength\n\
    \   ratio (as PDUs may be limited in length by the sender capabilities).\n   Using\
    \ DataSegmentLength of 0 may increase beyond what is reasonable\n   for the number\
    \ of PDUs and should therefore be avoided.\n   For Bidirectional operations, the\
    \ F bit is 1 for both the end of the\n   input sequences and the end of the output\
    \ sequences.\n"
- title: 10.7.2.  A (Acknowledge) Bit
  contents:
  - "10.7.2.  A (Acknowledge) Bit\n   For sessions with ErrorRecoveryLevel 1 or higher,\
    \ the target sets\n   this bit to 1 to indicate that it requests a positive acknowledgement\n\
    \   from the initiator for the data received.  The target should use the\n   A\
    \ bit moderately; it MAY only set the A bit to 1 once every\n   MaxBurstLength\
    \ bytes, or on the last Data-In PDU that concludes the\n   entire requested read\
    \ data transfer for the task from the target's\n   perspective, and it MUST NOT\
    \ do so more frequently.  The target MUST\n   NOT set to 1 the A bit for sessions\
    \ with ErrorRecoveryLevel=0.  The\n   initiator MUST ignore the A bit set to 1\
    \ for sessions with\n   ErrorRecoveryLevel=0.\n   On receiving a Data-In PDU with\
    \ the A bit set to 1 on a session with\n   ErrorRecoveryLevel greater than 0,\
    \ if there are no holes in the read\n   data until that Data-In PDU, the initiator\
    \ MUST issue a SNACK of type\n   DataACK except when it is able to acknowledge\
    \ the status for the task\n   immediately via ExpStatSN on other outbound PDUs\
    \ if the status for\n   the task is also received.  In the latter case (acknowledgement\n\
    \   through ExpStatSN), sending a SNACK of type DataACK in response to\n   the\
    \ A bit is OPTIONAL, but if it is done, it must not be sent after\n   the status\
    \ acknowledgement through ExpStatSN.  If the initiator has\n   detected holes\
    \ in the read data prior to that Data-In PDU, it MUST\n   postpone issuing the\
    \ SNACK of type DataACK until the holes are\n   filled.  An initiator also MUST\
    \ NOT acknowledge the status for the\n   task before those holes are filled. \
    \ A status acknowledgement for a\n   task that generated the Data-In PDUs is considered\
    \ by the target as\n   an implicit acknowledgement of the Data-In PDUs if such\
    \ an\n   acknowledgement was requested by the target.\n"
- title: 10.7.3.  Flags (byte 1)
  contents:
  - "10.7.3.  Flags (byte 1)\n   The last SCSI Data packet sent from a target to an\
    \ initiator for a\n   SCSI command that completed successfully (with a status\
    \ of GOOD,\n   CONDITION MET, INTERMEDIATE or INTERMEDIATE CONDITION MET) may\
    \ also\n   optionally contain the Status for the data transfer.  As Sense Data\n\
    \   cannot be sent together with the Command Status, if the command is\n   completed\
    \ with an error, then the response and sense data MUST be\n   sent in a SCSI Response\
    \ PDU (i.e., MUST NOT be sent in a SCSI Data\n   packet).  If Status is sent with\
    \ the data, then a SCSI Response PDU\n   MUST NOT be sent as this would violate\
    \ SCSI rules (a single status).\n   For Bidirectional commands, the status MUST\
    \ be sent in a SCSI\n   Response PDU.\n      bit 2-4 - Reserved.\n      bit 5-6\
    \ - used the same as in a SCSI Response.  These bits are\n                only\
    \ valid when S is set to 1.  For details see Section\n                10.4.1 Flags\
    \ (byte 1).\n      bit 7 S (status)- set to indicate that the Command Status field\n\
    \                contains status.  If this bit is set to 1, the F bit\n      \
    \          MUST also be set to 1.\n   The fields StatSN, Status, and Residual\
    \ Count only have meaningful\n   content if the S bit is set to 1 and their values\
    \ are defined in\n   Section 10.4 SCSI Response.\n"
- title: 10.7.4.  Target Transfer Tag and LUN
  contents:
  - "10.7.4.  Target Transfer Tag and LUN\n   On outgoing data, the Target Transfer\
    \ Tag is provided to the target\n   if the transfer is honoring an R2T.  In this\
    \ case, the Target\n   Transfer Tag field is a replica of the Target Transfer\
    \ Tag provided\n   with the R2T.\n   On incoming data, the Target Transfer Tag\
    \ and LUN MUST be provided by\n   the target if the A bit is set to 1; otherwise\
    \ they are reserved.\n   The Target Transfer Tag and LUN are copied by the initiator\
    \ into the\n   SNACK  of type DataACK that it issues as a result of receiving\
    \ a SCSI\n   Data-In PDU with the A bit set to 1.\n   The Target Transfer Tag\
    \ values are not specified by this protocol\n   except that the value 0xffffffff\
    \ is reserved and means that the\n   Target Transfer Tag is not supplied.  If\
    \ the Target Transfer Tag is\n   provided, then the LUN field MUST hold a valid\
    \ value and be\n   consistent with whatever was specified with the command; otherwise,\n\
    \   the LUN field is reserved.\n"
- title: 10.7.5.  DataSN
  contents:
  - "10.7.5.  DataSN\n   For input (read) or bidirectional Data-In PDUs, the DataSN\
    \ is the\n   input PDU number within the data transfer for the command identified\n\
    \   by the Initiator Task Tag.\n   R2T and Data-In PDUs, in the context of bidirectional\
    \ commands, share\n   the numbering sequence (see Section 3.2.2.3 Data Sequencing).\n\
    \   For output (write) data PDUs, the DataSN is the Data-Out PDU number\n   within\
    \ the current output sequence.  The current output sequence is\n   either identified\
    \ by the Initiator Task Tag (for unsolicited data) or\n   is a data sequence generated\
    \ for one R2T (for data solicited through\n   R2T).\n"
- title: 10.7.6.  Buffer Offset
  contents:
  - "10.7.6.  Buffer Offset\n   The Buffer Offset field contains the offset of this\
    \ PDU payload data\n   within the complete data transfer.  The sum of the buffer\
    \ offset and\n   length should not exceed the expected transfer length for the\n\
    \   command.\n   The order of data PDUs within a sequence is determined by\n \
    \  DataPDUInOrder.  When set to Yes, it means that PDUs have to be in\n   increasing\
    \ Buffer Offset order and overlays are forbidden.\n   The ordering between sequences\
    \ is determined by DataSequenceInOrder.\n   When set to Yes, it means that sequences\
    \ have to be in increasing\n   Buffer Offset order and overlays are forbidden.\n"
- title: 10.7.7.  DataSegmentLength
  contents:
  - "10.7.7.  DataSegmentLength\n   This is the data payload length of a SCSI Data-In\
    \ or SCSI Data-Out\n   PDU.  The sending of 0 length data segments should be avoided,\
    \ but\n   initiators and targets MUST be able to properly receive 0 length data\n\
    \   segments.\n   The Data Segments of Data-In and Data-Out PDUs SHOULD be filled\
    \ to\n   the integer number of 4 byte words (real payload) unless the F bit is\n\
    \   set to 1.\n"
- title: 10.8.  Ready To Transfer (R2T)
  contents:
  - "10.8.  Ready To Transfer (R2T)\n   Byte/     0       |       1       |      \
    \ 2       |       3       |\n      /              |               |          \
    \     |               |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x31      |1| Reserved                                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN                                                           |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag                                           |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| R2TSN\
    \                                                         |\n     +---------------+---------------+---------------+---------------+\n\
    \   40| Buffer Offset                                                 |\n    \
    \ +---------------+---------------+---------------+---------------+\n   44| Desired\
    \ Data Transfer Length                                  |\n     +---------------------------------------------------------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   When an\
    \ initiator has submitted a SCSI Command with data that passes\n   from the initiator\
    \ to the target (WRITE), the target may specify\n   which blocks of data it is\
    \ ready to receive.  The target may request\n   that the data blocks be delivered\
    \ in whichever order is convenient\n   for the target at that particular instant.\
    \  This information is\n   passed from the target to the initiator in the Ready\
    \ To Transfer\n   (R2T) PDU.\n   In order to allow write operations without an\
    \ explicit initial R2T,\n   the initiator and target MUST have negotiated the\
    \ key InitialR2T to\n   No during Login.\n   An R2T MAY be answered with one or\
    \ more SCSI Data-Out PDUs with a\n   matching Target Transfer Tag.  If an R2T\
    \ is answered with a single\n   Data-Out PDU, the Buffer Offset in the Data PDU\
    \ MUST be the same as\n   the one specified by the R2T, and the data length of\
    \ the Data PDU\n   MUST be the same as the Desired Data Transfer Length specified\
    \ in the\n   R2T.  If the R2T is answered with a sequence of Data PDUs, the Buffer\n\
    \   Offset and Length MUST be within the range of those specified by R2T,\n  \
    \ and the last PDU MUST have the F bit set to 1.  If the last PDU\n   (marked\
    \ with the F bit) is received before the Desired Data Transfer\n   Length is transferred,\
    \ a target MAY choose to Reject that\n   PDU with \"Protocol error\" reason code.\
    \  DataPDUInOrder governs the\n   Data-Out PDU ordering.  If DataPDUInOrder is\
    \ set to Yes, the Buffer\n   Offsets and Lengths for consecutive PDUs MUST form\
    \ a continuous\n   non-overlapping range and the PDUs MUST be sent in increasing\
    \ offset\n   order.\n   The target may send several R2T PDUs.  It, therefore,\
    \ can have a\n   number of pending data transfers.  The number of outstanding\
    \ R2T PDUs\n   are limited by the value of the negotiated key MaxOutstandingR2T.\n\
    \   Within a connection, outstanding R2Ts MUST be fulfilled by the\n   initiator\
    \ in the order in which they were received.\n   R2T PDUs MAY also be used to recover\
    \ Data Out PDUs.  Such an R2T\n   (Recovery-R2T) is generated by a target upon\
    \ detecting the loss of\n   one or more Data-Out PDUs due to:\n     - Digest error\n\
    \     - Sequence error\n     - Sequence reception timeout\n   A Recovery-R2T carries\
    \ the next unused R2TSN, but requests part of or\n   the entire data burst that\
    \ an earlier R2T (with a lower R2TSN) had\n   already requested.\n   DataSequenceInOrder\
    \ governs the buffer offset ordering in consecutive\n   R2Ts.  If DataSequenceInOrder\
    \ is Yes, then consecutive R2Ts MUST\n   refer to continuous non-overlapping ranges\
    \ except for Recovery-R2Ts.\n"
- title: 10.8.1.  TotalAHSLength and DataSegmentLength
  contents:
  - "10.8.1.  TotalAHSLength and DataSegmentLength\n   For this PDU TotalAHSLength\
    \ and DataSegmentLength MUST be 0.\n"
- title: 10.8.2.  R2TSN
  contents:
  - "10.8.2.  R2TSN\n   R2TSN is the R2T PDU input PDU number within the command identified\n\
    \   by the Initiator Task Tag.\n   For bidirectional commands R2T and Data-In\
    \ PDUs share the input PDU\n   numbering sequence (see Section 3.2.2.3 Data Sequencing).\n"
- title: 10.8.3.  StatSN
  contents:
  - "10.8.3.  StatSN\n   The StatSN field will contain the next StatSN.  The StatSN\
    \ for this\n   connection is not advanced after this PDU is sent.\n"
- title: 10.8.4.  Desired Data Transfer Length and Buffer Offset
  contents:
  - "10.8.4.  Desired Data Transfer Length and Buffer Offset\n   The target specifies\
    \ how many bytes it wants the initiator to send\n   because of this R2T PDU. \
    \ The target may request the data from the\n   initiator in several chunks, not\
    \ necessarily in the original order of\n   the data.  The target, therefore, also\
    \ specifies a Buffer Offset that\n   indicates the point at which the data transfer\
    \ should begin, relative\n   to the beginning of the total data transfer.  The\
    \ Desired Data\n   Transfer Length MUST NOT be 0 and MUST not exceed MaxBurstLength.\n"
- title: 10.8.5.  Target Transfer Tag
  contents:
  - "10.8.5.  Target Transfer Tag\n   The target assigns its own tag to each R2T request\
    \ that it sends to\n   the initiator.  This tag can be used by the target to easily\
    \ identify\n   the data it receives.  The Target Transfer Tag and LUN are copied\
    \ in\n   the outgoing data PDUs and are only used by the target.  There is no\n\
    \   protocol rule about the Target Transfer Tag except that the value\n   0xffffffff\
    \ is reserved and MUST NOT be sent by a target in an R2T.\n"
- title: 10.9.  Asynchronous Message
  contents:
  - "10.9.  Asynchronous Message\n   An Asynchronous Message may be sent from the\
    \ target to the initiator\n   without correspondence to a particular command.\
    \  The target specifies\n   the reason for the event and sense data.\n   Byte/\
    \     0       |       1       |       2       |       3       |\n      /     \
    \         |               |               |               |\n     |0 1 2 3 4 5\
    \ 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x32      |1| Reserved                                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Reserved                                               |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| 0xffffffff                                                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| AsyncEvent\
    \    | AsyncVCode    | Parameter1 or Reserved        |\n     +---------------+---------------+---------------+---------------+\n\
    \   40| Parameter2 or Reserved        | Parameter3 or Reserved        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   44| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / DataSegment\
    \ - Sense Data and iSCSI Event Data                 /\n    +/                \
    \                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   Some Asynchronous\
    \ Messages are strictly related to iSCSI while others\n   are related to SCSI\
    \ [SAM2].\n   StatSN counts this PDU as an acknowledgeable event (StatSN is\n\
    \   advanced), which allows for initiator and target state\n   synchronization.\n"
- title: 10.9.1.  AsyncEvent
  contents:
  - "10.9.1.  AsyncEvent\n   The codes used for iSCSI Asynchronous Messages (events)\
    \ are:\n      0 - a SCSI Asynchronous Event is reported in the sense data.\n \
    \         Sense Data that accompanies the report, in the data segment,\n     \
    \     identifies the condition.  The sending of a SCSI Event\n          (Asynchronous\
    \ Event Reporting in SCSI terminology) is\n          dependent on the target support\
    \ for SCSI asynchronous event\n          reporting (see [SAM2]) as indicated in\
    \ the standard INQUIRY\n          data (see [SPC3]).  Its use may be enabled by\
    \ parameters in\n          the SCSI Control mode page (see [SPC3]).\n      1 -\
    \ target requests Logout.  This Async Message MUST be sent on\n          the same\
    \ connection as the one requesting to be logged out.\n          The initiator\
    \ MUST honor this request by issuing a Logout as\n          early as possible,\
    \ but no later than Parameter3 seconds.\n          Initiator MUST send a Logout\
    \ with a reason code of \"Close the\n          connection\" OR \"Close the session\"\
    \ to close all the\n          connections.  Once this message is received, the\
    \ initiator\n          SHOULD NOT issue new iSCSI commands on the connection to\
    \ be\n          logged out.  The target MAY reject any new I/O requests that\n\
    \          it receives after this Message with the reason code \"Waiting\n   \
    \       for Logout\".  If the initiator does not Logout in Parameter3\n      \
    \    seconds, the target should send an Async PDU with iSCSI event\n         \
    \ code \"Dropped the connection\" if possible, or simply terminate\n         \
    \ the transport connection.  Parameter1 and Parameter2 are\n          reserved.\n\
    \      2 - target indicates it will drop the connection.  The Parameter1\n   \
    \       field indicates the CID of the connection that is going to be\n      \
    \    dropped.\n          The Parameter2 field (Time2Wait) indicates, in seconds,\
    \ the\n          minimum time to wait before attempting to reconnect or\n    \
    \      reassign.\n          The Parameter3 field (Time2Retain) indicates the maximum\
    \ time\n          allowed to reassign commands after the initial wait (in\n  \
    \        Parameter2).\n          If the initiator does not attempt to reconnect\
    \ and/or reassign\n          the outstanding commands within the time specified\
    \ by\n          Parameter3, or if Parameter3 is 0, the target will terminate\n\
    \          all outstanding commands on this connection.  In this case, no\n  \
    \        other responses should be expected from the target for the\n        \
    \  outstanding commands on this connection.\n          A value of 0 for Parameter2\
    \ indicates that reconnect can be\n          attempted immediately.\n      3 -\
    \ target indicates it will drop all the connections of this\n          session.\n\
    \          Parameter1 field is reserved.\n          The Parameter2 field (Time2Wait)\
    \ indicates, in seconds, the\n          minimum time to wait before attempting\
    \ to reconnect.  The\n          Parameter3 field (Time2Retain) indicates the maximum\
    \ time\n          allowed to reassign commands after the initial wait (in\n  \
    \        Parameter2).\n          If the initiator does not attempt to reconnect\
    \ and/or reassign\n          the outstanding commands within the time specified\
    \ by\n          Parameter3, or if Parameter3 is 0, the session is terminated.\n\
    \          In this case, the target will terminate all outstanding\n         \
    \ commands in this session; no other responses should be\n          expected from\
    \ the target for the outstanding commands in this\n          session.  A value\
    \ of 0 for Parameter2 indicates that reconnect\n          can be attempted immediately.\n\
    \      4 - target requests parameter negotiation on this connection.  The\n  \
    \        initiator MUST honor this request by issuing a Text Request\n       \
    \   (that can be empty) on the same connection as early as\n          possible,\
    \ but no later than Parameter3 seconds, unless a Text\n          Request is already\
    \ pending on the connection, or by issuing a\n          Logout Request.  If the\
    \ initiator does not issue a Text\n          Request the target may reissue the\
    \ Asynchronous Message\n          requesting parameter negotiation.\n      255\
    \ - vendor specific iSCSI Event.  The AsyncVCode details the\n            vendor\
    \ code, and data MAY accompany the report.\n   All other event codes are reserved.\n"
- title: 10.9.2.  AsyncVCode
  contents:
  - "10.9.2.  AsyncVCode\n   AsyncVCode is a vendor specific detail code that is only\
    \ valid if the\n   AsyncEvent field indicates a vendor specific event.  Otherwise,\
    \ it is\n   reserved.\n"
- title: 10.9.3.  LUN
  contents:
  - "10.9.3.  LUN\n   The LUN field MUST be valid if AsyncEvent is 0.  Otherwise,\
    \ this\n   field is reserved.\n"
- title: 10.9.4.  Sense Data and iSCSI Event Data
  contents:
  - "10.9.4.  Sense Data and iSCSI Event Data\n   For a SCSI event, this data accompanies\
    \ the report in the data\n   segment and identifies the condition.\n   For an\
    \ iSCSI event, additional vendor-unique data MAY accompany the\n   Async event.\
    \  Initiators MAY ignore the data when not understood\n   while processing the\
    \ rest of the PDU.\n   If the DataSegmentLength is not 0, the format of the DataSegment\
    \ is\n   as follows:\n   Byte/     0       |       1       |       2       | \
    \      3       |\n      /              |               |               |     \
    \          |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4\
    \ 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|SenseLength                    | Sense Data                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n    x/ Sense\
    \ Data                                                    /\n     +---------------+---------------+---------------+---------------+\n\
    \    y/ iSCSI Event Data                                              /\n    \
    \ /                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \    z|\n"
- title: 10.9.4.1.  SenseLength
  contents:
  - "10.9.4.1.  SenseLength\n   This is the length of Sense Data.  When the Sense\
    \ Data field is empty\n   (e.g., the event is not a SCSI event) SenseLength is\
    \ 0.\n"
- title: 10.10.  Text Request
  contents:
  - "10.10.  Text Request\n   The Text Request is provided to allow for the exchange\
    \ of information\n   and for future extensions.  It permits the initiator to inform\
    \ a\n   target of its capabilities or to request some special operations.\n  \
    \ Byte/     0       |       1       |       2       |       3       |\n      /\
    \              |               |               |               |\n     |0 1 2\
    \ 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|I| 0x04      |F|C| Reserved                                  |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Reserved                                               |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| CmdSN                                                         |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \                                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / DataSegment\
    \ (Text)                                            /\n    +/                \
    \                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   An initiator\
    \ MUST have at most one outstanding Text Request on a\n   connection at any given\
    \ time.\n   On a connection failure, an initiator must either explicitly abort\n\
    \   any active allegiant text negotiation task or must cause such a task\n   to\
    \ be implicitly terminated by the target.\n"
- title: 10.10.1.  F (Final) Bit
  contents:
  - "10.10.1.  F (Final) Bit\n   When set to 1,  indicates that this is the last or\
    \ only text request\n   in a sequence of Text Requests; otherwise, it indicates\
    \ that more\n   Text Requests will follow.\n"
- title: 10.10.2.  C (Continue) Bit
  contents:
  - "10.10.2.  C (Continue) Bit\n   When set to 1, indicates that the text (set of\
    \ key=value pairs) in\n   this Text Request is not complete (it will be continued\
    \ on subsequent\n   Text Requests); otherwise, it indicates that this Text Request\
    \ ends a\n   set of key=value pairs.  A Text Request with the C bit set to 1 MUST\n\
    \   have the F bit set to 0.\n"
- title: 10.10.3.  Initiator Task Tag
  contents:
  - "10.10.3.  Initiator Task Tag\n   The initiator assigned identifier for this Text\
    \ Request.  If the\n   command is sent as part of a sequence of text requests\
    \ and responses,\n   the Initiator Task Tag MUST be the same for all the requests\
    \ within\n   the sequence (similar to linked SCSI commands).  The I bit for all\n\
    \   requests in a sequence also MUST be the same.\n"
- title: 10.10.4.  Target Transfer Tag
  contents:
  - "10.10.4.  Target Transfer Tag\n   When the Target Transfer Tag is set to the\
    \ reserved value 0xffffffff,\n   it tells the target that this is a new request\
    \ and the target resets\n   any internal state associated with the Initiator Task\
    \ Tag (resets the\n   current negotiation state).\n   The target sets the Target\
    \ Transfer Tag in a text response to a value\n   other than the reserved value\
    \ 0xffffffff whenever it indicates that\n   it has more data to send or more operations\
    \ to perform that are\n   associated with the specified Initiator Task Tag.  It\
    \ MUST do so\n   whenever it sets the F bit to 0 in the response.  By copying\
    \ the\n   Target Transfer Tag from the response to the next Text Request, the\n\
    \   initiator tells the target to continue the operation for the specific\n  \
    \ Initiator Task Tag.  The initiator MUST ignore the Target Transfer\n   Tag in\
    \ the Text Response when the F bit is set to 1.\n   This mechanism allows the\
    \ initiator and target to transfer a large\n   amount of textual data over a sequence\
    \ of text-command/text-response\n   exchanges, or to perform extended negotiation\
    \ sequences.\n   If the Target Transfer Tag is not 0xffffffff, the LUN field MUST\
    \ be\n   sent by the target in the Text Response.\n   A target MAY reset its internal\
    \ negotiation state if an exchange is\n   stalled by the initiator for a long\
    \ time or if it is running out of\n   resources.\n   Long text responses are handled\
    \ as in the following example:\n     I->T Text SendTargets=All (F=1,TTT=0xffffffff)\n\
    \     T->I Text <part 1> (F=0,TTT=0x12345678)\n     I->T Text <empty> (F=1, TTT=0x12345678)\n\
    \     T->I Text <part 2> (F=0, TTT=0x12345678)\n     I->T Text <empty> (F=1, TTT=0x12345678)\n\
    \     ...\n     T->I Text <part n> (F=1, TTT=0xffffffff)\n"
- title: 10.10.5.  Text
  contents:
  - "10.10.5.  Text\n   The data lengths of a text request MUST NOT exceed the iSCSI\
    \ target\n   MaxRecvDataSegmentLength (a per connection and per direction\n  \
    \ negotiated parameter).  The text format is specified in Section 5.2\n   Text\
    \ Mode Negotiation.\n   Chapter 11 and Chapter 12 list some basic Text key=value\
    \ pairs, some\n   of which can be used in Login Request/Response and some in Text\n\
    \   Request/Response.\n   A key=value pair can span Text request or response boundaries.\
    \  A\n   key=value pair can start in one PDU and continue on the next.  In\n \
    \  other words the end of a PDU does not necessarily signal the end of a\n   key=value\
    \ pair.\n   The target responds by sending its response back to the initiator.\n\
    \   The response text format is similar to the request text format.  The\n   text\
    \ response MAY refer to key=value pairs presented in an earlier\n   text request\
    \ and the text in the request may refer to earlier\n   responses.\n   Chapter\
    \ 5 details the rules for the Text Requests and Responses.\n   Text operations\
    \ are usually meant for parameter setting/\n   negotiations, but can also be used\
    \ to perform some long lasting\n   operations.\n   Text operations that take a\
    \ long time should be placed in their own\n   Text request.\n"
- title: 10.11.  Text Response
  contents:
  - "10.11.  Text Response\n   The Text Response PDU contains the target's responses\
    \ to the\n   initiator's Text request.  The format of the Text field matches that\n\
    \   of the Text request.\n   Byte/     0       |       1       |       2     \
    \  |       3       |\n      /              |               |               | \
    \              |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x24      |F|C| Reserved                                  |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Reserved                                               |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36/ Reserved\
    \                                                      /\n    +/             \
    \                                                  /\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / DataSegment\
    \ (Text)                                            /\n    +/                \
    \                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n"
- title: 10.11.1.  F (Final) Bit
  contents:
  - "10.11.1.  F (Final) Bit\n   When set to 1, in response to a Text Request with\
    \ the Final bit set\n   to 1, the F bit indicates that the target has finished\
    \ the whole\n   operation.  Otherwise, if set to 0 in response to a Text Request\
    \ with\n   the Final Bit set to 1, it indicates that the target has more work\
    \ to\n   do (invites a follow-on text request).  A Text Response with the F\n\
    \   bit set to 1 in response to a Text Request with the F bit set to 0 is\n  \
    \ a protocol error.\n   A Text Response with the F bit set to 1 MUST NOT contain\
    \ key=value\n   pairs that may require additional answers from the initiator.\n\
    \   A Text Response with the F bit set to 1 MUST have a Target Transfer\n   Tag\
    \ field set to the reserved value of 0xffffffff.\n   A Text Response with the\
    \ F bit set to 0 MUST have a Target Transfer\n   Tag field set to a value other\
    \ than the reserved 0xffffffff.\n"
- title: 10.11.2.  C (Continue) Bit
  contents:
  - "10.11.2.  C (Continue) Bit\n   When set to 1, indicates that the text (set of\
    \ key=value pairs) in\n   this Text Response is not complete (it will be continued\
    \ on\n   subsequent Text Responses); otherwise, it indicates that this Text\n\
    \   Response ends a set of key=value pairs.  A Text Response with the C\n   bit\
    \ set to 1 MUST have the F bit set to 0.\n"
- title: 10.11.3.  Initiator Task Tag
  contents:
  - "10.11.3.  Initiator Task Tag\n   The Initiator Task Tag matches the tag used\
    \ in the initial Text\n   Request.\n"
- title: 10.11.4.  Target Transfer Tag
  contents:
  - "10.11.4.  Target Transfer Tag\n   When a target has more work to do (e.g., cannot\
    \ transfer all the\n   remaining text data in a single Text Response or has to\
    \ continue the\n   negotiation) and has enough resources to proceed, it MUST set\
    \ the\n   Target Transfer Tag to a value other than the reserved value of\n  \
    \ 0xffffffff.  Otherwise, the Target Transfer Tag MUST be set to\n   0xffffffff.\n\
    \   When the Target Transfer Tag is not 0xffffffff, the LUN field may be\n   significant.\n\
    \   The initiator MUST copy the Target Transfer Tag and LUN in its next\n   request\
    \ to indicate that it wants the rest of the data.\n   When the target receives\
    \ a Text Request with the Target Transfer Tag\n   set to the reserved value of\
    \ 0xffffffff, it resets its internal\n   information (resets state) associated\
    \ with the given Initiator Task\n   Tag (restarts the negotiation).\n   When a\
    \ target cannot finish the operation in a single Text Response,\n   and does not\
    \ have enough resources to continue, it rejects the Text\n   Request with the\
    \ appropriate Reject code.\n   A target may reset its internal state associated\
    \ with an Initiator\n   Task Tag (the current negotiation state), state expressed\
    \ through the\n   Target Transfer Tag if the initiator fails to continue the exchange\n\
    \   for some time.  The target may reject subsequent Text Requests with\n   the\
    \ Target Transfer Tag set to the \"stale\" value.\n"
- title: 10.11.5.  StatSN
  contents:
  - "10.11.5.  StatSN\n   The target StatSN variable is advanced by each Text Response\
    \ sent.\n"
- title: 10.11.6.  Text Response Data
  contents:
  - "10.11.6.  Text Response Data\n   The data lengths of a text response MUST NOT\
    \ exceed the iSCSI\n   initiator MaxRecvDataSegmentLength (a per connection and\
    \ per\n   direction negotiated parameter).\n   The text in the Text Response Data\
    \ is governed by the same rules as\n   the text in the Text Request Data (see\
    \ Section 10.10.5 Text).\n   Although the initiator is the requesting party and\
    \ controls the\n   request-response initiation and termination, the target can\
    \ offer\n   key=value pairs of its own as part of a sequence and not only in\n\
    \   response to the initiator.\n"
- title: 10.12.  Login Request
  contents:
  - "10.12.  Login Request\n   After establishing a TCP connection between an initiator\
    \ and a\n   target, the initiator MUST start a Login Phase to gain further access\n\
    \   to the target's resources.\n   The Login Phase (see Chapter 5) consists of\
    \ a sequence of Login\n   Requests and Responses that carry the same Initiator\
    \ Task Tag.\n   Login Requests are always considered as immediate.\n   Byte/ \
    \    0       |       1       |       2       |       3       |\n      /      \
    \        |               |               |               |\n     |0 1 2 3 4 5\
    \ 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|1| 0x03      |T|C|.|.|CSG|NSG| Version-max   | Version-min   |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| ISID                                                          |\n    \
    \ +                               +---------------+---------------+\n   12|  \
    \                             | TSIH                          |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| CID\
    \                           | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| CmdSN                                                         |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \   or   Reserved                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| Reserved                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   40/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48/ DataSegment - Login Parameters in Text request Format         /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n"
- title: 10.12.1.  T (Transit) Bit
  contents:
  - "10.12.1.  T (Transit) Bit\n   If set to 1, indicates that the initiator is ready\
    \ to transit to the\n   next stage.\n   If the T bit is set to 1 and NSG is FullFeaturePhase,\
    \ then this also\n   indicates that the initiator is ready for the Final Login\
    \ Response\n   (see Chapter 5).\n"
- title: 10.12.2.  C (Continue) Bit
  contents:
  - "10.12.2.  C (Continue) Bit\n   When set to 1,  indicates that the text (set of\
    \ key=value pairs) in\n   this Login Request is not complete (it will be continued\
    \ on\n   subsequent Login Requests); otherwise, it indicates that this Login\n\
    \   Request ends a set of key=value pairs.  A Login Request with the C\n   bit\
    \ set to 1 MUST have the T bit set to 0.\n"
- title: 10.12.3.  CSG and NSG
  contents:
  - "10.12.3.  CSG and NSG\n   Through these fields, Current Stage (CSG) and Next\
    \ Stage (NSG), the\n   Login negotiation requests and responses are associated\
    \ with a\n   specific stage in the session (SecurityNegotiation,\n   LoginOperationalNegotiation,\
    \ FullFeaturePhase) and may indicate the\n   next stage to which they want to\
    \ move (see Chapter 5).  The next\n   stage value is only valid  when the T bit\
    \ is 1; otherwise, it is\n   reserved.\n   The stage codes are:\n      - 0 - SecurityNegotiation\n\
    \      - 1 - LoginOperationalNegotiation\n      - 3 - FullFeaturePhase\n   All\
    \ other codes are reserved.\n"
- title: 10.12.4.  Version
  contents:
  - "10.12.4.  Version\n   The version number of the current draft is 0x00.  As such,\
    \ all\n   devices MUST carry version 0x00 for both Version-min and Version-max.\n"
- title: 10.12.4.1.  Version-max
  contents:
  - "10.12.4.1.  Version-max\n   Maximum Version number supported.\n   All Login Requests\
    \ within the Login Phase MUST carry the same\n   Version-max.\n   The target MUST\
    \ use the value presented with the first Login Request.\n"
- title: 10.12.4.2.  Version-min
  contents:
  - "10.12.4.2.  Version-min\n   All Login Requests within the Login Phase MUST carry\
    \ the same\n   Version-min.  The target MUST use the value presented with the\
    \ first\n   Login Request.\n"
- title: 10.12.5.  ISID
  contents:
  - "10.12.5.  ISID\n   This is an initiator-defined component of the session identifier\
    \ and\n   is structured as follows (see [RFC3721] and Section 9.1.1\n   Conservative\
    \ Reuse of ISIDs for details):\n    Byte/     0       |       1       |      \
    \ 2       |       3       |\n       /              |               |         \
    \      |               |\n      |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7|\n      +---------------+---------------+---------------+---------------+\n\
    \     8| T |    A      |              B                |      C        |\n   \
    \   +---------------+---------------+---------------+---------------+\n    12|\
    \               D               |\n      +---------------+---------------+\n \
    \  The T field identifies the format and usage of A, B, C, and D as\n   indicated\
    \ below:\n     T\n     00b     OUI-Format\n             A&B are a 22 bit OUI\n\
    \             (the I/G & U/L bits are omitted)\n             C&D 24 bit qualifier\n\
    \     01b     EN - Format (IANA Enterprise Number)\n             A - Reserved\n\
    \             B&C EN (IANA Enterprise Number)\n             D - Qualifier\n  \
    \   10b     \"Random\"\n             A - Reserved\n             B&C Random\n \
    \            D - Qualifier\n     11b     A,B,C&D Reserved\n   For the T field\
    \ values 00b and 01b, a combination of A and B (for\n   00b) or B and C (for 01b)\
    \ identifies the vendor or organization whose\n   component (software or hardware)\
    \ generates this ISID.  A vendor or\n   organization with one or more OUIs, or\
    \ one or more Enterprise\n   Numbers, MUST use at least one of these numbers and\
    \ select the\n   appropriate value for the T field when its components generate\
    \ ISIDs.\n   An OUI or EN MUST be set in the corresponding fields in network byte\n\
    \   order (byte big-endian).\n   If the T field is 10b, B and C are set to a random\
    \ 24-bit unsigned\n   integer value in network byte order (byte big-endian). \
    \ See [RFC3721]\n   for how this affects the principle of \"conservative reuse\"\
    .\n   The Qualifier field is a 16 or 24-bit unsigned integer value that\n   provides\
    \ a range of possible values for the ISID within the selected\n   namespace. \
    \ It may be set to any value within the constraints\n   specified in the iSCSI\
    \ protocol (see Section 3.4.3 Consequences of\n   the Model and Section 9.1.1\
    \ Conservative Reuse of ISIDs).\n   The T field value of 11b is reserved.\n  \
    \ If the ISID is derived from something assigned to a hardware adapter\n   or\
    \ interface by a vendor, as a preset default value, it MUST be\n   configurable\
    \ to a value assigned according to the SCSI port behavior\n   desired by the system\
    \ in which it is installed (see Section 9.1.1\n   Conservative Reuse of ISIDs\
    \ and Section 9.1.2 iSCSI Name, ISID, and\n   TPGT Use).  The resultant ISID MUST\
    \ also be persistent over power\n   cycles, reboot, card swap, etc.\n"
- title: 10.12.6.  TSIH
  contents:
  - "10.12.6.  TSIH\n   TSIH must be set in the first Login Request.  The reserved\
    \ value 0\n   MUST be used on the first connection for a new session.  Otherwise,\n\
    \   the TSIH sent by the target at the conclusion of the successful login\n  \
    \ of the first connection for this session MUST be used.  The TSIH\n   identifies\
    \ to the target the associated existing session for this new\n   connection.\n\
    \   All Login Requests within a Login Phase MUST carry the same TSIH.\n   The\
    \ target MUST check the value presented with the first Login\n   Request and act\
    \ as specified in Section 5.3.1 Login Phase Start.\n"
- title: 10.12.7.  Connection ID - CID
  contents:
  - "10.12.7.  Connection ID - CID\n   A unique ID for this connection within the\
    \ session.\n   All Login Requests within the Login Phase MUST carry the same CID.\n\
    \   The target MUST use the value presented with the first Login Request.\n  \
    \ A Login Request with a non-zero TSIH and a CID equal to that of an\n   existing\
    \ connection implies a logout of the connection followed by a\n   Login (see Section\
    \ 5.3.4 Connection Reinstatement).  For the details\n   of the implicit Logout\
    \ Request, see Section 10.14 Logout Request.\n"
- title: 10.12.8.  CmdSN
  contents:
  - "10.12.8.  CmdSN\n   CmdSN is either the initial command sequence number of a\
    \ session (for\n   the first Login Request of a session - the \"leading\" login),\
    \ or the\n   command sequence number in the command stream if the login is for\
    \ a\n   new connection in an existing session.\n   Examples:\n      -  Login on\
    \ a leading connection - if the leading login carries\n         the CmdSN 123,\
    \ all other Login Requests in the same Login Phase\n         carry the CmdSN 123\
    \ and the first non-immediate command in\n         FullFeaturePhase also carries\
    \ the CmdSN 123.\n      -  Login on other than a leading connection - if the current\
    \ CmdSN\n         at the time the first login on the connection is issued is 500,\n\
    \         then that PDU carries CmdSN=500.  Subsequent Login Requests\n      \
    \   that are needed to complete this Login Phase may carry a CmdSN\n         higher\
    \ than 500 if non-immediate requests that were issued on\n         other connections\
    \ in the same session advance CmdSN.\n   If the Login Request is a leading Login\
    \ Request, the target MUST use\n   the value presented in CmdSN as the target\
    \ value for ExpCmdSN.\n"
- title: 10.12.9.  ExpStatSN
  contents:
  - "10.12.9.  ExpStatSN\n   For the first Login Request on a connection this is ExpStatSN\
    \ for the\n   old connection and this field is only valid if the Login Request\n\
    \   restarts a connection (see Section 5.3.4 Connection Reinstatement).\n   For\
    \ subsequent Login Requests it is used to acknowledge the Login\n   Responses\
    \ with their increasing StatSN values.\n"
- title: 10.12.10.  Login Parameters
  contents:
  - "10.12.10.  Login Parameters\n   The initiator MUST provide some basic parameters\
    \ in order to enable\n   the target to determine if the initiator may use the\
    \ target's\n   resources and the initial text parameters for the security exchange.\n\
    \   All the rules specified in Section 10.10.5 Text for text requests\n   also\
    \ hold for Login Requests.  Keys and their explanations are listed\n   in Chapter\
    \ 11 (security negotiation keys) and Chapter 12 (operational\n   parameter negotiation\
    \ keys).  All keys in Chapter 12, except for the\n   X extension formats, MUST\
    \ be supported by iSCSI initiators and\n   targets.  Keys in Chapter 11 only need\
    \ to be supported when the\n   function to which they refer is mandatory to implement.\n"
- title: 10.13.  Login Response
  contents:
  - "10.13.  Login Response\n   The Login Response indicates the progress and/or end\
    \ of the Login\n   Phase.\n   Byte/     0       |       1       |       2    \
    \   |       3       |\n      /              |               |               |\
    \               |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x23      |T|C|.|.|CSG|NSG| Version-max   | Version-active|\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| ISID                                                          |\n    \
    \ +                               +---------------+---------------+\n   12|  \
    \                             | TSIH                          |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| Status-Class\
    \  | Status-Detail | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   40/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48/ DataSegment - Login Parameters in Text request Format         /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n"
- title: 10.13.1.  Version-max
  contents:
  - "10.13.1.  Version-max\n   This is the highest version number supported by the\
    \ target.\n   All Login Responses within the Login Phase MUST carry the same\n\
    \   Version-max.\n   The initiator MUST use the value presented as a response\
    \ to the first\n   Login Request.\n"
- title: 10.13.2.  Version-active
  contents:
  - "10.13.2.  Version-active\n   Indicates the highest version supported by the target\
    \ and initiator.\n   If the target does not support a version within the range\
    \ specified\n   by the initiator, the target rejects the login and this field\n\
    \   indicates the lowest version supported by the target.\n   All Login Responses\
    \ within the Login Phase MUST carry the same\n   Version-active.\n   The initiator\
    \ MUST use the value presented as a response to the first\n   Login Request.\n"
- title: 10.13.3.  TSIH
  contents:
  - "10.13.3.  TSIH\n   The TSIH is the target assigned session identifying handle.\
    \  Its\n   internal format and content are not defined by this protocol except\n\
    \   for the value 0 that is reserved.  With the exception of the Login\n   Final-Response\
    \ in a new session, this field should be set to the TSIH\n   provided by the initiator\
    \ in the Login Request.  For a new session,\n   the target MUST generate a non-zero\
    \ TSIH and ONLY return it in the\n   Login Final-Response (see Section 5.3 Login\
    \ Phase).\n"
- title: 10.13.4.  StatSN
  contents:
  - "10.13.4.  StatSN\n   For the first Login Response (the response to the first\
    \ Login\n   Request), this is the starting status Sequence Number for the\n  \
    \ connection.  The next response of any kind, including the next Login\n   Response,\
    \ if any, in the same Login Phase, will carry this number +\n   1.  This field\
    \ is only valid if the Status-Class is 0.\n"
- title: 10.13.5.  Status-Class and Status-Detail
  contents:
  - "10.13.5.  Status-Class and Status-Detail\n   The Status returned in a Login Response\
    \ indicates the execution\n   status of the Login Phase.  The status includes:\n\
    \     Status-Class\n     Status-Detail\n   0 Status-Class indicates success.\n\
    \   A non-zero Status-Class indicates an exception.  In this case,\n   Status-Class\
    \ is sufficient for a simple initiator to use when\n   handling exceptions, without\
    \ having to look at the Status-Detail.\n   The Status-Detail allows finer-grained\
    \ exception handling for more\n   sophisticated initiators and for better information\
    \ for logging.\n   The status classes are as follows:\n      0 - Success - indicates\
    \ that the iSCSI target successfully\n          received, understood, and accepted\
    \ the request.  The numbering\n          fields (StatSN, ExpCmdSN, MaxCmdSN) are\
    \ only valid if\n          Status-Class is 0.\n      1 - Redirection - indicates\
    \ that the initiator must take further\n          action to complete the request.\
    \  This is usually due to the\n          target moving to a different address.\
    \  All of the redirection\n          status class responses MUST return one or\
    \ more text key\n          parameters of the type \"TargetAddress\", which indicates\
    \ the\n          target's new address.  A redirection response MAY be issued by\n\
    \          a target prior or after completing a security negotiation if a\n  \
    \        security negotiation is required.  A redirection SHOULD be\n        \
    \  accepted by an initiator even without having the target\n          complete\
    \ a security negotiation if any security negotiation is\n          required, and\
    \ MUST be accepted by the initiator after the\n          completion of the security\
    \ negotiation if any security\n          negotiation is required.\n      2 - Initiator\
    \ Error (not a format error) - indicates that the\n          initiator most likely\
    \ caused the error.  This MAY be due to a\n          request for a resource for\
    \ which the initiator does not have\n          permission.  The request should\
    \ not be tried again.\n      3 - Target Error - indicates that the target sees\
    \ no errors in the\n          initiator's Login Request, but is currently incapable\
    \ of\n          fulfilling the request.  The initiator may re-try the same\n \
    \         Login Request later.\n   The table below shows all of the currently\
    \ allocated status codes.\n   The codes are in hexadecimal; the first byte is\
    \ the status class and\n   the second byte is the status detail.\n   -----------------------------------------------------------------\n\
    \   Status        | Code | Description\n                 |(hex) |\n   -----------------------------------------------------------------\n\
    \   Success       | 0000 | Login is proceeding OK (*1).\n   -----------------------------------------------------------------\n\
    \   Target moved  | 0101 | The requested iSCSI Target Name (ITN)\n   temporarily\
    \   |      |  has temporarily moved\n                 |      |  to the address\
    \ provided.\n   -----------------------------------------------------------------\n\
    \   Target moved  | 0102 | The requested ITN has permanently moved\n   permanently\
    \   |      |  to the address provided.\n   -----------------------------------------------------------------\n\
    \   Initiator     | 0200 | Miscellaneous iSCSI initiator\n   error         | \
    \     | errors.\n   ----------------------------------------------------------------\n\
    \   Authentication| 0201 | The initiator could not be\n   failure       |    \
    \  | successfully authenticated or target\n                 |      | authentication\
    \ is not supported.\n   -----------------------------------------------------------------\n\
    \   Authorization | 0202 | The initiator is not allowed access\n   failure   \
    \    |      | to the given target.\n   -----------------------------------------------------------------\n\
    \   Not found     | 0203 | The requested ITN does not\n                 |    \
    \  | exist at this address.\n   -----------------------------------------------------------------\n\
    \   Target removed| 0204 | The requested ITN has been removed and\n          \
    \       |      |no forwarding address is provided.\n   -----------------------------------------------------------------\n\
    \   Unsupported   | 0205 | The requested iSCSI version range is\n   version  \
    \     |      | not supported by the target.\n   -----------------------------------------------------------------\n\
    \   Too many      | 0206 | Too many connections on this SSID.\n   connections\
    \   |      |\n   -----------------------------------------------------------------\n\
    \   Missing       | 0207 | Missing parameters (e.g., iSCSI\n   parameter     |\
    \      | Initiator and/or Target Name).\n   -----------------------------------------------------------------\n\
    \   Can't include | 0208 | Target does not support session\n   in session    |\
    \      | spanning to this connection (address).\n   -----------------------------------------------------------------\n\
    \   Session type  | 0209 | Target does not support this type of\n   not supported\
    \ |      | of session or not from this Initiator.\n   -----------------------------------------------------------------\n\
    \   Session does  | 020a | Attempt to add a connection\n   not exist     |   \
    \   | to a non-existent session.\n   -----------------------------------------------------------------\n\
    \   Invalid during| 020b | Invalid Request type during Login.\n   login      \
    \   |      |\n   -----------------------------------------------------------------\n\
    \   Target error  | 0300 | Target hardware or software error.\n   -----------------------------------------------------------------\n\
    \   Service       | 0301 | The iSCSI service or target is not\n   unavailable\
    \   |      | currently operational.\n   -----------------------------------------------------------------\n\
    \   Out of        | 0302 | The target has insufficient session,\n   resources\
    \     |      | connection, or other resources.\n   -----------------------------------------------------------------\n\
    \   (*1) If the response T bit is 1 in both the request and the matching\n   response,\
    \ and the NSG is FullFeaturePhase in both the request and the\n   matching response,\
    \ the Login Phase is finished and the initiator may\n   proceed to issue SCSI\
    \ commands.\n   If the Status Class is not 0, the initiator and target MUST close\
    \ the\n   TCP connection.\n   If the target wishes to reject the Login Request\
    \ for more than one\n   reason, it should return the primary reason for the rejection.\n"
- title: 10.13.6.  T (Transit) bit
  contents:
  - "10.13.6.  T (Transit) bit\n   The T bit is set to 1 as an indicator of the end\
    \ of the stage.  If\n   the T bit is set to 1 and NSG is FullFeaturePhase, then\
    \ this is also\n   the Final Login Response (see Chapter 5).  A T bit of 0 indicates\
    \ a\n   \"partial\" response, which means \"more negotiation needed\".\n   A Login\
    \ Response with a T bit set to 1 MUST NOT contain key=value\n   pairs that may\
    \ require additional answers from the initiator within\n   the same stage.\n \
    \  If the status class is 0, the T bit MUST NOT be set to 1 if the T bit\n   in\
    \ the request was set to 0.\n"
- title: 10.13.7.  C (Continue) Bit
  contents:
  - "10.13.7.  C (Continue) Bit\n   When set to 1,  indicates that the text (set of\
    \ key=value pairs) in\n   this Login Response is not complete (it will be continued\
    \ on\n   subsequent Login Responses); otherwise, it indicates that this Login\n\
    \   Response ends a set of key=value pairs.  A Login Response with the C\n   bit\
    \ set to 1 MUST have the T bit set to 0.\n"
- title: 10.13.8.  Login Parameters
  contents:
  - "10.13.8.  Login Parameters\n   The target MUST provide some basic parameters\
    \ in order to enable the\n   initiator to determine if it is connected to the\
    \ correct port and the\n   initial text parameters for the security exchange.\n\
    \   All the rules specified in Section 10.11.6 Text Response Data for\n   text\
    \ responses also hold for Login Responses.  Keys and their\n   explanations are\
    \ listed in Chapter 11 (security negotiation keys) and\n   Chapter 12 (operational\
    \ parameter negotiation keys).  All keys in\n   Chapter 12, except for the X extension\
    \ formats, MUST be supported by\n   iSCSI initiators and targets.  Keys in Chapter\
    \ 11, only need to be\n   supported when the function to which they refer is mandatory\
    \ to\n   implement.\n"
- title: 10.14.  Logout Request
  contents:
  - "10.14.  Logout Request\n   The Logout Request is used to perform a controlled\
    \ closing of a\n   connection.\n   An initiator MAY use a Logout Request to remove\
    \ a connection from a\n   session or to close an entire session.\n   After sending\
    \ the Logout Request PDU, an initiator MUST NOT send any\n   new iSCSI requests\
    \ on the closing connection.  If the Logout Request\n   is intended to close the\
    \ session, new iSCSI requests MUST NOT be sent\n   on any of the connections participating\
    \ in the session.\n   When receiving a Logout Request with the reason code of\
    \ \"close the\n   connection\" or \"close the session\", the target MUST terminate\
    \ all\n   pending commands, whether acknowledged via ExpCmdSN or not, on that\n\
    \   connection or session respectively.\n   When receiving a Logout Request with\
    \ the reason code \"remove\n   connection for recovery\", the target MUST discard\
    \ all requests not\n   yet acknowledged via ExpCmdSN that were issued on the specified\n\
    \   connection, and suspend all data/status/R2T transfers on behalf of\n   pending\
    \ commands on the specified connection.\n   The target then issues the Logout\
    \ Response and half-closes the TCP\n   connection (sends FIN).  After receiving\
    \ the Logout Response and\n   attempting to receive the FIN (if still possible),\
    \ the initiator MUST\n   completely close the logging-out connection.  For the\
    \ terminated\n   commands, no additional responses should be expected.\n   A Logout\
    \ for a CID may be performed on a different transport\n   connection when the\
    \ TCP connection for the CID has already been\n   terminated.  In such a case,\
    \ only a logical \"closing\" of the iSCSI\n   connection for the CID is implied\
    \ with a Logout.\n   All commands that were not terminated or not completed (with\
    \ status)\n   and acknowledged when the connection is closed completely can be\n\
    \   reassigned to a new connection if the target supports connection\n   recovery.\n\
    \   If an initiator intends to start recovery for a failing connection,\n   it\
    \ MUST use the Logout Request to \"clean-up\" the target end of a\n   failing\
    \ connection and enable recovery to start, or the Login Request\n   with a non-zero\
    \ TSIH and the same CID on a new connection for the\n   same effect (see Section\
    \ 10.14.3 CID).  In sessions with a single\n   connection, the connection can\
    \ be closed and then a new connection\n   reopened.  A connection reinstatement\
    \ login can be used for recovery\n   (see Section 5.3.4 Connection Reinstatement).\n\
    \   A successful completion of a Logout Request with the reason code of\n   \"\
    close the connection\" or \"remove the connection for recovery\"\n   results at\
    \ the target in the discarding of unacknowledged commands\n   received on the\
    \ connection being logged out.  These are commands that\n   have arrived on the\
    \ connection being logged out, but have not been\n   delivered to SCSI because\
    \ one or more commands with a smaller CmdSN\n   has not been received by iSCSI.\
    \  See Section 3.2.2.1 Command\n   Numbering and Acknowledging.  The resulting\
    \ holes the in command\n   sequence numbers will have to be handled by appropriate\
    \ recovery (see\n   Chapter 6) unless the session is also closed.\n   The entire\
    \ logout discussion in this section is also applicable for\n   an implicit Logout\
    \ realized via a connection reinstatement or session\n   reinstatement.  When\
    \ a Login Request performs an implicit Logout, the\n   implicit Logout is performed\
    \ as if having the reason codes specified\n   below:\n     Reason code       \
    \ Type of implicit Logout\n     -------------------------------------------\n\
    \         0              session reinstatement\n         1              connection\
    \ reinstatement when\n                       the operational ErrorRecoveryLevel\
    \ < 2\n         2              connection reinstatement when\n               \
    \        the operational ErrorRecoveryLevel = 2\n   Byte/     0       |      \
    \ 1       |       2       |       3       |\n      /              |          \
    \     |               |               |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|I| 0x06      |1| Reason Code | Reserved                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------------------------------------------------------+\n\
    \    8/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| CID\
    \ or Reserved               | Reserved                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| CmdSN                                                         |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \                                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n"
- title: 10.14.1.  Reason Code
  contents:
  - "10.14.1.  Reason Code\n   Reason Code indicates the reason for Logout as follows:\n\
    \      0 - close the session.  All commands associated with the session\n    \
    \      (if any) are terminated.\n      1 - close the connection.  All commands\
    \ associated with connection\n          (if any) are terminated.\n      2 - remove\
    \ the connection for recovery.  Connection is closed and\n          all commands\
    \ associated with it, if any, are to be prepared\n          for a new allegiance.\n\
    \   All other values are reserved.\n"
- title: 10.14.2.  TotalAHSLength and DataSegmentLength
  contents:
  - "10.14.2.  TotalAHSLength and DataSegmentLength\n   For this PDU TotalAHSLength\
    \ and DataSegmentLength MUST be 0.\n"
- title: 10.14.3.  CID
  contents:
  - "10.14.3.  CID\n   This is the connection ID of the connection to be closed (including\n\
    \   closing the TCP stream).  This field is only valid if the reason code\n  \
    \ is not \"close the session\".\n"
- title: 10.14.4.  ExpStatSN
  contents:
  - "10.14.4.  ExpStatSN\n   This is the last ExpStatSN value for the connection to\
    \ be closed.\n"
- title: 10.14.5.  Implicit termination of tasks
  contents:
  - "10.14.5.  Implicit termination of tasks\n   A target implicitly terminates the\
    \ active tasks due to the iSCSI\n   protocol in the following cases:\n      a)\
    \  When a connection is implicitly or explicitly logged out with\n          the\
    \ reason code of \"Close the connection\" and there are active\n          tasks\
    \ allegiant to that connection.\n      b)  When a connection fails and eventually\
    \ the connection state\n          times out (state transition M1 in Section 7.2.2\
    \ State\n          Transition Descriptions for Initiators and Targets) and there\n\
    \          are active tasks allegiant to that connection.\n      c)  When a successful\
    \ recovery Logout is performed while there are\n          active tasks allegiant\
    \ to that connection, and those tasks\n          eventually time out after the\
    \ Time2Wait and Time2Retain\n          periods without allegiance reassignment.\n\
    \      d)  When a connection is implicitly or explicitly logged out with\n   \
    \       the reason code of \"Close the session\" and there are active\n      \
    \    tasks in that session.\n   If the tasks terminated in any of the above cases\
    \ are SCSI tasks,\n   they must be internally terminated as if with CHECK CONDITION\
    \ status.\n   This status is only meaningful for appropriately handling the\n\
    \   internal SCSI state and SCSI side effects with respect to ordering\n   because\
    \ this status is never communicated back as a terminating\n   status to the initiator.\
    \ However additional actions may have to be\n   taken at SCSI level depending\
    \ on the SCSI context as defined by the\n   SCSI standards (e.g., queued commands\
    \ and ACA, in cases a), b), and\n   c), after the tasks are terminated, the target\
    \ MUST report a Unit\n   Attention condition on the next command processed on\
    \ any connection\n   for each affected I_T_L nexus with the status of CHECK CONDITION,\
    \ and\n   the ASC/ASCQ value of 47h/7Fh - \"SOME COMMANDS CLEARED BY ISCSI\n \
    \  PROTOCOL EVENT\" - etc. - see [SAM2] and [SPC3]).\n"
- title: 10.15.  Logout Response
  contents:
  - "10.15.  Logout Response\n   The Logout Response is used by the target to indicate\
    \ if the cleanup\n   operation for the connection(s) has completed.\n   After\
    \ Logout, the TCP connection referred by the CID MUST be closed\n   at both ends\
    \ (or all connections must be closed if the logout reason\n   was session close).\n\
    \   Byte/     0       |       1       |       2       |       3       |\n    \
    \  /              |               |               |               |\n     |0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x26      |1| Reserved    | Response      | Reserved      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------------------------------------------------------+\n\
    \    8/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag                                            |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| Reserved\
    \                                                      |\n     +---------------------------------------------------------------+\n\
    \   40| Time2Wait                     | Time2Retain                   |\n    \
    \ +---------------+---------------+---------------+---------------+\n   44| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n"
- title: 10.15.1.  Response
  contents:
  - "10.15.1.  Response\n   Logout Response:\n      0 - connection or session closed\
    \ successfully.\n      1 - CID not found.\n      2 - connection recovery is not\
    \ supported.  If Logout reason code\n         was recovery and target does not\
    \ support it as indicated by the\n         ErrorRecoveryLevel.\n      3 - cleanup\
    \ failed for various reasons.\n"
- title: 10.15.2.  TotalAHSLength and DataSegmentLength
  contents:
  - "10.15.2.  TotalAHSLength and DataSegmentLength\n   For this PDU TotalAHSLength\
    \ and DataSegmentLength MUST be 0.\n"
- title: 10.15.3.  Time2Wait
  contents:
  - "10.15.3.  Time2Wait\n   If the Logout Response code is 0 and if the operational\n\
    \   ErrorRecoveryLevel is 2, this is the minimum amount of time, in\n   seconds,\
    \ to wait before attempting task reassignment.  If the Logout\n   Response code\
    \ is 0 and if the operational ErrorRecoveryLevel is less\n   than 2, this field\
    \ is to be ignored.\n   This field is invalid if the Logout Response code is 1.\n\
    \   If the Logout response code is 2 or 3, this field specifies the\n   minimum\
    \ time to wait before attempting a new implicit or explicit\n   logout.\n   If\
    \ Time2Wait is 0, the reassignment or a new Logout may be attempted\n   immediately.\n"
- title: 10.15.4.  Time2Retain
  contents:
  - "10.15.4.  Time2Retain\n   If the Logout response code is 0 and if the operational\n\
    \   ErrorRecoveryLevel is 2, this is the maximum amount of time, in\n   seconds,\
    \ after the initial wait (Time2Wait), the target waits for the\n   allegiance\
    \ reassignment for any active task after which the task\n   state is discarded.\
    \  If the Logout response code is 0 and if the\n   operational ErrorRecoveryLevel\
    \ is less than 2, this field is to be\n   ignored.\n   This field is invalid if\
    \ the Logout response code is 1.\n   If the Logout response code is 2 or 3, this\
    \ field specifies the\n   maximum amount of time, in seconds, after the initial\
    \ wait\n   (Time2Wait), the target waits for a new implicit or explicit logout.\n\
    \   If it is the last connection of a session, the whole session state is\n  \
    \ discarded after Time2Retain.\n   If Time2Retain is 0, the target has already\
    \ discarded the connection\n   (and possibly the session) state along with the\
    \ task states.  No\n   reassignment or Logout is required in this case.\n"
- title: 10.16.  SNACK Request
  contents:
  - "10.16.  SNACK Request\n   Byte/     0       |       1       |       2       |\
    \       3       |\n      /              |               |               |    \
    \           |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4\
    \ 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|.| 0x10      |1|.|.|.| Type  | Reserved                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Reserved                                               |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag or 0xffffffff                              |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag or SNACK Tag or 0xffffffff                |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| Reserved                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \                                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   40| BegRun                                                        |\n    \
    \ +---------------------------------------------------------------+\n   44| RunLength\
    \                                                     |\n     +---------------------------------------------------------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   If the\
    \ implementation supports ErrorRecoveryLevel greater than zero,\n   it MUST support\
    \ all SNACK types.\n   The SNACK is used by the initiator to request the retransmission\
    \ of\n   numbered-responses, data, or R2T PDUs from the target.  The SNACK\n \
    \  request indicates the numbered-responses or data \"runs\" whose\n   retransmission\
    \ is requested by the target, where the run starts with\n   the first StatSN,\
    \ DataSN, or R2TSN whose retransmission is requested\n   and indicates the number\
    \ of Status, Data, or R2T PDUs requested\n   including the first.  0 has special\
    \ meaning when used as a starting\n   number and length:\n     - When used in\
    \ RunLength, it means all PDUs starting with the\n       initial.\n     - When\
    \ used in both BegRun and RunLength, it means all\n       unacknowledged PDUs.\n\
    \   The numbered-response(s) or R2T(s), requested by a SNACK, MUST be\n   delivered\
    \ as exact replicas of the ones that the target transmitted\n   originally except\
    \ for the fields ExpCmdSN, MaxCmdSN, and ExpDataSN,\n   which MUST carry the current\
    \ values.  R2T(s)requested by SNACK MUST\n   also carry the current value of StatSN.\n\
    \   The numbered Data-In PDUs, requested by a Data SNACK MUST be\n   delivered\
    \ as exact replicas of the ones that the target transmitted\n   originally except\
    \ for the fields ExpCmdSN and MaxCmdSN, which MUST\n   carry the current values\
    \ and except for resegmentation (see Section\n   10.16.3 Resegmentation).\n  \
    \ Any SNACK that requests a numbered-response, Data, or R2T that was\n   not sent\
    \ by the target or was already acknowledged by the initiator,\n   MUST be rejected\
    \ with a reason code of \"Protocol error\".\n"
- title: 10.16.1.  Type
  contents:
  - "10.16.1.  Type\n   This field encodes the SNACK function as follows:\n      0-Data/R2T\
    \ SNACK - requesting retransmission of one or more Data-\n        In or R2T PDUs.\n\
    \      1-Status SNACK - requesting retransmission of one or more numbered\n  \
    \      responses.\n      2-DataACK - positively acknowledges Data-In PDUs.\n \
    \     3-R-Data SNACK - requesting retransmission of Data-In PDUs with\n      \
    \  possible resegmentation and status tagging.\n   All other values are reserved.\n\
    \   Data/R2T SNACK, Status SNACK, or R-Data SNACK for a command MUST\n   precede\
    \ status acknowledgement for the given command.\n"
- title: 10.16.2.  Data Acknowledgement
  contents:
  - "10.16.2.  Data Acknowledgement\n   If an initiator operates at ErrorRecoveryLevel\
    \ 1 or higher, it MUST\n   issue a SNACK of type DataACK after receiving a Data-In\
    \ PDU with the\n   A bit set to 1.  However, if the initiator has detected holes\
    \ in the\n   input sequence, it MUST postpone issuing the SNACK of type DataACK\n\
    \   until the holes are filled.  An initiator MAY ignore the A bit if it\n   deems\
    \ that the bit is being set aggressively by the target (i.e.,\n   before the MaxBurstLength\
    \ limit is reached).\n   The DataACK is used to free resources at the target and\
    \ not to\n   request or imply data retransmission.\n   An initiator MUST NOT request\
    \ retransmission for any data it had\n   already acknowledged.\n"
- title: 10.16.3.  Resegmentation
  contents:
  - "10.16.3.  Resegmentation\n   If the initiator MaxRecvDataSegmentLength changed\
    \ between the\n   original transmission and the time the initiator requests\n\
    \   retransmission, the initiator MUST issue a R-Data SNACK (see Section\n   10.16.1\
    \ Type).  With R-Data SNACK, the initiator indicates that it\n   discards all\
    \ the unacknowledged data and expects the target to resend\n   it.  It also expects\
    \ resegmentation.  In this case, the retransmitted\n   Data-In PDUs MAY be different\
    \ from the ones originally sent in order\n   to reflect changes in MaxRecvDataSegmentLength.\
    \  Their DataSN starts\n   with the BegRun of the last DataACK received by the\
    \ target if any was\n   received; otherwise it starts with 0 and is increased\
    \ by 1 for each\n   resent Data-In PDU.\n   A target that has received a R-Data\
    \ SNACK MUST return a SCSI Response\n   that contains a copy of the SNACK Tag\
    \ field from the R-Data SNACK in\n   the SCSI Response SNACK Tag field as its\
    \ last or only Response.  For\n   example, if it has already sent a response containing\
    \ another value\n   in the SNACK Tag field or had the status included in the last\
    \ Data-In\n   PDU, it must send a new SCSI Response PDU.  If a target sends more\n\
    \   than one SCSI Response PDU due to this rule, all SCSI responses must\n   carry\
    \ the same StatSN (see Section 10.4.4 SNACK Tag).  If an\n   initiator attempts\
    \ to recover a lost SCSI Response (with a\n   Status SNACK, see Section 10.16.1\
    \ Type) when more than one response\n   has been sent, the target will send the\
    \ SCSI Response with the latest\n   content known to the target, including the\
    \ last SNACK Tag for the\n   command.\n   For considerations in allegiance reassignment\
    \ of a task to a\n   connection with a different MaxRecvDataSegmentLength, refer\
    \ to\n   Section 6.2.2 Allegiance Reassignment.\n"
- title: 10.16.4.  Initiator Task Tag
  contents:
  - "10.16.4.  Initiator Task Tag\n   For Status SNACK and DataACK, the Initiator\
    \ Task Tag MUST be set to\n   the reserved value 0xffffffff.  In all other cases,\
    \ the Initiator\n   Task Tag field MUST be set to the Initiator Task Tag of the\n\
    \   referenced command.\n"
- title: 10.16.5.  Target Transfer Tag or SNACK Tag
  contents:
  - "10.16.5.  Target Transfer Tag or SNACK Tag\n   For an R-Data SNACK, this field\
    \ MUST contain a value that is\n   different from 0 or 0xffffffff and is unique\
    \ for the task (identified\n   by the Initiator Task Tag).  This value MUST be\
    \ copied by the iSCSI\n   target in the last or only SCSI Response PDU it issues\
    \ for the\n   command.\n   For DataACK, the Target Transfer Tag MUST contain a\
    \ copy of the\n   Target Transfer Tag and LUN provided with the SCSI Data-In PDU\
    \ with\n   the A bit set to 1.\n   In all other cases, the Target Transfer Tag\
    \ field MUST be set to the\n   reserved value of 0xffffffff.\n"
- title: 10.16.6.  BegRun
  contents:
  - "10.16.6.  BegRun\n   The DataSN, R2TSN, or StatSN of the first PDU whose retransmission\
    \ is\n   requested (Data/R2T and Status SNACK), or the next expected DataSN\n\
    \   (DataACK SNACK).\n   BegRun 0 when used in conjunction with RunLength 0 means\
    \ resend all\n   unacknowledged Data-In, R2T or Response PDUs.\n   BegRun MUST\
    \ be 0 for a R-Data SNACK.\n"
- title: 10.16.7.  RunLength
  contents:
  - "10.16.7.  RunLength\n   The number of PDUs whose retransmission is requested.\n\
    \   RunLength 0 signals that all Data-In, R2T, or Response PDUs carrying\n   the\
    \ numbers equal to or greater than BegRun have to be resent.\n   The RunLength\
    \ MUST also be 0 for a DataACK SNACK in addition to\n   R-Data SNACK.\n"
- title: 10.17.  Reject
  contents:
  - "10.17.  Reject\n   Byte/     0       |       1       |       2       |      \
    \ 3       |\n      /              |               |               |          \
    \     |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n\
    \     +---------------+---------------+---------------+---------------+\n    0|.|.|\
    \ 0x3f      |1| Reserved    | Reason        | Reserved      |\n     +---------------+---------------+---------------+---------------+\n\
    \    4|TotalAHSLength | DataSegmentLength                             |\n    \
    \ +---------------+---------------+---------------+---------------+\n    8/ Reserved\
    \                                                      /\n    +/             \
    \                                                  /\n     +---------------+---------------+---------------+---------------+\n\
    \   16| 0xffffffff                                                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36| DataSN/R2TSN\
    \ or Reserved                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   40| Reserved                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   44| Reserved\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   xx/ Complete\
    \ Header of Bad PDU                                    /\n    +/             \
    \                                                  /\n     +---------------+---------------+---------------+---------------+\n\
    \   yy/Vendor specific data (if any)                                  /\n    \
    \ /                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   zz| Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   Reject\
    \ is used to indicate an iSCSI error condition (protocol,\n   unsupported option,\
    \ etc.).\n"
- title: 10.17.1.  Reason
  contents:
  - "10.17.1.  Reason\n   The reject Reason is coded as follows:\n   +------+----------------------------------------+------------------+\n\
    \   | Code | Explanation                            | Can the original |\n   |\
    \ (hex)|                                        | PDU be re-sent?  |\n   +------+----------------------------------------+------------------+\n\
    \   | 0x01 | Reserved                               | no               |\n   |\
    \      |                                        |                  |\n   | 0x02\
    \ | Data (payload) Digest Error            | yes  (Note 1)    |\n   |      | \
    \                                       |                  |\n   | 0x03 | SNACK\
    \ Reject                           | yes              |\n   |      |         \
    \                               |                  |\n   | 0x04 | Protocol Error\
    \ (e.g., SNACK request for| no               |\n   |      | a status that was\
    \ already acknowledged)|                  |\n   |      |                     \
    \                   |                  |\n   | 0x05 | Command not supported  \
    \                | no               |\n   |      |                           \
    \             |                  |\n   | 0x06 | Immediate Command Reject - too\
    \ many    | yes              |\n   |      | immediate commands               \
    \      |                  |\n   |      |                                     \
    \   |                  |\n   | 0x07 | Task in progress                       |\
    \ no               |\n   |      |                                        |   \
    \               |\n   | 0x08 | Invalid Data ACK                       | no   \
    \            |\n   |      |                                        |         \
    \         |\n   | 0x09 | Invalid PDU field                      | no   (Note 2)\
    \    |\n   |      |                                        |                 \
    \ |\n   | 0x0a | Long Operation Reject - Can't generate | yes              |\n\
    \   |      | Target Transfer Tag - out of resources |                  |\n   |\
    \      |                                        |                  |\n   | 0x0b\
    \ | Negotiation Reset                      | no               |\n   |      | \
    \                                       |                  |\n   | 0x0c | Waiting\
    \ for Logout                     | no               |\n   +------+----------------------------------------+------------------+\n\
    \   Note 1: For iSCSI, Data-Out PDU retransmission is only done if the\n   target\
    \ requests retransmission with a recovery R2T.  However, if this\n   is the data\
    \ digest error on immediate data, the initiator may choose\n   to retransmit the\
    \ whole PDU including the immediate data.\n   Note 2: A target should use this\
    \ reason code for all invalid values\n   of PDU fields that are meant to describe\
    \ a task,  a response, or a\n   data transfer.  Some examples are invalid TTT/ITT,\
    \ buffer offset, LUN\n   qualifying a TTT, and an invalid sequence number in a\
    \ SNACK.\n   All other values for Reason are reserved.\n   In all the cases in\
    \ which a pre-instantiated SCSI task is terminated\n   because of the reject,\
    \ the target MUST issue a proper SCSI command\n   response with CHECK CONDITION\
    \ as described in Section 10.4.3\n   Response.  In these cases in which a status\
    \ for the SCSI task was\n   already sent before the reject, no additional status\
    \ is required.  If\n   the error is detected while data from the initiator is\
    \ still expected\n   (i.e., the command PDU did not contain all the data and the\
    \ target\n   has not received a Data-Out PDU with the Final bit set to 1 for the\n\
    \   unsolicited data, if any, and all outstanding R2Ts, if any), the\n   target\
    \ MUST wait until it receives the last expected Data-Out PDUs\n   with the F bit\
    \ set to 1 before sending the Response PDU.\n   For additional usage semantics\
    \ of Reject PDU, see Section 6.3 Usage\n   Of Reject PDU in Recovery.\n"
- title: 10.17.2.  DataSN/R2TSN
  contents:
  - "10.17.2.  DataSN/R2TSN\n   This field is only valid if the rejected PDU is a\
    \ Data/R2T SNACK and\n   the Reject reason code is \"Protocol error\" (see Section\
    \ 10.16 SNACK\n   Request).  The DataSN/R2TSN is the next Data/R2T sequence number\
    \ that\n   the target would send for the task, if any.\n"
- title: 10.17.3.  StatSN, ExpCmdSN and MaxCmdSN
  contents:
  - "10.17.3.  StatSN, ExpCmdSN and MaxCmdSN\n   These fields carry their usual values\
    \ and are not related to the\n   rejected command. StatSN is advanced after a\
    \ Reject.\n"
- title: 10.17.4.  Complete Header of Bad PDU
  contents:
  - "10.17.4.  Complete Header of Bad PDU\n   The target returns the header (not including\
    \ digest) of the PDU in\n   error as the data of the response.\n"
- title: 10.18.  NOP-Out
  contents:
  - "10.18.  NOP-Out\n   Byte/     0       |       1       |       2       |     \
    \  3       |\n      /              |               |               |         \
    \      |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6\
    \ 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0|.|I| 0x00      |1| Reserved                                    |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4|TotalAHSLength\
    \ | DataSegmentLength                             |\n     +---------------+---------------+---------------+---------------+\n\
    \    8| LUN or Reserved                                               |\n    \
    \ +                                                               +\n   12|  \
    \                                                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag or 0xffffffff                              |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| CmdSN                                                         |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpStatSN\
    \                                                     |\n     +---------------+---------------+---------------+---------------+\n\
    \   32/ Reserved                                                      /\n    +/\
    \                                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / DataSegment\
    \ - Ping Data (optional)                            /\n    +/                \
    \                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   A NOP-Out\
    \ may be used by an initiator as a \"ping request\" to verify\n   that a connection/session\
    \ is still active and all its components are\n   operational.  The NOP-In response\
    \ is the \"ping echo\".\n   A NOP-Out is also sent by an initiator in response\
    \ to a NOP-In.\n   A NOP-Out may also be used to confirm a changed ExpStatSN if\
    \ another\n   PDU will not be available for a long time.\n   Upon receipt of a\
    \ NOP-In with the Target Transfer Tag set to a valid\n   value (not the reserved\
    \ 0xffffffff), the initiator MUST respond with\n   a NOP-Out.  In this case, the\
    \ NOP-Out Target Transfer Tag MUST\n   contain a copy of the NOP-In Target Transfer\
    \ Tag.\n"
- title: 10.18.1.  Initiator Task Tag
  contents:
  - "10.18.1.  Initiator Task Tag\n   The NOP-Out MUST have the Initiator Task Tag\
    \ set to a valid value\n   only if a response in the form of NOP-In is requested\
    \ (i.e., the\n   NOP-Out is used as a ping request).  Otherwise, the Initiator\
    \ Task\n   Tag MUST be set to 0xffffffff.\n   When a target receives the NOP-Out\
    \ with a valid Initiator Task Tag,\n   it MUST respond with a Nop-In Response\
    \ (see Section 10.19 NOP-In).\n   If the Initiator Task Tag contains 0xffffffff,\
    \ the I bit MUST be set\n   to 1 and the CmdSN is not advanced after this PDU\
    \ is sent.\n"
- title: 10.18.2.  Target Transfer Tag
  contents:
  - "10.18.2.  Target Transfer Tag\n   A target assigned identifier for the operation.\n\
    \   The NOP-Out MUST only have the Target Transfer Tag set if it is\n   issued\
    \ in response to a NOP-In with a valid Target Transfer Tag.  In\n   this case,\
    \ it copies the Target Transfer Tag from the NOP-In PDU.\n   Otherwise, the Target\
    \ Transfer Tag MUST be set to 0xffffffff.\n   When the Target Transfer Tag is\
    \ set to a value other than 0xffffffff,\n   the LUN field MUST also be copied\
    \ from the NOP-In.\n"
- title: 10.18.3.  Ping Data
  contents:
  - "10.18.3.  Ping Data\n   Ping data are reflected in the NOP-In Response.  The\
    \ length of the\n   reflected data are limited to MaxRecvDataSegmentLength.  The\
    \ length\n   of ping data are indicated by the DataSegmentLength.  0 is a valid\n\
    \   value for the DataSegmentLength and indicates the absence of ping\n   data.\n"
- title: 10.19.  NOP-In
  contents:
  - "10.19.  NOP-In\n   Byte/     0       |       1       |       2       |      \
    \ 3       |\n      /             |               |               |           \
    \    |\n     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n\
    \     +---------------+---------------+---------------+---------------+\n    0|.|.|\
    \ 0x20      |1| Reserved                                    |\n     +---------------+---------------+---------------+---------------+\n\
    \    4|TotalAHSLength | DataSegmentLength                             |\n    \
    \ +---------------+---------------+---------------+---------------+\n    8| LUN\
    \ or Reserved                                               |\n     +        \
    \                                                       +\n   12|            \
    \                                                   |\n     +---------------+---------------+---------------+---------------+\n\
    \   16| Initiator Task Tag or 0xffffffff                              |\n    \
    \ +---------------+---------------+---------------+---------------+\n   20| Target\
    \ Transfer Tag or 0xffffffff                             |\n     +---------------+---------------+---------------+---------------+\n\
    \   24| StatSN                                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   28| ExpCmdSN\
    \                                                      |\n     +---------------+---------------+---------------+---------------+\n\
    \   32| MaxCmdSN                                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n   36/ Reserved\
    \                                                      /\n    +/             \
    \                                                  /\n     +---------------+---------------+---------------+---------------+\n\
    \   48| Header-Digest (Optional)                                      |\n    \
    \ +---------------+---------------+---------------+---------------+\n     / DataSegment\
    \ - Return Ping Data                                /\n    +/                \
    \                                               /\n     +---------------+---------------+---------------+---------------+\n\
    \     | Data-Digest (Optional)                                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n   NOP-In\
    \ is either sent by a target as a response to a NOP-Out, as a\n   \"ping\" to\
    \ an initiator, or as a means to carry a changed ExpCmdSN\n   and/or MaxCmdSN\
    \ if another PDU will not be available for a long time\n   (as determined by the\
    \ target).\n   When a target receives the NOP-Out with a valid Initiator Task\
    \ Tag\n   (not the reserved value 0xffffffff), it MUST respond with a NOP-In\n\
    \   with the same Initiator Task Tag that was provided in the NOP-Out\n   request.\
    \  It MUST also duplicate up to the first\n   MaxRecvDataSegmentLength bytes of\
    \ the initiator provided Ping Data.\n   For such a response, the Target Transfer\
    \ Tag MUST be 0xffffffff.\n   Otherwise, when a target sends a NOP-In that is\
    \ not a response to a\n   Nop-Out received from the initiator, the Initiator Task\
    \ Tag MUST be\n   set to 0xffffffff and the Data Segment MUST NOT contain any\
    \ data\n   (DataSegmentLength MUST be 0).\n"
- title: 10.19.1.  Target Transfer Tag
  contents:
  - "10.19.1.  Target Transfer Tag\n   If the target is responding to a NOP-Out, this\
    \ is set to the reserved\n   value 0xffffffff.\n   If the target is sending a\
    \ NOP-In as a Ping (intending to receive a\n   corresponding NOP-Out), this field\
    \ is set to a valid value (not the\n   reserved 0xffffffff).\n   If the target\
    \ is initiating a NOP-In without wanting to receive a\n   corresponding NOP-Out,\
    \ this field MUST hold the reserved value of\n   0xffffffff.\n"
- title: 10.19.2.  StatSN
  contents:
  - "10.19.2.  StatSN\n   The StatSN field will always contain the next StatSN.  However,\
    \ when\n   the Initiator Task Tag is set to 0xffffffff, StatSN for the\n   connection\
    \ is not advanced after this PDU is sent.\n"
- title: 10.19.3.  LUN
  contents:
  - "10.19.3.  LUN\n   A LUN MUST be set to a correct value when the Target Transfer\
    \ Tag is\n   valid (not the reserved value 0xffffffff).\n"
- title: 11.  iSCSI Security Text Keys and Authentication Methods
  contents:
  - "11.  iSCSI Security Text Keys and Authentication Methods\n   Only the following\
    \ keys are used during the SecurityNegotiation stage\n   of the Login Phase:\n\
    \     SessionType\n     InitiatorName\n     TargetName\n     TargetAddress\n \
    \    InitiatorAlias\n     TargetAlias\n     TargetPortalGroupTag\n     AuthMethod\
    \ and the keys used by the authentication methods\n       specified under Section\
    \ 11.1 AuthMethod along with all of\n       their associated keys as well as Vendor\
    \ Specific\n       Authentication Methods.\n   Other keys MUST NOT be used.\n\
    \   SessionType, InitiatorName, TargetName, InitiatorAlias, TargetAlias,\n   and\
    \ TargetPortalGroupTag are described in Chapter 12 as they can be\n   used also\
    \ in the OperationalNegotiation stage.\n   All security keys have connection-wide\
    \ applicability.\n"
- title: 11.1.  AuthMethod
  contents:
  - "11.1.  AuthMethod\n   Use: During Login - Security Negotiation Senders: Initiator\
    \ and\n   Target Scope: connection\n   AuthMethod = <list-of-values>\n   The main\
    \ item of security negotiation is the authentication method\n   (AuthMethod).\n\
    \   The authentication methods that can be used (appear in the\n   list-of-values)\
    \ are either those listed in the following table or are\n   vendor-unique methods:\n\
    \   +------------------------------------------------------------+\n   | Name\
    \          | Description                                |\n   +------------------------------------------------------------+\n\
    \   | KRB5          | Kerberos V5 - defined in [RFC1510]         |\n   +------------------------------------------------------------+\n\
    \   | SPKM1         | Simple Public-Key GSS-API Mechanism        |\n   |     \
    \          | defined in [RFC2025]                       |\n   +------------------------------------------------------------+\n\
    \   | SPKM2         | Simple Public-Key GSS-API Mechanism        |\n   |     \
    \          | defined in [RFC2025]                       |\n   +------------------------------------------------------------+\n\
    \   | SRP           | Secure Remote Password                     |\n   |     \
    \          | defined in [RFC2945]                       |\n   +------------------------------------------------------------+\n\
    \   | CHAP          | Challenge Handshake Authentication Protocol|\n   |     \
    \          | defined in [RFC1994]                       |\n   +------------------------------------------------------------+\n\
    \   | None          | No authentication                          |\n   +------------------------------------------------------------+\n\
    \   The AuthMethod selection is followed by an \"authentication exchange\"\n \
    \  specific to the authentication method selected.\n   The authentication method\
    \ proposal may be made by either the\n   initiator or the target.  However the\
    \ initiator MUST make the first\n   step specific to the selected authentication\
    \ method as soon as it is\n   selected.  It follows that if the target makes the\
    \ authentication\n   method proposal the initiator sends the first keys(s) of\
    \ the exchange\n   together with its authentication method selection.\n   The\
    \ authentication exchange authenticates the initiator to the\n   target, and optionally,\
    \ the target to the initiator.  Authentication\n   is OPTIONAL to use but MUST\
    \ be supported by the target and initiator.\n   The initiator and target MUST\
    \ implement CHAP.  All other\n   authentication methods are OPTIONAL.\n   Private\
    \ or public extension algorithms MAY also be negotiated for\n   authentication\
    \ methods.  Whenever a private or public extension\n   algorithm is part of the\
    \ default offer (the offer made in absence of\n   explicit administrative action)\
    \ the implementer MUST ensure that CHAP\n   is listed as an alternative  in the\
    \ default offer and \"None\" is not\n   part of the default offer.\n   Extension\
    \ authentication methods MUST be named using one of the\n   following two formats:\n\
    \       a)  Z-reversed.vendor.dns_name.do_something=\n       b)  Z<#><IANA-registered-string>=\n\
    \   Authentication methods named using the Z- format are used as private\n   extensions.\
    \  Authentication methods named using the Z# format are\n   used as public extensions\
    \ that must be registered with IANA and MUST\n   be described by an informational\
    \ RFC.\n   For all of the public or private extension authentication methods,\n\
    \   the method specific keys MUST conform to the format specified in\n   Section\
    \ 5.1 Text Format for standard-label.\n   To identify the vendor for private extension\
    \ authentication methods,\n   we suggest you use the reversed DNS-name as a prefix\
    \ to the proper\n   digest names.\n   The part of digest-name following Z- and\
    \ Z# MUST conform to the\n   format for standard-label specified in Section 5.1\
    \ Text Format.\n   Support for public or private extension authentication methods\
    \ is\n   OPTIONAL.\n   The following subsections define the specific exchanges\
    \ for each of\n   the standardized authentication methods.  As mentioned earlier\
    \ the\n   first step is always done by the initiator.\n"
- title: 11.1.1.  Kerberos
  contents:
  - "11.1.1.  Kerberos\n   For KRB5 (Kerberos V5) [RFC1510] and [RFC1964], the initiator\
    \ MUST\n   use:\n      KRB_AP_REQ=<KRB_AP_REQ>\n   where KRB_AP_REQ is the client\
    \ message as defined in [RFC1510].\n   The default principal name assumed by an\
    \ iSCSI initiator or target\n   (prior to any administrative configuration action)\
    \ MUST be the iSCSI\n   Initiator Name or iSCSI Target Name respectively, prefixed\
    \ by the\n   string \"iscsi/\".\n   If the initiator authentication fails, the\
    \ target MUST respond with a\n   Login reject with \"Authentication Failure\"\
    \ status.  Otherwise, if the\n   initiator has selected the mutual authentication\
    \ option (by setting\n   MUTUAL-REQUIRED in the ap-options field of the KRB_AP_REQ),\
    \ the\n   target MUST reply with:\n      KRB_AP_REP=<KRB_AP_REP>\n   where KRB_AP_REP\
    \ is the server's response message as defined in\n   [RFC1510].\n   If mutual\
    \ authentication was selected and target authentication\n   fails, the initiator\
    \ MUST close the connection.\n   KRB_AP_REQ and KRB_AP_REP are binary-values and\
    \ their binary length\n   (not the length of the character string that represents\
    \ them in\n   encoded form) MUST not exceed 65536 bytes.\n"
- title: 11.1.2.  Simple Public-Key Mechanism (SPKM)
  contents:
  - "11.1.2.  Simple Public-Key Mechanism (SPKM)\n   For SPKM1 and SPKM2 [RFC2025],\
    \ the initiator MUST use:\n      SPKM_REQ=<SPKM-REQ>\n   where SPKM-REQ is the\
    \ first initiator token as defined in [RFC2025].\n   [RFC2025] defines situations\
    \ where each side may send an error token\n   that may cause the peer to re-generate\
    \ and resend its last token.\n   This scheme is followed in iSCSI, and the error\
    \ token syntax is:\n      SPKM_ERROR=<SPKM-ERROR>\n   However, SPKM-DEL tokens\
    \ that are defined by [RFC2025] for fatal\n   errors will not be used by iSCSI.\
    \  If the target needs to send a\n   SPKM-DEL token, it will, instead, send a\
    \ Login \"login reject\" message\n   with the \"Authentication Failure\" status\
    \ and terminate the\n   connection.  If the initiator needs to send a SPKM-DEL\
    \ token, it will\n   close the connection.\n   In the following sections, we assume\
    \ that no SPKM-ERROR tokens are\n   required.\n   If the initiator authentication\
    \ fails, the target MUST return an\n   error.  Otherwise, if the AuthMethod is\
    \ SPKM1 or if the initiator has\n   selected the mutual authentication option\
    \ (by setting mutual-state\n   bit in the options field of the REQ-TOKEN in the\
    \ SPKM-REQ), the\n   target MUST reply with:\n      SPKM_REP_TI=<SPKM-REP-TI>\n\
    \   where SPKM-REP-TI is the target token as defined in [RFC2025].\n   If mutual\
    \ authentication was selected and target authentication\n   fails, the initiator\
    \ MUST close the connection.  Otherwise, if the\n   AuthMethod is SPKM1, the initiator\
    \ MUST continue with:\n      SPKM_REP_IT=<SPKM-REP-IT>\n   where SPKM-REP-IT is\
    \ the second initiator token as defined in\n   [RFC2025].  If the initiator authentication\
    \ fails, the target MUST\n   answer with a Login reject with \"Authentication\
    \ Failure\" status.\n   SPKM requires support for very long authentication items.\n\
    \   All the SPKM-* tokens are binary-values and their binary length (not\n   the\
    \ length of the character string that represents them in encoded\n   form) MUST\
    \ not exceed 65536 bytes.\n"
- title: 11.1.3.  Secure Remote Password (SRP)
  contents:
  - "11.1.3.  Secure Remote Password (SRP)\n   For SRP [RFC2945], the initiator MUST\
    \ use:\n      SRP_U=<U> TargetAuth=Yes   /* or TargetAuth=No */\n   The target\
    \ MUST answer with a Login reject with the \"Authorization\n   Failure\" status\
    \ or reply with:\n   SRP_GROUP=<G1,G2...> SRP_s=<s>\n   Where G1,G2... are proposed\
    \ groups, in order of preference.\n   The initiator MUST either close the connection\
    \ or continue with:\n   SRP_A=<A> SRP_GROUP=<G>\n   Where G is one of G1,G2...\
    \ that were proposed by the target.\n   The target MUST answer with a Login reject\
    \ with the \"Authentication\n   Failure\" status or reply with:\n      SRP_B=<B>\n\
    \   The initiator MUST close the connection or continue with:\n      SRP_M=<M>\n\
    \   If the initiator authentication fails, the target MUST answer with a\n   Login\
    \ reject with \"Authentication Failure\" status.  Otherwise, if the\n   initiator\
    \ sent TargetAuth=Yes in the first message (requiring target\n   authentication),\
    \ the target MUST reply with:\n     SRP_HM=<H(A | M | K)>\n   If the target authentication\
    \ fails, the initiator MUST close the\n   connection.\n   Where U, s, A, B, M,\
    \ and H(A | M | K) are defined in [RFC2945] (using\n   the SHA1 hash function,\
    \ such as SRP-SHA1) and G,Gn (Gn stands for\n   G1,G2...) are identifiers of SRP\
    \ groups specified in [RFC3723].  G,\n   Gn, and U are text strings, s,A,B,M,\
    \ and H(A | M | K) are\n   binary-values.  The length of s,A,B,M and H(A | M |\
    \ K) in binary form\n   (not the length of the character string that represents\
    \ them in\n   encoded form) MUST not exceed 1024 bytes.\n   For the SRP_GROUP,\
    \ all the groups specified in [RFC3723] up to 1536\n   bits (i.e., SRP-768, SRP-1024,\
    \ SRP-1280, SRP-1536) must be supported\n   by initiators and targets.  To guarantee\
    \ interoperability, targets\n   MUST always offer \"SRP-1536\" as one of the proposed\
    \ groups.\n"
- title: 11.1.4.  Challenge Handshake Authentication Protocol (CHAP)
  contents:
  - "11.1.4.  Challenge Handshake Authentication Protocol (CHAP)\n   For CHAP [RFC1994],\
    \ in the first step, the initiator MUST send:\n      CHAP_A=<A1,A2...>\n   Where\
    \ A1,A2... are proposed algorithms, in order of preference.\n   In the second\
    \ step, the target MUST answer with a Login reject with\n   the \"Authentication\
    \ Failure\" status or reply with:\n      CHAP_A=<A> CHAP_I=<I> CHAP_C=<C>\n  \
    \ Where A is one of A1,A2... that were proposed by the initiator.\n   In the third\
    \ step, the initiator MUST continue with:\n      CHAP_N=<N> CHAP_R=<R>\n   or,\
    \ if it requires target authentication, with:\n      CHAP_N=<N> CHAP_R=<R> CHAP_I=<I>\
    \ CHAP_C=<C>\n   If the initiator authentication fails, the target MUST answer\
    \ with a\n   Login reject with \"Authentication Failure\" status.  Otherwise,\
    \ if the\n   initiator required target authentication, the target MUST either\n\
    \   answer with a Login reject with \"Authentication Failure\" or reply\n   with:\n\
    \      CHAP_N=<N> CHAP_R=<R>\n   If target authentication fails, the initiator\
    \ MUST close the\n   connection.\n   Where N, (A,A1,A2), I, C, and R are (correspondingly)\
    \ the Name,\n   Algorithm, Identifier, Challenge, and Response as defined in\n\
    \   [RFC1994], N is a text string, A,A1,A2, and I are numbers, and C and\n   R\
    \ are large-binary-values and their binary length (not the length of\n   the character\
    \ string that represents them in encoded form) MUST not\n   exceed 1024 bytes.\n\
    \   For the Algorithm, as stated in [RFC1994], one value is required to\n   be\
    \ implemented:\n       5     (CHAP with MD5)\n   To guarantee interoperability,\
    \ initiators MUST always offer it as one\n   of the proposed algorithms.\n"
- title: 12.  Login/Text Operational Text Keys
  contents:
  - "12.  Login/Text Operational Text Keys\n   Some session specific parameters MUST\
    \ only be carried on the leading\n   connection and cannot be changed after the\
    \ leading connection login\n   (e.g., MaxConnections, the maximum number of connections).\
    \  This\n   holds for a single connection session with regard to connection\n\
    \   restart.  The keys that fall into this category have the use: LO\n   (Leading\
    \ Only).\n   Keys that can only be used during login have the use: IO (initialize\n\
    \   only), while those that can be used in both the Login Phase and Full\n   Feature\
    \ Phase have the use: ALL.\n   Keys that can only be used during Full Feature\
    \ Phase use FFPO (Full\n   Feature Phase only).\n   Keys marked as Any-Stage may\
    \ also appear in the SecurityNegotiation\n   stage while all other keys described\
    \ in this chapter are operational\n   keys.\n   Keys that do not require an answer\
    \ are marked as Declarative.\n   Key scope is indicated as session-wide (SW) or\
    \ connection-only (CO).\n   Result function, wherever mentioned, states the function\
    \ that can be\n   applied to check the validity of the responder selection.  Minimum\n\
    \   means that the selected value cannot exceed the offered value.\n   Maximum\
    \ means that the selected value cannot be lower than the\n   offered value.  AND\
    \ means that the selected value must be a possible\n   result of a Boolean \"\
    and\" function with an arbitrary Boolean value\n   (e.g., if the offered value\
    \ is No the selected value must be No).  OR\n   means that the selected value\
    \ must be a possible result of a Boolean\n   \"or\" function with an arbitrary\
    \ Boolean value (e.g., if the offered\n   value is Yes the selected value must\
    \ be Yes).\n"
- title: 12.1.  HeaderDigest and DataDigest
  contents:
  - "12.1.  HeaderDigest and DataDigest\n   Use: IO\n   Senders: Initiator and Target\n\
    \   Scope: CO\n   HeaderDigest = <list-of-values>\n   DataDigest = <list-of-values>\n\
    \   Default is None for both HeaderDigest and DataDigest.\n   Digests enable the\
    \ checking of end-to-end, non-cryptographic data\n   integrity beyond the integrity\
    \ checks provided by the link layers and\n   the covering of the whole communication\
    \ path including all elements\n   that may change the network level PDUs such\
    \ as routers, switches, and\n   proxies.\n   The following table lists cyclic\
    \ integrity checksums that can be\n   negotiated for the digests and that MUST\
    \ be implemented by every\n   iSCSI initiator and target.  These digest options\
    \ only have error\n   detection significance.\n   +---------------------------------------------+\n\
    \   | Name          | Description     | Generator |\n   +---------------------------------------------+\n\
    \   | CRC32C        | 32 bit CRC      |0x11edc6f41|\n   +---------------------------------------------+\n\
    \   | None          | no digest                   |\n   +---------------------------------------------+\n\
    \   The generator polynomial for this digest is given in\n   hex-notation (e.g.,\
    \ 0x3b stands for 0011 1011 and the polynomial is\n   x**5+X**4+x**3+x+1).\n \
    \  When the Initiator and Target agree on a digest, this digest MUST be\n   used\
    \ for every PDU in Full Feature Phase.\n   Padding bytes, when present in a segment\
    \ covered by a CRC, SHOULD be\n   set to 0 and are included in the CRC.\n   The\
    \ CRC MUST be calculated by a method that produces the same\n   results as the\
    \ following process:\n      -  The PDU bits are considered as the coefficients\
    \ of a\n         polynomial M(x) of degree n-1; bit 7 of the lowest numbered\n\
    \         byte is considered the most significant bit (x^n-1), followed\n    \
    \     by bit 6 of the lowest numbered byte through bit 0 of the\n         highest\
    \ numbered byte (x^0).\n      -  The most significant 32 bits are complemented.\n\
    \      -  The polynomial is multiplied by x^32 then divided by G(x).  The\n  \
    \       generator polynomial produces a remainder R(x) of degree <= 31.\n    \
    \  -  The coefficients of R(x) are considered a 32 bit sequence.\n      -  The\
    \ bit sequence is complemented and the result is the CRC.\n      -  The CRC bits\
    \ are mapped into the digest word.  The x^31\n         coefficient in bit 7 of\
    \ the lowest numbered byte of the digest\n         continuing through to the byte\
    \ up to the x^24 coefficient in\n         bit 0 of the lowest numbered byte, continuing\
    \ with the x^23\n         coefficient in bit 7 of next byte through x^0 in bit\
    \ 0 of the\n         highest numbered byte.\n      -  Computing the CRC over any\
    \ segment (data or header) extended\n         to include the CRC built using the\
    \ generator 0x11edc6f41 will\n         always get the value 0x1c2d19ed as its\
    \ final remainder (R(x)).\n         This value is given here in its polynomial\
    \ form (i.e., not\n         mapped as the digest word).\n   For a discussion about\
    \ selection criteria for the CRC, see\n   [RFC3385].  For a detailed analysis\
    \ of the iSCSI polynomial, see\n   [Castagnoli93].\n   Private or public extension\
    \ algorithms MAY also be negotiated for\n   digests.  Whenever a private or public\
    \ digest extension algorithm is\n   part of the default offer (the offer made\
    \ in absence of explicit\n   administrative action) the implementer MUST ensure\
    \ that CRC32C is\n   listed as an alternative in the default offer and \"None\"\
    \ is not\n   part of the default offer.\n   Extension digest algorithms MUST be\
    \ named using one of the following\n   two formats:\n         a) Y-reversed.vendor.dns_name.do_something=\n\
    \         b) Y<#><IANA-registered-string>=\n   Digests named using the Y- format\
    \ are used for private purposes\n   (unregistered).  Digests named using the Y#\
    \ format (public extension)\n   must be registered with IANA and MUST be described\
    \ by an\n   informational RFC.\n   For private extension digests, to identify\
    \ the vendor, we suggest\n   you use the reversed DNS-name as a prefix to the\
    \ proper digest\n   names.\n   The part of digest-name following Y- and Y# MUST\
    \ conform to the\n   format for standard-label specified in Section 5.1 Text Format.\n\
    \   Support for public or private extension digests is OPTIONAL.\n"
- title: 12.2.  MaxConnections
  contents:
  - "12.2.  MaxConnections\n   Use: LO\n   Senders: Initiator and Target\n   Scope:\
    \ SW\n   Irrelevant when: SessionType=Discovery\n   MaxConnections=<numerical-value-from-1-to-65535>\n\
    \   Default is 1.\n   Result function is Minimum.\n   Initiator and target negotiate\
    \ the maximum number of connections\n   requested/acceptable.\n"
- title: 12.3.  SendTargets
  contents:
  - "12.3.  SendTargets\n   Use: FFPO\n   Senders: Initiator\n   Scope: SW\n   For\
    \ a complete description, see Appendix D.  - SendTargets\n   Operation -.\n"
- title: 12.4.  TargetName
  contents:
  - "12.4.  TargetName\n   Use: IO by initiator, FFPO by target - only as response\
    \ to a\n   SendTargets, Declarative, Any-Stage\n   Senders: Initiator and Target\n\
    \   Scope: SW\n   TargetName=<iSCSI-name-value>\n   Examples:\n      TargetName=iqn.1993-11.com.disk-vendor:diskarrays.sn.45678\n\
    \      TargetName=eui.020000023B040506\n   The initiator of the TCP connection\
    \ MUST provide this key to the\n   remote endpoint in the first login request\
    \ if the initiator is not\n   establishing a discovery session.  The iSCSI Target\
    \ Name specifies\n   the worldwide unique name of the target.\n   The TargetName\
    \ key may also be returned by the \"SendTargets\" text\n   request (which is its\
    \ only use when issued by a target).\n   TargetName MUST not be redeclared within\
    \ the login phase.\n"
- title: 12.5.  InitiatorName
  contents:
  - "12.5.  InitiatorName\n   Use: IO, Declarative, Any-Stage\n   Senders: Initiator\n\
    \   Scope: SW\n   InitiatorName=<iSCSI-name-value>\n   Examples:\n      InitiatorName=iqn.1992-04.com.os-vendor.plan9:cdrom.12345\n\
    \      InitiatorName=iqn.2001-02.com.ssp.users:customer235.host90\n   The initiator\
    \ of the TCP connection MUST provide this key to the\n   remote endpoint at the\
    \ first Login of the Login Phase for every\n   connection.  The InitiatorName\
    \ key enables the initiator to identify\n   itself to the remote endpoint.\n \
    \  InitiatorName MUST not be redeclared within the login phase.\n"
- title: 12.6.  TargetAlias
  contents:
  - "12.6.  TargetAlias\n   Use: ALL, Declarative, Any-Stage\n   Senders: Target\n\
    \   Scope: SW\n   TargetAlias=<iSCSI-local-name-value>\n   Examples:\n      TargetAlias=Bob-s\
    \ Disk\n      TargetAlias=Database Server 1 Log Disk\n      TargetAlias=Web Server\
    \ 3 Disk 20\n   If a target has been configured with a human-readable name or\n\
    \   description, this name SHOULD be communicated to the initiator during\n  \
    \ a Login Response PDU if SessionType=Normal (see Section 12.21\n   SessionType).\
    \  This string is not used as an identifier, nor is it\n   meant to be used for\
    \ authentication or authorization decisions.  It\n   can be displayed by the initiator's\
    \ user interface in a list of\n   targets to which it is connected.\n"
- title: 12.7.  InitiatorAlias
  contents:
  - "12.7.  InitiatorAlias\n   Use: ALL, Declarative, Any-Stage\n   Senders: Initiator\n\
    \   Scope: SW\n   InitiatorAlias=<iSCSI-local-name-value>\n   Examples:\n    \
    \  InitiatorAlias=Web Server 4\n      InitiatorAlias=spyalley.nsa.gov\n      InitiatorAlias=Exchange\
    \ Server\n   If an initiator has been configured with a human-readable name or\n\
    \   description, it SHOULD be communicated to the target during a Login\n   Request\
    \ PDU.  If not, the host name can be used instead.  This string\n   is not used\
    \ as an identifier, nor is meant to be used for\n   authentication or authorization\
    \ decisions.  It can be displayed by\n   the target's user interface in a list\
    \ of initiators to which it is\n   connected.\n"
- title: 12.8.  TargetAddress
  contents:
  - "12.8.  TargetAddress\n   Use: ALL, Declarative, Any-Stage\n   Senders: Target\n\
    \   Scope: SW\n   TargetAddress=domainname[:port][,portal-group-tag]\n   The domainname\
    \ can be specified as either a DNS host name, a\n   dotted-decimal IPv4 address,\
    \ or a bracketed IPv6 address as specified\n   in [RFC2732].\n   If the TCP port\
    \ is not specified, it is assumed to be the\n   IANA-assigned default port for\
    \ iSCSI (see Section 13 IANA\n   Considerations).\n   If the TargetAddress is\
    \ returned as the result of a redirect status\n   in a login response, the comma\
    \ and portal group tag MUST be omitted.\n   If the TargetAddress is returned within\
    \ a SendTargets response, the\n   portal group tag MUST be included.\n   Examples:\n\
    \      TargetAddress=10.0.0.1:5003,1\n      TargetAddress=[1080:0:0:0:8:800:200C:417A],65\n\
    \      TargetAddress=[1080::8:800:200C:417A]:5003,1\n      TargetAddress=computingcenter.example.com,23\n\
    \   Use of the portal-group-tag is described in Appendix D.\n   - SendTargets\
    \ Operation -.  The formats for the port and\n   portal-group-tag are the same\
    \ as the one specified in Section 12.9\n   TargetPortalGroupTag.\n"
- title: 12.9.  TargetPortalGroupTag
  contents:
  - "12.9.  TargetPortalGroupTag\n   Use: IO by target, Declarative, Any-Stage\n \
    \  Senders: Target\n   Scope: SW\n   TargetPortalGroupTag=<16-bit-binary-value>\n\
    \   Examples:\n   TargetPortalGroupTag=1\n   The target portal group tag is a\
    \ 16-bit binary-value that uniquely\n   identifies a portal group within an iSCSI\
    \ target node.  This key\n   carries the value of the tag of the portal group\
    \ that is servicing\n   the Login request.  The iSCSI target returns this key\
    \ to the\n   initiator in the Login Response PDU to the first Login Request PDU\n\
    \   that has the C bit set to 0 when TargetName is given by the\n   initiator.\n\
    \   For the complete usage expectations of this key see Section 5.3 Login\n  \
    \ Phase.\n"
- title: 12.10.  InitialR2T
  contents:
  - "12.10.  InitialR2T\n   Use: LO\n   Senders: Initiator and Target\n   Scope: SW\n\
    \   Irrelevant when: SessionType=Discovery\n   InitialR2T=<boolean-value>\n  \
    \ Examples:\n      I->InitialR2T=No\n      T->InitialR2T=No\n   Default is Yes.\n\
    \   Result function is OR.\n   The InitialR2T key is used to turn off the default\
    \ use of R2T for\n   unidirectional and the output part of bidirectional commands,\
    \ thus\n   allowing an initiator to start sending data to a target as if it has\n\
    \   received an initial R2T with Buffer Offset=Immediate Data Length and\n   Desired\
    \ Data Transfer Length=(min(FirstBurstLength, Expected Data\n   Transfer Length)\
    \ - Received Immediate Data Length).\n   The default action is that R2T is required,\
    \ unless both the initiator\n   and the target send this key-pair attribute specifying\
    \ InitialR2T=No.\n   Only the first outgoing data burst (immediate data and/or\
    \ separate\n   PDUs) can be sent unsolicited (i.e., not requiring an explicit\
    \ R2T).\n"
- title: 12.11.  ImmediateData
  contents:
  - "12.11.  ImmediateData\n   Use: LO\n   Senders: Initiator and Target\n   Scope:\
    \ SW\n   Irrelevant when: SessionType=Discovery\n   ImmediateData=<boolean-value>\n\
    \   Default is Yes.\n   Result function is AND.\n   The initiator and target negotiate\
    \ support for immediate data.  To\n   turn immediate data off, the initiator or\
    \ target must state its\n   desire to do so.  ImmediateData can be turned on if\
    \ both the\n   initiator and target have ImmediateData=Yes.\n   If ImmediateData\
    \ is set to Yes and InitialR2T is set to Yes\n   (default), then only immediate\
    \ data are accepted in the first burst.\n   If ImmediateData is set to No and\
    \ InitialR2T is set to Yes, then the\n   initiator MUST NOT send unsolicited data\
    \ and the target MUST reject\n   unsolicited data with the corresponding response\
    \ code.\n   If ImmediateData is set to No and InitialR2T is set to No, then the\n\
    \   initiator MUST NOT send unsolicited immediate data, but MAY send one\n   unsolicited\
    \ burst of Data-Out PDUs.\n   If ImmediateData is set to Yes and InitialR2T is\
    \ set to No, then the\n   initiator MAY send unsolicited immediate data and/or\
    \ one unsolicited\n   burst of Data-Out PDUs.\n   The following table is a summary\
    \ of unsolicited data options:\n   +----------+-------------+------------------+--------------+\n\
    \   |InitialR2T|ImmediateData|    Unsolicited   |Immediate Data|\n   |       \
    \   |             |   Data Out PDUs  |              |\n   +----------+-------------+------------------+--------------+\n\
    \   | No       | No          | Yes              | No           |\n   +----------+-------------+------------------+--------------+\n\
    \   | No       | Yes         | Yes              | Yes          |\n   +----------+-------------+------------------+--------------+\n\
    \   | Yes      | No          | No               | No           |\n   +----------+-------------+------------------+--------------+\n\
    \   | Yes      | Yes         | No               | Yes          |\n   +----------+-------------+------------------+--------------+\n"
- title: 12.12.  MaxRecvDataSegmentLength
  contents:
  - "12.12.  MaxRecvDataSegmentLength\n   Use: ALL, Declarative\n   Senders: Initiator\
    \ and Target\n   Scope: CO\n   MaxRecvDataSegmentLength=<numerical-value-512-to-(2**24-1)>\n\
    \   Default is 8192 bytes.\n   The initiator or target declares the maximum data\
    \ segment length in\n   bytes it can receive in an iSCSI PDU.\n   The transmitter\
    \ (initiator or target) is required to send PDUs with a\n   data segment that\
    \ does not exceed MaxRecvDataSegmentLength of the\n   receiver.\n   A target receiver\
    \ is additionally limited by MaxBurstLength for\n   solicited data and FirstBurstLength\
    \ for unsolicited data.  An\n   initiator MUST NOT send solicited PDUs exceeding\
    \ MaxBurstLength nor\n   unsolicited PDUs exceeding FirstBurstLength (or\n   FirstBurstLength-Immediate\
    \ Data Length if immediate data were sent).\n"
- title: 12.13.  MaxBurstLength
  contents:
  - "12.13.  MaxBurstLength\n   Use: LO\n   Senders: Initiator and Target\n   Scope:\
    \ SW\n   Irrelevant when: SessionType=Discovery\n   MaxBurstLength=<numerical-value-512-to-(2**24-1)>\n\
    \   Default is 262144 (256 Kbytes).\n   Result function is Minimum.\n   The initiator\
    \ and target negotiate maximum SCSI data payload in bytes\n   in a Data-In or\
    \ a solicited Data-Out iSCSI sequence.  A sequence\n   consists of one or more\
    \ consecutive Data-In or Data-Out PDUs that end\n   with a Data-In or Data-Out\
    \ PDU with the F bit set to one.\n"
- title: 12.14.  FirstBurstLength
  contents:
  - "12.14.  FirstBurstLength\n   Use: LO\n   Senders: Initiator and Target\n   Scope:\
    \ SW\n   Irrelevant when: SessionType=Discovery\n   Irrelevant when: ( InitialR2T=Yes\
    \ and ImmediateData=No )\n   FirstBurstLength=<numerical-value-512-to-(2**24-1)>\n\
    \   Default is 65536 (64 Kbytes).\n   Result function is Minimum.\n   The initiator\
    \ and target negotiate the maximum amount in bytes of\n   unsolicited data an\
    \ iSCSI initiator may send to the target during the\n   execution of a single\
    \ SCSI command.  This covers the immediate data\n   (if any) and the sequence\
    \ of unsolicited Data-Out PDUs (if any) that\n   follow the command.\n   FirstBurstLength\
    \ MUST NOT exceed MaxBurstLength.\n"
- title: 12.15.  DefaultTime2Wait
  contents:
  - "12.15.  DefaultTime2Wait\n   Use: LO\n   Senders: Initiator and Target\n   Scope:\
    \ SW\n   DefaultTime2Wait=<numerical-value-0-to-3600>\n   Default is 2.\n   Result\
    \ function is Maximum.\n   The initiator and target negotiate the minimum time,\
    \ in seconds, to\n   wait before attempting an explicit/implicit logout or an\
    \ active task\n   reassignment after an unexpected connection termination or a\n\
    \   connection reset.\n   A value of 0 indicates that logout or active task reassignment\
    \ can be\n   attempted immediately.\n"
- title: 12.16.  DefaultTime2Retain
  contents:
  - "12.16.  DefaultTime2Retain\n   Use: LO Senders: Initiator and Target Scope: SW\n\
    \   DefaultTime2Retain=<numerical-value-0-to-3600>\n   Default is 20.  Result\
    \ function is Minimum.\n   The initiator and target negotiate the maximum time,\
    \ in seconds after\n   an initial wait (Time2Wait), before which an active task\
    \ reassignment\n   is still possible after an unexpected connection termination\
    \ or a\n   connection reset.\n   This value is also the session state timeout\
    \ if the connection in\n   question is the last LOGGED_IN connection in the session.\n\
    \   A value of 0 indicates that connection/task state is immediately\n   discarded\
    \ by the target.\n"
- title: 12.17.  MaxOutstandingR2T
  contents:
  - "12.17.  MaxOutstandingR2T\n   Use: LO\n   Senders: Initiator and Target\n   Scope:\
    \ SW\n   MaxOutstandingR2T=<numerical-value-from-1-to-65535>\n   Irrelevant when:\
    \ SessionType=Discovery\n   Default is 1.\n   Result function is Minimum.\n  \
    \ Initiator and target negotiate the maximum number of outstanding R2Ts\n   per\
    \ task, excluding any implied initial R2T that might be part of\n   that task.\
    \  An R2T is considered outstanding until the last data PDU\n   (with the F bit\
    \ set to 1) is transferred, or a sequence reception\n   timeout (Section 6.1.4.1\
    \ Recovery Within-command) is encountered for\n   that data sequence.\n"
- title: 12.18.  DataPDUInOrder
  contents:
  - "12.18.  DataPDUInOrder\n   Use: LO\n   Senders: Initiator and Target\n   Scope:\
    \ SW\n   Irrelevant when: SessionType=Discovery\n   DataPDUInOrder=<boolean-value>\n\
    \   Default is Yes.\n   Result function is OR.\n   No is used by iSCSI to indicate\
    \ that the data PDUs within sequences\n   can be in any order.  Yes is used to\
    \ indicate that data PDUs within\n   sequences have to be at continuously increasing\
    \ addresses and\n   overlays are forbidden.\n"
- title: 12.19.  DataSequenceInOrder
  contents:
  - "12.19.  DataSequenceInOrder\n   Use: LO\n   Senders: Initiator and Target\n \
    \  Scope: SW\n   Irrelevant when: SessionType=Discovery\n   DataSequenceInOrder=<boolean-value>\n\
    \   Default is Yes.\n   Result function is OR.\n   A Data Sequence is a sequence\
    \ of Data-In or Data-Out PDUs that end\n   with a Data-In or Data-Out PDU with\
    \ the F bit set to one.  A Data-Out\n   sequence is sent either unsolicited or\
    \ in response to an R2T.\n   Sequences cover an offset-range.\n   If DataSequenceInOrder\
    \ is set to No, Data PDU sequences may be\n   transferred in any order.\n   If\
    \ DataSequenceInOrder is set to Yes, Data Sequences MUST be\n   transferred using\
    \ continuously non-decreasing sequence offsets (R2T\n   buffer offset for writes,\
    \ or the smallest SCSI Data-In buffer offset\n   within a read data sequence).\n\
    \   If DataSequenceInOrder is set to Yes, a target may retry at most the\n   last\
    \ R2T, and an initiator may at most request retransmission for the\n   last read\
    \ data sequence.  For this reason, if ErrorRecoveryLevel is\n   not 0 and DataSequenceInOrder\
    \ is set to Yes then MaxOustandingR2T\n   MUST be set to 1.\n"
- title: 12.20.  ErrorRecoveryLevel
  contents:
  - "12.20.  ErrorRecoveryLevel\n   Use: LO\n   Senders: Initiator and Target\n  \
    \ Scope: SW\n   ErrorRecoveryLevel=<numerical-value-0-to-2>\n   Default is 0.\n\
    \   Result function is Minimum.\n   The initiator and target negotiate the recovery\
    \ level supported.\n   Recovery levels represent a combination of recovery capabilities.\n\
    \   Each recovery level includes all the capabilities of the lower\n   recovery\
    \ levels and adds some new ones to them.\n   In the description of recovery mechanisms,\
    \ certain recovery classes\n   are specified.  Section 6.1.5 Error Recovery Hierarchy\
    \ describes the\n   mapping between the classes and the levels.\n"
- title: 12.21.  SessionType
  contents:
  - "12.21.  SessionType\n   Use: LO, Declarative, Any-Stage\n   Senders: Initiator\n\
    \   Scope: SW\n   SessionType= <Discovery|Normal>\n   Default is Normal.\n   The\
    \ initiator indicates the type of session it wants to create.  The\n   target\
    \ can either accept it or reject it.\n   A discovery session indicates to the\
    \ Target that the only purpose of\n   this Session is discovery.  The only requests\
    \ a target accepts in\n   this type of session are a text request with a SendTargets\
    \ key and a\n   logout request with reason \"close the session\".\n   The discovery\
    \ session implies MaxConnections = 1 and overrides both\n   the default and an\
    \ explicit setting.\n"
- title: 12.22.  The Private or Public Extension Key Format
  contents:
  - "12.22.  The Private or Public Extension Key Format\n   Use: ALL\n   Senders:\
    \ Initiator and Target\n   Scope: specific key dependent\n   X-reversed.vendor.dns_name.do_something=\n\
    \   or\n   X<#><IANA-registered-string>=\n   Keys with this format are used for\
    \ public or private extension\n   purposes.  These keys always start with X- if\
    \ unregistered with IANA\n   (private) or X# if registered with IANA (public).\n\
    \   For unregistered keys, to identify the vendor, we suggest you use the\n  \
    \ reversed DNS-name as a prefix to the key-proper.\n   The part of key-name following\
    \ X- and X# MUST conform to the format\n   for key-name specified in Section 5.1\
    \ Text Format.\n   For IANA registered keys the string following X# must be registered\n\
    \   with IANA and the use of the key MUST be described by an\n   informational\
    \ RFC.\n   Vendor specific keys MUST ONLY be used in normal sessions.\n   Support\
    \ for public or private extension keys is OPTIONAL.\n"
- title: 13.  IANA Considerations
  contents:
  - "13.  IANA Considerations\n   This section conforms to [RFC2434].\n   The well-known\
    \ user TCP port number for iSCSI connections assigned by\n   IANA is 3260 and\
    \ this is the default iSCSI port.  Implementations\n   needing a system TCP port\
    \ number may use port 860, the port assigned\n   by IANA as the iSCSI system port;\
    \ however in order to use port 860,\n   it MUST be explicitly specified - implementations\
    \ MUST NOT default to\n   use of port 860, as 3260 is the only allowed default.\n\
    \   Extension keys, authentication methods, or digest types for which a\n   vendor\
    \ or group of vendors intend to provide publicly available\n   descriptions MUST\
    \ be described by an RFC and MUST be registered with\n   IANA.\n   The IANA has\
    \ set up the following three registries:\n         a)  iSCSI extended key registry\n\
    \         b)  iSCSI authentication methods registry\n         c)  iSCSI digests\
    \ registry\n   [RFC3723] also instructs IANA to maintain a registry for the values\n\
    \   of the SRP_GROUP key.  The format of these values must conform to the\n  \
    \ one specified for iSCSI extension item-label in Section 13.5.4\n   Standard\
    \ iSCSI extension item-label format.\n   For the iSCSI authentication methods\
    \ registry and the iSCSI digests\n   registry, IANA MUST also assign a 16-bit\
    \ unsigned integer number (the\n   method number for the authentication method\
    \ and the digest number for\n   the digest).\n   The following initial values\
    \ for the registry for authentication\n   methods are specified by the standards\
    \ action of this document:\n    Authentication Method                   | Number\
    \ |\n   +----------------------------------------+--------+\n   | CHAP       \
    \                            |     1  |\n   +----------------------------------------+--------+\n\
    \   | SRP                                    |     2  |\n   +----------------------------------------+--------+\n\
    \   | KRB5                                   |     3  |\n   +----------------------------------------+--------+\n\
    \   | SPKM1                                  |     4  |\n   +----------------------------------------+--------+\n\
    \   | SPKM2                                  |     5  |\n   +----------------------------------------+--------+\n\
    \   All other record numbers from 0 to 255 are reserved.  IANA will\n   register\
    \ numbers above 255.\n   Authentication methods with numbers above 255 MUST be\
    \ unique within\n   the registry and MUST be used with the prefix Z#.\n   The\
    \ following initial values for the registry for digests are\n   specified by the\
    \ standards action of this document:\n    Digest                             \
    \     | Number |\n   +----------------------------------------+--------+\n   |\
    \ CRC32C                                 |     1  |\n   +----------------------------------------+--------+\n\
    \   All other record numbers from 0 to 255 are reserved.  IANA will\n   register\
    \ numbers above 255.\n   Digests with numbers above 255 MUST be unique within\
    \ the registry and\n   MUST be used with the prefix Y#.\n   The RFC that describes\
    \ the item to be registered MUST indicate in the\n   IANA Considerations section\
    \ the string and iSCSI registry to which it\n   should be recorded.\n   Extension\
    \ Keys, Authentication Methods, and digests (iSCSI extension\n   items) must conform\
    \ to a number of requirements as described below.\n"
- title: 13.1.  Naming Requirements
  contents:
  - "13.1.  Naming Requirements\n   Each iSCSI extension item must have a unique name\
    \ in its category.\n   This name will be used as a standard-label for the key,\
    \ access\n   method, or digest and must conform to the syntax specified in Section\n\
    \   13.5.4 Standard iSCSI extension item-label format for iSCSI extension\n  \
    \ item-labels.\n"
- title: 13.2.  Mechanism Specification Requirements
  contents:
  - "13.2.  Mechanism Specification Requirements\n   For iSCSI extension items all\
    \ of the protocols and procedures used by\n   a given iSCSI extension item must\
    \ be described, either in the\n   specification of the iSCSI extension item itself\
    \ or in some other\n   publicly available specification, in sufficient detail\
    \ for the iSCSI\n   extension item to be implemented by any competent implementor.\
    \  Use\n   of secret and/or proprietary methods in iSCSI extension items are\n\
    \   expressly prohibited.  In addition, the restrictions imposed by\n   [RFC1602]\
    \ on the standardization of patented algorithms must be\n   respected.\n"
- title: 13.3.  Publication Requirements
  contents:
  - "13.3.  Publication Requirements\n   All iSCSI extension items must be described\
    \ by an RFC.  The RFC may\n   be informational rather than Standards-Track, although\
    \ Standards\n   Track review and approval are encouraged for all iSCSI extension\n\
    \   items.\n"
- title: 13.4.  Security Requirements
  contents:
  - "13.4.  Security Requirements\n   Any known security issues that arise from the\
    \ use of the iSCSI\n   extension item must be completely and fully described.\
    \  It is not\n   required that the iSCSI extension item be secure or that it be\
    \ free\n   from risks, but that the known risks be identified.  Publication of\
    \ a\n   new iSCSI extension item does not require an exhaustive security\n   review,\
    \ and the security considerations section is subject to\n   continuing evaluation.\n\
    \   Additional security considerations should be addressed by publishing\n   revised\
    \ versions of the iSCSI extension item specification.\n   For each of these registries,\
    \ IANA must record the registered string,\n   which MUST conform to the format\
    \ rules described in Section 13.5.4\n   Standard iSCSI extension item-label format\
    \ for iSCSI extension\n   item-labels, and the RFC number that describes it. \
    \ The key prefix\n   (X#, Y# or Z#) is not part of the recorded string.\n"
- title: 13.5.  Registration Procedure
  contents:
  - "13.5.  Registration Procedure\n   Registration of a new iSCSI extension item\
    \ starts with the\n   construction of an Internet Draft to become an RFC.\n"
- title: 13.5.1.  Present the iSCSI extension item to the Community
  contents:
  - "13.5.1.  Present the iSCSI extension item to the Community\n   Send a proposed\
    \ access type specification to the IPS WG mailing list,\n   or if the IPS WG is\
    \ disbanded at the registration time, to a mailing\n   list designated by the\
    \ IETF Transport Area Director for a review\n   period of a month.  The intent\
    \ of the public posting is to solicit\n   comments and feedback on the iSCSI extension\
    \ item specification and a\n   review of any security considerations.\n"
- title: 13.5.2.  iSCSI extension item review and IESG approval
  contents:
  - "13.5.2.  iSCSI extension item review and IESG approval\n   When the one month\
    \ period has passed, the IPS WG chair or a person\n   nominated by the IETF Transport\
    \ Area Director (the iSCSI extension\n   item reviewer) forwards the Internet\
    \ Draft to the IESG for\n   publication as an informational RFC or rejects it.\
    \  If the\n   specification is a standards track document, the usual IETF\n  \
    \ procedures for such documents are followed.\n   Decisions made by the iSCSI\
    \ extension item reviewer must be published\n   within two weeks after the month-long\
    \ review period.  Decisions made\n   by the iSCSI extension item reviewer can\
    \ be appealed through the IESG\n   appeal process.\n"
- title: 13.5.3.  IANA Registration
  contents:
  - "13.5.3.  IANA Registration\n   Provided that the iSCSI extension item has either\
    \ passed review or\n   has been successfully appealed to the IESG, and the specification\
    \ is\n   published as an RFC, then IANA will register the iSCSI extension item\n\
    \   and make the registration available to the community.\n"
- title: 13.5.4.  Standard iSCSI extension item-label format
  contents:
  - "13.5.4.  Standard iSCSI extension item-label format\n   The following character\
    \ symbols are used iSCSI extension item-labels\n   (the hexadecimal values represent\
    \ Unicode code points):\n   (a-z, A-Z) - letters\n   (0-9) - digits\n   \".\"\
    \  (0x2e) - dot\n   \"-\"  (0x2d) - minus\n   \"+\"  (0x2b) - plus\n   \"@\" \
    \ (0x40) - commercial at\n   \"_\"  (0x5f) - underscore\n   An iSCSI extension\
    \ item-label is a string of one or more characters\n   that consist of letters,\
    \ digits, dot, minus, plus, commercial at, or\n   underscore.  An iSCSI extension\
    \ item-label MUST begin with a capital\n   letter and must not exceed 63 characters.\n"
- title: 13.6.  IANA Procedures for Registering iSCSI extension items
  contents:
  - "13.6.  IANA Procedures for Registering iSCSI extension items\n   The identity\
    \ of the iSCSI extension item reviewer is communicated to\n   the IANA by the\
    \ IESG.  Then, the IANA only acts in response to iSCSI\n   extension item definitions\
    \ that are approved by the iSCSI extension\n   item reviewer and forwarded by\
    \ the reviewer to the IANA for\n   registration, or in response to a communication\
    \ from the IESG that an\n   iSCSI extension item definition appeal has overturned\
    \ the iSCSI\n   extension item reviewer's ruling.\n"
- title: References
  contents:
  - 'References

    '
- title: Normative References
  contents:
  - "Normative References\n   [CAM]          ANSI X3.232-199X, Common Access Method-3.\n\
    \   [EUI]          \"Guidelines for 64-bit Global Identifier (EUI-64)\",\n   \
    \               http:\n                  //standards.ieee.org/regauth/oui/tutorials/EUI64.html\n\
    \   [OUI]          \"IEEE OUI and Company_Id Assignments\",\n                \
    \  http://standards.ieee.org/regauth/oui\n   [RFC791]       Postel, J., \"Internet\
    \ Protocol\", STD 5, RFC 791,\n                  September 1981.\n   [RFC793]\
    \       Postel, J., \"Transmission Control Protocol\", STD 7,\n              \
    \    RFC 793, September 1981.\n   [RFC1035]      Mockapetris, P., \"Domain Names\
    \ - Implementation and\n                  Specification\", STD 13, RFC 1035, November\
    \ 1987.\n   [RFC1122]      Braden, R., Ed., \"Requirements for Internet Hosts-\n\
    \                  Communication Layer\", STD 3, RFC 1122, October 1989.\n   [RFC1510]\
    \      Kohl, J. and C. Neuman, \"The Kerberos Network\n                  Authentication\
    \ Service (V5)\", RFC 1510, September\n                  1993.\n   [RFC1737] \
    \     Sollins, K. and L. Masinter \"Functional Requirements\n                \
    \  for Uniform Resource Names\"RFC 1737, December 1994.\n   [RFC1964]      Linn,\
    \ J., \"The Kerberos Version 5 GSS-API Mechanism\",\n                  RFC 1964,\
    \ June 1996.\n   [RFC1982]      Elz, R. and R. Bush, \"Serial Number Arithmetic\"\
    , RFC\n                  1982, August 1996.\n   [RFC1994]      Simpson, W., \"\
    PPP Challenge Handshake Authentication\n                  Protocol (CHAP)\", RFC\
    \ 1994, August 1996.\n   [RFC2025]      Adams, C., \"The Simple Public-Key GSS-API\
    \ Mechanism\n                  (SPKM)\", RFC 2025, October 1996.\n   [RFC2045]\
    \      Borenstein, N. and N. Freed, \"MIME (Multipurpose\n                  Internet\
    \ Mail Extensions) Part One: Mechanisms for\n                  Specifying and\
    \ Describing the Format of Internet\n                  Message Bodies\", RFC 2045,\
    \ November 1996.\n   [RFC2119]      Bradner, S. \"Key Words for use in RFCs to\
    \ Indicate\n                  Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RFC2279]      Yergeau, F., \"UTF-8, a Transformation Format of ISO\n    \
    \              10646\", RFC 2279 October 1996.\n   [RFC2373]      Hinden, R. and\
    \ S. Deering, \"IP Version 6 Addressing\n                  Architecture\", RFC\
    \ 2373, July 1998.\n   [RFC2396]      Berners-Lee, T., Fielding, R. and L. Masinter\
    \ \"Uniform\n                  Resource Identifiers\", RFC 2396, August 1998.\n\
    \   [RFC2401]      Kent, S. and R. Atkinson, \"Security Architecture for\n   \
    \               the Internet Protocol\", RFC 2401, November 1998.\n   [RFC2404]\
    \      Madson, C. and R. Glenn, \"The Use of HMAC-SHA-1-96\n                 \
    \ within ESP and AH\", RFC 2404, November 1998.\n   [RFC2406]      Kent, S. and\
    \ R. Atkinson, \"IP Encapsulating Security\n                  Payload (ESP)\"\
    , RFC 2406, November 1998.\n   [RFC2407]      Piper, D., \"The Internet IP Security\
    \ Domain of\n                  Interpretation of ISAKMP\", RFC 2407, November\
    \ 1998.\n   [RFC2409]      Harkins, D. and D. Carrel, \"The Internet Key Exchange\n\
    \                  (IKE)\", RFC2409, November 1998.\n   [RFC2434]      Narten,\
    \ T. and H. Alvestrand, \"Guidelines for Writing\n                  an IANA Considerations\
    \ Section in RFCs.\", BCP 26, RFC\n                  2434, October 1998.\n   [RFC2451]\
    \      Pereira, R. and R. Adams \" The ESP CBC-Mode Cipher\n                 \
    \ Algorithms\", RFC 2451, November 1998.\n   [RFC2732]      Hinden, R., Carpenter,\
    \ B. and L. Masinter, \"Format for\n                  Literal IPv6 Addresses in\
    \ URL's\", RFC 2451, December\n                  1999.\n   [RFC2945]      Wu,\
    \ T., \"The SRP Authentication and Key Exchange\n                  System\", RFC\
    \ 2945, September 2000.\n   [RFC3066]      Alvestrand, H., \"Tags for the Identification\
    \ of\n                  Languages\", STD 47, RFC 3066, January 2001.\n   [RFC3454]\
    \      Hoffman, P. and M. Blanchet, \"Preparation of\n                  Internationalized\
    \ Strings (\"stringprep\")\", RFC 3454,\n                  December 2002.\n  \
    \ [RFC3566]      Frankel, S. and H. Herbert, \"The AES-XCBC-MAC-96\n         \
    \         Algorithm and Its Use With IPsec\", RFC 3566, September\n          \
    \        2003.\n   [RFC3686]      Housley, R., \"Using Advanced Encryption Standard\
    \ (AES)\n                  Counter Mode with IPsec Encapsulating Security Payload\n\
    \                  (ESP)\", RFC 3686, January 2004.\n   [RFC3722]      Bakke,\
    \ M., \"String Profile for Internet Small Computer\n                  Systems\
    \ Interface (iSCSI) Names\", RFC 3722, March\n                  2004.\n   [RFC3723]\
    \      Aboba, B., Tseng, J., Walker, J., Rangan, V. and F.\n                 \
    \ Travostino, \"Securing Block Storage Protocols over\n                  IP\"\
    , RFC 3723, March 2004.\n   [SAM2]         T10/1157D, SCSI Architecture Model\
    \ - 2 (SAM-2).\n   [SBC]          NCITS.306-1998, SCSI-3 Block Commands (SBC).\n\
    \   [SPC3]         T10/1416-D, SCSI Primary Commands-3.\n   [UNICODE]      Unicode\
    \ Standard Annex #15, \"Unicode Normalization\n                  Forms\", http://www.unicode.org/unicode/reports/tr15\n"
- title: Informative References
  contents:
  - "Informative References\n   [BOOT]         P. Sarkar, et al., \"Bootstrapping\
    \ Clients using the\n                  iSCSI Protocol\", Work in Progress, July\
    \ 2003.\n   [Castagnoli93] G. Castagnoli, S. Braeuer and M. Herrman \"Optimization\n\
    \                  of Cyclic Redundancy-Check Codes with 24 and 32 Parity\n  \
    \                Bits\", IEEE Transact. on Communications, Vol. 41, No.\n    \
    \              6, June 1993.\n   [CORD]          Chadalapaka, M. and R. Elliott,\
    \ \"SCSI Command\n                  Ordering Considerations with iSCSI\", Work\
    \ in Progress.\n   [RFC3347]      Krueger, M., Haagens, R., Sapuntzakis, C. and\
    \ M.\n                  Bakke, \"Small Computer Systems Interface protocol over\n\
    \                  the Internet (iSCSI) Requirements and Design\n            \
    \      Considerations\", RFC 3347, July 2002.\n   [RFC3385]      Sheinwald, D.,\
    \ Staran, J., Thaler, P. and V. Cavanna,\n                  \"Internet Protocol\
    \ Small Computer System Interface\n                  (iSCSI) Cyclic Redundancy\
    \ Check (CRC)/Checksum\n                  Considerations\", RFC 3385, September\
    \ 2002.\n   [RFC3721]      Bakke M., Hafner, J., Hufferd, J., Voruganti, K. and\n\
    \                  M. Krueger, \"Internet Small Computer Systems Interface\n \
    \                 (iSCSI) Naming and Discovery, RFC 3721, March 2004.\n   [SEQ-EXT]\
    \      Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n              \
    \    Work in Progress, July 2002.\n"
- title: Appendix A.  Sync and Steering with Fixed Interval Markers
  contents:
  - "Appendix A.  Sync and Steering with Fixed Interval Markers\n   This appendix\
    \ presents a simple scheme for synchronization (PDU\n   boundary retrieval). \
    \ It uses markers that include synchronization\n   information placed at fixed\
    \ intervals in the TCP stream.\n   A Marker consists of:\n   Byte /    0     \
    \  |       1       |       2       |       3       |\n       /             | \
    \              |               |               |\n     |0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n     +---------------+---------------+---------------+---------------+\n\
    \    0| Next-iSCSI-PDU-start pointer - copy #1                        |\n    \
    \ +---------------+---------------+---------------+---------------+\n    4| Next-iSCSI-PDU-start\
    \ pointer - copy #2                        |\n     +---------------+---------------+---------------+---------------+\n\
    \   The Marker scheme uses payload byte stream counting that includes\n   every\
    \ byte placed by iSCSI in the TCP stream except for the markers\n   themselves.\
    \  It also excludes any bytes that TCP counts but are not\n   originated by iSCSI.\n\
    \   Markers MUST NOT be included in digest calculation.\n   The Marker indicates\
    \ the offset to the next iSCSI PDU header.  The\n   Marker is eight bytes in length\
    \ and contains two 32-bit offset fields\n   that indicate how many bytes to skip\
    \ in the TCP stream in order to\n   find the next iSCSI PDU header.  The marker\
    \ uses two copies of the\n   pointer so that a marker that spans a TCP packet\
    \ boundary should\n   leave at least one valid copy in one of the packets.\n \
    \  The structure and semantics of an inserted marker are independent of\n   the\
    \ marker interval.\n   The use of markers is negotiable.  The initiator and target\
    \ MAY\n   indicate their readiness to receive and/or send markers during login\n\
    \   separately for each connection.  The default is No.\n"
- title: A.1.  Markers At Fixed Intervals
  contents:
  - "A.1.  Markers At Fixed Intervals\n   A marker is inserted at fixed intervals\
    \ in the TCP byte stream.\n   During login, each end of the iSCSI session specifies\
    \ the interval at\n   which it is willing to receive the marker, or it disables\
    \ the marker\n   altogether.  If a receiver indicates that it desires a marker,\
    \ the\n   sender MAY agree (during negotiation) and provide the marker at the\n\
    \   desired interval.  However, in certain environments, a sender that\n   does\
    \ not provide markers to a receiver that wants markers may suffer\n   an appreciable\
    \ performance degradation.\n   The marker interval and the initial marker-less\
    \ interval are counted\n   in terms of the bytes placed in the TCP stream data\
    \ by iSCSI.\n   When reduced to iSCSI terms, markers MUST indicate the offset\
    \ to a\n   4-byte word boundary in the stream.  The least significant two bits\n\
    \   of each marker word are reserved and are considered 0 for offset\n   computation.\n\
    \   Padding iSCSI PDU payloads to 4-byte word boundaries simplifies\n   marker\
    \ manipulation.\n"
- title: A.2.  Initial Marker-less Interval
  contents:
  - "A.2.  Initial Marker-less Interval\n   To enable the connection setup including\
    \ the Login Phase negotiation,\n   marking (if any) is only started at the first\
    \ marker interval after\n   the end of the Login Phase.  However, in order to\
    \ enable the marker\n   inclusion and exclusion mechanism to work without knowledge\
    \ of the\n   length of the Login Phase, the first marker will be placed in the\
    \ TCP\n   stream as if the Marker-less interval had included markers.\n   Thus,\
    \ all markers appear in the stream at locations conforming to the\n   formula:\
    \ [(MI + 8) * n - 8] where MI = Marker Interval, n = integer\n   number.\n   For\
    \ example, if the marker interval is 512 bytes and the login ended\n   at byte\
    \ 1003 (first iSCSI placed byte is 0), the first marker will be\n   inserted after\
    \ byte 1031 in the stream.\n"
- title: A.3.  Negotiation
  contents:
  - "A.3.  Negotiation\n   The following operational key=value pairs are used to negotiate\
    \ the\n   fixed interval markers.  The direction (output or input) is relative\n\
    \   to the initiator.\n"
- title: A.3.1.  OFMarker, IFMarker
  contents:
  - "A.3.1.  OFMarker, IFMarker\n   Use: IO\n   Senders: Initiator and Target\n  \
    \ Scope: CO\n   OFMarker=<boolean-value>\n   IFMarker=<boolean-value>\n   Default\
    \ is No.\n   Result function is AND.\n   OFMarker is used to turn on or off the\
    \ initiator to target markers\n   on the connection.  IFMarker is used to turn\
    \ on or off the target to\n   initiator markers on the connection.\n   Examples:\n\
    \     I->OFMarker=Yes,IFMarker=Yes\n     T->OFMarker=Yes,IFMarker=Yes\n   Results\
    \ in the Marker being used in both directions while:\n     I->OFMarker=Yes,IFMarker=Yes\n\
    \     T->OFMarker=Yes,IFMarker=No\n   Results in Marker being used from the initiator\
    \ to the target, but\n   not from the target to initiator.\n"
- title: A.3.2.  OFMarkInt, IFMarkInt
  contents:
  - "A.3.2.  OFMarkInt, IFMarkInt\n   Use: IO\n   Senders: Initiator and Target\n\
    \   Scope: CO\n   OFMarkInt is Irrelevant when: OFMarker=No\n   IFMarkInt is Irrelevant\
    \ when: IFMarker=No\n   Offering:\n   OFMarkInt=<numeric-range-from-1-to-65535>\n\
    \   IFMarkInt=<numeric-range-from-1-to-65535>\n   Responding:\n   OFMarkInt=<numeric-value-from-1-to-65535>|Reject\n\
    \   IFMarkInt=<numeric-value-from-1-to-65535>|Reject\n   OFMarkInt is used to\
    \ set the interval for the initiator to target\n   markers on the connection.\
    \  IFMarkInt is used to set the interval for\n   the target to initiator markers\
    \ on the connection.\n   For the offering, the initiator or target indicates the\
    \ minimum to\n   maximum interval (in 4-byte words) it wants the markers for one\
    \ or\n   both directions.  In case it only wants a specific value, only a\n  \
    \ single value has to be specified.  The responder selects a value\n   within\
    \ the minimum and maximum offered or the only value offered or\n   indicates through\
    \ the xFMarker key=value its inability to set and/or\n   receive markers.  When\
    \ the interval is unacceptable the responder\n   answers with \"Reject\".  Reject\
    \ is resetting the marker function in\n   the specified direction (Output or Input)\
    \ to No.\n   The interval is measured from the end of a marker to the beginning\
    \ of\n   the next marker.  For example, a value of 1024 means 1024 words (4096\n\
    \   bytes of iSCSI payload between markers).\n   The default is 2048.\n"
- title: Appendix B.  Examples
  contents:
  - 'Appendix B.  Examples

    '
- title: B.1.  Read Operation Example
  contents:
  - "B.1.  Read Operation Example\n   +------------------+-----------------------+----------------------+\n\
    \   |Initiator Function|    PDU Type           |  Target Function     |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Command request |SCSI Command (READ)>>> |                      |\n   |\
    \  (read)          |                       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |                       |Prepare Data Transfer |\n   +------------------+-----------------------+----------------------+\n\
    \   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   +------------------+-----------------------+----------------------+\n\
    \   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   +------------------+-----------------------+----------------------+\n\
    \   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< SCSI Response   |Send Status and Sense |\n   +------------------+-----------------------+----------------------+\n\
    \   | Command Complete |                       |                      |\n   +------------------+-----------------------+----------------------+\n"
- title: B.2.  Write Operation Example
  contents:
  - "B.2.  Write Operation Example\n   +------------------+-----------------------+---------------------+\n\
    \   |Initiator Function|    PDU Type           |  Target Function    |\n   +------------------+-----------------------+---------------------+\n\
    \   | Command request  |SCSI Command (WRITE)>>>| Receive command     |\n   | \
    \ (write)         |                       | and queue it        |\n   +------------------+-----------------------+---------------------+\n\
    \   |                  |                       | Process old commands|\n   +------------------+-----------------------+---------------------+\n\
    \   |                  |                       | Ready to process    |\n   | \
    \                 |   <<< R2T             | WRITE command       |\n   +------------------+-----------------------+---------------------+\n\
    \   |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n   +------------------+-----------------------+---------------------+\n\
    \   |                  |   <<< R2T             | Ready for data      |\n   +------------------+-----------------------+---------------------+\n\
    \   |                  |   <<< R2T             | Ready for data      |\n   +------------------+-----------------------+---------------------+\n\
    \   |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n   +------------------+-----------------------+---------------------+\n\
    \   |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |\n   +------------------+-----------------------+---------------------+\n\
    \   |                  |   <<< SCSI Response   |Send Status and Sense|\n   +------------------+-----------------------+---------------------+\n\
    \   | Command Complete |                       |                     |\n   +------------------+-----------------------+---------------------+\n"
- title: B.3.  R2TSN/DataSN Use Examples
  contents:
  - "B.3.  R2TSN/DataSN Use Examples\n   Output (write) data DataSN/R2TSN Example\n\
    \   +------------------+-----------------------+----------------------+\n   |Initiator\
    \ Function|    PDU Type & Content |  Target Function     |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Command request |SCSI Command (WRITE)>>>| Receive command      |\n   |\
    \  (write)         |                       | and queue it         |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |                       | Process old commands |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< R2T             | Ready for data       |\n   |\
    \                  |   R2TSN = 0           |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< R2T             | Ready for more data  |\n   |\
    \                  |   R2TSN = 1           |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Send Data       |   SCSI Data-Out >>>   |   Receive Data       |\n   |\
    \  for R2TSN 0     |   DataSN = 0, F=0     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Send Data       |   SCSI Data-Out >>>   |   Receive Data       |\n   |\
    \  for R2TSN 0     |   DataSN = 1, F=1     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Send Data       |   SCSI Data >>>       |   Receive Data       |\n   |\
    \  for R2TSN 1     |   DataSN = 0, F=1     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< SCSI Response   |Send Status and Sense |\n   |\
    \                  |   ExpDataSN = 0       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   | Command Complete |                       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   Input (read) data DataSN Example\n   +------------------+-----------------------+----------------------+\n\
    \   |Initiator Function|    PDU Type           |  Target Function     |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Command request |SCSI Command (READ)>>> |                      |\n   |\
    \  (read)          |                       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |                       | Prepare Data Transfer|\n   +------------------+-----------------------+----------------------+\n\
    \   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |\
    \                  |   DataSN = 0, F=0     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |\
    \                  |   DataSN = 1, F=0     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |\
    \                  |   DataSN = 2, F=1     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< SCSI Response   |Send Status and Sense |\n   |\
    \                  |   ExpDataSN = 3       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   | Command Complete |                       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   Bidirectional DataSN Example\n   +------------------+-----------------------+----------------------+\n\
    \   |Initiator Function|    PDU Type           | Target Function      |\n   +------------------+-----------------------+----------------------+\n\
    \   | Command request |SCSI Command >>>        |                      |\n   |\
    \ (Read-Write)     | Read-Write            |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |                       | Process old commands |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< R2T             | Ready to process     |\n   |\
    \                  |   R2TSN = 0           | WRITE command        |\n   +------------------+-----------------------+----------------------+\n\
    \   | * Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |\
    \                  |   DataSN = 1, F=0     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   | * Receive Data   |   <<< SCSI Data-In    |   Send Data          |\n   |\
    \                  |   DataSN = 2, F=1     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   | * Send Data      |   SCSI Data-Out >>>   |   Receive Data       |\n   |\
    \ for R2TSN 0      |   DataSN = 0, F=1     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< SCSI Response   |Send Status and Sense |\n   |\
    \                  |   ExpDataSN = 3       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   | Command Complete |                       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   *) Send data and Receive Data may be transferred simultaneously as in\n  \
    \ an atomic Read-Old-Write-New or sequentially as in an atomic\n   Read-Update-Write\
    \ (in the latter case the R2T may follow the received\n   data).\n   Unsolicited\
    \ and immediate output (write) data with DataSN Example\n   +------------------+-----------------------+----------------------+\n\
    \   |Initiator Function|    PDU Type & Content |  Target Function     |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Command request |SCSI Command (WRITE)>>>| Receive command      |\n   |\
    \  (write)         |F=0                    | and data             |\n   |+ Immediate\
    \ data  |                       | and queue it         |\n   +------------------+-----------------------+----------------------+\n\
    \   | Send Unsolicited |   SCSI Write Data >>> | Receive more Data    |\n   |\
    \  Data            |   DataSN = 0, F=1     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |                       | Process old commands |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< R2T             | Ready for more data  |\n   |\
    \                  |   R2TSN = 0           |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |  Send Data       |   SCSI Write Data >>> |   Receive Data       |\n   |\
    \  for R2TSN 0     |   DataSN = 0, F=1     |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   |                  |   <<< SCSI Response   |Send Status and Sense |\n   |\
    \                  |                       |                      |\n   +------------------+-----------------------+----------------------+\n\
    \   | Command Complete |                       |                      |\n   +------------------+-----------------------+----------------------+\n"
- title: B.4.  CRC Examples
  contents:
  - "B.4.  CRC Examples\n   N.B.  all Values are Hexadecimal\n   32 bytes of zeroes:\n\
    \     Byte:        0  1  2  3\n        0:       00 00 00 00\n      ...\n     \
    \  28:       00 00 00 00\n      CRC:       aa 36 91 8a\n   32 bytes of ones:\n\
    \     Byte:        0  1  2  3\n        0:       ff ff ff ff\n      ...\n     \
    \  28:       ff ff ff ff\n      CRC:       43 ab a8 62\n   32 bytes of incrementing\
    \ 00..1f:\n     Byte:        0  1  2  3\n        0:       00 01 02 03\n      ...\n\
    \       28:       1c 1d 1e 1f\n      CRC:       4e 79 dd 46\n   32 bytes of decrementing\
    \ 1f..00:\n     Byte:        0  1  2  3\n        0:       1f 1e 1d 1c\n      ...\n\
    \       28:       03 02 01 00\n      CRC:       5c db 3f 11\n   An iSCSI - SCSI\
    \ Read (10) Command PDU\n    Byte:        0  1  2  3\n       0:       01 c0 00\
    \ 00\n       4:       00 00 00 00\n       8:       00 00 00 00\n      12:    \
    \   00 00 00 00\n      16:       14 00 00 00\n      20:       00 00 04 00\n  \
    \    24:       00 00 00 14\n      28:       00 00 00 18\n      32:       28 00\
    \ 00 00\n      36:       00 00 00 00\n      40:       02 00 00 00\n      44: \
    \      00 00 00 00\n     CRC:       56 3a 96 d9\n"
- title: Appendix C.  Login Phase Examples
  contents:
  - "Appendix C.  Login Phase Examples\n   In the first example, the initiator and\
    \ target authenticate each\n   other via Kerberos:\n     I-> Login (CSG,NSG=0,1\
    \ T=1)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n\
    \         AuthMethod=KRB5,SRP,None\n     T-> Login (CSG,NSG=0,0 T=0)\n       \
    \  AuthMethod=KRB5\n     I-> Login (CSG,NSG=0,1 T=1)\n         KRB_AP_REQ=<krb_ap_req>\n\
    \     (krb_ap_req contains the Kerberos V5 ticket and authenticator\n        with\
    \ MUTUAL-REQUIRED set in the ap-options field)\n     If the authentication is\
    \ successful, the target proceeds with:\n     T-> Login (CSG,NSG=0,1 T=1)\n  \
    \       KRB_AP_REP=<krb_ap_rep>\n     (krb_ap_rep is the Kerberos V5 mutual authentication\
    \ reply)\n     If the authentication is successful, the initiator may proceed\n\
    \        with:\n     I-> Login (CSG,NSG=1,0 T=0) FirstBurstLength=8192\n     T->\
    \ Login (CSG,NSG=1,0 T=0) FirstBurstLength=4096\n          MaxBurstLength=8192\n\
    \     I-> Login (CSG,NSG=1,0 T=0) MaxBurstLength=8192\n         ... more iSCSI\
    \ Operational Parameters\n     T-> Login (CSG,NSG=1,0 T=0)\n         ... more\
    \ iSCSI Operational Parameters\n     And at the end:\n     I-> Login (CSG,NSG=1,3\
    \ T=1)\n         optional iSCSI parameters\n     T-> Login (CSG,NSG=1,3 T=1) \"\
    login accept\"\n     If the initiator's authentication by the target is not\n\
    \          successful, the target responds with:\n     T-> Login \"login reject\"\
    \n     instead of the Login KRB_AP_REP message, and terminates the\n        connection.\n\
    \     If the target's authentication by the initiator is not\n       successful,\
    \ the initiator terminates the connection (without\n       responding to the Login\
    \ KRB_AP_REP message).\n   In the next example only the initiator is authenticated\
    \ by the\n   target via Kerberos:\n     I-> Login (CSG,NSG=0,1 T=1)\n        InitiatorName=iqn.1999-07.com.os:hostid.77\n\
    \        TargetName=iqn.1999-07.com.example:diskarray.sn.88\n        AuthMethod=SRP,KRB5,None\n\
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n        AuthMethod=KRB5\n     I-> Login\
    \ (CSG,NSG=0,1 T=1)\n         KRB_AP_REQ=krb_ap_req\n     (MUTUAL-REQUIRED not\
    \ set in the ap-options field of krb_ap_req)\n     If the authentication is successful,\
    \ the target proceeds with:\n     T-> Login (CSG,NSG=0,1 T=1)\n     I-> Login\
    \ (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n     T-> Login (CSG,NSG=1,0\
    \ T=0)\n         ... iSCSI parameters\n     . . .\n     T-> Login (CSG,NSG=1,3\
    \ T=1)\"login accept\"\n   In the next example, the initiator and target authenticate\
    \ each\n   other via SPKM1:\n     I-> Login (CSG,NSG=0,1 T=1)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n\
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n         AuthMethod=SPKM1,KRB5,None\n\
    \     T-> Login (CSG,NSG=0,0 T=0)\n         AuthMethod=SPKM1\n     I-> Login (CSG,NSG=0,0\
    \ T=0)\n         SPKM_REQ=<spkm-req>\n     (spkm-req is the SPKM-REQ token with\
    \ the mutual-state bit in the\n       options field of the REQ-TOKEN set)\n  \
    \   T-> Login (CSG,NSG=0,0 T=0)\n         SPKM_REP_TI=<spkm-rep-ti>\n     If the\
    \ authentication is successful, the initiator proceeds:\n     I-> Login (CSG,NSG=0,1\
    \ T=1)\n         SPKM_REP_IT=<spkm-rep-it>\n     If the authentication is successful,\
    \ the target proceeds with:\n     T-> Login (CSG,NSG=0,1 T=1)\n     The initiator\
    \ may proceed:\n     I-> Login  (CSG,NSG=1,0 T=0) ... iSCSI parameters\n     T->\
    \ Login  (CSG,NSG=1,0 T=0) ... iSCSI parameters\n     And at the end:\n     I->\
    \ Login  (CSG,NSG=1,3 T=1)\n         optional iSCSI parameters\n     T-> Login\
    \ (CSG,NSG=1,3 T=1) \"login accept\"\n     If the target's authentication by the\
    \ initiator is not\n          successful, the initiator terminates the connection\
    \ (without\n          responding to the Login SPKM_REP_TI message).\n     If the\
    \ initiator's authentication by the target is not\n          successful, the target\
    \ responds with:\n     T-> Login \"login reject\"\n     instead of the Login \"\
    proceed and change stage\" message, and\n          terminates the connection.\n\
    \   In the next example, the initiator and target authenticate each\n   other\
    \ via SPKM2:\n     I-> Login (CSG,NSG=0,0 T=0)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n\
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n               AuthMethod=SPKM1,SPKM2\n\
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n         AuthMethod=SPKM2\n     I-> Login\
    \ (CSG,NSG=0,1 T=1)\n         SPKM_REQ=<spkm-req>\n     (spkm-req is the SPKM-REQ\
    \ token with the mutual-state bit in the\n          options field of the REQ-TOKEN\
    \ not set)\n     If the authentication is successful, the target proceeds with:\n\
    \     T-> Login (CSG,NSG=0,1 T=1)\n     The initiator may proceed:\n     I-> Login\
    \ (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n     T-> Login (CSG,NSG=1,0\
    \ T=0)\n         ... iSCSI parameters\n     And at the end:\n     I-> Login  (CSG,NSG=1,3\
    \ T=1)\n         optional iSCSI parameters\n     T-> Login (CSG,NSG=1,3 T=1) \"\
    login accept\"\n   In the next example, the initiator and target authenticate\
    \ each\n   other via SRP:\n     I-> Login (CSG,NSG=0,1 T=1)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n\
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n         AuthMethod=KRB5,SRP,None\n\
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n         AuthMethod=SRP\n     I-> Login\
    \ (CSG,NSG=0,0 T=0)\n         SRP_U=<user>\n         TargetAuth=Yes\n     T->\
    \ Login (CSG,NSG=0,0 T=0)\n         SRP_GROUP=SRP-1536,SRP-1024\n         SRP_s=<s>\n\
    \     I-> Login (CSG,NSG=0,0 T=0)\n         SRP_GROUP=SRP-1536\n         SRP_A=<A>\n\
    \     T-> Login (CSG,NSG=0,0 T=0)\n         SRP_B=<B>\n     I-> Login (CSG,NSG=0,1\
    \ T=1)\n         SRP_M=<M>\n     If the initiator authentication is successful,\
    \ the target\n       proceeds:\n     T-> Login (CSG,NSG=0,1 T=1)\n         SRP_HM=<H(A\
    \ | M | K)>\n      Where N, g, s, A, B, M, and H(A | M | K) are defined in [RFC2945].\n\
    \     If the target authentication is not successful, the initiator\n        \
    \  terminates the connection; otherwise, it proceeds.\n     I-> Login (CSG,NSG=1,0\
    \ T=0)\n         ... iSCSI parameters\n     T-> Login (CSG,NSG=1,0 T=0)\n    \
    \     ... iSCSI parameters\n     And at the end:\n     I-> Login (CSG,NSG=1,3\
    \ T=1)\n         optional iSCSI parameters\n     T-> Login  (CSG,NSG=1,3 T=1)\
    \ \"login accept\"\n     If the initiator authentication is not successful, the\
    \ target\n          responds with:\n     T-> Login \"login reject\"\n     Instead\
    \ of the T-> Login SRP_HM=<H(A | M | K)>  message and\n          terminates the\
    \ connection.\n   In the next example, the initiator and target authenticate each\n\
    \   other via SRP:\n     I-> Login (CSG,NSG=0,1 T=1)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n\
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n         AuthMethod=KRB5,SRP,None\n\
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n         AuthMethod=SRP\n     I-> Login\
    \ (CSG,NSG=0,0 T=0)\n         SRP_U=<user>\n         TargetAuth=No\n      T->\
    \ Login (CSG,NSG=0,0 T=0)\n          SRP_GROUP=SRP-1536\n          SRP_s=<s>\n\
    \     I-> Login (CSG,NSG=0,0 T=0)\n         SRP_GROUP=SRP-1536\n         SRP_A=<A>\n\
    \     T-> Login (CSG,NSG=0,0 T=0)\n         SRP_B=<B>\n     I-> Login (CSG,NSG=0,1\
    \ T=1)\n         SRP_M=<M>\n     If the initiator authentication is successful,\
    \ the target\n          proceeds:\n     T-> Login (CSG,NSG=0,1 T=1)\n     I->\
    \ Login (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n     T-> Login (CSG,NSG=1,0\
    \ T=0)\n         ... iSCSI parameters\n     And at the end:\n     I-> Login (CSG,NSG=1,3\
    \ T=1)\n         optional iSCSI parameters\n     T-> Login (CSG,NSG=1,3 T=1) \"\
    login accept\"\n   In the next example the initiator and target authenticate each\
    \ other\n   via CHAP:\n     I-> Login (CSG,NSG=0,0 T=0)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n\
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n         AuthMethod=KRB5,CHAP,None\n\
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n         AuthMethod=CHAP\n     I-> Login\
    \ (CSG,NSG=0,0 T=0)\n         CHAP_A=<A1,A2>\n     T-> Login (CSG,NSG=0,0 T=0)\n\
    \         CHAP_A=<A1>\n         CHAP_I=<I>\n         CHAP_C=<C>\n     I-> Login\
    \ (CSG,NSG=0,1 T=1)\n         CHAP_N=<N>\n         CHAP_R=<R>\n         CHAP_I=<I>\n\
    \         CHAP_C=<C>\n     If the initiator authentication is successful, the\
    \ target\n       proceeds:\n     T-> Login (CSG,NSG=0,1 T=1)\n         CHAP_N=<N>\n\
    \         CHAP_R=<R>\n     If the target authentication is not successful, the\
    \ initiator\n       aborts the connection; otherwise, it proceeds.\n     I-> Login\
    \ (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n     T-> Login (CSG,NSG=1,0\
    \ T=0)\n         ... iSCSI parameters\n     And at the end:\n     I-> Login (CSG,NSG=1,3\
    \ T=1)\n         optional iSCSI parameters\n     T-> Login (CSG,NSG=1,3 T=1) \"\
    login accept\"\n     If the initiator authentication is not successful, the target\n\
    \       responds with:\n     T-> Login \"login reject\"\n     Instead of the Login\
    \ CHAP_R=<response> \"proceed and change\n       stage\" message and terminates\
    \ the connection.\n   In the next example, only the initiator is authenticated\
    \ by the\n   target via CHAP:\n     I-> Login (CSG,NSG=0,1 T=0)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n\
    \         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n         AuthMethod=KRB5,CHAP,None\n\
    \     T-> Login-PR (CSG,NSG=0,0 T=0)\n         AuthMethod=CHAP\n     I-> Login\
    \ (CSG,NSG=0,0 T=0)\n         CHAP_A=<A1,A2>\n     T-> Login (CSG,NSG=0,0 T=0)\n\
    \         CHAP_A=<A1>\n         CHAP_I=<I>\n         CHAP_C=<C>\n     I-> Login\
    \ (CSG,NSG=0,1 T=1)\n         CHAP_N=<N>\n         CHAP_R=<R>\n     If the initiator\
    \ authentication is successful, the target\n       proceeds:\n     T-> Login (CSG,NSG=0,1\
    \ T=1)\n     I-> Login (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n    \
    \ T-> Login (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n     And at the\
    \ end:\n     I-> Login (CSG,NSG=1,3 T=1)\n         optional iSCSI parameters\n\
    \     T-> Login (CSG,NSG=1,3 T=1) \"login accept\"\n   In the next example, the\
    \ initiator does not offer any security\n   parameters. It therefore may offer\
    \ iSCSI parameters on the Login PDU\n   with the T bit set to 1, and the target\
    \ may respond with a final\n   Login Response PDU immediately:\n     I-> Login\
    \ (CSG,NSG=1,3 T=1)\n         InitiatorName=iqn.1999-07.com.os:hostid.77\n   \
    \      TargetName=iqn.1999-07.com.example:diskarray.sn.88\n         ... iSCSI\
    \ parameters\n     T-> Login (CSG,NSG=1,3 T=1) \"login accept\"\n         ...\
    \ ISCSI parameters\n     In the next example, the initiator does offer security\n\
    \       parameters on the Login PDU, but the target does not choose\n       any\
    \ (i.e., chooses the \"None\" values):\n     I-> Login (CSG,NSG=0,1 T=1)\n   \
    \      InitiatorName=iqn.1999-07.com.os:hostid.77\n         TargetName=iqn.1999-07.com.example:diskarray.sn.88\n\
    \         AuthMethod=KRB5,SRP,None\n     T-> Login-PR (CSG,NSG=0,1 T=1)\n    \
    \     AuthMethod=None\n     I-> Login (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n\
    \     T-> Login (CSG,NSG=1,0 T=0)\n         ... iSCSI parameters\n     And at\
    \ the end:\n     I-> Login (CSG,NSG=1,3 T=1)\n         optional iSCSI parameters\n\
    \     T-> Login (CSG,NSG=1,3 T=1) \"login accept\"\n"
- title: Appendix D.  SendTargets Operation
  contents:
  - "Appendix D.  SendTargets Operation\n   To reduce the amount of configuration\
    \ required on an initiator, iSCSI\n   provides the SendTargets text request. \
    \ The initiator uses the\n   SendTargets request to get a list of targets to which\
    \ it may have\n   access, as well as the list of addresses (IP address and TCP\
    \ port) on\n   which these targets may be accessed.\n   To make use of SendTargets,\
    \ an initiator must first establish one of\n   two types of sessions.  If the\
    \ initiator establishes the session\n   using the key \"SessionType=Discovery\"\
    , the session is a discovery\n   session, and a target name does not need to be\
    \ specified.  Otherwise,\n   the session is a normal, operational session.  The\
    \ SendTargets\n   command MUST only be sent during the Full Feature Phase of a\
    \ normal\n   or discovery session.\n   A system that contains targets MUST support\
    \ discovery sessions on\n   each of its iSCSI IP address-port pairs, and MUST\
    \ support the\n   SendTargets command on the discovery session.  In a discovery\n\
    \   session, a target MUST return all path information (target name and\n   IP\
    \ address-port pairs and portal group tags) for the targets on the\n   target\
    \ network entity which the requesting initiator is authorized to\n   access.\n\
    \   A target MUST support the SendTargets command on operational\n   sessions;\
    \ these will only return path information about the target to\n   which the session\
    \ is connected, and do not need to return information\n   about other target names\
    \ that may be defined in the responding\n   system.\n   An initiator MAY make\
    \ use of the SendTargets as it sees fit.\n   A SendTargets command consists of\
    \ a single Text request PDU.  This\n   PDU contains exactly one text key and value.\
    \  The text key MUST be\n   SendTargets.  The expected response depends upon the\
    \ value, as well\n   as whether the session is a discovery or operational session.\n\
    \   The value must be one of:\n     All\n     The initiator is requesting that\
    \ information on all relevant\n       targets known to the implementation be returned.\
    \  This value\n       MUST be supported on a discovery session, and MUST NOT be\n\
    \       supported on an operational session.\n     <iSCSI-target-name>\n     If\
    \ an iSCSI target name is specified, the session should respond\n      with addresses\
    \ for only the named target, if possible.  This\n      value MUST be supported\
    \ on discovery sessions.  A discovery\n      session MUST be capable of returning\
    \ addresses for those\n      targets that would have been returned had value=All\
    \ had been\n      designated.\n     <nothing>\n     The session should only respond\
    \ with addresses for the target to\n       which the session is logged in.  This\
    \ MUST be supported on\n       operational sessions, and MUST NOT return targets\
    \ other than\n       the one to which the session is logged in.\n   The response\
    \ to this command is a text response that contains a list\n   of zero or more\
    \ targets and, optionally, their addresses.  Each\n   target is returned as a\
    \ target record.  A target record begins with\n   the TargetName text key, followed\
    \ by a list of TargetAddress text\n   keys, and bounded by the end of the text\
    \ response or the next\n   TargetName key, which begins a new record.  No text\
    \ keys other than\n   TargetName and TargetAddress are permitted within a SendTargets\n\
    \   response.\n   For the format of the TargetName, see Section 12.4 TargetName.\n\
    \   In a discovery session, a target MAY respond to a SendTargets request\n  \
    \ with its complete list of targets, or with a list of targets that is\n   based\
    \ on the name of the initiator logged in to the session.\n   A SendTargets response\
    \ MUST NOT contain target names if there are no\n   targets for the requesting\
    \ initiator to access.\n   Each target record returned includes zero or more TargetAddress\n\
    \   fields.\n   Each target record starts with one text key of the form:\n   \
    \  TargetName=<target-name-goes-here>\n   Followed by zero or more address keys\
    \ of the form:\n     TargetAddress=<hostname-or-ipaddress>[:<tcp-port>],\n   \
    \    <portal-group-tag>\n   The hostname-or-ipaddress contains a domain name,\
    \ IPv4 address, or\n   IPv6 address, as specified for the TargetAddress key.\n\
    \   A hostname-or-ipaddress duplicated in TargetAddress responses for a\n   given\
    \ node (the port is absent or equal) would probably indicate that\n   multiple\
    \ address families are in use at once (IPV6 and IPV4).\n   Each TargetAddress\
    \ belongs to a portal group, identified by its\n   numeric portal group tag (as\
    \ in Section 12.9 TargetPortalGroupTag).\n   The iSCSI target name, together with\
    \ this tag, constitutes the SCSI\n   port identifier; the tag only needs to be\
    \ unique within a given\n   target's name list of addresses.\n   Multiple-connection\
    \ sessions can span iSCSI addresses that belong to\n   the same portal group.\n\
    \   Multiple-connection sessions cannot span iSCSI addresses that belong\n   to\
    \ different portal groups.\n   If a SendTargets response reports an iSCSI address\
    \ for a target, it\n   SHOULD also report all other addresses in its portal group\
    \ in the\n   same response.\n   A SendTargets text response can be longer than\
    \ a single Text Response\n   PDU, and makes use of the long text responses as\
    \ specified.\n   After obtaining a list of targets from the discovery target session,\n\
    \   an iSCSI initiator may initiate new sessions to log in to the\n   discovered\
    \ targets for full operation.  The initiator MAY keep the\n   discovery session\
    \ open, and MAY send subsequent SendTargets commands\n   to discover new targets.\n\
    \   Examples:\n   This example is the SendTargets response from a single target\
    \ that\n   has no other interface ports.\n   Initiator sends text request that\
    \ contains:\n         SendTargets=All\n   Target sends a text response that contains:\n\
    \         TargetName=iqn.1993-11.com.example:diskarray.sn.8675309\n   All the\
    \ target had to return in the simple case was the target name.\n   It is assumed\
    \ by the initiator that the IP address and TCP port for\n   this target are the\
    \ same as used on the current connection to the\n   default iSCSI target.\n  \
    \ The next example has two internal iSCSI targets, each accessible via\n   two\
    \ different ports with different IP addresses.  The following is\n   the text\
    \ response:\n      TargetName=iqn.1993-11.com.example:diskarray.sn.8675309\n \
    \     TargetAddress=10.1.0.45:3000,1 TargetAddress=10.1.1.45:3000,2\n      TargetName=iqn.1993-11.com.example:diskarray.sn.1234567\n\
    \      TargetAddress=10.1.0.45:3000,1 TargetAddress=10.1.1.45:3000,2\n   Both\
    \ targets share both addresses; the multiple addresses are likely\n   used to\
    \ provide multi-path support.  The initiator may connect to\n   either target\
    \ name on either address.  Each of the addresses has its\n   own portal group\
    \ tag; they do not support spanning\n   multiple-connection sessions with each\
    \ other.  Keep in mind that the\n   portal group tags for the two named targets\
    \ are independent of one\n   another; portal group \"1\" on the first target is\
    \ not necessarily the\n   same as portal group \"1\" on the second target.\n \
    \  In the above example, a DNS host name or an IPv6 address could have\n   been\
    \ returned instead of an IPv4 address.\n   The next text response shows a target\
    \ that supports spanning sessions\n   across multiple addresses, and further illustrates\
    \ the use of the\n   portal group tags:\n       TargetName=iqn.1993-11.com.example:diskarray.sn.8675309\n\
    \      TargetAddress=10.1.0.45:3000,1 TargetAddress=10.1.1.46:3000,1\n      TargetAddress=10.1.0.47:3000,2\
    \ TargetAddress=10.1.1.48:3000,2\n      TargetAddress=10.1.1.49:3000,3\n   In\
    \ this example, any of the target addresses can be used to reach the\n   same\
    \ target.  A single-connection session can be established to any\n   of these\
    \ TCP addresses.  A multiple-connection session could span\n   addresses .45 and\
    \ .46 or .47 and .48, but cannot span any other\n   combination.  A TargetAddress\
    \ with its own tag (.49) cannot be\n   combined with any other address within\
    \ the same session.\n   This SendTargets response does not indicate whether .49\
    \ supports\n   multiple connections per session; it is communicated via the\n\
    \   MaxConnections text key upon login to the target.\n"
- title: Appendix E.  Algorithmic Presentation of Error Recovery Classes
  contents:
  - "Appendix E.  Algorithmic Presentation of Error Recovery Classes\n   This appendix\
    \ illustrates the error recovery classes using a\n   pseudo-programming-language.\
    \  The procedure names are chosen to be\n   obvious to most implementers.  Each\
    \ of the recovery classes described\n   has initiator procedures as well as target\
    \ procedures.  These\n   algorithms focus on outlining the mechanics of error\
    \ recovery\n   classes, and do not exhaustively describe all other aspects/cases.\n\
    \   Examples of this approach are:\n      -  Handling for only certain Opcode\
    \ types is shown.\n      -  Only certain reason codes (e.g., Recovery in Logout\
    \ command)\n         are outlined.\n      -  Resultant cases, such as recovery\
    \ of Synchronization on a\n         header digest error are considered out-of-scope\
    \ in these\n         algorithms.  In this particular example, a header digest\
    \ error\n         may lead to connection recovery if some type of sync and\n \
    \        steering layer is not implemented.\n   These algorithms strive to convey\
    \ the iSCSI error recovery concepts\n   in the simplest terms, and are not designed\
    \ to be optimal.\n"
- title: E.1.  General Data Structure and Procedure Description
  contents:
  - "E.1.  General Data Structure and Procedure Description\n   This section defines\
    \ the procedures and data structures that are\n   commonly used by all the error\
    \ recovery algorithms.  The structures\n   may not be the exhaustive representations\
    \ of what is required for a\n   typical implementation.\n   Data structure definitions\
    \ -\n   struct TransferContext {\n           int TargetTransferTag;\n        \
    \   int ExpectedDataSN;\n   };\n   struct TCB {              /* task control block\
    \ */\n           Boolean SoFarInOrder;\n           int ExpectedDataSN; /* used\
    \ for both R2Ts, and Data */\n           int MissingDataSNList[MaxMissingDPDU];\n\
    \           Boolean FbitReceived;\n           Boolean StatusXferd;\n         \
    \  Boolean CurrentlyAllegiant;\n           int ActiveR2Ts;\n           int Response;\n\
    \           char *Reason;\n           struct TransferContext\n               \
    \        TransferContextList[MaxOutStandingR2T];\n           int InitiatorTaskTag;\n\
    \           int CmdSN;\n           int SNACK_Tag;\n   };\n   struct Connection\
    \ {\n           struct Session SessionReference;\n           Boolean SoFarInOrder;\n\
    \           int CID;\n           int State;\n           int CurrentTimeout;\n\
    \           int ExpectedStatSN;\n           int MissingStatSNList[MaxMissingSPDU];\n\
    \           Boolean PerformConnectionCleanup;\n   };\n   struct Session {\n  \
    \         int NumConnections;\n           int CmdSN;\n           int Maxconnections;\n\
    \           int ErrorRecoveryLevel;\n           struct iSCSIEndpoint OtherEndInfo;\n\
    \           struct Connection ConnectionList[MaxSupportedConns];\n   };\n   Procedure\
    \ descriptions -\n   Receive-a-In-PDU(transport connection, inbound PDU);\n  \
    \ check-basic-validity(inbound PDU);\n   Start-Timer(timeout handler, argument,\
    \ timeout value);\n   Build-And-Send-Reject(transport connection, bad PDU, reason\
    \ code);\n"
- title: E.2.  Within-command Error Recovery Algorithms
  contents:
  - 'E.2.  Within-command Error Recovery Algorithms

    '
- title: E.2.1.  Procedure Descriptions
  contents:
  - "E.2.1.  Procedure Descriptions\n   Recover-Data-if-Possible(last required DataSN,\
    \ task control\n   block);\n   Build-And-Send-DSnack(task control block);\n  \
    \ Build-And-Send-RDSnack(task control block);\n   Build-And-Send-Abort(task control\
    \ block);\n   SCSI-Task-Completion(task control block);\n   Build-And-Send-A-Data-Burst(transport\
    \ connection, data-descriptor,\n                                             \
    \    task control block);\n   Build-And-Send-R2T(transport connection, data-descriptor,\n\
    \                                                task control block);\n   Build-And-Send-Status(transport\
    \ connection, task control block);\n   Transfer-Context-Timeout-Handler(transfer\
    \ context);\n   Notes:\n      -  One procedure used in this section: Handle-Status-SNACK-\n\
    \         request is defined in Within-connection recovery algorithms.\n     \
    \ -  The Response processing pseudo-code, shown in the target\n         algorithms,\
    \ applies to all solicited PDUs that carry StatSN -\n         SCSI Response, Text\
    \ Response etc.\n"
- title: E.2.2.  Initiator Algorithms
  contents:
  - 'E.2.2.  Initiator Algorithms

    '
- title: Recover-Data-if-Possible(LastRequiredDataSN, TCB)
  contents:
  - 'Recover-Data-if-Possible(LastRequiredDataSN, TCB)

    '
- title: '{'
  contents:
  - "{\n  if (operational ErrorRecoveryLevel > 0) {\n       if (# of missing PDUs\
    \ is trackable) {\n             Note the missing DataSNs in TCB.\n           \
    \  if (the task spanned a change in\n                       MaxRecvDataSegmentLength)\
    \ {\n                  if (TCB.StatusXferd is TRUE)\n                     drop\
    \ the status PDU;\n                  Build-And-Send-RDSnack(TCB);\n          \
    \   } else {\n                  Build-And-Send-DSnack(TCB);\n             }\n\
    \       } else {\n           TCB.Reason = \"Protocol service CRC error\";\n  \
    \         }\n  } else {\n        TCB.Reason = \"Protocol service CRC error\";\n\
    \  }\n  if (TCB.Reason == \"Protocol service CRC error\") {\n        Clear the\
    \ missing PDU list in the TCB.\n        if (TCB.StatusXferd is not TRUE)\n   \
    \        Build-And-Send-Abort(TCB);\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: Receive-a-In-PDU(Connection, CurrentPDU)
  contents:
  - 'Receive-a-In-PDU(Connection, CurrentPDU)

    '
- title: '{'
  contents:
  - "{\n  check-basic-validity(CurrentPDU);\n  if (Header-Digest-Bad) discard, return;\n\
    \  Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n  if ((CurrentPDU.type == Data)\n\
    \              or (CurrentPDU.type = R2T)) {\n     if (Data-Digest-Bad for Data)\
    \ {\n           send-data-SNACK = TRUE;\n       LastRequiredDataSN = CurrentPDU.DataSN;\n\
    \         } else {\n           if (TCB.SoFarInOrder = TRUE) {\n              \
    \ if (current DataSN is expected) {\n                    Increment TCB.ExpectedDataSN.\n\
    \               } else {\n                    TCB.SoFarInOrder = FALSE;\n    \
    \                send-data-SNACK = TRUE;\n                   }\n           } else\
    \ {\n                  if (current DataSN was considered missing) {\n        \
    \              remove current DataSN from missing PDU list.\n                \
    \  } else if (current DataSN is higher than expected)\n"
- title: '{'
  contents:
  - "{\n                        send-data-SNACK = TRUE;\n                   } else\
    \ {\n                         discard, return;\n                   }\n       \
    \            Adjust TCB.ExpectedDataSN if appropriate.\n           }\n       \
    \    LastRequiredDataSN = CurrentPDU.DataSN - 1;\n        }\n        if (send-data-SNACK\
    \ is TRUE and\n               task is not already considered failed) {\n     \
    \      Recover-Data-if-Possible(LastRequiredDataSN, TCB);\n     }\n        if\
    \ (missing data PDU list is empty) {\n           TCB.SoFarInOrder = TRUE;\n  \
    \      }\n     if (CurrentPDU.type == R2T) {\n        Increment ActiveR2Ts for\
    \ this task.\n        Create a data-descriptor for the data burst.\n        Build-And-Send-A-Data-Burst(Connection,\
    \ data-descriptor,\n                                                TCB);\n  \
    \   }\n  } else if (CurrentPDU.type == Response) {\n     if (Data-Digest-Bad)\
    \ {\n           send-status-SNACK = TRUE;\n        } else {\n        TCB.StatusXferd\
    \ = TRUE;\n        Store the status information in TCB.\n        if (ExpDataSN\
    \ does not match) {\n             TCB.SoFarInOrder = FALSE;\n             Recover-Data-if-Possible(current\
    \ DataSN, TCB);\n        }\n           if (missing data PDU list is empty) {\n\
    \                TCB.SoFarInOrder = TRUE;\n           }\n     }\n  } else { /*\
    \ REST UNRELATED TO WITHIN-COMMAND-RECOVERY, NOT\n              SHOWN */\n  }\n\
    \  if ((TCB.SoFarInOrder == TRUE) and\n                        (TCB.StatusXferd\
    \ == TRUE)) {\n     SCSI-Task-Completion(TCB);\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: E.2.3.  Target Algorithms
  contents:
  - 'E.2.3.  Target Algorithms

    '
- title: Receive-a-In-PDU(Connection, CurrentPDU)
  contents:
  - 'Receive-a-In-PDU(Connection, CurrentPDU)

    '
- title: '{'
  contents:
  - "{\n  check-basic-validity(CurrentPDU);\n  if (Header-Digest-Bad) discard, return;\n\
    \  Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n  if (CurrentPDU.type == Data)\
    \ {\n      Retrieve TContext from CurrentPDU.TargetTransferTag;\n      if (Data-Digest-Bad)\
    \ {\n            Build-And-Send-Reject(Connection, CurrentPDU,\n             \
    \                 Payload-Digest-Error);\n         Note the missing data PDUs\
    \ in MissingDataRange[].\n            send-recovery-R2T = TRUE;\n         } else\
    \ {\n         if (current DataSN is not expected) {\n             Note the missing\
    \ data PDUs in MissingDataRange[].\n                send-recovery-R2T = TRUE;\n\
    \            }\n         if (CurrentPDU.Fbit == TRUE) {\n             if (current\
    \ PDU is solicited) {\n                    Decrement TCB.ActiveR2Ts.\n       \
    \      }\n             if ((current PDU is unsolicited and\n                 \
    \   data received is less than I/O length and\n                      data received\
    \ is less than FirstBurstLength)\n                 or (current PDU is solicited\
    \ and the length of\n                      this burst is less than expected))\
    \ {\n                 send-recovery-R2T = TRUE;\n                 Note the missing\
    \ data in MissingDataRange[].\n             }\n            }\n         }\n   \
    \      Increment TContext.ExpectedDataSN.\n      if (send-recovery-R2T is TRUE\
    \  and\n                task is not already considered failed) {\n         if\
    \ (operational ErrorRecoveryLevel > 0) {\n             Increment TCB.ActiveR2Ts.\n\
    \             Create a data-descriptor for the data burst\n                  \
    \      from MissingDataRange.\n             Build-And-Send-R2T(Connection, data-descriptor,\
    \ TCB);\n         } else {\n              if (current PDU is the last unsolicited)\n\
    \                 TCB.Reason = \"Not enough unsolicited data\";\n            \
    \  else\n                  TCB.Reason = \"Protocol service CRC error\";\n    \
    \     }\n      }\n      if (TCB.ActiveR2Ts == 0) {\n         Build-And-Send-Status(Connection,\
    \ TCB);\n      }\n  } else if (CurrentPDU.type == SNACK) {\n      snack-failure\
    \ = FALSE;\n      if (operational ErrorRecoveryLevel > 0) {\n         if (CurrentPDU.type\
    \ == Data/R2T) {\n              if (the request is satisfiable) {\n          \
    \       if (request for Data) {\n                    Create a data-descriptor\
    \ for the data burst\n                        from BegRun and RunLength.\n   \
    \                 Build-And-Send-A-Data-Burst(Connection,\n                  \
    \                data-descriptor, TCB);\n                 } else { /* R2T */\n\
    \                    Create a data-descriptor for the data burst\n           \
    \             from BegRun and RunLength.\n                    Build-And-Send-R2T(Connection,\
    \ data-descriptor,\n                                   TCB);\n               \
    \   }\n              } else {\n                    snack-failure = TRUE;\n   \
    \           }\n         } else if (CurrentPDU.type == status) {\n            \
    \  Handle-Status-SNACK-request(Connection, CurrentPDU);\n         } else if (CurrentPDU.type\
    \ == DataACK) {\n              Consider all data upto CurrentPDU.BegRun as\n \
    \             acknowledged.\n              Free up the retransmission resources\
    \ for that data.\n         } else if (CurrentPDU.type == R-Data SNACK) {\n   \
    \              Create a data descriptor for a data burst covering\n          \
    \       all unacknowledged data.\n              Build-And-Send-A-Data-Burst(Connection,\n\
    \                                  data-descriptor, TCB);\n              TCB.SNACK_Tag\
    \ = CurrentPDU.SNACK_Tag;\n              if (there's no more data to send) {\n\
    \                 Build-And-Send-Status(Connection, TCB);\n              }\n \
    \        }\n      } else { /* operational ErrorRecoveryLevel = 0 */\n        \
    \      snack-failure = TRUE;\n      }\n      if (snack-failure == TRUE) {\n  \
    \        Build-And-Send-Reject(Connection, CurrentPDU,\n                     \
    \                             SNACK-Reject);\n          if (TCB.StatusXferd !=\
    \ TRUE) {\n              TCB.Reason = \"SNACK Rejected\";\n              Build-And-Send-Status(Connection,\
    \ TCB);\n          }\n      }\n  } else { /* REST UNRELATED TO WITHIN-COMMAND-RECOVERY,\
    \ NOT SHOWN */\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: Transfer-Context-Timeout-Handler(TContext)
  contents:
  - 'Transfer-Context-Timeout-Handler(TContext)

    '
- title: '{'
  contents:
  - "{\n  Retrieve TCB and Connection from TContext.\n  Decrement TCB.ActiveR2Ts.\n\
    \  if (operational ErrorRecoveryLevel > 0 and\n                task is not already\
    \ considered failed) {\n      Note the missing data PDUs in MissingDataRange[].\n\
    \      Create a data-descriptor for the data burst\n                        from\
    \ MissingDataRange[].\n      Build-And-Send-R2T(Connection, data-descriptor, TCB);\n\
    \  } else {\n      TCB.Reason = \"Protocol service CRC error\";\n      if (TCB.ActiveR2Ts\
    \ = 0) {\n         Build-And-Send-Status(Connection, TCB);\n      }\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: E.3.  Within-connection Recovery Algorithms
  contents:
  - 'E.3.  Within-connection Recovery Algorithms

    '
- title: E.3.1.  Procedure Descriptions
  contents:
  - 'E.3.1.  Procedure Descriptions

    '
- title: 'Procedure descriptions:'
  contents:
  - 'Procedure descriptions:

    '
- title: Recover-Status-if-Possible(transport connection,
  contents:
  - "Recover-Status-if-Possible(transport connection,\n                          \
    \          currently received PDU);\n"
- title: Evaluate-a-StatSN(transport connection, currently received PDU);
  contents:
  - 'Evaluate-a-StatSN(transport connection, currently received PDU);

    '
- title: Retransmit-Command-if-Possible(transport connection, CmdSN);
  contents:
  - 'Retransmit-Command-if-Possible(transport connection, CmdSN);

    '
- title: Build-And-Send-SSnack(transport connection);
  contents:
  - 'Build-And-Send-SSnack(transport connection);

    '
- title: Build-And-Send-Command(transport connection, task control block);
  contents:
  - 'Build-And-Send-Command(transport connection, task control block);

    '
- title: Command-Acknowledge-Timeout-Handler(task control block);
  contents:
  - 'Command-Acknowledge-Timeout-Handler(task control block);

    '
- title: Status-Expect-Timeout-Handler(transport connection);
  contents:
  - 'Status-Expect-Timeout-Handler(transport connection);

    '
- title: Build-And-Send-Nop-Out(transport connection);
  contents:
  - 'Build-And-Send-Nop-Out(transport connection);

    '
- title: Handle-Status-SNACK-request(transport connection, status SNACK
  contents:
  - 'Handle-Status-SNACK-request(transport connection, status SNACK

    '
- title: PDU);
  contents:
  - 'PDU);

    '
- title: Retransmit-Status-Burst(status SNACK, task control block);
  contents:
  - 'Retransmit-Status-Burst(status SNACK, task control block);

    '
- title: Is-Acknowledged(beginning StatSN, run length);
  contents:
  - 'Is-Acknowledged(beginning StatSN, run length);

    '
- title: 'Implementation-specific tunables:'
  contents:
  - 'Implementation-specific tunables:

    '
- title: InitiatorProactiveSNACKEnabled
  contents:
  - "InitiatorProactiveSNACKEnabled\n   Notes:\n      -  The initiator algorithms\
    \ only deal with unsolicited Nop-In PDUs\n         for generating status SNACKs.\
    \  A solicited Nop-In PDU has an\n         assigned StatSN, which, when out of\
    \ order, could trigger the\n         out of order StatSN handling in Within-command\
    \ algorithms,\n         again leading to Recover-Status-if-Possible.\n      -\
    \  The pseudo-code shown may result in the retransmission of\n         unacknowledged\
    \ commands in more cases than necessary.  This\n         will not, however, affect\
    \ the correctness of the operation\n         because the target is required to\
    \ discard the duplicate CmdSNs.\n      -  The procedure Build-And-Send-Async is\
    \ defined in the Connection\n         recovery algorithms.\n      -  The procedure\
    \ Status-Expect-Timeout-Handler describes how\n         initiators may proactively\
    \ attempt to retrieve the Status if\n         they so choose. This procedure is\
    \ assumed to be triggered much\n         before the standard ULP timeout.\n"
- title: E.3.2.  Initiator Algorithms
  contents:
  - 'E.3.2.  Initiator Algorithms

    '
- title: Recover-Status-if-Possible(Connection, CurrentPDU)
  contents:
  - 'Recover-Status-if-Possible(Connection, CurrentPDU)

    '
- title: '{'
  contents:
  - "{\n  if ((Connection.state == LOGGED_IN) and\n                 connection is\
    \ not already considered failed) {\n     if (operational ErrorRecoveryLevel >\
    \ 0) {\n        if (# of missing PDUs is trackable) {\n              Note the\
    \ missing StatSNs in Connection\n             that were not already requested\
    \ with SNACK;\n          Build-And-Send-SSnack(Connection);\n            } else\
    \ {\n              Connection.PerformConnectionCleanup = TRUE;\n        }\n  \
    \   } else {\n            Connection.PerformConnectionCleanup = TRUE;\n     }\n\
    \     if (Connection.PerformConnectionCleanup == TRUE) {\n        Start-Timer(Connection-Cleanup-Handler,\
    \ Connection, 0);\n         }\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: Retransmit-Command-if-Possible(Connection, CmdSN)
  contents:
  - 'Retransmit-Command-if-Possible(Connection, CmdSN)

    '
- title: '{'
  contents:
  - "{\n  if (operational ErrorRecoveryLevel > 0) {\n     Retrieve the InitiatorTaskTag,\
    \ and thus TCB for the CmdSN.\n     Build-And-Send-Command(Connection, TCB);\n\
    \  }\n"
- title: '}'
  contents:
  - '}

    '
- title: Evaluate-a-StatSN(Connection, CurrentPDU)
  contents:
  - 'Evaluate-a-StatSN(Connection, CurrentPDU)

    '
- title: '{'
  contents:
  - "{\n  send-status-SNACK = FALSE;\n  if (Connection.SoFarInOrder == TRUE) {\n \
    \    if (current StatSN is the expected) {\n          Increment Connection.ExpectedStatSN.\n\
    \     } else {\n              Connection.SoFarInOrder = FALSE;\n             \
    \ send-status-SNACK = TRUE;\n         }\n  } else {\n     if (current StatSN was\
    \ considered missing) {\n          remove current StatSN from the missing list.\n\
    \     } else {\n              if (current StatSN is higher than expected){\n \
    \                 send-status-SNACK = TRUE;\n              } else {\n        \
    \          send-status-SNACK = FALSE;\n              discard the PDU;\n      \
    \    }\n     }\n     Adjust Connection.ExpectedStatSN if appropriate.\n     if\
    \ (missing StatSN list is empty) {\n          Connection.SoFarInOrder = TRUE;\n\
    \         }\n  }\n  return send-status-SNACK;\n"
- title: '}'
  contents:
  - '}

    '
- title: Receive-a-In-PDU(Connection, CurrentPDU)
  contents:
  - 'Receive-a-In-PDU(Connection, CurrentPDU)

    '
- title: '{'
  contents:
  - "{\n  check-basic-validity(CurrentPDU);\n  if (Header-Digest-Bad) discard, return;\n\
    \  Retrieve TCB for CurrentPDU.InitiatorTaskTag.\n  if (CurrentPDU.type == Nop-In)\
    \ {\n        if (the PDU is unsolicited) {\n              if (current StatSN is\
    \ not expected) {\n                   Recover-Status-if-Possible(Connection,\n\
    \                                CurrentPDU);\n              }\n             \
    \ if (current ExpCmdSN is not Session.CmdSN) {\n                  Retransmit-Command-if-Possible(Connection,\n\
    \                                CurrentPDU.ExpCmdSN);\n              }\n    \
    \    }\n  } else if (CurrentPDU.type == Reject) {\n        if (it is a data digest\
    \ error on immediate data) {\n              Retransmit-Command-if-Possible(Connection,\n\
    \                                 CurrentPDU.BadPDUHeader.CmdSN);\n        }\n\
    \  } else if (CurrentPDU.type == Response) {\n       send-status-SNACK = Evaluate-a-StatSN(Connection,\n\
    \                                      CurrentPDU);\n       if (send-status-SNACK\
    \ == TRUE)\n           Recover-Status-if-Possible(Connection, CurrentPDU);\n \
    \ } else { /* REST UNRELATED TO WITHIN-CONNECTION-RECOVERY,\n            * NOT\
    \ SHOWN */\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: Command-Acknowledge-Timeout-Handler(TCB)
  contents:
  - 'Command-Acknowledge-Timeout-Handler(TCB)

    '
- title: '{'
  contents:
  - "{\n  Retrieve the Connection for TCB.\n  Retransmit-Command-if-Possible(Connection,\
    \ TCB.CmdSN);\n"
- title: '}'
  contents:
  - '}

    '
- title: Status-Expect-Timeout-Handler(Connection)
  contents:
  - 'Status-Expect-Timeout-Handler(Connection)

    '
- title: '{'
  contents:
  - "{\n  if (operational ErrorRecoveryLevel > 0) {\n      Build-And-Send-Nop-Out(Connection);\n\
    \  } else if (InitiatorProactiveSNACKEnabled){\n      if ((Connection.state ==\
    \ LOGGED_IN) and\n             connection is not already considered failed) {\n\
    \           Build-And-Send-SSnack(Connection);\n      }\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: E.3.3.   Target Algorithms
  contents:
  - 'E.3.3.   Target Algorithms

    '
- title: Handle-Status-SNACK-request(Connection, CurrentPDU)
  contents:
  - 'Handle-Status-SNACK-request(Connection, CurrentPDU)

    '
- title: '{'
  contents:
  - "{\n  if (operational ErrorRecoveryLevel > 0) {\n     if (request for an acknowledged\
    \ run) {\n         Build-And-Send-Reject(Connection, CurrentPDU,\n           \
    \                                Protocol-Error);\n     } else if (request for\
    \ an untransmitted run) {\n         discard, return;\n     } else {\n        \
    \ Retransmit-Status-Burst(CurrentPDU, TCB);\n     } else {\n        Build-And-Send-Async(Connection,\
    \ DroppedConnection,\n                                DefaultTime2Wait,\n    \
    \                            DefaultTime2Retain);\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: E.4.  Connection Recovery Algorithms
  contents:
  - 'E.4.  Connection Recovery Algorithms

    '
- title: E.4.1.  Procedure Descriptions
  contents:
  - 'E.4.1.  Procedure Descriptions

    '
- title: Build-And-Send-Async(transport connection, reason code,
  contents:
  - "Build-And-Send-Async(transport connection, reason code,\n                   \
    \                minimum time, maximum time);\n"
- title: Pick-A-Logged-In-Connection(session);
  contents:
  - 'Pick-A-Logged-In-Connection(session);

    '
- title: Build-And-Send-Logout(transport connection, logout connection
  contents:
  - "Build-And-Send-Logout(transport connection, logout connection\n             \
    \     identifier, reason code);\n"
- title: PerformImplicitLogout(transport connection, logout connection
  contents:
  - "PerformImplicitLogout(transport connection, logout connection\n             \
    \     identifier, target information);\n"
- title: PerformLogin(transport connection, target information);
  contents:
  - 'PerformLogin(transport connection, target information);

    '
- title: CreateNewTransportConnection(target information);
  contents:
  - 'CreateNewTransportConnection(target information);

    '
- title: Build-And-Send-Command(transport connection, task control block);
  contents:
  - 'Build-And-Send-Command(transport connection, task control block);

    '
- title: Connection-Cleanup-Handler(transport connection);
  contents:
  - 'Connection-Cleanup-Handler(transport connection);

    '
- title: Connection-Resource-Timeout-Handler(transport connection);
  contents:
  - 'Connection-Resource-Timeout-Handler(transport connection);

    '
- title: Quiesce-And-Prepare-for-New-Allegiance(session, task control
  contents:
  - 'Quiesce-And-Prepare-for-New-Allegiance(session, task control

    '
- title: block);
  contents:
  - 'block);

    '
- title: Build-And-Send-Logout-Response(transport connection,
  contents:
  - "Build-And-Send-Logout-Response(transport connection,\n                      \
    \   CID of connection in recovery, reason\n"
- title: code);
  contents:
  - 'code);

    '
- title: Build-And-Send-TaskMgmt-Response(transport connection,
  contents:
  - "Build-And-Send-TaskMgmt-Response(transport connection,\n                    \
    \   task mgmt command PDU, response code);\n"
- title: Establish-New-Allegiance(task control block, transport
  contents:
  - 'Establish-New-Allegiance(task control block, transport

    '
- title: connection);
  contents:
  - 'connection);

    '
- title: Schedule-Command-To-Continue(task control block);
  contents:
  - 'Schedule-Command-To-Continue(task control block);

    '
- title: 'Notes:'
  contents:
  - "Notes:\n      - Transport exception conditions, such as unexpected connection\n\
    \         termination, connection reset, and hung connection while the\n     \
    \    connection is in the full-feature phase, are all assumed to be\n        \
    \ asynchronously signaled to the iSCSI layer using the\n         Transport_Exception_Handler\
    \ procedure.\n"
- title: E.4.2.  Initiator Algorithms
  contents:
  - "E.4.2.  Initiator Algorithms\n         Receive-a-In-PDU(Connection, CurrentPDU)\
    \ {\n           check-basic-validity(CurrentPDU);\n           if (Header-Digest-Bad)\
    \ discard, return;\n           Retrieve TCB from CurrentPDU.InitiatorTaskTag.\n\
    \           if (CurrentPDU.type == Async) {\n               if (CurrentPDU.AsyncEvent\
    \ == ConnectionDropped) {\n                  Retrieve the AffectedConnection for\n\
    \         CurrentPDU.Parameter1.\n                  AffectedConnection.CurrentTimeout\
    \ =\n         CurrentPDU.Parameter3;\n                  AffectedConnection.State\
    \ = CLEANUP_WAIT;\n                  Start-Timer(Connection-Cleanup-Handler,\n\
    \                               AffectedConnection,\n         CurrentPDU.Parameter2);\n\
    \               } else if (CurrentPDU.AsyncEvent == LogoutRequest)) {\n      \
    \           AffectedConnection = Connection;\n                 AffectedConnection.State\
    \ = LOGOUT_REQUESTED;\n                 AffectedConnection.PerformConnectionCleanup\
    \ = TRUE;\n                 AffectedConnection.CurrentTimeout =\n         CurrentPDU.Parameter3;\n\
    \                 Start-Timer(Connection-Cleanup-Handler,\n                  \
    \             AffectedConnection, 0);\n               } else if (CurrentPDU.AsyncEvent\
    \ == SessionDropped)) {\n                 for (each Connection) {\n          \
    \           Connection.State = CLEANUP_WAIT;\n                     Connection.CurrentTimeout\
    \ = CurrentPDU.Parameter3;\n                     Start-Timer(Connection-Cleanup-Handler,\n\
    \                               Connection, CurrentPDU.Parameter2);\n        \
    \         }\n                 Session.state = FAILED;\n               }\n    \
    \       } else if (CurrentPDU.type == LogoutResponse) {\n               Retrieve\
    \ the CleanupConnection for CurrentPDU.CID.\n               if (CurrentPDU.Response\
    \ = failure) {\n                  CleanupConnection.State = CLEANUP_WAIT;\n  \
    \             } else {\n                   CleanupConnection.State = FREE;\n \
    \              }\n           } else if (CurrentPDU.type == LoginResponse) {\n\
    \                if (this is a response to an implicit Logout) {\n           \
    \        Retrieve the CleanupConnection.\n                   if (successful) {\n\
    \                       CleanupConnection.State = FREE;\n                    \
    \   Connection.State = LOGGED_IN;\n                   } else {\n             \
    \           CleanupConnection.State = CLEANUP_WAIT;\n                        DestroyTransportConnection(Connection);\n\
    \                   }\n                }\n           } else { /* REST UNRELATED\
    \ TO CONNECTION-RECOVERY,\n                     * NOT SHOWN */\n           }\n\
    \           if (CleanupConnection.State == FREE) {\n              for (each command\
    \ that was active on CleanupConnection) {\n              /* Establish new connection\
    \ allegiance */\n                   NewConnection = Pick-A-Logged-In-Connection(Session);\n\
    \                   Build-And-Send-Command(NewConnection, TCB);\n            \
    \   }\n           } }\n         Connection-Cleanup-Handler(Connection) {\n   \
    \        Retrieve Session from Connection.\n           if (Connection can still\
    \ exchange iSCSI PDUs) {\n               NewConnection = Connection;\n       \
    \    } else {\n               Start-Timer(Connection-Resource-Timeout-Handler,\n\
    \                     Connection, Connection.CurrentTimeout);\n              \
    \ if (there are other logged-in connections) {\n                    NewConnection\
    \ = Pick-A-Logged-In-\n         Connection(Session);\n               } else {\n\
    \                    NewConnection =\n                      CreateTransportConnection(Session.OtherEndInfo);\n\
    \                    Initiate an implicit Logout on NewConnection for\n      \
    \                                                Connection.CID.\n           \
    \         return;\n               }\n           }\n           Build-And-Send-Logout(NewConnection,\
    \ Connection.CID,\n                                               RecoveryRemove);\
    \ }\n         Transport_Exception_Handler(Connection) {\n           Connection.PerformConnectionCleanup\
    \ = TRUE;\n           if (the event is an unexpected transport disconnect) {\n\
    \               Connection.State = CLEANUP_WAIT;\n               Connection.CurrentTimeout\
    \ = DefaultTime2Retain;\n               Start-Timer(Connection-Cleanup-Handler,\
    \ Connection,\n                                                 DefaultTime2Wait);\n\
    \           } else {\n               Connection.State = FREE;\n           } }\n"
- title: E.4.3.  Target Algorithms
  contents:
  - "E.4.3.  Target Algorithms\n         Receive-a-In-PDU(Connection, CurrentPDU)\n\
    \         {\n           check-basic-validity(CurrentPDU);\n           if (Header-Digest-Bad)\
    \ discard, return;\n           else if (Data-Digest-Bad) {\n                 Build-And-Send-Reject(Connection,\
    \ CurrentPDU,\n                                             Payload-Digest-Error);\n\
    \                 discard, return;\n           }\n           Retrieve TCB and\
    \ Session.\n           if (CurrentPDU.type == Logout) {\n              if (CurrentPDU.ReasonCode\
    \ = RecoveryRemove) {\n                  Retrieve the CleanupConnection from CurrentPDU.CID).\n\
    \                  for (each command active on CleanupConnection) {\n        \
    \               Quiesce-And-Prepare-for-New-Allegiance(Session,\n            \
    \                               TCB);\n                       TCB.CurrentlyAllegiant\
    \ = FALSE;\n                  }\n                  Cleanup-Connection-State(CleanupConnection);\n\
    \                  if ((quiescing successful) and (cleanup successful)) {\n  \
    \                     Build-And-Send-Logout-Response(Connection,\n           \
    \                             CleanupConnection.CID, Success);\n             \
    \     } else {\n                       Build-And-Send-Logout-Response(Connection,\n\
    \                                        CleanupConnection.CID, Failure);\n  \
    \                }\n              }\n           } else if ((CurrentPDU.type ==\
    \ Login) and\n                              operational ErrorRecoveryLevel ==\
    \ 2) {\n                  Retrieve the CleanupConnection from CurrentPDU.CID).\n\
    \                  for (each command active on CleanupConnection) {\n        \
    \           Quiesce-And-Prepare-for-New-Allegiance(Session, TCB);\n          \
    \             TCB.CurrentlyAllegiant = FALSE;\n                  }\n         \
    \         Cleanup-Connection-State(CleanupConnection);\n                  if ((quiescing\
    \ successful) and (cleanup successful)) {\n                       Continue with\
    \ the rest of the Login processing;\n                  } else {\n            \
    \           Build-And-Send-Login-Response(Connection,\n                      \
    \            CleanupConnection.CID, Target Error);\n                  }\n    \
    \          }\n           } else if (CurrentPDU.type == TaskManagement) {\n   \
    \             if (CurrentPDU.function == \"TaskReassign\") {\n               \
    \       if (Session.ErrorRecoveryLevel < 2) {\n                         Build-And-Send-TaskMgmt-Response(Connection,\n\
    \                              CurrentPDU, \"Allegiance reassignment\n       \
    \                                              not supported\");\n           \
    \           } else if (task is not found) {\n                         Build-And-Send-TaskMgmt-Response(Connection,\n\
    \                              CurrentPDU, \"Task not in task set\");\n      \
    \                } else if (task is currently allegiant) {\n                 \
    \        Build-And-Send-TaskMgmt-Response(Connection,\n                      \
    \             CurrentPDU, \"Task still allegiant\");\n                      }\
    \ else {\n                         Establish-New-Allegiance(TCB, Connection);\n\
    \                         TCB.CurrentlyAllegiant = TRUE;\n                   \
    \      Schedule-Command-To-Continue(TCB);\n                      }\n         \
    \       }\n           } else { /* REST UNRELATED TO CONNECTION-RECOVERY,\n   \
    \                  * NOT SHOWN */\n           }\n         }\n         Transport_Exception_Handler(Connection)\n\
    \         {\n           Connection.PerformConnectionCleanup = TRUE;\n        \
    \   if (the event is an unexpected transport disconnect) {\n               Connection.State\
    \ = CLEANUP_WAIT;\n               Start-Timer(Connection-Resource-Timeout-Handler,\n\
    \               Connection,\n         (DefaultTime2Wait+DefaultTime2Retain));\n\
    \                 if (this Session has full-feature phase connections\n      \
    \                left)\n         {\n                   DifferentConnection =\n\
    \                      Pick-A-Logged-In-Connection(Session);\n               \
    \     Build-And-Send-Async(DifferentConnection,\n                          DroppedConnection,\
    \ DefaultTime2Wait,\n                            DefaultTime2Retain);\n      \
    \        }\n           } else {\n               Connection.State = FREE;\n   \
    \        }\n         }\n"
- title: Appendix F.  Clearing Effects of Various Events on Targets
  contents:
  - 'Appendix F.  Clearing Effects of Various Events on Targets

    '
- title: F.1.  Clearing Effects on iSCSI Objects
  contents:
  - "F.1.  Clearing Effects on iSCSI Objects\n   The following tables describe the\
    \ target behavior on receiving the\n   events specified in the rows of the table.\
    \  The second table is  an\n   extension of the first table and defines clearing\
    \ actions for more\n   objects on the same events.  The legend is:\n      Y =\
    \ Yes (cleared/discarded/reset on the event specified in the\n          row).\
    \  Unless otherwise noted, the clearing action is only\n          applicable for\
    \ the issuing initiator port.\n      N = No (not affected on the event specified\
    \ in the row, i.e.,\n          stays at previous value).\n      NA = Not Applicable\
    \ or Not Defined.\n                         +-----+-----+-----+-----+-----+\n\
    \                         |IT(1)|IC(2)|CT(5)|ST(6)|PP(7)|\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |connection failure(8)|Y    |Y    |N    |N    |Y    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |connection state     |NA   |NA   |Y    |N    |NA   |\n   |timeout (9)   \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |session timeout/     |Y    |Y    |Y    |Y    |Y(14)|\n   |closure/reinstatement|\
    \     |     |     |     |     |\n   |(10)                 |     |     |     |\
    \     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n   |session\
    \ continuation |NA   |NA   |N(11)|N    |NA   |\n   |(12)                 |   \
    \  |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |successful connection|Y    |Y    |Y    |N    |Y(13)|\n   |close logout  \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |session failure (18) |Y    |Y    |N    |N    |Y    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |successful recovery  |Y    |Y    |N    |N    |Y(13)|\n   |Logout        \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |failed Logout        |Y    |Y    |N    |N    |Y    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |connection Login     |NA   |NA   |NA   |Y(15)|NA   |\n   |(leading)     \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |connection Login     |NA   |NA   |N(11)|N    |Y    |\n   |(non-leading) \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |target cold reset(16)|Y    |Y    |Y    |Y    |Y    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |target warm reset(16)|Y    |Y    |Y    |Y    |Y    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |LU reset(19)         |Y    |Y    |Y    |Y    |Y    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |powercycle(16)       |Y    |Y    |Y    |Y    |Y    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   1.  Incomplete TTTs - Target Transfer Tags on which the target is\n   still\
    \  expecting PDUs to be received.  Examples include TTTs received\n   via R2T,\
    \ NOP-IN, etc.\n   2.  Immediate Commands - immediate commands, but waiting for\n\
    \   execution on a target.  For example, Abort Task Set.\n   5.  Connection Tasks\
    \ - tasks that are active on the iSCSI connection\n   in question.\n   6.  Session\
    \ Tasks - tasks that are active on the entire iSCSI\n   session.  A union of \"\
    connection tasks\" on all participating\n   connections.\n   7.  Partial PDUs\
    \ (if any) - PDUs that are partially sent and waiting\n   for transport window\
    \ credit to complete the transmission.\n   8.  Connection failure is a connection\
    \ exception condition - one of\n   the transport connections shutdown, transport\
    \ connections reset, or\n   transport connections timed out, which abruptly terminated\
    \ the iSCSI\n   full-feature phase connection.  A connection failure always takes\
    \ the\n   connection state machine to the CLEANUP_WAIT state.\n   9.  Connection\
    \ state timeout happens if a connection spends more time\n   that agreed upon\
    \ during Login negotiation in the CLEANUP_WAIT state,\n   and this takes the connection\
    \ to the FREE state (M1 transition in\n   connection cleanup state diagram).\n\
    \   10.  These are defined in Section 5.3.5 Session Reinstatement,\n   Closure,\
    \ and Timeout.\n   11.  This clearing effect is \"Y\" only if it is a connection\n\
    \   reinstatement and the operational ErrorRecoveryLevel is less than 2.\n   12.\
    \  Session continuation is defined in Section 5.3.6 Session\n   Continuation and\
    \ Failure.\n   13.  This clearing effect is only valid if the connection is being\n\
    \   logged out on a different connection and when the connection being\n   logged\
    \ out on the target may have some partial PDUs pending to be\n   sent.  In all\
    \ other cases, the effect is \"NA\".\n   14.  This clearing effect is only valid\
    \ for a \"close the session\"\n   logout in a multi-connection session.  In all\
    \ other cases, the effect\n   is \"NA\".\n   15.  Only applicable if this leading\
    \ connection login is a session\n   reinstatement.  If this is not the case, it\
    \ is \"NA\".\n   16.  This operation affects all logged-in initiators.\n   18.\
    \  Session failure is defined in Section 5.3.6 Session Continuation\n   and Failure.\n\
    \   19.  This operation affects all logged-in initiators and the clearing\n  \
    \ effects are only applicable to the LU being reset.\n                       \
    \  +-----+-----+-----+-----+-----+\n                         |DC(1)|DD(2)|SS(3)|CS(4)|DS(5)|\n\
    \   +---------------------+-----+-----+-----+-----+-----+\n   |connection failure\
    \   |N    |Y    |N    |N    |N    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |connection state     |Y    |NA   |Y    |N    |NA   |\n   |timeout       \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |session timeout/     |Y    |Y    |Y(7) |Y    |NA   |\n   |closure/reinstatement|\
    \     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |session continuation |N(11)|NA*12|NA   |N    |NA*13|\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |successful connection|Y    |Y    |Y    |N    |NA   |\n   |close Logout  \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |session failure      |N    |Y    |N    |N    |N    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |successful recovery  |Y    |Y    |Y    |N    |N    |\n   |Logout        \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |failed Logout        |N    |Y(9) |N    |N    |N    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |connection Login     |NA   |NA   |N(8) |N(8) |NA   |\n   |(leading      \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |connection Login     |N(11)|NA*12|N(8) |N    |NA*13|\n   |(non-leading) \
    \       |     |     |     |     |     |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |target cold reset    |Y    |Y    |Y    |Y(10)|NA   |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |target warm reset    |Y    |Y    |N    |N    |NA   |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |LU reset             |N    |Y    |N    |N    |N    |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   |powercycle           |Y    |Y    |Y    |Y(10)|NA   |\n   +---------------------+-----+-----+-----+-----+-----+\n\
    \   1.  Discontiguous Commands - commands allegiant to the connection in\n   question\
    \ and waiting to be reordered in the iSCSI layer.  All \"Y\"s in\n   this column\
    \ assume that the task causing the event (if indeed the\n   event is the result\
    \ of a task) is issued as an immediate command,\n   because the discontiguities\
    \ can be ahead of the task.\n   2.  Discontiguous Data - data PDUs received for\
    \ the task in question\n   and waiting to be reordered due to prior discontiguities\
    \ in DataSN.\n   3.  StatSN\n   4.  CmdSN\n   5.  DataSN\n   7.  It clears the\
    \ StatSN on all the connections.\n   8.  This sequence number is instantiated\
    \ on this event.\n   9.  A logout failure drives the connection state machine\
    \ to the\n   CLEANUP_WAIT state, similar to the connection failure event.  Hence,\n\
    \   it has a similar effect on this and several other protocol aspects.\n   10.\
    \  This is cleared by virtue of the fact that all sessions with all\n   initiators\
    \ are terminated.\n   11.  This clearing effect is \"Y\" if it is a connection\
    \ reinstatement.\n   12.  This clearing effect is \"Y\" only if it is a connection\n\
    \   reinstatement and the operational ErrorRecoveryLevel is 2.\n   13.  This clearing\
    \ effect is \"N\" only if it is a connection\n   reinstatement and the operational\
    \ ErrorRecoveryLevel is 2.\n"
- title: F.2.  Clearing Effects on SCSI Objects
  contents:
  - "F.2.  Clearing Effects on SCSI Objects\n   The only iSCSI protocol action that\
    \ can effect clearing actions on\n   SCSI objects is the \"I_T nexus loss\" notification\
    \ (Section 4.3.5.1\n   Loss of Nexus notification).  [SPC3] describes the clearing\
    \ effects\n   of this notification on a variety of SCSI attributes.  In addition,\n\
    \   SCSI standards documents (such as [SAM2] and [SBC]) define additional\n  \
    \ clearing actions that may take place for several SCSI objects on SCSI\n   events\
    \ such as LU resets and power-on resets.\n   Since iSCSI defines a target cold\
    \ reset as a protocol-equivalent to a\n   target power-cycle, the iSCSI target\
    \ cold reset must also be\n   considered as the power-on reset event in interpreting\
    \ the actions\n   defined in the SCSI standards.\n   When the iSCSI session is\
    \ reconstructed (between the same SCSI ports\n   with the same nexus identifier)\
    \ reestablishing the same I_T nexus,\n   all SCSI objects that are defined to\
    \ not clear on the \"I_T nexus\n   loss\" notification event, such as persistent\
    \ reservations, are\n   automatically associated to this new session.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This protocol was developed by a design team that, in addition\
    \ to the\n   authors, included Daniel Smith, Ofer Biran, Jim Hafner and John\n\
    \   Hufferd (IBM), Mark Bakke (Cisco), Randy Haagens (HP), Matt Wakeley\n   (Agilent,\
    \ now Sierra Logic), Luciano Dalle Ore (Quantum), and Paul\n   Von Stamwitz (Adaptec,\
    \ now TrueSAN Networks).\n   Furthermore, a large group of people contributed\
    \ to this work through\n   their review, comments, and valuable insights.  We\
    \ are grateful to\n   all of them.  We especially thank those people who found\
    \ the time and\n   patience to take part in our weekly phone conferences and\n\
    \   intermediate meetings in Almaden and Haifa, which helped shape this\n   document:\
    \ Prasenjit Sarkar, Meir Toledano, John Dowdy, Steve Legg,\n   Alain Azagury (IBM),\
    \ Dave Nagle (CMU), David Black (EMC), John Matze\n   (Veritas - now Okapi Software),\
    \ Steve DeGroote, Mark Schrandt\n   (Cisco), Gabi Hecht (Gadzoox), Robert Snively\
    \ and Brian Forbes\n   (Brocade), Nelson Nachum (StorAge), and Uri Elzur (Broadcom).\
    \  Many\n   others helped edit and improve this document within the IPS working\n\
    \   group.  We are especially grateful to David Robinson and Raghavendra\n   Rao\
    \ (Sun), Charles Monia, Joshua Tseng (Nishan), Somesh Gupta\n   (Silverback),\
    \ Michael Krause, Pierre Labat, Santosh Rao, Matthew\n   Burbridge, Bob Barry,\
    \ Robert Elliott, Nick Martin (HP), Stephen\n   Bailey (Sandburst), Steve Senum,\
    \ Ayman Ghanem, Dave Peterson (Cisco),\n   Barry Reinhold (Trebia Networks), Bob\
    \ Russell (UNH), Eddy Quicksall\n   (iVivity, Inc.), Bill Lynn and Michael Fischer\
    \ (Adaptec), Vince\n   Cavanna, Pat Thaler (Agilent), Jonathan Stone (Stanford),\
    \ Luben\n   Tuikov (Splentec), Paul Koning (EqualLogic), Michael Krueger\n   (Windriver),\
    \ Martins Krikis (Intel), Doug Otis (Sanlight), John\n   Marberg (IBM), Robert\
    \ Griswold and Bill Moody (Crossroads), Bill\n   Studenmund (Wasabi Systems),\
    \ Elizabeth Rodriguez (Brocade) and Yaron\n   Klein (Sanrad).  The recovery chapter\
    \ was enhanced with the help of\n   Stephen Bailey (Sandburst), Somesh Gupta (Silverback),\
    \ and Venkat\n   Rangan (Rhapsody Networks).  Eddy Quicksall contributed some\
    \ examples\n   and began the Definitions section.  Michael Fischer and Bob Barry\n\
    \   started the Acronyms section.  Last, but not least, we thank Ralph\n   Weber\
    \ for keeping us in line with T10 (SCSI) standardization.\n   We would like to\
    \ thank Steve Hetzler for his unwavering support and\n   for coming up with such\
    \ a good name for the protocol, and Micky\n   Rodeh, Jai Menon, Clod Barrera,\
    \ and Andy Bechtolsheim for helping\n   make this work happen.\n   In addition\
    \ to this document, we recommend you acquaint yourself with\n   the following\
    \ in order to get a full understanding of the iSCSI\n   specification: \"iSCSI\
    \ Naming & Discovery\"[RFC3721], \"Bootstrapping\n   Clients using the iSCSI Protocol\"\
    \ [BOOT], \"Securing Block Storage\n   Protocols over IP\" [RFC3723] documents,\
    \ \"iSCSI Requirements and\n   Design Considerations\" [RFC3347] and \"SCSI Command\
    \ Ordering\n   Considerations with iSCSI\" [CORD].\n   The \"iSCSI Naming & Discovery\"\
    \ document is authored by:\n      Mark Bakke (Cisco), Jim Hafner, John Hufferd,\
    \ Kaladhar Voruganti\n         (IBM), and Marjorie Krueger (HP).\n   The \"Bootstrapping\
    \ Clients using the iSCSI Protocol\" document is\n   authored by:\n      Prasenjit\
    \ Sarkar (IBM), Duncan Missimer (HP), and Costa\n         Sapuntzakis (Cisco).\n\
    \   The \"Securing Block Storage Protocols over IP\" document is authored\n  \
    \ by:\n      Bernard Aboba (Microsoft), Joshua Tseng (Nishan), Jesse Walker\n\
    \         (Intel), Venkat Rangan (Rhapsody Networks), and Franco\n         Travostino\
    \ (Nortel Networks).\n   The \"iSCSI Requirements and Design Considerations\"\
    \ document is\n   authored by:\n      Marjorie Krueger, Randy Haagens (HP), Costa\
    \ Sapuntzakis, and Mark\n      Bakke (Cisco).\n   The \"SCSI Command Ordering\
    \ Considerations with iSCSI\" document is\n   authored by:\n      Mallikarjun\
    \ Chadalapaka, Rob Elliot (HP)\n   We are grateful to all of them for their good\
    \ work and for helping us\n   correlate this document with the ones they produced.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Julian Satran\n   IBM Research Laboratory in Haifa\n \
    \  Haifa University Campus - Mount Carmel\n   Haifa 31905, Israel\n   Phone +972.4.829.6264\n\
    \   EMail: Julian_Satran@il.ibm.com\n   Kalman Meth\n   IBM Research Laboratory\
    \ in Haifa\n   Haifa University Campus - Mount Carmel\n   Haifa 31905, Israel\n\
    \   Phone +972.4.829.6341\n   EMail: meth@il.ibm.com\n   Costa Sapuntzakis\n \
    \  Stanford University\n   353 Serra Mall Dr #407\n   Stanford, CA 94305\n   Phone:\
    \ +1.650.723.2458\n   EMail: csapuntz@alum.mit.edu\n   Efri Zeidner\n   XIV Ltd.\n\
    \   1 Azrieli Center,\n   Tel-Aviv 67021, Israel\n   Phone: +972.3.607.4722\n\
    \   EMail: efri@xiv.co.il\n   Mallikarjun Chadalapaka\n   Hewlett-Packard Company\n\
    \   8000 Foothills Blvd.\n   Roseville, CA 95747-5668, USA\n   Phone: +1.916.785.5621\n\
    \   EMail: cbm@rose.hp.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This\
    \ document is subject\n   to the rights, licenses and restrictions contained in\
    \ BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
