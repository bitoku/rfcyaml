ABSTRACT The IDUP GSS API extends the GSS API [RFC 2078] for applications requiring protection of a generic data unit (such as a file or message) in a way which is independent of the protection of any other data unit and independent of any concurrent contact with designated "receivers" of the data unit.
Thus, it is suitable for applications such as secure electronic mail where data needs to be protected without any on line connection with the intended recipient(s) of that data.
The protection offered by IDUP includes services such as data origin authentication with data integrity, data confidentiality with data integrity, and support for non repudiation services.
Subsequent to being protected, the data unit can be transferred to the recipient(s) or to an archive perhaps to be processed ("unprotected") only days or years later.
Throughout the remainder of this document, the "unit" of data described in the above paragraph will be referred to as an IDU (Independent Data Unit).
The IDU can be of any size (the application may, if it wishes, split the IDU into pieces and have the protection computed a piece at a time, but the resulting protection token applies to the entire IDU).
However, the primary characteristic of an IDU is that it represents a stand alone unit of data whose protection is entirely independent of any other unit of data.
If an application protects several IDUs and sends them all to a single receiver, the IDUs may be unprotected by that receiver in any order over any time span; no logical connection of any kind is implied by the protection process itself.
As with RFC 2078, this IDUP GSS API definition provides security services to callers in a generic fashion, supportable with a range of underlying mechanisms and technologies and hence allowing source  level portability of applications to different environments.
This specification defines IDUP GSS API services and primitives at a level independent of underlying mechanism and programming language environment, and is to be complemented by other, related specifications:
documents defining specific parameter bindings for particular language environments; documents defining token formats, protocols, and procedures to be implemented in order to realize IDUP GSS API services atop particular security mechanisms.
IDUP Acquire Cred With Auth
IDUP GSS API Characteristics and Concepts
The paradigm within which IDUP GSS API operates is as follows.
An IDUP GSS API caller is any application that works with IDUs, calling on IDUP GSS API in order to protect its IDUs with services such as data origin authentication with integrity (DOA), confidentiality with integrity (CONF), and/or support for non repudiation (e.g., evidence generation, where "evidence" is information that either by itself, or when used in conjunction with other information, is used to establish proof about an event or action
(note:  the evidence itself does not necessarily prove truth or existence of something, but contributes to establish proof)
see [ISO/IEC] for fuller discussion regarding evidence and its role in various types of non repudiation).
An IDUP GSS API caller passes an IDU to, and accepts a token from, its local IDUP GSS API implementation, transferring the resulting protected IDU (P IDU) to a peer or to any storage medium.
When a P  IDU is to be "unprotected", it is passed to an IDUP GSS API implementation for processing.
The security services available through IDUP GSS API in this fashion are implementable over a range of underlying mechanisms based on secret key and/or public key cryptographic technologies.
During the protection operation, the input IDU buffers may be modified (for example, the data may be encrypted or encoded in some way) or may remain unchanged.
In any case, the result is termed a "M IDU" (Modified IDU) in order to distinguish it from the original IDU.
Depending on the desire of the calling application and the capabilities of the underlying IDUP mechanism, the output produced by the protection processing may or may not encapsulate the M IDU.
Thus, the P IDU may be the contents of a single output parameter (if encapsulation is done) or may be the logical concatenation of an unencapsulated token parameter and a M IDU parameter (if encapsulation is not done).
In the latter case, the protecting application may choose whatever method it wishes to concatenate or combine the unencapsulated token and the M IDU into a P IDU, provided the unprotecting application knows how to de couple the P IDU back into its component parts prior to calling the IDUP unprotection set of functions.
It is expected that any output buffer returned by IDUP (i.e., P IDU or portion thereof) is ready for immediate transmission to the intended receiver(s) by the calling application, if this is desired.
In other words, an application wishing to transmit data buffers as they appear from IDUP should not be unduly restricted from doing so by the underlying mechanism.
The IDUP GSS API separates the operation of initializing a security environment (the IDUP Establish Env() call) from the operations of providing per IDU protection, for IDUs subsequently protected in conjunction with that environment.
Per IDU protection and unprotection calls provide DOA, CONF, evidence, and other services, as requested by the calling application and as supported by the underlying mechanism.
The following paragraphs provide an example illustrating the dataflows involved in the use of the IDUP GSS API by the sender and receiver of a P IDU in a mechanism independent fashion.
The example assumes that credential acquisition has already been completed by both sides.
Furthermore, the example does not cover all possible options available in the protection/unprotection calls.
The sender first calls IDUP Establish Env() to establish a security environment.
Then, for the IDU to be protected the sender calls the appropriate protection calls (SE, EV, or GP) to perform the IDU protection.
The resulting P IDU, which may (depending on whether or not encapsulation was chosen/available) be either the token itself or the logical concatenation of the token and the M IDU, is now ready to be sent to the target.
The sender then calls IDUP Abolish Env() to flush all environment  specific information.
The receiver first calls IDUP Establish Env() to establish a security environment in order to unprotect the P IDU.
Then, for the received P IDU the receiver calls the appropriate unprotection calls (SE, EV, or GP (known a priori, or possibly determined through the use of the IDUP Get token details call)) to perform the P IDU unprotection.
The receiver then calls IDUP Abolish Env() to flush all environment specific information.
It is important to note that absolutely no synchronization is implied or expected between the data buffer size used by the sender as input to the protection calls, the data buffer size used by the receiver as input to the unprotection calls, and the block sizes required by the underlying protection algorithms (integrity and confidentiality).
All these sizes are meant to be independent; furthermore, the data buffer sizes used for the protection and unprotection calls are purely a function of the local environment where the calls are made.
The IDUP GSS API design assumes and addresses several basic goals, including the following.
The IDUP GSS API defines an interface to cryptographically implemented security services at a generic level which is independent of particular underlying mechanisms.
For example, IDUP GSS API provided services can be implemented by secret key technologies or public key approaches.
The IDUP GSS API is independent of the communications protocol suites which may be used to transfer P IDUs, permitting use in a broad range of protocol environments.
Protocol association independence: The IDUP GSS API's security environment construct has nothing whatever to do with communications protocol association constructs, so that IDUP GSS  API services can be invoked by applications, wholly independent of protocol associations.
Suitability for a range of implementation placements: IDUP GSS API clients are not constrained to reside within any Trusted Computing Base (TCB) perimeter defined on a system where the IDUP GSS API is implemented; security services are specified in a manner suitable for both intra TCB and extra TCB callers.
This section describes the basic elements comprising the IDUP GSS  API.
Credentials Credentials in IDUP GSS API are to be understood and used as described in GSS API [RFC 2078].
Tokens Tokens in IDUP GSS API are to be understood and used as described in GSS API [RFC 2078] with the exception that there are no context level tokens generated by IDUP GSS API.
The IDUP GSS API token may (depending on the underlying mechanism) encapsulate the M IDU or may be logically concatenated with the M IDU prior to transfer to a target; furthermore, for some evidence services the token may be sent independently of any other data transfer.
The "security environment" in IDUP GSS API is entirely different from the concept of security contexts used in GSS API [RFC 2078].
Here, a security environment exists within a calling application (that is, it is purely local to the caller) for the purpose of protecting or unprotecting one or more IDUs using a particular caller credential or set of credentials.
In GSS API, on the other hand, a security context exists between peers (the initiator and the target) for the purpose of protecting, in real time, the data that is exchanged between them.
Although they are different concepts, the env handle in IDUP GSS API is similar to the context handle in GSS API in that it is a convenient way of tying together the entire process of protecting or unprotecting one or more IDUs using a particular underlying mechanism.
As with the GSS API security contexts, a caller can initiate and maintain multiple environments using the same or different credentials.
Mechanism Types Mechanism types in IDUP GSS API are to be understood and used as described in GSS API [RFC 2078].
Naming Naming in IDUP GSS API is to be understood and used as described in GSS API [RFC 2078].
The concept of channel bindings discussed in GSS API [RFC 2078] is not relevant to the IDUP GSS API.
IDUP GSS API Features and Issues
This section describes aspects of IDUP GSS API operations and of the security services which the IDUP GSS API provides.
It also provides commentary on design issues.
Status Reporting Status reporting in IDUP GSS API is to be understood and used as described in GSS API [RFC 2078], with the addition of a number of IDUP specific status codes.
Descriptions of the major status codes used in IDUP are provided in Table 1.
(i.e., that do not cause the requested operation to fail) are indicated with the symbol "(I)".
As with GSS API, minor status codes, which provide more detailed status information than major status codes, and which may include status codes specific to the underlying security mechanism, are not specified in this document.
Major Status Codes GSS S BAD MECH indicates that a mech type unsupported by the IDUP GSS API implementation was requested, causing the environment establishment operation to fail.
GSS S BAD QOP indicates that the provided qop alg value is not recognized or supported for the environment.
GSS S BAD MIC indicates that the received P IDU contains an incorrect integrity field (e.g., signature or MAC) for the data.
GSS S COMPLETE indicates that the requested operation was successful.
GSS S CREDENTIALS EXPIRED indicates that the credentials associated with this operation have expired, so that the requested operation cannot be performed.
GSS S DEFECTIVE CREDENTIAL indicates that consistency checks performed on the credential structure referenced by claimant cred handle failed, preventing further processing from being performed using that credential structure.
GSS S DEFECTIVE TOKEN indicates that consistency checks performed on the received P IDU failed, preventing further processing from being performed.
GSS S FAILURE indicates that the requested operation could not be accomplished for reasons unspecified at the IDUP GSS API level, and that no interface defined recovery action is available.
NO CRED indicates that no environment was established, either because the input cred handle was invalid or because the caller lacks authorization to access the referenced credentials.
IDUP S BAD DOA KEY indicates that the key used to provide IDU data origin auth.
has either expired or been revoked.
IDUP S BAD ENC IDU indicates that decryption of the received IDU cannot be completed because the encrypted IDU was invalid/defective (e.g., the final block was short or had incorrect padding).
S BAD KE KEY indicates that the key used to establish a key for confidentiality purposes between originator and target
has either expired or been revoked.
IDUP S BAD TARG INFO indicates that the full set of supplied information regarding the target(s) is invalid or is insufficient for the protection of an IDU, so P IDU cannot be created.
IDUP S DEFECTIVE VERIF indicates that consistency checks performed on Service Verification Info failed, preventing further processing from being performed with that parameter.
UNAVAIL (I) indicates that the underlying mechanism does not support encapsulation of the M IDU into the token.
IDUP S INAPPROPRIATE CRED indicates that the credentials supplied do not contain the information necessary for P IDU unprotection.
IDUP S INCOMPLETE (I) indicates that the unprotection of the P IDU is not yet complete (i.e., a determination cannot yet be made on the validity of the P IDU).
The application should call IDUP Form Complete PIDU and then should call this function again with the complete P IDU.
IDUP S INCONSISTENT PARAMS indicates that the supplied parameters are inconsistent (e.g., only one or the other of two parameters may be supplied, but both have been input).
IDUP S MORE OUTBUFFER NEEDED (I) indicates that the output buffer supplied is too small to hold the generated data.
The application should continue calling this routine (until GSS S COMPLETE is returned) in order to get all remaining output data.
IDUP S MORE PIDU NEEDED (I) indicates that not enough of the P IDU has been input yet for the completion of StartUnprotect.
The application should call this routine again with another buffer of P IDU in partial(initial) pidu buffer.
NO ENV indicates that no valid environment was recognized for the env handle provided.
NO MATCH indicates that Service Verification Info (or evidence check) and the P IDU to be verified do not match.
IDUP S REQ TIME SERVICE UNAVAIL indicates that the time service requested (TTIME or UTIME) is not available in the environment.
IDUP S SERVICE UNAVAIL indicates that the underlying mechanism does not support the service requested.
IDUP S SERV VERIF INFO NEEDED (I) indicates that the Service Verification Info parameter bundle must be input in order for service verification to proceed.
The output parameter service verification info
id contains an identifier which may be used by the calling application to locate the necessary information.
IDUP S UNKNOWN OPER ID indicates that the input prot oper
d value is not recognized or supported in the underlying mechanism.
Per IDU Security Service Availability Per IDU security service availability in IDUP GSS API is to be understood and used as described in GSS API [RFC 2078], with the exception that combinations of services requested by the calling application and supported by the underlying mechanism may be applied simultaneously to any IDU (true for both the SE and the EV calls, but true in the fullest sense for the GP calls).
GSS API callers desiring per message security services should check the relevant service OBJECT IDs at environment establishment time to ensure that what is available in the established environment is suitable for their security needs.
Per IDU Replay Detection and Sequencing The concept of per IDU replay detection and sequencing discussed in GSS API [RFC 2078] is not relevant to the IDUP GSS API.
The concept of QOP control in IDUP GSS API is to be understood essentially as described in GSS API [RFC 2078].
However, the actual description and use of the QOP parameter is given as follows.
where U is a 19 bit Unspecified field (available for future use/expansion)   must be set to zero; TS is a 5 bit Type Specifier (a semantic qualifier whose value specifies the type of algorithm which may be used to protect the corresponding IDU
see below for details); IA is a 4 bit field enumerating Implementation specific Algorithms; and MA is a 4 bit field enumerating Mechanism defined Algorithms.
The interpretation of the qop algs parameter is as follows.
The MA field is examined first.
If it is non zero
then the algorithm used to protect the IDU
is the mechanism specified algorithm corresponding to that integer value.
If MA is zero then IA is examined.
If this field value is non zero
then the algorithm used to protect the IDU
specified algorithm corresponding to that integer value.
Note that use of this field may hinder portability since a particular value may specify one algorithm in one implementation of the mechanism and may not be supported or may specify a completely different algorithm in another implementation of the mechanism.
Finally, if both MA and IA are zero then TS is examined.
A value of zero for TS specifies the default algorithm for the established mechanism.
A non zero value for TS corresponds to a particular algorithm qualifier and selects any algorithm from the mechanism specification which satisfies that qualifier (which actual algorithm is selected is an implementation choice; the calling application need not be aware of the choice made).
The following TS values (i.e., algorithm qualifiers) are specified; other values may be added in the future.
When qop algs is used to select a confidentiality algorithm:
(0)   default confidentiality algorithm 00001
(1)   IDUP SYM ALG STRENGTH
(2)   IDUP SYM ALG STRENGTH MEDIUM 00011
(3)   IDUP SYM ALG STRENGTH WEAK 11111 (31)
When qop algs is used to select a DOA/integrity algorithm:
(0)   default integrity algorithm 00001
(1)   IDUP INT ALG DIG SIGNATURE (integrity provided through a digital signature)
INT ALG NON DIG SIGNATURE (integrity without a dig.
(e.g., with a MAC)) 11111
Clearly, qualifiers such as strong, medium, and weak are debatable and likely to change with time, but for the purposes of this version of the specification we define these terms as follows.
A confidentiality algorithm is "weak" if the effective key length of the cipher is 40 bits or less; it is "medium strength" if the effective key length is strictly between 40 and 80 bits; and it is "strong" if the effective key length is 80 bits or greater.
("Effective key length" describes the computational effort required to break a cipher using the best known cryptanalytic attack against that cipher.)
A five bit TS field allows up to 30 qualifiers for each of confidentiality and integrity (since "0" is reserved for "default" and "31" is reserved for "none", as shown above).
This document specifies three for confidentiality and two for integrity, leaving a lot of room for future specification.
Suggestions of qualifiers such as "fast", "medium speed", and "slow" have been made, but such terms are difficult to quantify (and in any case are platform  and processor dependent), and so have been left out of this initial specification.
The intention is that the TS terms be quantitative, environment independent qualifiers of algorithms, as much as this is possible.
Use of the qop algs parameter as defined above is ultimately meant to be as follows.
TS values are specified at the IDUP GSS API level and are therefore portable across mechanisms.
Applications which know nothing about algorithms are still able to choose "quality" of protection for their message tokens.
MA values are specified at the mechanism level and are therefore portable across implementations of a mechanism.
IA values are specified at the implementation level (in user documentation, for example) and are therefore typically non  portable.
An application which is aware of its own mechanism implementation and the mechanism implementation of its intended P IDU recipient, however, is free to use these values since they will be perfectly valid and meaningful for protecting IDUs between those entities.
The receiver of a P IDU must pass back to its calling application (in IDUP Start Unprotect())
a qop algs parameter with all relevant fields set.
For example, if triple DES has been specified by a mechanism as algorithm 8, then a receiver of a triple DES protected P IDU must pass to its application (TS 1, IA 0, MA 8).
In this way, the application is free to read whatever part of the qop algs parameter it understands (TS or IA/MA).
The Provision of Time IDUP mechanisms should make provision in their protocols for the carrying of time information from originator to target(s).
That is, a target (a legitimate recipient) should get some indication during unprotection regarding the time at which the protection operation took place.
This is particularly important if the mechanism offers non repudiation services because in some cases evidence verification may only be achievable if the time at which the evidence was generated is known.
Depending upon the platform and resources available to the implementation, an IDUP environment may have access to a source of trusted (secure) time, untrusted (local) time, both kinds of time, or no time.
OBJECT IDs indicating such availability are returned by the IDUP Establish Env() call.
When starting a protection operation, an application may specify which time services it wishes to have applied to the IDU.
Similarly, for unprotection, an application may specify which kind of time (if any) to consult when the validity of the P IDU is to be established.
Specifying both kinds of time is interpreted to mean that the calling application does not care which kind of time is used.
The IDUP calls which use a time parameter specify the type of that parameter to be INTEGER.
This INTEGER is defined in all cases to be the number of seconds which have elapsed since midnight, January 1, 1970, coordinated universal time.
This section describes the IDUP GSS API's operational interface, dividing the set of calls offered into five groups.
Credential management calls are related to the acquisition and release of credentials by API callers.
Environment level calls are related to the management of the security environment by an API caller.
Per IDU calls are related to the protection or unprotection of individual IDUs in established security environments.
Special purpose calls deal with unusual or auxiliary evidence generation/verification requirements.
Support calls provide extra functions useful to IDUP  GSS API callers.
Table 2 groups and summarizes the calls in tabular fashion.
Table 2:  IDUP GSS API Calls CREDENTIAL MANAGEMENT (see the calls given in Section 2.1 of GSS API [RFC 2078])
ENVIRONMENT LEVEL CALLS IDUP Establish Env IDUP Abolish Env IDUP Inquire Env PER IDU CALLS SE (SIGN,ENCRYPT)
CALLS IDUP SE SingleBuffer Protect IDUP SE SingleBuffer Unprotect IDUP SE
MultiBuffer StartProtect IDUP SE MultiBuffer EndProtect IDUP SE MultiBuffer StartUnprotect IDUP SE MultiBuffer EndUnprotect IDUP SE Process Buffer EV (EVIDENCE)
EV MultiBuffer StartVerify IDUP EV MultiBuffer EndVerify IDUP EV Process Buffer GP (GENERAL PROTECTION)
Protect IDUP Protect IDUP End Protect IDUP Start Unprotect IDUP Unprotect IDUP End Unprotect SPECIAL PURPOSE
CALLS  (might not be supported by all mechanisms)
IDUP Form Complete PIDU SUPPORT CALLS IDUP Acquire cred with auth IDUP
Token Details IDUP Get Policy Info IDUP
Cancel Multibuffer Op (see also the calls given in Section 2.4 of GSS API [RFC 2078])
In terms of conformance to this specification, IDUP GSS API implementations must support the credential management calls, the environment level calls, some subset of the per IDU calls, and the support calls (except where explicitly stated otherwise in Section 2.5).
The subset of per IDU calls supported will depend upon the underlying mechanisms supported and will typically be the SE calls, or the EV calls, or both.
As stated in Section 2.3.2.1, implementations are encouraged to support the more powerful GP calls to anticipate the future needs of applications developers, but this is not required for conformance.
Relationship to GSS API Credential management in IDUP GSS API is to be understood and used as described in GSS API [RFC 2078].
The calls given in Section 2.1 of GSS API (including all associated parameters) are unchanged, although the interpretation of the cred usage parameter in the GSS API calls for IDUP purposes is as follows.
The values above may be logically OR'ed together in any desired combination to restrict credential usage (where OR'ing all values results in NO RESTRICTION).
Future possible values for this parameter are for further study.
The call IDUP Acquire cred with auth has been added as a support call in this specification to permit authenticated credential acquirement; see Section 2.5.2 for details.
Environment level calls This group of calls is devoted to the establishment and management of an environment for the purpose of IDU protection and unprotection.
Before protecting or unprotecting any IDU, an application must call IDUP Establish Env() to initialize environment information and select the underlying IDUP GSS mechanism to be used.
A series of protection or unprotection calls is made to process each IDU, the protection calls resulting in a P IDU for each.
Finally, IDUP Abolish Env() is called to flush all environment information.
Semantically, acquiring credentials and establishing an environment is (in many cases) analogous to logging in to a system
it authenticates a local user to the system and gives that user access to a set of operations which can be performed.
The set of calls described in this section is used in place of the calls described in Section 2.2 of GSS API [RFC 2078], since those calls are specific to a session oriented environment.
IDUP Establish Env call Inputs:  claimant cred handle CREDENTIAL HANDLE,
NULL parameter specifies "use default"  req mech type OBJECT IDENTIFIER,
NULL parameter specifies "use default"
req environmentPolicies EnvironmentPolicies,   NULL parameter specifies "use default"  req services SET OF OBJECT IDENTIFIER,   GSS C
SET requests full set of services available   for req mech type Outputs:  major status INTEGER,  minor status INTEGER,
env handle ENVIRONMENT HANDLE,  actual mech type OBJECT IDENTIFIER,   actual mechanism always indicated, never NULL
actual environmentPolicies EnvironmentPolicies,   actual values always indicated, never NULL  ret services
IDENTIFIER, Return major status codes:  GSS S COMPLETE
environment level information was successfully initialized,   and IDU / P IDU processing can begin.
GSS S DEFECTIVE CREDENTIAL  GSS S NO CRED
the credentials provided through claimant cred handle are   no longer valid, so environment cannot be established.
The following structures are defined to facilitate environment policy input and output:
Using information in the credentials structure referenced by claimant cred handle, IDUP Establish Env() initializes the data structures required to protect or unprotect IDUs.
The claimant cred handle, if non NULL, must correspond to a valid credentials structure.
This routine returns an env handle for all future references to this environment; when protection, unprotection, or IDUP Abolish Env() calls are made, this handle value will be used as the input env handle argument.
It is the caller's responsibility to establish a communications path to the intended recipients of the P IDU, and to transmit the P IDU to those recipients over that path.
This may occur subsequent to the IDUP Abolish Env() call.
The req services parameter may be used by the calling application to request that data origin authentication with integrity, confidentiality with integrity, evidence generation, and/or evidence verification services be available in the established environment.
Requests can also be made for "trusted" or "untrusted" time services.
Requesting evidence generation or verification indicates that the calling application may wish to generate or verify evidence information for non repudiation purposes (note:  an IDU protector may request that a flag be inserted into a P IDU asking a recipient to provide an evidence of the type "non repudiation of delivery"; however, the IDUP GSS API cannot by itself guarantee that the evidence will be sent because there is no way to force a target to send an evidence token back to the IDU protector).
Not all features will be available in all underlying mech types; the returned value of ret services indicates, as a function of mech type processing capabilities and the initiator provided input OBJECT IDs, the set of features which will be available in the environment.
The value of this parameter is undefined unless the routine's major status indicates COMPLETE.
Failure to provide the precise set of services desired by the caller does not cause environment establishment to fail; it is the caller's choice to abolish the environment if the service set provided is unsuitable for the caller's use.
The returned mech type value indicates the specific mechanism employed in the environment and will never indicate the value for "default".
The following OBJECT IDs are defined for protection and unprotection services (the OBJECT ID iso.org.dod.internet.security.services, 1.3.6.1.5.7, has been assigned by IANA, and some of the security services under that node are assigned as shown below).
It is recognized that this list may grow over time.
(may be used only when PER DOA is requested simultaneously)
perform data origin authentication with data integrity PER DOA
non repudiable "proof of origin"
non repudiable "proof of delivery
(may be used only when REC DOA is received simultaneously)
verify DOA with DI over ciphertext (rather than plaintext)
(may be used only when PER CONF is received simultaneously)
receive / verify "proof of origin
The PER CONF return value (in the ret services paramater) indicates whether the environment supports confidentiality services, and so informs the caller whether or not a request for encryption can be honored.
In similar fashion, the PER DOA return value indicates whether DOA services are available in the established environment, and the PER POO and PER POD return values indicate whether evidence generation services are available.
The TTIME and UTIME values indicate whether trusted time and untrusted time are available for protection / unprotection services.
Note that, unlike a GSS "context", an IDUP environment does not have an explicit lifetime associated with it.
Instead, it relies on the lifetime of the calling entity's credential (set by the caller in the GSS Acquire cred() call).
When the credential expires (or is explicitly deleted in any other way), no new operations are allowed in the IDUP environment (although operations which have begun, such as the Protection set of calls, can be taken to completion).
IDUP Abolish Env call Input:
HANDLE Outputs:  major status INTEGER,  minor status INTEGER,
the relevant environment specific information was flushed.
This call is made to flush environment specific information.
(Once an environment is established, cached credential and environment related info.
is expected to be retained until an IDUP Abolish Env() call is made or until the cred.
Attempts to perform IDU processing on a deleted environment will result in error returns.
IDUP Inquire Env call Input:
Outputs:  major status INTEGER,  minor status INTEGER,  mech type OBJECT IDENTIFIER,   the mechanism supporting this environment
environmentPolicies EnvironmentPolicies,   the environment policies in effect  ret services
IDENTIFIER, Return major status codes:
GSS S COMPLETE   referenced environment is valid and mech type and other return
values describe the characteristics of the environment.
NO ENV  GSS S FAILURE
This routine provides environment related information to the caller.
Per IDU calls This group of calls is used to perform IDU protection and unprotection processing on an established IDUP environment.
Some of these calls may block pending network interactions (depending on the underlying mechanism in use).
These calls may be invoked by an IDU's protector or by the P IDU's recipient.
Members of this group form pairs; the output from the protection types of calls is typically meant to be input to the unprotection types of calls.
The per IDU calls can support caller requested data origin authentication with data integrity, confidentiality with data integrity, evidence, and evidence requested from target services.
The protection operations output a token which encapsulates all the information required to unprotect the IDU.
The token is passed to the target (possibly separate from the M IDU) and is processed by the unprotection calls at that system.
Unprotection performs decipherment, DOA verification, evidence verification, or notification of evidence requested, as required.
Each of the two main operations (protection and unprotection) may be separated into three parts:  "Start Operation"; "Operation" (which may be called once for each buffer of input data); and "End Operation".
This separation is available for the case where the IDU or P IDU is to be processed one buffer at a time. "
Start Operation" allows the caller to specify or retrieve the appropriate "Quality" used during the processing.
"Operation" is concerned with the processing itself, receiving a buffer of input data and potentially returning a buffer of output data.
End Operation" performs any required clean up and creates the appropriate token or states whether the input token was verified.
If the IDU or P IDU is wholly contained in a single buffer, the three part protection/unprotection processing need not be done.
Instead, protection or unprotection can be accomplished using only a single call, simplifying application code.
The set of calls described in this section is used in place of the calls GSS GetMIC(), GSS VerifyMIC, GSS Wrap(), and GSS Unwrap() which are specified in [RFC 2078], since those calls are specific to a session oriented environment.
The "SE" group of calls provides a very simple, high level interface to underlying IDUP mechanisms when application developers need access only to signature and encryption protection/unprotection services.
It includes both the single buffer and multiple buffer IDU cases and can be used for signing only, encrypting only, signing and encrypting (in either order, and with or without visibility of the resulting signature), and "clear signing" (where the data is not modified in any way and the signature itself is returned as a separate item).
[Note that encapsulation occurs in all cases except for clear signing, so that these calls provide functionality similar to the GSS Wrap call.]
Note that the term "signing" is used in its most generic sense, not necessarily implying the use of public key techniques.
This concept has also been called "sealing" in other contexts (e.g., in other standardization efforts).
The SE calls may be viewed by mechanism implementors as an "API" to the more powerful GP calls defined later and so may be implemented as simple mapping functions to those calls (when those optional calls are supported).
Application callers, on the other hand, may find that the SE calls are all they currently need for many environments.
At some time in the future when they have need of non repudiation or "directed receipts" types of services, they may consider using the EV calls (or the GP calls   when these are supported   if complex and sophisticated combinations of services are required).
To assist in this migration path, mechanism implementors are encouraged to support the full set of IDUP calls (i.e., the SE, EV, and GP calls) even though some calling applications will only use the SE calls in the short term.
The concept of "parameter bundles" is used in the calls presented in the following subsections in order to simplify their presentation and clarify their intended purpose and use.
for a more complete description of parameter bundles.
The following parameter bundles are used in the "SE" protection and unprotection sets of calls.
AlgorithmIdentifier,  overrides enc qop alg
OCTET STRING,   type of the IDU ("data", "e mail doc", MIME type, etc.)
OCTET STRING,  mech indep encap req BOOLEAN
originator name    INTERNAL NAME,  originator role    Originator Role,
INTEGER,   a status flag giving the reason for rejection of the name   in bad targ name.
the name is not recognized;
SET OF Bad Target Name, 2.3.2.3.
IDUP SE major status codes
The following major status return codes are defined for the "SE" calls in this section:  GSS S COMPLETE
NEEDED   returned (by any SE call) to indicate that there is more output   data than can fit into the supplied buffers.
The application   should save the returned data and call again to retrieve the   remaining output.
NEEDED   indicates that more PIDU data is needed for the StartUnprotect   operation (e.g., so that PIDU Information or initial idu buffer   may be returned).
BAD QOP  GSS S FAILURE
If Target Info is used as an input parameter (e.g., if an encryption operation is being performed), the following major status return code is also defined:  IDUP S BAD TARG INFO Note for this return code that if one or more of the targets in targ names cannot be used as a valid recipient of the P IDU, these names will be returned in bad targ names (with associated status codes in bad targ status).
As long as at least one of the targets can be used, however, this does not cause this call to fail (i.e., the failure code IDUP S
BAD TARG INFO is not returned); it is the caller's choice to discontinue IDU protection if the target set which can be used is unsuitable for the caller's purposes.
IDUP SE SingleBuffer Protect call Inputs:
env handle ENVIRONMENT HANDLE,  Protect Options PARAMETER BUNDLE,  Target Info PARAMETER BUNDLE,  idu buffer
OCTET STRING  additional protection BOOLEAN
TRUE if idu buffer is the output of a previous protection   operation
(i.e., if this is the second (or higher) in a   series of SE/EV protection calls) Outputs:  major status INTEGER,  minor status INTEGER,  pidu buffer OCTET STRING,  sig token OCTET STRING   used if Protect Options is clear sign only Using the security environment referenced by env handle, encrypt and/or sign the supplied IDU.
If "clear signing" is performed, the signature will be returned in sig token and pidu buffer may be empty (depends on underlying mechanism).
env handle ENVIRONMENT HANDLE,  pidu buffer
OCTET STRING,   may contain an IDU if sig token
is non NULL (i.e., if   clear sign only protection was applied)  sig token OCTET STRING Outputs:  major status INTEGER,  minor status INTEGER,
OCTET STRING,   may be empty if clear sign only protection was applied (depends   on underlying mechanism)
TRUE if idu buffer should be input to another unprotection   operation (i.e., if this should not be the last in a series   of SE/EV unprotection calls) Using the security environment referenced by env handle, decrypt and/or verify the supplied PIDU and return the contained IDU along with all available PIDU Information.
IDUP SE MultiBuffer StartProtect call Inputs:
env handle ENVIRONMENT HANDLE,  Protect Options PARAMETER BUNDLE,  Target Info PARAMETER BUNDLE,  additional protection BOOLEAN,
Outputs:  major status INTEGER,  minor status INTEGER,
OCTET STRING   may be empty
(depends on underlying mechanism) Using the security environment referenced by env handle, initialize the data structures required to begin the process of signing and/or encrypting the IDU (which will be supplied in multiple buffers to the Process Buffer call).
IDUP SE MultiBuffer EndProtect call Inputs:
HANDLE Outputs:  major status INTEGER,  minor status INTEGER,  final pidu buffer
sig token OCTET STRING   used if Protect Options was clear sign only Using the security environment referenced by env handle, complete the protection processing on the data and place the computed output in final pidu buffer and/or sig token.
Successful application of IDUP SE MultiBuffer EndProtect() does not guarantee that unprotection can necessarily be performed successfully when the P IDU arrives at the target (for example, it may be damaged in transit).
IDUP SE MultiBuffer StartUnprotect call Inputs:
env handle ENVIRONMENT HANDLE,  initial pidu buffer
OCTET STRING,  sign qop alg in UNSIGNED INTEGER,
used if Protect Options was clear sign only (and calling   application has prior knowledge of signing alg.
if NULL, then sign qop alg in must be supplied Outputs:  major status INTEGER,  minor status INTEGER,  PIDU Information PARAMETER BUNDLE,
returns all available information  initial idu buffer
OCTET STRING   may be empty Using the security environment referenced by env handle, initialize the data structures required to begin the process of decrypting and/or verifying the PIDU (which will be supplied in multiple buffers to the Process Buffer call).
The parameters sign qop alg in and sig token should not both be supplied (i.e., they should not both be non NULL).
If they are both non NULL, however, sig token is taken to be authoritative since this is the token created at protection time and therefore is guaranteed to carry the information needed to unprotect.
IDUP SE MultiBuffer EndUnprotect call Inputs:
env handle ENVIRONMENT HANDLE,  sig token OCTET STRING
used if Protect Options was clear sign only and sig token
was   not available when StartUnprotect was called Outputs:
Using the security environment referenced by env handle, complete the decryption and/or verification processing on the data and place any residual output in final idu buffer.
IDUP SE Process Buffer call Inputs:
,  input buffer OCTET STRING, Outputs:  major status INTEGER,  minor status INTEGER,  output buffer
OCTET STRING   may be zero length
(depends on underlying mechanism and   corresponding Start() call and Protect Options value)
Using the security environment referenced by env handle, continue the processing on the data in input buffer and, if it is available, put any resulting output data in output buffer.
The application calls this routine over and over again with new buffers of data until it has processed all the data buffers of the IDU/PIDU.
It then calls the appropriate End() call to complete the processing.
The "EV" group of calls provides a simple, high level interface to underlying IDUP mechanisms when application developers need to deal only with evidence but not with encryption or integrity services.
It includes both the single buffer and multiple buffer IDU cases and can be used for the generation and verification of evidence
tokens embodying several different types of evidences.
The following list of evidence types is supported.
This list is by no means exhaustive and it is anticipated that it may be extended in future versions of this specification. "
Non repudiation of Origin" prevents a message creator's false denial of creating and sending a message. "
Non repudiation of Creation" prevents a message creator's false denial of creating a message. "
Non repudiation of Sender" prevents a message creator's false denial of sending a message (that was not necessarily created by the sender).
Non repudiation of Delivery" prevents a message recipient's false denial of having received and looked at the content of a message. "
Non repudiation of Receipt" prevents a message recipient's false denial of having received a message (whose content was not necessarily looked at by the recipient).
Non repudiation of Approval" prevents a message recipient's false denial of having approved the content of a received message.
An evidence is provided in the form of a evidence token.
Two forms of evidence tokens are supported:
Tokens including the associated data,  Tokens without included data (but with a unique reference to the associated data).
Evidence tokens may be freely distributed.
Any possessor of an evidence token (and of the associated data, if not included in the token) can verify the evidence if it has the appropriate credentials which include the definition of security policies (i.e., keys alone do not permit the verification of evidence tokens).
Any holder of an evidence token may store it (along with the associated data, if not included in the token) for later verification.
Calls that are specific to the support of evidence include:   Generate token, which generates a non repudiation token using the current environment.
The generated token may consist of: 1 an evidence token 2 a token containing a request for an evidence, which carries information describing which evidence type should be generated by the recipient(s) and sent back to some entities (that may or may not include the sender).
a token containing an evidence token which is an answer to an evidence that has been previously requested.
a token including both an evidence and a request for another evidence to be provided.
Verify evidence, which verifies the evidence token using the current environment.
This operation returns a major status code which can be used to determine whether the evidence contained in a token is complete (i.e., can be successfully verified (perhaps years) later).
If a token's evidence is not complete, the token can be passed to form complete pidu to complete it.
Additional useful calls for evidence services include:
The following parameter bundles are used in the "EV" protection and unprotection sets of calls.
525600;//365 days  mech indep encap req BOOLEAN
token generator name INTERNAL NAME,   obtained from the credentials of the originator   (e.g., from its public key certificate)
token generator role Originator Role OPTIONAL,
a status flag giving the reason for rejection of the   name in bad targ name
The following data type is used in the "EV" protection calls.
IDUP EV major status codes
The following major status return codes are defined for the "EV" calls in this section:  GSS S COMPLETE   indicates that the evidence is complete
IDUP S INCOMPLETE  IDUP S MORE OUTBUFFER
NEEDED   returned (by any EV call) to indicate that there is more output   data than can fit into the supplied buffers.
The application   should save the returned data and call again to retrieve the   remaining output.
If Target Info is used as an input parameter (i.e., if an evidence is being requested ), the following major status return code is also defined:  IDUP S BAD TARG INFO Note for this return code that if one or more of the targets in targ names cannot be used as a valid recipient of the P IDU, these names will be returned in bad targ names (with associated status codes in bad targ status).
As long as at least one of the targets can be used, however, this does not cause this call to fail (i.e., the failure code IDUP S
BAD TARG INFO is not returned); it is the caller's choice to discontinue IDU protection if the target set which can be used is unsuitable for the caller's purposes.
the type of the evidence that is requested;   policy under which the returned evidence should be generated;   the recipients that are supposed to send back an evidence;   the recipients that should receive the requested evidence;
present only if an evidence is requested.
Consists of data to   be used to verify the requested token(s)
(if any) when they are   received.
Description: This operation generates a non repudiation token associated with the data passed in an input buffer.
Two kinds of operations can be performed (using the Nr Operation parameter): a) generating a token that includes either an evidence only, or an evidence request only, or both an evidence and an evidence request; b) generating a response token for some recipients that includes an evidence generated as a response to a request (in this case the idu buffer is used to enter the request token that was received).
It is possible to request the generation of complete evidence.
This may succeed or fail; if it fails, a subsequent call to Form Complete PIDU can be made.
present only if the input token is a response to a previous   request for evidence (this parameter is used to validate that   evidence).
IDUP S INCOMPLETE, IDUP Form Complete PIDU should be called   with the same token before this time.
IDUP S INCOMPLETE, IDUP Form Complete PIDU should be called   with the same token after this time.
if the IDU was present within the token  additional unprotection BOOLEAN
Verifies the validity and discloses the content of a nr token.
If the token containing the evidence to be verified was provided to the calling application by a partner responding to the calling application's request, then the calling application must pass the evidence check it received when it generated the request as a parameter along with the token it received from the partner.
Output indicators are provided which give guidance about the time or times at which form complete pidu should be called; see the parameter descriptions for explanations of these indicators and their use.
Note that the time specified by complete evidence before may be earlier than that specified by complete evidence after; in this case it will be necessary to call form complete pidu twice.
Because keys can be revoked or declared compromised, the return from verify evidence cannot in all cases be a definitive "valid" or "invalid"; sometimes "conditionally valid" may be returned, depending upon the policy in use.
IDUP S INCOMPLETE will be returned, for example, if: the interval during which the generator of the evidence may permissibly declare his key invalid has not yet expired (and therefore it is possible that the evidence may be declared invalid in the future), or trusted time is required for verification, and the time obtained from the token is not trusted.
IDUP EV MultiBuffer StartGenerate call Inputs:
OCTET STRING   may be empty (depends on underlying mechanism)
Using the security environment referenced by env handle, initialize the data structures required to begin the generation of a token.
The IDU will be supplied in multiple buffers to the IDUP EV Process Buffer call).
Two kinds of operations can be performed (using the Nr Operation parameter) : a) generating a token that includes either an evidence only, or an evidence request only, or both an evidence and an evidence request.
b) generating a return token for some recipients that includes an evidence generated as a response to a request.
In that case the received token will be passed into the subsequent IDUP EV Process Buffer calls.
The boolean include data in token is ignored as the output will always be contained in a single token.
The Request Features are ignored in that case at this time in order to keep things simple and to avoid the piggy  backing that is theoretically possible.
It is possible to request the generation of complete evidence.
This may succeed or fail; if it fails, a subsequent call to Form Complete PIDU can be made.
IDUP EV MultiBuffer EndGenerate call Inputs:
present only if an evidence is requested.
Description: Using the security environment referenced by env handle, provide the requested token or the final P IDU.
A token will be generated if encapsulation was not requested; otherwise, the final P IDU is provided.
EV MultiBuffer StartVerify call Inputs:
present only if an evidence has been previously requested.
Outputs:  major status INTEGER,  minor status INTEGER Description: Using the security environment referenced by env handle, initialize the data structures required to begin the process of verifying the token.
The P IDU will be supplied in multiple buffers to the IDUP EV Process Buffer call.
IDUP EV MultiBuffer EndVerify call Input:
if the IDU was present within the token  additional unprotection BOOLEAN
Description: Using the security environment referenced by env handle, complete the verification processing on the data and provide verified output parameters to the caller when the major status code is either:
GSS S COMPLETE or IDUP S
IDUP EV Process Buffer call Inputs:
(depends on underlying mechanism and   corresponding Generate () call and options   (e.g., data included in token)
: Using the security environment referenced by env handle, continue the processing on the data in input buffer and, if it is available, put any resulting output data in output buffer.
The application calls this routine over and over again with new buffers of data until it has processed all the data buffers of the IDU/PIDU.
It then calls the appropriate End() call to complete the processing.
The "GP" group of calls provides a powerful interface to flexible and sophisticated combinations of protection and unprotection services.
This power and flexibility, however, necessitates a more complex interface than either the SE or the EV calls.
Furthermore, such combinations of services are not needed in many of the security mechanisms in common use today (although this is likely to change as time goes on).
The GP calls are therefore specified to be OPTIONAL and need not be supported by IDUP conformant implementations.
Note, however, that the structure of IDUP tokens should be such that the SE/EV and GP calls may be used interchangably by the receiver.
The concept of "parameter bundles" is used in the calls presented in the following subsections in order to simplify their presentation and clarify their intended purpose and use (note that specific language bindings may or may not use parameter bundles for its actual calling conventions).
A parameter bundle is simply a set of closely related parameters of a call which are either all used by / available to the calling application or all not used by / unavailable to the calling application.
These parameters may be all input parameters, all output parameters, or any combination of the two.
An example use envisioned for parameter bundles in a language such as C would be as a structure, where individual parameters in the bundle are structure members.
The calling application wishing to use a particular bundle would then allocate the appropriate structure variable, assign the desired input values to the appropriate members, and pass the address of the structure as the bundle "parameter".
On output, the values of the appropriate output members may be read.
An application not wishing to use a particular bundle (or one which is satisfied with default values for all input parameters of the bundle and which doesn't care about output values), can pass NULL as the bundle "parameter".
From the mechanism implementor's perspective, if a parameter bundle is not supported (for example, if it represents a security service which is not supported by the implementation), then any non NULL value passed as the bundle parameter will generate an error status return code.
[Note that the parameter bundles given below, except where explicitly referenced by the SE and EV calls, are specific to the (optional) GP calls.
Thus, these bundles need not be supported by IDUP conformant implementations if the GP calls are not supported.]
The following parameter bundles are used in the subsequent protection and unprotection sets of calls.
A parameter preceded by "(I)" is an input parameter; one preceded by "(O)" is an output parameter; one preceded by neither is an input if the bundle itself is an input and is an output if the bundle itself is an output; one preceded by "(X)" is the opposite:  an output if the bundle itself is an input and an input if the bundle itself is an output.
Mech Specific Info PARAMETER BUNDLE
actual parameters included in this bundle are defined by (and   specific to)
actual parameters included in this bundle are defined by (and   specific to) the underlying mechanism, but it is mandatory   that they include at least service
id and Quality Service Verification Info PARAMETER BUNDLE
actual parameters included in this bundle are defined by (and   specific to) the underlying mechanism, but it is mandatory   that they include at least service
id and Quality  Quality PARAMETER BUNDLE
UNSIGNED INTEGER,   protection guaranteed to be valid until time specified
policy id OBJECT IDENTIFIER,   security policy under which protection is/was carried out  allow policy mapping BOOLEAN,   determines whether mapping between policy IDs is allowed  actual policy time INTEGER   time at which the above policy rules came into effect  Idu Information PARAMETER BUNDLE,  idu type oid OBJECT IDENTIFIER,  idu type string
OCTET STRING,  idu title OCTET STRING,
idu sensitivity Sensitivity,  pidu type oid OBJECT IDENTIFIER,  pidu type string
OCTET STRING,  pidu title OCTET STRING,
is authenticated (e.g., inside a cert.)
Special Conditions PARAMETER BUNDLE,  prot oper
form complete pidu BOOLEAN,   input to protection operations for evidence generation  pidu in solic service BOOLEAN,   in protection operations, used as input for service   solicitation to request that receiver include the   received PIDU when generating the response.
operations, used as output to inform receiver that PIDU   should be included when generating the response.
use trusted time BOOLEAN,  use untrusted time BOOLEAN,  mech indep encap req BOOLEAN
Bad Target Name PARAMETER BUNDLE,  (O) bad targ name INTERNAL NAME,  (O)
a status flag giving the reason for rejection of   the name in bad targ name.
(O) bad targ count   INTEGER,  (
zero length if encapsulation request is TRUE
(O) minor status INTEGER, Three types of protection services are defined in IDUP.
perform unsolicited service (i.e., act on a locally generated service request), 2.
perform solicited service (i.e., act on a remotely generated service request), and 3.
perform service solicitation (i.e., send a service request to the remote end).
As an originator, applying data confidentiality with data integrity, or data origin authentication with data integrity, or proof of origin evidence is an example of service type 1.
As a target, creating a proof of delivery (i.e., receipt) evidence token as the result of a request received from the originator is an example of service type 2.
Finally, as an originator, submitting a request that one or more targets return a receipt for the data sent is an example of service type 3.
The first four parameters in the Prot Service parameter bundle pertain to all service types; the fifth parameter is used if and only if service type 2 is desired; parameters 6 8 are used if and only if service type 3 is desired.
(I) prot service type INTEGER,
(I) service id OBJECT IDENTIFIER,  (I)
NULL specifies default Quality  (I) general service data General Service Data,  (I) service creation info Service Creation Info,  (I) service to SET OF INTERNAL NAME,  (O) service verification info Service Verification Info,  (O) service verification info i
d INTEGER, Also, three types of unprotection services are defined.
receive unsolicited service (i.e., process unrequested remotely generated service), 2.
receive solicited service (i.e., process remotely generated response to locally generated request), and 3.
receive service solicitation (i.e., process req.
As a target, unprotecting an encrypted message, or verifying the originator's proof of origin is an example of service type 1.
As an originator, verifying a proof of delivery which you requested from a target is an example of service type 2.
Finally, as a target, receiving a request from an originator for a proof of delivery is an example of service type 3.
The first four parameters in the Unprot Service parameter bundle pertain to all service types; parameters 5 6 are used if and only if service type 2 is required; parameters 7 8 are used only if service type 3 is required.
(O) unprot service type INTEGER,
(O) service id OBJECT IDENTIFIER,  (O)
actual Quality specified (never NULL)
(O) general service data General Service Data,  (O) service verification info i
d INTEGER,  (I) service verification info Service Verification Info,  (O) service to SET OF INTERNAL NAME,  (O) service creation info Service Creation Info,
IDUP Start Protect call Inputs:
env handle ENVIRONMENT HANDLE,  Mech Specific Info PARAMETER BUNDLE,
NULL selects the mechanism defined default values  Idu Information PARAMETER BUNDLE,  Special Conditions PARAMETER BUNDLE,  encapsulation request BOOLEAN,  single idu buffer OCTET STRING,   non zero length for this buffer means that Protect/End Protect   won't be called (i.e., entire IDU is contained in this buffer)  idu size INTEGER,   size (in bytes) of the IDU to be protected;   may be " 1" signifying "UNKNOWN"
(note that some mechanisms   may not support encapsulation in such a case)  Target Info PARAMETER BUNDLE,  Services to Perform SET OF Prot Service, Outputs:  major status INTEGER,  minor status INTEGER,  midu buffer
zero length if encapsulation request is TRUE;   may be zero length otherwise (depends on underlying mechanism)
zero length if encapsulation request is FALSE;   may be zero length otherwise (depends on underlying mechanism)
Return major status codes:  GSS S COMPLETE
the protection process can begin (or has completed, if   single idu buffer has non zero length).
UNAVAIL  IDUP S REQ TIME SERVICE UNAVAIL
UNKNOWN OPER ID  GSS S
GSS S FAILURE Using the security environment referenced by env handle, initialize the data structures required to begin the process of protecting the IDU buffers.
The caller requests specific protection services by supplying the appropriate Prot Service parameter bundles in Services to Perform.
Each service is able to return a minor status code to the calling application, if necessary.
The calling application, knowing the size of the IDU it wishes to protect and the buffer size which it has available to it, can choose to input the entire IDU in a single buffer and omit the subsequent IDUP Protect() and IDUP End Protect() calls.
Furthermore, the application can request that the resulting M IDU be encapsulated in the token   so that the token contains the entire P IDU   rather than having it be returned separately in midu buffer.
Encapsulation, however, may not be supported by all underlying mechanisms or implementations; if this is the case, the IDUP S ENCAPSULATION UNAVAIL major status code will be returned and M IDU will be returned in midu buffer.
For those mechanisms which allow or require multiple stages of processing, each producing a different aspect of protection for the IDU, the operation identifier prot oper
id is used to specify which stage is currently being requested by the application.
An example where this would be useful is a mechanism which implements the signed Message Security Protocol [MSP].
As another example, a mechanism may choose to do a digital signature in two stages:  one for the hashing of the message and another for the signature on the hash.
The calling application would therefore use the protection set of calls on the IDU in stage 1 and then use the protection set of calls on the token (from stage 1) in stage 2.
The calling application uses this parameter to indicate to the underlying mechanism whether it wishes to do stage 1 of protection / unprotection processing, or stage 2, and so on.
Portable applications may pass "0" to let the mechanism choose the stage (note that mechanism implementers may still iterate when prot oper
(e.g., use output as next input, et cetera).
If one or more of the targets in targ names cannot be used as a valid recipient of the P IDU, these names will be returned in bad targ names (with associated status codes in bad targ status).
As long as at least one of the targets can be used, this does not cause this call to fail; it is the caller's choice to discontinue IDU protection if the target set which can be used is unsuitable for the caller's purposes.
Note that each Prot Service parameter bundle can also input a list of targ names; this is used if a separate list is to be used for that service only (the general list of targets is to be used for all services unless overridden in this way).
,  input buffer OCTET STRING, Outputs:  major status INTEGER,  minor status INTEGER,  output buffer
OCTET STRING   may be zero length if encapsulation request was set to TRUE in   IDUP Start Protect()
GSS S COMPLETE  IDUP S
ENV  GSS S FAILURE Using the security environment referenced by env handle, continue the protection processing on the data in input buffer and, if the underlying mechanism defines this, put any resulting P IDU/M IDU data in output buffer.
The application calls this routine over and over again with new buffers of data until it has protected all the data buffers of the IDU.
It then calls IDUP End Protect() to complete the protection processing.
Outputs:  major status INTEGER,  minor status INTEGER,  Services to Perform SET OF Prot Service,  final midu buffer
zero length if encapsulation request was set to TRUE in
IDUP Start Protect(), in which case pidu is used  final pidu buffer OCTET STRING,   zero length if encapsulation request was set to FALSE in   IDUP Start Protect(), in which case token and midu are used Return major status codes:
GSS S COMPLETE   protection has successfully completed and the resulting P IDU   is ready for transfer.
If defined by the underlying mechanism,   final midu buffer will contain any residual M IDU data.
ENV  GSS S FAILURE Using the security environment referenced by env handle, complete the protection processing on the data and place the computed output in final pidu buffer (or final midu buffer and the unencapsulated token parameter for each Prot Service).
If a service was requested from one or more targets in Start Protect() and if this is supported by the underlying mechanism Service Verification Info will hold whatever data is necessary for the mechanism to verify a service returned by a target (unprotector) of the P IDU.
Successful application of IDUP End Protect() does not guarantee that the corresponding unprotection set of calls can necessarily be performed successfully when the P IDU arrives at the target (for example, it may be damaged in transit).
env handle ENVIRONMENT HANDLE,  Mech Specific Info PARAMETER BUNDLE,
NULL selects the mechanism defined default values  single pidu buffer
OCTET STRING,   non zero length for this buffer means that IDUP Unprotect() and   IDUP End Unprotect() will not be called (i.e., the entire P IDU   (if encapsulation is used) or M IDU (if encap.
is not used)   is contained in this buffer)  partial pidu buffer
OCTET STRING,   may be an arbitrary sized piece of the full pidu (if the   application's buffer isn't large enough to hold entire pidu).
Used if pidu buffer will be input a buffer at a time (except   that the final buffer must be passed in final pidu buffer   rather than partial pidu buffer).
Only one of   single pidu buffer and partial(final) pidu buffer can have   nonzero length.
final pidu buffer OCTET STRING,  Special Conditions PARAMETER BUNDLE, Outputs:  major status INTEGER,  minor status INTEGER,  Services to Receive SET OF Unprot Service,  Prot Information PARAMETER BUNDLE,  single idu buffer
if this buffer has non zero length, then service processing has   been completed on the data in single pidu buffer  initial idu buffer
OCTET STRING,   holds any data from partial(final) pidu buffer which has been   unprotected; remaining data will be returned by Unprotect and   End Unprotect as they are called with successive buffers of   pidu  Service Verification Info PARAMETER BUNDLE,   used only if target is on "service to" list in Unprot Service  service verification info
used only if target is on "service to" list in Unprot Service Return major status codes:  GSS S COMPLETE   unprotection processing can begin (or has completed, if   single idu buffer has non zero length).
IDUP S INCOMPLETE   used only if single idu buffer has non zero length.
UNAVAIL  IDUP S REQ TIME SERVICE
UNAVAIL  IDUP S SERV VERIF INFO NEEDED
UNKNOWN OPER ID  GSS S BAD QOP
the qop algs value specified in P IDU for at least one of the   services is unavailable in the local mechanism, so processing   cannot continue.
IDUP S BAD DOA KEY  IDUP
IDUP S BAD ENC IDU  GSS S
FAILURE Using the security environment referenced by env handle, initialize the data structures required to begin the process of unprotecting a P IDU.
The caller will be alerted as to which services were applied to the P IDU in the returned Services to Receive set of parameters.
If encapsulation was not used by the originator, it is the receiving application's responsibility to separate the received P IDU into a M IDU and one or more unencapsulated token buffers (the latter being input in separate Unprot Service bundles in the Services to Receive parameter).
These unencapsulated token buffers should be input before the M IDU (i.e., in IDUP Start Unprotect) or after the M IDU (i.e., in IDUP End Unprotect) as appropriate; this order may be dictated, for example, by their placement in the in coming message.
If unprotection will be applied more than once to a given P IDU, it is the responsibility of the calling application to remember if a service solicitation has been responded to previously (i.e., if the requested service has already been generated / sent for that P IDU) and thus ignore subsequent solicitations on unprotect.
The time flags indicate whether to consult trusted, untrusted, or no time (if both flags are FALSE) during the unprotection operation.
If the current time is not to be checked, then unprotection may be successful even if the protector's key has expired since the P IDU was generated (that is, if the Validity period   as specified in the Quality parameter bundle   has expired).
If the underlying mechanism supports it and if this information is contained in the P IDU, information regarding the originator (that is, the entity which used the protection set of calls to generate this P IDU) is returned in the Prot Information parameter bundle.
input buffer OCTET STRING Outputs:  major status INTEGER,  minor status INTEGER,  output buffer
OCTET STRING Return major status codes:
GSS S COMPLETE  IDUP S
ENV  GSS S FAILURE Using the security environment referenced by env handle, continue the unprotection processing on the data in input buffer, putting any resulting IDU data in output buffer (if required).
IDUP End Unprotect call Inputs:
Outputs:  major status INTEGER,  minor status INTEGER,  Prot Information PARAMETER BUNDLE,
Services to Receive SET OF Unprot Service,  final idu buffer OCTET STRING,  Service Verification Info PARAMETER BUNDLE,   used only if target is on "service to" list in Unprot Service  service verification info
used only if target is on "service to" list in Unprot Service Return major status codes:
GSS S COMPLETE   residual IDU data will be returned in final idu buffer.
IDUP S BAD DOA KEY  IDUP
IDUP S BAD ENC IDU  IDUP S
ENV  GSS S FAILURE Using the security environment referenced by env handle, complete the unprotection processing on the data and return the appropriate status code.
If there is any residual IDU data it will be returned in final idu buffer.
If the IDUP S INCOMPLETE major status value is returned, all output parameters are conditionally valid; the unprotection set of functions will have to be called again (perhaps with a complete P IDU, as produced by IDUP Form Complete PIDU) in order to get valid values for all parameters.
"Conditional validity" may arise, for example, if all relevant certificates verify correctly, but it is not yet past the time up to which the current policy allows the authorities involved to repudiate their keys.
If the underlying mechanism supports it and if this information is contained in the token, information regarding the originator (that is, the entity which used the protection set of calls to generate this token) is returned in the Prot Information parameter bundle.
This information may or may not be omitted if it was returned by the IDUP Start Unprotect() call.
Note that, unlike GSS API, IDUP GSS API does not incorporate the concept of error tokens transferred between sender and recipient since the protection and unprotection of an IDU may be separated by an indefinite amount of time and may or may not be performed by the same entity.
The special purpose call described in this section has no analog in GSS API [RFC 2078].
This call is used to complete a P IDU (that is, to generate a P IDU which can be unprotected successfully with no additional data at any time during its validity period).
This call may not be supported by all underlying IDUP mechanisms or implementations.
IDUP Form Complete PIDU call Inputs:
env handle ENVIRONMENT HANDLE,  single pidu buffer
OCTET STRING,  partial pidu buffer
an arbitrary sized piece of the full pidu token.
Used if pidu   will be input a buffer at a time (except that the final buffer   must be passed in final pidu buffer rather than   partial pidu buffer).
Only one of single pidu buffer and   partial(final) pidu buffer can have nonzero length.
final pidu buffer OCTET STRING, Outputs:  major status INTEGER,  minor status INTEGER,  pidu token out OCTET STRING
the augmented PIDU; may be complete  call again before INTEGER,  call again after INTEGER,
trusted time stamping time INTEGER    for information
only Return major status codes:  GSS S COMPLETE
IDUP S INCOMPLETE   generation of the P IDU is not yet complete.
The application   should call this function again before the time given in   call again before (if not NULL), or after the time given in   call again after (if not NULL), or both (if neither are NULL).
IDUP S INCONSISTENT PARAMS  IDUP S
UNAVAIL  GSS S DEFECTIVE TOKEN
GSS S FAILURE Form Complete PIDU is used primarily by the evidence services; in particular, when the evidence token itself does not contain all the data required for its verification and it is anticipated that some of the data not stored in the token may become unavailable during the interval between generation of the evidence token and verification unless it is stored in the token.
The Form Complete PIDU operation gathers the missing information and includes it in the token so that verification can be guaranteed to be possible at any future time.
This call generates a PIDU which can be unprotected successfully with no additional data at any time during its validity period.
[For background information on the notion of "complete" evidence, see "CORBA Security Service v1.2 Draft D02", 18 June 1997.]
Using the security environment referenced by env handle, complete the generation of a P IDU token and return the appropriate status value along with the completed token (if available).
Such a call may be used, for example, for the purpose of batch evidence generation on an "evidence server".
A local machine may be able to use the protection set of calls to fill out most of an evidence token and then send a number of these to a batch processor which forms the complete evidence tokens (perhaps by adding a certification path, or a timestamp and signature from a timestamping authority).
As another example, on the receiving end an application may make such a call in order to collect all the information necessary to unprotect a P IDU (such as all relevant certificates and Certificate Revocation Lists); this will ensure that the calls to the unprotection set of operations will be entirely local (i.e., can be performed off line) and fast.
Note that the complete P IDU generated will be formed using trusted time if this is available in the environment referenced by env handle and will use untrusted time or no time otherwise (depending on what is available).
to GSS API Support calls in IDUP GSS API are to be understood and used as described in GSS API [RFC 2078].
The calls described in Section 2.4 of GSS API (including all associated parameters) are unchanged.
The following additional calls are specified for IDUP GSS API.
IDUP Acquire cred with auth call Inputs:
Future possible values for this parameter are for further   study (note that the type of this parameter is BIT STRING   (rather than INTEGER as in GSS Acquire cred) to facilitate   such future expansion).
Outputs:  major status INTEGER,  minor status INTEGER,
output cred handle  CREDENTIAL HANDLE,  actual mechs SET OF OBJECT
IDENTIFIER,  actual cred usage   BIT STRING,  lifetime rec INTEGER   in seconds, or reserved value for INDEFINITE
This call (which need not be supported by all underlying mechanisms or implementations) is identical to the GSS Acquire cred call, with the exception of the added input parameter "authenticator" and the added output parameter "actual cred usage".
The authenticator (typically a password, pass phrase, or PIN) is used to authenticate the caller claiming to be desired name to the underlying GSS (or mechanism) code.
The actual cred usage specifies the actual uses available for these credentials; it is up to the caller to determine if this is sufficient for its purposes.
Implementations that are able to authenticate the caller in some other way are encouraged to use the GSS Acquire cred call; those having no other means available to them, or wishing to explicitly authenticate the caller at the time of credential acquisition, should use the IDUP Acquire cred with auth call (if supported).
Note that the return major status codes for this call are identical to those given for the GSS Acquire cred call.
If the authentication fails (e.g., the wrong authenticator is supplied for the given desired name), the major status GSS S FAILURE is returned (along with an appropriate minor status code).
all the data to be returned shall be within the first 4 KB of
the token; hence, a single call is needed.
It is not necessary   to provide the entire token when the token includes the IDU.
IDENTIFIER   input if known (typically SET will contain a single member)
input token could be parsed for all relevant fields.
GSS S CREDENTIALS EXPIRED  GSS S DEFECTIVE TOKEN
the mechanism type could be parsed, but either the other fields   could not be determined from the input token, or their values   did not correspond to valid values for that mechanism.
the mechanism type was missing or corrupted.
IDUP Get token details() is used to return to an application the attributes that correspond to a given input token.
API tokens are meant to be opaque to the calling application, this function allows the application to determine information about the token without having to violate the opaqueness intention of IDUP.
Of primary importance is the mechanism type, which the application can then use as input to the IDUP Establish Env() call in order to establish the correct environment in which to have the token processed.
If all tokens are framed as suggested in Section 3.1 of [RFC 2078] (mandated in the Kerberos V5 GSS mechanism [RFC 1964] and in the SPKM GSS Mechanism [RFC 2025]), then any mechanism implementation should be able to return the mech type parameter for any uncorrupted input token.
If the mechanism implementation whose IDUP Get token details() function is being called does recognize the token, it can return any further relevant information in the other token attributes, as specified.
In particular, this function can set has SE protection if the SE calls may be used to unprotect it, or has EV protection if the EV calls may be used to unprotect it, or both if both kinds of protection have been applied (so that SE or EV calls may be used in any order for unprotection)
[note that GP calls, when supported, should be usable for unprotection of any IDUP token].
IDUP Get token details (which need not be supported by all underlying mechanisms or implementations) gives only a hint about the content of the token, there is no integrity check of any kind performed.
Regardless of the token type, it is possible to check that this information is correct only by doing a proper unprotection of the token.
It is recommended that IDUP callers supply a token buffer at least 4 KB in length in order to ensure that the desired data can easily flow across this interface.
The OID of the mechanism and whether the token contains the associated data is returned.
In addition the size of the associated data, whether inside or outside the token, is included if known.
[Note:  data size will typically be unknown if the data was protected using multibuffer calls.
A value of " 1" may be used to indicate "UNKNOWN".]
When the input token contains only an evidence generated spontaneously, the following is returned: the evidence type; the Non Repudiation policy under which the evidence was generated; the name of the generator of the evidence; the date and time when the evidence was generated (if available); the date and time when it was time stamped (if available).
When the input token contains only an evidence generated in response to  a request from another entity, the following additional information is returned: an indicator to state that this evidence relates to a request; a string significant for the requester that will allow him to check whether the answer corresponds to the requested evidence.
When the input token only contains a request, the following is returned: the name of the requestor of the evidence, the date and time when the request was made, the evidence type to send back, the non repudiation policy under which the evidence to send back should be generated, the names of the recipients which should generate and distribute the requested evidence, the names of the recipients to whom the requested evidence should be sent after it has been generated.
When the input token contains both evidence and a request, an indicator is returned describing whether the new evidence should be generated using only the data in the input token, or using both the data and the evidence in the input token.
When the input token contains only CONF and DOA services, the PIDU Information bundle is returned.
Other relevant parameters (such as idu size and time stamping time) may also be returned if this data is available.
IDUP Get policy info call Inputs:
OBJECT IDENTIFIER Outputs:  major status INTEGER,  minor status INTEGER,  policy version INTEGER,  policy effective time INTEGER,  policy expiry time INTEGER,
SET OF Service Descriptor,   services supported by this particular policy id (equal to the   intersection of the services supported by the mechanisms   listed in supported mechanisms)  supported mechanisms SET OF Mechanism Descriptor   mechanisms supported by this particular policy id Return major status codes:  GSS S COMPLETE   policy id recognized; all relevant fields have been returned.
the policy id was not recognized.
This call (which need not be supported by all underlying mechanisms or implementations) allows the application to retrieve information pertaining to a given policy id.
Policies define the following:  rules for the protection of IDUs, such as trusted third parties which may be involved in P IDU generation, the roles in which they may be involved, and the duration for which the generated P IDU is valid;  rules for the unprotection of P IDUs, such as the interval during which a trusted third party may legitimately declare its key to have been compromised or revoked; and  rules for adjudication, such as which authorities may be used to adjudicate disputes.
The policy itself may be used by an adjudicator when resolving a dispute.
For example, the adjudicator might refer to the policy to determine whether the rules for generation of the P IDU have been followed.
The following parameter bundles are associated with this call.
Service Descriptor PARAMETER BUNDLE,  service type OBJECT IDENTIFIER,  service validity duration INTEGER,  must use trusted time BOOLEAN  Mechanism Descriptor PARAMETER BUNDLE,  mechanism type OBJECT IDENTIFIER,  Authority List PARAMETER BUNDLE,  maximum time skew INTEGER
maximum permissible difference between P IDU generation   time and the time of countersignature from a time   service (if required).
This parameter is unused if   trusted time is not required.
Authority List PARAMETER BUNDLE,  authority name INTERNAL NAME,  authority role OCTET STRING,  last revocation check offset INTEGER   may be 0, greater than 0, or less than 0.
The value of   this parameter is added to P IDU generation time to   get latest time at which the mechanism will check to
see if this authority's key has been revoked.
An example of the use of the last parameter in Authority List is as follows.
If an authority has a defined last revocation check offset of negative one hour, then all revocations taking effect earlier than one hour before the generation of a P IDU will render that P IDU invalid; no revocation taking place later than one hour before the generation of the P IDU will affect the P IDU's validity.
Note that both the maximum time skew and the last revocation check offset values are given in minutes.
Cancel multibuffer op call Inputs:
Outputs:  major status INTEGER,  minor status INTEGER, Return major status codes:  GSS S COMPLETE   operation cancelled; state purged.
GSS S FAILURE   unable to cancel operation; state retained.
This call (which need not be supported by all underlying mechanisms or implementations) allows the application to cancel a multibuffer operation prior to normal completion (e.g., subsequent to calling Start operation and zero or more Process operation, but prior to calling End operation).
When successful, this call purges any internal state information which would have been used to continue processing for the full set of multibuffer calls.
In order to implement the IDUP GSS API atop existing, emerging, and future security mechanisms, the following is necessary: object identifiers must be assigned to candidate IDUP GSS API mechanisms and the name types which they support; and concrete data element (i.e., token and parameter bundle)
formats must be defined for candidate mechanisms.
Calling applications must implement formatting conventions which will enable them to distinguish IDUP GSS API P IDUs from other IDUs in their environment.
Concrete language bindings are required for the programming environments in which the IDUP GSS API is to be employed.
Security Considerations Security issues are discussed throughout this memo.
[RFC 1421]  Linn, J., "Privacy Enhancement for Internet Electronic Mail:
I: Message Encryption and Authentication Procedures", RFC 1421, February 1993.
[RFC 2078]  Linn, J., "Generic Security Service Application Program Interface, Version 2", RFC 2078, January 1997..
[RFC 1964]  Linn, J, "The Kerberos Version 5 GSS API Mechanism", RFC 1964, June 1996.
[RFC 2025]  Adams, C., "The Simple Public Key GSS API Mechanism (SPKM)", RFC 2025, October 1996.
2nd ISO/IEC CD 13888 1, "Information technology Security techniques
Non repudiation Part 1:  General Model", ISO/IEC JTC 1/SC 27, May 30, 1995 APPENDIX
This appendix specifies the use, for IDUP GSS API tokens, of the mechanism independent level of encapsulating representation for tokens given in Section 3.1 of GSS API [RFC 2078].
The representation given there incorporates an identifier of the mechanism type to be used when processing the associated tokens.
Use of that octet format is recommended to the designers of IDUP GSS API implementations based on various mechanisms so that tokens can be interpreted unambiguously at IDUP GSS API peers.
It is recognized, however, that for interoperability purposes with peers not using IDUP for specific IDU protection/unprotection protocols, the encapsulating representation may need to be omitted.
(In such a case it is necessary that the underlying mechanism provides some sort of internal or external identification that allows it to recognize its own tokens.)
When the mechanism independent level of encapsulating representation is not desired, callers SHOULD set mech indep encap req to FALSE (note that some underlying mechanisms may default this parameter to FALSE).
For purely descriptive purposes, the following simple ASN.1 structure is used to illustrate the structural relationships among token and tag objects.
For interoperability purposes, token and tag encoding shall be performed using the concrete encoding procedures described in Section 3.1 of GSS API [RFC 2078].
top level token definition to frame different mechanisms IDUP GSS API DEFINITIONS ::
IMPLICIT SEQUENCE { thisMech MechType, token ANY DEFINED BY thisMech
contents mechanism specific } END APPENDIX
This appendix provides examples of the use of IDUP to do IDU protection and unprotection.
It should not be regarded as constrictive to implementations or as defining the only means through which IDUP GSS API functions can be realized with particular underlying technology, and does not demonstrate all IDUP GSS API features.
Most of the examples below only illustrate the use of CONF/DOA protection services.
Note that when both CONF/DOA and Evidence services are required, calling applications may use a series of SE and EV calls, or may use the GP calls (when these are supported).
Using the former approach implies multiple calls (e.g., the SE calls are used to protect some data and the resulting token is then input to the EV calls to add evidence information), but some callers may find this to be more attractive than coding to the GP
calls because of the simpler SE/EV interface.
Depending upon the underlying mechanism, the series of SE/EV calls may result in a single token that can be unprotected using the SE and EV calls in any order (for example, because it is a single ASN.1 SEQUENCE that incorporates all the specified protection services at one level), or the series may result in a token that can only be unprotected in the reverse order of protection (for example, because each SE/EV output token was effectively embedded in the token of the subsequent call).
The IDUP Get token details call can assist callers in determining how to unprotect any received token.
Simple Mechanism, Single Buffer To illustrate the simplest possible case, consider an underlying IDUP mechanism which does straightforward encryption/decryption and signing/verification only using public key techniques; none of the other possible services, such as creation of proof of origin evidence, requests for proof of delivery evidence, or use of trusted time, are supported.
PEM[RFC 1421] is one example of a mechanism which fits this description.
Furthermore (again for simplicity), assume that encapsulation is chosen by the calling application during IDU protection.
Such a mechanism would likely use the "SE" set of IDUP GSS API calls.
The following parameter bundle uses and defaults would therefore be specified in the relevant IDUP mechanism document.
If not GSS S COMPLETE, check minor status, Target Info.
Bad Targ Name, (as required) for more detailed information.
Send Output parameter pidu buffer to receiver.
RECEIVER (any parameters not listed below are given the value NULL):
If not GSS S COMPLETE, check minor status, (as required) for more detailed information Utilize PIDU Information.
Protect Operation, (to determine which services were applied by the originator) PIDU Information.
Protect Options.sign qop alg / enc qop alg, (to determine the corresponding qualities of the services)
Prot Information.originator name, (to determine the name of the originator)
Prot Information.protection time, (to determine when the IDU was protected) idu buffer (to retrieve the unprotected data).
Simple Mechanism, Single Buffer (Again)
To illustrate a slight variation on the simplest possible case, assume that everything is as in the previous scenario except that the "GP" calls are used.
The following parameter bundle uses and defaults would therefore be specified in the relevant IDUP mechanism document.
NOT USED (the only acceptable input, therefore, is NULL)
NOT USED (the only acceptable input, therefore, is NULL)
NOT USED (the only acceptable input, therefore, is NULL)
NOT USED (the only acceptable input, therefore, is NULL)
Quality the qop algs parameter must be supported, with a suitable DEFAULT value specified; suitable DEFAULT values for validity, policy id, and allow policy mapping must be specified (it may be an implementation option as to whether these parameters are explicitly modifiable by the calling application, or whether NULLs are the only acceptable input)
Idu Information the idu type parameter must have a value representing a suitable IDU type (for example, in PEM a value representing the string "RFC822" or some other valid "Content Domain" would be used), with a suitable DEFAULT value specified; the idu title parameter is NOT USED (the only acceptable input, therefore, is NULL)
Prot Information the originator name and idu type (in Idu Information)
parameters are read from the encapsulating information and output by IDUP Start Unprotect; all other parameters are NOT USED (and therefore NULL)
NOT USED (the only acceptable input, therefore, is NULL)
Target Info this bundle is used as described in IDUP; no DEFAULT values are specified General Service Data the unencapsulated token parameter is used if encapsulation request is FALSE; the minor status parameter is used to return minor status values as specified by the mechanism document Prot Service the prot service type parameter may have a value of "1" ("perform unsolicited service") or NULL (which specifies the DEFAULT value of "1"); the service id parameter must have a value representing "
PER CONF" or "PER DOA"; the parameters Service Creation Info, service to, Service Verification Info, and service verification info
id are NOT USED (and therefore NULL)
the unprot service type parameter will always have a value of "1" ("receive unsolicited service"); the service id parameter will have a value representing "REC CONF" or "REC DOA"; the parameters service verification info id, Service Verification Info, service to, and Service Creation Info, are NOT USED (and therefore NULL)
Assuming that the calling application has only a single buffer of data to protect/unprotect, the following sequence of operations must be performed by the sender and receivers (subsequent to environment establishment).
(any parameters not listed below are given the value NULL):
Call IDUP Start Protect() with above input parameters Check major status.
If not GSS S COMPLETE, check minor status, Target Info.bad targ names / Target Info.bad targ status, P Services.
Prot Service 1.General Service Data.minor status, P Services.
Prot Service 2.General Service Data.minor status (as required) for more detailed information.
Send Output parameter pidu buffer to receiver.
RECEIVER (any parameters not listed below are given the value NULL):
If not GSS S COMPLETE, check minor status, R Services.
Unprot Service 1.General Service Data.minor status, R Services.
Unprot Service 2.General Service Data.minor status (as required) for more detailed information Utilize R Services.
id, (to determine which services were applied by the originator) R Services.
Unprot Service 1/2.Quality, (to determine the corresponding qualities of the services)
Prot Information.originator name, (to determine the name of the originator) single idu buffer (
to retrieve the unprotected data).
Simple Mechanism, Multiple Buffers To illustrate the next step up in complexity, consider the use of the simple IDUP mechanism described in B.2 above with multiple data buffers.
In particular, consider the case in which a large data file is to be signed.
For this example, assume that the calling application does not wish to use encapsulation.
Note that the parameter bundle uses and defaults
are as specified in B.2.
(any parameters not listed below are given the value NULL):
Call IDUP Start Protect() with above input parameters Check major status.
If not GSS S COMPLETE, check minor status, P Services.
General Service Data.minor status (as required) for more detailed information.
For each buffer of input data: Set input buffer   buffer Call IDUP Protect() with above input parameter Check major status.
If not GSS S COMPLETE, check minor status Call IDUP End Protect()
If not GSS S COMPLETE, check minor status, P Services.
General Service Data.minor status (as required) for more detailed information.
General Service Data.unencapsulated token, and the file for which the signature was calculated (if required), to receiver.
(any parameters not listed below are given the value NULL):
Unprot Service 1.General Service Data.
unencapsulated token    received unencapsulated token; Call IDUP Start Unprotect() with above input parameters Check major status.
If not GSS S COMPLETE, check minor status, R Services.
Unprot Service 1.General Service Data.minor status, (as required) for more detailed information For each buffer of input data:
Set input buffer   buffer Call IDUP Unprotect()
with above input parameter Check major status.
If not GSS S COMPLETE, check minor status Call IDUP End Unprotect
If not GSS S COMPLETE, check minor status, R Services.
Unprot Service 1.General Service Data.minor status, (as required) for more detailed information.
Unprot Service 1.service id, (to determine which service was applied by the originator; note that Unprot Service 2 will have NULL in unprot service type to indicate that it is not used) R Services.
Unprot Service 1.Quality, (to determine the corresponding quality of the service)
Prot Information.originator name, (from IDUP Start Unprotect)
(to determine the name of the signer) major status (from IDUP End Unprotect) (to determine pass/fail status of signature verification).
More Sophisticated Mechanism, Small Application Buffers To illustrate a higher level of complexity, consider the use of a more sophisticated IDUP mechanism and a calling application with small data buffers.
In particular, consider the case in which a very small e mail message is to be encrypted for a relatively large receiver list (R), some subset of whom (r) will be asked to send proofs of receipt of the message to some other subset (L) (which includes the originator).
So that the example is not unnecessarily complicated, assume again that the originating application uses encapsulation.
The uses and defaults for the various parameter bundles for this mechanism would be specified in the relevant IDUP mechanism document as follows.
NOT USED (the only acceptable input, therefore, is NULL)
NOT USED (the only acceptable input, therefore, is NULL)
Service Creation Info used to create "proof of delivery" evidence (but actual structure is opaque to calling application)
Service Verification Info used to verify "proof of delivery" evidence (but actual structure is opaque to calling application)
Quality the qop algs parameter must be supported, with a suitable DEFAULT value specified; suitable DEFAULT values for validity, policy id, and allow policy mapping must be specified (it may be an implementation option as to whether these parameters are explicitly modifiable by the calling application, or whether NULLs are the only acceptable input)
Idu Information the idu type parameter must have a value representing a suitable IDU type, with a suitable DEFAULT value specified; the idu title parameter must have a value representing a suitable IDU title, with a suitable DEFAULT value specified Prot Information the originator name, protection time, and idu type / idu title (in Idu Information) parameters are read from the contained header information and output by IDUP Start Unprotect; Special Conditions the parameter prot oper
id, Service Verification Info, service to, and Service Creation Info, are used when required by the IDUP operation SENDER (any parameters not listed below are given the value NULL):
with above input parameters Check major status.
If not GSS S COMPLETE, while major status   IDUP S MORE OUTBUFFER NEEDED Save pidu buffer, Call IDUP Start Protect() (to get next portion of pidu buffer)
Check major status, minor status, Target Info.bad targ names / Target Info.bad targ status, P Services.
Prot Service 1.General Service Data.minor status, P Services.
Prot Service 2.General Service Data.minor status (as required) for more detailed information.
Save Prot Service 2.Service Verification Info, Prot Service 2.service verification info i
Send All saved buffers of pidu buffer to receiver list (R).
RECEIVER (ON RECEIVER LIST (R)):
(any parameters not listed below are given the value NULL)
Start Unprotect() Check major status, minor status, R Services.
Unprot Service 1.General Service Data.minor status, R Services.
Unprot Service 2.General Service Data.minor status, (as required) for more detailed information Save initial idu buffer (
remaining p idu buffer Call IDUP Unprotect()
with above input parameter Check major status.
If not GSS S COMPLETE, check minor status
Save output buffer Call IDUP End Unprotect
If not GSS S COMPLETE, check minor status, R Services.
Unprot Service 1.General Service Data.minor status, R Services.
Unprot Service 2.General Service Data.minor status, (as required) for more detailed information.
id, (to determine which services were applied by the originator) R Services.
Unprot Service 1/2.Quality, (to determine the corresponding qualities of the service)
Prot Information.originator name/protection time and Prot Information.
Idu Information.idu type/idu title, (from IDUP Start Unprotect) (to determine originator info.)
Unprot Service 2.General Service Data.
targ.names, (to determine if rec.
is in "receipts from" (r))
Service Verification Info/service verification info
id (to determine if receiver is in "receipts to" list (L))
If receiver is in "receipts from" list (r) Save R Services.
Unprot Service 2.service to, R Services.
Unprot Service 2.Service Creation Info
If receiver is in "receipts to" list (L)
Save Service Verification Info, service verification info
with above input parameters Check major status.
If not GSS S COMPLETE, check minor status, P Services.
Prot Service 1.General Service Data.minor status (as required) for more detailed information.
Call IDUP Start Unprotect() with above input parameters
If major status   IDUP S SERV VERIF INFO NEEDED Utilize R Services.
Unprot Service 1.service verification info.id (to assist in locating necessary Service Verification Info)
Unprot Service 1.Service Verification Info
Service Verification Info Call IDUP Start Unprotect()
with above input parameters Check major status, minor status, R Services.
Unprot Service 1.General Service Data.minor status (as required) for more detailed information.
Unprot Service 1.service id, (to determine that this is a "proof of delivery" evidence) R Services.
Unprot Service 1.Quality, Prot Information.originator name, (for evidence generator info.)
major status (to determine pass/fail status of evi.
