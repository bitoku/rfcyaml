- title: __initial_text__
  contents:
  - '                         DNS Push Notifications

    '
- title: Abstract
  contents:
  - "Abstract\n   The Domain Name System (DNS) was designed to return matching records\n\
    \   efficiently for queries for data that are relatively static.  When\n   those\
    \ records change frequently, DNS is still efficient at returning\n   the updated\
    \ results when polled, as long as the polling rate is not\n   too high.  But,\
    \ there exists no mechanism for a client to be\n   asynchronously notified when\
    \ these changes occur.  This document\n   defines a mechanism for a client to\
    \ be notified of such changes to\n   DNS records, called DNS Push Notifications.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8765.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Requirements Language\n  \
    \   1.2.  Fatal Errors\n   2.  Motivation\n   3.  Overview\n   4.  State Considerations\n\
    \   5.  Transport\n   6.  Protocol Operation\n     6.1.  Discovery\n     6.2.\
    \  DNS Push Notification SUBSCRIBE\n       6.2.1.  SUBSCRIBE Request\n       6.2.2.\
    \  SUBSCRIBE Response\n     6.3.  DNS Push Notification Updates\n       6.3.1.\
    \  PUSH Message\n     6.4.  DNS Push Notification UNSUBSCRIBE\n       6.4.1. \
    \ UNSUBSCRIBE Message\n     6.5.  DNS Push Notification RECONFIRM\n       6.5.1.\
    \  RECONFIRM Message\n     6.6.  DNS Stateful Operations TLV Context Summary\n\
    \     6.7.  Client-Initiated Termination\n     6.8.  Client Fallback to Polling\n\
    \   7.  Security Considerations\n     7.1.  Security Services\n     7.2.  TLS\
    \ Name Authentication\n     7.3.  TLS Early Data\n     7.4.  TLS Session Resumption\n\
    \   8.  IANA Considerations\n   9.  References\n     9.1.  Normative References\n\
    \     9.2.  Informative References\n   Acknowledgments\n   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Domain Name System (DNS) records may be updated using DNS\
    \ Update\n   [RFC2136].  Other mechanisms such as a Discovery Proxy [RFC8766]\
    \ can\n   also generate changes to a DNS zone.  This document specifies a\n  \
    \ protocol for DNS clients to subscribe to receive asynchronous\n   notifications\
    \ of changes to RRsets of interest.  It is immediately\n   relevant in the case\
    \ of DNS-based Service Discovery [RFC6763] but is\n   not limited to that use\
    \ case; it provides a general DNS mechanism for\n   DNS record change notifications.\
    \  Familiarity with the DNS protocol\n   and DNS packet formats is assumed [RFC1034]\
    \ [RFC1035] [RFC6895].\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 1.2.  Fatal Errors
  contents:
  - "1.2.  Fatal Errors\n   Certain invalid situations are described in this specification,\
    \ such\n   as a server sending a Push Notification subscription request to a\n\
    \   client, or a client sending a Push Notification response to a server.\n  \
    \ These should never occur with a correctly implemented client and\n   server,\
    \ and if they do occur, then they indicate a serious\n   implementation error.\
    \  In these extreme cases, there is no reasonable\n   expectation of a graceful\
    \ recovery, and the recipient detecting the\n   error should respond by unilaterally\
    \ aborting the session without\n   regard for data loss.  Such cases are addressed\
    \ by having an engineer\n   investigate the cause of the failure and fixing the\
    \ problem in the\n   software.\n   Where this specification says \"forcibly abort\"\
    , it means sending a\n   TCP RST to terminate the TCP connection and the TLS session\
    \ running\n   over that TCP connection.  In the BSD Sockets API, this is achieved\n\
    \   by setting the SO_LINGER option to zero before closing the socket.\n"
- title: 2.  Motivation
  contents:
  - "2.  Motivation\n   As the domain name system continues to adapt to new uses and\
    \ changes\n   in deployment, polling has the potential to burden DNS servers at\n\
    \   many levels throughout the network.  Other network protocols have\n   successfully\
    \ deployed a publish/subscribe model following the\n   Observer design pattern\
    \ [OBS].  Extensible Messaging and Presence\n   Protocol (XMPP) Publish-Subscribe\
    \ [XEP0060] and Atom [RFC4287] are\n   examples.  While DNS servers are generally\
    \ highly tuned and capable\n   of a high rate of query/response traffic, adding\
    \ a publish/subscribe\n   model for tracking changes to DNS records can deliver\
    \ more timely\n   notifications of changes with reduced CPU usage and lower network\n\
    \   traffic.\n   The guiding design principle of DNS Push Notifications is that\n\
    \   clients that choose to use DNS Push Notifications, instead of\n   repeated\
    \ polling with DNS queries, will receive the same results as\n   they could via\
    \ sufficiently rapid polling, except more efficiently.\n   This means that the\
    \ rules for which records match a given DNS Push\n   Notification subscription\
    \ are the same as the already established\n   rules used to determine which records\
    \ match a given DNS query\n   [RFC1034].  For example, name comparisons are done\
    \ in a case-\n   insensitive manner, and a record of type CNAME in a zone matches\
    \ any\n   DNS TYPE in a query or subscription.\n   Multicast DNS [RFC6762] implementations\
    \ always listen on a well-known\n   link-local IP multicast group address, and\
    \ changes are sent to that\n   multicast group address for all group members to\
    \ receive.  Therefore,\n   Multicast DNS already has asynchronous change notification\n\
    \   capability.  When DNS-based Service Discovery [RFC6763] is used\n   across\
    \ a wide area network using Unicast DNS (possibly facilitated\n   via a Discovery\
    \ Proxy [RFC8766]), it would be beneficial to have an\n   equivalent capability\
    \ for Unicast DNS in order to allow clients to\n   learn about DNS record changes\
    \ in a timely manner without polling.\n   The DNS Long-Lived Queries (LLQ) mechanism\
    \ [RFC8764] is an existing\n   deployed solution to provide asynchronous change\
    \ notifications; it\n   was used by Apple's Back to My Mac [RFC6281] service introduced\
    \ in\n   Mac OS X 10.5 Leopard in 2007.  Back to My Mac was designed in an era\n\
    \   when the data center operations staff asserted that it was impossible\n  \
    \ for a server to handle large numbers of TCP connections, even if\n   those connections\
    \ carried very little traffic and spent most of their\n   time idle.  Consequently,\
    \ LLQ was defined as a UDP-based protocol,\n   effectively replicating much of\
    \ TCP's connection state management\n   logic in user space and creating its own\
    \ imitation of existing TCP\n   features like flow control, reliability, and the\
    \ three-way handshake.\n   This document builds on experience gained with the\
    \ LLQ protocol, with\n   an improved design.  Instead of using UDP, this specification\
    \ uses\n   DNS Stateful Operations (DSO) [RFC8490] running over TLS over TCP,\n\
    \   and therefore doesn't need to reinvent existing TCP functionality.\n   Using\
    \ TCP also gives long-lived low-traffic connections better\n   longevity through\
    \ NAT gateways without depending on the gateway to\n   support NAT Port Mapping\
    \ Protocol (NAT-PMP) [RFC6886] or Port Control\n   Protocol (PCP) [RFC6887], or\
    \ resorting to excessive keepalive\n   traffic.\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   A DNS Push Notification client subscribes for Push Notifications\
    \ for\n   a particular RRset by connecting to the appropriate Push Notification\n\
    \   server for that RRset and sending DSO message(s) indicating the\n   RRset(s)\
    \ of interest.  When the client loses interest in receiving\n   further updates\
    \ to these records, it unsubscribes.\n   The DNS Push Notification server for\
    \ a DNS zone is any server capable\n   of generating the correct change notifications\
    \ for a name.  It may be\n   a primary, secondary, or stealth name server [RFC8499].\n\
    \   The \"_dns-push-tls._tcp.<zone>\" SRV record for a zone MAY reference\n  \
    \ the same target host and port as that zone's\n   \"_dns-update-tls._tcp.<zone>\"\
    \ SRV record.  When the same target host\n   and port is offered for both DNS\
    \ Updates and DNS Push Notifications,\n   a client MAY use a single DSO session\
    \ to that server for both DNS\n   Updates and DNS Push Notification subscriptions.\
    \  DNS Updates and DNS\n   Push Notifications may be handled on different ports\
    \ on the same\n   target host, in which case they are not considered to be the\
    \ \"same\n   server\" for the purposes of this specification, and communications\n\
    \   with these two ports are handled independently.  Supporting DNS\n   Updates\
    \ and DNS Push Notifications on the same server is OPTIONAL.  A\n   DNS Push Notification\
    \ server is not required to support DNS Update.\n   Standard DNS Queries MAY be\
    \ sent over a DNS Push Notification (i.e.,\n   DSO) session.  For any zone for\
    \ which the server is authoritative, it\n   MUST respond authoritatively for queries\
    \ for names falling within\n   that zone (e.g., the \"_dns-push-tls._tcp.<zone>\"\
    \ SRV record) both for\n   normal DNS queries and for DNS Push Notification subscriptions.\
    \  For\n   names for which the server is acting as a recursive resolver (e.g.,\n\
    \   when the server is the local recursive resolver) for any query for\n   which\
    \ it supports DNS Push Notification subscriptions, it MUST also\n   support standard\
    \ queries.\n   DNS Push Notifications impose less load on the responding server\
    \ than\n   rapid polling would, but Push Notifications do still have a cost.\n\
    \   Therefore, DNS Push Notification clients MUST NOT recklessly create\n   an\
    \ excessive number of Push Notification subscriptions.\n   Specifically:\n   (a)\
    \  A subscription should only be active when there is a valid\n        reason\
    \ to need live data (for example, an on-screen display is\n        currently showing\
    \ the results to the user), and the subscription\n        SHOULD be canceled as\
    \ soon as the need for that data ends (for\n        example, when the user dismisses\
    \ that display).  In the case of\n        a device like a smartphone that, after\
    \ some period of\n        inactivity, goes to sleep or otherwise darkens its screen,\
    \ it\n        should cancel its subscriptions when darkening the screen (since\n\
    \        the user cannot see any changes on the display anyway) and\n        reinstate\
    \ its subscriptions when reawakening from display sleep.\n   (b)  A DNS Push Notification\
    \ client SHOULD NOT routinely keep a DNS\n        Push Notification subscription\
    \ active 24 hours a day, 7 days a\n        week, just to keep a list in memory\
    \ up to date so that if the\n        user does choose to bring up an on-screen\
    \ display of that data,\n        it can be displayed really fast.  DNS Push Notifications\
    \ are\n        designed to be fast enough that there is no need to pre-load a\n\
    \        \"warm\" list in memory just in case it might be needed later.\n   Generally,\
    \ as described in the DNS Stateful Operations specification\n   [RFC8490], a client\
    \ must not keep a DSO session to a server open\n   indefinitely if it has no subscriptions\
    \ (or other operations) active\n   on that session.  A client should begin closing\
    \ a DSO session\n   immediately after it becomes idle, and then, if needed in\
    \ the future,\n   open a new session when required.  Alternatively, a client may\n\
    \   speculatively keep an idle DSO session open for some time, subject to\n  \
    \ the constraint that it must not keep a session open that has been\n   idle for\
    \ more than the session's idle timeout (15 seconds by default)\n   [RFC8490].\n\
    \   Note that a DSO session that has an active DNS Push Notification\n   subscription\
    \ is not considered idle, even if there is no traffic\n   flowing for an extended\
    \ period of time.  In this case, the DSO\n   inactivity timeout does not apply,\
    \ because the session is not\n   inactive, but the keepalive interval does still\
    \ apply, to ensure the\n   generation of sufficient messages to maintain state\
    \ in middleboxes\n   (such at NAT gateways or firewalls) and for the client and\
    \ server to\n   periodically verify that they still have connectivity to each\
    \ other.\n   This is described in Section 6.2 of the DSO specification [RFC8490].\n"
- title: 4.  State Considerations
  contents:
  - "4.  State Considerations\n   Each DNS Push Notification server is capable of\
    \ handling some finite\n   number of Push Notification subscriptions.  This number\
    \ will vary\n   from server to server and is based on physical machine\n   characteristics,\
    \ network capacity, and operating system resource\n   allocation.  After a client\
    \ establishes a session to a DNS server,\n   each subscription is individually\
    \ accepted or rejected.  Servers may\n   employ various techniques to limit subscriptions\
    \ to a manageable\n   level.  Correspondingly, the client is free to establish\
    \ simultaneous\n   sessions to alternate DNS servers that support DNS Push Notifications\n\
    \   for the zone and distribute subscriptions at the client's discretion.\n  \
    \ In this way, both clients and servers can react to resource\n   constraints.\n"
- title: 5.  Transport
  contents:
  - "5.  Transport\n   Other DNS operations like DNS Update [RFC2136] MAY use either\
    \ DNS\n   over User Datagram Protocol (UDP) [RFC0768] or DNS over Transmission\n\
    \   Control Protocol (TCP) [RFC0793] as the transport protocol, provided\n   they\
    \ follow the historical precedent that DNS queries must first be\n   sent using\
    \ DNS over UDP and only switch to DNS over TCP if needed\n   [RFC1123].  This\
    \ requirement to prefer UDP has subsequently been\n   relaxed [RFC7766].\n   In\
    \ keeping with the more recent precedent, DNS Push Notification is\n   defined\
    \ only for TCP.  DNS Push Notification clients MUST use DNS\n   Stateful Operations\
    \ [RFC8490] running over TLS over TCP [RFC7858].\n   Connection setup over TCP\
    \ ensures return reachability and alleviates\n   concerns of state overload at\
    \ the server, a potential problem with\n   connectionless protocols, which can\
    \ be more vulnerable to being\n   exploited by attackers using spoofed source\
    \ addresses.  All\n   subscribers are guaranteed to be reachable by the server\
    \ by virtue of\n   the TCP three-way handshake.  Flooding attacks are possible\
    \ with any\n   protocol, and a benefit of TCP is that there are already established\n\
    \   industry best practices to guard against SYN flooding and similar\n   attacks\
    \ [SYN] [RFC4953].\n   Use of TCP also allows DNS Push Notifications to take advantage\
    \ of\n   current and future developments in TCP such as Multipath TCP (MPTCP)\n\
    \   [RFC8684], TCP Fast Open (TFO) [RFC7413], the TCP RACK fast loss\n   detection\
    \ algorithm [TCPRACK], and so on.\n   Transport Layer Security (TLS) [RFC8446]\
    \ is well understood and is\n   used by many application-layer protocols running\
    \ over TCP.  TLS is\n   designed to prevent eavesdropping, tampering, and message\
    \ forgery.\n   TLS is REQUIRED for every connection between a client subscriber\
    \ and\n   server in this protocol specification.  Additional security measures\n\
    \   such as client authentication during TLS negotiation may also be\n   employed\
    \ to increase the trust relationship between client and\n   server.\n"
- title: 6.  Protocol Operation
  contents:
  - "6.  Protocol Operation\n   The DNS Push Notification protocol is a session-oriented\
    \ protocol and\n   makes use of DNS Stateful Operations (DSO) [RFC8490].\n   For\
    \ details of the DSO message format, refer to the DNS Stateful\n   Operations\
    \ specification [RFC8490].  Those details are not repeated\n   here.\n   DNS Push\
    \ Notification clients and servers MUST support DSO.  A single\n   server can\
    \ support DNS Queries, DNS Updates, and DNS Push\n   Notifications (using DSO)\
    \ on the same TCP port.\n   A DNS Push Notification exchange begins with the client\
    \ discovering\n   the appropriate server, using the procedure described in Section\
    \ 6.1,\n   and then making a TLS/TCP connection to it.\n   After making the TLS/TCP\
    \ connection to the server, a typical DNS Push\n   Notification client will then\
    \ immediately issue a DSO Keepalive\n   operation to establish the DSO session\
    \ and request a session timeout\n   and/or keepalive interval longer than the\
    \ 15-second default values,\n   but this is not required.  A DNS Push Notification\
    \ client MAY issue\n   other requests on the session first, and only issue a DSO\
    \ Keepalive\n   operation later if it determines that to be necessary.  Sending\n\
    \   either a DSO Keepalive operation or a Push Notification subscription\n   request\
    \ over the TLS/TCP connection to the server signals the\n   client's support of\
    \ DSO and serves to establish a DSO session.\n   In accordance with the current\
    \ set of active subscriptions, the\n   server sends relevant asynchronous Push\
    \ Notifications to the client.\n   Note that a client MUST be prepared to receive\
    \ (and silently ignore)\n   Push Notifications for subscriptions it has previously\
    \ removed, since\n   there is no way to prevent the situation where a Push Notification\
    \ is\n   in flight from server to client while the client's UNSUBSCRIBE\n   message\
    \ canceling that subscription is simultaneously in flight from\n   client to server.\n"
- title: 6.1.  Discovery
  contents:
  - "6.1.  Discovery\n   The first step in establishing a DNS Push Notification subscription\n\
    \   is to discover an appropriate DNS server that supports DNS Push\n   Notifications\
    \ for the desired zone.\n   The client begins by opening a DSO session to its\
    \ normal configured\n   DNS recursive resolver and requesting a Push Notification\n\
    \   subscription.  This connection is made to TCP port 853, the default\n   port\
    \ for DNS over TLS [RFC7858].  If the request for a Push\n   Notification subscription\
    \ is successful, and the recursive resolver\n   doesn't already have an active\
    \ subscription for that name, type, and\n   class, then the recursive resolver\
    \ will make a corresponding Push\n   Notification subscription on the client's\
    \ behalf.  Results received\n   are relayed to the client.  This is closely analogous\
    \ to how a client\n   sends a normal DNS query to its configured DNS recursive\
    \ resolver,\n   which, if it doesn't already have appropriate answer(s) in its\
    \ cache,\n   issues an upstream query to satisfy the request.\n   In many contexts,\
    \ the recursive resolver will be able to handle Push\n   Notifications for all\
    \ names that the client may need to follow.  Use\n   of VPN tunnels and Private\
    \ DNS [RFC8499] can create some additional\n   complexity in the client software\
    \ here; the techniques to handle VPN\n   tunnels and Private DNS for DNS Push\
    \ Notifications are the same as\n   those already used to handle this for normal\
    \ DNS queries.\n   If the recursive resolver does not support DNS over TLS, or\
    \ supports\n   DNS over TLS but is not listening on TCP port 853, or supports\
    \ DNS\n   over TLS on TCP port 853 but does not support DSO on that port, then\n\
    \   the DSO session establishment will fail [RFC8490].\n   If the recursive resolver\
    \ does support DSO on TCP port 853 but does\n   not support Push Notification\
    \ subscriptions, then when the client\n   attempts to create a subscription, the\
    \ server will return the DSO\n   error code DSOTYPENI (11).\n   In some cases,\
    \ the recursive resolver may support DSO and Push\n   Notification subscriptions\
    \ but may not be able to subscribe for Push\n   Notifications for a particular\
    \ name.  In this case, the recursive\n   resolver should return SERVFAIL to the\
    \ client.  This includes being\n   unable to establish a connection to the zone's\
    \ DNS Push Notification\n   server or establishing a connection but receiving\
    \ a non-success\n   response code.  In some cases, where the client has a pre-established\n\
    \   trust relationship with the owner of the zone (that is not handled\n   via\
    \ the usual mechanisms for VPN software), the client may handle\n   these failures\
    \ by contacting the zone's DNS Push Notification server\n   directly.\n   In any\
    \ of the cases described above where the client fails to\n   establish a DNS Push\
    \ Notification subscription via its configured\n   recursive resolver, the client\
    \ should proceed to discover the\n   appropriate server for direct communication.\
    \  The client MUST also\n   determine on which TCP port the server is listening\
    \ for connections,\n   which need not be, and often is not, TCP port 53 (traditionally\
    \ used\n   for conventional DNS) or TCP port 853 (traditionally used for DNS\n\
    \   over TLS).\n   The discovery algorithm described here is an iterative algorithm,\n\
    \   which starts with the full name of the record to which the client\n   wishes\
    \ to subscribe.  Successive SOA queries are then issued,\n   trimming one label\
    \ each time, until the closest enclosing\n   authoritative server is discovered.\
    \  There is also an optimization to\n   enable the client to take a \"short cut\"\
    \ directly to the SOA record of\n   the closest enclosing authoritative server\
    \ in many cases.\n   1.  The client begins the discovery by sending a DNS query\
    \ to its\n       local resolver, with record type SOA [RFC1035] for the record\n\
    \       name to which it wishes to subscribe.  As an example, suppose the\n  \
    \     client wishes to subscribe to PTR records with the name\n       \"_ipp._tcp.headoffice.example.com\"\
    \ (to discover Internet Printing\n       Protocol (IPP) printers [RFC8010] [RFC8011]\
    \ being advertised in\n       the head office of Example Company).  The client\
    \ begins by\n       sending an SOA query for \"_ipp._tcp.headoffice.example.com\"\
    \ to\n       the local recursive resolver.  The goal is to determine the\n   \
    \    server that is authoritative for the name\n       \"_ipp._tcp.headoffice.example.com\"\
    .  The closest enclosing DNS\n       zone containing the name \"_ipp._tcp.headoffice.example.com\"\
    \ could\n       be \"example.com\", or \"headoffice.example.com\", or\n      \
    \ \"_tcp.headoffice.example.com\", or even\n       \"_ipp._tcp.headoffice.example.com\"\
    .  The client does not know in\n       advance where the closest enclosing zone\
    \ cut occurs, which is why\n       it uses the iterative procedure described here\
    \ to discover this\n       information.\n   2.  If the requested SOA record exists,\
    \ it will be returned in the\n       Answer Section with a NOERROR response code,\
    \ and the client has\n       succeeded in discovering the information it needs.\n\
    \       (This language is not placing any new requirements on DNS\n       recursive\
    \ resolvers.  This text merely describes the existing\n       operation of the\
    \ DNS protocol [RFC1034] [RFC1035].)\n   3.  If the requested SOA record does\
    \ not exist, the client will get\n       back a NOERROR/NODATA response or an\
    \ NXDOMAIN/Name Error\n       response.  In either case, the local resolver would\
    \ normally\n       include the SOA record for the closest enclosing zone of the\n\
    \       requested name in the Authority Section.  If the SOA record is\n     \
    \  received in the Authority Section, then the client has succeeded\n       in\
    \ discovering the information it needs.\n       (This language is not placing\
    \ any new requirements on DNS\n       recursive resolvers.  This text merely describes\
    \ the existing\n       operation of the DNS protocol regarding negative responses\n\
    \       [RFC2308].)\n   4.  If the client receives a response containing no SOA\
    \ record, then\n       it proceeds with the iterative approach.  The client strips\
    \ the\n       leading label from the current query name, and if the resulting\n\
    \       name has at least two labels in it, then the client sends an SOA\n   \
    \    query for that new name and processing continues at step 2 above,\n     \
    \  repeating the iterative search until either an SOA is received or\n       the\
    \ query name consists of a single label, i.e., a Top-Level\n       Domain (TLD).\
    \  In the case of a single-label name (TLD), this is\n       a network configuration\
    \ error, which should not happen, and the\n       client gives up.  The client\
    \ may retry the operation at a later\n       time of the client's choosing, such\
    \ as after a change in network\n       attachment.\n   5.  Once the SOA is known\
    \ (by virtue of being seen either in the\n       Answer Section or in the Authority\
    \ Section), the client sends a\n       DNS query with type SRV [RFC2782] for the\
    \ record name\n       \"_dns-push-tls._tcp.<zone>\", where <zone> is the owner\
    \ name of\n       the discovered SOA record.\n   6.  If the zone in question is\
    \ set up to offer DNS Push\n       Notifications, then this SRV record MUST exist.\
    \  (If this SRV\n       record does not exist, then the zone is not correctly\
    \ configured\n       for DNS Push Notifications as specified in this document.)\
    \  The\n       SRV \"target\" contains the name of the server providing DNS Push\n\
    \       Notifications for the zone.  The port number on which to contact\n   \
    \    the server is in the SRV record \"port\" field.  The address(es) of\n   \
    \    the target host MAY be included in the Additional Section,\n       however,\
    \ the address records SHOULD be authenticated before use\n       as described\
    \ in Section 7.2 and in the specification for using\n       DNS-Based Authentication\
    \ of Named Entities (DANE) TLSA Records\n       with SRV Records [RFC7673], if\
    \ applicable.\n   7.  More than one SRV record may be returned.  In this case,\
    \ the\n       \"priority\" and \"weight\" values in the returned SRV records are\n\
    \       used to determine the order in which to contact the servers for\n    \
    \   subscription requests.  As described in the SRV specification\n       [RFC2782],\
    \ the server with the lowest \"priority\" is first\n       contacted.  If more\
    \ than one server has the same \"priority\", the\n       \"weight\" indicates\
    \ the weighted probability that the client\n       should contact that server.\
    \  Higher weights have higher\n       probabilities of being selected.  If a server\
    \ is not willing to\n       accept a subscription request, or is not reachable\
    \ within a\n       reasonable time, as determined by the client, then a subsequent\n\
    \       server is to be contacted.\n   Each time a client makes a new DNS Push\
    \ Notification subscription, it\n   SHOULD repeat the discovery process in order\
    \ to determine the\n   preferred DNS server for that subscription at that time.\
    \  If a client\n   already has a DSO session with that DNS server, the client\
    \ SHOULD\n   reuse that existing DSO session for the new subscription; otherwise,\n\
    \   a new DSO session is established.  The client MUST respect the DNS\n   TTL\
    \ values on records it receives while performing the discovery\n   process and\
    \ store them in its local cache with this lifetime (as it\n   will generally do\
    \ anyway for all DNS queries it performs).  This\n   means that, as long as the\
    \ DNS TTL values on the authoritative\n   records are set to reasonable values,\
    \ repeated application of the\n   discovery process can be completed practically\
    \ instantaneously by the\n   client, using only locally stored cached data.\n"
- title: 6.2.  DNS Push Notification SUBSCRIBE
  contents:
  - "6.2.  DNS Push Notification SUBSCRIBE\n   After connecting, and requesting a\
    \ longer idle timeout and/or\n   keepalive interval if necessary, a DNS Push Notification\
    \ client then\n   indicates its desire to receive DNS Push Notifications for a\
    \ given\n   domain name by sending a SUBSCRIBE request to the server.  A\n   SUBSCRIBE\
    \ request is encoded in a DSO message [RFC8490].  This\n   specification defines\
    \ a DSO Primary TLV for DNS Push Notification\n   SUBSCRIBE Requests (DSO Type\
    \ Code 0x0040).\n   DSO messages with the SUBSCRIBE TLV as the Primary TLV are\
    \ permitted\n   in TLS early data, provided that the precautions described in\n\
    \   Section 7.3 are followed.\n   The entity that initiates a SUBSCRIBE request\
    \ is by definition the\n   client.  A server MUST NOT send a SUBSCRIBE request\
    \ over an existing\n   session from a client.  If a server does send a SUBSCRIBE\
    \ request\n   over a DSO session initiated by a client, this is a fatal error\
    \ and\n   the client MUST forcibly abort the connection immediately.\n   Each\
    \ SUBSCRIBE request generates exactly one SUBSCRIBE response from\n   the server.\
    \  The entity that initiates a SUBSCRIBE response is by\n   definition the server.\
    \  A client MUST NOT send a SUBSCRIBE response.\n   If a client does send a SUBSCRIBE\
    \ response, this is a fatal error and\n   the server MUST forcibly abort the connection\
    \ immediately.\n"
- title: 6.2.1.  SUBSCRIBE Request
  contents:
  - "6.2.1.  SUBSCRIBE Request\n   A SUBSCRIBE request begins with the standard DSO\
    \ 12-byte header\n   [RFC8490], followed by the SUBSCRIBE Primary TLV.  A SUBSCRIBE\n\
    \   request is illustrated in Figure 1.\n   The MESSAGE ID field MUST be set to\
    \ a unique value that the client is\n   not using for any other active operation\
    \ on this DSO session.  For\n   the purposes here, a MESSAGE ID is in use on this\
    \ session if either\n   the client has used it in a request for which it has not\
    \ yet received\n   a response, or if the client has used it for a subscription\
    \ that it\n   has not yet canceled using UNSUBSCRIBE.  In the SUBSCRIBE response,\n\
    \   the server MUST echo back the MESSAGE ID value unchanged.\n   The other header\
    \ fields MUST be set as described in the DSO\n   specification [RFC8490].  The\
    \ DNS OPCODE field contains the OPCODE\n   value for DNS Stateful Operations (6).\
    \  The four count fields must be\n   zero, and the corresponding four sections\
    \ must be empty (i.e.,\n   absent).\n   The DSO-TYPE is SUBSCRIBE (0x0040).\n\
    \   The DSO-LENGTH is the length of the DSO-DATA that follows, which\n   specifies\
    \ the name, type, and class of the record(s) being sought.\n        0  1  2  3\
    \  4  5  6  7  8  9  0  1  2  3  4  5\n      |                  MESSAGE ID   \
    \                |   \\\n      |QR| OPCODE(6) |         Z          |   RCODE \
    \  |    |\n      |             QDCOUNT (MUST BE ZERO)            |    |\n    \
    \  |             ANCOUNT (MUST BE ZERO)            |    |\n      |           \
    \  NSCOUNT (MUST BE ZERO)            |    |\n      |             ARCOUNT (MUST\
    \ BE ZERO)            |   /\n      |         DSO-TYPE = SUBSCRIBE (0x0040)   \
    \      |\n      |   DSO-LENGTH (number of octets in DSO-DATA)   |\n      \\  \
    \                   NAME                      \\   \\\n      |               \
    \      TYPE                      |     > DSO-DATA\n      |                   \
    \  CLASS                     |   /\n                        Figure 1: SUBSCRIBE\
    \ Request\n   The DSO-DATA for a SUBSCRIBE request MUST contain exactly one NAME,\n\
    \   TYPE, and CLASS.  Since SUBSCRIBE requests are sent over TCP,\n   multiple\
    \ SUBSCRIBE DSO request messages can be concatenated in a\n   single TCP stream\
    \ and packed efficiently into TCP segments.\n   If accepted, the subscription\
    \ will stay in effect until the client\n   cancels the subscription using UNSUBSCRIBE\
    \ or until the DSO session\n   between the client and the server is closed.\n\
    \   SUBSCRIBE requests on a given session MUST be unique.  A client MUST\n   NOT\
    \ send a SUBSCRIBE message that duplicates the name, type and class\n   of an\
    \ existing active subscription on that DSO session.  For the\n   purpose of this\
    \ matching, the established DNS case insensitivity for\n   US-ASCII letters [RFC0020]\
    \ applies (e.g., \"example.com\" and\n   \"Example.com\" are the same).  If a\
    \ server receives such a duplicate\n   SUBSCRIBE message, this is a fatal error\
    \ and the server MUST forcibly\n   abort the connection immediately.\n   DNS wildcarding\
    \ is not supported.  That is, an asterisk character\n   (\"*\") in a SUBSCRIBE\
    \ message matches only a literal asterisk\n   character (\"*\") in a name and\
    \ nothing else.  Similarly, a CNAME in a\n   SUBSCRIBE message matches only a\
    \ CNAME record with that name in the\n   zone and no other records with that name.\n\
    \   A client may SUBSCRIBE to records that are unknown to the server at\n   the\
    \ time of the request (providing that the name falls within one of\n   the zone(s)\
    \ the server is responsible for), and this is not an error.\n   The server MUST\
    \ NOT return NXDOMAIN in this case.  The server MUST\n   accept these requests\
    \ and send Push Notifications if and when\n   matching records are found in the\
    \ future.\n   If neither TYPE nor CLASS are ANY (255), then this is a specific\n\
    \   subscription to changes for the given name, type, and class.  If one\n   or\
    \ both of TYPE or CLASS are ANY (255), then this subscription\n   matches all\
    \ types and/or all classes as appropriate.\n   NOTE: A little-known quirk of DNS\
    \ is that in DNS QUERY requests,\n   QTYPE and QCLASS 255 mean \"ANY\", not \"\
    ALL\".  They indicate that the\n   server should respond with ANY matching records\
    \ of its choosing, not\n   necessarily ALL matching records.  This can lead to\
    \ some surprising\n   and unexpected results, where a query returns some valid\
    \ answers, but\n   not all of them, and makes QTYPE = 255 (ANY) queries less useful\
    \ than\n   people sometimes imagine.\n   When used in conjunction with SUBSCRIBE,\
    \ TYPE 255 and CLASS 255\n   should be interpreted to mean \"ALL\", not \"ANY\"\
    .  After accepting a\n   subscription where one or both of TYPE or CLASS are 255,\
    \ the server\n   MUST send Push Notification Updates for ALL record changes that\
    \ match\n   the subscription, not just some of them.\n"
- title: 6.2.2.  SUBSCRIBE Response
  contents:
  - "6.2.2.  SUBSCRIBE Response\n   A SUBSCRIBE response begins with the standard\
    \ DSO 12-byte header\n   [RFC8490].  The QR bit in the header is set indicating\
    \ it is a\n   response.  The header MAY be followed by one or more optional\n\
    \   Additional TLVs such as a Retry Delay Additional TLV.  A SUBSCRIBE\n   response\
    \ is illustrated in Figure 2.\n   The MESSAGE ID field MUST echo the value given\
    \ in the MESSAGE ID\n   field of the SUBSCRIBE request.  This is how the client\
    \ knows which\n   request is being responded to.\n   The other header fields MUST\
    \ be set as described in the DSO\n   specification [RFC8490].  The DNS OPCODE\
    \ field contains the OPCODE\n   value for DNS Stateful Operations (6).  The four\
    \ count fields must be\n   zero, and the corresponding four sections must be empty\
    \ (i.e.,\n   absent).\n   A SUBSCRIBE response message MUST NOT include a SUBSCRIBE\
    \ TLV.  If a\n   client receives a SUBSCRIBE response message containing a SUBSCRIBE\n\
    \   TLV, then the response message is processed but the SUBSCRIBE TLV\n   MUST\
    \ be silently ignored.\n        0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n\
    \      |                  MESSAGE ID                   |   \\\n      |QR| OPCODE(6)\
    \ |         Z          |   RCODE   |    |\n      |             QDCOUNT (MUST BE\
    \ ZERO)            |    |\n      |             ANCOUNT (MUST BE ZERO)        \
    \    |    |\n      |             NSCOUNT (MUST BE ZERO)            |    |\n  \
    \    |             ARCOUNT (MUST BE ZERO)            |   /\n                 \
    \       Figure 2: SUBSCRIBE Response\n   In the SUBSCRIBE response, the RCODE\
    \ indicates whether or not the\n   subscription was accepted.  Supported RCODEs\
    \ are as follows:\n         | Mnemonic  | Value | Description                \
    \       |\n         | NOERROR   |   0   | SUBSCRIBE successful.             |\n\
    \         | FORMERR   |   1   | Server failed to process request  |\n        \
    \ |           |       | due to a malformed request.       |\n         | SERVFAIL\
    \  |   2   | Server failed to process request  |\n         |           |     \
    \  | due to a problem with the server. |\n         | NOTIMP    |   4   | Server\
    \ does not implement DSO.    |\n         | REFUSED   |   5   | Server refuses\
    \ to process request |\n         |           |       | for policy or security\
    \ reasons.   |\n         | NOTAUTH   |   9   | Server is not authoritative for\
    \   |\n         |           |       | the requested name.               |\n  \
    \       | DSOTYPENI |   11  | SUBSCRIBE operation not           |\n         |\
    \           |       | supported.                        |\n                  \
    \   Table 1: SUBSCRIBE Response Codes\n   This document specifies only these RCODE\
    \ values for SUBSCRIBE\n   Responses.  Servers sending SUBSCRIBE Responses SHOULD\
    \ use one of\n   these values.  Note that NXDOMAIN is not a valid RCODE in response\
    \ to\n   a SUBSCRIBE Request.  However, future circumstances may create\n   situations\
    \ where other RCODE values are appropriate in SUBSCRIBE\n   Responses, so clients\
    \ MUST be prepared to accept and handle SUBSCRIBE\n   Responses with any other\
    \ nonzero RCODE error values.\n   If the server sends a nonzero RCODE in the SUBSCRIBE\
    \ response, that\n   means:\n   a.  the client is (at least partially) misconfigured,\
    \ or\n   b.  the server resources are exhausted, or\n   c.  there is some other\
    \ unknown failure on the server.\n   In any case, the client shouldn't retry the\
    \ subscription to this\n   server right away.  If multiple SRV records were returned\
    \ as\n   described in Section 6.1, Paragraph 9, Item 7, a subsequent server\n\
    \   MAY be tried immediately.\n   If the client has other successful subscriptions\
    \ to this server,\n   these subscriptions remain even though additional subscriptions\
    \ may\n   be refused.  Neither the client nor the server is required to close\n\
    \   the connection, although either end may choose to do so.\n   If the server\
    \ sends a nonzero RCODE, then it SHOULD append a Retry\n   Delay Additional TLV\
    \ [RFC8490] to the response specifying a delay\n   before the client attempts\
    \ this operation again.  Recommended values\n   for the delay for different RCODE\
    \ values are given below.  These\n   recommended values apply both to the default\
    \ values a server should\n   place in the Retry Delay Additional TLV and the default\
    \ values a\n   client should assume if the server provides no Retry Delay Additional\n\
    \   TLV.\n      For RCODE = 1 (FORMERR), the delay may be any value selected by\n\
    \      the implementer.  A value of five minutes is RECOMMENDED to reduce\n  \
    \    the risk of high load from defective clients.\n      For RCODE = 2 (SERVFAIL),\
    \ the delay should be chosen according to\n      the level of server overload\
    \ and the anticipated duration of that\n      overload.  By default, a value of\
    \ one minute is RECOMMENDED.  If a\n      more serious server failure occurs,\
    \ the delay may be longer in\n      accordance with the specific problem encountered.\n\
    \      For RCODE = 4 (NOTIMP), which occurs on a server that doesn't\n      implement\
    \ DNS Stateful Operations [RFC8490], it is unlikely that\n      the server will\
    \ begin supporting DSO in the next few minutes, so\n      the retry delay SHOULD\
    \ be one hour.  Note that in such a case, a\n      server that doesn't implement\
    \ DSO is unlikely to place a Retry\n      Delay Additional TLV in its response,\
    \ so this recommended value in\n      particular applies to what a client should\
    \ assume by default.\n      For RCODE = 5 (REFUSED), which occurs on a server\
    \ that implements\n      DNS Push Notifications but is currently configured to\
    \ disallow DNS\n      Push Notifications, the retry delay may be any value selected\
    \ by\n      the implementer and/or configured by the operator.\n      If the server\
    \ being queried is listed in a\n      \"_dns-push-tls._tcp.<zone>\" SRV record\
    \ for the zone, then this is\n      a misconfiguration, since this server is being\
    \ advertised as\n      supporting DNS Push Notifications for this zone, but the\
    \ server\n      itself is not currently configured to perform that task.  Since\
    \ it\n      is possible that the misconfiguration may be repaired at any time,\n\
    \      the retry delay should not be set too high.  By default, a value\n    \
    \  of 5 minutes is RECOMMENDED.\n      For RCODE = 9 (NOTAUTH), which occurs on\
    \ a server that implements\n      DNS Push Notifications but is not configured\
    \ to be authoritative\n      for the requested name, the retry delay may be any\
    \ value selected\n      by the implementer and/or configured by the operator.\n\
    \      If the server being queried is listed in a\n      \"_dns-push-tls._tcp.<zone>\"\
    \ SRV record for the zone, then this is\n      a misconfiguration, since this\
    \ server is being advertised as\n      supporting DNS Push Notifications for this\
    \ zone, but the server\n      itself is not currently configured to perform that\
    \ task.  Since it\n      is possible that the misconfiguration may be repaired\
    \ at any time,\n      the retry delay should not be set too high.  By default,\
    \ a value\n      of 5 minutes is RECOMMENDED.\n      For RCODE = 11 (DSOTYPENI),\
    \ which occurs on a server that\n      implements DSO but doesn't implement DNS\
    \ Push Notifications, it is\n      unlikely that the server will begin supporting\
    \ DNS Push\n      Notifications in the next few minutes, so the retry delay SHOULD\n\
    \      be one hour.\n      For other RCODE values, the retry delay should be set\
    \ by the\n      server as appropriate for that error condition.  By default, a\n\
    \      value of 5 minutes is RECOMMENDED.\n   For RCODE = 9 (NOTAUTH), the time\
    \ delay applies to requests for other\n   names falling within the same zone.\
    \  Requests for names falling\n   within other zones are not subject to the delay.\
    \  For all other\n   RCODEs, the time delay applies to all subsequent requests\
    \ to this\n   server.\n   After sending an error response, the server MAY allow\
    \ the session to\n   remain open, or MAY follow it with a DSO Retry Delay operation\
    \ (using\n   the Retry Delay Primary TLV) instructing the client to close the\n\
    \   session as described in the DSO specification [RFC8490].  Clients\n   MUST\
    \ correctly handle both cases.  Note that the DSO Retry Delay\n   operation (using\
    \ the Retry Delay Primary TLV) is different to the\n   Retry Delay Additional\
    \ TLV mentioned above.\n"
- title: 6.3.  DNS Push Notification Updates
  contents:
  - "6.3.  DNS Push Notification Updates\n   Once a subscription has been successfully\
    \ established, the server\n   generates PUSH messages to send to the client as\
    \ appropriate.  In the\n   case that the answer set was already non-empty at the\
    \ moment the\n   subscription was established, an initial PUSH message will be\
    \ sent\n   immediately following the SUBSCRIBE Response.  Subsequent changes to\n\
    \   the answer set are then communicated to the client in subsequent PUSH\n  \
    \ messages.\n   A client MUST NOT send a PUSH message.  If a client does send\
    \ a PUSH\n   message, or a PUSH message is sent with the QR bit set indicating\n\
    \   that it is a response, this is a fatal error and the receiver MUST\n   forcibly\
    \ abort the connection immediately.\n"
- title: 6.3.1.  PUSH Message
  contents:
  - "6.3.1.  PUSH Message\n   A PUSH unidirectional message begins with the standard\
    \ DSO 12-byte\n   header [RFC8490], followed by the PUSH Primary TLV.  A PUSH\
    \ message\n   is illustrated in Figure 3.\n   In accordance with the definition\
    \ of DSO unidirectional messages, the\n   MESSAGE ID field MUST be zero.  There\
    \ is no client response to a PUSH\n   message.\n   The other header fields MUST\
    \ be set as described in the DSO\n   specification [RFC8490].  The DNS OPCODE\
    \ field contains the OPCODE\n   value for DNS Stateful Operations (6).  The four\
    \ count fields must be\n   zero, and the corresponding four sections must be empty\
    \ (i.e.,\n   absent).\n   The DSO-TYPE is PUSH (0x0041).\n   The DSO-LENGTH is\
    \ the length of the DSO-DATA that follows, which\n   specifies the changes being\
    \ communicated.\n   The DSO-DATA contains one or more change notifications.  A\
    \ PUSH\n   Message MUST contain at least one change notification.  If a PUSH\n\
    \   Message is received that contains no change notifications, this is a\n   fatal\
    \ error and the client MUST forcibly abort the connection\n   immediately.\n \
    \  The change notification records are formatted similarly to how DNS\n   Resource\
    \ Records are conventionally expressed in DNS messages, as\n   illustrated in\
    \ Figure 3, and are interpreted as described below.\n   The TTL field holds an\
    \ unsigned 32-bit integer [RFC2181].  If the TTL\n   is in the range 0 to 2,147,483,647\
    \ seconds (0 to 2^(31) - 1, or\n   0x7FFFFFFF), then a new DNS Resource Record\
    \ with the given name,\n   type, class, and RDATA is added.  Type and class MUST\
    \ NOT be 255\n   (ANY).  If either type or class are 255 (ANY), this is a fatal\
    \ error\n   and the client MUST forcibly abort the connection immediately.  A\
    \ TTL\n   of 0 means that this record should be retained for as long as the\n\
    \   subscription is active and should be discarded immediately the moment\n  \
    \ the subscription is canceled.\n   If the TTL has the value 0xFFFFFFFF, then\
    \ the DNS Resource Record\n   with the given name, type, class, and RDATA is removed.\
    \  Type and\n   class MUST NOT be 255 (ANY).  If either type or class are 255\
    \ (ANY),\n   this is a fatal error and the client MUST forcibly abort the\n  \
    \ connection immediately.\n   If the TTL has the value 0xFFFFFFFE, then this is\
    \ a 'collective'\n   remove notification.  For collective remove notifications,\
    \ RDLEN MUST\n   be zero, and consequently, the RDATA MUST be empty.  If a change\n\
    \   notification is received where TTL = 0xFFFFFFFE and RDLEN is not\n   zero,\
    \ this is a fatal error and the client MUST forcibly abort the\n   connection\
    \ immediately.\n   There are three types of collective remove notification.  For\n\
    \   collective remove notifications:\n   *  If CLASS is not 255 (ANY) and TYPE\
    \ is not 255 (ANY), then for the\n      given name, this removes all records of\
    \ the specified type in the\n      specified class.\n   *  If CLASS is not 255\
    \ (ANY) and TYPE is 255 (ANY), then for the\n      given name, this removes all\
    \ records of all types in the specified\n      class.\n   *  If CLASS is 255 (ANY),\
    \ then for the given name, this removes all\n      records of all types in all\
    \ classes.  In this case, TYPE MUST be\n      set to zero on transmission and\
    \ MUST be silently ignored on\n      reception.\n   Summary of change notification\
    \ types:\n   *  Remove all RRsets from a name in all classes:\n      TTL = 0xFFFFFFFE,\
    \ RDLEN = 0, CLASS = 255 (ANY).\n   *  Remove all RRsets from a name in given\
    \ class:\n      TTL = 0xFFFFFFFE, RDLEN = 0, CLASS gives class, TYPE = 255 (ANY).\n\
    \   *  Remove specified RRset from a name in given class:\n      TTL = 0xFFFFFFFE,\
    \ RDLEN = 0,\n      CLASS and TYPE specify the RRset being removed.\n   *  Remove\
    \ an individual RR from a name:\n      TTL = 0xFFFFFFFF,\n      CLASS, TYPE, RDLEN,\
    \ and RDATA specify the RR being removed.\n   *  Add individual RR to a name:\n\
    \      TTL >= 0 and TTL <= 0x7FFFFFFF,\n      CLASS, TYPE, RDLEN, RDATA, and TTL\
    \ specify the RR being added.\n   Note that it is valid for the RDATA of an added\
    \ or removed DNS\n   Resource Record to be empty (zero length).  For example,\
    \ an Address\n   Prefix List Resource Record [RFC3123] may have empty RDATA.\n\
    \   Therefore, a change notification with RDLEN = 0 does not\n   automatically\
    \ indicate a remove notification.  If RDLEN = 0 and TTL\n   is in the range 0\
    \ to 0x7FFFFFFF, this change notification signals the\n   addition of a record\
    \ with the given name, type, class, and empty\n   RDATA.  If RDLEN = 0 and TTL\
    \ = 0xFFFFFFFF, this change notification\n   signals the removal specifically\
    \ of that single record with the given\n   name, type, class, and empty RDATA.\n\
    \   If the TTL is any value other than 0xFFFFFFFF, 0xFFFFFFFE, or a value\n  \
    \ in the range 0 to 0x7FFFFFFF, then the receiver SHOULD silently\n   ignore this\
    \ particular change notification record.  The connection is\n   not terminated\
    \ and other valid change notification records within\n   this PUSH message are\
    \ processed as usual.\n   In the case where a single change affects more than\
    \ one active\n   subscription, only one PUSH message is sent.  For example, a\
    \ PUSH\n   message adding a given record may match both a SUBSCRIBE request with\n\
    \   the same TYPE and a different SUBSCRIBE request with TYPE = 255\n   (ANY).\
    \  It is not the case that two PUSH messages are sent because\n   the new record\
    \ matches two active subscriptions.\n   The server SHOULD encode change notifications\
    \ in the most efficient\n   manner possible.  For example, when three AAAA records\
    \ are removed\n   from a given name, and no other AAAA records exist for that\
    \ name, the\n   server SHOULD send a \"Remove specified RRset from a name in given\n\
    \   class\" PUSH message, not three separate \"Remove an individual RR from\n\
    \   a name\" PUSH messages.  Similarly, when both an SRV and a TXT record\n  \
    \ are removed from a given name, and no other records of any kind exist\n   for\
    \ that name in that class, the server SHOULD send a \"Remove all\n   RRsets from\
    \ a name in given class\" PUSH message, not two separate\n   \"Remove specified\
    \ RRset from a name in given class\" PUSH messages.\n   For efficiency, when generating\
    \ a PUSH message, rather than sending\n   each change notification as a separate\
    \ DSO message, a server SHOULD\n   include as many change notifications as it\
    \ has immediately available\n   to send to that client, even if those change notifications\
    \ apply to\n   different subscriptions from that client.  Conceptually, a PUSH\n\
    \   message is a session-level mechanism, not a subscription-level\n   mechanism.\
    \  Once it has exhausted the list of change notifications\n   immediately available\
    \ to send to that client, a server SHOULD then\n   send the PUSH message immediately\
    \ rather than waiting speculatively\n   to see if additional change notifications\
    \ become available.\n   For efficiency, when generating a PUSH message a server\
    \ SHOULD use\n   standard DNS name compression, with offsets relative to the beginning\n\
    \   of the DNS message [RFC1035].  When multiple change notifications in\n   a\
    \ single PUSH message have the same owner name, this name compression\n   can\
    \ yield significant savings.  Name compression should be performed\n   as specified\
    \ in Section 18.14 of the Multicast DNS specification\n   [RFC6762]; namely, owner\
    \ names should always be compressed, and names\n   appearing within RDATA should\
    \ be compressed for only the RR types\n   listed below:\n      NS, CNAME, PTR,\
    \ DNAME, SOA, MX, AFSDB, RT, KX, RP, PX, SRV, NSEC\n   Servers may generate PUSH\
    \ messages up to a maximum DNS message length\n   of 16,382 bytes, counting from\
    \ the start of the DSO 12-byte header.\n   Including the two-byte length prefix\
    \ that is used to frame DNS over a\n   byte stream like TLS, this makes a total\
    \ of 16,384 bytes.  Servers\n   MUST NOT generate PUSH messages larger than this.\
    \  Where the\n   immediately available change notifications are sufficient to\
    \ exceed a\n   DNS message length of 16,382 bytes, the change notifications MUST\
    \ be\n   communicated in separate PUSH messages of up to 16,382 bytes each.\n\
    \   DNS name compression becomes less effective for messages larger than\n   16,384\
    \ bytes, so little efficiency benefit is gained by sending\n   messages larger\
    \ than this.\n   If a client receives a PUSH message with a DNS message length\
    \ larger\n   than 16,382 bytes, this is a fatal error and the client MUST forcibly\n\
    \   abort the connection immediately.\n        0  1  2  3  4  5  6  7  8  9  0\
    \  1  2  3  4  5\n      |           MESSAGE ID (MUST BE ZERO)           |   \\\
    \n      |QR| OPCODE(6) |         Z          |   RCODE   |    |\n      |      \
    \       QDCOUNT (MUST BE ZERO)            |    |\n      |             ANCOUNT\
    \ (MUST BE ZERO)            |    |\n      |             NSCOUNT (MUST BE ZERO)\
    \            |    |\n      |             ARCOUNT (MUST BE ZERO)            | \
    \  /\n      |            DSO-TYPE = PUSH (0x0041)           |\n      |   DSO-LENGTH\
    \ (number of octets in DSO-DATA)   |\n      \\                     NAME      \
    \                \\   \\\n      |                     TYPE                   \
    \   |    |\n      |                     CLASS                     |    |\n   \
    \   |                      TTL                      |    |\n      |     (32-bit\
    \ unsigned big-endian integer)      |     > DSO-DATA\n      |  RDLEN (16-bit unsigned\
    \ big-endian integer)   |    |\n      \\           RDATA (sized as necessary)\
    \          \\    |\n      :     NAME, TYPE, CLASS, TTL, RDLEN, RDATA      :  \
    \  |\n      :             Repeated As Necessary             :   /\n          \
    \                 Figure 3: PUSH Message\n   When processing the records received\
    \ in a PUSH Message, the receiving\n   client MUST validate that the records being\
    \ added or removed\n   correspond with at least one currently active subscription\
    \ on that\n   session.  Specifically, the record name MUST match the name given\
    \ in\n   the SUBSCRIBE request, subject to the usual established DNS case-\n \
    \  insensitivity for US-ASCII letters.  For individual additions and\n   removals,\
    \ if the TYPE in the SUBSCRIBE request was not ANY (255),\n   then the TYPE of\
    \ the record must either be CNAME or match the TYPE\n   given in the SUBSCRIBE\
    \ request, and if the CLASS in the SUBSCRIBE\n   request was not ANY (255), then\
    \ the CLASS of the record must match\n   the CLASS given in the SUBSCRIBE request.\
    \  For collective removals,\n   at least one of the records being removed must\
    \ match an active\n   subscription.  If a matching active subscription on that\
    \ session is\n   not found, then that particular addition/removal record is silently\n\
    \   ignored.  The processing of other additions and removal records in\n   this\
    \ message is not affected.  The DSO session is not closed.  This\n   is to allow\
    \ for the unavoidable race condition where a client sends\n   an outbound UNSUBSCRIBE\
    \ while inbound PUSH messages for that\n   subscription from the server are still\
    \ in flight.\n   The TTL of an added record is stored by the client.  While the\n\
    \   subscription is active the TTL is not decremented, because a change\n   to\
    \ the TTL would produce a new update.  For as long as a relevant\n   subscription\
    \ remains active, the client SHOULD assume that when a\n   record goes away, the\
    \ server will notify it of that fact.\n   Consequently, a client does not have\
    \ to poll to verify that the\n   record is still there.  Once a subscription is\
    \ canceled\n   (individually, or as a result of the DSO session being closed),\n\
    \   record aging for records covered by the subscription resumes and\n   records\
    \ are removed from the local cache when their TTL reaches zero.\n"
- title: 6.4.  DNS Push Notification UNSUBSCRIBE
  contents:
  - "6.4.  DNS Push Notification UNSUBSCRIBE\n   To cancel an individual subscription\
    \ without closing the entire DSO\n   session, the client sends an UNSUBSCRIBE\
    \ message over the established\n   DSO session to the server.\n   The entity that\
    \ initiates an UNSUBSCRIBE message is by definition the\n   client.  A server\
    \ MUST NOT send an UNSUBSCRIBE message over an\n   existing session from a client.\
    \  If a server does send an UNSUBSCRIBE\n   message over a DSO session initiated\
    \ by a client, or an UNSUBSCRIBE\n   message is sent with the QR bit set indicating\
    \ that it is a response,\n   this is a fatal error and the receiver MUST forcibly\
    \ abort the\n   connection immediately.\n"
- title: 6.4.1.  UNSUBSCRIBE Message
  contents:
  - "6.4.1.  UNSUBSCRIBE Message\n   An UNSUBSCRIBE unidirectional message begins\
    \ with the standard DSO\n   12-byte header [RFC8490], followed by the UNSUBSCRIBE\
    \ Primary TLV.\n   An UNSUBSCRIBE message is illustrated in Figure 4.\n   In accordance\
    \ with the definition of DSO unidirectional messages, the\n   MESSAGE ID field\
    \ MUST be zero.  There is no server response to an\n   UNSUBSCRIBE message.\n\
    \   The other header fields MUST be set as described in the DSO\n   specification\
    \ [RFC8490].  The DNS OPCODE field contains the OPCODE\n   value for DNS Stateful\
    \ Operations (6).  The four count fields must be\n   zero, and the corresponding\
    \ four sections must be empty (i.e.,\n   absent).\n   The DSO-TYPE is UNSUBSCRIBE\
    \ (0x0042).\n   The DSO-LENGTH field contains the value 2, the length of the 2-octet\n\
    \   MESSAGE ID contained in the DSO-DATA.\n   The DSO-DATA contains the value\
    \ previously given in the MESSAGE ID\n   field of an active SUBSCRIBE request.\
    \  This is how the server knows\n   which SUBSCRIBE request is being canceled.\
    \  After receipt of the\n   UNSUBSCRIBE message, the SUBSCRIBE request is no longer\
    \ active.\n   It is allowable for the client to issue an UNSUBSCRIBE message for\
    \ a\n   previous SUBSCRIBE request for which the client has not yet received\n\
    \   a SUBSCRIBE response.  This is to allow for the case where a client\n   starts\
    \ and stops a subscription in less than the round-trip time to\n   the server.\
    \  The client is NOT required to wait for the SUBSCRIBE\n   response before issuing\
    \ the UNSUBSCRIBE message.\n   Consequently, it is possible for a server to receive\
    \ an UNSUBSCRIBE\n   message that does not match any currently active subscription.\
    \  This\n   can occur when a client sends a SUBSCRIBE request, which subsequently\n\
    \   fails and returns an error code, but the client sent an UNSUBSCRIBE\n   message\
    \ before it became aware that the SUBSCRIBE request had failed.\n   Because of\
    \ this, servers MUST silently ignore UNSUBSCRIBE messages\n   that do not match\
    \ any currently active subscription.\n        0  1  2  3  4  5  6  7  8  9  0\
    \  1  2  3  4  5\n      |           MESSAGE ID (MUST BE ZERO)           |   \\\
    \n      |QR| OPCODE(6) |         Z          |   RCODE   |    |\n      |      \
    \       QDCOUNT (MUST BE ZERO)            |    |\n      |             ANCOUNT\
    \ (MUST BE ZERO)            |    |\n      |             NSCOUNT (MUST BE ZERO)\
    \            |    |\n      |             ARCOUNT (MUST BE ZERO)            | \
    \  /\n      |         DSO-TYPE = UNSUBSCRIBE (0x0042)       |\n      |       \
    \         DSO-LENGTH (2)                 |\n      |              SUBSCRIBE MESSAGE\
    \ ID             |   > DSO-DATA\n                       Figure 4: UNSUBSCRIBE\
    \ Message\n"
- title: 6.5.  DNS Push Notification RECONFIRM
  contents:
  - "6.5.  DNS Push Notification RECONFIRM\n   Sometimes, particularly when used with\
    \ a Discovery Proxy [RFC8766], a\n   DNS Zone may contain stale data.  When a\
    \ client encounters data that\n   it believes may be stale (e.g., an SRV record\
    \ referencing a target\n   host+port that is not responding to connection requests),\
    \ the client\n   can send a RECONFIRM message to ask the server to re-verify that\
    \ the\n   data is still valid.  For a Discovery Proxy, this causes it to issue\n\
    \   new Multicast DNS queries to ascertain whether the target device is\n   still\
    \ present.  How the Discovery Proxy causes these new Multicast\n   DNS queries\
    \ to be issued depends on the details of the underlying\n   Multicast DNS implementation\
    \ being used.  For example, a Discovery\n   Proxy built on Apple's dns_sd.h API\
    \ [SD-API] responds to a DNS Push\n   Notification RECONFIRM message by calling\
    \ the underlying API's\n   DNSServiceReconfirmRecord() routine.\n   For other\
    \ types of DNS server, the RECONFIRM operation is currently\n   undefined and\
    \ SHOULD result in a NOERROR response, but it need not\n   cause any other action\
    \ to occur.\n   Frequent use of RECONFIRM operations may be a sign of network\n\
    \   unreliability, or some kind of misconfiguration, so RECONFIRM\n   operations\
    \ MAY be logged or otherwise communicated to a human\n   administrator to assist\
    \ in detecting and remedying such network\n   problems.\n   If, after receiving\
    \ a valid RECONFIRM message, the server determines\n   that the disputed records\
    \ are in fact no longer valid, then\n   subsequent DNS PUSH Messages will be generated\
    \ to inform interested\n   clients.  Thus, one client discovering that a previously\
    \ advertised\n   device (like a network printer) is no longer present has the\
    \ side\n   effect of informing all other interested clients that the device in\n\
    \   question is now gone.\n   The entity that initiates a RECONFIRM message is\
    \ by definition the\n   client.  A server MUST NOT send a RECONFIRM message over\
    \ an existing\n   session from a client.  If a server does send a RECONFIRM message\n\
    \   over a DSO session initiated by a client, or a RECONFIRM message is\n   sent\
    \ with the QR bit set indicating that it is a response, this is a\n   fatal error\
    \ and the receiver MUST forcibly abort the connection\n   immediately.\n"
- title: 6.5.1.  RECONFIRM Message
  contents:
  - "6.5.1.  RECONFIRM Message\n   A RECONFIRM unidirectional message begins with\
    \ the standard DSO\n   12-byte header [RFC8490], followed by the RECONFIRM Primary\
    \ TLV.  A\n   RECONFIRM message is illustrated in Figure 5.\n   In accordance\
    \ with the definition of DSO unidirectional messages, the\n   MESSAGE ID field\
    \ MUST be zero.  There is no server response to a\n   RECONFIRM message.\n   The\
    \ other header fields MUST be set as described in the DSO\n   specification [RFC8490].\
    \  The DNS OPCODE field contains the OPCODE\n   value for DNS Stateful Operations\
    \ (6).  The four count fields must be\n   zero, and the corresponding four sections\
    \ must be empty (i.e.,\n   absent).\n   The DSO-TYPE is RECONFIRM (0x0043).\n\
    \   The DSO-LENGTH is the length of the data that follows, which\n   specifies\
    \ the name, type, class, and content of the record being\n   disputed.\n   A DNS\
    \ Push Notifications RECONFIRM message contains exactly one\n   RECONFIRM Primary\
    \ TLV.  The DSO-DATA in a RECONFIRM Primary TLV MUST\n   contain exactly one record.\
    \  The DSO-DATA in a RECONFIRM Primary TLV\n   has no count field to specify more\
    \ than one record.  Since RECONFIRM\n   messages are sent over TCP, multiple RECONFIRM\
    \ messages can be\n   concatenated in a single TCP stream and packed efficiently\
    \ into TCP\n   segments.  Note that this means that DNS name compression cannot\
    \ be\n   used between different RECONFIRM messages.  However, when a client is\n\
    \   sending multiple RECONFIRM messages this indicates a situation with\n   serious\
    \ network problems, and this is not expected to occur\n   frequently enough that\
    \ optimizing efficiency in this case is\n   important.\n   TYPE MUST NOT be the\
    \ value ANY (255) and CLASS MUST NOT be the value\n   ANY (255).\n   DNS wildcarding\
    \ is not supported.  That is, an asterisk character\n   (\"*\") in a RECONFIRM\
    \ message matches only a literal asterisk\n   character (\"*\") in a name and\
    \ nothing else.  Similarly, a CNAME in a\n   RECONFIRM message matches only a\
    \ CNAME record with that name in the\n   zone and no other records with that name.\n\
    \   Note that there is no RDLEN field, since the length of the RDATA can\n   be\
    \ inferred from DSO-LENGTH, so an additional RDLEN field would be\n   redundant.\n\
    \   Following the same rules as for PUSH messages, DNS name compression\n   SHOULD\
    \ be used within the RDATA of the RECONFIRM message, with\n   offsets relative\
    \ to the beginning of the DNS message [RFC1035].\n        0  1  2  3  4  5  6\
    \  7  8  9  0  1  2  3  4  5\n      |           MESSAGE ID (MUST BE ZERO)    \
    \       |   \\\n      |QR| OPCODE(6) |         Z          |   RCODE   |    |\n\
    \      |             QDCOUNT (MUST BE ZERO)            |    |\n      |       \
    \      ANCOUNT (MUST BE ZERO)            |    |\n      |             NSCOUNT (MUST\
    \ BE ZERO)            |    |\n      |             ARCOUNT (MUST BE ZERO)     \
    \       |   /\n      |         DSO-TYPE = RECONFIRM (0x0043)         |\n     \
    \ |   DSO-LENGTH (number of octets in DSO-DATA)   |\n      \\                \
    \     NAME                      \\   \\\n      |                     TYPE    \
    \                  |    |\n      |                     CLASS                 \
    \    |    |\n      \\                     RDATA                     \\   /\n \
    \                       Figure 5: RECONFIRM Message\n"
- title: 6.6.  DNS Stateful Operations TLV Context Summary
  contents:
  - "6.6.  DNS Stateful Operations TLV Context Summary\n   This document defines four\
    \ new DSO TLVs.  As recommended in\n   Section 8.2 of the DNS Stateful Operations\
    \ specification [RFC8490],\n   the valid contexts of these new TLV types are summarized\
    \ below.\n   The client TLV contexts are:\n   C-P:  Client request message, Primary\
    \ TLV\n   C-U:  Client Unidirectional message, primary TLV\n   C-A:  Client request\
    \ or unidirectional message, Additional TLV\n   CRP:  Response back to client,\
    \ Primary TLV\n   CRA:  Response back to client, Additional TLV\n            \
    \   |    TLV Type | C-P | C-U | C-A | CRP | CRA |\n               |   SUBSCRIBE\
    \ |  X  |     |     |     |     |\n               |        PUSH |     |     |\
    \     |     |     |\n               | UNSUBSCRIBE |     |  X  |     |     |  \
    \   |\n               |   RECONFIRM |     |  X  |     |     |     |\n        \
    \          Table 2: DSO TLV Client Context Summary\n   The server TLV contexts\
    \ are:\n   S-P:  Server request message, Primary TLV\n   S-U:  Server Unidirectional\
    \ message, primary TLV\n   S-A:  Server request or unidirectional message, Additional\
    \ TLV\n   SRP:  Response back to server, Primary TLV\n   SRA:  Response back to\
    \ server, Additional TLV\n               |    TLV Type | S-P | S-U | S-A | SRP\
    \ | SRA |\n               |   SUBSCRIBE |     |     |     |     |     |\n    \
    \           |        PUSH |     |  X  |     |     |     |\n               | UNSUBSCRIBE\
    \ |     |     |     |     |     |\n               |   RECONFIRM |     |     |\
    \     |     |     |\n                  Table 3: DSO TLV Server Context Summary\n"
- title: 6.7.  Client-Initiated Termination
  contents:
  - "6.7.  Client-Initiated Termination\n   An individual subscription is terminated\
    \ by sending an UNSUBSCRIBE\n   TLV for that specific subscription, or all subscriptions\
    \ can be\n   canceled at once by the client closing the DSO session.  When a\n\
    \   client terminates an individual subscription (via UNSUBSCRIBE) or all\n  \
    \ subscriptions on that DSO session (by ending the session), it is\n   signaling\
    \ to the server that it is no longer interested in receiving\n   those particular\
    \ updates.  It is informing the server that the server\n   may release any state\
    \ information it has been keeping with regards to\n   these particular subscriptions.\n\
    \   After terminating its last subscription on a session via UNSUBSCRIBE,\n  \
    \ a client MAY close the session immediately or it may keep it open if\n   it\
    \ anticipates performing further operations on that session in the\n   future.\
    \  If a client wishes to keep an idle session open, it MUST\n   respect the maximum\
    \ idle time required by the server [RFC8490].\n   If a client plans to terminate\
    \ one or more subscriptions on a session\n   and doesn't intend to keep that session\
    \ open, then as an efficiency\n   optimization, it MAY instead choose to simply\
    \ close the session,\n   which implicitly terminates all subscriptions on that\
    \ session.  This\n   may occur because the client computer is being shut down,\
    \ is going to\n   sleep, the application requiring the subscriptions has terminated,\
    \ or\n   simply because the last active subscription on that session has been\n\
    \   canceled.\n   When closing a session, a client should perform an orderly close\
    \ of\n   the TLS session.  Typical APIs will provide a session close method\n\
    \   that will send a TLS close_notify alert as described in Section 6.1\n   of\
    \ the TLS 1.3 specification [RFC8446].  This instructs the recipient\n   that\
    \ the sender will not send any more data over the session.  After\n   sending\
    \ the TLS close_notify alert, the client MUST gracefully close\n   the underlying\
    \ connection using a TCP FIN so that the TLS\n   close_notify is reliably delivered.\
    \  The mechanisms for gracefully\n   closing a TCP connection with a TCP FIN vary\
    \ depending on the\n   networking API.  For example, in the BSD Sockets API, sending\
    \ a TCP\n   FIN is achieved by calling \"shutdown(s,SHUT_WR)\" and keeping the\n\
    \   socket open until all remaining data has been read from it.\n   If the session\
    \ is forcibly closed at the TCP level by sending a RST\n   from either end of\
    \ the connection, data may be lost.\n"
- title: 6.8.  Client Fallback to Polling
  contents:
  - "6.8.  Client Fallback to Polling\n   There are cases where a client may exhaust\
    \ all avenues for\n   establishing a DNS Push Notification subscription without\
    \ success.\n   This can happen if the client's configured recursive resolver does\n\
    \   not support DNS over TLS, or supports DNS over TLS but is not\n   listening\
    \ on TCP port 853, or supports DNS over TLS on TCP port 853\n   but does not support\
    \ DSO on that port, or for some other reason is\n   unable to provide a DNS Push\
    \ Notification subscription.  In this\n   case, the client will attempt to communicate\
    \ directly with an\n   appropriate server, and it may be that the zone apex discovery\
    \ fails,\n   or there is no \"_dns-push-tls._tcp.<zone>\" SRV record, or the server\n\
    \   indicated in the SRV record is misconfigured, overloaded, or is\n   unresponsive\
    \ for some other reason.\n   Regardless of the reason for the failure, after being\
    \ unable to\n   establish the desired DNS Push Notification subscription, it is\n\
    \   likely that the client will still wish to know the answer it seeks,\n   even\
    \ if that answer cannot be obtained with the timely change\n   notifications provided\
    \ by DNS Push Notifications.  In such cases, it\n   is likely that the client\
    \ will obtain the answer it seeks via a\n   conventional DNS query instead, repeated\
    \ at some interval to detect\n   when the answer RRset changes.\n   In the case\
    \ where a client responds to its failure to establish a DNS\n   Push Notification\
    \ subscription by falling back to polling with\n   conventional DNS queries instead,\
    \ the polling rate should be\n   controlled to avoid placing excessive burden\
    \ on the server.  The\n   interval between successive DNS queries for the same\
    \ name, type, and\n   class SHOULD be at least the minimum of 900 seconds (15\
    \ minutes) or\n   two seconds more than the TTL of the answer RRset.\n   The reason\
    \ that for TTLs up to 898 seconds the query should not be\n   reissued until two\
    \ seconds _after_ the answer RRset has expired, is\n   to ensure that the answer\
    \ RRset has also expired from the cache on\n   the client's configured recursive\
    \ resolver.  Otherwise (particularly\n   if the clocks on the client and the recursive\
    \ resolver do not run at\n   precisely the same rate), there's a risk of a race\
    \ condition where\n   the client queries its configured recursive resolver just\
    \ as the\n   answer RRset has one second remaining in the recursive resolver's\n\
    \   cache.  The client would receive a reply telling it that the answer\n   RRset\
    \ has one second remaining; the client would then requery the\n   recursive resolver\
    \ again one second later.  If by this time the\n   answer RRset has actually expired\
    \ from the recursive resolver's\n   cache, the recursive resolver would then issue\
    \ a new query to fetch\n   fresh data from the authoritative server.  Waiting\
    \ until the answer\n   RRset has definitely expired from the cache on the client's\n\
    \   configured recursive resolver avoids this race condition and any\n   unnecessary\
    \ additional queries it causes.\n   Each time a client is about to reissue its\
    \ query to discover changes\n   to the answer RRset, it should first make a new\
    \ attempt to establish\n   a DNS Push Notification subscription using previously\
    \ cached DNS\n   answers as appropriate.  After a temporary misconfiguration has\
    \ been\n   remedied, this allows a client that is polling to return to using DNS\n\
    \   Push Notifications for asynchronous notification of changes.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The Strict Privacy profile for DNS over TLS is\
    \ REQUIRED for DNS Push\n   Notifications [RFC8310].  Cleartext connections for\
    \ DNS Push\n   Notifications are not permissible.  Since this is a new protocol,\n\
    \   transition mechanisms from the Opportunistic Privacy profile are\n   unnecessary.\n\
    \   Also, see Section 9 of the document Usage Profiles for DNS over\n   (D)TLS\
    \ [RFC8310] for additional recommendations for various versions\n   of TLS usage.\n\
    \   As a consequence of requiring TLS, client certificate authentication\n   and\
    \ verification may also be enforced by the server for stronger\n   client-server\
    \ security or end-to-end security.  However,\n   recommendations for security\
    \ in particular deployment scenarios are\n   outside the scope of this document.\n\
    \   DNSSEC is RECOMMENDED for the authentication of DNS Push Notification\n  \
    \ servers.  TLS alone does not provide complete security.  TLS\n   certificate\
    \ verification can provide reasonable assurance that the\n   client is really\
    \ talking to the server associated with the desired\n   host name, but since the\
    \ desired host name is learned via a DNS SRV\n   query, if the SRV query is subverted,\
    \ then the client may have a\n   secure connection to a rogue server.  DNSSEC\
    \ can provide added\n   confidence that the SRV query has not been subverted.\n"
- title: 7.1.  Security Services
  contents:
  - "7.1.  Security Services\n   It is the goal of using TLS to provide the following\
    \ security\n   services:\n   Confidentiality:  All application-layer communication\
    \ is encrypted\n      with the goal that no party should be able to decrypt it\
    \ except\n      the intended receiver.\n   Data integrity protection:  Any changes\
    \ made to the communication in\n      transit are detectable by the receiver.\n\
    \   Authentication:  An endpoint of the TLS communication is\n      authenticated\
    \ as the intended entity to communicate with.\n   Anti-replay protection:  TLS\
    \ provides for the detection of and\n      prevention against messages sent previously\
    \ over a TLS connection\n      (such as DNS Push Notifications).  If prior messages\
    \ are re-sent\n      at a later time as a form of a man-in-the-middle attack,\
    \ then the\n      receiver will detect this and reject the replayed messages.\n\
    \   Deployment recommendations on the appropriate key lengths and cipher\n   suites\
    \ are beyond the scope of this document.  Please refer to the\n   current TLS\
    \ Recommendations [BCP195] for the best current practices.\n   Keep in mind that\
    \ best practices only exist for a snapshot in time,\n   and recommendations will\
    \ continue to change.  Updated versions or\n   errata may exist for these recommendations.\n"
- title: 7.2.  TLS Name Authentication
  contents:
  - "7.2.  TLS Name Authentication\n   As described in Section 6.1, the client discovers\
    \ the DNS Push\n   Notification server using an SRV lookup for the record name\n\
    \   \"_dns-push-tls._tcp.<zone>\".  The server connection endpoint SHOULD\n  \
    \ then be authenticated using DANE TLSA records for the associated SRV\n   record.\
    \  This associates the target's name and port number with a\n   trusted TLS certificate\
    \ [RFC7673].  This procedure uses the TLS\n   Server Name Indication (SNI) extension\
    \ [RFC6066] to inform the server\n   of the name the client has authenticated\
    \ through the use of TLSA\n   records.  Therefore, if the SRV record passes DNSSEC\
    \ validation and a\n   TLSA record matching the target name is usable, an SNI\
    \ extension must\n   be used for the target name to ensure the client is connecting\
    \ to the\n   server it has authenticated.  If the target name does not have a\n\
    \   usable TLSA record, then the use of the SNI extension is optional.\n   See\
    \ Usage Profiles for DNS over TLS and DNS over DTLS [RFC8310] for\n   more information\
    \ on authenticating domain names.\n"
- title: 7.3.  TLS Early Data
  contents:
  - "7.3.  TLS Early Data\n   DSO messages with the SUBSCRIBE TLV as the Primary TLV\
    \ are permitted\n   in TLS early data.  Using TLS early data can save one network\
    \ round\n   trip and can result in the client obtaining results faster.\n   However,\
    \ there are some factors to consider before using TLS early\n   data.\n   TLS\
    \ early data is not forward secret.  In cases where forward secrecy\n   of DNS\
    \ Push Notification subscriptions is required, the client should\n   not use TLS\
    \ early data.\n   With TLS early data, there are no guarantees of non-replay between\n\
    \   connections.  If packets are duplicated and delayed in the network,\n   the\
    \ later arrivals could be mistaken for new subscription requests.\n   Generally,\
    \ this is not a major concern since the amount of state\n   generated on the server\
    \ for these spurious subscriptions is small and\n   short lived since the TCP\
    \ connection will not complete the three-way\n   handshake.  Servers MAY choose\
    \ to implement rate-limiting measures\n   that are activated when the server detects\
    \ an excessive number of\n   spurious subscription requests.\n   For further guidance\
    \ on use of TLS early data, please see discussion\n   of zero round-trip data\
    \ in Sections 2.3 and 8, and Appendix E.5, of\n   the TLS 1.3 specification [RFC8446].\n"
- title: 7.4.  TLS Session Resumption
  contents:
  - "7.4.  TLS Session Resumption\n   TLS session resumption [RFC8446] is permissible\
    \ on DNS Push\n   Notification servers.  However, closing the TLS connection terminates\n\
    \   the DSO session.  When the TLS session is resumed, the DNS Push\n   Notification\
    \ server will not have any subscription state and will\n   proceed as with any\
    \ other new DSO session.  Use of TLS session\n   resumption may allow a TLS connection\
    \ to be set up more quickly, but\n   the client will still have to recreate any\
    \ desired subscriptions.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document defines a new service name, only applicable\
    \ for the TCP\n   protocol, which has been recorded in the IANA \"Service Name\
    \ and\n   Transport Protocol Port Number Registry\" [RFC6335] [SRVTYPE].\n   \
    \  | Name                  | Port |        Value         | Section |\n     | DNS\
    \ Push Notification | None | \"_dns-push-tls._tcp\" |   6.1   |\n     | Service\
    \ Type          |      |                      |         |\n                  \
    \ Table 4: IANA Service Type Assignments\n   This document defines four new DNS\
    \ Stateful Operation TLV types,\n   which have been recorded in the IANA \"DSO\
    \ Type Codes\" registry\n   [RFC8490] [DSOTYPE].\n     | Name        | Value \
    \ | Early Data |      Status     | Section |\n     | SUBSCRIBE   | 0x0040 |  \
    \   OK     | Standards Track |   6.2   |\n     | PUSH        | 0x0041 |     NO\
    \     | Standards Track |   6.3   |\n     | UNSUBSCRIBE | 0x0042 |     NO    \
    \ | Standards Track |   6.4   |\n     | RECONFIRM   | 0x0043 |     NO     | Standards\
    \ Track |   6.5   |\n                Table 5: IANA DSO TLV Type Code Assignments\n\
    \   This document defines no new DNS OPCODEs or RCODEs.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [DSOTYPE]  IANA, \"Domain Name System (DNS) Parameters\"\
    ,\n              <https://www.iana.org/assignments/dns-parameters/>.\n   [RFC0020]\
    \  Cerf, V., \"ASCII format for network interchange\", STD 80,\n             \
    \ RFC 20, DOI 10.17487/RFC0020, October 1969,\n              <https://www.rfc-editor.org/info/rfc20>.\n\
    \   [RFC0768]  Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n     \
    \         DOI 10.17487/RFC0768, August 1980,\n              <https://www.rfc-editor.org/info/rfc768>.\n\
    \   [RFC0793]  Postel, J., \"Transmission Control Protocol\", STD 7,\n       \
    \       RFC 793, DOI 10.17487/RFC0793, September 1981,\n              <https://www.rfc-editor.org/info/rfc793>.\n\
    \   [RFC1034]  Mockapetris, P., \"Domain names - concepts and facilities\",\n\
    \              STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987,\n      \
    \        <https://www.rfc-editor.org/info/rfc1034>.\n   [RFC1035]  Mockapetris,\
    \ P., \"Domain names - implementation and\n              specification\", STD\
    \ 13, RFC 1035, DOI 10.17487/RFC1035,\n              November 1987, <https://www.rfc-editor.org/info/rfc1035>.\n\
    \   [RFC1123]  Braden, R., Ed., \"Requirements for Internet Hosts -\n        \
    \      Application and Support\", STD 3, RFC 1123,\n              DOI 10.17487/RFC1123,\
    \ October 1989,\n              <https://www.rfc-editor.org/info/rfc1123>.\n  \
    \ [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n          \
    \    Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2136]\
    \  Vixie, P., Ed., Thomson, S., Rekhter, Y., and J. Bound,\n              \"Dynamic\
    \ Updates in the Domain Name System (DNS UPDATE)\",\n              RFC 2136, DOI\
    \ 10.17487/RFC2136, April 1997,\n              <https://www.rfc-editor.org/info/rfc2136>.\n\
    \   [RFC2181]  Elz, R. and R. Bush, \"Clarifications to the DNS\n            \
    \  Specification\", RFC 2181, DOI 10.17487/RFC2181, July 1997,\n             \
    \ <https://www.rfc-editor.org/info/rfc2181>.\n   [RFC2782]  Gulbrandsen, A., Vixie,\
    \ P., and L. Esibov, \"A DNS RR for\n              specifying the location of\
    \ services (DNS SRV)\", RFC 2782,\n              DOI 10.17487/RFC2782, February\
    \ 2000,\n              <https://www.rfc-editor.org/info/rfc2782>.\n   [RFC6066]\
    \  Eastlake 3rd, D., \"Transport Layer Security (TLS)\n              Extensions:\
    \ Extension Definitions\", RFC 6066,\n              DOI 10.17487/RFC6066, January\
    \ 2011,\n              <https://www.rfc-editor.org/info/rfc6066>.\n   [RFC6335]\
    \  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.\n              Cheshire,\
    \ \"Internet Assigned Numbers Authority (IANA)\n              Procedures for the\
    \ Management of the Service Name and\n              Transport Protocol Port Number\
    \ Registry\", BCP 165,\n              RFC 6335, DOI 10.17487/RFC6335, August 2011,\n\
    \              <https://www.rfc-editor.org/info/rfc6335>.\n   [RFC6895]  Eastlake\
    \ 3rd, D., \"Domain Name System (DNS) IANA\n              Considerations\", BCP\
    \ 42, RFC 6895, DOI 10.17487/RFC6895,\n              April 2013, <https://www.rfc-editor.org/info/rfc6895>.\n\
    \   [RFC7673]  Finch, T., Miller, M., and P. Saint-Andre, \"Using DNS-\n     \
    \         Based Authentication of Named Entities (DANE) TLSA Records\n       \
    \       with SRV Records\", RFC 7673, DOI 10.17487/RFC7673, October\n        \
    \      2015, <https://www.rfc-editor.org/info/rfc7673>.\n   [RFC7766]  Dickinson,\
    \ J., Dickinson, S., Bellis, R., Mankin, A., and\n              D. Wessels, \"\
    DNS Transport over TCP - Implementation\n              Requirements\", RFC 7766,\
    \ DOI 10.17487/RFC7766, March 2016,\n              <https://www.rfc-editor.org/info/rfc7766>.\n\
    \   [RFC7858]  Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,\n    \
    \          and P. Hoffman, \"Specification for DNS over Transport\n          \
    \    Layer Security (TLS)\", RFC 7858, DOI 10.17487/RFC7858, May\n           \
    \   2016, <https://www.rfc-editor.org/info/rfc7858>.\n   [RFC8174]  Leiba, B.,\
    \ \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\"\
    , BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\
    \   [RFC8310]  Dickinson, S., Gillmor, D., and T. Reddy, \"Usage Profiles\n  \
    \            for DNS over TLS and DNS over DTLS\", RFC 8310,\n              DOI\
    \ 10.17487/RFC8310, March 2018,\n              <https://www.rfc-editor.org/info/rfc8310>.\n\
    \   [RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n \
    \             Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n  \
    \            <https://www.rfc-editor.org/info/rfc8446>.\n   [RFC8490]  Bellis,\
    \ R., Cheshire, S., Dickinson, J., Dickinson, S.,\n              Lemon, T., and\
    \ T. Pusateri, \"DNS Stateful Operations\",\n              RFC 8490, DOI 10.17487/RFC8490,\
    \ March 2019,\n              <https://www.rfc-editor.org/info/rfc8490>.\n   [SRVTYPE]\
    \  IANA, \"Service Name and Transport Protocol Port Number\n              Registry\"\
    , <https://www.iana.org/assignments/service-\n              names-port-numbers/>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [BCP195]   Sheffer, Y., Holz, R., and P. Saint-Andre,\n\
    \              \"Recommendations for Secure Use of Transport Layer\n         \
    \     Security (TLS) and Datagram Transport Layer Security\n              (DTLS)\"\
    , BCP 195, RFC 7525, May 2015,\n              <https://www.rfc-editor.org/info/bcp195>.\n\
    \   [OBS]      Wikipedia, \"Observer pattern\", February 2020,\n             \
    \ <https://en.wikipedia.org/w/\n              index.php?title=Observer_pattern&oldid=939702131>.\n\
    \   [RFC2308]  Andrews, M., \"Negative Caching of DNS Queries (DNS\n         \
    \     NCACHE)\", RFC 2308, DOI 10.17487/RFC2308, March 1998,\n              <https://www.rfc-editor.org/info/rfc2308>.\n\
    \   [RFC3123]  Koch, P., \"A DNS RR Type for Lists of Address Prefixes\n     \
    \         (APL RR)\", RFC 3123, DOI 10.17487/RFC3123, June 2001,\n           \
    \   <https://www.rfc-editor.org/info/rfc3123>.\n   [RFC4287]  Nottingham, M.,\
    \ Ed. and R. Sayre, Ed., \"The Atom\n              Syndication Format\", RFC 4287,\
    \ DOI 10.17487/RFC4287,\n              December 2005, <https://www.rfc-editor.org/info/rfc4287>.\n\
    \   [RFC4953]  Touch, J., \"Defending TCP Against Spoofing Attacks\",\n      \
    \        RFC 4953, DOI 10.17487/RFC4953, July 2007,\n              <https://www.rfc-editor.org/info/rfc4953>.\n\
    \   [RFC6281]  Cheshire, S., Zhu, Z., Wakikawa, R., and L. Zhang,\n          \
    \    \"Understanding Apple's Back to My Mac (BTMM) Service\",\n              RFC\
    \ 6281, DOI 10.17487/RFC6281, June 2011,\n              <https://www.rfc-editor.org/info/rfc6281>.\n\
    \   [RFC6762]  Cheshire, S. and M. Krochmal, \"Multicast DNS\", RFC 6762,\n  \
    \            DOI 10.17487/RFC6762, February 2013,\n              <https://www.rfc-editor.org/info/rfc6762>.\n\
    \   [RFC6763]  Cheshire, S. and M. Krochmal, \"DNS-Based Service\n           \
    \   Discovery\", RFC 6763, DOI 10.17487/RFC6763, February 2013,\n            \
    \  <https://www.rfc-editor.org/info/rfc6763>.\n   [RFC6886]  Cheshire, S. and\
    \ M. Krochmal, \"NAT Port Mapping Protocol\n              (NAT-PMP)\", RFC 6886,\
    \ DOI 10.17487/RFC6886, April 2013,\n              <https://www.rfc-editor.org/info/rfc6886>.\n\
    \   [RFC6887]  Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and\n  \
    \            P. Selkirk, \"Port Control Protocol (PCP)\", RFC 6887,\n        \
    \      DOI 10.17487/RFC6887, April 2013,\n              <https://www.rfc-editor.org/info/rfc6887>.\n\
    \   [RFC7413]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, \"TCP\n   \
    \           Fast Open\", RFC 7413, DOI 10.17487/RFC7413, December 2014,\n    \
    \          <https://www.rfc-editor.org/info/rfc7413>.\n   [RFC8010]  Sweet, M.\
    \ and I. McDonald, \"Internet Printing\n              Protocol/1.1: Encoding and\
    \ Transport\", STD 92, RFC 8010,\n              DOI 10.17487/RFC8010, January\
    \ 2017,\n              <https://www.rfc-editor.org/info/rfc8010>.\n   [RFC8011]\
    \  Sweet, M. and I. McDonald, \"Internet Printing\n              Protocol/1.1:\
    \ Model and Semantics\", STD 92, RFC 8011,\n              DOI 10.17487/RFC8011,\
    \ January 2017,\n              <https://www.rfc-editor.org/info/rfc8011>.\n  \
    \ [RFC8499]  Hoffman, P., Sullivan, A., and K. Fujiwara, \"DNS\n             \
    \ Terminology\", BCP 219, RFC 8499, DOI 10.17487/RFC8499,\n              January\
    \ 2019, <https://www.rfc-editor.org/info/rfc8499>.\n   [RFC8684]  Ford, A., Raiciu,\
    \ C., Handley, M., Bonaventure, O., and C.\n              Paasch, \"TCP Extensions\
    \ for Multipath Operation with\n              Multiple Addresses\", RFC 8684,\
    \ DOI 10.17487/RFC8684, March\n              2020, <https://www.rfc-editor.org/info/rfc8684>.\n\
    \   [RFC8764]  Cheshire, S. and M. Krochmal, \"Apple's DNS Long-Lived\n      \
    \        Queries Protocol\", RFC 8764, DOI 10.17487/RFC8764, June\n          \
    \    2020, <https://www.rfc-editor.org/info/rfc8764>.\n   [RFC8766]  Cheshire,\
    \ S., \"Discovery Proxy for Multicast DNS-Based\n              Service Discovery\"\
    , RFC 8766, DOI 10.17487/RFC8766, June\n              2020, <https://www.rfc-editor.org/info/rfc8766>.\n\
    \   [SD-API]   Apple Inc., \"dns_sd.h\",\n              <https://opensource.apple.com/source/mDNSResponder/\n\
    \              mDNSResponder-878.70.2/mDNSShared/dns_sd.h.auto.html>.\n   [SYN]\
    \      Eddy, W., \"Defenses Against TCP SYN Flooding Attacks\", The\n        \
    \      Internet Protocol Journal, Cisco Systems, Volume 9, Number\n          \
    \    4, December 2006,\n              <https://www.cisco.com/web/about/ac123/ac147/\n\
    \              archived_issues/ipj_9-4/ipj_9-4.pdf>.\n   [TCPRACK]  Cheng, Y.,\
    \ Cardwell, N., Dukkipati, N., and P. Jha, \"RACK:\n              a time-based\
    \ fast loss detection algorithm for TCP\", Work\n              in Progress, Internet-Draft,\
    \ draft-ietf-tcpm-rack-08, 9\n              March 2020,\n              <https://tools.ietf.org/html/draft-ietf-tcpm-rack-08>.\n\
    \   [XEP0060]  Millard, P., Saint-Andre, P., and R. Meijer, \"Publish-\n     \
    \         Subscribe\", XSF XEP 0060, October 2019,\n              <https://xmpp.org/extensions/xep-0060.html>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors would like to thank Kiren Sekar and Marc Krochmal\
    \ for\n   previous work completed in this field.\n   This document has been improved\
    \ due to comments from Ran Atkinson,\n   Tim Chown, Sara Dickinson, Mark Delany,\
    \ Ralph Droms, Jan Komissar,\n   Eric Rescorla, Michael Richardson, David Schinazi,\
    \ Manju Shankar Rao,\n   Robert Sparks, Markus Stenberg, Andrew Sullivan, Michael\
    \ Sweet, Dave\n   Thaler, Brian Trammell, Bernie Volz, \xC9ric Vyncke, Christopher\
    \ Wood,\n   Liang Xia, and Soraia Zlatkovic.  Ted Lemon provided clarifying text\n\
    \   that was greatly appreciated.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tom Pusateri\n   Unaffiliated\n   Raleigh, NC 27608\n\
    \   United States of America\n   Phone: +1 919 867 1330\n   Email: pusateri@bangj.com\n\
    \   Stuart Cheshire\n   Apple Inc.\n   One Apple Park Way\n   Cupertino, CA 95014\n\
    \   United States of America\n"
