- title: __initial_text__
  contents:
  - '             Layered Coding Transport (LCT) Building Block

    '
- title: Abstract
  contents:
  - "Abstract\n   The Layered Coding Transport (LCT) Building Block provides transport\n\
    \   level support for reliable content delivery and stream delivery\n   protocols.\
    \  LCT is specifically designed to support protocols using\n   IP multicast, but\
    \ it also provides support to protocols that use\n   unicast.  LCT is compatible\
    \ with congestion control that provides\n   multiple rate delivery to receivers\
    \ and is also compatible with\n   coding techniques that provide reliable delivery\
    \ of content.  This\n   document obsoletes RFC 3451.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the BSD License.\n   This document may\
    \ contain material from IETF Documents or IETF\n   Contributions published or\
    \ made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Rationale .......................................................3\n  \
    \ 3. Functionality ...................................................4\n   4.\
    \ Applicability ...................................................7\n      4.1.\
    \ Environmental Requirements and Considerations ..............9\n      4.2. Delivery\
    \ Service Models ...................................10\n      4.3. Congestion\
    \ Control ........................................13\n   5. Packet Header Fields\
    \ ...........................................13\n      5.1. LCT Header Format\
    \ .........................................13\n      5.2. Header-Extension Fields\
    \ ...................................18\n           5.2.1. General ............................................18\n\
    \           5.2.2. EXT_TIME Header Extension ..........................20\n  \
    \ 6. Operations .....................................................23\n    \
    \  6.1. Sender Operation ..........................................23\n      6.2.\
    \ Receiver Operation ........................................25\n   7. Requirements\
    \ from Other Building Blocks ........................26\n   8. Security Considerations\
    \ ........................................28\n      8.1. Session and Object Multiplexing\
    \ and Termination ...........28\n      8.2. Time Synchronization ......................................29\n\
    \      8.3. Data Transport ............................................29\n  \
    \ 9. IANA Considerations ............................................29\n    \
    \  9.1. Namespace Declaration for LCT Header Extension Types ......29\n      9.2.\
    \ LCT Header Extension Type Registration ....................30\n   10. Acknowledgments\
    \ ...............................................30\n   11. Changes from RFC 3451\
    \ .........................................31\n   12. References ....................................................31\n\
    \      12.1. Normative References .....................................31\n  \
    \    12.2. Informative References ...................................32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Layered Coding Transport (LCT) provides transport level\
    \ support for\n   reliable content delivery and stream delivery protocols.  Layered\n\
    \   Coding Transport is specifically designed to support protocols using\n   IP\
    \ multicast, but it also provides support to protocols that use\n   unicast. \
    \ Layered Coding Transport is compatible with congestion\n   control that provides\
    \ multiple rate delivery to receivers and is also\n   compatible with coding techniques\
    \ that provide reliable delivery of\n   content.\n   This document describes a\
    \ building block as defined in [RFC3048].\n   This document is a product of the\
    \ IETF RMT WG and follows the general\n   guidelines provided in [RFC3269].\n\
    \   [RFC3451], which was published in the \"Experimental\" category and\n   which\
    \ is obsoleted by this document, contained a previous version of\n   the protocol.\n\
    \   This Proposed Standard specification is thus based on and backwards\n   compatible\
    \ with the protocol defined in [RFC3451] updated according\n   to accumulated\
    \ experience and growing protocol maturity since its\n   original publication.\
    \  Said experience applies both to this\n   specification itself and to congestion\
    \ control strategies related to\n   the use of this specification.\n   The key\
    \ words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"\
    SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n\
    \   document are to be interpreted as described in [RFC2119].\n"
- title: 2.  Rationale
  contents:
  - "2.  Rationale\n   LCT provides transport level support for massively scalable\
    \ protocols\n   using the IP multicast network service.  The support that LCT\n\
    \   provides is common to a variety of very important applications,\n   including\
    \ reliable content delivery and streaming applications.\n   An LCT session comprises\
    \ multiple channels originating at a single\n   sender that are used for some\
    \ period of time to carry packets\n   pertaining to the transmission of one or\
    \ more objects that can be of\n   interest to receivers.  The logic behind defining\
    \ a session as\n   originating from a single sender is that this is the right\n\
    \   granularity to regulate packet traffic via congestion control.  One\n   rationale\
    \ for using multiple channels within the same session is that\n   there are massively\
    \ scalable congestion control protocols that use\n   multiple channels per session.\
    \  These congestion control protocols\n   are considered to be layered because\
    \ a receiver joins and leaves\n   channels in a layered order during its participation\
    \ in the session.\n   The use of layered channels is also useful for streaming\n\
    \   applications.\n   There are coding techniques that provide massively scalable\n\
    \   reliability and asynchronous delivery that are compatible with both\n   layered\
    \ congestion control and with LCT.  When all are combined, the\n   result is a\
    \ massively scalable reliable asynchronous content delivery\n   protocol that\
    \ is network friendly.  LCT also provides functionality\n   that can be used for\
    \ other applications as well, e.g., layered\n   streaming applications.\n   LCT\
    \ avoids providing functionality that is not massively scalable.\n   For example,\
    \ LCT does not provide any mechanisms for sending\n   information from receivers\
    \ to senders, although this does not rule\n   out protocols that both use LCT\
    \ and do require sending information\n   from receivers to senders.\n   LCT includes\
    \ general support for congestion control that must be\n   used.  It does not,\
    \ however, specify which congestion control should\n   be used.  The rationale\
    \ for this is that congestion control must be\n   provided by any protocol that\
    \ is network friendly, and yet the\n   different applications that can use LCT\
    \ will not have the same\n   requirements for congestion control.  For example,\
    \ a content delivery\n   protocol may strive to use all available bandwidth between\
    \ receivers\n   and the sender.  It must, therefore, drastically back off its\
    \ rate\n   when there is competing traffic.  On the other hand, a streaming\n\
    \   delivery protocol may strive to maintain a constant rate instead of\n   trying\
    \ to use all available bandwidth, and it may not back off its\n   rate as fast\
    \ when there is competing traffic.\n   Beyond support for congestion control,\
    \ LCT provides a number of\n   fields and supports functionality commonly required\
    \ by many\n   protocols.  For example, LCT provides a Transmission Session ID\
    \ that\n   can be used to identify to which session each received packet\n   belongs.\
    \  This is important because a receiver may be joined to many\n   sessions concurrently,\
    \ and thus it is very useful to be able to\n   demultiplex packets as they arrive\
    \ according to the session to which\n   they belong.  As another example, there\
    \ are optional fields within\n   the LCT packet header for identifying the object\
    \ about which\n   information is carried in the packet payload.\n"
- title: 3.  Functionality
  contents:
  - "3.  Functionality\n   An LCT session consists of a set of logically grouped LCT\
    \ channels\n   associated with a single sender carrying packets with LCT headers\
    \ for\n   one or more objects.  An LCT channel is defined by the combination of\n\
    \   a sender and an address associated with the channel by the sender.  A\n  \
    \ receiver joins a channel to start receiving the data packets sent to\n   the\
    \ channel by the sender, and a receiver leaves a channel to stop\n   receiving\
    \ data packets from the channel.\n   LCT is meant to be combined with other building\
    \ blocks so that the\n   resulting overall protocol is massively scalable.  Scalability\
    \ refers\n   to the behavior of the protocol in relation to the number of\n  \
    \ receivers and network paths, their heterogeneity, and the ability to\n   accommodate\
    \ dynamically variable sets of receivers.  Scalability\n   limitations can come\
    \ from memory or processing requirements, or from\n   the amount of feedback control\
    \ and redundant data packet traffic\n   generated by the protocol.  In turn, such\
    \ limitations may be a\n   consequence of the features that a complete reliable\
    \ content delivery\n   or stream delivery protocol is expected to provide.\n \
    \  The LCT header provides a number of fields that are useful for\n   conveying\
    \ in-band session information to receivers.  One of the\n   required fields is\
    \ the Transmission Session ID (TSI), which allows\n   the receiver of a session\
    \ to uniquely identify received packets as\n   part of the session.  Another required\
    \ field is the Congestion\n   Control Information (CCI), which allows the receiver\
    \ to perform the\n   required congestion control on the packets received within\
    \ the\n   session.  Other LCT fields provide optional but often very useful\n\
    \   additional information for the session.  For example, the Transport\n   Object\
    \ Identifier (TOI) identifies for which object the packet\n   contains data and\
    \ flags are included for indicating the close of the\n   session and the close\
    \ of sending packets for an object.  Header\n   extensions can carry additional\
    \ fields that, for example, can be used\n   for packet authentication or to convey\
    \ various kinds of timing\n   information: the Sender Current Time (SCT) conveys\
    \ the time when the\n   packet was sent from the sender to the receiver, the Expected\n\
    \   Residual Time (ERT) conveys the amount of time the session or\n   transmission\
    \ object will be continued for, and Session Last Change\n   (SLC) conveys the\
    \ time when objects have been added, modified, or\n   removed from the session.\n\
    \   LCT provides support for congestion control.  Congestion control MUST\n  \
    \ be used that conforms to [RFC2357] between receivers and the sender\n   for\
    \ each LCT session.  Congestion control refers to the ability to\n   adapt throughput\
    \ to the available bandwidth on the path from the\n   sender to a receiver, and\
    \ to share bandwidth fairly with competing\n   flows such as TCP.  Thus, the total\
    \ flow of packets flowing to each\n   receiver participating in an LCT session\
    \ MUST NOT compete unfairly\n   with existing flow-adaptive protocols such as\
    \ TCP.\n   A multiple rate or a single rate congestion control protocol can be\n\
    \   used with LCT.  For multiple rate protocols, a session typically\n   consists\
    \ of more than one channel, and the sender sends packets to\n   the channels in\
    \ the session at rates that do not depend on the\n   receivers.  Each receiver\
    \ adjusts its reception rate during its\n   participation in the session by joining\
    \ and leaving channels\n   dynamically depending on the available bandwidth to\
    \ the sender\n   independent of all other receivers.  Thus, for multiple rate\n\
    \   protocols, the reception rate of each receiver may vary dynamically\n   independent\
    \ of the other receivers.\n   For single rate protocols, a session typically consists\
    \ of one\n   channel and the sender sends packets to the channel at variable rates\n\
    \   over time depending on feedback from receivers.  Each receiver\n   remains\
    \ joined to the channel during its participation in the\n   session.  Thus, for\
    \ single rate protocols, the reception rate of each\n   receiver may vary dynamically\
    \ but in coordination with all receivers.\n   Generally, a multiple rate protocol\
    \ is preferable to a single rate\n   protocol in a heterogeneous receiver environment,\
    \ since generally it\n   more easily achieves scalability to many receivers and\
    \ provides\n   higher throughput to each individual receiver.  Use of the multiple\n\
    \   rate congestion control scheme defined in [RFC3738] is RECOMMENDED.\n   Alternative\
    \ multiple rate congestion control protocols are described\n   in [VIC1998] and\
    \ [BYE2000].  A possible single rate congestion\n   control protocol is described\
    \ in [RIZ2000].\n   Layered coding refers to the ability to produce a coded stream\
    \ of\n   packets that can be partitioned into an ordered set of layers.  The\n\
    \   coding is meant to provide some form of reliability, and the layering\n  \
    \ is meant to allow the receiver experience (in terms of quality of\n   playout,\
    \ or overall transfer speed) to vary in a predictable way\n   depending on how\
    \ many consecutive layers of packets the receiver is\n   receiving.\n   The concept\
    \ of layered coding was first introduced with reference to\n   audio and video\
    \ streams.  For example, the information associated\n   with a TV broadcast could\
    \ be partitioned into three layers,\n   corresponding to black and white, color,\
    \ and HDTV quality.  Receivers\n   can experience different quality without the\
    \ need for the sender to\n   replicate information in the different layers.\n\
    \   The concept of layered coding can be naturally extended to reliable\n   content\
    \ delivery protocols when Forward Error Correction (FEC)\n   techniques are used\
    \ for coding the data stream.  Descriptions of this\n   can be found in [RIZ1997a],\
    \ [RIZ1997b], [GEM2000], [VIC1998], and\n   [BYE1998].  By using FEC, the data\
    \ stream is transformed in such a\n   way that reconstruction of a data object\
    \ does not depend on the\n   reception of specific data packets, but only on the\
    \ number of\n   different packets received.  As a result, by increasing the number\
    \ of\n   layers from which a receiver is receiving, the receiver can reduce\n\
    \   the transfer time accordingly.  Using FEC to provide reliability can\n   increase\
    \ scalability dramatically in comparison to other methods for\n   providing reliability.\
    \  More details on the use of FEC for reliable\n   content delivery can be found\
    \ in [RFC3453].\n   Reliable protocols aim at giving guarantees on the reliable\
    \ delivery\n   of data from the sender to the intended recipients.  Guarantees\
    \ vary\n   from simple packet data integrity to reliable delivery of a precise\n\
    \   copy of an object to all intended recipients.  Several reliable\n   content\
    \ delivery protocols have been built on top of IP multicast\n   using methods\
    \ other than FEC, but scalability was not the primary\n   design goal for many\
    \ of them.\n   Two of the key difficulties in scaling reliable content delivery\n\
    \   using IP multicast are dealing with the amount of data that flows\n   from\
    \ receivers back to the sender and the associated response\n   (generally data\
    \ retransmissions) from the sender.  Protocols that\n   avoid any such feedback,\
    \ and minimize the amount of retransmissions,\n   can be massively scalable. \
    \ LCT can be used in conjunction with FEC\n   codes or a layered codec to achieve\
    \ reliability with little or no\n   feedback.\n   Protocol instantiations (PIs)\
    \ MAY be built by combining the LCT\n   framework with other components.  A complete\
    \ protocol instantiation\n   that uses LCT MUST include a congestion control protocol\
    \ that is\n   compatible with LCT and that conforms to [RFC2357].  A complete\n\
    \   protocol instantiation that uses LCT MAY include a scalable\n   reliability\
    \ protocol that is compatible with LCT, it MAY include a\n   session control protocol\
    \ that is compatible with LCT, and it MAY\n   include other protocols such as\
    \ security protocols.\n"
- title: 4.  Applicability
  contents:
  - "4.  Applicability\n   An LCT session comprises a logically related set of one\
    \ or more LCT\n   channels originating at a single sender.  The channels are used\
    \ for\n   some period of time to carry packets containing LCT headers, and\n \
    \  these headers pertain to the transmission of one or more objects that\n   can\
    \ be of interest to receivers.\n   LCT is most applicable for delivery of objects\
    \ or streams in a\n   session of substantial length, i.e., objects or streams\
    \ that range in\n   aggregate length from hundreds of kilobytes to many gigabytes,\
    \ and\n   where the duration of the session is on the order of tens of seconds\n\
    \   or more.\n   As an example, an LCT session could be used to deliver a TV program\n\
    \   using three LCT channels.  Receiving packets from the first LCT\n   channel\
    \ could allow black and white reception.  Receiving the first\n   two LCT channels\
    \ could also permit color reception.  Receiving all\n   three channels could allow\
    \ HDTV quality reception.  Objects in this\n   example could correspond to individual\
    \ TV programs being transmitted.\n   As another example, a reliable LCT session\
    \ could be used to reliably\n   deliver hourly updated weather maps (objects)\
    \ using ten LCT channels\n   at different rates, using FEC coding.  A receiver\
    \ may join and\n   concurrently receive packets from subsets of these channels,\
    \ until it\n   has enough packets in total to recover the object, then leave the\n\
    \   session (or remain connected listening for session description\n   information\
    \ only) until it is time to receive the next object.  In\n   this case, the quality\
    \ metric is the time required to receive each\n   object.\n   Before joining a\
    \ session, the receivers must obtain enough of the\n   session description to\
    \ start the session.  This includes the relevant\n   session parameters needed\
    \ by a receiver to participate in the\n   session, including all information relevant\
    \ to congestion control.\n   The session description is determined by the sender,\
    \ and is typically\n   communicated to the receivers out-of-band.  In some cases,\
    \ as\n   described later, parts of the session description that are not\n   required\
    \ to initiate a session MAY be included in the LCT header or\n   communicated\
    \ to a receiver out-of-band after the receiver has joined\n   the session.\n \
    \  An encoder MAY be used to generate the data that is placed in the\n   packet\
    \ payload in order to provide reliability.  A suitable decoder\n   is used to\
    \ reproduce the original information from the packet\n   payload.  There MAY be\
    \ a reliability header that follows the LCT\n   header if such an encoder and\
    \ decoder is used.  The reliability\n   header helps to describe the encoding\
    \ data carried in the payload of\n   the packet.  The format of the reliability\
    \ header depends on the\n   coding used, and this is negotiated out-of-band. \
    \ As an example, one\n   of the FEC headers described in [RFC5052] could be used.\n\
    \   For LCT, when multiple rate congestion control is used, congestion\n   control\
    \ is achieved by sending packets associated with a given\n   session to several\
    \ LCT channels.  Individual receivers dynamically\n   join one or more of these\
    \ channels, according to the network\n   congestion as seen by the receiver. \
    \ LCT headers include an opaque\n   field that MUST be used to convey congestion\
    \ control information to\n   the receivers.  The actual congestion control scheme\
    \ to use with LCT\n   is negotiated out-of-band.  Some examples of congestion\
    \ control\n   protocols that may be suitable for content delivery are described\
    \ in\n   [VIC1998], [BYE2000], and [RFC3738].  Other congestion controls may\n\
    \   be suitable when LCT is used for a streaming application.\n   This document\
    \ does not specify and restrict the type of exchanges\n   between LCT (or any\
    \ protocol instantiation built on top of LCT) and\n   an upper application.  Some\
    \ upper APIs may use an object-oriented\n   approach, where the only possible\
    \ unit of data exchanged between LCT\n   (or any protocol instantiation built\
    \ on top of LCT) and an\n   application, either at a source or at a receiver,\
    \ is an object.\n   Other APIs may enable a sending or receiving application to\
    \ exchange\n   a subset of an object with LCT (or any PI built on top of LCT),\
    \ or\n   may even follow a streaming model.  These considerations are outside\n\
    \   the scope of this document.\n"
- title: 4.1.  Environmental Requirements and Considerations
  contents:
  - "4.1.  Environmental Requirements and Considerations\n   LCT is intended for congestion\
    \ controlled delivery of objects and\n   streams (both reliable content delivery\
    \ and streaming of multimedia\n   information).\n   LCT can be used with both\
    \ multicast and unicast delivery.  LCT\n   requires connectivity between a sender\
    \ and receivers, but it does not\n   require connectivity from receivers to a\
    \ sender.  LCT inherently\n   works with all types of networks, including LANs,\
    \ WANs, Intranets,\n   the Internet, asymmetric networks, wireless networks, and\
    \ satellite\n   networks.  Thus, the inherent raw scalability of LCT is unlimited.\n\
    \   However, when other specific applications are built on top of LCT,\n   then\
    \ these applications, by their very nature, may limit scalability.\n   For example,\
    \ if an application requires receivers to retrieve out-of-\n   band information\
    \ in order to join a session, or an application allows\n   receivers to send requests\
    \ back to the sender to report reception\n   statistics, then the scalability\
    \ of the application is limited by the\n   ability to send, receive, and process\
    \ this additional data.\n   LCT requires receivers to be able to uniquely identify\
    \ and\n   demultiplex packets associated with an LCT session.  In particular,\n\
    \   there MUST be a Transport Session Identifier (TSI) associated with\n   each\
    \ LCT session.  The TSI is scoped by the IP address of the sender,\n   and the\
    \ IP address of the sender together with the TSI MUST uniquely\n   identify the\
    \ session.  If the underlying transport is UDP, as\n   described in [RFC0768],\
    \ then the 16-bit UDP source port number MAY\n   serve as the TSI for the session.\
    \  The TSI value MUST be the same in\n   all places it occurs within a packet.\
    \  If there is no underlying TSI\n   provided by the network, transport, or any\
    \ other layer, then the TSI\n   MUST be included in the LCT header.\n   LCT is\
    \ presumed to be used with an underlying network or transport\n   service that\
    \ is a \"best effort\" service that does not guarantee\n   packet reception or\
    \ packet reception order, and that does not have\n   any support for flow or congestion\
    \ control.  For example, the Any-\n   Source Multicast (ASM) model of IP multicast\
    \ as defined in [RFC1112]\n   is such a \"best effort\" network service.  While\
    \ the basic service\n   provided by [RFC1112] is largely scalable, providing congestion\n\
    \   control or reliability should be done carefully to avoid severe\n   scalability\
    \ limitations, especially in the presence of heterogeneous\n   sets of receivers.\n\
    \   There are currently two models of multicast delivery, the Any-Source\n   Multicast\
    \ (ASM) model as defined in [RFC1112] and the Source-Specific\n   Multicast (SSM)\
    \ model as defined in [RFC4607].  LCT works with both\n   multicast models, but\
    \ in a slightly different way with somewhat\n   different environmental concerns.\
    \  When using ASM, a sender S sends\n   packets to a multicast group G, and the\
    \ LCT channel address consists\n   of the pair (S,G), where S is the IP address\
    \ of the sender and G is a\n   multicast group address.  When using SSM, a sender\
    \ S sends packets to\n   an SSM channel (S,G), and the LCT channel address coincides\
    \ with the\n   SSM channel address.\n   A sender can locally allocate unique SSM\
    \ channel addresses, and this\n   makes allocation of LCT channel addresses easy\
    \ with SSM.  To allocate\n   LCT channel addresses using ASM, the sender must\
    \ uniquely chose the\n   ASM multicast group address across the scope of the group,\
    \ and this\n   makes allocation of LCT channel addresses more difficult with ASM.\n\
    \   LCT channels and SSM channels coincide, and thus the receiver will\n   only\
    \ receive packets sent to the requested LCT channel.  With ASM,\n   the receiver\
    \ joins an LCT channel by joining a multicast group G, and\n   all packets sent\
    \ to G, regardless of the sender, may be received by\n   the receiver.  Thus,\
    \ SSM has compelling security advantages over ASM\n   for prevention of denial-of-service\
    \ (DoS) attacks.  In either case,\n   receivers SHOULD use packet authentication\
    \ mechanisms to mitigate\n   such attacks (see Sections 6.2 and 7).\n   Some networks\
    \ are not amenable to some congestion control protocols\n   that could be used\
    \ with LCT.  In particular, for a satellite or\n   wireless network, there may\
    \ be no mechanism for receivers to\n   effectively reduce their reception rate\
    \ since there may be a fixed\n   transmission rate allocated to the session.\n\
    \   LCT is compatible with both IPv4 and IPv6 as no part of the packet is\n  \
    \ IP version specific.\n"
- title: 4.2.  Delivery Service Models
  contents:
  - "4.2.  Delivery Service Models\n   LCT can support several different delivery\
    \ service models.  Two\n   examples are briefly described here.\n   Push service\
    \ model\n      One way a push service model can be used for reliable content\n\
    \      delivery is to deliver a series of objects.  For example, a\n      receiver\
    \ could join the session and dynamically adapt the number\n      of LCT channels\
    \ the receiver is joined to until enough packets\n      have been received to\
    \ reconstruct an object.  After reconstructing\n      the object, the receiver\
    \ may stay in the session and wait for the\n      transmission of the next object.\n\
    \      The push model is particularly attractive in satellite networks\n     \
    \ and wireless networks.  In these cases, a session may consist of\n      one\
    \ fixed rate LCT channel.\n      A push service model can be used, for example,\
    \ for reliable\n      delivery of a large object such as a 100 GB file.  The sender\n\
    \      could send a Session Description announcement to a control channel\n  \
    \    and receivers could monitor this channel and join a session\n      whenever\
    \ a Session Description of interest arrives.  Upon receipt\n      of the Session\
    \ Description, each receiver could join the session\n      to receive packets\
    \ until enough packets have arrived to\n      reconstruct the object, at which\
    \ point the receiver could report\n      back to the sender that its reception\
    \ was completed successfully.\n      The sender could decide to continue sending\
    \ packets for the object\n      to the session until all receivers have reported\
    \ successful\n      reconstruction or until some other condition has been satisfied.\n\
    \      There are several features Asynchronous Layered Coding (ALC)\n      provides\
    \ to support the push model.  For example, the sender can\n      optionally include\
    \ an Expected Residual Time (ERT) in the packet\n      header extension that indicates\
    \ the expected remaining time of\n      packet transmission for either the single\
    \ object carried in the\n      session or for the object identified by the Transmission\
    \ Object\n      Identifier (TOI) if there are multiple objects carried in the\n\
    \      session.  This can be used by receivers to determine if there is\n    \
    \  enough time remaining in the session to successfully receive\n      enough\
    \ additional packets to recover the object.  If, for example,\n      there is\
    \ not enough time, then the push application may have\n      receivers report\
    \ back to the sender to extend the transmission of\n      packets for the object\
    \ for enough time to allow the receivers to\n      obtain enough packets to reconstruct\
    \ the object.  The sender could\n      then include an ERT based on the extended\
    \ object transmission time\n      in each subsequent packet header for the object.\
    \  As other\n      examples, the LCT header optionally can contain a Close Session\n\
    \      flag that indicates when the sender is about to stop sending\n      packets\
    \ to the session and a Close Object flag that indicates when\n      the sender\
    \ is about to stop sending packets to the session for the\n      object identified\
    \ by the Transmission Object ID.  However, these\n      flags are not a completely\
    \ reliable mechanism and thus the Close\n      Session flag should only be used\
    \ as a hint of when the session is\n      about to close, and the Close Object\
    \ flag should only be used as a\n      hint of when transmission of packets for\
    \ the object is about to\n      end.\n   On-demand content delivery model\n  \
    \    For an on-demand content delivery service model, senders typically\n    \
    \  transmit for some given time period selected to be long enough to\n      allow\
    \ all the intended receivers to join the session and recover\n      the object.\
    \  For example, a popular software update might be\n      transmitted using LCT\
    \ for several days, even though a receiver may\n      be able to complete the\
    \ download in one hour total of connection\n      time, perhaps spread over several\
    \ intervals of time.  In this\n      case, the receivers join the session at any\
    \ point in time when it\n      is active.  Receivers leave the session when they\
    \ have received\n      enough packets to recover the object.  The receivers, for\
    \ example,\n      obtain a Session Description by contacting a web server.\n \
    \     In this case, the receivers join the session, and dynamically\n      adapt\
    \ the number of LCT channels to which they subscribe according\n      to the available\
    \ bandwidth.  Receivers then drop from the session\n      when they have received\
    \ enough packets to recover the object.\n      As an example, assume that an object\
    \ is 50 MB.  The sender could\n      send 1 KB packets to the first LCT channel\
    \ at 50 packets per\n      second, so that receivers using just this LCT channel\
    \ could\n      complete reception of the object in 1,000 seconds in absence of\n\
    \      loss, and would be able to complete reception even in presence of\n   \
    \   some substantial amount of losses with the use of coding for\n      reliability.\
    \  Furthermore, the sender could use a number of LCT\n      channels such that\
    \ the aggregate rate of 1 KB packets to all LCT\n      channels is 1,000 packets\
    \ per second, so that a receiver could be\n      able to complete reception of\
    \ the object in as little 50 seconds\n      (assuming no loss and that the congestion\
    \ control mechanism\n      immediately converges to the use of all LCT channels).\n\
    \   Other service models\n      There are many other delivery service models for\
    \ which LCT can be\n      used that are not covered above.  As examples, a live\
    \ streaming or\n      an on-demand archival content streaming service model. \
    \ A\n      description of the many potential applications, the appropriate\n \
    \     delivery service model, and the additional mechanisms to support\n     \
    \ such functionalities when combined with LCT is beyond the scope of\n      this\
    \ document.  This document only attempts to describe the\n      minimal common\
    \ scalable elements to these diverse applications\n      using LCT as the delivery\
    \ transport.\n"
- title: 4.3.  Congestion Control
  contents:
  - "4.3.  Congestion Control\n   The specific congestion control protocol to be used\
    \ for LCT sessions\n   depends on the type of content to be delivered.  While\
    \ the general\n   behavior of the congestion control protocol is to reduce the\n\
    \   throughput in presence of congestion and gradually increase it in the\n  \
    \ absence of congestion, the actual dynamic behavior (e.g., response to\n   single\
    \ losses) can vary.\n   It is RECOMMENDED that the congestion control mechanism\
    \ specified in\n   [RFC3738] be used.  Some alternative possible congestion control\n\
    \   protocols for reliable content delivery using LCT are described in\n   [VIC1998]\
    \ and [BYE2000].  Different delivery service models might\n   require different\
    \ congestion control protocols.\n"
- title: 5.  Packet Header Fields
  contents:
  - "5.  Packet Header Fields\n   Packets sent to an LCT session MUST include an \"\
    LCT header\".  The LCT\n   header format is described below.\n   Other building\
    \ blocks MAY describe some of the same fields as\n   described for the LCT header.\
    \  It is RECOMMENDED that protocol\n   instantiations using multiple building\
    \ blocks include shared fields\n   at most once in each packet.  Thus, for example,\
    \ if another building\n   block is used with LCT that includes the optional Expected\
    \ Residual\n   Time field, then the Expected Residual Time field SHOULD be carried\n\
    \   in each packet at most once.\n   The position of the LCT header within a packet\
    \ MUST be specified by\n   any protocol instantiation that uses LCT.\n"
- title: 5.1.  LCT Header Format
  contents:
  - "5.1.  LCT Header Format\n   The LCT header is of variable size, which is specified\
    \ by a length\n   field in the third byte of the header.  In the LCT header, all\n\
    \   integer fields are carried in \"big-endian\" or \"network order\" format,\n\
    \   that is, most significant byte (octet) first.  Bits designated as\n   \"padding\"\
    \ or \"reserved\" (r) MUST by set to 0 by senders and ignored\n   by receivers\
    \ in this version of the specification.  Unless otherwise\n   noted, numeric constants\
    \ in this specification are in decimal form\n   (base 10).\n   The format of the\
    \ default LCT header is depicted in Figure 1.\n        0                   1 \
    \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |   V   | C |PSI|S| O |H|Res|A|B|   HDR_LEN     | Codepoint (CP)|\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   | Congestion Control Information (CCI, length = 32*(C+1) bits)  |\n      \
    \ |                          ...                                  |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  Transport Session Identifier (TSI, length = 32*S+16*H bits)  |\n  \
    \     |                          ...                                  |\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ |   Transport Object Identifier (TOI, length = 32*O+16*H bits)  |\n       |\
    \                          ...                                  |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                Header Extensions (if applicable)              |\n  \
    \     |                          ...                                  |\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \              Figure 1: Default LCT Header Format\n   The function and length\
    \ of each field in the default LCT header is\n   the following.\n   LCT version\
    \ number (V): 4 bits\n      Indicates the LCT version number.  The LCT version\
    \ number for this\n      specification is 1.\n   Congestion control flag (C):\
    \ 2 bits\n      C=0 indicates the Congestion Control Information (CCI) field is\
    \ 32\n      bits in length.  C=1 indicates the CCI field is 64 bits in length.\n\
    \      C=2 indicates the CCI field is 96 bits in length.  C=3 indicates\n    \
    \  the CCI field is 128 bits in length.\n   Protocol-Specific Indication (PSI):\
    \ 2 bits\n      The usage of these bits, if any, is specific to each protocol\n\
    \      instantiation that uses the LCT building block.  If no protocol-\n    \
    \  instantiation-specific usage of these bits is defined, then a\n      sender\
    \ MUST set them to zero and a receiver MUST ignore these\n      bits.\n   Transport\
    \ Session Identifier flag (S): 1 bit\n      This is the number of full 32-bit\
    \ words in the TSI field.  The TSI\n      field is 32*S + 16*H bits in length,\
    \ i.e., the length is either 0\n      bits, 16 bits, 32 bits, or 48 bits.\n  \
    \ Transport Object Identifier flag (O): 2 bits\n      This is the number of full\
    \ 32-bit words in the TOI field.  The TOI\n      field is 32*O + 16*H bits in\
    \ length, i.e., the length is either 0\n      bits, 16 bits, 32 bits, 48 bits,\
    \ 64 bits, 80 bits, 96 bits, or 112\n      bits.\n   Half-word flag (H): 1 bit\n\
    \      The TSI and the TOI fields are both multiples of 32 bits plus 16*H\n  \
    \    bits in length.  This allows the TSI and TOI field lengths to be\n      multiples\
    \ of a half-word (16 bits), while ensuring that the\n      aggregate length of\
    \ the TSI and TOI fields is a multiple of 32\n      bits.\n   Reserved (Res):\
    \ 2 bits\n      These bits are reserved.  In this version of the specification,\n\
    \      they MUST be set to zero by senders and MUST be ignored by\n      receivers.\n\
    \   Close Session flag (A): 1 bit\n      Normally, A is set to 0.  The sender\
    \ MAY set A to 1 when\n      termination of transmission of packets for the session\
    \ is\n      imminent.  A MAY be set to 1 in just the last packet transmitted\n\
    \      for the session, or A MAY be set to 1 in the last few seconds of\n    \
    \  packets transmitted for the session.  Once the sender sets A to 1\n      in\
    \ one packet, the sender SHOULD set A to 1 in all subsequent\n      packets until\
    \ termination of transmission of packets for the\n      session.  A received packet\
    \ with A set to 1 indicates to a\n      receiver that the sender will immediately\
    \ stop sending packets for\n      the session.  When a receiver receives a packet\
    \ with A set to 1,\n      the receiver SHOULD assume that no more packets will\
    \ be sent to\n      the session.\n   Close Object flag (B): 1 bit\n      Normally,\
    \ B is set to 0.  The sender MAY set B to 1 when\n      termination of transmission\
    \ of packets for an object is imminent.\n      If the TOI field is in use and\
    \ B is set to 1, then termination of\n      transmission for the object identified\
    \ by the TOI field is\n      imminent.  If the TOI field is not in use and B is\
    \ set to 1, then\n      termination of transmission for the one object in the\
    \ session\n      identified by out-of-band information is imminent.  B MAY be\
    \ set\n      to 1 in just the last packet transmitted for the object, or B MAY\n\
    \      be set to 1 in the last few seconds that packets are transmitted\n    \
    \  for the object.  Once the sender sets B to 1 in one packet for a\n      particular\
    \ object, the sender SHOULD set B to 1 in all subsequent\n      packets for the\
    \ object until termination of transmission of\n      packets for the object. \
    \ A received packet with B set to 1\n      indicates to a receiver that the sender\
    \ will immediately stop\n      sending packets for the object.  When a receiver\
    \ receives a packet\n      with B set to 1, then it SHOULD assume that no more\
    \ packets will\n      be sent for the object to the session.\n   LCT header length\
    \ (HDR_LEN): 8 bits\n      Total length of the LCT header in units of 32-bit words.\
    \  The\n      length of the LCT header MUST be a multiple of 32 bits.  This\n\
    \      field can be used to directly access the portion of the packet\n      beyond\
    \ the LCT header, i.e., to the first other header if it\n      exists, or to the\
    \ packet payload if it exists and there is no\n      other header, or to the end\
    \ of the packet if there are no other\n      headers or packet payload.\n   Codepoint\
    \ (CP): 8 bits\n      An opaque identifier that is passed to the packet payload\
    \ decoder\n      to convey information on the codec being used for the packet\n\
    \      payload.  The mapping between the codepoint and the actual codec\n    \
    \  is defined on a per session basis and communicated out-of-band as\n      part\
    \ of the session description information.  The use of the CP\n      field is similar\
    \ to the Payload Type (PT) field in RTP headers as\n      described in [RFC3550].\n\
    \   Congestion Control Information (CCI): 32, 64, 96, or 128 bits\n      Used\
    \ to carry congestion control information.  For example, the\n      congestion\
    \ control information could include layer numbers,\n      logical channel numbers,\
    \ and sequence numbers.  This field is\n      opaque for the purpose of this specification.\n\
    \      This field MUST be 32 bits if C=0.\n      This field MUST be 64 bits if\
    \ C=1.\n      This field MUST be 96 bits if C=2.\n      This field MUST be 128\
    \ bits if C=3.\n   Transport Session Identifier (TSI): 0, 16, 32, or 48 bits\n\
    \      The TSI uniquely identifies a session among all sessions from a\n     \
    \ particular sender.  The TSI is scoped by the IP address of the\n      sender,\
    \ and thus the IP address of the sender and the TSI together\n      uniquely identify\
    \ the session.  Although a TSI in conjunction with\n      the IP address of the\
    \ sender always uniquely identifies a session,\n      whether or not the TSI is\
    \ included in the LCT header depends on\n      what is used as the TSI value.\
    \  If the underlying transport is\n      UDP, then the 16-bit UDP source port\
    \ number MAY serve as the TSI\n      for the session.  If the TSI value appears\
    \ multiple times in a\n      packet, then all occurrences MUST be the same value.\
    \  If there is\n      no underlying TSI provided by the network, transport or\
    \ any other\n      layer, then the TSI MUST be included in the LCT header.\n \
    \     The TSI MUST be unique among all sessions served by the sender\n      during\
    \ the period when the session is active, and for a large\n      period of time\
    \ preceding and following when the session is active.\n      A primary purpose\
    \ of the TSI is to prevent receivers from\n      inadvertently accepting packets\
    \ from a sender that belong to\n      sessions other than the sessions to which\
    \ receivers are\n      subscribed.  For example, suppose a session is deactivated\
    \ and\n      then another session is activated by a sender and the two sessions\n\
    \      use an overlapping set of channels.  A receiver that connects and\n   \
    \   remains connected to the first session during this sender activity\n     \
    \ could possibly accept packets from the second session as belonging\n      to\
    \ the first session if the TSI for the two sessions were\n      identical.  The\
    \ mapping of TSI field values to sessions is outside\n      the scope of this\
    \ document and is to be done out-of-band.\n      The length of the TSI field is\
    \ 32*S + 16*H bits.  Note that the\n      aggregate lengths of the TSI field plus\
    \ the TOI field is a\n      multiple of 32 bits.\n   Transport Object Identifier\
    \ (TOI): 0, 16, 32, 48, 64, 80, 96, or 112\n      bits.\n      This field indicates\
    \ to which object within the session this\n      packet pertains.  For example,\
    \ a sender might send a number of\n      files in the same session, using TOI=0\
    \ for the first file, TOI=1\n      for the second one, etc.  As another example,\
    \ the TOI may be a\n      unique global identifier of the object that is being\
    \ transmitted\n      from several senders concurrently, and the TOI value may\
    \ be the\n      output of a hash function applied to the object.  The mapping\
    \ of\n      TOI field values to objects is outside the scope of this document\n\
    \      and is to be done out-of-band.  The TOI field MUST be used in all\n   \
    \   packets if more than one object is to be transmitted in a session,\n     \
    \ i.e., the TOI field is either present in all the packets of a\n      session\
    \ or is never present.\n      The length of the TOI field is 32*O + 16*H bits.\
    \  Note that the\n      aggregate length of the TSI field plus the TOI field is\
    \ a multiple\n      of 32 bits.\n"
- title: 5.2.  Header-Extension Fields
  contents:
  - '5.2.  Header-Extension Fields

    '
- title: 5.2.1.  General
  contents:
  - "5.2.1.  General\n   Header Extensions are used in LCT to accommodate optional\
    \ header\n   fields that are not always used or have variable size.  Examples\
    \ of\n   the use of Header Extensions include:\n   o  Extended-size versions of\
    \ already existing header fields.\n   o  Sender and receiver authentication information.\n\
    \   o  Transmission of timing information.\n   The presence of Header Extensions\
    \ can be inferred by the LCT header\n   length (HDR_LEN).  If HDR_LEN is larger\
    \ than the length of the\n   standard header, then the remaining header space\
    \ is taken by Header\n   Extension fields.\n   If present, Header Extensions MUST\
    \ be processed to ensure that they\n   are recognized before performing any congestion\
    \ control procedure or\n   otherwise accepting a packet.  The default action for\
    \ unrecognized\n   Header Extensions is to ignore them.  This allows the future\n\
    \   introduction of backward-compatible enhancements to LCT without\n   changing\
    \ the LCT version number.  Non-backward-compatible Header\n   Extensions CANNOT\
    \ be introduced without changing the LCT version\n   number.\n   There are two\
    \ formats for Header Extension fields, as depicted in\n   Figure 2.  The first\
    \ format is used for variable-length extensions,\n   with Header Extension Type\
    \ (HET) values between 0 and 127.  The\n   second format is used for fixed-length\
    \ (one 32-bit word) extensions,\n   using HET values from 127 to 255.\n      \
    \  0                   1                   2                   3\n        0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  HET (<=127)  |       HEL     |                               |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n    \
    \   .                                                               .\n      \
    \ .              Header Extension Content (HEC)                   .\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        0                   1                   2                   3\n     \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  HET (>=128)  |       Header Extension Content (HEC)          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \              Figure 2: Format of Additional Headers\n   The explanation of each\
    \ sub-field is the following:\n   Header Extension Type (HET): 8 bits\n      The\
    \ type of the Header Extension.  This document defines a number\n      of possible\
    \ types.  Additional types may be defined in future\n      versions of this specification.\
    \  HET values from 0 to 127 are used\n      for variable-length Header Extensions.\
    \  HET values from 128 to 255\n      are used for fixed-length 32-bit Header Extensions.\n\
    \   Header Extension Length (HEL): 8 bits\n      The length of the whole Header\
    \ Extension field, expressed in\n      multiples of 32-bit words.  This field\
    \ MUST be present for\n      variable-length extensions (HETs between 0 and 127)\
    \ and MUST NOT\n      be present for fixed-length extensions (HETs between 128\
    \ and 255).\n   Header Extension Content (HEC): variable length\n      The content\
    \ of the Header Extension.  The format of this sub-\n      field depends on the\
    \ Header Extension Type.  For fixed-length\n      Header Extensions, the HEC is\
    \ 24 bits.  For variable-length Header\n      Extensions, the HEC field has variable\
    \ size, as specified by the\n      HEL field.  Note that the length of each Header\
    \ Extension field\n      MUST be a multiple of 32 bits.  Also note that the total\
    \ size of\n      the LCT header, including all Header Extensions and all optional\n\
    \      header fields, cannot exceed 255 32-bit words.\n   The following LCT Header\
    \ Extensions are defined by this\n   specification:\n   EXT_NOP, HET=0  No-Operation\
    \ extension.  The information present in\n                   this extension field\
    \ MUST be ignored by receivers.\n   EXT_AUTH, HET=1 Packet authentication extension.\
    \  Information used to\n                   authenticate the sender of the packet.\
    \  The format of\n                   this Header Extension and its processing\
    \ is outside\n                   the scope of this document and is to be communicated\n\
    \                   out-of-band as part of the session description.\n   It is\
    \ RECOMMENDED that senders provide some form of packet\n                   authentication.\
    \  If EXT_AUTH is present, whatever\n                   packet authentication\
    \ checks that can be performed\n                   immediately upon reception\
    \ of the packet SHOULD be\n                   performed before accepting the packet\
    \ and performing\n                   any congestion-control-related action on\
    \ it.\n   Some packet authentication schemes impose a delay of several seconds\n\
    \                   between when a packet is received and when the packet\n  \
    \                 is fully authenticated.  Any congestion control\n          \
    \         related action that is appropriate SHOULD NOT be\n                 \
    \  postponed by any such full packet authentication.\n   EXT_TIME, HET=2 Time\
    \ Extension.  This extension is used to carry\n                   several types\
    \ of timing information.  It includes\n                   general purpose timing\
    \ information, namely the Sender\n                   Current Time (SCT), Expected\
    \ Residual Time (ERT), and\n                   Sender Last Change (SLC) time extensions\
    \ described in\n                   the present document.  It can also be used\
    \ for timing\n                   information with narrower applicability (e.g.,\n\
    \                   defined for a single protocol instantiation); in this\n  \
    \                 case, it will be described in a separate document.\n   All senders\
    \ and receivers implementing LCT MUST support the EXT_NOP\n   Header Extension\
    \ and MUST recognize EXT_AUTH and EXT_TIME, but are\n   not required to be able\
    \ to parse their content.\n"
- title: 5.2.2.  EXT_TIME Header Extension
  contents:
  - "5.2.2.  EXT_TIME Header Extension\n   This section defines the timing Header\
    \ Extensions with general\n   applicability.  The time values carried in this\
    \ Header Extension are\n   related to the server's wall clock.  The server MUST\
    \ maintain\n   consistent relative time during a session (i.e., insignificant\
    \ clock\n   drift).  For some applications, system or even global synchronization\n\
    \   of server wall clock may be desirable, such as using the Network Time\n  \
    \ Protocol (NTP) [RFC1305] to ensure actual time relative to 00:00\n   hours GMT,\
    \ January 1st 1900.  Such session-external synchronization\n   is outside the\
    \ scope of this document.\n   The EXT_TIME Header Extension uses the format depicted\
    \ in Figure 3.\n       0                   1                   2             \
    \      3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     HET = 2   |    HEL >= 1   |         Use (bit field)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       first time value                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ...            (other time values (optional)                  ...\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \          Figure 3: EXT_TIME Header Extension Format\n   The \"Use\" bit field\
    \ indicates the semantic of the following 32-bit\n   time value(s).\n   It is\
    \ divided into two parts:\n   o  8 bits are reserved for general purpose timing\
    \ information.  This\n      information is applicable to any protocol that makes\
    \ use of LCT.\n   o  8 bits are reserved for PI-specific timing information. \
    \ This\n      information is out of the scope of this document.\n   The format\
    \ of the \"Use\" bit field is depicted in Figure 4.\n                        2\
    \                                       3\n        6   7   8   9   0   1   2 \
    \  3   4   5   6   7   8   9   0   1\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \      |SCT|SCT|ERT|SLC|   reserved    |          PI-specific          |\n   \
    \   |Hi |Low|   |   |    by LCT     |              use              |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \                     Figure 4: \"Use\" Bit Field Format\n   Several \"time value\"\
    \ fields MAY be present in a given EXT_TIME Header\n   Extension, as specified\
    \ in the \"Use-field\".  When several \"time\n   value\" fields are present, they\
    \ MUST appear in the order specified by\n   the associated flag position in the\
    \ \"Use-field\": first SCT-High (if\n   present), then SCT-Low (if present), then\
    \ ERT (if present), then SLC\n   (if present).  Receivers SHOULD ignore additional\
    \ fields within the\n   EXT_TIME Header Extension that they do not support.\n\
    \   The fields for the general purpose EXT_TIME timing information are:\n   Sender\
    \ Current Time (SCT): SCT-High flag, SCT-Low flag, corresponding\n   time value\
    \ (one or two 32-bit words).\n      This timing information represents the current\
    \ time at the sender\n      at the time this packet was transmitted.\n      When\
    \ the SCT-High flag is set, the associated 32-bit time value\n      provides an\
    \ unsigned integer representing the time in seconds of\n      the sender's wall\
    \ clock.  In the particular case where NTP is\n      used, these 32 bits provide\
    \ an unsigned integer representing the\n      time in seconds relative to 00:00\
    \ hours GMT, January 1st 1900,\n      (i.e., the most significant 32 bits of a\
    \ full 64-bit NTP time\n      value).  In that case, handling of wraparound of\
    \ the 32-bit time\n      is outside the scope of NTP and LCT.\n      When the\
    \ SCT-Low flag is set, the associated 32-bit time value\n      provides an unsigned\
    \ integer representing a multiple of 1/2^^32 of\n      a second, in order to allow\
    \ sub-second precision.  When the SCT-\n      Low flag is set, the SCT-High flag\
    \ MUST be set, too.  In the\n      particular case where NTP is used, these 32\
    \ bits provide the 32\n      least significant bits of a 64-bit NTP timestamp.\n\
    \   Expected Residual Time (ERT): ERT flag, corresponding 32-bit time\n   value.\n\
    \      This timing information represents the sender expected residual\n     \
    \ transmission time for the transmission of the current object.  If\n      the\
    \ packet containing the ERT timing information also contains the\n      TOI field,\
    \ then ERT refers to the object corresponding to the TOI\n      field; otherwise,\
    \ it refers to the only object in the session.\n      When the ERT flag is set,\
    \ it is expressed as a number of seconds.\n      The 32 bits provide an unsigned\
    \ integer representing this number\n      of seconds.\n   Session Last Changed\
    \ (SLC): SLC flag, corresponding 32-bit time\n   value.\n      The Session Last\
    \ Changed time value is the server wall clock time,\n      in seconds, at which\
    \ the last change to session data occurred.\n      That is, it expresses the time\
    \ at which the last (most recent)\n      Transport Object addition, modification,\
    \ or removal was made for\n      the delivery session.  In the case of modifications\
    \ and additions,\n      it indicates that new data will be transported that was\
    \ not\n      transported prior to this time.  In the case of removals, SLC\n \
    \     indicates that some prior data will no longer be transported.\n      When\
    \ the SLC flag is set, the associated 32-bit time value\n      provides an unsigned\
    \ integer representing a time in seconds.  In\n      the particular case where\
    \ NTP is used, these 32 bits provide an\n      unsigned integer representing the\
    \ time in seconds relative to\n      00:00 hours GMT, January 1st 1900, (i.e.,\
    \ the most significant 32\n      bits of a full 64-bit NTP time value).  In that\
    \ case, handling of\n      wraparound of the 32-bit time is outside the scope\
    \ of NTP and LCT.\n      In some cases, it may be appropriate that a packet containing\
    \ an\n      EXT_TIME Header Extension with SLC information also contain an\n \
    \     SCT-High information.\n   Reserved by LCT for future use (4 bits):\n   \
    \   In this version of the specification, these bits MUST be set to\n      zero\
    \ by senders and MUST be ignored by receivers.\n   PI-specific use (8 bits):\n\
    \      These bits are out of the scope of this document.  The bits that\n    \
    \  are not specified by the PI built on top of LCT SHOULD be set to\n      zero.\n\
    \   The total EXT_TIME length is carried in the HEL, since this Header\n   Extension\
    \ is of variable length.  It also enables clients to skip\n   this Header Extension\
    \ altogether if not supported (but recognized).\n"
- title: 6.  Operations
  contents:
  - '6.  Operations

    '
- title: 6.1.  Sender Operation
  contents:
  - "6.1.  Sender Operation\n   Before joining an LCT session, a receiver MUST obtain\
    \ a session\n   description.  The session description MUST include:\n   o  The\
    \ sender IP address;\n   o  The number of LCT channels;\n   o  The addresses and\
    \ port numbers used for each LCT channel;\n   o  The Transport Session ID (TSI)\
    \ to be used for the session;\n   o  Enough information to determine the congestion\
    \ control protocol\n      being used;\n   o  Enough information to determine the\
    \ packet authentication scheme\n      being used (if one is being used).\n   The\
    \ session description could also include, but is not limited to:\n   o  The data\
    \ rates used for each LCT channel;\n   o  The length of the packet payload;\n\
    \   o  The mapping of TOI value(s) to objects for the session;\n   o  Any information\
    \ that is relevant to each object being transported,\n      such as when it will\
    \ be available within the session, for how\n      long, and the length of the\
    \ object;\n   Protocol instantiations using LCT MAY place additional requirements\n\
    \   on what must be included in the session description.  For example, a\n   protocol\
    \ instantiation might require that the data rates for each\n   channel, or the\
    \ mapping of TOI value(s) to objects for the session,\n   or other information\
    \ related to other headers that might be required\n   be included in the session\
    \ description.\n   The session description could be in a form such as SDP as defined\
    \ in\n   [RFC4566], or another format appropriate to a particular application.\n\
    \   It might be carried in a session announcement protocol such as SAP as\n  \
    \ defined in [RFC2974], obtained using a proprietary session control\n   protocol,\
    \ located on a Web page with scheduling information, or\n   conveyed via email\
    \ or other out-of-band methods.  Discussion of\n   session description format,\
    \ and distribution of session descriptions\n   is beyond the scope of this document.\n\
    \   Within an LCT session, a sender using LCT transmits a sequence of\n   packets,\
    \ each in the format defined above.  Packets are sent from a\n   sender using\
    \ one or more LCT channels, which together constitute a\n   session.  Transmission\
    \ rates may be different in different channels\n   and may vary over time.  The\
    \ specification of the other building\n   block headers and the packet payload\
    \ used by a complete protocol\n   instantiation using LCT is beyond the scope\
    \ of this document.  This\n   document does not specify the order in which packets\
    \ are transmitted,\n   nor the organization of a session into multiple channels.\
    \  Although\n   these issues affect the efficiency of the protocol, they do not\n\
    \   affect the correctness nor the inter-operability of LCT between\n   senders\
    \ and receivers.\n   Several objects can be carried within the same LCT session.\
    \  In this\n   case, each object MUST be identified by a unique TOI.  Objects\
    \ MAY be\n   transmitted sequentially, or they MAY be transmitted concurrently.\n\
    \   It is good practice to only send objects concurrently in the same\n   session\
    \ if the receivers that participate in that portion of the\n   session have interest\
    \ in receiving all the objects.  The reason for\n   this is that it wastes bandwidth\
    \ and networking resources to have\n   receivers receive data for objects in which\
    \ they have no interest.\n   Typically, the sender(s) continues to send packets\
    \ in a session until\n   the transmission is considered complete.  The transmission\
    \ may be\n   considered complete when some time has expired, a certain number\
    \ of\n   packets have been sent, or some out-of-band signal (possibly from a\n\
    \   higher level protocol) has indicated completion by a sufficient\n   number\
    \ of receivers.\n   For the reasons mentioned above, this document does not pose\
    \ any\n   restriction on packet sizes.  However, network efficiency\n   considerations\
    \ recommend that the sender uses an as large as possible\n   packet payload size,\
    \ but in such a way that packets do not exceed the\n   network's maximum transmission\
    \ unit size (MTU), or when fragmentation\n   coupled with packet loss might introduce\
    \ severe inefficiency in the\n   transmission.\n   It is recommended that all\
    \ packets have the same or very similar\n   sizes, as this can have a severe impact\
    \ on the effectiveness of\n   congestion control schemes such as the ones described\
    \ in [VIC1998],\n   [BYE2000], and [RFC3738].  A sender of packets using LCT MUST\n\
    \   implement the sender-side part of one of the congestion control\n   schemes\
    \ that is in accordance with [RFC2357] using the Congestion\n   Control Information\
    \ field provided in the LCT header, and the\n   corresponding receiver congestion\
    \ control scheme is to be\n   communicated out-of-band and MUST be implemented\
    \ by any receivers\n   participating in the session.\n"
- title: 6.2.  Receiver Operation
  contents:
  - "6.2.  Receiver Operation\n   Receivers can operate differently depending on the\
    \ delivery service\n   model.  For example, for an on-demand service model, receivers\
    \ may\n   join a session, obtain the necessary packets to reproduce the object,\n\
    \   and then leave the session.  As another example, for a streaming\n   service\
    \ model, a receiver may be continuously joined to a set of LCT\n   channels to\
    \ download all objects in a session.\n   To be able to participate in a session,\
    \ a receiver MUST obtain the\n   relevant session description information as listed\
    \ in Section 6.1.\n   If packet authentication information is present in an LCT\
    \ header, it\n   SHOULD be used as specified in Section 5.2.  To be able to be\
    \ a\n   receiver in a session, the receiver MUST be able to process the LCT\n\
    \   header.  The receiver MUST be able to discard, forward, store, or\n   process\
    \ the other headers and the packet payload.  If a receiver is\n   not able to\
    \ process an LCT header, it MUST drop from the session.\n   To be able to participate\
    \ in a session, a receiver MUST implement the\n   congestion control protocol\
    \ specified in the session description\n   using the Congestion Control Information\
    \ field provided in the LCT\n   header.  If a receiver is not able to implement\
    \ the congestion\n   control protocol used in the session, it MUST NOT join the\
    \ session.\n   When the session is transmitted on multiple LCT channels, receivers\n\
    \   MUST initially join channels according to the specified startup\n   behavior\
    \ of the congestion control protocol.  For a multiple rate\n   congestion control\
    \ protocol that uses multiple channels, this\n   typically means that a receiver\
    \ will initially join only a minimal\n   set of LCT channels, possibly a single\
    \ one, that in aggregate are\n   carrying packets at a low rate.  This rule has\
    \ the purpose of\n   preventing receivers from starting at high data rates.\n\
    \   Several objects can be carried either sequentially or concurrently\n   within\
    \ the same LCT session.  In this case, each object is identified\n   by a unique\
    \ TOI.  Note that even if a server stops sending packets\n   for an old object\
    \ before starting to transmit packets for a new\n   object, both the network and\
    \ the underlying protocol layers can cause\n   some reordering of packets, especially\
    \ when sent over different LCT\n   channels, and thus receivers SHOULD NOT assume\
    \ that the reception of\n   a packet for a new object means that there are no\
    \ more packets in\n   transit for the previous one, at least for some amount of\
    \ time.\n   A receiver MAY be concurrently joined to multiple LCT sessions from\n\
    \   one or more senders.  The receiver MUST perform congestion control on\n  \
    \ each such LCT session.  If the congestion control protocol allows the\n   receiver\
    \ some flexibility in terms of its actions within a session,\n   then the receiver\
    \ MAY make choices to optimize the packet flow\n   performance across the multiple\
    \ LCT sessions, as long as the receiver\n   still adheres to the congestion control\
    \ rules for each LCT session\n   individually.\n"
- title: 7.  Requirements from Other Building Blocks
  contents:
  - "7.  Requirements from Other Building Blocks\n   As described in [RFC3048], LCT\
    \ is a building block that is intended\n   to be used, in conjunction with other\
    \ building blocks, to help\n   specify a protocol instantiation.  A congestion\
    \ control building\n   block that uses the Congestion Control information field\
    \ within the\n   LCT header MUST be used by any protocol instantiation that uses\
    \ LCT;\n   other building blocks MAY also be used, such as a reliability\n   building\
    \ block.\n   The congestion control MUST be applied to the LCT session as an\n\
    \   entity, i.e., over the aggregate of the traffic carried by all of the\n  \
    \ LCT channels associated with the LCT session.  The Congestion Control\n   Information\
    \ field in the LCT header is an opaque field that is\n   reserved to carry information\
    \ related to congestion control.  There\n   MAY also be congestion control Header\
    \ Extension fields that carry\n   additional information related to congestion\
    \ control.\n   The particular layered encoder and congestion control protocols\
    \ used\n   with LCT have an impact on the performance and applicability of LCT.\n\
    \   For example, some layered encoders used for video and audio streams\n   can\
    \ produce a very limited number of layers, thus providing a very\n   coarse control\
    \ in the reception rate of packets by receivers in a\n   session.  When LCT is\
    \ used for reliable data transfer, some FEC\n   codecs are inherently limited\
    \ in the size of the object they can\n   encode, and for objects larger than this\
    \ size the reception overhead\n   on the receivers can grow substantially.\n \
    \  A more in-depth description of the use of FEC in Reliable Multicast\n   Transport\
    \ (RMT) protocols is given in [RFC3453].  Some of the FEC\n   codecs that MAY\
    \ be used in conjunction with LCT for reliable content\n   delivery are specified\
    \ in [RFC5052].  The Codepoint field in the LCT\n   header is an opaque field\
    \ that can be used to carry information\n   related to the encoding of the packet\
    \ payload.\n   LCT also requires receivers to obtain a session description, as\n\
    \   described in Section 6.1.  The session description could be in a form\n  \
    \ such as SDP as defined in [RFC4566], or another format appropriate to\n   a\
    \ particular application and may be distributed with SAP as defined\n   in [RFC2974],\
    \ using HTTP, or in other ways.  It is RECOMMENDED that\n   an authentication\
    \ protocol be used to deliver the session description\n   to receivers to ensure\
    \ the correct session description arrives.\n   It is RECOMMENDED that LCT implementors\
    \ use some packet\n   authentication scheme to protect the protocol from attacks.\
    \  An\n   example of a possibly suitable scheme is described in [Perrig2001].\n\
    \   Some protocol instantiations that use LCT MAY use building blocks\n   that\
    \ require the generation of feedback from the receivers to the\n   sender.  However,\
    \ the mechanism for doing this is outside the scope\n   of LCT.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   LCT is a building block as defined in [RFC3048]\
    \ and as such does not\n   define a complete protocol.  Protocol instantiations\
    \ that use the LCT\n   building block MUST address the potential vulnerabilities\
    \ described\n   in the following sections.  For an example, see [ALC-PI].\n  \
    \ Protocol instantiations could address the vulnerabilities described\n   below\
    \ by taking measures to prevent receivers from accepting\n   incorrect packets,\
    \ for example, by using a source authentication and\n   content integrity mechanism.\
    \  See also Sections 6.2 and 7 for\n   discussion of packet authentication requirements.\n\
    \   Note that for correct operation, LCT assumes availability of session\n   description\
    \ information (see Sections 4 and 7).  Incorrect or\n   maliciously modified session\
    \ description information may result in\n   receivers being unable to correctly\
    \ receive the session content, or\n   that receivers inadvertently try to receive\
    \ at a much higher rate\n   than they are capable of, thereby disrupting traffic\
    \ in portions of\n   the network.  Protocol instantiations MUST address this potential\n\
    \   vulnerability, for example, by providing source authentication and\n   integrity\
    \ mechanisms for the session description.  Additionally,\n   these mechanisms\
    \ MUST allow the receivers to securely verify the\n   correspondence between session\
    \ description and LCT data packets.\n   The following sections consider further\
    \ each of the services provided\n   by LCT.\n"
- title: 8.1.  Session and Object Multiplexing and Termination
  contents:
  - "8.1.  Session and Object Multiplexing and Termination\n   The Transport Session\
    \ Identifier and the Transport Object Identifier\n   in the LCT header provide\
    \ for multiplexing of sessions and objects.\n   Modification of these fields by\
    \ an attacker could have the effect of\n   depriving a session or object of data\
    \ and potentially directing\n   incorrect data to another session or object, in\
    \ both cases effecting\n   a denial-of-service attack.\n   Additionally, injection\
    \ of forged packets with fake TSI or TOI values\n   may cause receivers to allocate\
    \ resources for additional sessions or\n   objects, again potentially effecting\
    \ a DoS attack.\n   The Close Object and Close Session bits in the LCT header\
    \ provide for\n   signaling of the end of a session or object.  Modification of\
    \ these\n   fields by an attacker could cause receivers to incorrectly behave\
    \ as\n   if the session or object had ended, resulting in a denial-of-service\n\
    \   attack, or conversely to continue to unnecessarily utilize resources\n   after\
    \ the session or object has ended (although resource utilization\n   in this case\
    \ is largely an implementation issue).\n   As a result of the above vulnerabilities,\
    \ these fields MUST be\n   protected by protocol instantiation security mechanisms\
    \ (for example,\n   source authentication and data integrity mechanisms).\n"
- title: 8.2.  Time Synchronization
  contents:
  - "8.2.  Time Synchronization\n   The SCT and ERT mechanisms provide rudimentary\
    \ time synchronization\n   features which can both be subject to attacks.  Indeed\
    \ an attacker\n   can easily de-synchronize clients, sending erroneous SCT information,\n\
    \   or mount a DoS attack by informing all clients that the session\n   (respectively,\
    \ a particular object) is about to be closed.\n   As a result of the above vulnerabilities,\
    \ these fields MUST be\n   protected by protocol instantiation security mechanisms\
    \ (for example,\n   source authentication and data integrity mechanisms).\n"
- title: 8.3.  Data Transport
  contents:
  - "8.3.  Data Transport\n   The LCT protocol provides for transport of information\
    \ for other\n   building blocks, specifically the PSI field for the protocol\n\
    \   instantiation, the Congestion Control field for the Congestion\n   Control\
    \ building block, the Codepoint field for the FEC building\n   block, the EXT-AUTH\
    \ Header Extension (used by the protocol\n   instantiation) and the packet payload\
    \ itself.\n   Modification of any of these fields by an attacker may result in\
    \ a\n   denial-of-service attack.  In particular, modification of the\n   Codepoint\
    \ or packet payload may prevent successful reconstruction or\n   cause inaccurate\
    \ reconstruction of large portions of an object by\n   receivers.  Modification\
    \ of the Congestion Control field may cause\n   receivers to attempt to receive\
    \ at an incorrect rate, potentially\n   worsening or causing a congestion situation\
    \ and thereby effecting a\n   DoS attack.\n   As a result of the above vulnerabilities,\
    \ these fields MUST be\n   protected by protocol instantiation security mechanisms\
    \ (for example,\n   source authentication and data integrity mechanisms).\n"
- title: 9.  IANA Considerations
  contents:
  - '9.  IANA Considerations

    '
- title: 9.1.  Namespace Declaration for LCT Header Extension Types
  contents:
  - "9.1.  Namespace Declaration for LCT Header Extension Types\n   This document\
    \ defines a new namespace for \"LCT Header Extension\n   Types\".  Values in this\
    \ namespace are integers between 0 and 255\n   (inclusive).\n   Values in the\
    \ range 0 to 63 (inclusive) are reserved for use for\n   variable-length LCT Header\
    \ Extensions and assignments shall be made\n   through \"IETF Review\" as defined\
    \ in [RFC5226].\n   Values in the range 64 to 127 (inclusive) are reserved for\
    \ variable-\n   length LCT Header Extensions and assignments shall be made on\
    \ the\n   \"Specification Required\" basis as defined in [RFC5226].\n   Values\
    \ in the range 128 to 191 (inclusive) are reserved for use for\n   fixed-length\
    \ LCT Header Extensions and assignments shall be made\n   through \"IETF Review\"\
    \ as defined in [RFC5226].\n   Values in the range 192 to 255 (inclusive) are\
    \ reserved for fixed-\n   length LCT Header Extensions and assignments shall be\
    \ made on the\n   \"Specification Required\" basis as defined in [RFC5226].\n\
    \   Initial values for the LCT Header Extension Type registry are defined\n  \
    \ in Section 9.2.\n   Note that the previous Experimental version of this specification\n\
    \   reserved values in the ranges [64, 127] and [192, 255] for PI-\n   specific\
    \ LCT Header Extensions.  In the interest of simplification\n   and since there\
    \ were no overlapping allocations of these LCT Header\n   Extension Type values\
    \ by PIs, this document specifies a single flat\n   space for LCT Header Extension\
    \ Types.\n"
- title: 9.2.  LCT Header Extension Type Registration
  contents:
  - "9.2.  LCT Header Extension Type Registration\n   This document registers three\
    \ values in the LCT Header Extension Type\n   namespace as follows:\n        \
    \         +-------+----------+--------------------+\n                 | Value\
    \ | Name     | Reference          |\n                 +-------+----------+--------------------+\n\
    \                 | 0     | EXT_NOP  | This specification |\n                \
    \ |       |          |                    |\n                 | 1     | EXT_AUTH\
    \ | This specification |\n                 |       |          |              \
    \      |\n                 | 2     | EXT_TIME | This specification |\n       \
    \          +-------+----------+--------------------+\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   This specification is substantially based on RFC 3451\
    \ [RFC3451] and\n   thus credit for the authorship of this document is primarily\
    \ due to\n   the authors of RFC 3451: Mike Luby, Jim Gemmel, Lorenzo Vicisano,\n\
    \   Luigi Rizzo, Mark Handley, and Jon Crowcroft.  Bruce Lueckenhoff,\n   Hayder\
    \ Radha, and Justin Chapweske also contributed to RFC 3451.\n   Additional thanks\
    \ are due to Vincent Roca, Rod Walsh, and Toni Paila\n   for contributions to\
    \ this update to Proposed Standard.\n"
- title: 11.  Changes from RFC 3451
  contents:
  - "11.  Changes from RFC 3451\n   This section summarizes the changes that were\
    \ made from the\n   Experimental version of this specification published as RFC\
    \ 3451\n   [RFC3451]:\n   o  Removed the 'Statement of Intent' from the introduction.\
    \  (The\n      statement of intent was meant to clarify the \"Experimental\" status\n\
    \      of RFC 3451.)\n   o  Inclusion of material from ALC that is applicable\
    \ in the more\n      general LCT context.\n   o  Creation of an IANA registry\
    \ for LCT Header Extensions.\n   o  Allocation of the 2 'reserved' bits in the\
    \ LCT header as\n      \"Protocol-Specific Indication\" - usage to be defined\
    \ by protocol\n      instantiations.\n   o  Removal of the Sender Current Time\
    \ and Expected Residual Time LCT\n      header fields.\n   o  Inclusion of a new\
    \ Header Extension, EXT_TIME, to replace the SCT\n      and ERT and provide for\
    \ future extension of timing capabilities.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC0768]     Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n                 August 1980.\n   [RFC1112]     Deering, S.,\
    \ \"Host extensions for IP multicasting\",\n                 STD 5, RFC 1112,\
    \ August 1989.\n   [RFC2119]     Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \                 Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC5052]\
    \     Watson, M., Luby, M., and L. Vicisano, \"Forward Error\n               \
    \  Correction (FEC) Building Block\", RFC 5052,\n                 August 2007.\n\
    \   [RFC5226]     Narten, T. and H. Alvestrand, \"Guidelines for Writing\n   \
    \              an IANA Considerations Section in RFCs\", BCP 26,\n           \
    \      RFC 5226, May 2008.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [ALC-PI]      Luby, M., Watson, M., and L.\
    \ Vicisano, \"Asynchronous\n                 Layered Coding (ALC) Protocol Instantiation\"\
    , Work\n                 in Progress, September 2009.\n   [BYE1998]     Byers,\
    \ J., Luby, M., Mitzenmacher, M., and A. Rege,\n                 \"Fountain Approach\
    \ to Reliable Distribution of Bulk\n                 Data\", Proceedings ACM SIGCOMM'98,\
    \ Vancouver, Canada,\n                 September 1998.\n   [BYE2000]     Byers,\
    \ J., Frumin, M., Horn, G., Luby, M.,\n                 Mitzenmacher, M., Rotter,\
    \ A., and W. Shaver, \"FLID-DL:\n                 Congestion Control for Layered\
    \ Multicast\", Proceedings\n                 of Second International Workshop\
    \ on Networked Group\n                 Communications (NGC 2000), Palo Alto, CA,\n\
    \                 November 2000.\n   [GEM2000]     Gemmell, J., Schooler, E.,\
    \ and J. Gray, \"Fcast\n                 Multicast File Distribution\", IEEE Network,\
    \ Vol. 14,\n                 No. 1, pp. 58-68, January 2000.\n   [Perrig2001]\
    \  Perrig, A., Canetti, R., Song, D., and J. Tyger,\n                 \"Efficient\
    \ and Secure Source Authentication for\n                 Multicast\", Network\
    \ and Distributed System Security\n                 Symposium, NDSS 2001, pp.\
    \ 35-46, February 2001.\n   [RFC1305]     Mills, D., \"Network Time Protocol (Version\
    \ 3)\n                 Specification, Implementation\", RFC 1305, March 1992.\n\
    \   [RFC2357]     Mankin, A., Romanov, A., Bradner, S., and V. Paxson,\n     \
    \            \"IETF Criteria for Evaluating Reliable Multicast\n             \
    \    Transport and Application Protocols\", RFC 2357,\n                 June 1998.\n\
    \   [RFC2974]     Handley, M., Perkins, C., and E. Whelan, \"Session\n       \
    \          Announcement Protocol\", RFC 2974, October 2000.\n   [RFC3048]    \
    \ Whetten, B., Vicisano, L., Kermode, R., Handley, M.,\n                 Floyd,\
    \ S., and M. Luby, \"Reliable Multicast Transport\n                 Building Blocks\
    \ for One-to-Many Bulk-Data Transfer\",\n                 RFC 3048, January 2001.\n\
    \   [RFC3269]     Kermode, R. and L. Vicisano, \"Author Guidelines for\n     \
    \            Reliable Multicast Transport (RMT) Building Blocks and\n        \
    \         Protocol Instantiation documents\", RFC 3269,\n                 April\
    \ 2002.\n   [RFC3451]     Luby, M., Gemmell, J., Vicisano, L., Rizzo, L.,\n  \
    \               Handley, M., and J. Crowcroft, \"Layered Coding\n            \
    \     Transport (LCT) Building Block\", RFC 3451,\n                 December 2002.\n\
    \   [RFC3453]     Luby, M., Vicisano, L., Gemmell, J., Rizzo, L.,\n          \
    \       Handley, M., and J. Crowcroft, \"The Use of Forward\n                \
    \ Error Correction (FEC) in Reliable Multicast\",\n                 RFC 3453,\
    \ December 2002.\n   [RFC3550]     Schulzrinne, H., Casner, S., Frederick, R.,\
    \ and V.\n                 Jacobson, \"RTP: A Transport Protocol for Real-Time\n\
    \                 Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3738] \
    \    Luby, M. and V. Goyal, \"Wave and Equation Based Rate\n                 Control\
    \ (WEBRC) Building Block\", RFC 3738, April 2004.\n   [RFC4566]     Handley, M.,\
    \ Jacobson, V., and C. Perkins, \"SDP:\n                 Session Description Protocol\"\
    , RFC 4566, July 2006.\n   [RFC4607]     Holbrook, H. and B. Cain, \"Source-Specific\
    \ Multicast\n                 for IP\", RFC 4607, August 2006.\n   [RIZ1997a]\
    \    Rizzo, L., \"Effective Erasure Codes for Reliable\n                 Computer\
    \ Communication Protocols\", ACM SIGCOMM Computer\n                 Communication\
    \ Review, Vol.27, No.2, pp.24-36,\n                 April 1997.\n   [RIZ1997b]\
    \    Rizzo, L. and L. Vicisano, \"Reliable Multicast Data\n                 Distribution\
    \ protocol based on software FEC\n                 techniques\", Proceedings of\
    \ the Fourth IEEE Workshop on\n                 the Architecture and Implementation\
    \ of High Performance\n                 Communication Systems, HPCS'97, Chalkidiki\
    \ Greece,\n                 June 1997.\n   [RIZ2000]     Rizzo, L., \"PGMCC: A\
    \ TCP-friendly single-rate multicast\n                 congestion control scheme\"\
    , Proceedings of SIGCOMM\n                 2000, Stockholm Sweden, August 2000.\n\
    \   [VIC1998]     Vicisano, L., Rizzo, L., and J. Crowcroft, \"TCP-like\n    \
    \             Congestion Control for Layered Multicast Data\n                \
    \ Transfer\", IEEE Infocom'98, San Francisco, CA,\n                 March 1998.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Michael Luby\n   Qualcomm, Inc.\n   3165 Kifer Rd.\n \
    \  Santa Clara, CA  95051\n   US\n   EMail: luby@qualcomm.com\n   Mark Watson\n\
    \   Qualcomm, Inc.\n   3165 Kifer Rd.\n   Santa Clara, CA  95051\n   US\n   EMail:\
    \ watson@qualcomm.com\n   Lorenzo Vicisano\n   Qualcomm, Inc.\n   3165 Kifer Rd.\n\
    \   Santa Clara, CA  95051\n   US\n   EMail: vicisano@qualcomm.com\n"
