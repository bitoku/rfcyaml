- title: __initial_text__
  contents:
  - "             Elements of a Distributed Programming System\n                 \
    \          January 5, 1976\n                            James E. White\n     \
    \                Augmentation Research Center\n                     Stanford Research\
    \ Institute\n                    Menlo Park, California  94025\n             \
    \            (415) 326-6200 X2960\nThis paper suggests some extensions to the\
    \ simple Procedure Call Protocol\ndescribed in a previous paper (27197).  By expanding\
    \ the procedure call\nmodel and standardizing other common forms of inter-process\
    \ interaction,\nsuch extensions would provide the applications programmer with\
    \ an even\nmore powerful distributed programming system.\nThe work reported here\
    \ was supported by the Advanced Research Projects\nAgency of the Department of\
    \ Defense, and by the Rome Air Development \nCenter of the Air Force.\nThis paper\
    \ will be submitted to publication in the Journal of Computer\nLanguages.\f  \
    \                           INTRODUCTION\nIn a companion paper [i], the author\
    \ proposes a simple protocol and\nsoftware framework that would facilitate the\
    \ construction of distributed\nsystems within a resource-sharing computer network\
    \ by enabling distant\nprocesses to communicate with one another at the procedure\
    \ call level.\nAlthough of great utility even in its present form, this rudimentary\n\
    \"distributed programming system (DPS)\" supports only the most fundamental\n\
    aspects of remote procedure calling.  In particular, it permits the\ncaller to\
    \ identify the remote procedure to be called, supply the \nnecessary arguments,\
    \ determine the outcome of the procedure, and recover \nits results.  The present\
    \ paper extends this simple procedure call model\nand standardizes other common\
    \ forms of process interaction to provide\na more powerful and comprehensive distributed\
    \ programming system.  The\nparticular extensions proposed in this paper serve\
    \ hopefully to reveal the \nDPS concept's potential, and are offered not as dogma\
    \ but rather as\nstimulus for further research.\nThe first section of this paper\
    \ summarizes the basic distributed\nprogramming system derived in [1].  The second\
    \ section describes the\ngeneral strategy to be followed in extending it.  The\
    \ third and longest\nsection identifies and explores some of the aspects of process\
    \ interaction\nthat are sufficiently common to warrant standardization, and suggests\n\
    methods for incorporating them in the DPS model.\n                      REVIEWING\
    \ THE BASIC SYSTEM\nThe distributed programming system derived in [1] assumes\
    \ the existence\nof and is built upon a network-wide \"inter-process communication\
    \ (IPC)\"\nfacility.  As depicted in Figure 1, DPS consists of a high-level model\
    \ of\ncomputer processes and a simple, application-independent \"procedure\ncall\
    \ protocol (PCP)\" that implements the model by regulating the dialog\nbetween\
    \ two processes interconnected by means of an IPC communication \n\"channel.\"\
    \  DPS is implemented by an installation-provided \"run-time \nenvironment (RTE),\"\
    \ which is link loaded with (or otherwise made\navailable to) each applications\
    \ program.\nRequests for Comments:  708\tElements of a Distributed Programming\
    \ System\n\t\t\t\t\t         Reviewing the Basic System\nThe Model\nThe procedure\
    \ call model (hereafter termed the Model) views a process as a\ncollection of\
    \ remotely callable subroutines or \"procedures.\"  Each procedure\nis invoked\
    \ by name, can be supplied a list of arguments, and returns to its\ncaller both\
    \ a boolean outcome, indicating whether it succeeded or failed,\nand a list of\
    \ results.  The Model permits the process at either end of the \nIPC channel to\
    \ invoke procedures in its neighbor, and further permits a\nprocess to accept\
    \ two or more procedure calls for concurrent execution.\nThe arguments and results\
    \ of procedures are modeled from a small set of\nprimitive \"data types,\" listed\
    \ below:\n\tLIST:  A list is an ordered sequence of N data objects called\n\t\"\
    elements\" (here and throughout these descriptions, N is\t\n\tconfined to the\
    \ range [0, 2**15-1]).  A LIST may contain\n\tother LISTs as elements, and can\
    \ therefore be employed to\n\tconstruct arbitrarily complex, composite arguments\
    \ or results.\n\tCHARSTR:  A character string is an ordered sequence of N ASCII\n\
    \tcharacters, and conveniently models a variety of textual\n\tentities, from short\
    \ user names to whole paragraphs of text.\n\tBITSTR:  A bit string is an ordered\
    \ sequence of N bits and,\n\ttherefore, provides a means for representing arbitrary\n\
    \tbinary data (for example, the contents of a word of memory).\n\tINTEGER:  An\
    \ integer is a fixed-point number in the range\n\t[-2**31, 2**31-1], and conveniently\
    \ models various kinds of\n\tnumerical data, including time intervals, distances,\
    \ and so on.\n\tINDEX:  An index is an integer in the range [1, 2**15-1].  As\n\
    \tits name and value range suggest, an INDEX can be used to\n\taddress a particular\
    \ bit of character within a string, or \n\telement within a list.  Furthermore,\
    \ many of the protocol\n\textensions to be proposed in this paper will employ\
    \ INDEXES as\n\thandles for objects within the DPS environment (for example,\n\
    \tprocesses and channels).\n\tBOOLEAN:  A boolean represents a single bit of information\n\
    \tand has either the value  true or false.\n\tEMPTY:  An empty is a valueless\
    \ place holder within a LIST of\n\tparameter list.\nRequests for Comments:  708\t\
    Elements of a Distributed Programming System\n\t\t\t\t\t\t  Reviewing the Basic\
    \ System\nThe Protocol\nThe procedure call protocol (hereafter terms the Protocol),\
    \ which\nimplements the Model, defines a \"transmission format\" (like those suggested\n\
    in Appendix A) for each of the seven data types listed above, and\nrequires that\
    \ parameters be encoded in that format whenever they are\ntransported between\
    \ processes.\nThe Protocol also specified the inter-process messages by which\
    \ remote\nprocedures are invoked.  These messages can be described symbolically\
    \ as\nfollows:\n\tmessage-type=CALL\t[tid] procedure-name arguments\n\tmessage-type=RETURN\
    \      tid  outcome        results\nThe first message invokes the procedure whose\
    \ NAME is specified using the\nARGUMENTS provided.  The second is returned in\
    \ eventual response to the\nfirst and reports the OUTCOME and RESULTS of the completed\
    \ procedure.\nWhenever OUTCOME indicates that a procedure has failed, the procedure's\
    \ \nRESULTS are required to be an error number and diagnostic message, the \n\
    former to help the invoking program determine what to do next, the \nlatter for\
    \ possible presentation to the user.  The presence of an\noptional \"transaction\
    \ identifier (TID)\" in the CALL message constitutes\na request by the caller\
    \ for an acknowledging RETURN message echoing the\nidentifier.\nAlthough data\
    \ types and their transmission formats serve primarily as\nvehicles for representing\
    \ the arguments and results of remote procedures,\nthey can just as readily and\
    \ effectively be employed to represent the\nmessages by which those parameters\
    \ are transmitted.  The Protocol,\ntherefore, represents each of the two messages\
    \ described above as a PCP \ndata object, namely, a LIST whose first element is\
    \ an INDEX message\ntype.  The following concise statement of the Protocol results:\n\
    \tLIST (CALL,   tid,    procedure, arguments)\n              INDEX=1 [INDEX] CHARSTR\
    \    LIST\n\tLIST (RETURN, tid,    outcome,   results)\n\t      INDEX=2 INDEX\
    \   BOOLEAN    LIST\nHere and in subsequent protocol descriptions, elements enclosed\
    \ in square\nbrackets are optional (that is, may be EMPTY).  The RESULTS of an\n\
    unsuccessful procedure would be represented as follows:\n\tLIST (error, diagnostic)\n\
    \t      INDEX  CHARSTR\nRequests for Comments:  708\tElements of a Distributed\
    \ Programming System\n\t\t\t\t\t          Reviewing the Basic System\nThe Run-Time\
    \ Environment\nThe run-time environment (hereafter termed the environment) interfaces\
    \ the\napplications program to a remote process via an IPC channel.  In doing\
    \ so,\nit provides the applications program with a collection of \"primitives,\"\
    \nimplemented either as subroutines or system calls, that the applications\nprogram\
    \ can employ to manipulate the remote process to which the channel\nconnects it.\
    \  The environment implements these primitives by sending\nand receiving various\
    \ protocol messages via the channel.\nIn its present rudimentary form, the Protocol\
    \ enables the environment to\nmake a single, remote procedure calling primitive\
    \ like the following\navailable to the applications program:\n\tCALLPROCEDURE\
    \ (procedure, arguments -> outcome, results)\n\t\t       CHARSTR    LIST     \
    \    BOOLEAN  LIST\nThis primitive invokes the indicated remote PROCEDURE using\
    \ the ARGUMENTS\nprovided and returns its OUTCOME and RESULTS.  While this primitive\n\
    blocks the invoking applications program until the remote procedure\nreturns,\
    \ a variant that simply initiates the call and allows the\napplications program\
    \ to collect the outcome and results in a second\noperation can also be provided.\n\
    Since the interface between the environment and the applications program\nis machine-\
    \ and possibly even language-dependent, environment-provided\nprimitives can only\
    \ be described in this paper symbolically.  Although\nPCP data types provide a\
    \ convenient vehicle for describing their\narguments and results are therefore\
    \ used for that purpose above and\nthroughout the paper, such parameters will\
    \ normally be transmitted\nbetween the environment and the applications program\
    \ in some internal\nformat.\n               BOOTSTRAPPING THE NEW PROTOCOL FUNCTIONS\n\
    Since the Protocol already provides a mechanism for invoking arbitrary\nremote\
    \ procedures, the Model extensions to be proposed in this paper\nwill be implemented\
    \ whenever possible as procedures, rather than as\nadditional messages.  Unlike\
    \ applications procedures, these special\n\"system procedures\" will be called\
    \ and implemented by run-time environments, \nrather than by the applications\
    \ programs they serve.  Although inaccessible\nto the remote applications program\
    \ via the normal environment-provided\nremote procedure calling primitive, system\
    \ procedures will enable the\nenvironment to implement and offer new primitives\
    \ to its applications\nprogram.\nRequests for Comments:  708\tElements of a Distributed\
    \ Programming System\n\t\t\t\t    Bootstrapping the New Protocol Functions\nThe\
    \ calling sequences of many of these new primitives will closely\ncorrespond to\
    \ those of the remote system procedures by which they are\nimplemented.  Other\
    \ primitives will be more complex and require for their\nimplementation calls\
    \ to several system procedures, possibly in different\nprocesses.  Besides describing\
    \ the Protocol additions required by various\nModel extensions proposed, the author\
    \ will, throughout this paper, suggest\ncalling sequences for the new primitives\
    \ that become available to the \napplications program.\n\t\t\t\t       Some Possible\
    \ Extensions to the Model\n                SOME POSSIBLE EXTENSIONS TO THE MODEL\n\
    1.  Creating Remote Processes\nBefore a program in one machine can use resources\
    \ in another, it must either\ncreate a new process in the remote machine, or gain\
    \ access to an existing\none.  In either case, the local process must establish\
    \ an IPC channel to a\nresident dispatching process within the remote system,\
    \ specify the program \nto be started or contacted. and identify itself so that\
    \ its access to the\nprogram can be established and billing carried out.  After\
    \ these preliminary\nsteps have been accomplished, the requested process assumes\
    \ responsibility\nfor the IPC channel and substantive communication begins.\n\
    The manner in which the environment carries out the above scenario is\nlargely\
    \ dictated by the IPC facility upon which the distributed system is\nbased.  If\
    \ the IPC facility itself provides single primitive that\naccomplishes the entire\
    \ task, then the environment need only invoke that\nprimitive.  If, on the other\
    \ hand, it only provides a mechanism by which\nthe environment can establish a\
    \ channel to the remote dispatcher, as is\nthe case within the ARPA computer Network\
    \ (the ARPANET), then the Protocol \nitself must contain provisions for naming\
    \ the program to be run and\npresenting the required credential.\nAdding to the\
    \ Protocol the following system procedure enables the local\nenvironment to provide\
    \ the remote dispatcher with the necessary information\nin this latter case:\n\
    \tINIPROCESS (program, credential)\n\t\t    CHARSTR  LIST (user,   password, account)\n\
    \t\t\t\t   CHARSTR CHARSTR   CHARSTR\nIts arguments include the name of the applications\
    \ PROGRAM to be run; and\nthe USER name, PASSWORD, and ACCOUNT of the local user\
    \ to whom its use is\nto be billed.\nThis new procedure effectively adds to the\
    \ Model the notion of \"creation,\" and enables the environment to offer the following\
    \ primitives\nto its applications program:\n\tCRTPROCESS (computer, program, credential\
    \ -> ph)\n\t\t    CHARSTR   CHARSTR  (as above)    INDEX\n\tDELPROCESS (ph)\n\t\
    \t    INDEX\n\t\t\t\t         Some Possible Extensions to the Model\n\t\t\t\t\t\
    \t     Creating Remote Processes\nThe first primitive creates a new process or\
    \ establishes contact with an\nexisting one by first creating a channel to the\
    \ dispatcher within the\nindicated COMPUTER and then invoking the remote system\
    \ procedure INIPROCESS\nwith the specified PROGRAM name and CREDENTIALS as arguments.\
    \  The primitive\nreturns a \"process handle PH\" by which the applications program\
    \ can refer to \nthe newly created process in subsequent dialog with the local\
    \ environment\nby the IPC facility, an index into a table within the environment,\
    \ or anything\nelse the environment's implementor may find convenient.\nThe second\
    \ primitive \"deletes\" the previously created process whose handle\nPH is specified\
    \ by simply deleting the IPC channel to the remote process and\nreclaiming any\
    \ internal table space that may have been allocated to the\nprocess.\n2.  Introducing\
    \ Processes to One Another\nThe simplest distributed systems begin with a single\
    \ process that creates,\nvia the CRTPROCESS primitive described above, one or\
    \ more \"inferior\"\nprocesses whose resources it requires.  Some or all of these\
    \ inferiors may \nin turn require other remote resources and so create interiors\
    \ of their\nown.  This creative activity can proceed, in principle, to arbitrary\
    \ depth.\nThe distributed system is thus a tree structure whose nodes are processes\
    \ \nand whose branches are IPC channels.\nAlthough a distributed system can include\
    \ an arbitrarily large number of\nprocesses, each process is cognizant of only\
    \ the process that created it\nand those it itself creates, that is, its parent\
    \ and sons.  The radius\nwithin which a process can access the resources of the\
    \ tree is thus\nartificially small.  This limited sharing range, which prevents\
    \ the\nconvenient implementation of many distributed systems, can be overcome\n\
    by extending the Model to permit an arbitrarily complex network of\ncommunication\
    \ paths to be superimposed upon the process tree.\nOne of the many ways by which\
    \ the Protocol can provide for such communication\npaths is to permit one process\
    \ to \"introduce\" and thereby make known to one \nanother any two processes it\
    \ itself knows (for example, two of its sons,\nor its parent and son).  Once introduced,\
    \ the two processes would be able \nto invoke one another's procedures with the\
    \ same freedom the introducing\nprocess enjoys.  They could also introduce one\
    \ another to other processes,\nand so create even longer communication paths.\n\
    \t\t\t\t       Some Possible Extensions to the Model\n\t\t\t\t\tIntroducing Processes\
    \ to One Another\n2.1  Introductions Within a Homogeneous Environment\nProvided\
    \ one remains within a \"homogeneous environment\" (that is, the domain\nof a\
    \ single IPC facility), the introduction of two processes requires little\nmore\
    \ than the formation of an IPC channel between them.  Adding to the\nProtocol\
    \ the following system procedures, which manipulate IPC \"ports,\"\nenables the\
    \ run-time environment of the process performing the introduction\nto negotiate\
    \ such a channel:\n\tALOPORT (-> ph,   COMPUTER, PORT)\n\t\t    INDEX CHARSTR\
    \   any\n\tCNNPORT (ph,   computer, port)\n\t\t INDEX CHARSTR   any\n\tDCNPORT\
    \ (ph)\n\t\t INDEX\nThe detailed calling sequences for these procedures are dictated\
    \ by the IPC\nfacility that underlies the distributed system.  Those above are\
    \ therefore\nonly representative of what may be required within any particular\
    \ network,\nbut are only slightly less complicated than those required, for example,\n\
    within the ARPANET.\nTo create the channel, the introducing process' run-time\
    \ environment\nallocates a PORT in each target process via ALOPORT, and then instructs\n\
    each process via CNNPORT to connect its port to the other's via the IPC\nfacility.\
    \  The process handle PH returned by ALOPORT serves as a handle\nboth initially\
    \ for the allocated port, and then later for the process to\nwhich the attached\
    \ channel provides access.  To \"separate\" the two processes,\nthe introducing\
    \ process' environment need only invoke the DCNPORT procedure\nin each process,\
    \ thereby dissolving the channel, releasing the associated \nports, and deallocating\
    \ the process handles.\nArmed with these three new system procedures, the environment\
    \ can provide\nthe following new primitives to its applications program:\n\tITDPROCESS\
    \ (ph1,  ph2 -> ph12, PH21, ih)\n\t\t    INDEX INDEX  INDEX INDEX INDEX\n\tSEPPROCESS\
    \ (ih)\n\t\t    INDEX\n\t\t\t\t       Some Possible Extensions to the Model\n\t\
    \t\t\t\t  Introducing Process to One Another\nThe first primitive introduces the\
    \ two processes whose handles PH1 and PH2 \nare specified.  Each handle may designate\
    \ either a son, in which case the\nhandle is one returned by CRTPROCESS; the parent\
    \ process, for which a\nspecial handle (for example, 1) must always be defined;\
    \ or a previously\nintroduced process, in which case the handle is one obtained\
    \ in a previous\ninvocation of ITDPROCESS.\nITDPROCESS returns handles PH12 and\
    \ PH21 by which the two processes will\nknow one another, as well as an \"introduction\
    \ handle IH\" that the applications\nprogram can later employ to separate the\
    \ two processes via SEPPROCESS.  The\napplications program initiating the introduction\
    \ assumes responsibility for\ncommunicating to each introduced applications program\
    \ its handle for the \nother.\n2.2  Introductions Within a Heterogeneous Environment\n\
    While their interconnection via an IPC channel is sufficient to introduce\ntwo\
    \ processes to one another, in a heterogeneous environment the creation\nof such\
    \ a channel is impossible.  Suppose, as depicted in Figure 2, that \nprocesses\
    \ P1 and P2 (in computers C1 and C2, respectively) are interconnected\nwithin\
    \ a distributed system by means of a network IPC facility.  Assume\nfurther that\
    \ P2 attaches to the system another process P3 in a minicomputer\nM that although\
    \ attached to C2 is not formally a part of the network.  With\nthis configuration,\
    \ it is impossible for P2 to introduce processes P1 and P3 \nto one another by\
    \ simply establishing an IPC channel between them, since\nthey are not within\
    \ the domain of a single IPC facility.\nOne way of overcoming this problem is\
    \ to extend the Model to embrace the\nnotion of a composite or \"logical channel\"\
    \ composed of two or more physical \n(that is, IPC) channels.  A message transmitted\
    \ by process P1 via the logical \nchannel to Pn (n=3 in the example above) would\
    \ be relayed over successive\nphysical channels by the environments of intermediate\
    \ processes P2 through\nPn-1.  Although more expensive than physical channels,\
    \ since each message\nmust traverse at least two physical channels and be handled\
    \ by all the\nenvironments along the way, logical channels would nevertheless\
    \ enable \nprocesses that could not otherwise do so to access one another's resources.\n\
    Since the relaying of messages is a responsibility of the environment, the\napplications\
    \ program need never be aware of it.\n\t\t\t\t       Some Possible Extensions\
    \ to the Model\n\t\t\t\t\tIntroducing Processes to One Another\nAs depicted in\
    \ Figure 3, a logical channel would consist of table entries\nmaintained by the\
    \ environment of each process P1 through Pn, plus the\nenvironment to forward\
    \ messages that arrive with a \"routing code\" addressing\nthe local table entry.\
    \  Each table entry would contain process handles for\nthe two adjacent processes,\
    \ as well as the routing code recognized by each.\nTo communicate a message to\
    \ its distant neighbor, the source process (say \nP1) would transmit it via its\
    \ IPC channel to P2, with a routing code\naddressing the appropriate table entry\
    \ within P2.  Upon receipt of the\nmessage, P2 would locate its table entry via\
    \ the routing code, update the\nmessage with the routing code recognized by P3,\
    \ and forward the message\nto P3.  Eventually the message would reach its final\
    \ destination, Pn.\nAdding to the Protocol the following system procedures enables\
    \ the\nenvironment to construct a logical channel like that described above:\n\
    \tCRTROUTE (mycode, oldcode -> code, ph)\n                  INDEX   [INDEX]  \
    \  INDEX INDEX\n\tDELROUTE (yourcode)\n\t          INDEX\nThe simplest logical\
    \ channel (n=3) is created by P2, which invokes CRTROUTE\nin both P1 and P3, specifying\
    \ in each case the routing code MYCODE it has\nassigned to its segment of the\
    \ logical channel, and receiving in return\nthe routing CODES and process handles\
    \ PHs assigned by the two processes.\nOLDCODE is not required in this simple case\
    \ and is therefore EMPTY.\nMore complicated logical channels (n>3) are required\
    \ when one or both\nof the processes to be introduced is already linked, by a\
    \ logical channel,\nto the process performing the introduction.  In such cases,\
    \ a portion of\nthe new channel to be constructed must replicate the existing\
    \ channel, and\nhence the routing code OLDCODE for the table entry that represents\
    \ that\nchannel within the target process is specified as an additional argument\n\
    of the system procedure.  The target process must call CRTROUTE recursively\n\
    in the adjacent process to replicate the rest of the model channel.\n\t\t\t\t\
    \       Some Possible Extensions to the Model\n\t\t\t\t\tIntroducing Processes\
    \ to One Another\nThe process Pi that creates a logical channel assumes responsibility\
    \ for\ninsuring that it is eventually dismantled.  It deletes the logical channel\n\
    by invoking DELROUTE in Pi-1 and Pi+1, each of which propagates the call\ntoward\
    \ its end of the channel.\n3.  Controlling Access to Local Resources\nThe process\
    \ introduction primitive proposed above effectively permits\naccess to a process\
    \ to be transmitted from one process to another.  Any\nprocess P2 that already\
    \ possesses a handle to a process P1 can obtain a \nhandle for use by a third\
    \ process P3.  Once P1 and P3 have been introduced,\nP3 can freely call procedures\
    \ in P1 (and vice versa).\nAlthough a process can, by aborting the ALOPORT system\
    \ procedure, prevent\nits introduction to another process and so restrict the\
    \ set of processes\nthat gain access to it, finer access controls may sometimes\
    \ be required.\nA process may, for example, house two separate resources, one\
    \ of which\nis to be made available only to its parent (for example), and the\
    \ other\nto any process to which the parent introduces it.  Before such a strategy\n\
    can be conveniently implemented, the Model must be extended to permit\naccess\
    \ controls to be independently applied to individual resources within\na single\
    \ process.\nAlthough a single procedure can be considered a resource, it is more\
    \ practical and convenient to conceive of larger, composite resources\nconsisting\
    \ of a number of related procedures.  A simple data base\nmanagement module containing\
    \ procedures for creating, deleting, assigning\nvalues to, reading, and searching\
    \ for data objects exemplifies such \ncomposite resources.  Although each procedure\
    \ is useless in isolating, the\nwhole family of procedures provides a meaningful\
    \ service.  Such \"package\"\nof logically related procedures might thus be the\
    \ most reasonable object\nof the finer access controls to be defined.\nAccess\
    \ controls can be applied to packages by requiring that a process \nfirst \"open\"\
    \ and obtain a handle for a remote package before it may call\nany of the procedures\
    \ it contains.  When the process attempts to open\nthe package, its right to do\
    \ so can be verified and the attempt aborted if\nnecessary.  Challenging the open\
    \ attempt would, of course, be less expensive \nthan challenging every procedure\
    \ call.  The opening of a package would also\nprovide a convenient time for package-dependent\
    \ state information to be\ninitialized.\n\t\t\t\t\tSome Possible Extensions to\
    \ the Model\n\t\t\t\t\tControlling Access to Local Resources\nAdding to the Protocol\
    \ the following pair of system procedures enables the\nenvironment to open and\
    \ close packages within another process.  For \nefficiency, these procedures manipulate\
    \ an arbitrary number of packages\nin a single transaction.\n\tOPNPACKAGE (packages\
    \ ->    pkhs)\n\t\t    LISTofCHARSTRs LISTofINDEXs\n\tCLSPACKAGE (pkhs)\n\t\t\
    \   (as above)\nThe first procedure opens and returns \"package handles PKHS\"\
    \ for the \nspecified PACKAGES; the second closes one or more packages and releases\n\
    the handles PKHS previously obtained for them.\nBesides incorporating these two\
    \ new system procedures, the Protocol must\nfurther require that a package handle\
    \ accompany the procedure name in every\nCALL message (an EMPTY handle perhaps\
    \ designating a system procedure).  Note\nthat this requirement has the side effect\
    \ of making the package the domain\nwithin which procedure names must be unique.\n\
    The system procedures described above enable the environment to make\navailable\
    \ to its applications program, primitives that have calling\nsequences similar\
    \ to those of the corresponding system procedures but\nwhich accept the process\
    \ handle of the target process as an additional\nargument.  Their implementation\
    \ requires only that the environment\nidentify the remote process from its internal\
    \ tables and invoke OPNPACKAGE\nor CLSPACKAGE in that process.\n4.  Standardizing\
    \ Access to Global Variables\nConventional systems often maintain global \"variables\"\
    \ that can be accessed\nby modules throughout the system.  Such variables are\
    \ typically manipulated\nusing primitives of the form:\n    (1)  Return the current\
    \ value of V.\n    (2)  Replace the current contents of V with a new value.\n\
    These primitives are either provided as language constructs or implemented\nby\
    \ specialized procedures.  The former approach encourages uniform\ntreatment of\
    \ all variables within the system.\nThose distributed systems that maintain remotely-accessible\
    \ variables must\nalso select a strategy for implementing the required access\
    \ primitives.  \nWhile such primitives can, of course, be implemented as specialized\n\
    \t\t\t\t       Some Possible Extensions to the Model\n\t\t\t\t    Standardizing\
    \ Access to Global Variables\napplications procedures, adding to the Protocol\
    \ the following new system\nprocedures insures a uniform run-time access mechanism:\n\
    \tRDVARIABLE (pkh,  variable -> value)\n\t\t    INDEX CHARSTR     any\n\tWRVARIABLE\
    \ (pkh,  variable, value)\n\t\t    INDEX CHARSTR   any\nThese procedures effectively\
    \ define variables as named data objects modeled\nfrom PCP data types, and suggest\
    \ that they be clustered in packages with\nrelated procedures.  The system procedures\
    \ return and specify, respectively,\nthe VALUE of the VARIABLE whose name and\
    \ package handle PKH are specified.\nThese new procedures enable the environment\
    \ to make available its applications\nprogram, primitives that have calling sequences\
    \ similar to those of the \ncorresponding system procedures but which accept the\
    \ process handle of the\ntarget process as an additional argument.  These primitives\
    \ provide a basis\nupon which a suitably modified compiler can reestablish the\
    \ compile-time\nuniformity that characterizes the manipulation of variables in\
    \ conventional\nprogramming environments.  Their implementation requires only\
    \ that the local\nenvironment identify the remote process from its internal tables\
    \ and invoke\nRDVARIABLE or WRVARIABLE in that process.\nMost variables will restrict\
    \ the range of data types and values that may be\nassigned to them; some may even\
    \ be read-only.  But because they are modeled\nusing PCP data types, their values\
    \ can, in principle, be arbitrarily complex\n(for example, a LIST of LISTS) and\
    \ the programmer may sometimes wish to\nmanipulate only a single element of the\
    \ variable (or, if the element is \nitself a LIST, just one of its elements; and\
    \ so on, to arbitrary depth).\nAdding the following argument to their calling\
    \ sequences extends the system\nprocedures proposed above to optionally manipulate\
    \ a single element of a\nvariable's composite value:\n\tsubstructure\n\t(LISTofINDEXs)\n\
    At successive levels of the value's tree structure, the INDEX of the desired\n\
    element is identified; the resulting list of indices identifies the\nSUBSTRUCTURE\
    \ whose value is to be returned or replaced.\n\t\t\t\t       Some Possible Extensions\
    \ to the Model\n\t\t\t\t       Routing Parameters Between Procedures\n5.  Routing\
    \ Parameters Between Procedures\nIn conventional programming systems, the results\
    \ of procedures are used in a\nvariety of ways, depending upon the context of\
    \ the calls made upon them.  A\nresult may, for example:\n\t(1)  Provide the basis\
    \ for a branch decision within the calling\n\t     program.\n\t(2)  Become an\
    \ argument to a subsequent procedure call.\n\t(3)  Be ignored and thus effectively\
    \ discarded.\nAt run-time, the knowledge of a result's intended use usually lies\
    \ solely\nwithin the calling program, which examines the results, passes it to\
    \ a\nsecond procedure, or ignores it as it chooses.\nIn a distributed system,\
    \ the transportation of results from callee to caller,\ncarried out by means of\
    \ one of more inter-process messages, can be an\nexpensive operation, especially\
    \ when the results are large.  Data movement \ncan be reduced in Cases 2 and 3\
    \ above by extending the Model to permit the\nintended disposition of each procedure\
    \ result to be made known in advance\nto the callee's environment.  In Case 2,\
    \ provided both callees reside\nwithin the same process, the result can be held\
    \ at its source and later\nlocally supplied to the next procedure.  In Case 3,\
    \ the result can be \ndiscarded at its source (perhaps not even computed), rather\
    \ than sent and\ndiscarded at its destination.\n5.1  Specifying Parameters Indirectly\n\
    Variables offer potential for the eliminating the inefficiencies involved in\n\
    Case 2 above by providing a place within the callees' process where results \n\
    generated by one procedure can be held until required by another.  The\nProtocol\
    \ can be extended to permit variables to be used in this way by \nallowing the\
    \ caller of any procedure to include optional \"argument- and \nresult-list mask\"\
    \ like the following as additional parameters of the CALL\nmessage:\n\tparameter\
    \ list mask\n\t[LIST variable, ...)]\n\t      [CHARSTR]\nA parameter list mask\
    \ would permit each parameter to be transmitted either\ndirectly, via the parameter\
    \ list, or indirectly via a VARIABLE within the\ncallee's process.  Thus each\
    \ element of the mask specifies how the callee's\n\t\t\t\t       Some Possible\
    \ Extensions to the Model\n\t\t\t\t       Routing Parameters Between Procedures\n\
    environment is to obtain or dispose of the corresponding parameter.  To supply\n\
    the result of one procedure as an argument to another, the caller need only\n\
    then appropriately set corresponding elements of the result and argument\nlist\
    \ masks in the first and second calls, respectively.  The result list\nmask should\
    \ be ignored if the procedure fails, and the error number and\ndiagnostic message\
    \ returned directly to the caller.\n5.2  Providing Scratch Variables for Parameter\
    \ Routing\nAlthough each applications program could provide variables for use\
    \ as described\nabove, a more economical approach is to extend the Model to permit\
    \ special\n\"scratch variables,\" maintained by the environment without assistance\
    \ from\nits applications program, to be created and deleted as necessary at run-time.\n\
    Adding to the Protocol the following pair of system procedures enables the\nlocal\
    \ environment to create and delete such variables in a remote process:\n\tCRTVARIABLE\
    \ (variable, value)\n\t\t     CHARSTR   any\n\tDELVARIABLE (variable)\n\t\t  \
    \   CHARSTR\nThese procedures create and delete the specified VARIABLE, respectively.\n\
    CRTVARIABLE also assigns an initial VALUE to the newly-created variable.\nThese\
    \ new procedures enable the environment to make available to its\napplications\
    \ program, primitives that have calling sequences similar to\nthose of the corresponding\
    \ system procedures but which accept the process\nhandle of the target process\
    \ as an additional argument.  Their implementation\nrequired only that the environment\
    \ identify the remote process from its\ninternal tables and invoke CRTVARIABLE\
    \ or DELVARIABLE in that process.\n5.3  Discarding Results\nThe inefficiencies\
    \ that result in Case 3 above are conveniently eliminated\nby allowing the caller\
    \ to identify via the result list mask (for example,\nvia a zero-length CHARSTR)\
    \ that a result will be ignored and therefore need\nnot be returned to the caller.\n\
    \t\t\t\t       Some Possible Extensions to the Model\n\t\t\t   Supporting a Richer\
    \ Spectrum of Control Transfers\n6.  Supporting a Richer Spectrum of Control Transfers\n\
    As currently defined by the Model, a procedure call is a simple two-stage\ndialog\
    \ in which the caller first describes the operation it wishes performed\nand the\
    \ callee, after performing the operation, reports its outcome.  \nAlthough this\
    \ simple dialog form is sufficient to conveniently implement\na large class of\
    \ distributed systems, more complex forms are sometimes \nrequired.  The Model\
    \ can be extended to admit a variety of more powerful \ndialog forms, of which\
    \ the four described below are examples.\n6.1  Transferring Control Between Caller\
    \ and Callee\nMany conventional programming systems permit caller and callee to\
    \ exchange\ncontrol any number of times before the callee returns.  Such \"coroutine\n\
    linkages\" provide a means, for example, by which the callee can obtain \nhelp\
    \ with a problem that it has encountered or deliver the results of one\nsuboperation\
    \ and obtain the arguments for the next.\nAdding to the Protocol the following\
    \ system procedure, whose invocation\nrelinquishes control of another, previously\
    \ initiated procedure, enables\nthe environment to effect a coroutine linkage\
    \ between caller and callee:\n\tTAKEPROCEDURE (tid,  yourtid, parameters)\n \t\
    \t       INDEX BOOLEAN  LIST\nIts arguments include the identifier TID of the\
    \ affected transaction, an\nindication YOURTID of from whose name space the identifier\
    \ was assigned\n(that is, whether the process relinquishing control is the caller\
    \ or callee),\nand PARAMETERS provided by the procedure surrendering control.\
    \  By exploiting \nan existing provision of the Protocol (that is, by declining\
    \ acknowledgment\nof its calls to TAKEPROCEDURE) the invoking environment can\
    \ effect the\ncontrol transfer with a single inter-process message.\nThe addition\
    \ of this new procedure to the Protocol enables the environment\nto provide the\
    \ following new primitive to its applications program:\n\tLINKPROCEDURE (tid,\
    \  arguments -> outcome,  results)\n\t\t       INDEX LIST         [BOOLEAN] LIST\n\
    \t\t\t\t       Some Possible Extensions to the Model\n        \t\t  Supporting\
    \ a Richer Spectrum of Control Transfers\nThis primitive assumes that the CALLPROCEDURE\
    \ primitive is also modified to\nreturn the pertinent transaction identifier should\
    \ the callee initiate a\ncoroutine linkage rather than return.  Invocation of\
    \ LINKPROCEDURE then \ncontinues the dialog by supplying ARGUMENTS and returning\
    \ control to the remote\nprocedure, and then awaiting the next transfer of control\
    \ and the RESULTS that\naccompany it.  If the remote procedure then returns, rather\
    \ than initiating\nanother coroutine linkage, the primitive reports its OUTCOME\
    \ and invalidates \nthe transaction identifier.\nWhile this primitive blocks the\
    \ applications program until the remoter\nprocedure relinquishes control, a variant\
    \ that simply initiates the coroutine\nlinkage and allows the applications program\
    \ to collect the outcome and\nresults in a second operation can also be provided.\n\
    6.2  Signaling the Caller/Callee\nA monolog is often more appropriate than the\
    \ dialog initiated by a coroutine\nlinkage.  The caller or callee might wish,\
    \ for example, to report an event it \nhas detected or send large parameters piecemeal\
    \ to minimize buffering\nrequirements.  Since no return parameters are required\
    \ in such cases, the\ninitiating procedure need only \"signal\" its partner, while\
    \ retaining control\nof the call.\nAdding to the Protocol the following system\
    \ procedure extends the Model to\nsupport signals and enables the environment\
    \ to transmit parameters to or\nfrom another, previously initiated procedure without\
    \ relinquishing control\nof the call:\n\tSGNLPROCEDURE (tid,  yourtid, parameters)\n\
    \t\t       INDEX BOOLEAN  LIST\nLike the TAKEPROCEDURE procedure already described,\
    \ its arguments include\nthe identifier TID of the affected transaction, an indication\
    \ YOURTID of\nfrom whose name space the identifier was assigned, and the PARAMETERS\n\
    themselves.\nThis new procedure enables the environment to make available to its\n\
    applications program a primitive that has a calling sequence similar to that \n\
    of the system procedure but which does not require YOURTID as an argument.\nIts\
    \ implementation requires only that the environment identify the remote\nprocess\
    \ via its internal tables and invoke SGNLPROCEDURE in that process.\n\t\t\t\t\
    \       Some Possible Extensions to the Model\n                      \t   Supporting\
    \ a Richer Spectrum of Control Transfers\nBy requesting the acknowledgment of\
    \ each call to SGNLPROCEDURE and, if \nnecessary, delaying subsequent calls affecting\
    \ the same transaction until\nthe acknowledgment arrives, the invoking environment\
    \ effects a crude form of \nflow control and so prevents the remote process' buffers\
    \ from being overrun.\n6.3  Soliciting Help from Superiors\nAs in conventional\
    \ programming systems, remotely callable procedures within\na distributed system\
    \ will sometimes call upon others to carry out portions\nof their task.  Each\
    \ procedure along the \"thread of control\" resulting from\nsuch nested calls\
    \ is, in a sense, responsible to not only its immediate caller\nbut also to all\
    \ those procedures that lie above it along the control thread.\nTo properly discharge\
    \ its responsibilities, a procedure must sometimes\ncommunicate with these \"\
    superiors.\"\nOccasionally a procedure reaches a point in its execution beyond\
    \ which it\ncannot proceed without external assistance.  It might, for example,\
    \ require\nadditional resources or further direction from the human user upon\
    \ whose\nbehalf it is executing.  Before reaching this impasse, the procedure\
    \ may \nhave invested considerable real and/or processing time that will be lost\n\
    if it aborts.\nAdding to the Protocol the following system procedure minimizes\
    \ such\ninefficiencies by enabling the environment to solicit help from a callee's\n\
    superiors:\n\tHELPPROCEDURE (tid,  number, information -> solution)\n\t\t    \
    \   INDEX INDEX   any            any\nIts arguments include the identifier TID\
    \ of the affected transaction (the\ndirection of the control transfer being implicit\
    \ in this case), a NUMBER\nidentifying the problem encountered, and arbitrary\
    \ supplementary\nINFORMATION.  \nThe primitive that this new procedure enables\
    \ the environment to provide\nits applications program has an identical calling\
    \ sequence.  Its implementation\nrequires only that the environment identify the\
    \ remote process from its\ninternal tables and invoke HELPPROCEDURE in that process.\n\
    The search for help begins with invocation of HELPPROCEDURE in the caller's\n\
    environment.  If the caller understands the problem (that is, recognizes\n   \
    \      \t\t     Supporting a Richer Spectrum of Control Transfers\nits number)\
    \ and is able to solve it, HELPPROCEDURE will simply return whatever\nSOLUTION\
    \ information the caller provides.  Otherwise, HELPPROCEDURE must give\nthe next\
    \ superior an opportunity to respond by calling itself recursively in \nthat process.\
    \  The search terminates as soon as a superior responds positively\nor when the\
    \ end of the control thread is reached.  In the latter case, each of\nthe nested\
    \ HELPPROCEDURE procedures returns unsuccessfully to indicate to its\ncaller that\
    \ the search failed.\n6.4  Reporting an Event to Superiors\nA procedure sometimes\
    \ witnesses or causes an event of which its superiors\nshould be made aware (for\
    \ example, the start or completion of some major\nstep in the procedure's execution).\
    \  Adding to the Protocol the following\nsystem procedure enables the environment\
    \ to notify a callee's superiors of an \narbitrary event:\n\tNOTEPROCEDURE (tid,\
    \  number, information)\n\t\t       INDEX INDEX   any\nLike HELPPROCEDURE, its\
    \ arguments include the identifier TID of the\ntransaction it affects, a NUMBER\
    \ identifying the event being reports, and\narbitrary supplementary INFORMATION.\n\
    The primitive that this new procedure enables the environment to provide its\n\
    applications program has an identical calling sequence.  Its implementation\n\
    requires only that the environment identify the remote process from its\ninternal\
    \ tables and invoke NOTEPROCEDURE in that process.\nBy requesting acknowledgment\
    \ of each call to NOTEPROCEDURE and, if necessary,\ndelaying subsequent calls\
    \ that affect that transaction until the acknowledgment\narrives, the invoking\
    \ environment effects a crude form of flow control and so\nprevents the remote\
    \ process' buffers from being overrun.\nNotification of the procedure's superiors\
    \ begins with invocation of \nNOTEPROCEDURE in the caller's process and works\
    \ its way recursively up the\nthread of control until the top is reached.\n\t\t\
    \t\t         Some Possible Extensions to the Model\n\t\t\t\t\t\t Aborting Executing\
    \ Procedures\n7.  Aborting Executing Procedures\nConventional systems that accept\
    \ commands from the user sometimes permit him\nto cancel an executing command\
    \ issued inadvertently or with erroneous\nparameters, or one for whose completion\
    \ he cannot wait.  This ability is\nparticularly important when the command (for\
    \ example, one that compiles a\nsource file) has a significant execution time.\
    \  In a distributed system, the\nexecution of such a command may involve the invocation\
    \ of one or more remote\nprocedures.  Its cancellation, therefore, requires the\
    \ abortion of any \noutstanding remote procedure calls.\nAdding to the Protocol\
    \ the following system procedure provides the basis\nfor a command cancellation\
    \ facility by enabling the environment to abort\nanother, previously invoked procedure:\n\
    \tABRTPROCEDURE (tid)\n\t\t       INDEX\nIts sole argument is the identified TID\
    \ of the transaction it affects.\nThe primitive that this new procedure enables\
    \ the environment to make \navailable to the applications program has an identical\
    \ calling sequence.\nIts implementation requires only that the local environment\
    \ identify the\nremote process from its internal tables and invoke ABRTPROCEDURE\
    \ in that\nprocess.\n\t\t\t\t\t\t\t\t Conclusions\n                          \
    \    CONCLUSION\nThe EXPANDED Protocol and Model that result from the extensions\
    \ proposed in\nthe present paper are summarized in Appendixes B and C, respectively.\
    \  \nNeedless to say, many additional forms and aspects of process interaction,\n\
    of which Appendix D suggests a few, remain to be explored.  Nevertheless,\nthe\
    \ primitives already made available by the run-time environment provide\nthe applications\
    \ programmer with a powerful and coherent set of tools for\nconstructing distributed\
    \ systems.\n\t\t\t\t\t\t\t     Acknowledgments\n                           ACKNOWLEDGMENTS\n\
    Many individuals within both SRI's Augmentation Research Center (ARC) and the\n\
    larger ARPANET community have contributed their time and ideas to the\ndevelopment\
    \ of the Protocol and Model described in this and its companion\npaper.  The contributions\
    \ of the following individuals are expressly\nacknowledged:  Dick Watson, Jon\
    \ Postel, Charles Irby, Ken Victor, Dave Maynard,\nLarry Garlick of ARC; and Bob\
    \ Thomas and Rick Schantz of Bolt, Beranek and\nNewman, Inc. \nARC has been working\
    \ toward a high-level framework for network-based\ndistributed systems for a number\
    \ of years now [2].  The particular Protocol\nand Model result from research begun\
    \ by ARC in July of 1974.  This research \nincluded developing the Model; designing\
    \ and documenting, and implementing\na prototype run-time environment for a particular\
    \ machine [4, 5], specifically\na PDP-10 running the Tenex operating system developed\
    \ by Bolt, Beranek and\nNewman, Inc. [6].  Three design iterations were carried\
    \ out during a 12-month\nperiod and the resulting specification implemented for\
    \ Tenex.  The Tenex RTE\nprovides a superset of the capabilities proposed in this\
    \ paper.\nThe work reported here was supported by the Advanced Research Project\
    \ Agency\nof the Department of Defense, and by the Rome Air Development Center\
    \ of the\nAir Force.\n\t\t\tAppendix A:  Transmission Formats for PCP Data Objects\n\
    \                              APPENDIX A\n              TRANSMISSION FORMATS\
    \ FOR PCP DATA OBJECTS\nData objects must be encoded in a standard transmission\
    \ format before they can\nbe sent from one process to another via the Protocol.\
    \  An effective strategy \nis to define several formats and select the most appropriate\
    \ one at run-time,\nadding to the Protocol a mechanism for format negotiation.\
    \  Format negotiation\nwould be another responsibility of the environment and\
    \ could thus be made\ncompletely invisible to the applications program.\nSuggested\
    \ below are two transmission formats.  The first is a 36-bit binary\nformat for\
    \ use between 36-bit machines, the second an 8-bit binary, \"universal\"\nformat\
    \ for use between dissimilar machines.  Data objects are fully typed in \neach\
    \ format to enable the environment to automatically decode and internalize\nincoming\
    \ parameters should it be desired to provide this service to the\napplications\
    \ program.\nPCPB36, For Use Between 36-Bit Machines\n\tBits  0-13 Unused (zero)\n\
    \tBits 14-17 Data type\n\t   EMPTY  =1  INTEGER=4  LIST=7\n\t   BOOLEAN=2  BITSTR\
    \ =5\n\t   INDEX  -3  CHARSTR=6\n\tBits 18-20 Unused (zero)\t\n\tBits 21-35 Value\
    \ or length N\n\t   EMPTY       unused (zero)\n\t   BOOLEAN     14 zero-bits +\
    \ 1-bit value (TRUE=1/FALSE=0)\n\t   INDEX       unsigned value\n\t   INTEGER\
    \     unused (zero)\n\t   BITSTR      unsigned bit count N\n\t   CHARSTR     unsigned\
    \ character count N\n\t   LIST        unsigned element count N\n\tBits 36-   Value\n\
    \t   EMPTY    unused (nonexistent)\n\t   BOOLEAN  unused (nonexistent)\n\t   INDEX\
    \    unused (nonexistent)\n\t   INTEGER  two's complement full-word value\n\t\
    \   BITSTR   bit string + zero padding to word boundary\n\t   CHARSTR  ASCII string\
    \ + zero padding to word boundary\n\t   LIST     element data objects\nNetwork\
    \ Working\t\t\t                              James E. White\n\t              Appendix\
    \ A:  Transmission Formats for PCP Data Objects\nPCPB8, For Use Between Dissimilar\
    \ Machines\n\tByte    0  Data type\n\t   EMPTY  =1  INTEGER=4  LIST=7\n\t   BOOLEAN=2\
    \  BITSTR =5\n\t   INDEX  =3  CHARSTR=6\n\tBytes 1-   Value\n\t   EMPTY      unused\
    \ (nonexistent)\n\t   BOOLEAN    7 zero-bits + 1-bit value (TRUE=1/FALSE=0\n\t\
    \   INDEX      2 byte unsigned value\n\t   INTEGER    4-type two's complement\
    \ value\n\t   BITSTR     2-byte unsigned bit count N + bit string\n\t\t      \
    \ + zero padding to byte boundary\n\t   CHARSTR    2-byte unsigned character count\
    \ N + ASCII string\n\t   LIST\t      2-byte element count N + element data objects\n\
    \t\t\t   Appendix B:\tThe Expanded Procedure Call Protocol\n                 \
    \             APPENDIX B\n                 THE EXPANDED PROCEDURE CALL PROTOCOL\n\
    The Protocol that results from the extensions proposed in this paper is\nsummarized\
    \ below.  The reader should note the concise syntactic description\nmade possible\
    \ by the underlying notion of PCP data types.\nParameter list masks have been\
    \ included not only as additional parameters\nof the CALL message, as proposed\
    \ in the paper, but as arguments of the\nTAKEPROCEDURE and SGNLPROCEDURE system\
    \ procedures as well.  Throughout the\nProtocol description, \"MASK\" is shorthand\
    \ for:\n\t[LIST (variable [CHARSTR], ...)]\nMessages\n\tLIST (route INDEX, opcode\
    \ INDEX CALL=1, tid [INDEX],\n\t      pkh [INDEX], procedure CHARSTR, arguments\
    \ LIST,\n\t      argumentlistmask MASK, resultlistmask MASK)\n\tLIST (route INDEX,\
    \ opcode INDEX RETURN=2, tid INDEX,\n\t      outcome BOOLEAN, results LIST)\n\t\
    \   If OUTCOME is FALSE\n\t      RESULTS is LIST (error INDEX, diagnostic CHARSTR)\n\
    Process-Related System Procedures\n\tINIPROCESS (program CHARSTR,\n\t\t    credentials\
    \ LIST (error CHARSTR, password CHARSTR,\n\t\t\t\t      account CHARSTR))\n\t\
    ALOPORT    (-> ph INDEX, computer CHARSTR, port)\n\tCNNPORT    (ph INDEX, computer\
    \ CHARSTR, port)\n\tDCNPORT    (ph INDEX)\n\tCRTROUTE   (mycode INDEX, oldcode\
    \ [INDEX]\n\t\t    -> code INDEX, ph INDEX)\n\tDELROUTE   (yourcode INDEX)\nPackage-Related\
    \ System Procedures\n\tOPNPACKAGE (packages LISTofCHARSTRs -> pkhs LISTofINDEXs)\n\
    \tCLSPACKAGE (pkhs LISTofINDEXs)\n\t\t\t   Appendix B:  The Expanded Procedure\
    \ Call Protocol\nVariable-Related System Procedures\n\tCRTVARIABLE (variable CHARSTR,\
    \ value)\n\tDELVARIABLE (variable CHARSTR)\n\tRDVARIABLE  (pkh INDEX, variable\
    \ CHARSTR,\n\t\t     substructure [LISTofINDEXs] -> value)\nProcedure-Related\
    \ System Procedures\n\tTAKEPROCEDURE (tid INDEX, yourtid BOOLEAN, parameters LIST,\n\
    \t\t       argumentlistmask MASK, resultlistmask MASK)\n\tSGNLPROCEDURE (tid INDEX,\
    \ yourtid BOOLEAN, parameters LIST,\n\t\t       parameterlistmask MASK)\n\tHELPPROCEDURE\
    \ (tid INDEX, number INDEX, information -> solution)\n\tNOTEPROCEDURE (tid INDEX,\
    \ number INDEX, information)\n\tABRTPROCEDURE (tid INDEX)\n\t\t\t\t\tAppendix\
    \ C:  Summary of RTE Primitives\n                              APPENDIX C\n  \
    \                    SUMMARY OF RTE PRIMITIVES\nThe DPS primitives made available\
    \ to the applications program as a result of\nthe Model extensions proposed in\
    \ this paper are summarized below.  \nCollectively, they provide the applications\
    \ programmer with a powerful\nand coherent set of tools for constructing distributed\
    \ systems.  Some of\nthe primitives (for example, CRTPROCESS and DELPROCESS) are\
    \ necessary elements\nfor a \"network operating system (NOS),\" into which DPS\
    \ may itself one day\nevolve.\n\tCRTPROCESS (computer, program, credentials ->\
    \ PH)\n\tDELPROCESS (ph)\n\tITDPROCESS (ph1, ph2 -> ph12, ph21, ih)\n\tSEPPROCESS\
    \ (ih)\nPackages\n\tOPNPACKAGE (ph, packages -> pkhs)\n\tCLSPACKAGE (ph, pkhs)\n\
    Variables\n\tCRTVARIABLE (ph, variable, value)\n\tDELVARIABLE (ph, variable)\n\
    \tRDVARIABLE  (ph, pkh, variable, substructure -> value)\n\tWRTVARIABLE (ph, pkh,\
    \ variable, substructure, value)\nProcedures\n\tCALLPROCEDURE (ph, pkh, procedure,\
    \ arguments, argumentlistmask,\n\t\t       resultlistmask, -> outcome, results,\
    \ tid)\n\tLINKPROCEDURE (tid, arguments, argumentlistmask,\n\t\t       resultlistmask,\
    \ -> outcome, results)\n\tSGNLPROCEDURE (tid, parameters, parameterlistmask)\n\
    \tHELPPROCEDURE (tid, number, information -> solution)\n\tNOTEPROCEDURE (tid,\
    \ number, information)\n\tABRTPROCEDURE (tid)\n                              APPENDIX\
    \ D\n                  ADDITIONAL AREAS FOR INVESTIGATION\nAlthough the expanded\
    \ distributed programming system developed in this paper\nand summarized in the\
    \ previous appendix is already very powerful, many\nadditional aspects of process\
    \ interaction remain, of course, to be explored.\nAmong the additional facilities\
    \ that the Protocol must eventually enable the\nenvironment to provide are mechanisms\
    \ for:\n\t(1)  Queuing procedure calls for long periods of time (for\n\t     example,\
    \ days).\n\t(2)  Broadcasting requests to groups of processes.\n\t(3)  Subcontracting\
    \ work to other processes (without remaining\n\t     a middleman).\n\t(4)  Supporting\
    \ brief or infrequent inter-process exchanges\n\t     with minimal startup overhead.\n\
    \t(5)  Recovering from and restarting after system errors.\n                 \
    \             REFERENCES\n1.  White, J. E., \"A High-Level Framework for Network-Based\
    \ Resource Sharing,\"\n    submitted for publication in the AFIPS Conference Proceedings\
    \ of the 1976\n    National Computer Conference.\n2.  Watson, R. W., Some Thoughts\
    \ on System Design to Facilitate Resource\n    Sharing, ARPA Network Working Group\
    \ Request for Comments 592, Augmentation\n    Research Center, Stanford Research\
    \ Institute, Menlo Park, California,\n    November 20, 1973 (SRI-ARC Catalog Item\
    \ 20391).\n3.  White, J. E., DPS-10 Version 2.5 Implementor's Guide, Augmentation\n\
    \    Research Center, Stanford Research Institute, Menlo Park, California,\n \
    \   August 15, 1975 (SRI-ARC Catalog Item 26282).\n4.  White, J. E., DPS-10 Version\
    \ 2.5 Programmer's Guide, Augmentation Research\n    Center, Stanford Research\
    \ Institute, Menlo Park, California, August 13, \n    1975 (SRI-ARC Catalog Item\
    \ 26271).\n5.  White, J. E., DPS-10 Version 2.5 Source Code, Augmentation Research\n\
    \    Center, Stanford Research Institute, Menlo Park, California, August 13,\n\
    \    1975 (SRI-ARC Catalog Item 26267).\n6.  Bobrow, D. G., Burchfiel, J. D.,\
    \ Murphy, D. L., Tomlinson, R. S., \"TENEX,\n    a paged Time Sharing System for\
    \ the PDP-10,\" Communications of the ACM,\n    Vol. 15, No. 3, pp. 135-143, March\
    \ 1972.\n                             FIGURE LIST\nFig. 1\tInterfacing distant\
    \ applications programs via their run-time\n\tenvironments and an IPC channel.\n\
    Fig. 2\tTwo processes that can only be introduced via a logical channel.\nFig.\
    \ 3  A logical channel.\n"
