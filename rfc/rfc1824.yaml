- title: __initial_text__
  contents:
  - "                 The Exponential Security System TESS:\n                An Identity-Based\
    \ Cryptographic Protocol\n                     for Authenticated Key-Exchange\n\
    \                        (E.I.S.S.-Report 1995/4)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This informational RFC describes the basic mechanisms  and  functions\n\
    \   of  an identity based system for the secure authenticated exchange of\n  \
    \ cryptographic keys, the generation of signatures, and  the  authentic\n   distribution\
    \ of public keys.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and preliminary remarks . . . . . . .\
    \ . . . . . .  2\n       1.1.  Definition of terms/Terminology  . . . . . . .\
    \ . . . . .  2\n       1.2.  Required mechanisms  . . . . . . . . . . . . . .\
    \ . . . .  4\n   2.  Setup  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  5\n       2.1.  SKIA Setup . . . . . . . . . . . . . . . . . . . . .\
    \ . .  5\n       2.2.  User Setup . . . . . . . . . . . . . . . . . . . . . .\
    \ .  5\n   3.  Authentication . . . . . . . . . . . . . . . . . . . . . . . .\
    \  7\n       3.1.  Zero Knowledge Authentication  . . . . . . . . . . . . .  7\n\
    \       3.2.  Unilateral Authentication  . . . . . . . . . . . . . . .  8\n  \
    \     3.3.  Mutual Authentication  . . . . . . . . . . . . . . . . .  9\n    \
    \   3.4.  Message Signing  . . . . . . . . . . . . . . . . . . . . 10\n   4. \
    \ Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . 10\n       4.1.\
    \  Non-Escrowed Key Generation  . . . . . . . . . . . . . . 11\n       4.2.  Hardware\
    \ Protected Key . . . . . . . . . . . . . . . . . 11\n       4.3.  Key Regeneration\
    \ . . . . . . . . . . . . . . . . . . . . 12\n       4.4.  r ^ r  . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . 13\n       4.5.  Implicit Key Exchange\
    \  . . . . . . . . . . . . . . . . . 13\n       4.6.  Law Enforcement  . . . .\
    \ . . . . . . . . . . . . . . . . 13\n       4.7.  Usage of other Algebraic Groups\
    \  . . . . . . . . . . . . 14\n             4.7.1  DSA subgroup SKIA Setup . .\
    \ . . . . . . . . . . . 14\n             4.7.2  Escrowed DSA subgroup User Setup\
    \  . . . . . . . . 14\n             4.7.3  Non-Escrowed DSA subgroup User Setup\
    \  . . . . . . 15\n             4.7.4  DSA subgroup Authentication . . . . . .\
    \ . . . . . 15\n   5.  Multiple SKIAs . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 15\n       5.1.  Unstructured SKIAs . . . . . . . . . . . . . . . .\
    \ . . . 15\n       5.2.  Hierarchical SKIAs . . . . . . . . . . . . . . . . .\
    \ . . 16\n       5.3.  Example: A DNS-based public key structure  . . . . . .\
    \ . 18\n   Security Considerations  . . . . . . . . . . . . . . . . . . . . .\
    \ 19\n   References . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\
    \   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 21\n"
- title: 1.  Introduction and preliminary remarks
  contents:
  - "1.  Introduction and preliminary remarks\n   This RFC describes The Exponential\
    \ Security System TESS [1].  TESS is\n   a toolbox set system of different but\
    \ cooperating cryptographic\n   mechanisms and functions based on the primitive\
    \ of discrete\n   exponentiation. TESS is based on asymmetric cryptographical\
    \ protocols\n   and a structure of self-certified public keys.\n   The most important\
    \ mechanisms TESS is based on are the ElGamal\n   signature [2, 3] and the KATHY\
    \ protocols (KeY exchange with embedded\n   AuTHentication), which were simultaneously\
    \ discovered by Guenther [4]\n   and Bauspiess and Knobloch [5, 6, 7].\n   This\
    \ RFC explains how to create and use the secret and public keys of\n   TESS and\
    \ shows a method for the secure distribution of the public\n   keys.\n   It is\
    \ expected that the reader is familiar with the basics of\n   cryptography, the\
    \ Discrete Logarithm Problem, and the ElGamal\n   signature mechanism.\n   Due\
    \ to the ASCII representation of this RFC the following style is\n   choosen for\
    \ mathematical purposes:\n   -  a  ^  b  means the exponentiation of a to the\
    \ power of b, which is\n      always used within a modulo context.\n   -  a[b]\
    \ means a with an index or subscription of b.\n   -  a = b means equality or congruency\
    \ within a modulo context.\n"
- title: 1.1.  Definition of terms/Terminology
  contents:
  - "1.1.  Definition of terms/Terminology\n   Key pair\n      A key pair is a set\
    \ of a public and a secret key which belong\n      together.  There are two distinct\
    \ kinds of key pairs, the SKIA key\n      pair and the User key pair. (As will\
    \ be shown in the section about\n      hierarchical SKIAs, the two kinds of keys\
    \ are not really distinct.\n      They are the same thing seen from a different\
    \ point of view.)\n   User\n      Any principal (human or machine) who owns, holds\
    \ and uses a User\n      key pair and can be uniquely identified by any description\
    \ (see\n      the Identity Descriptor below).\n      In this RFC example users\
    \ are referred to as A, B, C or Alice and\n      Bob.\n   SKIA\n      SKIA is\
    \ an acronym for \"Secure Key Issuing Authority\". The SKIA is\n      a trusted\
    \ local authority which generates the public and secret\n      part of a User\
    \ key pair. It is the SKIA's duty to verify whether\n      the identity encoded\
    \ in the key pair (see below) belongs to the\n      key holder.  It has to check\
    \ passports, identity cards, driving\n      licenses etc. to investigate the real\
    \ world identity of the key\n      owner.  Since every key has an implicite signature\
    \ of the SKIA it\n      came from, the SKIA is responsible for the correctness\
    \ of the\n      encoded identity.\n      Since the SKIA has to check the real\
    \ identity of users, it is\n      usually able to work within a small physical\
    \ range only (like a\n      campus or a city).  Therefore, not all users of a\
    \ wide area or\n      world wide area network can get their keys from the same\
    \ SKIA with\n      reasonable expense.  There is the need for multiple SKIAs which\n\
    \      can work locally. This implies the need of a web of trust levels\n    \
    \  and trust forwards.  Communication partners with keys from the\n      same\
    \ SKIA know the public data of their SKIA because it is part of\n      their own\
    \ key.  Partners with keys from different SKIAs have to\n      make use of the\
    \ web to learn about the origin, the trust level,\n      and the public key of\
    \ the SKIA which issued the other key.\n   Id[A] Identity Descriptor\n      The\
    \ Identity Descriptor is a part of the public User key. It is a\n      somehow\
    \ structured bitstring describing the key owner in a certain\n      way. This\
    \ description of the key owner should be precise enough to\n      fully identify\
    \ the owner of a User key. The description depends on\n      the nature of the\
    \ owner. For a human this could be the name, the\n      address, the phone number,\
    \ date of birth, size of the feet, color\n      of the eyes, or anything else.\
    \ For a machine this could be the\n      hostname, the hostid, the internet address\
    \ etc., for a fax machine\n      or a modem it could be the international phone\
    \ number.\n      Furthermore, the description bitstring could contain key\n  \
    \    management data as the name of the SKIA (see below) which issued\n      the\
    \ key, the SKIA-specific serial number, the expiry date of the\n      key, whether\
    \ the secret part of the key is a software key or\n      hidden in a hardware\
    \ device (see section Enhancements), etc.\n      Note that the numerical interpretation\
    \ (the hash value) of the\n      Identity Descriptor is an essential part of the\
    \ mathematical\n      mechanism of the TESS protocol. It can not be changed in\
    \ any way\n      without destroying the key structure.  Therefore, knowing the\n\
    \      public part of a user key pair always means knowing the Identity\n    \
    \  Descriptor as composed by the SKIA which issued this key. This is\n      an\
    \ important security feature of this mechanism.\n      The contents of the Identity\
    \ Descriptor have to be verified by the\n      issuing SKIA at key generation\
    \ time. The trust level of the User\n      Key depends on the trust level of the\
    \ SKIA. A certain Identity\n      Descriptor must not be used more than once for\
    \ creating a User\n      Key.  There must not exist distinct keys with the same\
    \ Identity\n      Descriptor.  Nevertheless, a user may have several keys with\n\
    \      distinct expiration times, key lengths, serial numbers, or\n      security\
    \ levels, which affect the contents of the Identity\n      Descriptor.\n     \
    \ However, it is emphasized that there are no assumptions about the\n      structure\
    \ of the Identity Descriptor.  The SKIA may choose any\n      construction method\
    \ depending on its purposes.\n      The Identity Descriptor of a certain user\
    \ A is referred to as\n      Id[A].  Whereever the Identity Descriptor Id[A] is\
    \ used in a\n      mathematical context, its cryptographical hash sum H(Id[A])\
    \ is\n      used.\n   Encrypt(Key,Message)\n   Decrypt(Key,Message)\n      Encryption\
    \ and Decryption of the Message with any common cipher.\n"
- title: 1.2.  Required mechanisms
  contents:
  - "1.2.  Required mechanisms\n   The protocols described in this RFC require the\
    \ following\n   submechanisms:\n   -  A random number generator of cryptographic\
    \ quality\n   -  A prime number generator of cryptographic quality\n   -  A hash\
    \ mechanism H() of cryptographic quality\n   -  An encryption mechanism (e.g.\
    \ a common block cipher)\n   -  An arithmetical library for long unsigned integers\n\
    \   -  A method for checking network identities against real-world\n      identities\
    \ (e.g. an authority which checks human identity cards\n      etc.)\n"
- title: 2.  Setup
  contents:
  - "2.  Setup\n   This section describes the base method for the creation of the\
    \ SKIA\n   and the User key pairs. Enhancements and modifications are described\n\
    \   in subsequent sections.\n   The main idea of the protocols described below\
    \ is to generate an\n   ElGamal signature (r,s) for an Identity Descriptor Id[A]\
    \ of a user A.\n   Id[A] and r form the user's public key and s is the users secret\
    \ key.\n   The connection between the secret and the public key is the\n   verification\
    \ equation for the ElGamal signature (r,s). Instead of\n   checking the signature\
    \ (r,s), the equation is used in 'reverse mode'\n   to calculate r^s from public\
    \ data without knowledge of the secret s.\n   The authority generating those signatures\
    \ is the SKIA introduced\n   above.\n"
- title: 2.1.  SKIA Setup
  contents:
  - "2.1.  SKIA Setup\n   By the following steps the SKIA key pair is created:\n \
    \  -  p: choose a large prime p of at least 512 bit length.\n   -  g: choose a\
    \ primitive root g in GF(p)\n   -  x: choose a random number x in the range 1\
    \ < x < p-1\n   -  y:= ( g ^ x )  mod p\n   The public part of the SKIA is the\
    \ triple (p,g,y), the secret part is\n   x.\n   Since the public triple (p,g,y)\
    \ is needed within the verification\n   equation for the signatures created by\
    \ the SKIA, this triple is also\n   an essential part of all user keys generated\
    \ by this SKIA.\n"
- title: 2.2.  User Setup
  contents:
  - "2.2.  User Setup\n   The User Setup is the generation of an ElGamal signature\
    \ on the\n   user's Identity Descriptor by the SKIA. This can be done more than\n\
    \   once for a specific User, but it is done only once for a specific\n   Identity\
    \ Descriptor.\n   To create a User key pair for a User A, the SKIA has to perform\
    \ the\n   following steps:\n   -  Id[A]: Describe the key owner A in any way (name,\
    \ address,  etc.),\n      convert this description into a bit- or byte-oriented\n\
    \      representation, and concatenate them to form the Identity\n      Descriptor\
    \ Id[A].\n   -  k[A]: choose a random number k[A] with gcd(k[A],p-1) = 1. k[A]\n\
    \      must not be revealed by the SKIA.\n   -  r[A] := ( g ^ k[A] ) mod p\n \
    \  -  s[A] := ( H(Id[A])  - x * r[A] ) *  ( k[A] ^ -1 )    mod (p-1)\n   The calculated\
    \ set of numbers fulfills the equation:\n      x * r[A] + s[A] * k[A] = H(Id[A])\
    \  mod (p-1).\n   The public part of the generated key of A consists of Id[A]\
    \ and r[A],\n   referenced to as (Id[A],r[A]) in the context of the triple (p,g,y).\n\
    \   (Id[A],r[A]) always implicitely refers to the triple (p,g,y) of its\n   parent\
    \ SKIA.\n   The secret part of the key is s[A].\n   k[A] must be destroyed by\
    \ the SKIA immediately after key generation,\n   because User A could solve the\
    \ equation and find out the SKIAs secret\n   x if he knew both the s[A] and k[A].\
    \  The random number k must not be\n   used twice. s[A] must not be equal to 0.\n\
    \   Since (r[A],s[A]) are the ElGamal signature on Id[A], the connection\n   between\
    \ the SKIA public key und the User key pair is the ElGamal\n   verification equation:\n\
    \      r[A] ^ s[A] =  ( g ^ H(Id[A]) ) * ( y ^  (-r[A]) )  mod p.\n   This equation\
    \ allows to calculate r[A] ^ s[A] from public data\n   without knowledge of the\
    \ secret s[A].  Since this equation is used\n   very often, and for reasons of\
    \ readability, the abbreviation Y[A] is\n   used for this equation.\n   Y[A] means\
    \ to calculate the value of r[A] ^ s[A] which is\n      ( g ^ H(Id[A]) ) * ( y\
    \ ^ (-r[A]) )  mod p.\n   Note that a given value of Y[A] is not reliable. It\
    \ must have been\n   reliably calculated from (p,g,y) and (Id[A],r[A]).  Y[A]\
    \ is to be\n   understood as a macro definition, not as a value.\n   Obviously\
    \ both the SKIA and the User know the secret part of the\n   User's key and can\
    \ reveal it, either accidently or in malice\n   prepense.  The enhancements section\
    \ below shows methods to avoid\n   this.\n"
- title: 3.  Authentication
  contents:
  - "3.  Authentication\n   This section describes the basic methods of applying the\
    \ User keys.\n   They refer to online and offline communication between two users\n\
    \   A(lice) and B(ob).\n   The unilateral and the mutual authentications use the\
    \ KATHY protocol\n   to generate reliable session keys for further use as session\n\
    \   encryption keys etc.\n"
- title: 3.1.  Zero Knowledge Authentication
  contents:
  - "3.1.  Zero Knowledge Authentication\n   The \"Zero Knowledge Authentication\"\
    \ is used if Alice wants to\n   authenticate herself to Bob without need for a\
    \ session key.\n   Assuming that Bob already reliably learned the (p,g,y) of the\
    \ SKIA\n   Alice got her key from, the steps are:\n   1. Alice generates a large\
    \ random number t, 1<t<p-1, where  t  should\n      have approximately the same\
    \ length as p-1.\n   2. a := r[A] ^ t  mod p\n   3. Alice sends her public key\
    \ (Id[A],r[A]) and the number a to Bob.\n   4. Bob  generates a large random number\
    \ c, c<p-1, where c should have\n      approximately the same length as p-1, and\
    \ sends c to Alice.\n   5. Alice calculates\n      c' := (c * s[A] + t) mod (p-1)\n\
    \      and sends c' to Bob.\n   6. Bob verifies whether\n      r[A] ^ c' = (Y[A]\
    \ ^ c) * a    mod p.\n   This is the Beth-Zero-Knowledge protocol [8] which is\
    \ based on self-\n   certified public keys and an improvement of the DLP-Zero-Knowledge\n\
    \   identification protocol from Chaum, Evertse, and van de Graaf [9].\n"
- title: 3.2.  Unilateral Authentication
  contents:
  - "3.2.  Unilateral Authentication\n   The \"Unilateral Authentication\" (or \"\
    Half Authentication\") can be\n   used in those cases:\n   - Alice wants to authenticate\
    \ herself to Bob without Bob\n     authenticating himself to Alice.\n   - Bob\
    \ wants to send an encrypted message to Alice readable by her\n     only (offline\
    \ encryption).\n   A shared key is generated by the following protocol. This key\
    \ can be\n   known by Alice and Bob only.\n   Assuming that Bob already reliably\
    \ learned the (p,g,y) of the SKIA\n   Alice got her key from, the steps are:\n\
    \   1. Alice sends her public key (Id[A],r[A]) to Bob if he does not\n      already\
    \ know it.\n   2. Bob chooses a random number 1 < z[A] < p-1 and calculates\n\
    \      v[A] := r[A] ^ z[A] mod p\n   3. Bob sends v[A] to Alice.\n   4. Alice\
    \ and Bob calculate the session key:\n      Alice: key[A] := v[A] ^ s[A] mod p\n\
    \      Bob:   key[A] := Y[A] ^ z[A] mod p\n   Apply the equations of the User\
    \ Key Setup section to Bob's equation\n   to see that Alice and Bob get the very\
    \ same key in step 4:\n      key[A] = r[A] ^ ( s[A] * z[A] ) mod p\n   A third\
    \ party cannot calculate key[A], because it has neither s[A]\n   nor z[A]. Therefore,\
    \ Bob can trust in the fact that only Alice is\n   able to know the key[A] (as\
    \ long as nobody else knows her secret\n   s[A]).\n   This protocol is based on\
    \ the Diffie-Hellman scheme [10], but avoids\n   the weakness of the missing authenticity\
    \ of the public keys.\n   In this protocol Bob did not verify whether Alice really\
    \ knew her\n   s[A] and was able to calculate key[A]. Therefore, a final challenge-\n\
    \   response step should be performed in case of online communication\n   (see\
    \ the subsection below).\n   In case of sending encrypted messages, Bob can execute\
    \ step 4 before\n   step 3, use the key[A] to encrypt the message, and send the\
    \ encrypted\n   message together with v[A] in step 3.\n"
- title: 3.3.  Mutual Authentication
  contents:
  - "3.3.  Mutual Authentication\n   The \"Mutual Authentication\" is used for online\
    \ connections where both\n   Alice and Bob want to authenticate to each other.\n\
    \   Within this protocol description it is assumed that Alice and Bob\n   have\
    \ keys of the same SKIA and use the same triple (p,g,y). Otherwise\n   in each\
    \ step the triple has to be used which belongs to the user key\n   it is applied\
    \ to.\n   The steps are as follows (where the first four steps are exactly\n \
    \  twice the \"Unilateral Authentication\" and steps 5-9 form a mutual\n   challenge-response\
    \ step to find out whether the other side really got\n   the key):\n   1. Alice\
    \ sends her (Id[A],r[A]) to Bob.\n      Bob sends his (Id[B],r[B]) to Alice.\n\
    \   2. Bob chooses a random number z[A] < p-1\n      and calculates v[A] := r[A]\
    \ ^ z[A] mod p\n      Alice chooses a random number z[B] < p-1\n      and calculates\
    \ v[B] := r[B] ^ z[B] mod p\n   3. Bob sends v[A] to Alice.\n      Alice sends\
    \ v[B] to Bob.\n   4. Alice and Bob calculate the session keys:\n      Alice:\
    \ key[A] := v[A] ^ s[A] mod p\n             key[B] := Y[B] ^ z[B] mod p\n    \
    \  Bob:   key[B] := v[B] ^ s[B] mod p\n             key[A] := Y[A] ^ z[A] mod\
    \ p\n   5. Alice chooses a random number R[B]\n      Bob   chooses a random number\
    \ R[A]\n   6. Alice sends Encrypt(key[B],R[B]) to Bob.\n      Bob   sends Encrypt(key[A],R[A])\
    \ to Alice.\n   7. Alice and Bob decrypt the received messages to R'[A] and R'[B].\n\
    \   8. Alice sends Encrypt(key[A],T(R'[A])) to Bob.\n      Bob   sends Encrypt(key[B],T(R'[B]))\
    \ to Alice.\n   9. Alice and Bob decrypt the received messages to R''[A] and R''[B]\n\
    \  10. Alice verifies whether T(R[B]) = R''[B].\n      Bob   verifies whether\
    \ T(R[A]) = R''[A].\n   T()  is a simple bijective transformation function, e.g.\
    \ increment().\n   After step 4 Alice can trust in the fact that only Bob and\
    \ herself\n   can know key[B], but she still does not know whether she is really\n\
    \   talking to Bob. Therefore, she forces Bob to make use of his key\n   within\
    \ steps 5-9. Alice now has checked whether she really talks to\n   Bob. Since\
    \ the scheme is symmetrical, Bob also knows that he talks to\n   Alice.\n"
- title: 3.4.  Message Signing
  contents:
  - "3.4.  Message Signing\n   To sign a message m (where H(m) is a cryptographic\
    \ hash value of the\n   message), the message author A generates an ElGamal signature\
    \ by\n   using his r[A] as the generator and the s[A] as his secret:\n   -  A\
    \ generates a random number K with gcd(K,p-1) = 1.\n   -  R := r[A] ^ K mod p\n\
    \   -  S := ( H(m) - s[A] * R ) * (K ^ -1)   mod (p-1)\n   The calculated set\
    \ of numbers fulfills the equation:\n      ( s[A] * R + K * S ) = H(m) mod(p-1)\n\
    \   The signed message consists of (m,Id[A],r[A],R,S).\n   The receiver of the\
    \ message checks the authenticity of the message by\n   calculating the hash value\
    \ H(m) and verifying the equation:\n      r[A] ^ H(m) = ( Y[A] ^ R )  * ( R ^\
    \ S )  mod p\n"
- title: 4.  Enhancements
  contents:
  - "4.  Enhancements\n   This section describes several enhancements and modifications\
    \ of the\n   base protocol as well as other comments.\n"
- title: 4.1.  Non-Escrowed Key Generation
  contents:
  - "4.1.  Non-Escrowed Key Generation\n   Within the normal User Setup procedure\
    \ for a User A, the SKIA gains\n   knowledge about the secret key s[A]. The SKIA\
    \ could use this key to\n   fake signatures or decrypt messages, or to allow others\
    \ to do so.\n   To avoid this situation, a slight modification of the User Setup\n\
    \   procedure may be applied. The SKIA Setup is the same as in the base\n   protocol.\n\
    \   Within the User Setup the SKIA does not use its primitive element g,\n   but\
    \ a generator created by the User instead.\n   The modified scheme looks like\
    \ this:\n   -  User A generates a random number a with gcd(a,p-1)=1\n   -  User\
    \ A calculates g' := g^a mod p and forwards g' to the SKIA.\n   -  The SKIA generates\
    \ Id[A] and k[A] as in the base protocol\n   -  The SKIA sets r[A] := ( g' ^ k[A]\
    \ ) mod p and\n      s'[A] := ( H(Id[A])  - x * r[A] ) *  (k[A] ^ -1)    mod (p-1)\n\
    \   -  The SKIA forwards (Id[A],r[A],s'[A]) to the user A\n   -  The user A calculates\
    \ his s[A] := s'[A] * (a^-1) mod (p-1)\n   The SKIA is not able to find out the\
    \ secret key s[A] of A.  This\n   protocol is based on the idea of the 'testimonial'\
    \ [11].\n   The SKIA is still able to create a second key with the same Identity\n\
    \   Descriptor (identical or at least having same contents), but with\n   different\
    \ r[A] and s[A]. If such a second key was successfully used\n   for authentication\
    \ or message signing, the real key owner can use his\n   own key to proof the\
    \ existence of two different keys with identical\n   (equivalent) Descriptors.\
    \ The existence of such two keys shows that\n   the SKIA cannot be trusted any\
    \ longer.\n   If the key is generated by this method, it should be mentioned in\
    \ the\n   Identity Descriptor. This allows any communication partners to look\n\
    \   up in the public part of a key whether the secret part is known to\n   the\
    \ SKIA.\n"
- title: 4.2.  Hardware Protected Key
  contents:
  - "4.2.  Hardware Protected Key\n   The protocol of the previous subsection guaranteed\
    \ that the SKIA does\n   not know the user's secret key.\n   On the other hand,\
    \ the SKIA may wish that the user himself does not\n   know his own secret key.\
    \ This may be necessary because the user could\n   otherwise reveal his secret\
    \ key accidently or intentionally.\n   Especially if untrusted hard- or software\
    \ or an environment without\n   trusted process protection is used, the secret\
    \ key can be spied out.\n   For high-level security applications this might not\
    \ be acceptable.\n   The key owner must be able to use his key without being able\
    \ to read\n   this key. This contradiction can be solved by hiding the secret\
    \ part\n   of the User Key within a protected hardware device.\n   Within the\
    \ SELANE project, the protocols described in this RFC were\n   implemented for\
    \ SmartCards. The User Key is created using the non-\n   escrowed key generation\
    \ procedure described in the previous section,\n   modified such that the random\
    \ number is generated inside the card.\n   The secret s[A] exists only inside\
    \ the card and does not get outside.\n   The SmartCard is able to execute all\
    \ parts of the algorithms which\n   need access to the secret key.  To make use\
    \ of the SmartCard an\n   additional password is required.\n   If the key is hidden\
    \ in such a hardware device, it should be\n   mentioned in the Identity Descriptor.\
    \ This allows any communication\n   partners to look up in the public part of\
    \ a key whether the key is\n   hardware protected.\n"
- title: 4.3.  Key Regeneration
  contents:
  - "4.3.  Key Regeneration\n   If both methods of the previous subsections are used\
    \ to protect the\n   key, neither the SKIA nor the User himself knows the secret\
    \ key. This\n   could be harmful for the User if the hardware device is lost or\n\
    \   damaged, because the User could become unable to decrypt messages\n   encrypted\
    \ with the public key.\n   To prevent such a denial of service, there are two\
    \ methods:\n   - If the protection factor 'a' was choosen by the User, the User\n\
    \     can deposit the factor 'a' in a secure way, e.g. give it as a\n     shared\
    \ secret to his friends. The SKIA can do the same and\n     deposit s'[A] somewhere\
    \ else.  If the SKIA and the User\n     cooperate, they are able to create a second\
    \ hardware device\n     equivalent to the first.\n   - If the protection factor\
    \ a was generated inside of the hardware\n     device, the device itself may give\
    \ out the s[A] or the a in a\n     secure way (e.g. as a shared secret).\n   Since\
    \ the recreation of a User key defeats the property of such a key\n   to exist\
    \ only once, the SKIA should restrict this to special cases\n   only.  Furthermore\
    \ it should be done only after the end of the\n   lifetime of the key, if its\
    \ lifetime was limited.\n"
- title: 4.4.  r ^ r
  contents:
  - "4.4.  r ^ r\n   A slight modification of the base protocol allows some speedup\
    \ in the\n   key exchange:\n   -  The SKIA is created as in the base protocol\n\
    \   -  For the User Setup the SKIA solves the equation\n      x * s[A] + r[A]\
    \ * k[A] = H(Id[A]) mod (p-1)\n      which differs from the base protocol in that\
    \ r and s were swapped.\n   -  The public key allows to calculate\n      y ^ s[A]\
    \ = ( g ^ H(Id[A]) ) * ( r[A] ^ -r[A] )  mod p\n      without knowing s[A]. Here\
    \ the term  (  r[A]  ^  -r[A]  )  can  be\n      precalculated for speedup.\n\
    \   -  Bob calculates key[A] := ( g ^ H(Id[A]) * r[A] ^ -r[A] ) ^ z[A]\n     \
    \          and     v[A] := y ^ z[A] mod p\n      Alice gets     key[A] := v[A]\
    \ ^ s[A] mod p\n      where key[A] = y ^ (s[A] * z[A])\n   This protocol is similar\
    \ to the AMV modification by Agnew et al.\n   [12].\n"
- title: 4.5.  Implicit Key Exchange
  contents:
  - "4.5.  Implicit Key Exchange\n   If the r ^ r protocol of the previous section\
    \ is used, an implicit\n   shared key can be calculated for Alice and Bob by using\
    \ the Diffie-\n   Hellman scheme:\n   -  Alice: key[A,B] = ( g ^ H(Id[B]) * r[B]\
    \ ^ -r[B] ) ^ s[A] mod p\n   -  Bob:   key[B,A] = ( g ^ H(Id[A]) * r[A] ^ -r[A]\
    \ ) ^ s[B] mod p\n   where key[A,B] = key[B,A] = y ^ (s[A] * s[B]).\n   This can\
    \ not be used with Non-escrowed keys.\n"
- title: 4.6.  Law Enforcement
  contents:
  - "4.6.  Law Enforcement\n   This will be subject of a separate RFC.\n"
- title: 4.7.  Usage of other Algebraic Groups
  contents:
  - "4.7.  Usage of other Algebraic Groups\n   Within this RFC calculations were based\
    \ on a specific algebraic\n   group, the multiplicative group of integers modulo\
    \ a prime number p\n   (which is the multiplicative group of a finite field GF(p)).\
    \ However,\n   any cyclic finite group with a strong discrete logarithm problem\
    \ can\n   be used, e.g., a subgroup of the multiplicative group or elliptic\n\
    \   curves.\n   As an example the subgroup used by the DSA (Digital Signature\n\
    \   Algorithm) of length N can be used instead of the full multiplicative\n  \
    \ group of GF(p) for speedup (in this case the Secure Hash Algorithm\n   SHA is\
    \ recommended as the hash algorithm).  See [13, 14] for a\n   description of DSA\
    \ and SHA.\n"
- title: 4.7.1.  DSA subgroup SKIA Setup
  contents:
  - "4.7.1.  DSA subgroup SKIA Setup\n   -  Generate  large  primes  p  and  q such\
    \ that p is at least 512 bit\n      long, q is 160 bit long, and q is a factor\
    \ of (p-1).\n   -  choose a primitive root h in GF(p)\n   -  g:= h^((p-1)/q)\n\
    \      Note that g generates a subgroup G with |G|=q\n   -  x: a random number\
    \ of about 160 bit.\n   -  y:= ( g ^ x ) mod p\n   The public key of the SKIA\
    \ is (p,g,y,q). (q is required for speedup\n   only.)\n   The secret key of the\
    \ SKIA is x.\n"
- title: 4.7.2.  Escrowed DSA subgroup User Setup
  contents:
  - "4.7.2.  Escrowed DSA subgroup User Setup\n   -  k[A]: a random number of 160\
    \ bit length with gcd(k[A],q)=1\n   -  r[A]:= ( g ^ k[A] ) mod p\n   -  s[A]:=\
    \ (H(Id[A]) + x * r[A]) * (k[A] ^ -1)  mod q\n   Again, (Id[A],r[A]) is the public\
    \ key and s[A] is the secret key.\n   Note that r[A] has the length of p and s[A]\
    \ has the length of q (160\n   bit).\n"
- title: 4.7.3.  Non-Escrowed DSA subgroup User Setup
  contents:
  - "4.7.3.  Non-Escrowed DSA subgroup User Setup\n   -  User A generates a random\
    \ number h of 160 bit length.\n   -  User A calculates a := g^h mod p and sends\
    \ a to the SKIA.\n   -  The SKIA generates the user key with the secret key s'[A].\n\
    \   -  User A calculates s[A]:= s'[a] * (h^-1) mod q\n"
- title: 4.7.4.  DSA subgroup Authentication
  contents:
  - "4.7.4.  DSA subgroup Authentication\n   The protocols for authentication are\
    \ the same as described above,\n   except that wherever the modulus (p-1) was\
    \ used the smaller modulus q\n   is used instead, and DSA is used for message\
    \ signing.\n   The abbreviation Y[A] still stands for r[A] ^ s[A], which is now\
    \ (the\n   sign of r[A] was changed for speedup)\n      ( g ^ H(Id[A])) * ( y\
    \ ^ r[A] ) mod p\n   and can be calculated in a faster way as\n      u1 * u2 mod\
    \ p\n   where\n      u1 := g ^ ( H(Id[A])  mod q )  mod p\n      u2 := y ^ ( r[A]\
    \ mod q ) mod p.\n"
- title: 5.  Multiple SKIAs
  contents:
  - "5.  Multiple SKIAs\n   In the preceding sections it was assumed that everybody\
    \ learned the\n   (p,g,y) triple of a SKIA reliably.\n   By default, a User reliably\
    \ learns only the (p,g,y) of the SKIA which\n   generated his own key, because\
    \ he gets the triple with his key and\n   can verify the triple with the signature\
    \ verification equation.\n   If the User wants to communicate with someone whose\
    \ key was generated\n   by a different SKIA, a method for authenticating the (p,g,y)\
    \ of the\n   other SKIA is needed.\n"
- title: 5.1.  Unstructured SKIAs
  contents:
  - "5.1.  Unstructured SKIAs\n   This will be subject of a separate RFC.\n"
- title: 5.2.  Hierarchical SKIAs
  contents:
  - "5.2.  Hierarchical SKIAs\n   If there is a hierarchy between the SKIAs, their\
    \ keys can be\n   generated hierarchically:\n   -  Every SKIA and every User has\
    \ a level  (expressed  as  a  cardinal\n      number).  The root SKIA has level\
    \ 0. All Users and all other SKIAs\n      have levels greater than 0.\n   -  Each\
    \ SKIA except the root SKIA is also a User, and each  User  can\n      be a SKIA.\n\
    \      A SKIA of level n generates keys for Users of level n+1.\n      A User\
    \ of level n is also a SKIA of level n.\n   -  Since  every SKIA (except the root\
    \ SKIA) is also a User, each SKIA\n      has an Identity Descriptor describing\
    \ its Identity and perhaps its\n      level  and  its  parent  SKIA. There is\
    \ a function parent(A) which\n      finds the parent SKIA for every user  A. \
    \ This  function  may  use\n      informations stored in the Identity Descriptor.\n\
    \      Thus,  the  parent()  function allows to find the path to the root\n  \
    \    SKIA for every node of the tree forming the hierarchy.\n      The root SKIA\
    \ may also have an Identity Descriptor.\n   -  The root SKIA creates itself as\
    \ in the base protocol.\n   -  The key for a User A of level n (n>0) is generated\
    \ by  the  parent\n      SKIA  of  level  n-1.  The public part is (Id[A],r[A]),\
    \ the secret\n      part is (s[A]).\n      User A is automatically SKIA A:\n \
    \     p[A] := p[parent(A)]  = p of the root SKIA\n      g[A] := r[A]\n      x[A]\
    \ := s[A]\n      y[A] := g[A] ^ x[A] = r[A] ^ s[A] = Y[A] =\n             ( g[parent(A)]\
    \ ^ H(Id[A]) ) * ( y[parent(A)] ^ -r[A]) mod p\n      Therefore, the public data\
    \ (p,g[A],y[A]) of  the  SKIA  A  can  be\n      calculated  by everyone from\
    \ the public data of the User A and the\n      public data of its parent SKIA.\
    \ The SKIA  A  itself  may  use  the\n      faster  method  to  get  y[A]  by\
    \  calculating  r[A] ^ s[A], while\n      everybody else has to use the slower\
    \ but public method as  in  the\n      lower  equation.  The  secret  of the \"\
    SKIA A\" is identical to the\n      secret of the \"User A\".\n      Since a User\
    \ A uses the very same data to act as either a user  or\n      as a SKIA, and\
    \ since message signing (subsection 3.4.) is the very\n      same procedure as\
    \ generating a User key (in fact it  is  the  same\n      thing),   a  user  should\
    \  not  sign  a  message  which  could  be\n      misunderstood  as  an  Identity\
    \  Descriptor.  An  attacker   could\n      intercept  the  message  and  its\
    \ signature and abuse it as a User\n      key. This can be avoided by the use\
    \ of tags  which  preceed  every\n      set  of  data  being signed and show whether\
    \ it is a message or an\n      Identity Descriptor.\n   This scheme allows any\
    \ two users (even users of distinct hierarchies)\n   to communicate reliably.\
    \ They need to know the public data (p,g,y) of\n   each other's root SKIA only.\
    \ There is no need for online key servers.\n   The communication is the same as\
    \ in the base protocols but with an\n   extension to the method of finding Y[A]\
    \ (again with Alice and Bob):\n   -  Bob reliably learned the (p,g,y) of Alice's\
    \ root SKIA S(0).\n   -  Where Alice presented (Id[A],r[A]) only in the first\
    \ step, she now\n      presents (Id[S],r[S]) for each SKIA/User node S in her\
    \ path to her\n      root SKIA S(0).  Since  this  information  does  not  need\
    \  to  be\n      reliable  or  signed,  it  can  be  provided  by any simple server\n\
    \      mechanism.\n   -  Bob iteratively calculates the public data (p,g,y) of\
    \ each SKIA in\n      the  path,  starting  with  Alice's  root  SKIA, until he\
    \ gets the\n      (p,g,y) of Alice where y is Y[Alice].\n   Note that Bob did\
    \ not have to verify anything within the iteration.\n   After the iteration he\
    \ has a set of public SKIA data (p,g,y) to be\n   used with Alice public key,\
    \ but he still does not know whether he was\n   spoofed with wrong data of Alice\
    \ or her parent SKIAs.\n   Since the iteration Bob calculated is a chain of nested\
    \ signatures,\n   the correctness of the (p,g,y) he gets depends on every single\
    \ step.\n   If there is at least one step with a bad Id[S] or r[S], Bob will get\n\
    \   a wrong Y[S] in this step and all following steps, and the chain\n   doesn't\
    \ work.\n   If the chain calculated by Bob was not completely correct for any\n\
    \   reason, Alice cannot make use of her key: her signatures do not\n   verify,\
    \ she cannot decrypt encrypted messages and she cannot answer\n   to the challenge\
    \ response step in case of mutual authentication.\n"
- title: '5.3.  Example: A DNS-based public key structure'
  contents:
  - "5.3.  Example: A DNS-based public key structure\n   Here is a simple example\
    \ of the usage of the hierarchical SKIA scheme\n   within the DNS name space:\n\
    \   Let every domain also be a SKIA, and let the root domain be a root\n   SKIA.\
    \ Let the Identity Descriptor of any object within the name space\n   be its name:\
    \ the domain name for domains, the host name for machines,\n   the mail address\
    \ for humans and services.\n   Consequently, a user with the mail address \"danisch@ira.uka.de\"\
    \ got\n   his key from the SKIA of the domain \"ira.uka.de\". This SKIA was\n\
    \   authorized by the SKIA of \"uka.de\", which was authorized by the SKIA\n \
    \  of \"de\", which is the root SKIA of Germany. It is assumed that\n   everybody\
    \ reliably learned the public key of the german root domain\n   \"de\".\n   The\
    \ public key of danisch@ira.uka.de would look like:\n      (  \"danisch@ira.uka.de\"\
    , r[danisch@ira.uka.de] ,\n         \"ira.uka.de\"        , r[ira.uka.de]    \
    \     ,\n         \"uka.de\"            , r[uka.de]\n      )\n   For the reasons\
    \ described in the previous subsection, this key is\n   self-certified and does\
    \ not need any further signature.\n   The key can be presented by danisch@ira.uka.de\
    \ within online\n   communications, be appended to signed messages, or simply\
    \ be\n   retrieved by the domain name server of ira.uka.de.\n   Someone who reliably\
    \ learned the (p,g,y) of the root domain .de\n   (Germany) can now build the chain:\n\
    \      \"de\"                        (p,g,y)[de]\n      \"uka.de\"           \
    \         (p,g,y)[uka.de]\n      \"ira.uka.de\"                (p,g,y)[ira.uka.de]\n\
    \      \"danisch@ira.uka.de\"        (p,g,y)[danisch@ira.uka.de]\n   Thus it is\
    \ possible to reliably obtain the Y[danisch@ira.uka.de].\n   To communicate with\
    \ the whole world, knowledge of the public keys of\n   all root domain SKIAs only\
    \ is needed. These keys can be stored within\n   some tens of KBytes.  No third\
    \ party is needed for doing an\n   authenticated key exchange.\n   The whole world\
    \ could also be based on a single root SKIA; in this\n   case a single (p,g,y)\
    \ is needed only.\n   In a more realistic example the Id[danisch@ira.uka.de] could\
    \ contain:\n      creator=      ira.uka.de\n      created=      1-Jun-1995\n \
    \     expiry=       31-Dec-1999\n      protection=   non-escrowed, smartcard\n\
    \      type=         human\n      name=         Hadmut Danisch\n      email= \
    \       danisch@ira.uka.de\n      phone=        +49 721 9640018\n      fax=  \
    \        +49 721 696893\n      photo=        <digitized compressed portrait>\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   -  The strength of TESS depends  on  the  strength\
    \  of  the  discrete\n      logarith  problem,  the strength of the ElGamal signature,\
    \ and the\n      confidentiality of the SKIAs.\n   -  Attention should be paid\
    \ to the  security  considerations  of  the\n      underlying mechanisms (ElGamal,\
    \ DSA, Diffie-Hellman, etc.).\n   -  Since  the  SKIA  creates  itself  under\
    \  normal circumstances, an\n      attacker could create his own SKIA and use\
    \ it to create a User Key\n      with  an  arbitrary  Identity  Descriptor.  This\
    \  shows  that  the\n      Identity Descriptor is as reliable as the  origin \
    \ of  the  triple\n      (p,g,y) of the SKIA it came from. The User Key creation\
    \ process is\n      a signature process  for  the  Identity  Descriptor  and \
    \ strongly\n      depends on the trustworthyness of the signing SKIA.\n   -  It\
    \  is  the  SKIA's  duty  to  give  the s[A] only to the user the\n      Identity\
    \ Descriptor belongs to.\n   -  Since the very same procedure is used  for  signing\
    \  messages  and\n      generating  user  keys,  it  is  important  to distinguish\
    \ between\n      messages and keys.\n   -  The authentication protocols work \
    \ without  an  online  authority.\n      Therefore,  there  is  no  simple  way\
    \ for revoking keys. For this\n      reason keys should  have  an  expiration\
    \  date  mentioned  in  the\n      Identity  Descriptor.  In  case  of  the hierarchical\
    \ scheme a key\n      expires if any key in the path to the root SKIA expires.\n"
- title: References
  contents:
  - 'References

    '
- title: 1.    Th. Beth, F. Bauspiess, H.-J. Knobloch,  S.  Stempel,  "TESS  -  A
  contents:
  - "1.    Th. Beth, F. Bauspiess, H.-J. Knobloch,  S.  Stempel,  \"TESS  -  A\n \
    \     Security  System  based  on Discrete Exponentation,\" Computer\n      Communcations\
    \ Journal, Vol. 17, Special Issue, No.  7, pp.\n      466-475 (1994).\n"
- title: 2.    T.  ElGamal,  "A  Public  Key  Cryptosystem and a Signature Scheme
  contents:
  - "2.    T.  ElGamal,  \"A  Public  Key  Cryptosystem and a Signature Scheme\n \
    \     Based on  Discrete  Logarithm,\"  IEEE-Trans.  Information  Theory,\n  \
    \    IT-31, pp. 469-472 (July 1985).\n"
- title: 3.    B.  Klein, H.-J. Knobloch, "ElGamal-Signatur" in
  contents:
  - "3.    B.  Klein, H.-J. Knobloch, \"ElGamal-Signatur\" in\n      Sicherheitsmechanismen,\
    \ ed. Fries, Fritsch, Kessler, Klein, pp.\n      171-176, Oldenburg, Muenchen\
    \ (1993).\n"
- title: 4.    C.  G.  Guenther, "An Identity-Based Key-Exchange Protocol" in
  contents:
  - "4.    C.  G.  Guenther, \"An Identity-Based Key-Exchange Protocol\" in\n    \
    \  Advances in Cryptology, Proceedings of Eurocrypt '89,  pp.  29-37,\n      Springer\
    \ (1990).\n"
- title: 5.    B.  Klein,  H.-J. Knobloch, "KATHY" in Sicherheitsmechanismen, ed.
  contents:
  - "5.    B.  Klein,  H.-J. Knobloch, \"KATHY\" in Sicherheitsmechanismen, ed.\n\
    \      Fries, Fritsch, Kessler, Klein, pp. 252-259,  Oldenburg,  Muenchen\n  \
    \    (1993).\n"
- title: 6.    F. Bauspiess, H.-J. Knobloch, "How to keep authenticity alive in a
  contents:
  - "6.    F. Bauspiess, H.-J. Knobloch, \"How to keep authenticity alive in a\n \
    \     computer network\" in Advances in Cryptology, Proceedings of\n      Eurocrypt\
    \ '89, pp. 38-46, Springer (1990).\n"
- title: 7.    F.  Bauspiess,  "SELANE  -  An  Approach  to  Secure  Networks" in
  contents:
  - "7.    F.  Bauspiess,  \"SELANE  -  An  Approach  to  Secure  Networks\" in\n\
    \      Abstracts of SECURICOM '90, pp. 159-164, Paris (1990).\n"
- title: 8.    Th. Beth,  "Efficient  zero-knowledge  identification  scheme  for
  contents:
  - "8.    Th. Beth,  \"Efficient  zero-knowledge  identification  scheme  for\n \
    \     smart  cards\"  in Advances in Cryptology, Proceedings of Eurocrypt\n  \
    \    '88, pp. 77-84, Springer (1988).\n"
- title: 9.    D. Chaum, J. H. Evertse, J. van de Graaf,  "An  improved  protocol
  contents:
  - "9.    D. Chaum, J. H. Evertse, J. van de Graaf,  \"An  improved  protocol\n \
    \     for demonstrating possesion of discrete logarithms and some\n      generalizations\"\
    \ in Advances in Cryptology, Proceedings of\n      Eurocrypt '87, pp. 127-141,\
    \ Springer (1988).\n"
- title: 10.   W.  Diffie,  M.  Hellman,  "New directions in cryptography," IEEE-
  contents:
  - "10.   W.  Diffie,  M.  Hellman,  \"New directions in cryptography,\" IEEE-\n\
    \      Trans. Information Theory, 22, pp. 644-654 (1976).\n"
- title: 11.   Th. Beth, H.-J. Knobloch, "Open network authentication without  an
  contents:
  - "11.   Th. Beth, H.-J. Knobloch, \"Open network authentication without  an\n \
    \     online  server\"  in  Proc.  Symposium on Comput. Security '90, pp.\n  \
    \    160-165, Rome, Italy (1990).\n"
- title: 12.   G. B. Agnew, R. C. Mullin, S. A. Vanstone, "Improved digital
  contents:
  - "12.   G. B. Agnew, R. C. Mullin, S. A. Vanstone, \"Improved digital\n      signature\
    \ scheme based on discrete exponentation,\" Electron.\n      Lett., 26, pp. 1024-1025\
    \ (1990).\n"
- title: 13.   "The Digital Signature Standard," Communications of the ACM,  Vol.
  contents:
  - "13.   \"The Digital Signature Standard,\" Communications of the ACM,  Vol.\n\
    \      35, pp. 36-40 (July 1992).\n"
- title: 14.   Bruce Schneier, Applied Cryptography, John Wiley & Sons (1994).
  contents:
  - '14.   Bruce Schneier, Applied Cryptography, John Wiley & Sons (1994).

    '
- title: Author's Address
  contents:
  - "Author's Address\n   Dipl.-Inform. Hadmut Danisch\n   European Institute for\
    \ System Security (E.I.S.S.)\n   Institut fuer Algorithmen und Kognitive Systeme\
    \ (IAKS)\n   University of Karlsruhe\n   D-76128 Karlsruhe\n   Germany\n   Phone:\
    \ ++49 721 96400-18\n   Fax:   ++49 721 696893\n   EMail: danisch@ira.uka.de\n\
    \   WWW:   http://avalon.ira.uka.de/personal/danisch.html\n"
