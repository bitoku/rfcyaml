- title: __initial_text__
  contents:
  - "           PKCS #5: Password-Based Cryptography Specification\n             \
    \                 Version 2.0\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo represents a republication of PKCS #5 v2.0 from RSA\n\
    \   Laboratories' Public-Key Cryptography Standards (PKCS) series, and\n   change\
    \ control is retained within the PKCS process.  The body of this\n   document,\
    \ except for the security considerations section, is taken\n   directly from that\
    \ specification.\n   This document provides recommendations for the implementation\
    \ of\n   password-based cryptography, covering key derivation functions,\n   encryption\
    \ schemes, message-authentication schemes, and ASN.1 syntax\n   identifying the\
    \ techniques.\n   The recommendations are intended for general application within\n\
    \   computer and communications systems, and as such include a fair\n   amount\
    \ of flexibility. They are particularly intended for the\n   protection of sensitive\
    \ information such as private keys, as in PKCS\n   #8 [25]. It is expected that\
    \ application standards and implementation\n   profiles based on these specifications\
    \ may include additional\n   constraints.\n   Other cryptographic techniques based\
    \ on passwords, such as password-\n   based key entity authentication and key\
    \ establishment protocols\n   [4][5][26] are outside the scope of this document.\
    \  Guidelines for\n   the selection of passwords are also outside the scope.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.   Introduction ...............................................\
    \  3\n   2.   Notation ...................................................  3\n\
    \   3.   Overview ...................................................  4\n   4.\
    \   Salt and iteration count ...................................  6\n       4.1\
    \  Salt ...................................................  6\n       4.2  Iteration\
    \ count ........................................  8\n   5.   Key derivation functions\
    \ ...................................  8\n       5.1  PBKDF1 .................................................\
    \  9\n       5.2  PBKDF2 .................................................  9\n\
    \   6.   Encryption schemes ......................................... 11\n   \
    \    6.1  PBES1 .................................................. 12\n      \
    \      6.1.1  Encryption operation ............................ 12\n         \
    \   6.1.2  Decryption operation ............................ 13\n       6.2  PBES2\
    \ .................................................. 14\n            6.2.1  Encryption\
    \ operation ............................ 14\n            6.2.2  Decryption operation\
    \ ............................ 15\n   7.   Message authentication schemes .............................\
    \ 15\n       7.1  PBMAC1 ................................................. 16\n\
    \            7.1.1  MAC generation .................................. 16\n   \
    \         7.1.2  MAC verification ................................ 16\n   8. \
    \  Security Considerations .................................... 17\n   9.   Author's\
    \ Address............................................ 17\n   A.   ASN.1 syntax\
    \ ............................................... 18\n       A.1  PBKDF1 .................................................\
    \ 18\n       A.2  PBKDF2 ................................................. 18\n\
    \       A.3  PBES1 .................................................. 20\n   \
    \    A.4  PBES2 .................................................. 20\n      \
    \ A.5  PBMAC1 ................................................. 21\n   B.   Supporting\
    \ techniques ...................................... 22\n       B.1  Pseudorandom\
    \ functions ................................. 22\n       B.2  Encryption schemes\
    \ ..................................... 23\n       B.3  Message authentication\
    \ schemes ......................... 26\n   C.   ASN.1 module ...............................................\
    \ 26\n   Intellectual Property Considerations ............................ 30\n\
    \   Revision history ................................................ 30\n   References\
    \ ...................................................... 31\n   Contact Information\
    \ & About PKCS ................................ 33\n   Full Copyright Statement\
    \ ........................................ 34\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document provides recommendations for the implementation\
    \ of\n   password-based cryptography, covering the following aspects:\n   -  key\
    \ derivation functions\n   -  encryption schemes\n   -  message-authentication\
    \ schemes\n   -  ASN.1 syntax identifying the techniques\n   The recommendations\
    \ are intended for general application within\n   computer and communications\
    \ systems, and as such include a fair\n   amount of flexibility. They are particularly\
    \ intended for the\n   protection of sensitive information such as private keys,\
    \ as in PKCS\n   #8 [25]. It is expected that application standards and implementation\n\
    \   profiles based on these specifications may include additional\n   constraints.\n\
    \   Other cryptographic techniques based on passwords, such as password-\n   based\
    \ key entity authentication and key establishment protocols\n   [4][5][26] are\
    \ outside the scope of this document.  Guidelines for\n   the selection of passwords\
    \ are also outside the scope.\n   This document supersedes PKCS #5 version 1.5\
    \ [24], but includes\n   compatible techniques.\n"
- title: 2. Notation
  contents:
  - "2. Notation\n   C       ciphertext, an octet string\n   c       iteration count,\
    \ a positive integer\n   DK      derived key, an octet string\n   dkLen   length\
    \ in octets of derived key, a positive integer\n   EM      encoded message, an\
    \ octet string\n   Hash    underlying hash function\n   hLen    length in octets\
    \ of pseudorandom function output, a positive\n           integer\n   l      \
    \ length in blocks of derived key, a positive integer\n   IV      initialization\
    \ vector, an octet string\n   K       encryption key, an octet string\n   KDF\
    \     key derivation function\n   M       message, an octet string\n   P     \
    \  password, an octet string\n   PRF     underlying pseudorandom function\n  \
    \ PS      padding string, an octet string\n   psLen   length in octets of padding\
    \ string, a positive integer\n   S       salt, an octet string\n   T       message\
    \ authentication code, an octet string\n   T_1, ..., T_l, U_1, ..., U_c\n    \
    \       intermediate values, octet strings\n   01, 02, ..., 08\n           octets\
    \ with value 1, 2, ..., 8\n   \\xor    bit-wise exclusive-or of two octet strings\n\
    \   ||  ||  octet length operator\n   ||      concatenation operator\n   <i..j>\
    \  substring extraction operator: extracts octets i through j,\n           0 <=\
    \ i <= j\n"
- title: 3. Overview
  contents:
  - "3. Overview\n   In many applications of public-key cryptography, user security\
    \ is\n   ultimately dependent on one or more secret text values or passwords.\n\
    \   Since a password is not directly applicable as a key to any\n   conventional\
    \ cryptosystem, however, some processing of the password\n   is required to perform\
    \ cryptographic operations with it. Moreover, as\n   passwords are often chosen\
    \ from a relatively small space, special\n   care is required in that processing\
    \ to defend against search attacks.\n   A general approach to password-based cryptography,\
    \ as described by\n   Morris and Thompson [8] for the protection of password tables,\
    \ is to\n   combine a password with a salt to produce a key. The salt can be\n\
    \   viewed as an index into a large set of keys derived from the\n   password,\
    \ and need not be kept secret. Although it may be possible\n   for an opponent\
    \ to construct a table of possible passwords (a so-\n   called \"dictionary attack\"\
    ), constructing a table of possible keys\n   will be difficult, since there will\
    \ be many possible keys for each\n   password.  An opponent will thus be limited\
    \ to searching through\n   passwords separately for each salt.\n   Another approach\
    \ to password-based cryptography is to construct key\n   derivation techniques\
    \ that are relatively expensive, thereby\n   increasing the cost of exhaustive\
    \ search. One way to do this is to\n   include an iteration count in the key derivation\
    \ technique,\n   indicating how many times to iterate some underlying function\
    \ by\n   which keys are derived. A modest number of iterations, say 1000, is\n\
    \   not likely to be a burden for legitimate parties when computing a\n   key,\
    \ but will be a significant burden for opponents.\n   Salt and iteration count\
    \ formed the basis for password-based\n   encryption in PKCS #5 v1.5, and adopted\
    \ here as well for the various\n   cryptographic operations. Thus, password-based\
    \ key derivation as\n   defined here is a function of a password, a salt, and\
    \ an iteration\n   count, where the latter two quantities need not be kept secret.\n\
    \   From a password-based key derivation function, it is straightforward\n   to\
    \ define password-based encryption and message authentication\n   schemes. As\
    \ in PKCS #5 v1.5, the password-based encryption schemes\n   here are based on\
    \ an underlying, conventional encryption scheme,\n   where the key for the conventional\
    \ scheme is derived from the\n   password. Similarly, the password-based message\
    \ authentication scheme\n   is based on an underlying conventional scheme. This\
    \ two-layered\n   approach makes the password-based techniques modular in terms\
    \ of the\n   underlying techniques they can be based on.\n   It is expected that\
    \ the password-based key derivation functions may\n   find other applications\
    \ than just the encryption and message\n   authentication schemes defined here.\
    \ For instance, one might derive a\n   set of keys with a single application of\
    \ a key derivation function,\n   rather than derive each key with a separate application\
    \ of the\n   function. The keys in the set would be obtained as substrings of\
    \ the\n   output of the key derivation function. This approach might be\n   employed\
    \ as part of key establishment in a session-oriented protocol.\n   Another application\
    \ is password checking, where the output of the key\n   derivation function is\
    \ stored (along with the salt and iteration\n   count) for the purposes of subsequent\
    \ verification of a password.\n   Throughout this document, a password is considered\
    \ to be an octet\n   string of arbitrary length whose interpretation as a text\
    \ string is\n   unspecified. In the interest of interoperability, however, it\
    \ is\n   recommended that applications follow some common text encoding rules.\n\
    \   ASCII and UTF-8 [27] are two possibilities. (ASCII is a subset of\n   UTF-8.)\n\
    \   Although the selection of passwords is outside the scope of this\n   document,\
    \ guidelines have been published [17] that may well be taken\n   into account.\n"
- title: 4. Salt and Iteration Count
  contents:
  - "4. Salt and Iteration Count\n   Inasmuch as salt and iteration count are central\
    \ to the techniques\n   defined in this document, some further discussion is warranted.\n"
- title: 4.1 Salt
  contents:
  - "4.1 Salt\n   A salt in password-based cryptography has traditionally served the\n\
    \   purpose of producing a large set of keys corresponding to a given\n   password,\
    \ among which one is selected at random according to the\n   salt. An individual\
    \ key in the set is selected by applying a key\n   derivation function KDF, as\n\
    \                              DK = KDF (P, S)\n   where DK is the derived key,\
    \ P is the password, and S is the salt.\n   This has two benefits:\n      1. It\
    \ is difficult for an opponent to precompute all the keys\n         corresponding\
    \ to a dictionary of passwords, or even the most\n         likely keys. If the\
    \ salt is 64 bits long, for instance, there\n         will be as many as 2^64\
    \ keys for each password. An opponent is\n         thus limited to searching for\
    \ passwords after a password-based\n         operation has been performed and\
    \ the salt is known.\n      2. It is unlikely that the same key will be selected\
    \ twice.\n         Again, if the salt is 64 bits long, the chance of \"collision\"\
    \n         between keys does not become significant until about 2^32 keys\n  \
    \       have been produced, according to the Birthday Paradox. This\n        \
    \ addresses some of the concerns about interactions between\n         multiple\
    \ uses of the same key, which may apply for some\n         encryption and authentication\
    \ techniques.\n   In password-based encryption, the party encrypting a message\
    \ can gain\n   assurance that these benefits are realized simply by selecting\
    \ a\n   large and sufficiently random salt when deriving an encryption key\n \
    \  from a password. A party generating a message authentication code can\n   gain\
    \ such assurance in a similar fashion.\n   The party decrypting a message or verifying\
    \ a message authentication\n   code, however, cannot be sure that a salt supplied\
    \ by another party\n   has actually been generated at random. It is possible,\
    \ for instance,\n   that the salt may have been copied from another password-based\n\
    \   operation, in an attempt to exploit interactions between multiple\n   uses\
    \ of the same key. For instance, suppose two legitimate parties\n   exchange a\
    \ encrypted message, where the encryption key is an 80-bit\n   key derived from\
    \ a shared password with some salt. An opponent could\n   take the salt from that\
    \ encryption and provide it to one of the\n   parties as though it were for a\
    \ 40-bit key. If the party reveals the\n   result of decryption with the 40-bit\
    \ key, the opponent may be able to\n   solve for the 40-bit key. In the case that\
    \ 40-bit key is the first\n   half of the 80-bit key, the opponent can then readily\
    \ solve for the\n   remaining 40 bits of the 80-bit key.\n   To defend against\
    \ such attacks, either the interaction between\n   multiple uses of the same key\
    \ should be carefully analyzed, or the\n   salt should contain data that explicitly\
    \ distinguishes between\n   different operations.  For instance, the salt might\
    \ have an\n   additional, non-random octet that specifies whether the derived\
    \ key\n   is for encryption, for message authentication, or for some other\n \
    \  operation.\n   Based on this, the following is recommended for salt selection:\n\
    \      1. If there is no concern about interactions between multiple uses\n  \
    \       of the same key (or a prefix of that key) with the password-\n       \
    \  based encryption and authentication techniques supported for a\n         given\
    \ password, then the salt may be generated at random and\n         need not be\
    \ checked for a particular format by the party\n         receiving the salt. It\
    \ should be at least eight octets (64\n         bits) long.\n      2. Otherwise,\
    \ the salt should contain data that explicitly\n         distinguishes between\
    \ different operations and different key\n         lengths, in addition to a random\
    \ part that is at least eight\n         octets long, and this data should be checked\
    \ or regenerated by\n         the party receiving the salt. For instance, the\
    \ salt could have\n         an additional non-random octet that specifies the\
    \ purpose of\n         the derived key. Alternatively, it could be the encoding\
    \ of a\n         structure that specifies detailed information about the derived\n\
    \         key, such as the encryption or authentication technique and a\n    \
    \     sequence number among the different keys derived from the\n         password.\
    \  The particular format of the additional data is left\n         to the application.\n\
    \   Note. If a random number generator or pseudorandom generator is not\n   available,\
    \ a deterministic alternative for generating the salt (or\n   the random part\
    \ of it) is to apply a password-based key derivation\n   function to the password\
    \ and the message M to be processed. For\n   instance, the salt could be computed\
    \ with a key derivation function\n   as S = KDF (P, M). This approach is not recommended\
    \ if the message M\n   is known to belong to a small message space (e.g., \"Yes\"\
    \ or \"No\"),\n   however, since then there will only be a small number of possible\n\
    \   salts.\n"
- title: 4.2 Iteration Count
  contents:
  - "4.2 Iteration Count\n   An iteration count has traditionally served the purpose\
    \ of increasing\n   the cost of producing keys from a password, thereby also increasing\n\
    \   the difficulty of attack. For the methods in this document, a minimum\n  \
    \ of 1000 iterations is recommended. This will increase the cost of\n   exhaustive\
    \ search for passwords significantly, without a noticeable\n   impact in the cost\
    \ of deriving individual keys.\n"
- title: 5. Key Derivation Functions
  contents:
  - "5. Key Derivation Functions\n   A key derivation function produces a derived\
    \ key from a base key and\n   other parameters. In a password-based key derivation\
    \ function, the\n   base key is a password and the other parameters are a salt\
    \ value and\n   an iteration count, as outlined in Section 3.\n   The primary\
    \ application of the password-based key derivation\n   functions defined here\
    \ is in the encryption schemes in Section 6 and\n   the message authentication\
    \ scheme in Section 7. Other applications\n   are certainly possible, hence the\
    \ independent definition of these\n   functions.\n   Two functions are specified\
    \ in this section: PBKDF1 and PBKDF2.\n   PBKDF2 is recommended for new applications;\
    \ PBKDF1 is included only\n   for compatibility with existing applications, and\
    \ is not recommended\n   for new applications.\n   A typical application of the\
    \ key derivation functions defined here\n   might include the following steps:\n\
    \      1. Select a salt S and an iteration count c, as outlined in\n         Section\
    \ 4.\n      2. Select a length in octets for the derived key, dkLen.\n      3.\
    \ Apply the key derivation function to the password, the salt,\n         the iteration\
    \ count and the key length to produce a derived\n         key.\n      4. Output\
    \ the derived key.\n   Any number of keys may be derived from a password by varying\
    \ the\n   salt, as described in Section 3.\n"
- title: 5.1 PBKDF1
  contents:
  - "5.1 PBKDF1\n   PBKDF1 applies a hash function, which shall be MD2 [6], MD5 [19]\
    \ or\n   SHA-1 [18], to derive keys. The length of the derived key is bounded\n\
    \   by the length of the hash function output, which is 16 octets for MD2\n  \
    \ and MD5 and 20 octets for SHA-1. PBKDF1 is compatible with the key\n   derivation\
    \ process in PKCS #5 v1.5.\n   PBKDF1 is recommended only for compatibility with\
    \ existing\n   applications since the keys it produces may not be large enough\
    \ for\n   some applications.\n   PBKDF1 (P, S, c, dkLen)\n   Options:        Hash\
    \       underlying hash function\n   Input:          P          password, an octet\
    \ string\n                   S          salt, an eight-octet string\n        \
    \           c          iteration count, a positive integer\n                 \
    \  dkLen      intended length in octets of derived key,\n                    \
    \          a positive integer, at most 16 for MD2 or\n                       \
    \       MD5 and 20 for SHA-1\n   Output:         DK         derived key, a dkLen-octet\
    \ string\n   Steps:\n      1. If dkLen > 16 for MD2 and MD5, or dkLen > 20 for\
    \ SHA-1, output\n         \"derived key too long\" and stop.\n      2. Apply the\
    \ underlying hash function Hash for c iterations to the\n         concatenation\
    \ of the password P and the salt S, then extract\n         the first dkLen octets\
    \ to produce a derived key DK:\n                   T_1 = Hash (P || S) ,\n   \
    \                T_2 = Hash (T_1) ,\n                   ...\n                \
    \   T_c = Hash (T_{c-1}) ,\n                   DK = Tc<0..dkLen-1>\n      3. Output\
    \ the derived key DK.\n"
- title: 5.2 PBKDF2
  contents:
  - "5.2 PBKDF2\n   PBKDF2 applies a pseudorandom function (see Appendix B.1 for an\n\
    \   example) to derive keys. The length of the derived key is essentially\n  \
    \ unbounded. (However, the maximum effective search space for the\n   derived\
    \ key may be limited by the structure of the underlying\n   pseudorandom function.\
    \ See Appendix B.1 for further discussion.)\n   PBKDF2 is recommended for new\
    \ applications.\n   PBKDF2 (P, S, c, dkLen)\n   Options:        PRF        underlying\
    \ pseudorandom function (hLen\n                              denotes the length\
    \ in octets of the\n                              pseudorandom function output)\n\
    \   Input:          P          password, an octet string\n                   S\
    \          salt, an octet string\n                   c          iteration count,\
    \ a positive integer\n                   dkLen      intended length in octets\
    \ of the derived\n                              key, a positive integer, at most\n\
    \                              (2^32 - 1) * hLen\n   Output:         DK      \
    \   derived key, a dkLen-octet string\n   Steps:\n      1. If dkLen > (2^32 -\
    \ 1) * hLen, output \"derived key too long\" and\n         stop.\n      2. Let\
    \ l be the number of hLen-octet blocks in the derived key,\n         rounding\
    \ up, and let r be the number of octets in the last\n         block:\n       \
    \            l = CEIL (dkLen / hLen) ,\n                   r = dkLen - (l - 1)\
    \ * hLen .\n         Here, CEIL (x) is the \"ceiling\" function, i.e. the smallest\n\
    \         integer greater than, or equal to, x.\n      3. For each block of the\
    \ derived key apply the function F defined\n         below to the password P,\
    \ the salt S, the iteration count c, and\n         the block index to compute\
    \ the block:\n                   T_1 = F (P, S, c, 1) ,\n                   T_2\
    \ = F (P, S, c, 2) ,\n                   ...\n                   T_l = F (P, S,\
    \ c, l) ,\n         where the function F is defined as the exclusive-or sum of\
    \ the\n         first c iterates of the underlying pseudorandom function PRF\n\
    \         applied to the password P and the concatenation of the salt S\n    \
    \     and the block index i:\n                   F (P, S, c, i) = U_1 \\xor U_2\
    \ \\xor ... \\xor U_c\n         where\n                   U_1 = PRF (P, S || INT\
    \ (i)) ,\n                   U_2 = PRF (P, U_1) ,\n                   ...\n  \
    \                 U_c = PRF (P, U_{c-1}) .\n         Here, INT (i) is a four-octet\
    \ encoding of the integer i, most\n         significant octet first.\n      4.\
    \ Concatenate the blocks and extract the first dkLen octets to\n         produce\
    \ a derived key DK:\n                   DK = T_1 || T_2 ||  ...  || T_l<0..r-1>\n\
    \      5. Output the derived key DK.\n   Note. The construction of the function\
    \ F follows a \"belt-and-\n   suspenders\" approach. The iterates U_i are computed\
    \ recursively to\n   remove a degree of parallelism from an opponent; they are\
    \ exclusive-\n   ored together to reduce concerns about the recursion degenerating\n\
    \   into a small set of values.\n"
- title: 6. Encryption Schemes
  contents:
  - "6. Encryption Schemes\n   An encryption scheme, in the symmetric setting, consists\
    \ of an\n   encryption operation and a decryption operation, where the encryption\n\
    \   operation produces a ciphertext from a message under a key, and the\n   decryption\
    \ operation recovers the message from the ciphertext under\n   the same key. In\
    \ a password-based encryption scheme, the key is a\n   password.\n   A typical\
    \ application of a password-based encryption scheme is a\n   private-key protection\
    \ method, where the message contains private-key\n   information, as in PKCS #8.\
    \ The encryption schemes defined here would\n   be suitable encryption algorithms\
    \ in that context.\n   Two schemes are specified in this section: PBES1 and PBES2.\
    \ PBES2 is\n   recommended for new applications; PBES1 is included only for\n\
    \   compatibility with existing applications, and is not recommended for\n   new\
    \ applications.\n"
- title: 6.1   PBES1
  contents:
  - "6.1   PBES1\n   PBES1 combines the PBKDF1 function (Section 5.1) with an underlying\n\
    \   block cipher, which shall be either DES [15] or RC2(tm) [21] in CBC\n   mode\
    \ [16]. PBES1 is compatible with the encryption scheme in PKCS #5\n   v1.5.\n\
    \   PBES1 is recommended only for compatibility with existing\n   applications,\
    \ since it supports only two underlying encryption\n   schemes, each of which\
    \ has a key size (56 or 64 bits) that may not be\n   large enough for some applications.\n"
- title: 6.1.1   Encryption Operation
  contents:
  - "6.1.1   Encryption Operation\n   The encryption operation for PBES1 consists\
    \ of the following steps,\n   which encrypt a message M under a password P to\
    \ produce a ciphertext\n   C:\n      1. Select an eight-octet salt S and an iteration\
    \ count c, as\n         outlined in Section 4.\n      2. Apply the PBKDF1 key\
    \ derivation function (Section 5.1) to the\n         password P, the salt S, and\
    \ the iteration count c to produce at\n         derived key DK of length 16 octets:\n\
    \                 DK = PBKDF1 (P, S, c, 16) .\n      3. Separate the derived key\
    \ DK into an encryption key K consisting\n         of the first eight octets of\
    \ DK and an initialization vector IV\n         consisting of the next eight octets:\n\
    \                 K   = DK<0..7> ,\n                 IV  = DK<8..15> .\n     \
    \ 4. Concatenate M and a padding string PS to form an encoded\n         message\
    \ EM:\n                 EM = M || PS ,\n         where the padding string PS consists\
    \ of 8-(||M|| mod 8) octets\n         each with value 8-(||M|| mod 8). The padding\
    \ string PS will\n         satisfy one of the following statements:\n        \
    \         PS = 01, if ||M|| mod 8 = 7 ;\n                 PS = 02 02, if ||M||\
    \ mod 8 = 6 ;\n                 ...\n                 PS = 08 08 08 08 08 08 08\
    \ 08, if ||M|| mod 8 = 0.\n         The length in octets of the encoded message\
    \ will be a multiple\n         of eight and it will be possible to recover the\
    \ message M\n         unambiguously from the encoded message. (This padding rule\
    \ is\n         taken from RFC 1423 [3].)\n      5. Encrypt the encoded message\
    \ EM with the underlying block cipher\n         (DES or RC2) in cipher block chaining\
    \ mode under the encryption\n         key K with initialization vector IV to produce\
    \ the ciphertext\n         C. For DES, the key K shall be considered as a 64-bit\
    \ encoding\n         of a 56-bit DES key with parity bits ignored (see [9]). For\n\
    \         RC2, the \"effective key bits\" shall be 64 bits.\n      6.   Output\
    \ the ciphertext C.\n   The salt S and the iteration count c may be conveyed to\
    \ the party\n   performing decryption in an AlgorithmIdentifier value (see Appendix\n\
    \   A.3).\n"
- title: 6.1.2 Decryption Operation
  contents:
  - "6.1.2 Decryption Operation\n   The decryption operation for PBES1 consists of\
    \ the following steps,\n   which decrypt a ciphertext C under a password P to\
    \ recover a message\n   M:\n      1. Obtain the eight-octet salt S and the iteration\
    \ count c.\n      2. Apply the PBKDF1 key derivation function (Section 5.1) to\
    \ the\n         password P, the salt S, and the iteration count c to produce a\n\
    \         derived key DK of length 16 octets:\n                 DK = PBKDF1 (P,\
    \ S, c, 16)\n      3. Separate the derived key DK into an encryption key K consisting\n\
    \         of the first eight octets of DK and an initialization vector IV\n  \
    \       consisting of the next eight octets:\n                 K = DK<0..7> ,\n\
    \                 IV  = DK<8..15> .\n      4. Decrypt the ciphertext C with the\
    \ underlying block cipher (DES\n         or RC2) in cipher block chaining mode\
    \ under the encryption key\n         K with initialization vector IV to recover\
    \ an encoded message\n         EM. If the length in octets of the ciphertext C\
    \ is not a\n         multiple of eight, output \"decryption error\" and stop.\n\
    \      5. Separate the encoded message EM into a message M and a padding\n   \
    \      string PS:\n                 EM = M || PS ,\n         where the padding\
    \ string PS consists of some number psLen\n         octets each with value psLen,\
    \ where psLen is between 1 and 8.\n         If it is not possible to separate\
    \ the encoded message EM in\n         this manner, output \"decryption error\"\
    \ and stop.\n      6. Output the recovered message M.\n"
- title: 6.2 PBES2
  contents:
  - "6.2 PBES2\n   PBES2 combines a password-based key derivation function, which\
    \ shall\n   be PBKDF2 (Section 5.2) for this version of PKCS #5, with an\n   underlying\
    \ encryption scheme (see Appendix B.2 for examples). The key\n   length and any\
    \ other parameters for the underlying encryption scheme\n   depend on the scheme.\n\
    \   PBES2 is recommended for new applications.\n"
- title: 6.2.1   Encryption Operation
  contents:
  - "6.2.1   Encryption Operation\n   The encryption operation for PBES2 consists\
    \ of the following steps,\n   which encrypt a message M under a password P to\
    \ produce a ciphertext\n   C, applying a selected key derivation function KDF\
    \ and a selected\n   underlying encryption scheme:\n      1. Select a salt S and\
    \ an iteration count c, as outlined in\n         Section 4.\n      2. Select the\
    \ length in octets, dkLen, for the derived key for the\n         underlying encryption\
    \ scheme.\n      3. Apply the selected key derivation function to the password\
    \ P,\n         the salt S, and the iteration count c to produce a derived key\n\
    \         DK of length dkLen octets:\n                 DK = KDF (P, S, c, dkLen)\
    \ .\n      4. Encrypt the message M with the underlying encryption scheme\n  \
    \       under the derived key DK to produce a ciphertext C. (This step\n     \
    \    may involve selection of parameters such as an initialization\n         vector\
    \ and padding, depending on the underlying scheme.)\n      5. Output the ciphertext\
    \ C.\n   The salt S, the iteration count c, the key length dkLen, and\n   identifiers\
    \ for the key derivation function and the underlying\n   encryption scheme may\
    \ be conveyed to the party performing decryption\n   in an AlgorithmIdentifier\
    \ value (see Appendix A.4).\n"
- title: 6.2.2   Decryption Operation
  contents:
  - "6.2.2   Decryption Operation\n   The decryption operation for PBES2 consists\
    \ of the following steps,\n   which decrypt a ciphertext C under a password P\
    \ to recover a message\n   M:\n      1. Obtain the salt S for the operation.\n\
    \      2. Obtain the iteration count c for the key derivation function.\n    \
    \  3. Obtain the key length in octets, dkLen, for the derived key for\n      \
    \   the underlying encryption scheme.\n      4. Apply the selected key derivation\
    \ function to the password P,\n         the salt S, and the iteration count c\
    \ to produce a derived key\n         DK of length dkLen octets:\n            \
    \     DK = KDF (P, S, c, dkLen) .\n      5. Decrypt the ciphertext C with the\
    \ underlying encryption scheme\n         under the derived key DK to recover a\
    \ message M. If the\n         decryption function outputs \"decryption error,\"\
    \ then output\n         \"decryption error\" and stop.\n      6. Output the recovered\
    \ message M.\n"
- title: 7. Message Authentication Schemes
  contents:
  - "7. Message Authentication Schemes\n   A message authentication scheme consists\
    \ of a MAC (message\n   authentication code) generation operation and a MAC verification\n\
    \   operation, where the MAC generation operation produces a message\n   authentication\
    \ code from a message under a key, and the MAC\n   verification operation verifies\
    \ the message authentication code under\n   the same key. In a password-based\
    \ message authentication scheme, the\n   key is a password.\n   One scheme is\
    \ specified in this section: PBMAC1.\n"
- title: 7.1 PBMAC1
  contents:
  - "7.1 PBMAC1\n   PBMAC1 combines a password-based key derivation function, which\
    \ shall\n   be PBKDF2  (Section 5.2) for this version of PKCS #5, with an\n  \
    \ underlying message authentication scheme (see Appendix B.3 for an\n   example).\
    \ The key length and any other parameters for the underlying\n   message authentication\
    \ scheme depend on the scheme.\n"
- title: 7.1.1 MAC Generation
  contents:
  - "7.1.1 MAC Generation\n   The MAC generation operation for PBMAC1 consists of\
    \ the following\n   steps, which process a message M under a password P to generate\
    \ a\n   message authentication code T, applying a selected key derivation\n  \
    \ function KDF and a selected underlying message authentication scheme:\n    \
    \  1. Select a salt S and an iteration count c, as outlined in\n         Section\
    \ 4.\n      2. Select a key length in octets, dkLen, for the derived key for\n\
    \         the underlying message authentication function.\n      3. Apply the\
    \ selected key derivation function to the password P,\n         the salt S, and\
    \ the iteration count c to produce a derived key\n         DK of length dkLen\
    \ octets:\n                 DK = KDF (P, S, c, dkLen) .\n      4. Process the\
    \ message M with the underlying message\n         authentication scheme under\
    \ the derived key DK to generate a\n         message authentication code T.\n\
    \      5. Output the message authentication code T.\n   The salt S, the iteration\
    \ count c, the key length dkLen, and\n   identifiers for the key derivation function\
    \ and underlying message\n   authentication scheme may be conveyed to the party\
    \ performing\n   verification in an AlgorithmIdentifier value (see Appendix A.5).\n"
- title: 7.1.2   MAC Verification
  contents:
  - "7.1.2   MAC Verification\n   The MAC verification operation for PBMAC1 consists\
    \ of the following\n   steps, which process a message M under a password P to\
    \ verify a\n   message authentication code T:\n      1. Obtain the salt S and\
    \ the iteration count c.\n      2. Obtain the key length in octets, dkLen, for\
    \ the derived key for\n         the underlying message authentication scheme.\n\
    \      3. Apply the selected key derivation function to the password P,\n    \
    \     the salt S, and the iteration count c to produce a derived key\n       \
    \  DK of length dkLen octets:\n                 DK = KDF (P, S, c, dkLen) .\n\
    \      4. Process the message M with the underlying message\n         authentication\
    \ scheme under the derived key DK to verify the\n         message authentication\
    \ code T.\n      5. If the message authentication code verifies, output \"correct\"\
    ;\n         else output \"incorrect.\"\n"
- title: 8. Security Considerations
  contents:
  - "8. Security Considerations\n   Password-based cryptography is generally limited\
    \ in the security that\n   it can provide, particularly for methods such as those\
    \ defined in\n   this document where off-line password search is possible. While\
    \ the\n   use of salt and iteration count can increase the complexity of attack\n\
    \   (see Section 4 for recommendations), it is essential that passwords\n   are\
    \ selected well, and relevant guidelines (e.g., [17]) should be\n   taken into\
    \ account. It is also important that passwords be protected\n   well if stored.\n\
    \   In general, different keys should be derived from a password for\n   different\
    \ uses to minimize the possibility of unintended\n   interactions. For password-based\
    \ encryption with a single algorithm,\n   a random salt is sufficient to ensure\
    \ that different keys will be\n   produced. In certain other situations, as outlined\
    \ in Section 4, a\n   structured salt is necessary. The recommendations in Section\
    \ 4 should\n   thus be taken into account when selecting the salt value.\n"
- title: 9. Author's Address
  contents:
  - "9. Author's Address\n   Burt Kaliski\n   RSA Laboratories\n   20 Crosby Drive\n\
    \   Bedford, MA 01730 USA\n   EMail: bkaliski@rsasecurity.com\n"
- title: APPENDICES
  contents:
  - 'APPENDICES

    '
- title: A. ASN.1 Syntax
  contents:
  - "A. ASN.1 Syntax\n   This section defines ASN.1 syntax for the key derivation\
    \ functions,\n   the encryption schemes, the message authentication scheme, and\n\
    \   supporting techniques. The intended application of these definitions\n   includes\
    \ PKCS #8 and other syntax for key management, encrypted data,\n   and integrity-protected\
    \ data. (Various aspects of ASN.1 are specified\n   in several ISO/IEC standards\
    \ [9][10][11][12][13][14].)\n   The object identifier pkcs-5 identifies the arc\
    \ of the OID tree from\n   which the PKCS #5-specific OIDs in this section are\
    \ derived:\n   rsadsi OBJECT IDENTIFIER ::= {iso(1) member-body(2) us(840) 113549}\n\
    \   pkcs OBJECT IDENTIFIER   ::= {rsadsi 1}\n   pkcs-5 OBJECT IDENTIFIER ::= {pkcs\
    \ 5}\n"
- title: A.1   PBKDF1
  contents:
  - "A.1   PBKDF1\n   No object identifier is given for PBKDF1, as the object identifiers\n\
    \   for PBES1 are sufficient for existing applications and PBKDF2 is\n   recommended\
    \ for new applications.\n"
- title: A.2   PBKDF2
  contents:
  - "A.2   PBKDF2\n   The object identifier id-PBKDF2 identifies the PBKDF2 key derivation\n\
    \   function (Section 5.2).\n   id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}\n\
    \   The parameters field associated with this OID in an\n   AlgorithmIdentifier\
    \ shall have type PBKDF2-params:\n   PBKDF2-params ::= SEQUENCE {\n       salt\
    \ CHOICE {\n           specified OCTET STRING,\n           otherSource AlgorithmIdentifier\
    \ {{PBKDF2-SaltSources}}\n       },\n       iterationCount INTEGER (1..MAX),\n\
    \       keyLength INTEGER (1..MAX) OPTIONAL,\n       prf AlgorithmIdentifier {{PBKDF2-PRFs}}\
    \ DEFAULT\n       algid-hmacWithSHA1 }\n   The fields of type PKDF2-params have\
    \ the following meanings:\n   -  salt specifies the salt value, or the source\
    \ of the salt value.\n      It shall either be an octet string or an algorithm\
    \ ID with an OID\n      in the set PBKDF2-SaltSources, which is reserved for future\n\
    \      versions of PKCS #5.\n      The salt-source approach is intended to indicate\
    \ how the salt\n      value is to be generated as a function of parameters in\
    \ the\n      algorithm ID, application data, or both. For instance, it may\n \
    \     indicate that the salt value is produced from the encoding of a\n      structure\
    \ that specifies detailed information about the derived\n      key as suggested\
    \ in Section 4.1. Some of the information may be\n      carried elsewhere, e.g.,\
    \ in the encryption algorithm ID. However,\n      such facilities are deferred\
    \ to a future version of PKCS #5.\n      In this version, an application may achieve\
    \ the benefits mentioned\n      in Section 4.1 by choosing a particular interpretation\
    \ of the salt\n      value in the specified alternative.\n   PBKDF2-SaltSources\
    \ ALGORITHM-IDENTIFIER ::= { ... }\n   -  iterationCount specifies the iteration\
    \ count. The maximum\n      iteration count allowed depends on the implementation.\
    \ It is\n      expected that implementation profiles may further constrain the\n\
    \      bounds.\n   -  keyLength, an optional field, is the length in octets of\
    \ the\n      derived key. The maximum key length allowed depends on the\n    \
    \  implementation; it is expected that implementation profiles may\n      further\
    \ constrain the bounds. The field is provided for\n      convenience only; the\
    \ key length is not cryptographically\n      protected. If there is concern about\
    \ interaction between\n      operations with different key lengths for a given\
    \ salt (see\n      Section 4.1), the salt should distinguish among the different\
    \ key\n      lengths.\n   -  prf identifies the underlying pseudorandom function.\
    \ It shall be\n      an algorithm ID with an OID in the set PBKDF2-PRFs, which\
    \ for this\n      version of PKCS #5 shall consist of id-hmacWithSHA1 (see Appendix\n\
    \      B.1.1) and any other OIDs defined by the application.\n      PBKDF2-PRFs\
    \ ALGORITHM-IDENTIFIER ::=\n          { {NULL IDENTIFIED BY id-hmacWithSHA1},\
    \ ... }\n      The default pseudorandom function is HMAC-SHA-1:\n      algid-hmacWithSHA1\
    \ AlgorithmIdentifier {{PBKDF2-PRFs}} ::=\n          {algorithm id-hmacWithSHA1,\
    \ parameters NULL : NULL}\n"
- title: A.3 PBES1
  contents:
  - "A.3 PBES1\n   Different object identifiers identify the PBES1 encryption scheme\n\
    \   (Section 6.1) according to the underlying hash function in the key\n   derivation\
    \ function and the underlying block cipher, as summarized in\n   the following\
    \ table:\n        Hash Function  Block Cipher      OID\n             MD2     \
    \      DES         pkcs-5.1\n             MD2           RC2         pkcs-5.4\n\
    \             MD5           DES         pkcs-5.3\n             MD5           RC2\
    \         pkcs-5.6\n            SHA-1          DES         pkcs-5.10\n       \
    \     SHA-1          RC2         pkcs-5.11\n   pbeWithMD2AndDES-CBC OBJECT IDENTIFIER\
    \ ::= {pkcs-5 1}\n   pbeWithMD2AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 4}\n \
    \  pbeWithMD5AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 3}\n   pbeWithMD5AndRC2-CBC\
    \ OBJECT IDENTIFIER ::= {pkcs-5 6}\n   pbeWithSHA1AndDES-CBC OBJECT IDENTIFIER\
    \ ::= {pkcs-5 10}\n   pbeWithSHA1AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 11}\n\
    \   For each OID, the parameters field associated with the OID in an\n   AlgorithmIdentifier\
    \ shall have type PBEParameter:\n   PBEParameter ::= SEQUENCE {\n       salt OCTET\
    \ STRING (SIZE(8)),\n       iterationCount INTEGER }\n   The fields of type PBEParameter\
    \ have the following meanings:\n   -  salt specifies the salt value, an eight-octet\
    \ string.\n   -  iterationCount specifies the iteration count.\n"
- title: A.4 PBES2
  contents:
  - "A.4 PBES2\n   The object identifier id-PBES2 identifies the PBES2 encryption\
    \ scheme\n   (Section 6.2).\n   id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}\n \
    \  The parameters field associated with this OID in an\n   AlgorithmIdentifier\
    \ shall have type PBES2-params:\n   PBES2-params ::= SEQUENCE {\n       keyDerivationFunc\
    \ AlgorithmIdentifier {{PBES2-KDFs}},\n       encryptionScheme AlgorithmIdentifier\
    \ {{PBES2-Encs}} }\n   The fields of type PBES2-params have the following meanings:\n\
    \   -  keyDerivationFunc identifies the underlying key derivation\n      function.\
    \ It shall be an algorithm ID with an OID in the set\n      PBES2-KDFs, which\
    \ for this version of PKCS #5 shall consist of\n      id-PBKDF2 (Appendix A.2).\n\
    \   PBES2-KDFs ALGORITHM-IDENTIFIER ::=\n       { {PBKDF2-params IDENTIFIED BY\
    \ id-PBKDF2}, ... }\n   -  encryptionScheme identifies the underlying encryption\
    \ scheme. It\n      shall be an algorithm ID with an OID in the set PBES2-Encs,\
    \ whose\n      definition is left to the application. Example underlying\n   \
    \   encryption schemes are given in Appendix B.2.\n   PBES2-Encs ALGORITHM-IDENTIFIER\
    \ ::= { ... }\n"
- title: A.5 PBMAC1
  contents:
  - "A.5 PBMAC1\n   The object identifier id-PBMAC1 identifies the PBMAC1 message\n\
    \   authentication scheme (Section 7.1).\n   id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5\
    \ 14}\n   The parameters field associated with this OID in an\n   AlgorithmIdentifier\
    \ shall have type PBMAC1-params:\n   PBMAC1-params ::=  SEQUENCE {\n       keyDerivationFunc\
    \ AlgorithmIdentifier {{PBMAC1-KDFs}},\n       messageAuthScheme AlgorithmIdentifier\
    \ {{PBMAC1-MACs}} }\n   The keyDerivationFunc field has the same meaning as the\
    \ corresponding\n   field of PBES2-params (Appendix A.4) except that the set of\
    \ OIDs is\n   PBMAC1-KDFs.\n   PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=\n       {\
    \ {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n   The messageAuthScheme field\
    \ identifies the underlying message\n   authentication scheme. It shall be an\
    \ algorithm ID with an OID in the\n   set PBMAC1-MACs, whose definition is left\
    \ to the application. Example\n   underlying encryption schemes are given in Appendix\
    \ B.3.\n   PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }\n"
- title: B. Supporting Techniques
  contents:
  - "B. Supporting Techniques\n   This section gives several examples of underlying\
    \ functions and\n   schemes supporting the password-based schemes in Sections\
    \ 5, 6 and 7.\n   While these supporting techniques are appropriate for applications\
    \ to\n   implement, none of them is required to be implemented. It is\n   expected,\
    \ however, that profiles for PKCS #5 will be developed that\n   specify particular\
    \ supporting techniques.\n   This section also gives object identifiers for the\
    \ supporting\n   techniques.  The object identifiers digestAlgorithm and\n   encryptionAlgorithm\
    \ identify the arcs from which certain algorithm\n   OIDs referenced in this section\
    \ are derived:\n   digestAlgorithm OBJECT IDENTIFIER ::= {rsadsi 2}\n   encryptionAlgorithm\
    \ OBJECT IDENTIFIER ::= {rsadsi 3}\n"
- title: B.1 Pseudorandom functions
  contents:
  - "B.1 Pseudorandom functions\n   An example pseudorandom function for PBKDF2 (Section\
    \ 5.2) is HMAC-\n   SHA-1.\n"
- title: B.1.1 HMAC-SHA-1
  contents:
  - "B.1.1 HMAC-SHA-1\n   HMAC-SHA-1 is the pseudorandom function corresponding to\
    \ the HMAC\n   message authentication code [7] based on the SHA-1 hash function\n\
    \   [18].  The pseudorandom function is the same function by which the\n   message\
    \ authentication code is computed, with a full-length output.\n   (The first argument\
    \ to the pseudorandom function PRF serves as HMAC's\n   \"key,\" and the second\
    \ serves as HMAC's \"text.\" In the case of PBKDF2,\n   the \"key\" is thus the\
    \ password and the \"text\" is the salt.)  HMAC-\n   SHA-1 has a variable key\
    \ length and a 20-octet (160-bit) output\n   value.\n   Although the length of\
    \ the key to HMAC-SHA-1 is essentially\n   unbounded, the effective search space\
    \ for pseudorandom function\n   outputs may be limited by the structure of the\
    \ function. In\n   particular, when the key is longer than 512 bits, HMAC-SHA-1\
    \ will\n   first hash it to 160 bits. Thus, even if a long derived key\n   consisting\
    \ of several pseudorandom function outputs is produced from\n   a key, the effective\
    \ search space for the derived key will be at most\n   160 bits. Although the\
    \ specific limitation for other key sizes\n   depends on details of the HMAC construction,\
    \ one should assume, to be\n   conservative, that the effective search space is\
    \ limited to 160 bits\n   for other key sizes as well.\n   (The 160-bit limitation\
    \ should not generally pose a practical\n   limitation in the case of password-based\
    \ cryptography, since the\n   search space for a password is unlikely to be greater\
    \ than 160 bits.)\n   The object identifier id-hmacWithSHA1 identifies the HMAC-SHA-1\n\
    \   pseudorandom function:\n   id-hmacWithSHA1 OBJECT IDENTIFIER ::= {digestAlgorithm\
    \ 7}\n   The parameters field associated with this OID in an\n   AlgorithmIdentifier\
    \ shall have type NULL. This object identifier is\n   employed in the object set\
    \ PBKDF2-PRFs (Appendix A.2).\n   Note. Although HMAC-SHA-1 was designed as a\
    \ message authentication\n   code, its proof of security is readily modified to\
    \ accommodate\n   requirements for a pseudorandom function, under stronger assumptions.\n\
    \   A hash function may also meet the requirements of a pseudorandom\n   function\
    \ under certain assumptions. For instance, the direct\n   application of a hash\
    \ function to to the concatenation of the \"key\"\n   and the \"text\" may be\
    \ appropriate, provided that \"text\" has\n   appropriate structure to prevent\
    \ certain attacks. HMAC-SHA-1 is\n   preferable, however, because it treats \"\
    key\" and \"text\" as separate\n   arguments and does not require \"text\" to\
    \ have any structure.\n"
- title: B.2 Encryption Schemes
  contents:
  - "B.2 Encryption Schemes\n   Example pseudorandom functions for PBES2 (Section\
    \ 6.2) are DES-CBC-\n   Pad, DES-EDE2-CBC-Pad, RC2-CBC-Pad, and RC5-CBC-Pad.\n\
    \   The object identifiers given in this section are intended to be\n   employed\
    \ in the object set PBES2-Encs (Appendix A.4).\n"
- title: B.2.1 DES-CBC-Pad
  contents:
  - "B.2.1 DES-CBC-Pad\n   DES-CBC-Pad is single-key DES [15] in CBC mode [16] with\
    \ the RFC 1423\n   padding operation (see Section 6.1.1). DES-CBC-Pad has an eight-octet\n\
    \   encryption key and an eight-octet initialization vector.  The key is\n   considered\
    \ as a 64-bit encoding of a 56-bit DES key with parity bits\n   ignored.\n   The\
    \ object identifier desCBC (defined in the NIST/OSI Implementors'\n   Workshop\
    \ agreements) identifies the DES-CBC-Pad encryption scheme:\n   desCBC OBJECT\
    \ IDENTIFIER ::=\n       {iso(1) identified-organization(3) oiw(14) secsig(3)\n\
    \        algorithms(2) 7}\n   The parameters field associated with this OID in\
    \ an\n   AlgorithmIdentifier shall have type OCTET STRING (SIZE(8)),\n   specifying\
    \ the initialization vector for CBC mode.\n"
- title: B.2.2 DES-EDE3-CBC-Pad
  contents:
  - "B.2.2 DES-EDE3-CBC-Pad\n   DES-EDE3-CBC-Pad is three-key triple-DES in CBC mode\
    \ [1] with the RFC\n   1423 padding operation. DES-EDE3-CBC-Pad has a 24-octet\
    \ encryption\n   key and an eight-octet initialization vector. The key is considered\n\
    \   as the concatenation of three eight-octet keys, each of which is a\n   64-bit\
    \ encoding of a 56-bit DES key with parity bits ignored.\n   The object identifier\
    \ des-EDE3-CBC identifies the DES-EDE3-CBC-Pad\n   encryption scheme:\n   des-EDE3-CBC\
    \ OBJECT IDENTIFIER ::= {encryptionAlgorithm 7}\n   The parameters field associated\
    \ with this OID in an\n   AlgorithmIdentifier shall have type OCTET STRING (SIZE(8)),\n\
    \   specifying the initialization vector for CBC mode.\n   Note. An OID for DES-EDE3-CBC\
    \ without padding is given in ANSI X9.52\n   [1]; the one given here is preferred\
    \ since it specifies padding.\n"
- title: B.2.3 RC2-CBC-Pad
  contents:
  - "B.2.3 RC2-CBC-Pad\n   RC2-CBC-Pad is the RC2(tm) encryption algorithm [21] in\
    \ CBC mode with\n   the RFC 1423 padding operation. RC2-CBC-Pad has a variable\
    \ key\n   length, from one to 128 octets, a separate \"effective key bits\"\n\
    \   parameter from one to 1024 bits that limits the effective search\n   space\
    \ independent of the key length, and an eight-octet\n   initialization vector.\n\
    \   The object identifier rc2CBC identifies the RC2-CBC-Pad encryption\n   scheme:\n\
    \   rc2CBC OBJECT IDENTIFIER ::= {encryptionAlgorithm 2}\n   The parameters field\
    \ associated with OID in an AlgorithmIdentifier\n   shall have type RC2-CBC-Parameter:\n\
    \   RC2-CBC-Parameter ::= SEQUENCE {\n       rc2ParameterVersion INTEGER OPTIONAL,\n\
    \       iv OCTET STRING (SIZE(8)) }\n   The fields of type RC2-CBCParameter have\
    \ the following meanings:\n   -  rc2ParameterVersion is a proprietary RSA Security\
    \ Inc. encoding of\n      the \"effective key bits\" for RC2. The following encodings\
    \ are\n      defined:\n         Effective Key Bits         Encoding\n        \
    \         40                    160\n                 64                    120\n\
    \                128                     58\n               b >= 256         \
    \         b\n   If the rc2ParameterVersion field is omitted, the \"effective key\
    \ bits\"\n   defaults to 32. (This is for backward compatibility with certain\
    \ very\n   old implementations.)\n   -  iv is the eight-octet initialization vector.\n"
- title: B.2.4 RC5-CBC-Pad
  contents:
  - "B.2.4 RC5-CBC-Pad\n   RC5-CBC-Pad is the RC5(tm) encryption algorithm [20] in\
    \ CBC mode with\n   a generalization of the RFC 1423 padding operation. This scheme\
    \ is\n   fully specified in [2]. RC5-CBC-Pad has a variable key length, from 0\n\
    \   to 256 octets, and supports both a 64-bit block size and a 128-bit\n   block\
    \ size. For the former, it has an eight-octet initialization\n   vector, and for\
    \ the latter, a 16-octet initialization vector.\n   RC5-CBC-Pad also has a variable\
    \ number of \"rounds\" in the encryption\n   operation, from 8 to 127.\n   Note:\
    \ The generalization of the padding operation is as follows. For\n   RC5 with\
    \ a 64-bit block size, the padding string is as defined in RFC\n   1423. For RC5\
    \ with a 128-bit block size, the padding string consists\n   of 16-(||M|| mod\
    \ 16) octets each with value 16-(||M|| mod 16).\n   The object identifier rc5-CBC-PAD\
    \ [2] identifies RC5-CBC-Pad\n   encryption scheme:\n   rc5-CBC-PAD OBJECT IDENTIFIER\
    \ ::= {encryptionAlgorithm 9}\n   The parameters field associated with this OID\
    \ in an\n   AlgorithmIdentifier shall have type RC5-CBC-Parameters:\n   RC5-CBC-Parameters\
    \ ::= SEQUENCE {\n       version INTEGER {v1-0(16)} (v1-0),\n       rounds INTEGER\
    \ (8..127),\n       blockSizeInBits INTEGER (64 | 128),\n       iv OCTET STRING\
    \ OPTIONAL }\n   The fields of type RC5-CBC-Parameters have the following meanings:\n\
    \   -  version is the version of the algorithm, which shall be v1-0.\n   -  rounds\
    \ is the number of rounds in the encryption operation, which\n      shall be between\
    \ 8 and 127.\n   -  blockSizeInBits is the block size in bits, which shall be\
    \ 64 or\n      128.\n   -  iv is the initialization vector, an eight-octet string\
    \ for 64-bit\n      RC5 and a 16-octet string for 128-bit RC5. The default is\
    \ a string\n      of the appropriate length consisting of zero octets.\n"
- title: B.3 Message Authentication Schemes
  contents:
  - "B.3 Message Authentication Schemes\n   An example message authentication scheme\
    \ for PBMAC1 (Section 7.1) is\n   HMAC-SHA-1.\n"
- title: B.3.1 HMAC-SHA-1
  contents:
  - "B.3.1 HMAC-SHA-1\n   HMAC-SHA-1 is the HMAC message authentication scheme [7]\
    \ based on the\n   SHA-1 hash function [18]. HMAC-SHA-1 has a variable key length\
    \ and a\n   20-octet (160-bit) message authentication code.\n   The object identifier\
    \ id-hmacWithSHA1 (see Appendix B.1.1) identifies\n   the HMAC-SHA-1 message authentication\
    \ scheme. (The object identifier\n   is the same for both the pseudorandom function\
    \ and the message\n   authentication scheme; the distinction is to be understood\
    \ by\n   context.) This object identifier is intended to be employed in the\n\
    \   object set PBMAC1-Macs (Appendix A.5).\n"
- title: C. ASN.1 Module
  contents:
  - "C. ASN.1 Module\n   For reference purposes, the ASN.1 syntax in the preceding\
    \ sections is\n   presented as an ASN.1 module here.\n   -- PKCS #5 v2.0 ASN.1\
    \ Module\n   -- Revised March 25, 1999\n   -- This module has been checked for\
    \ conformance with the\n   -- ASN.1 standard by the OSS ASN.1 Tools\n   PKCS5v2-0\
    \ {iso(1) member-body(2) us(840) rsadsi(113549)\n       pkcs(1) pkcs-5(5) modules(16)\
    \ pkcs5v2-0(1)}\n   DEFINITIONS ::= BEGIN\n   -- Basic object identifiers\n  \
    \ rsadsi OBJECT IDENTIFIER ::= {iso(1) member-body(2) us(840) 113549}\n   pkcs\
    \ OBJECT IDENTIFIER ::= {rsadsi 1}\n   pkcs-5 OBJECT IDENTIFIER ::= {pkcs 5}\n\
    \   -- Basic types and classes\n   AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet\
    \ } ::=\n     SEQUENCE {\n       algorithm ALGORITHM-IDENTIFIER.&id({InfoObjectSet}),\n\
    \       parameters ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}\n       {@algorithm})\
    \ OPTIONAL\n   }\n   ALGORITHM-IDENTIFIER ::= TYPE-IDENTIFIER\n   -- PBKDF2\n\
    \   PBKDF2Algorithms ALGORITHM-IDENTIFIER ::=\n       { {PBKDF2-params IDENTIFIED\
    \ BY id-PBKDF2}, ...}\n   id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}\n   algid-hmacWithSHA1\
    \ AlgorithmIdentifier {{PBKDF2-PRFs}} ::=\n       {algorithm id-hmacWithSHA1,\
    \ parameters NULL : NULL}\n   PBKDF2-params ::= SEQUENCE {\n       salt CHOICE\
    \ {\n         specified OCTET STRING,\n         otherSource AlgorithmIdentifier\
    \ {{PBKDF2-SaltSources}}\n       },\n       iterationCount INTEGER (1..MAX),\n\
    \       keyLength INTEGER (1..MAX) OPTIONAL,\n       prf AlgorithmIdentifier {{PBKDF2-PRFs}}\
    \ DEFAULT\n       algid-hmacWithSHA1\n   }\n   PBKDF2-SaltSources ALGORITHM-IDENTIFIER\
    \ ::= { ... }\n   PBKDF2-PRFs ALGORITHM-IDENTIFIER ::=\n       { {NULL IDENTIFIED\
    \ BY id-hmacWithSHA1}, ... }\n   -- PBES1\n   PBES1Algorithms ALGORITHM-IDENTIFIER\
    \ ::= {\n       {PBEParameter IDENTIFIED BY pbeWithMD2AndDES-CBC}  |\n       {PBEParameter\
    \ IDENTIFIED BY pbeWithMD2AndRC2-CBC}  |\n       {PBEParameter IDENTIFIED BY pbeWithMD5AndDES-CBC}\
    \  |\n       {PBEParameter IDENTIFIED BY pbeWithMD5AndRC2-CBC}  |\n       {PBEParameter\
    \ IDENTIFIED BY pbeWithSHA1AndDES-CBC} |\n       {PBEParameter IDENTIFIED BY pbeWithSHA1AndRC2-CBC},\n\
    \       ...\n   }\n   pbeWithMD2AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 1}\n\
    \   pbeWithMD2AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 4}\n   pbeWithMD5AndDES-CBC\
    \ OBJECT IDENTIFIER ::= {pkcs-5 3}\n   pbeWithMD5AndRC2-CBC OBJECT IDENTIFIER\
    \ ::= {pkcs-5 6}\n   pbeWithSHA1AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 10}\n\
    \   pbeWithSHA1AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 11}\n   PBEParameter ::=\
    \ SEQUENCE {\n       salt OCTET STRING (SIZE(8)),\n       iterationCount INTEGER\n\
    \   }\n   -- PBES2\n   PBES2Algorithms ALGORITHM-IDENTIFIER ::=\n       { {PBES2-params\
    \ IDENTIFIED BY id-PBES2}, ...}\n   id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}\n\
    \   PBES2-params ::= SEQUENCE {\n       keyDerivationFunc AlgorithmIdentifier\
    \ {{PBES2-KDFs}},\n       encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}\n\
    \   }\n   PBES2-KDFs ALGORITHM-IDENTIFIER ::=\n       { {PBKDF2-params IDENTIFIED\
    \ BY id-PBKDF2}, ... }\n   PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }\n   --\
    \ PBMAC1\n   PBMAC1Algorithms ALGORITHM-IDENTIFIER ::=\n       { {PBMAC1-params\
    \ IDENTIFIED BY id-PBMAC1}, ...}\n   id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5 14}\n\
    \   PBMAC1-params ::=  SEQUENCE {\n       keyDerivationFunc AlgorithmIdentifier\
    \ {{PBMAC1-KDFs}},\n       messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}}\n\
    \   }\n   PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=\n       { {PBKDF2-params IDENTIFIED\
    \ BY id-PBKDF2}, ... }\n   PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }\n   --\
    \ Supporting techniques\n   digestAlgorithm OBJECT IDENTIFIER     ::= {rsadsi\
    \ 2}\n   encryptionAlgorithm OBJECT IDENTIFIER ::= {rsadsi 3}\n   SupportingAlgorithms\
    \ ALGORITHM-IDENTIFIER ::= {\n       {NULL IDENTIFIED BY id-hmacWithSHA1} |\n\
    \       {OCTET STRING (SIZE(8)) IDENTIFIED BY desCBC} |\n       {OCTET STRING\
    \ (SIZE(8)) IDENTIFIED BY des-EDE3-CBC} |\n       {RC2-CBC-Parameter IDENTIFIED\
    \ BY rc2CBC} |\n       {RC5-CBC-Parameters IDENTIFIED BY rc5-CBC-PAD},\n     \
    \  ...\n   }\n   id-hmacWithSHA1 OBJECT IDENTIFIER ::= {digestAlgorithm 7}\n \
    \  desCBC OBJECT IDENTIFIER ::=\n       {iso(1) identified-organization(3) oiw(14)\
    \ secsig(3)\n        algorithms(2) 7} -- from OIW\n   des-EDE3-CBC OBJECT IDENTIFIER\
    \ ::= {encryptionAlgorithm 7}\n   rc2CBC OBJECT IDENTIFIER ::= {encryptionAlgorithm\
    \ 2}\n   RC2-CBC-Parameter ::= SEQUENCE {\n       rc2ParameterVersion INTEGER\
    \ OPTIONAL,\n       iv OCTET STRING (SIZE(8))\n   }\n   rc5-CBC-PAD OBJECT IDENTIFIER\
    \ ::= {encryptionAlgorithm 9}\n   RC5-CBC-Parameters ::= SEQUENCE {\n       version\
    \ INTEGER {v1-0(16)} (v1-0),\n       rounds INTEGER (8..127),\n       blockSizeInBits\
    \ INTEGER (64 | 128),\n       iv OCTET STRING OPTIONAL\n   }\n   END\n"
- title: Intellectual Property Considerations
  contents:
  - "Intellectual Property Considerations\n   RSA Security makes no patent claims\
    \ on the general constructions\n   described in this document, although specific\
    \ underlying techniques\n   may be covered. Among the underlying techniques, the\
    \ RC5 encryption\n   algorithm (Appendix B.2.4) is protected by U.S. Patents 5,724,428\n\
    \   [22] and 5,835,600 [23].\n   RC2 and RC5 are trademarks of RSA Security.\n\
    \   License to copy this document is granted provided that it is\n   identified\
    \ as RSA Security Inc. Public-Key Cryptography Standards\n   (PKCS) in all material\
    \ mentioning or referencing this document.\n   RSA Security makes no representations\
    \ regarding intellectual property\n   claims by other parties. Such determination\
    \ is the responsibility of\n   the user.\n"
- title: Revision history
  contents:
  - "Revision history\n   Versions 1.0-1.3\n      Versions 1.0-1.3 were distributed\
    \ to participants in RSA Data\n      Security Inc.'s Public-Key Cryptography Standards\
    \ meetings in\n      February and March 1991.\n   Version 1.4\n      Version 1.4\
    \ was part of the June 3, 1991 initial public release of\n      PKCS. Version\
    \ 1.4 was published as NIST/OSI Implementors' Workshop\n      document SEC-SIG-91-20.\n\
    \   Version 1.5\n      Version 1.5 incorporated several editorial changes, including\n\
    \      updates to the references and the addition of a revision history.\n   Version\
    \ 2.0\n      Version 2.0 incorporates major editorial changes in terms of the\n\
    \      document structure, and introduces the PBES2 encryption scheme,\n     \
    \ the PBMAC1 message authentication scheme, and independent\n      password-based\
    \ key derivation functions. This version continues to\n      support the encryption\
    \ process in version 1.5.\n"
- title: References
  contents:
  - "References\n   [1]  American National Standard X9.52 - 1998, Triple Data Encryption\n\
    \        Algorithm Modes of Operation. Working draft, Accredited\n        Standards\
    \ Committee X9, July 27, 1998.\n   [2]  Baldwin, R. and R. Rivest, \"The RC5,\
    \ RC5-CBC, RC5-CBC-Pad, and\n        RC5-CTS Algorithms\", RFC 2040, October 1996.\n\
    \   [3]  Balenson, D., \"Privacy Enhancement for Internet Electronic Mail:\n \
    \       Part III: Algorithms, Modes, and Identifiers\", RFC 1423,\n        February\
    \ 1993.\n   [4]  S.M. Bellovin and M. Merritt. Encrypted key exchange:\n     \
    \   Password-based protocols secure against dictionary attacks. In\n        Proceedings\
    \ of the 1992 IEEE Computer Society Conference on\n        Research in Security\
    \ and Privacy, pages 72-84, IEEE Computer\n        Society, 1992.\n   [5]  D.\
    \ Jablon. Strong password-only authenticated key exchange. ACM\n        Computer\
    \ Communications Review, October 1996.\n   [6]  Kaliski, B., \"The MD2 Message-Digest\
    \ Algorithm\", RFC 1319, April\n        1992.\n   [7]  Krawczyk, H., Bellare,\
    \ M. and R. Canetti, \"HMAC: Keyed-Hashing\n        for Message Authentication\"\
    , RFC 2104, February 1997.\n   [8]  Robert Morris and Ken Thompson. Password security:\
    \ A case\n        history.  Communications of the ACM, 22(11):594-597, November\n\
    \        1979.\n   [9]  ISO/IEC 8824-1:1995: Information technology - Abstract\
    \ Syntax\n        Notation One (ASN.1) - Specification of basic notation. 1995.\n\
    \   [10] ISO/IEC 8824-1:1995/Amd.1:1995 Information technology - Abstract\n  \
    \      Syntax Notation One (ASN.1) - Specification of basic notation -\n     \
    \   Amendment 1 - Rules of extensibility. 1995.\n   [11] ISO/IEC 8824-2:1995 Information\
    \ technology - Abstract Syntax\n        Notation One (ASN.1) - Information object\
    \ specification. 1995.\n   [12] ISO/IEC 8824-2:1995/Amd.1:1995 Information technology\
    \ - Abstract\n        Syntax Notation One (ASN.1) - Information object specification\
    \ -\n        Amendment 1 - Rules of extensibility. 1995.\n   [13] ISO/IEC 8824-3:1995\
    \ Information technology - Abstract Syntax\n        Notation One (ASN.1) - Constraint\
    \ specification. 1995.\n   [14] ISO/IEC 8824-4:1995 Information technology - Abstract\
    \ Syntax\n        Notation One (ASN.1) - Parameterization of ASN.1 specifications.\n\
    \        1995.\n   [15] National Institute of Standards and Technology (NIST).\
    \ FIPS PUB\n        46-2: Data Encryption Standard. December 30, 1993.\n   [16]\
    \ National Institute of Standards and Technology (NIST). FIPS PUB\n        81:\
    \ DES Modes of Operation. December 2, 1980.\n   [17] National Institute of Standards\
    \ and Technology (NIST). FIPS PUB\n        112: Password Usage. May 30, 1985.\n\
    \   [18] National Institute of Standards and Technology (NIST). FIPS PUB\n   \
    \     180-1: Secure Hash Standard. April 1994.\n   [19] Rivest, R., \"The MD5\
    \ Message-Digest Algorithm\", RFC 1321, April\n        1992.\n   [20] R.L. Rivest.\
    \ The RC5 encryption algorithm. In Proceedings of the\n        Second International\
    \ Workshop on Fast Software Encryption, pages\n        86-96, Springer-Verlag,\
    \ 1994.\n   [21] Rivest, R., \"A Description of the RC2(r) Encryption Algorithm\"\
    ,\n        RFC 2268, March 1998.\n   [22] R.L. Rivest. Block-Encryption Algorithm\
    \ with Data-Dependent\n        Rotations. U.S. Patent No. 5,724,428, March 3,\
    \ 1998.\n   [23] R.L. Rivest. Block Encryption Algorithm with Data-Dependent\n\
    \        Rotations. U.S. Patent No. 5,835,600, November 10, 1998.\n   [24] RSA\
    \ Laboratories. PKCS #5: Password-Based Encryption Standard.\n        Version\
    \ 1.5, November 1993.\n   [25] RSA Laboratories. PKCS #8: Private-Key Information\
    \ Syntax\n        Standard.  Version 1.2, November 1993.\n   [26] T. Wu. The Secure\
    \ Remote Password protocol. In Proceedings of\n        the 1998 Internet Society\
    \ Network and Distributed System\n        Security Symposium, pages 97-111, Internet\
    \ Society, 1998.\n   [27] Yergeau, F., \"UTF-8, a transformation format of ISO\
    \ 10646\", RFC\n        2279, January 1998.\n"
- title: Contact Information & About PKCS
  contents:
  - "Contact Information & About PKCS\n   The Public-Key Cryptography Standards are\
    \ specifications produced by\n   RSA Laboratories in cooperation with secure systems\
    \ developers\n   worldwide for the purpose of accelerating the deployment of public-\n\
    \   key cryptography. First published in 1991 as a result of meetings\n   with\
    \ a small group of early adopters of public-key technology, the\n   PKCS documents\
    \ have become widely referenced and implemented.\n   Contributions from the PKCS\
    \ series have become part of many formal\n   and de facto standards, including\
    \ ANSI X9 documents, PKIX, SET,\n   S/MIME, and SSL.\n   Further development of\
    \ PKCS occurs through mailing list discussions\n   and occasional workshops, and\
    \ suggestions for improvement are\n   welcome. For more information, contact:\n\
    \        PKCS Editor\n        RSA Laboratories\n        20 Crosby Drive\n    \
    \    Bedford, MA  01730  USA\n        pkcs-editor@rsasecurity.com\n        http://www.rsalabs.com/pkcs/\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
