- title: __initial_text__
  contents:
  - '                       Pip Near-term Architecture

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Preamble
  contents:
  - "Preamble\n   During 1992 and 1993, the Pip internet protocol, developed at\n\
    \   Belclore, was one of the candidate replacments for IP.  In mid 1993,\n   Pip\
    \ was merged with another candidate, the Simple Internet Protocol\n   (SIP), creating\
    \ SIPP (SIP Plus).  While the major aspects of Pip--\n   particularly its distinction\
    \ of identifier from address, and its use\n   of the source route mechanism to\
    \ achieve rich routing capabilities--\n   were preserved, many of the ideas in\
    \ Pip were not.  The purpose of\n   this RFC and the companion RFC \"Pip Header\
    \ Processing\" are to record\n   the ideas (good and bad) of Pip.\n   This document\
    \ references a number of Pip draft memos that were in\n   various stages of completion.\
    \  The basic ideas of those memos are\n   presented in this document, though many\
    \ details are lost.  The very\n   interested reader can obtain those internet\
    \ drafts by requesting them\n   directly from me at <francis@cactus.ntt.jp>.\n\
    \   The remainder of this document is taken verbatim from the Pip draft\n   memo\
    \ of the same title that existed when the Pip project ended.  As\n   such, any\
    \ text that indicates that Pip is an intended replacement for\n   IP should be\
    \ ignored.\n"
- title: Abstract
  contents:
  - "Abstract\n   Pip is an internet protocol intended as the replacement for IP\n\
    \   version 4.  Pip is a general purpose internet protocol, designed to\n   evolve\
    \ to all forseeable internet protocol requirements.  This\n   specification describes\
    \ the routing and addressing architecture for\n   near-term Pip deployment.  We\
    \ say near-term only because Pip is\n   designed with evolution in mind, so other\
    \ architectures are expected\n   in the future.  This document, however, makes\
    \ no reference to such\n   future architectures.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Pip Architecture Overview ...................................\
    \    4\n   1.1 Pip Architecture Characteristics ...........................  \
    \  4\n   1.2 Components of the Pip Architecture .........................    5\n\
    \   2. A Simple Example ............................................    6\n  \
    \ 3. Pip Overview ................................................    7\n   4.\
    \ Pip Addressing ..............................................    9\n   4.1 Hierarchical\
    \ Pip Addressing ................................    9\n   4.1.1 Assignment of\
    \ (Hierarchical) Pip Addresses ...............   12\n   4.1.2 Host Addressing\
    \ ..........................................   14\n   4.2 CBT Style Multicast\
    \ Addresses ..............................   15\n   4.3 Class D Style Multicast\
    \ Addresses ..........................   16\n   4.4 Anycast Addressing .........................................\
    \   16\n   5. Pip IDs .....................................................  \
    \ 17\n   6. Use of DNS ..................................................   18\n\
    \   6.1 Information Held by DNS ....................................   19\n  \
    \ 6.2 Authoritative Queries in DNS ...............................   20\n   7.\
    \ Type-of-Service (TOS) (or lack thereof) .....................   21\n   8. Routing\
    \ on (Hierarchical) Pip Addresses .....................   22\n   8.1 Exiting a\
    \ Private Domain ...................................   23\n   8.2 Intra-domain\
    \ Networking ....................................   24\n   9. Pip Header Server\
    \ ...........................................   25\n   9.1 Forming Pip Headers\
    \ ........................................   25\n   9.2 Pip Header Protocol (PHP)\
    \ ..................................   27\n   9.3 Application Interface ......................................\
    \   27\n   10. Routing Algorithms in Pip ..................................  \
    \ 28\n   10.1 Routing Information Filtering .............................   29\n\
    \   11. Transition .................................................   30\n  \
    \ 11.1 Justification for Pip Transition Scheme ...................   31\n   11.2\
    \ Architecture for Pip Transition Scheme ....................   31\n   11.3 Translation\
    \ between Pip and IP packets ....................   33\n   11.4 Translating between\
    \ PCMP and ICMP .........................   34\n   11.5 Translating between IP\
    \ and Pip Routing Information ........   34\n   11.6 Old TCP and Application Binaries\
    \ in Pip Hosts .............   34\n   11.7 Translating between Pip Capable and\
    \ non-Pip Capable DNS\n        Servers ...................................................\
    \   35\n   12. Pip Address and ID Auto-configuration ......................  \
    \ 37\n   12.1 Pip Address Prefix Administration .........................   37\n\
    \   12.2 Host Autoconfiguration ....................................   38\n  \
    \ 12.2.1 Host Initial Pip ID Creation ............................   38\n   12.2.2\
    \ Host Pip Address Assignment .............................   39\n   12.2.3 Pip\
    \ ID and Domain Name Assignment .......................   39\n   13. Pip Control\
    \ Message Protocol (PCMP) ........................   40\n   14. Host Mobility\
    \ ..............................................   42\n   14.1 PCMP Mobile Host\
    \ message ..................................   43\n   14.2 Spoofing Pip IDs ..........................................\
    \   44\n   15. Public Data Network (PDN) Address Discovery ................  \
    \ 44\n   15.1 Notes on Carrying PDN Addresses in NSAPs ..................   46\n\
    \   16. Evolution with Pip .........................................   46\n  \
    \ 16.1 Handling Directive (HD) and Routing Context (RC) Evolution.   49\n   16.1.1\
    \ Options Evolution .......................................   50\n   References\
    \ .....................................................   51\n   Security Considerations\
    \ ........................................   51\n   Author's Address ...............................................\
    \   51\n"
- title: Introduction
  contents:
  - "Introduction\n   Pip is an internet protocol intended as the replacement for\
    \ IP\n   version 4.  Pip is a general purpose internet protocol, designed to\n\
    \   handle all forseeable internet protocol requirements.  This\n   specification\
    \ describes the routing and addressing architecture for\n   near-term Pip deployment.\
    \  We say near-term only because Pip is\n   designed with evolution in mind, so\
    \ other architectures are expected\n   in the future.  This document, however,\
    \ makes no reference to such\n   future architectures (except in that it discusses\
    \ Pip evolution in\n   general).\n   This document gives an overall picture of\
    \ how Pip operates.  It is\n   provided primarily as a framework within which\
    \ to understand the\n   total set of documents that comprise Pip.\n"
- title: 1.  Pip Architecture Overview
  contents:
  - "1.  Pip Architecture Overview\n   The Pip near-term architecture is an incremental\
    \ step from IP.  Like\n   IP, near-term Pip is datagram.  Pip runs under TCP and\
    \ UDP.  DNS is\n   used in the same fashion it is now used to distribute name\
    \ to Pip\n   Address (and ID) mappings.  Routing in the near-term Pip architecture\n\
    \   is hop-by-hop, though it is possible for a host to create a domain-\n   level\
    \ source route (for policy reasons).\n   Pip Addresses have more hierarchy than\
    \ IP, thus improving scaling on\n   one hand, but introducing additional addressing\
    \ complexities, such as\n   multiple addresses, on the other.  Pip, however, uses\
    \ hierarchical\n   addresses to advantage by making them provider-based, and using\
    \ them\n   to make policy routing (in this case, provider selection) choices.\n\
    \   Pip also provides mechanisms for automatically assigning provider\n   prefixes\
    \ to hosts and routers in domains.  This is the main\n   difference between the\
    \ Pip near-term architecture and the IP\n   architecture.  (Note that in the remainder\
    \ of this paper, unless\n   otherwise stated, the phrase \"Pip architecture\"\
    \ refers to the near-\n   term Pip architecture described herein.)\n"
- title: 2.  Pip Architecture Characteristics
  contents:
  - "2.  Pip Architecture Characteristics\n   The proposed architecture for near-term\
    \ Pip has the following\n   characteristics:\n   1.  Provider-rooted hierarchical\
    \ addresses.\n   2.  Automatic domain-wide address prefix assignment.\n   3. \
    \ Automatic host address and ID assignment.\n   4.  Exit provider selection.\n\
    \   5.  Multiple defaults routing (default routing, but to multiple exit\n   \
    \    points).\n   6.  Equivalent of IP Class D style addressing for multicast.\n\
    \   7.  CBT style multicast.\n   8.  \"Anycast\" addressing (route to one of a\
    \ group, usually the\n       nearest).\n   9.  Providers support forwarding on\
    \ policy routes (but initially will\n       not provide the support for sources\
    \ to calculate policy routes).\n   10.  Mobile hosts.\n   11.  Support for routing\
    \ across large Public Data Networks (PDN).\n   12.  Inter-operation with IP hosts\
    \ (but, only within an IP-address\n        domain where IP addresses are unique).\
    \  In particular, an IP\n        address can be explicitly carried in a Pip header.\n\
    \   13.  Operation with existing transport and application binaries\n        (though\
    \ if the application contains IP context, like FTP, it may\n        only work\
    \ within a domain where IP addresses are unique).\n   14.  Mechanisms for evolving\
    \ Pip beyond the near-term architecture.\n"
- title: 1.2 Components of the Pip Architecture
  contents:
  - "1.2 Components of the Pip Architecture\n   The Pip Architecture consists of the\
    \ following five systems:\n   1.  Host (source and sink of Pip packets)\n   2.\
    \  Router (forwards Pip packets)\n   3.  DNS\n   4.  Pip/IP Translator\n   5.\
    \  Pip Header Server (formats Pip headers)\n   The first three systems exist in\
    \ the IP architecture, and require no\n   explanation here.  The fourth system,\
    \ the Pip/IP Translator, is\n   required solely for the purpose of inter-operating\
    \ with current IP\n   systems.  All Pip routers are also Pip/IP translators.\n\
    \   The fifth system, the Pip Header Server, is new.  Its function is to\n   format\
    \ Pip headers on behalf of the source host (though initially\n   hosts will be\
    \ able to do this themselves).  This use of the Pip\n   Header Server will increase\
    \ as policy routing becomes more\n   sophisticated (moves beyond near-term Pip\
    \ Architecture capabilities).\n   To handle future evolution, a Pip Header Server\
    \ can be used to\n   \"spoon-feed\" Pip headers to old hosts that have not been\
    \ updated to\n   understand new uses of Pip.  This way, the probability that the\n\
    \   internet can evolve without changing all hosts is increased.\n"
- title: 2.  A Simple Example
  contents:
  - "2.  A Simple Example\n   A typical Pip \"exchange\" is as follows: An application\
    \ initiates an\n   exchange with another host as identified by a domain name.\
    \  A request\n   for one or more Pip Headers, containing the domain name of the\n\
    \   destination host, goes to the Pip Header Server.  The Pip Header\n   Server\
    \ generates a DNS request, and receive back a Pip ID, multiple\n   Pip Addresses,\
    \ and possibly other information such as a mobile host\n   server or a PDN address.\
    \  Given this information, plus information\n   about the source host (its Pip\
    \ Addresses, for instance), plus\n   optionally policy information, plus optionally\
    \ topology information,\n   the Pip Header Server formats an ordered list of valid\
    \ Pip headers\n   and give these to the host.  (Note that if the Pip Header Server\
    \ is\n   co-resident with the host, as will be common initially, the host\n  \
    \ behavior is similar to that of an IP host in that a DNS request comes\n   from\
    \ the host, and the host forms a Pip header based on the answer\n   from DNS.)\n\
    \   The source host then begins to transmit Pip packets to the\n   destination\
    \ host.  If the destination host is an IP host, then the\n   Pip packet is translated\
    \ into an IP packet along the way.  Assuming\n   that the destination host is\
    \ a Pip host, however, the destination\n   host uses the destination Pip ID alone\
    \ to determine if the packet is\n   destined for it.  The destination host generates\
    \ a return Pip header\n   based either on information in the received Pip header,\
    \ or the\n   destination host uses the Pip ID of the source host to query the\
    \ Pip\n   Header Server/DNS itself.  The latter case involves more overhead,\n\
    \   but allows a more informed decision about how to return packets to\n   the\
    \ originating host.\n   If either host is mobile, and moves to a new location,\
    \ thus getting a\n   new Pip Address, it informs the other host of its new address\n\
    \   directly.  Since host identification is based on the Pip ID and not\n   the\
    \ Pip Address, this doesn't cause transport level to fail.  If both\n   hosts\
    \ are mobile and receive new Pip Addresses at the same time (and\n   thus cannot\
    \ exchange packets at all), then they can query each\n   other's respective mobile\
    \ host servers (learned from DNS).  Note that\n   keeping track of host mobility\
    \ is completely confined to hosts.\n   Routers never get involved in tracking\
    \ mobile hosts (though naturally\n   they are involved in host discovery and automatic\
    \ host address\n   assignment).\n"
- title: 3.  Pip Overview
  contents:
  - "3.  Pip Overview\n   Here, a brief overview of the Pip protocol is given.  The\
    \ reader is\n   encouraged to read [2] for a complete description.\n   The Pip\
    \ header is divided into three parts:\n      Initial Part\n      Transit Part\n\
    \      Options Part\n   The Initial Part contains the following fields:\n    \
    \  Version Number\n      Options Offset, OP Contents, Options Present (OP)\n \
    \     Packet SubID\n      Protocol\n      Dest ID\n      Source ID\n      Payload\
    \ Length\n      Host Version\n      Payload Offset\n      Hop Count\n   All of\
    \ the fields in the Initial Part are of fixed length.  The\n   Initial Part is\
    \ 8 32-bit words in length.\n   The Version Number places Pip as a subsequent\
    \ version of IP.  The\n   Options Offset, OP Contents, and Options Present (OP)\
    \ fields tell how\n   to process the options.  The Options Offset tells where\
    \ the options\n   are The OP tells which of up to 8 options are in the options\
    \ part, so\n   that the Pip system can efficiently ignore options that don't pertain\n\
    \   to it.  The OP Contents is like a version number for the OP field.\n   It\
    \ allows for different sets of the (up to 8) options.\n   The Packet SubID is\
    \ used to relate a received PCMP message to a\n   previously sent Pip packet.\
    \  This is necessary because, since routers\n   in Pip can tag packets, the packet\
    \ returned to a host in a PCMP\n   message may not be the same as the packet sent.\
    \  The Payload Length\n   and Protocol take the place of IP's Total Length and\
    \ Protocol fields\n   respectively.  The Dest ID identifies the destination host,\
    \ and is\n   not used for routing, except for where the final router on a LAN\
    \ uses\n   ARP to find the physical address of the host identified by the dest\n\
    \   ID.  The Source ID identifies the source of the packet.  The Host\n   Version\
    \ tells what control algorithms the host has implemented, so\n   that routers\
    \ can respond to hosts appropriately.  This is an\n   evolution mechanism.  The\
    \ Hop Count is similar to IP's Time-to-Live.\n   The Transit Part contains the\
    \ following fields:\n      Transit Part Offset\n      HD Contents\n      Handling\
    \ Directive (HD)\n      Active FTIF\n      RC Contents\n      Routing Context\
    \ (RC)\n      FTIF Chain (FTIF = Forwarding Table Index Field)\n   Except for\
    \ the FTIF Chain, which can have a variable number of 16-bit\n   FTIF fields,\
    \ the fields in the Transit Part are of fixed length, and\n   are three 32-bit\
    \ words in length.\n   The Transit Part Offset gives the length of the Transit\
    \ Part.  This\n   is used to determine the location of the subsequent Transit\
    \ Part (in\n   the case of Transit Part encapsulation).\n   The Handling Directive\
    \ (HD) is a set of subfields, each of which\n   indicates a specific handling\
    \ action that must be executed on the\n   packet.  Handling directives have no\
    \ influence on routing.  The HD\n   Contents field indicates what subfields are\
    \ in the Handling\n   Directive.  This allows the definition of the set of handling\n\
    \   directives to evolve over time.  Example handling directives are\n   queueing\
    \ priority, congestion experienced bit, drop priority, and so\n   on.\n   The\
    \ remaining fields comprise the Routing Directive.  This is where\n   the routing\
    \ decision gets made.  The basic algorithm is that the\n   router uses the Routing\
    \ Context to choose one of multiple forwarding\n   tables.  The Active FTIF indicates\
    \ which of the FTIFs to retrieve,\n   which is then used as an index into the\
    \ forwarding table, which\n   either instructs the router to look at the next\
    \ FTIF, or returns the\n   forwarding information.\n   Examples of Routing Context\
    \ uses are; to distinguish address families\n   (multicast vs. unicast), to indicate\
    \ which level of the hierarchy a\n   packet is being routed at, and to indicate\
    \ a Type of Service.  In the\n   near-term architecture, the FTIF Chain is used\
    \ to carry source and\n   destination hierarchical unicast addresses, policy route\
    \ fragments,\n   multicast addresses (all-of-group), and anycast (one-of-group)\n\
    \   addresses.  Like the OP Contents and HD Contents fields, the RC\n   Contents\
    \ field indicates what subfields are in the Routing Context.\n   This allows the\
    \ definition of the Routing Context to evolve over\n   time.\n   The Options Part\
    \ contains the options.  The options are preceded by\n   an array of 8 fields\
    \ that gives the offset of each of up to 8\n   options.  Thus, a particular option\
    \ can be found without a serial\n   search of the list of options.\n"
- title: 4.  Pip Addressing
  contents:
  - "4.  Pip Addressing\n   Addressing is the core of any internet architecture. \
    \ Pip Addresses\n   are carried in the Routing Directive (RD) of the Pip header\
    \ (except\n   for the Pip ID, which in certain circumstances functions as part\
    \ of\n   the Pip Address).  Pip Addresses are used only for routing packets.\n\
    \   They do not identify the source and destination of a Pip packet.  The\n  \
    \ Pip ID does this.  Here we describe and justify the Pip Addressing\n   types.\n\
    \   There are four Pip Address types [11].  The hierarchical Pip Address\n   (referred\
    \ to simply as the Pip Address) is used for scalable unicast\n   and for the unicast\
    \ part of a CBT-style multicast and anycast.  The\n   multicast part of a CBT-style\
    \ multicast is the second Pip address\n   type.  The third Pip address type is\
    \ class-D style multicast.  The\n   fourth type of Pip address is the so-called\
    \ \"anycast\" address.  This\n   address causes the packet to be forwarded to\
    \ one of a class of\n   destinations (such as, to the nearest DNS server).\n \
    \  Bits 0 and 1 of the RC defined by RC Contents value of 1 (that is,\n   for\
    \ the near-term Pip architecture) indicate which of four address\n   families\
    \ the FTIFs and Dest ID apply to.  The values are:\n      Value      Address Family\n\
    \      -----      --------------\n       00        Hierarchical Unicast Pip Address\n\
    \       01        Class D Style Multicast Address\n       10        CBT Style\
    \ Multicast Address\n       11        Anycast Pip Address\n   The remaining bits\
    \ are defined differently for different address\n   families, and are defined\
    \ in the following sections.\n"
- title: 4.1  Hierarchical Pip Addressing
  contents:
  - "4.1  Hierarchical Pip Addressing\n   The primary purpose of a hierarchical address\
    \ is to allow better\n   scaling of routing information, though Pip also uses\
    \ the \"path\"\n   information latent in hierarchical addresses for making provider\n\
    \   selection (policy routing) decisions.\n   The Pip Header encodes addresses\
    \ as a series of separate numbers, one\n   number for each level of hierarchy.\
    \  This can be contrasted to\n   traditional packet encodings of addresses, which\
    \ places the entire\n   address into one field.  Because of Pip's encoding, it\
    \ is not\n   necessary to specify a format for a Pip Address as it is with\n \
    \  traditional addresses (for instance, the SIP address is formatted\n   such\
    \ that the first so-many bits are the country/metro code, the next\n   so-many\
    \ bits are the site/subscriber, and so on).  Pip's encoding\n   also eliminates\
    \ the \"cornering in\" effect of running out of space in\n   one part of the hierarchy\
    \ even though there is plenty of room in\n   another.  No \"field sizing\" decisions\
    \ need be made at all with Pip\n   Addresses.  This makes address assignment easier\
    \ and more flexible\n   than with traditional addresses.\n   Pip Addresses are\
    \ carried in DNS as a series of numbers, usually with\n   each number representing\
    \ a layer of the hierarchy [1], but optionally\n   with the initial number(s)\
    \ representing a \"route fragment\" (the tail\n   end of a policy route--a source\
    \ route whose elements are providers).\n   The route fragments would be used,\
    \ for instance, when the destination\n   network's directly attached (local access)\
    \ provider is only giving\n   access to other (long distance) providers, but the\
    \ important\n   provider-selection policy decision has to do the long distance\n\
    \   providers.\n   The RC for (hierarchical) Pip Addresses is defined as:\n  \
    \    bits       meaning\n      ----       -------\n      0,1        Pip Address\
    \ (= 00)\n      2,3        level\n      4,5        metalevel\n      6        \
    \  exit routing type\n   The level and metalevel subfields are used to indicate\
    \ what level of\n   the hierarchy the packet is currently at (see section 8).\
    \  The exit\n   routing type subfield is used to indicate whether host-driven\
    \ (hosts\n   decide exit provider) or router-driven (routers decide exit provider)\n\
    \   exit routing is in effect (see section 8.1).\n   Each FTIF in the FTIF Chain\
    \ is 16 bits in length.  The low-order part\n   of each FTIF in a (hierarchical\
    \ unicast) Pip Address indicates the\n   relationship of the FTIF with the next\
    \ FTIF.  The three relators are\n   Vertical, Horizontal, and Extension.  The\
    \ Vertical and Horizontal\n   relators indicate if the subsequent FTIF is hierarchically\
    \ above or\n   below (Vertical) or hierarchically unrelated (Horizontal).  The\n\
    \   Extension relator is used to encode FTIF values longer than 16 bits.\n   FTIF\
    \ values 0 - 31 are reserved for special purposes.  That is, they\n   cannot be\
    \ assigned to normal hierarchical elements.  FTIF value 1 is\n   defined as a\
    \ flag to indicate a switch from the unicast phase of\n   packet forwarding to\
    \ the anycast phase of packet forwarding.\n   Note that Pip Addresses do not need\
    \ to be seen by protocol layers\n   above Pip (though layers above Pip can provide\
    \ a Pip Address if\n   desired).  Transport and above use the Pip ID to identify\
    \ the source\n   and destination of a Pip packet.  The Pip layer is able to map\
    \ the\n   Pip IDs (and other information received from the layer above, such as\n\
    \   QOS) into Pip Addresses.\n   The Pip ID can serve as the lowest level of a\
    \ Pip Address.  While\n   this \"bends the principal\" of separating Pip Addressing\
    \ from Pip\n   Identification, it greatly simplifies dynamic host address\n  \
    \ assignment.  The Pip ID also serves as a multicast ID.  Unless\n   otherwise\
    \ stated, the term \"Pip Address\" refers to just the part in\n   the Routing\
    \ Directive (that is, excludes the Pip ID).\n   Pip Addresses are provider-rooted\
    \ (as opposed to geographical).  That\n   is, the top-level of a Pip Address indicates\
    \ a network service\n   provider (even when the service provided is not Pip).\
    \  (A\n   justification of using provider-rooted rather than geographical\n  \
    \ addresses is given in [12].)\n   Thus, the basic form of a Pip address is:\n\
    \         providerPart,subscriberPart\n   where both the providerPart and subscriberPart\
    \ can have multiple\n   layers of hierarchy internally.\n   A subscriber may be\
    \ attached to multiple providers.  In this case, a\n   host can end up with multiple\
    \ Pip Addresses by virtue of having\n   multiple providerParts:\n         providerPart1,subscriberPart\n\
    \         providerPart2,subscriberPart\n         providerPart3,subscriberPart\n\
    \   This applies to the case where the subscriber network spans many\n   different\
    \ provider areas, for instance, a global corporate network.\n   In this case,\
    \ some hosts in the global corporate network will have\n   certain providerParts,\
    \ and other hosts will have others.  The\n   subscriberPart should be assigned\
    \ such that routing can successfully\n   take place without a providerPart in\
    \ the destination Pip Address of\n   the Pip Routing Directive (see section 8.2).\n\
    \   Note that, while there are three providerParts shown, there is only\n   one\
    \ subscriberPart.  Internal subscriber numbering should be\n   independent of\
    \ the providerPart.  Indeed, with the Pip architecture,\n   it is possible to\
    \ address internal packets without including any of\n   the providerPart of the\
    \ address.\n   Top-level Pip numbers can be assigned to subscriber networks as\
    \ well\n   as to providers.\n         privatePart,subscriberPart\n   In this case,\
    \ however, the top-level number (privatePart) would not\n   be advertised globally.\
    \  The purpose of such an assignment is to give\n   a private network \"ownership\"\
    \ of a globally unique Pip Address space.\n   Note that the privatePart is assigned\
    \ as an extended FTIF (that is,\n   from numbers greater than 2^15).  Because\
    \ the privatePart is not\n   advertised globally, and because internal packets\
    \ do not need the\n   prefix (above the subscriberPart), the privatePart actually\
    \ never\n   appears in a Pip packet header.\n   Pip Addresses can be prepended\
    \ with a route fragment.  That is, one\n   or more Pip numbers that are all at\
    \ the top of the hierarchy.\n         longDistanceProvider.localAccessProvider.subscriber\n\
    \             (top-level)          (top-level)     (next level)\n   This is useful,\
    \ for instance, when the subscriber's directly attached\n   provider is a \"local\
    \ access\" provider, and is not advertised\n   globally.  In this case, the \"\
    long distance\" provider is prepended to\n   the address even though the local\
    \ access provider number is enough to\n   provide global uniqueness.\n   Note\
    \ that no coordination is required between the long distance and\n   local access\
    \ providers to form this address.  The subscriber with a\n   prefix assigned to\
    \ it by the local access provider can autonomously\n   form and use this address.\
    \  It is only necessary that the long\n   distance provider know how to route\
    \ to the local access provider.\n"
- title: 4.1.1  Assignment of (Hierarchical) Pip Addresses
  contents:
  - "4.1.1  Assignment of (Hierarchical) Pip Addresses\n   Administratively, Pip Addresses\
    \ are assigned as follows [3].  There\n   is a root Pip Address assignment authority.\
    \  Likely choices for this\n   are IANA or ISOC.  The root authority assigns top-level\
    \ Pip Address\n   numbers.  (A \"Pip Address number\" is the number at a single\
    \ level of\n   the Pip Address hierarchy.  A Pip Address prefix is a series of\n\
    \   contiguous Pip Address numbers, starting at the top level but not\n   including\
    \ the entire Pip Address.  Thus, the top-level prefix is the\n   same thing as\
    \ the top-level number.)\n   Though by-and-large, and most importantly, top-level\
    \ assignments are\n   made to providers, each country is given an assignment,\
    \ each existing\n   address space (such as E.164, X.121, IP, etc.) is given an\n\
    \   assignment, and private networks can be given assignments.  Thus,\n   existing\
    \ addresses can be grandfathered in.  Even if the top-level\n   Pip address number\
    \ is an administrative rather than topological\n   assignment, the routing algorithm\
    \ still advertises providers at the\n   top (provider) level of routing.  That\
    \ is, routing will advertise\n   enough levels of hierarchy that providers know\
    \ how to route to each\n   other.\n   There must be some means of validating top-level\
    \ number requests from\n   providers (basically, those numbers less than 2^15).\
    \  That is, top-\n   level assignments must be made only to true providers.  While\n\
    \   designing the best way to do this is outside the scope of this\n   document,\
    \ it seems off hand that a reasonable approach is to charge\n   for the top-level\
    \ prefixes.  The charge should be enough to\n   discourage non-serious requests\
    \ for prefixes, but not so much that it\n   becomes an inhibitor to entry in the\
    \ market.  The charge might\n   include a yearly \"rent\", and top-level prefixes\
    \ could be reclaimed\n   when they are no longer used by the provider.  Any profit\
    \ made from\n   this activity could be used to support the overall role of number\n\
    \   assignment.  Since roughly 32,000 top-level assignments can be made\n   before\
    \ having to increase the FTIF size in the Pip header from 16\n   bits to 32 bits,\
    \ it is envisioned that top-level prefixes will not be\n   viewed as a scarce\
    \ resource.\n   After a provider obtains a top-level prefix, it becomes an assignment\n\
    \   authority with respect to that particular prefix.  The provider has\n   complete\
    \ control over assignments at the next level down (the level\n   below the top-level).\
    \  The provider may either assign top-level minus\n   one prefixes to subscribers,\
    \ or preferably use that level to provide\n   hierarchy within the provider's\
    \ network (for instance, in the case\n   where the provider has so many subscribers\
    \ that keeping routing\n   information on all of them creates a scaling problem).\
    \  It is\n   envisioned that the subscriber will have complete control over number\n\
    \   assignments made at levels below that of the prefix assigned it by\n   the\
    \ provider.\n   Assigning top level prefixes directly to providers leaves the\
    \ number\n   of top-level assignments open-ended, resulting in the possibility\
    \ of\n   scaling problems at the top level.  While it is expected that the\n \
    \  number of providers will remain relatively small (say less than 10000\n   globally),\
    \ this can't be guaranteed.  If there are more providers\n   than top-level routing\
    \ can handle, it is likely that many of these\n   providers will be \"local access\"\
    \ providers--providers whose role is\n   to give a subscriber access to multiple\
    \ \"long-distance\" providers.\n   In this case, the local access providers need\
    \ not appear at the top\n   level of routing, thus mitigating the scaling problem\
    \ at that level.\n   In the worst case, if there are too many top-level \"long-distance\"\
    \n   providers for top-level routing to handle, a layer of hierarchy above\n \
    \  the top-level can be created.  This layer should probably conform to\n   some\
    \ policy criteria (as opposed to a geographical criteria).  For\n   instance,\
    \ backbones with similar access restrictions or type-of-\n   service can be hierarchically\
    \ clustered.  Clustering according to\n   policy criteria rather than geographical\
    \ allows the choice of address\n   to remain an effective policy routing mechanism.\
    \  Of course, adding a\n   layer of hierarchy to the top requires that all systems,\
    \ over time,\n   obtain a new providerPart prefix.  Since Pip has automatic prefix\n\
    \   assignment, and since DNS hides addresses from users, this is not a\n   debilitating\
    \ problem.\n"
- title: 4.1.2  Host Addressing
  contents:
  - "4.1.2  Host Addressing\n   Hosts can have multiple Pip Addresses.  Since Pip\
    \ Addresses are\n   topologically significant, a host has multiple Pip Addresses\
    \ because\n   it exists in multiple places topologically.  For instance, a host\
    \ can\n   have multiple Pip addresses because it can be reached via multiple\n\
    \   providers, or because it has multiple physical interfaces.  The\n   address\
    \ used to reach the host influences the path to the host.\n   Locally, Pip Addressing\
    \ is similar to IP Addressing.  That is, Pip\n   prefixes are assigned to subnetworks\
    \ (where the term subnetwork here\n   is meant in the OSI sense.  That is, it\
    \ denotes a network operating\n   at a lower layer than the Pip layer, for instance,\
    \ a LAN).  Thus, it\n   is not necessary to advertise individual hosts in routing\
    \ updates--\n   routers only need to advertise and store routes to subnetworks.\n\
    \   Unlike IP, however, a single subnetwork can have multiple prefixes.\n   (Strictly\
    \ speaking, in IP a single subnetwork can have multiple\n   prefixes, but a host\
    \ may not be able to recognize that it can reach\n   another host on the same\
    \ subnetwork but with a different prefix\n   without going through a router.)\n\
    \   There are two styles of local Pip Addressing--one where the Pip\n   Address\
    \ denotes the host, and another where the Pip Address denotes\n   only the destination\
    \ subnetwork.  The latter style is called ID-\n   tailed Pip Addressing.  With\
    \ ID-tailed Pip Addresses, the Pip ID is\n   used by the last router to forward\
    \ the packet to the host.  It is\n   expected that ID-tailed Pip Addressing is\
    \ the most common, because it\n   greatly eases address administration.\n   (Note\
    \ that the Pip Routing Directive can be used to route a Pip\n   packet internal\
    \ to a host.  For instance, the RD can be used to\n   direct a packet to a device\
    \ in a host, or even a certain memory\n   location.  The use of the RD for this\
    \ purpose is not part of this\n   near-term Pip architecture.  We note, however,\
    \ that this use of the\n   RD could be locally done without effecting any other\
    \ Pip systems.)\n   When a router receives a Pip packet and determines that the\
    \ packet is\n   destined for a host on one of its' attached subnetworks (by examining\n\
    \   the appropriate FTIF), it then examines the destination Pip ID (which\n  \
    \ is in a fixed position) and forwards based on that.  If it does not\n   know\
    \ the subnetwork address of the host, then it ARPs, using the Pip\n   ID as the\
    \ \"address\" in the ARP query.\n"
- title: 4.2  CBT Style Multicast Addresses
  contents:
  - "4.2  CBT Style Multicast Addresses\n   When bits 1 and 0 of the RC defined by\
    \ RC Contents = 1 are set to 10,\n   the FTIF and Dest ID indicate CBT (Core Based\
    \ Tree) style multicast.\n   The remainder of the bits are defined as follows:\n\
    \      bits       meaning\n      ----       -------\n      0,1        CBT Multicast\
    \ (= 10)\n      2,3        level\n      4,5        metalevel\n      6        \
    \  exit routing type\n      7          on-tree bit\n      8,9        scoping\n\
    \   With CBT (Core-based Tree) multicast, there is a single multicast\n   tree\
    \ connecting the members (recipients) of the multicast group (as\n   opposed to\
    \ Class-D style multicast, where there is a tree per\n   source).  The tree emanates\
    \ from a single \"core\" router.  To transmit\n   to the group, a packet is routed\
    \ to the core using unicast routing.\n   Once the packet reaches a router on the\
    \ tree, it is multicast using a\n   group ID.\n   Thus, the FTIF Chain for CBT\
    \ multicast contains the (Unicast)\n   Hierarchical Pip Address of the core router.\
    \ The Dest ID field\n   contains the group ID.\n   A Pip CBT packet, then, has\
    \ two phases of forwarding, a unicast phase\n   and a multicast phase.  The \"\
    on-tree\" bit of the RC indicates which\n   phase the packet is in.  While in\
    \ the unicast phase, the on-tree bit\n   is set to 0, and the packet is forwarded\
    \ similarly to Pip Addresses.\n   During this phase, the scoping bits are ignored.\n\
    \   Once the packet reaches the multicast tree, it switches to multicast\n   routing\
    \ by changing the on-tree bit to 1 and using the Dest ID group\n   address for\
    \ forwarding.  During this phase, bits 2-6 are ignored.\n"
- title: 4.3  Class D Style Multicast Addresses
  contents:
  - "4.3  Class D Style Multicast Addresses\n   When bits 1 and 0 of the RC defined\
    \ by RC Contents = 1 are set to 01,\n   the FTIF and Dest ID indicate Class D\
    \ style multicast.  The remainder\n   of the RC is defined as:\n      bits   \
    \    meaning\n      ----       -------\n      0,1        Class D Style Multicast\
    \ (= 01)\n      2-5        Scoping\n   By \"class D\" style multicast, we mean\
    \ multicast using the algorithms\n   developed for use with Class D addresses\
    \ in IP (class D addresses are\n   not used per se).  This style of routing uses\
    \ both source and\n   destination information to route the packet (source host\
    \ address and\n   destination multicast group).\n   For Pip, the FTIF Chain holds\
    \ the source Pip Address, in order of\n   most significant hierarchy level first.\
    \  The reason for putting the\n   source Pip Address rather than the Source ID\
    \ in the FTIF Chain is\n   that use of the source Pip Address allows the multicast\
    \ routing to\n   take advantage of the hierarchical source address, as is being\
    \ done\n   with IP.  The Dest ID field holds the multicast group.  The Routing\n\
    \   Context indicates Class-D style multicast.  All routers must first\n   look\
    \ at the FTIF Chain and Dest ID field to route the packet on the\n   tree.\n \
    \  Bits 2 through 5 of the RC are the scoping bits.\n"
- title: 4.4  Anycast Addressing
  contents:
  - "4.4  Anycast Addressing\n   When bits 1 and 0 of the RC defined by RC Contents\
    \ = 1 are set to 11,\n   the FTIF and Dest ID indicate Anycast addressing.  The\
    \ remainder of\n   the RC is defined as:\n      bits       meaning\n      ----\
    \       -------\n      0,1        Anycast Address (= 11)\n      2,3        level\n\
    \      4,5        metalevel\n      6          exit routing type\n      7     \
    \     anycast active\n      8,9        scoping\n   With anycast routing, the packet\
    \ is unicast, but to the nearest of a\n   group of destinations.  This type of\
    \ routing is used by Pip for\n   autoconfiguration.  Other applications, such\
    \ as discovery protocols,\n   may also use anycast routing.\n   Like CBT, Pip\
    \ anycast has two phases of operation, in this case the\n   unicast phase and\
    \ the anycast phase.  The unicast phase is for the\n   purpose of getting the\
    \ packet into a certain vicinity.  The anycast\n   phase is to forward the packet\
    \ to the nearest of a group of\n   destinations in that vicinity.\n   Thus, the\
    \ RC has both unicast and anycast information in it.  During\n   the unicast phase,\
    \ the anycast active bit is set to 0, and the packet\n   is forwarded according\
    \ to the rules of Pip Addressing.  The scoping\n   bits are ignored.\n   The switch\
    \ from the unicast phase to the anycast phase is triggered\n   by the presence\
    \ of an FTIF of value 1 in the FTIF Chain.  When this\n   FTIF is reached, the\
    \ anycast active bit is set to 1, the scoping bits\n   take effect, and bits 2\
    \ through 6 are ignored.  When in the anycast\n   phase, forwarding is based on\
    \ the Dest ID field.\n"
- title: 5.  Pip IDs
  contents:
  - "5.  Pip IDs\n   The Pip ID is 64-bits in length [4].\n   The basic role of the\
    \ Pip ID is to identify the source and\n   destination host of a Pip Packet. \
    \ (The other role of the Pip ID is\n   for allowing a router to find the destination\
    \ host on the destination\n   subnetwork.)\n   This having been said, it is possible\
    \ for the Pip ID to ultimately\n   identify something in addition to the host.\
    \  For instance, the Pip ID\n   could identify a user or a process.  For this\
    \ to work, however, the\n   Pip ID has to be bound to the host, so that as far\
    \ as the Pip layer\n   is concerned, the ID is that of the host.  Any additional\
    \ use of the\n   Pip ID is outside the scope of this Pip architecture.\n   The\
    \ Pip ID is treated as flat.  When a host receives a Pip packet, it\n   compares\
    \ the destination Pip ID in the Pip header with its' own.  If\n   there is a complete\
    \ match, then the packet has reached the correct\n   destination, and is sent\
    \ to the higher layer protocol.  If there is\n   not a complete match, then the\
    \ packet is discarded, and a PCMP\n   Invalid Address packet is returned to the\
    \ originator of the packet\n   [7].\n   It is something of an open issue as to\
    \ whether or not Pip IDs should\n   contain significant organizational hierarchy\
    \ information.  Such\n   information could be used for inverse DNS lookups and\
    \ allowing a Pip\n   packet to be associated with an organization.  (Note that\
    \ the use of\n   the Pip ID alone for this purpose can be easily spoofed.  By\
    \ cross\n   checking the Pip ID with the Pip Address prefix, spoofing is harder-\n\
    \   -as hard as it is with IP--but still easy.  Section 14.2 discusses\n   methods\
    \ for making spoofing harder still, without requiring\n   encryption.)\n   However,\
    \ relying on organizational information in the Pip header\n   generally complicates\
    \ ID assignment.  This complication has several\n   ramifications.  It makes host\
    \ autoconfiguration of hosts harder,\n   because hosts then have to obtain an\
    \ assignment from some database\n   somewhere (versus creating one locally from\
    \ an IEEE 802 address, for\n   instance).  It means that a host has to get a new\
    \ assignment if it\n   changes organizations.  It is not clear what the ramifications\
    \ of\n   this might be in the case of a mobile host moving through different\n\
    \   organizations.\n   Because of these difficulties, the use of flat Pip IDs\
    \ is currently\n   favored.\n   Blocks of Pip ID numbers have been reserved for\
    \ existing numbering\n   spaces, such as IP, IEEE 802, and E.164.  Pip ID numbers\
    \ have been\n   assigned for such special purposes such as \"any host\", \"any\
    \ router\",\n   \"all hosts on a subnetwork\", \"all routers on a subnetwork\"\
    , and so\n   on.  Finally, 32-bit blocks of Pip ID numbers have been reserved\
    \ for\n   each country, according to ISO 3166 country code assignments.\n"
- title: 6.  Use of DNS
  contents:
  - "6.  Use of DNS\n   The Pip near-term architecture uses DNS in roughly the same\
    \ style\n   that it is currently used.  In particular, the Pip architecture\n\
    \   maintains the two fundamental DNS characteristics of 1) information\n   stored\
    \ in DNS does not change often, and 2) the information returned\n   by DNS is\
    \ independent of who requested it.\n   While the fundamental use of DNS remains\
    \ roughly the same, Pip's use\n   of DNS differs from IP's use by degrees.  First,\
    \ Pip relies on DNS to\n   hold more types of information than IP [1].  Second,\
    \ Pip Addresses in\n   DNS are expected to change more often than IP addresses,\
    \ due to\n   reassignment of Pip Address prefixes (the providerPart).  To still\n\
    \   allow aggressive caching of DNS records in the face of more quickly\n   changing\
    \ addressing, Pip has a mechanism of indicating to hosts when\n   an address is\
    \ no longer assigned.  This triggers an authoritative\n   query, which overrides\
    \ DNS caches.  The mechanism consists of PCMP\n   Packet Not Delivered messages\
    \ that indicate explicitly that the Pip\n   Address is invalid.\n   In what follows,\
    \ we first discuss the information contained in DNS,\n   and then discuss authoritative\
    \ queries.\n"
- title: 6.1  Information Held by DNS
  contents:
  - "6.1  Information Held by DNS\n   The information contained in DNS for the Pip\
    \ architecture is:\n   1.  The Pip ID.\n   2.  Multiple Pip Addresses\n   3. \
    \ The destination's mobile host address servers.\n   4.  The Public Data Network\
    \ (PDN) addresses through which the\n       destination can be reached.\n   5.\
    \  The Pip/IP Translators through which the destination (if the\n       destination\
    \ is IP-only) can be reached.\n   6.  Information about the providers represented\
    \ by the destination's\n       Pip addresses.  This information includes provider\
    \ name, the type\n       of provider network (such as SMDS, ATM, or SIP), and\
    \ access\n       restrictions on the provider's network.\n   The Pip ID and Addresses\
    \ are the basic units of information required\n   for carriage of a Pip packet.\n\
    \   The mobile host address server tells where to send queries for the\n   current\
    \ address of a mobile Pip host. Note that usually the current\n   address of the\
    \ mobile host is conveyed by the mobile host itself,\n   thus a mobile host server\
    \ query is not usually required.\n   The PDN address is used by the entry router\
    \ of a PDN to learn the PDN\n   address of the next hop router.  The entry router\
    \ obtains the PDN\n   address via an option in the Pip packet.  If there are multiple\
    \ PDNs\n   associated with a given Pip Address, then there can be multiple PDN\n\
    \   addresses carried in the option.  Note that the option is not sent on\n  \
    \ every packet, and that only the PDN entry router need examine the\n   option.\n\
    \   The Pip/IP translator information is used to know how to translate an\n  \
    \ IP address into a Pip Address so that the packet can be carried\n   across the\
    \ Pip infrastructure.  If the originating host is IP, then\n   the first IP/Pip\
    \ translator reached by the IP packet must query DNS\n   for this information.\n\
    \   The information about the destination's providers is used to help the\n  \
    \ \"source\" (either the source host or a Pip Header Server near the\n   source\
    \ host) format an appropriate Pip header with regards to\n   choosing a Pip Address\
    \ [14].  The choice of one of multiple Pip\n   Addresses is essentially a policy\
    \ routing choice.\n   More detailed descriptions of the use of the information\
    \ carried in\n   DNS is contained in the relevant sections.\n"
- title: 6.2 Authoritative Queries in DNS
  contents:
  - "6.2 Authoritative Queries in DNS\n   In general, Pip treats addresses as more\
    \ dynamic entities than does\n   IP.  One example of this is how Pip Address prefixes\
    \ change when a\n   subscriber network attaches to a new provider.  Pip also carries\
    \ more\n   information in DNS, any of which can change for various reasons.\n\
    \   Thus, the information in DNS is more dynamic with Pip than with IP.\n   Because\
    \ of the increased reliance on DNS, there is a danger of\n   increasing the load\
    \ on DNS.  This would be particularly true if the\n   means of increasing DNS'\
    \ dynamicity is by shortening the cache\n   holding time by decreasing the DNS\
    \ Time-to-Live (TTL).  To counteract\n   this trend, Pip provides explicit network\
    \ layer (Pip layer) feedback\n   on the correctness of address information.  This\
    \ allows Pip hosts to\n   selectively over-ride cached DNS information by making\
    \ an\n   authoritative query.  Through this mechanism, we actually hope to\n \
    \  increase the cache holding time of DNS, thus improving DNS' scaling\n   characteristics\
    \ overall.\n   The network layer feedback is in the form of a type of PCMP Packet\n\
    \   Not Delivered (PDN) message that indicates that the address used is\n   known\
    \ to be out-of-date.  Routers can be configured with this\n   information, or\
    \ it can be provided through the routing algorithm\n   (when an address is decommissioned,\
    \ the routing algorithm can\n   indicate that this is the reason that it has become\
    \ unreachable, as\n   opposed to becoming \"temporarily\" unreachable through\
    \ equipment\n   failure).\n   Pip hosts consider destination addresses to be in\
    \ one of four states:\n   1.  Unknown, but assumed to be valid.\n   2.  Reachable\
    \ (and therefore valid).\n   3.  Unreachable and known to be invalid.\n   4. \
    \ Unreachable, but weakly assumed to be valid.\n   The first state exists before\
    \ a host has attempted communication with\n   another host.  In this state, the\
    \ host queries DNS as normal (that\n   is, does not make an authoritative query).\n\
    \   The second state is reached when a host has successfully communicated\n  \
    \ with another host.  Once a host has reached this state, it can stay\n   in it\
    \ for an arbitrarily long time, including after the DNS TTL has\n   expired. \
    \ When in this state, there is no need to query DNS.\n   A host enters the third\
    \ state after a failed attempt at communicating\n   with another host where the\
    \ PCMP PND message indicates explicitly\n   that the address is known to be invalid.\
    \  In this case, the host\n   makes an authoritative query to DNS whether or not\
    \ the TTL has\n   expired.  It is this case that allows lengthy caching of DNS\n\
    \   information while still allowing addresses to be reassigned\n   frequently.\n\
    \   A host enters the fourth state after a failed attempt at\n   communicating\
    \ with another host, but where the address is not\n   explicitly known to be invalid.\
    \  In this state, the host weakly\n   assumes that the address of the destination\
    \ is still valid, and so\n   can requery DNS with a normal (non-authoritative)\
    \ query.\n"
- title: 7.  Type-of-Service (TOS) (or lack thereof)
  contents:
  - "7.  Type-of-Service (TOS) (or lack thereof)\n   One year ago it probably would\
    \ have been adequate to define a handful\n   (4 or 5) of priority levels to drive\
    \ a simple priority FIFO queue.\n   With the advent of real-time services over\
    \ the Internet, however,\n   this is no longer sufficient.  Real-time traffic\
    \ cannot be handled on\n   the same footing as non-real-time.  In particular,\
    \ real-time traffic\n   must be subject to access control so that excess real-time\
    \ traffic\n   does not swamp a link (to the detriment of other real-time and non-\n\
    \   real-time traffic alike).\n   Given that a consensus solution to real- and\
    \ non-real-time traffic\n   management in the internet does not exist, this version\
    \ of the Pip\n   near-term architecture does not specify any classes of service\
    \ (and\n   related queueing mechanisms).  It is expected that Pip will define\n\
    \   classes of service (primarily for use in the Handling Directive) as\n   solutions\
    \ become available.\n"
- title: 8.  Routing on (Hierarchical) Pip Addresses
  contents:
  - "8.  Routing on (Hierarchical) Pip Addresses\n   Pip forwarding in a single router\
    \ is done based on one or a small\n   number of FTIFs.  What this means with respect\
    \ to hierarchical Pip\n   Addresses is that a Pip router is able to forward a\
    \ packet based on\n   examining only part of the Pip Address--often a single level.\n\
    \   One advantage to encoding each level of the Pip Address separately is\n  \
    \ that it makes handling of addresses, for instance address assignment\n   or\
    \ managing multiple addresses, easier.  Another advantage is address\n   lookup\
    \ speed--the entire address does not have to be examined to\n   forward a packet\
    \ (as is necessary, for instance, with traditional\n   hierarchical address encoding).\
    \  The cost of this, however, is\n   additional complexity in keeping track of\
    \ the active hierarchical\n   level in the Pip header.\n   Since Pip Addresses\
    \ allow reuse of numbers at each level of the\n   hierarchy, it is necessary for\
    \ a Pip router to know which level of\n   the hierarchy it is acting at when it\
    \ retrieves an FTIF.  This is\n   done in part with a hierarchy level indicator\
    \ in the Routing Context\n   (RC) field.  RC level is numbered from the top of\
    \ the hierarchy down.\n   Therefore, the top of the hierarchy is RC level = 0,\
    \ the next level\n   down is RC level = 1, and so on.\n   The RC level alone,\
    \ however, is not adequate to keep track of the\n   appropriate level in all cases.\
    \  This is because different parts of\n   the hierarchy may have different numbers\
    \ of levels, and elements of\n   the hierarchy (such as a domain or an area) may\
    \ exist in multiple\n   parts of the hierarchy.  Thus, a hierarchy element can\
    \ be, say, level\n   3 under one of its parents and level 2 under another.\n \
    \  To resolve this ambiguity, the topological hierarchy is superimposed\n   with\
    \ another set of levels--metalevels [11].  A metalevel boundary\n   exists wherever\
    \ a hierarchy element has multiple parents with\n   different numbers of levels,\
    \ or may with reasonable probability have\n   multiple parents with different\
    \ numbers of levels in the future.\n   Thus, a metalevel boundary exists between\
    \ a subscriber network and\n   its provider.  (Note that in general the metalevel\
    \ represents a\n   significant administrative boundary between two levels of the\n\
    \   topological hierarchy.  It is because of this administrative boundary\n  \
    \ that the child is likely to have multiple parents.) Lower metalevels\n   may\
    \ exist, but usually will not.\n   The RC, then, contains a level and a metalevel\
    \ indicator.  The level\n   indicates the number of levels from the top of the\
    \ next higher\n   metalevel.  The top of the global hierarchy is metalevel 0,\
    \ level 0.\n   The next level down (for instance, the level that provides a level\
    \ of\n   hierarchy within a provider) is metalevel 0, level 1.  The first\n  \
    \ level of hierarchy under a provider is metalevel 1, level 0, and so\n   on.\n\
    \   To determine the RC level and RC metalevel in a transmitted Pip\n   packet,\
    \ a host (or Pip Header Server) must know where the metalevels\n   are in its\
    \ own Pip Addresses.\n   The host compares its source Pip Address with the destination\
    \ Pip\n   Address.  The highest Pip Address component that is different between\n\
    \   the two addresses determines the level and metalevel.  (No levels\n   higher\
    \ than this level need be encoded in the Routing Directive.)\n   Neighbor routers\
    \ are configured to know if there is a level or\n   metalevel boundary between\
    \ them, so that they can modify the RC level\n   and RC metalevel in a transmitted\
    \ packet appropriately.\n"
- title: 8.1  Exiting a Private Domain
  contents:
  - "8.1  Exiting a Private Domain\n   The near-term Pip Architecture provides two\
    \ methods of exit routing,\n   that is, routing inter-domain Pip packets from\
    \ a source host to a\n   network service provider of a private domain [12,15].\
    \  In the first\n   method, called transit-driven exit routing, the source host\
    \ leaves\n   the choice of provider to the routers.  In the second method, called\n\
    \   host-driven exit routing, the source host explicitly chooses the\n   provider.\
    \  In either method, it is possible to prevent internal\n   routers from having\
    \ to carry external routing information.  The exit\n   routing bit of the RC indicates\
    \ which type of exit routing is in\n   effect.\n   With host-driven exit routing,\
    \ it is possible for the host to choose\n   a provider through which the destination\
    \ cannot be reached.  In this\n   case, the host receives the appropriate PCMP\
    \ Packet Not Delivered\n   message, and may either fallback on transit-driven\
    \ exit routing or\n   choose a different provider.\n   When using transit-driven\
    \ exit routing, there are two modes of\n   operation.  The first, called destination-oriented,\
    \ is used when the\n   routers internal to a domain have external routing information,\
    \ and\n   the host has only one provider prefix.  The second, called provider-\n\
    \   oriented, is used when the routers internal to a domain do not have\n   any\
    \ external routing information or when the host has multiple\n   provider prefixes.\
    \  (With IP, this case is called default routing.\n   In the case of IP, however,\
    \ default routing does not allow an\n   intelligent choice of multiple exit points.)\n\
    \   With provider-oriented exit routing, the host arbitrarily chooses a\n   source\
    \ Pip Address (and therefore, a provider).  (Note that if the\n   Pip Header Server\
    \ is tracking inter-domain routing, then it chooses\n   the appropriate provider.)\
    \ If the host chooses the wrong provider,\n   then the border router will redirect\
    \ the host to the correct provider\n   with a PCMP Provider Redirect message.\n"
- title: 8.2  Intra-domain Networking
  contents:
  - "8.2  Intra-domain Networking\n   With intra-domain networking (where both source\
    \ and destination are\n   in the private network), there are two scenarios of\
    \ concern.  In the\n   first, the destination address shares a providerPart with\
    \ the source\n   address, and so the destination is known to be intra-domain even\n\
    \   before a packet is sent.  In the second, the destination address does\n  \
    \ not share a providerPart with the source address, and so the source\n   host\
    \ doesn't know that the destination is reachable intra-domain.\n   Note that the\
    \ first case is the most common, because the private\n   top-level number assignment\
    \ acts as the common prefix even though it\n   isn't advertised globally (see\
    \ section 4.1).\n   In the first case, the Pip Addresses in the Routing Directive\
    \ need\n   not contain the providerPart.  Rather, it contains only the address\n\
    \   part below the metalevel boundary.  (A Pip Address in an FTIF Chain\n   always\
    \ starts at a metalevel boundary).\n   For instance, if the source Pip Address\
    \ is 1.2.3,4.5.6 and the\n   destination Pip Address is 1.2.3,4.7.8, then only\
    \ 4.7.8 need be\n   included for the destination address in the Routing Directive.\
    \  (The\n   comma \",\" in the address indicates the metalevel boundary between\n\
    \   providerPart and subscriberPart.) The metalevel and level are set\n   accordingly.\n\
    \   In the second case, it is desirable to use the Pip Header Server to\n   determine\
    \ if the destination is intra-domain or inter-domain.  The\n   Pip Header Server\
    \ can do this by monitoring intra-domain routing.\n   (This is done by having\
    \ the Pip Header Server run the intra-domain\n   routing algorithm, but not advertise\
    \ any destinations.) Thus, the Pip\n   Header Server can determine if the providerPart\
    \ can be eliminated\n   from the address, as described in the last paragraph,\
    \ or cannot and\n   must conform to the rules of exit routing as described in\
    \ the\n   previous section.\n   If the Pip Header Server does not monitor intra-domain\
    \ routing,\n   however, then the following actions occur.  In the case of host-\n\
    \   driven exit routing, the packet will be routed to the stated\n   provider,\
    \ and an external path will be used to reach an internal\n   destination.  (The\
    \ moral here is to not use host-driven exit routing\n   unless the Pip Header\
    \ Server is privy to routing information, both\n   internal and external.)\n \
    \  In the case of transit-driven exit routing, the packet sent by the\n   host\
    \ will eventually reach a router that knows that the destination\n   is intra-domain.\
    \  This router will forward the packet towards the\n   destination, and at the\
    \ same time send a PCMP Reformat Transit Part\n   message to the host.  This message\
    \ tells the host how much of the Pip\n   Address is needed to route the packet.\n"
- title: 9.  Pip Header Server
  contents:
  - "9.  Pip Header Server\n   Two new components of the Pip Architecture are the\
    \ Pip/IP Translator\n   and the Pip Header Server.  The Pip/IP Translator is only\
    \ used for\n   transition from IP to Pip, and otherwise would not be necessary.\
    \  The\n   Pip Header Server, however, is a new architectural component.\n   The\
    \ purpose of the Pip Header Server is to form a Pip Header.  It is\n   useful\
    \ to form the Pip header in a separate box because 1) in the\n   future (as policy\
    \ routing matures, for instance), significant amounts\n   of information may be\
    \ needed to form the Pip header--too much\n   information to distribute to all\
    \ hosts, and 2) it won't be possible\n   to evolve all hosts at the same time,\
    \ so the existence of a separate\n   box that can spoon-feed Pip headers to old\
    \ hosts is necessary.  (It\n   is impossible to guarantee that no modification\
    \ of Pip hosts is\n   necessary for any potential evolution, but being able to\
    \ form the\n   header in a server, and hand it to an outdated host, is a large\
    \ step\n   in the right direction.)\n   (Note that policy routing architectures\
    \ commonly if not universally\n   require the use of some kind of \"route server\"\
    \ for calculating policy\n   routes.  The Pip Header Server is, among other things,\
    \ just this\n   server.  Thus, the Pip Header Server does not so much result from\
    \ the\n   fact that Pip itself is more complex than IP or other \"IPv7\"\n   proposals.\
    \  Rather, the Pip Header Server reflects the fact that the\n   Pip Architecture\
    \ has more functionality than ROAD architectures\n   supported by the simpler\
    \ proposals.)\n   We note that for the near-term architecture hosts themselves\
    \ will\n   by-and-large have the capability of forming Pip headers.  The\n   exception\
    \ to this will be the case where the Pip Header Server wishes\n   to monitor inter-domain\
    \ routing to enhance provider selection.  Thus,\n   the Pip Header Server role\
    \ will be largely limited to evolution (see\n   section 16).\n"
- title: 9.1  Forming Pip Headers
  contents:
  - "9.1  Forming Pip Headers\n   Forming a Pip header is more complex than forming\
    \ an IP header\n   because there are many more choices to make.  At a minimum,\
    \ one of\n   multiple Pip Addresses (both source and destination) must be chosen\n\
    \   [14].  In the near future, it will also be necessary to choose a TOS.\n  \
    \ After DNS information about the destination has been received, the\n   the following\
    \ information is available to the Pip header formation\n   function.\n   1.  From\
    \ DNS: The destination's providers (either directly connected\n       or nearby\
    \ enough to justify making a policy decision about), and\n       the names, types,\
    \ and access restrictions of those providers.\n   2.  From the source host: The\
    \ application type (and thus, the desired\n       service), and the user access\
    \ restriction classes.\n   3.  From local configuration: The source's providers,\
    \ and the names,\n       types, and access restrictions of those providers.\n\
    \   4.  Optionally from inter-domain routing: The routes chosen by\n       inter-domain\
    \ to all top level providers.  (Note that inter-domain\n       routing in the\
    \ Pip near-term architecture is path-vector.\n       Because of this, the Pip\
    \ Header Server does not obtain enough\n       information from inter-domain routing\
    \ to form a policy route.\n       When the technology to do this matures, it can\
    \ be installed into\n       Pip Header Servers.)\n       The inter-domain routing\
    \ information is optional.  If it is used,\n       then probably a Pip Header\
    \ Server is necessary, to limit this\n       information to a small number of\
    \ systems.\n   There may also be arbitrary policy information available to the\
    \ Pip\n   header formation function.  This architecture does not specify any\n\
    \   such information.\n   The Pip header formation function then goes through\
    \ a process of\n   forming an ordered list of source/destination Pip Addresses\
    \ to use.\n   The ordering is based on knowledge of the application service\n\
    \   requirements, the service provided by the source providers, guesses\n   or\
    \ learned information about the service provided by the destination\n   providers\
    \ or by source/destination provider pairs, and the cost of\n   using source providers\
    \ to reach destination providers.  It is assumed\n   that the sophistication of\
    \ forming the ordered list will grow as\n   experienced is gained with internet\
    \ commercialization and real-time\n   services.\n   The Pip Header formation function\
    \ then returns the ordered pairs of\n   source and destination addresses to the\
    \ source host in the PHP\n   response message, along with an indication of what\
    \ kind of exit\n   routing to use with each pair.  Any additional information,\
    \ such as\n   PDN Address, is also returned.  With this information, the source\n\
    \   host can now establish communications and properly respond to PCMP\n   messages.\
    \  Based on information received from PCMP messages,\n   particularly PCMP Packet\
    \ Not Delivered messages but also Mobile Host\n   messages, the host is able to\
    \ choose appropriately from the ordered\n   list.\n   Note that if Pip evolves\
    \ to the point where the Transit Part of the\n   Pip header is no longer compatible\
    \ with the current Transit Part, and\n   the querying host has not been updated\
    \ to understand the new Transit\n   Part, then the PHP response message contains\
    \ a bit map of the Transit\n   Part.  The host puts this bit map into the Transit\
    \ Part of the\n   transmitted Pip header even though it does not understand the\n\
    \   semantics of the Transit Part.  The Host Version field indicates to\n   the\
    \ Pip Header Server what kinds of transit parts the host can\n   understand.\n"
- title: 9.2  Pip Header Protocol (PHP)
  contents:
  - "9.2  Pip Header Protocol (PHP)\n   The Pip Header Protocol (PHP) is a simple\
    \ query/response protocol\n   used to exchange information between the Pip host\
    \ and the Pip Header\n   Server [6].  In the query, the Pip host includes (among\
    \ other things)\n   the domain name of the destination it wishes to send Pip packets\
    \ to.\n   (Thus, the PHP query serves as a substitute for the DNS query.)\n  \
    \ The PHP query also contains 1) User Access Restriction Classes, 2)\n   Application\
    \ Types, and 3) host version.  The host version tells the\n   Pip Header Server\
    \ what features are installed in the host.  Thus, the\n   Pip Header Server is\
    \ able to determine if the host can format its own\n   Pip header based on DNS\
    \ information, or whether the Pip Header Server\n   needs to do it on behalf of\
    \ the host.  In the future, the PHP query\n   will also contain desired TOS (possibly\
    \ in lieu of Application Type).\n   (Note that this information could come from\
    \ the application.  Thus,\n   the application interface to PHP (the equivalent\
    \ of gethostbyname())\n   must pass this information.)\n"
- title: 9.3  Application Interface
  contents:
  - "9.3  Application Interface\n   In order for a Pip host to generate the information\
    \ required in the\n   PHP query, there must be a way for the application to convey\
    \ the\n   information to the PHP software.  The host architecture for doing\n\
    \   this is as follows.\n   A local \"Pip Header Client\" (the source host analog\
    \ to the Pip Header\n   Server) is called by the application (instead of the current\n\
    \   gethostbyname()).  The application provides the Pip Header Client\n   with\
    \ either the destination host domain name or the destination host\n   Pip ID,\
    \ and other pertinent information such as user access\n   restriction class and\
    \ TOS.  The Pip Header Client, if it doesn't have\n   the information cached locally,\
    \ queries the Pip Header Server and\n   receives an answer.  (Remember that the\
    \ Pip Header Server can be co-\n   resident with the host.)\n   Once the Pip Header\
    \ Client has determined what the Pip header(s) are,\n   it assigns a local handle\
    \ to the headers, returns the handle to the\n   application, and configures the\
    \ Pip packet processing engine with the\n   handle and related Pip Headers.  The\
    \ application then issues packets\n   to the Pip layer (via intervening layers\
    \ such as transport) using the\n   local handle.\n"
- title: 10.  Routing Algorithms in Pip
  contents:
  - "10.  Routing Algorithms in Pip\n   This section discusses the routing algorithm\
    \ for use with\n   (hierarchical) Pip Addresses.\n   The architecture for operating\
    \ routing algorithms in Pip reflects the\n   clean partitioning of routing contexts\
    \ in the Pip header.  Thus,\n   routing in the Pip architecture is nicely modularized.\n\
    \   Within the Hierarchical Pip Address, there are multiple hierarchical\n   levels.\
    \  Wherever two routers connect, or two levels interface\n   (either in a single\
    \ router or between routers), two decisions must be\n   made:  1) what information\
    \ should be exchanged (that is, what of one\n   side's routing table should be\
    \ propagated to the other side), and 2)\n   what routing algorithm should be used\
    \ to exchange the information?\n   The first decision is discussed in section\
    \ 10.1 below (Routing\n   Information Filtering).  The latter decision is discussed\
    \ here.\n   Conceptually, and to a large extent in practice, the routing\n   algorithms\
    \ at each level are cleanly partitioned.  This partition is\n   much like the\
    \ partition between \"egp\" and \"igp\" level routing in IP,\n   but with Pip\
    \ it exists at each level of the hierarchy.\n   At the top-level of the Pip Address\
    \ hierarchy, a path-vector routing\n   algorithm is used.  Path-vector is more\
    \ appropriate at the top level\n   than link-state because path-vector does not\
    \ require agreement\n   between top-level entities (providers) on metrics in order\
    \ to be\n   loop-free.  (Agreement between the providers is likely to result in\n\
    \   better paths, but the Pip Architecture does not assume such\n   agreement.)\n\
    \   The top-level path-vector routing algorithm is based on IDRP, but\n   enhanced\
    \ to handle Pip addresses and Pip idiosyncrasies such as the\n   Routing Context.\
    \  At any level below the top level, it is a local\n   decision as to what routing\
    \ algorithm technology to run.  However,\n   the path-vector routing algorithm\
    \ is generalized so that it can run\n   at multiple levels of the Pip Address\
    \ hierarchy.  Thus, a lower level\n   domain can choose to take advantage of the\
    \ path-vector algorithm, or\n   run another, such as a link-state algorithm. \
    \ The modified version of\n   IDRP is called MLPV [10], for Multi-Level Path-Vector\
    \ (pronounced\n   \"milpiv\").\n   Normally, information is exchanged between\
    \ two separate routing\n   algorithms by virtue of the two algorithms co-existing\
    \ in the same\n   router.  For instance, a border router is likely to participate\
    \ in an\n   exchange of routing information with provider routers, and still run\n\
    \   the routing algorithm of the internal routers.  If the two algorithms\n  \
    \ are different routing technologies (for instance, link-state versus\n   distance-vector)\
    \ then internal conversion translates information from\n   one routing algorithm\
    \ to the form of the other.\n   In some cases, however, two routing algorithms\
    \ that exchange\n   information will exist in different routers, and will have\
    \ to\n   exchange information over a link.  If these two algorithms are\n   different\
    \ technologies, then they need a common means of exchanging\n   routing information.\
    \  While strictly speaking this is a local matter,\n   MLPV can also serve as\
    \ the interface between two disparate routing\n   algorithms.  Thus, all routers\
    \ should be able to run MLPV, if for no\n   other reason than to exchange information\
    \ with other, perhaps\n   proprietary, routing protocols.\n   MLPV is designed\
    \ to be extendible with regards to the type of routes\n   that it calculates.\
    \  It uses the Pip Object parameter identification\n   number space to identify\
    \ what type of route is being advertised and\n   calculated [9].  Thus, to add\
    \ new types of routes (for instance, new\n   types of service), it is only necessary\
    \ to configure the routers to\n   accept the new route type, define metrics for\
    \ that type, and criteria\n   for preferring one route of that type over another.\n"
- title: 10.1  Routing Information Filtering
  contents:
  - "10.1  Routing Information Filtering\n   Of course, the main point behind having\
    \ hierarchical routing is so\n   that information from one part of the hierarchy\
    \ can be reduced when\n   passed to another.  In general, reduction (in the form\
    \ of\n   aggregation) takes place when passing information from the bottom of\n\
    \   the hierarchy up.  However, Pip uses tunneling and exit routing to,\n   if\
    \ desired, allow information from the top to be reduced when it goes\n   down.\n\
    \   When two routers become neighbors, they can determine what\n   hierarchical\
    \ levels they have in common by comparing Pip Addresses.\n   For instance, if\
    \ two neighbor routers have Pip Addresses 1.2.3,4 and\n   1.2.8,9.14 respectively,\
    \ then they share levels 0 and 1, and are\n   different at levels below that.\
    \  (0 is the highest level, 1 is the\n   next highest, and so on.) As a general\
    \ rule, these two routers\n   exchange level 0, level 1, and level 2 routing information,\
    \ but not\n   level 3 or lower routing information.  In other words, both routers\n\
    \   know how to route to all things at the top level (level 0), how to\n   route\
    \ to all level 1 things with \"1\" as the level 0 prefix, and how\n   to route\
    \ to all level 2 things with \"1.2\" as the level 1 prefix.\n   In the absence\
    \ of other instructions, two routers will by default\n   exchange information\
    \ about all levels from the top down to the first\n   level at which they have\
    \ differing Pip Addresses.  In practice,\n   however, this default exchange is\
    \ as likely to be followed as not.\n   For instance, assume that 1.2.3,4 is a\
    \ provider router, and\n   1.2.8,9.14 is a subscriber router.  (Note that 1.2.8\
    \ is the prefix\n   given the subscriber by the provider, thus the metalevel boundary\n\
    \   indicated by the comma.) Assume also that the subscriber network is\n   using\
    \ destination-oriented transit-driven exit routing (see section\n   8.1).  Finally,\
    \ assume that router 1.2.8,9.14 is the subscriber's\n   only entry point into\
    \ provider 1 (other routers provide entry points\n   to other providers).\n  \
    \ In this case, 1.2.8,9.14 does not need to know about level 2 or level\n   1\
    \ areas in the provider (that is, it does not need to know about\n   1.2.4...,\
    \ 1.2.5..., or 1.3..., 1.4..., and so on).  Thus, 1.2.8,9.14\n   should be configured\
    \ to inform 1.2.3,4 that it does not need level 1\n   or 2 information.\n   As\
    \ another example, assume still that 1.2.3,4 is a provider and\n   1.2.8,9.14\
    \ is a subscriber.  However, assume now that the subscriber\n   network is using\
    \ host-driven exit routing.  In this case, the\n   subscriber does not even need\
    \ to know about level 0 information,\n   because all exit routing is directed\
    \ to the provider of choice, and\n   having level 0 information therefore does\
    \ not influence that choice.\n"
- title: 11.  Transition
  contents:
  - "11.  Transition\n   The transition scheme for Pip has two major components, 1)\n\
    \   translation, and 2) encapsulation.  Translation is required to map\n   the\
    \ Pip Address into the IP address and vice versa.  Encapsulation is\n   used for\
    \ one Pip router (or host) to exchange packets with another\n   Pip router (or\
    \ host) by tunneling through intermediate IP routers.\n   The Pip transition scheme\
    \ is basically a set of techniques that\n   allows existing IP \"stuff\" and Pip\
    \ to coexist, but within the\n   limitations of IP address depletion (though not\
    \ within the\n   limitations of IP scaling problems).  By this I mean that an\
    \ IP-only\n   host can only exchange packets with other hosts in a domain where\
    \ IP\n   numbers are unique.  Initially this domain includes all IP hosts, but\n\
    \   eventually will include only hosts within a private domain.  The IP\n   \"\
    stuff\" that can exist includes 1) whole IP domains, 2) individual IP\n   hosts,\
    \ 3) IP-oriented TCPs, and 4) IP-oriented applications.\n"
- title: 11.1  Justification for Pip Transition Scheme
  contents:
  - "11.1  Justification for Pip Transition Scheme\n   Note that all transition to\
    \ a bigger address require translation.  It\n   cannot be avoided.  The major\
    \ choices one must make when deciding on\n   a translation scheme are:\n   1.\
    \  Will we require a contiguous infrastructure consisting of the new\n       protocol,\
    \ or will we allow tunneling through whatever remains of\n       the existing\
    \ IP infrastructure at any point in time?\n   2.  Will we allow global connectivity\
    \ between IP machines after IP\n       addresses are no longer globally unique,\
    \ or not?  (In other words,\n       will we use a NAT scheme or not? [15])\n \
    \  Concerning question number 1; while it is desirable to move as\n   quickly\
    \ as possible to a contiguous Pip (or SIP or whatever)\n   infrastructure, especially\
    \ for purposes of improved scaling, it is\n   fantasy to think that the whole\
    \ infrastructure will cut over to Pip\n   quickly.  Furthermore, during the testing\
    \ stages of Pip, it is highly\n   desirable to be able to install Pip in any box\
    \ anywhere, and by\n   tunneling through IP, create a virtual Pip internet.  Thus,\
    \ it seems\n   that the only reasonable answer to question number 1 is to allow\n\
    \   tunneling.\n   Concerning question number 2; it is highly desirable to avoid\
    \ using a\n   NAT scheme.  A NAT (Network Address Translation) scheme is one\n\
    \   whereby any two IP hosts can communicate, even though IP addresses\n   are\
    \ not globally unique.  This is done by dynamically mapping non-\n   unique IP\
    \ addresses into unique ones in order to cross the\n   infrastructure.  NAT schemes\
    \ have the problems of increased\n   complexity to maintain the mappings, and\
    \ of translating IP addresses\n   that reside within application data structures\
    \ (such as the PORT\n   command in FTP).\n   This having been said, it is conceivable\
    \ that the new protocol will\n   not be far enough along when IP addresses are\
    \ no longer unique, and\n   therefore a NAT scheme becomes necessary.  It is possible\
    \ to employ a\n   NAT scheme at any time in the future without making it part\
    \ of the\n   intended transition scheme now.  Thus, we can plan for a NATless\n\
    \   transition now without preventing the potential use of NAT if it\n   becomes\
    \ necessary.\n"
- title: 11.2  Architecture for Pip Transition Scheme
  contents:
  - "11.2  Architecture for Pip Transition Scheme\n   The architecture for Pip Transition\
    \ is that of a Pip infrastructure\n   surrounded by IP-only \"systems\".  The\
    \ IP-only \"systems\" surrounding\n   Pip can be whole IP domains, individual\
    \ IP hosts, an old TCP in an\n   otherwise Pip host, or an old application running\
    \ on top of a Pip-\n   smart TCP.\n   The Pip infrastructure will initially get\
    \ its internal connectivity\n   by tunneling through IP.  Thus, any Pip box can\
    \ be installed\n   anywhere, and become part of the Pip infrastructure by configuration\n\
    \   over a \"virtual\" IP.  Of course, it is desirable that Pip boxes be\n   directly\
    \ connected to other Pip boxes, but very early on this is the\n   exception rather\
    \ than the rule.\n   Two neighbor Pip systems tunneling through IP simply view\
    \ IP as a\n   \"link layer\" protocol, and encapsulate Pip over IP just as they\
    \ would\n   encapsulate Pip over any other link layer protocol.  In particular,\n\
    \   the hop-count field of Pip is not copied into the Time-to-Live field\n   of\
    \ IP.  There is no automatic configuration of neighbor Pip systems\n   over IP.\
    \  Manual configuration (and careful \"virtual topology\"\n   engineering) is\
    \ required.  Note that ICMP messages from a IP router\n   in a tunnel is not translated\
    \ into a PCMP message and sent on.  ICMP\n   messages are sinked at the translating\
    \ router at the head of the\n   tunnel.  The information learned from such ICMP\
    \ messages, however,\n   may be used to determine unreachability of the other\
    \ end of the\n   tunnel, and may there result in PCMP message on later packets.\n\
    \   In the remainder of this section, we do not distinguish between a\n   virtual\
    \ Pip infrastructure on IP, and a pure Pip infrastructure.\n   Given the model\
    \ of a Pip infrastructure surrounded by IP, there are 5\n   possible packet paths:\n\
    \   1.  IP - IP\n   2.  IP - Pip - IP\n   3.  IP - Pip\n   4.  Pip - IP\n   5.\
    \  Pip - Pip\n   The first three paths involve packets that originate at IP-only\n\
    \   hosts.  In order for an IP host to talk to any other host (IP or\n   not),\
    \ the other host must be addressable within the context of the IP\n   host's 32-bit\
    \ IP address.  Initially, this \"IP-unique\" domain will\n   include all IP hosts.\
    \  When IP addresses become no longer unique, the\n   IP-unique domain will include\
    \ a subset of all hosts.  At a minimum,\n   this subset will include those hosts\
    \ in the IP-host's private domain.\n   However, it makes sense also to arrange\
    \ for the set of all \"public\"\n   hosts, basically anonymous ftp servers and\
    \ mail gateways, to be in\n   this subset.  In other words, a portion of IP address\
    \ space should be\n   set aside to remain globally unique, even though other parts\
    \ of the\n   address space are being reused.\n"
- title: 11.3  Translation between Pip and IP packets
  contents:
  - "11.3  Translation between Pip and IP packets\n   Paths 2 and 4 involve translation\
    \ from Pip to IP.  This translation\n   is straightforward, as all the information\
    \ needed to create the IP\n   addresses is in the Pip header.  In particular,\
    \ Pip IDs have an\n   encoding that allows them to contain an IP address (again,\
    \ one that\n   is unique within an IP-unique domain).  Whenever a packet path\n\
    \   involves an IP host on either end, both hosts must have IP addresses.\n  \
    \ Thus, translating from Pip to IP is just a matter of extracting the\n   IP addresses\
    \ from the Pip IDs and forming an IP header.\n   Translating from an IP header\
    \ to a Pip header is more difficult,\n   because the 32-bit IP address must be\
    \ \"translated\" into a 64-bit Pip\n   ID and a Pip Address.  There is no algorithm\
    \ for making this\n   translation.  A table mapping IP addresses (or, rather,\
    \ network\n   numbers) to Pip IDs and Pip Addresses is required.  Since such a\n\
    \   table must potentially map every IP address, we choose to use dynamic\n  \
    \ discovery and caching to maintain the table.  We choose also to use\n   DNS\
    \ as the means of discovering the mappings.\n   Thus, DNS contains records that\
    \ map IP address to Pip ID and Pip\n   Address.  In the case where the host represented\
    \ by the DNS record is\n   a Pip host (packet path 3), the Pip ID and Pip Address\
    \ are those of\n   the host.  In the case where the host represented by the DNS\
    \ record\n   is an IP-only host (packet paths 2 and 4), the Pip Address is that\
    \ of\n   the Pip/IP translating gateway that is used to reach the IP host.\n \
    \  Thus, an IP-only domain must at least be able to return Pip\n   information\
    \ in its DNS records (or, the parent DNS domain must be\n   able to do it on behalf\
    \ of the child).\n   With paths 2 and 3 (IP-Pip-IP and IP-Pip), the initial translating\n\
    \   gateway (IP to Pip) makes the DNS query.  It stores the IP packet\n   while\
    \ waiting for the answer.  The query is an inverse address (in-\n   addr) using\
    \ the destination IP address.  The translating gateway can\n   cache the record\
    \ for an arbitrarily long period, because if the\n   mapping ever becomes invalid,\
    \ a PCMP Invalid Address message flushes\n   the cache entry.\n   In the case\
    \ of path 4 (Pip-IP), however, the Pip Address of the\n   translating gateway\
    \ is returned directly to the source host--\n   piggybacked on the DNS record\
    \ that is normally returned.  Thus this\n   scheme incurs only a small incremental\
    \ cost over the normal DNS\n   query.\n"
- title: 11.4  Translating between PCMP and ICMP
  contents:
  - "11.4  Translating between PCMP and ICMP\n   The only ICMP/PCMP messages that\
    \ are translated are the Destination\n   Unreachable, Echo, and PTMU Exceeded\
    \ messages.  The portion of the\n   offending IP/Pip header that is attached to\
    \ the ICMP/PCMP message is\n   not translated.\n"
- title: 11.5  Translating between IP and Pip Routing Information
  contents:
  - "11.5  Translating between IP and Pip Routing Information\n   It is not necessary\
    \ to pass IP routing information into the Pip\n   infrastructure.  The mapping\
    \ of IP address to Pip Address in DNS\n   allows Pip to find the appropriate gateway\
    \ to IP in the context of\n   Pip addresses only.\n   It is impossible to pass\
    \ Pip routing information into IP routers,\n   since IP routers cannot understand\
    \ Pip addresses.  IP domains must\n   therefore use default routing to reach IP/Pip\
    \ translators.\n"
- title: 11.6  Old TCP and Application Binaries in Pip Hosts
  contents:
  - "11.6  Old TCP and Application Binaries in Pip Hosts\n   A Pip host can be expected\
    \ to have an old TCP above it for a long\n   time to come, and a new (Pip-smart)\
    \ TCP can be expected to have old\n   application binaries running over it for\
    \ a long time to come.  Thus,\n   we must have some way of insuring that the TCP\
    \ checksum is correctly\n   calculated in the event that one or both ends is running\
    \ Pip, and one\n   or both ends has an old TCP binary.  In addition, we must arrange\
    \ to\n   allow applications to interface with TCP using a 32-bit \"address\"\n\
    \   only, even though those 32 bits get locally translated into Pip\n   Addresses\
    \ and IDs.\n   As stated above, in all cases where a Pip host is talking to an\
    \ IP-\n   only host, the Pip host has a 32-bit IP address. This address is\n \
    \  embedded in the Pip ID such that it can be identified as an IP\n   address\
    \ from inspection of the Pip ID alone.\n   The TCP pseudo-header is calculated\
    \ using the Payload Length and\n   Protocol fields, and some or all of the Source\
    \ and Dest Pip IDs.  In\n   the case where both Source and Dest Pip IDs are IP-based,\
    \ only the\n   32-bit IP address is included in the pseudo-header checksum\n \
    \  calculation.  Otherwise, the full 64 bits are used.  (Note that using\n   the\
    \ full Payload Length and Protocol fields does not fail when old\n   TCP binaries\
    \ are being used, because the values for those fields must\n   be within the 16-bit\
    \ and 8-bit limits for TCP to correctly operate.)\n   The reason for only using\
    \ 32 bits of the Pip ID in the case of both\n   ends using an IP address is that\
    \ an old TCP will use only 32 bits of\n   some number to form the pseudo-header.\
    \  If the entire 64 bits of the\n   Pip ID were used, then there would be cases\
    \ where no 32-bit number\n   could be used to insure that the correct checksum\
    \ is calculated in\n   all cases.\n   Note that in the case of an old TCP on top\
    \ of Pip, \"Pip\" (actually, a\n   Pip daemon) must create a 32-bit number that\
    \ can both be used to 1)\n   allow the Pip layer to correctly associate a packet\
    \ from the TCP\n   layer with the right Pip header, and 2) cause the TCP layer\
    \ to\n   calculate the right checksum.  (This number is created when the\n   application\
    \ initiates a DNS query.  A Pip daemon intervenes in this\n   request, calculates\
    \ a 32 bit number that the application/TCP can use,\n   and informs the Pip layer\
    \ of the mapping between this 32 bit number\n   and the full Pip header.)\n  \
    \ When the destination host is an IP only host, then this 32-bit number\n   is\
    \ nothing more than the IP address.  When the destination host is a\n   Pip host,\
    \ then this 32-bit number is some number generated by Pip to\n   \"fool\" the\
    \ old TCP into generating the right checksum.  This 32-bit\n   number can normally\
    \ be the same as the lower 32 bits of the Pip ID.\n   However, it is possible\
    \ that two or more active TCP connections is\n   established to different hosts\
    \ whose Pip IDs have the same lower 32\n   bits.  In this case, the Pip layer\
    \ must generate a different 32-bit\n   number for each connection, but in such\
    \ a way that the sum of the two\n   16-bit components of the 32-bit numbers are\
    \ the same as the sum of\n   the two 16-bit components of the lower 32 bits of\
    \ the Pip IDs.\n   In the case where an old Application wants to open a socket\
    \ using an\n   IP address handed to it (by the user or hard-coded), and not using\
    \ a\n   domain name, then it must be assumed that this IP address is valid\n \
    \  within the IP-unique domain.  To form a Pip ID out of this 32-bit\n   number,\
    \ the host appends the high-order 24 bits of its own Pip ID,\n   plus the IP-address-identifier-byte\
    \ value, to the 32-bit IP address.\n"
- title: 11.7  Translating between Pip Capable and non-Pip Capable DNS Servers
  contents:
  - "11.7  Translating between Pip Capable and non-Pip Capable DNS Servers\n   In\
    \ addition to transitioning \"Pip-layer\" packets, it is necessary to\n   transition\
    \ DNS from non-Pip capable to Pip capable.  During\n   transition there will be\
    \ name servers in DNS that only understand IP\n   queries and those that understand\
    \ both Pip and IP queries.  This\n   means there must be a mechanism for Pip resolvers\
    \ to detect whether a\n   name server is Pip capable, and vice versa.  Also, a\
    \ name server, if\n   it provides recursive service, must be able to translate\
    \ Pip requests\n   to IP requests.  (Pip-capable means a name server understands\
    \ Pip and\n   existing IP queries.  It does not necessarily mean the name server\n\
    \   uses the Pip protocol to communicate.)\n   New resource records have been\
    \ defined to hold Pip identifiers and\n   addresses, and other information [1].\
    \  These resource records must be\n   queried using a new opcode in the DNS query\
    \ packet header.  Existing\n   resource records can be queried using both the\
    \ old and new header\n   formats.  Name servers that are not Pip-capable will\
    \ respond with a\n   format error to queries with the new opcode.  Thus, a resolver\
    \ can\n   determine dynamically whether a name server is Pip-capable, by\n   sending\
    \ it a Pip query and noting the response.  This only need be\n   done once, when\
    \ querying a server for the \"first\" time, and the\n   outcome can be cached\
    \ along with the name server's address.\n   Using a new opcode for making Pip\
    \ queries also helps name servers\n   determine whether a resolver is Pip-capable\
    \ (it is not always not\n   obvious from the type of query made since many queries\
    \ are common to\n   to IP and Pip).  Determining whether a resolver is Pip-capable\
    \ is\n   necessary when responding with address information that is not\n   explicitly\
    \ requested by the query.  An important example of this is\n   when a name server\
    \ makes a referral to another name server in a\n   response: if the request comes\
    \ from a Pip resolver, name server\n   addresses will be returned as Pip identifier/address\
    \ resource\n   records, otherwise the addresses will be returned as IP A resource\n\
    \   records.\n   Those servers that are Pip-capable and provide recursive service\
    \ must\n   translate Pip requests to IP requests when querying an IP name\n  \
    \ server.  For most queries, this will just mean modifying the opcode\n   value\
    \ in the query header to reflect an IP query, rather than a Pip\n   query.  (Most\
    \ queries are identical in IP and Pip.) Other queries,\n   notably the query for\
    \ Pip identifier/address information, must be\n   translated into its IP counterpart,\
    \ namely, an IP A query.  On\n   receipt of an answer from an IP name server,\
    \ a Pip name server must\n   translate the query header and question section back\
    \ to its original,\n   and format the answer appropriately.  Again, for most queries,\
    \ this\n   will be a trivial operation, but responses containing IP addresses,\n\
    \   either as a result of an explicit query or as additional information,\n  \
    \ must be formatted to appear as a valid Pip response.\n   Pip-capable name servers\
    \ that provide recursive name service should\n   also translate IP address requests\
    \ into Pip identifier/address\n   requests when querying a Pip-capable name server.\
    \  (A host's IP\n   address can be deduced from the host's Pip identifier.) This\
    \ enables\n   a Pip-capable name server to cache all relevant addressing\n   information\
    \ about a Pip host in the first address query concerning\n   the host.  Caching\
    \ partial information is undesirable since the name\n   server, using the current\
    \ DNS caching strategy, would return only the\n   cached information on a future\
    \ Pip request, and IP, rather than Pip,\n   would be used to communicate with\
    \ the destination host.\n"
- title: 12.  Pip Address and ID Auto-configuration
  contents:
  - "12.  Pip Address and ID Auto-configuration\n   One goal of Pip is to make networks\
    \ as easy to administer as\n   possible, especially with regards to hosts.  Certain\
    \ aspects of the\n   Pip architecture make administration easier.  For instance,\
    \ the ID\n   field provides a network layer \"anchor\" around which address changes\n\
    \   can be administered.\n   This section discusses three aspects of autoconfiguration;\
    \ 1)\n   domain-wide Pip Address prefix assignment, 2) host Pip Address\n   assignment,\
    \ and 3) host Pip ID assignment.\n"
- title: 12.1  Pip Address Prefix Administration
  contents:
  - "12.1  Pip Address Prefix Administration\n   A central premise behind the use\
    \ of provider-rooted hierarchical\n   addresses is that domain-wide address prefix\
    \ assignment and re-\n   assignment is straight-forward.  This section describes\
    \ that process.\n   Pip Address prefix administration limits required manual prefix\n\
    \   configuration to DNS and border routers.  This is the minimum\n   required\
    \ manual configuration possible, because both border routers\n   and DNS must\
    \ be configured with prefix information for other reasons.\n   DNS must be configured\
    \ with prefix information so that it can reply\n   to address queries.  DNS files\
    \ are structured so that the prefix is\n   administered in only one place (that\
    \ is, every host record does not\n   have to be changed to create a new prefix).\
    \  Border routers must be\n   configured with prefix information in order to advertise\
    \ exit routes\n   internally.\n   Note in particular that no internal (non-border)\
    \ routers or hosts\n   need ever be manually configured with any externally derived\n\
    \   addressing information.  All internal routers that are expected to\n   fall\
    \ under a common provider-prefix must, however, be configured with\n   a \"group\
    \ ID\" taken from the Pip ID space.  (This group ID is not a\n   multicast ID\
    \ per se.  Rather, it is an identifier that allows prefix\n   updates to be targetted\
    \ to a specific set of routers.)\n   Each border router is configured with the\
    \ following information.\n   1.  The type of exit routing for the domain.  This\
    \ tells the border\n       router whether or not it needs to advertise external\
    \ routes\n       internally.\n   2.  The address prefix of the providers that\
    \ the border is directly\n       connected to.  This prefix information includes\
    \ any metalevel\n       boundaries above the subscriber/provider metalevel boundary\n\
    \       (called simply the subscriber metalevel).\n   3.  Other information about\
    \ the provider (provider name, type, user\n       access restriction classes).\n\
    \   4.  A list of common-provider-prefix group IDs that should receive the\n \
    \      auto-configuration information. (The default is that only systems\n   \
    \    that share a group ID with the border router will receive the\n       information.)\n\
    \   This information is injected into the intra-domain routing algorithm.\n  \
    \ It is automatically spread to all routers indicated by the group ID\n   list.\
    \  This way, the default behavior is for the information to be\n   automatically\
    \ constrained to the border router's \"area\".\n   When a non-border router receives\
    \ this information, it 1) records the\n   route to the providers in its forwarding\
    \ table, and 2) advertises the\n   information to hosts in the router discovery\
    \ protocol [8].  Thus\n   hosts learn not only their complete address, but also\
    \ information on\n   how to do exit routing and on how to choose source addresses.\n"
- title: 12.2  Host Autoconfiguration
  contents:
  - "12.2  Host Autoconfiguration\n   There are three phases of host autoconfiguration:\n\
    \   1.  The host locally creates a flat unique Pip ID (probably globally\n   \
    \    unique but at least unique on the attached subnet).\n   2.  The host learns\
    \ its Pip Addresses.\n   3.  The host optionally obtains a hierarchical, organizationally\n\
    \       meaningful Pip ID and a domain name from a Pip ID/domain name\n      \
    \ assignment service.  This service updates DNS.\n   Item three is optional. \
    \ If Pip ID and domain name assignment\n   services are not installed, then the\
    \ host must obtain its domain name\n   and, if necessary, Pip ID, from static\
    \ configuration.  Each of the\n   three phases are described below.\n"
- title: 12.2.1  Host Initial Pip ID Creation
  contents:
  - "12.2.1  Host Initial Pip ID Creation\n   When a host boots, it can form an ID\
    \ based only on local information.\n   If the host has an IEEE 802 number, either\
    \ from an IEEE 802 interface\n   or from an internal identifier, then it can create\
    \ a globally unique\n   Pip ID from the IEEE 802 Pip ID type [4].  Otherwise,\
    \ the host can\n   create an ID from the IEEE 802 space using its subnet (link\
    \ layer)\n   address.  This latter ID is only guaranteed to be locally unique.\n"
- title: 12.2.2  Host Pip Address Assignment
  contents:
  - "12.2.2  Host Pip Address Assignment\n   Unless a host does not wish to use ID-tailed\
    \ Pip Addresses (see\n   section 4.1.2), host Pip Address assignment is trivial.\
    \  (The near-\n   term Pip Architecture doesn't specify a means for a host to\
    \ obtain a\n   non-ID-tailed Pip Address.) When a host attaches to a subnet, it\n\
    \   learns the Pip Address of the attached routers through router\n   discovery.\n\
    \   The host simply adopts these Pip Addresses as its own.  The Pip\n   Address\
    \ gets a packet to the host's subnet, and the host's Pip ID is\n   used to route\
    \ across the subnet.  When the routers advertise new\n   addresses (for instance,\
    \ because of a new provider), the host adopts\n   the new addresses.\n"
- title: 12.2.3  Pip ID and Domain Name Assignment
  contents:
  - "12.2.3  Pip ID and Domain Name Assignment\n   Once the host has obtained its\
    \ Pip Addresses and an at-least-\n   locally-unique Pip ID, it can exchange packets\
    \ with an ID/Domain Name\n   (ID/DN) assignment service.  If the host locally\
    \ created a globally\n   unique Pip ID (using an IEEE 802 number), and the organization\
    \ it\n   belongs to does not use organizationally structured Pip IDs (which\n\
    \   should normally be the case) then it only needs to obtain a domain\n   name.\
    \  The ID/DN assignment service is reachable at a well-known\n   anycast address\
    \ [4].  Thus, the host is able to start exchanging\n   packets with the ID/DN\
    \ assignment service without any additional\n   configuration.\n   If there is\
    \ no ID/DN assignment service available, then the host must\n   obtain it's organizational\
    \ ID or DNS name in a non-automatic way.  If\n   the ID/DN assignment service\
    \ is down, the host must temporarily\n   suffice with just a Pip ID and Address.\
    \  The host can periodically\n   try to reach the ID/DN assignment service.\n\
    \   The ID/DN assignment service must coordinate with DNS.  When the\n   ID/DN\
    \ assignment service creates a new ID or domain name to assign to\n   a new host,\
    \ it must know which IDs and domain names are available for\n   assignment.  It\
    \ must also update DNS with the new information.\n   The design of this service\
    \ is left for further study.\n"
- title: 13.  Pip Control Message Protocol (PCMP)
  contents:
  - "13.  Pip Control Message Protocol (PCMP)\n   The Pip analog to ICMP is PCMP [7].\
    \  The near-term Pip architecture\n   defines the following PCMP messages:\n \
    \  1.  Local Redirect\n   2.  Packet Not Delivered\n   3.  Echo\n   4.  Parameter\
    \ Problem\n   5.  Router Discovery\n   6.  PMTU Exceeded\n   7.  Provider Redirect\n\
    \   8.  Reformat Transit Part\n   9.  Unknown Parameter\n   10. Host Mobility\n\
    \   11. Exit PDN Address\n   The Local Redirect, Echo, and Parameter Problem PCMP\
    \ messages operate\n   almost identically to their ICMP counterparts.\n   The\
    \ Packet Not Delivered PCMP message serves the role of ICMP's\n   Destination\
    \ Unreachable.  The Packet Not Delivered, has two major\n   differences.  First,\
    \ it is more general in that it indicates the\n   hierarchy level of unreachability\
    \ (rather than explicit host, subnet,\n   network unreachability as with IP).\
    \  Second, it indicates when an\n   address is known to be invalid, thus allowing\
    \ for more intelligent\n   use of DNS (see section 6.2).\n   The Router Discovery\
    \ PCMP message operates as ICMP's, with the\n   exception that a host derives\
    \ its Pip Address from it.\n   The PMTU Exceeded message operates as ICMP's, with\
    \ the exception that\n   the Pip header size of the offending Packet is also given.\
    \  This\n   allows the source host transport to determine how much smaller the\n\
    \   packet PMTU should be from the advertised subnet PMTU.  Note that if\n   an\
    \ occasional option, such as the PDN Address option, needs to be\n   attached\
    \ to one of many packets, and that this option makes the\n   packet larger than\
    \ the PMTU, then it is not necessary to modify the\n   MTU coming from transport.\
    \  Instead, that packet can be fragmented by\n   the host's Pip forwarding engine.\
    \  (Pip specifies\n   fragmentation/reassembly for hosts but not for routers.\
    \  The\n   fragmentation information is in a Pip Option.)\n   The Provider Redirect,\
    \ Invalid Address, Reformat Transit Part,\n   Unknown Parameter, Host Mobility,\
    \ and Exit PDN Address PCMP messages\n   are new.\n   The Provider Redirect PCMP\
    \ message is used to inform the source host\n   of a preferable exit provider\
    \ to use when provider-rooted, transit-\n   driven exit routing is used (see section\
    \ 8.1).\n   The Invalid Address PCMP message is used to inform the source host\n\
    \   that none of the IDs of the destination host match that of the Pip\n   packet.\
    \  The purpose of this message is to allow for authoritative\n   DNS requests\
    \ (see section 6.2).\n   The Reformat Transit Part PCMP message has both near-term\
    \ Pip\n   architecture functions and evolution functions.  Near-term, the\n  \
    \ Reformat Transit Part PCMP message is used to indicate to the source\n   whether\
    \ it has too few or too many layers of address in the Routing\n   Directive (see\
    \ section 8.2).  Long-term, the Reformat Transit Part\n   PCMP message is able\
    \ to arbitrarily modify the transit part\n   transmitted by the host, as encoded\
    \ by a bit string.\n   The Unknown Parameter PCMP message is used to inform the\
    \ source host\n   that the router does not understand a parameter in either the\n\
    \   Handling Directive, the Routing Context, or the Transit Options.  The\n  \
    \ purpose of this message is to assist evolution (see section 16.1).\n   The Host\
    \ Mobility PCMP message is sent by a host to inform another\n   host (for instance,\
    \ the host's Mobile Address Server) that it has a\n   new address (see section\
    \ 14).  The main use of this packet is for\n   host mobility, though it can be\
    \ used to manage any address changes,\n   such as because of a new prefix assignment.\n\
    \   The Exit PDN Address PCMP message is used to manage the function\n   whereby\
    \ the source host informs the PDN entry router of the PDN\n   Address of the exit\
    \ PDN system (see section 15).\n   When a router needs to send a PCMP message,\
    \ it sends it to the source\n   Pip Address.  If the Pip header is in a tunnel,\
    \ then the PCMP message\n   is sent to the router that is the source of the tunnel.\
    \  Depending on\n   the situation, this may result in another PCMP message from\
    \ the\n   source of the tunnel to the true source (for instance, if the source\n\
    \   of the tunnel finds that the dest of the tunnel can't be reached, it\n   may\
    \ send a Packet Not Delivered to the source host).\n"
- title: 14.  Host Mobility
  contents:
  - "14.  Host Mobility\n   Depending on how security conscience a host is, and what\
    \ security\n   mechanisms a host has available, mobility can come from Pip \"\
    for\n   free\".  If a host is willing to accept a packet by just looking at\n\
    \   source and destination Pip ID, and if the host simply records the\n   source\
    \ Pip Address on any packet it receives as the appropriate\n   return address\
    \ to the source Pip ID, then mobility comes\n   automatically.\n   That is, when\
    \ a mobile host gets a new Pip Address, it simply puts\n   that address into the\
    \ next packet it sends.  When the other host\n   receives it, it records the new\
    \ Pip Address, and starts sending\n   return packets to that address.  The security\
    \ aspect of this is that\n   this type of operation leads to an easy way to spoof\
    \ the (internet\n   level) identity of a host.  That is, absent any other security\n\
    \   mechanisms, any host can write any Pip ID into a packet.  (Cross-\n   checking\
    \ a source Pip ID against the source Pip Address at least\n   makes spoofing of\
    \ this sort as hard as with IP. This is discussed\n   below.)\n   The above simple\
    \ host mobility mechanism does not work in the case\n   where source and destination\
    \ hosts obtain new Pip Addresses at the\n   same time and the old Pip addresses\
    \ no longer work, because neither\n   is able to send its new address information\
    \ directly to the other.\n   Furthermore, if a host wishes to be more secure about\
    \ authenticating\n   the source Pip ID of a packet, then the above mechanism also\
    \ is not\n   satisfactory.  In what follows, the complete host mobility mechanism\n\
    \   is described.\n   Pip uses the Mobile Host Server and the PCMP Host Mobility\
    \ message to\n   manage host mobility;\n   The Mobile Host Server is a non-mobile\
    \ host (or router acting as a\n   host) that keeps track of the active address\
    \ of a mobile host.  The\n   Pip ID and Address of the Mobile Host Server is configured\
    \ into the\n   mobile host, and in DNS.  When a host X obtains information from\
    \ DNS\n   about a host Y, the Pip ID and Address of host Y's Mobile Host Server\n\
    \   is among the information.  (Also among the information is host Y's\n   \"\
    permanent\" address, if host Y has one.  If host Y is so mobile that\n   it doesn't\
    \ have a permanent address, then no permanent address is\n   returned by DNS.\
    \  In particular, note that DNS is not intended to\n   keep track of a mobile\
    \ host's active address.)\n   Given the destination host's (Y) permanent ID and\
    \ Address, and the\n   Mobile Host Server's permanent IDs and Addresses, the source\
    \ host (X)\n   proceedes as follows.  X tries to establish communications with\
    \ Y\n   using one of the permanent addresses.  If this fails (or if at any\n \
    \  time X cannot contact Y), X sends a PCMP Mobile Host message to the\n   Mobile\
    \ Host Server requesting the active address for Y.  (Note that X\n   can determine\
    \ that it cannot contact Y from receipt of a PCMP\n   Destination Unreachable\
    \ or a PCMP Invalid Address message.)\n   The Mobile Host Server responds to X\
    \ with the active Pip Addresses of\n   Y.  (Of course, Y must inform its Mobile\
    \ Host Server(s) of its active\n   Pip Addresses when it knows them.  This also\
    \ is done using the PCMP\n   Mobile Host message.  Y also informs any hosts that\
    \ it is actively\n   communicating with, using either a regular Pip packet or\
    \ with a PCMP\n   Mobile Host message.  Thus, usually X does not need to contact\
    \ the\n   Mobile Host Server to track Y's active address.)\n   If the address\
    \ that X already tried is among those returned by Y,\n   then the source host\
    \ has the option of either 1) continuing to try\n   the same Pip Address, 2) trying\
    \ another of Y's Pip Addresses, 3)\n   waiting and querying the Mobile Host Server\
    \ again, or 4) giving up.\n   If the Mobile Host Server indicates that Y has new\
    \ active Pip\n   Addresses, then X chooses among these in the same manner that\
    \ it\n   chooses among multiple permanent Pip Addresses, and tries to contact\n\
    \   Y.\n"
- title: 14.1  PCMP Mobile Host message
  contents:
  - "14.1  PCMP Mobile Host message\n   There are two types of PCMP Mobile Host messages,\
    \ the query and the\n   response.  The query consists of the Pip ID of the host\
    \ for which\n   active Pip Address information is being requested.\n   The response\
    \ consists of a Pip ID, a sequence number, a set of Pip\n   Addresses, and a signature\
    \ field.  The set of Pip Addresses includes\n   all currently usable addresses\
    \ of the host indicated by the Pip ID.\n   Thus, the PCMP Mobile Host message\
    \ can be used both to indicate a\n   newly obtained address, and to indicate that\
    \ a previous address is no\n   longer active (by that addresses' absence in the\
    \ set).\n   The sequence number indicates which is the most recent information.\n\
    \   It is needed to deal with the case where an older PCMP Mobile Host\n   response\
    \ is received after a newer one.\n   The signature field is a value that derives\
    \ from encrypting the\n   sequence number and the set of Pip Addresses.  For now,\
    \ the\n   encryption algorithms used, how to obtain keys, and so on are for\n\
    \   further study.\n"
- title: 14.2  Spoofing Pip IDs
  contents:
  - "14.2  Spoofing Pip IDs\n   This section discusses host mechanisms for decreasing\
    \ the probability\n   of Pip ID spoofing.  The mechanisms provided in this version\
    \ of the\n   near-term Pip architecture are no more secure than DNS itself.  It\
    \ is\n   hoped that mechanisms and the corresponding infrastructure needed for\n\
    \   better internetwork layer security can be installed with whatever new\n  \
    \ IP protocol is chosen.\n   After a host makes a DNS query, it knows:\n   1.\
    \  The destination host's Pip ID,\n   2.  The destination host's permanent Pip\
    \ Addresses, and\n   3.  The destination host's Mobile Host Server's Pip ID and\
    \ Addresses.\n   Note that the DNS query can be a normal one (based on domain\
    \ name) or\n   an inverse query (based on Pip ID or Pip Address, though the latter\n\
    \   is more likely to succeed, since the Pip ID may be flat and therefore\n  \
    \ not suitable for an inverse lookup).  The inverse query is done when\n   the\
    \ host did not initiate the packet exchange, and therefore doesn't\n   know the\
    \ domain name of the remote (initiating) host.\n   If the destination host is\
    \ not mobile, then the source host can check\n   the source Pip Address, compare\
    \ it with those received from DNS, and\n   reject the packet if it does not match.\
    \  This gives spoof protection\n   equal to that of IP.\n   If the destination\
    \ host is mobile and obtains new Pip Addresses, then\n   the source host can check\
    \ the validity of the new Pip Address by\n   sending a PCMP Mobile Host query\
    \ to the Mobile Host Server learned\n   from DNS.  The set of Pip Addresses learned\
    \ from the Mobile Address\n   Server is then used for subsequent validation.\n"
- title: 15.  Public Data Network (PDN) Address Discovery
  contents:
  - "15.  Public Data Network (PDN) Address Discovery\n   One of the problems with\
    \ running Pip (or any internet protocol) over\n   a PDN is that of the PDN entry\
    \ Pip System discovering the PDN Address\n   of the appropriate PDN exit Pip System.\
    \  This problem is solved using\n   ARP in small, broadcast LANs because the broadcast\
    \ mechanism is\n   relatively cheap.  This solution is not available in the PDN\
    \ case,\n   where the number of attached systems is very large, and where\n  \
    \ broadcast is not available (or is not cheap if it is).\n   For the case where\
    \ the domain of the destination host is attached to\n   a PDN, the problem is\
    \ nicely solved by distributing the domain's exit\n   PDN Address information\
    \ in DNS, and then having the source host\n   convey the exit PDN Address to the\
    \ PDN entry router in a Pip option.\n   The DNS of the destination host's domain\
    \ contains the PDN Addresses\n   for the domain.  When DNS returns a record for\
    \ the destination host,\n   the record associates zero or more PDN Addresses with\
    \ each Pip\n   Address.  There can be more than one PDN address associated with\
    \ a\n   given PDN, and there can be more than on PDN associated with a given\n\
    \   Pip Address.  This latter case occurs when more than one hierarchical\n  \
    \ component of the Pip Address each represents a separate PDN.  It is\n   expected\
    \ that in almost all cases, there will be only one (or none)\n   PDN associated\
    \ with any Pip address.\n   (Note that, while the returned DNS record associates\
    \ the PDN\n   Addresses with a single Pip Address, in general the PDN Address\
    \ will\n   apply to a set of Pip Addresses--those for all hosts in the domain.\n\
    \   The DNS files are structured to reflect this grouping in the same way\n  \
    \ that a single Pip Address prefix in DNS applies to many hosts.\n   Therefore,\
    \ every individual host entry in the DNS files does not need\n   to have separate\
    \ PDN Addresses typed in with it.  This simplifies\n   configuration of DNS.)\n\
    \   When the source host sends the first packet to a given destination\n   host,\
    \ it attaches the PDN Addresses, one per PDN, to the packet in an\n   option.\
    \  (Note that, because of the way that options are processed in\n   Pip packets,\
    \ no router other than the entry PDN router need look at\n   the option.) When\
    \ the entry router receives this packet, it\n   determines that it is the entry\
    \ router based on the result of the\n   FTIF Chain lookup.\n   It retrieves the\
    \ PDN Address from the option, and caches it locally.\n   The cache entry can\
    \ later by retrieved using either the destination\n   Pip ID or the destination\
    \ Pip Address as the cache index.\n   The entry router sends the source host a\
    \ PCMP Exit PDN Address\n   message indicating that it has cached the information.\
    \  If there are\n   multiple exit PDN Addresses, then the source host can at this\
    \ time\n   inform the entry PDN router of all the PDN addresses.  The entry PDN\n\
    \   router can either choose from these to setup a connection, or cache\n   them\
    \ to recover from the case where the existing connection breaks.\n   Finally,\
    \ the entry PDN router delivers the Pip packet (perhaps by\n   setting up a connection)\
    \ to the PDN Address indicated.\n   When a PDN entry router receives a Pip packet\
    \ for which it doesn't\n   know the exit PDN address (and has no other means of\
    \ determining it,\n   such as shortcut routing), it sends a PCMP Exit PDN Address\
    \ query\n   message to the originating host.  This can happen if, for instance,\n\
    \   routing changes and directs the packets to a new PDN entry router.\n   When\
    \ the source host receives the PCMP Exit PDN Address query\n   message, it transmits\
    \ the PDN Addresses to the entry PDN router.\n"
- title: 15.1  Notes on Carrying PDN Addresses in NSAPs
  contents:
  - "15.1  Notes on Carrying PDN Addresses in NSAPs\n   The Pip use of PDN Address\
    \ carriage in the option or PCP Exit PDN\n   Address message solves two significant\
    \ problems associated with the\n   analogous use of PDN Address-based NSAPs.\n\
    \   First, there is no existing agreement (standards or otherwise) that\n   the\
    \ existence of of a PDN Address in an NSAP address implies that the\n   identified\
    \ host is reachable behind the PDN Address.  Thus, upon\n   receiving such an\
    \ NSAP, the entry PDN router does not know for sure,\n   without explicit configuration\
    \ information, whether or not the PDN\n   Address can be used at the lower layer.\
    \  Solution of this problem\n   requires standards body agreement, perhaps be\
    \ setting aside\n   additional AFIs to mean \"PDN Address with topological significance\"\
    .\n   The second, and more serious, problem is that a PDN Address in an\n   NSAP\
    \ does not necessarily scale well.  This is best illustrated with\n   the E.164\
    \ address.  E.164 addresses can be used in many different\n   network technologies--telephone\
    \ network, BISDN, SMDS, Frame Relay,\n   and other ATM.  When a router receives\
    \ a packet with an E.164-based\n   NSAP, the E.164 address is in the most significant\
    \ part of the NSAP\n   address (that is, contains the highest level routing information).\n\
    \   Thus, without a potentially significant amount of routing table\n   information,\
    \ the router does not know which network to send the\n   packet to.  Thus, unless\
    \ E.164 addresses are assigned out in blocks\n   according to provider network,\
    \ it won't scale well.\n   A related problem is that of how an entry PDN router\
    \ knows that the\n   PDN address is meant for the PDN it is attached to or some\
    \ other PDN.\n   With Pip, there is a one-to-one relationship between Pip Address\n\
    \   prefix and PDN, so it is always known.  With NSAPs, it is not clear\n   without\
    \ the potentially large routing tables discussed in the\n   previous paragraph.\n"
- title: 16.  Evolution with Pip
  contents:
  - "16.  Evolution with Pip\n   The fact that we call this architecture \"near-term\"\
    \ implies that we\n   expect it to evolve to other architectures.  Thus it is\
    \ important\n   that we have a plan to evolve to these architectures.  The Pip\
    \ near-\n   term architecture includes explicit mechanisms to support evolution.\n\
    \   The key to evolution is being able to evolve any system at any time\n   without\
    \ destroying old functionality.  Depending on what the new\n   functionality is,\
    \ it may be immediately useful to any system that\n   installs it, or it may not\
    \ become useful until a significant number\n   or even a majority of systems install\
    \ it.  None-the-less, it is\n   necessary to be able to install it piece-wise.\n\
    \   The Pip protocol itself supports evolution through the following\n   mechanisms\
    \ [2]:\n   1.  Tunneling.  This allows more up-to-date routers to tunnel less\n\
    \       up-to-date routers, thus allowing for incremental router\n       evolution.\
    \  (Of course, by virtue of encapsulation, tunneling is\n       always an evolution\
    \ option, and indeed tunneling through IP is\n       used in the Pip transition.\
    \  However, Pip's tunneling encoding is\n       efficient because it doesn't duplicate\
    \ header information.)\n       The only use for Pip tunneling in the Pip near-term\
    \ architecture\n       is to route packets through the internal routers of a transit\n\
    \       domain when the internal routers have no external routing\n       information.\
    \  It is assumed that enhancements to the Pip\n       Architecture that require\
    \ tunneling will have their own means of\n       indicating when forming a tunnel\
    \ is necessary.\n   2.  Host independence from routing information.  Since a host\
    \ can\n       receive packets without understanding the routing content of the\n\
    \       packet, routers can evolve without necessarily requiring hosts to\n  \
    \     evolve at the same pace.\n       In order to allow hosts to send Pip packets\
    \ without understanding\n       the contents of the routing information (in the\
    \ Transit Part), the\n       Pip Header Server is able to \"spoon-feed\" the host\
    \ the Pip header.\n       If the Pip Header Server determines that the host is\
    \ able to form\n       its own Pip header (as will usually be the case with the\
    \ near-term\n       Pip architecture), the Pip Header is essentially a null function.\n\
    \       It accepts a query from the host, passes it on to DNS, and returns\n \
    \      the DNS information to the host.\n       If the Pip Header Server determines\
    \ that the host is not able to\n       form its own Pip header, then the Pip Header\
    \ Server forms one on\n       behalf of the host.  In one mode of operation, the\
    \ Pip Header\n       Server gives the host the values of some or all Transit Part\n\
    \       fields, and the host constructs the Transit Part.  This allows for\n \
    \      evolution within the framework of the current Transit Part.  In\n     \
    \  another mode, the Pip Header Server gives the host the Transit\n       Part\
    \ as a simple bit field.  This allows for evolution outside the\n       framework\
    \ of the current Transit Part.\n       In addition to the Pip Header Server being\
    \ able to spoon-feed the\n       host a Transit Part, routers are also able to\
    \ spoon-feed hosts a\n       Transit Part, in case the original Transit Part needs\
    \ to be\n       modified, using the PCMP Reformat Transit Part message.\n   3.\
    \  Separation of handling from routing.  This allows one aspect to\n       evolve\
    \ independently of the other.\n   4.  Flexible Handling Directive, Routing Context,\
    \ and Options\n       definition.  This allows new handling, routing, and option\
    \ types\n       to be added and defunct ones to be removed over time (see section\n\
    \       16.1 below).\n   5.  Fast and general options processing.  Options processing\
    \ in Pip is\n       fast, both because not every router need look at every option,\
    \ and\n       because once a router decides it needs to look at an option, it\n\
    \       can find it quickly (does not require a serial search).  Thus the\n  \
    \     oft-heard argument that a new option can't be used because it will\n   \
    \    slow down processing in all routers goes away.\n    Pip Options can be thought\
    \ of as an extension of the Handling\n    Directive (HD).  The HD is used when\
    \ the handling type is common,\n    and can be encoded in a small space.  The\
    \ option is used otherwise.\n    It is possible that a future option will influence\
    \ routing, and thus\n    the Option will be an extension of the RD as well.  The\
    \ RD, however,\n    is rich enough that this is unlikely.\n   6.  Generalized\
    \ Routing Directive.  Because the Routing Directive is\n       so general, it\
    \ is more likely that we can evolve routing and\n       addressing semantics without\
    \ having to redefine the Pip header or\n       the forwarding machinery.\n   7.\
    \  Host version number.  This number tells what Pip functions a host\n       has,\
    \ such as which PCMP messages it can handle, so that routers\n       can respond\
    \ appropriately to a Pip packet received from a remote\n       host.  This supports\
    \ the capability for routers to evolve ahead of\n       hosts.  (All Pip hosts\
    \ will at least be able to handle all Pip\n       near-term architecture functions.)\n\
    \    The Host version number is also used by the Pip Header Server to\n    determine\
    \ the extent to which the Pip Header Server needs to format\n    a header on behalf\
    \ of the host.\n   8.  Generalized Route Types.  The IDRP/MLPV routing algorithm\
    \ is\n       generic with regards to the types of routes it can calculate.\n \
    \      Thus, adding new route types is a matter of configuring routers to\n  \
    \     accept the new route type, defining metrics for the new route\n       type,\
    \ and defining criteria for selecting one route of the new\n       type over another.\n\
    \   Note that none of these evolution features of Pip significantly slow\n   down\
    \ Pip header processing (as compared to other internet protocols).\n"
- title: 16.1 Handling Directive (HD) and Routing Context (RC) Evolution
  contents:
  - "16.1 Handling Directive (HD) and Routing Context (RC) Evolution\n   Because the\
    \ HD and RC are central to handling and routing of a Pip\n   packet, the evolution\
    \ of these aspects deserves more discussion.\n   Both the HD and the RC fields\
    \ contain multiple parameters.  (In the\n   case of the RC, the router treats\
    \ the RC field as a single number,\n   that is, ignores the fact that the RC is\
    \ composed of multiple\n   parameters.  This allows for fast forwarding of Pip\
    \ packets.) These\n   HD and RC multiple parameters may be arranged in any fashion\
    \ (can be\n   any length, subject to the length of the HD and RC fields themselves,\n\
    \   and can fall on arbitrary bit boundaries).\n   Associated with the HD and\
    \ RC are \"Contents\" fields that indicate\n   what parameters are in the HD and\
    \ RC fields, and where they are.\n   (The Contents fields are basically version\
    \ numbers, except that a\n   higher \"version\" number is not considered to supersede\
    \ a lower one.\n   Typical types of parameters are address family, TOS value,\
    \ queueing\n   priority, and so on.)\n   The Contents field is a single number,\
    \ the value of which indicates\n   the parameter set.  The mapping of Contents\
    \ field value to parameter\n   set is configured manually.\n   The procedure for\
    \ establishing new HD or RC parameter sets (or,\n   erasing old ones) is as follows.\
    \  Some organization defines the new\n   parameter set.  This may involve defining\
    \ a new parameter.  If it\n   does, then the new parameter is described as a Pip\
    \ Object.  A Pip\n   Object is nothing more than a number space used to unambiguously\n\
    \   identify a new parameter type, and a character string that describes\n   it\
    \ [9].\n   Thus, the new parameter set is described as a list of Pip Objects,\n\
    \   and the bit locations in the HD/RC that each Pip Object occupies.\n   The\
    \ organization that defines the parameter set submits it for an\n   official Contents\
    \ field value.  (It would be submitted to the\n   standards body that has authority\
    \ over Pip, currently the IAB.) If\n   the new parameter set is approved, it is\
    \ given a Contents value, and\n   that value is published in a well known place\
    \ (an RFC).\n   Of course, network administrators are free to install or not install\n\
    \   the new parameter set in their hosts and routers.  In the case of a\n   new\
    \ RC parameter set, installation of the new parameter set does not\n   necessarily\
    \ require any new software, because any Pip routing\n   protocol, such as IDRP/MLPV,\
    \ is able to find routes according to the\n   new parameter set by appropriate\
    \ configuration of routers.\n   In the case of a new HD parameter set, however,\
    \ new software is\n   necessary--to execute the new handling.\n   For new HD and\
    \ RC parameters sets, systems that do not understand the\n   new parameter set\
    \ can still be configured to execute one of several\n   default actions on the\
    \ new parameter.  These default action allow for\n   some control over how new\
    \ functions are introduced into Pip systems.\n   The default actions are:\n  \
    \ 1.  Ignore the unknown parameter,\n   2.  Set unknown parameter to all 0's,\n\
    \   3.  Set unknown parameter to all 1's,\n   4.  Silently discard packet,\n \
    \  5.  Discard packet with PCMP Parameter Unknown.\n   Action 1 is used when it\
    \ doesn't much matter if previous systems on a\n   path have acted on the parameter\
    \ or not.  Actions 2 and 3 are used\n   when systems should know whether a previous\
    \ system has not understood\n   the parameter.  Actions 4 and 5 are used when\
    \ something bad happens\n   if not all systems understand the new parameter.\n"
- title: 16.1.1  Options Evolution
  contents:
  - "16.1.1  Options Evolution\n   The evolution of Options is very similar to that\
    \ of the HD and RC.\n   Associated with the Options is an Options Present field\
    \ that\n   indicates in a single word which of up to 8 options are present in\n\
    \   the Options Part.  There is a Contents field associated with the\n   Options\
    \ Present field that indicates which subset of all possible\n   options the Options\
    \ Present field refers to.  Contents field values\n   are assigned in the same\
    \ way as for the HD and RC Contents fields.\n   The same 5 default actions used\
    \ for the HD and RC also apply to the\n   Options.\n"
- title: References
  contents:
  - "References\n   [1]  Thomson, F., \"Use of DNS with Pip\", Work in Progress.\n\
    \   [2]  Francis, P., \"Pip Header Processing\", Work in Progress.\n   [3]  Pip\
    \ Address Assignment Specification,  Work in Progress.\n   [4]  Francis, P., \"\
    Pip Identifiers\", Work in Progress.\n   [5]  Pip Assigned Numbers, Work in Progress.\n\
    \   [6]  Pip Header Protocol,  Work in Progress.\n   [7]  Francis, G., \"PCMP:\
    \ Pip Control Message Protocol\",\n        Work in Progress.\n   [8]  Pip Router\
    \ Discovery Protocol, Work in Progress.\n   [9]  Pip Objects Specification, Work\
    \ in Progress.\n   [10] Rajagopolan, and P. Francis, \"The Multi-Level Path Vector\n\
    \        Routing Scheme\", Work in Progress.\n   [11] Francis, P., \"Pip Address\
    \ Conventions\", Work in Progress.\n   [12] Francis, P., \"On the Assignment of\
    \ Provider Rooted Addresses\",\n        Work in Progress.\n   [13] Ballardie,\
    \ Francis, P., and J. Crowcroft, \"Core Based Trees\n        (CBT), An Architecture\
    \ for Scalable Inter-Domain Multicast\n        Routing\", Work in Progress.\n\
    \   [14] Franics, P., \"Pip Host Operation\", Work in Progress.\n   [15] Egevang,\
    \ K., and P. Francis, \"The IP Network Address\n        Translator (NAT)\", RFC\
    \ 1631, Cray Communications, NTT,\n        May 1994.\n"
- title: 'Notes on the References:'
  contents:
  - "Notes on the References:\n   As of the publication of this RFC, a version of\
    \ [12], titled\n   \"Comparison of Geographic and Provider-rooted Internet Addressing,\"\
    \n   was submitted to ISOC INET 94 in Prague.  Reference [13] was\n   published\
    \ at ACM SIGCOMM 93 in San Francisco under the title \"An\n   Architecture for\
    \ Scalable Inter-Domain Multicast Routing\".\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 'Author''s Address:'
  contents:
  - "Author's Address:\n   Paul Francis\n   NTT Software Lab\n   3-9-11 Midori-cho\
    \ Musashino-shi\n   Tokyo 180 Japan\n   Phone: +81-422-59-3843\n   Fax +81-422-59-3765\n\
    \   EMail: francis@cactus.ntt.jp\n"
