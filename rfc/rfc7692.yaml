- contents:
  - '                  Compression Extensions for WebSocket

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines a framework for creating WebSocket extensions\n
    \  that add compression functionality to the WebSocket Protocol.  An\n   extension
    based on this framework compresses the payload data portion\n   of WebSocket data
    messages on a per-message basis using parameters\n   negotiated during the opening
    handshake.  This framework provides a\n   general method for applying a compression
    algorithm to the contents\n   of WebSocket messages.  Each compression algorithm
    has to be defined\n   in a document defining the extension by specifying the parameter\n
    \  negotiation and the payload transformation algorithm in detail.  This\n   document
    also specifies one specific compression extension using the\n   DEFLATE algorithm.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7692.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conformance Requirements and Terminology ........................3\n   3.
    Complementary Terminology .......................................4\n   4. WebSocket
    Per-Message Compression Extension .....................5\n   5. Extension Negotiation
    ...........................................5\n      5.1. General Negotiation Flow
    ...................................9\n      5.2. Negotiation Examples .......................................9\n
    \  6. Framing ........................................................10\n      6.1.
    Compression ...............................................10\n      6.2. Decompression
    .............................................12\n   7. The \"permessage-deflate\"
    Extension .............................12\n      7.1. Extension Parameters ......................................14\n
    \          7.1.1. Context Takeover Control ...........................14\n           7.1.2.
    Limiting the LZ77 Sliding Window Size ..............16\n           7.1.3. Examples
    ...........................................18\n      7.2. Message Payload Transformation
    ............................19\n           7.2.1. Compression ........................................19\n
    \          7.2.2. Decompression ......................................21\n           7.2.3.
    Examples ...........................................22\n      7.3. Implementation
    Notes ......................................25\n   8. Security Considerations
    ........................................25\n   9. IANA Considerations ............................................26\n
    \     9.1. Registration of the \"permessage-deflate\" WebSocket\n           Extension
    Name ............................................26\n      9.2. Registration of
    the \"Per-Message Compressed\"\n           WebSocket Framing Header Bit ..............................26\n
    \  10. References ....................................................27\n      10.1.
    Normative References .....................................27\n      10.2. Informative
    References ...................................27\n   Acknowledgements ..................................................28\n
    \  Author's Address ..................................................28\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document specifies a framework for adding compression\n
    \  functionality to the WebSocket Protocol [RFC6455].  The framework\n   specifies
    how to define WebSocket Per-Message Compression Extensions\n   (PMCEs) for a compression
    algorithm based on the extension concept of\n   the WebSocket Protocol specified
    in Section 9 of [RFC6455].  A\n   WebSocket client and a peer WebSocket server
    negotiate the use of a\n   PMCE and determine the parameters required to configure
    the\n   compression algorithm during the WebSocket opening handshake.  The\n   client
    and server can then exchange data messages whose frames\n   contain compressed
    data in the payload data portion.\n   This framework only specifies a general
    method for applying a\n   compression algorithm to the contents of WebSocket messages.
    \ Each\n   individual PMCE has to be specified in a document describing in\n   detail
    how to negotiate the configuration parameters for the specific\n   compression
    algorithm used by that PMCE and how to transform\n   (compress and decompress)
    data in the payload data portion.\n   A WebSocket client may offer multiple PMCEs
    during the WebSocket\n   opening handshake.  A peer WebSocket server receiving
    the offer may\n   choose to accept the preferred PMCE or decline all of them.
    \ PMCEs\n   use the RSV1 bit of the WebSocket frame header to indicate whether
    a\n   message is compressed or not so that an endpoint can choose not to\n   compress
    messages with incompressible contents.\n   This document also specifies one specific
    PMCE based on the DEFLATE\n   [RFC1951] algorithm.  The DEFLATE algorithm is widely
    available on\n   various platforms, and its overhead is small.  The extension
    name of\n   this PMCE is \"permessage-deflate\".  To align the end of compressed\n
    \  data to an octet boundary, this extension uses the algorithm\n   described
    in Section 2.1 of [RFC1979].  Endpoints can take over the\n   LZ77 sliding window
    [LZ77] used to build frames for previous messages\n   to achieve a better compression
    ratio.  For resource-limited devices,\n   this extension provides parameters to
    limit memory usage for\n   compression context.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conformance Requirements and Terminology\n   The key words \"MUST\", \"MUST
    NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
    \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
    as described in [RFC2119].\n   Requirements phrased in the imperative as part
    of algorithms (such as\n   \"strip any leading space characters\" or \"return
    false and abort these\n   steps\") are to be interpreted with the meaning of the
    key word\n   (\"MUST\", \"SHOULD\", \"MAY\", etc.) used in introducing the algorithm.\n
    \  Conformance requirements phrased as algorithms or specific steps can\n   be
    implemented in any manner, so long as the end result is\n   equivalent.  In particular,
    the algorithms defined in this\n   specification are intended to be easy to understand
    and are not\n   intended to be performant.\n   This document references the procedure
    to _Fail the WebSocket\n   Connection_.  This procedure is defined in Section
    7.1.7 of\n   [RFC6455].\n   This document references the event that _The WebSocket
    Connection is\n   Established_ and the event that _A WebSocket Message Has Been\n
    \  Received_.  These events are defined in Sections 4.1 and 6.2,\n   respectively,
    of [RFC6455].\n   This document uses the Augmented Backus-Naur Form (ABNF) notation
    of\n   [RFC5234].  The DIGIT (decimal 0-9) rule is included by reference, as\n
    \  defined in the Appendix B.1 of [RFC5234].\n"
  title: 2.  Conformance Requirements and Terminology
- contents:
  - "3.  Complementary Terminology\n   This document defines some terms about WebSocket
    and WebSocket\n   extension mechanisms that are underspecified or not defined
    at all in\n   [RFC6455].\n   data message - a message consisting of data frames
    as defined in\n   Section 5.6 of [RFC6455].\n   message payload (or payload of
    a message) - the concatenation of the\n   payload data portion of all data frames
    (see Section 6.2 of\n   [RFC6455]) representing a single message.\n   next extension
    in use after extension X - the next extension listed\n   after X in the \"Sec-WebSocket-Extensions\"
    header in the server's\n   opening handshake as defined in Section 9.1 of [RFC6455].
    \ Such an\n   extension is applied to outgoing data from the application right\n
    \  after X on the sender side but is applied right before X to incoming\n   data
    from the underlying transport.\n   extension in use preceding extension X - the
    extension listed right\n   before X in the \"Sec-WebSocket-Extensions\" header
    in the server's\n   opening handshake.  Such an extension is applied to outgoing
    data\n   from the application right before X on the sender side but is applied\n
    \  right after X to incoming data from the underlying transport.\n   extension
    negotiation offer - each element in the \"Sec-WebSocket-\n   Extensions\" header
    in the client's opening handshake.\n   extension negotiation response - each element
    in the \"Sec-WebSocket-\n   Extensions\" header in the server's opening handshake.\n
    \  corresponding extension negotiation response for an extension\n   negotiation
    offer - an extension negotiation response that a server\n   sends back to the
    peer client containing the same extension name as\n   the offer and meeting the
    requirements represented by the offer.\n   Accepting an extension negotiation
    offer - including a corresponding\n   extension negotiation response for the offer
    in the \"Sec-WebSocket-\n   Extensions\" header in the server's opening handshake.\n
    \  Declining an extension negotiation offer - not including a\n   corresponding
    extension negotiation response for the offer in the\n   \"Sec-WebSocket-Extensions\"
    header in the server's opening handshake.\n"
  title: 3.  Complementary Terminology
- contents:
  - "4.  WebSocket Per-Message Compression Extension\n   WebSocket PMCEs are extensions
    to the WebSocket Protocol enabling\n   compression functionality.  PMCEs are built
    based on the extension\n   concept of the WebSocket Protocol specified in Section
    9 of\n   [RFC6455].  PMCEs are individually defined for each compression\n   algorithm
    to be implemented and are registered in the \"WebSocket\n   Extension Name Registry\"
    created in Section 11.4 of [RFC6455].  Each\n   PMCE referring to this framework
    MUST define the following:\n   o  The extension name of the PMCE and any applicable
    extension\n      parameters that MUST be included in the \"Sec-WebSocket-Extensions\"\n
    \     header during the extension negotiation offer/response.\n   o  How to interpret
    the extension parameters exchanged during the\n      opening handshake.\n   o
    \ How to transform the payload of a message.\n   One PMCE is defined in Section
    7 of this document and is registered\n   in Section 9.  Other PMCEs may be defined
    in the future in other\n   documents.\n   Section 5 describes the basic extension
    negotiation process.\n   Section 6 describes how to apply the compression algorithm
    with\n   negotiated parameters to the contents of WebSocket messages.\n"
  title: 4.  WebSocket Per-Message Compression Extension
- contents:
  - "5.  Extension Negotiation\n   To offer use of a PMCE, a client MUST include the
    extension name of\n   the PMCE in the \"Sec-WebSocket-Extensions\" header field
    of its\n   opening handshake of the WebSocket connection.  Extension parameters\n
    \  are used to specify the PMCE offer in detail.  For example, a client\n   lists
    its preferred configuration parameter values for the\n   compression algorithm
    of the PMCE.  A client may also offer multiple\n   PMCE choices to the server
    by including multiple elements in the\n   \"Sec-WebSocket-Extensions\" header,
    one for each PMCE offered.  This\n   set of elements MAY include multiple PMCEs
    with the same extension\n   name to offer the possibility to use the same algorithm
    with\n   different configuration parameters.  The order of elements is\n   important
    as it specifies the client's preference.  An element\n   preceding another element
    has higher preference.  It is recommended\n   that a server accepts PMCEs with
    higher preference if the server\n   supports them.\n   A PMCE negotiation offer
    provides requests and/or hints to the\n   server.\n   A request in a PMCE negotiation
    offer indicates constraints on the\n   server's behavior that must be satisfied
    if the server accepts the\n   offer.  For example, suppose that a server sends
    data compressed with\n   the DEFLATE algorithm to a client.  The server must keep
    the original\n   bytes of data that it recently compressed and sent to the client.\n
    \  The client must keep the result of decompressing the bytes of data\n   that
    it recently received from the server.  The amount of bytes of\n   data kept is
    called the LZ77 window size.  The LZ77 window size of\n   the client must not
    be less than the LZ77 window size of the server.\n   In a PMCE negotiation offer,
    the client MUST inform the server of its\n   LZ77 window size so that the server
    uses an LZ77 window size that is\n   not greater than the LZ77 window size of
    the client.  This\n   restriction on the LZ77 window size is an example of a request
    in a\n   PMCE negotiation offer.\n   A hint in a PMCE negotiation offer provides
    information about the\n   client's behavior that the server may either safely
    ignore or refer\n   to when the server decides its behavior.  For example, suppose
    that a\n   client sends data compressed with the DEFLATE algorithm to a server.\n
    \  The client must keep the original bytes of data that it recently\n   compressed
    and sent to the server.  The server must keep the result\n   of decompressing
    the bytes of data that it recently received from the\n   client.  The LZ77 window
    size of the server must not be less than the\n   LZ77 window size of the client.
    \ In a PMCE negotiation offer, the\n   client MAY inform the server of the maximum
    LZ77 window size the\n   client can afford so that the server can choose to use
    an LZ77 window\n   size that is not greater than the maximum size of the client.
    \ This\n   information is an example of a hint in a PMCE negotiation offer.\n
    \  It's waste of memory to use an LZ77 window size greater than the LZ77\n   window
    size the client actually uses.  Using the hint, the server can\n   avoid the waste
    of memory.  Since the hint itself doesn't specify the\n   constraints on the endpoints,
    the server must use the \"agreed\n   parameters\" (defined below) to explicitly
    ask the client not to use\n   an LZ77 window size greater than the LZ77 window
    size of the server.\n   To accept the use of an offered PMCE, a server MUST include
    the\n   extension name of the PMCE in the \"Sec-WebSocket-Extensions\" header\n
    \  field of its opening handshake of the WebSocket connection.\n   Extension parameters
    represent the detailed configuration parameters\n   for the PMCE to use.  These
    extension parameters and their values are\n   called \"agreed parameters\".  The
    element MUST represent a PMCE that\n   is fully supported by the server.  The
    contents of the element don't\n   need to be exactly the same as those of the
    received extension\n   negotiation offers.  For example, suppose that a server
    received a\n   PMCE extension negotiation offer with an extension parameter \"X\"\n
    \  indicating that the client can enable an optional feature named X.\n   The
    server may accept the PMCE offer with an element without the\n   extension parameter
    \"X\", meaning that the server chose not to enable\n   the feature X.  In this
    case, the offer contains the extension\n   parameter \"X\", but the \"agreed parameters\"
    don't contain the\n   extension parameter \"X\".\n   \"Agreed parameters\" must
    represent how the requests and hints in the\n   client's extension negotiation
    offer have been handled in addition to\n   the server's requests and hints on
    the client's behavior, so that the\n   client can configure its behavior without
    identifying exactly which\n   PMCE extension negotiation offer has been accepted.\n
    \  For example, if a client sends an extension negotiation offer that\n   includes
    a parameter \"enable_compression\" and another without this\n   parameter, the
    server accepts the former and informs the client by\n   sending back an element
    that includes parameter(s) acknowledging\n   \"enable_compression\".  The name
    of the acknowledging parameter\n   doesn't need to be exactly the same as the
    offer.  For example, two\n   parameters, \"enable_strong_compression\" and\n   \"enable_weak_compression\",
    may be defined as acknowledging parameters\n   for \"enable_compression\".\n   Compression
    features can be applied differently for each direction.\n   For such features,
    the acknowledging parameter and the parameter in\n   the reverse direction must
    be chosen to distinguish them.  For\n   example, in order to make parameters distinguishable,
    a \"server_\"\n   prefix can be added to parameters affecting data sent from a
    server,\n   and a \"client_\" prefix can be added to parameters affecting data
    sent\n   from a client.\n   A server MUST NOT accept a PMCE extension negotiation
    offer together\n   with another extension if the PMCE will conflict with the extension\n
    \  on their use of the RSV1 bit.  A client that received a response\n   accepting
    a PMCE extension negotiation offer together with such an\n   extension MUST _Fail
    the WebSocket Connection_.\n   A server MUST NOT accept a PMCE extension negotiation
    offer together\n   with another extension if the PMCE will be applied to the output
    of\n   the extension and any of the following conditions applies to the\n   extension:\n
    \  o  The extension requires the boundary of frames to be preserved\n      between
    the output from the extension at the sender and the input\n      to the extension
    at the receiver.\n   o  The extension uses the \"Extension data\" field or any
    of the\n      reserved bits on the WebSocket header as a per-frame attribute.\n
    \  A client that receives a response accepting a PMCE extension\n   negotiation
    offer together with such an extension MUST _Fail the\n   WebSocket Connection_.\n
    \  A server declining all offered PMCEs MUST NOT include any element\n   with
    PMCE names.  If a server responds with no PMCE element in the\n   \"Sec-WebSocket-Extensions\"
    header, both endpoints proceed without\n   per-message compression once _the WebSocket
    Connection is\n   established_.\n   If a server gives an invalid response, such
    as accepting a PMCE that\n   the client did not offer, the client MUST _Fail the
    WebSocket\n   Connection_.\n   If a server responds with a valid PMCE element
    in the \"Sec-WebSocket-\n   Extensions\" header and _the WebSocket Connection
    is established_,\n   both endpoints MUST use the algorithm described in Section
    6 and the\n   message payload transformation (compressing and decompressing)\n
    \  procedure of the PMCE configured with the \"agreed parameters\"\n   returned
    by the server to exchange messages.\n"
  - contents:
    - "5.1.  General Negotiation Flow\n   This section describes a general negotiation
      flow.  How to handle\n   parameters in detail must be specified in the document
      specifying the\n   PMCE.\n   A client makes an offer including parameters identifying
      the\n   following:\n   o  Hints about how the client is planning to compress
      data\n   o  Requests about how the server compresses data\n   o  Limitations
      concerning the client's compression functionality\n   The peer server makes
      a determination of its behavior based on these\n   parameters.  If the server
      can and wants to proceed with this PMCE\n   enabled, the server responds to
      the client with parameters\n   identifying the following:\n   o  Requests about
      how the client compresses data\n   o  How the server will compress data\n   Based
      on these parameters received from the server, the client\n   determines its
      behavior and if it can and wants to proceed with this\n   PMCE enabled.  Otherwise,
      the client starts the closing handshake\n   with close code 1010.\n"
    title: 5.1.  General Negotiation Flow
  - contents:
    - "5.2.  Negotiation Examples\n   The following are example values for the \"Sec-WebSocket-Extensions\"\n
      \  header offering PMCEs; permessage-foo and permessage-bar in the\n   examples
      are hypothetical extension names of PMCEs for the\n   compression algorithm
      foo and bar.\n   o  Offer the permessage-foo.\n          permessage-foo\n   o
      \ Offer the permessage-foo with a parameter x with a value of 10.\n          permessage-foo;
      x=10\n      The value may be quoted.\n          permessage-foo; x=\"10\"\n   o
      \ Offer the permessage-foo as first choice and the permessage-bar as\n      a
      fallback plan.\n          permessage-foo, permessage-bar\n   o  Offer the permessage-foo
      with a parameter use_y, which enables a\n      feature y as first choice, and
      the permessage-foo without the\n      use_y parameter as a fallback plan.\n
      \         permessage-foo; use_y, permessage-foo\n"
    title: 5.2.  Negotiation Examples
  title: 5.  Extension Negotiation
- contents:
  - "6.  Framing\n   PMCEs operate only on data messages.\n   This document allocates
    the RSV1 bit of the WebSocket header for\n   PMCEs and calls the bit the \"Per-Message
    Compressed\" bit.  On a\n   WebSocket connection where a PMCE is in use, this
    bit indicates\n   whether a message is compressed or not.\n   A message with the
    \"Per-Message Compressed\" bit set on the first\n   fragment of the message is
    called a \"compressed message\".  Frames of\n   a compressed message have compressed
    data in the payload data\n   portion.  An endpoint receiving a compressed message
    decompresses the\n   concatenation of the compressed data of the frames of the
    message by\n   following the decompression procedure specified by the PMCE in
    use.\n   The endpoint uses the bytes corresponding to the application data\n   portion
    in this decompressed data for the _A WebSocket Message Has\n   Been Received_
    event instead of the received data as is.\n   A message with the \"Per-Message
    Compressed\" bit unset on the first\n   fragment of the message is called an \"uncompressed
    message\".  Frames\n   of an uncompressed message have uncompressed original data
    as is in\n   the payload data portion.  An endpoint receiving an uncompressed\n
    \  message uses the concatenation of the application data portion of the\n   frames
    of the message as is for the _A WebSocket Message Has Been\n   Received_ event.\n"
  - contents:
    - "6.1.  Compression\n   An endpoint MUST use the following algorithm to send
      a message in the\n   form of a compressed message.\n   1.  Compress the message
      payload of the original message by following\n       the compression procedure
      of the PMCE.  The original message may\n       be input from the application
      layer or output of another\n       WebSocket extension, depending on which extensions
      were\n       negotiated.\n   2.  Process the compressed data as follows:\n       *
      \ If this PMCE is the last extension to process outgoing\n          messages,
      build frame(s) using the compressed data instead of\n          the original
      data for the message payload, set the \"Per-\n          Message Compressed\"
      bit of the first frame, and then send the\n          frame(s) as described in
      Section 6.1 of [RFC6455].\n       *  Otherwise, pass the transformed message
      payload and modified\n          header values, including the \"Per-Message Compressed\"
      bit\n          value set to 1, to the next extension after the PMCE.  If the\n
      \         extension expects frames for input, build a frame for the\n          message
      and pass it.\n   An endpoint MUST use the following algorithm to send a message
      in the\n   form of an uncompressed message.\n   1.  Process the original data
      as follows:\n       *  If this PMCE is the last extension to process outgoing\n
      \         messages, build frame(s) using the original data for the\n          payload
      data portion as is, unset the \"Per-Message Compressed\"\n          bit of the
      first frame, and then send the frame(s) as\n          described in Section 6.1
      of [RFC6455].\n       *  Otherwise, pass the message payload and header values
      to the\n          next extension after the PMCE as is.  If the extension expects\n
      \         frames for input, build a frame for the message and pass it.\n   An
      endpoint MUST NOT set the \"Per-Message Compressed\" bit of control\n   frames
      and non-first fragments of a data message.  An endpoint\n   receiving such a
      frame MUST _Fail the WebSocket Connection_.\n   PMCEs do not change the opcode
      field.  The opcode of the first frame\n   of a compressed message indicates
      the opcode of the original message.\n   The payload data portion in frames generated
      by a PMCE is not subject\n   to the constraints for the original data type.
      \ For example, the\n   concatenation of the output data corresponding to the
      application\n   data portion of frames of a compressed text message is not required\n
      \  to be valid UTF-8.  At the receiver, the payload data portion after\n   decompression
      is subject to the constraints for the original data\n   type again.\n"
    title: 6.1.  Compression
  - contents:
    - "6.2.  Decompression\n   An endpoint MUST use the following algorithm to receive
      a message in\n   the form of a compressed message.\n   1.  Concatenate the payload
      data portion of the received frames of\n       the compressed message.  The
      received frames may be direct input\n       from the underlying transport or
      output of another WebSocket\n       extension, depending on which extensions
      were negotiated.\n   2.  Decompress the concatenation by following the decompression\n
      \      procedure of the PMCE.\n   3.  Process the decompressed message as follows:\n
      \      *  If this is the last extension to process incoming messages,\n          deliver
      the _A WebSocket Message Has Been Received_ event to\n          the application
      layer with the decompressed message payload\n          and header values, including
      the \"Per-Message Compressed\" bit\n          unset to 0.\n       *  Otherwise,
      pass the decompressed message payload and header\n          values, including
      the \"Per-Message Compressed\" bit unset to 0,\n          to the extension preceding
      the PMCE.  If the extension expects\n          frames for input, build a frame
      for the message and pass it.\n   An endpoint MUST use the following algorithm
      to receive a message in\n   the form of an uncompressed message.\n   1.  Process
      the received message as follows:\n       *  If this PMCE is the last extension
      to process incoming\n          messages, deliver the _A WebSocket Message Has
      Been Received_\n          event to the application layer with the received message\n
      \         payload and header values as is.\n       *  Otherwise, pass the message
      payload and header values to the\n          extension preceding the PMCE as
      is.  If the extension expects\n          frames for input, build a frame for
      the message and pass it.\n"
    title: 6.2.  Decompression
  title: 6.  Framing
- contents:
  - "7.  The \"permessage-deflate\" Extension\n   This section defines a specific
    PMCE called \"permessage-deflate\".  It\n   compresses the payload of a message
    using the DEFLATE algorithm\n   [RFC1951] and uses the byte boundary alignment
    method introduced in\n   [RFC1979].\n   This section uses the term \"byte\" with
    the same meaning as used in\n   [RFC1951], i.e., 8 bits stored or transmitted
    as a unit (same as an\n   octet).\n   The registered extension name for this extension
    is \"permessage-\n   deflate\".\n   Four extension parameters are defined for
    \"permessage-deflate\" to\n   help endpoints manage per-connection resource usage.\n
    \  o  \"server_no_context_takeover\"\n   o  \"client_no_context_takeover\"\n   o
    \ \"server_max_window_bits\"\n   o  \"client_max_window_bits\"\n   These parameters
    enable two methods (no_context_takeover and\n   max_window_bits) of constraining
    memory usage that may be applied\n   independently to either direction of WebSocket
    traffic.  The\n   extension parameters with the \"client_\" prefix are used by
    the client\n   to configure its compressor and by the server to configure its\n
    \  decompressor.  The extension parameters with the \"server_\" prefix are\n   used
    by the server to configure its compressor and by the client to\n   configure its
    decompressor.  All four parameters are defined for both\n   a client's extension
    negotiation offer and a server's extension\n   negotiation response.\n   A server
    MUST decline an extension negotiation offer for this\n   extension if any of the
    following conditions are met:\n   o  The negotiation offer contains an extension
    parameter not defined\n      for use in an offer.\n   o  The negotiation offer
    contains an extension parameter with an\n      invalid value.\n   o  The negotiation
    offer contains multiple extension parameters with\n      the same name.\n   o
    \ The server doesn't support the offered configuration.\n   A client MUST _Fail
    the WebSocket Connection_ if the peer server\n   accepted an extension negotiation
    offer for this extension with an\n   extension negotiation response meeting any
    of the following\n   conditions:\n   o  The negotiation response contains an extension
    parameter not\n      defined for use in a response.\n   o  The negotiation response
    contains an extension parameter with an\n      invalid value.\n   o  The negotiation
    response contains multiple extension parameters\n      with the same name.\n   o
    \ The client does not support the configuration that the response\n      represents.\n
    \  The term \"LZ77 sliding window\" [LZ77] used in this section means the\n   buffer
    used by the DEFLATE algorithm to store recently processed\n   input.  The DEFLATE
    compression algorithm searches the buffer for a\n   match with the following input.\n
    \  The term \"use context takeover\" used in this section means that the\n   same
    LZ77 sliding window used by the endpoint to build frames of the\n   previous sent
    message is reused to build frames of the next message\n   to be sent.\n"
  - contents:
    - '7.1.  Extension Parameters

      '
    - contents:
      - '7.1.1.  Context Takeover Control

        '
      - contents:
        - "7.1.1.1.  The \"server_no_context_takeover\" Extension Parameter\n   A
          client MAY include the \"server_no_context_takeover\" extension\n   parameter
          in an extension negotiation offer.  This extension\n   parameter has no
          value.  By including this extension parameter in an\n   extension negotiation
          offer, a client prevents the peer server from\n   using context takeover.
          \ If the peer server doesn't use context\n   takeover, the client doesn't
          need to reserve memory to retain the\n   LZ77 sliding window between messages.\n
          \  Absence of this extension parameter in an extension negotiation offer\n
          \  indicates that the client can decompress a message that the server\n
          \  built using context takeover.\n   A server accepts an extension negotiation
          offer that includes the\n   \"server_no_context_takeover\" extension parameter
          by including the\n   \"server_no_context_takeover\" extension parameter
          in the corresponding\n   extension negotiation response to send back to
          the client.  The\n   \"server_no_context_takeover\" extension parameter
          in an extension\n   negotiation response has no value.\n   It is RECOMMENDED
          that a server supports the\n   \"server_no_context_takeover\" extension
          parameter in an extension\n   negotiation offer.\n   A server MAY include
          the \"server_no_context_takeover\" extension\n   parameter in an extension
          negotiation response even if the extension\n   negotiation offer being accepted
          by the extension negotiation\n   response didn't include the \"server_no_context_takeover\"
          extension\n   parameter.\n"
        title: 7.1.1.1.  The "server_no_context_takeover" Extension Parameter
      - contents:
        - "7.1.1.2.  The \"client_no_context_takeover\" Extension Parameter\n   A
          client MAY include the \"client_no_context_takeover\" extension\n   parameter
          in an extension negotiation offer.  This extension\n   parameter has no
          value.  By including this extension parameter in an\n   extension negotiation
          offer, a client informs the peer server of a\n   hint that even if the server
          doesn't include the\n   \"client_no_context_takeover\" extension parameter
          in the corresponding\n   extension negotiation response to the offer, the
          client is not going\n   to use context takeover.\n   A server MAY include
          the \"client_no_context_takeover\" extension\n   parameter in an extension
          negotiation response.  If the received\n   extension negotiation offer includes
          the \"client_no_context_takeover\"\n   extension parameter, the server may
          either ignore the parameter or\n   use the parameter to avoid taking over
          the LZ77 sliding window\n   unnecessarily by including the \"client_no_context_takeover\"
          extension\n   parameter in the corresponding extension negotiation response
          to the\n   offer.  The \"client_no_context_takeover\" extension parameter
          in an\n   extension negotiation response has no value.  By including the\n
          \  \"client_no_context_takeover\" extension parameter in an extension\n
          \  negotiation response, a server prevents the peer client from using\n
          \  context takeover.  This reduces the amount of memory that the server\n
          \  has to reserve for the connection.\n   Absence of this extension parameter
          in an extension negotiation\n   response indicates that the server can decompress
          messages built by\n   the client using context takeover.\n   A client MUST
          support the \"client_no_context_takeover\" extension\n   parameter in an
          extension negotiation response.\n"
        title: 7.1.1.2.  The "client_no_context_takeover" Extension Parameter
      title: 7.1.1.  Context Takeover Control
    - contents:
      - '7.1.2.  Limiting the LZ77 Sliding Window Size

        '
      - contents:
        - "7.1.2.1.  The \"server_max_window_bits\" Extension Parameter\n   A client
          MAY include the \"server_max_window_bits\" extension parameter\n   in an
          extension negotiation offer.  This parameter has a decimal\n   integer value
          without leading zeroes between 8 to 15, inclusive,\n   indicating the base-2
          logarithm of the LZ77 sliding window size, and\n   MUST conform to the ABNF
          below.\n       server-max-window-bits = 1*DIGIT\n   By including this parameter
          in an extension negotiation offer, a\n   client limits the LZ77 sliding
          window size that the server will use\n   to compress messages.  If the peer
          server uses a small LZ77 sliding\n   window to compress messages, the client
          can reduce the memory needed\n   for the LZ77 sliding window.\n   A server
          declines an extension negotiation offer with this parameter\n   if the server
          doesn't support it.\n   Absence of this parameter in an extension negotiation
          offer indicates\n   that the client can receive messages compressed using
          an LZ77 sliding\n   window of up to 32,768 bytes.\n   A server accepts an
          extension negotiation offer with this parameter\n   by including the \"server_max_window_bits\"
          extension parameter in the\n   extension negotiation response to send back
          to the client with the\n   same or smaller value as the offer.  The \"server_max_window_bits\"\n
          \  extension parameter in an extension negotiation response has a\n   decimal
          integer value without leading zeroes between 8 to 15,\n   inclusive, indicating
          the base-2 logarithm of the LZ77 sliding window\n   size, and MUST conform
          to the ABNF below.\n       server-max-window-bits = 1*DIGIT\n   A server
          MAY include the \"server_max_window_bits\" extension parameter\n   in an
          extension negotiation response even if the extension\n   negotiation offer
          being accepted by the response didn't include the\n   \"server_max_window_bits\"
          extension parameter.\n"
        title: 7.1.2.1.  The "server_max_window_bits" Extension Parameter
      - contents:
        - "7.1.2.2.  The \"client_max_window_bits\" Extension Parameter\n   A client
          MAY include the \"client_max_window_bits\" extension parameter\n   in an
          extension negotiation offer.  This parameter has no value or a\n   decimal
          integer value without leading zeroes between 8 to 15\n   inclusive indicating
          the base-2 logarithm of the LZ77 sliding window\n   size.  If a value is
          specified for this parameter, the value MUST\n   conform to the ABNF below.\n
          \      client-max-window-bits = 1*DIGIT\n   By including this parameter
          in an offer, a client informs the peer\n   server that the client supports
          the \"client_max_window_bits\"\n   extension parameter in an extension negotiation
          response and,\n   optionally, a hint by attaching a value to the parameter.
          \ If the\n   \"client_max_window_bits\" extension parameter in an extension\n
          \  negotiation offer has a value, the parameter also informs the peer\n
          \  server of a hint that even if the server doesn't include the\n   \"client_max_window_bits\"
          extension parameter in the corresponding\n   extension negotiation response
          with a value greater than the one in\n   the extension negotiation offer
          or if the server doesn't include the\n   extension parameter at all, the
          client is not going to use an LZ77\n   sliding window size greater than
          the size specified by the value in\n   the extension negotiation offer to
          compress messages.\n   If a received extension negotiation offer has the\n
          \  \"client_max_window_bits\" extension parameter, the server MAY include\n
          \  the \"client_max_window_bits\" extension parameter in the corresponding\n
          \  extension negotiation response to the offer.  If the\n   \"client_max_window_bits\"
          extension parameter in a received extension\n   negotiation offer has a
          value, the server may either ignore this\n   value or use this value to
          avoid allocating an unnecessarily big LZ77\n   sliding window by including
          the \"client_max_window_bits\" extension\n   parameter in the corresponding
          extension negotiation response to the\n   offer with a value equal to or
          smaller than the received value.  The\n   \"client_max_window_bits\" extension
          parameter in an extension\n   negotiation response has a decimal integer
          value without leading\n   zeroes between 8 to 15 inclusive indicating the
          base-2 logarithm of\n   the LZ77 sliding window size and MUST conform to
          the ABNF below.\n       client-max-window-bits = 1*DIGIT\n   By including
          this extension parameter in an extension negotiation\n   response, a server
          limits the LZ77 sliding window size that the\n   client uses to compress
          messages.  This reduces the amount of memory\n   for the decompression context
          that the server has to reserve for the\n   connection.\n   If a received
          extension negotiation offer doesn't have the\n   \"client_max_window_bits\"
          extension parameter, the corresponding\n   extension negotiation response
          to the offer MUST NOT include the\n   \"client_max_window_bits\" extension
          parameter.\n   Absence of this extension parameter in an extension negotiation\n
          \  response indicates that the server can receive messages compressed\n
          \  using an LZ77 sliding window of up to 32,768 bytes.\n"
        title: 7.1.2.2.  The "client_max_window_bits" Extension Parameter
      title: 7.1.2.  Limiting the LZ77 Sliding Window Size
    - contents:
      - "7.1.3.  Examples\n   The simplest \"Sec-WebSocket-Extensions\" header in
        a client's opening\n   handshake to offer use of the \"permessage-deflate\"
        extension looks\n   like this:\n       Sec-WebSocket-Extensions: permessage-deflate\n
        \  Since the \"client_max_window_bits\" extension parameter is not\n   included
        in this extension negotiation offer, the server must not\n   accept the offer
        with an extension negotiation response that includes\n   the \"client_max_window_bits\"
        extension parameter.  The simplest \"Sec-\n   WebSocket-Extensions\" header
        in a server's opening handshake to\n   accept use of the \"permessage-deflate\"
        extension is the same:\n       Sec-WebSocket-Extensions: permessage-deflate\n
        \  The following extension negotiation offer sent by a client is asking\n
        \  the server to use an LZ77 sliding window with a size of 1,024 bytes\n   or
        less and declaring that the client supports the\n   \"client_max_window_bits\"
        extension parameter in an extension\n   negotiation response.\n       Sec-WebSocket-Extensions:\n
        \          permessage-deflate;\n           client_max_window_bits; server_max_window_bits=10\n
        \  This extension negotiation offer might be rejected by the server\n   because
        the server doesn't support the \"server_max_window_bits\"\n   extension parameter
        in an extension negotiation offer.  This is fine\n   if the client cannot
        receive messages compressed using a larger\n   sliding window size, but if
        the client just prefers using a small\n   window but wants to fall back to
        the \"permessage-deflate\" without the\n   \"server_max_window_bits\" extension
        parameter, the client can make an\n   offer with the fallback option like
        this:\n       Sec-WebSocket-Extensions:\n           permessage-deflate;\n
        \          client_max_window_bits; server_max_window_bits=10,\n           permessage-deflate;\n
        \          client_max_window_bits\n   The server can accept \"permessage-deflate\"
        by picking any supported\n   one from the listed offers.  To accept the first
        option, for example,\n   the server may send back a response as follows:\n
        \      Sec-WebSocket-Extensions:\n           permessage-deflate; server_max_window_bits=10\n
        \  To accept the second option, for example, the server may send back a\n
        \  response as follows:\n       Sec-WebSocket-Extensions: permessage-deflate\n"
      title: 7.1.3.  Examples
    title: 7.1.  Extension Parameters
  - contents:
    - '7.2.  Message Payload Transformation

      '
    - contents:
      - "7.2.1.  Compression\n   An endpoint uses the following algorithm to compress
        a message.\n   1.  Compress all the octets of the payload of the message using\n
        \      DEFLATE.\n   2.  If the resulting data does not end with an empty DEFLATE
        block\n       with no compression (the \"BTYPE\" bits are set to 00), append
        an\n       empty DEFLATE block with no compression to the tail end.\n   3.
        \ Remove 4 octets (that are 0x00 0x00 0xff 0xff) from the tail end.\n       After
        this step, the last octet of the compressed data contains\n       (possibly
        part of) the DEFLATE header bits with the \"BTYPE\" bits\n       set to 00.\n
        \  When using DEFLATE in the first step above:\n   o  An endpoint MAY use
        multiple DEFLATE blocks to compress one\n      message.\n   o  An endpoint
        MAY use DEFLATE blocks of any type.\n   o  An endpoint MAY use both DEFLATE
        blocks with the \"BFINAL\" bit set\n      to 0 and DEFLATE blocks with the
        \"BFINAL\" bit set to 1.\n   o  When any DEFLATE block with the \"BFINAL\"
        bit set to 1 doesn't end\n      at a byte boundary, an endpoint MUST add minimal
        padding bits of 0\n      to make it end at a byte boundary.  The next DEFLATE
        block follows\n      the padded data if any.\n   An endpoint fragments a compressed
        message by splitting the result of\n   running this algorithm.  Even when
        only part of the payload is\n   available, a fragment can be built by compressing
        the available data\n   and choosing the block type appropriately so that the
        end of the\n   resulting compressed data is aligned at a byte boundary.  Note
        that\n   for non-final fragments, the removal of 0x00 0x00 0xff 0xff MUST
        NOT\n   be done.\n   An endpoint MUST NOT use an LZ77 sliding window longer
        than 32,768\n   bytes to compress messages to send.\n   If the \"agreed parameters\"
        contain the \"client_no_context_takeover\"\n   extension parameter, the client
        MUST start compressing each new\n   message with an empty LZ77 sliding window.
        \ Otherwise, the client MAY\n   take over the LZ77 sliding window used to
        build the last compressed\n   message.  Note that even if the client has included
        the\n   \"client_no_context_takeover\" extension parameter in its offer, the\n
        \  client MAY take over the LZ77 sliding window used to build the last\n   compressed
        message if the \"agreed parameters\" don't contain the\n   \"client_no_context_takeover\"
        extension parameter.  The client-to-\n   server \"client_no_context_takeover\"
        extension parameter is just a\n   hint for the server to build an extension
        negotiation response.\n   If the \"agreed parameters\" contain the \"server_no_context_takeover\"\n
        \  extension parameter, the server MUST start compressing each new\n   message
        with an empty LZ77 sliding window.  Otherwise, the server MAY\n   take over
        the LZ77 sliding window used to build the last compressed\n   message.\n   If
        the \"agreed parameters\" contain the \"client_max_window_bits\"\n   extension
        parameter with a value of w, the client MUST NOT use an\n   LZ77 sliding window
        longer than the w-th power of 2 bytes to compress\n   messages to send.  Note
        that even if the client has included in its\n   offer the \"client_max_window_bits\"
        extension parameter with a value\n   smaller than one in the \"agreed parameters\",
        the client MAY use an\n   LZ77 sliding window with any size to compress messages
        to send as\n   long as the size conforms to the \"agreed parameters\".  The
        client-to-\n   server \"client_max_window_bits\" extension parameter is just
        a hint\n   for the server to build an extension negotiation response.\n   If
        the \"agreed parameters\" contain the \"server_max_window_bits\"\n   extension
        parameter with a value of w, the server MUST NOT use an\n   LZ77 sliding window
        longer than the w-th power of 2 bytes to compress\n   messages to send.\n"
      title: 7.2.1.  Compression
    - contents:
      - "7.2.2.  Decompression\n   An endpoint uses the following algorithm to decompress
        a message.\n   1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end
        of the\n       payload of the message.\n   2.  Decompress the resulting data
        using DEFLATE.\n   If the \"agreed parameters\" contain the \"server_no_context_takeover\"\n
        \  extension parameter, the client MAY decompress each new message with\n
        \  an empty LZ77 sliding window.  Otherwise, the client MUST decompress\n
        \  each new message using the LZ77 sliding window used to process the\n   last
        compressed message.\n   If the \"agreed parameters\" contain the \"client_no_context_takeover\"\n
        \  extension parameter, the server MAY decompress each new message with\n
        \  an empty LZ77 sliding window.  Otherwise, the server MUST decompress\n
        \  each new message using the LZ77 sliding window used to process the\n   last
        compressed message.  Note that even if the client has included\n   the \"client_no_context_takeover\"
        extension parameter in its offer,\n   the server MUST decompress each new
        message using the LZ77 sliding\n   window used to process the last compressed
        message if the \"agreed\n   parameters\" don't contain the \"client_no_context_takeover\"
        extension\n   parameter.  The client-to-server \"client_no_context_takeover\"\n
        \  extension parameter is just a hint for the server to build an\n   extension
        negotiation response.\n   If the \"agreed parameters\" contain the \"server_max_window_bits\"\n
        \  extension parameter with a value of w, the client MAY reduce the size\n
        \  of its LZ77 sliding window to decompress received messages down to\n   the
        w-th power of 2 bytes.  Otherwise, the client MUST use a\n   32,768-byte LZ77
        sliding window to decompress received messages.\n   If the \"agreed parameters\"
        contain the \"client_max_window_bits\"\n   extension parameter with a value
        of w, the server MAY reduce the size\n   of its LZ77 sliding window to decompress
        received messages down to\n   the w-th power of 2 bytes.  Otherwise, the server
        MUST use a\n   32,768-byte LZ77 sliding window to decompress received messages.\n
        \  Note that even if the client has included in its offer the\n   \"client_max_window_bits\"
        extension parameter with a value smaller\n   than one in the \"agreed parameters\",
        the client MUST use an LZ77\n   sliding window of a size that conforms the
        \"agreed parameters\" to\n   compress messages to send.  The client-to-server\n
        \  \"client_max_window_bits\" extension parameter is just a hint for the\n
        \  server to build an extension negotiation response.\n"
      title: 7.2.2.  Decompression
    - contents:
      - "7.2.3.  Examples\n   This section introduces examples of how the \"permessage-deflate\"\n
        \  extension transforms messages.\n"
      - contents:
        - "7.2.3.1.  A Message Compressed Using One Compressed DEFLATE Block\n   Suppose
          that an endpoint sends a text message \"Hello\".  If the\n   endpoint uses
          one compressed DEFLATE block (compressed with fixed\n   Huffman code and
          the \"BFINAL\" bit not set) to compress the message,\n   the endpoint obtains
          the compressed data to use for the message\n   payload as follows.\n   The
          endpoint compresses \"Hello\" into one compressed DEFLATE block and\n   flushes
          the resulting data into a byte array using an empty DEFLATE\n   block with
          no compression:\n       0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00 0x00 0x00 0xff
          0xff\n   By stripping 0x00 0x00 0xff 0xff from the tail end, the endpoint
          gets\n   the data to use for the message payload:\n       0xf2 0x48 0xcd
          0xc9 0xc9 0x07 0x00\n   Suppose that the endpoint sends this compressed
          message without\n   fragmentation.  The endpoint builds one frame by putting
          all of the\n   compressed data in the payload data portion of the frame:\n
          \      0xc1 0x07 0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00\n   The first 2 octets
          (0xc1 0x07) are the WebSocket frame header (FIN=1,\n   RSV1=1, RSV2=0, RSV3=0,
          opcode=text, MASK=0, Payload length=7).  The\n   following figure shows
          what value is set in each field of the\n   WebSocket frame header.\n        0
          \                  1\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n       +-+-+-+-+-------+-+-------------+\n
          \      |F|R|R|R| opcode|M| Payload len |\n       |I|S|S|S|       |A|             |\n
          \      |N|V|V|V|       |S|             |\n       | |1|2|3|       |K|             |\n
          \      +-+-+-+-+-------+-+-------------+\n       |1|1|0|0|   1   |0|      7
          \     |\n       +-+-+-+-+-------+-+-------------+\n   Suppose that the endpoint
          sends the compressed message with\n   fragmentation.  The endpoint splits
          the compressed data into\n   fragments and builds frames for each fragment.
          \ For example, if the\n   fragments are 3 and 4 octets, the first frame
          is:\n       0x41 0x03 0xf2 0x48 0xcd\n   and the second frame is:\n       0x80
          0x04 0xc9 0xc9 0x07 0x00\n   Note that the RSV1 bit is set only on the first
          frame.\n"
        title: 7.2.3.1.  A Message Compressed Using One Compressed DEFLATE Block
      - contents:
        - "7.2.3.2.  Sharing LZ77 Sliding Window\n   Suppose that a client has sent
          a message \"Hello\" as a compressed\n   message and will send the same message
          \"Hello\" again as a compressed\n   message.\n       0xf2 0x48 0xcd 0xc9
          0xc9 0x07 0x00\n   The above is the payload of the first message that the
          client has\n   sent.  If the \"agreed parameters\" contain the\n   \"client_no_context_takeover\"
          extension parameter, the client\n   compresses the payload of the next message
          into the same bytes (if\n   the client uses the same \"BTYPE\" value and
          \"BFINAL\" value).  So, the\n   payload of the second message will be:\n
          \      0xf2 0x48 0xcd 0xc9 0xc9 0x07 0x00\n   If the \"agreed parameters\"
          did not contain the\n   \"client_no_context_takeover\" extension parameter,
          the client can\n   compress the payload of the next message into fewer bytes
          by\n   referencing the history in the LZ77 sliding window.  So, the payload\n
          \  of the second message will be:\n       0xf2 0x00 0x11 0x00 0x00\n   So,
          2 bytes are saved in total.\n   Note that even if some uncompressed messages
          (with the RSV1 bit\n   unset) are inserted between the two \"Hello\" messages,
          they don't\n   affect the LZ77 sliding window.\n"
        title: 7.2.3.2.  Sharing LZ77 Sliding Window
      - contents:
        - "7.2.3.3.  Using a DEFLATE Block with No Compression\n   A DEFLATE block
          with no compression may be used.\n       0xc1 0x0b 0x00 0x05 0x00 0xfa 0xff
          0x48 0x65 0x6c 0x6c 0x6f 0x00\n   This is a frame constituting a text message
          \"Hello\" built using a\n   DEFLATE block with no compression.  The first
          2 octets (0xc1 0x0b)\n   are the WebSocket frame header (FIN=1, RSV1=1,
          RSV2=0, RSV3=0,\n   opcode=text, MASK=0, Payload length=7).  Note that the
          RSV1 bit is\n   set for this message (only on the first fragment if the
          message is\n   fragmented) because the RSV1 bit is set when DEFLATE is applied
          to\n   the message, including the case when only DEFLATE blocks with no\n
          \  compression are used.  The 3rd to 13th octets consist of the payload\n
          \  data containing \"Hello\" compressed using a DEFLATE block with no\n
          \  compression.\n"
        title: 7.2.3.3.  Using a DEFLATE Block with No Compression
      - contents:
        - "7.2.3.4.  Using a DEFLATE Block with \"BFINAL\" Set to 1\n   On platforms
          on which the flush method using an empty DEFLATE block\n   with no compression
          is not available, implementors can choose to\n   flush data using DEFLATE
          blocks with \"BFINAL\" set to 1.\n       0xf3 0x48 0xcd 0xc9 0xc9 0x07 0x00
          0x00\n   This is the payload of a message containing \"Hello\" compressed
          using\n   a DEFLATE block with \"BFINAL\" set to 1.  The first 7 octets\n
          \  constitute a DEFLATE block with \"BFINAL\" set to 1 and \"BTYPE\" set
          to\n   01 containing \"Hello\".  The last 1 octet (0x00) contains the header\n
          \  bits with \"BFINAL\" set to 0 and \"BTYPE\" set to 00, and 5 padding
          bits\n   of 0.  This octet is necessary to allow the payload to be\n   decompressed
          in the same manner as messages flushed using DEFLATE\n   blocks with \"BFINAL\"
          unset.\n"
        title: 7.2.3.4.  Using a DEFLATE Block with "BFINAL" Set to 1
      - contents:
        - "7.2.3.5.  Two DEFLATE Blocks in One Message\n   Two or more DEFLATE blocks
          may be used in one message.\n       0xf2 0x48 0x05 0x00 0x00 0x00 0xff 0xff
          0xca 0xc9 0xc9 0x07 0x00\n   The first 3 octets (0xf2 0x48 0x05) and the
          least significant two\n   bits of the 4th octet (0x00) constitute one DEFLATE
          block with\n   \"BFINAL\" set to 0 and \"BTYPE\" set to 01 containing \"He\".
          \ The rest of\n   the 4th octet contains the header bits with \"BFINAL\"
          set to 0 and\n   \"BTYPE\" set to 00, and the 3 padding bits of 0.  Together
          with the\n   following 4 octets (0x00 0x00 0xff 0xff), the header bits constitute\n
          \  an empty DEFLATE block with no compression.  A DEFLATE block\n   containing
          \"llo\" follows the empty DEFLATE block.\n"
        title: 7.2.3.5.  Two DEFLATE Blocks in One Message
      - contents:
        - "7.2.3.6.  Generating an Empty Fragment\n   Suppose that an endpoint is
          sending data of unknown size.  The\n   endpoint may encounter the end-of-data
          signal from the data source\n   when its buffer for uncompressed data is
          empty.  In such a case, the\n   endpoint just needs to send the last fragment
          with the FIN bit set to\n   1 and the payload set to the DEFLATE block(s),
          which contains 0 bytes\n   of data.  If the compression library being used
          doesn't generate any\n   data when its buffer is empty, an empty uncompressed
          DEFLATE block\n   can be built and used for this purpose as follows:\n       0x00\n
          \  The single octet 0x00 contains the header bits with \"BFINAL\" set to
          0\n   and \"BTYPE\" set to 00, and 5 padding bits of 0.\n"
        title: 7.2.3.6.  Generating an Empty Fragment
      title: 7.2.3.  Examples
    title: 7.2.  Message Payload Transformation
  - contents:
    - "7.3.  Implementation Notes\n   On most common software development platforms,
      the DEFLATE\n   compression library provides a method for aligning compressed
      data to\n   byte boundaries using an empty DEFLATE block with no compression.\n
      \  For example, zlib [zlib] does this when \"Z_SYNC_FLUSH\" is passed to\n   the
      deflate function.\n   Some platforms may only provide methods to output and
      process\n   compressed data with a zlib header and an Adler-32 checksum.  On
      such\n   platforms, developers need to write stub code to remove and\n   complement
      the zlib and Adler-32 checksum by themselves.\n   To obtain a useful compression
      ratio, an LZ77 sliding window size of\n   1,024 or more is RECOMMENDED.\n   If
      a side disallows context takeover, its endpoint can easily figure\n   out whether
      or not a certain message will be shorter if compressed.\n   Otherwise, it's
      not easy to know whether future messages will benefit\n   from having a certain
      message compressed.  Implementors may employ\n   some heuristics to determine
      this.\n"
    title: 7.3.  Implementation Notes
  title: 7.  The "permessage-deflate" Extension
- contents:
  - "8.  Security Considerations\n   There is a known exploit when history-based compression
    is combined\n   with a secure transport [CRIME].  Implementors should pay attention\n
    \  to this point when integrating this extension with other extensions\n   or
    protocols.\n"
  title: 8.  Security Considerations
- contents:
  - '9.  IANA Considerations

    '
  - contents:
    - "9.1.  Registration of the \"permessage-deflate\" WebSocket Extension Name\n
      \  IANA has registered the following WebSocket extension name in the\n   \"WebSocket
      Extension Name Registry\" defined in [RFC6455].\n   Extension Identifier\n      permessage-deflate\n
      \  Extension Common Name\n      WebSocket Per-Message Deflate\n   Extension
      Definition\n      This document.\n   Known Incompatible Extensions\n      None\n
      \  The \"permessage-deflate\" extension name is used in the \"Sec-\n   WebSocket-Extensions\"
      header in the WebSocket opening handshake to\n   negotiate use of the \"permessage-deflate\"
      extension.\n"
    title: 9.1.  Registration of the "permessage-deflate" WebSocket Extension Name
  - contents:
    - "9.2.  Registration of the \"Per-Message Compressed\" WebSocket Framing\n      Header
      Bit\n   IANA has registered the following WebSocket framing header bit in the\n
      \  \"WebSocket Framing Header Bits Registry\" defined in [RFC6455].\n   Value\n
      \     RSV1\n   Description\n      The \"Per-Message Compressed\" bit, which
      indicates whether or not\n      the message is compressed.  RSV1 is set for
      compressed messages\n      and unset for uncompressed messages.\n   Reference\n
      \     Section 6 of this document.\n   The \"Per-Message Compressed\" framing
      header bit is used on the first\n   fragment of data messages to indicate whether
      the payload of the\n   message is compressed by the PMCE or not.\n"
    title: 9.2.  Registration of the "Per-Message Compressed" WebSocket Framing
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [CRIME]    Rizzo, J. and T. Duong, \"The CRIME
      attack\", EKOparty\n              Security Conference, September 2012.\n   [LZ77]
      \    Ziv, J. and A. Lempel, \"A Universal Algorithm for\n              Sequential
      Data Compression\", IEEE Transactions on\n              Information Theory,
      Vol. 23, No. 3, pp. 337-343,\n              DOI 10.1109/TIT.1977.1055714, May
      1977,\n              <https://www.cs.duke.edu/courses/spring03/cps296.5/papers/\n
      \             ziv_lempel_1977_universal_algorithm.pdf>.\n   [RFC1951]  Deutsch,
      P., \"DEFLATE Compressed Data Format Specification\n              version 1.3\",
      RFC 1951, DOI 10.17487/RFC1951, May 1996,\n              <http://www.rfc-editor.org/info/rfc1951>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC5234]  Crocker,
      D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n
      \             <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC6455]  Fette,
      I. and A. Melnikov, \"The WebSocket Protocol\",\n              RFC 6455, DOI
      10.17487/RFC6455, December 2011,\n              <http://www.rfc-editor.org/info/rfc6455>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC1979]  Woods, J., \"PPP Deflate Protocol\",
      RFC 1979,\n              DOI 10.17487/RFC1979, August 1996,\n              <http://www.rfc-editor.org/info/rfc1979>.\n
      \  [zlib]     Gailly, J. and M. Adler, \"zlib\", <http://www.zlib.net/>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Acknowledgements\n   Special thanks to Patrick McManus who wrote up the initial\n
    \  specification of a DEFLATE-based compression extension for the\n   WebSocket
    Protocol, which I referred to when writing this\n   specification.\n   Thanks
    to the following people who participated in discussions on the\n   HyBi WG and
    contributed ideas and/or provided detailed reviews (the\n   list is likely incomplete):
    Adam Rice, Alexander Philippou, Alexey\n   Melnikov, Arman Djusupov, Bjoern Hoehrmann,
    Brian McKelvey, Dario\n   Crivelli, Greg Wilkins, Inaki Baz Castillo, Jamie Lokier,
    Joakim\n   Erdfelt, John A. Tamplin, Julian Reschke, Kenichi Ishibashi, Mark\n
    \  Nottingham, Peter Thorson, Roberto Peon, Salvatore Loreto, Simone\n   Bordet,
    Tobias Oberstein, and Yutaka Hirano.  Note that the people\n   listed above didn't
    necessarily endorse the end result of this work.\n"
  title: Acknowledgements
- contents:
  - "Author's Address\n   Takeshi Yoshino\n   Google, Inc.\n   Email: tyoshino@google.com\n"
  title: Author's Address
