- title: __initial_text__
  contents:
  - "                 Basic Socket Interface Extensions for\n                    the\
    \ Host Identity Protocol (HIP)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines extensions to the current sockets API for\
    \ the\n   Host Identity Protocol (HIP).  The extensions focus on the use of\n\
    \   public-key-based identifiers discovered via DNS resolution, but also\n   define\
    \ interfaces for manual bindings between Host Identity Tags\n   (HITs) and locators.\
    \  With the extensions, the application can also\n   support more relaxed security\
    \ models where communication can be non-\n   HIP-based, according to local policies.\
    \  The extensions in this\n   document are experimental and provide basic tools\
    \ for further\n   experimentation with policies.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6317.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................5\n  \
    \ 3. Name Resolution Process .........................................5\n    \
    \  3.1. Interaction with the Resolver ..............................5\n      3.2.\
    \ Interaction without a Resolver .............................6\n   4. API Syntax\
    \ and Semantics ........................................7\n      4.1. Socket Family\
    \ and Address Structure Extensions .............7\n      4.2. Extensions to Resolver\
    \ Data Structures .....................9\n      4.3. The Use of getsockname()\
    \ and getpeername() Functions ......12\n      4.4. Selection of Source HIT Type\
    \ ..............................12\n      4.5. Verification of HIT Type ..................................13\n\
    \      4.6. Explicit Handling of Locators .............................14\n  \
    \ 5. Summary of New Definitions .....................................16\n   6.\
    \ Security Considerations ........................................16\n   7. Contributors\
    \ ...................................................17\n   8. Acknowledgments\
    \ ................................................17\n   9. References .....................................................17\n\
    \      9.1. Normative References ......................................17\n  \
    \    9.2. Informative References ....................................18\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines the C-based sockets Application Programming\n\
    \   Interface (API) extensions for handling HIP-based identifiers\n   explicitly\
    \ in HIP-aware applications.  It is up to the applications,\n   or high-level\
    \ programming languages or libraries, to manage the\n   identifiers.  The extensions\
    \ in this document are mainly related to\n   the use case in which a DNS resolution\
    \ step has occurred prior to the\n   creation of a new socket, and assumes that\
    \ the system has cached or\n   is otherwise able to resolve identifiers to locators\
    \ (IP addresses).\n   The DNS extension for HIP is described in [RFC5205].  The\
    \ extensions\n   also cover the case in which an application may want to explicitly\n\
    \   provide suggested locators with the identifiers, including supporting\n  \
    \ the opportunistic case in which the system does not know the peer\n   host identity.\n\
    \   The Host Identity Protocol (HIP) [RFC4423] proposes a new\n   cryptographic\
    \ namespace by separating the roles of endpoint\n   identifiers and locators by\
    \ introducing a new namespace to the TCP/IP\n   stack.  Shim6 [RFC5533] is another\
    \ protocol based on an identity-\n   locator split.  The APIs specified in this\
    \ document are specific to\n   HIP, but have been designed as much as possible\
    \ to not preclude its\n   use with other protocols.  The use of these APIs with\
    \ other protocols\n   is, nevertheless, for further study.\n   The APIs in this\
    \ document are based on Host Identity Tags (HITs) that\n   are defined as IPv6\
    \ addresses with the Overlay Routable Cryptographic\n   Hash Identifiers (ORCHID)\
    \ prefix [RFC4843].  ORCHIDs are derived from\n   Host Identifiers using a hash\
    \ and fitting the result into an IPv6\n   address.  Such addresses are called\
    \ HITs, and they can be\n   distinguished from other IPv6 addresses via the ORCHID\
    \ prefix.  Note\n   that ORCHIDs are presently an experimental allocation by IANA.\
    \  If\n   the ORCHID allocation were to expire and HIT generation were to use\
    \ a\n   different prefix in the future, most users of the API would not be\n \
    \  impacted, unless they explicitly checked the ORCHID prefix on\n   returned\
    \ HITs.  Users who check (for consistency) that HITs have a\n   valid ORCHID prefix\
    \ must monitor the IANA allocation for ORCHIDs and\n   adapt their software in\
    \ case the ORCHID allocation were to be removed\n   at a future date.\n   Applications\
    \ can observe the HIP layer and its identifiers in the\n   networking stacks with\
    \ varying degrees of visibility.  [RFC5338]\n   discusses the lowest levels of\
    \ visibility in which applications are\n   completely unaware of the underlying\
    \ HIP layer.  Such HIP-unaware\n   applications in some circumstances use HIP-based\
    \ identifiers, such as\n   Local Scope Identifiers (LSIs) or HITs, instead of\
    \ IPv4 or IPv6\n   addresses and cannot observe the identifier-locator bindings.\n\
    \   This document specifies extensions to [RFC3493] to define a new\n   socket\
    \ address family, AF_HIP.  Similarly to other address families,\n   AF_HIP can\
    \ be used as an alias for PF_HIP.  The extensions also\n   describe a new socket\
    \ address structure for sockets using HITs\n   explicitly and describe how the\
    \ socket calls in [RFC3493] are adapted\n   or extended as a result.\n   Some\
    \ applications may accept incoming communications from any\n   identifier.  Other\
    \ applications may initiate outgoing communications\n   without the knowledge\
    \ of the peer identifier in opportunistic mode\n   (Section 4.1.6 of [RFC5201])\
    \ by just relying on a peer locator.  This\n   document describes how to address\
    \ both situations using \"wildcards\"\n   as described in Section 4.1.1.\n   This\
    \ document references one additional API document [RFC6316] that\n   defines multihoming\
    \ and explicit-locator handling.  Most of the\n   extensions defined in this document\
    \ can be used independently of the\n   above document.\n   The identity-locator\
    \ split introduced by HIP introduces some policy-\n   related challenges with\
    \ datagram-oriented sockets, opportunistic\n   mode, and manual bindings between\
    \ HITs and locators.  The extensions\n   in this document are of an experimental\
    \ nature and provide basic\n   tools for experimenting with policies.  Policy-related\
    \ issues are\n   left for further experimentation.\n   To recap, the extensions\
    \ in this document have three goals.  The\n   first goal is to allow HIP-aware\
    \ applications to open sockets to\n   other hosts based on the HITs alone, presuming\
    \ that the underlying\n   system can resolve the HITs to addresses used for initial\
    \ contact.\n   The second goal is that applications can explicitly initiate\n\
    \   communications with unknown peer identifiers.  The third goal is to\n   illustrate\
    \ how HIP-aware applications can use the Shim API [RFC6316]\n   to manually map\
    \ locators to HITs.\n   This document was published as experimental because a\
    \ number of its\n   normative references had experimental status.  The success\
    \ of this\n   experiment can be evaluated by a thorough implementation of the\
    \ APIs\n   defined.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The terms used in this document are summarized in Table 1.\n\
    \   +---------+--------------------------------------------------------+\n   |\
    \ Term    | Explanation                                            |\n   +---------+--------------------------------------------------------+\n\
    \   | FQDN    | Fully Qualified Domain Name                            |\n   |\
    \ HIP     | Host Identity Protocol                                 |\n   | HI\
    \      | Host Identifier                                        |\n   | HIT  \
    \   | Host Identity Tag, a 100-bit hash of a public key with |\n   |         |\
    \ a 28-bit prefix                                        |\n   | LSI     | Local\
    \ Scope Identifier, a local, 32-bit descriptor for |\n   |         | a given public\
    \ key                                     |\n   | Locator | Routable IPv4 or IPv6\
    \ address used at the lower layers |\n   | RR      | Resource Record         \
    \                               |\n   +---------+--------------------------------------------------------+\n\
    \                                  Table 1\n"
- title: 3.  Name Resolution Process
  contents:
  - "3.  Name Resolution Process\n   This section provides an overview of how the\
    \ API can be used.  First,\n   the case in which a resolver is involved in name\
    \ resolution is\n   described, and then the case in which no resolver is involved\
    \ is\n   described.\n"
- title: 3.1.  Interaction with the Resolver
  contents:
  - "3.1.  Interaction with the Resolver\n   Before an application can establish network\
    \ communications with the\n   entity named by a given FQDN or relative hostname,\
    \ the application\n   must translate the name into the corresponding identifier(s).\
    \  DNS-\n   based hostname-to-identifier translation is illustrated in Figure\
    \ 1.\n   The application calls the resolver in step (a) to resolve an FQDN to\n\
    \   one or more socket addresses within the PF_HIP family.  The resolver,\n  \
    \ in turn, queries the DNS in step (b) to map the FQDN to one or more\n   HIP\
    \ RRs with the HIT and HI and possibly the rendezvous server of the\n   Responder,\
    \ and also (in parallel or sequentially) to resolve the FQDN\n   into possibly\
    \ one or more A and AAAA records.  It should be noted\n   that the FQDN may map\
    \ to multiple Host Identifiers and locators, and\n   this step may involve multiple\
    \ DNS transactions, including queries\n   for A, AAAA, HI, and possibly other\
    \ resource records.  The DNS server\n   responds with a list of HIP resource records\
    \ in step (c).\n   Optionally, in step (d), the resolver caches the HIT-to-locator\n\
    \   mapping with the HIP module.  The resolver converts the HIP records\n   to\
    \ HITs and returns the HITs to the application contained in HIP\n   socket address\
    \ structures in step (e).  Depending on the parameters\n   for the resolver call,\
    \ the resolver may also return other socket\n   address structures to the application.\
    \  Finally, the application\n   receives the socket address structure(s) from\
    \ the resolver and uses\n   them in socket calls such as connect() in step (f).\n\
    \                                              +----------+\n                \
    \                              |          |\n                                \
    \              |   DNS    |\n                                              | \
    \         |\n                                              +----------+\n    \
    \                                              ^  |\n                        \
    \           b. QNAME=FQDN  |  | c. HIP and\n                                 \
    \                 |  |    A/AAAA\n                                           \
    \       |  v    RR(s)\n       +-------------+ a. getaddrinfo(<FQDN>)  +----------+\n\
    \       |             |------------------------>|          |\n       | Application\
    \ |                         | Resolver |\n       |             |<------------------------|\
    \          |\n       +-------------+        e. <HITs>        +----------+\n  \
    \             |                                    |\n               |       \
    \                             | d. HIP and\n               | f. connect(<HIT>)\
    \                  |    A/AAAA\n               |    or any other socket call \
    \       |    RR(s)\n               v                                    v\n  \
    \      +----------+                           +----------+\n        |        \
    \  |                           |          |\n        |  TCP/IP  |            \
    \               |   HIP    |\n        |  Stack   |                           |\
    \          |\n        +----------+                           +----------+\n  \
    \                               Figure 1\n   In practice, the resolver functionality\
    \ can be implemented in\n   different ways.  For example, it may be implemented\
    \ in existing\n   resolver libraries or as a HIP-aware interposing agent.\n"
- title: 3.2.  Interaction without a Resolver
  contents:
  - "3.2.  Interaction without a Resolver\n   The extensions in this document focus\
    \ on the use of the resolver to\n   map hostnames to HITs and locators in HIP-aware\
    \ applications.  The\n   resolver may implicitly associate a HIT with the corresponding\n\
    \   locator(s) by communicating the HIT-to-IP mapping to the HIP daemon.\n   However,\
    \ it is possible that an application operates directly on a\n   peer HIT without\
    \ interacting with the resolver.  In such a case, the\n   application may resort\
    \ to the system to map the peer HIT to an IP\n   address.  Alternatively, the\
    \ application can explicitly map the HIT\n   to an IP address using socket options\
    \ as specified in Section 4.6.\n   Full support for all of the extensions defined\
    \ in this document\n   requires a number of shim socket options [RFC6316] to be\
    \ implemented\n   by the system.\n"
- title: 4.  API Syntax and Semantics
  contents:
  - "4.  API Syntax and Semantics\n   In this section, we describe the native HIP\
    \ APIs using the syntax of\n   the C programming language.  We limit the description\
    \ to the\n   interfaces and data structures that are either modified or completely\n\
    \   new, because the native HIP APIs are otherwise identical to the\n   sockets\
    \ API [POSIX].\n"
- title: 4.1.  Socket Family and Address Structure Extensions
  contents:
  - "4.1.  Socket Family and Address Structure Extensions\n   The sockets API extensions\
    \ define a new protocol family, PF_HIP, and\n   a new address family, AF_HIP.\
    \  The AF_HIP and PF_HIP constants are\n   aliases to each other.  These definitions\
    \ shall be defined as a\n   result of including <sys/socket.h>.\n   When the socket()\
    \ function is called with PF_HIP as the first\n   argument (domain), it attempts\
    \ to create a socket for HIP\n   communication.  If HIP is not supported, socket()\
    \ follows its default\n   behavior and returns -1, and sets errno to EAFNOSUPPORT.\n\
    \   Figure 2 shows the recommended implementation of the socket address\n   structure\
    \ for HIP in Portable Operating System Interface (POSIX)\n   format.\n       \
    \     #include <netinet/hip.h>\n            typedef struct in6_addr hip_hit_t;\n\
    \            struct sockaddr_hip {\n                      uint8_t        ship_len;\n\
    \                      sa_family_t    ship_family;\n                      in_port_t\
    \      ship_port;\n                      uint32_t       ship_flags;\n        \
    \              hip_hit_t      ship_hit;\n            };\n                    \
    \             Figure 2\n   uint8_t ship_len: This field defines the length of\
    \ the structure.\n   Implementations that do not define this field typically embed\
    \ the\n   information in the following ship_family field.\n   sa_family_t ship_family:\
    \ This mandatory field identifies the\n   structure as a sockaddr_hip structure.\
    \  It overlays the sa_family\n   field of the sockaddr structure.  Its value must\
    \ be AF_HIP.\n   in_port_t ship_port: This mandatory field contains the transport\n\
    \   protocol port number.  It is handled in the same way as the sin_port\n   field\
    \ of the sockaddr_in structure.  The port number is stored in\n   network byte\
    \ order.\n   uint32_t ship_flags: This mandatory bit field contains auxiliary\n\
    \   flags.  This document does not define any flags.  This field is\n   included\
    \ for future extensions.\n   hip_hit_t ship_hit: This mandatory field contains\
    \ the endpoint\n   identifier.  When the system passes a sockaddr_hip structure\
    \ to the\n   application, the value of this field is set to a valid HIT, IPv4,\
    \ or\n   IPv6 address, as discussed in Section 4.5.  When the application\n  \
    \ passes a sockaddr_hip structure to the system, this field must be set\n   to\
    \ a HIT or a wildcard address as discussed in Section 4.1.1.\n   Some applications\
    \ rely on system-level access control, either\n   implicit or explicit (such as\
    \ the accept_filter() function found on\n   BSD-based systems), but such discussion\
    \ is out of scope.  Other\n   applications implement access control themselves\
    \ by using the HITs.\n   Applications operating on sockaddr_hip structures can\
    \ use memcmp() or\n   a similar function to compare the ship_hit fields.  It should\
    \ also be\n   noted that different connection attempts between the same two hosts\n\
    \   can result in different HITs, because a host is allowed to have\n   multiple\
    \ HITs.\n"
- title: 4.1.1.  HIP Wildcard Addresses
  contents:
  - "4.1.1.  HIP Wildcard Addresses\n   HIP wildcard addresses are similar to IPv4\
    \ and IPv6 wildcard\n   addresses.  They can be used instead of specific HITs\
    \ in the ship_hit\n   field for local and remote endpoints in sockets API calls\
    \ such as\n   bind(), connect(), sendto(), or sendmsg().\n   In order to bind\
    \ to all local IPv4 and IPv6 addresses and HIP HITs,\n   the ship_hit field must\
    \ be set to HIP_ENDPOINT_ANY.  In order to bind\n   to all local HITs, ship_hit\
    \ must contain HIP_HIT_ANY.  To only bind\n   to all local public HITs, the ship_hit\
    \ field must be HIP_HIT_ANY_PUB.\n   The value HIP_HIT_ANY_TMP binds a socket\
    \ to all local anonymous\n   identifiers only as specified in [RFC4423].  The\
    \ system may label\n   anonymous identifiers as such depending on whether they\
    \ have been\n   published or not.  After binding a socket via one of the\n   HIP_HIT_ANY_*\
    \ wildcard addresses, the application is guaranteed to\n   receive only HIP-based\
    \ data flows.  With the HIP_ENDPOINT_ANY\n   wildcard address, the socket accepts\
    \ HIP, IPv6, and IPv4-based data\n   flows.\n   When a socket is bound or connected\
    \ via a sockaddr_hip structure,\n   i.e., the PF_HIP protocol family, the system\
    \ returns only addresses\n   of the AF_HIP family, i.e., sockaddr_hip structures,\
    \ for this socket.\n   This applies to all functions that provide addresses to\
    \ the\n   application, such as accept() or recvfrom().  If the data flow is\n\
    \   based on HIP, the ship_hit field contains the peer's HIT.  For a\n   non-HIP\
    \ IPv6 data flow, the field contains the peer's IPv6 address.\n   For a non-HIP\
    \ IPv4 data flow, the field contains the peer's IPv4\n   address in IPv4-mapped\
    \ IPv6 address format as described in\n   Section 3.7 of [RFC3493].  Section 4.5\
    \ describes how the application\n   can verify the type of address returned by\
    \ the sockets API calls.\n   An application uses the sockets API as follows to\
    \ set up a connection\n   or to send messages in HIP opportunistic mode (cf. [RFC5201]).\n\
    \   First, the application associates a socket with at least one IP\n   address\
    \ of the destination peer via setting the\n   SHIM_LOCLIST_PEER_PREF socket option.\
    \  It then uses outgoing socket\n   functions such as connect(), sendto(), or\
    \ sendmsg() with the\n   HIP_ENDPOINT_ANY or HIP_HIT_ANY wildcard address in the\
    \ ship_hit\n   field of the sockaddr_hip structure.  With the HIP_HIT_ANY address,\n\
    \   the underlying system allows only HIP-based data flows with the\n   corresponding\
    \ socket.  For incoming packets, the system discards all\n   non-HIP-related traffic\
    \ arriving at the socket.  For outgoing\n   packets, the system returns -1 in\
    \ the socket call and sets errno to\n   an appropriate error type when the system\
    \ failed to deliver the\n   packet over a HIP-based data channel.  The semantics\
    \ of using\n   HIP_ENDPOINT_ANY are the subject of further experimentation in\
    \ the\n   context of opportunistic mode.  Such use may result in a data flow\n\
    \   either with or without HIP.\n"
- title: 4.2.  Extensions to Resolver Data Structures
  contents:
  - "4.2.  Extensions to Resolver Data Structures\n   The HIP APIs introduce a new\
    \ address family, AF_HIP, that HIP-aware\n   applications can use to control the\
    \ address type returned from the\n   getaddrinfo() function [RFC3493] [POSIX].\
    \  The getaddrinfo() function\n   uses a data structure called addrinfo in its\
    \ \"hints\" and \"res\"\n   arguments, which are described in more detail in the\
    \ next section.\n   The addrinfo data structure is illustrated in Figure 3.\n\
    \        #include <netdb.h>\n        struct addrinfo {\n            int      \
    \ ai_flags;          /* e.g., AI_CANONNAME */\n            int       ai_family;\
    \         /* e.g., AF_HIP */\n            int       ai_socktype;       /* e.g.,\
    \ SOCK_STREAM */\n            int       ai_protocol;       /* 0 or IPPROTO_HIP\
    \ */\n            socklen_t ai_addrlen;        /* size of *ai_addr  */\n     \
    \       struct    sockaddr *ai_addr; /* sockaddr_hip */\n            char    \
    \ *ai_canonname;      /* canon. name of the host */\n            struct    addrinfo\
    \ *ai_next; /* next endpoint */\n            int       ai_eflags;         /* RFC\
    \ 5014 extension */\n        };\n                                 Figure 3\n \
    \  An application resolving with the ai_family field set to AF_UNSPEC in\n   the\
    \ hints argument may receive any kind of socket address structures,\n   including\
    \ sockaddr_hip.  When the application wants to receive only\n   HITs contained\
    \ in sockaddr_hip structures, it should set the\n   ai_family field to AF_HIP.\
    \  Otherwise, the resolver does not return\n   any sockaddr_hip structures.  The\
    \ resolver returns EAI_FAMILY when\n   AF_HIP is requested but not supported.\n\
    \   The resolver ignores the AI_PASSIVE flag when the application sets\n   the\
    \ family in hints to AF_HIP.\n   The system may have a HIP-aware interposing DNS\
    \ agent as described in\n   Section 3.2 of [RFC5338].  In such a case, the DNS\
    \ agent may,\n   according to local policy, transparently return LSIs or HITs\
    \ in\n   sockaddr_in and sockaddr_in6 structures when available.  A HIP-aware\n\
    \   application can override this local policy in two ways.  First, the\n   application\
    \ can set the family to AF_HIP in the hints argument of\n   getaddrinfo() when\
    \ it requests only sockaddr_hip structures.  Second,\n   the application can set\
    \ the AI_NO_HIT flag to prevent the resolver\n   from returning HITs in any kind\
    \ of data structures.\n   When getaddrinfo() returns resolved outputs in the output\
    \ \"res\"\n   argument, it sets the family to AF_HIP when the related structure\
    \ is\n   sockaddr_hip.\n"
- title: 4.2.1.  Resolver Usage
  contents:
  - "4.2.1.  Resolver Usage\n   A HIP-aware application creates the sockaddr_hip structures\
    \ manually\n   or obtains them from the resolver.  The explicit configuration\
    \ of\n   locators is described in [RFC6316].  This document defines\n   \"automated\"\
    \ resolver extensions for the getaddrinfo() resolver\n   [RFC3493].  Other resolver\
    \ calls, such as gethostbyname() and\n   getservbyname(), are not defined in this\
    \ document.  The getaddrinfo()\n   resolver interface is shown in Figure 4.\n\
    \            #include <netdb.h>\n            int getaddrinfo(const char *nodename,\n\
    \                            const char *servname,\n                         \
    \   const struct addrinfo *hints,\n                            struct addrinfo\
    \ **res)\n            void free_addrinfo(struct addrinfo *res)\n             \
    \                    Figure 4\n   As described in [RFC3493], the getaddrinfo()\
    \ function takes nodename,\n   servname, and hints as its input arguments.  It\
    \ places the result of\n   the query into the res output argument.  The return\
    \ value is zero on\n   success, or a non-zero error value on error.  The nodename\
    \ argument\n   specifies the hostname to be resolved; a NULL argument denotes\
    \ the\n   HITs of the local host.  The servname parameter declares the port\n\
    \   number to be set in the socket addresses in the res output argument.\n   The\
    \ nodename and servname arguments cannot both be NULL at the same\n   time.\n\
    \   The input argument \"hints\" acts like a filter that defines the\n   attributes\
    \ required from the resolved endpoints.  A NULL hints\n   argument indicates that\
    \ any kind of endpoint is acceptable.\n   The output argument \"res\" is dynamically\
    \ allocated by the resolver.\n   The application frees the res argument with the\
    \ free_addrinfo\n   function.  The res argument contains a linked list of the\
    \ resolved\n   endpoints.  The linked list contains only sockaddr_hip structures\n\
    \   when the input argument has the family set to AF_HIP.  When the\n   family\
    \ is zero, the list contains sockaddr_hip structures before\n   sockaddr_in and\
    \ sockaddr_in6 structures.\n   The resolver can return a HIT that maps to multiple\
    \ locators.  The\n   resolver may cache the locator mappings with the HIP module.\
    \  The HIP\n   module manages the multiple locators according to system policies\
    \ of\n   the host.  The multihoming document [RFC6316] describes how an\n   application\
    \ can override system default policies.\n   It should be noted that the application\
    \ can configure the HIT\n   explicitly without setting the locator, or the resolver\
    \ can fail to\n   resolve any locator.  In this scenario, the application relies\
    \ on the\n   system to map the HIT to an IP address.  When the system fails to\n\
    \   provide the mapping, it returns -1 in the called sockets API function\n  \
    \ to the application and sets errno to EADDRNOTAVAIL.\n"
- title: 4.3.  The Use of getsockname() and getpeername() Functions
  contents:
  - "4.3.  The Use of getsockname() and getpeername() Functions\n   The sockaddr_hip\
    \ structure does not contain a HIT when the\n   application uses the HIP_HIT_ANY_*\
    \ or HIP_ENDPOINT_ANY constants.  In\n   such a case, the application can discover\
    \ the local and peer HITs\n   using the getsockname() and getpeername() functions\
    \ after the socket\n   is connected.  The functions getsockname() and getpeername()\
    \ always\n   output a sockaddr_hip structure when the family of the socket is\n\
    \   AF_HIP.  The application should be prepared to also handle IPv4 and\n   IPv6\
    \ addresses in the ship_hit field, as described in Section 4.1, in\n   the context\
    \ of the HIP_ENDPOINT_ANY constant.\n"
- title: 4.4.  Selection of Source HIT Type
  contents:
  - "4.4.  Selection of Source HIT Type\n   A client-side application can choose its\
    \ source HIT by, for example,\n   querying all of the local HITs with getaddrinfo()\
    \ and associating one\n   of them with the socket using bind().  This section\
    \ describes another\n   method for a client-side application to affect the selection\
    \ of the\n   source HIT type where the application does not call bind()\n   explicitly.\
    \  Instead, the application just specifies the preferred\n   requirements for\
    \ the source HIT type.\n   The sockets API for source address selection [RFC5014]\
    \ defines socket\n   options to allow applications to influence source address\
    \ selection\n   mechanisms.  In some cases, HIP-aware applications may want to\n\
    \   influence source HIT selection, in particular whether an outbound\n   connection\
    \ should use a published or anonymous HIT.  Similar to\n   IPV6_ADDR_PREFERENCES\
    \ defined in [RFC5014], the socket option\n   HIT_PREFERENCES is defined for HIP-based\
    \ sockets.  This socket option\n   can be used with setsockopt() and getsockopt()\
    \ calls to set and get\n   the HIT selection preferences affecting a HIP-enabled\
    \ socket.  The\n   socket option value (optval) is a 32-bit unsigned integer argument.\n\
    \   The argument consists of a number of flags where each flag indicates\n   an\
    \ address selection preference that modifies one of the rules in the\n   default\
    \ HIT selection; these flags are shown in Table 2.\n          +---------------------------+-------------------------+\n\
    \          | Socket Option             | Purpose                 |\n         \
    \ +---------------------------+-------------------------+\n          | HIP_PREFER_SRC_HIT_TMP\
    \    | Prefer an anonymous HIT |\n          | HIP_PREFER_SRC_HIT_PUBLIC | Prefer\
    \ a public HIT     |\n          +---------------------------+-------------------------+\n\
    \                                  Table 2\n   If the system is unable to assign\
    \ the type of HIT that is requested,\n   at HIT selection time, the socket call\
    \ (connect(), sendto(), or\n   sendmsg()) will fail, and errno will be set to\
    \ EINVAL.  If the\n   application tries to set both of the above flags for the\
    \ same socket,\n   this also results in the error EINVAL.\n"
- title: 4.5.  Verification of HIT Type
  contents:
  - "4.5.  Verification of HIT Type\n   An application that uses the HIP_ENDPOINT_ANY\
    \ constant may want to\n   check whether the actual communication was based on\
    \ HIP or not.\n   Also, the application may want to verify whether a HIT belonging\
    \ to\n   the local host is public or anonymous.  The application accomplishes\n\
    \   this using a new function called sockaddr_is_srcaddr(), which is\n   illustrated\
    \ in Figure 5.\n         #include <netinet/hip.h>\n         short sockaddr_is_srcaddr(struct\
    \ sockaddr *srcaddr,\n                                   uint64_t flags);\n  \
    \                               Figure 5\n   The sockaddr_is_srcaddr() function\
    \ operates in the same way as the\n   inet6_is_srcaddr() function [RFC5014], which\
    \ can be used to verify\n   the type of an address belonging to the local host.\
    \  The difference\n   is that the sockaddr_is_srcaddr() function handles sockaddr_hip\n\
    \   structures in addition to sockaddr_in6, and possibly other socket\n   structures\
    \ in further extensions.  Also, the length of the flags\n   argument is 64 bits\
    \ instead of 32 bits, because the new function\n   handles the same flags as defined\
    \ in [RFC5014], in addition to two\n   HIP-specific flags, HIP_PREFER_SRC_HIT_TMP\
    \ and\n   HIP_PREFER_SRC_HIT_PUBLIC.  With these two flags, the application can\n\
    \   distinguish anonymous HITs from public HITs.\n   When given an AF_INET6 socket,\
    \ sockaddr_is_srcaddr() behaves the same\n   way as the inet6_is_srcaddr() function\
    \ as described in [RFC5014].\n   With an AF_HIP socket, the function returns 1\
    \ when the HIT contained\n   in the socket address structure corresponds to a\
    \ valid HIT of the\n   local host and the HIT satisfies the given flags.  The\
    \ function\n   returns -1 when the HIT does not belong to the local host or the\n\
    \   flags are not valid.  The function returns 0 when the preference\n   flags\
    \ are valid but the HIT does not match the given flags.  The\n   function also\
    \ returns 0 on a sockaddr_hip structure containing a\n   HIP_ENDPOINT_ANY or HIP_HIT_ANY_*\
    \ wildcard.\n   The sockaddr_is_srcaddr() interface applies only to local HITs.\n\
    \   Applications can call the function hip_is_hit() to verify that the\n   given\
    \ hit_hit_t pointer has the HIT prefix.  The function is\n   illustrated in Figure\
    \ 6.\n         #include <netinet/hip.h>\n         short hip_is_hit(hip_hit_t *hit);\n\
    \                                 Figure 6\n   The hip_is_hit() function returns\
    \ 1 when the given argument contains\n   the HIT prefix.  The function returns\
    \ -1 on error and sets errno\n   appropriately.  The function returns 0 when the\
    \ argument does not\n   have the HIT prefix.  The function also returns 0 when\
    \ the argument\n   is a HIP_ENDPOINT_ANY or HIP_HIT_ANY_* wildcard.\n"
- title: 4.6.  Explicit Handling of Locators
  contents:
  - "4.6.  Explicit Handling of Locators\n   The system resolver, or the HIP module,\
    \ maps HITs to locators\n   implicitly.  However, some applications may want to\
    \ specify initial\n   locator mappings explicitly.  In such a case, the application\
    \ first\n   creates a socket with AF_HIP as the domain argument.  Second, the\n\
    \   application may get or set locator information with one of the\n   following\
    \ shim socket options as defined in the multihoming\n   extensions in [RFC6316].\
    \  The related socket options are summarized\n   briefly in Table 3.\n   +---------------------+---------------------------------------------+\n\
    \   | optname             | description                                 |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ SHIM_LOC_LOCAL_PREF | Get or set the preferred locator on the     |\n   |  \
    \                   | local side for the context associated with  |\n   |    \
    \                 | the socket.                                 |\n   | SHIM_LOC_PEER_PREF\
    \  | Get or set the preferred locator on the     |\n   |                     |\
    \ remote side for the context associated with |\n   |                     | the\
    \ socket.                                 |\n   | SHIM_LOCLIST_LOCAL  | Get or\
    \ set a list of locators associated    |\n   |                     | with the\
    \ local Endpoint Identifier (EID).   |\n   | SHIM_LOCLIST_PEER   | Get or set\
    \ a list of locators associated    |\n   |                     | with the peer's\
    \ EID.                        |\n   | SHIM_LOC_LOCAL_SEND | Set or get the default\
    \ source locator of    |\n   |                     | outgoing IP packets.    \
    \                    |\n   | SHIM_LOC_PEER_SEND  | Set or get the default destination\
    \ locator  |\n   |                     | of outgoing IP packets.             \
    \        |\n   +---------------------+---------------------------------------------+\n\
    \                                  Table 3\n   As an example of locator mappings,\
    \ a connection-oriented application\n   creates a HIP-based socket and sets the\
    \ SHIM_LOCLIST_PEER socket\n   option on the socket.  The HIP module uses the\
    \ first address\n   contained in the option if multiple addresses are provided.\
    \  If the\n   application provides one or more addresses in the SHIM_LOCLIST_PEER\n\
    \   setsockopt call, the system should not connect to the host via\n   another\
    \ destination address, in case the application intends to\n   restrict the range\
    \ of addresses permissible as a policy choice.  The\n   application can override\
    \ the default peer locator by setting the\n   SHIM_LOC_PEER_PREF socket option\
    \ if necessary.  Finally, the\n   application provides a specific HIT in the ship_hit\
    \ field of the\n   sockaddr_hip in the connect() system call.  If the system cannot\n\
    \   reach the HIT at one of the addresses provided, the outbound sockets\n   API\
    \ functions (connect(), sendmsg(), etc.) return -1 and set errno to\n   EINVALIDLOCATOR.\n\
    \   Applications may also choose to associate local addresses with\n   sockets.\
    \  The procedures specified in [RFC6316] are followed in this\n   case.\n   Another\
    \ use case is to use the opportunistic mode when the\n   destination HIT is specified\
    \ as a wildcard.  The application sets one\n   or more destination addresses using\
    \ the SHIM_LOCLIST_PEER socket\n   option as described earlier in this section,\
    \ and then calls connect()\n   with the wildcard HIT.  The connect() call returns\
    \ -1 and sets errno\n   to EADDRNOTAVAIL when the application connects to a wildcard\
    \ without\n   specifying any destination address.\n   Applications using datagram-oriented\
    \ sockets can use ancillary data\n   to control the locators, as described in\
    \ detail in [RFC6316].\n"
- title: 5.  Summary of New Definitions
  contents:
  - "5.  Summary of New Definitions\n   Table 4 summarizes the new constants and structures\
    \ defined in this\n   document.\n                +-----------------+-----------------------+\n\
    \                | Header          | Definition            |\n               \
    \ +-----------------+-----------------------+\n                | <sys/socket.h>\
    \  | AF_HIP                |\n                | <sys/socket.h>  | PF_HIP     \
    \           |\n                | <netinet/in.h>  | IPPROTO_HIP           |\n \
    \               | <netinet/hip.h> | HIP_HIT_ANY           |\n                |\
    \ <netinet/hip.h> | HIP_HIT_ANY_PUB       |\n                | <netinet/hip.h>\
    \ | HIP_HIT_ANY_TMP       |\n                | <netinet/hip.h> | HIP_ENDPOINT_ANY\
    \      |\n                | <netinet/hip.h> | HIP_HIT_PREFERENCES   |\n      \
    \          | <netinet/hip.h> | hip_hit_t             |\n                | <netdb.h>\
    \       | AI_NO_HIT             |\n                | <netinet/hip.h> | sockaddr_hip\
    \          |\n                | <netinet/hip.h> | sockaddr_is_srcaddr() |\n  \
    \              | <netinet/hip.h> | hip_is_hit()          |\n                +-----------------+-----------------------+\n\
    \                                  Table 4\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This document describes an API for HIP and therefore\
    \ depends on the\n   mechanisms defined in the HIP protocol suite.  Security concerns\n\
    \   associated with HIP itself are specified in [RFC4423], [RFC4843],\n   [RFC5201],\
    \ [RFC5205], and [RFC5338].\n   The HIP_ENDPOINT_ANY constant can be used to accept\
    \ incoming data\n   flows or create outgoing data flows without HIP.  The application\n\
    \   should use the sockaddr_is_srcaddr() function to validate the type of\n  \
    \ connection in order to, for example, inform the user of the lack of\n   HIP-based\
    \ security.  The use of the HIP_HIT_ANY_* constants is\n   recommended in security-critical\
    \ applications and systems.\n   It should be noted that the wildcards described\
    \ in this document are\n   not suitable for identifying end hosts.  Instead, applications\
    \ should\n   use getsockname() and getpeername() as described in Section 4.3 to\n\
    \   identify an end host.\n   Future proofing of HITs was discussed during the\
    \ design of this API.\n   If HITs longer than 128 bits are required at the application\
    \ layer,\n   this will require explicit support from the applications, because\n\
    \   they can store or cache HITs with their explicit sizes.  To support\n   longer\
    \ HITs, further extensions of this API may define an additional\n   flag for getaddrinfo()\
    \ to generate different kinds of socket address\n   structures for HIP.\n"
- title: 7.  Contributors
  contents:
  - "7.  Contributors\n   Thanks to Jukka Ylitalo and Pekka Nikander for their original\n\
    \   contributions, time, and effort to the native HIP APIs.  Thanks to\n   Yoshifuji\
    \ Hideaki and Stefan Goetz for their contributions to this\n   document.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   Kristian Slavov, Julien Laganier, Jaakko Kangasharju,\
    \ Mika Kousa, Jan\n   Melen, Andrew McGregor, Sasu Tarkoma, Lars Eggert, Joe Touch,\
    \ Antti\n   Jarvinen, Anthony Joseph, Teemu Koponen, Jari Arkko, Ari Keranen,\n\
    \   Juha-Matti Tapio, Shinta Sugimoto, Philip Matthews, Joakim Koskela,\n   Jeff\
    \ Ahrenholz, Tobias Heer, and Gonzalo Camarillo have provided\n   valuable ideas\
    \ and feedback.  Thanks to Nick Stoughton from the\n   Austin group for POSIX-related\
    \ comments.  Thanks also to the APPS\n   area folks, including Stephane Bortzmeyer,\
    \ Chris Newman, Tony Finch,\n   \"der Mouse\", and Keith Moore.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [POSIX]     \"IEEE Std. 1003.1-2008 Standard for\
    \ Information\n               Technology -- Portable Operating System Interface\n\
    \               (POSIX).  Open group Technical Standard: Base\n              \
    \ Specifications, Issue 7\", September 2008,\n               <http://www.opengroup.org/austin>.\n\
    \   [RFC3493]   Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.\n   \
    \            Stevens, \"Basic Socket Interface Extensions for IPv6\",\n      \
    \         RFC 3493, February 2003.\n   [RFC4423]   Moskowitz, R. and P. Nikander,\
    \ \"Host Identity Protocol\n               (HIP) Architecture\", RFC 4423, May\
    \ 2006.\n   [RFC4843]   Nikander, P., Laganier, J., and F. Dupont, \"An IPv6\n\
    \               Prefix for Overlay Routable Cryptographic Hash\n             \
    \  Identifiers (ORCHID)\", RFC 4843, April 2007.\n   [RFC5014]   Nordmark, E.,\
    \ Chakrabarti, S., and J. Laganier, \"IPv6\n               Socket API for Source\
    \ Address Selection\", RFC 5014,\n               September 2007.\n   [RFC5201]\
    \   Moskowitz, R., Nikander, P., Jokela, P., Ed., and T.\n               Henderson,\
    \ \"Host Identity Protocol\", RFC 5201, April\n               2008.\n   [RFC5205]\
    \   Nikander, P. and J. Laganier, \"Host Identity Protocol\n               (HIP)\
    \ Domain Name System (DNS) Extensions\", RFC 5205,\n               April 2008.\n\
    \   [RFC5338]   Henderson, T., Nikander, P., and M. Komu, \"Using the Host\n \
    \              Identity Protocol with Legacy Applications\", RFC 5338,\n     \
    \          September 2008.\n   [RFC6316]   Komu, M., Bagnulo, M., Slavov, K.,\
    \ and S. Sugimoto, Ed.,\n               \"Sockets Application Program Interface\
    \ (API) for\n               Multihoming Shim\", RFC 6316, July 2011.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [RFC5533]   Nordmark, E. and M. Bagnulo, \"\
    Shim6: Level 3 Multihoming\n               Shim Protocol for IPv6\", RFC 5533,\
    \ June 2009.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Miika Komu\n   Aalto University\n   Espoo\n   Finland\n\
    \   Phone: +358505734395\n   Fax:   +358947025014\n   EMail: miika@iki.fi\n  \
    \ URI: http://cse.aalto.fi/research/groups/datacommunications/people/\n   Thomas\
    \ Henderson\n   The Boeing Company\n   P.O. Box 3707\n   Seattle, WA\n   USA\n\
    \   EMail: thomas.r.henderson@boeing.com\n"
