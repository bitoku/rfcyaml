- title: __initial_text__
  contents:
  - "         DNS64: DNS Extensions for Network Address Translation\n            \
    \       from IPv6 Clients to IPv4 Servers\n"
- title: Abstract
  contents:
  - "Abstract\n   DNS64 is a mechanism for synthesizing AAAA records from A records.\n\
    \   DNS64 is used with an IPv6/IPv4 translator to enable client-server\n   communication\
    \ between an IPv6-only client and an IPv4-only server,\n   without requiring any\
    \ changes to either the IPv6 or the IPv4 node,\n   for the class of applications\
    \ that work through NATs.  This document\n   specifies DNS64, and provides suggestions\
    \ on how it should be\n   deployed in conjunction with IPv6/IPv4 translators.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6147.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Overview ........................................................5\n  \
    \ 3. Background to DNS64-DNSSEC Interaction ..........................7\n   4.\
    \ Terminology .....................................................9\n   5. DNS64\
    \ Normative Specification ..................................10\n      5.1. Resolving\
    \ AAAA Queries and the Answer Section .............11\n           5.1.1. The Answer\
    \ when There is AAAA Data Available .......11\n           5.1.2. The Answer when\
    \ There is an Error ..................11\n           5.1.3. Dealing with Timeouts\
    \ ..............................12\n           5.1.4. Special Exclusion Set for\
    \ AAAA Records .............12\n           5.1.5. Dealing with CNAME and DNAME\
    \ .......................12\n           5.1.6. Data for the Answer when Performing\
    \ Synthesis ......13\n           5.1.7. Performing the Synthesis ...........................13\n\
    \           5.1.8. Querying in Parallel ...............................14\n  \
    \    5.2. Generation of the IPv6 Representations of IPv4 Addresses ..14\n    \
    \  5.3. Handling Other Resource Records and the Additional\n           Section\
    \ ...................................................15\n           5.3.1. PTR\
    \ Resource Record ................................15\n           5.3.2. Handling\
    \ the Additional Section ....................16\n           5.3.3. Other Resource\
    \ Records .............................17\n      5.4. Assembling a Synthesized\
    \ Response to a AAAA Query .........17\n      5.5. DNSSEC Processing: DNS64 in\
    \ Validating Resolver Mode ......17\n   6. Deployment Notes ...............................................19\n\
    \      6.1. DNS Resolvers and DNS64 ...................................19\n  \
    \    6.2. DNSSEC Validators and DNS64 ...............................19\n    \
    \  6.3. DNS64 and Multihomed and Dual-Stack Hosts .................19\n      \
    \     6.3.1. IPv6 Multihomed Hosts ..............................19\n        \
    \   6.3.2. Accidental Dual-Stack DNS64 Use ....................20\n          \
    \ 6.3.3. Intentional Dual-Stack DNS64 Use ...................21\n   7. Deployment\
    \ Scenarios and Examples ..............................21\n      7.1. Example\
    \ of \"an IPv6 Network to the IPv4 Internet\"\n           Setup with DNS64 in\
    \ DNS Server Mode .......................22\n      7.2. Example of \"an IPv6 Network\
    \ to the IPv4 Internet\"\n           Setup with DNS64 in Stub-Resolver Mode ....................23\n\
    \      7.3. Example of \"the IPv6 Internet to an IPv4 Network\"\n           Setup\
    \ with DNS64 in DNS Server Mode .......................24\n   8. Security Considerations\
    \ ........................................27\n   9. Contributors ...................................................27\n\
    \   10. Acknowledgements ..............................................27\n  \
    \ 11. References ....................................................28\n    \
    \  11.1. Normative References .....................................28\n      11.2.\
    \ Informative References ...................................28\n   Appendix A.\
    \  Motivations and Implications of Synthesizing AAAA\n                Resource\
    \ Records when Real AAAA Resource Records\n                Exist ................................................30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies DNS64, a mechanism that is part\
    \ of the\n   toolbox for IPv4-IPv6 transition and coexistence.  DNS64, used\n\
    \   together with an IPv6/IPv4 translator such as stateful NAT64\n   [RFC6146],\
    \ allows an IPv6-only client to initiate communications by\n   name to an IPv4-only\
    \ server.\n   DNS64 is a mechanism for synthesizing AAAA resource records (RRs)\n\
    \   from A RRs.  A synthetic AAAA RR created by the DNS64 from an\n   original\
    \ A RR contains the same owner name of the original A RR, but\n   it contains\
    \ an IPv6 address instead of an IPv4 address.  The IPv6\n   address is an IPv6\
    \ representation of the IPv4 address contained in\n   the original A RR.  The\
    \ IPv6 representation of the IPv4 address is\n   algorithmically generated from\
    \ the IPv4 address returned in the A RR\n   and a set of parameters configured\
    \ in the DNS64 (typically, an IPv6\n   prefix used by IPv6 representations of\
    \ IPv4 addresses and,\n   optionally, other parameters).\n   Together with an\
    \ IPv6/IPv4 translator, these two mechanisms allow an\n   IPv6-only client to\
    \ initiate communications to an IPv4-only server\n   using the Fully Qualified\
    \ Domain Name (FQDN) of the server.\n   These mechanisms are expected to play\
    \ a critical role in the IPv4-\n   IPv6 transition and coexistence.  Due to IPv4\
    \ address depletion, it\n   is likely that in the future, many IPv6-only clients\
    \ will want to\n   connect to IPv4-only servers.  In the typical case, the approach\
    \ only\n   requires the deployment of IPv6/IPv4 translators that connect an\n\
    \   IPv6-only network to an IPv4-only network, along with the deployment\n   of\
    \ one or more DNS64-enabled name servers.  However, some features\n   require\
    \ performing the DNS64 function directly in the end hosts\n   themselves.\n  \
    \ This document is structured as follows: Section 2 provides a\n   non-normative\
    \ overview of the behavior of DNS64.  Section 3 provides\n   a non-normative background\
    \ required to understand the interaction\n   between DNS64 and DNS Security Extensions\
    \ (DNSSEC).  The normative\n   specification of DNS64 is provided in Sections\
    \ 4, 5, and 6.\n   Section 4 defines the terminology, Section 5 is the actual\
    \ DNS64\n   specification, and Section 6 covers deployment issues.  Section 7\
    \ is\n   non-normative and provides a set of examples and typical deployment\n\
    \   scenarios.\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   This section provides an introduction to the DNS64 mechanism.\n\
    \   We assume that we have one or more IPv6/IPv4 translator boxes\n   connecting\
    \ an IPv4 network and an IPv6 network.  The IPv6/IPv4\n   translator device provides\
    \ translation services between the two\n   networks, enabling communication between\
    \ IPv4-only hosts and\n   IPv6-only hosts.  (NOTE: By \"IPv6-only hosts\", we\
    \ mean hosts running\n   IPv6-only applications and hosts that can only use IPv6,\
    \ as well as\n   cases where only IPv6 connectivity is available to the client.\
    \  By\n   \"IPv4-only servers\", we mean servers running IPv4-only applications\n\
    \   and servers that can only use IPv4, as well as cases where only IPv4\n   connectivity\
    \ is available to the server).  Each IPv6/IPv4 translator\n   used in conjunction\
    \ with DNS64 must allow communications initiated\n   from the IPv6-only host to\
    \ the IPv4-only host.\n   To allow an IPv6 initiator to do a standard AAAA RR\
    \ DNS lookup to\n   learn the address of the responder, DNS64 is used to synthesize\
    \ a\n   AAAA record from an A record containing a real IPv4 address of the\n \
    \  responder, whenever the DNS64 cannot retrieve a AAAA record for the\n   queried\
    \ name.  The DNS64 service appears as a regular DNS server or\n   resolver to\
    \ the IPv6 initiator.  The DNS64 receives a AAAA DNS query\n   generated by the\
    \ IPv6 initiator.  It first attempts a resolution for\n   the requested AAAA records.\
    \  If there are no AAAA records available\n   for the target node (which is the\
    \ normal case when the target node is\n   an IPv4-only node), DNS64 performs a\
    \ query for A records.  For each A\n   record discovered, DNS64 creates a synthetic\
    \ AAAA RR from the\n   information retrieved in the A RR.\n   The owner name of\
    \ a synthetic AAAA RR is the same as that of the\n   original A RR, but an IPv6\
    \ representation of the IPv4 address\n   contained in the original A RR is included\
    \ in the AAAA RR.  The IPv6\n   representation of the IPv4 address is algorithmically\
    \ generated from\n   the IPv4 address and additional parameters configured in\
    \ the DNS64.\n   Among those parameters configured in the DNS64, there is at least\
    \ one\n   IPv6 prefix.  If not explicitly mentioned, all prefixes are treated\n\
    \   equally, and the operations described in this document are performed\n   using\
    \ the prefixes available.  So as to be general, we will call any\n   of these\
    \ prefixes Pref64::/n, and describe the operations made with\n   the generic prefix\
    \ Pref64::/n.  The IPv6 addresses representing IPv4\n   addresses included in\
    \ the AAAA RR synthesized by the DNS64 contain\n   Pref64::/n, and they also embed\
    \ the original IPv4 address.\n   The same algorithm and the same Pref64::/n prefix(es)\
    \ must be\n   configured both in the DNS64 device and the IPv6/IPv4 translator(s),\n\
    \   so that both can algorithmically generate the same IPv6\n   representation\
    \ for a given IPv4 address.  In addition, it is required\n   that IPv6 packets\
    \ addressed to an IPv6 destination address that\n   contains the Pref64::/n be\
    \ delivered to an IPv6/IPv4 translator that\n   has that particular Pref64::/n\
    \ configured, so they can be translated\n   into IPv4 packets.\n   Once the DNS64\
    \ has synthesized the AAAA RRs, the synthetic AAAA RRs\n   are passed back to\
    \ the IPv6 initiator, which will initiate an IPv6\n   communication with the IPv6\
    \ address associated with the IPv4\n   receiver.  The packet will be routed to\
    \ an IPv6/IPv4 translator,\n   which will forward it to the IPv4 network.\n  \
    \ In general, the only shared state between the DNS64 and the IPv6/IPv4\n   translator\
    \ is the Pref64::/n and an optional set of static\n   parameters.  The Pref64::/n\
    \ and the set of static parameters must be\n   configured to be the same on both;\
    \ there is no communication between\n   the DNS64 device and IPv6/IPv4 translator\
    \ functions.  The mechanism\n   to be used for configuring the parameters of the\
    \ DNS64 is beyond the\n   scope of this memo.\n   The prefixes to be used as Pref64::/n\
    \ and their applicability are\n   discussed in [RFC6052].  There are two types\
    \ of prefixes that can be\n   used as Pref64::/n.\n   o  The Pref64::/n can be\
    \ the Well-Known Prefix 64:ff9b::/96 reserved\n      by [RFC6052] for the purpose\
    \ of representing IPv4 addresses in\n      IPv6 address space.\n   o  The Pref64::/n\
    \ can be a Network-Specific Prefix (NSP).  An NSP is\n      an IPv6 prefix assigned\
    \ by an organization to create IPv6\n      representations of IPv4 addresses.\n\
    \   The main difference in the nature of the two types of prefixes is\n   that\
    \ the NSP is a locally assigned prefix that is under control of\n   the organization\
    \ that is providing the translation services, while\n   the Well-Known Prefix\
    \ is a prefix that has a global meaning since it\n   has been assigned for the\
    \ specific purpose of representing IPv4\n   addresses in IPv6 address space.\n\
    \   The DNS64 function can be performed in any of three places.  The\n   terms\
    \ below are more formally defined in Section 4.\n   The first option is to locate\
    \ the DNS64 function in authoritative\n   servers for a zone.  In this case, the\
    \ authoritative server provides\n   synthetic AAAA RRs for an IPv4-only host in\
    \ its zone.  This is one\n   type of DNS64 server.\n   Another option is to locate\
    \ the DNS64 function in recursive name\n   servers serving end hosts.  In this\
    \ case, when an IPv6-only host\n   queries the name server for AAAA RRs for an\
    \ IPv4-only host, the name\n   server can perform the synthesis of AAAA RRs and\
    \ pass them back to\n   the IPv6-only initiator.  The main advantage of this mode\
    \ is that\n   current IPv6 nodes can use this mechanism without requiring any\n\
    \   modification.  This mode is called \"DNS64 in DNS recursive-resolver\n   mode\"\
    .  This is a second type of DNS64 server, and it is also one\n   type of DNS64\
    \ resolver.\n   The last option is to place the DNS64 function in the end hosts,\n\
    \   coupled to the local (stub) resolver.  In this case, the stub\n   resolver\
    \ will try to obtain (real) AAAA RRs, and in case they are not\n   available,\
    \ the DNS64 function will synthesize AAAA RRs for internal\n   usage.  This mode\
    \ is compatible with some functions like DNSSEC\n   validation in the end host.\
    \  The main drawback of this mode is its\n   deployability, since it requires\
    \ changes in the end hosts.  This mode\n   is called \"DNS64 in stub-resolver\
    \ mode\".  This is the second type of\n   DNS64 resolver.\n"
- title: 3.  Background to DNS64-DNSSEC Interaction
  contents:
  - "3.  Background to DNS64-DNSSEC Interaction\n   DNSSEC ([RFC4033], [RFC4034],\
    \ [RFC4035]) presents a special challenge\n   for DNS64, because DNSSEC is designed\
    \ to detect changes to DNS\n   answers, and DNS64 may alter answers coming from\
    \ an authoritative\n   server.\n   A recursive resolver can be security-aware\
    \ or security-oblivious.\n   Moreover, a security-aware recursive resolver can\
    \ be validating or\n   non-validating, according to operator policy.  In the cases\
    \ below,\n   the recursive resolver is also performing DNS64, and has a local\n\
    \   policy to validate.  We call this general case vDNS64, but in all the\n  \
    \ cases below, the DNS64 functionality should be assumed to be needed.\n   DNSSEC\
    \ includes some signaling bits that offer some indicators of\n   what the query\
    \ originator understands.\n   If a query arrives at a vDNS64 device with the \"\
    DNSSEC OK\" (DO) bit\n   set, the query originator is signaling that it understands\
    \ DNSSEC.\n   The DO bit does not indicate that the query originator will validate\n\
    \   the response.  It only means that the query originator can understand\n  \
    \ responses containing DNSSEC data.  Conversely, if the DO bit is\n   clear, that\
    \ is evidence that the querying agent is not aware of\n   DNSSEC.\n   If a query\
    \ arrives at a vDNS64 device with the \"Checking Disabled\"\n   (CD) bit set,\
    \ it is an indication that the querying agent wants all\n   the validation data\
    \ so it can do checking itself.  By local policy,\n   vDNS64 could still validate,\
    \ but it must return all data to the\n   querying agent anyway.\n   Here are the\
    \ possible cases:\n   1.  A DNS64 (DNSSEC-aware or DNSSEC-oblivious) receives\
    \ a query with\n       the DO bit clear.  In this case, DNSSEC is not a concern,\
    \ because\n       the querying agent does not understand DNSSEC responses.  The\n\
    \       DNS64 can do validation of the response, if dictated by its local\n  \
    \     policy.\n   2.  A security-oblivious DNS64 receives a query with the DO\
    \ bit set,\n       and the CD bit clear or set.  This is just like the case of\
    \ a\n       non-DNS64 case: the server doesn't support it, so the querying\n \
    \      agent is out of luck.\n   3.  A security-aware and non-validating DNS64\
    \ receives a query with\n       the DO bit set and the CD bit clear.  Such a resolver\
    \ is not\n       validating responses, likely due to local policy (see [RFC4035],\n\
    \       Section 4.2).  For that reason, this case amounts to the same as\n   \
    \    the previous case, and no validation happens.\n   4.  A security-aware and\
    \ non-validating DNS64 receives a query with\n       the DO bit set and the CD\
    \ bit set.  In this case, the DNS64 is\n       supposed to pass on all the data\
    \ it gets to the query initiator\n       (see Section 3.2.2 of [RFC4035]).  This\
    \ case will not work with\n       DNS64, unless the validating resolver is prepared\
    \ to do DNS64\n       itself.  If the DNS64 modifies the record, the client will\
    \ get\n       the data back and try to validate it, and the data will be\n   \
    \    invalid as far as the client is concerned.\n   5.  A security-aware and validating\
    \ DNS64 resolver receives a query\n       with the DO bit clear and the CD bit\
    \ clear.  In this case, the\n       resolver validates the data.  If it fails,\
    \ it returns RCODE 2\n       (Server failure); otherwise, it returns the answer.\
    \  This is the\n       ideal case for vDNS64.  The resolver validates the data,\
    \ and then\n       synthesizes the new record and passes that to the client. \
    \ The\n       client, which is presumably not validating (else it should have\n\
    \       set DO and CD), cannot tell that DNS64 is involved.\n   6.  A security-aware\
    \ and validating DNS64 resolver receives a query\n       with the DO bit set and\
    \ the CD bit clear.  This works like the\n       previous case, except that the\
    \ resolver should also set the\n       \"Authentic Data\" (AD) bit on the response.\n\
    \   7.  A security-aware and validating DNS64 resolver receives a query\n    \
    \   with the DO bit set and the CD bit set.  This is effectively the\n       same\
    \ as the case where a security-aware and non-validating\n       recursive resolver\
    \ receives a similar query, and the same thing\n       will happen: the downstream\
    \ validator will mark the data as\n       invalid if DNS64 has performed synthesis.\
    \  The node needs to do\n       DNS64 itself, or else communication will fail.\n"
- title: 4.  Terminology
  contents:
  - "4.  Terminology\n   This section provides definitions for the special terms used\
    \ in the\n   document.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n   Authoritative server:  A DNS server that can answer\
    \ authoritatively a\n      given DNS request.\n   DNS64:  A logical function that\
    \ synthesizes DNS resource records\n      (e.g., AAAA records containing IPv6\
    \ addresses) from DNS resource\n      records actually contained in the DNS (e.g.,\
    \ A records containing\n      IPv4 addresses).\n   DNS64 recursive resolver: \
    \ A recursive resolver that provides the\n      DNS64 functionality as part of\
    \ its operation.  This is the same\n      thing as \"DNS64 in recursive-resolver\
    \ mode\".\n   DNS64 resolver:  Any resolver (stub resolver or recursive resolver)\n\
    \      that provides the DNS64 function.\n   DNS64 server:  Any server providing\
    \ the DNS64 function.  This\n      includes the server portion of a recursive\
    \ resolver when it is\n      providing the DNS64 function.\n   IPv4-only server:\
    \  Servers running IPv4-only applications and servers\n      that can only use\
    \ IPv4, as well as cases where only IPv4\n      connectivity is available to the\
    \ server.\n   IPv6-only hosts:  Hosts running IPv6-only applications and hosts\
    \ that\n      can only use IPv6, as well as cases where only IPv6 connectivity\n\
    \      is available to the client.\n   Recursive resolver:  A DNS server that\
    \ accepts requests from one\n      resolver, and asks another server (of some\
    \ description) for the\n      answer on behalf of the first resolver.  Full discussion\
    \ of DNS\n      recursion is beyond the scope of this document; see [RFC1034]\
    \ and\n      [RFC1035] for full details.\n   Synthetic RR:  A DNS resource record\
    \ (RR) that is not contained in\n      the authoritative servers' zone data, but\
    \ which is instead\n      synthesized from other RRs in the same zone.  An example\
    \ is a\n      synthetic AAAA record created from an A record.\n   IPv6/IPv4 translator:\
    \  A device that translates IPv6 packets to IPv4\n      packets and vice versa.\
    \  It is only required that the\n      communication initiated from the IPv6 side\
    \ be supported.\n   For a detailed understanding of this document, the reader\
    \ should also\n   be familiar with DNS terminology from [RFC1034] and [RFC1035]\
    \ and\n   with current NAT terminology from [RFC4787].  Some parts of this\n \
    \  document assume familiarity with the terminology of the DNS security\n   extensions\
    \ outlined in [RFC4035].  It is worth emphasizing that while\n   DNS64 is a logical\
    \ function separate from the DNS, it is nevertheless\n   closely associated with\
    \ that protocol.  It depends on the DNS\n   protocol, and some behavior of DNS64\
    \ will interact with regular DNS\n   responses.\n"
- title: 5.  DNS64 Normative Specification
  contents:
  - "5.  DNS64 Normative Specification\n   DNS64 is a logical function that synthesizes\
    \ AAAA records from A\n   records.  The DNS64 function may be implemented in a\
    \ stub resolver,\n   in a recursive resolver, or in an authoritative name server.\
    \  It\n   works within those DNS functions, and appears on the network as\n  \
    \ though it were a \"plain\" DNS resolver or name server conforming to\n   [RFC1034]\
    \ and [RFC1035].\n   The implementation SHOULD support mapping of separate IPv4\
    \ address\n   ranges to separate IPv6 prefixes for AAAA record synthesis.  This\n\
    \   allows handling of special use IPv4 addresses [RFC5735].\n   DNS messages\
    \ contain several sections.  The portion of a DNS message\n   that is altered\
    \ by DNS64 is the answer section, which is discussed\n   below in Section 5.1.\
    \  The resulting synthetic answer is put together\n   with other sections, and\
    \ that creates the message that is actually\n   returned as the response to the\
    \ DNS query.  Assembling that response\n   is covered below in Section 5.4.\n\
    \   DNS64 also responds to PTR queries involving addresses containing any\n  \
    \ of the IPv6 prefixes it uses for synthesis of AAAA RRs.\n"
- title: 5.1.  Resolving AAAA Queries and the Answer Section
  contents:
  - "5.1.  Resolving AAAA Queries and the Answer Section\n   When the DNS64 receives\
    \ a query for RRs of type AAAA and class IN, it\n   first attempts to retrieve\
    \ non-synthetic RRs of this type and class,\n   either by performing a query or,\
    \ in the case of an authoritative\n   server, by examining its own results.  The\
    \ query may be answered from\n   a local cache, if one is available.  DNS64 operation\
    \ for classes\n   other than IN is undefined, and a DNS64 MUST behave as though\
    \ no\n   DNS64 function is configured.\n"
- title: 5.1.1.  The Answer when There is AAAA Data Available
  contents:
  - "5.1.1.  The Answer when There is AAAA Data Available\n   If the query results\
    \ in one or more AAAA records in the answer\n   section, the result is returned\
    \ to the requesting client as per\n   normal DNS semantics, except in the case\
    \ where any of the AAAA\n   records match a special exclusion set of prefixes,\
    \ as considered in\n   Section 5.1.4.  If there is (non-excluded) AAAA data available,\
    \ DNS64\n   SHOULD NOT include synthetic AAAA RRs in the response (see Appendix\
    \ A\n   for an analysis of the motivations for and the implications of not\n \
    \  complying with this recommendation).  By default, DNS64\n   implementations\
    \ MUST NOT synthesize AAAA RRs when real AAAA RRs\n   exist.\n"
- title: 5.1.2.  The Answer when There is an Error
  contents:
  - "5.1.2.  The Answer when There is an Error\n   If the query results in a response\
    \ with an RCODE other than 0 (No\n   error condition), then there are two possibilities.\
    \  A result with\n   RCODE=3 (Name Error) is handled according to normal DNS operation\n\
    \   (which is normally to return the error to the client).  This stage is\n  \
    \ still prior to any synthesis having happened, so a response to be\n   returned\
    \ to the client does not need any special assembly other than\n   what would usually\
    \ happen in DNS operation.\n   Any other RCODE is treated as though the RCODE\
    \ were 0 (see\n   Sections 5.1.6 and 5.1.7) and the answer section were empty.\
    \  This is\n   because of the large number of different responses from deployed\
    \ name\n   servers when they receive AAAA queries without a AAAA record being\n\
    \   available (see [RFC4074]).  Note that this means, for practical\n   purposes,\
    \ that several different classes of error in the DNS are all\n   treated as though\
    \ a AAAA record is not available for that owner name.\n   It is important to note\
    \ that, as of this writing, some servers\n   respond with RCODE=3 to a AAAA query\
    \ even if there is an A record\n   available for that owner name.  Those servers\
    \ are in clear violation\n   of the meaning of RCODE 3, and it is expected that\
    \ they will decline\n   in use as IPv6 deployment increases.\n"
- title: 5.1.3.  Dealing with Timeouts
  contents:
  - "5.1.3.  Dealing with Timeouts\n   If the query receives no answer before the\
    \ timeout (which might be\n   the timeout from every authoritative server, depending\
    \ on whether the\n   DNS64 is in recursive-resolver mode), it is treated as RCODE=2\n\
    \   (Server failure).\n"
- title: 5.1.4.  Special Exclusion Set for AAAA Records
  contents:
  - "5.1.4.  Special Exclusion Set for AAAA Records\n   Some IPv6 addresses are not\
    \ actually usable by IPv6-only hosts.  If\n   they are returned to IPv6-only querying\
    \ agents as AAAA records,\n   therefore, the goal of decreasing the number of\
    \ failure modes will\n   not be attained.  Examples include AAAA records with\
    \ addresses in the\n   ::ffff:0:0/96 network, and possibly (depending on the context)\
    \ AAAA\n   records with the site's Pref64::/n or the Well-Known Prefix (see\n\
    \   below for more about the Well-Known Prefix).  A DNS64 implementation\n   SHOULD\
    \ provide a mechanism to specify IPv6 prefix ranges to be\n   treated as though\
    \ the AAAA containing them were an empty answer.  An\n   implementation SHOULD\
    \ include the ::ffff/96 network in that range by\n   default.  Failure to provide\
    \ this facility will mean that clients\n   querying the DNS64 function may not\
    \ be able to communicate with hosts\n   that would be reachable from a dual-stack\
    \ host.\n   When the DNS64 performs its initial AAAA query, if it receives an\n\
    \   answer with only AAAA records containing addresses in the excluded\n   range(s),\
    \ then it MUST treat the answer as though it were an empty\n   answer, and proceed\
    \ accordingly.  If it receives an answer with at\n   least one AAAA record containing\
    \ an address outside any of the\n   excluded range(s), then it by default SHOULD\
    \ build an answer section\n   for a response including only the AAAA record(s)\
    \ that do not contain\n   any of the addresses inside the excluded ranges.  That\
    \ answer section\n   is used in the assembly of a response as detailed in Section\
    \ 5.4.\n   Alternatively, it MAY treat the answer as though it were an empty\n\
    \   answer, and proceed accordingly.  It MUST NOT return the offending\n   AAAA\
    \ records as part of a response.\n"
- title: 5.1.5.  Dealing with CNAME and DNAME
  contents:
  - "5.1.5.  Dealing with CNAME and DNAME\n   If the response contains a CNAME or\
    \ a DNAME, then the CNAME or DNAME\n   chain is followed until the first terminating\
    \ A or AAAA record is\n   reached.  This may require the DNS64 to ask for an A\
    \ record, in case\n   the response to the original AAAA query is a CNAME or DNAME\
    \ without a\n   AAAA record to follow.  The resulting AAAA or A record is treated\n\
    \   like any other AAAA or A case, as appropriate.\n   When assembling the answer\
    \ section, any chains of CNAME or DNAME RRs\n   are included as part of the answer\
    \ along with the synthetic AAAA (if\n   appropriate).\n"
- title: 5.1.6.  Data for the Answer when Performing Synthesis
  contents:
  - "5.1.6.  Data for the Answer when Performing Synthesis\n   If the query results\
    \ in no error but an empty answer section in the\n   response, the DNS64 attempts\
    \ to retrieve A records for the name in\n   question, either by performing another\
    \ query or, in the case of an\n   authoritative server, by examining its own results.\
    \  If this new A RR\n   query results in an empty answer or in an error, then\
    \ the empty\n   result or error is used as the basis for the answer returned to\
    \ the\n   querying client.  If instead the query results in one or more A RRs,\n\
    \   the DNS64 synthesizes AAAA RRs based on the A RRs according to the\n   procedure\
    \ outlined in Section 5.1.7.  The DNS64 returns the\n   synthesized AAAA records\
    \ in the answer section, removing the A\n   records that form the basis of the\
    \ synthesis.\n"
- title: 5.1.7.  Performing the Synthesis
  contents:
  - "5.1.7.  Performing the Synthesis\n   A synthetic AAAA record is created from\
    \ an A record as follows:\n   o  The NAME field is set to the NAME field from\
    \ the A record.\n   o  The TYPE field is set to 28 (AAAA).\n   o  The CLASS field\
    \ is set to the original CLASS field, 1.  Under this\n      specification, DNS64\
    \ for any CLASS other than 1 is undefined.\n   o  The Time to Live (TTL) field\
    \ is set to the minimum of the TTL of\n      the original A RR and the SOA RR\
    \ for the queried domain.  (Note\n      that in order to obtain the TTL of the\
    \ SOA RR, the DNS64 does not\n      need to perform a new query, but it can remember\
    \ the TTL from the\n      SOA RR in the negative response to the AAAA query. \
    \ If the SOA RR\n      was not delivered with the negative response to the AAAA\
    \ query,\n      then the DNS64 SHOULD use the TTL of the original A RR or\n  \
    \    600 seconds, whichever is shorter.  It is possible instead to\n      query\
    \ explicitly for the SOA RR and use the result of that query,\n      but this\
    \ will increase query load and time to resolution for\n      little additional\
    \ benefit.)  This is in keeping with the approach\n      used in negative caching\
    \ [RFC2308].\n   o  The RDLENGTH field is set to 16.\n   o  The RDATA field is\
    \ set to the IPv6 representation of the IPv4\n      address from the RDATA field\
    \ of the A record.  The DNS64 MUST\n      check each A RR against configured IPv4\
    \ address ranges and select\n      the corresponding IPv6 prefix to use in synthesizing\
    \ the AAAA RR.\n      See Section 5.2 for discussion of the algorithms to be used\
    \ in\n      effecting the transformation.\n"
- title: 5.1.8.  Querying in Parallel
  contents:
  - "5.1.8.  Querying in Parallel\n   The DNS64 MAY perform the query for the AAAA\
    \ RR and for the A RR in\n   parallel, in order to minimize the delay.\n     \
    \ NOTE: Querying in parallel will result in performing unnecessary A\n      RR\
    \ queries in the case where no AAAA RR synthesis is required.  A\n      possible\
    \ trade-off would be to perform them sequentially but with\n      a very short\
    \ interval between them, so if we obtain a fast reply,\n      we avoid doing the\
    \ additional query.  (Note that this discussion\n      is relevant only if the\
    \ DNS64 function needs to perform external\n      queries to fetch the RR.  If\
    \ the needed RR information is\n      available locally, as in the case of an\
    \ authoritative server, the\n      issue is no longer relevant.)\n"
- title: 5.2.  Generation of the IPv6 Representations of IPv4 Addresses
  contents:
  - "5.2.  Generation of the IPv6 Representations of IPv4 Addresses\n   DNS64 supports\
    \ multiple algorithms for the generation of the IPv6\n   representation of an\
    \ IPv4 address.  The constraints imposed on the\n   generation algorithms are\
    \ the following:\n   o  The same algorithm to create an IPv6 address from an IPv4\
    \ address\n      MUST be used by both a DNS64 to create the IPv6 address to be\n\
    \      returned in the synthetic AAAA RR from the IPv4 address contained\n   \
    \   in an original A RR, and by an IPv6/IPv4 translator to create the\n      IPv6\
    \ address to be included in the source address field of the\n      outgoing IPv6\
    \ packets from the IPv4 address included in the source\n      address field of\
    \ the incoming IPv4 packet.\n   o  The algorithm MUST be reversible; i.e., it\
    \ MUST be possible to\n      derive the original IPv4 address from the IPv6 representation.\n\
    \   o  The input for the algorithm MUST be limited to the IPv4 address;\n    \
    \  the IPv6 prefix (denoted Pref64::/n) used in the IPv6\n      representations;\
    \ and, optionally, a set of stable parameters that\n      are configured in the\
    \ DNS64 and in the NAT64 (such as a fixed\n      string to be used as a suffix).\n\
    \      *  For each prefix Pref64::/n, n MUST be less than or equal to 96.\n  \
    \       If one or more Pref64::/n are configured in the DNS64 through\n      \
    \   any means (such as manual configuration, or other automatic\n         means\
    \ not specified in this document), the default algorithm\n         MUST use these\
    \ prefixes (and not use the Well-Known Prefix).\n         If no prefix is available,\
    \ the algorithm MUST use the\n         Well-Known Prefix 64:ff9b::/96 defined\
    \ in [RFC6052] to\n         represent the IPv4 unicast address range.\n   A DNS64\
    \ MUST support the algorithm for generating IPv6\n   representations of IPv4 addresses\
    \ defined in Section 2 of [RFC6052].\n   Moreover, the aforementioned algorithm\
    \ MUST be the default algorithm\n   used by the DNS64.  While the normative description\
    \ of the algorithm\n   is provided in [RFC6052], a sample description of the algorithm\
    \ and\n   its application to different scenarios are provided in Section 7 for\n\
    \   illustration purposes.\n"
- title: 5.3.  Handling Other Resource Records and the Additional Section
  contents:
  - '5.3.  Handling Other Resource Records and the Additional Section

    '
- title: 5.3.1.  PTR Resource Record
  contents:
  - "5.3.1.  PTR Resource Record\n   If a DNS64 server receives a PTR query for a\
    \ record in the IP6.ARPA\n   domain, it MUST strip the IP6.ARPA labels from the\
    \ QNAME, reverse the\n   address portion of the QNAME according to the encoding\
    \ scheme\n   outlined in Section 2.5 of [RFC3596], and examine the resulting\n\
    \   address to see whether its prefix matches any of the locally\n   configured\
    \ Pref64::/n or the default Well-Known Prefix.  There are\n   two alternatives\
    \ for a DNS64 server to respond to such PTR queries.\n   A DNS64 server MUST provide\
    \ one of these, and SHOULD NOT provide both\n   at the same time unless different\
    \ IP6.ARPA zones require answers of\n   different sorts:\n   1.  The first option\
    \ is for the DNS64 server to respond\n       authoritatively for its prefixes.\
    \  If the address prefix matches\n       any Pref64::/n used in the site, either\
    \ a NSP or the Well-Known\n       Prefix (i.e., 64:ff9b::/96), then the DNS64\
    \ server MAY answer the\n       query using locally appropriate RDATA.  The DNS64\
    \ server MAY use\n       the same RDATA for all answers.  Note that the requirement\
    \ is to\n       match any Pref64::/n used at the site, and not merely the locally\n\
    \       configured Pref64::/n.  This is because end clients could ask for\n  \
    \     a PTR record matching an address received through a different\n       (site-provided)\
    \ DNS64, and if this strategy is in effect, those\n       queries should never\
    \ be sent to the global DNS.  The advantage of\n       this strategy is that it\
    \ makes plain to the querying client that\n       the prefix is one operated by\
    \ the (DNS64) site, and that the\n       answers the client is getting are generated\
    \ by DNS64.  The\n       disadvantage is that any useful reverse-tree information\
    \ that\n       might be in the global DNS is unavailable to the clients querying\n\
    \       the DNS64.\n   2.  The second option is for the DNS64 name server to synthesize\
    \ a\n       CNAME mapping the IP6.ARPA namespace to the corresponding\n      \
    \ IN-ADDR.ARPA name.  In this case, the DNS64 name server SHOULD\n       ensure\
    \ that there is RDATA at the PTR of the corresponding\n       IN-ADDR.ARPA name,\
    \ and that there is not an existing CNAME at\n       that name.  This is in order\
    \ to avoid synthesizing a CNAME that\n       makes a CNAME chain longer or that\
    \ does not actually point to\n       anything.  The rest of the response would\
    \ be the normal DNS\n       processing.  The CNAME can be signed on the fly if\
    \ need be.  The\n       advantage of this approach is that any useful information\
    \ in the\n       reverse tree is available to the querying client.  The\n    \
    \   disadvantages are that it adds additional load to the DNS64\n       (because\
    \ CNAMEs have to be synthesized for each PTR query that\n       matches the Pref64::/n),\
    \ and that it may require signing on\n       the fly.\n   If the address prefix\
    \ does not match any Pref64::/n, then the DNS64\n   server MUST process the query\
    \ as though it were any other query;\n   i.e., a recursive name server MUST attempt\
    \ to resolve the query as\n   though it were any other (non-A/AAAA) query, and\
    \ an authoritative\n   server MUST respond authoritatively or with a referral,\
    \ as\n   appropriate.\n"
- title: 5.3.2.  Handling the Additional Section
  contents:
  - "5.3.2.  Handling the Additional Section\n   DNS64 synthesis MUST NOT be performed\
    \ on any records in the\n   additional section of synthesized answers.  The DNS64\
    \ MUST pass the\n   additional section unchanged.\n      NOTE: It may appear that\
    \ adding synthetic records to the\n      additional section is desirable, because\
    \ clients sometimes use the\n      data in the additional section to proceed without\
    \ having to\n      re-query.  There is in general no promise, however, that the\n\
    \      additional section will contain all the relevant records, so any\n    \
    \  client that depends on the additional section being able to\n      satisfy\
    \ its needs (i.e., without additional queries) is\n      necessarily broken. \
    \ An IPv6-only client that needs a AAAA record,\n      therefore, will send a\
    \ query for the necessary AAAA record if it\n      is unable to find such a record\
    \ in the additional section of an\n      answer it is consuming.  For a correctly\
    \ functioning client, the\n      effect would be no different if the additional\
    \ section were empty.\n      The alternative of removing the A records in the\
    \ additional\n      section and replacing them with synthetic AAAA records may\
    \ cause a\n      host behind a NAT64 to query directly a name server that is\n\
    \      unaware of the NAT64 in question.  The result in this case will be\n  \
    \    resolution failure anyway, but later in the resolution operation.\n     \
    \ The prohibition on synthetic data in the additional section\n      reduces,\
    \ but does not eliminate, the possibility of resolution\n      failures due to\
    \ cached DNS data from behind the DNS64.  See\n      Section 6.\n"
- title: 5.3.3.  Other Resource Records
  contents:
  - "5.3.3.  Other Resource Records\n   If the DNS64 is in recursive-resolver mode,\
    \ then considerations\n   outlined in [DEFAULT-LOCAL-ZONES] may be relevant.\n\
    \   All other RRs MUST be returned unchanged.  This includes responses to\n  \
    \ queries for A RRs.\n"
- title: 5.4.  Assembling a Synthesized Response to a AAAA Query
  contents:
  - "5.4.  Assembling a Synthesized Response to a AAAA Query\n   A DNS64 uses different\
    \ pieces of data to build the response returned\n   to the querying client.\n\
    \   The query that is used as the basis for synthesis results either in\n   an\
    \ error, an answer that can be used as a basis for synthesis, or an\n   empty\
    \ (authoritative) answer.  If there is an empty answer, then the\n   DNS64 responds\
    \ to the original querying client with the answer the\n   DNS64 received to the\
    \ original (initiator's) query.  Otherwise, the\n   response is assembled as follows.\n\
    \   The header fields are set according to the usual rules for recursive\n   or\
    \ authoritative servers, depending on the role that the DNS64 is\n   serving.\
    \  The question section is copied from the original\n   (initiator's) query. \
    \ The answer section is populated according to\n   the rules in Section 5.1.7.\
    \  The authority and additional sections\n   are copied from the response to the\
    \ final query that the DNS64\n   performed, and used as the basis for synthesis.\n\
    \   The final response from the DNS64 is subject to all the standard DNS\n   rules,\
    \ including truncation [RFC1035] and EDNS0 handling [RFC2671].\n"
- title: '5.5.  DNSSEC Processing: DNS64 in Validating Resolver Mode'
  contents:
  - "5.5.  DNSSEC Processing: DNS64 in Validating Resolver Mode\n   We consider the\
    \ case where a recursive resolver that is performing\n   DNS64 also has a local\
    \ policy to validate the answers according to\n   the procedures outlined in [RFC4035],\
    \ Section 5.  We call this\n   general case vDNS64.\n   The vDNS64 uses the presence\
    \ of the DO and CD bits to make some\n   decisions about what the query originator\
    \ needs, and can react\n   accordingly:\n   1.  If CD is not set and DO is not\
    \ set, vDNS64 SHOULD perform\n       validation and do synthesis as needed.  See\
    \ the next item for\n       rules about how to do validation and synthesis.  In\
    \ this case,\n       however, vDNS64 MUST NOT set the AD bit in any response.\n\
    \   2.  If CD is not set and DO is set, then vDNS64 SHOULD perform\n       validation.\
    \  Whenever vDNS64 performs validation, it MUST\n       validate the negative\
    \ answer for AAAA queries before proceeding\n       to query for A records for\
    \ the same name, in order to be sure\n       that there is not a legitimate AAAA\
    \ record on the Internet.\n       Failing to observe this step would allow an\
    \ attacker to use DNS64\n       as a mechanism to circumvent DNSSEC.  If the negative\
    \ response\n       validates, and the response to the A query validates, then\
    \ the\n       vDNS64 MAY perform synthesis and SHOULD set the AD bit in the\n\
    \       answer to the client.  This is acceptable, because [RFC4035],\n      \
    \ Section 3.2.3 says that the AD bit is set by the name server side\n       of\
    \ a security-aware recursive name server if and only if it\n       considers all\
    \ the RRSets in the answer and authority sections to\n       be authentic.  In\
    \ this case, the name server has reason to\n       believe the RRSets are all\
    \ authentic, so it SHOULD set the AD\n       bit.  If the data does not validate,\
    \ the vDNS64 MUST respond with\n       RCODE=2 (Server failure).\n       A security-aware\
    \ end point might take the presence of the AD bit\n       as an indication that\
    \ the data is valid, and may pass the DNS\n       (and DNSSEC) data to an application.\
    \  If the application attempts\n       to validate the synthesized data, of course,\
    \ the validation will\n       fail.  One could argue therefore that this approach\
    \ is not\n       desirable, but security-aware stub resolvers must not place any\n\
    \       reliance on data received from resolvers and validated on their\n    \
    \   behalf without certain criteria established by [RFC4035],\n       Section\
    \ 4.9.3.  An application that wants to perform validation\n       on its own should\
    \ use the CD bit.\n   3.  If the CD bit is set and DO is set, then vDNS64 MAY\
    \ perform\n       validation, but MUST NOT perform synthesis.  It MUST return\
    \ the\n       data to the query initiator, just like a regular recursive\n   \
    \    resolver, and depend on the client to do the validation and the\n       synthesis\
    \ itself.\n       The disadvantage to this approach is that an end point that\
    \ is\n       translation-oblivious but security-aware and validating will not\n\
    \       be able to use the DNS64 functionality.  In this case, the end\n     \
    \  point will not have the desired benefit of NAT64.  In effect,\n       this\
    \ strategy means that any end point that wishes to do\n       validation in a\
    \ NAT64 context must be upgraded to be\n       translation-aware as well.\n"
- title: 6.  Deployment Notes
  contents:
  - "6.  Deployment Notes\n   While DNS64 is intended to be part of a strategy for\
    \ aiding IPv6\n   deployment in an internetworking environment with some IPv4-only\
    \ and\n   IPv6-only networks, it is important to realize that it is\n   incompatible\
    \ with some things that may be deployed in an IPv4-only or\n   dual-stack context.\n"
- title: 6.1.  DNS Resolvers and DNS64
  contents:
  - "6.1.  DNS Resolvers and DNS64\n   Full-service resolvers that are unaware of\
    \ the DNS64 function can be\n   (mis)configured to act as mixed-mode iterative\
    \ and forwarding\n   resolvers.  In a native IPv4 context, this sort of configuration\
    \ may\n   appear to work.  It is impossible to make it work properly without it\n\
    \   being aware of the DNS64 function, because it will likely at some\n   point\
    \ obtain IPv4-only glue records and attempt to use them for\n   resolution.  The\
    \ result that is returned will contain only A records,\n   and without the ability\
    \ to perform the DNS64 function the resolver\n   will be unable to answer the\
    \ necessary AAAA queries.\n"
- title: 6.2.  DNSSEC Validators and DNS64
  contents:
  - "6.2.  DNSSEC Validators and DNS64\n   An existing DNSSEC validator (i.e., one\
    \ that is unaware of DNS64)\n   might reject all the data that comes from DNS64\
    \ as having been\n   tampered with (even if it did not set CD when querying).\
    \  If it is\n   necessary to have validation behind the DNS64, then the validator\n\
    \   must know how to perform the DNS64 function itself.  Alternatively,\n   the\
    \ validating host may establish a trusted connection with a DNS64,\n   and allow\
    \ the DNS64 recursive resolver to do all validation on its\n   behalf.\n"
- title: 6.3.  DNS64 and Multihomed and Dual-Stack Hosts
  contents:
  - '6.3.  DNS64 and Multihomed and Dual-Stack Hosts

    '
- title: 6.3.1.  IPv6 Multihomed Hosts
  contents:
  - "6.3.1.  IPv6 Multihomed Hosts\n   Synthetic AAAA records may be constructed on\
    \ the basis of the network\n   context in which they were constructed.  If a host\
    \ sends DNS queries\n   to resolvers in multiple networks, it is possible that\
    \ some of them\n   will receive answers from a DNS64 without all of them being\
    \ connected\n   via a NAT64.  For instance, suppose a system has two interfaces,\
    \ i1\n   and i2.  Whereas i1 is connected to the IPv4 Internet via NAT64, i2\n\
    \   has native IPv6 connectivity only.  I1 might receive a AAAA answer\n   from\
    \ a DNS64 that is configured for a particular NAT64; the IPv6\n   address contained\
    \ in that AAAA answer will not connect with anything\n   via i2.\n           \
    \  +---------------+                 +-------------+\n             |      i1 (IPv6)+----NAT64--------+IPv4\
    \ Internet|\n             |               |                 +-------------+\n\
    \             | host          |\n             |               |              \
    \   +-------------+\n             |      i2 (IPv6)+-----------------+IPv6 Internet|\n\
    \             +---------------+                 +-------------+\n            \
    \         Figure 1:  IPv6 Multihomed Hosts\n   This example illustrates why it\
    \ is generally preferable that hosts\n   treat DNS answers from one interface\
    \ as local to that interface.  The\n   answer received on one interface will not\
    \ work on the other\n   interface.  Hosts that attempt to use DNS answers globally\
    \ may\n   encounter surprising failures in these cases.\n   Note that the issue\
    \ is not that there are two interfaces, but that\n   there are two networks involved.\
    \  The same results could be achieved\n   with a single interface routed to two\
    \ different networks.\n"
- title: 6.3.2.  Accidental Dual-Stack DNS64 Use
  contents:
  - "6.3.2.  Accidental Dual-Stack DNS64 Use\n   Similarly, suppose that i1 has IPv6\
    \ connectivity and can connect to\n   the IPv4 Internet through NAT64, but i2\
    \ has native IPv4 connectivity.\n   In this case, i1 could receive an IPv6 address\
    \ from a synthetic AAAA\n   that would better be reached via native IPv4.  Again,\
    \ it is worth\n   emphasizing that this arises because there are two networks\
    \ involved.\n             +---------------+                 +-------------+\n\
    \             |      i1 (IPv6)+----NAT64--------+IPv4 Internet|\n            \
    \ |               |                 +-------------+\n             | host     \
    \     |\n             |               |                 +-------------+\n    \
    \         |      i2 (IPv4)+-----------------+IPv4 Internet|\n             +---------------+\
    \                 +-------------+\n                Figure 2:  Accidental Dual-Stack\
    \ DNS64 Use\n   The default configuration of dual-stack hosts is that IPv6 is\n\
    \   preferred over IPv4 ([RFC3484]).  In that arrangement, the host will\n   often\
    \ use the NAT64 when native IPv4 would be more desirable.  For\n   this reason,\
    \ hosts with IPv4 connectivity to the Internet should\n   avoid using DNS64. \
    \ This can be partly resolved by ISPs when\n   providing DNS resolvers to clients,\
    \ but that is not a guarantee that\n   the NAT64 will never be used when a native\
    \ IPv4 connection should be\n   used.  There is no general-purpose mechanism to\
    \ ensure that native\n   IPv4 transit will always be preferred, because to a DNS64-oblivious\n\
    \   host, the DNS64 looks just like an ordinary DNS server.  Operators of\n  \
    \ a NAT64 should expect traffic to pass through the NAT64 even when it\n   is\
    \ not necessary.\n"
- title: 6.3.3.  Intentional Dual-Stack DNS64 Use
  contents:
  - "6.3.3.  Intentional Dual-Stack DNS64 Use\n   Finally, consider the case where\
    \ the IPv4 connectivity on i2 is only\n   with a LAN, and not with the IPv4 Internet.\
    \  The IPv4 Internet is\n   only accessible using the NAT64.  In this case, it\
    \ is critical that\n   the DNS64 not synthesize AAAA responses for hosts in the\
    \ LAN, or else\n   that the DNS64 be aware of hosts in the LAN and provide context-\n\
    \   sensitive answers (\"split view\" DNS answers) for hosts inside the\n   LAN.\
    \  As with any split view DNS arrangement, operators must be\n   prepared for\
    \ data to leak from one context to another, and for\n   failures to occur because\
    \ nodes accessible from one context are not\n   accessible from the other.\n \
    \            +---------------+                 +-------------+\n             |\
    \      i1 (IPv6)+----NAT64--------+IPv4 Internet|\n             |            \
    \   |                 +-------------+\n             | host          |\n      \
    \       |               |\n             |      i2 (IPv4)+---(local LAN only)\n\
    \             +---------------+\n                Figure 3:  Intentional Dual-Stack\
    \ DNS64 Use\n   It is important for deployers of DNS64 to realize that, in some\n\
    \   circumstances, making the DNS64 available to a dual-stack host will\n   cause\
    \ the host to prefer to send packets via NAT64 instead of via\n   native IPv4,\
    \ with the associated loss of performance or functionality\n   (or both) entailed\
    \ by the NAT.  At the same time, some hosts are not\n   able to learn about DNS\
    \ servers provisioned on IPv6 addresses, or\n   simply cannot send DNS packets\
    \ over IPv6.\n"
- title: 7.  Deployment Scenarios and Examples
  contents:
  - "7.  Deployment Scenarios and Examples\n   In this section, we illustrate how\
    \ the DNS64 behaves in different\n   scenarios that are expected to be common.\
    \  In particular, we will\n   consider the following scenarios defined in [RFC6144]:\
    \ the \"an IPv6\n   network to the IPv4 Internet\" scenario (both with DNS64 in\
    \ DNS server\n   mode and in stub-resolver mode) and the \"IPv6 Internet to an\
    \ IPv4\n   network\" setup (with DNS64 in DNS server mode only).\n   In all the\
    \ examples below, there is an IPv6/IPv4 translator\n   connecting the IPv6 domain\
    \ to the IPv4 one.  Also, there is a name\n   server that is a dual-stack node,\
    \ so it can communicate with IPv6\n   hosts using IPv6 and with IPv4 nodes using\
    \ IPv4.  In addition, we\n   assume that in the examples, the DNS64 function learns\
    \ which IPv6\n   prefix it needs to use to map the IPv4 address space through\
    \ manual\n   configuration.\n"
- title: 7.1.  Example of "an IPv6 Network to the IPv4 Internet" Setup with DNS64
  contents:
  - "7.1.  Example of \"an IPv6 Network to the IPv4 Internet\" Setup with DNS64\n\
    \      in DNS Server Mode\n   In this example, we consider an IPv6 node located\
    \ in an IPv6-only\n   site that initiates a communication to an IPv4 node located\
    \ in the\n   IPv4 Internet.\n   The scenario for this case is depicted in the\
    \ following figure:\n             +---------------------+         +---------------+\n\
    \             |IPv6 network         |         |    IPv4       |\n            \
    \ |           |  +-------------+  |  Internet     |\n             |          \
    \ |--| Name server |--|               |\n             |           |  | with DNS64\
    \  |  |  +----+       |\n             |  +----+   |  +-------------+  |  | H2\
    \ |       |\n             |  | H1 |---|         |         |  +----+       |\n\
    \             |  +----+   |   +------------+  |  192.0.2.1    |\n            \
    \ |           |---| IPv6/IPv4  |--|               |\n             |          \
    \ |   | Translator |  |               |\n             |           |   +------------+\
    \  |               |\n             |           |         |         |         \
    \      |\n             +---------------------+         +---------------+\n   \
    \       Figure 4:  \"An IPv6 Network to the IPv4 Internet\" Setup\n          \
    \             with DNS64 in DNS Server Mode\n   The figure shows an IPv6 node\
    \ H1 and an IPv4 node H2 with the IPv4\n   address 192.0.2.1 and FQDN h2.example.com.\n\
    \   The IPv6/IPv4 translator has an IPv4 address 203.0.113.1 assigned\n   to its\
    \ IPv4 interface, and it is using the Well-Known Prefix\n   64:ff9b::/96 to create\
    \ IPv6 representations of IPv4 addresses.  The\n   same prefix is configured in\
    \ the DNS64 function in the local name\n   server.\n   For this example, assume\
    \ the typical DNS situation where IPv6 hosts\n   have only stub resolvers, and\
    \ they are configured with the IP address\n   of a name server that they always\
    \ have to query and that performs\n   recursive lookups (henceforth called \"\
    the recursive name server\").\n   The steps by which H1 establishes communication\
    \ with H2 are:\n   1.  H1 does a DNS lookup for h2.example.com.  H1 does this\
    \ by sending\n       a DNS query for a AAAA record for H2 to the recursive name\n\
    \       server.  The recursive name server implements DNS64\n       functionality.\n\
    \   2.  The recursive name server resolves the query, and discovers that\n   \
    \    there are no AAAA records for H2.\n   3.  The recursive name server performs\
    \ an A-record query for H2 and\n       gets back an RRSet containing a single\
    \ A record with the IPv4\n       address 192.0.2.1.  The name server then synthesizes\
    \ a AAAA\n       record.  The IPv6 address in the AAAA record contains the prefix\n\
    \       assigned to the IPv6/IPv4 translator in the upper 96 bits and the\n  \
    \     received IPv4 address in the lower 32 bits; i.e., the resulting\n      \
    \ IPv6 address is 64:ff9b::192.0.2.1.\n   4.  H1 receives the synthetic AAAA record\
    \ and sends a packet towards\n       H2.  The packet is sent to the destination\
    \ address 64:ff9b::\n       192.0.2.1.\n   5.  The packet is routed to the IPv6\
    \ interface of the IPv6/IPv4\n       translator, and the subsequent communication\
    \ flows by means of\n       the IPv6/IPv4 translator mechanisms.\n"
- title: 7.2.  Example of "an IPv6 Network to the IPv4 Internet" Setup with DNS64
  contents:
  - "7.2.  Example of \"an IPv6 Network to the IPv4 Internet\" Setup with DNS64\n\
    \      in Stub-Resolver Mode\n   This case is depicted in the following figure:\n\
    \             +---------------------+         +---------------+\n            \
    \ |IPv6 network         |         |    IPv4       |\n             |          \
    \ |     +--------+    |  Internet     |\n             |           |-----| Name\
    \   |----|               |\n             | +-----+   |     | server |    |  +----+\
    \       |\n             | | H1  |   |     +--------+    |  | H2 |       |\n  \
    \           | |with |---|         |         |  +----+       |\n             |\
    \ |DNS64|   |   +------------+  |  192.0.2.1    |\n             | +----+    |---|\
    \ IPv6/IPv4  |--|               |\n             |           |   | Translator |\
    \  |               |\n             |           |   +------------+  |         \
    \      |\n             |           |         |         |               |\n   \
    \          +---------------------+         +---------------+\n          Figure\
    \ 5:  \"An IPv6 Network to the IPv4 Internet\" Setup\n                       with\
    \ DNS64 in Stub-Resolver Mode\n   The figure shows an IPv6 node H1 implementing\
    \ the DNS64 function and\n   an IPv4 node H2 with the IPv4 address 192.0.2.1 and\
    \ FQDN\n   h2.example.com.\n   The IPv6/IPv4 translator has an IPv4 address 203.0.113.1\
    \ assigned\n   to its IPv4 interface, and it is using the Well-Known Prefix\n\
    \   64:ff9b::/96 to create IPv6 representations of IPv4 addresses.  The\n   same\
    \ prefix is configured in the DNS64 function in H1.\n   For this example, assume\
    \ the typical DNS situation where IPv6 hosts\n   have only stub resolvers, and\
    \ they are configured with the IP address\n   of a name server that they always\
    \ have to query and that performs\n   recursive lookups (henceforth called \"\
    the recursive name server\").\n   The recursive name server does not perform the\
    \ DNS64 function.\n   The steps by which H1 establishes communication with H2\
    \ are:\n   1.  H1 does a DNS lookup for h2.example.com.  H1 does this by sending\n\
    \       a DNS query for a AAAA record for H2 to the recursive name\n       server.\n\
    \   2.  The recursive DNS server resolves the query, and returns the\n       answer\
    \ to H1.  Because there are no AAAA records in the global\n       DNS for H2,\
    \ the answer is empty.\n   3.  The stub resolver at H1 then queries for an A record\
    \ for H2 and\n       gets back an A record containing the IPv4 address 192.0.2.1.\
    \  The\n       DNS64 function within H1 then synthesizes a AAAA record.  The\n\
    \       IPv6 address in the AAAA record contains the prefix assigned to\n    \
    \   the IPv6/IPv4 translator in the upper 96 bits, then the received\n       IPv4\
    \ address in the lower 32 bits; the resulting IPv6 address is\n       64:ff9b::192.0.2.1.\n\
    \   4.  H1 sends a packet towards H2.  The packet is sent to the\n       destination\
    \ address 64:ff9b::192.0.2.1.\n   5.  The packet is routed to the IPv6 interface\
    \ of the IPv6/IPv4\n       translator and the subsequent communication flows using\
    \ the IPv6/\n       IPv4 translator mechanisms.\n"
- title: 7.3.  Example of "the IPv6 Internet to an IPv4 Network" Setup with DNS64
  contents:
  - "7.3.  Example of \"the IPv6 Internet to an IPv4 Network\" Setup with DNS64\n\
    \      in DNS Server Mode\n   In this example, we consider an IPv6 node located\
    \ in the IPv6\n   Internet that initiates a communication to an IPv4 node located\
    \ in\n   the IPv4 site.\n   In some cases, this scenario can be addressed without\
    \ using any form\n   of DNS64 function.  This is because it is possible to assign\
    \ a fixed\n   IPv6 address to each of the IPv4 nodes.  Such an IPv6 address would\n\
    \   be constructed using the address transformation algorithm defined in\n   [RFC6052]\
    \ that takes as input the Pref64::/96 and the IPv4 address of\n   the IPv4 node.\
    \  Note that the IPv4 address can be a public or a\n   private address; the latter\
    \ does not present any additional\n   difficulty, since an NSP must be used as\
    \ Pref64::/96 (in this\n   scenario, the usage of the Well-Known Prefix is not\
    \ supported as\n   discussed in [RFC6052]).  Once these IPv6 addresses have been\n\
    \   assigned to represent the IPv4 nodes in the IPv6 Internet, real AAAA\n   RRs\
    \ containing these addresses can be published in the DNS under the\n   site's\
    \ domain.  This is the recommended approach to handle this\n   scenario, because\
    \ it does not involve synthesizing AAAA records at\n   the time of query.\n  \
    \ However, there are some more dynamic scenarios, where synthesizing\n   AAAA\
    \ RRs in this setup may be needed.  In particular, when DNS Update\n   [RFC2136]\
    \ is used in the IPv4 site to update the A RRs for the IPv4\n   nodes, there are\
    \ two options.  One option is to modify the DNS server\n   that receives the dynamic\
    \ DNS updates.  That would normally be the\n   authoritative server for the zone.\
    \  So the authoritative zone would\n   have normal AAAA RRs that are synthesized\
    \ as dynamic updates occur.\n   The other option is to modify all of the authoritative\
    \ servers to\n   generate synthetic AAAA records for a zone, possibly based on\n\
    \   additional constraints, upon the receipt of a DNS query for the AAAA\n   RR.\
    \  The first option -- in which the AAAA is synthesized when the\n   DNS update\
    \ message is received, and the data published in the\n   relevant zone -- is recommended\
    \ over the second option (i.e., the\n   synthesis upon receipt of the AAAA DNS\
    \ query).  This is because it is\n   usually easier to solve problems of misconfiguration\
    \ when the DNS\n   responses are not being generated dynamically.  However, it\
    \ may be\n   the case where the primary server (that receives all the updates)\n\
    \   cannot be upgraded for whatever reason, but where a secondary can be\n   upgraded\
    \ in order to handle the (comparatively small amount of) AAAA\n   queries.  In\
    \ such a case, it is possible to use the DNS64 as\n   described next.  The DNS64\
    \ behavior that we describe in this section\n   covers the case of synthesizing\
    \ the AAAA RR when the DNS query\n   arrives.\n   The scenario for this case is\
    \ depicted in the following figure:\n              +-----------+          +----------------------+\n\
    \              |           |          |   IPv4 site          |\n             \
    \ |   IPv6    |    +------------+  |   +----+   |\n              | Internet  |----|\
    \ IPv6/IPv4  |--|---| H2 |   |\n              |           |    | Translator |\
    \  |   +----+   |\n              |           |    +------------+  |          \
    \  |\n              |           |          |         | 192.0.2.1  |\n        \
    \      |           |    +------------+  |            |\n              |      \
    \     |----| Name server|--|            |\n              |           |    | with\
    \ DNS64 |  |            |\n              +-----------+    +------------+  |  \
    \          |\n                |                    |         |            |\n\
    \              +----+                 |                      |\n             \
    \ | H1 |                 +----------------------+\n              +----+\n    \
    \      Figure 6:  \"The IPv6 Internet to an IPv4 Network\" Setup\n           \
    \            with DNS64 in DNS Server Mode\n   The figure shows an IPv6 node H1\
    \ and an IPv4 node H2 with the IPv4\n   address 192.0.2.1 and FQDN h2.example.com.\n\
    \   The IPv6/IPv4 translator is using an NSP 2001:db8::/96 to create IPv6\n  \
    \ representations of IPv4 addresses.  The same prefix is configured in\n   the\
    \ DNS64 function in the local name server.  The name server that\n   implements\
    \ the DNS64 function is the authoritative name server for\n   the local domain.\n\
    \   The steps by which H1 establishes communication with H2 are:\n   1.  H1 does\
    \ a DNS lookup for h2.example.com.  H1 does this by sending\n       a DNS query\
    \ for a AAAA record for H2.  The query is eventually\n       forwarded to the\
    \ server in the IPv4 site.\n   2.  The local DNS server resolves the query (locally),\
    \ and discovers\n       that there are no AAAA records for H2.\n   3.  The name\
    \ server verifies that h2.example.com and its A RR are\n       among those that\
    \ the local policy defines as allowed to generate\n       a AAAA RR.  If that\
    \ is the case, the name server synthesizes a\n       AAAA record from the A RR\
    \ and the prefix 2001:db8::/96.  The IPv6\n       address in the AAAA record is\
    \ 2001:db8::192.0.2.1.\n   4.  H1 receives the synthetic AAAA record and sends\
    \ a packet towards\n       H2.  The packet is sent to the destination address\
    \ 2001:db8::\n       192.0.2.1.\n   5.  The packet is routed through the IPv6\
    \ Internet to the IPv6\n       interface of the IPv6/IPv4 translator and the communication\
    \ flows\n       using the IPv6/IPv4 translator mechanisms.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   DNS64 operates in combination with the DNS, and\
    \ is therefore subject\n   to whatever security considerations are appropriate\
    \ to the DNS mode\n   in which the DNS64 is operating (i.e., authoritative, recursive,\
    \ or\n   stub-resolver mode).\n   DNS64 has the potential to interfere with the\
    \ functioning of DNSSEC,\n   because DNS64 modifies DNS answers, and DNSSEC is\
    \ designed to detect\n   such modifications and to treat modified answers as bogus.\
    \  See the\n   discussion above in Sections 3, 5.5, and 6.2.\n   Additionally,\
    \ for the correct functioning of the translation\n   services, the DNS64 and the\
    \ NAT64 need to use the same Pref64.  If an\n   attacker manages to change the\
    \ Pref64 used by the DNS64, the traffic\n   generated by the host that receives\
    \ the synthetic reply will be\n   delivered to the altered Pref64.  This can result\
    \ in either a denial-\n   of-service (DoS) attack (if the resulting IPv6 addresses\
    \ are not\n   assigned to any device), a flooding attack (if the resulting IPv6\n\
    \   addresses are assigned to devices that do not wish to receive the\n   traffic),\
    \ or an eavesdropping attack (in case the Pref64 is routed\n   through the attacker).\n"
- title: 9.  Contributors
  contents:
  - "9.  Contributors\n   Dave Thaler\n   Microsoft\n   dthaler@windows.microsoft.com\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   This document contains the result of discussions involving\
    \ many\n   people, including the participants of the IETF BEHAVE Working Group.\n\
    \   The following IETF participants made specific contributions to parts\n   of\
    \ the text, and their help is gratefully acknowledged: Jaap\n   Akkerhuis, Mark\
    \ Andrews, Jari Arkko, Rob Austein, Timothy Baldwin,\n   Fred Baker, Doug Barton,\
    \ Marc Blanchet, Cameron Byrne, Brian\n   Carpenter, Zhen Cao, Hui Deng, Francis\
    \ Dupont, Patrik Faltstrom,\n   David Harrington, Ed Jankiewicz, Peter Koch, Suresh\
    \ Krishnan, Martti\n   Kuparinen, Ed Lewis, Xing Li, Bill Manning, Matthijs Mekking,\
    \ Hiroshi\n   Miyata, Simon Perrault, Teemu Savolainen, Jyrki Soini, Dave Thaler,\n\
    \   Mark Townsley, Rick van Rein, Stig Venaas, Magnus Westerlund, Jeff\n   Westhead,\
    \ Florian Weimer, Dan Wing, Xu Xiaohu, and Xiangsong Cui.\n   Marcelo Bagnulo\
    \ and Iljitsch van Beijnum are partly funded by\n   Trilogy, a research project\
    \ supported by the European Commission\n   under its Seventh Framework Program.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names -\
    \ concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n\
    \   [RFC1035]  Mockapetris, P., \"Domain names - implementation and\n        \
    \      specification\", STD 13, RFC 1035, November 1987.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC2671]  Vixie, P., \"Extension Mechanisms\
    \ for DNS (EDNS0)\",\n              RFC 2671, August 1999.\n   [RFC4787]  Audet,\
    \ F. and C. Jennings, \"Network Address Translation\n              (NAT) Behavioral\
    \ Requirements for Unicast UDP\", BCP 127,\n              RFC 4787, January 2007.\n\
    \   [RFC6052]  Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X.\n    \
    \          Li, \"IPv6 Addressing of IPv4/IPv6 Translators\", RFC 6052,\n     \
    \         October 2010.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [DEFAULT-LOCAL-ZONES]\n              Andrews,\
    \ M., \"Locally-served DNS Zones\", Work in Progress,\n              March 2011.\n\
    \   [RFC2136]  Vixie, P., Thomson, S., Rekhter, Y., and J. Bound,\n          \
    \    \"Dynamic Updates in the Domain Name System (DNS UPDATE)\",\n           \
    \   RFC 2136, April 1997.\n   [RFC2308]  Andrews, M., \"Negative Caching of DNS\
    \ Queries (DNS\n              NCACHE)\", RFC 2308, March 1998.\n   [RFC3484] \
    \ Draves, R., \"Default Address Selection for Internet\n              Protocol\
    \ version 6 (IPv6)\", RFC 3484, February 2003.\n   [RFC3596]  Thomson, S., Huitema,\
    \ C., Ksinant, V., and M. Souissi,\n              \"DNS Extensions to Support\
    \ IP Version 6\", RFC 3596,\n              October 2003.\n   [RFC4033]  Arends,\
    \ R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"DNS Security\
    \ Introduction and Requirements\",\n              RFC 4033, March 2005.\n   [RFC4034]\
    \  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,\
    \ \"Resource Records for the DNS Security Extensions\",\n              RFC 4034,\
    \ March 2005.\n   [RFC4035]  Arends, R., Austein, R., Larson, M., Massey, D.,\
    \ and S.\n              Rose, \"Protocol Modifications for the DNS Security\n\
    \              Extensions\", RFC 4035, March 2005.\n   [RFC4074]  Morishita, Y.\
    \ and T. Jinmei, \"Common Misbehavior Against\n              DNS Queries for IPv6\
    \ Addresses\", RFC 4074, May 2005.\n   [RFC5735]  Cotton, M. and L. Vegoda, \"\
    Special Use IPv4 Addresses\",\n              BCP 153, RFC 5735, January 2010.\n\
    \   [RFC6144]  Baker, F., Li, X., Bao, C., and K. Yin, \"Framework for\n     \
    \         IPv4/IPv6 Translation\", RFC 6144, April 2011.\n   [RFC6146]  Bagnulo,\
    \ M., Matthews, P., and I. van Beijnum, \"Stateful\n              NAT64: Network\
    \ Address and Protocol Translation from IPv6\n              Clients to IPv4 Servers\"\
    , RFC 6146, April 2011.\n"
- title: Appendix A.  Motivations and Implications of Synthesizing AAAA Resource
  contents:
  - "Appendix A.  Motivations and Implications of Synthesizing AAAA Resource\n   \
    \          Records when Real AAAA Resource Records Exist\n   The motivation for\
    \ synthesizing AAAA RRs when real AAAA RRs exist is\n   to support the following\
    \ scenario:\n   o  An IPv4-only server application (e.g., web server software)\
    \ is\n      running on a dual-stack host.  There may also be dual-stack server\n\
    \      applications running on the same host.  That host has fully\n      routable\
    \ IPv4 and IPv6 addresses, and hence the authoritative DNS\n      server has an\
    \ A record and a AAAA record.\n   o  An IPv6-only client (regardless of whether\
    \ the client application\n      is IPv6-only, the client stack is IPv6-only, or\
    \ it only has an\n      IPv6 address) wants to access the above server.\n   o\
    \  The client issues a DNS query to a DNS64 resolver.\n   If the DNS64 only generates\
    \ a synthetic AAAA if there's no real AAAA,\n   then the communication will fail.\
    \  Even though there's a real AAAA,\n   the only way for communication to succeed\
    \ is with the translated\n   address.  So, in order to support this scenario,\
    \ the administrator of\n   a DNS64 service may want to enable the synthesis of\
    \ AAAA RRs even\n   when real AAAA RRs exist.\n   The implication of including\
    \ synthetic AAAA RRs when real AAAA RRs\n   exist is that translated connectivity\
    \ may be preferred over native\n   connectivity in some cases where the DNS64\
    \ is operated in DNS server\n   mode.\n   RFC 3484 [RFC3484] rules use \"longest\
    \ matching prefix\" to select the\n   preferred destination address to use.  So,\
    \ if the DNS64 resolver\n   returns both the synthetic AAAA RRs and the real AAAA\
    \ RRs, then if\n   the DNS64 is operated by the same domain as the initiating\
    \ host, and\n   a global unicast prefix (referred to as a Network-Specific Prefix\n\
    \   (NSP) in [RFC6052]) is used, then a synthetic AAAA RR is likely to be\n  \
    \ preferred.\n   This means that without further configuration:\n   o  In the\
    \ \"an IPv6 network to the IPv4 Internet\" scenario, the host\n      will prefer\
    \ translated connectivity if an NSP is used.  If the\n      Well-Known Prefix\
    \ defined in [RFC6052] is used, it will probably\n      prefer native connectivity.\n\
    \   o  In the \"IPv6 Internet to an IPv4 network\" scenario, it is possible\n\
    \      to bias the selection towards the real AAAA RR if the DNS64\n      resolver\
    \ returns the real AAAA first in the DNS reply, when an NSP\n      is used (the\
    \ Well-Known Prefix usage is not supported in this\n      case).\n   o  In the\
    \ \"an IPv6 network to an IPv4 network\" scenario, for local\n      destinations\
    \ (i.e., target hosts inside the local site), it is\n      likely that the NSP\
    \ and the destination prefix are the same, so we\n      can use the order of RR\
    \ in the DNS reply to bias the selection\n      through native connectivity. \
    \ If the Well-Known Prefix is used,\n      the \"longest matching prefix\" rule\
    \ will select native\n      connectivity.\n   The problem can be solved by properly\
    \ configuring the RFC 3484\n   [RFC3484] policy table.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Marcelo Bagnulo\n   UC3M\n   Av. Universidad 30\n   Leganes,\
    \ Madrid  28911\n   Spain\n   Phone: +34-91-6249500\n   EMail: marcelo@it.uc3m.es\n\
    \   URI:   http://www.it.uc3m.es/marcelo\n   Andrew Sullivan\n   Shinkuro\n  \
    \ 4922 Fairmont Avenue, Suite 250\n   Bethesda, MD  20814\n   USA\n   Phone: +1\
    \ 301 961 3131\n   EMail: ajs@shinkuro.com\n   Philip Matthews\n   Unaffiliated\n\
    \   600 March Road\n   Ottawa, Ontario\n   Canada\n   Phone: +1 613-592-4343 x224\n\
    \   EMail: philip_matthews@magma.ca\n   Iljitsch van Beijnum\n   IMDEA Networks\n\
    \   Avda. del Mar Mediterraneo, 22\n   Leganes, Madrid  28918\n   Spain\n   Phone:\
    \ +34-91-6246245\n   EMail: iljitsch@muada.com\n"
