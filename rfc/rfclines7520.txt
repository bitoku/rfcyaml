Abstract This document contains a set of examples using JSON Object Signing and Encryption (JOSE) technology to protect data.
These examples present a representative sampling of JSON Web Key (JWK) objects as well as various JSON Web Signature (JWS) and
JSON Web Encryption (JWE) results given similar inputs.
The JSON Object Signing and Encryption (JOSE
JSON Web Signature [JWS], JSON Web Encryption [JWE]
, JSON Web Key [JWK], and JSON Web Algorithms [JWA]   can be used collectively to encrypt and/or sign content using a variety of algorithms.
While the full set of permutations is extremely large, and might be daunting to some, it is expected that most applications will only use a small set of algorithms to meet their needs.
This document provides a number of examples of signing or encrypting content using JOSE.
While not exhaustive, it does compile a representative sampling of JOSE features.
As much as possible, the same signature payload or encryption plaintext content is used to illustrate differences in various signing and encryption results.
This document also provides a number of example JWK objects.
These examples illustrate the distinguishing properties of various key types and emphasize important characteristics.
Most of the JWK examples are then used in the signature or encryption examples that follow.
All of the examples contained herein are available in a machine  readable format at <https://github.com/ietf jose/cookbook>. 1.1.
Conventions Used in This Document
This document separates data that are expected to be input to an implementation of JOSE from data that are expected to be generated by an implementation of JOSE.
Each example, wherever possible, provides enough information both to replicate the results of this document and to validate the results by running its inverse operation (e.g., signature results can be validated by performing the JWS verify).
However, some algorithms inherently use random data; therefore, computations employing them cannot be exactly replicated.
Such cases are explicitly stated in the relevant sections.
All instances of binary octet strings are represented using base64url
Wherever possible and unless otherwise noted, the examples include the JWS or JWE Compact Serialization, general JWS or JWE JSON Serialization, and flattened JWS or JWE JSON Serialization.
All of the examples in this document have whitespace added to improve formatting and readability.
Except for JWE Plaintext or JWS Payload content, whitespace is not part of the cryptographic operations nor the exchange results.
characters to improve readability but are not present in the JWE Plaintext or JWS Payload.
This document inherits terminology regarding JSON Web Signature (JWS) technology from [JWS], terminology regarding JSON Web Encryption (JWE) technology from [JWE], terminology regarding JSON Web Key (JWK) technology from [JWK], and terminology regarding algorithms from [JWA].
The following sections demonstrate how to represent various JWK and JWK Set objects.
This example illustrates an Elliptic Curve (EC)
This example is the public key corresponding to the private key in Figure 2.
The field "kty" value of "EC" identifies this as an Elliptic Curve key.
The field "crv" identifies the curve, which is curve P 521 for this example.
The values of the fields "x" and "y" are the base64url encoded X and Y coordinates (respectively).
The values of the fields "x" and "y" decoded are the octets necessary to represent each full coordinate to the order of the curve.
For a key over curve P 521, the values of the fields "
x" and "y" are exactly 66 octets in length when decoded, padded with leading zero (0x00) octets to reach the expected length.
This example illustrates an Elliptic Curve private key.
This example is the private key corresponding to the public key in Figure 1.
The field "kty" value of "EC" identifies this as an Elliptic Curve key.
The field "crv" identifies the curve, which is curve P 521 (also known as SECG curve secp521r1) for this example.
The values of the fields "x" and "y" are the base64url encoded X and Y coordinates (respectively).
The field "d" value is the base64url encoded private key.
The values of the fields "d", "x", and "y" decoded are the octets necessary to represent the private key or each full coordinate (respectively) to the order of the curve.
For a key over curve P 521, the values of the "d", "x", and "y" fields are each exactly 66 octets in length when decoded, padded with leading zero (0x00) octets to reach the expected length.
This example illustrates an RSA public key.
This example is the public key corresponding to the private key in Figure 4.
HdrNP5zw", "e": "AQAB" } Figure 3: RSA 2048 Bit Public Key
The field "kty" value of "RSA" identifies this as an RSA key.
The fields "n" and "e" values are the modulus and (public) exponent (respectively) using the minimum octets necessary.
For a 2048 bit key, the field "n" value is 256 octets in length when decoded.
This example illustrates an RSA private key.
This example is the private key corresponding to the public key in Figure 3.
HdrNP5zw", "e": "AQAB", "d": "bWUC9B EFRIo8kpGfh0ZuyGPvMNKvYWNtB ikiH9k20eT
iZkpXxXQ0UTEs2LsNRS 8uJbvQ A1irkwMSMkK1J3XTGgdrhCku9gRld Y7sNA AKZGh
MwWWSDFu2MUBYwkHTMEzLYGqOe04noqeq1hExBTHBOBdkMXiuFhUq1BU 6l DqEiWxqg82sXt2h LMnT3046AOYJoRioz75tSUQfGCshWTBnP5uDj d18kKhyv07lhfSJdrPdM5Plyl21hsFf4L mHCuoFau7gdsPfHPxxjVOc OpBrQzwQ", "p": "
3Slxg DwTXJcb6095RoXygQCAZ5RnAvZlno1yhHtnUex fp7AZ 9nR aO7HX  SFfGQeutao2TDjDAWU4Vupk8rw9JR0AzZ0N2fvuIAmr
", "q": "uKE2dh cTf6ERF4k4e jy78GfPYUIaUyoSSJuBzp3Cubk3OCqs6grT 8bR cu0Dm1MZwWmtdqDyI95HrUeq3MP15vMMON8lHTeZu2lmKvwqW7an V5UzhM1iZ7z4yMkuUwFWoBvyY898EXvRD hdqRxHlSqAZ192zB3pVFJ0 s7pFc", "dp": "B8PVvXkvJrj2L GYQ7v3y9r6Kw5g9SahXBwsWUzp19TVlgI
bi 7k vJgGHwHxgPaX2PnvP zyEkDERuf ry4c Z11Cq9AqC2yeL6kdK T1cYF8", "qi": "3PiqvXQN0zwMeE sBvZgi289XP9XCQF3VWqPzMKnIgQp7 Tugo6
" } Figure 4: RSA 2048 Bit
The field "kty" value of "RSA" identifies this as an RSA key.
The fields "n" and "e" values are the base64url encoded modulus and (public) exponent (respectively) using the minimum number of octets necessary.
The field "d" value is the base64url encoded private exponent using the minimum number of octets necessary.
The fields "p", "q", "dp", "dq", and "qi" are the base64url encoded additional private information using the minimum number of octets necessary.
For a 2048 bit key, the field "n" is 256 octets in length when decoded, and the field "d" is not longer than 256 octets in length when decoded.
This example illustrates a symmetric key used for computing Message Authentication Codes (MACs).
HMAC SHA 256 Symmetric Key
The field "kty" value of "oct" identifies this as a symmetric key.
The field "k" value is the symmetric key.
When used for the signing algorithm "HS256" (HMAC SHA256), the field "k" value is 32 octets (or more) in length when decoded, padded with leading zero (0x00)
octets to reach the minimum expected length.
This example illustrates a symmetric key used for encryption.
e8d68773842d", "use": "enc", "alg": "A256GCM", "k": "AAPapAv4LbFbiVawEjagUBluYqN5rhna 8nuldDvOx8
AES 256 Bit Symmetric Encryption
The field "kty" value of "oct" identifies this as a symmetric key.
The field "k" value is the symmetric key.
For the content encryption algorithm "A256GCM", the field "k" value is exactly 32 octets in length when decoded, padded with leading zero (0x00)
octets to reach the expected length.
The following sections demonstrate how to generate various JWS objects.
All of the signature examples use the following payload content (an abridged quote from "The Fellowship of the Ring" [LOTR FELLOWSHIP]), serialized as UTF 8.
The payload is presented here as a series of quoted strings that are concatenated to produce the JWS Payload.
The sequence "\xe2\x80\x99" is substituted for (U 2019 RIGHT SINGLE QUOTATION MARK), and quotation marks (U 0022 QUOTATION MARK) are added for readability but are not present in the JWS Payload. "
It\xe2\x80\x99s a dangerous business, Frodo, going out your " "door.
no knowing where you might be swept off " "to."
Figure 7: Payload Content Plaintext
The payload   with the sequence "\xe2\x80\x99" replaced with (U 2019 RIGHT SINGLE QUOTATION MARK) and quotations marks (U 0022 QUOTATION MARK) are removed   is encoded as UTF 8 and then as base64url
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 8:
Payload Content, base64url encoded 4.1.
This example illustrates signing content using the "RS256" (RSASSA  PKCS1 v1 5 with SHA 256) algorithm.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
RSA private key; this example uses the key from Figure 4.
The following is generated to complete the signing operation:  JWS Protected Header; this example uses the header from Figure 9, encoded using base64url
JWS Protected Header JSON eyJhbGciOiJSUzI1NiIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZX
JWS Protected Header, base64url encoded The JWS Protected Header (Figure 10) and JWS Payload (Figure 8) are combined as described in Section 5.1 of [JWS] to produce the JWS Signing Input (Figure 11).
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 11:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 11) produces the JWS Signature (Figure 12).
JWS Signature, base64url encoded 4.1.3.
The following compose the resulting JWS object:  JWS Protected Header
(Figure 8)  Signature (Figure 12)
The resulting JWS object using the JWS Compact Serialization: eyJhbGciOiJSUzI1NiIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZX hhbXBsZSJ9 .
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 .
Z29pbmcgb3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9h ZCwgYW5kIGlmIHlvdSBkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXi gJlzIG5vIGtub3dpbmcgd2hlcmUgeW91IG1pZ2h0IGJlIHN3ZXB0IG9m ZiB0by4", "protected": "
eyJhbGciOiJSUzI1NiIsImtpZCI6ImJpbGJvLmJhZ2dpbn NAaG9iYml0b24uZXhhbXBsZSJ9", "signature": "MRjdkly7  oTPTS3AXP41iQIGKa80A0ZmTuV5MEaHoxnW2 e5CZ5NlKtainoFmKZopdHM1O2U4mwzJdQx996ivp83xuglII7PNDi84w
XtL0RnltuYv746iYTh q HRD68BNt1uSNCrUCTJDt5aAE6x8wW1Kt9eRo4QPocSadnHXFxnt8Is9U zpERV0ePPQdLuW3IS de3xyIrDaLGdjluPxUAhb6L2aXic1U12podGU0 KLUQSE
Flattened JWS JSON Serialization 4.2.
This example illustrates signing content using the "PS384" (RSASSA  PSS with SHA 384) algorithm.
Note that RSASSA PSS uses random data to generate the signature; it might not be possible to exactly replicate the results in this section.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
RSA private key; this example uses the key from Figure 4.
The following is generated to complete the signing operation:  JWS Protected Header; this example uses the header from Figure 16, encoded using base64url
JWS Protected Header JSON eyJhbGciOiJQUzM4NCIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZX
JWS Protected Header, base64url encoded The JWS Protected Header (Figure 17) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 18:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 18) produces the JWS Signature (Figure 19).
e8P ijQ7p8Vdz0TTrxUeT3lm8d9shnr2lfJT8ImUjvAA2Xez2Mlp8cBE5awDzT 0qI0n6uiP1aCN 2 jLAeQTlqRHtfa64QQSUmFAAjVKPbByi7xho0uTOcbH510a 6GYmJUAfmWjwZ6oD4ifKo8DYM X72Eaw Figure 19
: JWS Signature, base64url encoded 4.2.3.
The following compose the resulting JWS object:  JWS Protected Header
(Figure 8)  Signature (Figure 19)
The resulting JWS object using the JWS Compact Serialization:
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 .
e8P ijQ7p8Vdz0TTrxUeT3lm8d9shnr2lfJT8ImUjvAA2Xez2Mlp8cBE5awDzT 0qI0n6uiP1aCN 2 jLAeQTlqRHtfa64QQSUmFAAjVKPbByi7xho0uTOcbH510a 6GYmJUAfmWjwZ6oD4ifKo8DYM X72Eaw Figure 20
eyJhbGciOiJQUzM4NCIsImtpZCI6ImJpbGJvLmJhZ2 dpbnNAaG9iYml0b24uZXhhbXBsZSJ9", "signature": "cu22eBqkYDKgIlTpzDXGvaFfz6WGoz7fUDcfT0kkOy 42miAh2qyBzk1xEsnk2IpN6
Figure 21: General JWS JSON Serialization
Z29pbmcgb3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9h ZCwgYW5kIGlmIHlvdSBkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXi gJlzIG5vIGtub3dpbmcgd2hlcmUgeW91IG1pZ2h0IGJlIHN3ZXB0IG9m ZiB0by4", "protected": "eyJhbGciOiJQUzM4NCIsImtpZCI6ImJpbGJvLmJhZ2dpbn
2 jLAeQT lqRHtfa64QQSUmFAAjVKPbByi7xho0uTOcbH510a6GYmJUAfmWjwZ6oD 4ifKo8DYM X72Eaw
Flattened JWS JSON Serialization 4.3.
This example illustrates signing content using the "ES512" (Elliptic Curve Digital Signature Algorithm (ECDSA) with curve P 521 and SHA  512) algorithm.
Note that ECDSA uses random data to generate the signature; it might not be possible to exactly replicate the results in this section.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
EC private key on the curve P 521; this example uses the key from Figure 2.
The following is generated before beginning the signature process:
; this example uses the header from Figure 23, encoded using base64url
JWS Protected Header JSON eyJhbGciOiJFUzUxMiIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZX hhbXBsZSJ9
JWS Protected Header, base64url encoded The JWS Protected Header (Figure 24) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input (Figure 25).
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 25:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 25) produces the JWS Signature (Figure 26).
JWS Signature, base64url encoded 4.3.3.
The following compose the resulting JWS object:  JWS Protected Header (Figure 24)
(Figure 8)  Signature (Figure 26)
The resulting JWS object using the JWS Compact Serialization: eyJhbGciOiJFUzUxMiIsImtpZCI6ImJpbGJvLmJhZ2dpbnNAaG9iYml0b24uZX hhbXBsZSJ9 .
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 .
AE R YZCChjn4791jSQCrdPZCNYqHXCTZH0 JZGYNl aAjP2kqaluUIIUnC9qvbu9Plon7KRTzoNEuT4Va2cmL1eJAQy3mt PBu u sDDyYjnAMDxXPn7XrT0lw kvAD890jl8e2puQens IEKBp
Z29pbmcgb3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9h ZCwgYW5kIGlmIHlvdSBkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXi gJlzIG5vIGtub3dpbmcgd2hlcmUgeW91IG1pZ2h0IGJlIHN3ZXB0IG9m ZiB0by4", "protected": "
NAaG9iYml0b24uZXhhbXBsZSJ9", "signature": "AE R YZCChjn4791jSQCrdPZCNYqHXCTZH0
IEKBpHABlsbEPX6sF Y8OcGDqoRuBomu9xQ2" } Figure 29:
Flattened JWS JSON Serialization 4.4.
This example illustrates integrity protecting content using the "HS256" (HMAC SHA 256) algorithm.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
; this example uses the key from Figure 5.
The following is generated before completing the signing operation:
; this example uses the header from Figure 30, encoded using base64url
JWS Protected Header JSON eyJhbGciOiJIUzI1NiIsImtpZCI6IjAxOGMwYWU1LTRkOWItNDcxYi1iZmQ2LW VlZjMxNGJjNzAzNyJ9 Figure 31:
JWS Protected Header, base64url encoded The JWS Protected Header (Figure 31) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input (Figure 32).
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 32:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 32) produces the JWS Signature (Figure 33).
JWS Signature, base64url encoded 4.4.3.
The following compose the resulting JWS object:  JWS Protected Header
The resulting JWS object using the JWS Compact Serialization: eyJhbGciOiJIUzI1NiIsImtpZCI6IjAxOGMwYWU1LTRkOWItNDcxYi1iZmQ2LW VlZjMxNGJjNzAzNyJ9 .
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 .
Z29pbmcgb3V0IHlvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9h ZCwgYW5kIGlmIHlvdSBkb24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXi gJlzIG5vIGtub3dpbmcgd2hlcmUgeW91IG1pZ2h0IGJlIHN3ZXB0IG9m ZiB0by4", "protected": "eyJhbGciOiJIUzI1NiIsImtpZCI6IjAxOGMwYWU1LTRkOW ItNDcxYi1iZmQ2LWVlZjMxNGJjNzAzNyJ9", "signature": "s0h6KThzkfBBBkLspW1h84VsJZFTsPPqMDA7g1Md7p0" } Figure 36: Flattened JWS JSON Serialization 4.5.
This example illustrates a signature with detached content.
This example is identical to other examples in Section 4, except the resulting JWS objects do not include the JWS Payload field.
Instead, the application is expected to locate it elsewhere.
For example, the signature might be in a metadata section, with the payload being the content.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
Signing key; this example uses the AES symmetric key from Figure 5.
Signing algorithm; this example uses "HS256".
The following is generated before completing the signing operation:
; this example uses the header from Figure 37, encoded using base64url
JWS Protected Header JSON eyJhbGciOiJIUzI1NiIsImtpZCI6IjAxOGMwYWU1LTRkOWItNDcxYi1iZmQ2LW VlZjMxNGJjNzAzNyJ9 Figure 38:
JWS Protected Header, base64url encoded The JWS Protected Header (Figure 38) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input (Figure 39).
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 39:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 39) produces the JWS Signature (Figure 40).
JWS Signature, base64url encoded 4.5.3.
The following compose the resulting JWS object:  JWS Protected Header (Figure 38)
The resulting JWS object using the JWS Compact Serialization: eyJhbGciOiJIUzI1NiIsImtpZCI6IjAxOGMwYWU1LTRkOWItNDcxYi1iZmQ2LW VlZjMxNGJjNzAzNyJ9 .
This example illustrates a signature where only certain Header Parameters are protected.
Since this example contains both unprotected and protected Header Parameters, only the general JWS JSON Serialization and flattened JWS JSON Serialization are possible.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
Signing key; this example uses the AES symmetric key from Figure 5.
Signing algorithm; this example uses "HS256".
The following are generated before completing the signing operation:
; this example uses the header from Figure 44, encoded using base64url
[RFC4648] to produce Figure 45.
JWS Unprotected Header; this example uses the header from Figure 46.
{ "alg": "HS256" } Figure 44:
JWS Protected Header JSON eyJhbGciOiJIUzI1NiJ9 Figure 45:
JWS Protected Header, base64url encoded { "kid": "018c0ae5 4d9b 471b bfd6 eef314bc7037
" } Figure 46: JWS Unprotected Header JSON
The JWS Protected Header (Figure 45) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input (Figure 47).
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 47:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 47) produces the JWS Signature (Figure 48).
Figure 48: JWS Signature, base64url encoded 4.6.3.
The following compose the resulting JWS object:  JWS Protected Header
The JWS Compact Serialization is not presented because it does not support this use case.
Flattened JWS JSON Serialization 4.7.
Only This example illustrates a signature where none of the Header Parameters are protected.
Since this example contains only unprotected Header Parameters, only the general JWS JSON Serialization and flattened JWS JSON Serialization are possible.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
Signing key; this example uses the AES symmetric key from Figure 5.
Signing algorithm; this example uses "HS256".
The empty string (as there is no JWS Protected Header) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input (Figure 52). .
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 52:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 52) produces the JWS Signature (Figure 53).
JWS Signature, base64url encoded 4.7.3.
The following compose the resulting JWS object:  JWS Unprotected Header (Figure 51)
The JWS Compact Serialization is not presented because it does not support this use case.
This example illustrates multiple signatures applied to the same payload.
Since this example contains more than one signature, only the JSON General Serialization is possible.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the content from Figure 7, encoded using base64url
[RFC4648] to produce Figure 8.
The following are generated before completing the first signing operation:
; this example uses the header from Figure 56, encoded using base64url
[RFC4648] to produce Figure 57.
JWS Unprotected Header; this example uses the header from Figure 58.
{ "alg": "RS256" } Figure 56: Signature
#1 JWS Protected Header JSON eyJhbGciOiJSUzI1NiJ9 Figure 57: Signature #1 JWS Protected Header, base64url encoded { "kid": "bilbo.baggins@hobbiton.example
" } Figure 58: Signature #1 JWS Unprotected Header JSON
The JWS Protected Header (Figure 57) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input (Figure 59).
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 59:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 59) produces the JWS Signature (Figure 60).
BG5t4sdbuCHtFjp9iJmkio47AIwqkZV1aIZsv33uPUqB BCXbYoQJwt7mxPftHmNlGoOSMxR 3thmXTCm4US xiNOyhbm8afKK64jU6 TPt QHiJeQJxz9G3Tx 083B745 AfYOnlC9w
JWS Signature #1, base64url encoded
qptrzZc7CG6Svw2Y13TDIqHzTUrL lR2ZFcryNFiHkS w129EghGpwkpxaTn THJTCglNbADko1MZBCdwzJxwqZc 1RlpO2HibUY
The following is generated before completing the second signing operation:  JWS Unprotected Header; this example uses the header from Figure 62.
{ "alg": "ES512", "kid": "
bilbo.baggins@hobbiton.example" } Figure 62: Signature #2 JWS Unprotected Header JSON
The empty string (as there is no JWS Protected Header) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input (Figure 63). .
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 63:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 63) produces the JWS Signature (Figure 64).
ARcVLnaJJaUWG8fG 8t5BREVAuTY8n8YHjwDO1muhcdCoFZFFjfISu0Cdkn9Yb dlmi54ho0x924DUz8sK7ZXkhc7AFM8ObLfTvNCrqcI3Jkl2U5IX3utNhODH6v7 xgy1Qahsn0fyb4zSAkje8bAWz4vIfj5pCMYxxm4fgV3q7ZYhm5eD Figure 64:
JWS Signature #2, base64url encoded
The following is generated before completing the third signing operation:
; this example uses the header from Figure 66, encoded using base64url
Signature #3 JWS Protected Header JSON eyJhbGciOiJIUzI1NiIsImtpZCI6IjAxOGMwYWU1LTRkOWItNDcxYi1iZmQ2LW VlZjMxNGJjNzAzNyJ9 Figure 67:
Signature #3 JWS Protected Header, base64url encoded The JWS Protected Header (Figure 67) and JWS Payload (Figure 8) are combined as described in [JWS] to produce the JWS Signing Input
SXTigJlzIGEgZGFuZ2Vyb3VzIGJ1c2luZXNzLCBGcm9kbywgZ29pbmcgb3V0IH lvdXIgZG9vci4gWW91IHN0ZXAgb250byB0aGUgcm9hZCwgYW5kIGlmIHlvdSBk b24ndCBrZWVwIHlvdXIgZmVldCwgdGhlcmXigJlzIG5vIGtub3dpbmcgd2hlcm UgeW91IG1pZ2h0IGJlIHN3ZXB0IG9mZiB0by4 Figure 68:
JWS Signing Input Performing the signature operation over the JWS Signing Input
(Figure 68) produces the JWS Signature (Figure 69).
JWS Signature #3, base64url encoded
The following compose the resulting JWS object:  Payload content (Figure 8)  Signature #1 JSON (Figure 61)  Signature #2 JSON (Figure 65)  Signature #3 JSON (Figure 70)
The JWS Compact Serialization is not presented because it does not support this use case; the flattened JWS JSON Serialization is not presented because there is more than one signature.
General JWS JSON Serialization 5.
The following sections demonstrate how to generate various JWE objects.
All of the encryption examples (unless otherwise noted) use the following Plaintext content (an abridged quote from "The Fellowship of the Ring" [LOTR FELLOWSHIP]), serialized as UTF 8.
The Plaintext is presented here as a series of quoted strings that are concatenated to produce the JWE Plaintext.
The sequence "\xe2\x80\x93" is substituted for (U 2013 EN DASH), and quotation marks (U 0022 QUOTATION MARK) are added for readability but are not present in the JWE Plaintext.
"You can trust us to stick with you through thick and " "thin\xe2\x80\x93to the bitter end.
And you can trust us to " "keep any secret of yours\xe2\x80\x93closer than you keep it " "yourself.
But you cannot trust us to let you face trouble " "alone, and go off without a word.
We are your friends, Frodo."
Key Encryption Using RSA v1.5 and AES HMAC
This example illustrates encrypting content using the "RSA1 5" (RSAES PKCS1 v1 5) key encryption algorithm and the "A128CBC HS256" (AES 128 CBC HMAC SHA 256) content encryption algorithm.
Note that RSAES PKCS1 v1 5 uses random data to generate the ciphertext; it might not be possible to exactly replicate the results in this section.
Note that only the RSA public key is necessary to perform the encryption.
However, the example includes the RSA private key to allow readers to validate the output.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
RSA public key; this example uses the key from Figure 73.
"alg" parameter of "RSA1 5".
"enc" parameter of "A128CBC HS256".
{ "kty": "RSA", "kid": "frodo.baggins@hobbiton.example", "use": "enc", "n": "maxhbsmBtdQ3CNrKvprUE6n9lYcregDMLYNeTAWcLj8NnPU9XIYegT HVHQjxKDSHP2l F5jS7sppG1wgdAqZyhnWvXhYNvcM7RfgKxqNx
NwaAllhrd osQGPjIeI1deHTwx ZTHu3C60Pu LJIl6hKn9wbwaUmA4c R5Bd2pgbaY7ASgsjCUbtYJaNIHSoHXprUdJZKUMAzV0WOKPfA6OPI4oy pBadjvMZ4ZAj3BnXaSYsEZhaueTXvZB4eZOAjIyh2e VOIKVMsnDrJYA VotGlvMQ", "e": "AQAB", "d": "Kn9tgoHfiTVi8uPu5b9TnwyHwG5dK6RE0uFdlpCGnJN7ZEi963R7wy
miuPUxO8OpI9KDIfu acc6fg14nsNaJqXe6RESvhGPH2afjHqSy Fd2v pzj85bQQ", "p": "2DwQmZ43FoTnQ8IkUj3BmKRf5Eh2mizZA5xEJ2MinUE3sdTYKSLtaE oekX9vbBZuWxHdVhM6UnKCJ 2iNk8Z0ayLYHL0 G21aXf9 unynEpUsH 7HHTklLpYAzOOx1ZgVljoxAdWNn3hiEFrjZLZGS7lOH a3QQlDDQoJOJ 2VFmU", "q": "te8LY4 W7IyaqH1ExujjMqkTAlTeRbv0VLQnfLY2xINnrWdwiQ93 V F099aP1ESeLja2nw 6iKIe qT7mtCPozKfVtUYfz5HrJ XY2kfexJINb 9lhZHMv5p1skZpeIS GPHCC6gRlKo1q idn qxyusfWv7WAxlSVfQfk8 d6Et0", "dp": "UfYKcL or492vVc0PzwLSplbg4L3
zf9RmgJXkDrFs9rkdxPtAsL1WYdeCT5c125Fkdg317JV RDo1inX7x2Kdh8ERCreW8 4zXItuTl KiXZNU5lvMQjWbIw2eTx1lpsf lo0rYU", "dq": "iEgcO QfpepdH8FWd7mUFyrXdnOkXJBCogChY6YKuIHGc p8Le9Mb pFKESzEaLlN1Ehf3B6oGBl5Iz ayUlZj2IoQZ82znoUrpa9fVYNot87A CfzIG7q9Mv7RiPAderZi03tkVXAdaBau 9vs5rS 7HMtxkVrxSUvJY14 TkXlHE", "qi": "
kC lzZOqoFaZCr5l0tOVtREKoVqaAYhQiqIRGL MzS4sCmRkxm5vZ lXYx6RtE1n AagjqajlkjieGlxTTThHD8Iga6foGBMaAr5uR1hGQpSc7 Gl7CF1DZkBJMTQN6EshYzZfxW08mIO8M6Rzuh0beL6fG9mkDcIyPrBXx
2bQ mM" } Figure 73: RSA 2048 Bit Key, in JWK Format
(NOTE: While the key includes the private parameters, only the public parameters "e" and "n" are necessary for the encryption operation.)
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 74.
Initialization Vector; this example uses the Initialization Vector from Figure 75.
Content Encryption Key, base64url encoded bbd5sTkYwhAIqfHsx8DayA Figure 75:
Initialization Vector, base64url encoded 5.1.3.
Encrypting the Key Performing the key encryption operation over the CEK (Figure 74) with the RSA key (Figure 73) results in the following Encrypted Key:
G Xfz8YAImcc91Tfk0WXC2F5Xbb71ClQ1DDH151tlpH77f2ff7xiSxh9oSewYrcG TSLUeeCt36r1Kt3OSj7EyBQXoZlN7IxbyhMAfgIe7Mv1rOTOI5I8NQqeXXW8Vl zNmoxaGMny3YnGir5Wf6Qt2nBq4qDaPdnaAuuGUGEecelIO1wx1BpyIfgvfjOh MBs9M8XL223Fg47xlGsMXdfuY 4jaqVw Figure 76:
Encrypted Key, base64url encoded 5.1.4.
The following is generated before encrypting the Plaintext:
JWE Protected Header; this example uses the header from Figure 77, encoded using base64url
JWE Protected Header JSON eyJhbGciOiJSU0ExXzUiLCJraWQiOiJmcm9kby5iYWdnaW5zQGhvYmJpdG9uLm V4YW1wbGUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0 Figure 78:
JWE Protected Header, base64url encoded Performing the content encryption operation on the Plaintext (Figure 72) using the following:  CEK (Figure 74);  Initialization Vector (Figure 75); and
JWE Protected Header (Figure 77) as authenticated data produces the following:  Ciphertext from Figure 79.
Authentication Tag from Figure 80.
o5wR RsSzrS8Z wnI3Jvo0mkpEEnlDmZvDu k8O WzJv7eZVEqiWKdyVzFhPpiyQU28GLOpRc2VbVbK4dQKPdNTjPPEmRqcaGeTWZV
Ciphertext, base64url encoded kvKuFBXHe5mQr4lqgobAUg Figure 80:
Authentication Tag, base64url encoded 5.1.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 78)
The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJSU0ExXzUiLCJraWQiOiJmcm9kby5iYWdnaW5zQGhvYmJpdG9uLm V4YW1wbGUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0 .
pvSlWc9BRIazDrn50RcRai 3TDON395H3c62tIouJJ4XaRvYHFjZTZ2G Xfz8YAImcc91Tfk0WXC2F5Xbb71ClQ1DDH151tlpH77f2ff7xiSxh9oSewYrcG TSLUeeCt36r1Kt3OSj7EyBQXoZlN7IxbyhMAfgIe7Mv1rOTOI5I8NQqeXXW8Vl zNmoxaGMny3YnGir5Wf6Qt2nBq4qDaPdnaAuuGUGEecelIO1wx1BpyIfgvfjOh
o5wR RsSzrS8Z wnI3Jvo0mkpEEnlDmZvDu k8O WzJv7eZVEqiWKdyVzFhPpiyQU28GLOpRc2VbVbK4dQKPdNTjPPEmRqcaGeTWZV
tHG7VelHGiT93JfWDEQi5 V9UN1rhXNrYu 0fVMkZAKX3VWi7lzA6BP4 30m", "tag": "kvKuFBXHe5mQr4lqgobAUg" } Figure 82: General JWE JSON Serialization
f6Qt2nBq4qDaPdnaAuuGUGEecelIO1wx1BpyIfgvfjOhMBs9M8XL223F g47xlGsMXdfuY 4jaqVw", "iv": "bbd5sTkYwhAIqfHsx8DayA", "ciphertext": "0fys TY na7f8dwSfXLiYdHaA2DxUjD67ieF7fcVbIR62
tHG7VelHGiT93JfWDEQi5 V9UN1rhXNrYu 0fVMkZAKX3VWi7lzA6BP4 30m", "tag": "kvKuFBXHe5mQr4lqgobAUg" } Figure 83:
Flattened JWE JSON Serialization 5.2.
Key Encryption Using RSA OAEP with AES GCM
This example illustrates encrypting content using the "RSA OAEP" (RSAES OAEP)
key encryption algorithm and the "A256GCM" (AES GCM) content encryption algorithm.
Note that RSAES OAEP uses random data to generate the ciphertext; it might not be possible to exactly replicate the results in this section.
Note that only the RSA public key is necessary to perform the encryption.
However, the example includes the RSA private key to allow readers to validate the output.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the Plaintext from Figure 72.
RSA public key; this example uses the key from Figure 84.
"alg" parameter of "RSA OAEP".
{ "kty": "RSA", "kid": "samwise.gamgee@hobbiton.example", "use": "enc", "n": "wbdxI55VaanZXPY29Lg5hdmv2XhvqAhoxUkanfzf2 5zVUxa6prHRr
M 5qnZtdw 7v4WuR4779ubDuJ5nalMv2S66 RPcnFAzWSKxtBDnFJJDGIU e7Tzizjg1nms0Xq yPub
HcHSeYbghbMjGfasvKn0aZRsnT yC0xhWBlsolZE", "e": "AQAB", "alg": "RSA OAEP", "d": "
n7fzJc3 WG59VEOBTkayzuSMM780OJQuZjN KbH8lOZG25ZoA7T4Bx cc0xQn5oZE5uSCIwg91oCt0JvxPcpmqzaJZg1nirjcWZ oBtVk7gCAWq  B3qhfF3izlbkosrzjHajIcY33HBhsy4 WerrXg4MDNE4HYojy68TcxT 2LYQRxUOCf5TtJXvM8olexlSGtVnQnDRutxEUCwiewfmmrfveEogLx9E
A KMgAjTiISXxqIXQhWUQX1G7v mV Hr2YuImYcNcHkRvp9E7ook0876 DhkO8v4UOZLwA1OlUX98mkoqwc58A
MSH9sqbuziHN2grGjD jfRluMHa0l84fFKl6bcqN1JWxPVhzNZo01yD F 1LiQnqUYSepPf6X3a2SOdkqBRiquE6EvLuSYIDpJq3jDIsgoL8Mo1L oomgiJxUwL GWEOGu28gplyzm 9Q0U0nyhEf1uhSR8aJAQWAiFImWH5W
t zomrwjL mnhsPbGs0c 9WsWgRzI K8gE", "p"
a QZWpXB IrtFjVfdKUdMz94pHUhFGFj7nr6NNxfpiHSHWFE1zD AC3m Y46J961Y2LRnreVwAGNw53p07Db8yD 92pDa97vqcZOdgtybH9q6uma
fbZRqL94bbtE4 e0Zrpo8RNo8vxRLqQNwIy85fc6BRgBJomt8QdQvIgP gWCv5HoQ", "q": "zqOHk1P6WN rHuM7ZF1cXH0x6RuOHq67WuHiSknqQeefGBA9PWs6Zy
KQCO O6mKXtcgE8 Q hA2kMRcKOcvHil1hqMCNSXlflM7WPRPZu2qCDc qssd
e2kSwVgOzvt gsmM29QQ8veHy4uAqca5dZzMs7hkkHtw1z0jHV90epQJ JlXXnH8Q", "dp": "19oDkBh1AXelMIxQFm2zZTqUhAzCIr4xNIGEPNoDt1jK83 FJA xn x5kA7 1erdHdms
yXcrKGm pKdSO08kLBx8VUjkbv 3Pn20Gyu2YEuwpFlM H1NikuxJNKFGmnAq9Lc nwwT0jvoQ", "dq": "S6p59KrlmzGzaQYQM3o0XfHCGvfqHLYjCO557HYQf72O9kLMCfd 1
qSQ3C BafPyFaKrt1fg dyEwYa08pESKwwWisy7KnmoUvaJ3SaHmohFS78TJ25cfc10wZ9hQNOrI ChZlkiOdFCtxDqdmCqNacnhgE3bZQjGp3n83ODSz9zwJcSUvODlXBPc2 AycH6Ci5yjbxt4Ppox
" } Figure 84: RSA 4096 Bit Key
(NOTE: While the key includes the private parameters, only the public parameters "e" and "n" are necessary for the encryption operation.)
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 85.
Initialization Vector; this example uses the Initialization Vector from Figure 86.
Content Encryption Key, base64url encoded  nBoKLH0YkLZPSI9 Figure 86: Initialization Vector, base64url encoded 5.2.3.
Encrypting the Key Performing the key encryption operation over the CEK (Figure 85) with the RSA key
(Figure 84) produces the following Encrypted Key:
Jx9paBpnNmOOKH35j QlrQhDWUN6A2Gg8iFayJ69xDEdHAVCGRzN3woEI2ozDR s Figure 87:
Encrypted Key, base64url encoded 5.2.4.
The following is generated before encrypting the Plaintext:
JWE Protected Header; this example uses the header from Figure 88, encoded using base64url
JWE Protected Header JSON eyJhbGciOiJSU0EtT0FFUCIsImtpZCI6InNhbXdpc2UuZ2FtZ2VlQGhvYmJpdG
JWE Protected Header, base64url encoded Performing the content encryption operation over the Plaintext
(Figure 72) with the following:  CEK (Figure 85);  Initialization Vector (Figure 86); and  JWE Protected Header (Figure 89) as authenticated data produces the following:  Ciphertext from Figure 90.
Authentication Tag from Figure 91.
Authentication Tag, base64url encoded 5.2.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 89)
(Figure 86)  Ciphertext (Figure 90)  Authentication Tag (Figure 91)
The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJSU0EtT0FFUCIsImtpZCI6InNhbXdpc2UuZ2FtZ2VlQGhvYmJpdG 9uLmV4YW1wbGUiLCJlbmMiOiJBMjU2R0NNIn0 .
tsTBqC2UsPOdwjC9NhNupNNu9uHIVftDyucvI6hvALeZ6OGnhNV4 v1zx2k7O1D89mAzfw  kT3tkuorpDU CpBENfIHX1Q58 Aad3FzM
H4Bd7V3u9h8Gkg8B pxKdUV9ScfJQTcYm6eJEBz3aSwIaK4T3 dwWpuBOhROQXBosJzS1 asnuHtVMt2pKIIfux5BC6huIvmY7kzV7W7aIUrpYm 3H4zYvyMeq 5pGqFmW2k8zpO878TRlZx7pZfPYDSXZyS0CfKKkMozT qiCwZTSz
hNcizPersuhw5f pGYzseva TUaL8iWnctc sSwy7SQmRkfhDjwbz0fz 6kFovEgj64X1I5s7E6GLp5fnbYGLa1QUiML7Cc2GxgvI7zqWo0YIEc7a CflLG1
} Figure 93: General JWE JSON Serialization
tOdFwCASQj3uuAgPGrO 2AWBe38UjQb0lvXn1SpyvYZ3WFc7WOJYaTa7A8DRn6MC6T xDmMuxC0G 7S2rscw5lQQU06MvZTlFOt0UvfuKBa03cxA nIBIhLMjY2kOTxQMmpDP
hNcizPersuhw5f pGYzseva TUaL8iWnctc sSwy7SQmRkfhDjwbz0fz 6kFovEgj64X1I5s7E6GLp5fnbYGLa1QUiML7Cc2GxgvI7zqWo0YIEc7a CflLG1
Flattened JWE JSON Serialization 5.3.
Key Wrap Using PBES2 AES KeyWrap with AES CBC HMAC
The example illustrates encrypting content using the "PBES2 HS512 A256KW"
(PBES2 Password based Encryption using HMAC  SHA 512 and AES 256 KeyWrap)
key encryption algorithm with the "A128CBC HS256" (AES 128 CBC HMAC SHA 256) content encryption algorithm.
A common use of password based encryption is the import/export of keys.
Therefore, this example uses a JWK Set for the Plaintext content instead of the Plaintext from Figure 72.
Note that if password based encryption is used for multiple recipients, it is expected that each recipient use different values for the PBES2 parameters "p2s" and "p2c".
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the Plaintext from Figure 95
All whitespace was added for readability).
Password; this example uses the password from Figure 96   with the sequence "\xe2\x80\x93" replaced with (U 2013 EN DASH).
"alg" parameter of "PBES2 HS512 A256KW".
"enc" parameter of "A128CBC HS256".
o\xe2\x80\x93peter long\xe2\x80\x93credit tun Figure 96:
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 97.
Initialization Vector; this example uses the Initialization Vector from Figure 98.
Content Encryption Key, base64url encoded VBiCzVHNoLiR3F4V82uoTQ Figure 98: Initialization Vector, base64url
The following are generated before encrypting the CEK:
Salt input; this example uses the salt input from Figure 99.
Iteration count; this example uses the iteration count 8192.
Salt Input, base64url encoded Performing the key encryption operation over the CEK (Figure 97) with the following:  Password (Figure 96);  Salt input (Figure 99), encoded as an octet string; and  Iteration count (8192) produces the following Encrypted Key:
Encrypted Key, base64url encoded 5.3.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 101, encoded using base64url
JWE Protected Header, base64url encoded Performing the content encryption operation over the Plaintext
(Figure 95) with the following:  CEK (Figure 97);  Initialization Vector (Figure 98); and  JWE Protected Header (Figure 102) as authenticated data produces the following:  Ciphertext from Figure 103.
Authentication Tag from Figure 104.
Authentication Tag, base64url encoded 5.3.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 102)
The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJQQkVTMi1IUzUxMitBMjU2S1ciLCJwMnMiOiI4UTFTemluYXNSM3 hjaFl6NlpaY0hBIiwicDJjIjo4MTkyLCJjdHkiOiJqd2stc2V0K2pzb24iLCJl bmMiOiJBMTI4Q0JDLUhTMjU2In0 .
I4UTFTemluYXNSM3hjaFl6NlpaY0hBIiwicDJjIjo4MTkyLCJjdHkiOi Jqd2stc2V0K2pzb24iLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0", "iv": "VBiCzVHNoLiR3F4V82uoTQ", "ciphertext": "23i
N zl5 tuJYyuvKhjKv6ihbsV k1hJGPGAxJ6wUpmwC4PTQ2izEm0TuSE8oMKdT w8V3kobXZ77ulMwDs4p", "tag": "0HlwodAhOCILG5SQ2LQ9dg" } Figure 106:
N zl5 tuJYyuvKhjKv6ihbsV k1hJGPGAxJ6wUpmwC4PTQ2izEm0TuSE8oMKdT w8V3kobXZ77ulMwDs4p", "tag": "0HlwodAhOCILG5SQ2LQ9dg" } Figure 107:
Flattened JWE JSON Serialization 5.4.
Key Agreement with Key Wrapping Using ECDH ES and AES KeyWrap with AES GCM
This example illustrates encrypting content using the "ECDH  ES A128KW" (Elliptic Curve Diffie Hellman Ephemeral Static with AES  128 KeyWrap) key encryption algorithm and the "A128GCM" (AES GCM) content encryption algorithm.
Note that only the EC public key is necessary to perform the key agreement.
However, the example includes the EC private key to allow readers to validate the output.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
EC public key; this example uses the public key from Figure 108.
"alg" parameter of "ECDH ES A128KW".
{ "kty": "EC", "kid": "peregrin.took@tuckborough.example", "use": "enc", "crv": "P 384", "x": "YU4rRUzdmVqmRtWOs2OpDE T5fsNIodcG8G5FWPrTPMyxpzsSOGaQL pe2FpxBmu2", "y": "A8 yxCHxkfBz3hKZfI1jUYMjUhsEveZ9THuwFjH2sCNdtksRJU7D5  SkgaFL1ETP", "d": "iTx2pk7wW GqJkHcEkFQb2EFyYcO7RugmaW3mRrQVAOUiPommT0Idn
Elliptic Curve P 384 Key, in JWK Format (NOTE: While the key includes the private parameters, only the public parameters "crv", "
x", and "y" are necessary for the encryption operation.)
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 109.
Initialization Vector; this example uses the Initialization Vector from Figure 110.
Content Encryption Key, base64url encoded mH
Initialization Vector, base64url encoded 5.4.3.
To encrypt the Content Encryption Key, the following is generated:  Ephemeral EC private key on the same curve as the EC public key; this example uses the private key from Figure 111.
{ "kty": "EC", "crv": "P 384", "x": "uBo4kHPw6kbjx5l0xowrd
oYzBmaz GKFZu4xAFFkbYiWgutEK6iuE DsQ6wNdNg3", "y": "sp3p5SGhZVC2faXumI e9JU2Mo8KpoYrFDr5yPNVtW4PgEwZOyQTA  JdaY8tb7E0", "d": "D5H4Y 5PSKZvhfVFbcCYJOtcGZygRgfZkpsBr59Icmmhe9sW6nkZ8W fwhinUfWJg
Ephemeral Elliptic Curve P 384 Key, in JWK Format Performing the key encryption operation over the CEK (Figure 109) with the following:
The static Elliptic Curve public key (Figure 108); and  The ephemeral Elliptic Curve private key (Figure 111) produces the following JWE Encrypted Key:
Encrypted Key, base64url encoded 5.4.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 113, encoded to base64url
JWE Protected Header JSON eyJhbGciOiJFQ0RILUVTK0ExMjhLVyIsImtpZCI6InBlcmVncmluLnRvb2tAdH
hBRkZrYllpV2d1dEVLNml1RURzUTZ3TmROZzMiLCJ5Ijoic3AzcDVTR2haVkMy ZmFYdW1JLWU5SlUyTW84S3BvWXJGRHI1eVBOVnRXNFBnRXdaT3lRVEEtSmRhWT h0YjdFMCJ9LCJlbmMiOiJBMTI4R0NNIn0 Figure 114:
JWE Protected Header, base64url encoded Performing the content encryption operation on the Plaintext (Figure 72) using the following:  CEK (Figure 109);  Initialization Vector (Figure 110); and
JWE Protected Header (Figure 114) as authenticated data produces the following:  Ciphertext from Figure 115.
Authentication Tag from Figure 116.
3RCMhSYMzsXaEwDdXta9Mn5B7cCBoJKB0 IgEnj qfo1hIi uEkUpOZ8aLTZGHfpl05jMwbKkTe2yK3mjF6SBAsgicQDVCkc Y9BLluzx1RmC3ORXaM0JaHPB93YcdSDGgpgBWMVrNU1ErkjcMqMoT
Ciphertext, base64url encoded WuGzxmcreYjpHGJoa17EBg Figure 116:
Authentication Tag, base64url encoded 5.4.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 114)
(Figure 110)  Ciphertext (Figure 115)  Authentication Tag (Figure 116) The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJFQ0RILUVTK0ExMjhLVyIsImtpZCI6InBlcmVncmluLnRvb2tAdH Vja2Jvcm91Z2guZXhhbXBsZSIsImVwayI6eyJrdHkiOiJFQyIsImNydiI6IlAt Mzg0IiwieCI6InVCbzRrSFB3Nmtiang1bDB4b3dyZF9vWXpCbWF6LUdLRlp1NH hBRkZrYllpV2d1dEVLNml1RURzUTZ3TmROZzMiLCJ5Ijoic3AzcDVTR2haVkMy ZmFYdW1JLWU5SlUyTW84S3BvWXJGRHI1eVBOVnRXNFBnRXdaT3lRVEEtSmRhWT h0YjdFMCJ9LCJlbmMiOiJBMTI4R0NNIn0 .
3RCMhSYMzsXaEwDdXta9Mn5B7cCBoJKB0 IgEnj qfo1hIi uEkUpOZ8aLTZGHfpl05jMwbKkTe2yK3mjF6SBAsgicQDVCkc Y9BLluzx1RmC3ORXaM0JaHPB93YcdSDGgpgBWMVrNU1ErkjcMqMoT
eyJhbGciOiJFQ0RILUVTK0ExMjhLVyIsImtpZCI6InBlcm VncmluLnRvb2tAdHVja2Jvcm91Z2guZXhhbXBsZSIsImVwayI6eyJrdH kiOiJFQyIsImNydiI6IlAtMzg0IiwieCI6InVCbzRrSFB3Nmtiang1bD B4b3dyZF9vWXpCbWF6LUdLRlp1NHhBRkZrYllpV2d1dEVLNml1RURzUT Z3TmROZzMiLCJ5Ijoic3AzcDVTR2haVkMyZmFYdW1JLWU5SlUyTW84S3
tRJ6K53NgPQ5p99l3Z408OUqj4ioYezbS6vTPlQ", "tag": "WuGzxmcreYjpHGJoa17EBg" } Figure 118:
BvWXJGRHI1eVBOVnRXNFBnRXdaT3lRVEEtSmRhWTh0YjdFMCJ9LCJlbm MiOiJBMTI4R0NNIn0", "encrypted key": "0DJjBXri
, "tag": "WuGzxmcreYjpHGJoa17EBg" } Figure 119:
Flattened JWE JSON Serialization 5.5.
Key Agreement Using ECDH ES with AES CBC HMAC
This example illustrates encrypting content using the "ECDH ES" (Elliptic Curve Diffie Hellman Ephemeral Static) key agreement algorithm and the "A128CBC HS256" (
AES 128 CBC HMAC SHA 256) content encryption algorithm.
Note that only the EC public key is necessary to perform the key agreement.
However, the example includes the EC private key to allow readers to validate the output.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
EC public key; this example uses the public key from Figure 120.
"alg" parameter of "ECDH ES".
"enc" parameter of "A128CBC HS256".
{ "kty": "EC", "kid": "meriadoc.brandybuck@buckland.example", "use": "enc", "crv": "P 256", "x": "Ze2loSV3wrroKUN 4zhwGhCqo3Xhu1td4QjeQ5wIVR0", "y": "HlLtdXARY f55A3fnzQbPcm6hgr34Mp8p nuzQCE0Zw", "d": "r kHyZ a06rmxM3yESK84r1otSg aQcVStkRhA iCM8
Elliptic Curve P 256 Key
(NOTE: While the key includes the private parameters, only the public parameters "crv", "x", and "y" are necessary for the encryption operation.)
The following is generated before encrypting:  Initialization Vector; this example uses the Initialization Vector from Figure 121.
yc9N8v5sYyv3iGQT926IUg Figure 121: Initialization Vector, base64url
The Content Encryption Key (CEK) is not randomly generated; instead, it is determined using ECDH ES key agreement.
The following is generated to agree on a CEK:  Ephemeral private key; this example uses the private key from Figure 122.
{ "kty": "EC", "crv": "P 256", "x": "
mPUKT bAWGHIhg0TpjjqVsP1rXWQu vwVOHHtNkdYoA", "y": "
8BQAsImGeAS46fyWw5MhYfGTT0IjBpFw2SS34Dv4Irs", "d": "AtH35vJsQ9SGjYfOsjUxYXQKrPH3FjZHmEtSKoSN8cM" } Figure 122:
Ephemeral Private Key, in JWK Format Performing the ECDH operation using the static EC public key (Figure 120) over the ephemeral private key
(Figure 122) produces the following CEK: hzHdlfQIAEehb8Hrd mFRhKsKLEzPfshfXs9l6areCc Figure 123:
Agreed to Content Encryption Key, base64url encoded 5.5.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 124, encoded to base64url
A128CBC HS256" } Figure 124:
eyJhbGciOiJFQ0RILUVTIiwia2lkIjoibWVyaWFkb2MuYnJhbmR5YnVja0BidW NrbGFuZC5leGFtcGxlIiwiZXBrIjp7Imt0eSI6IkVDIiwiY3J2IjoiUC0yNTYi LCJ4IjoibVBVS1RfYkFXR0hJaGcwVHBqanFWc1AxclhXUXVfdndWT0hIdE5rZF lvQSIsInkiOiI4QlFBc0ltR2VBUzQ2ZnlXdzVNaFlmR1RUMElqQnBGdzJTUzM0 RHY0SXJzIn0sImVuYyI6IkExMjhDQkMtSFMyNTYifQ Figure 125:
JWE Protected Header, base64url encoded Performing the content encryption operation on the Plaintext (Figure 72) using the following:  CEK (Figure 123);  Initialization Vector (Figure 121); and  JWE Protected Header (Figure 125) as authenticated data produces the following:  Ciphertext from Figure 126.
Authentication Tag from Figure 127.
Authentication Tag, base64url encoded 5.5.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 114)  Initialization Vector
Only the general JWE JSON Serialization is presented because the flattened JWE JSON Serialization is identical.
The resulting JWE object using the JWE Compact Serialization:
eyJhbGciOiJFQ0RILUVTIiwia2lkIjoibWVyaWFkb2MuYnJhbmR5YnVja0BidW NrbGFuZC5leGFtcGxlIiwiZXBrIjp7Imt0eSI6IkVDIiwiY3J2IjoiUC0yNTYi LCJ4IjoibVBVS1RfYkFXR0hJaGcwVHBqanFWc1AxclhXUXVfdndWT0hIdE5rZF lvQSIsInkiOiI4QlFBc0ltR2VBUzQ2ZnlXdzVNaFlmR1RUMElqQnBGdzJTUzM0 RHY0SXJzIn0sImVuYyI6IkExMjhDQkMtSFMyNTYifQ .
JhbmR5YnVja0BidWNrbGFuZC5leGFtcGxlIiwiZXBrIjp7Imt0eSI6Ik VDIiwiY3J2IjoiUC0yNTYiLCJ4IjoibVBVS1RfYkFXR0hJaGcwVHBqan FWc1AxclhXUXVfdndWT0hIdE5rZFlvQSIsInkiOiI4QlFBc0ltR2VBUz Q2ZnlXdzVNaFlmR1RUMElqQnBGdzJTUzM0RHY0SXJzIn0sImVuYyI6Ik ExMjhDQkMtSFMyNTYifQ", "iv": "yc9N8v5sYyv3iGQT926IUg", "ciphertext": "
JGG2m9 Csg", "tag": "WCCkNa x4BeB9hIDIfFuhg" } Figure 129: General JWE JSON Serialization 5.6.
Direct Encryption Using AES GCM
This example illustrates encrypting content using a previously exchanged key directly and the "A128GCM" (AES GCM) content encryption algorithm.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 130.
{ "kty": "oct", "kid": "77c7e2b8
", "use": "enc", "alg": "A128GCM", "k": "XctOhJAkA pD9Lh7ZgW 2A" } Figure 130: AES 128 Bit Key, in JWK Format 5.6.2.
The following is generated before encrypting:  Initialization Vector; this example uses the Initialization Vector from Figure 131.
Initialization Vector, base64url encoded 5.6.3.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 132, encoded as base64url
", "enc": "A128GCM" } Figure 132:
JWE Protected Header JSON eyJhbGciOiJkaXIiLCJraWQiOiI3N2M3ZTJiOC02ZTEzLTQ1Y2YtODY3Mi02MT
JWE Protected Header, base64url encoded Performing the encryption operation on the Plaintext (Figure 72) using the following:  CEK (Figure 130);  Initialization Vector (Figure 131); and  JWE Protected Header (Figure 133) as authenticated data produces the following:  Ciphertext from Figure 134.
Authentication Tag from Figure 135.
s7LJAGb15wEBtXphVCgyy53CoIKLHHeJHXex45Uz9aKZSRSIn ZI wjsY0yu3cT4 aQ3i1o tiE F8Ios61EKgyIQ4CWao8PFMj8TTnp
, base64url encoded vbb32Xvllea2OtmHAdccRQ Figure 135:
Authentication Tag, base64url encoded 5.6.4.
The following compose the resulting JWE object:  JWE Protected Header (Figure 133)  Initialization Vector
Only the general JWE JSON Serialization is presented because the flattened JWE JSON Serialization is identical.
The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJkaXIiLCJraWQiOiI3N2M3ZTJiOC02ZTEzLTQ1Y2YtODY3Mi02MT diNWI0NTI0M2EiLCJlbmMiOiJBMTI4R0NNIn0 . .
FtBP c BIwCPTjb9o0SbdcdREEMJMyZBH8 ySWMVi1gPD9yxi aQpGbSv
", "tag": "vbb32Xvllea2OtmHAdccRQ" } Figure 137: General JWE JSON Serialization 5.7.
Key Wrap Using AES GCM KeyWrap with AES CBC HMAC
This example illustrates encrypting content using the "A256GCMKW" (AES 256 GCM KeyWrap)
key encryption algorithm with the "A128CBC  HS256" (AES 128 CBC HMAC SHA 256) content encryption algorithm.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
AES symmetric key; this example uses the key from Figure 138.
"enc" parameter of "A128CBC HS256".
{ "kty": "oct", "kid": "18ec08e1
b205 2b4dd1d4321d", "use": "enc", "alg": "A256GCMKW", "k": "qC57l uxcm7Nm3K ct4GFjx8tM1U8CZ0NLBvdQstiS8" } Figure 138: AES 256 Bit Key 5.7.2.
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 139.
Initialization Vector for content encryption; this example uses the Initialization Vector from Figure 140.
Content Encryption Key, base64url encoded gz6NjyEFNm vm8Gj6FwoFQ Figure 140: Initialization Vector, base64url encoded 5.7.3.
The following is generated before encrypting the CEK:  Initialization Vector for key wrapping; this example uses the Initialization Vector from Figure 141.
Figure 141: Initialization Vector for Key Wrapping, base64url
encoded Performing the key encryption operation over the CEK (Figure 139) with the following:
(Figure 141); and  The empty string as authenticated data produces the following:  Encrypted Key from Figure 142.
Authentication Tag from Figure 143.
Encrypted Key, base64url encoded kfPduVQ3T3H6vnewt ksw Figure 143:
Authentication Tag from Key Wrapping, base64url encoded 5.7.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 144, encoded to base64url
eyJhbGciOiJBMjU2R0NNS1ciLCJraWQiOiIxOGVjMDhlMS1iZmE5LTRkOTUtYj IwNS0yYjRkZDFkNDMyMWQiLCJ0YWciOiJrZlBkdVZRM1QzSDZ2bmV3dC0ta3N3 IiwiaXYiOiJLa1lUMEdYXzJqSGxmcU5fIiwiZW5jIjoiQTEyOENCQy1IUzI1Ni J9 Figure 145:
JWE Protected Header, base64url encoded Performing the content encryption operation over the Plaintext
(Figure 72) with the following:  CEK (Figure 139);  Initialization Vector (Figure 140); and  JWE Protected Header (Figure 145) as authenticated data produces the following:  Ciphertext from Figure 146.
Authentication Tag from Figure 147.
eVIgMqWmsuJKuoVgzR3YfzoMd3GxEm3VxNhzWyWtZKX0gxKdy6HgLvqoGNbZCz LjqcpDiF8q2 62EVAbr2uSc2oaxFmFuIQHLcqAHxy51449xkjZ7ewzZaGV3eFq hpco8o4DijXaG5 7kp3h2cajRfDgymuxUbWgLqaeNQaJtvJmSMFuEOSAzw9Hde
4yDJFcqb5CiDSmA psB2k0Jtj xAj4UPI61oONK7zzFIu4gBfjJCndsZfdvG7h8wGjV98QhrKEnR7xKZ3KCr0 qR 1B gxpNk3xWU Figure 146:
Ciphertext, base64url encoded DKW7jrb4WaRSNfbXVPlT5g Figure 147:
Authentication Tag, base64url encoded 5.7.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 145)
(Figure 140)  Ciphertext (Figure 146)
The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJBMjU2R0NNS1ciLCJraWQiOiIxOGVjMDhlMS1iZmE5LTRkOTUtYj IwNS0yYjRkZDFkNDMyMWQiLCJ0YWciOiJrZlBkdVZRM1QzSDZ2bmV3dC0ta3N3
eVIgMqWmsuJKuoVgzR3YfzoMd3GxEm3VxNhzWyWtZKX0gxKdy6HgLvqoGNbZCz LjqcpDiF8q2 62EVAbr2uSc2oaxFmFuIQHLcqAHxy51449xkjZ7ewzZaGV3eFq hpco8o4DijXaG5 7kp3h2cajRfDgymuxUbWgLqaeNQaJtvJmSMFuEOSAzw9Hde
psB2k0Jtj xAj4UPI61oONK7zzFIu4gBfjJCndsZfdvG7h8wGjV98QhrKEnR7xKZ3KCr0 qR 1B gxpNk3xWU .
ZRM1QzSDZ2bmV3dC0ta3N3IiwiaXYiOiJLa1lUMEdYXzJqSGxmcU5fIi wiZW5jIjoiQTEyOENCQy1IUzI1NiJ9", "iv": "gz6NjyEFNm vm8Gj6FwoFQ", "ciphertext": "Jf5p9 ZhJlJy IQ byKFmI0Ro7w7G1QiaZpI8OaiVgD8E qoDZHyFKFBupS8iaEeVIgMqWmsuJKuoVgzR3YfzoMd3GxEm3VxNhzWyW
F1 4yDJFcqb5CiDSmA psB2k0JtjxAj4UPI61oONK7z zFIu4gBfjJCndsZfdvG7h8wGjV98QhrKEnR7xKZ3KCr0 qR1B
pIbGZxTl8iLCJraWQiOiIxOGVjMDhlMS1iZmE5LTRkOTUtYjIwNS0yYj RkZDFkNDMyMWQiLCJ0YWciOiJrZlBkdVZRM1QzSDZ2bmV3dC0ta3N3Ii wiZW5jIjoiQTEyOENCQy1IUzI1NiJ9", "encrypted key": "lJf3HbOApxMEBkCMOoTnnABxs
k", "iv": "gz6NjyEFNm vm8Gj6FwoFQ", "ciphertext": "Jf5p9 ZhJlJy IQ byKFmI0Ro7w7G1QiaZpI8OaiVgD8E qoDZHyFKFBupS8iaEeVIgMqWmsuJKuoVgzR3YfzoMd3GxEm3VxNhzWyW
F1 4yDJFcqb5CiDSmA psB2k0JtjxAj4UPI61oONK7z zFIu4gBfjJCndsZfdvG7h8wGjV98QhrKEnR7xKZ3KCr0 qR1B
gxpNk3 xWU", "tag": "NvBveHr vonkvflfnUrmBQ" } Figure 150:
Flattened JWE JSON Serialization 5.8.
Using AES KeyWrap with AES GCM
The following example illustrates content encryption using the "A128KW
" (AES 128 KeyWrap) key encryption algorithm and the "A128GCM" (AES 128 GCM) content encryption algorithm.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
AES symmetric key; this example uses the key from Figure 151.
{ "kty": "oct", "kid": "81b20965 8332 43d9 a468 82160ad91ac8", "use": "enc", "alg": "A128KW", "k"
: "GZy6sIZ6wl9NJOKB jnmVQ" } Figure 151: AES 128 Bit Key 5.8.2.
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key; this example uses the key from Figure 152.
Initialization Vector; this example uses the Initialization Vector from Figure 153.
: Content Encryption Key, base64url encoded Qx0pmsDa8KnJc9Jo Figure 153: Initialization Vector, base64url encoded 5.8.3.
Encrypting the Key Performing the key encryption operation over the CEK (Figure 152) with the AES symmetric key (Figure 151) produces the following Encrypted Key:
Encrypted Key, base64url encoded 5.8.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 155, encoded to base64url
JWE Protected Header, base64url encoded Performing the content encryption over the Plaintext (Figure 72) with the following:  CEK (Figure 152);  Initialization Vector (Figure 153); and  JWE Protected Header (Figure 156) as authenticated data produces the following:  Ciphertext from Figure 157.
Authentication Tag from Figure 158.
F0LwkcTtjbYKCsiNJQkcIp1yeM03OmuiYSoYJVSpf7ej6zaYcMv3WwdxDFl8RE wOhNImk2Xld2JXq6BR53TSFkyT7PwVLuq 1GwtGHlQeg7gDT6xW0JqHDPn H p uQsmthc9Zg0ojmJfqqFvETUxLAF KjcBTS5dNy6egwkYtOt8EIHK
: Ciphertext, base64url encoded ER7MWJZ1FBI NKvn7Zb1Lw Figure 158:
Authentication Tag, base64url encoded 5.8.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 156)
The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJBMTI4S1ciLCJraWQiOiI4MWIyMDk2NS04MzMyLTQzZDktYTQ2OC 04MjE2MGFkOTFhYzgiLCJlbmMiOiJBMTI4R0NNIn0 .
F0LwkcTtjbYKCsiNJQkcIp1yeM03OmuiYSoYJVSpf7ej6zaYcMv3WwdxDFl8RE wOhNImk2Xld2JXq6BR53TSFkyT7PwVLuq 1GwtGHlQeg7gDT6xW0JqHDPn H p uQsmthc9Zg0ojmJfqqFvETUxLAF KjcBTS5dNy6egwkYtOt8EIHK oEsKYtZRa
MyLTQzZDktYTQ2OC04MjE2MGFkOTFhYzgiLCJlbmMiOiJBMTI4R0NNIn 0", "iv": "Qx0pmsDa8KnJc9Jo", "ciphertext": "AwliP
TUxLAF KjcBTS5dNy6egwkYtOt8EIHK oEsKYtZRaa8Z7MOZ7UGxGIMv EmxrGCPeJa14slv2 gaqK0kEThkaSqdYw0FkQZF", "tag": "ER7MWJZ1FBI NKvn7Zb1Lw" } Figure 160: General JWE JSON Serialization
"CBI6oDw8MydIx1IBntf lQcw2MmJKIQx", "iv": "Qx0pmsDa8KnJc9Jo", "ciphertext": "AwliP
TUxLAF KjcBTS5dNy6egwkYtOt8EIHK oEsKYtZRaa8Z7MOZ7UGxGIMv EmxrGCPeJa14slv2 gaqK0kEThkaSqdYw0FkQZF", "tag": "ER7MWJZ1FBI NKvn7Zb1Lw" } Figure 161:
Flattened JWE JSON Serialization 5.9.
This example illustrates encrypting content that is first compressed.
It reuses the AES symmetric key, key encryption algorithm, and content encryption algorithm from Section 5.8.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
Recipient encryption key; this example uses the key from Figure 151.
Key encryption algorithm; this example uses "A128KW".
Content encryption algorithm; this example uses "A128GCM".
The following are generated before encrypting:  Compressed Plaintext from the original Plaintext content; compressing Figure 72 using the DEFLATE [RFC1951] algorithm produces the compressed Plaintext from Figure 162.
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 163.
Initialization Vector; this example uses the Initialization Vector from Figure 164.
PSy6oZIXUnDYbVKN4jNXi2u0yB7t1qSHTjmMODf9QgvrDzfTIQXnyQRuUya4zI WG3vTOdir0v7BRHFYWq3k1k1A gSDJqtcBF GZxw8 Figure 162:
Compressed Plaintext, base64url encoded hC MpLZSuwWv8sexS6ydfw Figure 163
: Content Encryption Key, base64url encoded p9pUq6XHY0jfEZIl Figure 164: Initialization Vector, base64url encoded 5.9.3.
Encrypting the Key Performing the key encryption operation over the CEK (Figure 163) with the AES symmetric key (Figure 151) produces the following Encrypted Key: 5vUT2WOtQxKWcekM IzVQwkGgzlFDwPi Figure 165:
Encrypted Key, base64url encoded 5.9.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 166, encoded to base64url
JWE Protected Header, base64url encoded Performing the content encryption operation over the compressed Plaintext
(Figure 162, encoded as an octet string) with the following:  CEK (Figure 163);  Initialization Vector
(Figure 164); and  JWE Protected Header (Figure 167) as authenticated data produces the following:  Ciphertext from Figure 168.
Authentication Tag from Figure 169.
Ciphertext, base64url encoded VILuUwuIxaLVmh5X T7kmA Figure 169
: Authentication Tag, base64url encoded 5.9.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 167)
The resulting JWE object using the JWE Compact Serialization: eyJhbGciOiJBMTI4S1ciLCJraWQiOiI4MWIyMDk2NS04MzMyLTQzZDktYTQ2OC 04MjE2MGFkOTFhYzgiLCJlbmMiOiJBMTI4R0NNIiwiemlwIjoiREVGIn0 .
XhhlYg0 m BHaqfDO5iTOWxPxFMUedx7WCy8mxgDHj0aBMG6152PsM w5E o2B3jDbrYBK hpYA7qi3AyijnCJ7BP9rr3U8kxExCpG3mK420TjOw .
MyLTQzZDktYTQ2OC04MjE2MGFkOTFhYzgiLCJlbmMiOiJBMTI4R0NNIi wiemlwIjoiREVGIn0", "iv": "p9pUq6XHY0jfEZIl", "ciphertext": "HbDtOsdai1oYziSx25KEeTxmwnh8L8jKMFNc1k3zmMI6V B8hry57tDZ61jXyezSPt0fdLVfe6Jf5y5 JaCap
BHaqfDO5iTOWxPxFMUedx7WCy8mxgDH j0aBMG6152PsM w5E o2B3jDbrYBKhpYA7qi3AyijnCJ7BP9rr3U8kxE xCpG3mK420TjOw", "tag": "VILuUwuIxaLVmh5X T7kmA"
} Figure 171: General JWE JSON Serialization
MyLTQzZDktYTQ2OC04MjE2MGFkOTFhYzgiLCJlbmMiOiJBMTI4R0NNIi wiemlwIjoiREVGIn0", "encrypted key": "5vUT2WOtQxKWcekM IzVQwkGgzlFDwPi", "iv": "p9pUq6XHY0jfEZIl", "ciphertext":
BHaqfDO5iTOWxPxFMUedx7WCy8mxgDH j0aBMG6152PsM w5E o2B3jDbrYBKhpYA7qi3AyijnCJ7BP9rr3U8kxE xCpG3mK420TjOw", "tag": "VILuUwuIxaLVmh5X T7kmA" } Figure 172:
Flattened JWE JSON Serialization 5.10.
This example illustrates encrypting content that includes additional authenticated data.
As this example includes an additional top level property not present in the JWE Compact Serialization, only the flattened JWE JSON Serialization and general JWE JSON Serialization are possible.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
Recipient encryption key; this example uses the key from Figure 151.
Key encryption algorithm; this example uses "A128KW".
Content encryption algorithm; this example uses "A128GCM".
Additional Authenticated Data; this example uses a vCard [RFC7095] from Figure 173, serialized to UTF 8.
Figure 173: Additional Authenticated Data, in JSON Format NOTE:
Whitespace between JSON values was added for readability.
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 174.
Initialization Vector; this example uses the Initialization Vector from Figure 175.
Encoded Additional Authenticated Data (AAD); this example uses the Additional Authenticated Data from Figure 173, encoded to base64url
Content Encryption Key, base64url encoded veCx9ece2orS7c N Figure 175:
Initialization Vector, base64url encoded WyJ2Y2FyZCIsW1sidmVyc2lvbiIse30sInRleHQiLCI0LjAiXSxbImZuIix7fS widGV4dCIsIk1lcmlhZG9jIEJyYW5keWJ1Y2siXSxbIm4iLHt9LCJ0ZXh0Iixb
Additional Authenticated Data, base64url encoded 5.10.3.
Encrypting the Key Performing the key encryption operation over the CEK (Figure 174) with the AES symmetric key (Figure 151) produces the following Encrypted Key: 4YiiQ
Encrypted Key, base64url encoded 5.10.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 178, encoded to base64url
Authentication Tag from Figure 181.
ek6LQn5NRehvApqf9ZrxB4a q3FXBxOxCys35PhCdaggy2kfUfl2OkwKnWUbgXVD1C6HxLIlqHhCwXDG59weHr RDQeHyMRoBljoV3X bUTJDnKBFOod7nLz cj48JMx3SnCZTpbQAkFV Figure 180:
vOaH Rajnpy 3hOtqvZHRA Figure 181:
Authentication Tag, base64url encoded 5.10.5.
The following compose the resulting JWE object:  JWE Protected Header (Figure 179)
(Figure 175)  Additional Authenticated Data (Figure 176)  Ciphertext
The JWE Compact Serialization is not presented because it does not support this use case.
MyLTQzZDktYTQ2OC04MjE2MGFkOTFhYzgiLCJlbmMiOiJBMTI4R0NNIn 0", "iv": "veCx9ece2orS7c N", "aad": "WyJ2Y2FyZCIsW1sidmVyc2lvbiIse30sInRleHQiLCI0LjAiXSxb ImZuIix7fSwidGV4dCIsIk1lcmlhZG9jIEJyYW5keWJ1Y2siXSxbIm4i LHt9LCJ0ZXh0IixbIkJyYW5keWJ1Y2siLCJNZXJpYWRvYyIsIk1yLiIs IiJdXSxbImJkYXkiLHt9LCJ0ZXh0IiwiVEEgMjk4MiJdLFsiZ2VuZGVy Iix7fSwidGV4dCIsIk0iXV1d", "ciphertext": "Z 3cbr0k3bVM6N3oSNmHz7Lyf3iPppGf3Pj17wNZqteJ0 Ui8p74SchQP8xygM1oFRWCNzeIa6s6BcEtp8qEFiqTUEyiNkOWDNoF14 T 4NFqF p2Mx8zkbKxI7oPK8KNarFbyxIDvICNqBLba v3uzXBdB89fz OI Lv4PjOFAQGHrgv1rjXAmKbgkft9cB4WeyZw8MldbBhc
V KWZslrs LNygon JJWd ek6LQn5NRehvApqf9ZrxB4aq3FXBxOxCys35PhCdaggy 2kfUfl2OkwKnWUbgXVD1C6HxLIlqHhCwXDG59weHrRDQeHyMRoBljoV3
X bUTJDnKBFOod7nLz cj48JMx3SnCZTpbQAkFV", "tag": "vOaH Rajnpy 3hOtqvZHRA" } Figure 182: General JWE JSON Serialization
MyLTQzZDktYTQ2OC04MjE2MGFkOTFhYzgiLCJlbmMiOiJBMTI4R0NNIn 0", "encrypted key": "4YiiQ ZzH76TaIkJmYfRFgOV9MIpnx4X", "aad": "WyJ2Y2FyZCIsW1sidmVyc2lvbiIse30sInRleHQiLCI0LjAiXSxb ImZuIix7fSwidGV4dCIsIk1lcmlhZG9jIEJyYW5keWJ1Y2siXSxbIm4i LHt9LCJ0ZXh0IixbIkJyYW5keWJ1Y2siLCJNZXJpYWRvYyIsIk1yLiIs IiJdXSxbImJkYXkiLHt9LCJ0ZXh0IiwiVEEgMjk4MiJdLFsiZ2VuZGVy Iix7fSwidGV4dCIsIk0iXV1d", "iv": "veCx9ece2orS7c N", "ciphertext": "Z 3cbr0k3bVM6N3oSNmHz7Lyf3iPppGf3Pj17wNZqteJ0 Ui8p74SchQP8xygM1oFRWCNzeIa6s6BcEtp8qEFiqTUEyiNkOWDNoF14 T 4NFqF p2Mx8zkbKxI7oPK8KNarFbyxIDvICNqBLba v3uzXBdB89fz OI Lv4PjOFAQGHrgv1rjXAmKbgkft9cB4WeyZw8MldbBhc
V KWZslrs LNygon JJWd ek6LQn5NRehvApqf9ZrxB4aq3FXBxOxCys35PhCdaggy 2kfUfl2OkwKnWUbgXVD1C6HxLIlqHhCwXDG59weHrRDQeHyMRoBljoV3
X bUTJDnKBFOod7nLz cj48JMx3SnCZTpbQAkFV", "tag": "vOaH Rajnpy 3hOtqvZHRA"
Flattened JWE JSON Serialization 5.11.
This example illustrates encrypting content where only certain JOSE Header Parameters are protected.
As this example includes parameters in the JWE Shared Unprotected Header, only the general JWE JSON Serialization and flattened JWE JSON Serialization are possible.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
Recipient encryption key; this example uses the key from Figure 151.
Key encryption algorithm; this example uses "A128KW".
Content encryption algorithm; this example uses "A128GCM".
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 184.
Initialization Vector; this example uses the Initialization Vector from Figure 185.
Content Encryption Key, base64url encoded WgEJsDS9bkoXQ3nR Figure 185: Initialization Vector, base64url encoded 5.11.3.
Encrypting the Key Performing the key encryption operation over the CEK (Figure 184) with the AES symmetric key (Figure 151) produces the following Encrypted Key:
Encrypted Key, base64url encoded 5.11.4.
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 187, encoded to base64url
JWE Protected Header JSON eyJlbmMiOiJBMTI4R0NNIn0 Figure 188:
JWE Protected Header, base64url encoded Performing the content encryption operation over the Plaintext with the following:  CEK (Figure 184);  Initialization Vector (Figure 185); and  JWE Protected Header (Figure 188) as authenticated data produces the following:  Ciphertext from Figure 189.
Authentication Tag from Figure 190.
5g5UjWVD3lgiLCN P7AW8mIiFvUNXBPJK3nO WL4teUPS8yHLbWeL83olU4UAgL48x 8dDkH23JykibVSQju f7e
Ciphertext, base64url encoded fNYLqpUe84KD45lvDiaBAQ Figure 190:
Authentication Tag, base64url encoded 5.11.5.
The following compose the resulting JWE object:  JWE Shared Unprotected Header (Figure 191)
JWE Protected Header (Figure 188)
The JWE Compact Serialization is not presented because it does not support this use case.
JWE Shared Unprotected Header JSON
", "tag": "fNYLqpUe84KD45lvDiaBAQ" } Figure 193:
Flattened JWE JSON Serialization 5.12.
Only This example illustrates encrypting content where none of the JOSE header parameters are protected.
As this example includes parameters only in the JWE Shared Unprotected Header, only the flattened JWE JSON Serialization and general JWE JSON Serialization are possible.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 72.
Recipient encryption key; this example uses the key from Figure 151.
Key encryption algorithm; this example uses "A128KW".
Content encryption algorithm; this example uses "A128GCM".
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key
; this example the key from Figure 194.
Initialization Vector; this example uses the Initialization Vector from Figure 195.
Content Encryption Key, base64url encoded YihBoVOGsR1l7jCD Figure 195: Initialization Vector,
Encrypting the Key Performing the key encryption operation over the CEK (Figure 194) with the AES symmetric key (Figure 151) produces the following Encrypted Key: 244YHfO W7RMpQW81UjQrZcq5LSyqiPv Figure 196:
Encrypted Key, base64url encoded 5.12.4.
Encrypting the Content Performing the content encryption operation over the Plaintext (Figure 72) using the following:  CEK (Figure 194);  Initialization Vector (Figure 195); and  Empty string as authenticated data produces the following:  Ciphertext from Figure 197.
Authentication Tag from Figure 198.
L3 svybhHYUGyQuTmUQEDjgjJfBOifwHIsDsRPeBz1NomqeifVPq5GTCWFo5k MNI QURR2Wj0AHC2k7JZfu2iWjUHLF8ExFZLZ4nlmsvJu mvifMYiikfNfsZAudISO a6O73yPZtL04k
1FI7WDfrb2w7OqKLWDXzlpcxohPVOLQwpA3mFNRKdY bQz4Z 4KX9lfz1cne31N4 8BKmojpw OdQjKdLOGkC445Fb
Ciphertext, base64url encoded e2m0Vm7JvjK2VpCKXS kyg Figure 198:
Authentication Tag, base64url encoded 5.12.5.
The JWE Compact Serialization is not presented because it does not support this use case.
JWE Shared Unprotected Header JSON
The following compose the resulting JWE object:  JWE Shared Unprotected Header (Figure 199)  Encrypted Key
arsVCPaIeFwQfzrSS6oEUWbBtxEasE0vC6r7sphyVziMCVJEuRJyoAHF SP3eqQPb4Ic1SDSqyXjw L3svybhHYUGyQuTmUQEDjgjJfBOifwHIsDs RPeBz1NomqeifVPq5GTCWFo5k MNIQURR2Wj0AHC2k7JZfu2iWjUHLF8 ExFZLZ4nlmsvJu mvifMYiikfNfsZAudISOa6O73yPZtL04k
1FI7WDf rb2w7OqKLWDXzlpcxohPVOLQwpA3mFNRKdY bQz4Z4KX9lfz1cne31N4  8BKmojpw OdQjKdLOGkC445Fb K1tlDQXw2sBF", "tag": "e2m0Vm7JvjK2VpCKXS kyg"
} Figure 200: General JWE JSON Serialization
arsVCPaIeFwQfzrSS6oEUWbBtxEasE0vC6r7sphyVziMCVJEuRJyoAHF SP3eqQPb4Ic1SDSqyXjw L3svybhHYUGyQuTmUQEDjgjJfBOifwHIsDs RPeBz1NomqeifVPq5GTCWFo5k MNIQURR2Wj0AHC2k7JZfu2iWjUHLF8 ExFZLZ4nlmsvJu mvifMYiikfNfsZAudISOa6O73yPZtL04k
1FI7WDf rb2w7OqKLWDXzlpcxohPVOLQwpA3mFNRKdY bQz4Z4KX9lfz1cne31N4  8BKmojpw OdQjKdLOGkC445Fb K1tlDQXw2sBF", "tag": "e2m0Vm7JvjK2VpCKXS kyg"
Flattened JWE JSON Serialization 5.13.
This example illustrates encryption content for multiple recipients.
As this example has multiple recipients, only the general JWE JSON Serialization is possible.
Note that RSAES PKCS1 v1 5 uses random data to generate the ciphertext; it might not be possible to exactly replicate the results in this section.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the Plaintext from Figure 72.
Recipient keys; this example uses the following:
The RSA public key from Figure 73 for the first recipient.
The EC public key from Figure 108 for the second recipient.
The AES symmetric key from Figure 138 for the third recipient.
"ECDH ES A256KW" for the second recipient.
"A256GCMKW" for the third recipient.
Content encryption algorithm; this example uses "A128CBC HS256".
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 202.
Initialization Vector; this example uses the Initialization Vector from Figure 203.
zXayeJ4gvm8NJr3IUInyokTUO LbQNKEhe zWlYbdpQ Figure 202:
Content Encryption Key, base64url encoded VgEIHY20EnzUtZFl2RpB1
g Figure 203: Initialization Vector, base64url
Encrypting the Key to the First Recipient
Performing the "RSA1 5" key encryption operation over the CEK (Figure 202) with the first recipient's RSA key (Figure 73) produces the following Encrypted Key:
dYOD28kab0Vvf4ODgxVAJXgHcSZICSOp8M51zjwj4w6Y5G4XJQsNNIBiqyvUUA OcpL7S7 cFe7Pio7gV Q06WmCSa vhW6me4bWrBf7cHwEQJdXihidAYWVajJIa
KMXMvFRMV6iDlRr076DFthg2 AV0 tSiV6xSEIFqt1xnYPpmP91tc5WJDOGb w qjw0 b
bHcGlihqc wGgho9fLMK8JOArYLcMDNQ Figure 204: Recipient #1 Encrypted Key, base64url encoded
The following is generated after encrypting the CEK for the first recipient:  Recipient JWE Unprotected Header from Figure 205.
{ "alg": "RSA1 5", "kid": "frodo.baggins@hobbiton.example" } Figure 205: Recipient #1 JWE Per Recipient Unprotected Header JSON
6Y5G4XJQsNNIBiqyvUUAOcpL7S7 cFe7Pio7gV Q06WmCSa vhW6me4b WrBf7cHwEQJdXihidAYWVajJIaKMXMvFRMV6iDlRr076DFthg2
Encrypting the Key to the Second Recipient
The following is generated before encrypting the CEK for the second recipient:  Ephemeral EC private key on the same curve as the EC public key; this example uses the private key from Figure 207.
{ "kty": "EC", "crv": "P 384", "x": "Uzdvk3pi5wKCRc1izp5 r0OjeqT I68i8g2b8mva8diRhsE2xAn2Dt MRb25Ma2CX", "y": "VDrRyFJh Kwd1EjAgmj5Eo CTHAZ53MC7PjjpLioy3ylEjI1pOMbw9 1fzZ84pbfm", "d": "1DKHfTv
" } Figure 207: Ephemeral Private Key for Recipient #2, in JWK Format Performing the "ECDH ES A256KW" key encryption operation over the CEK (Figure 202) with the following:  Static Elliptic Curve public key (Figure 108).
Ephemeral Elliptic Curve private key (Figure 207).
produces the following Encrypted Key:
ExInT0io9BqBMYF6 maw5tZlgoZXThD1zWKsHixJuw elY4gSSId w Figure 208: Recipient #2 Encrypted Key
The following is generated after encrypting the CEK for the second recipient:  Recipient JWE Unprotected Header from Figure 209.
Encrypting the Key to the Third Recipient
The following is generated before encrypting the CEK for the third recipient:  Initialization Vector for key wrapping; this example uses the Initialization Vector from Figure 211.
AvpeoPZ9Ncn9mkBn Figure 211: Recipient #2 Initialization Vector for Key Wrapping, base64url encoded Performing the "A256GCMKW" key encryption operation over the CEK (Figure 202) with the following:
(Figure 138); and  Initialization Vector
(Figure 211) produces the following:  Encrypted Key from Figure 212.
Authentication Tag from Figure 213.
a7CclAejo 7JSuPB8zeagxXRam8dwCfmkt9 WyTpS1E Figure 212: Recipient #3
base64url encoded 59Nqh1LlYtVIhfD3pgRGvw Figure 213: Recipient #3 Authentication Tag from Key Wrapping, base64url encoded
The following is generated after encrypting the CEK for the third recipient:
Recipient JWE Unprotected Header; this example uses the header from Figure 214.
{ "alg": "A256GCMKW", "kid": "18ec08e1
b205 2b4dd1d4321d", "tag": "59Nqh1LlYtVIhfD3pgRGvw", "iv": "AvpeoPZ9Ncn9mkBn"
} Figure 214: Recipient #3 JWE Per Recipient Unprotected Header JSON
The following is generated before encrypting the content:
JWE Protected Header; this example uses the header from Figure 216, encoded to base64url
JWE Protected Header, base64url encoded Performing the content encryption operation over the Plaintext
(Figure 72) with the following:  CEK (Figure 202),  Initialization Vector (Figure 203), and  JWE Protected Header (Figure 217) as the authenticated data produces the following:  Ciphertext from Figure 218.
Authentication Tag from Figure 219.
iEuzHgIJFIJn2wh9Tj0cg kOZy9BqMRZbmYXM Y9YQjorZ P JYG3ARAIF3OjDNqpdYe
Ciphertext, base64url encoded BESYyFN7T09KY7i8zKs5 g Figure 219:
The following is generated after encrypting the Plaintext:  JWE Shared Unprotected Header parameters; this example uses the header from Figure 220.
{ "cty": "text/plain" } Figure 220:
JWE Shared Unprotected Header JSON 5.13.7.
The following compose the resulting JWE object:  Recipient #1 JSON (Figure 206)
#3 JSON (Figure 215)  Initialization Vector
The JWE Compact Serialization is not presented because it does not support this use case; the flattened JWE JSON Serialization is not presented because there is more than one recipient.
P6ga7 siYxStR7 G07Thd1jh zGT0wxM5g VRORtq0K6AXpLlwEqRp7p kt2zRM0ZAXqSpe1O6FJ7FHLDyEFnD zDIZukLpCbzhzMDLLw2 8I14FQ
iEuzHgIJFIJn2wh9Tj0cg kOZy9BqMRZbmYXMY9YQjorZ P JYG3 ARAIF3OjDNqpdYe K 5Q5crGJSDNyij
ygEiItR5jssQVH2ofDQdLCht azE", "tag": "BESYyFN7T09KY7i8zKs5 g
" } Figure 221: General JWE JSON Serialization 6.
This example illustrates nesting a JSON Web Signature (JWS) structure within a JSON Web Encryption (JWE) structure.
The signature uses the "PS256" (RSASSA PSS) algorithm; the encryption uses the "RSA OAEP" (RSAES OAEP)
key encryption algorithm and the "A128GCM" (AES GCM) content encryption algorithm.
Note that RSASSA PSS uses random data to generate the signature, and RSAES OAEP uses random data to generate the ciphertext; it might not be possible to exactly replicate the results in this section.
Note that whitespace is added for readability as described in Section 1.1.
The following are supplied before beginning the signing operation:  Payload content; this example uses the JSON Web Token [JWT] content from Figure 222, encoded as base64url
[RFC4648] to produce Figure 223.
RSA private key; this example uses the key from Figure 224.
{ "iss": "hobbiton.example", "exp": 1300819380, "http://example.com/is root": true } Figure 222:
Payload Content, in JSON Format eyJpc3MiOiJob2JiaXRvbi5leGFtcGxlIiwiZXhwIjoxMzAwODE5MzgwLCJodH RwOi8vZXhhbXBsZS5jb20vaXNfcm9vdCI6dHJ1ZX0
Payload Content, base64url encoded { "kty": "RSA", "kid": "hobbiton.example", "use": "sig", "n": "kNrPIBDXMU6fcyv5i QHQAQ
nd2BKC5OiG4MwALhaL2Z2k8CsRdfy 7dg7z41Rp6D0ZeEvtaUp4bX4aK raL4rTfw", "e": "AQAB", "d": "ZLe TIxpE9 W n2VBa HWvuYPtjvxwVXClJFOpJsdea8g9RMx34qEO EtnoYc2un3CZ3LtJi mju5RAT8YSc76YJds3ZVw0UiO8mMBeG6 iOnvg obobNx7K57 xjTJZU72EjOr9kB7z6ZKwDDq7HFyCDhUEcYcHFVc7iL 6
TibVhAhOFONWlqlJgEgwVYd0rybNGKifdnpEbwyHoMwY6HM1qvnEFgP7 iZ0YzHUT535x6jj4VKcdA7ZduFkhUauysySEW7mxZM6fj1vdjJIy9LD1 fIz30Xv4ckoqhKF5GONU6tNmMmNgAD6gIViyEle1PrIxl1tBhCI14bRW  zrpHgAQ", "p": "yKWYoNIAqwMRQlgIBOdT1NIcbDNUUs2Rh pBaxD mIkweMt4Mg 0
e0q7M idRDOBXSoe7Z2 CV2x ZCY3RP8qp642R13WgXqGDIM4MbUkZSj cY9 c", "q": "uND4o15V30KDzf8vFJw589p1vlQVQ3NEilrinRUPHkkxaAzDzccGgr WMWpGxGFFnNL3w5CqPLeU76 5IVYQq0HwYVl0hVXQHr7sgaGu 483Ad3
SKvqpYvfSPTczPcZ kh9Kk", "dp": "jmTnEoq2qqa8ouaymjhJSCnsveUXnMQC2gAneQJRQkFqQu zV2PKP KNbPvKVyiF5b2 L3tM3OW2d2iNDyRUWXlT7V5l0KwPTABSTOnTqAmYCh Gi8kXXdlhcrtSvXldBakC6saxwI TzGGY2MVXzc2ZnCvCXHV4qjSxOrf
", "dq": "R9FUvU88OVzEkTkXl3 5 WusE4DjHmndeZIlu3rifBdfLpq P iWP BbGaq9wzQ1c J7SzCdJqkEJDv5yd2C7rnZ6kpzwBh nmL8zscAk1qsun
} Figure 224: RSA 2048 Bit Private Key, in JWK Format 6.2.
The following is generated to complete the signing operation:  JWS Protected Header; this example uses the header from Figure 225, encoded using base64url
JWS Protected Header JSON eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9 Figure 226:
JWS Protected Header, base64url encoded Performing the signature operation over the combined JWS Protected Header (Figure 226) and payload content (Figure 222) produces the following signature:
JWS Signature, base64url encoded 6.3.
The following compose the resulting JWS object:  JWS Protected Header (Figure 226)
The resulting JWS object using the JWS Compact Serialization (which is the plaintext input to the following encryption operation):
The following are supplied before beginning the encryption process:  Plaintext content; this example uses the content from Figure 228.
RSA public key; this example uses the key from Figure 84.
"alg" parameter of "RSA OAEP".
The following are generated before encrypting:
AES symmetric key as the Content Encryption Key (CEK); this example uses the key from Figure 229.
Initialization Vector; this example uses the Initialization Vector from Figure 230.
6 2QBGsYTZLSQ Figure 229: Content Encryption Key, base64url encoded GbX1i9kXz0sxXPmA Figure 230:
Initialization Vector, base64url encoded 6.6.
Encrypting the Key Performing the key encryption operation over the CEK (Figure 229) with the RSA key (Figure 84) produces the following Encrypted Key: a0JHRoITfpX4qRewImjlStn8m3CPxBV1ueYlVhjurCyrBg3I7YhCRYjphDOOS4 E7rXbr2Fn6NyQq A
zkZV7A9matpgevAJWrXzOUysYGTtwoSN6gtUVtlLaivjvb21 O0ul4YxSHV ByK1kyeetRp fuYJxHoKLQL9P424sKx2WGYb4zsBIPF4ssl e5I
Fpp4Z 5o6yV64x6yzDU F 5JCIdl Qv6H5dMVIY7q1eKpXcV1lWO 2FefEBqXxXvIjLeZivjNkzogCq3
Encrypted Key, base64url encoded 6.7.
The following is generated before encrypting the Plaintext:
JWE Protected Header; this example uses the header from Figure 232, encoded using base64url
JWE Protected Header JSON eyJhbGciOiJSU0EtT0FFUCIsImN0eSI6IkpXVCIsImVuYyI6IkExMjhHQ00ifQ Figure 233:
JWE Protected Header, base64url encoded Performing the content encryption operation over the Plaintext (Figure 228) with the following:  CEK (Figure 229);  Initialization Vector
(Figure 230); and  JWE Protected Header (Figure 233) as authenticated data produces the following:  Ciphertext from Figure 234.
Authentication Tag from Figure 235.
BimYZY81zVBuIhc7HsQePCpu33SzMsFHjn4lP idrJz glZ TNgKDt8zdnUPauKTKDNOH1DD4fuzvDYfDIAfqGPyL5sVRwbiXpXdGokEszM 9C hMPqW1QNhzuX Zul3bvrJwr7nuGZs4cUScY3n8yE3AHCLurgls
1sYjKUuis7yWW HTr vqvFt0bj7WJf2vzB0TZ3dvsoGaTvPH2dyWwumUr lx4gmPUzBdwTO6ubfYSDUEEz5py0d OtWeUSYcCYBKD aM7tXg26qJo21gYjLf hn9zy
Ciphertext, base64url encoded KnIKEhN8U 3C9s4gtSpjSw Figure 235:
Authentication Tag, base64url encoded 6.8.
The following compose the resulting JWE object:  JWE Protected Header (Figure 233)
The resulting JWE object using the JWE Compact Serialization:
zkZV7A9matpgevAJWrXzOUysYGTtwoSN6gtUVtlLaivjvb21 O0ul4YxSHV ByK1kyeetRp fuYJxHoKLQL9P424sKx2WGYb4zsBIPF4ssl e5I
Fpp4Z 5o6yV64x6yzDU F 5JCIdl Qv6H5dMVIY7q1eKpXcV1lWO 2FefEBqXxXvIjLeZivjNkzogCq3
X x pkIHkiIHWDOLx03BpqDTivpKkBYwqP2UZkcxqX2Fo GnVrNwlK7Lgxw6FSQvDO 0 .
BimYZY81zVBuIhc7HsQePCpu33SzMsFHjn4lP idrJz glZ TNgKDt8zdnUPauKTKDNOH1DD4fuzvDYfDIAfqGPyL5sVRwbiXpXdGokEszM 9C hMPqW1QNhzuX Zul3bvrJwr7nuGZs4cUScY3n8yE3AHCLurgls
1sYjKUuis7yWW HTr vqvFt0bj7WJf2vzB0TZ3dvsoGaTvPH2dyWwumUr lx4gmPUzBdwTO6ubfYSDUEEz5py0d OtWeUSYcCYBKD aM7tXg26qJo21gYjLf hn9zy
ByK1kyeetRp fuYJxHoKLQL9P424sKx2WGYb4zsBIPF4ssl e 5IR7nany 25 UmC2urosNkoFz9cQ82MypZP8gqbQJyPN Fpp4Z 5
uinIpNcOY3n4KKrXLrCcteX85m4IIHMZa38s1Hpr56fPPseMA Jl tmt a9iEDtOzhtxz8AXy9tsCAZV2XBWNG8c3kJusAamBKOYwfk7J hLRDgOnJjlJLhn7TI4UxDp9dCmUXEN6z0v23W15qJIEXNJtqnblp ymooeWAHCT4e Owbim1g0AEpTHUdA2iiLNs9WTX
utWYUcKrBN gCe2OFMf66cSJ8k2QkxaQD3 R60MGE9ofomwtky3GFxMeGRjtpMt9OAv VLsAXB0 UTCBGyBg3C2bWLXqZlfJAAoJRUPRk
aM7tXg26qJo21gY jLfhn9zy W19sOCZGuzgFjPhawXHpvnj t 0 ES96kogjJLxS1IMU9Y5 XmnwZMyNc9EIwnogsCg hVuvzyP0sIruktmI94
ShDp5dmM", "tag": "KnIKEhN8U 3C9s4gtSpjSw" } Figure 237: General JWE JSON Serialization
e5IR7nany 25 UmC2uros NkoFz9cQ82MypZP8gqbQJyPN Fpp4Z 5o6yV64x6yzDUF
a38s1Hpr56fPPseMA Jltmt a9iEDtOzhtxz8AXy9tsCAZV2XBWNG8c3 kJusAamBKOYwfk7JhLRDgOnJjlJLhn7TI4UxDp9dCmUXEN6z0v23W15q JIEXNJtqnblpymooeWAHCT4e Owbim1g0AEpTHUdA2iiLNs9WTX
", "protected": "eyJhbGciOiJSU0EtT0FFUCIsImN0eSI6IkpXVCIsImVuYy I6IkExMjhHQ00ifQ", "iv": "GbX1i9kXz0sxXPmA", "ciphertext": "SZI4IvKHmwpazl pJQXX3mHv1ANnOU4Wf9
utWYUcKrBN gCe2OFMf66cSJ8k2QkxaQD3 R60MGE9ofomwtky3GFxMeGRjtpMt9OAv VLsAXB0 UTCBGyBg3C2bWLXqZlfJAAoJRUPRk
aM7tXg26qJo21gY jLfhn9zy W19sOCZGuzgFjPhawXHpvnj t 0 ES96kogjJLxS1IMU9Y5 XmnwZMyNc9EIwnogsCg hVuvzyP0sIruktmI94
Flattened JWE JSON Serialization 7.
Security Considerations This document is designed to provide examples for developers to use in checking their implementations.
As such, it does not follow some of the security considerations and recommendations in the core documents (i.e., [JWS], [JWE], [JWK], and [JWA]).
For instance:  it does not always generate a new CEK value for every encrypted example;  it does not always generate a new Initialization Vector (IV) value for every encrypted example; and  it does not always generate a new ephemeral key for every ephemeral key example.
For each example, data that is expected to be generated for each signing or encryption operation is isolated to sections titled "Generated Factors".
