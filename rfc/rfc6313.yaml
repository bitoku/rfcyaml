- title: __initial_text__
  contents:
  - '    Export of Structured Data in IP Flow Information Export (IPFIX)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies an extension to the IP Flow Information\n\
    \   Export (IPFIX) protocol specification in RFC 5101 and the IPFIX\n   information\
    \ model specified in RFC 5102 to support hierarchical\n   structured data and\
    \ lists (sequences) of Information Elements in data\n   records.  This extension\
    \ allows definition of complex data structures\n   such as variable-length lists\
    \ and specification of hierarchical\n   containment relationships between Templates.\
    \  Finally, the semantics\n   are provided in order to express the relationship\
    \ among multiple list\n   elements in a structured data record.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6313.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Overview ........................................................5\n\
    \      1.1. IPFIX Documents Overview ...................................5\n  \
    \    1.2. Relationship between IPFIX and PSAMP .......................6\n   2.\
    \ Introduction ....................................................6\n      2.1.\
    \ The IPFIX Track ............................................7\n      2.2. The\
    \ IPFIX Limitations ......................................8\n      2.3. Structured\
    \ Data Use Cases ..................................8\n      2.4. Specifications\
    \ Summary ....................................11\n   3. Terminology ....................................................11\n\
    \      3.1. New Terminology ...........................................12\n  \
    \    3.2. Conventions Used in This Document .........................12\n   4.\
    \ Linkage with the IPFIX Information Model .......................12\n      4.1.\
    \ New Abstract Data Types ...................................12\n           4.1.1.\
    \ basicList ..........................................12\n           4.1.2. subTemplateList\
    \ ....................................12\n           4.1.3. subTemplateMultiList\
    \ ...............................12\n      4.2. New Data Type Semantic ....................................13\n\
    \           4.2.1. List ...............................................13\n  \
    \    4.3. New Information Elements ..................................13\n    \
    \       4.3.1. basicList ..........................................13\n      \
    \     4.3.2. subTemplateList ....................................13\n        \
    \   4.3.3. subTemplateMultiList ...............................13\n      4.4.\
    \ New Structured Data Type Semantics ........................13\n           4.4.1.\
    \ undefined ..........................................14\n           4.4.2. noneOf\
    \ .............................................14\n           4.4.3. exactlyOneOf\
    \ .......................................14\n           4.4.4. oneOrMoreOf ........................................15\n\
    \           4.4.5. allOf ..............................................16\n  \
    \         4.4.6. ordered ............................................16\n    \
    \  4.5. Encoding of IPFIX Data Types ..............................16\n      \
    \     4.5.1. basicList ..........................................17\n        \
    \   4.5.2. subTemplateList ....................................19\n          \
    \ 4.5.3. subTemplateMultiList ...............................21\n   5. Structured\
    \ Data Format .........................................25\n      5.1. Length Encoding\
    \ Considerations ............................25\n      5.2. Recursive Structured\
    \ Data .................................26\n      5.3. Structured Data Information\
    \ Elements Applicability\n           in Options Template Sets ..................................26\n\
    \      5.4. Usage Guidelines for Equivalent Data Representations ......27\n  \
    \    5.5. Padding ...................................................29\n    \
    \  5.6. Semantic ..................................................29\n   6. Template\
    \ Management ............................................33\n   7. The Collecting\
    \ Process's Side ..................................33\n   8. Defining New Information\
    \ Elements Based on the New\n      Abstract Data Types ............................................34\n\
    \   9. Structured Data Encoding Examples ..............................34\n  \
    \    9.1. Encoding a Multicast Data Record with basicList ...........35\n    \
    \  9.2. Encoding a Load-Balanced Data Record with a basicList .....37\n      9.3.\
    \ Encoding subTemplateList ..................................38\n      9.4. Encoding\
    \ subTemplateMultiList .............................41\n      9.5. Encoding an\
    \ Options Template Set Using Structured Data ....46\n   10. Relationship with\
    \ the Other IPFIX Documents ...................51\n      10.1. Relationship with\
    \ Reducing Redundancy ....................51\n           10.1.1. Encoding Structured\
    \ Data Element Using\n                   Common Properties .................................51\n\
    \           10.1.2. Encoding Common Properties Elements with\n               \
    \    Structured Data Information Element ...............51\n      10.2. Relationship\
    \ with Guidelines for IPFIX Testing ...........53\n      10.3. Relationship with\
    \ IPFIX Mediation Function ...............54\n   11. IANA Considerations ...........................................54\n\
    \      11.1. New Abstract Data Types ..................................54\n  \
    \         11.1.1. basicList .........................................54\n    \
    \       11.1.2. subTemplateList ...................................54\n      \
    \     11.1.3. subTemplateMultiList ..............................55\n      11.2.\
    \ New Data Type Semantics ..................................55\n           11.2.1.\
    \ list ..............................................55\n      11.3. New Information\
    \ Elements .................................55\n           11.3.1. basicList .........................................55\n\
    \           11.3.2. subTemplateList ...................................56\n  \
    \         11.3.3. subTemplateMultiList ..............................56\n    \
    \  11.4. New Structured Data Semantics ............................56\n      \
    \     11.4.1. undefined .........................................56\n        \
    \   11.4.2. noneOf ............................................57\n          \
    \ 11.4.3. exactlyOneOf ......................................57\n           11.4.4.\
    \ oneOrMoreOf .......................................57\n           11.4.5. allOf\
    \ .............................................57\n           11.4.6. ordered\
    \ ...........................................58\n   12. Security Considerations\
    \ .......................................58\n   13. References ....................................................58\n\
    \      13.1. Normative References .....................................58\n  \
    \    13.2. Informative References ...................................58\n   14.\
    \ Acknowledgements ..............................................59\n   Appendix\
    \ A. Additions to XML Specification of IPFIX\n               Information Elements\
    \ and Abstract Data Types ..........60\n   Appendix B. Encoding IPS Alert Using\
    \ Structured Data\n               Information Elements ..................................65\n"
- title: Table of Figures
  contents:
  - "Table of Figures\n  Figure 1:  basicList Encoding ......................................17\n\
    \  Figure 2:  basicList Encoding with Enterprise Number ...............18\n  Figure\
    \ 3:  Variable-Length basicList Encoding (Length < 255 Octets) 18\n  Figure 4:\
    \  Variable-Length basicList Encoding (Length 0 to 65535\n             Octets)\
    \ .................................................19\n  Figure 5:  subTemplateList\
    \ Encoding ................................19\n  Figure 6:  Variable-Length subTemplateList\
    \ Encoding\n             (Length < 255 Octets) ...................................20\n\
    \  Figure 7:  Variable-Length subTemplateList Encoding\n             (Length 0\
    \ to 65535 Octets) ..............................21\n  Figure 8:  subTemplateMultiList\
    \ Encoding ...........................21\n  Figure 9:  Variable-Length subTemplateMultiList\
    \ Encoding\n             (Length < 255 Octets) ...................................23\n\
    \  Figure 10: Variable-Length subTemplateMultiList Encoding\n             (Length\
    \ 0 to 65535 Octets) ..............................24\n  Figure 11: Encoding basicList,\
    \ Template Record .....................35\n  Figure 12: Encoding basicList, Data\
    \ Record, Semantic allOf .........36\n  Figure 13: Encoding basicList, Data Record\
    \ with Variable-Length\n             Elements, Semantic allOf ................................37\n\
    \  Figure 14: Encoding basicList, Data Record, Semantic exactlyOneOf ..38\n  Figure\
    \ 15: Encoding subTemplateList, Template for One-Way Delay\n             Metrics\
    \ .................................................39\n  Figure 16: Encoding subTemplateList,\
    \ Template Record ...............40\n  Figure 17: Encoding subTemplateList, Data\
    \ Set ......................40\n  Figure 18: Encoding subTemplateMultiList, Template\
    \ for Filtering\n             Attributes ..............................................44\n\
    \  Figure 19: Encoding subTemplateMultiList, Template for Sampling\n         \
    \    Attributes ..............................................44\n  Figure 20:\
    \ Encoding subTemplateMultiList, Template for Flow Record .45\n  Figure 21: Encoding\
    \ subTemplateMultiList, Data Set .................45\n  Figure 22: PSAMP SSRI\
    \ to Be encoded ................................48\n  Figure 23: Options Template\
    \ Record for PSAMP SSRI Using\n             subTemplateMultiList ....................................48\n\
    \  Figure 24: PSAMP SSRI, Template Record for interface ...............49\n  Figure\
    \ 25: PSAMP SSRI, Template Record for linecard ................49\n  Figure 26:\
    \ PSAMP SSRI, Template Record for linecard and interface ..49\n  Figure 27: Example\
    \ of a PSAMP SSRI Data Record, Encoded Using a\n             subTemplateMultiList\
    \ ...................................50\n  Figure 28: Common and Specific Properties\
    \ Exported Together\n             [RFC5473] ..............................................51\n\
    \  Figure 29: Common and Specific Properties Exported Separately\n           \
    \  According to [RFC5473] .................................52\n  Figure 30: Common\
    \ and Specific Properties Exported with Structured\n             Data Information\
    \ Element ...............................52\n  Figure 31: Encoding IPS Alert,\
    \ Template for Target ................67\n  Figure 32: Encoding IPS Alert, Template\
    \ for Attacker ..............68\n  Figure 33: Encoding IPS Alert, Template for\
    \ Participant ...........68\n  Figure 34: Encoding IPS Alert, Template for IPS\
    \ Alert .............69\n  Figure 35: Encoding IPS Alert, Data Set ...........................69\n"
- title: 1.  Overview
  contents:
  - '1.  Overview

    '
- title: 1.1.  IPFIX Documents Overview
  contents:
  - "1.1.  IPFIX Documents Overview\n   The IPFIX protocol [RFC5101] provides network\
    \ administrators with\n   access to IP Flow information.\n   The architecture\
    \ for the export of measured IP Flow information out\n   of an IPFIX Exporting\
    \ Process to a Collecting Process is defined in\n   the IPFIX architecture [RFC5470],\
    \ per the requirements defined in RFC\n   3917 [RFC3917].\n   The IPFIX architecture\
    \ [RFC5470] specifies how IPFIX Data Records and\n   Templates are carried via\
    \ a congestion-aware transport protocol from\n   IPFIX Exporting Processes to\
    \ IPFIX Collecting Processes.\n   IPFIX has a formal description of IPFIX Information\
    \ Elements, their\n   name, type, and additional semantic information, as specified\
    \ in the\n   IPFIX information model [RFC5102].\n   In order to gain a level of\
    \ confidence in the IPFIX implementation,\n   probe the conformity and robustness,\
    \ and allow interoperability, the\n   guidelines for IPFIX testing [RFC5471] present\
    \ a list of tests for\n   implementers of compliant Exporting Processes and Collecting\n\
    \   Processes.\n   The Bidirectional Flow Export [RFC5103] specifies a method\
    \ for\n   exporting bidirectional flow (biflow) information using the IP Flow\n\
    \   Information Export (IPFIX) protocol, representing each biflow using a\n  \
    \ single Flow Record.\n   \"Reducing Redundancy in IP Flow Information Export\
    \ (IPFIX) and Packet\n   Sampling (PSAMP) Reports\" [RFC5473] specifies a bandwidth-saving\n\
    \   method for exporting Flow or packet information, by separating\n   information\
    \ common to several Flow Records from information specific\n   to an individual\
    \ Flow Record: common Flow information is exported\n   only once.\n"
- title: 1.2.  Relationship between IPFIX and PSAMP
  contents:
  - "1.2.  Relationship between IPFIX and PSAMP\n   The specification in this document\
    \ applies to the IPFIX protocol\n   specifications [RFC5101].  All specifications\
    \ from [RFC5101] apply\n   unless specified otherwise in this document.\n   The\
    \ Packet Sampling (PSAMP) protocol [RFC5476] specifies the export\n   of packet\
    \ information from a PSAMP Exporting Process to a PSAMP\n   Collecting Process.\
    \  Like IPFIX, PSAMP has a formal description of\n   its information elements,\
    \ their name, type, and additional semantic\n   information.  The PSAMP information\
    \ model is defined in [RFC5477].\n   As the PSAMP protocol specifications [RFC5476]\
    \ are based on the IPFIX\n   protocol specifications, the specifications in this\
    \ document are also\n   valid for the PSAMP protocol.\n   Indeed, the major difference\
    \ between IPFIX and PSAMP is that the\n   IPFIX protocol exports Flow Records\
    \ while the PSAMP protocol exports\n   Packet Reports.  From a pure export point\
    \ of view, IPFIX will not\n   distinguish a Flow Record composed of several packets\
    \ aggregated\n   together from a Flow Record composed of a single packet.  So\
    \ the\n   PSAMP export can be seen as a special IPFIX Flow Record containing\n\
    \   information about a single packet.\n"
- title: 2.  Introduction
  contents:
  - "2.  Introduction\n   While collecting the interface counters every five minutes\
    \ has proven\n   to be useful in the past, more and more granular information\
    \ is\n   required from network elements for a series of applications:\n   performance\
    \ assurance, capacity planning, security, billing, or\n   simply monitoring. \
    \ However, the amount of information has become so\n   large that, when dealing\
    \ with highly granular information such as\n   Flow information, a push mechanism\
    \ (as opposed to a pull mechanism,\n   such as Simple Network Management Protocol\
    \ (SNMP)) is the only\n   solution for routers whose primary function is to route\
    \ packets.\n   Indeed, polling short-lived Flows via SNMP is not an option: high-end\n\
    \   routers can support hundreds of thousands of Flows simultaneously.\n   Furthermore,\
    \ in order to reduce the export bandwidth requirements,\n   the network elements\
    \ have to integrate mediation functions to\n   aggregate the collected information,\
    \ both in space (typically, from\n   different linecards or different Exporters)\
    \ and in time.\n   Typically, it would be beneficial if access routers could export\
    \ Flow\n   Records, composed of the counters before and after an optimization\n\
    \   mechanism on the egress interface, instead of exporting two Flow\n   Records\
    \ with identical tuple information.\n   In terms of aggregation in time, let us\
    \ imagine that, for performance\n   assurance, the network management application\
    \ must receive the\n   performance metrics associated with a specific Flow, every\n\
    \   millisecond.  Since the performance metrics will be constantly\n   changing,\
    \ there is a new dimension to the Flow definition: we are not\n   dealing anymore\
    \ with a single Flow lasting a few seconds or a few\n   minutes, but with a multitude\
    \ of one millisecond sub-flows for which\n   the performance metrics are reported.\n\
    \   Which current protocol is suitable for these requirements: push\n   mechanism,\
    \ highly granular information, and huge number of similar\n   records? IPFIX,\
    \ as specified in RFC 5101 would give part of the\n   solution.\n"
- title: 2.1.  The IPFIX Track
  contents:
  - "2.1.  The IPFIX Track\n   The IPFIX working group has specified a protocol to\
    \ export Flow\n   information [RFC5101].  This protocol is designed to export\n\
    \   information about IP traffic Flows and related measurement data,\n   where\
    \ a Flow is defined by a set of key attributes (e.g., source and\n   destination\
    \ IP address, source and destination port).\n   The IPFIX protocol specification\
    \ [RFC5101] specifies that traffic\n   measurements for Flows are exported using\
    \ a TLV (type, length, value)\n   format.  The information is exported using a\
    \ Template Record that is\n   sent once to export the {type, length} pairs that\
    \ define the data\n   format for the Information Elements in a Flow.  The Data\
    \ Records\n   specify values for each Flow.\n   Based on the requirements for\
    \ IP Flow Information Export (IPFIX)\n   [RFC3917], the IPFIX protocol has been\
    \ optimized to export Flow-\n   related information.  However, thanks to its Template\
    \ mechanism, the\n   IPFIX protocol can export any type of information, as long\
    \ as the\n   relevant Information Element is specified in the IPFIX information\n\
    \   model [RFC5102], registered with IANA [IANA-IPFIX], or specified as\n   an\
    \ enterprise-specific Information Element.  For each Information\n   Element,\
    \ the IPFIX information model [RFC5102] defines a numeric\n   identifier, an abstract\
    \ data type, an encoding mechanism for the data\n   type, and any semantic constraints.\
    \  Only basic, single-valued data\n   types, e.g., numbers, strings, and network\
    \ addresses, are currently\n   supported.\n"
- title: 2.2.  The IPFIX Limitations
  contents:
  - "2.2.  The IPFIX Limitations\n   The IPFIX protocol specification [RFC5101] does\
    \ not support the\n   encoding of hierarchical structured data and arbitrary-length\
    \ lists\n   (sequences) of Information Elements as fields within a Template\n\
    \   Record.  As it is currently specified, a Data Record is a \"flat\" list\n\
    \   of single-valued attributes.  However, it is a common data modeling\n   requirement\
    \ to compose complex hierarchies of data types, with\n   multiple occurrences,\
    \ e.g., 0..* cardinality allowed for instances of\n   each Information Element\
    \ in the hierarchy.\n   A typical example is the MPLS label stack entries model.\
    \  An early\n   NetFlow implementation used two Information Elements to represent\
    \ the\n   MPLS label stack entry: a \"label stack entry position\" followed by\
    \ a\n   \"label stack value\".  However, several drawbacks were discovered.\n\
    \   Firstly, the Information Elements in the Template Record had to be\n   imposed\
    \ so that the position would always precede the value.\n   However, some encoding\
    \ optimizations are based on the permutation of\n   Information Element order.\
    \  Secondly, a new semantic intelligence,\n   not described in the information\
    \ model, had to be hard-coded in the\n   Collecting Process: the label value at\
    \ the position \"X\" in the stack\n   is contained in the \"label stack value\"\
    \ Information Element following\n   by a \"label stack entry position\" Information\
    \ Element containing the\n   value \"X\".  Therefore, this model was abandoned.\n\
    \   The selected solution in the IPFIX information model [RFC5102] is a\n   long\
    \ series of Information Elements: mplsTopLabelStackSection,\n   mplsLabelStackSection2,\
    \ mplsLabelStackSection3,\n   mplsLabelStackSection4, mplsLabelStackSection5,\n\
    \   mplsLabelStackSection6, mplsLabelStackSection7,\n   mplsLabelStackSection8,\
    \ mplsLabelStackSection9,\n   mplsLabelStackSection10.  While this model removes\
    \ any ambiguity, it\n   overloads the IPFIX information model with repetitive\
    \ information.\n   Furthermore, if mplsLabelStackSection11 is required, IANA\n\
    \   [IANA-IPFIX] will not be able to assign the new Information Element\n   next\
    \ to the other ones in the registry, which might cause some\n   confusion.\n"
- title: 2.3.  Structured Data Use Cases
  contents:
  - "2.3.  Structured Data Use Cases\n   Clearly, the MPLS label stack entries issue\
    \ can best be solved by\n   using a real structured data type composed of (\"\
    label stack entry\n   position\", \"label stack value\") pairs, potentially repeated\
    \ multiple\n   times in Flow Records, since this would be the most efficient from\
    \ an\n   information model point of view.\n   Some more examples enter the same\
    \ category: how to encode the list of\n   output interfaces in a multicast Flow,\
    \ how to encode the list of BGP\n   Autonomous Systems (AS) in a BGP Flow, how\
    \ to encode the BGP\n   communities in a BGP Flow, etc.\n   The one-way delay\
    \ passive measurement, which is described in the\n   IPFIX applicability [RFC5472],\
    \ is yet another example that would\n   benefit from a structured data encoding.\
    \  Assuming synchronized\n   clocks, the Collector can deduce the one-way delay\
    \ between two\n   Observation Points from the following two Information Elements,\n\
    \   collected from two different Observation Points:\n       - Packet arrival\
    \ time: observationTimeMicroseconds [RFC5477]\n       - Packet ID: digestHashValue\
    \ [RFC5477]\n   In practice, this implies that many pairs of\n   (observationTimeMicroseconds,\
    \ digestHashValue) must be exported for\n   each Observation Point, even if Hash-Based\
    \ Filtering [RFC5475] is\n   used.  On top of that information, if the requirement\
    \ is to\n   understand the one-way delay per application type, the 5-tuple\n \
    \  (source IP address, destination IP address, protocol, source port,\n   destination\
    \ port) would need to be added to every Flow Record.\n   Instead of exporting\
    \ this repetitive 5-tuple, as part of every single\n   Flow Record a Flow Record\
    \ composed of a structured data type such as\n   the following would save a lot\
    \ of bandwidth:\n      5-tuple\n                { observationTimeMicroseconds\
    \ 1, digestHashValue 1 }\n                { observationTimeMicroseconds 2, digestHashValue\
    \ 2 }\n                { observationTimeMicroseconds 3, digestHashValue 3 }\n\
    \                { ...  , ... }\n   As a last example, here is a more complex\
    \ case of hierarchical\n   structured data encoding.  Consider the example scenario\
    \ of an IPS\n   (Intrusion Prevention System) alert data structure containing\n\
    \   multiple participants, where each participant contains multiple\n   attackers\
    \ and multiple targets, with each target potentially composed\n   of multiple\
    \ applications, as depicted below:\n      alert\n          signatureId\n     \
    \     protocolIdentifier\n          riskRating\n          participant 1\n    \
    \          attacker 1\n                  sourceIPv4Address\n                 \
    \ applicationId\n              ...\n              attacker N\n               \
    \   sourceIPv4Address\n                  applicationId\n              target 1\n\
    \                  destinationIPv4Address\n                  applicationId 1\n\
    \                  ...\n                  applicationId n\n              ...\n\
    \              target N\n                  destinationIPv4Address\n          \
    \        applicationId 1\n                  ...\n                  applicationId\
    \ n\n          participant 2\n              ...\n   To export this information\
    \ in IPFIX, the data would need to be\n   flattened (thus, losing the hierarchical\
    \ relationships) and a new\n   IPFIX Template created for each alert, according\
    \ to the number of\n   applicationId elements in each target, the number of targets\
    \ and\n   attackers in each participant, and the number of participants in each\n\
    \   alert.  Clearly, each Template will be unique to each alert, and a\n   large\
    \ amount of CPU, memory, and export bandwidth will be wasted\n   creating, exporting,\
    \ maintaining, and withdrawing the Templates.  See\n   Appendix B for a specific\
    \ example related to this case study.\n"
- title: 2.4.  Specifications Summary
  contents:
  - "2.4.  Specifications Summary\n   This document specifies an IPFIX extension to\
    \ support hierarchical\n   structured data and variable-length lists by defining\
    \ three new\n   Information Elements and three corresponding new abstract data\
    \ types\n   called basicList, subTemplateList, and subTemplateMultiList.  These\n\
    \   are defined in Sections 4.1 and 4.3.\n   The three Structured Data Information\
    \ Elements carry some semantic\n   information so that the Collecting Process\
    \ can understand the\n   relationship between the different list elements.  The\
    \ semantic in\n   the Structured Data Information Elements is provided in order\
    \ to\n   express the relationship among the multiple top-level list elements.\n\
    \   As an example, if a list is composed of the elements (A,B,C), the\n   semantic\
    \ expresses the relationship among A, B, and C, regardless of\n   whether A, B,\
    \ and C are individual elements or a list of elements.\n   It is important to\
    \ note that whereas the Information Elements and\n   abstract data types defined\
    \ in the IPFIX information model [RFC5102]\n   represent single values, these\
    \ new abstract data types are structural\n   in nature and primarily contain references\
    \ to other Information\n   Elements and to Templates.  By referencing other Information\
    \ Elements\n   and Templates from an Information Element's data content, it is\n\
    \   possible to define complex data structures such as variable-length\n   lists\
    \ and to specify hierarchical containment relationships between\n   Templates.\
    \  Therefore, this document prefers the more generic \"Data\n   Record\" term\
    \ to the \"Flow Record\" term.\n   This document specifies three new abstract\
    \ data types, which are\n   basic blocks to represent structured data.  However,\
    \ this document\n   does not comment on all possible combinations of basicList,\n\
    \   subTemplateList, and subTemplateMultiList.  Neither does it limit the\n  \
    \ possible combinations.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   IPFIX-specific terminology used in this document is defined\
    \ in\n   Section 2 of the IPFIX protocol specification [RFC5101] and Section 3\n\
    \   of the PSAMP protocol specification [RFC5476].  As in [RFC5101],\n   these\
    \ IPFIX-specific terms have the first letter of a word\n   capitalized when used\
    \ in this document.\n"
- title: 3.1.  New Terminology
  contents:
  - "3.1.  New Terminology\n   Structured Data Information Element\n      One of the\
    \ Information Elements supporting structured data, i.e.,\n      the basicList,\
    \ subTemplateList, or subTemplateMultiList\n      Information Elements specified\
    \ in Section 4.3.\n"
- title: 3.2.  Conventions Used in This Document
  contents:
  - "3.2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 4.  Linkage with the IPFIX Information Model
  contents:
  - "4.  Linkage with the IPFIX Information Model\n   As in the IPFIX protocol specification\
    \ [RFC5101], the new Information\n   Elements specified in Section 4.3 MUST be\
    \ sent in canonical format in\n   network-byte order (also known as the big-endian\
    \ byte ordering).\n"
- title: 4.1.  New Abstract Data Types
  contents:
  - "4.1.  New Abstract Data Types\n   This document specifies three new abstract\
    \ data types, as described\n   below.\n"
- title: 4.1.1.  basicList
  contents:
  - "4.1.1.  basicList\n   The type \"basicList\" represents a list of zero or more\
    \ instances of\n   any Information Element, primarily used for single-valued data\
    \ types.\n   Examples include a list of port numbers, a list of interface indexes,\n\
    \   a list of AS in a BGP AS-PATH, etc.\n"
- title: 4.1.2.  subTemplateList
  contents:
  - "4.1.2.  subTemplateList\n   The type \"subTemplateList\" represents a list of\
    \ zero or more\n   instances of a structured data type, where the data type of\
    \ each list\n   element is the same and corresponds with a single Template Record.\n\
    \   Examples include a structured data type composed of multiple pairs of\n  \
    \ (\"MPLS label stack entry position\", \"MPLS label stack value\"), a\n   structured\
    \ data type composed of performance metrics, and a\n   structured data type composed\
    \ of multiple pairs of IP address, etc.\n"
- title: 4.1.3.  subTemplateMultiList
  contents:
  - "4.1.3.  subTemplateMultiList\n   The type \"subTemplateMultiList\" represents\
    \ a list of zero or more\n   instances of a structured data type, where the data\
    \ type of each list\n   element can be different and corresponds with different\
    \ Template\n   definitions.  Examples include a structured data type composed\
    \ of\n   multiple access-list entries, where entries can be composed of\n   different\
    \ criteria types.\n"
- title: 4.2.  New Data Type Semantic
  contents:
  - "4.2.  New Data Type Semantic\n   This document specifies a new data type semantic,\
    \ in addition to the\n   ones specified in Section 3.2 of the IPFIX information\
    \ model\n   [RFC5102], as described below.\n"
- title: 4.2.1.  List
  contents:
  - "4.2.1.  List\n   A list represents an arbitrary-length sequence of zero or more\n\
    \   structured data Information Elements, either composed of regular\n   Information\
    \ Elements or composed of data conforming to a Template\n   Record.\n"
- title: 4.3.  New Information Elements
  contents:
  - "4.3.  New Information Elements\n   This document specifies three new Information\
    \ Elements, as described\n   below.\n"
- title: 4.3.1.  basicList
  contents:
  - "4.3.1.  basicList\n   A basicList specifies a generic Information Element with\
    \ a basicList\n   abstract data type as defined in Section 4.1.1 and list semantics\
    \ as\n   defined in Section 4.2.1.  Examples include a list of port numbers, a\n\
    \   list of interface indexes, etc.\n"
- title: 4.3.2.  subTemplateList
  contents:
  - "4.3.2.  subTemplateList\n   A subTemplateList specifies a generic Information\
    \ Element with a\n   subTemplateList abstract data type as defined in Section\
    \ 4.1.2 and\n   list semantics as defined in Section 4.2.1.\n"
- title: 4.3.3.  subTemplateMultiList
  contents:
  - "4.3.3.  subTemplateMultiList\n   A subTemplateMultiList specifies a generic Information\
    \ Element with a\n   subTemplateMultiList abstract data type as defined in Section\
    \ 4.1.3\n   and list semantics as defined in Section 4.2.1.\n"
- title: 4.4.  New Structured Data Type Semantics
  contents:
  - "4.4.  New Structured Data Type Semantics\n   Structured data type semantics are\
    \ provided in order to express the\n   relationship among multiple list elements\
    \ in a Structured Data\n   Information Element.  These structured data type semantics\
    \ require a\n   new IPFIX subregistry, as specified in the \"IANA Considerations\"\
    \n   section.  The semantics are specified in the following subsections.\n"
- title: 4.4.1.  undefined
  contents:
  - "4.4.1.  undefined\n   The \"undefined\" structured data type semantic specifies\
    \ that the\n   semantic of list elements is not specified and that, if a semantic\n\
    \   exists, then it is up to the Collecting Process to draw its own\n   conclusions.\
    \  The \"undefined\" structured data type semantic, which is\n   the default value,\
    \ is used when no other structured data type\n   semantic applies.\n   For example,\
    \ a mediator that wants to translate IPFIX [RFC5101] into\n   the export of structured\
    \ data according to the specifications in this\n   document doesn't know what\
    \ the semantic is; it can only guess, as the\n   IPFIX specifications [RFC5101]\
    \ does not contain any semantic.\n   Therefore, the mediator should use the \"\
    undefined\" semantic.\n"
- title: 4.4.2.  noneOf
  contents:
  - "4.4.2.  noneOf\n   The \"noneOf\" structured data type semantic specifies that\
    \ none of the\n   elements are actual properties of the Data Record.\n   For example,\
    \ a mediator might want to report to a Collector that a\n   specific Flow is suspicious,\
    \ but that it checked already that this\n   Flow does not belong to the attack\
    \ type 1, attack type 2, or attack\n   type 3.  So this Flow might need some further\
    \ inspection.  In such a\n   case, the mediator would report the Flow Record with\
    \ a basicList\n   composed of (attack type 1, attack type 2, attack type 3) and\
    \ the\n   respective structured data type semantic of \"noneOf\".\n   Another\
    \ example is a router that monitors some specific BGP AS-PATHs\n   and reports\
    \ if a Flow belongs to any of them.  If the router wants to\n   export that a\
    \ Flow does not belong to any of the monitored BGP AS-\n   PATHs, the router reports\
    \ a Data Record with a basicList composed of\n   (BGP AS-PATH 1, BGP AS-PATH 2,\
    \ BGP AS-PATH 3) and the respective\n   structured data type semantic of \"noneOf\"\
    .\n"
- title: 4.4.3. exactlyOneOf
  contents:
  - "4.4.3. exactlyOneOf\n   The \"exactlyOneOf\" structured data type semantic specifies\
    \ that only\n   a single element from the structured data is an actual property\
    \ of\n   the Data Record.  This is equivalent to a logical XOR operation.\n  \
    \ For example, if a Flow record contains a basicList of outgoing\n   interfaces\
    \ with the \"exactlyOneOf\" semantic, then it implies that the\n   reported Flow\
    \ only egressed from a single interface, although the\n   Flow Record lists all\
    \ of the possible outgoing interfaces.  This is a\n   typical example of a per\
    \ destination load-balancing.\n   Another example is a mediator that must aggregate\
    \ Data Records from\n   different Observation Points and report an aggregated\
    \ Observation\n   Point.  However, the different Observation Points can be specified\
    \ by\n   different Information Element types depending on the Exporter.  For\n\
    \   example:\n      Exporter1 Observation Point is characterized by the\n    \
    \  exporterIPv4Address, so a specific Exporter can be represented.\n      Exporter2\
    \ Observation Point is characterized by the\n      exporterIPv4Address and a basicList\
    \ of ingressInterface, so the\n      Exporting Process can express that the observations\
    \ were made on a\n      series of input interfaces.\n      Exporter3 Observation\
    \ Point is characterized by the\n      exporterIPv4Address and a specific lineCardId,\
    \ so the Exporting\n      Process can express that the observation was made on\
    \ a specific\n      linecard.\n   If the mediator models the three different types\
    \ of Observation\n   Points with the three Template Records below:\n      Template\
    \ Record 1: exporterIPv4Address\n      Template Record 2: exporterIPv4Address,\
    \ basicList of\n                         ingressInterface\n      Template Record\
    \ 3: exporterIPv4Address, lineCardId\n   then it can represent the aggregated\
    \ Observation Point with a\n   subTemplateMultiList and the semantic \"exactlyOneOf\"\
    .  The aggregated\n   Observation Point is modeled with the Data Records corresponding\
    \ to\n   either Template Record 1, Template Record 2, or Template Record 3 but\n\
    \   not more than one of these.  This implies that the Flow was observed\n   at\
    \ exactly one of the Observation Points reported.\n"
- title: 4.4.4.  oneOrMoreOf
  contents:
  - "4.4.4.  oneOrMoreOf\n   The \"oneOrMoreOf\" structured data type semantic specifies\
    \ that one or\n   more elements from the list in the structured data are actual\n\
    \   properties of the Data Record.  This is equivalent to a logical OR\n   operation.\n\
    \   Consider an example where a mediator must report an aggregated Flow\n   (e.g.,\
    \ by aggregating IP addresses from IP prefixes), with an\n   aggregated Observation\
    \ Point.  However, the different Observation\n   Points can be specified by different\
    \ Information Element types as\n   described in Section 4.4.2.\n   If the mediator\
    \ models the three different types of Observation\n   Points with the three Template\
    \ Records below:\n          Template Record 1: exporterIPv4Address\n         \
    \ Template Record 2: exporterIPv4Address, basicList of\n                     \
    \        ingressInterface\n          Template Record 3: exporterIPv4Address, lineCardId\n\
    \   then it can represent the aggregated Observation Point with a\n   subTemplateMultiList\
    \ and the semantic \"oneOrMoreOf\".  The aggregated\n   Observation Point is modeled\
    \ with the Data Records corresponding to\n   either Template Record 1, Template\
    \ Record 2, or Template Record 3.\n   This implies that the Flow was observed\
    \ on at least one of the\n   Observation Points reported, and potentially on multiple\
    \ Observation\n   Points.\n"
- title: 4.4.5.  allOf
  contents:
  - "4.4.5.  allOf\n   The \"allOf\" structured data type semantic specifies that\
    \ all of the\n   list elements from the structured data are actual properties\
    \ of the\n   Data Record.\n   For example, if a Record contains a basicList of\
    \ outgoing interfaces\n   with the \"allOf\" semantic, then the observed Flow\
    \ is typically a\n   multicast Flow where each packet in the Flow has been replicated\
    \ to\n   each outgoing interface in the basicList.\n"
- title: 4.4.6.  ordered
  contents:
  - "4.4.6.  ordered\n   The \"ordered\" structured data type semantic specifies that\
    \ elements\n   from the list in the structured data are ordered.\n   For example,\
    \ an Exporter might want to export the AS10 AS20 AS30 AS40\n   BGP AS-PATH.  In\
    \ such a case, the Exporter would report a basicList\n   composed of (AS10, AS20,\
    \ AS30, AS40) and the respective structured\n   data type semantic of \"ordered\"\
    .\n"
- title: 4.5.  Encoding of IPFIX Data Types
  contents:
  - "4.5.  Encoding of IPFIX Data Types\n   The following subsections define the encoding\
    \ of the abstract data\n   types defined in Section 4.1.  These data types may\
    \ be encoded using\n   either fixed- or variable-length Information Elements,\
    \ as discussed\n   in Section 5.1.  Like in the IPFIX specifications [RFC5101],\
    \ all\n   lengths are specified in octets.\n"
- title: 4.5.1.  basicList
  contents:
  - "4.5.1.  basicList\n   The basicList Information Element defined in Section 4.3.1\
    \ represents\n   a list of zero or more instances of an Information Element and\
    \ is\n   encoded as follows:\n    0                   1                   2  \
    \                 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Semantic    |0|          Field ID           |   Element...  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...Length     |           basicList Content ...               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 1: basicList Encoding\n   Semantic\n      The Semantic\
    \ field indicates the relationship among the different\n      Information Element\
    \ values within this Structured Data Information\n      Element.  Refer to IANA's\
    \ \"IPFIX Structured Data Types Semantics\"\n      registry.\n   Field ID\n  \
    \    Field ID is the Information Element identifier of the Information\n     \
    \ Element(s) contained in the list.\n   Element Length\n      Per Section 7 of\
    \ [RFC5101], the Element Length field indicates the\n      length, in octets,\
    \ of each list element specified by Field ID, or\n      contains the value 0xFFFF\
    \ if the length is encoded as a variable-\n      length Information Element at\
    \ the start of the basicList Content.\n      Effectively, the Element Length field\
    \ is part of the header, so\n      even in the case of a zero-element list, it\
    \ MUST NOT be omitted.\n   basicList Content\n      A Collecting Process decodes\
    \ list elements from the basicList\n      Content until no further data remains.\
    \  A field count is not\n      included but can be derived when the Information\
    \ Element is\n      decoded.\n   Note that in the diagram above, Field ID is shown\
    \ with the Enterprise\n   bit (most significant bit) set to 0.  Instead, if the\
    \ Enterprise bit\n   is set to 1, a four-byte Enterprise Number MUST be encoded\n\
    \   immediately after the Element Length as shown below.  See the \"Field\n  \
    \ Specifier Format\" section in the IPFIX protocol [RFC5101] for\n   additional\
    \ information.\n    0                   1                   2                \
    \   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   \
    \ Semantic   |1|         Field ID            |   Element...  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...Length     |               Enterprise Number ...           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |              basicList Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           Figure 2: basicList Encoding with Enterprise Number\n   Also, note\
    \ that if a basicList has zero elements, the encoded data\n   contains the Semantic\
    \ field, Field ID, the Element Length field, and\n   the four-byte Enterprise\
    \ Number (if present), while the basicList\n   Content is empty.\n   If the basicList\
    \ is encoded as a variable-length Information Element\n   in less than 255 octets,\
    \ it MAY be encoded with the Length field per\n   Section 7 of [RFC5101] as shown\
    \ in Figure 3.  However, the three-byte\n   length encoding, as shown in Figure\
    \ 4, is RECOMMENDED (see Section\n   5.1).\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Length (< 255)|   Semantic    |0|          Field ID           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Element Length        | basicList Content ...         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Figure 3: Variable-Length basicList Encoding\n                      (Length\
    \ < 255 Octets)\n   If the basicList is encoded as a variable-length Information\
    \ Element\n   in 255 or more octets, it MUST be encoded with the Length field\
    \ per\n   Section 7 of [RFC5101] as follows:\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      255      |      Length (0 to 65535)      |   Semantic    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|          Field ID           |        Element Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      basicList Content ...                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 4: Variable-Length basicList Encoding\n                  (Length\
    \ 0 to 65535 Octets)\n"
- title: 4.5.2.  subTemplateList
  contents:
  - "4.5.2.  subTemplateList\n   The subTemplateList Information Element represents\
    \ a list of zero or\n   more Data Records corresponding to a specific Template.\
    \  Because the\n   Template Record referenced by a subTemplateList Information\
    \ Element\n   can itself contain other subTemplateList Information Elements, and\n\
    \   because these Template Record references are part of the Information\n   Elements\
    \ content in the Data Record, it is possible to represent\n   complex hierarchical\
    \ data structures.  The following diagram shows\n   how a subTemplateList Information\
    \ Element is encoded within a Data\n   Record:\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Semantic    |         Template ID           |     ...       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                subTemplateList Content    ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 5: subTemplateList Encoding\n   Semantic\n      The\
    \ Semantic field indicates the relationship among the different\n      Data Records\
    \ within this Structured Data Information Element.\n   Template ID\n      The\
    \ Template ID field contains the ID of the Template used to\n      encode and\
    \ decode the subTemplateList Content.\n   subTemplateList Content\n      subTemplateList\
    \ Content consists of zero or more instances of Data\n      Records corresponding\
    \ to the Template ID specified in the Template\n      ID field.  A Collecting\
    \ Process decodes the subTemplateList\n      Content until no further data remains.\
    \  A record count is not\n      included but can be derived when the subTemplateList\
    \ is decoded.\n      Encoding and decoding are performed recursively if the specified\n\
    \      Template itself contains Structured Data Information Elements as\n    \
    \  described here.\n   Note that, if a subTemplateList has zero elements, the\
    \ encoded data\n   contains only the Semantic field and the Template ID field,\
    \ while the\n   subTemplateList Content is empty.\n   If the subTemplateList is\
    \ encoded as a variable-length Information\n   Element in less than 255 octets,\
    \ it MAY be encoded with the Length\n   field per Section 7 of [RFC5101] as shown\
    \ in Figure 6.  However, the\n   three-byte length encoding, as shown in Figure\
    \ 7, is RECOMMENDED (see\n   Section 5.1).\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Length (< 255)|   Semantic    |         Template ID           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                subTemplateList Content    ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 6: Variable-Length subTemplateList Encoding\n                   \
    \    (Length < 255 Octets)\n   If the subTemplateList is encoded as a variable-length\
    \ Information\n   Element in 255 or more octets, it MUST be encoded with the Length\n\
    \   field per Section 7 of [RFC5101] as follows:\n    0                   1  \
    \                 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      255      |      Length (0 to 65535)      |   Semantic    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Template ID           | subTemplateList Content ...   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 7: Variable-Length subTemplateList Encoding\n                   \
    \ (Length 0 to 65535 Octets)\n"
- title: 4.5.3.  subTemplateMultiList
  contents:
  - "4.5.3.  subTemplateMultiList\n   Whereas each element in a subTemplateList Information\
    \ Element\n   corresponds to a single Template, it is sometimes useful for a list\n\
    \   to contain elements corresponding to different Templates.  To support\n  \
    \ this case, each top-level element in a subTemplateMultiList\n   Information\
    \ Element carries a Template ID, Length, and zero or more\n   Data Records corresponding\
    \ to the Template ID.  The following diagram\n   shows how a subTemplateMultiList\
    \ Information Element is encoded\n   within a Data Record.  Note that the encoding\
    \ following the Semantic\n   field is consistent with the Set Header specified\
    \ in [RFC5101].\n    0                   1                   2               \
    \    3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \  Semantic   |         Template ID X         |Data Records...|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ... Length X  |        Data Record X.1 Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |        Data Record X.2 Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |        Data Record X.L Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |         Template ID Y         |Data Records...|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ... Length Y  |        Data Record  Y.1 Content ...           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |        Data Record Y.2 Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |        Data Record Y.M Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |         Template ID Z         |Data Records...|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ... Length Z  |        Data Record Z.1 Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |        Data Record Z.2 Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |        Data Record Z.N Content ...            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ...      |\n   +-+-+-+-+-+-+-+-+\n                Figure 8: subTemplateMultiList\
    \ Encoding\n   Semantic\n      The Semantic field indicates the top-level relationship\
    \ among the\n      series of Data Records corresponding to the different Template\n\
    \      Records within this Structured Data Information Element.\n   Template ID\n\
    \      Unlike the subTemplateList Information Element, each element of\n     \
    \ the subTemplateMultiList contains a Template ID that specifies the\n      encoding\
    \ of the following Data Records.\n   Data Records Length\n      This is the total\
    \ length of the Data Records encoding for the\n      Template ID previously specified,\
    \ including the two bytes for the\n      Template ID and the two bytes for the\
    \ Data Records Length field\n      itself.\n   Data Record X.M\n      The Data\
    \ Record X.M consists of the Mth Data Record of the\n      Template Record X.\
    \  A Collecting Process decodes the Data Records\n      according to Template\
    \ Record X until no further data remains,\n      according to the Data Records\
    \ Length X.  Further Template IDs and\n      Data Records may then be decoded\
    \ according to the overall\n      subTemplateMultiList length.  A record count\
    \ is not included but\n      can be derived when the Element Content is decoded.\
    \  Encoding and\n      decoding are performed recursively if the specified Template\n\
    \      itself contains Structured Data Information Elements as described\n   \
    \   here.\n   In the exceptional case of zero instances in the\n   subTemplateMultiList,\
    \ no data is encoded, only the Semantic field and\n   Template ID field(s), and\
    \ the Data Record Length field is set to\n   zero.\n   If the subTemplateMultiList\
    \ is encoded as a variable-length\n   Information Element in less than 255 octets,\
    \ it MAY be encoded with\n   the Length field per Section 7 of [RFC5101] as shown\
    \ in Figure 9.\n   However, the three-byte length encoding, as shown in Figure\
    \ 10, is\n   RECOMMENDED (see Section 5.1).\n    0                   1       \
    \            2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Length (< 255)|    Semantic   |         Template ID X         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Data Records Length X    |  Data Record X.1 Content ...  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |   Data Record X.2 Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |   Data Record X.L Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |         Template ID Y         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Data Records Length Y    |   Data Record Y.1 Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |   Data Record Y.2 Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |   Data Record Y.M Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |         Template ID Z         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Data Records Length Z    |   Data Record Z.1 Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |   Data Record Z.2 Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |   Data Record Z.N Content ... |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             ...               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 9: Variable-Length subTemplateMultiList Encoding\n             \
    \         (Length < 255 Octets)\n   If the subTemplateMultiList is encoded as\
    \ a variable-length\n   Information Element in 255 or more octets, it MUST be\
    \ encoded with\n   the Length field per Section 7 of [RFC5101] as follows:\n \
    \   0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      255      |      Length (0 to 65535)      |   Semantic    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Template ID X         |    Data Records Length X      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Data Record X.1 Content ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Data Record X.2 Content ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Data Record X.L Content ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Template ID Y         |    Data Records Length Y      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Data Record  Y.1 Content ...                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Data Record Y.2 Content ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Data Record Y.M Content ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Template ID Z         |    Data Records Length Z      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Data Record Z.1 Content ...               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Data Record Z.2 Content ...               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Data Record Z.N Content ...               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 10: Variable-Length subTemplateMultiList Encoding\n             \
    \           (Length 0 to 65535 Octets)\n"
- title: 5.  Structured Data Format
  contents:
  - '5.  Structured Data Format

    '
- title: 5.1.  Length Encoding Considerations
  contents:
  - "5.1.  Length Encoding Considerations\n   The new Structured Data Information\
    \ Elements represent a list that\n   potentially carries complex hierarchical\
    \ and repeated data.\n   When the encoding of a Structured Data Information Element\
    \ has a\n   fixed length (because, for example, it contains the same number of\n\
    \   fixed-length elements, or if the permutations of elements in the list\n  \
    \ always produces the same total length), the element length can be\n   encoded\
    \ in the corresponding Template Record.\n   However, when representing variable-length\
    \ data, hierarchical data,\n   and repeated data with variable element counts,\
    \ where the number and\n   length of elements can vary from record to record,\
    \ we RECOMMEND that\n   the Information Elements are encoded using the variable-length\n\
    \   encoding described in Section 7 of [RFC5101], with the length carried\n  \
    \ before the Structured Data Information Element encoding.\n   Because of the\
    \ complex and repeated nature of the data, it is\n   potentially difficult for\
    \ the Exporting Process to efficiently know\n   in advance the exact encoding\
    \ size.  In this case, the Exporting\n   Process may encode the available data\
    \ starting at a fixed offset and\n   fill in the final length afterwards.  Therefore,\
    \ the three-byte\n   length encoding is RECOMMENDED for variable-length Information\n\
    \   Elements in all Template Records containing a Structured Data\n   Information\
    \ Element, even if the encoded length can be less than 255\n   bytes, because\
    \ the starting offset of the data is known in advance.\n   When encoding such\
    \ data, an Exporting Process MUST take care to not\n   exceed the maximum allowed\
    \ IPFIX message length of 65535 bytes as\n   specified in [RFC5101].\n"
- title: 5.2.  Recursive Structured Data
  contents:
  - "5.2.  Recursive Structured Data\n   It is possible to define recursive relationships\
    \ between IPFIX\n   structured data instances, for example, when representing\
    \ a tree\n   structure.  The simplest case of this might be a basicList, where\n\
    \   each element is itself a basicList, or a subTemplateList where one of\n  \
    \ the fields of the referenced Template is itself a subTemplateList\n   referencing\
    \ the same Template.  Also, the Exporting Process MUST take\n   care when encoding\
    \ recursively-defined structured data not to exceed\n   the maximum allowed length\
    \ of an IPFIX Message (as noted in Length\n   Encoding Considerations).\n"
- title: 5.3.  Structured Data Information Elements Applicability in Options
  contents:
  - "5.3.  Structured Data Information Elements Applicability in Options\n      Template\
    \ Sets\n   Structured Data Information Elements MAY be used in Options Template\n\
    \   Sets.\n   As an example, consider a mediation function that must aggregate\
    \ Data\n   Records from multiple Observation Point types:\n      Router 1, (interface\
    \ 1)\n      Router 2, (linecard A)\n      Router 3, (linecard B)\n      Router\
    \ 4, (linecard C, interface 2)\n   In order to encode the PSAMP Selection Sequence\
    \ Report Interpretation\n   [RFC5476], the mediation function must express this\
    \ combination of\n   Observation Points as a single new Observation Point.  Recall\
    \ from\n   [RFC5476] that the PSAMP Selection Sequence Report Interpretation\n\
    \   consists of the following fields:\n     Scope:     selectionSequenceId\n \
    \    Non-Scope: one Information Element mapping the Observation Point\n      \
    \          selectorId (one or more)\n   Without structured data, there is clearly\
    \ no way to express the\n   complex aggregated Observation Point as \"one Information\
    \ Element\n   mapping the Observation Point\".  However, the desired result may\
    \ be\n   easily achieved using the structured data types.  Refer to Section\n\
    \   9.5. for an encoding example related to this case study.\n   Regarding the\
    \ scope in the Options Template Record, the IPFIX\n   specification [RFC5101]\
    \ mentions that \"the IPFIX protocol doesn't\n   prevent the use of any Information\
    \ Elements for scope\".  Therefore, a\n   Structured Data Information Element\
    \ MAY be used as scope in an\n   Options Template Set.\n   Extending the previous\
    \ example, the mediation function could export a\n   given name for this complex\
    \ aggregated Observation Point:\n      Scope: Aggregated Observation Point (structured\
    \ data)\n      Non-Scope: a new Information Element containing the name\n"
- title: 5.4.  Usage Guidelines for Equivalent Data Representations
  contents:
  - "5.4.  Usage Guidelines for Equivalent Data Representations\n   Because basicList,\
    \ subTemplateList, and subTemplateMultiList are all\n   lists, in several cases,\
    \ there is more than one way to represent what\n   is effectively the same data\
    \ structure.  However, in some cases, one\n   approach has an advantage over the\
    \ other, e.g., more compact, uses\n   fewer resources, and is therefore preferred\
    \ over an alternate\n   representation.\n   A subTemplateList can represent the\
    \ same simple list of single-valued\n   Information Elements as a basicList, if\
    \ the Template referenced by\n   the subTemplateList contains only one single-valued\
    \ Information\n   Element.  Although the encoding is more compact than a basicList\
    \ by\n   two bytes, using a subTemplateList, in this case, requires a new\n  \
    \ Template per Information Element.  The basicList requires no\n   additional\
    \ Template and is therefore RECOMMENDED in this case.\n   Although a subTemplateMultiList\
    \ with one Element can represent the\n   contents of a subTemplateList, the subTemplateMultiList\
    \ carries two\n   additional bytes (Element Length).  It is also potentially useful\
    \ to\n   a Collecting Process to know in advance that a subTemplateList\n   directly\
    \ indicates that list element types are consistent.  The\n   subTemplateList Information\
    \ Element is therefore RECOMMENDED in this\n   case.\n   The Semantic field in\
    \ a subTemplateMultiList indicates the top-level\n   relationship among the series\
    \ of Data Records corresponding to the\n   different Template Records, within\
    \ this Structured Data Information\n   Element.  If a semantic is required to\
    \ describe the relationship\n   among the different Data Records corresponding\
    \ to a single Template\n   ID within the subTemplateMultiList, then an encoding\
    \ based on a\n   basicList of subTemplateLists should be used; refer to Section\
    \ 5.6\n   for more information.  Alternatively, if a semantic is required to\n\
    \   describe the relationship among all Data Records within a\n   subTemplateMultiList\
    \ (regardless of the Template Record), an encoding\n   based on a subTemplateMultiList\
    \ with one Data Record corresponding to\n   a single Template ID can be used.\n\
    \   Note that the referenced Information Element(s) in the Structured\n   Data\
    \ Information Elements can be taken from the IPFIX information\n   model [RFC5102],\
    \ the PSAMP information model [RFC5477], any of the\n   Information Elements defined\
    \ in the IANA IPFIX registry [IANA-IPFIX],\n   or enterprise-specific Information\
    \ Elements.\n   If a Template Record contains a subTemplateList as the only field,\
    \ a\n   Set encoding as specified in the IPFIX protocol specifications\n   [RFC5101]\
    \ should be considered, unless:\n   - A relationship among multiple list elements\
    \ must be exported, in\n     which case, the semantic from the IPFIX Structured\
    \ Data Information\n     Element can convey this relationship.\n   - The Exporting\
    \ Process wants to convey the number of elements in the\n     list, even in the\
    \ special cases of zero or one element in the list.\n     Indeed, the case of\
    \ an empty list cannot be represented with the\n     IPFIX protocol specifications\
    \ [RFC5101].  In the case of a single\n     element list, the Template Record\
    \ specified in the IPFIX protocol\n     specification [RFC5101] could be used.\
    \  However, on the top of the\n     Template Record with the subTemplateList to\
    \ export multiple list\n     elements, this supplementary Template would impose\
    \ some extra\n     management, both on the Exporting Process and on the Collecting\n\
    \     Process, which might have to correlate the information from two\n     Template\
    \ Records.\n   Similarly, if a Template Record contains a subTemplateMultiList\
    \ as\n   the only field, an IPFIX Message as described in the IPFIX protocol\n\
    \   specification [RFC5101] should be considered, unless:\n   - A relationship\
    \ among top-level list elements must be exported, in\n     which case, the semantic\
    \ from the IPFIX Structured Data Information\n     Element can convey this relationship.\n\
    \   - The Exporting Process wants to convey the number of Data Records\n     corresponding\
    \ to every Template in the subTemplateMultiList.\n"
- title: 5.5.  Padding
  contents:
  - "5.5.  Padding\n   The Exporting Process MAY insert some padding octets in structured\n\
    \   data field values in a Data Record by including the 'paddingOctets'\n   Information\
    \ Element as described in [RFC5101], Section 3.3.1.  The\n   paddingOctets Information\
    \ Element can be included in a Template\n   Record referenced by a structured\
    \ data Information Element for this\n   purpose.\n"
- title: 5.6.  Semantic
  contents:
  - "5.6.  Semantic\n   Semantic interpretations of received Data Records at or beyond\
    \ the\n   Collecting Process remain explicitly undefined, unless that data is\n\
    \   transmitted using this extension with explicit structured data type\n   semantic\
    \ information.\n   It is not the Exporter's role to check the validity of the\
    \ semantic\n   representation of Data Records.\n   More complex semantics can\
    \ be expressed as a combination of the\n   Semantic Data Information Elements\
    \ specified in this document.\n   For example, the export of the AS10 AS20 AS30\
    \ AS40 {AS50,AS60} BGP\n   AS-PATH would be reported as a basicList of two elements,\
    \ each\n   element being a basicList of BGP AS, with the top-level structured\n\
    \   data type semantic of \"ordered\".  The first element would contain a\n  \
    \ basicList composed of (AS10,AS20,AS30,AS40) and the respective\n   structured\
    \ data type semantic of \"ordered\", while the second element\n   would contain\
    \ a basicList composed of (AS50, AS60) and the respective\n   structured data\
    \ type semantic of \"exactlyOneOf\".  A high-level Data\n   Record diagram would\
    \ be represented as:\n        BGP AS-PATH = (basicList, ordered,\n           \
    \ (basicList, ordered, AS10,AS20,AS30,AS40),\n            (basicList, exactlyOneOf,\
    \ AS50, AS60)\n        )\n   If a semantic is required to describe the relationship\
    \ among the\n   different Data Records corresponding to a single Template ID within\n\
    \   the subTemplateMultiList, then an encoding based on a basicList of\n   subTemplateLists\
    \ should be used, as shown in the next case study.\n    Case study 1:\n   In this\
    \ example, an Exporter monitoring security attacks must export\n   a list of security\
    \ events consisting of attackers and targets.  For\n   the sake of the example,\
    \ assume that the Collector can differentiate\n   the attacker (which is expressed\
    \ using source fields) from the target\n   (which is expressed using destination\
    \ fields).  Imagine that\n   attackers A1 or A2 may attack targets T1 and T2.\n\
    \   The first case uses a subTemplateMultiList composed of two Template\n   Records,\
    \ one representing the attacker and one representing the\n   target, each of them\
    \ containing an IP address and a port.\n        Attacker Template Record = (src\
    \ IP address, src port)\n        Target Template Record = (dst IP address, dst\
    \ port)\n   A high-level Data Record diagram would be represented as:\n      \
    \   Alert = (subTemplateMultiList, allOf,\n            (Attacker Template Record,\
    \ A1, A2),\n            (Target Template Record, T1, T2)\n         )\n   The Collecting\
    \ Process can only conclude that the list of attackers\n   (A1, A2) and the list\
    \ of targets (T1, T2) are present, without\n   knowing the relationship amongst\
    \ attackers and targets.  The\n   Exporting Process would have to explicitly call\
    \ out the relationship\n   amongst attackers and targets as the top-level semantic\
    \ offered by\n   the subTemplateMultiList isn't sufficient.\n   The only proper\
    \ encoding for the previous semantic (i.e., attacker A1\n   or A2 may attack target\
    \ T1 and T2) uses a basicList of\n   subTemplateLists and is represented as follows:\n\
    \        Attacker Template Record = (src IP address, src port)\n        Target\
    \ Template Record = (dst IP address, dst port)\n        Alert = (basicList, allOf,\n\
    \              (subTemplateList, exactlyOneOf, attacker A1, A2)\n            \
    \  (subTemplateList, allOf, target T1, T2)\n        )\n    Case study 2:\n   In\
    \ this example, an Exporter monitoring security attacks must export\n   a list\
    \ of attackers and targets.  For the sake of the example, assume\n   that the\
    \ Collector can differentiate the attacker (which is expressed\n   using source\
    \ fields) from the target (which is expressed using\n   destination fields). \
    \ Imagine that attacker A1 or A2 is attacking\n   target T1, while attacker A3\
    \ is attacking targets T2 and T3.  The\n   first case uses a subTemplateMultiList\
    \ that contains Data Records\n   corresponding to two Template Records, one representing\
    \ the attacker\n   and one representing the target, each of them containing an\
    \ IP\n   address and a port.\n        Attacker Template Record = (src IP address,\
    \ src port)\n        Target Template Record = (dst IP address, dst port)\n   A\
    \ high-level Data Record diagram would be represented as:\n         Alert = (subTemplateMultiList,\
    \ allOf,\n            (Attacker Template Record, A1, A2, A3),\n            (Target\
    \ Template Record, T1, T2, T3)\n         )\n   The Collecting Process can only\
    \ conclude that the list of attackers\n   (A1, A2, A3), and the list of targets\
    \ (T1, T2, T3) are present,\n   without knowing the relationship amongst attackers\
    \ and targets.\n   The second case could use a Data Record definition composed\
    \ of the\n   following:\n         Alert = (subTemplateMultiList, allOf,\n    \
    \        (Attacker Template Record, A1, A2),\n            (Target Template Record,\
    \ T1),\n            (Attacker Template Record, A3),\n            (Target Template\
    \ Record, T2, T3)\n         )\n   With the above representation, the Collecting\
    \ Process can infer that\n   the alert consists of the list of attackers (A1,\
    \ A2), target (T1),\n   attacker (A3), and list of targets (T2, T3).  From the\
    \ sequence in\n   which attackers and targets are encoded, the Collector can possibly\n\
    \   deduce that some relationship exists among (A1, A2, T1) and (A2, T1,\n   T2)\
    \ but cannot understand what it is exactly.  So, there is a need\n   for the Exporting\
    \ Process to explicitly define the relationship\n   between the attackers, and\
    \ targets and the top-level semantic of the\n   subTemplateMultiList is not sufficient.\n\
    \   The only proper encoding for the previous semantic (i.e., attacker A1\n  \
    \ or A2 attacks target T1, attacker A3 attacks targets T2 and T3) uses\n   a basicList\
    \ of subTemplateLists and is represented as follows:\n        Participant P1 =\n\
    \        (basicList, allOf,\n              (subTemplateList, exactlyOneOf, attacker\
    \ A1, A2)\n              (subTemplateList, undefined, target T1)\n        )\n\
    \        Participant P2 =\n        (basicList, allOf,\n              (subTemplateList,\
    \ undefined, attacker A3,\n              (subTemplateList, allOf, targets T2,\
    \ T3)\n        )\n   The security alert is represented as a subTemplateList of\n\
    \   participants.\n        Alert =\n           (subTemplateList, allOf, Participant\
    \ P1, Participant P2)\n   Note that, in the particular case of a single element\
    \ in a Structured\n   Data Information Element, the Semantic field is actually\
    \ not very\n   useful since it specifies the relationship among multiple elements.\n\
    \   Any choice of allOf, exactlyOneOf, or OneOrMoreOf would provide the\n   same\
    \ result semantically.  Therefore, in case of a single element in\n   a Structured\
    \ Data Information Element, the default \"undefined\"\n   semantic SHOULD be used.\n"
- title: 6.  Template Management
  contents:
  - "6.  Template Management\n   This section introduces some more specific Template\
    \ management and\n   Template Withdrawal Message-related specifications compared\
    \ to the\n   IPFIX protocol specification [RFC5101].\n   First of all, the Template\
    \ ID uniqueness is unchanged compared to\n   [RFC5101]; the uniqueness is local\
    \ to the Transport Session and\n   Observation Domain that generated the Template\
    \ ID.  In other words,\n   the Set ID used to export the Template Record does\
    \ not influence the\n   Template ID uniqueness.\n   While [RFC5101] mentions that\
    \ \"if an Information Element is required\n   more than once in a Template, the\
    \ different occurrences of this\n   Information Element SHOULD follow the logical\
    \ order of their\n   treatments by the Metering Process\", this rule MAY be ignored\
    \ within\n   Structured Data Information Elements.\n   As specified in [RFC5101],\
    \ Templates that are not used anymore SHOULD\n   be deleted.  Deleting a Template\
    \ implies that it MUST NOT be used\n   within subTemplateList and subTemplateMultiList\
    \ anymore.  Before\n   reusing a Template ID, the Template MUST be deleted.  In\
    \ order to\n   delete an allocated Template, the Template is withdrawn through\
    \ the\n   use of a Template Withdrawal Message.\n"
- title: 7.  The Collecting Process's Side
  contents:
  - "7.  The Collecting Process's Side\n   This section introduces some more specific\
    \ specifications to the\n   Collection Process compared to Section 9 in the IPFIX\
    \ protocol\n   [RFC5101].\n   As opposed to the IPFIX specification in [RFC5101],\
    \ IPFIX Messages\n   with IPFIX Structured Data Information Elements change the\
    \ IPFIX\n   concept from the Collector's point of view as the data types are\n\
    \   present in the Data Records rather than in the Template Records.  For\n  \
    \ example, a basicList Information Element in a Template Record doesn't\n   specify\
    \ the list element data type; this information is contained in\n   the Data Record.\
    \  For example, in case of a subTemplateMultiList, the\n   Collecting Process\
    \ must refer to the included Template Records in the\n   middle of the Data Record\
    \ decode.\n   As described in [RFC5101], a Collecting Process MUST note the\n\
    \   Information Element identifier of any Information Element that it\n   does\
    \ not understand and MAY discard that Information Element from the\n   Flow Record.\
    \  Therefore, a Collection Process that does not support\n   the extension specified\
    \ in this document can ignore the Structured\n   Data Information Elements in\
    \ a Data Record, or it can ignore Data\n   Records containing these new Structured\
    \ Data Information Elements\n   while continuing to process other Data Records.\n\
    \   If the structured data contains the \"undefined\" structured data type\n \
    \  semantic, the Collecting Process MAY attempt to draw its own\n   conclusion\
    \ in terms of the semantic contained in the Data Record.\n"
- title: 8.  Defining New Information Elements Based on the New Abstract Data
  contents:
  - "8.  Defining New Information Elements Based on the New Abstract Data\n    Types\n\
    \   This document specifies three new abstract data types: basicList,\n   subTemplateList,\
    \ and subTemplateMultiList.  As specified in\n   [RFC5102], the specification\
    \ of new IPFIX Information Elements uses\n   the Template specified in Section\
    \ 2.1 of [RFC5102].  This Template\n   mentioned existing and future the data\
    \ types: \"One of the types\n   listed in Section 3.1 of this document or in a\
    \ future extension of\n   the information model\".  So new Information Elements\
    \ can be specified\n   based on the three new abstract data types.\n   The authors\
    \ anticipate the creation of both enterprise-specific and\n   IANA Information\
    \ Elements based on the IPFIX structured data types.\n   For example, bgpPathList,\
    \ bgpSequenceList, and bgpSetList, of\n   abstract types and semantics basicList/ordered,\
    \ basicList/ordered,\n   and basicList/exactlyOneOf respectively, would define\
    \ the complete\n   semantic of the list.  This specification doesn't specify any\
    \ new\n   Information Elements beyond the ones in Section 4.3.\n"
- title: 9.  Structured Data Encoding Examples
  contents:
  - "9.  Structured Data Encoding Examples\n   The following examples are created\
    \ solely for the purpose of\n   illustrating how the extensions proposed in this\
    \ document are\n   encoded.\n"
- title: 9.1.  Encoding a Multicast Data Record with basicList
  contents:
  - "9.1.  Encoding a Multicast Data Record with basicList\n   Consider encoding a\
    \ multicast Data Record containing the following\n   data:\n   ---------------------------------------------------------------\n\
    \    Ingress If | Source IP   | Destination IP  | Egress Interfaces\n   ---------------------------------------------------------------\n\
    \         9       192.0.2.201      233.252.0.1         1, 4, 8\n   ---------------------------------------------------------------\n\
    \   Template Record for the multicast Flows, with the Template ID 256:\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Set ID = 2            |      Length = 24 octets       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Template ID = 256       |       Field Count = 4         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|    ingressInterface = 10    |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   sourceIPv4Address = 8     |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| DestinationIPv4Address = 12 |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|       basicList = 291       |     Field Length = 0xFFFF     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 11: Encoding basicList, Template Record\n   The list of\
    \ outgoing interfaces is represented as a basicList with\n   semantic allOf, and\
    \ the Length of the list is chosen to be encoded in\n   three bytes even though\
    \ it may be less than 255 octets.\n   The Data Set is represented as follows:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 256         |          Length = 36          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     ingressInterface = 9                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               sourceIPv4Address = 192.0.2.201                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             DestinationIPv4Address = 233.252.0.1              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      255      |        List Length = 17       | semantic=allOf|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | egressInterface FieldId = 14  |egressInterface Field Length=4 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                egressInterface value 1 = 1                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                egressInterface value 2 = 4                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                egressInterface value 3 = 8                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Figure 12: Encoding basicList, Data Record, Semantic allOf\n   In the\
    \ example above, the basicList contains fixed-length elements.\n   To illustrate\
    \ how variable-length elements would be encoded, the same\n   example is shown\
    \ below with variable-length interface names in the\n   basicList instead:\n \
    \   0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 256         |          Length = 44          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     ingressInterface = 9                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               sourceIPv4Address = 192.0.2.201                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             DestinationIPv4Address = 233.252.0.1              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      255      |        List Length = 25       | semantic=allOf|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| InterfaceName FieldId = 82  | InterfaceName Field Len=0xFFFF|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Length = 5   |      'F'      |      'E'      |      '0'      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     '/'       |      '0'      |  Length = 7   |      'F'      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     'E'       |      '1'      |      '0'      |      '/'      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     '1'       |      '0'      |  Length = 5   |      'F'      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     'E'       |      '2'      |     '/'       |      '2'      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    Figure 13: Encoding basicList, Data Record with Variable-Length\n       \
    \                Elements, Semantic allOf\n"
- title: 9.2.  Encoding a Load-Balanced Data Record with a basicList
  contents:
  - "9.2.  Encoding a Load-Balanced Data Record with a basicList\n   Consider encoding\
    \ a load-balanced Data Record containing the\n   following data:\n   ---------------------------------------------------------------\n\
    \    Ingress If | Source IP   | Destination IP  | Egress Interfaces\n   ---------------------------------------------------------------\n\
    \         9       192.0.2.201      233.252.0.1         1, 4, 8\n   ---------------------------------------------------------------\n\
    \   So the Data Record egressed from either interface 1, 4, or 8.  The\n   Data\
    \ Set is represented as follows:\n    0                   1                  \
    \ 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 256         |          Length = 36          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     ingressInterface = 9                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               sourceIPv4Address = 192.0.2.201                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             DestinationIPv4Address = 233.252.0.1              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      255      |        List Length = 17       |sem=exactlyOne |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | egressInterface FieldId = 14  |egressInterface Field Length=4 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                egressInterface value 1 = 1                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                egressInterface value 2 = 4                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                egressInterface value 3 = 8                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Note: sem=exactlyOne represents semantic=exactlyOneOf\n     Figure 14:\
    \ Encoding basicList, Data Record, Semantic exactlyOneOf\n"
- title: 9.3.  Encoding subTemplateList
  contents:
  - "9.3.  Encoding subTemplateList\n   As explained in Section 2.2, multiple pairs\
    \ of\n   (observationTimeMicroseconds, digestHashValue) must be collected from\n\
    \   two different Observation Points to passively compute the one-way\n   delay\
    \ across the network.  This data can be exported with an\n   optimized Data Record\
    \ that consists of the following attributes:\n       5-tuple\n               \
    \  { observationTimeMicroseconds 1, digestHashValue 1 }\n                 { observationTimeMicroseconds\
    \ 2, digestHashValue 2 }\n                 { observationTimeMicroseconds 3, digestHashValue\
    \ 3 }\n                 { ...  , ... }\n   A subTemplateList is best suited for\
    \ exporting the list of\n   (observationTimeMicroseconds, digestHashValue).  For\
    \ illustration\n   purposes, the number of elements in the list is 5; in practice,\
    \ it\n   could be more.\n   ------------------------------------------------------------------\n\
    \   srcIP     | dstIP      | src   | dst  |proto| one-way delay\n            \
    \ |            | Port  | Port |     |   metrics\n   ------------------------------------------------------------------\n\
    \   192.0.2.1  192.0.2.105   1025     80     6    Time1, 0x0x91230613\n      \
    \                                           Time2, 0x0x91230650\n            \
    \                                     Time3, 0x0x91230725\n                  \
    \                               Time4, 0x0x91230844\n                        \
    \                         Time5, 0x0x91230978\n   ------------------------------------------------------------------\n\
    \   The following Template is defined for exporting the one-way delay\n   metrics:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Set ID = 2             |      Length = 16 octets       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Template ID = 257       |       Field Count = 2         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| observationTimeMicroSec=324 |       Field Length = 8        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   digestHashValue = 326     |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 15: Encoding subTemplateList, Template for One-Way Delay\n     \
    \                            Metrics\n   The Template Record for the Optimized\
    \ Data Record is as follows:\n    0                   1                   2  \
    \                 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Set ID = 2            |      Length = 32 octets       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Template ID = 258       |       Field Count = 6         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   sourceIPv4Address = 8     |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| destinationIPv4Address = 12 |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|  sourceTransportPort = 7    |       Field Length = 2        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| destinationTransportPort= 11|       Field Length = 2        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| protocolIdentifier = 4      |       Field Length = 1        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|  subTemplateList = 292      |     Field Length = 0xFFFF     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           Figure 16: Encoding subTemplateList, Template Record\n   The list\
    \ of (observationTimeMicroseconds, digestHashValue) is\n   exported as a subTemplateList\
    \ with semantic allOf.  The Length of the\n   subTemplateList is chosen to be\
    \ encoded in three bytes even though it\n   may be less than 255 octets.\n   The\
    \ Data Record is represented as follows:\n    0                   1          \
    \         2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Set ID = 258          |      Length = 83 octets       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                sourceIPv4Address = 192.0.2.1                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              destinationIPv4Address = 192.0.2.105             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | sourceTransportPort = 1025    | destinationTransportPort = 80 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Protocol = 6  |      255      | one-way metrics list len = 63 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | semantic=allOf|       TemplateID = 257        | TimeValue1    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 ... octets 2-5 of TimeValue1                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          ... octets 6-8 of TimeValue1         |digestHashVal1=|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                ... 0x0x91230613               | TimeValue2    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 ... octets 2-5 of TimeValue2                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          ... octets 6-8 of TimeValue2         |digestHashVal2=|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                ... 0x0x91230650               | TimeValue3    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 ... octets 2-5 of TimeValue3                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          ... octets 6-8 of TimeValue3         |digestHashVal3=|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                ... 0x0x91230725               | TimeValue4    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 ... octets 2-5 of TimeValue4                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          ... octets 6-8 of TimeValue4         |digestHashVal4=|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                ... 0x0x91230844               | TimeValue5    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 ... octets 2-5 of TimeValue5                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          ... octets 6-8 of TimeValue5         |digestHashVal5=|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                ... 0x0x91230978               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 17: Encoding subTemplateList, Data Set\n"
- title: 9.4.  Encoding subTemplateMultiList
  contents:
  - "9.4.  Encoding subTemplateMultiList\n   As explained in Section 4.5.3, a subTemplateMultiList\
    \ is used to\n   export a list of mixed-type content where each top-level element\n\
    \   corresponds to a different Template Record.\n   To illustrate this, consider\
    \ the Data Record with the following\n   attributes:\n        5-tuple (Flow Keys),\
    \ octetCount, packetCount\n                  attributes for filtering\n      \
    \                 selectorId,\n                       selectorAlgorithm\n    \
    \              attributes for sampling\n                       selectorId,\n \
    \                      selectorAlgorithm,\n                       samplingPacketInterval,\n\
    \                       samplingPacketSpace\n   This example demonstrates that\
    \ the Selector Report Interpretation\n   [RFC5476] can be encoded with the subTemplateMultiList.\
    \  More\n   specifically, the example describes Property Match Filtering Selector\n\
    \   Report Interpretation [RFC5476] used for filtering purposes, and the\n   Systemic\
    \ Count-Based Sampling as described in Section 6.5.2.1 of\n   [RFC5476].  Some\
    \ traffic will be filtered according to match\n   properties configured, some\
    \ will be sampled, some will be filtered\n   and sampled, and some will not be\
    \ filtered or sampled.\n   A subTemplateMultiList is best suited for exporting\
    \ this variable\n   data.  A Template is defined for filtering attributes and\
    \ another\n   Template is defined for sampling attributes.  A Data Record can\n\
    \   contain data corresponding to either of the Templates, both of them,\n   or\
    \ neither of them.\n   Consider the example below where the following Data Record\
    \ contains\n   both filtering and sampling attributes.\n   Key attributes of the\
    \ Data Record:\n   ------------------------------------------------------------------\n\
    \   srcIP      | dstIP     | src  | dst  | proto | octetCount | packet\n     \
    \         |           | Port | Port |       |            | Count\n   ------------------------------------------------------------------\n\
    \   2001:DB8::1 2001:DB8::2  1025    80      6       108000      120\n   ------------------------------------------------------------------\n\
    \   Filtering attributes:\n   -------------------------------------------\n  \
    \ selectorId  | selectorAlgorithm\n   -------------------------------------------\n\
    \      100         5 (Property Match Filtering)\n   -------------------------------------------\n\
    \   Sampling attributes:\n   For Systemic Count-Based Sampling as defined in Section\
    \ 6.5.2.1 of\n   [RFC5476] the required algorithm-specific Information Elements\
    \ are:\n         samplingPacketInterval: number of packets selected in a row\n\
    \         samplingPacketSpace:    number of packets between selections\n   Example\
    \ of a simple 1-out-of-100 systematic count-based Selector\n   definition, where\
    \ the samplingPacketInterval is 1 and the\n   samplingPacketSpace is 99.\n   --------------------------------------------------------------\n\
    \   selectorId | selectorAlgorithm        | sampling | sampling\n            \
    \  |                          | Packet   | Packet\n              |           \
    \               | Interval | Space\n   --------------------------------------------------------------\n\
    \      15        1 (Count-Based Sampling)      1         99\n   --------------------------------------------------------------\n\
    \   To represent the Data Record, the following Template Records are\n   defined:\n\
    \       Template for filtering attributes: 259\n        Template for sampling\
    \ attributes: 260\n        Template for Flow Record: 261\n        Flow record\
    \ (261)\n            |  (sourceIPv6Address)\n            |  (destinationIPv6Address)\n\
    \            |  (sourceTransportPort)\n            |  (destinationTransportPort)\n\
    \            |  (protocolIdentifier)\n            |  (octetTotalCount)\n     \
    \       |  (packetTotalCount)\n            |\n            +------ filtering attributes\
    \ (259)\n            |          (selectorId)\n            |          (selectorAlgorithm)\n\
    \            |\n            +------ sampling attributes (260)\n            | \
    \         (selectorId)\n            |          (selectorAlgorithm)\n         \
    \   |          (samplingPacketInterval)\n            |          (samplingPacketSpace)\n\
    \   The following Template Record is defined for filtering attributes:\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 2           |          Length = 16          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Template ID = 259        |        Field Count = 2        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|    selectorId = 302         |        Field Length = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| selectorAlgorithm = 304     |        Field Length = 1       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    Figure 18: Encoding subTemplateMultiList, Template for Filtering\n      \
    \                         Attributes\n   The Template for sampling attributes\
    \ is defined as follows:\n    0                   1                   2      \
    \             3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 2           |          Length = 24          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Template ID = 260        |        Field Count = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|    selectorId = 302         |        Field Length = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|  selectorAlgorithm = 304    |        Field Length = 1       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| samplingPacketInterval = 305|        Field Length = 1       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| samplingPacketSpace = 306   |        Field Length = 1       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 19: Encoding subTemplateMultiList, Template for Sampling\n      \
    \                         Attributes\n   Note that while selectorAlgorithm is\
    \ defined as unsigned16, and\n   samplingPacketInterval and samplingPacketSpace\
    \ are defined as\n   unsigned32, they are compressed down to 1 octet here as allowed\
    \ by\n   Reduced Size Encoding in Section 6.2 of the IPFIX protocol\n   specifications\
    \ [RFC5101].\n   Template for the Flow Record is defined as shown below:\n   \
    \ 0                   1                   2                   3\n    0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 2           |          Length = 40          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      Template ID = 261        |        Field Count = 8        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   sourceIPv6Address = 27    |       Field Length = 16       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| destinationIPv6Address = 28 |       Field Length = 16       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| sourceTransportPort = 7     |       Field Length = 2        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| destinationTransportPort=11 |       Field Length = 2        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| protocolIdentifier = 4      |       Field Length = 1        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   octetTotalCount = 85      |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   packetTotalCount = 86     |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0| subTemplateMultiList = 293  |     Field Length = 0XFFFF     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 20: Encoding subTemplateMultiList, Template for Flow Record\n   A subTemplateMultiList\
    \ with semantic allOf is used to export the\n   filtering and sampling attributes.\
    \  The Length field of the\n   subTemplateMultiList is chosen to be encoded in\
    \ three bytes even\n   though it may be less than 255 octets.\n   The Data Record\
    \ is encoded as follows:\n    0                   1                   2      \
    \             3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Set ID = 261            |          Length = 73          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      sourceIPv6Address =        ...           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          2001:DB8::1                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   destinationIPv6Address =      ...           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          2001:DB8::2                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  sourceTransportPort = 1025   | destinationTransportPort = 80 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | protocol = 6  |        octetTotalCount = 108000               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     ...       |        packetTotalCount = 120                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     ...       |      255      | Attributes List Length = 21   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |semantic=allOf | Filtering Template ID = 259   |Filtering Attr |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...Length = 9 |              selectorId = ...                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | ...  100      |selectorAlg = 5|  Sampling Template ID = 260   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Sampling Attributes Length=11 |         selectorId = ...      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  ...         15               |selectorAlg = 1|  Interval = 1 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Space = 99    |\n   +-+-+-+-+-+-+-+-+\n           Figure 21: Encoding subTemplateMultiList,\
    \ Data Set\n"
- title: 9.5.  Encoding an Options Template Set Using Structured Data
  contents:
  - "9.5.  Encoding an Options Template Set Using Structured Data\n   As described\
    \ in Section 5.3, consider a mediation function that must\n   aggregate Data Records\
    \ from different Observation Points.\n   Say Observation Point 1 consists of one\
    \ or more interfaces,\n   Observation Points 2 and 3 consist of one or more linecards,\
    \ and\n   Observation Point 4 consists of one or more interfaces and one or\n\
    \   more linecards.  Without structured data, a Template would have to be\n  \
    \ defined for every possible combination to interpret the data\n   corresponding\
    \ to each of the Observation Points.  However, with\n   structured data, a basicList\
    \ can be used to encode the list of\n   interfaces and another basicList can be\
    \ used to encode the list of\n   linecards.\n   For the sake of simplicity, each\
    \ Observation Point shown below has\n   the IP address corresponding to the Router\
    \ and an <interface> or\n   <linecard> or <linecard and interface>.  This can\
    \ very well be\n   extended to include a list of interfaces and a list of linecards\n\
    \   using basicLists as explained above.\n      Observation Point 1: Router 1,\
    \ (interface 1)\n      Observation Point 2: Router 2, (linecard A)\n      Observation\
    \ Point 3: Router 3, (linecard B)\n      Observation Point 4: Router 4, (linecard\
    \ C, interface 2)\n   The mediation function wishes to express this as a single\
    \ Observation\n   Point, in order to encode the PSAMP Selection Sequence Report\n\
    \   Interpretation (SSRI).  Recall from [RFC5476] that the PSAMP\n   Selection\
    \ Sequence Report Interpretation consists of the following\n   fields:\n     Scope:\
    \     selectionSequenceId\n     Non-Scope: one Information Element mapping the\n\
    \                Observation Point\n                selectorId (one or more)\n\
    \   For example, the Observation Point detailed above may be encoded in a\n  \
    \ PSAMP Selection Sequence Report Interpretation as shown below:\n    Selection\
    \ Sequence 7 (Filter->Sampling):\n     Observation Point: subTemplateMultiList.\n\
    \      Router 1 (IP address = 192.0.2.11), (interface 1)\n      Router 2 (IP address\
    \ = 192.0.2.12), (linecard A)\n      Router 3 (IP address = 192.0.2.13), (linecard\
    \ B)\n      Router 4 (IP address = 192.0.2.14), (linecard C, interface 2)\n  \
    \    selectorId: 5 (Filter, match IPv4SourceAddress 192.0.2.1)\n      selectorId:\
    \ 10 (Sampler, Random 1 out-of ten)\n   The following Templates are defined to\
    \ represent the PSAMP SSRI:\n   Template for representing PSAMP SSRI: 262\n  \
    \ Template for representing interface: 263\n   Template for representing linecard:\
    \ 264\n   Template for representing linecard and interface: 265\n       PSAMP\
    \ SSRI (262)\n           | (SelectionSequenceId)\n           |\n           +---\
    \ Observation Point 1 (263)\n           |      (exporterIPv4Address)\n       \
    \    |      (Interface Id)\n           |\n           +--- Observation Point 2\
    \ and 3 (264)\n           |      (exporterIPv4Address)\n           |      (linecard)\n\
    \           |\n           +--- Observation Point 4 (265)\n           |      (exporterIPv4Address)\n\
    \           |      (linecard)\n           |      (Interface Id)\n           |\n\
    \           | (selectorId 1)\n           | (selectorId 2)\n   Note that the example\
    \ could further be improved with a basicList\n   of selectorId if many Selector\
    \ IDs have to be reported.\n                    Figure 22: PSAMP SSRI to Be Encoded\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 3           |          Length = 26          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Template ID = 262      |         Field Count = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Scope Field Count =  1    |0|  selectionSequenceId = 301  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Scope 1 Length = 4      |0| subTemplateMultiList =  293 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Field Length = 0xFFFF     |0|      selectorId = 302       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Field Length = 4       |0|      selectorId = 302       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Field Length = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 23: Options Template Record for PSAMP SSRI Using\n          \
    \                subTemplateMultiList\n   A subTemplateMultiList with semantic\
    \ allOf is used to encode the\n   list of Observation Points.\n    0         \
    \          1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 2           |          Length = 16          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Template ID = 263      |         Field Count = 2       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   exporterIPv4Address = 8   |        Field Length = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   ingressInterface = 10     |        Field Length = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 24: PSAMP SSRI, Template Record for interface\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 2           |          Length = 16          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Template ID = 264      |         Field Count = 2       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   exporterIPv4Address = 8   |         Field Length = 4      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|      lineCardId = 141       |         Field Length = 4      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 25: PSAMP SSRI, Template Record for linecard\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 2           |          Length = 20          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Template ID = 265      |         Field Count = 3       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|   exporterIPv4Address = 8   |       Field Length = 4        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|      lineCardId = 141       |        Field Length = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|    ingressInterface = 10    |        Field Length = 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 26: PSAMP SSRI, Template Record for linecard and interface\n   The\
    \ PSAMP SSRI Data Set is represented as follows:\n    0                   1  \
    \                 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Set ID = 262         |           Length = 68         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    selectionSequenceId = 7                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      255      | Observation Point List Len=49 |semantic=allOf |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     OP1 Template ID = 263     |        OP1 Length = 12        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Router 1 exporterIPv4Address = 192.0.2.11             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  OP1 ingressInterface = 1                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   OP2&OP3 Template ID = 264   |    OP2 & OP3 Length = 20      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Router 2 exporterIPv4Address = 192.0.2.12             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      OP2 lineCardId = A                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Router 3 exporterIPv4Address = 192.0.2.13             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      OP3 lineCardId = B                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     OP4 Template ID = 265     |         OP4 Length = 16       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Router 4 exporterIPv4Address = 192.0.2.14             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      OP4 lineCardId = C                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   OP4 ingressInterface = 2                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         selectorId = 5                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         selectorId = 10                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 27: Example of a PSAMP SSRI Data Record, Encoded Using a\n        \
    \                 subTemplateMultiList\n   Note that the Data Record above contains\
    \ multiple instances of\n   Template 264 to represent Observation Point 2 (Router2,\
    \ linecard A)\n   and Observation Point 3 (Router3, linecard B).  Instead, if\
    \ a single\n   Observation Point had both linecard A and linecard B, a basicList\n\
    \   would be used to represent the list of linecards.\n"
- title: 10.  Relationship with the Other IPFIX Documents
  contents:
  - '10.  Relationship with the Other IPFIX Documents

    '
- title: 10.1.  Relationship with Reducing Redundancy
  contents:
  - "10.1.  Relationship with Reducing Redundancy\n   \"Reducing Redundancy in IP\
    \ Flow Information Export (IPFIX) and Packet\n   Sampling (PSAMP) Reports\" [RFC5473]\
    \ describes a bandwidth saving\n   method for exporting Flow or packet information\
    \ using the IP Flow\n   Information Export (IPFIX) protocol.\n   It defines the\
    \ commonPropertiesID Information Element for exporting\n   Common Properties.\n"
- title: 10.1.1.  Encoding Structured Data Element Using Common Properties
  contents:
  - "10.1.1.  Encoding Structured Data Element Using Common Properties\n   When Structured\
    \ Data Information Elements contain repeated elements,\n   these elements may\
    \ be replaced with a commonPropertiesID Information\n   Element as specified in\
    \ [RFC5473].  The replaced elements may include\n   the basicList, subTemplateList,\
    \ and subTemplateMultiList Information\n   Elements.\n   This technique might\
    \ help reducing the bandwidth requirements for the\n   export.  However, a detailed\
    \ analysis of the gain has not been done;\n   refer to Section 8.3 of [RFC5473]\
    \ for further considerations.\n"
- title: 10.1.2. Encoding Common Properties Elements with Structured Data
  contents:
  - "10.1.2. Encoding Common Properties Elements with Structured Data\n        Information\
    \ Element\n   Structured Data Information Element MAY be used to define a list\
    \ of\n   commonPropertiesID, as a replacement for the specifications in\n   [RFC5473].\n\
    \   Indeed, the example in Figures 1 and 2 of [RFC5473] can be encoded\n   with\
    \ the specifications in this document.\n   +----------------+-------------+---------------------------+\n\
    \   | sourceAddressA | sourcePortA |     <Flow1 information>   |\n   +----------------+-------------+---------------------------+\n\
    \   | sourceAddressA | sourcePortA |     <Flow2 information>   |\n   +----------------+-------------+---------------------------+\n\
    \   | sourceAddressA | sourcePortA |     <Flow3 information>   |\n   +----------------+-------------+---------------------------+\n\
    \   | sourceAddressA | sourcePortA |     <Flow4 information>   |\n   +----------------+-------------+---------------------------+\n\
    \   |      ...       |     ...     |            ...            |\n   +----------------+-------------+---------------------------+\n\
    \   Figure 28: Common and Specific Properties Exported Together\n            \
    \                  [RFC5473]\n   +------------------------+-----------------+-------------+\n\
    \   | index for properties A | sourceAddressA  | sourcePortA |\n   +------------------------+-----------------+-------------+\n\
    \   |          ...           |      ...        |     ...     |\n   +------------------------+-----------------+-------------+\n\
    \   +------------------------+---------------------------+\n   | index for properties\
    \ A |     <Flow1 information>   |\n   +------------------------+---------------------------+\n\
    \   | index for properties A |     <Flow2 information>   |\n   +------------------------+---------------------------+\n\
    \   | index for properties A |     <Flow3 information>   |\n   +------------------------+---------------------------+\n\
    \   | index for properties A |     <Flow4 information>   |\n   +------------------------+---------------------------+\n\
    \   Figure 29: Common and Specific Properties Exported Separately\n          \
    \           According to [RFC5473]\n   +----------------+-------------+---------------------------+\n\
    \   | sourceAddressA | sourcePortA |     <Flow1 information>   |\n   +----------------+-------------+---------------------------+\n\
    \                                  |     <Flow2 information>   |\n           \
    \                       +---------------------------+\n                      \
    \            |     <Flow3 information>   |\n                                 \
    \ +---------------------------+\n                                  |     <Flow4\
    \ information>   |\n                                  +---------------------------+\n\
    \                                  |            ...            |\n           \
    \                       +---------------------------+\n    Figure 30: Common and\
    \ Specific Properties Exported with\n                 Structured Data Information\
    \ Element\n   The example in Figure 28 could be encoded with a basicList if the\n\
    \   <Flow information> represents a single Information Element, with a\n   subTemplateList\
    \ if the <Flow information> represents a Template\n   Record, or with a subTemplateMultiList\
    \ if the <Flow information> is\n   composed of different Template Records.\n \
    \  Using Structured Data Information Elements as a replacement for the\n   techniques\
    \ specified in \"Reducing Redundancy in IP Flow Information\n   Export (IPFIX)\
    \ and Packet Sampling (PSAMP) Reports\" [RFC5473] offers\n   the advantage that\
    \ a single Template Record is defined.  Hence, the\n   Collector's job is simplified\
    \ in terms of Template management and\n   combining Template/Options Template\
    \ Records.\n   However, it must be noted that using Structured Data Information\n\
    \   Elements as a replacement for the techniques specified in \"Reducing\n   Redundancy\
    \ in IP Flow Information Export (IPFIX) and Packet Sampling\n   (PSAMP) Reports\"\
    \ only applies to simplified cases.  For example, the\n   \"Multiple Data Reduction\"\
    \ (Section 7.1 [RFC5473]) might be too\n   complex to encode with Structured Data\
    \ Information Elements.\n"
- title: 10.2.  Relationship with Guidelines for IPFIX Testing
  contents:
  - "10.2.  Relationship with Guidelines for IPFIX Testing\n   [RFC5471] presents\
    \ a list of tests for implementers of IP Flow\n   Information Export (IPFIX) compliant\
    \ Exporting Processes and\n   Collecting Processes.\n   Although [RFC5471] doesn't\
    \ define any structured data element\n   specific tests, the Structured Data Information\
    \ Elements can be used\n   in many of the [RFC5471] tests.\n   The [RFC5471] series\
    \ of test could be useful because the document\n   specifies that every Information\
    \ Element type should be tested.\n   However, not all cases from this document\
    \ are tested in [RFC5471].\n   The following sections are especially noteworthy:\n\
    \      3.2.1.  Transmission of Template with Fixed-Size Information\n        \
    \      Elements\n         - each data type should be used in at least one test.\
    \  The new\n           data types specified in Section 4.1 should be included\
    \ in\n           this test.\n      3.2.2.  Transmission of Template with Variable-Length\
    \ Information\n              Elements\n         - this test should be expanded\
    \ to include Data Records\n           containing variable length basicList, subTemplateList,\
    \ and\n           subTemplateMultiList Information Elements.\n      3.3.1.  Enterprise-Specific\
    \ Information Elements\n         - this test should include the export of basicList,\n\
    \           subTemplateList, and subTemplateMultiList Information\n          \
    \ Elements containing Enterprise-specific Information Elements,\n           e.g.,\
    \ see the example in Figure 2.\n      3.3.3.  Multiple Instances of the Same Information\
    \ Element in One\n              Template\n         - this test should verify that\
    \ multiple instances of the\n           basicList, subTemplateList, and subTemplateMultiList\n\
    \           Information Elements are accepted.\n      3.5.  Stress/Load Tests\n\
    \         - since the structured data types defined here allow modeling\n    \
    \       of complex data structures, they may be useful for stress\n          \
    \ testing both Exporting Processes and Collecting Processes.\n"
- title: 10.3.  Relationship with IPFIX Mediation Function
  contents:
  - "10.3.  Relationship with IPFIX Mediation Function\n   The Structured Data Information\
    \ Elements would be beneficial for the\n   export of aggregated Data Records in\
    \ mediation function, as was\n   demonstrated with the example of the aggregated\
    \ Observation Point in\n   Section 5.3.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This document specifies several new IPFIX abstract\
    \ data types, a new\n   IPFIX Data Type Semantic, and several new Information\
    \ Elements.\n   Two new IPFIX registries have been created, and the existing IPFIX\n\
    \   Information Element registry has been updated as detailed below.\n"
- title: 11.1.  New Abstract Data Types
  contents:
  - "11.1.  New Abstract Data Types\n   Section 4.1 of this document specifies several\
    \ new IPFIX abstract\n   data types.  Per Section 6 of the IPFIX information model\
    \ [RFC5102],\n   new abstract data types can be added to the IPFIX information\
    \ model\n   in the IPFIX Information Element Data Types registry.\n   Abstract\
    \ data types that have been added to the IPFIX Information\n   Element Data Types\
    \ registry are listed below.\n"
- title: 11.1.1.  basicList
  contents:
  - "11.1.1.  basicList\n   The type \"basicList\" represents a list of any Information\
    \ Element\n   used for single-valued data types.\n"
- title: 11.1.2.  subTemplateList
  contents:
  - "11.1.2.  subTemplateList\n   The type \"subTemplateList\" represents a list of\
    \ a structured data\n   type, where the data type of each list element is the\
    \ same and\n   corresponds with a single Template Record.\n"
- title: 11.1.3.  subTemplateMultiList
  contents:
  - "11.1.3.  subTemplateMultiList\n   The type \"subTemplateMultiList\" represents\
    \ a list of structured data\n   types, where the data types of the list elements\
    \ can be different and\n   correspond with different Template definitions.\n"
- title: 11.2.  New Data Type Semantics
  contents:
  - "11.2.  New Data Type Semantics\n   Section 4.2 of this document specifies a new\
    \ IPFIX Data Type\n   Semantic.  Per Section 3.2 of the IPFIX information model\
    \ [RFC5102],\n   new data type semantics can be added to the IPFIX information\
    \ model.\n   Therefore, the IANA IPFIX informationElementSemantics registry\n\
    \   [IANA-IPFIX], which contains all the data type semantics from Section\n  \
    \ 3.2 of [RFC5102], has been augmented with the \"list\" value below.\n"
- title: 11.2.1.  list
  contents:
  - "11.2.1.  list\n   A list is a structured data type, being composed of a sequence\
    \ of\n   elements, e.g., Information Element, Template Record.\n"
- title: 11.3.  New Information Elements
  contents:
  - "11.3.  New Information Elements\n   Section 4.3 of this document specifies several\
    \ new Information\n   Elements that have been created in the IPFIX Information\
    \ Element\n   registry [IANA-IPFIX].\n   New Information Elements that have been\
    \ added to the IPFIX\n   Information Element registry are listed below.\n"
- title: 11.3.1.  basicList
  contents:
  - "11.3.1.  basicList\n   Name: basicList\n   Description:\n   Specifies a generic\
    \ Information Element with a basicList abstract\n   data type.  Examples include\
    \ a list of port numbers, and a list of\n   interface indexes.\n   Abstract Data\
    \ Type: basicList\n   Data Type Semantics: list\n   ElementId: 291\n   Status:\
    \ current\n"
- title: 11.3.2. subTemplateList
  contents:
  - "11.3.2. subTemplateList\n   Name: subTemplateList\n   Description:\n   Specifies\
    \ a generic Information Element with a subTemplateList\n   abstract data type.\n\
    \   Abstract Data Type: subTemplateList\n   Data Type Semantics: list\n   ElementId:\
    \ 292\n   Status: current\n"
- title: 11.3.3. subTemplateMultiList
  contents:
  - "11.3.3. subTemplateMultiList\n   Name: subTemplateMultiList\n   Description:\n\
    \   Specifies a generic Information Element with a\n   subTemplateMultiList abstract\
    \ data type.\n   Abstract Data Type: subTemplateMultiList\n   Data Type Semantics:\
    \ list\n   ElementId: 293\n   Status: current\n"
- title: 11.4.  New Structured Data Semantics
  contents:
  - "11.4.  New Structured Data Semantics\n   Section 4.4 of this document specifies\
    \ a series of new IPFIX\n   structured data type semantics, which is expressed\
    \ as an 8-bit value.\n   This requires the creation of a new \"IPFIX Structured\
    \ Data Types\n   Semantics\" IPFIX subregistry [IANA-IPFIX].\n   Entries may be\
    \ added to this subregistry subject to a Standards\n   Action [RFC5226].  Initially,\
    \ this registry includes all the\n   structured data type semantics listed below.\n"
- title: 11.4.1.  undefined
  contents:
  - "11.4.1.  undefined\n   Name: undefined\n   Description: The \"undefined\" structured\
    \ data type semantic specifies\n   that the semantic of list elements is not specified\
    \ and that, if a\n   semantic exists, then it is up to the Collecting Process\
    \ to draw its\n   own conclusions.  The \"undefined\" structured data type semantic\
    \ is\n   the default structured data type semantic.\n   Value: 0xFF\n   Reference:\
    \ RFC 6313\n"
- title: 11.4.2.  noneOf
  contents:
  - "11.4.2.  noneOf\n   Name: noneOf\n   Description: The \"noneOf\" structured data\
    \ type semantic specifies\n   that none of the elements are actual properties\
    \ of the Data Record.\n   Value: 0x00\n   Reference: RFC 6313\n"
- title: 11.4.3.  exactlyOneOf
  contents:
  - "11.4.3.  exactlyOneOf\n   Name: exactlyOneOf\n   Description: The \"exactlyOneOf\"\
    \ structured data type semantic\n   specifies that only a single element from\
    \ the structured data is an\n   actual property of the Data Record.  This is equivalent\
    \ to a logical\n   XOR operation.\n   Value: 0x01\n   Reference: RFC 6313\n"
- title: 11.4.4.  oneOrMoreOf
  contents:
  - "11.4.4.  oneOrMoreOf\n   Name: oneOrMoreOf\n   Description: The \"oneOrMoreOf\"\
    \ structured data type semantic\n   specifies that one or more elements from the\
    \ list in the structured\n   data are actual properties of the Data Record.  This\
    \ is equivalent to\n   a logical OR operation.\n   Value: 0x02\n   Reference:\
    \ RFC 6313\n"
- title: 11.4.5.  allOf
  contents:
  - "11.4.5.  allOf\n   Name: allOf\n   Description: The \"allOf\" structured data\
    \ type semantic specifies that\n   all of the list elements from the structured\
    \ data are actual\n   properties of the Data Record.\n   Value: 0x03\n   Reference:\
    \ RFC 6313\n"
- title: 11.4.6.  ordered
  contents:
  - "11.4.6.  ordered\n   Name: ordered Description: The \"ordered\" structured data\
    \ type\n   semantic specifies that elements from the list in the structured data\n\
    \   are ordered.\n   Value: 0x04\n   Reference: RFC 6313\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   The addition of complex data types necessarily\
    \ complicates the\n   implementation of the Collector.  This could easily result\
    \ in new\n   security vulnerabilities (e.g., buffer overflows); this creates\n\
    \   additional risk in cases where either Datagram Transport Layer\n   Security\
    \ (DTLS) is not used or if the Observation Point and Collector\n   belong to different\
    \ trust domains.  Otherwise, the same security\n   considerations as for the IPFIX\
    \ protocol [RFC5101] and the IPFIX\n   information model [RFC5102] apply.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [RFC2119]    Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC5101]    Claise, B., Ed., \"Specification of the IP Flow\n\
    \                Information Export (IPFIX) Protocol for the Exchange of\n   \
    \             IP Traffic Flow Information\", RFC 5101, January 2008.\n   [RFC5102]\
    \    Quittek, J., Bryant, S., Claise, B., Aitken, P., and J.\n               \
    \ Meyer, \"Information Model for IP Flow Information\n                Export\"\
    , RFC 5102, January 2008.\n   [RFC5226]    Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n                IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 5226,\n                May 2008.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [RFC3917]    Quittek, J., Zseby, T., Claise,\
    \ B., and S. Zander,\n                \"Requirements for IP Flow Information Export\
    \ (IPFIX)\",\n                RFC 3917, October 2004.\n   [RFC5103]    Trammell,\
    \ B. and E. Boschi, \"Bidirectional Flow Export\n                Using IP Flow\
    \ Information Export (IPFIX)\", RFC 5103,\n                January 2008.\n   [RFC5470]\
    \    Sadasivan, G., Brownlee, N., Claise, B., and J. Quittek,\n              \
    \  \"Architecture for IP Flow Information Export\", RFC 5470,\n              \
    \  March 2009.\n   [RFC5471]    Schmoll, C., Aitken, P., and B. Claise, \"Guidelines\
    \ for\n                IP Flow Information Export (IPFIX) Testing\", RFC 5471,\n\
    \                March 2009.\n   [RFC5472]    Zseby, T., Boschi, E., Brownlee,\
    \ N., and B. Claise, \"IP\n                Flow Information Export (IPFIX) Applicability\"\
    , RFC\n                5472, March 2009.\n   [RFC5473]    Boschi, E., Mark, L.,\
    \ and B. Claise, \"Reducing\n                Redundancy in IP Flow Information\
    \ Export (IPFIX) and\n                Packet Sampling (PSAMP) Reports\", RFC 5473,\
    \ March 2009.\n   [RFC5475]    Zseby, T., Molina, M., Duffield, N., Niccolini,\
    \ S., and\n                F. Raspall, \"Sampling and Filtering Techniques for\
    \ IP\n                Packet Selection\", RFC 5475, March 2009.\n   [RFC5476]\
    \    Claise, B., Ed., Johnson, A., and J. Quittek, \"Packet\n                Sampling\
    \ (PSAMP) Protocol Specifications\", RFC 5476,\n                March 2009.\n\
    \   [RFC5477]    Dietz, T., Claise, B., Aitken, P., Dressler, F., and G.\n   \
    \             Carle, \"Information Model for Packet Sampling Exports\",\n    \
    \            RFC 5477, March 2009.\n   [IANA-IPFIX] IANA, \"IP Flow Information\
    \ Export (IPFIX) Entities\",\n                <http://www.iana.org/>.\n"
- title: 14.  Acknowledgements
  contents:
  - "14.  Acknowledgements\n   The authors would like to thank Zhipu Jin, Nagaraj\
    \ Varadharajan,\n   Brian Trammel, Atsushi Kobayashi, and Rahul Patel for their\
    \ feedback,\n   and Gerhard Muenz, for proofreading the document.\n"
- title: Appendix A.  Additions to XML Specification of IPFIX Information
  contents:
  - "Appendix A.  Additions to XML Specification of IPFIX Information\n          \
    \   Elements and Abstract Data Types\n   This appendix contains additions to the\
    \ machine-readable description\n   of the IPFIX information model coded in XML\
    \ in Appendices A and B in\n   [RFC5102].  Note that this appendix is of informational\
    \ nature, while\n   the text in Section 4 (generated from this appendix) is normative.\n\
    \   The following field definitions are appended to the IPFIX information\n  \
    \ model in Appendix A of [RFC5102].\n   <field name=\"basicList\"\n          \
    \ dataType=\"basicList\"\n           group=\"structured-data\"\n           dataTypeSemantics=\"\
    List\"\n           elementId=\"291\" applicability=\"all\" status=\"current\"\
    >\n      <description>\n        <paragraph>\n           Represents a list of zero\
    \ or more instances of\n           any Information Element, primarily used for\n\
    \           single-valued data types.  Examples include a list of port\n     \
    \      numbers, list of interface indexes, and a list of AS in a\n           BGP\
    \ AS-PATH.\n        </paragraph>\n      </description>\n    </field>\n    <field\
    \ name=\"subTemplateList\"\n           dataType=\"subTemplateList\"\n        \
    \   group=\"structured-data\"\n           dataTypeSemantics=\"List\"\n       \
    \    elementId=\"292\" applicability=\"all\" status=\"current\">\n      <description>\n\
    \        <paragraph>\n           Represents a list of zero or more instances of\
    \ a\n           structured data type, where the data type of each list\n     \
    \      element is the same and corresponds with a single\n           Template\
    \ Record.  Examples include a structured data type\n           composed of multiple\
    \ pairs of (\"MPLS label stack entry\n           position\", \"MPLS label stack\
    \ value\"), a structured data\n           type composed of performance metrics,\
    \ and a structured data\n           type composed of multiple pairs of IP address.\n\
    \        </paragraph>\n      </description>\n    </field>\n    <field name=\"\
    subTemplateMultiList\"\n           dataType=\"subTemplateMultiList\"\n       \
    \    group=\"structured-data\"\n           dataTypeSemantics=\"List\"\n      \
    \     elementId=\"293\" applicability=\"all\" status=\"current\">\n      <description>\n\
    \        <paragraph>\n          Represents a list of zero or more instances of\n\
    \          structured data types, where the data type of each list\n         \
    \ element can be different and corresponds with\n          different Template\
    \ definitions.  Examples include, a\n          structured data type composed of\
    \ multiple access-list\n          entries, where entries can be composed of different\n\
    \          criteria types.\n        </paragraph>\n      </description>\n    </field>\n\
    \   The following structured data type semantic definitions are appended\n   to\
    \ the IPFIX information model in Appendix A of [RFC5102].\n   <structuredDataTypeSemantics>\n\
    \     <structuredDataTypeSemantic name=\"undefined\" value=\"255\">\n       <description>\n\
    \         <paragraph>\n          The \"undefined\" structured data type semantic\
    \ specifies\n          that the semantic of list elements is not specified and\n\
    \          that, if a semantic exists, then it is up to the\n          Collecting\
    \ Process to draw its own conclusions.  The\n          \"undefined\" structured\
    \ data type semantic is the default\n          structured data type semantic.\n\
    \         </paragraph>\n       </description>\n     </structuredDataTypeSemantic>\n\
    \     <structuredDataTypeSemantic name=\"noneOf\" value=\"0\">\n       <description>\n\
    \         <paragraph>\n          The \"noneOf\" structured data type semantic\
    \ specifies\n          that none of the elements are actual properties of the\n\
    \          Data Record.\n         </paragraph>\n       </description>\n     </structuredDataTypeSemantic>\n\
    \     <structuredDataTypeSemantic name=\"exactlyOneOf\" value=\"1\">\n       <description>\n\
    \         <paragraph>\n          The \"exactlyOneOf\" structured data type semantic\n\
    \          specifies that only a single element from the structured\n        \
    \  data is an actual property of the Data Record.  This is\n          equivalent\
    \ to a logical XOR operation.\n         </paragraph>\n       </description>\n\
    \     </structuredDataTypeSemantic>\n     <structuredDataTypeSemantic name=\"\
    oneOrMoreOf\" value=\"2\">\n       <description>\n         <paragraph>\n     \
    \     The \"oneOrMoreOf\" structured data type semantic\n          specifies that\
    \ one or more elements from the list in the\n          structured data are actual\
    \ properties of the Data\n          Record.  This is equivalent to a logical OR\
    \ operation.\n         </paragraph>\n       </description>\n     </structuredDataTypeSemantic>\n\
    \     <structuredDataTypeSemantic name=\"allOf\" value=\"3\">\n       <description>\n\
    \         <paragraph>\n          The \"allOf\" structured data type semantic specifies\
    \ that\n          all of the list elements from the structured data are\n    \
    \      actual properties of the Data Record.\n         </paragraph>\n       </description>\n\
    \     </structuredDataTypeSemantic>\n     <structuredDataTypeSemantic name=\"\
    ordered\" value=\"4\">\n       <description>\n         <paragraph>\n         \
    \ The \"ordered\" structured data type semantic specifies\n          that elements\
    \ from the list in the structured data are\n          ordered.\n         </paragraph>\n\
    \       </description>\n     </structuredDataTypeSemantic>\n   </structuredDataTypeSemantics>\n\
    \   The following schema definitions are appended to the abstract data\n   types\
    \ defined in Appendix B of [RFC5102].  This schema and its\n   namespace are registered\
    \ by IANA at\n   http://www.iana.org/assignments/xml-registry/schema/ipfix.xsd.\n\
    \ <simpleType name=\"dataType\">\n   <restriction base=\"string\">\n     <enumeration\
    \ value=\"basicList\">\n       <annotation>\n         <documentation>\n      \
    \     Represents a list of zero or more instances of\n           any Information\
    \ Element, primarily used for\n           single-valued data types.  Examples\
    \ include a list of port\n           numbers, a list of interface indexes, and\
    \ a list of AS in a\n           BGP AS-PATH.\n         </documentation>\n    \
    \   </annotation>\n     </enumeration>\n     <enumeration value=\"subTemplateList\"\
    >\n       <annotation>\n         <documentation>\n           Represents a list\
    \ of zero or more instances of a\n           structured data type, where the data\
    \ type of each list\n           element is the same and corresponds with a single\n\
    \           Template Record.  Examples include a structured data type\n      \
    \     composed of multiple pairs of (\"MPLS label stack entry\n           position\"\
    , \"MPLS label stack value\"), a structured\n           data type composed of\
    \ performance metrics, and a\n           structured data type composed of multiple\
    \ pairs of IP\n           address.\n         </documentation>\n       </annotation>\n\
    \     </enumeration>\n     <enumeration value=\"subTemplateMultiList\">\n    \
    \   <annotation>\n         <documentation>\n           Represents a list of zero\
    \ or more instances of\n           structured data types, where the data type\
    \ of each\n           list element can be different and corresponds with\n   \
    \        different Template definitions.  An example is a\n           structured\
    \ data type composed of multiple\n           access-list entries, where entries\
    \ can be\n           composed of different criteria types.\n         </documentation>\n\
    \       </annotation>\n     </enumeration>\n   </restriction>\n </simpleType>\n\
    \ <simpleType name=\"dataTypeSemantics\">\n   <restriction base=\"string\">\n\
    \     <enumeration value=\"List\">\n       <annotation>\n         <documentation>\n\
    \           Represents an arbitrary-length sequence of structured\n          \
    \ data elements, either composed of regular Information\n           Elements or\
    \ composed of data conforming to a Template\n           Record.\n         </documentation>\n\
    \       </annotation>\n     </enumeration>\n   </restriction>\n </simpleType>\n\
    \ <complexType name=\"structuredDataTypeSemantics\">\n   <sequence>\n     <element\
    \ name=\"structuredDataTypeSemantic\"\n              minOccurs=\"1\" maxOccurs=\"\
    unbounded\">\n       <complexType>\n         <sequence>\n           <element name=\"\
    description\" type=\"text\"/>\n         </sequence>\n         <attribute name=\"\
    name\" type=\"string\" use=\"required\"/>\n         <attribute name=\"value\"\
    \ type=\"unsignedByte\" use=\"required\"/>\n       </complexType>\n     </element>\n\
    \   </sequence>\n </complexType>\n <element name=\"structuredDataTypeSemantics\"\
    \n          type=\"structuredDataTypeSemantics\">\n   <annotation>\n     <documentation>\n\
    \       Structured data type semantics express the relationship\n       among\
    \ multiple list elements in a structured data\n       Information Element.\n \
    \    </documentation>\n   </annotation>\n </element>\n"
- title: Appendix B.  Encoding IPS Alert Using Structured Data Information
  contents:
  - "Appendix B.  Encoding IPS Alert Using Structured Data Information\n         \
    \    Elements\n   In this section, an IPS alert example is used to demonstrate\
    \ how\n   complex data and multiple levels of hierarchy can be encoded using\n\
    \   Structured Data Information Elements.  Also, this example\n   demonstrates\
    \ how a basicList of subTemplateLists can be used to\n   represent semantics at\
    \ multiple levels in the hierarchy.\n   An IPS alert consists of the following\
    \ mandatory attributes:\n   signatureId, protocolIdentifier, and riskRating. \
    \ It can also contain\n   zero or more participants, and each participant can\
    \ contain zero or\n   more attackers and zero or more targets.  An attacker contains\
    \ the\n   attributes sourceIPv4Address and applicationId, and a target contains\n\
    \   the attributes destinationIPv4Address and applicationId.\n   Note that the\
    \ signatureId and riskRating Information Element fields\n   are created for these\
    \ examples only; the Field IDs are shown as N/A.\n   The signatureId helps to\
    \ uniquely identify the IPS signature that\n   triggered the alert.  The riskRating\
    \ identifies the potential risk,\n   on a scale of 0-100 (100 being most serious),\
    \ of the traffic that\n   triggered the alert.\n   Consider the example described\
    \ in case study 2 of Section 5.6. The\n   IPS alert contains participants encoded\
    \ as a subTemplateList with\n   semantic allOf.  Each participant uses a basicList\
    \ of\n   subTemplateLists to represent attackers and targets.  For the sake of\n\
    \   simplicity, the alert has two participants P1 and P2.  In participant\n  \
    \ P1, attacker A1 or A2 attacks target T1.  In participant P2, attacker\n   A3\
    \ attacks targets T2 and T3.\n   Participant P1:\n        (basicList, allOf,\n\
    \              (subTemplateList, exactlyOneOf, attacker A1, A2)\n            \
    \  (subTemplateList, undefined, target T1)\n        )\n   Participant P2:\n  \
    \      (basicList, allOf,\n              (subTemplateList, undefined, attacker\
    \ A3,\n              (subTemplateList, allOf, targets T2, T3)\n        )\n   Alert\
    \ :\n           (subTemplateList, allOf, Participant P1, Participant P2)\n   \
    \ ------------------------------------------------------------------\n       \
    \   |        |        |             participant\n    sigId |protocol| risk   |\
    \      attacker   |      target\n          |   Id   | Rating |    IP   | appId\
    \ |    IP      | appId\n    ------------------------------------------------------------------\n\
    \    1003     17      10      192.0.2.3  103    192.0.2.103    3001\n        \
    \                     192.0.2.4  104\n                             192.0.2.5 \
    \ 105    192.0.2.104    4001\n                                               192.0.2.105\
    \    5001\n    ------------------------------------------------------------------\n\
    \    Participant P1 contains:\n    Attacker A1: (IP, appId)=(192.0.2.3, 103)\n\
    \    Attacker A2: (IP, appId)=(192.0.2.4, 104)\n    Target T1: (IP, appId)= (192.0.2.103,\
    \ 3001)\n    Participant P2 contains:\n    Attacker A3: (IP, appId) = (192.0.2.5,\
    \ 105)\n    Target T2: (IP, appId)= (192.0.2.104, 4001)\n    Target T3: (IP, appId)=\
    \ (192.0.2.105, 5001)\n    To represent an alert, the following Templates are\
    \ defined:\n    Template for target (268)\n    Template for attacker (269)\n \
    \   Template for participant (270)\n    Template for alert (271)\n         alert\
    \ (271)\n         |  (signatureId)\n         |  (protocolIdentifier)\n       \
    \  |  (riskRating)\n         |\n         +------- participant (270)\n        \
    \          |\n                  +------- attacker (269)\n                  | \
    \          (sourceIPv4Address)\n                  |           (applicationId)\n\
    \                  |\n                  +------- target (268)\n              \
    \             |  (destinationIPv4Address)\n                           |  (applicationId)\n\
    \   Note that the attackers are always composed of a single\n   applicationId,\
    \ while the targets typically have multiple\n   applicationIds; for the sake of\
    \ simplicity, this example shows only\n   one applicationId in the target.\n \
    \  Template Record for target, with the Template ID 268:\n    0              \
    \     1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        Set ID = 2             |      Length = 16 octets       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |       Template ID = 268       |       Field Count = 2         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0| destinationIPv4Address = 12 |       Field Length = 4        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|       applicationId = 95    |       Field Length = 4        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             Figure 31: Encoding IPS Alert, Template for Target\n    Template\
    \ Record for attacker, with the Template ID 269:\n     0                   1 \
    \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |         Set ID = 2            |      Length = 16 octets       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |       Template ID = 269       |       Field Count = 2         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|    sourceIPv4Address = 8    |       Field Length = 4        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|     applicationId = 95      |       Field Length = 4        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 32: Encoding IPS Alert, Template for Attacker\n    Template\
    \ Record for participant, with the Template ID 270:\n     0                  \
    \ 1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |         Set ID = 2            |      Length = 12 octets       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |       Template ID = 270       |       Field Count = 1         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|       basicList = 291       |     Field Length = 0xFFFF     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 33: Encoding IPS Alert, Template for Participant\n   The Template\
    \ Record for the participant has one basicList Information\n   Element, which\
    \ is a list of subTemplateLists of attackers and\n   targets.\n   Template Record\
    \ for IPS alert, with the Template ID 271:\n     0                   1       \
    \            2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |         Set ID = 2            |      Length = 24 octets       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |       Template ID = 271       |       Field Count = 4         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|    signatureId = N/A        |       Field Length = 2        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|   protocolIdentifier = 4    |       Field Length = 1        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|     riskRating = N/A        |       Field Length = 1        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|     subTemplateList = 292   |     Field Length = 0xFFFF     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           Figure 34: Encoding IPS Alert, Template for IPS Alert\n   The subTemplateList\
    \ in the alert Template Record contains a list of\n   participants.\n   The Length\
    \ of basicList and subTemplateList are encoded in three\n   bytes even though\
    \ they may be less than 255 octets.\n   The Data Set is represented as follows:\n\
    \     0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          Set ID = 271         |         Length = 102          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      signatureId = 1003       | protocolId=17 | riskRating=10 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      255      |participant List Length  = 91  |semantic=allOf |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | participant Template ID = 270 |     255       | P1 List Len = |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      41       | semantic=allOf|    P1 List Field ID = 292     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | P1 List Field ID Len = 0xFFFF |      255      |P1 attacker ...|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | List Len = 19 |sem=exactlyOne | P1 attacker Template ID = 269 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          P1 attacker A1 sourceIPv4Address = 192.0.2.3         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |               P1 attacker A1 applicationId = 103              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          P1 attacker A2 sourceIPv4Address = 192.0.2.4         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |               P1 attacker A2 applicationId = 104              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      255      | P1 target List Len = 11       | sem=undefined |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  P1 target Template ID = 268  | P1 target T1 destinationIPv4  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | ... Address = 192.0.2.103     |P1 target T1 applicationId =...|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | ...       3001                |      255      | P2 List Len = |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | ...  41       | semantic=allOf|    P2 List Field ID = 292     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | P2 List Field ID Len = 0xFFFF |      255      |P2 attacker ...|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | List Len = 11 | sem=undefined | P2 attacker Template ID = 269 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          P2 attacker A3 sourceIPv4Address = 192.0.2.5         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |               P2 attacker A3 applicationId = 105              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      255      |    P2 target List Len = 19    |semantic=allOf |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  P2 target Template ID = 268  | P2 target T2 destinationIPv4  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | ... Address = 192.0.2.104     |P2 target T2 applicationId =...|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | ...       4001                | P2 target T3 destinationIPv4  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | ... Address = 192.0.2.105     |P2 target T3 applicationId =...|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | ...       5001                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Note: sem=exactlyOne represents semantic=exactlyOneOf\n           \
    \       Figure 35: Encoding IPS Alert, Data Set\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Benoit Claise\n   Cisco Systems, Inc.\n   De Kleetlaan\
    \ 6a b1\n   Diegem 1813\n   Belgium\n   Phone: +32 2 704 5622\n   EMail: bclaise@cisco.com\n\
    \   Gowri Dhandapani\n   Cisco Systems, Inc.\n   13615 Dulles Technology Drive\n\
    \   Herndon, Virginia 20171\n   United States\n   Phone: +1 408 853 0480\n   EMail:\
    \ gowri@cisco.com\n   Paul Aitken\n   Cisco Systems, Inc.\n   96 Commercial Quay\n\
    \   Commercial Street\n   Edinburgh, EH6 6LX\n   United Kingdom\n   Phone: +44\
    \ 131 561 3616\n   EMail: paitken@cisco.com\n   Stan Yates\n   Cisco Systems,\
    \ Inc.\n   7100-8 Kit Creek Road\n   PO Box 14987\n   Research Triangle Park,\
    \ North Carolina 27709-4987\n   United States\n   Phone: +1 919 392 8044\n   EMail:\
    \ syates@cisco.com\n"
