- title: __initial_text__
  contents:
  - '                      Network Service Header (NSH)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a Network Service Header (NSH) imposed on\n\
    \   packets or frames to realize Service Function Paths (SFPs).  The NSH\n   also\
    \ provides a mechanism for metadata exchange along the\n   instantiated service\
    \ paths.  The NSH is the Service Function Chaining\n   (SFC) encapsulation required\
    \ to support the SFC architecture (defined\n   in RFC 7665).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8300.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Applicability ..............................................4\n  \
    \    1.2. Requirements Language ......................................4\n    \
    \  1.3. Definition of Terms ........................................4\n      1.4.\
    \ Problem Space ..............................................6\n      1.5. NSH-Based\
    \ Service Chaining .................................6\n   2. Network Service Header\
    \ ..........................................7\n      2.1. Network Service Header\
    \ Format ..............................7\n      2.2. NSH Base Header ............................................8\n\
    \      2.3. Service Path Header .......................................11\n  \
    \    2.4. NSH MD Type 1 .............................................12\n    \
    \  2.5. NSH MD Type 2 .............................................13\n      \
    \     2.5.1. Optional Variable-Length Metadata ..................13\n   3. NSH\
    \ Actions ....................................................15\n   4. NSH Transport\
    \ Encapsulation ....................................16\n   5. Fragmentation Considerations\
    \ ...................................17\n   6. Service Path Forwarding with NSH\
    \ ...............................18\n      6.1. SFFs and Overlay Selection ................................18\n\
    \      6.2. Mapping the NSH to Network Topology .......................21\n  \
    \    6.3. Service Plane Visibility ..................................21\n    \
    \  6.4. Service Graphs ............................................22\n   7. Policy\
    \ Enforcement with NSH ....................................22\n      7.1. NSH\
    \ Metadata and Policy Enforcement .......................22\n      7.2. Updating/Augmenting\
    \ Metadata ..............................24\n      7.3. Service Path Identifier\
    \ and Metadata ......................25\n   8. Security Considerations ........................................26\n\
    \      8.1. NSH Security Considerations from Operators' Environments ..27\n  \
    \    8.2. NSH Security Considerations from the SFC Architecture .....28\n    \
    \       8.2.1. Integrity ..........................................29\n      \
    \     8.2.2. Confidentiality ....................................31\n   9. IANA\
    \ Considerations ............................................32\n      9.1. NSH\
    \ Parameters ............................................32\n           9.1.1.\
    \ NSH Base Header Bits ...............................32\n           9.1.2. NSH\
    \ Version ........................................32\n           9.1.3. NSH MD\
    \ Types .......................................33\n           9.1.4. NSH MD Class\
    \ .......................................33\n           9.1.5. NSH IETF-Assigned\
    \ Optional Variable-Length\n                  Metadata Types .....................................34\n\
    \           9.1.6. NSH Next Protocol ..................................35\n  \
    \ 10. NSH-Related Codepoints ........................................35\n    \
    \  10.1. NSH Ethertype ............................................35\n   11.\
    \ References ....................................................36\n   Acknowledgments\
    \ ...................................................38\n   Contributors ......................................................39\n\
    \   Authors' Addresses ................................................40\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Service Functions are widely deployed and essential in many\
    \ networks.\n   These Service Functions provide a range of features such as security,\n\
    \   WAN acceleration, and server load balancing.  Service Functions may\n   be\
    \ instantiated at different points in the network infrastructure\n   such as the\
    \ WAN, data center, and so forth.\n   Prior to development of the SFC architecture\
    \ [RFC7665] and the\n   protocol specified in this document, current Service Function\n\
    \   deployment models have been relatively static and bound to topology\n   for\
    \ insertion and policy selection.  Furthermore, they do not adapt\n   well to\
    \ elastic service environments enabled by virtualization.\n   New data-center\
    \ network and cloud architectures require more flexible\n   Service Function deployment\
    \ models.  Additionally, the transition to\n   virtual platforms demands an agile\
    \ service insertion model that\n   supports dynamic and elastic service delivery.\
    \  Specifically, the\n   following functions are necessary:\n   1.  The movement\
    \ of Service Functions and application workloads in\n       the network.\n   2.\
    \  The ability to easily bind service policy to granular\n       information,\
    \ such as per-subscriber state.\n   3.  The capability to steer traffic to the\
    \ requisite Service\n       Function(s).\n   This document, the Network Service\
    \ Header (NSH) specification,\n   defines a new data-plane protocol, which is\
    \ an encapsulation for\n   SFCs.  The NSH is designed to encapsulate an original\
    \ packet or frame\n   and, in turn, be encapsulated by an outer transport encapsulation\n\
    \   (which is used to deliver the NSH to NSH-aware network elements), as\n   shown\
    \ in Figure 1:\n                     +------------------------------+\n      \
    \               |    Transport Encapsulation   |\n                     +------------------------------+\n\
    \                     | Network Service Header (NSH) |\n                     +------------------------------+\n\
    \                     |    Original Packet / Frame   |\n                     +------------------------------+\n\
    \              Figure 1: Network Service Header Encapsulation\n   The NSH is composed\
    \ of the following elements:\n   1.  Service Function Path identification.\n \
    \  2.  Indication of location within a Service Function Path.\n   3.  Optional,\
    \ per-packet metadata (fixed-length or variable).\n   [RFC7665] provides an overview\
    \ of a service chaining architecture\n   that clearly defines the roles of the\
    \ various elements and the scope\n   of a SFC encapsulation.  Figure 3 of [RFC7665]\
    \ depicts the SFC\n   architectural components after classification.  The NSH\
    \ is the SFC\n   encapsulation referenced in [RFC7665].\n"
- title: 1.1.  Applicability
  contents:
  - "1.1.  Applicability\n   The NSH is designed to be easy to implement across a\
    \ range of\n   devices, both physical and virtual, including hardware platforms.\n\
    \   The intended scope of the NSH is for use within a single provider's\n   operational\
    \ domain.  This deployment scope is deliberately\n   constrained, as explained\
    \ also in [RFC7665], and limited to a single\n   network administrative domain.\
    \  In this context, a \"domain\" is a set\n   of network entities within a single\
    \ administration.  For example, a\n   network administrative domain can include\
    \ a single data center, or an\n   overlay domain using virtual connections and\
    \ tunnels.  A corollary is\n   that a network administrative domain has a well-defined\
    \ perimeter.\n   An NSH-aware control plane is outside the scope of this document.\n"
- title: 1.2.  Requirements Language
  contents:
  - "1.2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 1.3.  Definition of Terms
  contents:
  - "1.3.  Definition of Terms\n   Byte:  All references to \"bytes\" in this document\
    \ refer to 8-bit\n      bytes, or octets.\n   Classification:  Defined in [RFC7665].\n\
    \   Classifier:  Defined in [RFC7665].\n   Metadata (MD):  Defined in [RFC7665].\
    \  The metadata, or context\n      information shared between Classifiers and\
    \ SFs, and among SFs, is\n      carried on the NSH's Context Headers.  It allows\
    \ summarizing a\n      classification result in the packet itself, avoiding subsequent\n\
    \      re-classifications.  Examples of metadata include classification\n    \
    \  information used for policy enforcement and network context for\n      forwarding\
    \ after service delivery.\n   Network Locator:  Data-plane address, typically\
    \ IPv4 or IPv6, used to\n      send and receive network traffic.\n   Network Node/Element:\
    \  Device that forwards packets or frames based\n      on an outer header (i.e.,\
    \ transport encapsulation) information.\n   Network Overlay:  Logical network\
    \ built on top of an existing network\n      (the underlay).  Packets are encapsulated\
    \ or tunneled to create\n      the overlay network topology.\n   NSH-aware:  NSH-aware\
    \ means SFC-encapsulation-aware, where the NSH\n      provides the SFC encapsulation.\
    \  This specification uses NSH-aware\n      as a more specific term from the more\
    \ generic term \"SFC-aware\"\n      [RFC7665].\n   Service Classifier:  Logical\
    \ entity providing classification\n      function.  Since they are logical, Classifiers\
    \ may be co-resident\n      with SFC elements such as SFs or SFFs.  Service Classifiers\n\
    \      perform classification and impose the NSH.  The initial Classifier\n  \
    \    imposes the initial NSH and sends the NSH packet to the first SFF\n     \
    \ in the path.  Non-initial (i.e., subsequent) classification can\n      occur\
    \ as needed and can alter, or create a new service path.\n   Service Function\
    \ (SF):  Defined in [RFC7665].\n   Service Function Chain (SFC):  Defined in [RFC7665].\n\
    \   Service Function Forwarder (SFF):  Defined in [RFC7665].\n   Service Function\
    \ Path (SFP):  Defined in [RFC7665].\n   Service Plane:  The collection of SFFs\
    \ and associated SFs creates a\n      service-plane overlay in which all SFs and\
    \ SFC Proxies reside\n      [RFC7665].\n   SFC Proxy:  Defined in [RFC7665].\n"
- title: 1.4.  Problem Space
  contents:
  - "1.4.  Problem Space\n   The NSH addresses several limitations associated with\
    \ Service\n   Function deployments.  [RFC7498] provides a comprehensive review\
    \ of\n   those issues.\n"
- title: 1.5.  NSH-Based Service Chaining
  contents:
  - "1.5.  NSH-Based Service Chaining\n   The NSH creates a dedicated service plane;\
    \ more specifically, the NSH\n   enables:\n   1.  Topological Independence: Service\
    \ forwarding occurs within the\n       service plane, so the underlying network\
    \ topology does not\n       require modification.  The NSH provides an identifier\
    \ used to\n       select the network overlay for network forwarding.\n   2.  Service\
    \ Chaining: The NSH enables service chaining per [RFC7665].\n       The NSH contains\
    \ path identification information needed to\n       realize a service path.  Furthermore,\
    \ the NSH provides the\n       ability to monitor and troubleshoot a service chain,\
    \ end-to-end\n       via service-specific Operations, Administration, and Maintenance\n\
    \       (OAM) messages.  The NSH fields can be used by administrators\n      \
    \ (for example, via a traffic analyzer) to verify the path\n       specifics (e.g.,\
    \ accounting, ensuring correct chaining, providing\n       reports, etc.) of packets\
    \ being forwarded along a service path.\n   3.  The NSH provides a mechanism to\
    \ carry shared metadata between\n       participating entities and Service Functions.\
    \  The semantics of\n       the shared metadata are communicated via a control\
    \ plane (which\n       is outside the scope of this document) to participating\
    \ nodes.\n       Section 3.3 of [SFC-CONTROL-PLANE] provides an example of this.\n\
    \       Examples of metadata include classification information used for\n   \
    \    policy enforcement and network context for forwarding post\n       service\
    \ delivery.  Sharing the metadata allows Service Functions\n       to share initial\
    \ and intermediate classification results with\n       downstream Service Functions\
    \ saving re-classification, where\n       enough information was enclosed.\n \
    \  4.  The NSH offers a common and standards-based header for service\n      \
    \ chaining to all network and service nodes.\n   5.  Transport Encapsulation Agnostic:\
    \ The NSH is transport\n       encapsulation independent: meaning it can be transported\
    \ by a\n       variety of encapsulation protocols.  An appropriate (for a given\n\
    \       deployment) encapsulation protocol can be used to carry NSH-\n       encapsulated\
    \ traffic.  This transport encapsulation may form an\n       overlay network;\
    \ and if an existing overlay topology provides the\n       required service path\
    \ connectivity, that existing overlay may be\n       used.\n"
- title: 2.  Network Service Header
  contents:
  - "2.  Network Service Header\n   An NSH is imposed on the original packet/frame.\
    \  This NSH contains\n   service path information and, optionally, metadata that\
    \ are added to\n   a packet or frame and used to create a service plane.  Subsequently,\n\
    \   an outer transport encapsulation is imposed on the NSH, which is used\n  \
    \ for network forwarding.\n   A Service Classifier adds the NSH.  The NSH is removed\
    \ by the last\n   SFF in the service chain or by an SF that consumes the packet.\n"
- title: 2.1.  Network Service Header Format
  contents:
  - "2.1.  Network Service Header Format\n   The NSH is composed of a 4-byte Base\
    \ Header, a 4-byte Service Path\n   Header, and optional Context Headers, as shown\
    \ in Figure 2.\n      0                   1                   2              \
    \     3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |                Base Header                                    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                Service Path Header                            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     ~      \
    \          Context Header(s)                              ~\n     |          \
    \                                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 2: Network Service Header\n   Base Header:  Provides\
    \ information about the service header and the\n      payload protocol.\n   Service\
    \ Path Header:  Provides path identification and location\n      within a service\
    \ path.\n   Context Header:  Carries metadata (i.e., context data) along a\n \
    \     service path.\n"
- title: 2.2.  NSH Base Header
  contents:
  - "2.2.  NSH Base Header\n   Figure 3 depicts the NSH Base Header:\n      0    \
    \               1                   2                   3\n      0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                 Figure 3: NSH Base Header\n   The field descriptions are as\
    \ follows:\n   Version:  The Version field is used to ensure backward compatibility\n\
    \      going forward with future NSH specification updates.  It MUST be\n    \
    \  set to 0x0 by the sender, in this first revision of the NSH.  If a\n      packet\
    \ presumed to carry an NSH header is received at an SFF, and\n      the SFF does\
    \ not understand the version of the protocol as\n      indicated in the base header,\
    \ the packet MUST be discarded, and\n      the event SHOULD be logged.  Given\
    \ the widespread implementation\n      of existing hardware that uses the first\
    \ nibble after an MPLS\n      label stack for Equal-Cost Multipath (ECMP) decision\
    \ processing,\n      this document reserves version 01b.  This value MUST NOT\
    \ be used\n      in future versions of the protocol.  Please see [RFC7325] for\n\
    \      further discussion of MPLS-related forwarding requirements.\n   O bit:\
    \  Setting this bit indicates an OAM packet (see [RFC6291]).\n      The actual\
    \ format and processing of SFC OAM packets is outside the\n      scope of this\
    \ specification (for example, see [SFC-OAM-FRAMEWORK]\n      for one approach).\n\
    \      The O bit MUST be set for OAM packets and MUST NOT be set for\n      non-OAM\
    \ packets.  The O bit MUST NOT be modified along the SFP.\n      SF/SFF/SFC Proxy/Classifier\
    \ implementations that do not support\n      SFC OAM procedures SHOULD discard\
    \ packets with O bit set, but MAY\n      support a configurable parameter to enable\
    \ forwarding received SFC\n      OAM packets unmodified to the next element in\
    \ the chain.\n      Forwarding OAM packets unmodified by SFC elements that do\
    \ not\n      support SFC OAM procedures may be acceptable for a subset of OAM\n\
    \      functions, but it can result in unexpected outcomes for others;\n     \
    \ thus, it is recommended to analyze the impact of forwarding an OAM\n      packet\
    \ for all OAM functions prior to enabling this behavior.  The\n      configurable\
    \ parameter MUST be disabled by default.\n   TTL:  Indicates the maximum SFF hops\
    \ for an SFP.  This field is used\n      for service-plane loop detection.  The\
    \ initial TTL value SHOULD be\n      configurable via the control plane; the configured\
    \ initial value\n      can be specific to one or more SFPs.  If no initial value\
    \ is\n      explicitly provided, the default initial TTL value of 63 MUST be\n\
    \      used.  Each SFF involved in forwarding an NSH packet MUST\n      decrement\
    \ the TTL value by 1 prior to NSH forwarding lookup.\n      Decrementing by 1\
    \ from an incoming value of 0 shall result in a\n      TTL value of 63.  The packet\
    \ MUST NOT be forwarded if TTL is,\n      after decrement, 0.\n      This TTL\
    \ field is the primary loop-prevention mechanism.  This TTL\n      mechanism represents\
    \ a robust complement to the Service Index (see\n      Section 2.3), as the TTL\
    \ is decremented by each SFF.  The handling\n      of an incoming 0 TTL allows\
    \ for better, although not perfect,\n      interoperation with pre-standard implementations\
    \ that do not\n      support this TTL field.\n   Length:  The total length, in\
    \ 4-byte words, of the NSH including the\n      Base Header, the Service Path\
    \ Header, the Fixed-Length Context\n      Header, or Variable-Length Context Header(s).\
    \  The length MUST be\n      0x6 for MD Type 0x1, and it MUST be 0x2 or greater\
    \ for MD Type\n      0x2.  The length of the Network Service Header MUST be an\
    \ integer\n      multiple of 4 bytes; thus, variable-length metadata is always\n\
    \      padded out to a multiple of 4 bytes.\n   Unassigned bits:  All other flag\
    \ fields, marked U, are unassigned and\n      available for future use; see Section\
    \ 9.1.1.  Unassigned bits MUST\n      be set to zero upon origination, and they\
    \ MUST be ignored and\n      preserved unmodified by other NSH supporting elements.\
    \  At\n      reception, all elements MUST NOT modify their actions based on\n\
    \      these unknown bits.\n   Metadata (MD) Type:  Indicates the format of the\
    \ NSH beyond the\n      mandatory NSH Base Header and the Service Path Header.\
    \  MD Type\n      defines the format of the metadata being carried.  Please see\
    \ the\n      IANA Considerations in Section 9.1.3.\n      This document specifies\
    \ the following four MD Type values:\n      0x0:  This is a reserved value.  Implementations\
    \ SHOULD silently\n            discard packets with MD Type 0x0.\n      0x1: \
    \ This indicates that the format of the header includes a\n            Fixed-Length\
    \ Context Header (see Figure 5 below).\n      0x2:  This does not mandate any\
    \ headers beyond the Base Header and\n            Service Path Header, but may\
    \ contain optional Variable-\n            Length Context Header(s).  With MD Type\
    \ 0x2, a length of 0x2\n            implies there are no Context Headers.  The\
    \ semantics of the\n            Variable-Length Context Header(s) are not defined\
    \ in this\n            document.  The format of the optional Variable-Length\n\
    \            Context Headers is provided in Section 2.5.1.\n      0xF:  This value\
    \ is reserved for experimentation and testing, as\n            per [RFC3692].\
    \  Implementations not explicitly configured to\n            be part of an experiment\
    \ SHOULD silently discard packets\n            with MD Type 0xF.\n      The format\
    \ of the Base Header and the Service Path Header is\n      invariant and not affected\
    \ by MD Type.\n      The NSH MD Type 1 and MD Type 2 are described in detail in\n\
    \      Sections 2.4 and 2.5, respectively.  NSH implementations MUST\n      support\
    \ MD Types 0x1 and 0x2 (where the length is 0x2).  NSH\n      implementations\
    \ SHOULD support MD Type 0x2 with length greater\n      than 0x2.  Devices that\
    \ do not support MD Type 0x2 with a length\n      greater than 0x2 MUST ignore\
    \ any optional Context Headers and\n      process the packet without them; the\
    \ Base Header Length field can\n      be used to determine the original payload\
    \ offset if access to the\n      original packet/frame is required.  This specification\
    \ does not\n      disallow the MD Type value from changing along an SFP; however,\n\
    \      the specification of the necessary mechanism to allow the MD Type\n   \
    \   to change along an SFP are outside the scope of this document and\n      would\
    \ need to be defined for that functionality to be available.\n      Packets with\
    \ MD Type values not supported by an implementation\n      MUST be silently dropped.\n\
    \   Next Protocol:  Indicates the protocol type of the encapsulated data.\n  \
    \    The NSH does not alter the inner payload, and the semantics on the\n    \
    \  inner protocol remain unchanged due to NSH SFC.  Please see the\n      IANA\
    \ Considerations in Section 9.1.6.\n      This document defines the following\
    \ Next Protocol values:\n      0x1: IPv4\n      0x2: IPv6\n      0x3: Ethernet\n\
    \      0x4: NSH\n      0x5: MPLS\n      0xFE: Experiment 1\n      0xFF: Experiment\
    \ 2\n      The functionality of hierarchical NSH using a Next Protocol value\n\
    \      of 0x4 (NSH) is outside the scope of this specification.  Packets\n   \
    \   with Next Protocol values not supported SHOULD be silently dropped\n     \
    \ by default, although an implementation MAY provide a configuration\n      parameter\
    \ to forward them.  Additionally, an implementation not\n      explicitly configured\
    \ for a specific experiment [RFC3692] SHOULD\n      silently drop packets with\
    \ Next Protocol values 0xFE and 0xFF.\n"
- title: 2.3.  Service Path Header
  contents:
  - "2.3.  Service Path Header\n   Figure 4 shows the format of the Service Path Header:\n\
    \      0                   1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Service Path Identifier (SPI)        | Service Index |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     Service\
    \ Path Identifier (SPI): 24 bits\n     Service Index (SI): 8 bits\n          \
    \           Figure 4: NSH Service Path Header\n   The meaning of these fields\
    \ is as follows:\n   Service Path Identifier (SPI): Uniquely identifies a Service\
    \ Function\n   Path (SFP).  Participating nodes MUST use this identifier for SFP\n\
    \   selection.  The initial Classifier MUST set the appropriate SPI for a\n  \
    \ given classification result.\n   Service Index (SI): Provides location within\
    \ the SFP.  The initial\n   Classifier for a given SFP SHOULD set the SI to 255;\
    \ however, the\n   control plane MAY configure the initial value of the SI as\n\
    \   appropriate (i.e., taking into account the length of the SFP).  The\n   Service\
    \ Index MUST be decremented by a value of 1 by Service\n   Functions or by SFC\
    \ Proxy nodes after performing required services;\n   the new decremented SI value\
    \ MUST be used in the egress packet's NSH.\n   The initial Classifier MUST send\
    \ the packet to the first SFF in the\n   identified SFP for forwarding along an\
    \ SFP.  If re-classification\n   occurs, and that re-classification results in\
    \ a new SPI, the\n   (re-)Classifier is, in effect, the initial Classifier for\
    \ the\n   resultant SPI.\n   The SI is used in conjunction with the Service Path\
    \ Identifier for\n   SFP selection and for determining the next SFF/SF in the\
    \ path.  The\n   SI is also valuable when troubleshooting or reporting service\
    \ paths.\n   While the TTL provides the primary SFF-based loop prevention for\
    \ this\n   mechanism, SI decrement by SF serves as a limited loop-prevention\n\
    \   mechanism.  NSH packets, as described above, are discarded when an\n   SFF\
    \ decrements the TTL to 0.  In addition, an SFF that is not the\n   terminal SFF\
    \ for an SFP will discard any NSH packet with an SI of 0,\n   as there will be\
    \ no valid next SF information.\n"
- title: 2.4.  NSH MD Type 1
  contents:
  - "2.4.  NSH MD Type 1\n   When the Base Header specifies MD Type 0x1, a Fixed-Length\
    \ Context\n   Header (16-bytes) MUST be present immediately following the Service\n\
    \   Path Header, as per Figure 5.  The value of a Fixed-Length Context\n   Header\
    \ that carries no metadata MUST be set to zero.\n      0                   1 \
    \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        Service Path Identifier              | Service Index |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ |                 Fixed-Length Context Header                   |\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 5: NSH MD Type 0x1\n   This specification does\
    \ not make any assumptions about the content of\n   the 16-byte Context Header\
    \ that must be present when the MD Type\n   field is set to 1, and it does not\
    \ describe the structure or meaning\n   of the included metadata.\n   An SFC-aware\
    \ SF or SFC Proxy needs to receive the data structure and\n   semantics first\
    \ in order to process the data placed in the mandatory\n   context field.  The\
    \ data structure and semantics include both the\n   allocation schema and order\
    \ as well as the meaning of the included\n   data.  How an SFC-aware SF or SFC\
    \ Proxy gets the data structure and\n   semantics is outside the scope of this\
    \ specification.\n   An SF or SFC Proxy that does not know the format or semantics\
    \ of the\n   Context Header for an NSH with MD Type 1 MUST discard any packet\
    \ with\n   such an NSH (i.e., MUST NOT ignore the metadata that it cannot\n  \
    \ process), and MUST log the event at least once per the SPI for which\n   the\
    \ event occurs (subject to thresholding).\n   [NSH-DC-ALLOCATION] and [NSH-BROADBAND-ALLOCATION]\
    \ provide specific\n   examples of how metadata can be allocated.\n"
- title: 2.5.  NSH MD Type 2
  contents:
  - "2.5.  NSH MD Type 2\n   When the Base Header specifies MD Type 0x2, zero or more\
    \ Variable-\n   Length Context Headers MAY be added, immediately following the\n\
    \   Service Path Header (see Figure 6).  Therefore, Length = 0x2,\n   indicates\
    \ that only the Base Header and Service Path Header are\n   present (and in that\
    \ order).  The optional Variable-Length Context\n   Headers MUST be of an integer\
    \ number of 4-bytes.  The Base Header\n   Length field MUST be used to determine\
    \ the offset to locate the\n   original packet or frame for SFC nodes that require\
    \ access to that\n   information.\n      0                   1               \
    \    2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        Service Path Identifier              | Service Index |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ ~              Variable-Length Context Headers  (opt.)          ~\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                         Figure 6: NSH MD Type 0x2\n"
- title: 2.5.1.  Optional Variable-Length Metadata
  contents:
  - "2.5.1.  Optional Variable-Length Metadata\n   The format of the optional Variable-Length\
    \ Context Headers, is as\n   depicted in Figure 7.\n      0                  \
    \ 1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          Metadata Class       |      Type     |U|    Length   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                 Variable-Length Metadata                    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 7: Variable-Length Context Headers\n   Metadata Class\
    \ (MD Class):  Defines the scope of the Type field to\n      provide a hierarchical\
    \ namespace.  Section 9.1.4 defines how the\n      MD Class values can be allocated\
    \ to standards bodies, vendors, and\n      others.\n   Type:  Indicates the explicit\
    \ type of metadata being carried.  The\n      definition of the Type is the responsibility\
    \ of the MD Class\n      owner.\n   Unassigned bit:  One unassigned bit is available\
    \ for future use.\n      This bit MUST NOT be set, and it MUST be ignored on receipt.\n\
    \   Length:  Indicates the length of the variable-length metadata, in\n      bytes.\
    \  In case the metadata length is not an integer number of\n      4-byte words,\
    \ the sender MUST add pad bytes immediately following\n      the last metadata\
    \ byte to extend the metadata to an integer number\n      of 4-byte words.  The\
    \ receiver MUST round the Length field up to\n      the nearest 4-byte-word boundary,\
    \ to locate and process the next\n      field in the packet.  The receiver MUST\
    \ access only those bytes in\n      the metadata indicated by the Length field\
    \ (i.e., actual number of\n      bytes) and MUST ignore the remaining bytes up\
    \ to the nearest\n      4-byte-word boundary.  The length may be 0 or greater.\n\
    \      A value of 0 denotes a Context Header without a Variable-Length\n     \
    \ Metadata field.\n   This specification does not make any assumption about Context\
    \ Headers\n   that are mandatory to implement or those that are mandatory to\n\
    \   process.  These considerations are deployment specific.  However, the\n  \
    \ control plane is entitled to instruct SFC-aware SFs with the data\n   structure\
    \ of the Context Header together with its scoping (see e.g.,\n   Section 3.3.3\
    \ of [SFC-CONTROL-PLANE]).\n   Upon receipt of a packet that belongs to a given\
    \ SFP, if a mandatory-\n   to-process Context Header is missing in that packet,\
    \ the SFC-aware SF\n   MUST NOT process the packet and MUST log an error at least\
    \ once per\n   the SPI for which the mandatory metadata is missing.\n   If multiple\
    \ mandatory-to-process Context Headers are required for a\n   given SFP, the control\
    \ plane MAY instruct the SFC-aware SF with the\n   order to consume these Context\
    \ Headers.  If no instructions are\n   provided and the SFC-aware SF will make\
    \ use of or modify the specific\n   Context Header, then the SFC-aware SF MUST\
    \ process these Context\n   Headers in the order they appear in an NSH packet.\n\
    \   If multiple instances of the same metadata are included in an NSH\n   packet,\
    \ but the definition of that Context Header does not allow for\n   it, the SFC-aware\
    \ SF MUST process the first instance and ignore\n   subsequent instances.  The\
    \ SFC-aware SF MAY log or increase a counter\n   for this event.\n"
- title: 3.  NSH Actions
  contents:
  - "3.  NSH Actions\n   NSH-aware nodes (which include Service Classifiers, SFFs,\
    \ SFs, and\n   SFC Proxies) may alter the contents of the NSH headers.  These\
    \ nodes\n   have several possible NSH-related actions:\n   1.  Insert or remove\
    \ the NSH: These actions can occur respectively at\n       the start and end of\
    \ a service path.  Packets are classified, and\n       if determined to require\
    \ servicing, an NSH will be imposed.  A\n       Service Classifier MUST insert\
    \ an NSH at the start of an SFP.  An\n       imposed NSH MUST contain both a valid\
    \ Base Header and Service\n       Path Header.  At the end of an SFP, an SFF MUST\
    \ remove the NSH\n       before forwarding or delivering the un-encapsulated packet.\n\
    \       Therefore, it is the last node operating on the service header.\n    \
    \   Multiple logical Classifiers may exist within a given service\n       path.\
    \  Non-initial Classifiers may re-classify data, and that\n       re-classification\
    \ MAY result in the selection of a different SFP.\n       When the logical Classifier\
    \ performs re-classification that\n       results in a change of service path,\
    \ it MUST replace the existing\n       NSH with a new NSH with the Base Header\
    \ and Service Path Header\n       reflecting the new service path information\
    \ and MUST set the\n       initial SI.  The O bit, the TTL field, and unassigned\
    \ flags MUST\n       be copied transparently from the old NSH to a new NSH.  Metadata\n\
    \       MAY be preserved in the new NSH.\n   2.  Select service path: The Service\
    \ Path Header provides service\n       path information and is used by SFFs to\
    \ determine correct service\n       path selection.  SFFs MUST use the Service\
    \ Path Header for\n       selecting the next SF or SFF in the service path.\n\
    \   3.  Update the NSH: SFs MUST decrement the service index by one.  If\n   \
    \    an SFF receives a packet with an SPI and SI that do not\n       correspond\
    \ to a valid next hop in a valid SFP, that packet MUST\n       be dropped by the\
    \ SFF.\n       Classifiers MAY update Context Headers if new/updated context is\n\
    \       available.\n       If an SFC proxy is in use (acting on behalf of an NSH-unaware\n\
    \       Service Function for NSH actions), then the proxy MUST update the\n  \
    \     Service Index and MAY update contexts.  When an SFC Proxy\n       receives\
    \ an NSH-encapsulated packet, it MUST remove the NSH\n       before forwarding\
    \ it to an NSH-unaware SF.  When the SFC Proxy\n       receives a packet back\
    \ from an NSH-unaware SF, it MUST\n       re-encapsulate it with the correct NSH,\
    \ and it MUST decrement the\n       Service Index by one.\n   4.  Service policy\
    \ selection: Service Functions derive policy (i.e.,\n       service actions such\
    \ as permit or deny) selection and enforcement\n       from the NSH.  Metadata\
    \ shared in the NSH can provide a range of\n       service-relevant information\
    \ such as traffic classification.\n   Figure 8 maps each of the four actions above\
    \ to the components in the\n   SFC architecture that can perform it.\n   +-----------+-----------------------+-------+---------------+-------+\n\
    \   |           | Insert, remove, or    |Forward| Update        |Service|\n  \
    \ |           | replace the NSH       |the NSH| the NSH       |policy |\n   |\
    \           |                       |packets|               |sel.   |\n   |Component\
    \  +-------+-------+-------+       +-------+-------+       |\n   |           |\
    \       |       |       |       |Dec.   |Update |       |\n   |           |Insert\
    \ |Remove |Replace|       |Service|Context|       |\n   |           |       |\
    \       |       |       |Index  |Header |       |\n   +-----------+-------+-------+-------+-------+-------+-------+-------+\n\
    \   |           |  +    |       |   +   |       |       |   +   |       |\n  \
    \ |Classifier |       |       |       |       |       |       |       |\n   +-----------+-------+-------+-------+-------+-------+-------+-------+\n\
    \   |Service    |       |   +   |       |   +   |       |       |       |\n  \
    \ |Function   |       |       |       |       |       |       |       |\n   |Forwarder\
    \  |       |       |       |       |       |       |       |\n   |(SFF)      |\
    \       |       |       |       |       |       |       |\n   +-----------+-------+-------+-------+-------+-------+-------+-------+\n\
    \   |Service    |       |       |       |       |   +   |   +   |   +   |\n  \
    \ |Function   |       |       |       |       |       |       |       |\n   |(SF)\
    \       |       |       |       |       |       |       |       |\n   +-----------+-------+-------+-------+-------+-------+-------+-------+\n\
    \   |           |  +    |   +   |       |       |   +   |   +   |       |\n  \
    \ |SFC Proxy  |       |       |       |       |       |       |       |\n   +-----------+-------+-------+-------+-------+-------+-------+-------+\n\
    \                   Figure 8: NSH Action and Role Mapping\n"
- title: 4.  NSH Transport Encapsulation
  contents:
  - "4.  NSH Transport Encapsulation\n   Once the NSH is added to a packet, an outer\
    \ transport encapsulation\n   is used to forward the original packet and the associated\
    \ metadata to\n   the start of a service chain.  The encapsulation serves two\
    \ purposes:\n   1.  Creates a topologically independent services plane.  Packets\
    \ are\n       forwarded to the required services without changing the\n      \
    \ underlying network topology.\n   2.  Transit network nodes simply forward the\
    \ encapsulated packets\n       without modification.\n   The service header is\
    \ independent of the transport encapsulation\n   used.  Existing transport encapsulations\
    \ can be used.  The presence\n   of an NSH is indicated via a protocol type or\
    \ another indicator in\n   the outer transport encapsulation.\n"
- title: 5.  Fragmentation Considerations
  contents:
  - "5.  Fragmentation Considerations\n   The NSH and the associated transport encapsulation\
    \ header are \"added\"\n   to the encapsulated packet/frame.  This additional\
    \ information\n   increases the size of the packet.\n   Within a managed administrative\
    \ domain, an operator can ensure that\n   the underlay MTU is sufficient to carry\
    \ SFC traffic without requiring\n   fragmentation.  Given that the intended scope\
    \ of the NSH is within a\n   single provider's operational domain, that approach\
    \ is sufficient.\n   However, although explicitly outside the scope of this specification,\n\
    \   there might be cases where the underlay MTU is not large enough to\n   carry\
    \ the NSH traffic.  Since the NSH does not provide fragmentation\n   support at\
    \ the service plane, the transport encapsulation protocol\n   ought to provide\
    \ the requisite fragmentation handling.  For instance,\n   Section 9 of [RTG-ENCAP]\
    \ provides exemplary approaches and guidance\n   for those scenarios.\n   When\
    \ the transport encapsulation protocol supports fragmentation, and\n   fragmentation\
    \ procedures needs to be used, such fragmentation is part\n   of the transport\
    \ encapsulation logic.  If, as it is common,\n   fragmentation is performed by\
    \ the endpoints of the transport\n   encapsulation, then fragmentation procedures\
    \ are performed at the\n   sending NSH entity as part of the transport encapsulation,\
    \ and\n   reassembly procedures are performed at the receiving NSH entity\n  \
    \ during transport de-encapsulation handling logic.  In no case would\n   such\
    \ fragmentation result in duplication of the NSH header.\n   For example, when\
    \ the NSH is encapsulated in IP, IP-level\n   fragmentation coupled with Path\
    \ MTU Discovery (PMTUD) (e.g.,\n   [RFC8201]) is used.  Since PMTUD relies on\
    \ ICMP messages, an operator\n   should ensure ICMP packets are not blocked. \
    \ When, on the other hand,\n   the underlay does not support fragmentation procedures,\
    \ an error\n   message SHOULD be logged when dropping a packet too big.  Lastly,\n\
    \   NSH-specific fragmentation and reassembly methods may be defined as\n   well,\
    \ but these methods are outside the scope of this document and\n   subject for\
    \ future work.\n"
- title: 6.  Service Path Forwarding with NSH
  contents:
  - '6.  Service Path Forwarding with NSH

    '
- title: 6.1.  SFFs and Overlay Selection
  contents:
  - "6.1.  SFFs and Overlay Selection\n   As described above, the NSH contains a Service\
    \ Path Identifier (SPI)\n   and a Service Index (SI).  The SPI is, as per its\
    \ name, an\n   identifier.  The SPI alone cannot be used to forward packets along\
    \ a\n   service path.  Rather, the SPI provides a level of indirection\n   between\
    \ the service path / topology and the network transport\n   encapsulation.  Furthermore,\
    \ there is no requirement for, or\n   expectation of, an SPI being bound to a\
    \ predetermined or static\n   network path.\n   The Service Index provides an\
    \ indication of location within a service\n   path.  The combination of SPI and\
    \ SI provides the identification of a\n   logical SF and its order within the\
    \ service plane.  This combination\n   is used to select the appropriate network\
    \ locator(s) for overlay\n   forwarding.  The logical SF may be a single SF or\
    \ a set of eligible\n   SFs that are equivalent.  In the latter case, the SFF\
    \ provides load\n   distribution amongst the collection of SFs as needed.\n  \
    \ SI serves as a mechanism for detecting invalid SFPs.  In particular,\n   an\
    \ SI value of zero indicates that forwarding is incorrect and the\n   packet must\
    \ be discarded.\n   This indirection -- SPI to overlay -- creates a true service\
    \ plane.\n   That is, the SFF/SF topology is constructed without impacting the\n\
    \   network topology, but, more importantly, service-plane-only\n   participants\
    \ (i.e., most SFs) need not be part of the network overlay\n   topology and its\
    \ associated infrastructure (e.g., control plane,\n   routing tables, etc.). \
    \ SFs need to be able to return a packet to an\n   appropriate SFF (i.e., has\
    \ the requisite NSH information) when\n   service processing is complete.  This\
    \ can be via the overlay or\n   underlay and, in some cases, can require additional\
    \ configuration on\n   the SF.  As mentioned above, an existing overlay topology\
    \ may be\n   used, provided it offers the requisite connectivity.\n   The mapping\
    \ of SPI to transport encapsulation occurs on an SFF (as\n   discussed above,\
    \ the first SFF in the path gets an NSH encapsulated\n   packet from the Classifier).\
    \  The SFF consults the SPI/ID values to\n   determine the appropriate overlay\
    \ transport encapsulation protocol\n   (several may be used within a given network)\
    \ and next hop for the\n   requisite SF.  Table 1 depicts an example of a single\
    \ next-hop SPI/\n   SI-to-network overlay network locator mapping.\n      +------+------+---------------------+-------------------------+\n\
    \      | SPI  | SI   | Next Hop(s)         | Transport Encapsulation |\n     \
    \ +------+------+---------------------+-------------------------+\n      | 10\
    \   | 255  | 192.0.2.1           | VXLAN-gpe               |\n      |      | \
    \     |                     |                         |\n      | 10   | 254  |\
    \ 198.51.100.10       | GRE                     |\n      |      |      |     \
    \                |                         |\n      | 10   | 251  | 198.51.100.15\
    \       | GRE                     |\n      |      |      |                   \
    \  |                         |\n      | 40   | 251  | 198.51.100.15       | GRE\
    \                     |\n      |      |      |                     |         \
    \                |\n      | 50   | 200  | 01:23:45:67:89:ab   | Ethernet     \
    \           |\n      |      |      |                     |                   \
    \      |\n      | 15   | 212  | Null (end of path)  | None                   \
    \ |\n      +------+------+---------------------+-------------------------+\n \
    \                    Table 1: SFF NSH Mapping Example\n   Additionally, further\
    \ indirection is possible: the resolution of the\n   required SF network locator\
    \ may be a localized resolution on an SFF,\n   rather than an SFC control plane\
    \ responsibility, as per Tables 2 and\n   3.\n   Please note: VXLAN-gpe and GRE\
    \ in the above table refer to\n   [VXLAN-GPE] and [RFC2784] [RFC7676], respectively.\n\
    \                      +------+-----+----------------+\n                     \
    \ | SPI  | SI  | Next Hop(s)    |\n                      +------+-----+----------------+\n\
    \                      | 10   | 3   | SF2            |\n                     \
    \ |      |     |                |\n                      | 245  | 12  | SF34 \
    \          |\n                      |      |     |                |\n        \
    \              | 40   | 9   | SF9            |\n                      +------+-----+----------------+\n\
    \                    Table 2: NSH-to-SF Mapping Example\n          +------+-------------------+-------------------------+\n\
    \          | SF   | Next Hop(s)       | Transport Encapsulation |\n          +------+-------------------+-------------------------+\n\
    \          | SF2  | 192.0.2.2         | VXLAN-gpe               |\n          |\
    \      |                   |                         |\n          | SF34 | 198.51.100.34\
    \     | UDP                     |\n          |      |                   |    \
    \                     |\n          | SF9  | 2001:db8::1       | GRE          \
    \           |\n          +------+-------------------+-------------------------+\n\
    \                    Table 3: SF Locator Mapping Example\n   Since the SPI is\
    \ a representation of the service path, the lookup may\n   return more than one\
    \ possible next hop within a service path for a\n   given SF, essentially a series\
    \ of weighted (equally or otherwise)\n   paths to be used (for load distribution,\
    \ redundancy, or policy); see\n   Table 4.  The metric depicted in Table 4 is\
    \ an example to help\n   illustrate weighing SFs.  In a real network, the metric\
    \ will range\n   from a simple preference (similar to routing next-hop) to a true\n\
    \   dynamic composite metric based on the state of a Service Function\n   (including\
    \ load, session state, capacity, etc.).\n                  +------+-----+--------------+---------+\n\
    \                  | SPI  | SI  | NH           | Metric  |\n                 \
    \ +------+-----+--------------+---------+\n                  | 10   | 3   | 203.0.113.1\
    \  | 1       |\n                  |      |     |              |         |\n  \
    \                |      |     | 203.0.113.2  | 1       |\n                  |\
    \      |     |              |         |\n                  | 20   | 12  | 192.0.2.1\
    \    | 1       |\n                  |      |     |              |         |\n\
    \                  |      |     | 203.0.113.4  | 1       |\n                 \
    \ |      |     |              |         |\n                  | 30   | 7   | 192.0.2.10\
    \   | 10      |\n                  |      |     |              |         |\n \
    \                 |      |     | 198.51.100.1 | 5       |\n                  +------+-----+--------------+---------+\n\
    \                (encapsulation type omitted for formatting)\n               \
    \     Table 4: NSH Weighted Service Path\n   The information contained in Tables\
    \ 1-4 may be received from the\n   control plane, but the exact mechanism is outside\
    \ the scope of this\n   document.\n"
- title: 6.2.  Mapping the NSH to Network Topology
  contents:
  - "6.2.  Mapping the NSH to Network Topology\n   As described above, the mapping\
    \ of the SPI to network topology may\n   result in a single path, or it might\
    \ result in a more complex\n   topology.  Furthermore, the SPI-to-overlay mapping\
    \ occurs at each SFF\n   independently.  Any combination of topology selection\
    \ is possible.\n   Please note, there is no requirement to create a new overlay\
    \ topology\n   if a suitable one already exists.  NSH packets can use any (new\
    \ or\n   existing) overlay, provided the requisite connectivity requirements\n\
    \   are satisfied.\n   Examples of mapping for a topology:\n   1.  Next SF is\
    \ located at SFFb with locator 2001:db8::1\n       SFFa mapping: SPI=10 --> VXLAN-gpe,\
    \ dst-ip: 2001:db8::1\n   2.  Next SF is located at SFFc with multiple network\
    \ locators for\n       load-distribution purposes:\n       SFFb mapping: SPI=10\
    \ --> VXLAN-gpe, dst_ip:203.0.113.1,\n       203.0.113.2, 203.0.113.3, equal cost\n\
    \   3.  Next SF is located at SFFd with two paths from SFFc, one for\n       redundancy:\n\
    \       SFFc mapping: SPI=10 --> VXLAN-gpe, dst_ip:192.0.2.10 cost=10,\n     \
    \  203.0.113.10, cost=20\n   In the above example, each SFF makes an independent\
    \ decision about\n   the network overlay path and policy for that path.  In other\
    \ words,\n   there is no a priori mandate about how to forward packets in the\n\
    \   network (only the order of services that must be traversed).\n   The network\
    \ operator retains the ability to engineer the network\n   paths as required.\
    \  For example, the overlay path between SFFs may\n   utilize traffic engineering,\
    \ QoS marking, or ECMP, without requiring\n   complex configuration and network\
    \ protocol support to be extended to\n   the service path explicitly.  In other\
    \ words, the network operates as\n   expected, and evolves as required, as does\
    \ the service plane.\n"
- title: 6.3.  Service Plane Visibility
  contents:
  - "6.3.  Service Plane Visibility\n   The SPI and SI serve an important function\
    \ for visibility into the\n   service topology.  An operator can determine what\
    \ service path a\n   packet is \"on\" and its location within that path simply\
    \ by viewing\n   NSH information (packet capture, IP Flow Information Export (IPFIX),\n\
    \   etc.).  The information can be used for service scheduling and\n   placement\
    \ decisions, troubleshooting, and compliance verification.\n"
- title: 6.4.  Service Graphs
  contents:
  - "6.4.  Service Graphs\n   While a given realized SFP is a specific sequence of\
    \ Service\n   Functions, the service, as seen by a user, can actually be a\n \
    \  collection of SFPs, with the interconnection provided by Classifiers\n   (in-service\
    \ path, non-initial re-classification).  These internal re-\n   Classifiers examine\
    \ the packet at relevant points in the network,\n   and, if needed, SPI and SI\
    \ are updated (whether this update is a re-\n   write, or the imposition of a\
    \ new NSH with new values is\n   implementation specific) to reflect the \"result\"\
    \ of the\n   classification.  These Classifiers may, of course, also modify the\n\
    \   metadata associated with the packet.\n   Section 2.1 of [RFC7665] describes\
    \ Service Graphs in detail.\n"
- title: 7.  Policy Enforcement with NSH
  contents:
  - '7.  Policy Enforcement with NSH

    '
- title: 7.1.  NSH Metadata and Policy Enforcement
  contents:
  - "7.1.  NSH Metadata and Policy Enforcement\n   As described in Section 2, NSH\
    \ provides the ability to carry metadata\n   along a service path.  This metadata\
    \ may be derived from several\n   sources.  Common examples include:\n      Network\
    \ nodes/devices: Information provided by network nodes can\n      indicate network-centric\
    \ information (such as VPN Routing and\n      Forwarding (VRF) or tenant) that\
    \ may be used by Service Functions\n      or conveyed to another network node\
    \ post service path egress.\n      External (to the network) systems: External\
    \ systems, such as\n      orchestration systems, often contain information that\
    \ is valuable\n      for Service Function policy decisions.  In most cases, this\n\
    \      information cannot be deduced by network nodes.  For example, a\n     \
    \ cloud orchestration platform placing workloads \"knows\" what\n      application\
    \ is being instantiated and can communicate this\n      information to all NSH\
    \ nodes via metadata carried in the Context\n      Header(s).\n      Service Functions:\
    \ A Classifier co-resident with Service Functions\n      often performs very detailed\
    \ and valuable classification.\n   Regardless of the source, metadata reflects\
    \ the \"result\" of\n   classification.  The granularity of classification may\
    \ vary.  For\n   example, a network switch, acting as a Classifier, might only\
    \ be able\n   to classify based on a 2-tuple, or based on a 5-tuple, while a\n\
    \   Service Function may be able to inspect application information.\n   Regardless\
    \ of granularity, the classification information can be\n   represented in the\
    \ NSH.\n   Once the data is added to the NSH, it is carried along the service\n\
    \   path.  NSH-aware SFs receive the metadata, and can use that metadata\n   for\
    \ local decisions and policy enforcement.  Figures 9 and 10\n   highlight the\
    \ relationship between metadata and policy.\n                +-------+       \
    \ +-------+        +-------+\n                |  SFF  )------->(  SFF  |------->|\
    \  SFF  |\n                +---+---+        +---+---+        +---+---+\n     \
    \               ^                |                |\n                  ,-|-. \
    \           ,-|-.            ,-|-.\n                 /     \\          /     \\\
    \          /     \\\n                ( Class )        (  SF1  )        (  SF2\
    \  )\n                 \\ ify /          \\     /          \\     /\n        \
    \          `---'            `---'            `---'\n                 5-tuple:\
    \        Permit             Inspect\n                 Tenant A        Tenant A\
    \           AppY\n                 AppY\n                       Figure 9: Metadata\
    \ and Policy\n               +-----+           +-----+            +-----+\n  \
    \             | SFF |---------> | SFF |----------> | SFF |\n               +--+--+\
    \           +--+--+            +--+--+\n                  ^                 |\
    \                  |\n                ,-+-.             ,-+-.              ,-+-.\n\
    \               /     \\           /     \\            /     \\\n            \
    \  ( Class )         (  SF1  )          (  SF2  )\n               \\ ify /   \
    \        \\     /            \\     /\n                `-+-'             `---'\
    \              `---'\n                  |              Permit            Deny\
    \ AppZ\n              +---+---+          employees\n              |       |\n\
    \              +-------+\n              External\n              system:\n    \
    \          Employee\n              AppZ\n                  Figure 10: External\
    \ Metadata and Policy\n   In both of the examples above, the Service Functions\
    \ perform policy\n   decisions based on the result of the initial classification:\
    \ the SFs\n   did not need to perform re-classification; instead, they rely on\
    \ an\n   antecedent classification for local policy enforcement.\n   Depending\
    \ on the information carried in the metadata, data privacy\n   impact needs to\
    \ be considered.  For example, if the metadata conveys\n   tenant information,\
    \ that information may need to be authenticated\n   and/or encrypted between the\
    \ originator and the intended recipients\n   (which may include intended SFs only);\
    \ one approach to an optional\n   capability to do this is explored in [NSH-ENCRYPT].\
    \  The NSH itself\n   does not provide privacy functions, rather it relies on\
    \ the transport\n   encapsulation/overlay.  An operator can select the appropriate\
    \ set of\n   transport encapsulation protocols to ensure confidentiality (and\n\
    \   other security) considerations are met.  Metadata privacy and\n   security\
    \ considerations are a matter for the documents that define\n   metadata format.\n"
- title: 7.2.  Updating/Augmenting Metadata
  contents:
  - "7.2.  Updating/Augmenting Metadata\n   Post-initial metadata imposition (typically,\
    \ performed during initial\n   service path determination), the metadata may be\
    \ augmented or\n   updated:\n   1.  Metadata Augmentation: Information may be\
    \ added to the NSH's\n       existing metadata, as depicted in Figure 11.  For\
    \ example, if the\n       initial classification returns the tenant information,\
    \ a\n       secondary classification (perhaps co-resident with deep packet\n \
    \      inspection (DPI) or server load balancing (SLB)) may augment the\n    \
    \   tenant classification with application information, and impose\n       that\
    \ new information in NSH metadata.  The tenant classification\n       is still\
    \ valid and present, but additional information has been\n       added to it.\n\
    \   2.  Metadata Update: Subsequent Classifiers may update the initial\n     \
    \  classification if it is determined to be incorrect or not\n       descriptive\
    \ enough.  For example, the initial Classifier adds\n       metadata that describes\
    \ the traffic as \"Internet\", but a security\n       Service Function determines\
    \ that the traffic is really \"attack\".\n       Figure 12 illustrates an example\
    \ of updating metadata.\n               +-----+           +-----+            +-----+\n\
    \               | SFF |---------> | SFF |----------> | SFF |\n               +--+--+\
    \           +--+--+            +--+--+\n                  ^                 |\
    \                  |\n                ,---.             ,---.              ,---.\n\
    \               /     \\           /     \\            /     \\\n            \
    \  ( Class )         (  SF1  )          (  SF2  )\n               \\     /   \
    \        \\     /            \\     /\n                `-+-'             `---'\
    \              `---'\n                  |              Inspect           Deny\n\
    \              +---+---+          employees         employee+\n              |\
    \       |          Class=AppZ        appZ\n              +-------+\n         \
    \     External\n              system:\n              Employee\n              \
    \       Figure 11: Metadata Augmentation\n                +-----+           +-----+\
    \            +-----+\n                | SFF |---------> | SFF |----------> | SFF\
    \ |\n                +--+--+           +--+--+            +--+--+\n          \
    \         ^                 |                  |\n                 ,---.     \
    \        ,---.              ,---.\n                /     \\           /     \\\
    \            /     \\\n               ( Class )         (  SF1  )          ( \
    \ SF2  )\n                \\     /           \\     /            \\     /\n  \
    \               `---'             `---'              `---'\n              5-tuple:\
    \            Inspect             Deny\n              Tenant A            Tenant\
    \ A            attack\n                                   --> attack\n       \
    \                 Figure 12: Metadata Update\n"
- title: 7.3.  Service Path Identifier and Metadata
  contents:
  - "7.3.  Service Path Identifier and Metadata\n   Metadata information may influence\
    \ the service path selection since\n   the Service Path Identifier values can\
    \ represent the result of\n   classification.  A given SPI can be defined based\
    \ on classification\n   results (including metadata classification).  The imposition\
    \ of the\n   SPI and SI results in the packet being placed on the newly specified\n\
    \   SFP at the position indicated by the imposed SPI and SI.\n   This relationship\
    \ provides the ability to create a dynamic service\n   plane based on complex\
    \ classification, without requiring each node to\n   be capable of such classification\
    \ or requiring a coupling to the\n   network topology.  This yields Service Graph\
    \ functionality as\n   described in Section 6.4.  Figure 13 illustrates an example\
    \ of this\n   behavior.\n               +-----+           +-----+            +-----+\n\
    \               | SFF |---------> | SFF |------+---> | SFF |\n               +--+--+\
    \           +--+--+      |     +--+--+\n                  |                 |\
    \         |        |\n                ,---.             ,---.       |      ,---.\n\
    \               /     \\           / SF1 \\      |     /     \\\n            \
    \  (  SCL  )         (   +   )     |    (  SF2  )\n               \\     /   \
    \        \\SCL2 /      |     \\     /\n                `---'             `---'\
    \    +-----+   `---'\n             5-tuple:            Inspect   | SFF |    Original\n\
    \             Tenant A            Tenant A  +--+--+    next SF\n             \
    \                     --> DoS     |\n                                        \
    \      V\n                                            ,-+-.\n                \
    \                           /     \\\n                                       \
    \   (  SF10 )\n                                           \\     /\n         \
    \                                   `---'\n                                  \
    \           DoS\n                                          \"Scrubber\"\n    \
    \         Legend:\n             SCL = Service Classifier\n                   \
    \   Figure 13: Path ID and Metadata\n   Specific algorithms for mapping metadata\
    \ to an SPI are outside the\n   scope of this document.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   NSH security must be considered in the contexts\
    \ of the SFC\n   architecture and operators' environments.  One important\n  \
    \ characteristic of NSH is that it is not an end-to-end protocol.  As\n   opposed\
    \ to a protocol that \"starts\" on a host and \"ends\" on a server\n   or another\
    \ host, NSH is typically imposed by a network device on\n   ingress to the SFC\
    \ domain and removed at the egress of the SFC\n   domain.  As such, and as with\
    \ any other network-centric protocols\n   (e.g., IP Tunneling, Traffic Engineering,\
    \ MPLS, or Provider-\n   Provisioned Virtual Private Networks), there is an underlying\
    \ trust\n   in the network devices responsible for imposing, removing, and acting\n\
    \   on NSH information.\n   The following sections detail an analysis and present\
    \ a set of\n   requirements and recommendations in those two areas.\n"
- title: 8.1.  NSH Security Considerations from Operators' Environments
  contents:
  - "8.1.  NSH Security Considerations from Operators' Environments\n   Trusted Devices\n\
    \      All Classifiers, SFFs and SFs (hereinafter referred to as \"SFC\n     \
    \ devices\") within an operator's environment are assumed to have\n      been\
    \ selected, vetted, and actively maintained; therefore, they\n      are trusted\
    \ by that operator.  This assumption differs from the\n      oft held view that\
    \ devices are untrusted, often referred to as the\n      \"zero-trust model\"\
    .  Operators SHOULD regularly monitor (i.e.,\n      continuously audit) these\
    \ devices to help ensure compliant\n      behavior.  This trust, therefore, extends\
    \ into NSH operations: SFC\n      devices are not, themselves, considered to be\
    \ attack vectors.\n      This assumption, and the resultant conclusion is reasonable\
    \ since\n      this is the very basis of an operator posture; the operator\n \
    \     depends on this reality to function.  If these devices are not\n      trusted,\
    \ and indeed are compromised, almost the entirety of the\n      operator's standard-based\
    \ IP and MPLS protocol suites are\n      vulnerable; therefore, the operation\
    \ of the entire network is\n      compromised.  Although there are well-documented\
    \ monitoring-based\n      methods for detecting compromise (such as included continuous\n\
    \      monitoring and audit and log review), these may not be sufficient\n   \
    \   to contain damage by a completely compromised element.\n      Methods and\
    \ best practices to secure devices are also widely\n      documented and outside\
    \ the scope of this document.\n   Single Domain Boundary\n      As per [RFC7665],\
    \ NSH is designed for use within a single\n      administrative domain.  This\
    \ scoping provides two important\n      characteristics:\n      i) Clear NSH boundaries\n\
    \      NSH egress devices MUST strip the NSH headers before they send the\n  \
    \    users' packets or frames out of the NSH domain.\n      Means to prevent leaking\
    \ privacy-related information outside an\n      administrative domain are natively\
    \ supported by the NSH given that\n      the last SFF of a service path will systematically\
    \ remove the NSH\n      encapsulation before forwarding a packet exiting the service\
    \ path.\n      The second step in such prevention is to filter the transport\n\
    \      encapsulation protocol used by NSH at the domain edge.  The\n      transport\
    \ encapsulation protocol MUST be filtered and MUST NOT\n      leave the domain\
    \ edge.\n      Depending upon the transport encapsulation protocol used for NSH,\n\
    \      this can be done either by completely blocking the transport\n      encapsulation\
    \ (e.g., if MPLS is the chosen NSH transport\n      encapsulation protocol, it\
    \ is therefore never allowed to leave the\n      domain) or by examining the carried\
    \ protocol with the transport\n      encapsulation (e.g., if VXLAN-gpe is used\
    \ as the NSH transport\n      encapsulation protocol, all domain edges need to\
    \ filter based on\n      the carried protocol in the VXLAN-gpe.)\n      The other\
    \ consequence of this bounding is that ingress packets\n      MUST also be filtered\
    \ to prevent attackers from sending in NSH\n      packets with service path identification\
    \ and metadata of their own\n      selection.  The same filters as described above\
    \ for both the NSH\n      at SFC devices and for the transport encapsulation protocol\
    \ as\n      general edge protections MUST be applied on ingress.\n      In summary,\
    \ packets originating outside the SFC-enabled domain\n      MUST be dropped if\
    \ they contain an NSH.  Similarly, packets\n      exiting the SFC-enabled domain\
    \ MUST be dropped if they contain an\n      NSH.\n      ii) Mitigation of external\
    \ threats\n      As per the trusted SFC device points raised above, given that\
    \ NSH\n      is scoped within an operator's domain, that operator can ensure\n\
    \      that the environment and its transitive properties comply with\n      that\
    \ operator's required security posture.  Continuous audits for\n      assurance\
    \ are recommended with this reliance on a fully trusted\n      environment.  The\
    \ term \"continuous audits\" describes a method\n      (automated or manual) of\
    \ checking security-control compliance on a\n      regular basis, at some set\
    \ period of time.\n"
- title: 8.2.  NSH Security Considerations from the SFC Architecture
  contents:
  - "8.2.  NSH Security Considerations from the SFC Architecture\n   The SFC architecture\
    \ defines functional roles (e.g., SFF), as well as\n   protocol elements (e.g.,\
    \ Metadata).  This section considers each role\n   and element in the context\
    \ of threats posed in the areas of integrity\n   and confidentiality.  As with\
    \ routing, the distributed computation\n   model assumes a distributed trust model.\n\
    \   An important consideration is that NSH contains mandatory-to-mute\n   fields,\
    \ and further, the SFC architecture describes cases where other\n   fields in\
    \ NSH change, all on a possible SFP hop-by-hop basis.  This\n   means that any\
    \ cryptographic solution requires complex key\n   distribution and life-cycle\
    \ operations.\n"
- title: 8.2.1.  Integrity
  contents:
  - "8.2.1.  Integrity\n   SFC devices\n      SFC devices MAY perform various forms\
    \ of verification on received\n      NSH packets such as only accepting NSH packets\
    \ from expected\n      devices, checking that NSH SPI and SI values received from\n\
    \      expected devices conform to expected values and so on.\n      Implementation\
    \ of these additional checks are a local matter and,\n      thus, out of scope\
    \ of this document.\n   NSH Base and Service Path Headers\n      Attackers who\
    \ can modify packets within the operator's network may\n      be able to modify\
    \ the SFP, path position, and/or the metadata\n      associated with a packet.\n\
    \      One specific concern is an attack in which a malicious\n      modification\
    \ of the SPI/SI results in an alteration of the path to\n      avoid security\
    \ devices.  The options discussed in this section\n      help thwart that attack,\
    \ and so does the use of the optional\n      \"Proof of Transit\" method [PROOF-OF-TRANSIT].\n\
    \      As stated above, SFC devices are trusted; in the case where an SFC\n  \
    \    device is compromised, NSH integrity protection would be subject\n      to\
    \ forging (in many cases) as well.\n      NSH itself does not mandate protocol-specific\
    \ integrity\n      protection.  However, if an operator deems protection is required,\n\
    \      several options are viable:\n      1.  SFF/SF NSH verification\n      \
    \    Although, strictly speaking, not integrity protection, some of\n        \
    \  the techniques mentioned above, such as checking expected NSH\n          values\
    \ are received from expected SFC device(s), can provide a\n          form of verification\
    \ without incurring the burden of a full-\n          fledged integrity-protection\
    \ deployment.\n      2.  Transport Security\n          NSH is always encapsulated\
    \ by an outer transport encapsulation\n          as detailed in Section 4 of this\
    \ specification, and as\n          depicted in Figure 1.  If an operator deems\
    \ cryptographic\n          integrity protection necessary due to their risk analysis,\n\
    \          then an outer transport encapsulation that provides such\n        \
    \  protection [RFC6071], such as IPsec, MUST be used.\n          Although the\
    \ threat model and recommendations of Section 5 of\n          BCP 72 [RFC3552]\
    \ would normally require cryptographic data\n          origin authentication for\
    \ the header, this document does not\n          mandate such mechanisms in order\
    \ to reflect the operational\n          and technical realities of deployment.\n\
    \          Given that NSH is transport independent, as mentioned above, a\n  \
    \        secure transport, such as IPsec can be used for carry NSH.\n        \
    \  IPsec can be used either alone or in conjunction with other\n          transport\
    \ encapsulation protocols, in turn, encapsulating NSH.\n          Operators MUST\
    \ ensure the selected transport encapsulation\n          protocol can be supported\
    \ by the transport encapsulation/\n          underlay of all relevant network\
    \ segments as well as SFFs,\n          SFs, and SFC Proxies in the service path.\n\
    \          If connectivity between SFC-enabled devices traverses the\n       \
    \   public Internet, then such connectivity MUST be secured at the\n         \
    \ transport encapsulation layer.  IPsec is an example of such a\n          transport.\n\
    \      3.  NSH Variable Header-Based Integrity\n          Lastly, NSH MD Type\
    \ 2 provides, via variable-length headers,\n          the ability to append cryptographic\
    \ integrity protection to\n          the NSH packet.  The implementation of such\
    \ a scheme is\n          outside the scope of this document.\n   NSH metadata\n\
    \      As with the Base and Service Path Headers, if an operator deems\n     \
    \ cryptographic integrity protection needed, then an existing,\n      standard\
    \ transport protocol MUST be used since the integrity\n      protection applies\
    \ to entire encapsulated NSH packets.  As\n      mentioned above, a risk assessment\
    \ that deems data-plane traffic\n      subject to tampering will apply not only\
    \ to NSH but to the\n      transport information; therefore, the use of a secure\
    \ transport is\n      likely needed already to protect the entire stack.\n   \
    \   If an MD Type 2 variable header integrity scheme is in place, then\n     \
    \ the integrity of the metadata can be ensured via that mechanism as\n      well.\n"
- title: 8.2.2.  Confidentiality
  contents:
  - "8.2.2.  Confidentiality\n   SFC devices\n      SFC devices can \"see\" (and need\
    \ to use) NSH information.\n   NSH Base and Service Path Headers\n      SPI and\
    \ other base / service path information does not typically\n      require confidentiality;\
    \ however, if an operator does deem\n      confidentiality to be required, then,\
    \ as with integrity, an\n      existing transport encapsulation that provides\
    \ encryption MUST be\n      utilized.\n   NSH metadata\n      An attacker with\
    \ access to the traffic in an operator's network\n      can potentially observe\
    \ the metadata NSH carries with packets,\n      potentially discovering privacy-sensitive\
    \ information.\n      Much of the metadata carried by NSH is not sensitive.  It\
    \ often\n      reflects information that can be derived from the underlying\n\
    \      packet or frame.  Direct protection of such information is not\n      necessary,\
    \ as the risks are simply those of carrying the\n      underlying packet or frame.\n\
    \      Implementers and operators MUST be aware that metadata can have\n     \
    \ privacy implications, and those implications are sometimes hard to\n      predict.\
    \  Therefore, attached metadata should be limited to that\n      necessary for\
    \ correct operation of the SFP.  Further, [RFC8165]\n      defines metadata considerations\
    \ that operators can take into\n      account when using NSH.\n      Protecting\
    \ NSH metadata information between SFC components can be\n      done using transport\
    \ encapsulation protocols with suitable\n      security capabilities, along the\
    \ lines discussed above.  If a\n      security analysis deems these protections\
    \ necessary, then security\n      features in the transport encapsulation protocol\
    \ (such as IPsec)\n      MUST be used.\n      One useful element of providing\
    \ privacy protection for sensitive\n      metadata is described under the \"SFC\
    \ Encapsulation\" area of the\n      Security Considerations of [RFC7665].  Operators\
    \ can and should\n      use indirect identification for metadata deemed to be\
    \ sensitive\n      (such as personally identifying information), significantly\n\
    \      mitigating the risk of a privacy violation.  In particular,\n      subscriber-identifying\
    \ information should be handled carefully,\n      and, in general, SHOULD be obfuscated.\n\
    \      For those situations where obfuscation is either inapplicable or\n    \
    \  judged to be insufficient, an operator can also encrypt the\n      metadata.\
    \  An approach to an optional capability to do this was\n      explored in [NSH-ENCRYPT].\
    \  For other situations where greater\n      assurance is desired, optional mechanisms\
    \ such as\n      [PROOF-OF-TRANSIT] can be used.\n"
- title: 9.  IANA Considerations
  contents:
  - '9.  IANA Considerations

    '
- title: 9.1.  NSH Parameters
  contents:
  - "9.1.  NSH Parameters\n   IANA has created a new \"Network Service Header (NSH)\
    \ Parameters\"\n   registry.  The following subsections detail new registries\
    \ within the\n   \"Network Service Header (NSH) Parameters\" registry.\n"
- title: 9.1.1.  NSH Base Header Bits
  contents:
  - "9.1.1.  NSH Base Header Bits\n   There are five unassigned bits (U bits) in the\
    \ NSH Base Header, and\n   one assigned bit (O bit).  New bits are assigned via\
    \ Standards Action\n   [RFC8126].\n   Bit 2 - O (OAM) bit\n   Bit 3 - Unassigned\n\
    \   Bits 16-19 - Unassigned\n"
- title: 9.1.2.  NSH Version
  contents:
  - "9.1.2.  NSH Version\n   IANA has set up the \"NSH Version\" registry.  New values\
    \ are assigned\n   via Standards Action [RFC8126].\n       +-------------+---------------------------------+-----------+\n\
    \       | Version     | Description                     | Reference |\n      \
    \ +-------------+---------------------------------+-----------+\n       | Version\
    \ 00b | Protocol as defined by RFC 8300 | RFC 8300  |\n       | Version 01b |\
    \ Reserved                        | RFC 8300  |\n       | Version 10b | Unassigned\
    \                      |           |\n       | Version 11b | Unassigned      \
    \                |           |\n       +-------------+---------------------------------+-----------+\n\
    \                           Table 5: NSH Version\n"
- title: 9.1.3.  NSH MD Types
  contents:
  - "9.1.3.  NSH MD Types\n   IANA has set up the \"NSH MD Types\" registry, which\
    \ contains 4-bit\n   values.  MD Type values 0x0, 0x1, 0x2, and 0xF are specified\
    \ in this\n   document; see Table 6.  Registry entries are assigned via the \"\
    IETF\n   Review\" policy defined in RFC 8126 [RFC8126].\n                +-----------+-----------------+-----------+\n\
    \                | MD Type   | Description     | Reference |\n               \
    \ +-----------+-----------------+-----------+\n                | 0x0       | Reserved\
    \        | RFC 8300  |\n                |           |                 |      \
    \     |\n                | 0x1       | NSH MD Type 1   | RFC 8300  |\n       \
    \         |           |                 |           |\n                | 0x2 \
    \      | NSH MD Type 2   | RFC 8300  |\n                |           |        \
    \         |           |\n                | 0x3 - 0xE | Unassigned      |     \
    \      |\n                |           |                 |           |\n      \
    \          | 0xF       | Experimentation | RFC 8300  |\n                +-----------+-----------------+-----------+\n\
    \                          Table 6: MD Type Values\n"
- title: 9.1.4.  NSH MD Class
  contents:
  - "9.1.4.  NSH MD Class\n   IANA has set up the \"NSH MD Class\" registry, which\
    \ contains 16-bit\n   values.  New allocations are to be made according to the\
    \ following\n   policies:\n   0x0000 to 0x01ff: IETF Review\n   0x0200 to 0xfff5:\
    \ Expert Review\n   IANA has assigned the values as follows:\n        +------------------+------------------------+------------+\n\
    \        | Value            | Meaning                | Reference  |\n        +------------------+------------------------+------------+\n\
    \        | 0x0000           | IETF Base NSH MD Class | RFC 8300   |\n        |\
    \                  |                        |            |\n        | 0xfff6 to\
    \ 0xfffe | Experimental           | RFC 8300   |\n        |                  |\
    \                        |            |\n        | 0xffff           | Reserved\
    \               | RFC 8300   |\n        +------------------+------------------------+------------+\n\
    \                           Table 7: NSH MD Class\n   A registry for Types for\
    \ the MD Class of 0x0000 is defined in\n   Section 9.1.5.\n   Designated Experts\
    \ evaluating new allocation requests from the\n   \"Expert Review\" range should\
    \ principally consider whether a new MD\n   class is needed compared to adding\
    \ MD Types to an existing class.\n   The Designated Experts should also encourage\
    \ the existence of an\n   associated and publicly visible registry of MD Types\
    \ although this\n   registry need not be maintained by IANA.\n   When evaluating\
    \ a request for an allocation, the Expert should verify\n   that the allocation\
    \ plan includes considerations to handle privacy\n   and security issues associated\
    \ with the anticipated individual MD\n   Types allocated within this class.  These\
    \ plans should consider, when\n   appropriate, alternatives such as indirection,\
    \ encryption, and\n   limited-deployment scenarios.  Information that can't be\
    \ directly\n   derived from viewing the packet contents should be examined for\n\
    \   privacy and security implications.\n"
- title: 9.1.5.  NSH IETF-Assigned Optional Variable-Length Metadata Types
  contents:
  - "9.1.5.  NSH IETF-Assigned Optional Variable-Length Metadata Types\n   The Type\
    \ values within the IETF Base NSH MD Class, i.e., when the MD\n   Class is set\
    \ to 0x0000 (see Section 9.1.4), are the Types owned by\n   the IETF.  Per this\
    \ document, IANA has created a registry for the\n   Type values for the IETF Base\
    \ NSH MD Class called the \"NSH IETF-\n   Assigned Optional Variable-Length Metadata\
    \ Types\" registry, as\n   specified in Section 2.5.1.\n   The type values are\
    \ assigned via Standards Action [RFC8126].\n   No initial values are assigned\
    \ at the creation of the registry.\n"
- title: 9.1.6.  NSH Next Protocol
  contents:
  - "9.1.6.  NSH Next Protocol\n   IANA has set up the \"NSH Next Protocol\" registry,\
    \ which contains\n   8-bit values.  Next Protocol values 0, 1, 2, 3, 4, and 5\
    \ are defined\n   in this document (see Table 8).  New values are assigned via\
    \ \"Expert\n   Review\" as per [RFC8126].\n               +---------------+--------------+-----------+\n\
    \               | Next Protocol | Description  | Reference |\n               +---------------+--------------+-----------+\n\
    \               | 0x00          | Unassigned   |           |\n               |\
    \               |              |           |\n               | 0x01          |\
    \ IPv4         | RFC 8300  |\n               |               |              |\
    \           |\n               | 0x02          | IPv6         | RFC 8300  |\n \
    \              |               |              |           |\n               |\
    \ 0x03          | Ethernet     | RFC 8300  |\n               |               |\
    \              |           |\n               | 0x04          | NSH          |\
    \ RFC 8300  |\n               |               |              |           |\n \
    \              | 0x05          | MPLS         | RFC 8300  |\n               |\
    \               |              |           |\n               | 0x06 - 0xFD   |\
    \ Unassigned   |           |\n               |               |              |\
    \           |\n               | 0xFE          | Experiment 1 | RFC 8300  |\n \
    \              |               |              |           |\n               |\
    \ 0xFF          | Experiment 2 | RFC 8300  |\n               +---------------+--------------+-----------+\n\
    \               Table 8: NSH Base Header Next Protocol Values\n   Expert Review\
    \ requests MUST include a single codepoint per request.\n   Designated Experts\
    \ evaluating new allocation requests from this\n   registry should consider the\
    \ potential scarcity of codepoints for an\n   8-bit value, and check both for\
    \ duplications and availability of\n   documentation.  If the actual assignment\
    \ of the Next Protocol field\n   allocation reaches half of the range (that is,\
    \ when there are 128\n   unassigned values), IANA needs to alert the IESG.  At\
    \ that point, a\n   new more strict allocation policy SHOULD be considered.\n"
- title: 10.  NSH-Related Codepoints
  contents:
  - '10.  NSH-Related Codepoints

    '
- title: 10.1.  NSH Ethertype
  contents:
  - "10.1.  NSH Ethertype\n   An IEEE Ethertype, 0x894F, has been allocated for NSH.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC7665]  Halpern, J., Ed. and C. Pignataro, Ed., \"Service Function\n  \
    \            Chaining (SFC) Architecture\", RFC 7665,\n              DOI 10.17487/RFC7665,\
    \ October 2015,\n              <https://www.rfc-editor.org/info/rfc7665>.\n  \
    \ [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n        \
    \      Writing an IANA Considerations Section in RFCs\", BCP 26,\n           \
    \   RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [NSH-BROADBAND-ALLOCATION]\n              Napper,\
    \ J., Kumar, S., Muley, P., Henderickx, W., and M.\n              Boucadair, \"\
    NSH Context Header Allocation -- Broadband\",\n              Work in Progress,\
    \ draft-napper-sfc-nsh-broadband-\n              allocation-04, November 2017.\n\
    \   [NSH-DC-ALLOCATION]\n              Guichard, J., Smith, M., Kumar, S., Majee,\
    \ S., Agarwal,\n              P., Glavin, K., Laribi, Y., and T. Mizrahi, \"Network\n\
    \              Service Header (NSH) MD Type 1: Context Header Allocation\n   \
    \           (Data Center)\", Work in Progress,\n              draft-guichard-sfc-nsh-dc-allocation-07,\
    \ August 2017.\n   [NSH-ENCRYPT]\n              Reddy, T., Patil, P., Fluhrer,\
    \ S., and P. Quinn,\n              \"Authenticated and encrypted NSH service chains\"\
    , Work in\n              Progress, draft-reddy-sfc-nsh-encrypt-00, April 2015.\n\
    \   [PROOF-OF-TRANSIT]\n              Brockners, F., Bhandari, S., Dara, S., Pignataro,\
    \ C.,\n              Leddy, J., Youell, S., Mozes, D., and T. Mizrahi, \"Proof\n\
    \              of Transit\", Work in Progress, draft-brockners-proof-\n      \
    \        of-transit-04, October 2017.\n   [RFC2784]  Farinacci, D., Li, T., Hanks,\
    \ S., Meyer, D., and P.\n              Traina, \"Generic Routing Encapsulation\
    \ (GRE)\", RFC 2784,\n              DOI 10.17487/RFC2784, March 2000,\n      \
    \        <https://www.rfc-editor.org/info/rfc2784>.\n   [RFC3552]  Rescorla, E.\
    \ and B. Korver, \"Guidelines for Writing RFC\n              Text on Security\
    \ Considerations\", BCP 72, RFC 3552,\n              DOI 10.17487/RFC3552, July\
    \ 2003,\n              <https://www.rfc-editor.org/info/rfc3552>.\n   [RFC3692]\
    \  Narten, T., \"Assigning Experimental and Testing Numbers\n              Considered\
    \ Useful\", BCP 82, RFC 3692,\n              DOI 10.17487/RFC3692, January 2004,\n\
    \              <https://www.rfc-editor.org/info/rfc3692>.\n   [RFC6071]  Frankel,\
    \ S. and S. Krishnan, \"IP Security (IPsec) and\n              Internet Key Exchange\
    \ (IKE) Document Roadmap\", RFC 6071,\n              DOI 10.17487/RFC6071, February\
    \ 2011,\n              <https://www.rfc-editor.org/info/rfc6071>.\n   [RFC6291]\
    \  Andersson, L., van Helvoort, H., Bonica, R., Romascanu,\n              D.,\
    \ and S. Mansfield, \"Guidelines for the Use of the \"OAM\"\n              Acronym\
    \ in the IETF\", BCP 161, RFC 6291,\n              DOI 10.17487/RFC6291, June\
    \ 2011,\n              <https://www.rfc-editor.org/info/rfc6291>.\n   [RFC7325]\
    \  Villamizar, C., Ed., Kompella, K., Amante, S., Malis, A.,\n              and\
    \ C. Pignataro, \"MPLS Forwarding Compliance and\n              Performance Requirements\"\
    , RFC 7325, DOI 10.17487/RFC7325,\n              August 2014, <https://www.rfc-editor.org/info/rfc7325>.\n\
    \   [RFC7498]  Quinn, P., Ed. and T. Nadeau, Ed., \"Problem Statement for\n  \
    \            Service Function Chaining\", RFC 7498,\n              DOI 10.17487/RFC7498,\
    \ April 2015,\n              <https://www.rfc-editor.org/info/rfc7498>.\n   [RFC7676]\
    \  Pignataro, C., Bonica, R., and S. Krishnan, \"IPv6 Support\n              for\
    \ Generic Routing Encapsulation (GRE)\", RFC 7676,\n              DOI 10.17487/RFC7676,\
    \ October 2015,\n              <https://www.rfc-editor.org/info/rfc7676>.\n  \
    \ [RFC8165]  Hardie, T., \"Design Considerations for Metadata\n              Insertion\"\
    , RFC 8165, DOI 10.17487/RFC8165, May 2017,\n              <https://www.rfc-editor.org/info/rfc8165>.\n\
    \   [RFC8201]  McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,\n     \
    \         \"Path MTU Discovery for IP version 6\", STD 87, RFC 8201,\n       \
    \       DOI 10.17487/RFC8201, July 2017,\n              <https://www.rfc-editor.org/info/rfc8201>.\n\
    \   [RTG-ENCAP]\n              Nordmark, E., Tian, A., Gross, J., Hudson, J.,\
    \ Kreeger,\n              L., Garg, P., Thaler, P., and T. Herbert, \"Encapsulation\n\
    \              Considerations\", Work in Progress,\n              draft-ietf-rtgwg-dt-encap-02,\
    \ October 2016.\n   [SFC-CONTROL-PLANE]\n              Boucadair, M., \"Service\
    \ Function Chaining (SFC) Control\n              Plane Components & Requirements\"\
    , Work in Progress,\n              draft-ietf-sfc-control-plane-08, October 2016.\n\
    \   [SFC-OAM-FRAMEWORK]\n              Aldrin, S., Pignataro, C., Kumar, N., Akiya,\
    \ N., Krishnan,\n              R., and A. Ghanwani, \"Service Function Chaining\
    \ (SFC)\n              Operation, Administration and Maintenance (OAM)\n     \
    \         Framework\", Work in Progress,\n              draft-ietf-sfc-oam-framework-03,\
    \ September 2017.\n   [VXLAN-GPE]\n              Maino, F., Kreeger, L., and U.\
    \ Elzur, \"Generic Protocol\n              Extension for VXLAN\", Work in Progress,\n\
    \              draft-ietf-nvo3-vxlan-gpe-05, October 2017.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors would like to thank Sunil Vallamkonda, Nagaraj\
    \ Bagepalli,\n   Abhijit Patra, Peter Bosch, Darrel Lewis, Pritesh Kothari, Tal\n\
    \   Mizrahi, and Ken Gray for their detailed reviews, comments, and\n   contributions.\n\
    \   A special thank you goes to David Ward and Tom Edsall for their\n   guidance\
    \ and feedback.\n   Additionally, the authors would like to thank Larry Kreeger\
    \ for his\n   invaluable ideas and contributions, which are reflected throughout\n\
    \   this document.\n   Loa Andersson provided a thorough review and valuable comments;\
    \ we\n   thank him for that.\n   Reinaldo Penno deserves a particular thank you\
    \ for his architecture\n   and implementation work that helped guide the protocol\
    \ concepts and\n   design.\n   The editors also acknowledge comprehensive reviews\
    \ and respective\n   useful suggestions by Med Boucadair, Adrian Farrel, Juergen\n\
    \   Schoenwaelder, Acee Lindem, and Kathleen Moriarty.\n   Lastly, David Dolson\
    \ has provided significant review, feedback, and\n   suggestions throughout the\
    \ evolution of this document.  His\n   contributions are very much appreciated.\n"
- title: Contributors
  contents:
  - "Contributors\n   This WG document originated as draft-quinn-sfc-nsh; the following\
    \ are\n   its coauthors and contributors along with their respective\n   affiliations\
    \ at the time of WG adoption.  The editors of this\n   document would like to\
    \ thank and recognize them and their\n   contributions.  These coauthors and contributors\
    \ provided invaluable\n   concepts and content for this document's creation.\n\
    \   o  Jim Guichard, Cisco Systems, Inc.\n   o  Surendra Kumar, Cisco Systems,\
    \ Inc.\n   o  Michael Smith, Cisco Systems, Inc.\n   o  Wim Henderickx, Alcatel-Lucent\n\
    \   o  Tom Nadeau, Brocade\n   o  Puneet Agarwal\n   o  Rajeev Manur, Broadcom\n\
    \   o  Abhishek Chauhan, Citrix\n   o  Joel Halpern, Ericsson\n   o  Sumandra\
    \ Majee, F5\n   o  David Melman, Marvell\n   o  Pankaj Garg, Microsoft\n   o \
    \ Brad McConnell, Rackspace\n   o  Chris Wright, Red Hat, Inc.\n   o  Kevin Glavin,\
    \ Riverbed\n   o  Hong (Cathy) Zhang, Huawei US R&D\n   o  Louis Fourie, Huawei\
    \ US R&D\n   o  Ron Parker, Affirmed Networks\n   o  Myo Zarny, Goldman Sachs\n\
    \   o  Andrew Dolganow, Alcatel-Lucent\n   o  Rex Fernando, Cisco Systems, Inc.\n\
    \   o  Praveen Muley, Alcatel-Lucent\n   o  Navindra Yadav, Cisco Systems, Inc.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Paul Quinn (editor)\n   Cisco Systems, Inc.\n   Email:\
    \ paulq@cisco.com\n   Uri Elzur (editor)\n   Intel\n   Email: uri.elzur@intel.com\n\
    \   Carlos Pignataro (editor)\n   Cisco Systems, Inc.\n   Email: cpignata@cisco.com\n"
