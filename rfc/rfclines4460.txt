Abstract This document is a compilation of issues found during six interoperability events and 5 years of experience with implementing, testing, and using Stream Control Transmission Protocol (SCTP) along with the suggested fixes.
This document provides deltas to RFC 2960 and is organized in a time based way.
The issues are listed in the order they were brought up.
Because some text is changed several times, the last delta in the text is the one that should be applied.
In addition to the delta, a description of the problem and the details of the solution are also provided.
This document contains a compilation of all defects found up until the publishing of this document for the Stream Control Transmission Protocol (SCTP), RFC 2960 [5].
These defects may be of an editorial or technical nature.
This document may be thought of as a companion document to be used in the implementation of SCTP to clarify errors in the original SCTP document.
This document provides a history of the changes that will be compiled into RFC 2960's [5] BIS document.
Each error will be detailed within this document in the form of  the problem description,  the text quoted from RFC 2960 [5],  the replacement text that should be placed into the BIS document, and  a description of the solution.
This document is a historical record of sequential changes what have been found necessary at various interop events and through discussion on this list.
Note that because some text is changed several times, the last delta for a text in the document is the erratum for that text in RFC 2960.
The keywords MUST, MUST NOT, REQUIRED, SHALL,
SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL
, when they appear in this document, are to be interpreted as described in RFC 2119 [2].
Corrections to RFC 2960 2.1.
Incorrect Error Type During Chunk Processing.
A typo was discovered in RFC 2960 [5] that incorrectly specifies an action to be taken when processing chunks of unknown identity.
Text changes to the document   Old text:
Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
New text: (Section 3.2)   01
Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized chunk in an 'Unrecognized Chunk Type'.
The receiver of an unrecognized chunk should not send a 'parameter' error but instead should send the appropriate chunk error as described above.
A typographical error was introduced through an improper cut and paste in the use of the upper two bits to describe proper handling of unknown parameters.
Text Changes to the Document
Stop processing this SCTP packet and discard it; do not process any further chunks within it.
Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
New text: (Section 3.2.1)   00
Stop processing this SCTP chunk and discard it, do not process any further parameters within this chunk.
Stop processing this SCTP chunk and discard it, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
It was always the intent to stop processing at the level one was at in an unknown chunk or parameter with the upper bit set to 0.
Thus, if you are processing a chunk, you should drop the packet.
If you are processing a parameter, you should drop the chunk.
A problem was found when a Chunk terminated in a TLV parameter.
If this last TLV was not on a 32 bit boundary (as required), there was confusion as to whether the last padding was included in the chunk length.
Text Changes to the Document
(Section 3.2)   Chunk Length: 16 bits (unsigned integer)
This value represents the size of the chunk in bytes including the Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields.
Therefore, if the Chunk Value field is zero length, the Length field will be set to 4.
The Chunk Length field does not count any padding.
The Chunk Value field contains the actual information to be transferred in the chunk.
The usage and format of this field is dependent on the Chunk Type.
The total length of a chunk (including Type, Length and Value fields) MUST be a multiple of 4 bytes.
If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes and this padding is not included in the chunk length field.
The sender should never pad with more than 3 bytes.
The receiver MUST ignore the padding bytes.
New text: (Section 3.2)   Chunk Length: 16 bits (unsigned integer)
This value represents the size of the chunk in bytes, including the Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields.
Therefore, if the Chunk Value field is zero length, the Length field will be set to 4.
The Chunk Length field does not count any chunk padding.
Chunks (including Type, Length, and Value fields) are padded out by the sender with all zero bytes to be a multiple of 4 bytes long.
This padding MUST NOT be more than 3 bytes in total.
The Chunk Length value does not include terminating padding of the chunk.
However, it does include padding of any variable length parameter except the last parameter in the chunk.
The receiver MUST ignore the padding.
Note: A robust implementation should accept the Chunk whether or not the final padding has been included in the Chunk Length.
The Chunk Value field contains the actual information to be transferred in the chunk.
The usage and format of this field is dependent on the Chunk Type.
The total length of a chunk (including Type, Length, and Value fields) MUST be a multiple of 4 bytes.
If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes, and this padding is not included in the chunk length field.
The sender should never pad with more than 3 bytes.
The receiver MUST ignore the padding bytes.
The above text makes clear that the padding of the last parameter is not included in the Chunk Length field.
It also clarifies that the padding of parameters that are not the last one must be counted in the Chunk Length field.
Parameter Types across All Chunk Types 2.4.1.
A problem was noted when multiple errors are needed to be sent regarding unknown or unrecognized parameters.
Since often the error type does not hold the chunk type field, it may become difficult to tell which error was associated with which chunk.
Text Changes to the Document
The actual SCTP parameters are defined in the specific SCTP chunk sections.
The rules for IETF defined parameter extensions are defined in Section 13.2.
The actual SCTP parameters are defined in the specific SCTP chunk sections.
The rules for IETF defined parameter extensions are defined in Section 13.2.
Note that a parameter type MUST be unique across all chunks.
For example, the parameter type '5' is used to represent an IPv4 address (see Section 3.3.2).
The value '5' then is reserved across all chunks to represent an IPv4 address and MUST NOT be reused with a different meaning in any other chunk.
13.2 IETF defined Chunk Parameter Extension
The assignment of new chunk parameter type codes is done through an IETF Consensus action as defined in [RFC2434].
Documentation of the chunk parameter MUST contain the following information: a) Name of the parameter type.
Detailed description of the structure of the parameter field.
This structure MUST conform to the general type length value format described in Section 3.2.1.
Detailed definition of each component of the parameter type.
Detailed description of the intended use of this parameter type, and an indication of whether and under what circumstances multiple instances of this parameter type may be found within the same chunk.
New text: (Section 13.2)   13.2.
IETF defined Chunk Parameter Extension
The assignment of new chunk parameter type codes is done through an IETF Consensus action, as defined in [RFC2434].
Documentation of the chunk parameter MUST contain the following information: a) Name of the parameter type.
Detailed description of the structure of the parameter field.
This structure MUST conform to the general type length value format described in Section 3.2.1.
Detailed definition of each component of the parameter type.
Detailed description of the intended use of this parameter type, and an indication of whether and under what circumstances multiple instances of this parameter type may be found within the same chunk.
Each parameter type MUST be unique across all chunks.
By having all parameters unique across all chunk assignments (the current assignment policy), no ambiguity exists as to what a parameter means in different contexts.
The trade off for this is a smaller parameter space, i.e., 65,536 parameters versus 65,536   Number of  chunks.
Description of the problem A problem was found where the specification is unclear on the legality of an endpoint asking for more stream resources than were allowed in the MIS value of the INIT.
In particular, the value in the INIT ACK requested in its OS value was larger than the MIS value received in the INIT chunk.
This behavior is illegal, yet it was unspecified in RFC 2960
Text Changes to the Document
Old text: (Section 3.3.3)   Number of Outbound Streams (OS):  16 bits (unsigned integer)
Defines the number of outbound streams the sender of this INIT ACK chunk wishes to create in this association.
The value of 0 MUST NOT be used.
Note: A receiver of an INIT ACK with the OS value set to 0 SHOULD destroy the association discarding its TCB.
New text: (Section 3.3.3)   Number of Outbound Streams (OS): 16 bits (unsigned integer)
Defines the number of outbound streams the sender of this INIT ACK chunk wishes to create in this association.
The value of 0 MUST NOT be used, and the value MUST NOT be greater than the MIS value sent in the INIT chunk.
Note: A receiver of an INIT ACK with the OS value set to 0 SHOULD destroy the association, discarding its TCB.
The change in wording, above, changes it so that a responder to an INIT chunk does not specify more streams in its OS value than were represented to it in the MIS value, i.e., its maximum.
Restarting Association Security Issue 2.6.1.
A security problem was found when a restart occurs.
It is possible for an intruder to send an INIT to an endpoint of an existing association.
In the INIT the intruder would list one or more of the current addresses of an association and its own.
The normal restart procedures would then occur, and the intruder would have hijacked an association.
Text Changes to the Document
Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause Specific Information fields
Cause specific Information: variable length This field carries the details of the error condition.
Sections 3.3.10.1 3.3.10.10 define error causes for SCTP.
Guidelines for the IETF to define new error cause values are discussed in Section 13.3.
New text: (Section 3.3.10)   Cause Code Value
Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause Specific Information fields.
Cause specific Information: variable length This field carries the details of the error condition.
Sections 3.3.10.1 3.3.10.11 define error causes for SCTP.
Guidelines for the IETF to define new error cause values are discussed in Section 13.3.
(Note no old text, new error cause added in section 3.3.10)
Restart of an Association with New Addresses
(11) Cause of error   Restart of an association with new addresses
: An INIT was received on an existing association.
But the INIT added addresses to the association that were previously NOT part of the association.
The new addresses are listed in the error code.
This ERROR is normally sent as part of an ABORT refusing the INIT (see Section 5.2).
: Each New Address TLV is an exact copy of the TLV that was found in the INIT chunk that was new, including the Parameter Type and the Parameter length.
Old text: (Section 5.2.1)   Upon receipt of an INIT in the COOKIE WAIT or COOKIE ECHOED state
, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiation Tag, unchanged).
These original parameters are combined with those from the newly received INIT chunk.
The endpoint shall also generate a State Cookie with the INIT ACK.
The endpoint uses the parameters sent in its INIT to calculate the State Cookie.
(Section 5.2.1)   Upon receipt of an INIT in the COOKIE WAIT state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiation Tag, unchanged).
When responding, the endpoint MUST send the INIT ACK back to the same address that the original INIT (sent by this endpoint) was sent to.
Upon receipt of an INIT in the COOKIE ECHOED state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiation Tag, unchanged), provided that no NEW address has been added to the forming association.
If the INIT message indicates that a new address has been added to the association, then the entire INIT MUST be discarded, and NO changes should be made to the existing association.
An ABORT SHOULD be sent in response that MAY include the error 'Restart of an association with new addresses'.
The error SHOULD list the addresses that were added to the restarting association.
When responding in either state (COOKIE WAIT or COOKIE ECHOED) with an INIT ACK, the original parameters are combined with those from the newly received INIT chunk.
The endpoint shall also generate a State Cookie with the INIT ACK.
The endpoint uses the parameters sent in its INIT to calculate the State Cookie.
Old text: (Section 5.2.2)   5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE ECHOED, COOKIE WAIT and SHUTDOWN
Unless otherwise stated, upon reception of an unexpected INIT for this association, the endpoint shall generate an INIT ACK with a State Cookie.
In the outbound INIT ACK the endpoint MUST copy its current Verification Tag and peer's Verification Tag into a reserved place within the state cookie.
We shall refer to these locations as the Peer's Tie Tag and the Local Tie Tag.
The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT.
And the INIT ACK MUST contain a new Initiation Tag (randomly generated see Section 5.3.1).
Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.
After sending out the INIT ACK, the endpoint shall take no further actions, i.e., the existing association, including its current state, and the corresponding TCB MUST NOT be changed.
Note: Only when a TCB exists and the association is not in a COOKIE
WAIT state are the Tie Tags populated.
For a normal association INIT (i.e., the endpoint is in a COOKIE WAIT state), the Tie Tags MUST be set to 0 (indicating that no previous TCB existed).
The INIT ACK and State Cookie are populated as specified in section 5.2.1.
New text: (Section 5.2.2)   5.2.2.
Other Than CLOSED, COOKIE ECHOED, COOKIE WAIT, and SHUTDOWN
Unless otherwise stated, upon receipt of an unexpected INIT for this association, the endpoint shall generate an INIT ACK with a State Cookie.
Before responding, the endpoint MUST check to see if the unexpected INIT adds new addresses to the association.
If new addresses are added to the association, the endpoint MUST respond with an ABORT, copying the 'Initiation Tag' of the unexpected INIT into the 'Verification Tag' of the outbound packet carrying the ABORT.
In the ABORT response, the cause of error MAY be set to 'restart of an association with new addresses'.
The error SHOULD list the addresses that were added to the restarting association.
If no new addresses are added, when responding to the INIT in the outbound INIT ACK, the endpoint MUST copy its current Verification Tag and peer's Verification Tag into a reserved place within the state cookie.
We shall refer to these locations as the Peer's Tie  Tag and the Local Tie Tag.
The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT.
And the INIT ACK MUST contain a new Initiation Tag (randomly generated; see Section 5.3.1).
Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.
After sending out the INIT ACK or ABORT, the endpoint shall take no further actions; i.e., the existing association, including its current state, and the corresponding TCB MUST NOT be changed.
Note: Only when a TCB exists and the association is not in a COOKIE
ACK SENT state are the Tie Tags populated with a value other than 0.
For a normal association INIT (i.e., the endpoint is in the CLOSED state), the Tie Tags MUST be set to 0 (indicating that no previous TCB existed).
A new error code is being added, along with specific instructions to send back an ABORT to a new association in a restart case or collision case, where new addresses have been added.
The error code can be used by a legitimate restart to inform the endpoint that it has made a software error in adding a new address.
The endpoint then can choose to wait until the OOTB ABORT tears down the old association, or to restart without the new address.
Also, the note at the end of Section 5.2.2 explaining the use of the Tie Tags was modified to properly explain the states in which the Tie Tags should be set to a value different than 0.
Implicit Ability to Exceed cwnd by PMTU 1 Bytes 2.7.1.
Some implementations were having difficulty growing their cwnd.
This was due to an improper enforcement of the congestion control rules.
The rules, as written, provided for a slop over of the cwnd value.
Without this slop over, the sender would appear NOT to be using its full cwnd value and thus would never increase it.
Text Changes to the Document
Old text: (Section 6.1)   B)
At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd or more bytes of data outstanding to that transport address.
New text: (Section 6.1)   B)
At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd or more bytes of data outstanding to that transport address.
The sender may exceed cwnd by up to (PMTU 1) bytes on a new transmission if the cwnd is not currently exceeded.
The text changes make clear the ability to go over the cwnd value by no more than (PMTU 1) bytes.
Issues with Fast Retransmit 2.8.1.
Several problems were found in the current specification of fast retransmit.
The current wording did not require GAP ACK blocks to be sent, even though they are essential to the workings of SCTP's congestion control.
The specification left unclear how to handle the fast retransmit cycle, having the implementation wait on the cwnd to retransmit a TSN that was marked for fast retransmit.
No limit was placed on how many times a TSN could be fast retransmitted.
Fast Recovery was not specified, causing the congestion window to be reduced drastically when there are multiple losses in a single RTT.
Text Changes to the Document
Acknowledgements MUST be sent in SACK chunks unless shutdown was requested by the ULP in which case an endpoint MAY send an acknowledgement in the SHUTDOWN chunk.
A SACK chunk can acknowledge the reception of multiple DATA chunks.
See Section 3.3.4 for SACK chunk format.
In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to indicate the latest sequential TSN (of a valid DATA chunk) it has received.
Any received DATA chunks with TSN greater than the value in the Cumulative TSN Ack field SHOULD also be reported in the Gap Ack Block fields.
Acknowledegments MUST be sent in SACK chunks unless shutdown was requested by the ULP, in which case an endpoint MAY send an acknowledgement in the SHUTDOWN chunk.
A SACK chunk can acknowledge the reception of multiple DATA chunks.
See Section 3.3.4 for SACK chunk format.
In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to indicate the latest sequential TSN (of a valid DATA chunk) it has received.
Any received DATA chunks with TSN greater than the value in the Cumulative TSN Ack field are reported in the Gap Ack Block fields.
The SCTP endpoint MUST report as many Gap Ack Blocks as can fit in a single SACK chunk limited by the current path MTU.
Old text: (Section 6.2.1)   D)
Any time a SACK arrives, the endpoint performs the following: i)
If Cumulative TSN Ack is less than the Cumulative TSN Ack Point, then drop the SACK.
Since Cumulative TSN Ack is monotonically increasing, a SACK whose Cumulative TSN Ack is less than the Cumulative TSN Ack Point indicates an out of  order SACK.
Set rwnd equal to the newly received a rwnd minus the number of bytes still outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.
If the SACK is missing a TSN that was previously acknowledged via a Gap Ack Block (e.g., the data receiver reneged on the data), then mark the corresponding DATA chunk as available for retransmit:
Mark it as missing for fast retransmit as described in Section 7.2.4 and if no retransmit timer is running for the destination address to which the DATA chunk was originally transmitted, then T3 rtx is started for that destination address.
New text: (Section 6.2.1)   D)
Any time a SACK arrives, the endpoint performs the following: i)
If Cumulative TSN Ack is less than the Cumulative TSN Ack Point, then drop the SACK.
Since Cumulative TSN Ack is monotonically increasing, a SACK whose Cumulative TSN Ack is less than the Cumulative TSN Ack Point indicates an out of  order SACK.
Set rwnd equal to the newly received a rwnd minus the number of bytes still outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.
If the SACK is missing a TSN that was previously acknowledged via a Gap Ack Block (e.g., the data receiver reneged on the data), then consider the corresponding DATA that might be possibly missing:
Count one miss indication towards fast retransmit as described in Section 7.2.4, and if no retransmit timer is running for the destination address to which the DATA chunk was originally transmitted, then T3 rtx is started for that destination address.
If the Cumulative TSN Ack matches or exceeds the Fast Recovery exitpoint (Section 7.2.4), Fast Recovery is exited.
Whenever an endpoint receives a SACK that indicates some TSN(s) missing, it SHOULD wait for 3 further miss indications (via subsequent SACK's) on the same TSN(s) before taking action with regard to Fast Retransmit.
When the TSN(s) is reported as missing in the fourth consecutive SACK,
the data sender shall: 1) Mark the missing DATA chunk(s) for retransmission, 2)
Adjust the ssthresh and cwnd of the destination address(es) to which the missing DATA chunks were last sent, according to the formula described in Section 7.2.3.
3) Determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the path MTU of the destination transport address to which the packet is being sent.
Call this value K.  Retransmit
those K DATA chunks in a single packet.
Restart T3 rtx timer only if the last SACK acknowledged the lowest outstanding TSN number sent to that address, or
the endpoint is retransmitting the first outstanding DATA chunk sent to that address.
Before the above adjustments, if the received SACK also acknowledges new DATA chunks and advances the Cumulative TSN Ack Point, the cwnd adjustment rules defined in Sections 7.2.1 and 7.2.2 must be applied first.
A straightforward implementation of the above keeps a counter for each TSN hole reported by a SACK.
The counter increments for each consecutive SACK reporting the TSN hole.
After reaching 4 and starting the fast retransmit procedure, the counter resets to 0.
Because cwnd in SCTP indirectly bounds the number of outstanding TSN's, the effect of TCP fast recovery is achieved automatically with no adjustment to the congestion control window size.
Whenever an endpoint receives a SACK that indicates that some TSNs are missing, it SHOULD wait for 3 further miss indications (via subsequent SACKs) on the same TSN(s) before taking action with regard to Fast Retransmit.
Miss indications SHOULD follow the HTNA (Highest TSN Newly Acknowledged)
For each incoming SACK, miss indications are incremented only for missing TSNs prior to the highest TSN newly acknowledged in the SACK.
A newly acknowledged DATA chunk is one not previously acknowledged in a SACK.
If an endpoint is in Fast Recovery and a SACK arrives that advances the Cumulative TSN Ack Point, the miss indications are incremented for all TSNs reported missing in the SACK.
When the fourth consecutive miss indication is received for a TSN(s), the data sender shall do the following: 1)
Mark the DATA chunk(s) with four miss indications for retransmission.
If not in Fast Recovery, adjust the ssthresh and cwnd of the destination address(es) to which the missing DATA chunks were last sent, according to the formula described in Section 7.2.3.
3) Determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the path MTU of the destination transport address to which the packet is being sent.
Call this value K.  Retransmit
those K DATA chunks in a single packet.
When a Fast Retransmit is being performed, the sender SHOULD ignore the value of cwnd and SHOULD NOT delay retransmission for this single packet.
Restart T3 rtx timer only if the last SACK acknowledged the lowest outstanding TSN number sent to that address, or
the endpoint is retransmitting the first outstanding DATA chunk sent to that address.
5) Mark the DATA chunk(s) as being fast retransmitted and thus ineligible for a subsequent fast retransmit.
Those TSNs marked for retransmission due to the Fast Retransmit algorithm that did not fit in the sent datagram carrying K other TSNs are also marked as ineligible for a subsequent fast retransmit.
However, as they are marked for retransmission they will be retransmitted later on as soon as cwnd allows.
If not in Fast Recovery, enter Fast Recovery and mark the highest outstanding TSN as the Fast Recovery exit point.
When a SACK acknowledges all TSNs up to and including this exit point, Fast Recovery is exited.
While in Fast Recovery, the ssthresh and cwnd SHOULD NOT change for any destinations due to a subsequent Fast Recovery event (i.e., one SHOULD NOT reduce the cwnd further due to a subsequent fast retransmit).
Note: Before the above adjustments, if the received SACK also acknowledges new DATA chunks and advances the Cumulative TSN Ack Point, the cwnd adjustment rules defined in Sections 7.2.1 and 7.2.2 must be applied first.
The effect of the above wording changes are as follows:
It requires with a MUST the sending of GAP Ack blocks instead of the current RFC 2960
It allows a TSN being Fast Retransmitted (FR) to be sent only once via FR.
It ends the delay in waiting for the flight size to drop when a TSN is identified as being ready to FR.
It changes the way chunks are marked during fast retransmit, so that only new reports are counted.
It introduces a Fast Recovery period to avoid multiple congestion window reductions when there are multiple losses in a single RTT (as shown by Caro et al.
These changes will effectively allow SCTP to follow a similar model as TCP SACK in the handling of Fast Retransmit.
Missing Statement about partial bytes acked Update 2.9.1.
Description of the Problem SCTP uses four control variables to regulate its transmission rate: rwnd, cwnd, ssthresh, and partial bytes acked.
Upon detection of packet losses from SACK, or when the T3 rtx timer expires on an address, cwnd and ssthresh should be updated as stated in Section 7.2.3.
However, that section should also clarify that partial bytes acked must be updated as well; it has to be reset to 0.
Text Changes to the Document
Old text: (Section 7.2.3)   7.2.3 Congestion Control Upon detection of packet losses from SACK
(see Section 7.2.4), An endpoint should do the following: ssthresh   max(cwnd/2, 2 MTU)
Basically, a packet loss causes cwnd to be cut in half.
When the T3 rtx timer expires on an address, SCTP should perform slow start by: ssthresh   max(cwnd/2, 2 MTU)
New text: (Section 7.2.3)   7.2.3.
Upon detection of packet losses from SACK
(see Section 7.2.4), an endpoint should do the following if not in Fast Recovery:
cwnd   ssthresh partial bytes acked   0
Basically, a packet loss causes cwnd to be cut in half.
When the T3 rtx timer expires on an address, SCTP should perform slow start by ssthresh   max(cwnd/2, 2 MTU)
cwnd   1 MTU partial bytes acked   0 2.9.3.
The missing text added solves the doubts about what to do with partial bytes acked in the situations stated in Section 7.2.3, making clear that, along with ssthresh and cwnd, partial bytes acked should also be updated by being reset to 0.
Issues with Heartbeating and Failure Detection 2.10.1.
Five basic problems have been discovered with the current heartbeat procedures:
The current specification does not specify that you should count a failed heartbeat as an error against the overall association.
The current specification is not specific as to when you start sending heartbeats and when you should stop.
The current specification is not specific as to when you should respond to heartbeats.
When responding to a Heartbeat, it is unclear what to do if more than a single TLV is present.
The jitter applied to a heartbeat was meant to be a small variance of the RTO and is currently a wide variance, due to the default delay time and incorrect wording within the RFC.
Text Changes to the Document
Old text: (Section 8.1)   8.1 Endpoint Failure Detection
An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (including retransmissions to all the destination transport addresses of the peer if it is multi homed).
If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.
Retrans', the endpoint shall consider the peer endpoint unreachable and shall stop transmitting any more data to it (and thus the association enters the CLOSED state).
In addition, the endpoint shall report the failure to the upper layer, and optionally report back all outstanding user data remaining in its outbound queue.
The association is automatically closed when the peer endpoint becomes unreachable.
The counter shall be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK), or a HEARTBEAT ACK is received from the peer endpoint.
New text: (Section 8.1)   8.1.
An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (this includes retransmissions to all the destination transport addresses of the peer if it is multi homed), including unacknowledged HEARTBEAT Chunks.
If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.
Retrans', the endpoint shall consider the peer endpoint unreachable and shall stop transmitting any more data to it (and thus the association enters the CLOSED state).
In addition, the endpoint MAY report the failure to the upper layer and optionally report back all outstanding user data remaining in its outbound queue.
The association is automatically closed when the peer endpoint becomes unreachable.
The counter shall be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK), or a HEARTBEAT ACK is received from the peer endpoint.
Old text: (Section 8.3)   8.3 Path Heartbeat
By default, an SCTP endpoint shall monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es).
New text: (Section 8.3)   8.3 Path Heartbeat By default
, an SCTP endpoint SHOULD monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es).
HEARTBEAT sending MAY begin upon reaching the ESTABLISHED state and is discontinued after sending either SHUTDOWN or SHUTDOWN ACK.
A receiver of a HEARTBEAT MUST respond to a HEARTBEAT with a HEARTBEAT ACK after entering the COOKIE ECHOED state (INIT sender) or the ESTABLISHED state (INIT receiver), up until reaching the SHUTDOWN SENT state (SHUTDOWN sender) or the SHUTDOWN
ACK SENT state (SHUTDOWN receiver).
The receiver of the HEARTBEAT should immediately respond with a HEARTBEAT ACK that contains the Heartbeat Information field copied from the received HEARTBEAT chunk.
The receiver of the HEARTBEAT should immediately respond with a HEARTBEAT ACK that contains the Heartbeat Information TLV, together with any other received TLVs, copied unchanged from the received HEARTBEAT chunk.
The above text provides guidance as to how to respond to the five issues mentioned in Section 2.10.1.
In particular, the wording changes provide guidance as to when to start and stop heartbeating, how to respond to a heartbeat with extra parameters, and it clarifies the error counting procedures for the association.
Security interactions with firewalls 2.11.1.
Description of the Problem When dealing with firewalls, it is advantageous for the firewall to be able to properly determine the initial startup sequence of a reliable transport protocol.
With this in mind, the following text is to be added to SCTP's security section.
Text Changes to the Document
New text: (no old text, new section added)   11.4 SCTP Interactions with Firewalls
It is helpful for some firewalls if they can inspect just the first fragment of a fragmented SCTP packet and unambiguously determine whether it corresponds to an INIT chunk (for further information, please refer to RFC1858).
Accordingly, we stress the requirements, stated in 3.1, that (1) an INIT chunk MUST NOT be bundled with any other chunk in a packet, and (2) a packet containing an INIT chunk MUST have a zero Verification Tag.
Furthermore, we require that the receiver of an INIT chunk MUST enforce these rules by silently discarding an arriving packet with an INIT chunk that is bundled with other chunks.
ALLMAN99] Allman, M. and Paxson, V., "On Estimating End to End Network Path Properties", Proc.
Fall, K. and Floyd, S., Simulation based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp. 5 21.
[RFC1950]  Deutsch P. and J. Gailly, "ZLIB Compressed Data Format Specification version 3.3", RFC 1950, May 1996.
[RFC2104]  Krawczyk, H., Bellare, M. and R. Canetti, "HMAC:
Keyed  Hashing for Message Authentication", RFC 2104, March 1997.
[RFC2196]  Fraser, B., "Site Security Handbook", FYI 8, RFC 2196, September 1997.
[RFC2522]  Karn, P. and W. Simpson, "Photuris: Session Key Management Protocol", RFC 2522, March 1999.
[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., "TCP Congestion Control with a Misbehaving Receiver", ACM Computer Communication Review, 29(5), October 1999.
New text: (Section 18)   18.
ALLMAN99] Allman, M. and Paxson, V., "On Estimating End to End Network Path Properties", Proc.
Fall, K. and Floyd, S., Simulation based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp.
[RFC1858]  Ziemba, G., Reed, D. and Traina P., "Security Considerations for IP Fragment Filtering", RFC 1858, October 1995.
[RFC1950]  Deutsch P. and J. Gailly, "ZLIB Compressed Data Format Specification version 3.3", RFC 1950, May 1996.
[RFC2104]  Krawczyk, H., Bellare, M. and R. Canetti, "HMAC:  Keyed  Hashing for Message Authentication", RFC 2104, March 1997.
[RFC2196]  Fraser, B., "Site Security Handbook", FYI 8, RFC 2196, September 1997.
[RFC2522]  Karn, P. and W. Simpson, "Photuris: Session Key Management Protocol", RFC 2522, March 1999.
[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., "TCP Congestion Control with a Misbehaving Receiver", ACM Computer Communication Review, 29(5), October 1999.
The above text, which adds a new subsection to the Security Considerations section of RFC 2960 [5] makes clear that, to make easier the interaction with firewalls, an INIT chunk must not be bundled in any case with any other chunk that will silently discard the packets that do not follow this rule (this rule is enforced by the packet receiver).
Currently, there is an ambiguity between the statements in Sections 6.2 and 9.2.
Section 6.2 allows the sending of a SHUTDOWN chunk in place of a SACK when the sender is in the process of shutting down, while section 9.2 requires that both a SHUTDOWN chunk and a SACK chunk be sent.
Along with this ambiguity there is a problem wherein an errant SHUTDOWN receiver may fail to stop accepting user data.
Text Changes to the Document
If there are still outstanding DATA chunks left, the SHUTDOWN receiver shall continue to follow normal data transmission procedures defined in Section 6 until all outstanding DATA chunks are acknowledged; however, the SHUTDOWN receiver MUST NOT accept new data from its SCTP user.
While in SHUTDOWN SENT state, the SHUTDOWN sender MUST immediately respond to each received packet containing one or more DATA chunk(s) with a SACK, a SHUTDOWN chunk, and restart the T2 shutdown timer.
If it has no more outstanding DATA chunks, the SHUTDOWN receiver shall send a SHUTDOWN ACK and start a T2 shutdown timer of its own, entering the SHUTDOWN ACK SENT state.
If the timer expires, the endpoint must re send the SHUTDOWN ACK.
If there are still outstanding DATA chunks left, the SHUTDOWN receiver MUST continue to follow normal data transmission procedures defined in Section 6, until all outstanding DATA chunks are acknowledged; however, the SHUTDOWN receiver MUST NOT accept new data from its SCTP user.
While in SHUTDOWN SENT state, the SHUTDOWN sender MUST immediately respond to each received packet containing one or more DATA chunks with a SHUTDOWN chunk and restart the T2 shutdown timer.
If a SHUTDOWN chunk by itself cannot acknowledge all of the received DATA chunks (i.e., there are TSNs that can be acknowledged that are larger than the cumulative TSN, and thus gaps exist in the TSN sequence), or if duplicate TSNs have been received, then a SACK chunk MUST also be sent.
The sender of the SHUTDOWN MAY also start an overall guard timer 'T5 shutdown guard' to bound the overall time for shutdown sequence.
At the expiration of this timer, the sender SHOULD abort the association by sending an ABORT chunk.
If the 'T5 shutdown guard' timer is used, it SHOULD be set to the recommended value of 5 times 'RTO.Max'.
If the receiver of the SHUTDOWN has no more outstanding DATA chunks, the SHUTDOWN receiver MUST send a SHUTDOWN ACK and start a T2 shutdown timer of its own, entering the SHUTDOWN ACK SENT state.
If the timer expires, the endpoint must re send the SHUTDOWN ACK.
The above text clarifies the use of a SACK in conjunction with a SHUTDOWN chunk.
It also adds a guard timer to the SCTP shutdown sequence to protect against errant receivers of SHUTDOWN chunks.
It was noted that the wording in Section 8.5.1 did not give proper directions in the use of the 'T bit' with the Verification Tags.
Text changes to the document   Old text:
Rules for packet carrying ABORT:
The endpoint shall always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value if it is known.
If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.
The receiver MUST accept the packet if the Verification Tag matches either its own tag, OR the tag of its peer.
Otherwise, the receiver MUST silently discard the packet and take no further action.
Rules for packet carrying ABORT:
The endpoint MUST always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value, if it is known.
If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.
The receiver of a ABORT MUST accept the packet if the Verification Tag field of the packet matches its own tag OR if it is set to its peer's tag and the T bit is set in the Chunk Flags.
Otherwise, the receiver MUST silently discard the packet and take no further action.
The above text change clarifies that the T bit must be set before an implementation looks for the peer's tag.
Cwnd Gated by Its Full Use 2.14.1.
A problem was found with the current specification of the growth and decay of cwnd.
The cwnd should only be increased if it is being fully utilized, and after periods of underutilization, the cwnd should be decreased.
In some sections, the current wording is weak and is not clearly defined.
Also, the current specification unnecessarily introduces the need for special case code to ensure cwnd degradation.
Plus, the cwnd should not be increased during Fast Recovery, since a full cwnd during Fast Recovery does not qualify the cwnd as being fully utilized.
Additionally, multiple loss scenarios in a single window may cause the cwnd to grow more rapidly as the number of losses in a window increases [3].
Text Changes to the Document
Old text: (Section 6.1)   D)
Then, the sender can send out as many new DATA chunks as Rule A and Rule B above allow.
New text: (Section 6.1)   D)
When the time comes for the sender to transmit new DATA chunks, the protocol parameter Max.
Burst SHOULD be used to limit the number of packets sent.
The limit MAY be applied by adjusting cwnd as follows:
Or it MAY be applied by strictly limiting the number of packets emitted by the output routine.
Then, the sender can send out as many new DATA chunks as Rule A and Rule B allow.
When cwnd is less than or equal to ssthresh an SCTP endpoint MUST use the slow start algorithm to increase cwnd (assuming the current congestion window is being fully utilized).
If an incoming SACK advances the Cumulative TSN Ack Point, cwnd MUST be increased by at most the lesser of 1)
the total size of the previously outstanding DATA chunk(s) acknowledged, and 2) the destination's path MTU.
This protects against the ACK Splitting attack outlined in [SAVAGE99].
When cwnd is less than or equal to ssthresh, an SCTP endpoint MUST use the slow start algorithm to increase cwnd only if the current congestion window is being fully utilized, an incoming SACK advances the Cumulative TSN Ack Point, and the data sender is not in Fast Recovery.
Only when these three conditions are met can the cwnd be increased; otherwise, the cwnd MUST not be increased.
If these conditions are met, then cwnd MUST be increased by, at most, the lesser of 1)
the total size of the previously outstanding DATA chunk(s) acknowledged, and 2) the destination's path MTU.
This upper bound protects against the ACK Splitting attack outlined in [SAVAGE99].
Suggested SCTP Protocol Parameter Values
The following protocol parameters are RECOMMENDED:
Suggested SCTP Protocol Parameter Values
The following protocol parameters are RECOMMENDED:
The above changes strengthen the rules and make it much more apparent as to the need to block cwnd growth when the full cwnd is not being utilized.
The changes also apply cwnd degradation without introducing the need for complex special case code.
Window Probes in SCTP 2.15.1.
Description of the Problem When a receiver clamps its rwnd to 0 to flow control the peer, the specification implies that one must continue to accept data from the remote peer.
This is incorrect and needs clarification.
Text Changes to the Document
The SCTP endpoint MUST always acknowledge the receipt of each valid DATA chunk.
The SCTP endpoint MUST always acknowledge the reception of each valid DATA chunk when the DATA chunk received is inside its receive window.
When the receiver's advertised window is 0, the receiver MUST drop any new incoming DATA chunk with a TSN larger than the largest TSN received so far.
If the new incoming DATA chunk holds a TSN value less than the largest TSN received so far, then the receiver SHOULD drop the largest TSN held for reordering and accept the new incoming DATA chunk.
In either case, if such a DATA chunk is dropped, the receiver MUST immediately send back a SACK with the current receive window showing only DATA chunks received and accepted so far.
The dropped DATA chunk(s) MUST NOT be included in the SACK, as they were not accepted.
The receiver MUST also have an algorithm for advertising its receive window to avoid receiver silly window syndrome (SWS), as described in RFC 813.
The algorithm can be similar to the one described in Section 4.2.3.3 of RFC 1122.
At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is 0, see Section 6.2.1).
However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B below).
This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK having been lost in transit from the data receiver to the data sender.
New text: (Section 6.1)   A)
At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is 0; see Section 6.2.1).
However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B, below).
This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK's having been lost in transit from the data receiver to the data sender.
When the receiver's advertised window is zero, this probe is called a zero window probe.
Note that a zero window probe SHOULD only be sent when all outstanding DATA chunks have been cumulatively acknowledged and no DATA chunks are in flight.
Zero window probing MUST be supported.
If the sender continues to receive new packets from the receiver while doing zero window probing, the unacknowledged window probes should not increment the error counter for the association or any destination transport address.
This is because the receiver MAY keep its window closed for an indefinite time.
Refer to Section 6.2 on the receiver behavior when it advertises a zero window.
The sender SHOULD send the first zero window probe after 1 RTO when it detects that the receiver has closed its window and SHOULD increase the probe interval exponentially afterwards.
Also note that the cwnd SHOULD be adjusted according to Section 7.2.1.
Zero window probing does not affect the calculation of cwnd.
The sender MUST also have an algorithm for sending new DATA chunks to avoid silly window syndrome (SWS) as described in RFC 813.
The algorithm can be similar to the one described in Section 4.2.3.4 of RFC 1122.
The above allows a receiver to drop new data that arrives and yet still requires the receiver to send a SACK showing the conditions unchanged (with the possible exception of a new a rwnd) and the dropped chunk as missing.
This will allow the association to continue until the rwnd condition clears.
Fragmentation and Path MTU Issues
The current wording of the Fragmentation and Reassembly forces an implementation that supports fragmentation to always fragment.
This prohibits an implementation from offering its users an option to disable sends that exceed the SCTP fragmentation point.
The restriction in RFC 2960 [5], Section 6.9, was never meant to restrict an implementations API from this behavior.
Text Changes to the Document
Old text: (Section 6.1)   6.9 Fragmentation and Reassembly An endpoint MAY support fragmentation when sending DATA chunks, but MUST support reassembly when receiving DATA chunks.
If an endpoint supports fragmentation, it MUST fragment a user message if the size of the user message to be sent causes the outbound SCTP packet size to exceed the current MTU.
If an implementation does not support fragmentation of outbound user messages, the endpoint must return an error to its upper layer and not attempt to send the user message.
In this error case, the Send primitive discussed in Section 10.1 would need to return an error to the upper layer.
New text: (Section 6.1)   6.9.
Fragmentation and Reassembly An endpoint MAY support fragmentation when sending DATA chunks, but it MUST support reassembly when receiving DATA chunks.
If an endpoint supports fragmentation, it MUST fragment a user message if the size of the user message to be sent causes the outbound SCTP packet size to exceed the current MTU.
If an implementation does not support fragmentation of outbound user messages, the endpoint MUST return an error to its upper layer and not attempt to send the user message.
If an implementation that supports fragmentation makes available to its upper layer a mechanism to turn off fragmentation it may do so.
However, in so doing, it MUST react just like an implementation that does NOT support fragmentation, i.e., it MUST reject sends that exceed the current P MTU.
In this error case, the Send primitive discussed in Section 10.1 would need to return an error to the upper layer.
The above wording will allow an implementation to offer the option of rejecting sends that exceed the P MTU size even when the implementation supports fragmentation.
Initial Value of the Cumulative TSN Ack 2.17.1.
The current description of the SACK chunk within the RFC does not clearly state the value that would be put within a SACK when no DATA chunk has been received.
Text Changes to the Document
Cumulative TSN Ack: 32 bits (unsigned integer)
This parameter contains the TSN of the last DATA chunk received in sequence before a gap.
Cumulative TSN Ack: 32 bits (unsigned integer)
This parameter contains the TSN of the last DATA chunk received in sequence before a gap.
In the case where no DATA chunk has been received, this value is set to the peer's Initial TSN minus one.
This change clearly states what the initial value will be for a SACK sender.
Handling of Address Parameters within the INIT or INIT ACK 2.18.1.
The current description on handling address parameters contained within the INIT and INIT ACK does not fully describe a requirement for their handling.
Text Changes to the Document
If there are only IPv4/IPv6 addresses present in the received INIT or INIT ACK chunk, the receiver shall derive and record all the transport address(es) from the received chunk AND the source IP address that sent the INIT or INIT ACK.
The transport address(es) are derived by the combination of SCTP source port (from the common header) and the IP address parameter(s) carried in the INIT or INIT ACK chunk and the source IP address of the IP datagram.
The receiver should use only these transport addresses as destination transport addresses when sending subsequent packets to its peer.
New text: (Section 5.1.2)   C)
If there are only IPv4/IPv6 addresses present in the received INIT or INIT ACK chunk, the receiver MUST derive and record all the transport addresses from the received chunk AND the source IP address that sent the INIT or INIT ACK.
The transport addresses are derived by the combination of SCTP source port (from the common header) and the IP address parameter(s) carried in the INIT or INIT ACK chunk and the source IP address of the IP datagram.
The receiver should use only these transport addresses as destination transport addresses when sending subsequent packets to its peer.
An INIT or INIT ACK chunk MUST be treated as belonging to an already established association (or one in the process of being established) if the use of any of the valid address parameters contained within the chunk would identify an existing TCB.
This new text clearly specifies to an implementor the need to look within the INIT or INIT ACK.
Any implementation that does not do this may (for example) not be able to recognize an INIT chunk coming from an already established association that adds new addresses (see Section 2.6) or an incoming INIT ACK chunk sent from a source address different from the destination address used to send the INIT chunk.
Handling of Stream Shortages 2.19.1.
The current wording in the RFC places the choice of sending an ABORT upon the SCTP stack when a stream shortage occurs.
This decision should really be made by the upper layer, not the SCTP stack.
Text Changes to the Document
Old text:   5.1.1 Handle Stream Parameters
In the INIT and INIT ACK chunks, the sender of the chunk shall indicate the number of outbound streams (OS) it wishes to have in the association, as well as the maximum inbound streams (MIS)
it will accept from the other endpoint.
After receiving the stream configuration information from the other side, each endpoint shall perform the following check:  If the peer's MIS is less than the endpoint's OS, meaning that the peer is incapable of supporting all the outbound streams the endpoint wants to configure, the endpoint MUST either use MIS outbound streams, or abort the association and report to its upper layer the resources shortage at its peer.
New text: (Section 5.1.2)   5.1.1.
In the INIT and INIT ACK chunks, the sender of the chunk MUST indicate the number of outbound streams (OS) it wishes to have in the association, as well as the maximum inbound streams (MIS)
it will accept from the other endpoint.
After receiving the stream configuration information from the other side, each endpoint MUST perform the following check:  If the peer's MIS is less than the endpoint's OS, meaning that the peer is incapable of supporting all the outbound streams the endpoint wants to configure, the endpoint MUST use MIS outbound streams and MAY report any shortage to the upper layer.
The upper layer can then choose to abort the association if the resource shortage is unacceptable.
The above changes take the decision to ABORT out of the realm of the SCTP stack and place it into the user's hands.
The current RFC does not provide any guidance on the assignment of TSN sequence numbers to outbound messages nor reception of these messages.
This could lead to a possible indefinite postponement.
Text Changes to the Document
: The data sender SHOULD NOT use a TSN that is more than 2  31 1 above the beginning TSN of the current send window.
6.2  Acknowledgement on Reception of DATA Chunks
: The data sender SHOULD NOT use a TSN that is more than 2  31 1 above the beginning TSN of the current send window.
The algorithm by which an implementation assigns sequential TSNs to messages on a particular association MUST ensure that no user message that has been accepted by SCTP is indefinitely postponed from being assigned a TSN.
Acceptable algorithms for assigning TSNs include (a) assigning TSNs in round robin order over all streams with pending data; and (b) preserving the linear order in which the user messages were submitted to the SCTP association.
When an upper layer requests to read data on an SCTP association, the SCTP receiver SHOULD choose the message with the lowest TSN from among all deliverable messages.
In SCTP implementations that allow a user to request data on a specific stream, this operation SHOULD NOT block if data is not available, since this can lead to a deadlock under certain conditions.
Acknowledgement on Receipt of DATA Chunks 2.20.3.
The above wording clarifies how TSNs SHOULD be assigned by the sender.
User Initiated Abort of an Association 2.21.1.
It is not possible for an upper layer to abort the association and provide the peer with an indication of why the association is aborted.
Text changes to the document
Some of the changes given here already include changes suggested in Section 2.6 of this document.
Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause Specific Information fields
Cause specific Information: variable length This field carries the details of the error condition.
Sections 3.3.10.1 3.3.10.10 define error causes for SCTP.
Guidelines for the IETF to define new error cause values are discussed in Section 13.3.
New text: (Section 3.3.10)   Cause Code Value
Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause Specific Information fields
Cause specific Information: variable length This field carries the details of the error condition.
Sections 3.3.10.1 3.3.10.12 define error causes for SCTP.
Guidelines for the IETF to define new error cause values are discussed in Section 13.3.
(Note: no old text, new error added in Section 3.3.10)   3.3.10.12.
User Initiated Abort (12) Cause of error
This error cause MAY be included in ABORT chunks that are sent because of an upper layer request.
The upper layer can specify an Upper Layer Abort Reason that is transported by SCTP transparently and MAY be delivered to the upper layer protocol at the peer.
9.1 Abort of an Association When an endpoint decides to abort an existing association, it shall send an ABORT chunk to its peer endpoint.
The sender MUST fill in the peer's Verification Tag in the outbound packet and MUST NOT bundle any DATA chunk with the ABORT.
An endpoint MUST NOT respond to any received packet that contains an ABORT chunk (also see Section 8.4).
An endpoint receiving an ABORT shall apply the special Verification Tag check rules described in Section 8.5.1.
After checking the Verification Tag, the receiving endpoint shall remove the association from its record and shall report the termination to its upper layer.
New text: (Section 9.1)   9.1.
Abort of an Association When an endpoint decides to abort an existing association, it MUST send an ABORT chunk to its peer endpoint.
The sender MUST fill in the peer's Verification Tag in the outbound packet and MUST NOT bundle any DATA chunk with the ABORT.
If the association is aborted on request of the upper layer, a User Initiated Abort error cause (see 3.3.10.12) SHOULD be present in the ABORT chunk.
An endpoint MUST NOT respond to any received packet that contains an ABORT chunk (also see Section 8.4).
An endpoint receiving an ABORT MUST apply the special Verification Tag check rules described in Section 8.5.1.
After checking the Verification Tag, the receiving endpoint MUST remove the association from its record and SHOULD report the termination to its upper layer.
If a User Initiated Abort error cause is present in the ABORT chunk, the Upper Layer Abort Reason SHOULD be made available to the upper layer.
Old text: (Section 10.1)   D)
Any locally queued user data will be discarded and an ABORT chunk is sent to the peer.
A success code will be returned on successful abortion of the association.
If attempting to abort the association results in a failure, an error code shall be returned.
id local handle to the SCTP association
cause code reason of the abort to be passed to the peer.
New text: (Section 10.1)   D)
[, Upper Layer Abort Reason])
Any locally queued user data will be discarded, and an ABORT chunk is sent to the peer.
A success code will be returned on successful abortion of the association.
If attempting to abort the association results in a failure, an error code shall be returned.
id Local handle to the SCTP association.
Upper Layer Abort Reason Reason of the abort to be passed to the peer.
When SCTP loses communication to an endpoint completely (e.g., via Heartbeats) or detects that the endpoint has performed an abort operation, it shall invoke this notification on the ULP.
The following shall be passed with the notification:  association
id local handle to the SCTP association status
This indicates what type of event has occurred; The status may indicate a failure OR a normal termination event occurred in response to a shutdown or abort request.
The following may be passed with the notification:  data retrieval id an identification used to retrieve unsent and unacknowledged data.
last acked the TSN last acked by that peer endpoint;  last sent the TSN last sent to that peer endpoint;
When SCTP loses communication to an endpoint completely (e.g., via Heartbeats) or detects that the endpoint has performed an abort operation, it shall invoke this notification on the ULP.
The following shall be passed with the notification:  association
id Local handle to the SCTP association.
This indicates what type of event has occurred; The status may indicate that a failure OR a normal termination event occurred in response to a shutdown or abort request.
The following may be passed with the notification:  data retrieval id
An identification used to retrieve unsent and unacknowledged data.
The TSN last acked by that peer endpoint.
last sent The TSN last sent to that peer endpoint.
The abort reason specified in case of a user initiated abort.
The above allows an upper layer to provide its peer with an indication of why the association was aborted.
Therefore, an addition error cause was introduced.
Handling of Invalid Initiate Tag of INIT
Description of the Problem RFC 2960 requires that the receiver of an INIT ACK with the Initiate Tag set to zero handles this as an error and sends back an ABORT.
But the sender of the INIT ACK normally has no TCB, and thus the ABORT is useless.
Text Changes to the Document
Initiate Tag: 32 bits (unsigned integer)
The receiver of the INIT ACK records the value of the Initiate Tag parameter.
This value MUST be placed into the Verification Tag field of every SCTP packet that the INIT ACK receiver transmits within this association.
The Initiate Tag MUST NOT take the value 0.
See Section 5.3.1 for more on the selection of the Initiate Tag value.
If the value of the Initiate Tag in a received INIT ACK chunk is found to be 0, the receiver MUST treat it as an error and close the association by transmitting an ABORT.
Initiate Tag: 32 bits (unsigned integer)
The receiver of the INIT ACK records the value of the Initiate Tag parameter.
This value MUST be placed into the Verification Tag field of every SCTP packet that the INIT ACK receiver transmits within this association.
The Initiate Tag MUST NOT take the value 0.
See Section 5.3.1 for more on the selection of the Initiate Tag value.
If the value of the Initiate Tag in a received INIT ACK chunk is found to be 0, the receiver MUST destroy the association discarding its TCB.
The receiver MAY send an ABORT for debugging purpose.
The new text does not require that the receiver of the invalid INIT  ACK send the ABORT.
This behavior is in tune with the error case of invalid stream numbers in the INIT ACK.
However, sending an ABORT for debugging purposes is allowed.
Sending an ABORT in Response to an INIT 2.23.1.
Whenever the receiver of an INIT chunk has to send an ABORT chunk in response, for whatever reason, it is not stated clearly which Verification Tag and value of the T bit should be used.
Text Changes to the Document
Old text: (Section 8.4)   3)
If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1.
Otherwise,   New text: (Section 8.4)   3)
If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1.
If, for whatever reason, the INIT cannot be processed normally and an ABORT has to be sent in response, the Verification Tag of the packet containing the ABORT chunk MUST be the Initiate tag of the received INIT chunk, and the T Bit of the ABORT chunk has to be set to 0, indicating that a TCB was destroyed.
The new text stated clearly which value of the Verification Tag and T bit have to be used.
Stream Sequence Number (SSN) Initialization 2.24.1.
Description of the Problem RFC 2960 does not describe the fact that the SSN has to be initialized to 0, as required by RFC 2119.
Text Changes to the Document
The stream sequence number in all the streams shall start from 0 when the association is established.
Also, when the stream sequence number reaches the value 65535 the next stream sequence number shall be set to 0.
The stream sequence number in all the streams MUST start from 0 when the association is established.
Also, when the stream sequence number reaches the value 65535 the next stream sequence number MUST be set to 0.
The 'shall' in the text is replaced by a 'MUST' to clearly state the required behavior.
It is not clear in RFC 2960 whether a SACK must contain the fields Number of Gap Ack Blocks and Number of Duplicate TSNs.
Text Changes to the Document
The SACK MUST contain the Cumulative TSN Ack and Advertised Receiver Window Credit (a rwnd) parameters.
The SACK MUST contain the Cumulative TSN Ack, Advertised Receiver Window Credit (a rwnd), Number of Gap Ack Blocks, and Number of Duplicate TSNs fields.
The text has been modified.
It is now clear that a SACK always contains the fields Number of Gap Ack Blocks and Number of Duplicate TSNs.
Protocol Violation Error Cause 2.26.1.
Description of the Problem There are many situations where an SCTP endpoint may detect that its peer violates the protocol.
The result of such detection often results in the association being destroyed by the sending of an ABORT.
Currently, there are only some error causes that could be used to indicate the reason for the abort, but these do not cover all cases.
Text Changes to the Document
Some of the changes given here already include changes suggested in Section 2.6 and 2.21 of this document.
Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause Specific Information fields
Cause specific Information: variable length This field carries the details of the error condition.
Sections 3.3.10.1 3.3.10.10 define error causes for SCTP.
Guidelines for the IETF to define new error cause values are discussed in Section 13.3.
New text: (Section 3.3.10)   Cause Code Value
Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause Specific Information fields
Cause specific Information: variable length This field carries the details of the error condition.
Sections 3.3.10.1 3.3.10.13 define error causes for SCTP.
Guidelines for the IETF to define new error cause values are discussed in Section 13.3.
(Note: no old text; new error added in section 3.3.10)
This error cause MAY be included in ABORT chunks that are sent because an SCTP endpoint detects a protocol violation of the peer that is not covered by the error causes described in 3.3.10.1 to 3.3.10.12.
An implementation MAY provide additional information specifying what kind of protocol violation has been detected.
An additional error cause has been defined that can be used by an endpoint to indicate a protocol violation of the peer.
Reporting of Unrecognized Parameters 2.27.1.
It is not stated clearly in RFC 2960
[5] how unrecognized parameters should be reported.
Unrecognized parameters in an INIT chunk could be reported in the INIT ACK chunk or in a separate ERROR chunk, which can get lost.
Unrecognized parameters in an INIT ACK chunk have to be reported in an ERROR chunk.
This can be bundled with the COOKIE  ERROR chunk or sent separately.
If it is sent separately and received before the COOKIE ECHO, it will be handled as an OOTB packet, resulting in sending out an ABORT chunk.
Therefore, the association would not be established.
Text Changes to the Document
Some of the changes given here already include changes suggested in Section 2.2 of this document.
Old text: (Section 3.2.1)   00
Stop processing this SCTP packet and discard it, do not process any further chunks within it.
Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
10 Skip this parameter and continue processing.
11 Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
New text: (Section 3.2.1)   00
Stop processing this SCTP chunk and discard it; do not process any further parameters within this chunk.
Stop processing this SCTP chunk and discard it, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.
10 Skip this parameter and continue processing.
11 Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.
(Note: no old text; clarification added in Section 3.2)
If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the 'Unrecognized Parameter' parameter(s)
in the INIT ACK chunk sent in response to the INIT chunk.
Note that if the receiver of the INIT chunk is NOT going to establish an association (e.g., due to lack of resources), then no report would be sent back.
If the receiver of an INIT ACK chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the 'Unrecognized Parameter' error cause with the COOKIE ECHO chunk sent in response to the INIT ACK chunk.
If the receiver of the INIT ACK cannot bundle the COOKIE ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE ACK has been received.
Note: Any time a COOKIE ECHO is sent in a packet, it MUST be the first chunk.
The procedure of reporting unrecognized parameters has been described clearly.
Handling of IP Address Parameters 2.28.1.
It is not stated clearly in RFC 2960
[5] how an SCTP endpoint that supports either IPv4 addresses or IPv6 addresses should respond if IPv4 and IPv6 addresses are presented by the peer in the INIT or INIT ACK chunk.
Text Changes to the Document
In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.
New text: (Section 5.1.2)   IMPLEMENTATION NOTE:
In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re  initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.
If an SCTP endpoint that only supports either IPv4 or IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT
ACK chunk from its peer
, it MUST use all the addresses belonging to the supported address family.
The other addresses MAY be ignored.
The endpoint SHOULD NOT respond with any kind of error indication.
The procedure of handling IP address parameters has been described clearly.
Handling of COOKIE ECHO Chunks When a TCB Exists 2.29.1.
The description of the behavior in RFC 2960
[5] when a COOKIE ECHO chunk and a TCB exist could be misunderstood.
When a COOKIE ECHO is received, a TCB exists and the local tag and peer's tag match, it is stated that the endpoint should enter the ESTABLISHED state if it has not already done so and send a COOKIE ACK.
It was not clear that, in the case the endpoint has already left the ESTABLISHED state again, then it should not go back to established.
In case D, the endpoint can only enter state ESTABLISHED from COOKIE ECHOED because in state CLOSED it has no TCB and in state COOKIE
it has a TCB but knows nothing about the peer's tag, which is requested to match in this case.
Text Changes to the Document
When both local and remote tags match the endpoint should always enter the ESTABLISHED state, if it has not already done so.
It should stop any init or cookie timers that may be running and send a COOKIE ACK.
New text: (Section 5.2.4)   D)
When both local and remote tags match, the endpoint should enter the ESTABLISHED state, if it is in the COOKIE ECHOED state.
It should stop any cookie timer that may be running and send a COOKIE ACK.
The procedure of handling of COOKIE ECHO chunks when a TCB exists has been described clearly.
The Initial Congestion Window Size 2.30.1.
Description of the Problem RFC 2960 was published with the intention of having the same congestion control properties as TCP.
Since the publication of RFC 2960, TCP's initial congestion window size has been increased via RFC 3390.
This same update will be needed for SCTP to keep SCTP's congestion control properties equivalent to that of TCP.
Text Changes to the Document
The initial cwnd before DATA transmission or after a sufficiently long idle period MUST be <  2 MTU.
The initial cwnd before DATA transmission or
after a sufficiently long idle period MUST be set to min(4 MTU, max (2 MTU, 4380 bytes)).
When the endpoint does not transmit data on a given transport address, the cwnd of the transport address should be adjusted to max(cwnd/2, 2 MTU) per RTO.
When the endpoint does not transmit data on a given transport address, the cwnd of the transport address should be adjusted to max(cwnd/2, 4 MTU) per RTO.
Old text: (Section 7.2.3)   7.2.3.
Upon detection of packet losses from SACK
(see Section 7.2.4), an endpoint should do the following: ssthresh   max(cwnd/2, 2 MTU)
Basically, a packet loss causes cwnd to be cut in half.
When the T3 rtx timer expires on an address, SCTP should perform slow start by ssthresh   max(cwnd/2, 2 MTU)
New text: (Section 7.2.3)   7.2.3 Congestion Control Upon detection of packet losses from SACK
(see Section 7.2.4), An endpoint should do the following: ssthresh   max(cwnd/2, 4 MTU)
Basically, a packet loss causes cwnd to be cut in half.
When the T3 rtx timer expires on an address, SCTP should perform slow start by: ssthresh   max(cwnd/2, 4 MTU)
The change to SCTP's initial congestion window will allow it to continue to maintain the same congestion control properties as TCP.
Stream Sequence Numbers in Figures 2.31.1.
In Section 2.24 of this document, it is clarified that the SSN are initialized with 0.
Two figures in RFC 2960
[5] illustrate that they start with 1.
Text Changes to the Document
[I Tag Tag A & other info]
(compose temp TCB and Cookie Z) /
New text: (Section 7.2.1)   Endpoint
[I Tag Tag A & other info]
(compose temp TCB and Cookie Z) /
Strm 0,Seq 1 & user data 2]
Old text: (Section 5.2.4.1)   Endpoint
{A crashes and restarts} {app sets up a association with Z} (build TCB)
[I Tag Tag A' & other info]
(find a existing TCB compose temp TCB and Cookie Z with Tie Tags to previous association) /
Tag A,Tag Z & other info]
(destroy temp TCB,leave original in place)
COOKIE ECHO [Veri Tag Z', Cookie Z Tie Tag A, Tag Z
(Find existing association, Tie Tags match old tags, Tags do not match i.e.,
case X X M M above, Announce Restart to ULP and reset association). /
[TSN Ack init TSN A,Block 0] (Cancel T3 rtx timer)
/ Figure 5: A Restart Example
{A crashes and restarts} {app sets up a association with Z} (build TCB)
[I Tag Tag A' & other info]
(find a existing TCB compose temp TCB and Cookie Z with Tie Tags to previous association) /
Tag A,Tag Z & other info]
(destroy temp TCB,leave original in place)
COOKIE ECHO [Veri Tag Z', Cookie Z Tie Tag A, Tag Z
(Find existing association, Tie Tags match old tags, Tags do not match i.e.,
case X X M M above, Announce Restart to ULP and reset association). /
[TSN Ack init TSN A,Block 0] (Cancel T3 rtx timer)
Solution description Figure 4 and 5 were changed so that the SSN starts with 0 instead of 1. 2.32.
The RFC does not state clearly in Section 3.3.3.1 whether one or multiple unrecognized parameters are included in the 'Unrecognized Parameter' parameter.
Text Changes to the Document
Optional    8 Reserved for ECN Capable (Note 2)
Host Name Address (Note 3)
Optional    8 Reserved for ECN Capable (Note 2)
Host Name Address (Note 3)
Parameter Type Value: 8 Parameter Length:  Variable Size.
Parameter Value: This parameter is returned to the originator of the INIT chunk when the INIT contains an unrecognized parameter which has a value that indicates that it should be reported to the sender.
This parameter value field will contain unrecognized parameters copied from the INIT chunk complete with Parameter Type, Length and Value fields.
Parameter Type Value: 8 Parameter Length:  Variable Size.
Parameter Value: This parameter is returned to the originator of the INIT chunk when the INIT contains an unrecognized parameter that has a value that indicates that it should be reported to the sender.
This parameter value field will contain the unrecognized parameter copied from the INIT chunk complete with Parameter Type, Length, and Value fields.
The new text states clearly that only one unrecognized parameter is reported per parameter.
It is not stated clearly in RFC 2960
[5] how unrecognized parameters should be handled.
The problem comes up when an INIT contains an unrecognized parameter with highest bits 00.
It was not clear whether an INIT ACK should be sent.
Text Changes to the Document
Some of the changes given here already include changes suggested in Section 2.27 of this document.
Old text: (Section 3.2.1)   00
Stop processing this SCTP packet and discard it, do not process any further chunks within it.
Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
10 Skip this parameter and continue processing.
11 Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
New text: (Section 3.2.1)   00
Stop processing this parameter; do not process any further parameters within this chunk.
Stop processing this parameter, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.
10 Skip this parameter and continue processing.
11 Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.
(Note: no old text; clarification added in section 3.2)
If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the 'Unrecognized Parameter' parameter(s)
in the INIT ACK chunk sent in response to the INIT chunk.
Note that if the receiver of the INIT chunk is NOT going to establish an association (e.g., due to lack of resources),
an 'Unrecognized Parameter' would NOT be included with any ABORT being sent to the sender of the INIT.
If the receiver of an INIT ACK chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the 'Unrecognized Parameter' error cause with the COOKIE ECHO chunk sent in response to the INIT ACK chunk.
If the receiver of the INIT ACK cannot bundle the COOKIE ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE ACK has been received.
Note: Any time a COOKIE ECHO is sent in a packet, it MUST be the first chunk.
The procedure of handling unrecognized parameters has been described clearly.
Description of the Problem RFC 2960 requires that Tie Tags be included in the COOKIE.
The cookie may not be encrypted.
An attacker could discover the value of the Verification Tags by analyzing cookies received after sending an INIT.
Text Changes to the Document
Verification Tags from a previous association.
These Tags are used within a State Cookie so that the newly restarting association can be linked to the original association within the endpoint that did not restart.
Tie Tags: Two 32 bit random numbers that together make a 64  bit nonce.
These Tags are used within a State Cookie and TCB so that a newly restarting association can be linked to the original association within the endpoint that did not restart and yet not reveal the true Verification Tags of an existing association.
For an endpoint that is in the COOKIE ECHOED state it MUST populate its Tie Tags with the Tag information of itself and its peer (see Section 5.2.2 for a description of the Tie Tags).
For an endpoint that is in the COOKIE ECHOED state it MUST populate its Tie Tags within both the association TCB and inside the State Cookie (see section 5.2.2 for a description of the Tie Tags).
Unless otherwise stated, upon reception of an unexpected INIT for this association, the endpoint shall generate an INIT ACK with a State Cookie.
In the outbound INIT ACK the endpoint MUST copy its current Verification Tag and peer's Verification Tag into a reserved place within the state cookie.
We shall refer to these locations as the Peer's Tie Tag and the Local Tie Tag.
The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT.
And the INIT ACK MUST contain a new Initiation Tag (randomly generated see Section 5.3.1).
Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.
Unless otherwise stated, upon receipt of an unexpected INIT for this association, the endpoint MUST generate an INIT ACK with a State Cookie.
In the outbound INIT ACK, the endpoint MUST copy its current Tie Tags to a reserved place within the State Cookie and the association's TCB.
We shall refer to these locations inside the cookie as the Peer's Tie Tag and the Local Tie Tag.
We will refer to the copy within an association's TCB as the Local Tag and Peer's Tag.
The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT.
And the INIT ACK MUST contain a new Initiation Tag (randomly generated; see Section 5.3.1).
Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.
The solution to this problem is not to use the real Verification Tags within the State Cookie as tie tags.
Instead, two 32 bit random numbers are created to form one 64 bit nonce and stored both in the State Cookie and the existing association TCB.
This prevents exposing the Verification Tags inadvertently.
Port Number Verification in the COOKIE ECHO 2.35.1.
The State Cookie sent by a listening SCTP endpoint may not contain the original port numbers or the local Verification Tag.
It is then possible that the endpoint, on receipt of the COOKIE ECHO, will not be able to verify that these values match the original values found in the INIT and INIT ACK that began the association setup.
Text Changes to the Document
(Section 5.1.5)   3) Compare the creation timestamp in the State Cookie to the current local time.
If the elapsed time is longer than the lifespan carried in the State Cookie, then the packet, including the COOKIE ECHO and any attached DATA chunks, SHOULD be discarded and the endpoint MUST transmit an ERROR chunk with a "Stale Cookie" error cause to the peer endpoint, 4)
If the State Cookie is valid, create an association to the sender of the COOKIE ECHO chunk with the information in the TCB data carried in the COOKIE ECHO, and enter the ESTABLISHED state, 5)
Send a COOKIE ACK chunk to the peer acknowledging reception of the COOKIE ECHO.
The COOKIE ACK MAY be bundled with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK MUST be the first chunk in the SCTP packet.
Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO with a SACK (subsequent DATA chunk acknowledgement should follow the rules defined in Section 6.2).
As mentioned in step 5), if the SACK is bundled with the COOKIE ACK, the COOKIE ACK MUST appear first in the SCTP packet.
(Section 5.1.5)   3) Compare the port numbers and the Verification Tag contained within the COOKIE ECHO chunk to the actual port numbers and the Verification Tag within the SCTP common header of the received packet.
If these values do not match, the packet MUST be silently discarded.
4) Compare the creation timestamp in the State Cookie to the current local time.
If the elapsed time is longer than the lifespan carried in the State Cookie, then the packet, including the COOKIE ECHO and any attached DATA chunks, SHOULD be discarded, and the endpoint MUST transmit an ERROR chunk with a "Stale Cookie" error cause to the peer endpoint.
If the State Cookie is valid, create an association to the sender of the COOKIE ECHO chunk with the information in the TCB data carried in the COOKIE ECHO and enter the ESTABLISHED state.
6) Send a COOKIE ACK chunk to the peer acknowledging receipt of the COOKIE ECHO.
The COOKIE ACK MAY be bundled with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK MUST be the first chunk in the SCTP packet.
Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO with a SACK (subsequent DATA chunk acknowledgement should follow the rules defined in Section 6.2).
As mentioned in step 5, if the SACK is bundled with the COOKIE ACK, the COOKIE ACK MUST appear first in the SCTP packet.
By including both port numbers and the local Verification Tag within the State Cookie and verifying these during COOKIE ECHO processing, this issue is resolved.
When an association enters the ESTABLISHED state, the endpoint has no verification that all of the addresses presented by the peer do in fact belong to the peer.
This could cause various forms of denial of service attacks.
Text Changes to the Document
During association establishment, the two peers exchange a list of addresses.
In the predominant case, these lists accurately represent the addresses owned by each peer.
However, it is possible that a misbehaving peer may supply addresses that it does not own.
To prevent this, the following rules are applied to all addresses of the new association: 1)
Any address passed to the sender of the INIT by its upper layer is automatically considered to be CONFIRMED.
For the receiver of the COOKIE ECHO the only CONFIRMED address is the one that the INIT ACK was sent to.
All other addresses not covered by rules 1 and 2 are considered UNCONFIRMED and are subject to probing for verification.
To probe an address for verification, an endpoint will send HEARTBEATs including a 64 bit random nonce and a path indicator (to identify the address that the HEARTBEAT is sent to) within the HEARTBEAT parameter.
Upon receipt of the HEARTBEAT ACK, a verification is made that the nonce included in the HEARTBEAT parameter is the one sent to the address indicated inside the HEARTBEAT parameter.
When this match occurs, the address that the original HEARTBEAT was sent to is now considered CONFIRMED and available for normal data transfer.
These probing procedures are started when an association moves to the ESTABLISHED state and are ended when all paths are confirmed.
Each RTO a probe may be sent on an active UNCONFIRMED path in an attempt to move it to the CONFIRMED state.
If during this probing the path becomes inactive, this rate is lowered to the normal HEARTBEAT rate.
At the expiration of the RTO timer, the error counter of any path that was probed but not CONFIRMED is incremented by one and subjected to path failure detection, as defined in section 8.2.
When probing UNCONFIRMED addresses, however, the association overall error count is NOT incremented.
The number of HEARTBEATS sent at each RTO SHOULD be limited by the HB.Max.
It is an implementation decision as to how to distribute HEARTBEATS to the peer's addresses for path verification.
Whenever a path is confirmed, an indication MAY be given to the upper layer.
An endpoint MUST NOT send any chunks to an UNCONFIRMED address, with the following exceptions: A HEARTBEAT including a nonce MAY be sent to an UNCONFIRMED address.
A HEARTBEAT ACK MAY be sent to an UNCONFIRMED address.
A COOKIE ACK MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT including a nonce.
An implementation that does NOT support bundling MUST NOT send a COOKIE ACK to an UNCONFIRMED address.
A COOKE ECHO MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT including a nonce, and the packet MUST NOT exceed the path MTU.
If the implementation does NOT support bundling or if the bundled COOKIE ECHO plus HEARTBEAT (including nonce) would exceed the path MTU, then the implementation MUST NOT send a COOKIE ECHO to an UNCONFIRMED address.
Suggested SCTP Protocol Parameter Values
The following protocol parameters are RECOMMENDED:
Suggested SCTP Protocol Parameter Values
The following protocol parameters are RECOMMENDED: RTO.Initial
By properly setting up initial path state and accelerated probing via HEARTBEAT's, a new association can verify that all addresses presented by a peer belong to that peer.
Description of the Problem RFC 2960 does not describe how ICMP messages should be processed by an SCTP endpoint.
Text Changes to the Document
Protection of Non SCTP Capable Hosts.
To provide a non SCTP capable host with the same level of protection against attacks as for SCTP capable ones, all SCTP stacks MUST implement the ICMP handling described in Appendix C.
When an SCTP stack receives a packet containing multiple control or DATA chunks and the processing of the packet requires the sending of multiple chunks in response, the sender of the response chunk(s) MUST NOT send more than one packet.
If bundling is supported, multiple response chunks that fit into a single packet MAY be bundled together into one single response packet.
If bundling is not supported, then the sender MUST NOT send more than one response chunk and MUST discard all other responses.
Note that this rule does NOT apply to a SACK chunk, since a SACK chunk is, in itself, a response to DATA and
a SACK does not require a response of more DATA.
An SCTP implementation SHOULD abort the association if it receives a SACK acknowledging a TSN that has not been sent.
An SCTP implementation that receives an INIT that would require a large packet in response, due to the inclusion of multiple ERROR parameters, MAY (at its discretion) elect to omit some or all of the ERROR parameters to reduce the size of the INIT ACK.
Due to a combination of the size of the COOKIE parameter and the number of addresses a receiver of an INIT may be indicating to a peer, it is always possible that the INIT ACK will be larger than the original INIT.
An SCTP implementation SHOULD attempt to make the INIT ACK as small as possible to reduce the possibility of byte amplification attacks.
Whenever an ICMP message is received by an SCTP endpoint the following procedures MUST be followed to ensure proper utilization of the information being provided by layer 3.
An implementation MAY ignore all ICMPv4 messages where the type field is not set to "Destination Unreachable".
An implementation MAY ignore all ICMPv6 messages where the type field is not "Destination Unreachable, "Parameter Problem" or "Packet Too Big".
An implementation MAY ignore any ICMPv4 messages where the code does not indicate "Protocol Unreachable" or "Fragmentation Needed".
An implementation MAY ignore all ICMPv6 messages of type "Parameter Problem"
if the code is not "Unrecognized next header type encountered".
An implementation MUST use the payload of the ICMP message (V4 or V6) to locate the association that sent the message that ICMP is responding to.
If the association cannot be found, an implementation SHOULD ignore the ICMP message.
An implementation MUST validate that the Verification Tag contained in the ICMP message matches the verification tag of the peer.
If the Verification Tag is not 0 and does NOT match, discard the ICMP message.
If it is 0 and the ICMP message contains enough bytes to verify that the chunk type is an INIT chunk and that the initiate tag matches the tag of the peer, continue with ICMP7.
If the ICMP message is too short or the chunk type or the initiate tag does not match, silently discard the packet.
If the ICMP message is either a V6 "Packet Too Big" or
a V4 "Fragmentation Needed", an implementation MAY process this information as defined for PATH MTU discovery.
If the ICMP code is a "Unrecognized next header type encountered" or a "Protocol Unreachable", an implementation MUST treat this message as an abort with the T bit set if it does not contain an INIT chunk.
If it does contain an INIT chunk and the association is in COOKIE WAIT state, handle the ICMP message like an ABORT.
If the ICMPv6 code is "Destination Unreachable", the implementation MAY mark the destination into the unreachable state or alternatively increment the path error counter.
Note that these procedures differ from RFC 1122 [1] and from its requirements for processing of port unreachable messages and the requirements that an implementation MUST abort associations in response to a "protocol unreachable" message.
Port unreachable messages are not processed, since an implementation will send an ABORT, not a port unreachable.
The stricter handling of the "protocol unreachable" message is due to security concerns for hosts that do NOT support SCTP.
The new appendix now describes proper handling of ICMP messages in conjunction with SCTP.
[6] changes the SCTP checksum due to weaknesses in the original Adler 32 checksum for small messages.
This document, being used as a guide for a cut and paste replacement to update RFC 2960, thus also needs to incorporate the checksum changes.
The idea is that one could apply all changes found in this guide to a copy of RFC 2960 and have a "new" document that has ALL changes (including RFC 3309).
Text Changes to the Document
Old text:   6.8 Adler 32 Checksum Calculation
When sending an SCTP packet, the endpoint MUST strengthen the data integrity of the transmission by including the Adler 32 checksum value calculated on the packet, as described below.
After the packet is constructed (containing the SCTP common header and one or more control or DATA chunks), the transmitter shall: 1) Fill in the proper Verification Tag in the SCTP common header and initialize the checksum field to 0's.
2) Calculate the Adler 32 checksum of the whole packet, including the SCTP common header and all the chunks.
Refer to appendix B for details of the Adler 32 algorithm.
And, 3) Put the resultant value into the checksum field in the common header, and leave the rest of the bits unchanged.
When an SCTP packet is received, the receiver MUST first check the Adler 32 checksum:
1) Store the received Adler 32 checksum value aside, 2) Replace the 32 bits of the checksum field in the received SCTP packet with all '0's and calculate an Adler 32 checksum value of the whole received packet.
And, 3) Verify that the calculated Adler 32 checksum is the same as the received Adler 32 checksum.
If not, the receiver MUST treat the packet as an invalid SCTP packet.
The default procedure for handling invalid SCTP packets is to silently discard them.
New text:   6.8 CRC 32c Checksum Calculation
When sending an SCTP packet, the endpoint MUST strengthen the data integrity of the transmission by including the CRC32c checksum value calculated on the packet, as described below.
After the packet is constructed (containing the SCTP common header and one or more control or DATA chunks), the transmitter MUST 1) fill in the proper Verification Tag in the SCTP common header and initialize the checksum field to '0's, 2)
calculate the CRC32c checksum of the whole packet, including the SCTP common header and all the chunks
(refer to appendix B for details of the CRC32c algorithm); and 3) put the resultant value into the checksum field in the common header, and leave the rest of the bits unchanged.
When an SCTP packet is received, the receiver MUST first check the CRC32c checksum as follows:
1) Store the received CRC32c checksum value aside.
2) Replace the 32 bits of the checksum field in the received SCTP packet with all '0's and calculate a CRC32c checksum value of the whole received packet.
Verify that the calculated CRC32c checksum is the same as the received CRC32c checksum.
If it is not, the receiver MUST treat the packet as an invalid SCTP packet.
The default procedure for handling invalid SCTP packets is to silently discard them.
Any hardware implementation SHOULD be done in a way that is verifiable by the software.
Appendix B Alder 32 bit checksum calculation
The Adler 32 checksum calculation given in this appendix is copied from [RFC1950].
Adler 32 is composed of two sums accumulated per byte: s1 is the sum of all bytes, s2 is the sum of all s1 values.
Both sums are done modulo 65521.
s1 is initialized to 1, s2 to zero.
The Adler 32 checksum is stored as s2 65536   s1 in network byte order.
The following C code computes the Adler 32 checksum of a data buffer.
It is written for clarity, not for speed.
The sample code is in the ANSI C programming language.
When applied to an unsigned quantity, as here, right shift inserts zero bit(s) at the left.
Left shift inserts zero bit(s) at the right.
..len 1] and return the updated checksum.
The Adler 32 checksum should be initialized to 1.
Usage example: unsigned long adler   1L; while (read buffer(buffer, length) !
/ unsigned long adler32(unsigned char  buf, int len)
Appendix B CRC32c Checksum Calculation
We define a 'reflected value' as one that is the opposite of the normal bit order of the machine.
The 32 bit CRC is calculated as described for CRC 32c and uses the polynomial code 0x11EDC6F41
x^22 x^20 x^19 x^18 x^14 x^13
The CRC is computed using a procedure similar to ETHERNET CRC [ITU32], modified to reflect transport level usage.
CRC computation uses polynomial division.
A message bit string M is transformed to a polynomial, M(X), and the CRC is calculated from M(X) using polynomial arithmetic [PETERSON 72].
When CRCs are used at the link layer, the polynomial is derived from on the wire bit ordering: the first bit 'on the wire' is the high order coefficient.
Since SCTP is a transport level protocol, it cannot know the actual serial media bit ordering.
Moreover, different links in the path between SCTP endpoints may use different link level bit orders.
A convention must therefore be established for mapping SCTP transport messages to polynomials for purposes of CRC computation.
The bit ordering for mapping SCTP messages to polynomials is that bytes are taken most significant first; but within each byte, bits are taken least significant first.
The first byte of the message provides the eight highest coefficients.
Within each byte, the least significant SCTP bit gives the most significant polynomial coefficient within that byte, and the most significant SCTP bit is the least significant polynomial coefficient in that byte.
(This bit ordering is sometimes called 'mirrored' or 'reflected'
CRC polynomials are to be transformed back into SCTP transport level byte values, using a consistent mapping.
The SCTP transport level CRC value should be calculated as follows:  CRC input data are assigned to a byte stream, numbered from 0 to N 1.
The transport level byte stream is mapped to a polynomial value.
An N byte PDU with j bytes numbered 0 to N 1 is considered as coefficients of a polynomial M(x) of order 8N 1, with bit 0 of byte j being coefficient
x^(8(N j) 8), and bit 7 of byte j being coefficient x^(8(N j) 1).
The CRC remainder register is initialized with all 1s and the CRC is computed with an algorithm that simultaneously multiplies by x^32 and divides by the CRC polynomial.
The polynomial is multiplied by x^32 and divided by G(x), the generator polynomial, producing a remainder R(x) of degree less than or equal to 31.
The coefficients of R(x) are considered a 32 bit sequence.
The bit sequence is complemented.
The result is the CRC polynomial.
The CRC polynomial is mapped back into SCTP transport level bytes.
The coefficient of x^31 gives the value of bit 7 of SCTP byte 0, and the coefficient of x^24 gives the value of bit 0 of byte 0.
The coefficient of x^7 gives bit 7 of byte 3, and the coefficient of x^0 gives bit 0 of byte 3.
The resulting four byte transport level sequence is the 32 bit SCTP checksum value.
Standards documents, textbooks, and vendor literature on CRCs often follow an alternative formulation, in which the register used to hold the remainder of the long division algorithm is initialized to zero rather than all 1s, and instead the first 32 bits of the message are complemented.
The long division algorithm used in our formulation is specified such that the initial multiplication by 2^32
and the long division are combined into one simultaneous operation.
For such algorithms, and for messages longer than 64 bits, the two specifications are precisely equivalent.
That equivalence is the intent of this document.
Implementors of SCTP are warned that both specifications are to be found in the literature, sometimes with no restriction on the long division algorithm.
The choice of formulation in this document is to permit non SCTP usage, where the same CRC algorithm may be used to protect messages shorter than 64 bits.
There may be a computational advantage in validating the Association against the Verification Tag, prior to performing a checksum, as invalid tags will result in the same action as a bad checksum in most cases.
The exceptions for this technique would be INIT and some SHUTDOWN COMPLETE exchanges, as well as a stale COOKIE ECHO.
These special case exchanges must represent small packets and will minimize the effect of the checksum calculation.
ALLMAN99] Allman, M. and Paxson, V., "On Estimating End to End Network Path Properties", Proc.
Fall, K. and Floyd, S., Simulation based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp.
[RFC1950]  Deutsch P. and J. Gailly, "ZLIB Compressed Data Format Specification version 3.3", RFC 1950, May 1996.
[RFC2104]  Krawczyk, H., Bellare, M. and R. Canetti, "HMAC:  Keyed  Hashing for Message Authentication", RFC 2104, March 1997.
[RFC2196]  Fraser, B., "Site Security Handbook", FYI 8, RFC 2196, September 1997.
[RFC2522]  Karn, P. and W. Simpson, "Photuris: Session Key Management Protocol", RFC 2522, March 1999.
[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., "TCP Congestion Control with a Misbehaving Receiver",  ACM Computer Communication Review, 29(5), October 1999.
New text: (Section 18, including changes from 2.11)   18.
ALLMAN99] Allman, M. and Paxson, V., "On Estimating End to End Network Path Properties", Proc.
Fall, K. and Floyd, S., Simulation based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp.
[PETERSON 1972] W. W. Peterson and E.J Weldon, Error Correcting Codes, 2nd Edition, MIT Press, Cambridge, Massachusetts.
[RFC1750]  Eastlake, D., Ed., "Randomness Recommendations for Security", RFC 1750, December 1994.
[RFC1858]  Ziemba, G., Reed, D. and Traina P., "Security Considerations for IP Fragment Filtering", RFC 1858, October 1995.
[RFC1950]  Deutsch P. and J. Gailly, "ZLIB Compressed Data Format Specification version 3.3", RFC 1950, May 1996.
[RFC2104]  Krawczyk, H., Bellare, M. and R. Canetti, "HMAC:  Keyed  Hashing for Message Authentication", RFC 2104, March 1997.
[RFC2196]  Fraser, B., "Site Security Handbook", FYI 8, RFC 2196, September 1997.
[RFC2522]  Karn, P. and W. Simpson, "Photuris: Session Key Management Protocol", RFC 2522, March 1999.
[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., "TCP Congestion Control with a Misbehaving Receiver", ACM Computer Communication Review, 29(5), October 1999.
Williams, R., "A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS" Internet publication, August 1993, http://www.geocities.com/SiliconValley/Pines/ 8659/crc.htm.
This change adds to the implementor's guide the complete set of changes that, when combined with RFC 2960 [5], encompasses the changes from RFC 3309 [6].
The current retransmission policy (send all retransmissions an alternate destination) in the specification has performance issues under certain loss conditions with multihomed endpoints.
Instead, fast retransmissions should be sent to the same destination, and only timeout retransmissions should be sent to an alternate destination [4].
Text Changes to the Document
Furthermore, when its peer is multi homed, an endpoint SHOULD try to retransmit a chunk to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.
Furthermore, when its peer is multi homed, an endpoint SHOULD try to retransmit a chunk that timed out to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.
When retransmitting data, if the endpoint is multi homed, it should consider each source destination address pair in its retransmission selection policy.
When retransmitting the endpoint should attempt to pick the most divergent source destination pair from the original source destination pair to which the packet was transmitted.
When retransmitting data that timed out, if the endpoint is multi homed, it should consider each source destination address pair in its retransmission selection policy.
When retransmitting timed out data, the endpoint should attempt to pick the most divergent source destination pair from the original source destination pair to which the packet was transmitted.
The above wording changes clarify that only timeout retransmissions should be sent to an alternate active destination.
The port number 0 has a special semantic in various APIs.
For example, in the socket API, if the user specifies 0, the SCTP implementation chooses an appropriate port number for the user.
Therefore, the port number 0 should not be used on the wire.
Text Changes to the Document
Source Port Number: 16 bits (unsigned integer)
This is the SCTP sender's port number.
It can be used by the receiver in combination with the source IP address, the SCTP destination port, and possibly the destination IP address to identify the association to which this packet belongs.
Destination Port Number: 16 bits (unsigned integer)
This is the SCTP port number to which this packet is destined.
The receiving host will use this port number to de multiplex the SCTP packet to the correct receiving endpoint/application.
Source Port Number: 16 bits (unsigned integer)
This is the SCTP sender's port number.
It can be used by the receiver in combination with the source IP address, the SCTP destination port and possibly the destination IP address to identify the association to which this packet belongs.
The port number 0 MUST NOT be used.
Destination Port Number: 16 bits (unsigned integer)
This is the SCTP port number to which this packet is destined.
The receiving host will use this port number to de multiplex the SCTP packet to the correct receiving endpoint/application.
The port number 0 MUST NOT be used.
It is clearly stated that the port number 0 is an invalid value on the wire.
The description of the T bit as the bit describing whether a TCB has been destroyed is misleading.
In addition, the procedure described in Section 2.13 is not as precise as needed.
Text Changes to the Document
The T bit is set to 0 if the sender had a TCB that it destroyed.
If the sender did not have a TCB it should set this bit to 1.
The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer.
If the Verification Tag is reflected, the T bit MUST be set to 1.
Reflecting means that the sent Verification Tag is the same as the received one.
The T bit is set to 0 if the sender had a TCB that it destroyed.
If the sender did not have a TCB it should set this bit to 1.
The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer.
If the Verification Tag is reflected, the T bit MUST be set to 1.
Reflecting means that the sent Verification Tag is the same as the received one.
Old text: (Section 8.4)   3)
If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1.
Otherwise,   New text: (Section 8.4)   3)
If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1.
If, for whatever reason, the INIT cannot be processed normally and an ABORT has to be sent in response, the Verification Tag of the packet containing the ABORT chunk MUST be the Initiate tag of the received INIT chunk, and the T Bit of the ABORT chunk has to be set to 0, indicating that the Verification Tag is NOT reflected.
Old text: (Section 8.4)   5)
If the packet contains a SHUTDOWN ACK chunk, the receiver should respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.
When sending the SHUTDOWN COMPLETE, the receiver of the OOTB packet must fill in the Verification Tag field of the outbound packet with the Verification Tag received in the SHUTDOWN ACK and set the T bit in the Chunk Flags to indicate that no TCB was found.
New text: (Section 8.4)   5)
If the packet contains a SHUTDOWN ACK chunk, the receiver should respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.
When sending the SHUTDOWN COMPLETE, the receiver of the OOTB packet must fill in the Verification Tag field of the outbound packet with the Verification Tag received in the SHUTDOWN ACK and set the T bit in the Chunk Flags to indicate that the Verification Tag is reflected.
Old text: (Section 8.4)   8)
The receiver should respond to the sender of the OOTB packet with an ABORT.
When sending the ABORT, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the value found in the Verification Tag field of the OOTB packet and set the T bit in the Chunk Flags to indicate that no TCB was found.
After sending this ABORT, the receiver of the OOTB packet shall discard the OOTB packet and take no further action.
New text: (Section 8.4)   8)
The receiver should respond to the sender of the OOTB packet with an ABORT.
When sending the ABORT, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the value found in the Verification Tag field of the OOTB packet and set the T bit in the Chunk Flags to indicate that the Verification Tag is reflected.
After sending this ABORT, the receiver of the OOTB packet shall discard the OOTB packet and take no further action.
Rules for packet carrying ABORT:
The endpoint shall always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value if it is known.
If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.
The receiver MUST accept the packet if the Verification Tag matches either its own tag, OR the tag of its peer.
Otherwise, the receiver MUST silently discard the packet and take no further action.
Rules for packet carrying ABORT:
The endpoint MUST always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value, if it is known.
If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.
The receiver of an ABORT MUST accept the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its peer's tag and the T bit is set in the Chunk Flags.
Otherwise, the receiver MUST silently discard the packet and take no further action.
Old text: (Section 8.5.1)   C) Rules for packet carrying SHUTDOWN
When sending a SHUTDOWN COMPLETE, if the receiver of the SHUTDOWN ACK has a TCB then the destination endpoint's tag MUST be used.
Only where no TCB exists should the sender use the Verification Tag from the SHUTDOWN ACK.
The receiver of a SHUTDOWN COMPLETE shall accept the packet if the Verification Tag field of the packet matches its own tag
OR it is set to its peer's tag and the T bit is set in the Chunk Flags.
Otherwise, the receiver MUST silently discard the packet and take no further action.
An endpoint MUST ignore the SHUTDOWN COMPLETE if it is not in the SHUTDOWN
New text: (Section 8.5.1)   C) Rules for packet carrying SHUTDOWN COMPLETE:
When sending a SHUTDOWN COMPLETE, if the receiver of the SHUTDOWN ACK has a TCB, then the destination endpoint's tag MUST be used, and the T bit MUST NOT be set.
Only where no TCB exists should the sender use the Verification Tag from the SHUTDOWN ACK, and MUST set the T bit.
The receiver of a SHUTDOWN COMPLETE shall accept the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its peer's tag and the T bit is set in the Chunk Flags.
Otherwise, the receiver MUST silently discard the packet and take no further action.
An endpoint MUST ignore the SHUTDOWN COMPLETE if it is not in the SHUTDOWN
The description of the T bit now clearly describes the semantic of the bit.
The procedures for receiving the T bit have been clarified.
The description given in Section 2.33 does not state clearly whether an INIT ACK or COOKIE ECHO is sent.
Text Changes to the Document
The changes given here already include changes suggested in Section 2.2, 2.27, and 2.33 of this document.
Old text: (Section 3.2.1)   00
Stop processing this SCTP packet and discard
it do not process any further chunks within it.
Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
10 Skip this parameter and continue processing.
11 Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).
New text: (Section 3.2.1)   00
Stop processing this parameter; do not process any further parameters within this chunk.
Stop processing this parameter, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter', as described in 3.2.2.
10 Skip this parameter and continue processing.
11 Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter', as described in 3.2.2.
Please note that in all four cases an INIT ACK or COOKIE ECHO chunk is sent.
In the 00 or 01 case the processing of the parameters after the unknown parameter is canceled, but no processing already done is rolled back.
(Note: no old text; clarification added in Section 3.2)
If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the 'Unrecognized Parameter' parameter(s)
in the INIT ACK chunk sent in response to the INIT chunk.
Note that if the receiver of the INIT chunk is NOT going to establish an association (e.g., due to lack of resources),
an 'Unrecognized Parameter' would NOT be included with any ABORT being sent to the sender of the INIT.
If the receiver of an INIT ACK chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the 'Unrecognized Parameters' error cause with the COOKIE ECHO chunk sent in response to the INIT ACK chunk.
If the receiver of the INIT ACK cannot bundle the COOKIE ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE ACK has been received.
Note: Any time a COOKIE ECHO is sent in a packet, it MUST be the first chunk.
The new text clearly states that an INIT ACK or COOKIE ECHO has to be sent.
The description given in Section 3.3.11 of RFC 2960 [5] is unclear as to how the COOKIE ECHO is composed.
Text Changes to the Document
Cookie: variable size This field must contain the exact cookie received in the State Cookie parameter from the previous INIT ACK.
An implementation SHOULD make the cookie as small as possible to insure interoperability.
Cookie: variable size This field must contain the exact cookie received in the State Cookie parameter from the previous INIT ACK.
An implementation SHOULD make the cookie as small as possible to ensure interoperability.
A Cookie Echo does NOT contain a State Cookie Parameter; instead, the data within the State Cookie's Parameter Value becomes the data within the Cookie Echo's Chunk Value.
This allows an implementation to change only the first two bytes of the State Cookie parameter to become a Cookie Echo Chunk.
The new text adds a note that helps clarify that a Cookie Echo chunk is nothing more than the State Cookie parameter with only two bytes modified.
Description of the Problem Section 6.10 of RFC 2960 [5] uses the notion of 'partial chunks' without defining it.
Text Changes to the Document
Partial chunks MUST NOT be placed in an SCTP packet.
Partial chunks MUST NOT be placed in an SCTP packet.
A partial chunk is a chunk that is not completely contained in the SCTP packet; i.e., the SCTP packet is too short to contain all the bytes of the chunk as indicated by the chunk length.
The new text adds a definition of 'partial chunks'.
Description of the Problem Section 8.4 of RFC 2960
[5] forces the OOTB handling to discard all non unicast addresses.
This leaves future use of anycast addresses in question.
With the addition of the add ip feature, SCTP should be able to easily handle anycast INIT
s that can be followed, after association setup, with a delete of the anycast address from the association.
Text Changes to the Document
Old text: (Section 8.4)   8.4 Handle "Out of the blue" Packets An SCTP packet is called an "out of the blue" (OOTB) packet if it is correctly formed, i.e., passed the receiver's Adler 32 check (see Section 6.8), but the receiver is not able to identify the association to which this packet belongs.
The receiver of an OOTB packet MUST do the following: 1)
If the OOTB packet is to or from a non unicast address, silently discard the packet.
New text: (Section 8.4)   8.4.
An SCTP packet is called an "out of the blue" (OOTB) packet if it is correctly formed (i.e., passed the receiver's CRC32c check; see Section 6.8), but the receiver is not able to identify the association to which this packet belongs.
The receiver of an OOTB packet MUST do the following: 1)
If the OOTB packet is to or from a non unicast address, a receiver SHOULD silently discard the packet.
The loosening of the wording to a SHOULD will now allow future use of anycast addresses.
Note that no changes are made to Section 11.2.4.1, since responding to broadcast addresses could lead to flooding attacks and implementors should pay careful attention to these words.
Description of the Problem Section 3.3.7 of RFC 2960 [5] requires an SCTP endpoint to silently discard ABORT chunks received for associations that do not exist.
It is not clear what this means in the COOKIE WAIT state, for example.
Therefore, it was not clear whether an ABORT sent in response to an INIT should be processed or silently discarded.
Text Changes to the Document
If an endpoint receives an ABORT with a format error or for an association that doesn't exist, it MUST silently discard it.
If an endpoint receives an ABORT with a format error or no TCB is found, it MUST silently discard it.
It is now clearly stated that an ABORT chunk should be processed whenever a TCB is found.
Sending of ABORT Chunks 2.47.1.
Description of the Problem Section 5.1 of RFC 2960 [5] requires that an ABORT chunk be sent in response to an INIT chunk when there is no listening end point.
To make port scanning harder, someone might not want these ABORTs to be received by the sender of the INIT chunks.
Currently, the only way to enforce this is by using a firewall that discards the packets containing the INIT chunks or the packets containing the ABORT chunks.
It is desirable that the same can be done without a middle box.
Text Changes to the Document
If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides not to establish the new association due to missing mandatory parameters in the received INIT or INIT ACK, invalid parameter values, or lack of local resources, it MUST respond with an ABORT chunk.
If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides not to establish the new association due to missing mandatory parameters in the received INIT or INIT ACK, invalid parameter values, or lack of local resources, it SHOULD respond with an ABORT chunk.
The requirement of sending ABORT chunks is relaxed such that an implementation can decide not to send ABORT chunks.
Handling of Supported Address Types Parameter 2.48.1.
The sender of the INIT chunk can include a 'Supported Address Types' parameter to indicate which address families are supported.
It is unclear how an INIT chunk should be processed where the source address of the packet containing the INIT chunk or listed addresses within the INIT chunk indicate that more address types are supported than those listed in the 'Supported Address Types' parameter.
Text Changes to the Document
The changes given here already include changes suggested in Section 2.28 of this document.
In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.
New text: (Section 5.1.2)   IMPLEMENTATION NOTE:
In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re  initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.
If an SCTP endpoint that only supports either IPv4 or IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT
ACK chunk from its peer
, it MUST use all the addresses belonging to the supported address family.
The other addresses MAY be ignored.
The endpoint SHOULD NOT respond with any kind of error indication.
If an SCTP endpoint lists in the 'Supported Address Types' parameter either IPv4 or IPv6, but uses the other family for sending the packet containing the INIT chunk, or if it also lists addresses of the other family in the INIT chunk, then the address family that is not listed in the 'Supported Address Types' parameter SHOULD also be considered as supported by the receiver of the INIT chunk.
The receiver of the INIT chunk SHOULD NOT respond with any kind of error indication.
It is now clearly described how these Supported Address Types parameters with incorrect data should be handled.
Handling of Unexpected Parameters 2.49.1.
Description of the Problem RFC 2960
[5] clearly describes how unknown parameters in the INIT and INIT ACK chunk should be processed.
But it is not described how unexpected parameters should be processed.
A parameter is unexpected if it is known and is an optional parameter in either the INIT or INIT ACK chunk but is received in the chunk for which it is not an optional parameter.
For example, the 'Supported Address Types' parameter would be an unexpected parameter if contained in an INIT  ACK chunk.
Text Changes to the Document
This parameter, when present, specifies all the address types the sending endpoint can support.
The absence of this parameter indicates that the sending endpoint can support any address type.
This parameter, when present, specifies all the address types the sending endpoint can support.
The absence of this parameter indicates that the sending endpoint can support any address type.
If an INIT chunk is received with known parameters that are not optional parameters of the INIT chunk then the receiver SHOULD process the INIT chunk and send back an INIT ACK.
The receiver of the INIT chunk MAY bundle an ERROR chunk with the COOKIE ACK chunk later.
However, restrictive implementations MAY send back an ABORT chunk in response to the INIT chunk.
An implementation MUST be prepared to receive a INIT ACK that is quite large (more than 1500 bytes) due to the variable size of the state cookie AND the variable address list.
For example if a responder to the INIT has 1000 IPv4 addresses it wishes to send, it would need at least 8,000 bytes to encode this in the INIT ACK.
An implementation MUST be prepared to receive a INIT ACK that is quite large (more than 1500 bytes) due to the variable size of the state cookie AND the variable address list.
For example, if a responder to the INIT has 1000 IPv4 addresses it wishes to send, it would need at least 8,000 bytes to encode this in the INIT ACK.
If an INIT ACK chunk is received with known parameters that are not optional parameters of the INIT ACK chunk, then the receiver SHOULD process the INIT ACK chunk and send back a COOKIE ECHO.
The receiver of the INIT ACK chunk MAY bundle an ERROR chunk with the COOKIE ECHO chunk.
However, restrictive implementations MAY send back an ABORT chunk in response to the INIT ACK chunk.
It is now stated how unexpected parameters should be processed.
The current description of the payload protocol identifier does NOT highlight the fact that the field is NOT necessarily in network byte order.
Text Changes to the Document
Payload Protocol Identifier: 32 bits (unsigned integer)
This value represents an application (or upper layer) specified protocol identifier.
This value is passed to SCTP by its upper layer and sent to its peer.
This identifier is not used by SCTP but can be used by certain network entities as well as the peer application to identify the type of information being carried in this DATA chunk.
This field must be sent even in fragmented DATA chunks (to make sure it is available for agents in the middle of the network).
The value 0 indicates no application identifier is specified by the upper layer for this payload data.
Payload Protocol Identifier: 32 bits (unsigned integer)
This value represents an application (or upper layer) specified protocol identifier.
This value is passed to SCTP by its upper layer and sent to its peer.
This identifier is not used by SCTP but can be used by certain network entities, as well as by the peer application, to identify the type of information being carried in this DATA chunk.
This field must be sent even in fragmented DATA chunks (to make sure it is available for agents in the middle of the network).
Note that this field is NOT touched by an SCTP implementation
, therefore its byte order is NOT necessarily Big Endian.
The upper layer is responsible for any byte order conversions to this field.
The value 0 indicates that no application identifier is specified by the upper layer for this payload data.
It is now explicitly stated that the upper layer is responsible for the byte order of this field.
The current wording of the use of Karn's algorithm is not descriptive enough to ensure that an implementation in a multi homed association does not incorrectly mismeasure the RTT.
Text Changes to the Document
RTT measurements MUST NOT be made using packets that were retransmitted (and thus for which it is ambiguous whether the reply was for the first instance of the packet or a later instance)
New text: (Section 6.3.1)   C5)
RTT measurements MUST NOT be made using chunks that were retransmitted (and thus for which it is ambiguous whether the reply was for the first instance of the chunk or for a later instance)
RTT measurements should only be made using a chunk with TSN r if no chunk with TSN less than or equal to r is retransmitted since r is first sent.
The above clarification adds an implementation note that will provide additional guidance in the application of Karn's algorithm.
The original SCTP specification is overly conservative in requiring 4 missing reports before fast retransmitting a segment.
TCP uses 3 missing reports or 4 acknowledgements indicating that the same segment was received.
Text Changes to the Document
Old text:   7.2.4 Fast Retransmit on Gap Reports
In the absence of data loss, an endpoint performs delayed acknowledgement.
However, whenever an endpoint notices a hole in the arriving TSN sequence, it SHOULD start sending a SACK back every time a packet arrives carrying data until the hole is filled.
Whenever an endpoint receives a SACK that indicates some TSN(s) missing, it SHOULD wait for 3 further miss indications (via subsequent SACK's) on the same TSN(s) before taking action with regard to Fast Retransmit.
Fast Retransmit on Gap Reports
In the absence of data loss, an endpoint performs delayed acknowledgement.
However, whenever an endpoint notices a hole in the arriving TSN sequence, it SHOULD start sending a SACK back every time a packet arrives carrying data until the hole is filled.
Whenever an endpoint receives a SACK that indicates that some TSNs are missing, it SHOULD wait for 2 further miss indications (via subsequent SACKs for a total of 3 missing reports) on the same TSNs before taking action with regard to Fast Retransmit.
The above changes will make SCTP and TCP behave similarly in terms of how fast they engage the Fast Retransmission algorithm upon receiving missing reports.
This document should add no additional security risks to SCTP and in fact SHOULD correct some original security flaws within the original document once it is incorporated into a RFC 2960
This document recommends changes for the RFC 2960 [5] BIS document.
As such, even though it lists new error cause code, this document in itself does NOT define those new codes.
Instead, the BIS document will make the needed changes to RFC 2960 [5] and thus its IANA section will require changes to be made.
