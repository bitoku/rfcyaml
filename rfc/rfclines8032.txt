This document describes elliptic curve signature scheme Edwards curve Digital Signature Algorithm (EdDSA).
The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves.
An example implementation and test vectors are provided.
The Edwards curve Digital Signature Algorithm (EdDSA) is a variant of Schnorr's signature system with (possibly twisted) Edwards curves.
EdDSA needs to be instantiated with certain parameters, and this document describes some recommended variants.
To facilitate adoption of EdDSA in the Internet community, this document describes the signature scheme in an implementation oriented way and provides sample code and test vectors.
The advantages with EdDSA are as follows:
EdDSA provides high performance on a variety of platforms; 2.
The use of a unique random number for each signature is not required; 3.
It is more resilient to side channel attacks; 4.
EdDSA uses small public keys (32 or 57 bytes) and signatures (64 or 114 bytes) for Ed25519 and Ed448, respectively; 5.
The formulas are "complete", i.e., they are valid for all points on the curve, with no exceptions.
This obviates the need for EdDSA to perform expensive point validation on untrusted public values; and 6.
EdDSA provides collision resilience, meaning that hash function collisions do not break this system (only holds for PureEdDSA).
The original EdDSA paper [EDDSA] and the generalized version described in "EdDSA for more curves" [EDDSA2] provide further background.
[RFC7748] discusses specific curves, including Curve25519 [CURVE25519] and Ed448 Goldilocks
Ed25519 is intended to operate at around the 128 bit security level and Ed448 at around the 224 bit security level.
A sufficiently large quantum computer would be able to break both.
Reasonable projections of the abilities of classical computers conclude that Ed25519 is perfectly safe.
Ed448 is provided for those applications with relaxed performance requirements and where there is a desire to hedge against analytical attacks on elliptic curves.
The i'th octet of octet string h
string b a <  b
a is less than or equal to b
a is greater than or equal to b i
Sum of i and j i
The y first octets of SHAKE256 [FIPS202] output for input
The number of octets in string x dom2(x, y)
The blank octet string when signing or verifying Ed25519.
Otherwise, the octet string: "
y, where x is in range 0 255 and y is an octet string of at most 255 octets.
"SigEd25519 no Ed25519 collisions" is in ASCII (32 octets).
y, where x is in range 0 255 and y is an octet string of at most 255 octets.
"SigEd448" is in ASCII (8 octets).
Bit strings are converted to octet strings by taking bits from left to right, packing those from the least significant bit of each octet to the most significant bit, and moving to the next octet when each octet fills up.
The conversion from octet string to bit string is the reverse of this process; for example, the 16 bit bit string b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 is converted into two octets x0 and x1 (in this order) as x0   b7 128 b6 64
b5 32 b4 16 b3 8 b2 4 b1 2 b0 x1
b15 128 b14 64 b13 32 b12 16
b11 8 b10 4 b9 2
b8 Little endian encoding into bits places bits from left to right and from least significant to most significant.
If combined with bit string to octet string conversion defined above, this results in little endian encoding into octets (if length is not a multiple of 8, the most significant bits of the last octet remain unused).
EdDSA Algorithm EdDSA is a digital signature system with 11 parameters.
The generic EdDSA digital signature system with its 11 input parameters is not intended to be implemented directly.
Choosing parameters is critical for secure and efficient operation.
Instead, you would implement a particular parameter choice for EdDSA (such as Ed25519 or Ed448), sometimes slightly generalized to achieve code reuse to cover Ed25519 and Ed448.
Therefore, a precise explanation of the generic EdDSA is thus not particularly useful for implementers.
For background and completeness, a succinct description of the generic EdDSA algorithm is given here.
The definition of some parameters, such as n and c, may help to explain some steps of the algorithm that are not intuitive.
This description closely follows [EDDSA2].
EdDSA has 11 parameters: 1.
EdDSA uses an elliptic curve over the finite field GF(p).
An integer b with 2^(b 1)
EdDSA public keys have exactly b bits, and EdDSA signatures have exactly 2 b bits.
b is recommended to be a multiple of 8, so public key and signature lengths are an integral number of octets.
A (b 1) bit encoding of elements of the finite field GF(p).
A cryptographic hash function H producing 2 b bit output.
Conservative hash functions (i.e., hash functions where it is infeasible to create collisions) are recommended and do not have much impact on the total cost of EdDSA. 5.
An integer c that is 2 or 3.
Secret EdDSA scalars are multiples of 2^c.
The integer c is the base 2 logarithm of the so called cofactor.
An integer n with c <  n < b.
Secret EdDSA scalars have exactly n
1 bits, with the top bit (the 2^n position) always set and the bottom c bits always cleared.
A non square element d of GF(p).
The usual recommendation is to take it as the value nearest to zero that gives an acceptable curve.
A non zero square element
The usual recommendation for best performance is a    1
if p mod 4   1, and a   1
if p mod 4   3. 9.
(0,1) of the set E   {
(x,y) is a member of GF(p)
x GF(p) such that a   x^2
An odd prime L such that
The number #E (the number of points on the curve) is part of the standard data provided for an elliptic curve E, or it can be computed as cofactor   order.
PureEdDSA means EdDSA where PH is the identity function, i.e., PH(M)
M.  HashEdDSA means EdDSA where PH generates a short output,
no matter how long the message is; for example, PH(M)   SHA 512(M).
Points on the curve form a group under addition, (x3, y3)
(x2, y2), with the formulas x1   y2
The neutral element in the group is (0,1).
Unlike many other curves used for cryptographic applications, these formulas are "complete"; they are valid for all points on the curve, with no exceptions.
In particular, the denominators are non zero for all input points.
There are more efficient formulas, which are still complete, that use homogeneous coordinates to avoid the expensive modulo p inversions.
See [Faster ECC] and [Edwards revisited].
< S < L 1 is encoded in little endian form as a b bit string ENC(S).
An element (x,y) of E is encoded as a b bit string called ENC(x,y), which is the (b 1) bit encoding of y concatenated with one bit that is 1 if x is negative and 0
if x is not negative.
The encoding of GF(p) is used to define "negative" elements of GF(p):
specifically, x is negative if the (b 1) bit encoding of x is lexicographically larger than the (b 1) bit encoding of  x. 3.2.
An EdDSA private key is a b bit string k.
h i for all integer
i, c <  i < n.
Let s determine the multiple A
The EdDSA public key is ENC(A).
3.3.  Sign The EdDSA signature of a message M under a private key k is defined as the PureEdDSA signature of PH(M).
In other words, EdDSA simply uses PureEdDSA to sign PH(M).
R and S are derived as follows.
Let R   [r]B and S   (r   H(ENC(R)
The s used here is from the previous section.
To verify a PureEdDSA signature ENC(R)
ENC(S) on a message M under a public key ENC(A), proceed as follows.
The signature is rejected if parsing fails (including S being out of range) or if the group equation does not hold.
EdDSA verification for a message M is defined as PureEdDSA verification for PH(M).
PureEdDSA, HashEdDSA, and Naming One of the parameters of the EdDSA algorithm is the "prehash" function.
This may be the identity function, resulting in an algorithm called PureEdDSA, or a collision resistant hash function such as SHA 512, resulting in an algorithm called HashEdDSA.
Choosing which variant to use depends on which property is deemed to be more important between 1) collision resilience and 2) a single  pass interface for creating signatures.
The collision resilience property means EdDSA is secure even if it is feasible to compute collisions for the hash function.
The single pass interface property means that only one pass over the input message is required to create a signature.
PureEdDSA requires two passes over the input.
Many existing APIs, protocols, and environments assume digital signature algorithms only need one pass over the input and may have API or bandwidth concerns supporting anything else.
Note that single pass verification is not possible with most uses of signatures, no matter which signature algorithm is chosen.
This is because most of the time, one can't process the message until the signature is validated, which needs a pass on the entire message.
This document specifies parameters resulting in the HashEdDSA variants Ed25519ph and Ed448ph and the PureEdDSA variants Ed25519 and Ed448.
This section instantiates the general EdDSA algorithm for the edwards25519 and edwards448 curves, each for the PureEdDSA and HashEdDSA variants (plus a contextualized extension of the Ed25519 scheme).
Thus, five different parameter sets are described.
Parameters of Ed25519 For Ed25519, dom2(f,c) is the empty string.
The phflag value is irrelevant.
The context (if present at all) MUST be empty.
This causes the scheme to be one and the same with the Ed25519 scheme published earlier.
The context input SHOULD NOT be empty.
For Ed25519ph, phflag 1 and PH is SHA512 instead.
That is, the input is hashed using SHA 512 before signing with Ed25519.
Value of context is set by the signer and verifier (maximum of 255 octets; the default is empty string, except for Ed25519, which can't have context) and has to match octet by octet for verification to be successful.
The curve used is equivalent to Curve25519 [CURVE25519], under a change of coordinates, which means that the difficulty of the discrete logarithm problem is the same as for Curve25519.
For advice on how to implement arithmetic modulo p
19 efficiently and securely, see Curve25519
For inversion modulo p, it is recommended to use the identity x^ 1
Inverting zero should never happen, as it would require invalid input, which would have been detected before, or would be a calculation error.
For point decoding or "decompression", square roots modulo p are needed.
They can be computed using the Tonelli Shanks algorithm or the special case for p   5
To find a square root of a, first compute the candidate root x   a^((p 3)/8)
Then there are three cases: x^2
Then x is a square root.
x is a square root.
a is not a square modulo
h[31] represents the integer h[0]
A curve point (x,y), with coordinates in the range 0 <
x,y < p, is coded as follows.
First, encode the y coordinate as a little endian string of 32 octets.
The most significant bit of the final octet is always zero.
To form the encoding of the point, copy the least significant bit of the x coordinate to the most significant bit of the final octet.
Decoding Decoding a point, given as a 32 octet string, is a little more complicated.
First, interpret the string as an integer in little endian representation.
Bit 255 of this number is the least significant bit of the x coordinate and denote this value x 0.
The y coordinate is recovered simply by clearing this bit.
If the resulting value is >  p, decoding fails.
To recover the x coordinate, the curve equation implies x^2
(d y^2   1) (mod p).
The denominator is always non zero mod
Let u   y^2 1 and v
To compute the square root of (u/v), the first step is to compute the candidate root x   (u/v)^((p 3)/8).
Again, there are three cases: 1.
u (mod p), x is a square root.
If v x^2    u (mod p), set
x   2^((p 1)/4), which is a square root.
Otherwise, no square root exists for modulo p, and decoding fails.
Finally, use the x 0 bit to select the right square root.
If x   0, and x 0   1, decoding fails.
Otherwise, if x 0 !
x   p x.  Return the decoded point (
For point addition, the following method is recommended.
A point (x,y) is represented in extended homogeneous coordinates (X, Y, Z, T), with x
The neutral point is (0,1), or equivalently in extended homogeneous coordinates (0, Z, Z, 0) for any non zero Z.
The following formulas for adding two points, (x3,y3)
(x2,y2), on twisted Edwards curves with a  1, square a, and non square d are described in Section 3.1 of [Edwards revisited] and in [EFD TWISTED ADD].
They are complete, i.e., they work for any pair of valid input points.
2 d T2 D   Z1 2 Z2 E   B A F
(x1,y1), one could just substitute equal points in the above (because of completeness, such substitution is valid) and observe that four multiplications turn into squares.
However, using the formulas described in Section 3.2 of [Edwards revisited] and in [EFD TWISTED DBL] saves a few smaller operations.
2 H   A B E   H (X1
A B F   C G X3   E F Y3
The private key is 32 octets (256 bits, corresponding to b) of cryptographically secure random data.
See [RFC4086] for a discussion about randomness.
The 32 byte public key is generated by the following steps.
Hash the 32 byte private key using SHA 512,
storing the digest in a 64 octet large buffer, denoted h.
Only the lower 32 bytes are used for generating the public key.
The lowest three bits of the first octet are cleared, the highest bit of the last octet is cleared, and the second highest bit of the last octet is set.
Interpret the buffer as the little endian integer, forming a secret scalar s.
Perform a fixed base scalar multiplication [s]B. 4.
The public key A is the encoding of the point [s]B.
First, encode the y coordinate (in the range 0
as a little  endian string of 32 octets.
The most significant bit of the final octet is always zero.
To form the encoding of the point [s]B, copy the least significant bit of the x coordinate to the most significant bit of the final octet.
The result is the public key.
The inputs to the signing procedure is the private key, a 32 octet string, and a message M of arbitrary size.
and Ed25519ph, there is additionally a context C of at most 255 octets and a flag F, 0 for Ed25519ctx and 1 for Ed25519ph.
Hash the private key, 32 octets, using SHA 512.
Let h denote the resulting digest.
Construct the secret scalar s from the first half of the digest, and the corresponding public key A, as described in the previous section.
Interpret the 64 octet digest as a little  endian integer
r]B.  For efficiency, do this by first reducing r modulo L, the group order of B.
Let the string R be the encoding of this point.
A    PH(M)), and interpret the 64 octet digest as a little endian integer k. 5.
For efficiency, again reduce k modulo L first.
Form the signature of the concatenation of R (32 octets) and the little endian encoding of S (32 octets; the three most significant bits of the final octet are always zero).
To verify a signature on a message M using public key A, with F being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or Ed25519ph is being used, C being the context, first split the signature into two 32 octet halves.
Decode the first half as a point R, and the second half as an integer S, in the range 0
If any of the decodings fail (including S being out of range), the signature is invalid.
A    PH(M)), and interpret the 64 octet digest as a little endian integer k. 3.
Check the group equation [8][S]B
It's sufficient, but not required, to instead check [S]B   R   [k]A'.
Value of context is set by signer and verifier (maximum of 255 octets; the default is empty string) and has to match octet by octet for verification to be successful.
The curve is equivalent to Ed448 Goldilocks under change of the basepoint, which preserves difficulty of the discrete logarithm.
For advice on how to implement arithmetic modulo p
1 efficiently and securely, see [ED448].
For inversion modulo p, it is recommended to use the identity x^ 1
Inverting zero should never happen, as it would require invalid input, which would have been detected before, or would be a calculation error.
For point decoding or "decompression", square roots modulo p are needed.
They can be computed by first computing candidate root x   a ^ (p 1)/4 (mod p)
and then checking if x^2
If it is, then x is the square root of a; if it isn't, then a does not have a square root.
h[56] represents the integer h[0]
A curve point (x,y), with coordinates in the range 0 <
x,y < p, is coded as follows.
First, encode the y coordinate as a little endian string of 57 octets.
The final octet is always zero.
To form the encoding of the point, copy the least significant bit of the x coordinate to the most significant bit of the final octet.
Decoding Decoding a point, given as a 57 octet string, is a little more complicated.
First, interpret the string as an integer in little endian representation.
Bit 455 of this number is the least significant bit of the x coordinate, and denote this value x 0.
The y coordinate is recovered simply by clearing this bit.
If the resulting value is >  p, decoding fails.
To recover the x coordinate, the curve equation implies x^2
(d y^2 1) (mod p).
The denominator is always non zero mod
Let u   y^2 1 and v
To compute the square root of (u/v), the first step is to compute the candidate root x   (u/v)^((p 1)/4).
This can be done using the following trick, to use a single modular powering for both the inversion of v and the square root:
u, the recovered x coordinate is x.
Otherwise, no square root exists, and the decoding fails.
Finally, use the x 0 bit to select the right square root.
If x   0, and x 0   1, decoding fails.
Otherwise, if x 0 !
x   p x.  Return the decoded point (
For point addition, the following method is recommended.
A point (x,y) is represented in projective coordinates (X, Y, Z), with x
The neutral point is (0,1), or equivalently in projective coordinates (0, Z, Z) for any non zero Z.
The following formulas for adding two points, (x3,y3)
on untwisted Edwards curve (i.e., a 1) with non  square d, are described in Section 4 of [Faster ECC] and in [EFD ADD].
They are complete, i.e., they work for any pair of valid input points.
A^2 C   X1 X2 D   Y1 Y2 E   d
E G   B E H
(X1 Y1) (X2 Y2) X3
A F (H C D)
A G (D C) Z3   F G
Again, similar to the other curve, doubling formulas can be obtained by substituting equal points, turning four multiplications into squares.
However, this is not even nearly optimal; the following formulas described in Section 4 of [Faster ECC] and in [EFD DBL] save multiple multiplications.
2 E   C D H   Z1^
2 J   E 2 H X3
The private key is 57 octets (456 bits, corresponding to b) of cryptographically secure random data.
See [RFC4086] for a discussion about randomness.
The 57 byte public key is generated by the following steps: 1.
the 57 byte private key using SHAKE256(x, 114), storing the digest in a 114 octet large buffer, denoted h.
Only the lower 57 bytes are used for generating the public key.
Prune the buffer: The two least significant bits of the first octet are cleared, all eight bits the last octet are cleared, and the highest bit of the second to last octet is set.
Interpret the buffer as the little endian integer, forming a secret scalar s.
Perform a known base point scalar multiplication [s]B. 4.
The public key A is the encoding of the point [s]B.
First encode the y coordinate (in the range 0
<  y < p) as a little endian string of 57 octets.
The most significant bit of the final octet is always zero.
To form the encoding of the point [s]B, copy the least significant bit of the x coordinate to the most significant bit of the final octet.
The result is the public key.
The inputs to the signing procedure is the private key, a 57 octet string, a flag F, which is 0 for Ed448, 1 for Ed448ph, context C of at most 255 octets, and a message M of arbitrary size.
the private key, 57 octets, using SHAKE256(x, 114).
Let h denote the resulting digest.
Construct the secret scalar s from the first half of the digest, and the corresponding public key A, as described in the previous section.
Interpret the 114 octet digest as a little endian integer
r]B.  For efficiency, do this by first reducing r modulo L, the group order of B.
Let the string R be the encoding of this point.
A    PH(M), 114), and interpret the 114 octet digest as a little endian integer k. 5.
For efficiency, again reduce k modulo L first.
Form the signature of the concatenation of R (57 octets) and the little endian encoding of S (57 octets; the ten most significant bits of the final octets are always zero).
To verify a signature on a message M using context C and public key A, with F being 0 for Ed448 and 1 for Ed448ph, first split the signature into two 57 octet halves.
Decode the first half as a point R, and the second half as an integer S, in the range 0
If any of the decodings fail (including S being out of range), the signature is invalid.
A    PH(M), 114), and interpret the 114 octet digest as a little endian integer k. 3.
Check the group equation [
It's sufficient, but not required, to instead check [S]B   R   [k]A'.
The rest of this section describes how Ed25519 can be implemented in Python
(version 3.2 or later) for illustration.
See Appendix A for the complete implementation and Appendix B for a test driver to run it through some test vectors.
Note that this code is not intended for production as it is not proven to be correct for all inputs, nor does it protect against side channel attacks.
The purpose is to illustrate the algorithm to help implementers with their own implementation.
## First, some preliminaries that will be needed.
# Base field Z p p   2  255 19 def modp inv(x): return pow(x, p 2, p)
# Curve constant d    121665
## Then follows functions to perform point operations.
# Points are represented as tuples (X, Y, Z, T) of extended # coordinates, with x
x y   T/Z def point add(P, Q)
% p; C, D   2
% p; E, F, G, H   B A, D C, D C, B A; return (E F, G H, F G, E H);
Q def point mul(s, P):
> 0: if s & 1:
add(Q, P) P   point add(P, P) s
1 return Q def point equal(P, Q):
# x1 / z1   x2 / z2
: return False if (P[1]
: return False return True
## Now follows functions for point compression.
x coordinate, with low bit corresponding to # sign, or return None on failure def recover x(y, sign):
if y >  p: return None x2
(y y 1)   modp inv(d y
y 1) if x2   0: if sign: return None else: return 0 # Compute square root of x2 x   pow(x2, (p 3) //
x x2) % p !
x   x   modp sqrt m1 % p
if (x x x2) % p !
: return None if (x & 1) !
x   p x return x # Base point g
x, g y, 1, g
32: raise Exception("Invalid input length for decompression")
x   recover x(y, sign) if x is None: return None else: return (
x, y, 1, x y % p)
## These are functions for manipulating the private key.
def secret expand(secret): if len(secret) !
32: raise Exception("Bad size of private key")
def secret to public(secret): (a, dummy)
## The signature function works as below.
a) % q return Rs
## And finally the verification function.
32: raise Exception("Bad public key length") if len(signature) !
hA   point mul(h, A) return point equal(sB, point add(R, hA))
This section contains test vectors for Ed25519ph, Ed25519ctx, Ed448ph, Ed25519, and Ed448.
Each section contains a sequence of test vectors.
The octets are hex encoded, and whitespace is inserted for readability.
Ed25519, Ed25519ctx, and Ed25519ph private and public keys are 32 octets; signatures are 64 octets.
Ed448 and Ed448ph private and public keys are 57 octets; signatures are 114 octets.
Messages are of arbitrary length.
If the context is non empty, it is given as 1 255 octets.
These test vectors are taken from [ED25519 TEST VECTORS]
(but we removed the public key as a suffix of the private key and removed the message from the signature) and [ED25519 LIBGCRYPT TEST VECTORS].
: d75a980182b10ab7d54bfed3c964073a 0ee172f3daa62325af021a68f707511a MESSAGE (length 0 bytes): SIGNATURE: e5564300c360ac729086e2cc806e828a 84877f1eb8e5d974d873e06522490155
PUBLIC KEY: 3d4017c3e843895a92b70aa74d1b7ebc 9c982ccf2ec4968cc0cd55f12af4660c MESSAGE (length 1 byte): 72 SIGNATURE:
fc51cd8e6218a1a38da47ed00230f058 0816ed13ba3303ac5deb911548908025 MESSAGE (length 2 bytes):
SECRET KEY: f5e5767cf153319517630f226876b86c 8160cc583bc013744c6bf255f5cc0ee5 PUBLIC KEY: 278117fc144c72340f67d0f2316e8386 ceffbf2b2428c9c51fef7c597f1d426e MESSAGE (length 1023 bytes):
ba5e43f1bca32301651339e22904cc8c 42f58c30c04aafdb038dda0847dd988d cda6f3bfd15c4b4c4525004aa06eeff8 ca61783aacec57fb3d1f92b0fe2fd1a8 5f6724517b65e614ad6808d6f6ee34df
984a74d37145986780fc0b16ac451649 de6188a7dbdf191f64b5fc5e2ab47b57 f7f7276cd419c17a3ca8e1b939ae49e4 88acba6b965610b5480109c8b17b80e1 b7b750dfc7598d5d5011fd2dcc5600a3 2ef5b52a1ecc820e308aa342721aac09
43bf6686b64b2579376504ccc493d97e 6aed3fb0f9cd71a43dd497f01f17c0e2 cb3797aa2a2f256656168e6c496afc5f b93246f6b1116398a346f1a641f3b041 e989f7914f90cc2c7fff357876e506b5 0d334ba77c225bc307ba537152f3f161 0e4eafe595f6d9d90d11faa933a15ef1
ec172b93ad5e563bf4932c70e1245034 c35467ef2efd4d64ebf819683467e2bf MESSAGE (length 64 bytes): ddaf35a193617abacc417349ae204131
0305334e381af78f141cb666f6199f57 bc3495335a256a95bd2a55bf546663f6 PUBLIC KEY: dfc9425e4f968f7f0c29f0259cf5f9ae d6851c2bb4ad8bfb860cfee0ab248292 MESSAGE (length 16 bytes)
: f726936d19c800494e3fdaff20b276a8 CONTEXT: 666f6f SIGNATURE: 55a4cc2f70a54e04288c5f4cd1e45a7b b520b36292911876cada7323198dd87a 8b36950b95130022907a7fb7c4e9b2d5 f6cca685a587b4b21f4b888e4e7edb0d  bar ALGORITHM:
0305334e381af78f141cb666f6199f57 bc3495335a256a95bd2a55bf546663f6 PUBLIC KEY: dfc9425e4f968f7f0c29f0259cf5f9ae d6851c2bb4ad8bfb860cfee0ab248292 MESSAGE (length 16 bytes):
0305334e381af78f141cb666f6199f57 bc3495335a256a95bd2a55bf546663f6 PUBLIC KEY: dfc9425e4f968f7f0c29f0259cf5f9ae d6851c2bb4ad8bfb860cfee0ab248292 MESSAGE (length 16 bytes):
3275a1fc0b65fd71b4b0dda10ad7d772 MESSAGE (length 16 bytes):
f726936d19c800494e3fdaff20b276a8 CONTEXT: 666f6f SIGNATURE: 21655b5f1aa965996b3f97b3c849eafb a922a0a62992f73b3d1b73106a84ad85 e9b86a7b6005ea868337ff2d20a7f5fb d4cd10b0be49a68da2b2e0dc0ad8960f   7.3.
Test Vectors for Ed25519ph  TEST
ec172b93ad5e563bf4932c70e1245034 c35467ef2efd4d64ebf819683467e2bf MESSAGE (length 3 bytes): 616263 SIGNATURE: 98a70222f0b8121aa9d30f813d683f80 9e462b469c7ff87639499bb94e6dae41 31f85042463c2a355a2003d062adf5aa
Test Vectors for Ed448  Blank ALGORITHM:
d1fa1abeafe8256180 MESSAGE (length 0 bytes): SIGNATURE: 533a37f6bbe457251f023c0d88f976ae 2dfb504a843e34d2074fd823d41a591f
235160627b4c3a9480 MESSAGE (length 1 byte): 03 SIGNATURE: 26b8f91727bd62897af15e41eb43c377 efb9c610d48f2335cb0bd0087810f435 2541b143c4b981b7e18f62de8ccdf633
235160627b4c3a9480 MESSAGE (length 1 byte): 03 CONTEXT: 666f6f SIGNATURE:
1d8b00696447001400 MESSAGE (length 11 bytes):
258cdd4ada32ed9c9ff54e63756ae582 fb8fab2ac721f2c8e676a72768513d93 9f63dddb55609133f29adf86ec9929dc cb52c1c5fd2ff7e21b PUBLIC KEY:
3ba16da0c6f2cc1f30187740756f5e79 8d6bc5fc015d7c63cc9510ee3fd44adc 24d8e968b6e46e6f94d19b945361726b d75e149ef09817f580 MESSAGE (length 12 bytes):
Ed448 SECRET KEY: 7ef4e84544236752fbb56b8f31a23a10 e42814f5f55ca037cdcc11c64c9a3b29
5c5dc59e176b4d9f381ca0938e13c6c0 7b174be65dfa578e80 MESSAGE (length 13 bytes): 64a65f3cdedcdd66811e2915e7 SIGNATURE: 6a12066f55331b6c22acd5d5bfc5d712 28fbda80ae8dec26bdd306743c5027cb 4890810c162c027468675ecf645a8317
d65df341ad13e008567688baedda8e9d cdc17dc024974ea5b4227b6530e339bf f21f99e68ca6968f3cca6dfe0fb9f4fa b4fa135d5542ea3f01 PUBLIC KEY:
b1c6132c20a9f1dd163483a26f8ac53a 39d6808bf4a1dfbd261b099bb03b3fb5 0906cb28bd8a081f00 MESSAGE (length 64 bytes):
2ec5fe3c17045abdb136a5e6a913e32a b75ae68b53d2fc149b77e504132d3756 9b7e766ba74a19bd6162343a21c8590a a9cebca9014c636df5 PUBLIC KEY: 79756f014dcfe2079f5dd9e718be4171
e2ef2486a08f25186f6bff43a9936b9b fe12402b08ae65798a3d81e22e9ec80e 7690862ef3d4ed3a00 MESSAGE (length 256 bytes)
: 15777532b0bdd0d1389f636c5f6b9ba7 34c90af572877e2d272dd078aa1e567c fa80e12928bb542330e8409f31745041 07ecd5efac61ae7504dabe2a602ede89 e5cca6257a7c77e27a702b3ae39fc769
Ed448 SECRET KEY: 872d093780f5d3730df7c212664b37b8 a0f24f56810daa8382cd4fa3f77634ec 44dc54f1c2ed9bea86fafb7632d8be19
a08effb81c5d685c0c56f64eecaef8cd f11cc38737838cf400 MESSAGE (length 1023 bytes):
72660cf4b6a9b369a6665f02e0cc9b6e dfad136b4fabe723d2813db3136cfde9 b6d044322fee2947952e031b73ab5c60 3349b307bdc27bc6cb8b8bbd7bd32321 9b8033a581b59eadebb09b3c4f3d2277 d4f0343624acc817804728b25ab79717
155baee3b0773c0f497c573f19bb4f42 40281f0b1f4f7be857a4e59d416c06b4 c50fa09e1810ddc6b1467baeac5a3668 d11b6ecaa901440016f389f80acc4db9 77025e7f5924388c7e340a732e554440
Test Vectors for Ed448ph  TEST
c09428a131d6b1b57303d90d8132c276 d5ed3d5d01c0f53880 MESSAGE (length 3 bytes):
616263 SIGNATURE: 822f6901f7480f3d5f562c592994d969 3602875614483256505600bbc281ae38 1f54d6bce2ea911574932f52a4e6cadd 78769375ec3ffd1b801a0d9b3f4030cd 433964b6457ea39476511214f97469b5
c09428a131d6b1b57303d90d8132c276 d5ed3d5d01c0f53880 MESSAGE (length 3 bytes):
c32299d46ec8ff02b54540982814dce9 a05812f81962b649d528095916a2aa48 1065b1580423ef927ecf0af5888f90da 0f6a9a85ad5dc3f280d91224ba9911a3 653d00e484e2ce232521481c8658df30
For implementations performing signatures, secrecy of the private key is fundamental.
It is possible to protect against some side channel attacks by ensuring that the implementation executes exactly the same sequence of instructions and performs exactly the same memory accesses, for any value of the private key.
To make an implementation side channel silent in this way, the modulo p arithmetic must not use any data dependent branches, e.g., related to carry propagation.
Side channel silent point addition is straightforward, thanks to the unified formulas.
Scalar multiplication, multiplying a point by an integer, needs some additional effort to implement in a side channel silent manner.
One simple approach is to implement a side channel silent conditional assignment, and use it together with the binary algorithm to examine one bit of the integer at a time.
Compared to other signature schemes, avoiding data dependent branches is easier due to side channel silent modulo p arithmetic being easier (with recommended curves) and having complete addition formulas instead of having a number of special cases.
Note that the example implementations in this document do not attempt to be side channel silent.
Randomness Considerations EdDSA signatures are deterministic.
This protects against attacks arising from signing with bad randomness; the effects of which can, depending on the algorithm, range up to full private key compromise.
It can be surprisingly hard to ensure good quality random numbers, and there have been numerous security failures relating to this.
Obviously, private key generation requires randomness, but due to the fact that the private key is hashed before use, a few missing bits of entropy doesn't constitute a disaster.
The basic signature verification is also deterministic.
However, some speedups by verifying multiple signatures at once do require random numbers.
Use of Contexts Contexts can be used to separate uses of the protocol between different protocols (which is very hard to reliably do otherwise) and between different uses within the same protocol.
However, the following SHOULD be kept in mind when using this facility: The context SHOULD be a constant string specified by the protocol using it.
It SHOULD NOT incorporate variable elements from the message itself.
Contexts SHOULD NOT be used opportunistically, as that kind of use is very error prone.
If contexts are used, one SHOULD require all signature schemes available for use in that purpose support contexts.
Contexts are an extra input, which percolate out of APIs; as such, even if the signature scheme supports contexts, those may not be available for use.
This problem is compounded by the fact that many times the application is not invoking the signing and verification functions directly but via some other protocol.
Some systems assume signatures are not malleable: that is, given a valid signature for some message under some key, the attacker can't produce another valid signature for the same message and key.
Ed25519 and Ed448 signatures are not malleable due to the verification check that decoded S is smaller than l.
Without this check, one can add a multiple of l into a scalar part and still pass signature verification, resulting in malleable signatures.
Primitive Ed25519 and Ed25519ph have a nominal strength of 128 bits, whereas Ed448 and Ed448ph have the strength of 224.
While the lower strength is sufficient for the foreseeable future, the higher level brings some defense against possible future cryptographic advances.
Both are demolished by quantum computers just about the same.
The Ed25519ph and Ed448ph variants are prehashed.
This is mainly useful for interoperation with legacy APIs, since in most of the cases, either the amount of data signed is not large or the protocol is in the position to do digesting in ways better than just prehashing (e.g., tree hashing or splitting the data).
The prehashing also makes the functions greatly more vulnerable to weaknesses in hash functions used.
These variants SHOULD NOT be used.
Ed25519ctx and Ed448 have contexts.
However, this is balanced by the problems noted in Section 8.3 about contexts.
On the implementation front, Ed25519 is widely implemented and has many high quality implementations.
The others have much worse support.
In summary, if a high 128 bit security level is enough, use of Ed25519 is RECOMMENDED; otherwise, Ed448 is RECOMMENDED.
The schemes described in this document are designed to be resistant to mixing prehashes.
That is, it is infeasible to find a message that verifies using the same signature under another scheme, even if the original signed message was chosen.
Thus, one can use the same key pair for Ed25519, Ed25519ctx, and Ed25519ph and correspondingly with Ed448 and Ed448ph.
The "SigEd25519 no Ed25519 collisions" constant is chosen to be a textual string such that it does not decode as a point.
Because the inner hash input in the Ed25519 signature always starts with a valid point, there is no way trivial collision can be constructed.
In the case of seed hash, trivial collisions are so unlikely, even with an attacker choosing all inputs, that it is much more probable that something else goes catastrophically wrong.
Signing Large Amounts of Data at Once
Avoid signing large amounts of data at once (where "large" depends on the expected verifier).
In particular, unless the underlying protocol does not require it, the receiver MUST buffer the entire message (or enough information to reconstruct it, e.g., compressed or encrypted version) to be verified.
This is needed because most of the time, it is unsafe to process unverified data, and verifying the signature makes a pass through the whole message, causing ultimately at least two passes through.
As an API consideration, this means that any Initialize Update Finalize (IFU) verification interface is prone to misuse.
It is a bad idea to modify Ed25519 or Ed448 signing to be able to create valid Ed25519/Ed448 signatures using an IUF interface with only constant buffering.
Pretty much any error in such would cause catastrophic security failure.
Multiplication by Cofactor in Verification
The given verification formulas for both Ed25519 and Ed448 multiply points by the cofactor.
While this is not strictly necessary for security (in fact, any signature that meets the non multiplied equation will satisfy the multiplied one), in some applications it is undesirable for implementations to disagree about the exact set of valid signatures.
Such disagreements could open up, e.g., fingerprinting attacks.
Use of SHAKE256 as a Hash Function Ed448 uses SHAKE256 as a hash function, even if SHAKE256 is specifically defined not to be a hash function.
The first potentially troublesome property is that shorter outputs are prefixes of longer ones.
This is acceptable because output lengths are fixed.
The second potentially troublesome property is failing to meet standard hash security notions (especially with preimages).
However, the estimated 256 bit security level against collisions and preimages is sufficient to pair with a 224 bit level elliptic curve.
Below is an example implementation of Ed25519/Ed448 written in Python; version 3.2 or higher is required.
Note: This code is not intended for production.
Although it should produce correct results for every input, it is slow and makes no attempt to avoid side channel attacks.
import hashlib; import os; #Compute candidate square root of x modulo p, with p
#Compute candidate square root of x modulo p, with p   5
If the square root exists, it is either y or y
if (y   y) % p   x % p: return y else:
z   pow(2,(p 1)//4,p) return (y   z
) % p #Decode a hexadecimal string representation of the integer.
x by b places to the left.
: return ((x << b)
& (2  64 1) #From little endian.
: return int.from bytes(s, byteorder "little")
#Do the SHA 3 state transform on state s. def sha3 transform(s
): ROTATIONS   [0,1,62,28,27,36,44,6,55,20,3,10,43,25,39,41,45,15,\ 21,8,18,2,61,56,14] PERMUTATION
0x000000008000808b,0x800000000000008b,0x8000000000008089,\ 0x8000000000008003,0x8000000000008002,0x8000000000000080,\ 0x000000000000800a,0x800000008000000a,0x8000000080008081,\ 0x8000000000008080,0x0000000080000001,0x8000000080008008] for rnd in range(0,24):
; for i in range(0,25): c[i%5]^ s[i] for i in range(0,5): d[i] c[(i
4)%5]^rol(c[(i 1)%5],1) for i in range(0,25)
#RotateWords (Rho) for i in range(0,25): s[i] rol(s[i],ROTATIONS[i])
for i in range(0,len(PERMUTATION) 1): s[PERMUTATION[i]] s[PERMUTATION[i 1]]
t; #NonlinearMixRows (Chi) for i in range(0,25,5)
: t [s[i],s[i 1],s[i 2],s[i 3],s[i
4],s[i],s[i 1]] for j in range(0,5):
#Reinterpret octet array b to word array and XOR
it to state s. def reinterpret to words and xor(s,b): for j in range(0,len(b)//8)
: s[j]^ from le(b[8 j:][:8])
to octet array and return it.
def reinterpret to octets(w): mp bytearray() for j in range(0,len(w))
generic SHA 3 implementation def sha3 raw(msg,r w,o p,e b): r b 8 r w s [0] 25
idx 0 blocks len(msg)//r b for i in range(0,blocks): reinterpret to words and
xor(s,msg[idx:][:r b]) idx  r b
128 #Handle padded last block.
reinterpret to words and xor(s
out   bytearray() while len(out)<e b: out  reinterpret to octets(s[:r w])
def shake256(msg,olen): return sha3 raw(msg,17,31,olen)
#Check that fields of self and y are the same.
if type(y) is not Field or self.
truediv (self,y): return self y.inv()
#Field inverse (inverse of 0 is 0).
Returns none if square root does not exist.
#Note: not presently implemented for p mod 8   1 case.
else: raise NotImplementedError("sqrt( ,8k 1)")
p); #Check square root candidate valid.
y if  y  y self else
None #Make the field element with the same field as this, but #with a different value.
#Is the field element the additive identity?
p y. p #Are field elements not equal?
return not (self y) #Serialize number to b 1 bits.
def frombytes(self,x,b): rv from le(x)%(2
p else None #Compute sign of number, 0 or 1.
The sign function #has the following property:
#sign(x)   1 sign( x) if x !
#A point on (twisted) Edwards curve.
#Check that point encoding is the correct length.
if y is None: return (None,None)
If it does not exist, or if zero and xs #are wrong, fail.
x self.solve x2(y).sqrt() if x is None or (x.iszero() and xs!
): return (None,None) #If sign of x isn't correct, flip it.
# Return the constructed point.
(x,y) def encode base(self,b): xp,yp self.x/self.z
#Add sign bit of x to encoding.
1<<(b 1)%8 return s def  mul (self,x): r self.zero elem
() s self while x
if (x%2)>0: r r s s s.double()
#Check that two points are equal.
def  eq (self,y): #Need to check x1/z1   x2/z2 and similarly for y, so cross #multiply to eliminate divisions.
y.z yn2 y.y self.z return xn1 xn2 and yn1 yn2
#Check if two points are not equal.
#Create a new point on the curve.
base field.make(121665)/base field.make(121666) f0 base field.make(0)
@staticmethod def stdbase(): return Edwards25519Point(Edwards25519Point.xb,\ Edwards25519Point.yb)
#Check the point is actually on the curve.
x,y self.decode base(s,256); return Edwards25519Point(x, y) if x is not None else None #Encode a point representation.
def encode(self): return self.encode base(256)
#Construct a neutral point on this curve.
def zero elem(self): return Edwards25519Point(self.f0,self.f1)
: return ((y y self.f1)/(self.d
The formulas are from EFD.
(y.y y.x) B (self.y self.x)
(y.y y.x) C (self.d self.d)
y.t D zcp zcp E
,H B A,B A F,G D C,D C tmp.x,tmp.y,tmp.z,
tmp.t E F,G H,F G
,E H return tmp #Point doubling.
#The formulas are from EFD (with assumption a  1 propagated).
xys G A B F C G tmp.x,tmp.y,tmp.z,tmp.t E F,G H,F G
,E H return tmp #Order of basepoint.
def c(self): return 3 #The highest set bit def n(self): return 254
#The coding length def b(self)
: return 256 #Validity check (for debugging)
x,y,z,t self.x,self.y,self.z,self.t x2 x x y2
z2 z2 self.d x2 y2 assert(lhs
#Create a new point on the curve.
@staticmethod def stdbase(): return Edwards448Point(Edwards448Point.xb,
#Check that the point is actually on the curve.
x,y self.decode base(s,456); return Edwards448Point(x, y)
if x is not None else None #Encode a point representation.
#Construct a neutral point on this curve.
def zero elem(self): return Edwards448Point(self.f0,self.f1)
: return ((y y self.f1)/(self.d
The formulas are from EFD.
zcp E self.d xcp ycp F,G B E
,B E tmp.x zcp F ((self.x self.y)
(ycp xcp),F G return tmp
The formulas are from EFD.
tmp self.zero elem() x1s,y1s,z1s self.x self.x,self.y self.y,
self.y F x1s y1s J F (z1s z1s) tmp.x,tmp.y,tmp.z (xys xys x1s y1s) J,F (x1s
y1s),F J return tmp #Order of basepoint.
): return 2 #The highest set bit.
: return 447 #The coding length.
: return 456 #Validity check (for debugging).
z2 z2 self.d x2 y2 assert(lhs
def curve self check(point): p point q
1 p.is valid point() q.is valid point() for i in range(0,point.b()):
q q p q.is valid point() p
() p.is valid point() assert q.encode()
def self check curves(): curve self check(Edwards25519Point.stdbase()) curve self check(Edwards448Point.stdbase())
only b mod 8   0 is handled.
class PureEdDSA: #Create a new object.
If privkey is None, a random one is generated.
In any case, the (privkey, pubkey) pair is returned.
If no private key data is given, generate random.
if privkey is None: privkey os.urandom(self.b//8)
#Return the key pair (public key is A Enc(aB).
#Calculate r and R (R only used in encoded form).
#Calculate h. h from le(self.
H(R pubkey msg,ctx,hflag))%self.l #Calculate s. S ((
#The final signature is a concatenation of R and S. return R S #Verify signature with public key.
: return False if len(pubkey)!
: return False #Split signature into R and S, and parse.
if (R is None) or (A is None) or S
return False #Calculate h. h from le(self.
,hflag))%self.l #Calculate left and right sides of check eq.
B S for i in range(0, self.c)
Ed25519 inthash(data,ctx,hflag): if (ctx is not None and len(ctx)
> 0) or hflag: raise ValueError("Contexts/hashes not supported")
no Ed25519 collisions" if ctx is not None: if len(ctx)
dompfx PREFIX bytes([1 if hflag else 0,len(ctx)]
"" if ctx is not None: if len(ctx)
dompfx b"SigEd448" bytes([1 if hflag else 0,len(ctx)])
#Create a new scheme object, with the specified PureEdDSA base #scheme and specified prehash.
def  init (self,pure scheme,prehash): self.
False # Generate a key.
If privkey is none, it generates a random # privkey key, otherwise it uses a specified private key.
# Returns pair (privkey, pubkey).
# Sign message msg using specified key pair.
if ctx is None: ctx b""; return self.
# Verify signature sig on message msg using public key pubkey.
def verify(self,pubkey,msg,sig,ctx None): if ctx is None: ctx b""; return self.
Ed25519ph   EdDSA(pEd25519ctx,lambda x,y:hashlib.sha512(x).digest()) Ed448   EdDSA(pEd448,None)
if name   "Ed25519": return Ed25519 if name   "Ed25519ctx": return Ed25519ctx
if name   "Ed25519ph": return Ed25519ph if name   "Ed448": return Ed448 if name   "Ed448ph": return Ed448ph
Appendix B.  Library Driver Below is a command line tool that uses the library above to perform computations for interactive use or for self checking.
import sys import binascii from eddsa2 import
Ed25519 def munge string(s, pos, change):
# Read a file in the format of # http://ed25519.cr.yp.to/python/sign.input lineno   0
() if not line: break lineno   lineno
) assert public   pubkey assert signature   Ed25519.sign(privkey, pubkey, msg) assert Ed25519.verify(public, msg, signature)
: bad msg   b"x" else
assert not Ed25519.verify(public, msg, munge string(signature,20,8))
