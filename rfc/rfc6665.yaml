- contents:
  - '                    SIP-Specific Event Notification

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes an extension to the Session Initiation\n
    \  Protocol (SIP) defined by RFC 3261.  The purpose of this extension is\n   to
    provide an extensible framework by which SIP nodes can request\n   notification
    from remote nodes indicating that certain events have\n   occurred.\n   Note that
    the event notification mechanisms defined herein are NOT\n   intended to be a
    general-purpose infrastructure for all classes of\n   event subscription and notification.\n
    \  This document represents a backwards-compatible improvement on the\n   original
    mechanism described by RFC 3265, taking into account several\n   years of implementation
    experience.  Accordingly, this document\n   obsoletes RFC 3265.  This document
    also updates RFC 4660 slightly to\n   accommodate some small changes to the mechanism
    that were discussed\n   in that document.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6665.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  5\n     1.1.  Overview of Operation  . . . . . . . . . . . . . .
    . . . .  5\n     1.2.  Documentation Conventions  . . . . . . . . . . . . . .
    . .  6\n   2.  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 6\n   3.  SIP Methods for Event Notification . . . . . . . . . . . . . .  7\n
    \    3.1.  SUBSCRIBE  . . . . . . . . . . . . . . . . . . . . . . . .  7\n       3.1.1.
    \ Subscription Duration  . . . . . . . . . . . . . . . .  7\n       3.1.2.  Identification
    of Subscribed Events and Event\n               Classes  . . . . . . . . . . .
    . . . . . . . . . . . .  8\n       3.1.3.  Additional SUBSCRIBE Header Field Values
    . . . . . . .  9\n     3.2.  NOTIFY . . . . . . . . . . . . . . . . . . . . .
    . . . . .  9\n       3.2.1.  Identification of Reported Events, Event Classes,\n
    \              and Current State  . . . . . . . . . . . . . . . . . .  9\n   4.
    \ Node Behavior  . . . . . . . . . . . . . . . . . . . . . . . . 10\n     4.1.
    \ Subscriber Behavior  . . . . . . . . . . . . . . . . . . . 10\n       4.1.1.
    \ Detecting Support for SIP Events . . . . . . . . . . . 10\n       4.1.2.  Creating
    and Maintaining Subscriptions . . . . . . . . 10\n       4.1.3.  Receiving and
    Processing State Information . . . . . . 14\n       4.1.4.  Forking of SUBSCRIBE
    Requests  . . . . . . . . . . . . 16\n     4.2.  Notifier Behavior  . . . . .
    . . . . . . . . . . . . . . . 17\n       4.2.1.  Subscription Establishment and
    Maintenance . . . . . . 17\n       4.2.2.  Sending State Information to Subscribers
    . . . . . . . 20\n       4.2.3.  PSTN/Internet Interworking (PINT) Compatibility
    \ . . . 23\n     4.3.  Proxy Behavior . . . . . . . . . . . . . . . . . . . .
    . . 23\n     4.4.  Common Behavior  . . . . . . . . . . . . . . . . . . . . .
    24\n       4.4.1.  Dialog Creation and Termination  . . . . . . . . . . . 24\n
    \      4.4.2.  Notifier Migration . . . . . . . . . . . . . . . . . . 24\n       4.4.3.
    \ Polling Resource State . . . . . . . . . . . . . . . . 25\n       4.4.4.  \"Allow-Events\"
    Header Field Usage  . . . . . . . . . . 26\n     4.5.  Targeting Subscriptions
    at Devices . . . . . . . . . . . . 26\n       4.5.1.  Using GRUUs to Route to
    Devices  . . . . . . . . . . . 27\n       4.5.2.  Sharing Dialogs  . . . . . .
    . . . . . . . . . . . . . 27\n     4.6.  CANCEL Requests for SUBSCRIBE and NOTIFY
    Transactions  . . 29\n   5.  Event Packages . . . . . . . . . . . . . . . . .
    . . . . . . . 29\n     5.1.  Appropriateness of Usage . . . . . . . . . . . .
    . . . . . 29\n     5.2.  Event Template-Packages  . . . . . . . . . . . . . .
    . . . 30\n     5.3.  Amount of State to Be Conveyed . . . . . . . . . . . . .
    . 31\n       5.3.1.  Complete State Information . . . . . . . . . . . . . . 31\n
    \      5.3.2.  State Deltas . . . . . . . . . . . . . . . . . . . . . 32\n     5.4.
    \ Event Package Responsibilities . . . . . . . . . . . . . . 32\n       5.4.1.
    \ Event Package Name . . . . . . . . . . . . . . . . . . 33\n       5.4.2.  Event
    Package Parameters . . . . . . . . . . . . . . . 33\n       5.4.3.  SUBSCRIBE
    Request Bodies . . . . . . . . . . . . . . . 33\n       5.4.4.  Subscription Duration
    \ . . . . . . . . . . . . . . . . 33\n       5.4.5.  NOTIFY Request Bodies  .
    . . . . . . . . . . . . . . . 34\n       5.4.6.  Notifier Processing of SUBSCRIBE
    Requests  . . . . . . 34\n       5.4.7.  Notifier generation of NOTIFY requests
    . . . . . . . . 34\n       5.4.8.  Subscriber Processing of NOTIFY Requests .
    . . . . . . 34\n       5.4.9.  Handling of Forked Requests  . . . . . . . . .
    . . . . 34\n       5.4.10. Rate of Notifications  . . . . . . . . . . . . . .
    . . 35\n       5.4.11. State Aggregation  . . . . . . . . . . . . . . . . . .
    35\n       5.4.12. Examples . . . . . . . . . . . . . . . . . . . . . . . 36\n
    \      5.4.13. Use of URIs to Retrieve State  . . . . . . . . . . . . 36\n   6.
    \ Security Considerations  . . . . . . . . . . . . . . . . . . . 36\n     6.1.
    \ Access Control . . . . . . . . . . . . . . . . . . . . . . 36\n     6.2.  Notifier
    Privacy Mechanism . . . . . . . . . . . . . . . . 36\n     6.3.  Denial-of-Service
    Attacks  . . . . . . . . . . . . . . . . 37\n     6.4.  Replay Attacks . . . .
    . . . . . . . . . . . . . . . . . . 37\n     6.5.  Man-in-the-Middle Attacks  .
    . . . . . . . . . . . . . . . 37\n     6.6.  Confidentiality  . . . . . . . .
    . . . . . . . . . . . . . 38\n   7.  IANA Considerations  . . . . . . . . . .
    . . . . . . . . . . . 38\n     7.1.  Event Packages . . . . . . . . . . . . .
    . . . . . . . . . 38\n       7.1.1.  Registration Information . . . . . . . .
    . . . . . . . 39\n       7.1.2.  Registration Template  . . . . . . . . . . .
    . . . . . 40\n     7.2.  Reason Codes . . . . . . . . . . . . . . . . . . . .
    . . . 40\n     7.3.  Header Field Names . . . . . . . . . . . . . . . . . . .
    . 41\n     7.4.  Response Codes . . . . . . . . . . . . . . . . . . . . . . 41\n
    \  8.  Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n     8.1.
    \ New Methods  . . . . . . . . . . . . . . . . . . . . . . . 42\n       8.1.1.
    \ SUBSCRIBE Method . . . . . . . . . . . . . . . . . . . 42\n       8.1.2.  NOTIFY
    Method  . . . . . . . . . . . . . . . . . . . . 42\n     8.2.  New Header Fields
    \ . . . . . . . . . . . . . . . . . . . . 42\n       8.2.1.  \"Event\" Header
    Field . . . . . . . . . . . . . . . . . 42\n       8.2.2.  \"Allow-Events\" Header
    Field  . . . . . . . . . . . . . 43\n       8.2.3.  \"Subscription-State\" Header
    Field  . . . . . . . . . . 43\n     8.3.  New Response Codes . . . . . . . . .
    . . . . . . . . . . . 43\n       8.3.1.  202 (Accepted) Response Code . . . .
    . . . . . . . . . 43\n       8.3.2.  489 (Bad Event) Response Code  . . . . .
    . . . . . . . 44\n     8.4.  Augmented BNF Definitions  . . . . . . . . . . .
    . . . . . 44\n   9.  References . . . . . . . . . . . . . . . . . . . . . . .
    . . . 45\n     9.1.  Normative References . . . . . . . . . . . . . . . . . .
    . 45\n     9.2.  Informative References . . . . . . . . . . . . . . . . . . 46\n
    \  Appendix A.  Acknowledgements  . . . . . . . . . . . . . . . . . . 48\n   Appendix
    B.  Changes from RFC 3265 . . . . . . . . . . . . . . . . 48\n     B.1.  Bug 666:
    Clarify use of \"expires=xxx\" with \"terminated\"  . 48\n     B.2.  Bug 667:
    Reason code for unsub/poll not clearly\n           spelled out  . . . . . . .
    . . . . . . . . . . . . . . . . 48\n     B.3.  Bug 669: Clarify: SUBSCRIBE for
    a duration might be\n           answered with a NOTIFY/expires=0 . . . . . . .
    . . . . . . 48\n     B.4.  Bug 670: Dialog State Machine needs clarification  .
    . . . 49\n     B.5.  Bug 671: Clarify timeout-based removal of subscriptions  .
    49\n     B.6.  Bug 672: Mandate \"expires\" in NOTIFY . . . . . . . . . . . 49\n
    \    B.7.  Bug 673: INVITE 481 response effect clarification  . . . . 49\n     B.8.
    \ Bug 677: SUBSCRIBE response matching text in error . . . . 49\n     B.9.  Bug
    695: Document is not explicit about response to\n           NOTIFY at subscription
    termination . . . . . . . . . . . . 49\n     B.10. Bug 696: Subscription state
    machine needs clarification  . 49\n     B.11. Bug 697: Unsubscription behavior
    could be clarified  . . . 49\n     B.12. Bug 699: NOTIFY and SUBSCRIBE are target
    refresh\n           requests . . . . . . . . . . . . . . . . . . . . . . . . .
    50\n     B.13. Bug 722: Inconsistent 423 reason phrase text . . . . . . . 50\n
    \    B.14. Bug 741: Guidance needed on when to not include\n           \"Allow-Events\"
    . . . . . . . . . . . . . . . . . . . . . . 50\n     B.15. Bug 744: 5xx to NOTIFY
    terminates a subscription, but\n           should not . . . . . . . . . . . .
    . . . . . . . . . . . . 50\n     B.16. Bug 752: Detection of forked requests is
    incorrect . . . . 50\n     B.17. Bug 773: Reason code needs IANA registry . .
    . . . . . . . 50\n     B.18. Bug 774: Need new reason for terminating subscriptions\n
    \          to resources that never change . . . . . . . . . . . . . . 50\n     B.19.
    Clarify Handling of \"Route\"/\"Record-Route\" in NOTIFY . . . 50\n     B.20.
    Eliminate Implicit Subscriptions . . . . . . . . . . . . . 51\n     B.21. Deprecate
    Dialog Reuse . . . . . . . . . . . . . . . . . . 51\n     B.22. Rationalize Dialog
    Creation  . . . . . . . . . . . . . . . 51\n     B.23. Refactor Behavior Sections
    . . . . . . . . . . . . . . . . 51\n     B.24. Clarify Sections That Need to Be
    Present in Event\n           Packages . . . . . . . . . . . . . . . . . . . .
    . . . . . 51\n     B.25. Make CANCEL Handling More Explicit . . . . . . . . .
    . . . 51\n     B.26. Remove \"State Agent\" Terminology . . . . . . . . . . .
    . . 51\n     B.27. Miscellaneous Changes  . . . . . . . . . . . . . . . . . .
    52\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The ability to request asynchronous notification of events
    proves\n   useful in many types of SIP services for which cooperation between\n
    \  end-nodes is required.  Examples of such services include automatic\n   callback
    services (based on terminal state events), buddy lists\n   (based on user presence
    events), message waiting indications (based\n   on mailbox state change events),
    and PSTN and Internet\n   Internetworking (PINT) [RFC2848] status (based on call
    state events).\n   The methods described in this document provide a framework
    by which\n   notification of these events can be ordered.\n   The event notification
    mechanisms defined herein are NOT intended to\n   be a general-purpose infrastructure
    for all classes of event\n   subscription and notification.  Meeting requirements
    for the general\n   problem set of subscription and notification is far too complex
    for a\n   single protocol.  Our goal is to provide a SIP-specific framework for\n
    \  event notification that is not so complex as to be unusable for\n   simple
    features, but that is still flexible enough to provide\n   powerful services.
    \ Note, however, that event packages based on this\n   framework may define arbitrarily
    elaborate rules that govern the\n   subscription and notification for the events
    or classes of events\n   they describe.\n   This document does not describe an
    extension that may be used\n   directly; it must be extended by other documents
    (herein referred to\n   as \"event packages\").  In object-oriented design terminology,
    it may\n   be thought of as an abstract base class that must be derived into an\n
    \  instantiable class by further extensions.  Guidelines for creating\n   these
    extensions are described in Section 5.\n"
  - contents:
    - "1.1.  Overview of Operation\n   The general concept is that entities in the
      network can subscribe to\n   resource or call state for various resources or
      calls in the network,\n   and those entities (or entities acting on their behalf)
      can send\n   notifications when those states change.\n   A typical flow of messages
      would be:\n   Subscriber          Notifier\n       |-----SUBSCRIBE---->|     Request
      state subscription\n       |<-------200--------|     Acknowledge subscription\n
      \      |<------NOTIFY----- |     Return current state information\n       |--------200------->|\n
      \      |<------NOTIFY----- |     Return current state information\n       |--------200------->|\n
      \  Subscriptions are expired and must be refreshed by subsequent\n   SUBSCRIBE
      requests.\n"
    title: 1.1.  Overview of Operation
  - contents:
    - "1.2.  Documentation Conventions\n   There are several paragraphs throughout
      this document that provide\n   motivational or clarifying text.  Such passages
      are non-normative and\n   are provided only to assist with reader comprehension.
      \ These\n   passages are set off from the remainder of the text by being indented\n
      \  thus:\n      This is an example of non-normative explanatory text.  It does
      not\n      form part of the specification and is used only for clarification.\n
      \  The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n
      \  \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in
      this\n   document are to be interpreted as described in [RFC2119].\n   In particular,
      implementors need to take careful note of the meaning\n   of \"SHOULD\" defined
      in RFC 2119.  To rephrase: violation of \"SHOULD\"-\n   strength requirements
      requires careful analysis and clearly\n   enumerable reasons.  It is a protocol
      violation to fail to comply\n   with \"SHOULD\"-strength requirements whimsically
      or for ease of\n   implementation.\n"
    title: 1.2.  Documentation Conventions
  title: 1.  Introduction
- contents:
  - "2.  Definitions\n   Event Package:  An event package is an additional specification
    that\n      defines a set of state information to be reported by a notifier to\n
    \     a subscriber.  Event packages also define further syntax and\n      semantics
    that are based on the framework defined by this document\n      and are required
    to convey such state information.\n   Event Template-Package:  An event template-package
    is a special kind\n      of event package that defines a set of states that may
    be applied\n      to all possible event packages, including itself.\n   Notification:
    \ Notification is the act of a notifier sending a NOTIFY\n      request to a subscriber
    to inform the subscriber of the state of a\n      resource.\n   Notifier:  A notifier
    is a user agent that generates NOTIFY requests\n      for the purpose of notifying
    subscribers of the state of a\n      resource.  Notifiers typically also accept
    SUBSCRIBE requests to\n      create subscriptions.\n   Subscriber:  A subscriber
    is a user agent that receives NOTIFY\n      requests from notifiers; these NOTIFY
    requests contain information\n      about the state of a resource in which the
    subscriber is\n      interested.  Subscribers typically also generate SUBSCRIBE\n
    \     requests and send them to notifiers to create subscriptions.\n   Subscription:
    \ A subscription is a set of application state\n      associated with a dialog.
    \ This application state includes a\n      pointer to the associated dialog, the
    event package name, and\n      possibly an identification token.  Event packages
    will define\n      additional subscription state information.  By definition,\n
    \     subscriptions exist in both a subscriber and a notifier.\n   Subscription
    Migration:  Subscription migration is the act of moving\n      a subscription
    from one notifier to another notifier.\n"
  title: 2.  Definitions
- contents:
  - '3.  SIP Methods for Event Notification

    '
  - contents:
    - "3.1.  SUBSCRIBE\n   The SUBSCRIBE method is used to request current state and
      state\n   updates from a remote node.  SUBSCRIBE requests are target refresh\n
      \  requests, as that term is defined in [RFC3261].\n"
    - contents:
      - "3.1.1.  Subscription Duration\n   SUBSCRIBE requests SHOULD contain an \"Expires\"
        header field (defined\n   in [RFC3261]).  This expires value indicates the
        duration of the\n   subscription.  In order to keep subscriptions effective
        beyond the\n   duration communicated in the \"Expires\" header field, subscribers
        need\n   to refresh subscriptions on a periodic basis using a new SUBSCRIBE\n
        \  request on the same dialog as defined in [RFC3261].\n   If no \"Expires\"
        header field is present in a SUBSCRIBE request, the\n   implied default MUST
        be defined by the event package being used.\n   200-class responses to SUBSCRIBE
        requests also MUST contain an\n   \"Expires\" header field.  The period of
        time in the response MAY be\n   shorter but MUST NOT be longer than specified
        in the request.  The\n   notifier is explicitly allowed to shorten the duration
        to zero.  The\n   period of time in the response is the one that defines the
        duration\n   of the subscription.\n   An \"expires\" parameter on the \"Contact\"
        header field has no semantics\n   for the SUBSCRIBE method and is explicitly
        not equivalent to an\n   \"Expires\" header field in a SUBSCRIBE request or
        response.\n   A natural consequence of this scheme is that a SUBSCRIBE request
        with\n   an \"Expires\" of 0 constitutes a request to unsubscribe from the\n
        \  matching subscription.\n      In addition to being a request to unsubscribe,
        a SUBSCRIBE request\n      with \"Expires\" of 0 also causes a fetch of state;
        see\n      Section 4.4.3.\n   Notifiers may also wish to cancel subscriptions
        to events; this is\n   useful, for example, when the resource to which a subscription
        refers\n   is no longer available.  Further details on this mechanism are\n
        \  discussed in Section 4.2.2.\n"
      title: 3.1.1.  Subscription Duration
    - contents:
      - "3.1.2.  Identification of Subscribed Events and Event Classes\n   Identification
        of events is provided by three pieces of information:\n   Request URI, Event
        Type, and (optionally) message body.\n   The Request URI of a SUBSCRIBE request,
        most importantly, contains\n   enough information to route the request to
        the appropriate entity per\n   the request routing procedures outlined in
        [RFC3261].  It also\n   contains enough information to identify the resource
        for which event\n   notification is desired, but not necessarily enough information
        to\n   uniquely identify the nature of the event (e.g.,\n   \"sip:adam@example.com\"
        would be an appropriate URI to subscribe to\n   for my presence state; it
        would also be an appropriate URI to\n   subscribe to the state of my voice
        mailbox).\n   Subscribers MUST include exactly one \"Event\" header field
        in\n   SUBSCRIBE requests, indicating to which event or class of events they\n
        \  are subscribing.  The \"Event\" header field will contain a token that\n
        \  indicates the type of state for which a subscription is being\n   requested.
        \ This token will be registered with the IANA and will\n   correspond to an
        event package that further describes the semantics\n   of the event or event
        class.\n   If the event package to which the event token corresponds defines\n
        \  behavior associated with the body of its SUBSCRIBE requests, those\n   semantics
        apply.\n   Event packages may also define parameters for the \"Event\" header\n
        \  field; if they do so, they must define the semantics for such\n   parameters.\n"
      title: 3.1.2.  Identification of Subscribed Events and Event Classes
    - contents:
      - "3.1.3.  Additional SUBSCRIBE Header Field Values\n   Because SUBSCRIBE requests
        create a dialog usage as defined in\n   [RFC3261], they MAY contain an \"Accept\"
        header field.  This header\n   field, if present, indicates the body formats
        allowed in subsequent\n   NOTIFY requests.  Event packages MUST define the
        behavior for\n   SUBSCRIBE requests without \"Accept\" header fields; usually,
        this will\n   connote a single, default body type.\n   Header values not described
        in this document are to be interpreted as\n   described in [RFC3261].\n"
      title: 3.1.3.  Additional SUBSCRIBE Header Field Values
    title: 3.1.  SUBSCRIBE
  - contents:
    - "3.2.  NOTIFY\n   NOTIFY requests are sent to inform subscribers of changes
      in state to\n   which the subscriber has a subscription.  Subscriptions are
      created\n   using the SUBSCRIBE method.  In legacy implementations, it is\n
      \  possible that other means of subscription creation have been used.\n   However,
      this specification does not allow the creation of\n   subscriptions except through
      SUBSCRIBE requests and (for backwards-\n   compatibility) REFER requests [RFC3515].\n
      \  NOTIFY is a target refresh request, as that term is defined in\n   [RFC3261].\n
      \  A NOTIFY request does not terminate its corresponding subscription;\n   in
      other words, a single SUBSCRIBE request may trigger several NOTIFY\n   requests.\n"
    - contents:
      - "3.2.1.  Identification of Reported Events, Event Classes, and Current\n        State\n
        \  Identification of events being reported in a notification is very\n   similar
        to that described for subscription to events (see\n   Section 3.1.2).\n   As
        in SUBSCRIBE requests, NOTIFY request \"Event\" header fields MUST\n   contain
        a single event package name for which a notification is being\n   generated.
        \ The package name in the \"Event\" header field MUST match\n   the \"Event\"
        header field in the corresponding SUBSCRIBE request.\n   Event packages may
        define semantics associated with the body of their\n   NOTIFY requests; if
        they do so, those semantics apply.  NOTIFY\n   request bodies are expected
        to provide additional details about the\n   nature of the event that has occurred
        and the resultant resource\n   state.\n   When present, the body of the NOTIFY
        request MUST be formatted into\n   one of the body formats specified in the
        \"Accept\" header field of the\n   corresponding SUBSCRIBE request (or the
        default type according to the\n   event package description, if no \"Accept\"
        header field was\n   specified).  This body will contain either the state
        of the\n   subscribed resource or a pointer to such state in the form of a
        URI\n   (see Section 5.4.13).\n"
      title: 3.2.1.  Identification of Reported Events, Event Classes, and Current
    title: 3.2.  NOTIFY
  title: 3.  SIP Methods for Event Notification
- contents:
  - '4.  Node Behavior

    '
  - contents:
    - '4.1.  Subscriber Behavior

      '
    - contents:
      - "4.1.1.  Detecting Support for SIP Events\n   The extension described in this
        document does not make use of the\n   \"Require\" or \"Proxy-Require\" header
        fields; similarly, there is no\n   token defined for \"Supported\" header
        fields.  Potential subscribers\n   may probe for the support of SIP events
        using the OPTIONS request\n   defined in [RFC3261].\n   The presence of \"SUBSCRIBE\"
        in the \"Allow\" header field of any\n   request or response indicates support
        for SIP events; further, in the\n   absence of an \"Allow\" header field,
        the simple presence of an \"Allow-\n   Events\" header field is sufficient
        to indicate that the node that\n   sent the message is capable of acting as
        a notifier (see\n   Section 4.4.4).\n      The \"methods\" parameter for Contact
        may also be used to\n      specifically announce support for SUBSCRIBE and
        NOTIFY requests\n      when registering.  (See [RFC3840] for details on the
        \"methods\"\n      parameter.)\n"
      title: 4.1.1.  Detecting Support for SIP Events
    - contents:
      - "4.1.2.  Creating and Maintaining Subscriptions\n   From the subscriber's
        perspective, a subscription proceeds according\n   to the following state
        diagram.  Events that result in a transition\n   back to the same state are
        not represented in this diagram.\n                          +-------------+\n
        \                         |    init     |<-----------------------+\n                          +-------------+
        \                       |\n                                 |                           Retry-after\n
        \                          Send SUBSCRIBE                    expires\n                                 |
        \                              |\n                                 V          Timer
        N Fires;       |\n                          +-------------+   SUBSCRIBE failure
        \   |\n             +------------| notify_wait |-- response; --------+  |\n
        \            |            +-------------+   or NOTIFY,        |  |\n             |
        \                  |          state=terminated  |  |\n             |                   |
        \                           |  |\n   ++========|===================|============================|==|====++\n
        \  ||        |                   |                            V  |    ||\n
        \  ||  Receive NOTIFY,    Receive NOTIFY,             +-------------+ ||\n
        \  ||  state=active       state=pending               | terminated  | ||\n
        \  ||        |                   |                    +-------------+ ||\n
        \  ||        |                   |          Re-subscription     A  A  ||\n
        \  ||        |                   V          times out;          |  |  ||\n
        \  ||        |            +-------------+   Receive NOTIFY,     |  |  ||\n
        \  ||        |            |   pending   |-- state=terminated; --+  |  ||\n
        \  ||        |            +-------------+   or 481 response        |  ||\n
        \  ||        |                   |          to SUBSCRIBE           |  ||\n
        \  ||        |            Receive NOTIFY,   refresh                |  ||\n
        \  ||        |            state=active                             |  ||\n
        \  ||        |                   |          Re-subscription        |  ||\n
        \  ||        |                   V          times out;             |  ||\n
        \  ||        |            +-------------+   Receive NOTIFY,        |  ||\n
        \  ||        +----------->|   active    |-- state=terminated; -----+  ||\n
        \  ||                     +-------------+   or 481 response           ||\n
        \  ||                                       to SUBSCRIBE              ||\n
        \  || Subscription                          refresh                   ||\n
        \  ++=================================================================++\n
        \  In the state diagram, \"Re-subscription times out\" means that an\n   attempt
        to refresh or update the subscription using a new SUBSCRIBE\n   request does
        not result in a NOTIFY request before the corresponding\n   Timer N expires.\n
        \  Any transition from \"notify_wait\" into a \"pending\" or \"active\" state\n
        \  results in a new subscription.  Note that multiple subscriptions can\n
        \  be generated as the result of a single SUBSCRIBE request (see\n   Section
        4.4.1).  Each of these new subscriptions exists in its own\n   independent
        state machine and runs its own set of timers.\n"
      - contents:
        - "4.1.2.1.  Requesting a Subscription\n   SUBSCRIBE is a dialog-creating
          method, as described in [RFC3261].\n   When a subscriber wishes to subscribe
          to a particular state for a\n   resource, it forms a SUBSCRIBE request.
          \ If the initial SUBSCRIBE\n   request represents a request outside of a
          dialog (as it typically\n   will), its construction follows the procedures
          outlined in [RFC3261]\n   for User Agent Client (UAC) request generation
          outside of a dialog.\n   This SUBSCRIBE request will be confirmed with a
          final response.\n   200-class responses indicate that the subscription has
          been accepted\n   and that a NOTIFY request will be sent immediately.\n
          \  The \"Expires\" header field in a 200-class response to SUBSCRIBE\n   request
          indicates the actual duration for which the subscription will\n   remain
          active (unless refreshed).  The received value might be\n   smaller than
          the value indicated in the SUBSCRIBE request but cannot\n   be larger; see
          Section 4.2.1 for details.\n   Non-200-class final responses indicate that
          no subscription or new\n   dialog usage has been created, and no subsequent
          NOTIFY request will\n   be sent.  All non-200-class responses (with the
          exception of 489 (Bad\n   Event), described herein) have the same meanings
          and handling as\n   described in [RFC3261].  For the sake of clarity: if
          a SUBSCRIBE\n   request contains an \"Accept\" header field, but that field
          does not\n   indicate a media type that the notifier is capable of generating
          in\n   its NOTIFY requests, then the proper error response is 406 (Not\n
          \  Acceptable).\n"
        title: 4.1.2.1.  Requesting a Subscription
      - contents:
        - "4.1.2.2.  Refreshing of Subscriptions\n   At any time before a subscription
          expires, the subscriber may refresh\n   the timer on such a subscription
          by sending another SUBSCRIBE request\n   on the same dialog as the existing
          subscription.  The handling for\n   such a request is the same as for the
          initial creation of a\n   subscription except as described below.\n   If
          a SUBSCRIBE request to refresh a subscription receives a 404, 405,\n   410,
          416, 480-485, 489, 501, or 604 response, the subscriber MUST\n   consider
          the subscription terminated.  (See [RFC5057] for further\n   details and
          notes about the effect of error codes on dialogs and\n   usages within dialog,
          such as subscriptions).  If the subscriber\n   wishes to re-subscribe to
          the state, he does so by composing an\n   unrelated initial SUBSCRIBE request
          with a freshly generated Call-ID\n   and a new, unique \"From\" tag (see
          Section 4.1.2.1).\n   If a SUBSCRIBE request to refresh a subscription fails
          with any error\n   code other than those listed above, the original subscription
          is\n   still considered valid for the duration of the most recently known\n
          \  \"Expires\" value as negotiated by the most recent successful SUBSCRIBE\n
          \  transaction, or as communicated by a NOTIFY request in its\n   \"Subscription-State\"
          header field \"expires\" parameter.\n      Note that many such errors indicate
          that there may be a problem\n      with the network or the notifier such
          that no further NOTIFY\n      requests will be received.\n   When refreshing
          a subscription, a subscriber starts Timer N, set to\n   64*T1, when it sends
          the SUBSCRIBE request.  If this Timer N expires\n   prior to the receipt
          of a NOTIFY request, the subscriber considers\n   the subscription terminated.
          \ If the subscriber receives a success\n   response to the SUBSCRIBE request
          that indicates that no NOTIFY\n   request will be generated -- such as the
          204 response defined for use\n   with the optional extension described in
          [RFC5839] -- then it MUST\n   cancel Timer N.\n"
        title: 4.1.2.2.  Refreshing of Subscriptions
      - contents:
        - "4.1.2.3.  Unsubscribing\n   Unsubscribing is handled in the same way as
          refreshing of a\n   subscription, with the \"Expires\" header field set
          to \"0\".  Note that\n   a successful unsubscription will also trigger a
          final NOTIFY request.\n   The final NOTIFY request may or may not contain
          information about the\n   state of the resource; subscribers need to be
          prepared to receive\n   final NOTIFY requests both with and without state.\n"
        title: 4.1.2.3.  Unsubscribing
      - contents:
        - "4.1.2.4.  Confirmation of Subscription Creation\n   The subscriber can
          expect to receive a NOTIFY request from each node\n   which has processed
          a successful subscription or subscription\n   refresh.  To ensure that subscribers
          do not wait indefinitely for a\n   subscription to be established, a subscriber
          starts a Timer N, set to\n   64*T1, when it sends a SUBSCRIBE request.  If
          this Timer N expires\n   prior to the receipt of a NOTIFY request, the subscriber
          considers\n   the subscription failed, and cleans up any state associated
          with the\n   subscription attempt.\n   Until Timer N expires, several NOTIFY
          requests may arrive from\n   different destinations (see Section 4.4.1).
          \ Each of these requests\n   establishes a new dialog usage and a new subscription.
          \ After the\n   expiration of Timer N, the subscriber SHOULD reject any
          such NOTIFY\n   requests that would otherwise establish a new dialog usage
          with a 481\n   (Subscription does not exist) response code.\n   Until the
          first NOTIFY request arrives, the subscriber should\n   consider the state
          of the subscribed resource to be in a neutral\n   state.  Event package
          specifications MUST define this \"neutral state\"\n   in such a way that
          makes sense for their application (see\n   Section 5.4.7).\n   Due to the
          potential for out-of-order messages, packet loss, and\n   forking, the subscriber
          MUST be prepared to receive NOTIFY requests\n   before the SUBSCRIBE transaction
          has completed.\n   Except as noted above, processing of this NOTIFY request
          is the same\n   as in Section 4.1.3.\n"
        title: 4.1.2.4.  Confirmation of Subscription Creation
      title: 4.1.2.  Creating and Maintaining Subscriptions
    - contents:
      - "4.1.3.  Receiving and Processing State Information\n   Subscribers receive
        information about the state of a resource to\n   which they have subscribed
        in the form of NOTIFY requests.\n   Upon receiving a NOTIFY request, the subscriber
        should check that it\n   matches at least one of its outstanding subscriptions;
        if not, it\n   MUST return a 481 (Subscription does not exist) response unless\n
        \  another 400- or 500-class response is more appropriate.  The rules\n   for
        matching NOTIFY requests with subscriptions that create a new\n   dialog usage
        are described in Section 4.4.1.  Notifications for\n   subscriptions that
        were created inside an existing dialog match if\n   they are in the same dialog
        and the \"Event\" header fields match (as\n   described in Section 8.2.1).\n
        \  If, for some reason, the event package designated in the \"Event\"\n   header
        field of the NOTIFY request is not supported, the subscriber\n   will respond
        with a 489 (Bad Event) response.\n   To prevent spoofing of events, NOTIFY
        requests SHOULD be\n   authenticated using any defined SIP authentication
        mechanism, such as\n   those described in Sections 22.2 and 23 of [RFC3261].\n
        \  NOTIFY requests MUST contain \"Subscription-State\" header fields that\n
        \  indicate the status of the subscription.\n   If the \"Subscription-State\"
        header field value is \"active\", it means\n   that the subscription has been
        accepted and (in general) has been\n   authorized.  If the header field also
        contains an \"expires\"\n   parameter, the subscriber SHOULD take it as the
        authoritative\n   subscription duration and adjust accordingly.  The \"retry-after\"
        and\n   \"reason\" parameters have no semantics for \"active\".\n   If the
        \"Subscription-State\" value is \"pending\", the subscription has\n   been
        received by the notifier, but there is insufficient policy\n   information
        to grant or deny the subscription yet.  If the header\n   field also contains
        an \"expires\" parameter, the subscriber SHOULD\n   take it as the authoritative
        subscription duration and adjust\n   accordingly.  No further action is necessary
        on the part of the\n   subscriber.  The \"retry-after\" and \"reason\" parameters
        have no\n   semantics for \"pending\".\n   If the \"Subscription-State\" value
        is \"terminated\", the subscriber\n   MUST consider the subscription terminated.
        \ The \"expires\" parameter\n   has no semantics for \"terminated\" -- notifiers
        SHOULD NOT include an\n   \"expires\" parameter on a \"Subscription-State\"
        header field with a\n   value of \"terminated\", and subscribers MUST ignore
        any such\n   parameter, if present.  If a reason code is present, the client\n
        \  should behave as described below.  If no reason code or an unknown\n   reason
        code is present, the client MAY attempt to re-subscribe at any\n   time (unless
        a \"retry-after\" parameter is present, in which case the\n   client SHOULD
        NOT attempt re-subscription until after the number of\n   seconds specified
        by the \"retry-after\" parameter).  The reason codes\n   defined by this document
        are:\n   deactivated:  The subscription has been terminated, but the\n      subscriber
        SHOULD retry immediately with a new subscription.  One\n      primary use
        of such a status code is to allow migration of\n      subscriptions between
        nodes.  The \"retry-after\" parameter has no\n      semantics for \"deactivated\".\n
        \  probation:  The subscription has been terminated, but the client\n      SHOULD
        retry at some later time (as long as the resource's state\n      is still
        relevant to the client at that time).  If a \"retry-after\"\n      parameter
        is also present, the client SHOULD wait at least the\n      number of seconds
        specified by that parameter before attempting to\n      re-subscribe.\n   rejected:
        \ The subscription has been terminated due to change in\n      authorization
        policy.  Clients SHOULD NOT attempt to re-subscribe.\n      The \"retry-after\"
        parameter has no semantics for \"rejected\".\n   timeout:  The subscription
        has been terminated because it was not\n      refreshed before it expired.
        \ Clients MAY re-subscribe\n      immediately.  The \"retry-after\" parameter
        has no semantics for\n      \"timeout\".  This reason code is also associated
        with polling of\n      resource state, as detailed in Section 4.4.3.\n   giveup:
        \ The subscription has been terminated because the notifier\n      could not
        obtain authorization in a timely fashion.  If a \"retry-\n      after\" parameter
        is also present, the client SHOULD wait at least\n      the number of seconds
        specified by that parameter before\n      attempting to re-subscribe; otherwise,
        the client MAY retry\n      immediately, but will likely get put back into
        pending state.\n   noresource:  The subscription has been terminated because
        the\n      resource state that was being monitored no longer exists.  Clients\n
        \     SHOULD NOT attempt to re-subscribe.  The \"retry-after\" parameter\n
        \     has no semantics for \"noresource\".\n   invariant:  The subscription
        has been terminated because the resource\n      state is guaranteed not to
        change for the foreseeable future.\n      This may be the case, for example,
        when subscribing to the\n      location information of a fixed-location land-line
        telephone.\n      When using this reason code, notifiers are advised to include
        a\n      \"retry-after\" parameter with a large value (for example, 31536000\n
        \     -- or one year) to prevent older clients that are RFC 3265\n      compliant
        from periodically re-subscribing.  Clients SHOULD NOT\n      attempt to re-subscribe
        after receiving a reason code of\n      \"invariant\", regardless of the presence
        of or value of a \"retry-\n      after\" parameter.\n   Other specifications
        may define new reason codes for use with the\n   \"Subscription-State\" header
        field.\n   Once the notification is deemed acceptable to the subscriber, the\n
        \  subscriber SHOULD return a 200 response.  In general, it is not\n   expected
        that NOTIFY responses will contain bodies; however, they\n   MAY, if the NOTIFY
        request contained an \"Accept\" header field.\n   Other responses defined
        in [RFC3261] may also be returned, as\n   appropriate.  In no case should
        a NOTIFY transaction extend for any\n   longer than the time necessary for
        automated processing.  In\n   particular, subscribers MUST NOT wait for a
        user response before\n   returning a final response to a NOTIFY request.\n"
      title: 4.1.3.  Receiving and Processing State Information
    - contents:
      - "4.1.4.  Forking of SUBSCRIBE Requests\n   In accordance with the rules for
        proxying non-INVITE requests as\n   defined in [RFC3261], successful SUBSCRIBE
        requests will receive only\n   one 200-class response; however, due to forking,
        the subscription may\n   have been accepted by multiple nodes.  The subscriber
        MUST therefore\n   be prepared to receive NOTIFY requests with \"From:\" tags
        that differ\n   from the \"To:\" tag received in the SUBSCRIBE 200-class response.\n
        \  If multiple NOTIFY requests are received in different dialogs in\n   response
        to a single SUBSCRIBE request, each dialog represents a\n   different destination
        to which the SUBSCRIBE request was forked.\n   Subscriber handling in such
        situations varies by event package; see\n   Section 5.4.9 for details.\n"
      title: 4.1.4.  Forking of SUBSCRIBE Requests
    title: 4.1.  Subscriber Behavior
  - contents:
    - '4.2.  Notifier Behavior

      '
    - contents:
      - "4.2.1.  Subscription Establishment and Maintenance\n   Notifiers learn about
        subscription requests by receiving SUBSCRIBE\n   requests from interested
        parties.  Notifiers MUST NOT create\n   subscriptions except upon receipt
        of a SUBSCRIBE request.  However,\n   for historical reasons, the implicit
        creation of subscriptions as\n   defined in [RFC3515] is still permitted.\n
        \     [RFC3265] allowed the creation of subscriptions using means other\n
        \     than the SUBSCRIBE method.  The only standardized use of this\n      mechanism
        is the REFER method [RFC3515].  Implementation\n      experience with REFER
        has shown that the implicit creation of a\n      subscription has a number
        of undesirable effects, such as the\n      inability to signal the success
        of a REFER request while signaling\n      a problem with the subscription,
        and difficulty performing one\n      action without the other.  Additionally,
        the proper exchange of\n      dialog identifiers is difficult without dialog
        reuse (which has\n      its own set of problems; see Section 4.5).\n"
      - contents:
        - "4.2.1.1.  Initial SUBSCRIBE Transaction Processing\n   In no case should
          a SUBSCRIBE transaction extend for any longer than\n   the time necessary
          for automated processing.  In particular,\n   notifiers MUST NOT wait for
          a user response before returning a final\n   response to a SUBSCRIBE request.\n
          \     This requirement is imposed primarily to prevent the non-INVITE\n
          \     transaction timeout timer F (see [RFC3261]) from firing during the\n
          \     SUBSCRIBE transaction, since interaction with a user would often\n
          \     exceed 64*T1 seconds.\n   The notifier SHOULD check that the event
          package specified in the\n   \"Event\" header field is understood.  If not,
          the notifier SHOULD\n   return a 489 (Bad Event) response to indicate that
          the specified\n   event/event class is not understood.\n   The notifier
          SHOULD also perform any necessary authentication and\n   authorization per
          its local policy.  See Section 4.2.1.3.\n   The notifier MAY also check
          that the duration in the \"Expires\" header\n   field is not too small.
          \ If and only if the expiration interval is\n   greater than zero AND smaller
          than one hour AND less than a notifier-\n   configured minimum, the notifier
          MAY return a 423 (Interval Too\n   Brief) error that contains a \"Min-Expires\"
          header field.  The\n   \"Min-Expires\" header field is described in [RFC3261].\n
          \  Once the notifier determines that it has enough information to create\n
          \  the subscription (i.e., it understands the event package, the\n   subscription
          pertains to a known resource, and there are no other\n   barriers to creating
          the subscription), it creates the subscription\n   and a dialog usage, and
          returns a 200 (OK) response.\n   When a subscription is created in the notifier,
          it stores the event\n   package name as part of the subscription information.\n
          \  The \"Expires\" values present in SUBSCRIBE 200-class responses behave\n
          \  in the same way as they do in REGISTER responses: the server MAY\n   shorten
          the interval but MUST NOT lengthen it.\n      If the duration specified
          in a SUBSCRIBE request is unacceptably\n      short, the notifier may be
          able to send a 423 response, as\n      described earlier in this section.\n
          \  200-class responses to SUBSCRIBE requests will not generally contain\n
          \  any useful information beyond subscription duration; their primary\n
          \  purpose is to serve as a reliability mechanism.  State information\n
          \  will be communicated via a subsequent NOTIFY request from the\n   notifier.\n
          \  The other response codes defined in [RFC3261] may be used in response\n
          \  to SUBSCRIBE requests, as appropriate.\n"
        title: 4.2.1.1.  Initial SUBSCRIBE Transaction Processing
      - contents:
        - "4.2.1.2.  Confirmation of Subscription Creation/Refreshing\n   Upon successfully
          accepting or refreshing a subscription, notifiers\n   MUST send a NOTIFY
          request immediately to communicate the current\n   resource state to the
          subscriber.  This NOTIFY request is sent on the\n   same dialog as created
          by the SUBSCRIBE response.  If the resource\n   has no meaningful state
          at the time that the SUBSCRIBE request is\n   processed, this NOTIFY request
          MAY contain an empty or neutral body.\n   See Section 4.2.2 for further
          details on NOTIFY request generation.\n   Note that a NOTIFY request is
          always sent immediately after any\n   200-class response to a SUBSCRIBE
          request, regardless of whether the\n   subscription has already been authorized.\n"
        title: 4.2.1.2.  Confirmation of Subscription Creation/Refreshing
      - contents:
        - "4.2.1.3.  Authentication/Authorization of SUBSCRIBE Requests\n   Privacy
          concerns may require that notifiers apply policy to determine\n   whether
          a particular subscriber is authorized to subscribe to a\n   certain set
          of events.  Such policy may be defined by mechanisms such\n   as access
          control lists or real-time interaction with a user.  In\n   general, authorization
          of subscribers prior to authentication is not\n   particularly useful.\n
          \  SIP authentication mechanisms are discussed in [RFC3261].  Note that,\n
          \  even if the notifier node typically acts as a proxy, authentication\n
          \  for SUBSCRIBE requests will always be performed via a 401\n   (Unauthorized)
          response, not a 407 (Proxy Authentication Required).\n   Notifiers always
          act as user agents when accepting subscriptions and\n   sending notifications.\n
          \     Of course, when acting as a proxy, a node will perform normal\n      proxy
          authentication (using 407).  The foregoing explanation is a\n      reminder
          that notifiers are always user agents and, as such,\n      perform user
          agent authentication.\n   If authorization fails based on an access list
          or some other\n   automated mechanism (i.e., it can be automatically authoritatively\n
          \  determined that the subscriber is not authorized to subscribe), the\n
          \  notifier SHOULD reply to the request with a 403 (Forbidden) or 603\n
          \  (Decline) response, unless doing so might reveal information that\n   should
          stay private; see Section 6.2.\n   If the notifier owner is interactively
          queried to determine whether a\n   subscription is allowed, a 200 (OK) response
          is returned immediately.\n   Note that a NOTIFY request is still formed
          and sent under these\n   circumstances, as described in the previous section.\n
          \  If subscription authorization was delayed and the notifier wishes to\n
          \  convey that such authorization has been declined, it may do so by\n   sending
          a NOTIFY request containing a \"Subscription-State\" header\n   field with
          a value of \"terminated\" and a reason parameter of\n   \"rejected\".\n"
        title: 4.2.1.3.  Authentication/Authorization of SUBSCRIBE Requests
      - contents:
        - "4.2.1.4.  Refreshing of Subscriptions\n   When a notifier receives a subscription
          refresh, assuming that the\n   subscriber is still authorized, the notifier
          updates the expiration\n   time for subscription.  As with the initial subscription,
          the server\n   MAY shorten the amount of time until expiration but MUST
          NOT increase\n   it.  The final expiration time is placed in the \"Expires\"
          header\n   field in the response.  If the duration specified in a SUBSCRIBE\n
          \  request is unacceptably short, the notifier SHOULD respond with a 423\n
          \  (Interval Too Brief) response.\n   If no refresh for a notification address
          is received before its\n   expiration time, the subscription is removed.
          \ When removing a\n   subscription, the notifier SHOULD send a NOTIFY request
          with a\n   \"Subscription-State\" value of \"terminated\" to inform it that
          the\n   subscription is being removed.  If such a request is sent, the\n
          \  \"Subscription-State\" header field SHOULD contain a \"reason=timeout\"\n
          \  parameter.\n   Clients can cause a subscription to be terminated immediately
          by\n   sending a SUBSCRIBE request with an \"Expires\" header field set
          to\n   '0'.  Notifiers largely treat this the same way as any other\n   subscription
          expiration: they send a NOTIFY request containing a\n   \"Subscription-State\"
          of \"terminated\", with a reason code of\n   \"timeout.\"  For consistency
          with state polling (see Section 4.4.3)\n   and subscription refreshes, the
          notifier may choose to include\n   resource state in this final NOTIFY request.
          \ However, in some cases,\n   including such state makes no sense.  Under
          such circumstances, the\n   notifier may choose to omit state information
          from the terminal\n   NOTIFY request.\n      The sending of a NOTIFY request
          when a subscription expires allows\n      the corresponding dialog usage
          to be terminated, if appropriate.\n"
        title: 4.2.1.4.  Refreshing of Subscriptions
      title: 4.2.1.  Subscription Establishment and Maintenance
    - contents:
      - "4.2.2.  Sending State Information to Subscribers\n   Notifiers use the NOTIFY
        method to send information about the state\n   of a resource to subscribers.
        \ The notifier's view of a subscription\n   is shown in the following state
        diagram.  Events that result in a\n   transition back to the same state are
        not represented in this\n   diagram.\n                         +-------------+\n
        \                        |    init     |\n                         +-------------+\n
        \                               |\n                          Receive SUBSCRIBE,\n
        \                         Send NOTIFY\n                                |\n
        \                               V          NOTIFY failure,\n                         +-------------+
        \  subscription expires,\n            +------------|  resp_wait  |-- or terminated
        ----+\n            |            +-------------+   per local policy  |\n            |
        \                  |                            |\n            |                   |
        \                           |\n            |                   |                            V\n
        \     Policy grants       Policy needed              +-------------+\n      permission
        \               |                    | terminated  |\n            |                   |
        \                   +-------------+\n            |                   |                               A
        A\n            |                   V          NOTIFY failure,      | |\n            |
        \           +-------------+   subscription expires,| |\n            |            |
        \  pending   |-- or terminated -------+ |\n            |            +-------------+
        \  per local policy       |\n            |                   |                                 |\n
        \           |            Policy changed to                        |\n            |
        \           grant permission                         |\n            |                   |
        \                                |\n            |                   V          NOTIFY
        failure,        |\n            |            +-------------+   subscription
        expires,  |\n            +----------->|   active    |-- or terminated ---------+\n
        \                        +-------------+   per local policy\n   When a SUBSCRIBE
        request is answered with a 200-class response, the\n   notifier MUST immediately
        construct and send a NOTIFY request to the\n   subscriber.  When a change
        in the subscribed state occurs, the\n   notifier SHOULD immediately construct
        and send a NOTIFY request,\n   unless the state transition is caused by a
        NOTIFY transaction\n   failure.  The sending of this NOTIFY message is also
        subject to\n   authorization, local policy, and throttling considerations.\n
        \  If the NOTIFY request fails due to expiration of SIP Timer F\n   (transaction
        timeout), the notifier SHOULD remove the subscription.\n      This behavior
        prevents unnecessary transmission of state\n      information for subscribers
        who have crashed or disappeared from\n      the network.  Because such transmissions
        will be sent multiple\n      times, per the retransmission algorithm defined
        in [RFC3261]\n      (instead of the typical single transmission for functioning\n
        \     clients), continuing to service them when no client is available\n      to
        acknowledge them could place undue strain on a network.  Upon\n      client
        restart or reestablishment of a network connection, it is\n      expected
        that clients will send SUBSCRIBE requests to refresh\n      potentially stale
        state information; such requests will reinstall\n      subscriptions in all
        relevant nodes.\n   If the NOTIFY transaction fails due to the receipt of
        a 404, 405,\n   410, 416, 480-485, 489, 501, or 604 response to the NOTIFY
        request,\n   the notifier MUST remove the corresponding subscription.  See\n
        \  [RFC5057] for further details and notes about the effect of error\n   codes
        on dialogs and usages within dialog (such as subscriptions).\n      A notify
        error response would generally indicate that something\n      has gone wrong
        with the subscriber or with some proxy on the way\n      to the subscriber.
        \ If the subscriber is in error, it makes the\n      most sense to allow the
        subscriber to rectify the situation (by\n      re-subscribing) once the error
        condition has been handled.  If a\n      proxy is in error, the periodic sending
        of SUBSCRIBE requests to\n      refresh the expiration timer will reinstall
        subscription state\n      once the network problem has been resolved.\n   NOTIFY
        requests MUST contain a \"Subscription-State\" header field with\n   a value
        of \"active\", \"pending\", or \"terminated\".  The \"active\" value\n   indicates
        that the subscription has been accepted and has been\n   authorized (in most
        cases; see Section 6.2).  The \"pending\" value\n   indicates that the subscription
        has been received, but that policy\n   information is insufficient to accept
        or deny the subscription at\n   this time.  The \"terminated\" value indicates
        that the subscription is\n   not active.\n   If the value of the \"Subscription-State\"
        header field is \"active\" or\n   \"pending\", the notifier MUST also include
        in the \"Subscription-State\"\n   header field an \"expires\" parameter that
        indicates the time remaining\n   on the subscription.  The notifier MAY use
        this mechanism to shorten\n   a subscription; however, this mechanism MUST
        NOT be used to lengthen\n   a subscription.\n      Including expiration information
        for active and pending\n      subscriptions is necessary in case the SUBSCRIBE
        request forks,\n      since the response to a forked SUBSCRIBE request may
        not be\n      received by the subscriber.  [RFC3265] allowed the notifier
        some\n      discretion in the inclusion of this parameter, so subscriber\n
        \     implementations are warned to handle the lack of an \"expires\"\n      parameter
        gracefully.  Note well that this \"expires\" value is a\n      parameter on
        the \"Subscription-State\" header field NOT the\n      \"Expires\" header
        field.\n      The period of time for a subscription can be shortened to zero
        by\n      the notifier.  In other words, it is perfectly valid for a\n      SUBSCRIBE
        request with a non-zero expires to be answered with a\n      NOTIFY request
        that contains \"Subscription-Status:\n      terminated;reason=expired\".  This
        merely means that the notifier\n      has shortened the subscription timeout
        to zero, and the\n      subscription has expired instantaneously.  The body
        may contain\n      valid state, or it may contain a neutral state (see\n      Section
        5.4.7).\n   If the value of the \"Subscription-State\" header field is\n   \"terminated\",
        the notifier SHOULD also include a \"reason\" parameter.\n   The notifier
        MAY also include a \"retry-after\" parameter, where\n   appropriate.  For
        details on the value and semantics of the \"reason\"\n   and \"retry-after\"
        parameters, see Section 4.1.3.\n"
      title: 4.2.2.  Sending State Information to Subscribers
    - contents:
      - "4.2.3.  PSTN/Internet Interworking (PINT) Compatibility\n   The \"Event\"
        header field is considered mandatory for the purposes of\n   this document.
        \ However, to maintain compatibility with PINT (see\n   [RFC2848]), notifiers
        MAY interpret a SUBSCRIBE request with no\n   \"Event\" header field as requesting
        a subscription to PINT events.  If\n   a notifier does not support PINT, it
        SHOULD return 489 (Bad Event) to\n   any SUBSCRIBE requests without an \"Event\"
        header field.\n"
      title: 4.2.3.  PSTN/Internet Interworking (PINT) Compatibility
    title: 4.2.  Notifier Behavior
  - contents:
    - "4.3.  Proxy Behavior\n   Proxies need no additional behavior beyond that described
      in\n   [RFC3261] to support SUBSCRIBE and NOTIFY transactions.  If a proxy\n
      \  wishes to see all of the SUBSCRIBE and NOTIFY requests for a given\n   dialog,
      it MUST add a \"Record-Route\" header field to the initial\n   SUBSCRIBE request
      and all NOTIFY requests.  It MAY choose to include\n   \"Record-Route\" in subsequent
      SUBSCRIBE requests; however, these\n   requests cannot cause the dialog's route
      set to be modified.\n   Proxies that did not add a \"Record-Route\" header field
      to the initial\n   SUBSCRIBE request MUST NOT add a \"Record-Route\" header
      field to any\n   of the associated NOTIFY requests.\n      Note that subscribers
      and notifiers may elect to use Secure/\n      Multipurpose Internet Mail Extensions
      (S/MIME) encryption of\n      SUBSCRIBE and NOTIFY requests; consequently, proxies
      cannot rely\n      on being able to access any information that is not explicitly\n
      \     required to be proxy-readable by [RFC3261].\n"
    title: 4.3.  Proxy Behavior
  - contents:
    - '4.4.  Common Behavior

      '
    - contents:
      - "4.4.1.  Dialog Creation and Termination\n   Dialogs usages are created upon
        completion of a NOTIFY transaction\n   for a new subscription, unless the
        NOTIFY request contains a\n   \"Subscription-State\" of \"terminated.\"\n
        \  Because the dialog usage is established by the NOTIFY request, the\n   route
        set at the subscriber is taken from the NOTIFY request itself,\n   as opposed
        to the route set present in the 200-class response to the\n   SUBSCRIBE request.\n
        \  NOTIFY requests are matched to such SUBSCRIBE requests if they\n   contain
        the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n   matches
        the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n   request,
        and the same \"Event\" header field.  Rules for comparisons of\n   the \"Event\"
        header fields are described in Section 8.2.1.\n   A subscription is destroyed
        after a notifier sends a NOTIFY request\n   with a \"Subscription-State\"
        of \"terminated\", or in certain error\n   situations described elsewhere
        in this document.  The subscriber will\n   generally answer such final requests
        with a 200 (OK) response (unless\n   a condition warranting an alternate response
        has arisen).  Except\n   when the mechanism described in Section 4.5.2 is
        used, the\n   destruction of a subscription results in the termination of
        its\n   associated dialog.\n      A subscriber may send a SUBSCRIBE request
        with an \"Expires\" header\n      field of 0 in order to trigger the sending
        of such a NOTIFY\n      request; however, for the purposes of subscription
        and dialog\n      lifetime, the subscription is not considered terminated
        until the\n      NOTIFY transaction with a \"Subscription-State\" of \"terminated\"\n
        \     completes.\n"
      title: 4.4.1.  Dialog Creation and Termination
    - contents:
      - "4.4.2.  Notifier Migration\n   It is often useful to allow migration of subscriptions
        between\n   notifiers.  Such migration may be effected by sending a NOTIFY\n
        \  request with a \"Subscription-State\" header field of \"terminated\" and\n
        \  a reason parameter of \"deactivated\".  This NOTIFY request is\n   otherwise
        normal and is formed as described in Section 4.2.2.\n   Upon receipt of this
        NOTIFY request, the subscriber SHOULD attempt to\n   re-subscribe (as described
        in the preceding sections).  Note that\n   this subscription is established
        on a new dialog, and does not reuse\n   the route set from the previous subscription
        dialog.\n   The actual migration is effected by making a change to the policy\n
        \  (such as routing decisions) of one or more servers to which the\n   SUBSCRIBE
        request will be sent in such a way that a different node\n   ends up responding
        to the SUBSCRIBE request.  This may be as simple\n   as a change in the local
        policy in the notifier from which the\n   subscription is migrating so that
        it serves as a proxy or redirect\n   server instead of a notifier.\n   Whether,
        when, and why to perform notifier migrations may be\n   described in individual
        event packages; otherwise, such decisions are\n   a matter of local notifier
        policy and are left up to individual\n   implementations.\n"
      title: 4.4.2.  Notifier Migration
    - contents:
      - "4.4.3.  Polling Resource State\n   A natural consequence of the behavior
        described in the preceding\n   sections is that an immediate fetch without
        a persistent subscription\n   may be effected by sending a SUBSCRIBE with
        an \"Expires\" of 0.\n   Of course, an immediate fetch while a subscription
        is active may be\n   effected by sending a SUBSCRIBE request with an \"Expires\"
        equal to\n   the number of seconds remaining in the subscription.\n   Upon
        receipt of this SUBSCRIBE request, the notifier (or notifiers,\n   if the
        SUBSCRIBE request was forked) will send a NOTIFY request\n   containing resource
        state in the same dialog.\n   Note that the NOTIFY requests triggered by SUBSCRIBE
        requests with\n   \"Expires\" header fields of 0 will contain a \"Subscription-State\"\n
        \  value of \"terminated\" and a \"reason\" parameter of \"timeout\".\n   Polling
        of event state can cause significant increases in load on the\n   network
        and notifiers; as such, it should be used only sparingly.  In\n   particular,
        polling SHOULD NOT be used in circumstances in which it\n   will typically
        result in more network messages than long-running\n   subscriptions.\n   When
        polling is used, subscribers SHOULD attempt to cache\n   authentication credentials
        between polls so as to reduce the number\n   of messages sent.\n      Due
        to the requirement on notifiers to send a NOTIFY request\n      immediately
        upon receipt of a SUBSCRIBE request, the state\n      provided by polling
        is limited to the information that the\n      notifier has immediate local
        access to when it receives the\n      SUBSCRIBE request.  If, for example,
        the notifier generally needs\n      to retrieve state from another network
        server, then that state\n      will be absent from the NOTIFY request that
        results from polling.\n"
      title: 4.4.3.  Polling Resource State
    - contents:
      - "4.4.4.  \"Allow-Events\" Header Field Usage\n   The \"Allow-Events\" header
        field, if present, MUST include a\n   comprehensive and inclusive list of
        tokens that indicates the event\n   packages for which the user agent can
        act as a notifier.  In other\n   words, a user agent sending an \"Allow-Events\"
        header field is\n   advertising that it can process SUBSCRIBE requests and
        generate\n   NOTIFY requests for all of the event packages listed in that
        header\n   field.\n   Any user agent that can act as a notifier for one or
        more event\n   packages SHOULD include an appropriate \"Allow-Events\" header
        field\n   indicating all supported events in all methods which initiate dialogs\n
        \  and their responses (such as INVITE) and OPTIONS responses.\n      This
        information is very useful, for example, in allowing user\n      agents to
        render particular interface elements appropriately\n      according to whether
        the events required to implement the features\n      they represent are supported
        by the appropriate nodes.\n      On the other hand, it doesn't necessarily
        make much sense to\n      indicate supported events inside a dialog established
        by a NOTIFY\n      request if the only event package supported is the one
        associated\n      with that subscription.\n   Note that \"Allow-Events\" header
        fields MUST NOT be inserted by\n   proxies.\n   The \"Allow-Events\" header
        field does not include a list of the event\n   template-packages supported
        by an implementation.  If a subscriber\n   wishes to determine which event
        template-packages are supported by a\n   notifier, it can probe for such support
        by attempting to subscribe to\n   the event template-packages it wishes to
        use.\n      For example: to check for support for the templatized package\n
        \     \"presence.winfo\", a client may attempt to subscribe to that event\n
        \     package for a known resource, using an \"Expires\" header value of\n
        \     0.  If the response is a 489 error code, then the client can\n      deduce
        that \"presence.winfo\" is unsupported.\n"
      title: 4.4.4.  "Allow-Events" Header Field Usage
    title: 4.4.  Common Behavior
  - contents:
    - "4.5.  Targeting Subscriptions at Devices\n   [RFC3265] defined a mechanism
      by which subscriptions could share\n   dialogs with invite usages and with other
      subscriptions.  The purpose\n   of this behavior was to allow subscribers to
      ensure that a\n   subscription arrived at the same device as an established
      dialog.\n   Unfortunately, the reuse of dialogs has proven to be exceedingly\n
      \  confusing.  [RFC5057] attempted to clarify proper behavior in a\n   variety
      of circumstances; however, the ensuing rules remain confusing\n   and prone
      to implementation error.  At the same time, the mechanism\n   described in [RFC5627]
      now provides a far more elegant and\n   unambiguous means to achieve the same
      goal.\n   Consequently, the dialog reuse technique described in RFC 3265 is
      now\n   deprecated.\n   This dialog-sharing technique has also historically
      been used as a\n   means for targeting an event package at a dialog.  This usage
      can be\n   seen, for example, in certain applications of the REFER method\n
      \  [RFC3515].  With the removal of dialog reuse, an alternate (and more\n   explicit)
      means of targeting dialogs needs to be used for this type\n   of correlation.
      \ The appropriate means of such targeting is left up\n   to the actual event
      packages.  Candidates include the \"Target-Dialog\"\n   header field [RFC4538],
      the \"Join\" header field [RFC3911], and the\n   \"Replaces\" header field [RFC3891],
      depending on the semantics\n   desired.  Alternately, if the semantics of those
      header fields do not\n   match the event package's purpose for correlation,
      event packages can\n   devise their own means of identifying dialogs.  For an
      example of\n   this approach, see the Dialog Event Package [RFC4235].\n"
    - contents:
      - "4.5.1.  Using GRUUs to Route to Devices\n   Notifiers MUST implement the
        Globally Routable User Agent URI (GRUU)\n   extension defined in [RFC5627],
        and MUST use a GRUU as their local\n   target.  This allows subscribers to
        explicitly target desired\n   devices.\n   If a subscriber wishes to subscribe
        to a resource on the same device\n   as an established dialog, it should check
        whether the remote contact\n   in that dialog is a GRUU (i.e., whether it
        contains a \"gr\" URI\n   parameter).  If so, the subscriber creates a new
        dialog, using the\n   GRUU as the Request URI for the new SUBSCRIBE request.\n
        \     Because GRUUs are guaranteed to route to a specific device, this\n      ensures
        that the subscription will be routed to the same place as\n      the established
        dialog.\n"
      title: 4.5.1.  Using GRUUs to Route to Devices
    - contents:
      - "4.5.2.  Sharing Dialogs\n   For compatibility with older clients, subscriber
        and notifier\n   implementations may choose to allow dialog sharing.  The
        behavior of\n   multiple usages within a dialog are described in [RFC5057].\n
        \  Subscribers MUST NOT attempt to reuse dialogs whose remote target is\n
        \  a GRUU.\n      Note that the techniques described in this section are included\n
        \     for backwards-compatibility purposes only.  Because subscribers\n      cannot
        reuse dialogs with a GRUU for their remote target, and\n      because notifiers
        must use GRUUs as their local target, any two\n      implementations that
        conform to this specification will\n      automatically use the mechanism
        described in Section 4.5.1.\n      Further note that the prohibition on reusing
        dialogs does not\n      exempt implicit subscriptions created by the REFER
        method.  This\n      means that implementations complying with this specification
        are\n      required to use the \"Target-Dialog\" mechanism described in\n
        \     [RFC4538] when the remote target is a GRUU.\n   If a subscriber wishes
        to subscribe to a resource on the same device\n   as an established dialog
        and the remote contact is not a GRUU, it MAY\n   revert to dialog-sharing
        behavior.  Alternately, it MAY choose to\n   treat the remote party as incapable
        of servicing the subscription\n   (i.e., the same way it would behave if the
        remote party did not\n   support SIP events at all).\n   If a notifier receives
        a SUBSCRIBE request for a new subscription on\n   an existing dialog, it MAY
        choose to implement dialog sharing\n   behavior.  Alternately, it may choose
        to fail the SUBSCRIBE request\n   with a 403 (Forbidden) response.  The error
        text of such 403\n   responses SHOULD indicate that dialog sharing is not
        supported.\n   To implement dialog sharing, subscribers and notifiers perform
        the\n   following additional processing:\n   o  When subscriptions exist in
        dialogs associated with INVITE-created\n      application state and/or other
        subscriptions, these sets of\n      application state do not interact beyond
        the behavior described\n      for a dialog (e.g., route set handling).  In
        particular, multiple\n      subscriptions within a dialog expire independently
        and require\n      independent subscription refreshes.\n   o  If a subscription's
        destruction leaves no other application state\n      associated with the dialog,
        the dialog terminates.  The\n      destruction of other application state
        (such as that created by an\n      INVITE) will not terminate the dialog if
        a subscription is still\n      associated with that dialog.  This means that,
        when dialogs are\n      reused, a dialog created with an INVITE does not necessarily\n
        \     terminate upon receipt of a BYE.  Similarly, in the case that\n      several
        subscriptions are associated with a single dialog, the\n      dialog does
        not terminate until all the subscriptions in it are\n      destroyed.\n   o
        \ Subscribers MAY include an \"id\" parameter in a SUBSCRIBE request's\n      \"Event\"
        header field to allow differentiation between multiple\n      subscriptions
        in the same dialog.  This \"id\" parameter, if\n      present, contains an
        opaque token that identifies the specific\n      subscription within a dialog.
        \ An \"id\" parameter is only valid\n      within the scope of a single dialog.\n
        \  o  If an \"id\" parameter is present in the SUBSCRIBE request used to\n
        \     establish a subscription, that \"id\" parameter MUST also be present\n
        \     in all corresponding NOTIFY requests.\n   o  When a subscriber refreshes
        the subscription timer, the SUBSCRIBE\n      request MUST contain the same
        \"Event\" header field \"id\" parameter\n      as was present in the SUBSCRIBE
        request that created the\n      subscription.  (Otherwise, the notifier will
        interpret the\n      SUBSCRIBE request as a request for a new subscription
        in the same\n      dialog.)\n   o  When a subscription is created in the notifier,
        it stores any\n      \"Event\" header field \"id\" parameter as part of the
        subscription\n      information (along with the event package name).\n   o
        \ If an initial SUBSCRIBE request is sent on a pre-existing dialog,\n      a
        matching NOTIFY request merely creates a new subscription\n      associated
        with that dialog.\n"
      title: 4.5.2.  Sharing Dialogs
    title: 4.5.  Targeting Subscriptions at Devices
  - contents:
    - "4.6.  CANCEL Requests for SUBSCRIBE and NOTIFY Transactions\n   Neither SUBSCRIBE
      nor NOTIFY requests can be canceled.  If a User\n   Agent Server (UAS) receives
      a CANCEL request that matches a known\n   SUBSCRIBE or NOTIFY transaction, it
      MUST respond to the CANCEL\n   request, but otherwise ignore it.  In particular,
      the CANCEL request\n   MUST NOT affect processing of the SUBSCRIBE or NOTIFY
      request in any\n   way.\n   UACs SHOULD NOT send CANCEL requests for SUBSCRIBE
      or NOTIFY\n   transactions.\n"
    title: 4.6.  CANCEL Requests for SUBSCRIBE and NOTIFY Transactions
  title: 4.  Node Behavior
- contents:
  - "5.  Event Packages\n   This section covers several issues that should be taken
    into\n   consideration when event packages based on the SUBSCRIBE and NOTIFY\n
    \  methods are proposed.\n"
  - contents:
    - "5.1.  Appropriateness of Usage\n   When designing an event package using the
      methods described in this\n   document for event notification, it is important
      to consider: is SIP\n   an appropriate mechanism for the problem set?  Is SIP
      being selected\n   because of some unique feature provided by the protocol (e.g.,
      user\n   mobility) or merely because \"it can be done\"?  If you find yourself\n
      \  defining event packages for notifications related to, for example,\n   network
      management or the temperature inside your car's engine, you\n   may want to
      reconsider your selection of protocols.\n      Those interested in extending
      the mechanism defined in this\n      document are urged to follow the development
      of \"Guidelines for\n      Authors of SIP Extensions\" [RFC4485] for further
      guidance\n      regarding appropriate uses of SIP.\n   Further, it is expected
      that this mechanism is not to be used in\n   applications where the frequency
      of reportable events is excessively\n   rapid (e.g., more than about once per
      second).  A SIP network is\n   generally going to be provisioned for a reasonable
      signaling volume;\n   sending a notification every time a user's GPS position
      changes by\n   one hundredth of a second could easily overload such a network.\n"
    title: 5.1.  Appropriateness of Usage
  - contents:
    - "5.2.  Event Template-Packages\n   Normal event packages define a set of state
      applied to a specific\n   type of resource, such as user presence, call state,
      and messaging\n   mailbox state.\n   Event template-packages are a special type
      of package that define a\n   set of state applied to other packages, such as
      statistics, access\n   policy, and subscriber lists.  Event template-packages
      may even be\n   applied to other event template-packages.\n   To extend the
      object-oriented analogy made earlier, event template-\n   packages can be thought
      of as templatized C++ packages that must be\n   applied to other packages to
      be useful.\n   The name of an event template-package as applied to a package
      is\n   formed by appending a period followed by the event template-package\n
      \  name to the end of the package.  For example, if a template-package\n   called
      \"winfo\" were being applied to a package called \"presence\", the\n   event
      token used in the \"Event\" header field would be\n   \"presence.winfo\".\n
      \     This scheme may be arbitrarily extended.  For example, application\n      of
      the \"winfo\" package to the \"presence.winfo\" state of a resource\n      would
      be represented by the name \"presence.winfo.winfo\".  It\n      naturally follows
      from this syntax that the order in which\n      templates are specified is significant.\n
      \     For example: consider a theoretical event template-package called\n      \"list\".
      \ The event \"presence.winfo.list\" would be the application\n      of the \"list\"
      template to \"presence.winfo\", which would presumably\n      be a list of winfo
      state associated with presence.  On the other\n      hand, the event \"presence.list.winfo\"
      would represent the\n      application of winfo to \"presence.list\", which
      would be represent\n      the winfo state of a list of presence information.\n
      \  Event template-packages must be defined so that they can be applied\n   to
      any arbitrary package.  In other words, event template-packages\n   cannot be
      specifically tied to one or a few \"parent\" packages in such\n   a way that
      they will not work with other packages.\n"
    title: 5.2.  Event Template-Packages
  - contents:
    - "5.3.  Amount of State to Be Conveyed\n   When designing event packages, it
      is important to consider the type\n   of information that will be conveyed during
      a notification.\n   A natural temptation is to convey merely the event (e.g.,
      \"a new\n   voice message just arrived\") without accompanying state (e.g.,
      \"7\n   total voice messages\").  This complicates implementation of\n   subscribing
      entities (since they have to maintain complete state for\n   the entity to which
      they have subscribed), and also is particularly\n   susceptible to synchronization
      problems.\n   This problem has two possible solutions that event packages may\n
      \  choose to implement.\n"
    - contents:
      - "5.3.1.  Complete State Information\n   In general, event packages need to
        be able to convey a well-defined\n   and complete state, rather than just
        a stream of events.  If it is\n   not possible to describe complete system
        state for transmission in\n   NOTIFY requests, then the problem set is not
        a good candidate for an\n   event package.\n   For packages that typically
        convey state information that is\n   reasonably small (on the order of 1 KB
        or so), it is suggested that\n   event packages are designed so as to send
        complete state information\n   whenever an event occurs.\n   In some circumstances,
        conveying the current state alone may be\n   insufficient for a particular
        class of events.  In these cases, the\n   event packages should include complete
        state information along with\n   the event that occurred.  For example, conveying
        \"no customer service\n   representatives available\" may not be as useful
        as conveying \"no\n   customer service representatives available; representative\n
        \  sip:46@cs.xyz.int just logged off\".\n"
      title: 5.3.1.  Complete State Information
    - contents:
      - "5.3.2.  State Deltas\n   In the case that the state information to be conveyed
        is large, the\n   event package may choose to detail a scheme by which NOTIFY
        requests\n   contain state deltas instead of complete state.\n   Such a scheme
        would work as follows: any NOTIFY request sent in\n   immediate response to
        a SUBSCRIBE request contains full state\n   information.  NOTIFY requests
        sent because of a state change will\n   contain only the state information
        that has changed; the subscriber\n   will then merge this information into
        its current knowledge about the\n   state of the resource.\n   Any event package
        that supports delta changes to states MUST include\n   a version number that
        increases by exactly one for each NOTIFY\n   transaction in a subscription.
        \ Note that the state version number\n   appears in the body of the message,
        not in a SIP header field.\n   If a NOTIFY request arrives that has a version
        number that is\n   incremented by more than one, the subscriber knows that
        a state delta\n   has been missed; it ignores the NOTIFY request containing
        the state\n   delta (except for the version number, which it retains to detect\n
        \  message loss), and re-sends a SUBSCRIBE request to force a NOTIFY\n   request
        containing a complete state snapshot.\n"
      title: 5.3.2.  State Deltas
    title: 5.3.  Amount of State to Be Conveyed
  - contents:
    - "5.4.  Event Package Responsibilities\n   Event packages are not required to
      reiterate any of the behavior\n   described in this document, although they
      may choose to do so for\n   clarity or emphasis.  In general, though, such packages
      are expected\n   to describe only the behavior that extends or modifies the
      behavior\n   described in this document.\n   Note that any behavior designated
      with \"SHOULD\" or \"MUST\" in this\n   document is not allowed to be weakened
      by extension documents;\n   however, such documents may elect to strengthen
      \"SHOULD\" requirements\n   to \"MUST\" requirements if required by their application.\n
      \  In addition to the normal sections expected in Standards Track RFCs\n   and
      SIP extension documents, authors of event packages need to\n   address each
      of the issues detailed in the following subsections.\n   For clarity: well-formed
      event package definitions contain sections\n   addressing each of these issues,
      ideally in the same order and with\n   the same titles as these subsections.\n"
    - contents:
      - "5.4.1.  Event Package Name\n   This section, which MUST be present, defines
        the token name to be\n   used to designate the event package.  It MUST include
        the information\n   that appears in the IANA registration of the token.  For
        information\n   on registering such types, see Section 7.\n"
      title: 5.4.1.  Event Package Name
    - contents:
      - "5.4.2.  Event Package Parameters\n   If parameters are to be used on the
        \"Event\" header field to modify\n   the behavior of the event package, the
        syntax and semantics of such\n   header fields MUST be clearly defined.\n
        \  Any \"Event\" header field parameters defined by an event package MUST\n
        \  be registered in the \"Header Field Parameters and Parameter Values\"\n
        \  registry defined by [RFC3968].  An \"Event\" header field parameter,\n
        \  once registered in conjunction with an event package, MUST NOT be\n   reused
        with any other event package.  Non-event-package\n   specifications MAY define
        \"Event\" header field parameters that apply\n   across all event packages
        (with emphasis on \"all\", as opposed to\n   \"several\"), such as the \"id\"
        parameter defined in this document.  The\n   restriction of a parameter to
        use with a single event package only\n   applies to parameters that are defined
        in conjunction with an event\n   package.\n"
      title: 5.4.2.  Event Package Parameters
    - contents:
      - "5.4.3.  SUBSCRIBE Request Bodies\n   It is expected that most, but not all,
        event packages will define\n   syntax and semantics for SUBSCRIBE request
        bodies; these bodies will\n   typically modify, expand, filter, throttle,
        and/or set thresholds for\n   the class of events being requested.  Designers
        of event packages are\n   strongly encouraged to reuse existing media types
        for message bodies\n   where practical.  See [RFC4288] for information on
        media type\n   specification and registration.\n   This mandatory section
        of an event package defines what type or types\n   of event bodies are expected
        in SUBSCRIBE requests (or specify that\n   no event bodies are expected).
        \ It should point to detailed\n   definitions of syntax and semantics for
        all referenced body types.\n"
      title: 5.4.3.  SUBSCRIBE Request Bodies
    - contents:
      - "5.4.4.  Subscription Duration\n   It is RECOMMENDED that event packages give
        a suggested range of times\n   considered reasonable for the duration of a
        subscription.  Such\n   packages MUST also define a default \"Expires\" value
        to be used if\n   none is specified.\n"
      title: 5.4.4.  Subscription Duration
    - contents:
      - "5.4.5.  NOTIFY Request Bodies\n   The NOTIFY request body is used to report
        state on the resource being\n   monitored.  Each package MUST define what
        type or types of event\n   bodies are expected in NOTIFY requests.  Such packages
        MUST specify\n   or cite detailed specifications for the syntax and semantics\n
        \  associated with such event bodies.\n   Event packages also MUST define
        which media type is to be assumed if\n   none are specified in the \"Accept\"
        header field of the SUBSCRIBE\n   request.\n"
      title: 5.4.5.  NOTIFY Request Bodies
    - contents:
      - "5.4.6.  Notifier Processing of SUBSCRIBE Requests\n   This section describes
        the processing to be performed by the notifier\n   upon receipt of a SUBSCRIBE
        request.  Such a section is required.\n   Information in this section includes
        details of how to authenticate\n   subscribers and authorization issues for
        the package.\n"
      title: 5.4.6.  Notifier Processing of SUBSCRIBE Requests
    - contents:
      - "5.4.7.  Notifier generation of NOTIFY requests\n   This section of an event
        package describes the process by which the\n   notifier generates and sends
        a NOTIFY request.  This includes\n   detailed information about what events
        cause a NOTIFY request to be\n   sent, how to compute the state information
        in the NOTIFY, how to\n   generate neutral or fake state information to hide
        authorization\n   delays and decisions from users, and whether state information
        is\n   complete or what the deltas are for notifications; see Section 5.3.\n
        \  Such a section is required.\n   This section may optionally describe the
        behavior used to process the\n   subsequent response.\n"
      title: 5.4.7.  Notifier generation of NOTIFY requests
    - contents:
      - "5.4.8.  Subscriber Processing of NOTIFY Requests\n   This section of an event
        package describes the process followed by\n   the subscriber upon receipt
        of a NOTIFY request, including any logic\n   required to form a coherent resource
        state (if applicable).\n"
      title: 5.4.8.  Subscriber Processing of NOTIFY Requests
    - contents:
      - "5.4.9.  Handling of Forked Requests\n   Each event package MUST specify whether
        forked SUBSCRIBE requests are\n   allowed to install multiple subscriptions.\n
        \  If such behavior is not allowed, the first potential dialog-\n   establishing
        message will create a dialog.  All subsequent NOTIFY\n   requests that correspond
        to the SUBSCRIBE request (i.e., have\n   matching \"To\", \"From\", \"Call-ID\",
        and \"Event\" header fields, as well\n   as \"From\" header field \"tag\"
        parameter and \"Event\" header field \"id\"\n   parameter) but that do not
        match the dialog would be rejected with a\n   481 response.  Note that the
        200-class response to the SUBSCRIBE\n   request can arrive after a matching
        NOTIFY request has been received;\n   such responses might not correlate to
        the same dialog established by\n   the NOTIFY request.  Except as required
        to complete the SUBSCRIBE\n   transaction, such non-matching 200-class responses
        are ignored.\n   If installing of multiple subscriptions by way of a single
        forked\n   SUBSCRIBE request is allowed, the subscriber establishes a new
        dialog\n   towards each notifier by returning a 200-class response to each\n
        \  NOTIFY request.  Each dialog is then handled as its own entity and is\n
        \  refreshed independently of the other dialogs.\n   In the case that multiple
        subscriptions are allowed, the event\n   package MUST specify whether merging
        of the notifications to form a\n   single state is required, and how such
        merging is to be performed.\n   Note that it is possible that some event packages
        may be defined in\n   such a way that each dialog is tied to a mutually exclusive
        state\n   that is unaffected by the other dialogs; this MUST be clearly stated\n
        \  if it is the case.\n"
      title: 5.4.9.  Handling of Forked Requests
    - contents:
      - "5.4.10.  Rate of Notifications\n   Each event package is expected to define
        a requirement (\"SHOULD\" or\n   \"MUST\" strength) that defines an absolute
        maximum on the rate at\n   which notifications are allowed to be generated
        by a single notifier.\n   Each package MAY further define a throttle mechanism
        that allows\n   subscribers to further limit the rate of notification.\n"
      title: 5.4.10.  Rate of Notifications
    - contents:
      - "5.4.11.  State Aggregation\n   Many event packages inherently work by collecting
        information about a\n   resource from a number of other sources -- either
        through the use of\n   PUBLISH [RFC3903], by subscribing to state information,
        or through\n   other state-gathering mechanisms.\n   Event packages that involve
        retrieval of state information for a\n   single resource from more than one
        source need to consider how\n   notifiers aggregate information into a single,
        coherent state.  Such\n   packages MUST specify how notifiers aggregate information
        and how\n   they provide authentication and authorization.\n"
      title: 5.4.11.  State Aggregation
    - contents:
      - "5.4.12.  Examples\n   Event packages SHOULD include several demonstrative
        message flow\n   diagrams paired with several typical, syntactically correct,
        and\n   complete messages.\n   It is RECOMMENDED that documents describing
        event packages clearly\n   indicate that such examples are informative and
        not normative, with\n   instructions that implementors refer to the main text
        of the document\n   for exact protocol details.\n"
      title: 5.4.12.  Examples
    - contents:
      - "5.4.13.  Use of URIs to Retrieve State\n   Some types of event packages may
        define state information that is\n   potentially too large to reasonably send
        in a SIP message.  To\n   alleviate this problem, event packages may include
        the ability to\n   convey a URI instead of state information; this URI will
        then be used\n   to retrieve the actual state information.\n   [RFC4483] defines
        a mechanism that can be used by event packages to\n   convey information in
        such a fashion.\n"
      title: 5.4.13.  Use of URIs to Retrieve State
    title: 5.4.  Event Package Responsibilities
  title: 5.  Event Packages
- contents:
  - '6.  Security Considerations

    '
  - contents:
    - "6.1.  Access Control\n   The ability to accept subscriptions should be under
      the direct\n   control of the notifier's user, since many types of events may
      be\n   considered private.  Similarly, the notifier should have the ability\n
      \  to selectively reject subscriptions based on the subscriber identity\n   (based
      on access control lists), using standard SIP authentication\n   mechanisms.
      \ The methods for creation and distribution of such access\n   control lists
      are outside the scope of this document.\n"
    title: 6.1.  Access Control
  - contents:
    - "6.2.  Notifier Privacy Mechanism\n   The mere act of returning certain 400-
      and 600-class responses to\n   SUBSCRIBE requests may, under certain circumstances,
      create privacy\n   concerns by revealing sensitive policy information.  In these
      cases,\n   the notifier SHOULD always return a 200 (OK) response.  While the\n
      \  subsequent NOTIFY request may not convey true state, it MUST appear\n   to
      contain a potentially correct piece of data from the point of view\n   of the
      subscriber, indistinguishable from a valid response.\n   Information about whether
      a user is authorized to subscribe to the\n   requested state is never conveyed
      back to the original user under\n   these circumstances.\n   Individual packages
      and their related documents for which such a mode\n   of operation makes sense
      can further describe how and why to generate\n   such potentially correct data.
      \ For example, such a mode of operation\n   is mandated by [RFC2779] for user
      presence information.\n"
    title: 6.2.  Notifier Privacy Mechanism
  - contents:
    - "6.3.  Denial-of-Service Attacks\n   The current model (one SUBSCRIBE request
      triggers a SUBSCRIBE\n   response and one or more NOTIFY requests) is a classic
      setup for an\n   amplifier node to be used in a smurf attack [CERT1998a].\n
      \  Also, the creation of state upon receipt of a SUBSCRIBE request can\n   be
      used by attackers to consume resources on a victim's machine,\n   rendering
      it unusable.\n   To reduce the chances of such an attack, implementations of
      notifiers\n   SHOULD require authentication.  Authentication issues are discussed\n
      \  in [RFC3261].\n"
    title: 6.3.  Denial-of-Service Attacks
  - contents:
    - "6.4.  Replay Attacks\n   Replaying of either SUBSCRIBE or NOTIFY requests can
      have detrimental\n   effects.\n   In the case of SUBSCRIBE requests, an attacker
      may be able to install\n   any arbitrary subscription that it witnessed being
      installed at some\n   point in the past.  Replaying of NOTIFY requests may be
      used to spoof\n   old state information (although a good versioning mechanism
      in the\n   body of the NOTIFY requests may help mitigate such an attack).  Note\n
      \  that the prohibition on sending NOTIFY requests to nodes that have\n   not
      subscribed to an event also aids in mitigating the effects of\n   such an attack.\n
      \  To prevent such attacks, implementations SHOULD require\n   authentication
      with anti-replay protection.  Authentication issues\n   are discussed in [RFC3261].\n"
    title: 6.4.  Replay Attacks
  - contents:
    - "6.5.  Man-in-the-Middle Attacks\n   Even with authentication, man-in-the-middle
      attacks using SUBSCRIBE\n   requests may be used to install arbitrary subscriptions,
      hijack\n   existing subscriptions, terminate outstanding subscriptions, or\n
      \  modify the resource to which a subscription is being made.  To\n   prevent
      such attacks, implementations SHOULD provide integrity\n   protection across
      \"Contact\", \"Route\", \"Expires\", \"Event\", and \"To\"\n   header fields
      (at a minimum) of SUBSCRIBE requests.  If SUBSCRIBE\n   request bodies are used
      to define further information about the state\n   of the call, they SHOULD be
      included in the integrity protection\n   scheme.\n   Man-in-the-middle attacks
      may also attempt to use NOTIFY requests to\n   spoof arbitrary state information
      and/or terminate outstanding\n   subscriptions.  To prevent such attacks, implementations
      SHOULD\n   provide integrity protection across the \"Call-ID\", \"CSeq\", and\n
      \  \"Subscription-State\" header fields and the bodies of NOTIFY requests.\n
      \  Integrity protection of message header fields and bodies is discussed\n   in
      [RFC3261].\n"
    title: 6.5.  Man-in-the-Middle Attacks
  - contents:
    - "6.6.  Confidentiality\n   The state information contained in a NOTIFY request
      has the potential\n   to contain sensitive information.  Implementations MAY
      encrypt such\n   information to ensure confidentiality.\n   While less likely,
      it is also possible that the information contained\n   in a SUBSCRIBE request
      contains information that users might not want\n   to have revealed.  Implementations
      MAY encrypt such information to\n   ensure confidentiality.\n   To allow the
      remote party to hide information it considers sensitive,\n   all implementations
      SHOULD be able to handle encrypted SUBSCRIBE and\n   NOTIFY requests.\n   The
      mechanisms for providing confidentiality are detailed in\n   [RFC3261].\n"
    title: 6.6.  Confidentiality
  title: 6.  Security Considerations
- contents:
  - "7.  IANA Considerations\n   With the exception of Section 7.2, the subsections
    here are for\n   current reference, carried over from the original specification
    (RFC\n   3265).  IANA has updated all registry references that pointed to RFC\n
    \  3265 to instead indicate this document and created the new \"reason\n   code\"
    registry described in Section 7.2.\n"
  - contents:
    - "7.1.  Event Packages\n   This document defines an event-type namespace that
      requires a central\n   coordinating body.  The body chosen for this coordination
      is the\n   Internet Assigned Numbers Authority (IANA).\n   There are two different
      types of event-types: normal event packages\n   and event template-packages;
      see Section 5.2.  To avoid confusion,\n   template-package names and package
      names share the same namespace; in\n   other words, an event template-package
      is forbidden from sharing a\n   name with a package.\n   Policies for registration
      of SIP event packages and SIP event package\n   templates are defined in Section
      4.1 of [RFC5727].\n   Registrations with the IANA are required to include the
      token being\n   registered and whether the token is a package or a template-package.\n
      \  Further, packages must include contact information for the party\n   responsible
      for the registration and/or a published document that\n   describes the event
      package.  Event template-package token\n   registrations are also required to
      include a pointer to the published\n   RFC that defines the event template-package.\n
      \  Registered tokens to designate packages and template-packages are\n   disallowed
      from containing the character \".\", which is used to\n   separate template-packages
      from packages.\n"
    - contents:
      - "7.1.1.  Registration Information\n   This document specifies no package or
        template-package names.  All\n   entries in this table are added by other
        documents.  The remainder of\n   the text in this section gives an example
        of the type of information\n   to be maintained by the IANA; it also demonstrates
        all four possible\n   permutations of package type, contact, and reference.\n
        \  The table below lists the event packages and template-packages\n   defined
        for use with the \"SIP-Specific Event Notification\" mechanism\n   [RFC 6665].
        \ Each name is designated as a package or a template-\n   package under \"Type\".\n
        \  Package Name      Type         Contact      Reference\n   ------------
        \     ----         -------      ---------\n   example1          package      [Doe]
        \       [RFCnnnn]\n   example2          package                   [RFCnnnn]\n
        \  example3          template     [Doe]        [RFCnnnn]\n   example4          template
        \                 [RFCnnnn]\n   PEOPLE\n   ------\n   [Doe] John Doe <john.doe@example.com>\n
        \  REFERENCES\n   ----------\n   [RFCnnnn] Doe, J., \"Sample Document\", RFC
        nnnn, Month YYYY.\n"
      title: 7.1.1.  Registration Information
    - contents:
      - "7.1.2.  Registration Template\n   To: ietf-sip-events@iana.org\n   Subject:
        Registration of new SIP event package\n   Package name:\n      (Package names
        must conform to the syntax described in\n      Section 8.2.1.)\n   Is this
        registration for a Template-Package:\n      (indicate yes or no)\n   Published
        specification(s):\n      (Template-packages require a published RFC.  Other
        packages may\n      reference a specification when appropriate.)\n   Person
        & email address to contact for further information:\n      (self-explanatory)\n"
      title: 7.1.2.  Registration Template
    title: 7.1.  Event Packages
  - contents:
    - "7.2.  Reason Codes\n   This document further defines \"reason\" codes for use
      in the\n   \"Subscription-State\" header field (see Section 4.1.3).\n   Following
      the policies outlined in \"Guidelines for Writing an IANA\n   Considerations
      Section in RFCs\" [RFC5226], new reason codes require a\n   Standards Action.\n
      \  Registrations with the IANA include the reason code being registered\n   and
      a reference to a published document that describes the event\n   package.  Insertion
      of such values takes place as part of the RFC\n   publication process or as
      the result of liaison activity between\n   standards development organizations
      (SDOs), the result of which will\n   be publication of an associated RFC.  New
      reason codes must conform\n   to the syntax of the ABNF \"token\" element defined
      in [RFC3261].\n   [RFC4660] defined a new reason code prior to the establishment
      of an\n   IANA registry.  We include its reason code (\"badfilter\") in the\n
      \  initial list of reason codes to ensure a complete registry.\n   The IANA
      registry for reason codes has been initialized with the\n   following values:\n
      \  Reason Code            Reference\n   -----------            ---------\n   deactivated
      \           [RFC6665]\n   probation              [RFC6665]\n   rejected               [RFC6665]\n
      \  timeout                [RFC6665]\n   giveup                 [RFC6665]\n   noresource
      \            [RFC6665]\n   invariant              [RFC6665]\n   badfilter              [RFC4660]\n
      \  REFERENCES\n   ----------\n   [RFC6665]  A.B. Roach, \"SIP-Specific Event
      Notification\", RFC 6665,\n              July 2012.\n   [RFC4660]  Khartabil,
      H., Leppanen, E., Lonnfors, M., and\n              J. Costa-Requena, \"Functional
      Description of Event\n              Notification Filtering\", September 2006.\n"
    title: 7.2.  Reason Codes
  - contents:
    - "7.3.  Header Field Names\n   This document registers three new header field
      names, described\n   elsewhere in this document.  These header fields are defined
      by the\n   following information, which is to be added to the header field sub-\n
      \  registry under http://www.iana.org/assignments/sip-parameters.\n   Header
      Name:   Allow-Events\n   Compact Form:  u\n   Header Name:   Subscription-State\n
      \  Compact Form:  (none)\n   Header Name:   Event\n   Compact Form:  o\n"
    title: 7.3.  Header Field Names
  - contents:
    - "7.4.  Response Codes\n   This document registers two new response codes.  These
      response codes\n   are defined by the following information, which is to be
      added to the\n   method and response-code sub-registry under\n   http://www.iana.org/assignments/sip-parameters.\n
      \  Response Code Number:   202\n   Default Reason Phrase:  Accepted\n   Response
      Code Number:   489\n   Default Reason Phrase:  Bad Event\n"
    title: 7.4.  Response Codes
  title: 7.  IANA Considerations
- contents:
  - "8.  Syntax\n   This section describes the syntax extensions required for event\n
    \  notification in SIP.  Semantics are described in Section 4.  Note\n   that
    the formal syntax definitions described in this document are\n   expressed in
    the ABNF format used in [RFC3261] and contain references\n   to elements defined
    therein.\n"
  - contents:
    - "8.1.  New Methods\n   This document describes two new SIP methods: SUBSCRIBE
      and NOTIFY.\n"
    - contents:
      - "8.1.1.  SUBSCRIBE Method\n   \"SUBSCRIBE\" is added to the definition of
        the element \"Method\" in the\n   SIP message grammar.\n   Like all SIP method
        names, the SUBSCRIBE method name is case\n   sensitive.  The SUBSCRIBE method
        is used to request asynchronous\n   notification of an event or set of events
        at a later time.\n"
      title: 8.1.1.  SUBSCRIBE Method
    - contents:
      - "8.1.2.  NOTIFY Method\n   \"NOTIFY\" is added to the definition of the element
        \"Method\" in the\n   SIP message grammar.\n   The NOTIFY method is used to
        notify a SIP node that an event that has\n   been requested by an earlier
        SUBSCRIBE method has occurred.  It may\n   also provide further details about
        the event.\n"
      title: 8.1.2.  NOTIFY Method
    title: 8.1.  New Methods
  - contents:
    - '8.2.  New Header Fields

      '
    - contents:
      - "8.2.1.  \"Event\" Header Field\n   Event is added to the definition of the
        element \"message-header\n   field\" in the SIP message grammar.\n   For the
        purposes of matching NOTIFY requests with SUBSCRIBE requests,\n   the event-type
        portion of the \"Event\" header field is compared byte\n   by byte, and the
        \"id\" parameter token (if present) is compared byte\n   by byte.  An \"Event\"
        header field containing an \"id\" parameter never\n   matches an \"Event\"
        header field without an \"id\" parameter.  No other\n   parameters are considered
        when performing a comparison.  SUBSCRIBE\n   responses are matched per the
        transaction handling rules in\n   [RFC3261].\n      Note that the foregoing
        text means that \"Event: foo; id=1234\"\n      would match \"Event: foo; param=abcd;
        id=1234\", but not \"Event:\n      foo\" (\"id\" does not match) or \"Event:
        Foo; id=1234\" (\"Event\"\n      portion does not match).\n   This document
        does not define values for event-types.  These values\n   will be defined
        by individual event packages and MUST be registered\n   with the IANA.\n   There
        MUST be exactly one event type listed per \"Event\" header field.\n   Multiple
        events per message are disallowed.\n   The \"Event\" header field is defined
        only for use in SUBSCRIBE and\n   NOTIFY requests and other requests whose
        definition explicitly calls\n   for its use.  It MUST NOT appear in any other
        SIP requests and MUST\n   NOT appear in responses.\n"
      title: 8.2.1.  "Event" Header Field
    - contents:
      - "8.2.2.  \"Allow-Events\" Header Field\n   \"Allow-Events\" is added to the
        definition of the element \"general-\n   header field\" in the SIP message
        grammar.  Its usage is described in\n   Section 4.4.4.\n   User agents MAY
        include the \"Allow-Events\" header field in any\n   request or response,
        as long as its contents comply with the behavior\n   described in Section
        4.4.4.\n"
      title: 8.2.2.  "Allow-Events" Header Field
    - contents:
      - "8.2.3.  \"Subscription-State\" Header Field\n   \"Subscription-State\" is
        added to the definition of the element\n   \"request-header\" field in the
        SIP message grammar.  Its usage is\n   described in Section 4.1.3.  \"Subscription-State\"
        header fields are\n   defined for use in NOTIFY requests only.  They MUST
        NOT appear in\n   other SIP requests or responses.\n"
      title: 8.2.3.  "Subscription-State" Header Field
    title: 8.2.  New Header Fields
  - contents:
    - '8.3.  New Response Codes

      '
    - contents:
      - "8.3.1.  202 (Accepted) Response Code\n   For historical purposes, the 202
        (Accepted) response code is added to\n   the \"Success\" header field definition.\n
        \  This document does not specify the use of the 202 response code in\n   conjunction
        with the SUBSCRIBE or NOTIFY methods.  Previous versions\n   of the SIP Events
        Framework assigned specific meaning to the 202\n   response code.\n   Due
        to response handling in forking cases, any 202 response to a\n   SUBSCRIBE
        request may be absorbed by a proxy, and thus it can never\n   be guaranteed
        to be received by the UAC.  Furthermore, there is no\n   actual processing
        difference for a 202 as compared to a 200; a NOTIFY\n   request is sent after
        the subscription is processed, and it conveys\n   the correct state.  SIP
        interoperability tests found that\n   implementations were handling 202 differently
        from 200, leading to\n   incompatibilities.  Therefore, the 202 response is
        being deprecated\n   to make it clear there is no such difference and 202
        should not be\n   handled differently than 200.\n   Implementations conformant
        with the current specification MUST treat\n   an incoming 202 response as
        identical to a 200 response and MUST NOT\n   generate 202 response codes to
        SUBSCRIBE or NOTIFY requests.\n   This document also updates [RFC4660], which
        reiterates the 202-based\n   behavior in several places.  Implementations
        compliant with the\n   present document MUST NOT send a 202 response to a
        SUBSCRIBE request\n   and will send an alternate success response (such as
        200) in its\n   stead.\n"
      title: 8.3.1.  202 (Accepted) Response Code
    - contents:
      - "8.3.2.  489 (Bad Event) Response Code\n   The 489 event response is added
        to the \"Client-Error\" header field\n   definition. 489 (Bad Event) is used
        to indicate that the server did\n   not understand the event package specified
        in a \"Event\" header field.\n"
      title: 8.3.2.  489 (Bad Event) Response Code
    title: 8.3.  New Response Codes
  - contents:
    - "8.4.  Augmented BNF Definitions\n   The Augmented BNF [RFC5234] definitions
      for the various new and\n   modified syntax elements follows.  The notation
      is as used in\n   [RFC3261], and any elements not defined in this section are
      as\n   defined in SIP and the documents to which it refers.\n   SUBSCRIBEm        =
      %x53.55.42.53.43.52.49.42.45 ; SUBSCRIBE in caps\n   NOTIFYm           = %x4E.4F.54.49.46.59
      ; NOTIFY in caps\n   extension-method  = SUBSCRIBEm / NOTIFYm / token\n   Event
      \            =  ( \"Event\" / \"o\" ) HCOLON event-type\n                        *(
      SEMI event-param )\n   event-type        =  event-package *( \".\" event-template
      )\n   event-package     =  token-nodot\n   event-template    =  token-nodot\n
      \  token-nodot       =  1*( alphanum / \"-\"  / \"!\" / \"%\" / \"*\"\n                            /
      \"_\" / \"+\" / \"`\" / \"'\" / \"~\" )\n   ; The use of the \"id\" parameter
      is deprecated; it is included\n   ; for backwards-compatibility purposes only.\n
      \  event-param       =  generic-param / ( \"id\" EQUAL token )\n   Allow-Events
      \     =  ( \"Allow-Events\" / \"u\" ) HCOLON event-type\n                        *(COMMA
      event-type)\n   Subscription-State   = \"Subscription-State\" HCOLON substate-value\n
      \                         *( SEMI subexp-params )\n   substate-value       =
      \"active\" / \"pending\" / \"terminated\"\n                          / extension-substate\n
      \  extension-substate   = token\n   subexp-params        =   (\"reason\" EQUAL
      event-reason-value)\n                          / (\"expires\" EQUAL delta-seconds)\n
      \                         / (\"retry-after\" EQUAL delta-seconds)\n                          /
      generic-param\n   event-reason-value   =   \"deactivated\"\n                          /
      \"probation\"\n                          / \"rejected\"\n                          /
      \"timeout\"\n                          / \"giveup\"\n                          /
      \"noresource\"\n                          / \"invariant\"\n                          /
      event-reason-extension\n   event-reason-extension = token\n"
    title: 8.4.  Augmented BNF Definitions
  title: 8.  Syntax
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]    Bradner, S., \"Key words for use
      in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC2848]    Petrack, S. and L. Conroy, \"The PINT Service Protocol:\n
      \               Extensions to SIP and SDP for IP Access to Telephone\n                Call
      Services\", RFC 2848, June 2000.\n   [RFC3261]    Rosenberg, J., Schulzrinne,
      H., Camarillo, G., Johnston,\n                A., Peterson, J., Sparks, R.,
      Handley, M., and E.\n                Schooler, \"SIP: Session Initiation Protocol\",
      RFC 3261,\n                June 2002.\n   [RFC3265]    Roach, A., \"Session
      Initiation Protocol (SIP)-Specific\n                Event Notification\", RFC
      3265, June 2002.\n   [RFC3968]    Camarillo, G., \"The Internet Assigned Number
      Authority\n                (IANA) Header Field Parameter Registry for the Session\n
      \               Initiation Protocol (SIP)\", BCP 98, RFC 3968,\n                December
      2004.\n   [RFC4483]    Burger, E., \"A Mechanism for Content Indirection in\n
      \               Session Initiation Protocol (SIP) Messages\", RFC 4483,\n                May
      2006.\n   [RFC5226]    Narten, T. and H. Alvestrand, \"Guidelines for Writing
      an\n                IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n
      \               May 2008.\n   [RFC5234]    Crocker, D. and P. Overell, \"Augmented
      BNF for Syntax\n                Specifications: ABNF\", STD 68, RFC 5234, January
      2008.\n   [RFC5627]    Rosenberg, J., \"Obtaining and Using Globally Routable\n
      \               User Agent URIs (GRUUs) in the Session Initiation\n                Protocol
      (SIP)\", RFC 5627, October 2009.\n   [RFC5727]    Peterson, J., Jennings, C.,
      and R. Sparks, \"Change\n                Process for the Session Initiation
      Protocol (SIP) and\n                the Real-time Applications and Infrastructure
      Area\",\n                BCP 67, RFC 5727, March 2010.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [RFC2779]    Day, M., Aggarwal, S., Mohr,
      G., and J. Vincent,\n                \"Instant Messaging / Presence Protocol
      Requirements\",\n                RFC 2779, February 2000.\n   [RFC3515]    Sparks,
      R., \"The Session Initiation Protocol (SIP) Refer\n                Method\",
      RFC 3515, April 2003.\n   [RFC3840]    Rosenberg, J., Schulzrinne, H., and P.
      Kyzivat,\n                \"Indicating User Agent Capabilities in the Session\n
      \               Initiation Protocol (SIP)\", RFC 3840, August 2004.\n   [RFC3891]
      \   Mahy, R., Biggs, B., and R. Dean, \"The Session\n                Initiation
      Protocol (SIP) \"Replaces\" Header\", RFC 3891,\n                September 2004.\n
      \  [RFC3903]    Niemi, A., \"Session Initiation Protocol (SIP) Extension\n                for
      Event State Publication\", RFC 3903, October 2004.\n   [RFC3911]    Mahy, R.
      and D. Petrie, \"The Session Initiation Protocol\n                (SIP) \"Join\"
      Header\", RFC 3911, October 2004.\n   [RFC4235]    Rosenberg, J., Schulzrinne,
      H., and R. Mahy, \"An INVITE-\n                Initiated Dialog Event Package
      for the Session\n                Initiation Protocol (SIP)\", RFC 4235, November
      2005.\n   [RFC4288]    Freed, N. and J. Klensin, \"Media Type Specifications
      and\n                Registration Procedures\", BCP 13, RFC 4288,\n                December
      2005.\n   [RFC4485]    Rosenberg, J. and H. Schulzrinne, \"Guidelines for\n
      \               Authors of Extensions to the Session Initiation Protocol\n                (SIP)\",
      RFC 4485, May 2006.\n   [RFC4538]    Rosenberg, J., \"Request Authorization
      through Dialog\n                Identification in the Session Initiation Protocol\n
      \               (SIP)\", RFC 4538, June 2006.\n   [RFC4660]    Khartabil, H.,
      Leppanen, E., Lonnfors, M., and J. Costa-\n                Requena, \"Functional
      Description of Event Notification\n                Filtering\", RFC 4660, September
      2006.\n   [RFC5057]    Sparks, R., \"Multiple Dialog Usages in the Session\n
      \               Initiation Protocol\", RFC 5057, November 2007.\n   [RFC5839]
      \   Niemi, A. and D. Willis, \"An Extension to Session\n                Initiation
      Protocol (SIP) Events for Conditional Event\n                Notification\",
      RFC 5839, May 2010.\n   [CERT1998a]  CERT, \"CERT Advisory CA-1998-01: Smurf
      IP Denial-of-\n                Service Attacks\", 1998,\n                <http://www.cert.org/advisories/CA-1998-01.html>.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  Acknowledgements\n   Thanks to the participants in the Events BOF
    at the 48th IETF meeting\n   in Pittsburgh, as well as those who gave ideas and
    suggestions on the\n   SIP Events mailing list.  In particular, I wish to thank
    Henning\n   Schulzrinne of Columbia University for coming up with the final\n
    \  three-tiered event identification scheme, Sean Olson for\n   miscellaneous
    guidance, Jonathan Rosenberg for a thorough scrubbing\n   of the first draft version,
    and the authors of the \"SIP Extensions\n   for Presence\" document for their
    input to SUBSCRIBE and NOTIFY\n   request semantics.\n   I also owe a debt of
    gratitude to all the implementors who have\n   provided feedback on areas of confusion
    or difficulty in the original\n   specification.  In particular, Robert Sparks'
    Herculean efforts\n   organizing, running, and collecting data from the SIPit
    events have\n   proven invaluable in shaking out specification bugs.  Robert Sparks\n
    \  is also responsible for untangling the dialog usage mess, in the form\n   of
    RFC 5057 [RFC5057].\n"
  title: Appendix A.  Acknowledgements
- contents:
  - "Appendix B.  Changes from RFC 3265\n   This document represents several changes
    from the mechanism\n   originally described in RFC 3265.  This section summarizes
    those\n   changes.  Bug numbers refer to the identifiers for the bug reports\n
    \  kept on file at http://bugs.sipit.net/.\n"
  - contents:
    - "B.1.  Bug 666: Clarify use of \"expires=xxx\" with \"terminated\"\n   Strengthened
      language in Section 4.1.3 to clarify that \"expires\"\n   should not be sent
      with \"terminated\", and must be ignored if\n   received.\n"
    title: 'B.1.  Bug 666: Clarify use of "expires=xxx" with "terminated"'
  - contents:
    - "B.2.  Bug 667: Reason code for unsub/poll not clearly spelled out\n   Clarified
      description of \"timeout\" in Section 4.1.3. (n.b., the text\n   in Section
      4.4.3 is actually pretty clear about this).\n"
    title: 'B.2.  Bug 667: Reason code for unsub/poll not clearly spelled out'
  - contents:
    - "B.3.  Bug 669: Clarify: SUBSCRIBE for a duration might be answered with\n      a
      NOTIFY/expires=0\n   Added clarifying text to Section 4.2.2 explaining that
      shortening a\n   subscription to zero seconds is valid.  Also added sentence
      to\n   Section 3.1.1 explicitly allowing shortening to zero.\n"
    title: 'B.3.  Bug 669: Clarify: SUBSCRIBE for a duration might be answered with'
  - contents:
    - "B.4.  Bug 670: Dialog State Machine needs clarification\n   The issues associated
      with the bug deal exclusively with the handling\n   of multiple usages with
      a dialog.  This behavior has been deprecated\n   and moved to Section 4.5.2.
      \ This section, in turn, cites [RFC5057],\n   which addresses all of the issues
      in Bug 670.\n"
    title: 'B.4.  Bug 670: Dialog State Machine needs clarification'
  - contents:
    - "B.5.  Bug 671: Clarify timeout-based removal of subscriptions\n   Changed Section
      4.2.2 to specifically cite Timer F (so as to avoid\n   ambiguity between transaction
      timeouts and retransmission timeouts).\n"
    title: 'B.5.  Bug 671: Clarify timeout-based removal of subscriptions'
  - contents:
    - "B.6.  Bug 672: Mandate \"expires\" in NOTIFY\n   Changed strength of including
      of \"expires\" in a NOTIFY from \"SHOULD\"\n   to \"MUST\" in Section 4.2.2.\n"
    title: 'B.6.  Bug 672: Mandate "expires" in NOTIFY'
  - contents:
    - "B.7.  Bug 673: INVITE 481 response effect clarification\n   This bug was addressed
      in [RFC5057].\n"
    title: 'B.7.  Bug 673: INVITE 481 response effect clarification'
  - contents:
    - "B.8.  Bug 677: SUBSCRIBE response matching text in error\n   Fixed Section
      8.2.1 to remove incorrect \"...responses and...\" --\n   explicitly pointed
      to SIP for transaction response handling.\n"
    title: 'B.8.  Bug 677: SUBSCRIBE response matching text in error'
  - contents:
    - "B.9.  Bug 695: Document is not explicit about response to NOTIFY at\n      subscription
      termination\n   Added text to Section 4.4.1 indicating that the typical response
      to a\n   terminal NOTIFY is a 200 (OK).\n"
    title: 'B.9.  Bug 695: Document is not explicit about response to NOTIFY at'
  - contents:
    - "B.10.  Bug 696: Subscription state machine needs clarification\n   Added state
      machine diagram to Section 4.1.2 with explicit handling\n   of what to do when
      a SUBSCRIBE never shows up.  Added definition of\n   and handling for new Timer
      N to Section 4.1.2.4.  Added state machine\n   to Section 4.2.2 to reinforce
      text.\n"
    title: 'B.10.  Bug 696: Subscription state machine needs clarification'
  - contents:
    - "B.11.  Bug 697: Unsubscription behavior could be clarified\n   Added text to
      Section 4.2.1.4 encouraging (but not requiring) full\n   state in final NOTIFY
      request.  Also added text to Section 4.1.2.3\n   warning subscribers that full
      state may or may not be present in the\n   final NOTIFY.\n"
    title: 'B.11.  Bug 697: Unsubscription behavior could be clarified'
  - contents:
    - "B.12.  Bug 699: NOTIFY and SUBSCRIBE are target refresh requests\n   Added
      text to both Sections 3.1 and 3.2 explicitly indicating that\n   SUBSCRIBE and
      NOTIFY are target refresh methods.\n"
    title: 'B.12.  Bug 699: NOTIFY and SUBSCRIBE are target refresh requests'
  - contents:
    - "B.13.  Bug 722: Inconsistent 423 reason phrase text\n   Changed reason phrase
      to \"Interval Too Brief\" in Sections 4.2.1.1 and\n   4.2.1.4, to match 423
      reason phrase in SIP [RFC3261].\n"
    title: 'B.13.  Bug 722: Inconsistent 423 reason phrase text'
  - contents:
    - "B.14.  Bug 741: Guidance needed on when to not include \"Allow-Events\"\n   Added
      non-normative clarification to Section 4.4.4 regarding\n   inclusion of \"Allow-Events\"
      in a NOTIFY for the one-and-only package\n   supported by the notifier.\n"
    title: 'B.14.  Bug 741: Guidance needed on when to not include "Allow-Events"'
  - contents:
    - "B.15.  Bug 744: 5xx to NOTIFY terminates a subscription, but should not\n   Issue
      of subscription (usage) termination versus dialog termination\n   is handled
      in [RFC5057].  The text in Section 4.2.2 has been updated\n   to summarize the
      behavior described by RFC 5057, and cites it for\n   additional detail and rationale.\n"
    title: 'B.15.  Bug 744: 5xx to NOTIFY terminates a subscription, but should not'
  - contents:
    - "B.16.  Bug 752: Detection of forked requests is incorrect\n   Removed erroneous
      \"CSeq\" from list of matching criteria in\n   Section 5.4.9.\n"
    title: 'B.16.  Bug 752: Detection of forked requests is incorrect'
  - contents:
    - "B.17.  Bug 773: Reason code needs IANA registry\n   Added Section 7.2 to create
      and populate IANA registry.\n"
    title: 'B.17.  Bug 773: Reason code needs IANA registry'
  - contents:
    - "B.18.  Bug 774: Need new reason for terminating subscriptions to\n       resources
      that never change\n   Added new \"invariant\" reason code to Section 4.1.3 and
      to ABNF syntax\n   in Section 8.4.\n"
    title: 'B.18.  Bug 774: Need new reason for terminating subscriptions to'
  - contents:
    - "B.19.  Clarify Handling of \"Route\"/\"Record-Route\" in NOTIFY\n   Changed
      text in Section 4.3 in order to mandate \"Record-Route\" in\n   initial SUBSCRIBE
      and all NOTIFY requests, and add \"MAY\"-level\n   statements for subsequent
      SUBSCRIBE requests.\n"
    title: B.19.  Clarify Handling of "Route"/"Record-Route" in NOTIFY
  - contents:
    - "B.20.  Eliminate Implicit Subscriptions\n   Added text to Section 4.2.1 explaining
      some of the problems\n   associated with implicit subscriptions, and added normative
      language\n   prohibiting them.  Removed language from Section 3.2 describing
      \"non-\n   SUBSCRIBE\" mechanisms for creating subscriptions.  Simplified\n
      \  language in Section 4.2.2, now that the soft-state/non-soft-state\n   distinction
      is unnecessary.\n"
    title: B.20.  Eliminate Implicit Subscriptions
  - contents:
    - "B.21.  Deprecate Dialog Reuse\n   Moved handling of dialog reuse and \"id\"
      handling to Section 4.5.2.\n   It is documented only for backwards-compatibility
      purposes.\n"
    title: B.21.  Deprecate Dialog Reuse
  - contents:
    - "B.22.  Rationalize Dialog Creation\n   Section 4.4.1 has been updated to specify
      that dialogs should be\n   created when the NOTIFY arrives.  Previously, the
      dialog was\n   established by the SUBSCRIBE 200 or by the NOTIFY transaction.
      \ This\n   was unnecessarily complicated; the newer rules are easier to\n   implement
      (and result in effectively the same behavior on the wire).\n"
    title: B.22.  Rationalize Dialog Creation
  - contents:
    - "B.23.  Refactor Behavior Sections\n   Reorganized Section 4 to consolidate
      behavior along role lines\n   (subscriber/notifier/proxy) instead of method
      lines.\n"
    title: B.23.  Refactor Behavior Sections
  - contents:
    - "B.24.  Clarify Sections That Need to Be Present in Event Packages\n   Added
      sentence to Section 5 clarifying that event packages are\n   expected to include
      explicit sections covering the issues discussed\n   in this section.\n"
    title: B.24.  Clarify Sections That Need to Be Present in Event Packages
  - contents:
    - "B.25.  Make CANCEL Handling More Explicit\n   Text in Section 4.6 now clearly
      calls out behavior upon receipt of a\n   CANCEL.  We also echo the \"...SHOULD
      NOT send...\" requirement from\n   [RFC3261].\n"
    title: B.25.  Make CANCEL Handling More Explicit
  - contents:
    - "B.26.  Remove \"State Agent\" Terminology\n   As originally planned, we anticipated
      a fairly large number of event\n   packages that would move back and forth between
      end-user devices and\n   servers in the network.  In practice, this has ended
      up not being the\n   case.  Certain events, like dialog state, are inherently
      hosted at\n   end-user devices; others, like presence, are almost always hosted
      in\n   the network (due to issues like composition, and the ability to\n   deliver
      information when user devices are offline).  Further, the\n   concept of State
      Agents is the most misunderstood by event package\n   authors.  In my expert
      review of event packages, I have yet to find\n   one that got the concept of
      State Agents completely correct -- and\n   most of them start out with the concept
      being 100% backwards from the\n   way RFC 3265 described it.\n   Rather than
      remove the ability to perform the actions previously\n   attributed to the widely
      misunderstood term \"State Agent\", we have\n   simply eliminated this term.
      \ Instead, we talk about the behaviors\n   required to create state agents (state
      aggregation, subscription\n   notification) without defining a formal term to
      describe the servers\n   that exhibit these behaviors.  In effect, this is an
      editorial change\n   to make life easier for event package authors; the actual
      protocol\n   does not change as a result.\n   The definition of \"State Agent\"
      has been removed from Section 2.\n   Section 4.4.2 has been retooled to discuss
      migration of subscription\n   in general, without calling out the specific example
      of state agents.\n   Section 5.4.11 has been focused on state aggregation in
      particular,\n   instead of state aggregation as an aspect of state agents.\n"
    title: B.26.  Remove "State Agent" Terminology
  - contents:
    - "B.27.  Miscellaneous Changes\n   The following changes are relatively minor
      revisions to the document\n   that resulted primarily from review of this document
      in the working\n   group and IESG, rather than implementation reports.\n   o
      \ Clarified scope of \"Event\" header field parameters.  In RFC 3265,\n      the
      scope is ambiguous, which causes problems with the registry in\n      RFC 3968.
      \ The new text ensures that \"Event\" header field\n      parameters are unique
      across all event packages.\n   o  Removed obsoleted language around IANA registration
      policies for\n      event packages.  Instead, we now cite RFC 5727, which updates
      RFC\n      3265, and is authoritative on event package registration policy.\n
      \  o  Several editorial updates after input from working group,\n      including
      proper designation of \"dialog usage\" rather than\n      \"dialog\" where needed.\n
      \  o  Clarified two normative statements about subscription termination\n      by
      changing from plain English prose to RFC2119 language.\n   o  Removed \"Table
      2\" expansions, per WG consensus on how SIP Table 2\n      is to be handled.\n
      \  o  Removed 202 response code.\n   o  Clarified that \"Allow-Events\" does
      not list event template-\n      packages.\n   o  Added clarification about proper
      response when the SUBSCRIBE\n      indicates an unknown media type in its \"Accept\"
      header field.\n   o  Minor clarifications to \"Route\" and \"Record-Route\"
      behavior.\n   o  Added non-normative warning about the limitations of state\n
      \     polling.\n   o  Added information about targeting subscriptions at specific\n
      \     dialogs.\n   o  Added RFC 3261 to list of documents updated by this one
      (rather\n      than the \"2543\" indicated by RFC 3265).\n   o  Clarified text
      in Section 3.1.1 explaining the meaning of\n      \"Expires: 0\".\n   o  Changed
      text in definition of \"probation\" reason code to indicate\n      that subscribers
      don't need to re-subscribe if the associated\n      state is no longer of use
      to them.\n   o  Specified that the termination of a subscription due to a NOTIFY\n
      \     transaction failure does not require sending another NOTIFY\n      message.\n
      \  o  Clarified how order of template application affects the meaning of\n      an
      \"Event\" header field value (e.g., \"foo.bar.baz\" is different\n      than
      \"foo.baz.bar\").\n"
    title: B.27.  Miscellaneous Changes
  title: Appendix B.  Changes from RFC 3265
- contents:
  - "Author's Address\n   Adam Roach\n   Tekelec\n   17210 Campbell Rd.\n   Suite
    250\n   Dallas, TX  75252\n   US\n   EMail: adam@nostrum.com\n"
  title: Author's Address
