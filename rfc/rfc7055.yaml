- title: __initial_text__
  contents:
  - '     A GSS-API Mechanism for the Extensible Authentication Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   This document defines protocols, procedures, and conventions to\
    \ be\n   employed by peers implementing the Generic Security Service\n   Application\
    \ Program Interface (GSS-API) when using the Extensible\n   Authentication Protocol\
    \ mechanism.  Through the GS2 family of\n   mechanisms defined in RFC 5801, these\
    \ protocols also define how\n   Simple Authentication and Security Layer (SASL)\
    \ applications use the\n   Extensible Authentication Protocol.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7055.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Discovery ..................................................4\n  \
    \    1.2. Authentication .............................................4\n    \
    \  1.3. Secure Association Protocol ................................6\n   2. Requirements\
    \ Notation ...........................................6\n   3. EAP Channel Binding\
    \ and Naming ..................................6\n      3.1. Mechanism Name Format\
    \ ......................................7\n      3.2. Internationalization of\
    \ Names .............................10\n      3.3. Exported Mechanism Names ..................................10\n\
    \      3.4. Acceptor Name RADIUS AVP ..................................11\n  \
    \    3.5. Proxy Verification of Acceptor Name .......................11\n   4.\
    \ Selection of EAP Method ........................................12\n   5. Context\
    \ Tokens .................................................13\n      5.1. Mechanisms\
    \ and Encryption Types ...........................14\n      5.2. Processing Received\
    \ Tokens ................................15\n      5.3. Error Subtokens ...........................................16\n\
    \      5.4. Initial State .............................................16\n  \
    \         5.4.1. Vendor Subtoken ....................................17\n    \
    \       5.4.2. Acceptor Name Request ..............................17\n      \
    \     5.4.3. Acceptor Name Response .............................18\n      5.5.\
    \ Authenticate State ........................................18\n           5.5.1.\
    \ EAP Request Subtoken ...............................19\n           5.5.2. EAP\
    \ Response Subtoken ..............................19\n      5.6. Extensions State\
    \ ..........................................20\n           5.6.1. Flags Subtoken\
    \ .....................................20\n           5.6.2. GSS Channel Bindings\
    \ Subtoken ......................20\n           5.6.3. MIC Subtoken .......................................21\n\
    \      5.7. Example Token .............................................22\n  \
    \    5.8. Context Options ...........................................23\n   6.\
    \ Acceptor Services ..............................................23\n      6.1.\
    \ GSS-API Channel Binding ...................................24\n      6.2. Per-Message\
    \ Security ......................................24\n      6.3. Pseudorandom Function\
    \ .....................................24\n   7. IANA Considerations ............................................25\n\
    \      7.1. OID Registry ..............................................25\n  \
    \    7.2. RFC 4121 Token Identifiers ................................26\n    \
    \  7.3. GSS-EAP Subtoken Types ....................................26\n      7.4.\
    \ RADIUS Attribute Assignments ..............................27\n      7.5. Registration\
    \ of the EAP-AES128 SASL Mechanisms ............28\n      7.6. GSS-EAP Errors\
    \ ............................................28\n      7.7. GSS-EAP Context Flags\
    \ .....................................30\n   8. Security Considerations ........................................30\n\
    \   9. Acknowledgements ...............................................32\n  \
    \ 10. References ....................................................32\n   Appendix\
    \ A. Pre-publication RADIUS VSA ............................33\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Application Bridging for Federated Access Beyond Web\
    \ (ABFAB)\n   document [ABFAB-ARCH] describes an architecture for providing\n\
    \   federated access management to applications using the Generic\n   Security\
    \ Service Application Programming Interface (GSS-API)\n   [RFC2743] and Simple\
    \ Authentication and Security Layer (SASL)\n   [RFC4422].  This specification\
    \ provides the core mechanism for\n   bringing federated authentication to these\
    \ applications.\n   The Extensible Authentication Protocol (EAP) [RFC3748] defines\
    \ a\n   framework for authenticating a network access client and server in\n \
    \  order to gain access to a network.  A variety of different EAP\n   methods\
    \ are in wide use; one of EAP's strengths is that for most\n   types of credentials\
    \ in common use, there is an EAP method that\n   permits the credential to be\
    \ used.\n   EAP is often used in conjunction with a backend Authentication,\n\
    \   Authorization and Accounting (AAA) server via RADIUS [RFC3579] or\n   Diameter\
    \ [RFC4072].  In this mode, the Network Access Server (NAS)\n   simply tunnels\
    \ EAP packets over the backend authentication protocol\n   to a home EAP/AAA server\
    \ for the client.  After EAP succeeds, the\n   backend authentication protocol\
    \ is used to communicate key material\n   to the NAS.  In this mode, the NAS need\
    \ not be aware of or have any\n   specific support for the EAP method used between\
    \ the client and the\n   home EAP server.  The client and EAP server share a credential\
    \ that\n   depends on the EAP method; the NAS and AAA server share a credential\n\
    \   based on the backend authentication protocol in use.  The backend\n   authentication\
    \ server acts as a trusted third party, enabling network\n   access even though\
    \ the client and NAS may not actually share any\n   common authentication methods.\
    \  As described in the architecture\n   document [ABFAB-ARCH], using AAA proxies,\
    \ this mode can be extended\n   beyond one organization to provide federated authentication\
    \ for\n   network access.\n   The GSS-API provides a generic framework for applications\
    \ to use\n   security services including authentication and per-message data\n\
    \   security.  Between protocols that support GSS-API directly or\n   protocols\
    \ that support SASL [RFC4422], many application protocols can\n   use GSS-API\
    \ for security services.  However, with the exception of\n   Kerberos [RFC4121],\
    \ few GSS-API mechanisms are in wide use on the\n   Internet.  While GSS-API permits\
    \ an application to be written\n   independent of the specific GSS-API mechanism\
    \ in use, there is no\n   facility to separate the server from the implementation\
    \ of the\n   mechanism as there is with EAP and backend authentication servers.\n\
    \   The goal of this specification is to combine GSS-API's support for\n   application\
    \ protocols with EAP/AAA's support for common credential\n   types and for authenticating\
    \ to a server without requiring that\n   server to specifically support the authentication\
    \ method in use.  In\n   addition, this specification supports the architectural\
    \ goal of\n   transporting attributes about subjects to relying parties.  Together\n\
    \   this combination will provide federated authentication and\n   authorization\
    \ for GSS-API applications.  This specification meets the\n   applicability requirements\
    \ for EAP to application authentication\n   [RFC7057].\n   This mechanism is a\
    \ GSS-API mechanism that encapsulates an EAP\n   conversation.  From the perspective\
    \ of RFC 3748, this specification\n   defines a new lower-layer protocol for EAP.\
    \  From the perspective of\n   the application, this specification defines a new\
    \ GSS-API mechanism.\n   Section 1.3 of [RFC5247] outlines the typical conversation\
    \ between\n   EAP peers where an EAP key is derived:\n   Phase 0: Discovery\n\
    \   Phase 1: Authentication\n            1a: EAP authentication\n            1b:\
    \ AAA Key Transport (optional)\n   Phase 2: Secure Association Protocol\n    \
    \        2a: Unicast Secure Association\n            2b: Multicast Secure Association\
    \ (optional)\n"
- title: 1.1.  Discovery
  contents:
  - "1.1.  Discovery\n   GSS-API peers discover each other and discover support for\
    \ GSS-API in\n   an application-dependent mechanism.  SASL [RFC4422] describes\
    \ how\n   discovery of a particular SASL mechanism such as a GSS-API EAP\n   mechanism\
    \ is conducted.  The Simple and Protected Negotiation\n   mechanism (SPNEGO) [RFC4178]\
    \ provides another approach for\n   discovering what GSS-API mechanisms are available.\
    \  The specific\n   approach used for discovery is out of scope for this mechanism.\n"
- title: 1.2.  Authentication
  contents:
  - "1.2.  Authentication\n   GSS-API authenticates a party called the \"GSS-API initiator\"\
    \ to the\n   GSS-API acceptor, optionally providing authentication of the acceptor\n\
    \   to the initiator.  Authentication starts with a mechanism-specific\n   message\
    \ called a \"context token\" sent from the initiator to the\n   acceptor.  The\
    \ acceptor responds, followed by the initiator, and so\n   on until authentication\
    \ succeeds or fails.  GSS-API context tokens\n   are reliably delivered by the\
    \ application using GSS-API.  The\n   application is responsible for in-order\
    \ delivery and retransmission.\n   EAP authenticates a party called a \"peer\"\
    \ to a party called the \"EAP\n   server\".  A third party called an \"EAP pass-through\
    \ authenticator\"\n   may decapsulate EAP messages from a lower layer and re-encapsulate\n\
    \   them into a AAA protocol.  The term EAP authenticator refers to\n   whichever\
    \ of the pass-through authenticator or EAP server receives\n   the lower-layer\
    \ EAP packets.  The first EAP message travels from the\n   authenticator to the\
    \ peer; a GSS-API message is sent from the\n   initiator to acceptor to prompt\
    \ the authenticator to send the first\n   EAP message.  The EAP peer maps onto\
    \ the GSS-API initiator.  The role\n   of the GSS-API acceptor is split between\
    \ the EAP authenticator and\n   the EAP server.  When these two entities are combined,\
    \ the division\n   resembles GSS-API acceptors in other mechanisms.  When a more\
    \ typical\n   deployment is used and there is a pass-through authenticator, most\n\
    \   context establishment takes place on the EAP server and per-message\n   operations\
    \ take place on the authenticator.  EAP messages from the\n   peer to the authenticator\
    \ are called responses; messages from the\n   authenticator to the peer are called\
    \ requests.\n   Because GSS-API applications provide guaranteed delivery of context\n\
    \   tokens, the EAP retransmission timeout MUST be infinite and the EAP\n   layer\
    \ MUST NOT retransmit a message.\n   This specification permits a GSS-API acceptor\
    \ to hand off the\n   processing of the EAP packets to a remote EAP server by\
    \ using AAA\n   protocols such as RADIUS, Transport Layer Security (TLS) Encryption\n\
    \   thereof [RFC6929], or Diameter.  In this case, the GSS-API acceptor\n   acts\
    \ as an EAP pass-through authenticator.  The pass-through\n   authenticator is\
    \ responsible for retransmitting AAA messages if a\n   response is not received\
    \ from the AAA server.  If a response cannot\n   be received, then the authenticator\
    \ generates an error at the GSS-API\n   level.  If EAP authentication is successful,\
    \ and where the chosen EAP\n   method supports key derivation, EAP keying material\
    \ may also be\n   derived.  If a AAA protocol is used, this can also be used to\n\
    \   replicate the EAP Key from the EAP server to the EAP authenticator.\n   See\
    \ Section 5 for details of the authentication exchange.\n"
- title: 1.3.  Secure Association Protocol
  contents:
  - "1.3.  Secure Association Protocol\n   After authentication succeeds, GSS-API\
    \ provides a number of per-\n   message security services that can be used:\n\
    \      GSS_Wrap() provides integrity and optional confidentiality for a\n    \
    \  message.\n      GSS_GetMIC() provides integrity protection for data sent\n\
    \      independently of the GSS-API\n      GSS_Pseudo_random [RFC4401] provides\
    \ key derivation functionality.\n   These services perform a function similar\
    \ to secure association\n   protocols in network access.  Like secure association\
    \ protocols,\n   these services need to be performed near the authenticator/acceptor\n\
    \   even when a AAA protocol is used to separate the authenticator from\n   the\
    \ EAP server.  The key used for these per-message services is\n   derived from\
    \ the EAP key; the EAP peer and authenticator derive this\n   key as a result\
    \ of a successful EAP authentication.  In the case that\n   the EAP authenticator\
    \ is acting as a pass-through, it obtains it via\n   the AAA protocol.  See Section\
    \ 6 for details.\n"
- title: 2.  Requirements Notation
  contents:
  - "2.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  EAP Channel Binding and Naming
  contents:
  - "3.  EAP Channel Binding and Naming\n   EAP authenticates a user to a realm. \
    \ The peer knows that it has\n   exchanged authentication with an EAP server in\
    \ a given realm.  Today,\n   the peer does not typically know which NAS it is\
    \ talking to securely.\n   That is often fine for network access.  However, privileges\
    \ to\n   delegate to a chat server seem very different than privileges for a\n\
    \   file server or trading site.  Also, an EAP peer knows the identity of\n  \
    \ the home realm, but perhaps not even the visited realm.\n   In contrast, GSS-API\
    \ takes a name for both the initiator and acceptor\n   as inputs to the authentication\
    \ process.  When mutual authentication\n   is used, both parties are authenticated.\
    \  The granularity of these\n   names is somewhat mechanism dependent.  In the\
    \ case of the Kerberos\n   mechanism, the acceptor name typically identifies both\
    \ the protocol\n   in use (such as IMAP) and the specific instance of the service\
    \ being\n   connected to.  The acceptor name almost always identifies the\n  \
    \ administrative domain providing service.\n   A GSS-API EAP mechanism needs to\
    \ provide GSS-API naming semantics in\n   order to work with existing GSS-API\
    \ applications.  EAP channel\n   binding [RFC6677] is used to provide GSS-API\
    \ naming semantics.\n   Channel binding sends a set of attributes from the peer\
    \ to the EAP\n   server either as part of the EAP conversation or as part of a\
    \ secure\n   association protocol.  In addition, attributes are sent in the\n\
    \   backend authentication protocol from the authenticator to the EAP\n   server.\
    \  The EAP server confirms the consistency of these attributes.\n   Confirming\
    \ attribute consistency also involves checking consistency\n   against a local\
    \ policy database as discussed in Section 3.5.  In\n   particular, the peer sends\
    \ the name of the acceptor it is\n   authenticating to as part of channel binding.\
    \  The acceptor sends its\n   full name as part of the backend authentication\
    \ protocol.  The EAP\n   server confirms consistency of the names.\n   EAP channel\
    \ binding is easily confused with a facility in GSS-API\n   also called \"channel\
    \ binding\".  GSS-API channel binding provides\n   protection against man-in-the-middle\
    \ attacks when GSS-API is used as\n   authentication inside some tunnel; it is\
    \ similar to a facility called\n   \"cryptographic binding\" in EAP.  See [RFC5056]\
    \ for a discussion of\n   the differences between these two facilities and Section\
    \ 6.1 for how\n   GSS-API channel binding is handled in this mechanism.\n"
- title: 3.1.  Mechanism Name Format
  contents:
  - "3.1.  Mechanism Name Format\n   Before discussing how the initiator and acceptor\
    \ names are validated\n   in the AAA infrastructure, it is necessary to discuss\
    \ what composes a\n   name for an EAP GSS-API mechanism.  GSS-API permits several\
    \ types of\n   generic names to be imported using GSS_Import_name().  Once a\n\
    \   mechanism is chosen, these names are converted into a mechanism-\n   specific\
    \ name called a \"Mechanism Name\".  Note that a Mechanism Name\n   is the name\
    \ of an initiator or acceptor, not of a GSS-API mechanism.\n   This section first\
    \ discusses the mechanism name form and then\n   discusses what name forms are\
    \ supported.\n   The string representation of the GSS-EAP mechanism name has the\n\
    \   following ABNF [RFC5234] representation:\n        char-normal = %x00-2E/%x30-3F/%x41-5B/%x5D-FF\n\
    \        char-escaped = \"\\\" %x2F / \"\\\" %x40 / \"\\\" %x5C\n        name-char\
    \ = char-normal / char-escaped\n        name-string = 1*name-char\n        user-or-service\
    \ = name-string\n        host = [name-string]\n        realm = name-string\n \
    \       service-specific = name-string\n        service-specifics = service-specific\
    \ 0*(\"/\" service-specifics)\n        name = user-or-service [\"/\" host [ \"\
    /\" service-specifics]] [ \"@\"\n                realm ]\n   Special characters\
    \ appearing in a name can be backslash escaped to\n   avoid their special meanings.\
    \  For example, \"\\\\\" represents a literal\n   backslash.  This escaping mechanism\
    \ is a property of the string\n   representation; if the components of a name\
    \ are transported in some\n   mechanism that will keep them separate without backslash\
    \ escaping,\n   then backslash SHOULD have no special meaning.\n   The user-or-service\
    \ component is similar to the portion of a network\n   access identifier (NAI)\
    \ before the '@' symbol for initiator names and\n   the service name from the\
    \ registry of GSS-API host-based services in\n   the case of acceptor names [GSS-IANA].\
    \  The NAI specification\n   provides rules for encoding and string preparation\
    \ in order to\n   support internationalization of NAIs; implementations of this\n\
    \   mechanism MUST NOT prepare the user-or-service according to these\n   rules;\
    \ see Section 3.2 for internationalization of this mechanism.\n   The host portion\
    \ is empty for initiators and typically contains the\n   domain name of the system\
    \ on which an acceptor service is running.\n   Some services MAY require additional\
    \ parameters to distinguish the\n   entity being authenticated against.  Such\
    \ parameters are encoded in\n   the service-specifics portion of the name.  The\
    \ EAP server MUST\n   reject authentication of any acceptor name that has a non-empty\n\
    \   service-specifics component unless the EAP server understands the\n   service-specifics\
    \ and authenticates them.  The interpretation of the\n   service-specifics is\
    \ scoped by the user-or-service portion.  The\n   realm is similar to the realm\
    \ portion of a NAI for initiator names;\n   again the NAI specification's internationalization\
    \ rules MUST NOT be\n   applied to the realm.  The realm is the administrative\
    \ realm of a\n   service for an acceptor name.\n   The string representation of\
    \ this name form is designed to be\n   generally compatible with the string representation\
    \ of Kerberos names\n   defined in [RFC1964].\n   The GSS_C_NT_USER_NAME form\
    \ represents the name of an individual\n   user.  From the standpoint of this\
    \ mechanism, it may take the form of\n   either an undecorated user name or a\
    \ name semantically similar to a\n   network access identifier (NAI) [RFC4282].\
    \  The name is split at the\n   first at-sign ('@') into the part preceding the\
    \ realm, which is the\n   user-or-service portion of the mechanism name, and the\
    \ realm portion,\n   which is the realm portion of the mechanism name.\n   The\
    \ GSS_C_NT_HOSTBASED_SERVICE name form represents a service running\n   on a host;\
    \ it is textually represented as \"service@host\".  This name\n   form is required\
    \ by most SASL profiles and is used by many existing\n   applications that use\
    \ the Kerberos GSS-API mechanism.  While support\n   for this name form is critical,\
    \ it presents an interesting challenge\n   in terms of EAP channel binding.  Consider\
    \ a case where the server\n   communicates with a \"server proxy,\" or a AAA server\
    \ near the server.\n   That server proxy communicates with the EAP server.  The\
    \ EAP server\n   and server proxy are in different administrative realms.  The\
    \ server\n   proxy is in a position to verify that the request comes from the\n\
    \   indicated host.  However, the EAP server cannot make this\n   determination\
    \ directly.  So, the EAP server needs to determine\n   whether to trust the server\
    \ proxy to verify the host portion of the\n   acceptor name.  This trust decision\
    \ depends both on the host name and\n   the realm of the server proxy.  In effect,\
    \ the EAP server decides\n   whether to trust that the realm of the server proxy\
    \ is the right\n   realm for the given hostname and then makes a trust decision\
    \ about\n   the server proxy itself.  The same problem appears in Kerberos:\n\
    \   there, clients decide what Kerberos realm to trust for a given\n   hostname.\
    \  The service portion of this name is imported into the\n   user-or-service portion\
    \ of the mechanism name; the host portion is\n   imported into the host portion\
    \ of the mechanism name.  The realm\n   portion is empty.  However, authentication\
    \ will typically fail unless\n   some AAA component indicates the realm to the\
    \ EAP server.  If the\n   application server knows its realm, then it should be\
    \ indicated in\n   the outgoing AAA request.  Otherwise, a proxy SHOULD add the\
    \ realm.\n   An alternate form of this name type MAY be used on acceptors; in\
    \ this\n   case, the name form is \"service\" with no host component.  This is\n\
    \   imported with the service as user-or-service and an empty host and\n   realm\
    \ portion.  This form is useful when a service is unsure which\n   name an initiator\
    \ knows it by.\n   If the null name type or the GSS_EAP_NT_EAP_NAME (OID\n   1.3.6.1.5.5.15.2.1)\
    \ (see Section 7.1 ) is imported, then the string\n   representation above should\
    \ be directly imported.  Mechanisms MAY\n   support the GSS_KRB5_NT_KRB5_PRINCIPAL_NAME\
    \ name form with the OID\n   {iso(1) member-body(2) United States(840) mit(113554)\
    \ infosys(1)\n   gssapi(2) krb5(2) krb5_name(1)}.  In many circumstances, Kerberos\n\
    \   GSS-API mechanism names will behave as expected when used with the\n   GSS-API\
    \ EAP mechanism, but there are some differences that may cause\n   some confusion.\
    \  If an implementation does support importing Kerberos\n   names it SHOULD fail\
    \ the import if the Kerberos name is not\n   syntactically a valid GSS-API EAP\
    \ mechanism name as defined in this\n   section.\n"
- title: 3.2.  Internationalization of Names
  contents:
  - "3.2.  Internationalization of Names\n   For the most part, GSS-EAP names are\
    \ transported in other protocols;\n   those protocols define the internationalization\
    \ semantics.  For\n   example, if a AAA server wishes to communicate the user-or-service\n\
    \   portion of the initiator name to an acceptor, it does so using\n   existing\
    \ mechanisms in the AAA protocol.  Existing\n   internationalization rules are\
    \ applied.  Similarly, within an\n   application, existing specifications such\
    \ as [RFC5178] define the\n   encoding of names that are imported and displayed\
    \ with the GSS-API.\n   This mechanism does introduce a few cases where name components\
    \ are\n   sent.  In these cases, the encoding of the string is UTF-8.  Senders\n\
    \   SHOULD NOT normalize or map strings before sending.  These strings\n   include\
    \ RADIUS attributes introduced in Section 3.4.\n   When comparing the host portion\
    \ of a GSS-EAP acceptor name supplied\n   in EAP channel binding by a peer to\
    \ that supplied by an acceptor, EAP\n   servers SHOULD prepare the host portion\
    \ according to [RFC5891] prior\n   to comparison.  Applications MAY prepare domain\
    \ names prior to\n   importing them into this mechanism.\n"
- title: 3.3.  Exported Mechanism Names
  contents:
  - "3.3.  Exported Mechanism Names\n   GSS-API provides the GSS_Export_name call.\
    \  This call can be used to\n   export the binary representation of a name.  This\
    \ name form can be\n   stored on access control lists for binary comparison.\n\
    \   The exported name token MUST use the format described in Section 3.2\n   of\
    \ RFC 2743.  The mechanism specific portion of this name token is\n   the string\
    \ format of the mechanism name described in Section 3.1.\n   RFC 2744 [RFC2744]\
    \ places the requirement that the result of\n   importing a name, canonicalizing\
    \ it to a Mechanism Name and then\n   exporting it needs to be the same as importing\
    \ that name, obtaining\n   credentials for that principal, initiating a context\
    \ with those\n   credentials and exporting the name on the acceptor.  In practice,\
    \ GSS\n   mechanisms often, but not always, meet this requirement.  For names\n\
    \   expected to be used as initiator names, this requirement is met.\n   However,\
    \ permitting empty host and realm components when importing\n   host-based services\
    \ may make it possible for an imported name to\n   differ from the exported name\
    \ actually used.  Other mechanisms such\n   as Kerberos have similar situations\
    \ where imported and exported names\n   may differ.\n"
- title: 3.4.  Acceptor Name RADIUS AVP
  contents:
  - "3.4.  Acceptor Name RADIUS AVP\n   See Section 7.4 for registrations of RADIUS\
    \ attribute types to carry\n   the acceptor service name.  All the attribute types\
    \ registered in\n   that section are strings.  See Section 3.1 for details of\
    \ the values\n   in a name.\n   If RADIUS is used as a AAA transport, the acceptor\
    \ MUST send the\n   acceptor name in these attribute types.  That is, the acceptor\n\
    \   decomposes its name and sends any non-empty portion as a RADIUS\n   attribute.\
    \  With the exception of the service-specifics portion of\n   the name, the backslash\
    \ escaping mechanism is not used in RADIUS\n   attributes; backslash has no special\
    \ meaning.  In the service-\n   specifics portion, a literal \"/\" separates components.\
    \  In this one\n   attribute, \"\\/\" indicates a slash character that does not\
    \ separate\n   components and \"\\\\\" indicates a literal backslash character.\n\
    \   The initiator MUST require that the EAP method in use support channel\n  \
    \ binding and MUST send the acceptor name as part of the channel\n   binding data.\
    \  The client MUST NOT indicate mutual authentication in\n   the result of GSS_Init_sec_context\
    \ unless all name elements that the\n   client supplied are in a successful channel\
    \ binding response.  For\n   example, if the client supplied a hostname in channel\
    \ binding data,\n   the hostname MUST be in a successful channel binding response.\n\
    \   If an empty target name is supplied to GSS_Init_sec_context, the\n   initiator\
    \ MUST fail context establishment unless the acceptor\n   supplies the acceptor\
    \ name response (Section 5.4.3).  If a null\n   target name is supplied, the initiator\
    \ MUST use this response to\n   populate EAP channel bindings.\n"
- title: 3.5.  Proxy Verification of Acceptor Name
  contents:
  - "3.5.  Proxy Verification of Acceptor Name\n   Proxies may play a role in verification\
    \ of the acceptor identity.\n   For example, a AAA proxy near the acceptor may\
    \ be in a position to\n   verify the acceptor hostname, while the EAP server is\
    \ likely to be\n   too distant to reliably verify this on its own.\n   The EAP\
    \ server or some proxy trusted by the EAP server is likely to\n   be in a position\
    \ to verify the acceptor realm.  In effect, this proxy\n   is confirming that\
    \ the right AAA credential is used for the claimed\n   realm and thus that the\
    \ acceptor is in the organization it claims to\n   be part of.  This proxy is\
    \ also typically trusted by the EAP server\n   to make sure that the hostname\
    \ claimed by the acceptor is a\n   reasonable hostname for the realm of the acceptor.\n\
    \   A proxy close to the EAP server is unlikely to be in a position to\n   confirm\
    \ that the acceptor is claiming the correct hostname.  Instead,\n   this is typically\
    \ delegated to a proxy near the acceptor.  That proxy\n   is typically expected\
    \ to verify the acceptor hostname and to verify\n   the appropriate AAA credential\
    \ for that host is used.  Such a proxy\n   may insert the acceptor realm if it\
    \ is absent, permitting realm\n   configuration to be at the proxy boundary rather\
    \ than on acceptors.\n   Ultimately, specific proxy behavior is a matter for deployment.\
    \  The\n   EAP server MUST assure that the appropriate validation has been done\n\
    \   before including acceptor name attributes in a successful channel\n   binding\
    \ response.  If the acceptor service is included, the EAP\n   server asserts that\
    \ the service is plausible for the acceptor.  If\n   the acceptor hostname is\
    \ included, the EAP server asserts that the\n   acceptor hostname is verified.\
    \  If the realm is included the EAP\n   server asserts that the realm has been\
    \ verified, and if the hostname\n   was also included, that the realm and hostname\
    \ are consistent.  Part\n   of this verification MAY be delegated to proxies,\
    \ but the EAP server\n   configuration MUST guarantee that the combination of\
    \ proxies meets\n   these requirements.  Typically, such delegation will involve\
    \ business\n   or operational measures such as cross-organizational agreements\
    \ as\n   well as technical measures.\n   It is likely that future technical work\
    \ will be needed to communicate\n   what verification has been done by proxies\
    \ along the path.  Such\n   technical measures will not release the EAP server\
    \ from its\n   responsibility to decide whether proxies on the path should be\n\
    \   trusted to perform checks delegated to them.  However, technical\n   measures\
    \ could prevent misconfigurations and help to support diverse\n   environments.\n"
- title: 4.  Selection of EAP Method
  contents:
  - "4.  Selection of EAP Method\n   EAP does not provide a facility for an EAP server\
    \ to advertise what\n   methods are available to a peer.  Instead, a server starts\
    \ with its\n   preferred method selection.  If the peer does not accept that method,\n\
    \   the peer sends a NAK response containing the list of methods\n   supported\
    \ by the client.\n   Providing multiple facilities to negotiate which security\
    \ mechanism\n   to use is undesirable.  Section 7.3 of [RFC4462]describes the\
    \ problem\n   referencing the Secure Shell (SSH) Protocol key exchange negotiation\n\
    \   and the SPNEGO GSS-API mechanism.  If a client preferred an EAP\n   method\
    \ A, a non-EAP authentication mechanism B, and then an EAP\n   method C, then\
    \ the client would have to commit to using EAP before\n   learning whether A is\
    \ actually supported.  Such a client might end up\n   using C when B is available.\n\
    \   The standard solution to this problem is to perform all the\n   negotiation\
    \ at one layer.  In this case, rather than defining a\n   single GSS-API mechanism,\
    \ a family of mechanisms should be defined.\n   Each mechanism corresponds to\
    \ an EAP method.  The EAP method type\n   should be part of the GSS-API OID. \
    \ Then, a GSS-API rather than EAP\n   facility can be used for negotiation.\n\
    \   Unfortunately, using a family of mechanisms has a number of problems.\n  \
    \ First, GSS-API assumes that both the initiator and acceptor know the\n   entire\
    \ set of mechanisms that are available.  Some negotiation\n   mechanisms are driven\
    \ by the client; others are driven by the server.\n   With EAP GSS-API, the acceptor\
    \ does not know what methods the EAP\n   server implements.  The EAP server that\
    \ is used depends on the\n   identity of the client.  The best solution so far\
    \ is to accept the\n   disadvantages of multi-layer negotiation and commit to\
    \ using EAP GSS-\n   API before a specific EAP method.  This has two main disadvantages.\n\
    \   First, authentication may fail when other methods might allow\n   authentication\
    \ to succeed.  Second, a non-optimal security mechanism\n   may be chosen.\n"
- title: 5.  Context Tokens
  contents:
  - "5.  Context Tokens\n   All context establishment tokens emitted by the EAP mechanism\
    \ SHALL\n   have the framing described in Section 3.1 of [RFC2743], as\n   illustrated\
    \ by the following pseudo-ASN.1 structures:\n   GSS-API DEFINITIONS ::=\n    \
    \        BEGIN\n            MechType ::= OBJECT IDENTIFIER\n            -- representing\
    \ EAP mechanism\n            GSSAPI-Token ::=\n            -- option indication\
    \ (delegation, etc.) indicated within\n            -- mechanism-specific token\n\
    \            [APPLICATION 0] IMPLICIT SEQUENCE {\n                    thisMech\
    \ MechType,\n                    innerToken ANY DEFINED BY thisMech\n        \
    \               -- contents mechanism-specific\n                       -- ASN.1\
    \ structure not required\n                    }\n            END\n   The innerToken\
    \ field starts with a 16-bit network byte order token\n   type identifier.  The\
    \ remainder of the innerToken field is a set of\n   type-length-value subtokens.\
    \  The following figure describes the\n   structure of the inner token:\n    \
    \          +----------------+---------------------------+\n              | Octet\
    \ Position | Description               |\n              +----------------+---------------------------+\n\
    \              | 0..1           | token ID                  |\n              |\
    \                |                           |\n              | 2..5         \
    \  | first subtoken type       |\n              |                |           \
    \                |\n              | 6..9           | length  of first subtoken\
    \ |\n              |                |                           |\n          \
    \    | 10..10+n-1     | first subtoken body       |\n              |         \
    \       |                           |\n              | 10+n..10+n+3   | second\
    \ subtoken type      |\n              +----------------+---------------------------+\n\
    \                         Structure of Inner Token\n   The inner token continues\
    \ with length, second subtoken body, and so\n   forth.  If a subtoken type is\
    \ present, its length and body MUST be\n   present.\n   The length is a four-octet\
    \ length of the subtoken body in network\n   byte order.  The length does not\
    \ include the length of the type field\n   or the length field; the length only\
    \ covers the body.\n   Tokens from the initiator to acceptor use an inner token\
    \ type with ID\n   06 01; tokens from acceptor to initiator use an inner token\
    \ type with\n   ID 06 02.  These token types are registered in the registry of\
    \ RFC\n   4121 token types; see Section 7.2.\n   See Section 5.7 for the encoding\
    \ of a complete token.  The following\n   sections discuss how mechanism OIDs\
    \ are chosen and the state machine\n   that defines what subtokens are permitted\
    \ at each point in the\n   context establishment process.\n"
- title: 5.1.  Mechanisms and Encryption Types
  contents:
  - "5.1.  Mechanisms and Encryption Types\n   This mechanism family uses the security\
    \ services of the Kerberos\n   cryptographic framework [RFC3961].  The root of\
    \ the OID ARC for\n   mechanisms described in this document is 1.3.6.1.5.5.15.1.1;\
    \ a\n   Kerberos encryption type number [RFC3961] is appended to that root\n \
    \  OID to form a mechanism OID.  As such, a particular encryption type\n   needs\
    \ to be chosen.  By convention, there is a single object\n   identifier arc for\
    \ the EAP family of GSS-API mechanisms.  A specific\n   mechanism is chosen by\
    \ adding the numeric Kerberos encryption type\n   number to the root of this arc.\
    \  However, in order to register the\n   SASL name, the specific usage with a\
    \ given encryption type needs to\n   be registered.  This document defines the\
    \ EAP-AES128 GSS-API\n   mechanism.\n"
- title: 5.2.  Processing Received Tokens
  contents:
  - "5.2.  Processing Received Tokens\n   Whenever a context token is received, the\
    \ receiver performs the\n   following checks.  First, the receiver confirms the\
    \ object identifier\n   is that of the mechanism being used.  The receiver confirms\
    \ that the\n   token type corresponds to the role of the peer: acceptors will\
    \ only\n   process initiator tokens and initiators will only process acceptor\n\
    \   tokens.\n   Implementations of this mechanism maintain a state machine for\
    \ the\n   context establishment process.  Both the initiator and acceptor start\n\
    \   out in the initial state; see Section 5.4 for a description of this\n   state.\
    \  Associated with each state are a set of subtoken types that\n   are processed\
    \ in that state and rules for processing these subtoken\n   types.  The receiver\
    \ examines the subtokens in order, processing any\n   that are appropriate for\
    \ the current state.  Unknown subtokens or\n   subtokens that are not expected\
    \ in the current state are ignored if\n   their critical bit (see below) is clear.\n\
    \   A state may have a set of required subtoken types.  If a subtoken\n   type\
    \ is required by the current state but no subtoken of that type is\n   present,\
    \ then the context establishment MUST fail.\n   The most significant bit (0x80000000)\
    \ in a subtoken type is the\n   critical bit.  If a subtoken with this bit set\
    \ in the type is\n   received, the receiver MUST fail context establishment unless\
    \ the\n   subtoken is understood and processed for the current state.\n   The\
    \ subtoken type MUST be unique within a given token.\n"
- title: 5.3.  Error Subtokens
  contents:
  - "5.3.  Error Subtokens\n   The acceptor may always end the exchange by generating\
    \ an error\n   subtoken.  The error subtoken has the following format:\n   +--------+----------------------------------------------------------+\n\
    \   | Pos    | Description                                              |\n  \
    \ +--------+----------------------------------------------------------+\n   |\
    \ 0..3   | 0x80 00 00 01                                            |\n   |  \
    \      |                                                          |\n   | 4..7\
    \   | length of error token                                    |\n   |       \
    \ |                                                          |\n   | 8..11  |\
    \ major status from RFC 2744 as 32-bit network byte order  |\n   |        |  \
    \                                                        |\n   | 12..15 | GSS-EAP\
    \ error code as 32-bit network byte order; see     |\n   |        | Section 7.6\
    \                                              |\n   +--------+----------------------------------------------------------+\n\
    \   Initiators MUST ignore octets beyond the GSS-EAP error code for\n   future\
    \ extensibility.  As indicated, the error token is always marked\n   critical.\n"
- title: 5.4.  Initial State
  contents:
  - "5.4.  Initial State\n   Both the acceptor and initiator start the context establishment\n\
    \   process in the initial state.\n   The initiator sends a token to the acceptor.\
    \  It MAY be empty; no\n   subtokens are required in this state.  Alternatively,\
    \ the initiator\n   MAY include a vendor ID subtoken or an acceptor name request\n\
    \   subtoken.\n   The acceptor responds to this message.  It MAY include an acceptor\n\
    \   name response subtoken.  It MUST include a first EAP request; this is\n  \
    \ an EAP request/identity message (see Section 5.5.1 for the format of\n   this\
    \ subtoken).\n   The initiator and acceptor then transition to authenticate state.\n"
- title: 5.4.1.  Vendor Subtoken
  contents:
  - "5.4.1.  Vendor Subtoken\n   The vendor ID subtoken has type 0x0000000B and the\
    \ following\n   structure:\n                 +-------------+------------------------+\n\
    \                 | Pos         | Description            |\n                 +-------------+------------------------+\n\
    \                 | 0..3        | 0x0000000B             |\n                 |\
    \             |                        |\n                 | 4..7        | length\
    \ of vendor token |\n                 |             |                        |\n\
    \                 | 8..8+length | Vendor ID string       |\n                 +-------------+------------------------+\n\
    \   The vendor ID string is an UTF-8 string describing the vendor of this\n  \
    \ implementation.  This string is unstructured and for debugging\n   purposes\
    \ only.\n"
- title: 5.4.2.  Acceptor Name Request
  contents:
  - "5.4.2.  Acceptor Name Request\n   The acceptor name request token is sent from\
    \ the initiator to the\n   acceptor indicating that the initiator wishes a particular\
    \ acceptor\n   name.  This is similar to Transport Layer Security (TLS) Server\
    \ Name\n   Indication [RFC6066] that permits a client to indicate which one of\
    \ a\n   number of virtual services to contact.  The structure is as follows:\n\
    \                  +------+------------------------------+\n                 \
    \ | Pos  | Description                  |\n                  +------+------------------------------+\n\
    \                  | 0..3 | 0x00000002                   |\n                 \
    \ |      |                              |\n                  | 4..7 | length of\
    \ subtoken           |\n                  |      |                           \
    \   |\n                  | 8..n | string form of acceptor name |\n           \
    \       +------+------------------------------+\n   It is likely that channel\
    \ binding and thus authentication will fail\n   if the acceptor does not choose\
    \ a name that is a superset of this\n   name.  That is, if a hostname is sent,\
    \ the acceptor needs to be\n   willing to accept this hostname.\n"
- title: 5.4.3.  Acceptor Name Response
  contents:
  - "5.4.3.  Acceptor Name Response\n   The acceptor name response subtoken indicates\
    \ what acceptor name is\n   used.  This is useful, for example, if the initiator\
    \ supplied no\n   target name to the context initialization.  This allows the\
    \ initiator\n   to learn the acceptor name.  EAP channel bindings will provide\n\
    \   confirmation that the acceptor is accurately naming itself.\n   This token\
    \ is sent from the acceptor to initiator.  In the Initial\n   state, this token\
    \ would typically be sent if the acceptor name\n   request is absent, because\
    \ if the initiator already sent an acceptor\n   name, then the initiator knows\
    \ what acceptor it wishes to contact.\n   This subtoken is also sent in Extensions\
    \ state Section 5.6, so the\n   initiator can protect against a man-in-the-middle\
    \ modifying the\n   acceptor name request subtoken.\n                  +------+------------------------------+\n\
    \                  | Pos  | Description                  |\n                 \
    \ +------+------------------------------+\n                  | 0..3 | 0x00000003\
    \                   |\n                  |      |                            \
    \  |\n                  | 4..7 | length of subtoken           |\n            \
    \      |      |                              |\n                  | 8..n | string\
    \ form of acceptor name |\n                  +------+------------------------------+\n"
- title: 5.5.  Authenticate State
  contents:
  - "5.5.  Authenticate State\n   In this state, the acceptor sends EAP requests to\
    \ the initiator and\n   the initiator generates EAP responses.  The goal of the\
    \ state is to\n   perform a successful EAP authentication.  Since the acceptor\
    \ sends an\n   identity request at the end of the initial state, the first half-\n\
    \   round-trip in this state is a response to that request from the\n   initiator.\n\
    \   The EAP conversation can end in a number of ways:\n   o  If the EAP state\
    \ machine generates an EAP Success message, then\n      the EAP authenticator\
    \ believes the authentication is successful.\n      The acceptor MUST confirm\
    \ that a key has been derived\n      (Section 7.10 of [RFC3748]).  The acceptor\
    \ MUST confirm that this\n      success indication is consistent with any protected\
    \ result\n      indication for combined authenticators and with AAA indication\
    \ of\n      success for pass-through authenticators.  If any of these checks\n\
    \      fail, the acceptor MUST send an error subtoken and fail the\n      context\
    \ establishment.  If these checks succeed, the acceptor\n      sends the Success\
    \ message using the EAP Request subtoken type and\n      transitions to Extensions\
    \ state.  If the initiator receives an EAP\n      Success message, it confirms\
    \ that a key has been derived and that\n      the EAP Success is consistent with\
    \ any protected result\n      indication.  If so, it transitions to Extensions\
    \ state.\n      Otherwise, it returns an error to the caller of\n      GSS_Init_sec_context\
    \ without producing an output token.\n   o  If the acceptor receives an EAP failure,\
    \ then the acceptor sends\n      this in the EAP Request subtoken type.  If the\
    \ initiator receives\n      an EAP Failure, it returns GSS failure.\n   o  If\
    \ there is some other error, the acceptor MAY return an error\n      subtoken.\n"
- title: 5.5.1.  EAP Request Subtoken
  contents:
  - "5.5.1.  EAP Request Subtoken\n   The EAP Request subtoken is sent from the acceptor\
    \ to the initiator.\n   This subtoken is always critical and is REQUIRED in the\n\
    \   authentication state.\n                  +-------------+-----------------------+\n\
    \                  | Pos         | Description           |\n                 \
    \ +-------------+-----------------------+\n                  | 0..3        | 0x80000005\
    \            |\n                  |             |                       |\n  \
    \                | 4..7        | length of EAP message |\n                  |\
    \             |                       |\n                  | 8..8+length | EAP\
    \ message           |\n                  +-------------+-----------------------+\n"
- title: 5.5.2.  EAP Response Subtoken
  contents:
  - "5.5.2.  EAP Response Subtoken\n   This subtoken is REQUIRED in authentication\
    \ state messages from the\n   initiator to the acceptor.  It is always critical.\n\
    \                  +-------------+-----------------------+\n                 \
    \ | Pos         | Description           |\n                  +-------------+-----------------------+\n\
    \                  | 0..3        | 0x80000004            |\n                 \
    \ |             |                       |\n                  | 4..7        | length\
    \ of EAP message |\n                  |             |                       |\n\
    \                  | 8..8+length | EAP message           |\n                 \
    \ +-------------+-----------------------+\n"
- title: 5.6.  Extensions State
  contents:
  - "5.6.  Extensions State\n   After EAP Success, the initiator sends a token to\
    \ the acceptor\n   including additional subtokens that negotiate optional features\
    \ or\n   provide GSS-API channel binding (see Section 6.1).  The acceptor then\n\
    \   responds with a token to the initiator.  When the acceptor produces\n   its\
    \ final token, it returns GSS_S_COMPLETE; when the initiator\n   consumes this\
    \ token, it returns GSS_S_COMPLETE if no errors are\n   detected.\n   The acceptor\
    \ SHOULD send an acceptor name response (Section 5.4.3) so\n   that the initiator\
    \ can get a copy of the acceptor name protected by\n   the Message Integrity Check\
    \ (MIC) subtoken.\n   Both the initiator and acceptor MUST include and verify\
    \ a MIC\n   subtoken to protect the extensions exchange.\n"
- title: 5.6.1.  Flags Subtoken
  contents:
  - "5.6.1.  Flags Subtoken\n   This subtoken is sent to convey initiator flags to\
    \ the acceptor.  The\n   flags are sent as a 32-bit integer in network byte order.\
    \  The only\n   flag defined so far is GSS_C_MUTUAL_FLAG, indicating that the\n\
    \   initiator successfully performed mutual authentication of the\n   acceptor.\
    \  This flag is communicated to the acceptor because some\n   protocols [RFC4462]\
    \ require the acceptor to know whether the\n   initiator has confirmed its identity.\
    \  This flag has the value 0x2 to\n   be consistent with RFC 2744.\n         \
    \            +-------+-----------------------+\n                     | Pos   |\
    \ Description           |\n                     +-------+-----------------------+\n\
    \                     | 0..3  | 0x0000000C            |\n                    \
    \ |       |                       |\n                     | 4..7  | length of\
    \ flags token |\n                     |       |                       |\n    \
    \                 | 8..11 | flags                 |\n                     +-------+-----------------------+\n\
    \   Initiators MUST send 4 octets of flags.  Acceptors MUST ignore flag\n   octets\
    \ beyond the first 4 and MUST ignore flag bits other than\n   GSS_C_MUTUAL_FLAG.\
    \  Initiators MUST send undefined flag bits as zero.\n"
- title: 5.6.2.  GSS Channel Bindings Subtoken
  contents:
  - "5.6.2.  GSS Channel Bindings Subtoken\n   This subtoken is always critical when\
    \ sent.  It is sent from the\n   initiator to the acceptor.  The contents of this\
    \ token are an RFC\n   3961 get_mic token of the application data from the GSS\
    \ channel\n   bindings structure passed into the context establishment call.\n\
    \      +-------------+-----------------------------------------------+\n     \
    \ | Pos         | Description                                   |\n      +-------------+-----------------------------------------------+\n\
    \      | 0..3        | 0x80000006                                    |\n     \
    \ |             |                                               |\n      | 4..7\
    \        | length of token                               |\n      |          \
    \   |                                               |\n      | 8..8+length | get_mic\
    \  of  channel binding application data |\n      +-------------+-----------------------------------------------+\n\
    \   Again, only the application data is sent in the channel binding.  Any\n  \
    \ initiator and acceptor addresses passed by an application into\n   context establishment\
    \ calls are ignored and not sent over the wire.\n   The checksum type of the get_mic\
    \ token SHOULD be the mandatory-to-\n   implement checksum type of the Context\
    \ Root Key (CRK).  The key to\n   use is the CRK and the key usage is 60 (KEY_USAGE_GSSEAP_CHBIND_MIC).\n\
    \   An acceptor MAY accept any MIC in the channel bindings subtoken if\n   the\
    \ channel bindings input to GSS_Accept_sec_context is not provided.\n   If the\
    \ channel binding input to GSS_Accept_sec_context is provided,\n   the acceptor\
    \ MUST return failure if the channel binding MIC in a\n   received channel binding\
    \ subtoken fails to verify.\n   The initiator MUST send this token if channel\
    \ bindings including\n   application data are passed into GSS_Init_sec_context\
    \ and MUST NOT\n   send this token otherwise.\n"
- title: 5.6.3.  MIC Subtoken
  contents:
  - "5.6.3.  MIC Subtoken\n   This subtoken MUST be the last subtoken in the tokens\
    \ sent in\n   Extensions state.  This subtoken is sent both by the initiator and\n\
    \   acceptor.\n    +-------------+--------------------------------------------------+\n\
    \    | Pos         | Description                                      |\n    +-------------+--------------------------------------------------+\n\
    \    | 0..3        | 0x8000000D for initiator 0x8000000E for acceptor |\n    |\
    \             |                                                  |\n    | 4..7\
    \        | length of RFC 3961 MIC token                     |\n    |         \
    \    |                                                  |\n    | 8..8+length |\
    \ RFC 3961 result of get_mic                       |\n    +-------------+--------------------------------------------------+\n\
    \   As with any call to get_mic, a token is produced as described in RFC\n   3961\
    \ using the CRK (Section 6) as the key and the mandatory checksum\n   type for\
    \ the encryption type of the CRK as the checksum type.  The\n   key usage is 61\
    \ (KEY_USAGE_GSSEAP_ACCTOKEN_MIC) for the subtoken from\n   the acceptor to the\
    \ initiator and 62 (KEY_USAGE_GSSEAP_INITTOKEN_MIC)\n   for the subtoken from\
    \ the initiator to the acceptor.  The input is as\n   follows:\n   1.  The DER-encoded\
    \ object identifier of the mechanism in use; this\n       value starts with 0x06\
    \ (the tag for object identifier).  When\n       encoded in an RFC 2743 context\
    \ token, the object identifier is\n       preceded by the tag and length for [Application\
    \ 0] SEQUENCE.\n       This tag and the length of the overall token is not included;\n\
    \       only the tag, length, and value of the object identifier itself.\n   2.\
    \  A 16-bit token type in network byte order of the RFC 4121 token\n       identifier\
    \ (0x0601 for initiator, 0x0602 for acceptor).\n   3.  For each subtoken, other\
    \ than the MIC subtoken itself, the order\n       the subtokens appear in the\
    \ token is as follows:\n   4.\n       1.  A four-octet subtoken type in network\
    \ byte order\n       2.  A four-byte length in network byte order\n       3. \
    \ Length octets of value from that subtoken\n"
- title: 5.7.  Example Token
  contents:
  - "5.7.  Example Token\n   +----+------+----+------+-----+-------------------------+\n\
    \   | 60 |  23  | 06 |  09  | 2b  | 06 01 05 05 0f 01 01 11 |\n   +----+------+----+------+-----+-------------------------+\n\
    \   |App0|Token |OID |OID   | 1 3 |  6  1  5  5 15  1  1 17 |\n   |Tag |length|Tag\
    \ |length|      Mechanism object ID      |\n   +----+------+----+------+-------------------------------+\n\
    \   +----------+-------------+-------------+\n   |  06 01   | 00 00 00 02 | 00\
    \ 00 00 0e |\n   +----------+-------------|-------------|\n   |Initiator | Acceptor\
    \    | Length      |\n   |context   | name        | (14 octets) |\n   |token ID\
    \  | request     |             |\n   +----------+-------------+-------------+\n\
    \   +-------------------------------------------+\n   | 68 6f 73 74 2f 6c 6f 63\
    \ 61 6c 68 6f 73 74 |\n   +-------------------------------------------+\n   |\
    \ String form of acceptor name              |\n   | \"host/localhost\"       \
    \                   |\n   +-------------------------------------------+\n    \
    \                      Example Initiator Token\n"
- title: 5.8.  Context Options
  contents:
  - "5.8.  Context Options\n   GSS-API provides a number of optional per-context services\
    \ requested\n   by flags on the call to GSS_Init_sec_context and indicated as\
    \ outputs\n   from both GSS_Init_sec_context and GSS_Accept_sec_context.  This\n\
    \   section describes how these services are handled.  Which services the\n  \
    \ client selects in the call to GSS_Init_sec_context controls what EAP\n   methods\
    \ MAY be used by the client.  Section 7.2 of RFC 3748 describes\n   a set of security\
    \ claims for EAP.  As described below, the selected\n   GSS options place requirements\
    \ on security claims that MUST be met.\n   This GSS mechanism MUST only be used\
    \ with EAP methods that provide\n   dictionary-attack resistance.  Typically,\
    \ dictionary-attack\n   resistance is obtained by using an EAP tunnel method to\
    \ tunnel an\n   inner method in TLS.\n   The EAP method MUST support key derivation.\
    \  Integrity,\n   confidentiality, sequencing, and replay detection MUST be indicated\n\
    \   in the output of GSS_Init_sec_context and GSS_Accept_sec_context\n   regardless\
    \ of which services are requested.\n   The PROT_READY service defined in Section\
    \ 1.2.7 of [RFC2743] is never\n   available with this mechanism.  Implementations\
    \ MUST NOT offer this\n   flag or permit per-message security services to be used\
    \ before\n   context establishment.\n   The EAP method MUST support mutual authentication\
    \ and channel\n   binding.  See Section 3.4 for details on what is required for\n\
    \   successful mutual authentication.  Regardless of whether mutual\n   authentication\
    \ is requested, the implementation MUST include channel\n   bindings in the EAP\
    \ authentication.  If mutual authentication is\n   requested and successful mutual\
    \ authentication takes place as defined\n   in Section 3.4, the initiator MUST\
    \ send a flags subtoken\n   Section 5.6.1 in Extensions state.\n"
- title: 6.  Acceptor Services
  contents:
  - "6.  Acceptor Services\n   The context establishment process may be passed through\
    \ to an EAP\n   server via a backend authentication protocol.  However, after\
    \ the EAP\n   authentication succeeds, security services are provided directly\
    \ by\n   the acceptor.\n   This mechanism uses an RFC 3961 cryptographic key called\
    \ the Context\n   Root Key (CRK).  The CRK is derived from the GMSK (GSS-API Master\n\
    \   Session Key).  The GMSK is the result of the random-to-key [RFC3961]\n   operation\
    \ of the encryption type of this mechanism consuming the\n   appropriate number\
    \ of bits from the EAP MSK.  For example, for\n   aes128-cts-hmac-sha1-96, the\
    \ random-to-key operation consumes 16\n   octets of key material; thus, the first\
    \ 16 bytes of the MSK are input\n   to random-to-key to form the GMSK.  If the\
    \ MSK is too short,\n   authentication MUST fail.\n   In the following, pseudorandom\
    \ is the RFC 3961 pseudorandom operation\n   for the encryption type of the GMSK\
    \ and random-to-key is the RFC 3961\n   random-to-key operation for the enctype\
    \ of the mechanism.  The\n   truncate function takes the initial l bits of its\
    \ input.  The goal in\n   constructing a CRK is to call the pseudorandom function\
    \ enough times\n   to produce the right number of bits of output and discard any\
    \ excess\n   bits of output.\n   The CRK is derived from the GMSK using the following\
    \ procedure:\n   Tn = pseudorandom(GMSK, n || \"rfc4121-gss-eap\")\n   CRK = random-to-key(truncate(L,\
    \ T0 || T1 || .. || Tn))\n   L = random-to-key input size\n   Where n is a 32-bit\
    \ integer in network byte order starting at 0 and\n   incremented to each call\
    \ to the pseudo_random operation.\n"
- title: 6.1.  GSS-API Channel Binding
  contents:
  - "6.1.  GSS-API Channel Binding\n   GSS-API channel binding [RFC5554] is a protected\
    \ facility for\n   exchanging a cryptographic name for an enclosing channel between\
    \ the\n   initiator and acceptor.  The initiator sends channel binding data and\n\
    \   the acceptor confirms that channel binding data has been checked.\n   The\
    \ acceptor SHOULD accept any channel binding provided by the\n   initiator if\
    \ null channel bindings are passed into\n   gss_accept_sec_context.  Protocols\
    \ such as HTTP Negotiate [RFC4559]\n   depend on this behavior of some Kerberos\
    \ implementations.\n   As discussed, the GSS channel bindings subtoken is sent\
    \ in the\n   Extensions state.\n"
- title: 6.2.  Per-Message Security
  contents:
  - "6.2.  Per-Message Security\n   The per-message tokens of Section 4 of RFC 4121\
    \ are used.  The CRK\n   SHALL be treated as the initiator sub-session key, the\
    \ acceptor sub-\n   session key and the ticket session key.\n"
- title: 6.3.  Pseudorandom Function
  contents:
  - "6.3.  Pseudorandom Function\n   The pseudorandom function defined in [RFC4402]\
    \ is used to provide\n   GSS_Pseudo_Random functionality to applications.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   This specification creates a number of IANA registries.\n"
- title: 7.1.  OID Registry
  contents:
  - "7.1.  OID Registry\n   IANA has created a registry of ABFAB object identifiers\
    \ titled\n   \"Object Identifiers for Application Bridging for Federated Access\"\
    .\n   The initial contents of the registry are specified below.  The\n   registration\
    \ policy is IETF Review or IESG Approval [RFC5226].  Early\n   allocation is permitted.\
    \  IANA has updated the reference for the root\n   of this OID delegation to point\
    \ to the newly created registry.\n   Decimal   Name        Description       \
    \                  References\n   -------   ----        ----------------------------------\
    \  ----------\n         0   Reserved    Reserved                            RFC\
    \ 7055\n         1   mechanisms  A sub-arc containing ABFAB          RFC 7055\n\
    \                         mechanisms\n         2   nametypes   A sub-arc containing\
    \ ABFAB          RFC 7055\n                         GSS-API Name Types\n   Prefix:\n\
    \   iso.org.dod.internet.security.mechanisms.abfab\n           (1.3.6.1.5.5.15)\n\
    \   NOTE: the following mechanisms registry is the root of the OID for\n   the\
    \ mechanism in question.  As discussed in Section 5.1, a Kerberos\n   encryption\
    \ type number [RFC3961] is appended to the mechanism version\n   OID below to\
    \ form the OID of a specific mechanism.\n   Prefix:\n   iso.org.dod.internet.security.mechanisms.abfab.mechanisms\n\
    \           (1.3.6.1.5.5.15.1)\n   Decimal   Name          Description       \
    \               References\n   -------   ----          -------------------------------\
    \  ----------\n         0   Reserved      Reserved                         RFC\
    \ 7055\n         1   gss-eap-v1    The GSS-EAP mechanism            RFC 7055\n\
    \   Prefix:\n   iso.org.dod.internet.security.mechanisms.abfab.nametypes\n   \
    \        (1.3.6.1.5.5.15.2)\n   Decimal   Name          Description          \
    \  References\n   -------   ----          ---------------------  ----------\n\
    \         0   Reserved      Reserved               RFC 7055\n         1   GSS_EAP_NT_EAP_NAME\
    \                  RFC 7055, Section 3.1\n"
- title: 7.2.  RFC 4121 Token Identifiers
  contents:
  - "7.2.  RFC 4121 Token Identifiers\n   In the top-level registry titled \"Kerberos\
    \ V GSS-API Mechanism\n   Parameters\", a subregistry called \"Kerberos GSS-API\
    \ Token Type\n   Identifiers\" was created; the references for this subregistry\
    \ are RFC\n   4121 and this document.  The allocation procedure is Expert Review\n\
    \   [RFC5226].  The Expert's primary job is to make sure that token type\n   identifiers\
    \ are requested by an appropriate requester for the RFC\n   4121 mechanism in\
    \ which they will be used and that multiple values\n   are not allocated for the\
    \ same purpose.  For RFC 4121 and this\n   mechanism, the Expert is currently\
    \ expected to make allocations for\n   token identifiers from documents in the\
    \ IETF stream; effectively, for\n   these mechanisms, the Expert currently confirms\
    \ the allocation meets\n   the requirements of the IETF Review process.\n   The\
    \ ID field is a hexadecimal token identifier specified in network\n   byte order.\n\
    \   The initial registrations are as follows:\n   +-------+-------------------------------+---------------------------+\n\
    \   | ID    | Description                   | Reference                 |\n  \
    \ +-------+-------------------------------+---------------------------+\n   |\
    \ 01 00 | KRB_AP_REQ                    | RFC 4121, Section 4.1     |\n   |  \
    \     |                               |                           |\n   | 02 00\
    \ | KRB_AP_REP                    | RFC 4121, Section 4.1     |\n   |       |\
    \                               |                           |\n   | 03 00 | KRB_ERROR\
    \                     | RFC 4121, Section 4.1     |\n   |       |            \
    \                   |                           |\n   | 04 04 | MIC tokens   \
    \                 | RFC 4121, Section 4.2.6.1 |\n   |       |                \
    \               |                           |\n   | 05 04 | wrap tokens      \
    \             | RFC 4121, Section 4.2.6.2 |\n   |       |                    \
    \           |                           |\n   | 06 01 | GSS-EAP initiator context\
    \     | RFC 7055, Section 5       |\n   |       | token                      \
    \   |                           |\n   |       |                              \
    \ |                           |\n   | 06 02 | GSS EAP acceptor context      |\
    \ RFC 7055, Section 5       |\n   |       | token                         |  \
    \                         |\n   +-------+-------------------------------+---------------------------+\n"
- title: 7.3.  GSS-EAP Subtoken Types
  contents:
  - "7.3.  GSS-EAP Subtoken Types\n   This document creates a top-level registry called\
    \ \"The Extensible\n   Authentication Protocol Mechanism for the Generic Security\
    \ Service\n   Application Programming Interface (GSS-EAP) Parameters\".  In any\n\
    \   short form of that name, including any URI for this registry, it is\n   important\
    \ that the string GSS come before the string EAP; this will\n   help to distinguish\
    \ registries if EAP methods for performing GSS-API\n   authentication are ever\
    \ defined.\n   In this registry is a subregistry of subtoken types.  Identifiers\
    \ are\n   32-bit integers; the upper bit (0x80000000) is reserved as a critical\n\
    \   flag and should not be indicated in the registration.  Assignments of\n  \
    \ GSS-EAP subtoken types are made by Expert Review [RFC5226].  The\n   Expert\
    \ is expected to require a public specification of the subtoken\n   similar in\
    \ detail to registrations given in this document.  The\n   security of GSS-EAP\
    \ depends on making sure that subtoken information\n   has adequate protection\
    \ and that the overall mechanism continues to\n   be secure.  Examining the security\
    \ and architectural consistency of\n   the proposed registration is the primary\
    \ responsibility of the\n   Expert.\n         +------------+--------------------------+---------------+\n\
    \         | Type       | Description              | Reference     |\n        \
    \ +------------+--------------------------+---------------+\n         | 0x00000001\
    \ | Error                    | Section 5.3   |\n         |            |      \
    \                    |               |\n         | 0x0000000B | Vendor       \
    \            | Section 5.4.1 |\n         |            |                      \
    \    |               |\n         | 0x00000002 | Acceptor name request    | Section\
    \ 5.4.2 |\n         |            |                          |               |\n\
    \         | 0x00000003 | Acceptor name response   | Section 5.4.3 |\n        \
    \ |            |                          |               |\n         | 0x00000005\
    \ | EAP request              | Section 5.5.1 |\n         |            |      \
    \                    |               |\n         | 0x00000004 | EAP response \
    \            | Section 5.5.2 |\n         |            |                      \
    \    |               |\n         | 0x0000000C | Flags                    | Section\
    \ 5.6.1 |\n         |            |                          |               |\n\
    \         | 0x00000006 | GSS-API channel bindings | Section 5.6.2 |\n        \
    \ |            |                          |               |\n         | 0x0000000D\
    \ | Initiator MIC            | Section 5.6.3 |\n         |            |      \
    \                    |               |\n         | 0x0000000E | Acceptor MIC \
    \            | Section 5.6.3 |\n         +------------+--------------------------+---------------+\n"
- title: 7.4.  RADIUS Attribute Assignments
  contents:
  - "7.4.  RADIUS Attribute Assignments\n   The following RADIUS attribute type values\
    \ [RFC3575] are assigned.\n   The allocation instructions in Section 10.3 of [RFC6929]\
    \ have been\n   followed.\n   +--------------------------------+-------+--------------------------+\n\
    \   | Description                    | Value | More Information         |\n  \
    \ +--------------------------------+-------+--------------------------+\n   |\
    \ GSS-Acceptor-Service-Name      | 164   | user-or-service portion  |\n   |  \
    \                              |       | of name                  |\n   |    \
    \                            |       |                          |\n   | GSS-Acceptor-Host-Name\
    \         | 165   | host portion of name     |\n   |                         \
    \       |       |                          |\n   | GSS-Acceptor-Service-Specifics\
    \ | 166   | service-specifics        |\n   |                                |\
    \       | portion of name          |\n   |                                |  \
    \     |                          |\n   | GSS-Acceptor-Realm-Name        | 167\
    \   | Realm portion of name    |\n   +--------------------------------+-------+--------------------------+\n"
- title: 7.5.  Registration of the EAP-AES128 SASL Mechanisms
  contents:
  - "7.5.  Registration of the EAP-AES128 SASL Mechanisms\n   Subject:  Registration\
    \ of SASL mechanisms EAP-AES128 and\n      EAP-AES128-PLUS\n   SASL mechanism\
    \ names:  EAP-AES128 and EAP-AES128-PLUS\n   Security considerations:  See RFC\
    \ 5801 and RFC 7055\n   Published specification (recommended):  RFC 7055\n   Person\
    \ & email address to contact for further information:\n      Abfab Working Group,\
    \ abfab@ietf.org\n   Intended usage:  common\n   Owner/Change controller:  iesg@ietf.org\n\
    \   Note:  This mechanism describes the GSS-EAP mechanism used with the\n    \
    \  aes128-cts-hmac-sha1-96 enctype.  The GSS-API OID for this\n      mechanism\
    \ is 1.3.6.1.5.5.15.1.1.17.\n      As described in RFC 5801, a PLUS variant of\
    \ this mechanism is also\n      required.\n"
- title: 7.6.  GSS-EAP Errors
  contents:
  - "7.6.  GSS-EAP Errors\n   A new subregistry is created in the GSS-EAP parameters\
    \ registry\n   titled \"GSS-EAP Error Codes\".  The error codes in this registry\
    \ are\n   unsigned 32-bit numbers.  Values less than or equal to 127 are\n   assigned\
    \ by Standards Action [RFC5226].  Values 128 through 255 are\n   assigned with\
    \ the Specification Required assignment policy [RFC5226].\n   Values greater than\
    \ 255 are reserved; updates to registration policy\n   may make these values available\
    \ for assignment and implementations\n   MUST be prepared to receive them.\n \
    \  This table provides the initial contents of the registry.\n        +-------+------------------------------------------------+\n\
    \        | Value | Description                                    |\n        +-------+------------------------------------------------+\n\
    \        | 0     | Reserved                                       |\n        |\
    \       |                                                |\n        | 1     |\
    \ Buffer is incorrect size                       |\n        |       |        \
    \                                        |\n        | 2     | Incorrect mechanism\
    \ OID                        |\n        |       |                            \
    \                    |\n        | 3     | Token is corrupted                 \
    \            |\n        |       |                                            \
    \    |\n        | 4     | Token is truncated                             |\n \
    \       |       |                                                |\n        |\
    \ 5     | Packet received by direction that sent it      |\n        |       |\
    \                                                |\n        | 6     | Incorrect\
    \ token type identifier                |\n        |       |                  \
    \                              |\n        | 7     | Unhandled critical subtoken\
    \ received           |\n        |       |                                    \
    \            |\n        | 8     | Missing required subtoken                  \
    \    |\n        |       |                                                |\n \
    \       | 9     | Duplicate subtoken type                        |\n        |\
    \       |                                                |\n        | 10    |\
    \ Received unexpected subtoken for current state |\n        |       |        \
    \                                        |\n        | 11    | EAP did not produce\
    \ a key                      |\n        |       |                            \
    \                    |\n        | 12    | EAP key too short                  \
    \            |\n        |       |                                            \
    \    |\n        | 13    | Authentication rejected                        |\n \
    \       |       |                                                |\n        |\
    \ 14    | AAA returned an unexpected message type        |\n        |       |\
    \                                                |\n        | 15    | AAA response\
    \ did not include EAP request       |\n        |       |                     \
    \                           |\n        | 16    | Generic AAA failure         \
    \                   |\n        +-------+------------------------------------------------+\n"
- title: 7.7.  GSS-EAP Context Flags
  contents:
  - "7.7.  GSS-EAP Context Flags\n   A new subregistry is created in the GSS-EAP parameters\
    \ registry.\n   This registry holds registrations of flag bits sent in the flags\n\
    \   subtoken (Section 5.6.1).  There are 32 flag bits available for\n   registration\
    \ represented as hexadecimal numbers from the most\n   significant bit 0x80000000\
    \ to the least significant bit 0x1.  The\n   registration policy for this registry\
    \ is IETF Review or, in\n   exceptional cases, IESG Approval.  The following table\
    \ indicates\n   initial registrations; all other values are available for assignment.\n\
    \               +------+-------------------+---------------+\n               |\
    \ Flag | Name              | Reference     |\n               +------+-------------------+---------------+\n\
    \               | 0x2  | GSS_C_MUTUAL_FLAG | Section 5.6.1 |\n               +------+-------------------+---------------+\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   RFC 3748 discusses security issues surrounding\
    \ EAP.  RFC 5247\n   discusses the security and requirements surrounding key management\n\
    \   that leverages the AAA infrastructure.  These documents are critical\n   to\
    \ the security analysis of this mechanism.\n   RFC 2743 discusses generic security\
    \ considerations for the GSS-API.\n   RFC 4121 discusses security issues surrounding\
    \ the specific per-\n   message services used in this mechanism.\n   As discussed\
    \ in Section 4, this mechanism may introduce multiple\n   layers of security negotiation\
    \ into application protocols.  Multiple\n   layer negotiations are vulnerable\
    \ to a bid-down attack when a\n   mechanism negotiated at the outer layer is preferred\
    \ to some but not\n   all mechanisms negotiated at the inner layer; see Section\
    \ 7.3 of\n   [RFC4462] for an example.  One possible approach to mitigate this\n\
    \   attack is to construct security policy such that the preference for\n   all\
    \ mechanisms negotiated in the inner layer falls between\n   preferences for two\
    \ outer-layer mechanisms or falls at one end of the\n   overall ranked preferences\
    \ including both the inner and outer layer.\n   Another approach is to only use\
    \ this mechanism when it has\n   specifically been selected for a given service.\
    \  The second approach\n   is likely to be common in practice because one common\
    \ deployment will\n   involve an EAP supplicant interacting with a user to select\
    \ a given\n   identity.  Only when an identity is successfully chosen by the user\n\
    \   will this mechanism be attempted.\n   EAP channel binding is used to give\
    \ the GSS-API initiator confidence\n   in the identity of the GSS-API acceptor.\
    \  Thus, the security of this\n   mechanism depends on the use and verification\
    \ of EAP channel binding.\n   Today, EAP channel binding is in very limited deployment.\
    \  If EAP\n   channel binding is not used, then the system may be vulnerable to\n\
    \   phishing attacks where a user is diverted from one service to\n   another.\
    \  If the EAP method in question supports mutual\n   authentication then users\
    \ can only be diverted between servers that\n   are part of the same AAA infrastructure.\
    \  For deployments where\n   membership in the AAA infrastructure is limited,\
    \ this may serve as a\n   significant limitation on the value of phishing as an\
    \ attack.  For\n   other deployments, use of EAP channel binding is critical to\
    \ avoid\n   phishing.  These attacks are possible with EAP today although not\n\
    \   typically with common GSS-API mechanisms.  For this reason,\n   implementations\
    \ are required to implement and use EAP channel\n   binding; see Section 3 for\
    \ details.\n   The security considerations of EAP channel binding [RFC6677] describe\n\
    \   the security properties of channel binding.  Two attacks are worth\n   calling\
    \ out here.  First, when a tunneled EAP method is used, it is\n   critical that\
    \ the channel binding be performed with an EAP server\n   trusted by the peer.\
    \  With existing EAP methods, this typically\n   requires validating the certificate\
    \ of the server tunnel endpoint\n   back to a trust anchor and confirming the\
    \ name of the entity who is a\n   subject of that certificate.  EAP methods may\
    \ suffer from bid-down\n   attacks where an attacker can cause a peer to think\
    \ that a particular\n   EAP server does not support channel binding.  This does\
    \ not directly\n   cause a problem because mutual authentication is only offered\
    \ at the\n   GSS-API level when channel binding to the server's identity is\n\
    \   successful.  However, when an EAP method is not vulnerable to these\n   bid-down\
    \ attacks, additional protection is available.  This mechanism\n   will benefit\
    \ significantly from new strong EAP methods such as\n   [TEAP].\n   Every proxy\
    \ in the AAA chain from the authenticator to the EAP server\n   needs to be trusted\
    \ to help verify channel bindings and to protect\n   the integrity of key material.\
    \  GSS-API applications may be built to\n   assume a trust model where the acceptor\
    \ is directly responsible for\n   authentication.  However, GSS-API is definitely\
    \ used with trusted-\n   third-party mechanisms such as Kerberos.\n   RADIUS does\
    \ provide a weak form of hop-by-hop confidentiality of key\n   material based\
    \ on using MD5 as a stream cipher.  Diameter can use TLS\n   or IPsec but has\
    \ no mandatory-to-implement confidentiality mechanism.\n   Operationally, protecting\
    \ key material as it is transported between\n   the Identity Provider (IdP) and\
    \ Relying Party (RP) is critical to\n   per-message security and verification\
    \ of GSS-API channel binding\n   [RFC5056].  Mechanisms such as RADIUS over TLS\
    \ [RFC6614] provide\n   significantly better protection of key material than the\
    \ base RADIUS\n   specification.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   Luke Howard, Jim Schaad, Alejandro Perez Mendez, Alexey\
    \ Melnikov, and\n   Sujing Zhou provided valuable reviews of this document.\n\
    \   Rhys Smith provided the text for the OID registry section.  Sam\n   Hartman's\
    \ work on this document has been funded by JANET.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [GSS-IANA] IANA, \"GSS-API Service Name Registry\"\
    ,\n              <http://www.iana.org/assignments/gssapi-service-names>.\n   [RFC2119]\
    \  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2743]  Linn, J., \"Generic Security\
    \ Service Application Program\n              Interface Version 2, Update 1\",\
    \ RFC 2743, January 2000.\n   [RFC2744]  Wray, J., \"Generic Security Service\
    \ API Version 2 :\n              C-bindings\", RFC 2744, January 2000.\n   [RFC3575]\
    \  Aboba, B., \"IANA Considerations for RADIUS (Remote\n              Authentication\
    \ Dial In User Service)\", RFC 3575, July\n              2003.\n   [RFC3748] \
    \ Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.\n              Levkowetz,\
    \ \"Extensible Authentication Protocol (EAP)\", RFC\n              3748, June\
    \ 2004.\n   [RFC3961]  Raeburn, K., \"Encryption and Checksum Specifications for\n\
    \              Kerberos 5\", RFC 3961, February 2005.\n   [RFC4121]  Zhu, L.,\
    \ Jaganathan, K., and S. Hartman, \"The Kerberos\n              Version 5 Generic\
    \ Security Service Application Program\n              Interface (GSS-API) Mechanism:\
    \ Version 2\", RFC 4121, July\n              2005.\n   [RFC4282]  Aboba, B., Beadles,\
    \ M., Arkko, J., and P. Eronen, \"The\n              Network Access Identifier\"\
    , RFC 4282, December 2005.\n   [RFC4401]  Williams, N., \"A Pseudo-Random Function\
    \ (PRF) API\n              Extension for the Generic Security Service Application\n\
    \              Program Interface (GSS-API)\", RFC 4401, February 2006.\n   [RFC4402]\
    \  Williams, N., \"A Pseudo-Random Function (PRF) for the\n              Kerberos\
    \ V Generic Security Service Application Program\n              Interface (GSS-API)\
    \ Mechanism\", RFC 4402, February 2006.\n   [RFC5056]  Williams, N., \"On the\
    \ Use of Channel Bindings to Secure\n              Channels\", RFC 5056, November\
    \ 2007.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n\
    \              May 2008.\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented\
    \ BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January\
    \ 2008.\n   [RFC5554]  Williams, N., \"Clarifications and Extensions to the\n\
    \              Generic Security Service Application Program Interface\n      \
    \        (GSS-API) for the Use of Channel Bindings\", RFC 5554, May\n        \
    \      2009.\n   [RFC5891]  Klensin, J., \"Internationalized Domain Names in\n\
    \              Applications (IDNA): Protocol\", RFC 5891, August 2010.\n   [RFC6677]\
    \  Hartman, S., Clancy, T., and K. Hoeper, \"Channel-Binding\n              Support\
    \ for Extensible Authentication Protocol (EAP)\n              Methods\", RFC 6677,\
    \ July 2012.\n   [RFC7057]  Winter, S. and J. Salowey, \"Update to the Extensible\n\
    \              Authentication Protocol (EAP) Applicability Statement for\n   \
    \           Application Bridging for Federated Access Beyond Web\n           \
    \   (ABFAB)\", RFC 7057, December 2013.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [ABFAB-ARCH]\n              Howlett, J., Hartman,\
    \ S., Tschofenig, H., Lear, E., and J.\n              Schaad, \"Application Bridging\
    \ for Federated Access Beyond\n              Web (ABFAB) Architecture\", Work\
    \ in Progress, July 2013.\n   [RFC1964]  Linn, J., \"The Kerberos Version 5 GSS-API\
    \ Mechanism\", RFC\n              1964, June 1996.\n   [RFC3579]  Aboba, B. and\
    \ P. Calhoun, \"RADIUS (Remote Authentication\n              Dial In User Service)\
    \ Support For Extensible\n              Authentication Protocol (EAP)\", RFC 3579,\
    \ September 2003.\n   [RFC4072]  Eronen, P., Hiller, T., and G. Zorn, \"Diameter\
    \ Extensible\n              Authentication Protocol (EAP) Application\", RFC 4072,\n\
    \              August 2005.\n   [RFC4178]  Zhu, L., Leach, P., Jaganathan, K.,\
    \ and W. Ingersoll, \"The\n              Simple and Protected Generic Security\
    \ Service Application\n              Program Interface (GSS-API) Negotiation Mechanism\"\
    , RFC\n              4178, October 2005.\n   [RFC4422]  Melnikov, A. and K. Zeilenga,\
    \ \"Simple Authentication and\n              Security Layer (SASL)\", RFC 4422,\
    \ June 2006.\n   [RFC4462]  Hutzelman, J., Salowey, J., Galbraith, J., and V.\
    \ Welch,\n              \"Generic Security Service Application Program Interface\n\
    \              (GSS-API) Authentication and Key Exchange for the Secure\n    \
    \          Shell (SSH) Protocol\", RFC 4462, May 2006.\n   [RFC4559]  Jaganathan,\
    \ K., Zhu, L., and J. Brezak, \"SPNEGO-based\n              Kerberos and NTLM\
    \ HTTP Authentication in Microsoft\n              Windows\", RFC 4559, June 2006.\n\
    \   [RFC5178]  Williams, N. and A. Melnikov, \"Generic Security Service\n    \
    \          Application Program Interface (GSS-API)\n              Internationalization\
    \ and Domain-Based Service Names and\n              Name Type\", RFC 5178, May\
    \ 2008.\n   [RFC5247]  Aboba, B., Simon, D., and P. Eronen, \"Extensible\n   \
    \           Authentication Protocol (EAP) Key Management Framework\",\n      \
    \        RFC 5247, August 2008.\n   [RFC6066]  Eastlake, D., \"Transport Layer\
    \ Security (TLS) Extensions:\n              Extension Definitions\", RFC 6066,\
    \ January 2011.\n   [RFC6614]  Winter, S., McCauley, M., Venaas, S., and K. Wierenga,\n\
    \              \"Transport Layer Security (TLS) Encryption for RADIUS\",\n   \
    \           RFC 6614, May 2012.\n   [RFC6929]  DeKok, A. and A. Lior, \"Remote\
    \ Authentication Dial In User\n              Service (RADIUS) Protocol Extensions\"\
    , RFC 6929, April\n              2013.\n   [TEAP]     Zhou, H., Cam-Winget, N.,\
    \ Salowey, J., and S. Hanna,\n              \"Tunnel EAP Method (TEAP) Version\
    \ 1\", Work in Progress,\n              September 2013.\n"
- title: Appendix A.  Pre-publication RADIUS VSA
  contents:
  - "Appendix A.  Pre-publication RADIUS VSA\n   As described in Section 3.4, RADIUS\
    \ attributes are used to carry the\n   acceptor name when this family of mechanisms\
    \ is used with RADIUS.\n   Prior to the publication of this specification, a vendor-specific\n\
    \   RADIUS attribute was used.  This non-normative appendix documents\n   that\
    \ attribute as it may be seen from older implementations.\n   Prior to IANA assignment,\
    \ GSS-EAP used a RADIUS vendor-specific\n   attribute for carrying the acceptor\
    \ name.  The Vendor-Specific\n   Attribute (VSA) with enterprise ID 25622 is formatted\
    \ as a VSA\n   according to the recommendation in the RADIUS specification.  The\n\
    \   following sub-attributes are defined:\n   +--------------------------------+-----------+----------------------+\n\
    \   | Name                           | Attribute | Description          |\n  \
    \ +--------------------------------+-----------+----------------------+\n   |\
    \ GSS-Acceptor-Service-Name      | 128       | user-or-service      |\n   |  \
    \                              |           | portion of name      |\n   |    \
    \                            |           |                      |\n   | GSS-Acceptor-Host-Name\
    \         | 129       | host portion of name |\n   |                         \
    \       |           |                      |\n   | GSS-Acceptor-Service-Specifics\
    \ | 130       | service-specifics    |\n   |                                |\
    \           | portion of name      |\n   |                                |  \
    \         |                      |\n   | GSS-Acceptor-Realm-Name        | 131\
    \       | Realm portion of     |\n   |                                |      \
    \     | name                 |\n   +--------------------------------+-----------+----------------------+\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Sam Hartman (editor)\n   Painless Security\n   EMail:\
    \ hartmans-ietf@mit.edu\n   Josh Howlett\n   JANET(UK)\n   EMail: josh.howlett@ja.net\n"
