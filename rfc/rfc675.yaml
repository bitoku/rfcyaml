- title: __initial_text__
  contents:
  - ''
- title: 'INWG: 72                                                   December 1974'
  contents:
  - "INWG: 72                                                   December 1974\n  \
    \       SPECIFICATION OF INTERNET TRANSMISSION CONTROL PROGRAM\n             \
    \            December 1974 Version\n"
- title: 1.  INTRODUCTION
  contents:
  - "1.  INTRODUCTION\n   This document describes the functions to be performed by\
    \ the\n   internetwork Transmission Control Program [TCP] and its interface to\n\
    \   programs or users that require its services. Several basic\n   assumptions\
    \ are made about process to process communication and these\n   are listed here\
    \ without further justification. The interested reader\n   is referred to [CEKA74,\
    \ TOML74, BELS74, DALA74, SUNS74] for further\n   discussion.\n   The authors\
    \ would like to acknowledge the contributions of R.\n   Tomlinson (three way handshake\
    \ and Initial Sequence Number\n   Selection), D. Belsnes, J. Burchfiel, M. Galland,\
    \ R. Kahn, D. Lloyd,\n   W. Plummer, and J. Postel all of whose good ideas and\
    \ counsel have\n   had a beneficial effect (we hope) on this protocol design.\
    \  In the\n   early phases of the design work, R. Metcalfe, A. McKenzie, H.\n\
    \   Zimmerman, G. LeLann, and M. Elie were most helpful in explicating\n   the\
    \ various issues to be resolved. Of course, we remain responsible\n   for the\
    \ remaining errors and misstatements which no doubt lurk in the\n   nooks and\
    \ crannies of the text.\n   Processes are viewed as the active elements of all\
    \ HOST computers in\n   a network. Even terminals and files or other I/O media\
    \ are viewed as\n   communicating through the use of processes. Thus, all network\n\
    \   communication is viewed as inter-process communication.\n   Since a process\
    \ may need to distinguish among several communication\n   streams between itself\
    \ and another process [or processes], we imagine\n   that each process may have\
    \ a number of PORTs through which it\n   communicates with the ports of other\
    \ processes.\n   Since port names are selected independently by each operating\
    \ system,\n   TCP, or user, they may not be unique. To provide for unique names\
    \ at\n   each TCP, we concatenate a NETWORK identifier, and a TCP identifier\n\
    \   with a port name to create a SOCKET name which will be unique\n   throughout\
    \ all networks connected together.\n   A pair of sockets form a CONNECTION which\
    \ can be used to carry data\n   in either direction [i.e. full duplex]. The connection\
    \ is uniquely\n   identified by the <local socket, foreign socket> address pair,\
    \ and\n   the same local socket can participate in multiple connections to\n \
    \  different foreign sockets [see Section 2.2].\n   Processes exchange finite\
    \ length LETTERS as a way of communicating;\n   thus, letter boundaries are significant.\
    \ However, the length of a\n   letter may be such that it must be broken into\
    \ FRAGMENTS before it\n   can be transmitted to its destination. We assume that\
    \ the fragments\n   will normally be reassembled into a letter before being passed\
    \ to the\n   receiving process. Throughout this document, it is legitimate to\n\
    \   assume that a fragment contains all or a part of a letter, but that a\n  \
    \ fragment never contains parts of more than one letter.\n   We specifically assume\
    \ that fragments are transmitted from Host to\n   Host through means of a PACKET\
    \ SWITCHING NETWORK [PSN] [ROWE70,\n   POUZ73]. This assumption is probably unnecessary,\
    \ since a circuit\n   switched network could also be used, but for concreteness,\
    \ we\n   explicitly assume that the hosts are connected to one or more PACKET\n\
    \   SWITCHES [PS] of a PSN [HEKA7O, POUZ74, SCWI71].\n   Processes make use of\
    \ the TCP by handing it letters. The TCP breaks\n   these into fragments, if necessary,\
    \ and then embeds each fragment in\n   an INTERNETWORK PACKET. Each internetwork\
    \ packet is in turn embedded\n   in a LOCAL PACKET suitable for transmission from\
    \ the host to one of\n   its serving PS. The packet switches may perform further\
    \ formatting or\n   other operations to achieve the delivery of the local packet\
    \ to the\n   destination Host.\n   The term LOCAL PACKET is used generically here\
    \ to mean the formatted\n   bit string exchanged between a host and a packet switch.\
    \ The format\n   of bit strings exchanged between the packet switches in a PSN\
    \ will\n   generally not be of concern to us. If an internetwork packet is\n \
    \  destined for a TCP in a foreign PSN, the packet is routed to a\n   GATEWAY\
    \ which connects the origin PSN with an intermediate or the\n   destination PSN.\
    \ Routing of internetwork packets to the GATEWAY may\n   be the responsibility\
    \ of the source TCP or the local PSN, depending\n   upon the PSN Implementation.\n\
    \   One model of TCP operation is to imagine that there is a basic\n   GATEWAY\
    \ associated with each TCP which provides an interface to the\n   local network.\
    \ This basic GATEWAY performs routing and packet\n   reformatting or embedding,\
    \ and may also implement congestion and\n   error control between the TCP and\
    \ GATEWAYS at or intermediate to the\n   destination TCP.\n   At a GATEWAY between\
    \ networks, the internetwork packet is unwrapped\n   from its local packet format\
    \ and examined to determine through which\n   network the internetwork packet\
    \ should travel next. The internetwork\n   packet is then wrapped in a local packet\
    \ format suitable to the next\n   network and passed on to a new packet switch.\n\
    \   A GATEWAY is permitted to break up the fragment carried by an\n   internetwork\
    \ packet into smaller fragments if this is necessary for\n   transmission through\
    \ the next network. To do this, the GATEWAY\n   produces a set of internetwork\
    \ packets, each carrying a new fragment.\n   The packet format is designed so\
    \ that the destination TCP may treat\n   fragments created by the source TCP or\
    \ by intermediate GATEWAYS\n   nearly identically.\n   The TCP is responsible\
    \ for regulating the flow of internetwork\n   packets to and from the processes\
    \ it serves, as a way of preventing\n   its host from becoming saturated or overloaded\
    \ with traffic. The TCP\n   is also responsible for retransmitting unacknowledged\
    \ packets, and\n   for detecting duplicates. A consequence of this error\n   detection/retransmission\
    \ scheme is that the order of letters received\n   on a given connection is also\
    \ maintained [CEKA74, SUNS74]. To perform\n   these functions, the TCP opens and\
    \ closes connections between ports\n   as described in Section 4.3. The TCP performs\
    \ retransmission,\n   duplicate detection, sequencing, and flow control on all\n\
    \   communication among the processes it serves.\n"
- title: 2.  The TCP INTERFACE to the USER
  contents:
  - '2.  The TCP INTERFACE to the USER

    '
- title: 2.1  The TCP as a POST OFFICE
  contents:
  - "2.1  The TCP as a POST OFFICE\n   The TCP acts in many ways like a postal service\
    \ since it provides a\n   way for processes to exchange letters with each other.\
    \ It sometimes\n   happens that a process may offer some service, but not know\
    \ in\n   advance what its correspondents' addresses are. The analogy can be\n\
    \   drawn with a mail order house which opens a post office box which can\n  \
    \ accept mail from any source. Unlike the post box, however, once a\n   letter\
    \ from a particular correspondent arrives, a port becomes\n   specific to the\
    \ correspondent until the owner of the port declares\n   otherwise.\n   In addition\
    \ to acting like a postal service, the TCP insures end-to-\n   end acknowledgment,\
    \ error correction, duplicate detection,\n   sequencing, and flow control.\n"
- title: 2.2  Sockets and Addressing
  contents:
  - "2.2  Sockets and Addressing\n   We have borrowed the term SOCKET from the ARPANET\
    \ terminology\n   [CACR70, MCKE73]. In general, a socket is the concatenation\
    \ of a\n   NETWORK identifier, TCP identifier, and PORT identifier. A CONNECTION\n\
    \   is fully specified by the pair of SOCKETS at each end since the same\n   local\
    \ socket may participate in many connections to different foreign\n   sockets.\n\
    \   Once the connections is specified in the OPEN command [see section\n   2.3.2],\
    \ the TCP supplies a [short] Local Connection Name by which the\n   user refers\
    \ to the connection in subsequent commands. In particular\n   this facilitates\
    \ using connections with initially unspecified foreign\n   sockets.\n   TCP's\
    \ are free to associate ports with processes however they choose.\n   However,\
    \ several basic concepts seem necessary in an implementation.\n   There must be\
    \ well known sockets [WKS] which the TCP associates only\n   with the \"appropriate\"\
    \ processes by some means. We envision that\n   processes may \"own\" sockets,\
    \ and that processes can only initiate\n   connections on the sockets they own\
    \ [means for implementing ownership\n   is a local issue, but we envision a Request\
    \ Port user call, or a\n   method of uniquely allocating a group of ports to a\
    \ given process,\n   e.g. by associating the high order bits of a port name with\
    \ a given\n   process.]\n   Once initiated, a connection may be passed to another\
    \ process that\n   does not own the local socket [e.g. from logger to service\
    \ process].\n   Strictly speaking this is a reconnection issue which might be\
    \ more\n   elegantly handled by a general reconnection protocol as discussed in\n\
    \   section 3.3. To simplify passing a connection within a single TCP,\n   such\
    \ \"invisible\" switches may be allowed as in TENEX systems.\n   Of course, each\
    \ connection is associated with exactly one process,\n   and any attempt to reference\
    \ that connection by another process will\n   be signaled as an error by the TCP.\
    \ This prevents stealing data from\n   or inserting data into another process'\
    \ data stream.\n   A connection is initiated by the rendezvous of an arriving\n\
    \   internetwork packet and a waiting Transmission Control Block [TCB]\n   created\
    \ by a user OPEN, SEND, INTERPUPT, or RECEIVE call [see section\n   2.3]. The\
    \ matching of local and foreign socket identifiers determines\n   when a successful\
    \ connection has been initiated. The connection\n   becomes established when sequence\
    \ numbers have been synchronized in\n   both directions as described in section\
    \ 4.3.2.\n   It is possible to specify a socket only partially by setting the\
    \ PORT\n   identifier to zero or setting both the TCP and PORT identifiers to\n\
    \   zero. A socket of all zero is called UNSPECIFIED. The purpose behind\n   unspecified\
    \ sockets is to provide a sort of \"general delivery\"\n   facility [useful for\
    \ logger type processes with well known sockets].\n   There are bounds on the\
    \ degree of unspecificity of socket\n   identifiers. TCB's must have fully specified\
    \ local sockets, although\n   the foreign socket may be fully or partly unspecified.\
    \ Arriving\n   packets must have fully specified sockets.\n   We employ the following\
    \ notation:\n    x.y.z = fully specified socket with x=net, y=TCP, z=port\n  \
    \  x.y.u = as above, but unspecified port\n    x.u.u = as above, but unspecified\
    \ TCP and port\n    u.u.u = completely unspecified\n    with respect to implementation,\
    \ u = 0 [zero]\n    We illustrate the principles of matching by giving all cases\
    \ of\n    incoming packets which match with existing TCB's. Generally, both\n\
    \    the local (foreign) socket of the TCB and the foreign (local) socket\n  \
    \  of the packet must match.\n          TCB local   TCB foreign     Packet local\
    \    Packet foreign\n    (a)     a.b.c       e.f.g           e.f.g           a.b.c\n\
    \    (b)     a.b.c       e.f.u           e.f.g           a.b.c\n    (c)     a.b.c\
    \       e.u.u           e.f.g           a.b.c\n    (d)     a.b.c       u.u.u \
    \          e.f.g           a.b.c\n    There are no other legal combinations of\
    \ socket identifiers which\n    match. Case (d) is typical of the ARPANET well\
    \ known socket idea in\n    which the well known socket (a.b.c) LISTENS for a\
    \ connection from\n    any (u.u.u) socket. Cases (b) and (c) can be used to restrict\n\
    \    matching to a particular TCP or net.\n"
- title: 2.3  TCP USER CALLS
  contents:
  - '2.3  TCP USER CALLS

    '
- title: 2.3.1  A Note on Style
  contents:
  - "2.3.1  A Note on Style\n    The following sections functionally define the USER/TCP\
    \ interface.\n    The notation used is similar to most procedure or function calls\
    \ in\n    high level languages, but this usage is not meant to rule out trap\n\
    \    type service calls [e.g. SVC's, UUO's, EMT's,...].\n    The user calls described\
    \ below specify the basic functions the TCP\n    will perform to support interprocess\
    \ communication. Individual\n    implementations should define their own exact\
    \ format, and may\n    provide combinations or subsets of the basic functions\
    \ in single\n    calls. In particular, some implementations may wish to automatically\n\
    \    OPEN a connection on the first SEND, RECEIVE, or INTERRUPT issued by\n  \
    \  the user for a given connection.\n    In providing interprocess communication\
    \ facilities, the TCP must not\n    only accept commands, but also return information\
    \ to the processes\n    it serves. This communication consists of:\n    (a) general\
    \ information about a connection [interrupts, remote\n        close, binding of\
    \ unspecified foreign socket].\n    (b) replies to specific user commands indicating\
    \ success or various\n        types of failure.\n   Although the means for signaling\
    \ user processes and the exact format\n   of replies will vary from one implementation\
    \ to another, it would\n   promote common understanding and testing if a common\
    \ set of codes\n   were adopted. Such a set of Event Codes is described in section\
    \ 2.4.\n   With respect to error messages, references to \"local\" and \"foreign\"\
    \n   are ambiguous unless it is known whether these refer to the world as\n  \
    \ seen by the sender or receiver of the error message. The authors\n   attempted\
    \ several different approaches and finally settled on the\n   convention that\
    \ these references would be as seen by the receiver of\n   the message.\n"
- title: 2.3.2  OPEN CONNECTION
  contents:
  - "2.3.2  OPEN CONNECTION\n   Format: OPEN(local port, foreign socket [, timeout])\n\
    \   We assume that the local TCP is aware of the identity of the\n   processes\
    \ it serves and will check the authority of the process to\n   use the connection\
    \ specified. Depending upon the implementation of\n   the TCP, the source network\
    \ and TCP identifiers will either be\n   supplied by the TCP or by the processes\
    \ that serve it [e.g. the\n   program which interfaces the TCP to its packet switch\
    \ or the packet\n   switch itself]. These considerations are the result of concern\
    \ about\n   security, to the extent that no TCP be able to masquerade as another\n\
    \   one, and so on. Similarly, no process can masquerade as another\n   without\
    \ the collusion of the TCP.\n   If no foreign socket is specified [i.e. the foreign\
    \ socket parameter\n   is 0 or not present], then this constitutes a LISTENING\
    \ local socket\n   which can accept communication from any foreign socket. Provision\
    \ is\n   also made for partial specification of foreign sockets as described\n\
    \   in section 2.2.\n   If the specified connection is already OPEN, an error\
    \ is returned,\n   otherwise a full-duplex transmission control block [TCB] is\
    \ created\n   and partially filled in with data from the OPEN command parameters.\n\
    \   The TCB format is described in more detail in section 4.2.2.\n   No network\
    \ traffic is generated by the OPEN command. The first SEND\n   or INTERRUPT by\
    \ the local user or the foreign user will cause the TCP\n   to synchronize the\
    \ connection.\n   The timeout, if present, permits the caller to set up a timeout\
    \ for\n   all letters transmitted on the connection. If a letter is not\n   successfully\
    \ transmitted within the timeout period, the user is\n   notified and may ignore\
    \ the condition [TCP will continue trying to\n   transmit] or direct the TCP to\
    \ close the connection. The present\n   global default is 30 seconds, and connections\
    \ which are set up\n   without specifying another timeout will retransmit every\
    \ letter for\n   at least 30 seconds before notifying the user. The retransmission\n\
    \   rate may vary, and is the responsibility of the TCP and not the user.\n  \
    \ Most likely, it will be related to the measured time for responses to\n   return\
    \ from letters sent.\n   Depending on the TCP implementation, either a local connection\
    \ name\n   will be returned to the user by the TCP, or the user will specify\n\
    \   this local connection name (in which case another parameter is needed\n  \
    \ in the call). The local connection name can then be used as a short\n   hand\
    \ term for the connection defined by the <local socket, foreign\n   socket> pair.\n\
    \   Responses from the TCP which may occur as a result of this call are\n   detailed\
    \ in section 2.4.\n"
- title: 2.3.3 SEND LETTER
  contents:
  - "2.3.3 SEND LETTER\n   Format: SEND(local connection name, buffer address, byte\
    \ count, EOL\n   flag [, timeout])\n   This call causes the data contained in\
    \ the indicated user buffer to\n   be sent on the indicated connection. If the\
    \ connection has not been\n   opened, the SEND is considered an error. Some implementations\
    \ may\n   allow users to SEND first, in which case an automatic OPEN would be\n\
    \   done. If the calling process is not authorized to use this\n   connection,\
    \ an error is returned.\n   If the EOL flag is set, the data is the End Of a Letter,\
    \ and the EOL\n   bit will be set in the last packet created from the buffer.\
    \ If the\n   EOL f1ag is not set, subsequent SEND's will appear as part of the\n\
    \   same letter. This extended letter facility should be used sparingly\n   because\
    \ some TCP's may delay processing packets until an entire\n   letter is received.\n\
    \   If no foreign socket was specified in the OPEN, but the connection is\n  \
    \ established [e.g. because a listening connection has become specific\n   due\
    \ to a foreign letter arriving for the local port] then the\n   designated letter\
    \ is sent to the implied foreign socket. In general,\n   users who make use of\
    \ OPEN with an unspecified foreign socket can\n   make use of SEND without ever\
    \ explicitly knowing the foreign socket\n   address.\n   However, if a SEND is\
    \ attempted before the foreign socket becomes\n   specified, an error will be\
    \ returned. Users can use the STATUS call\n   to determine the status of the connection.\
    \ In some implementations\n   the TCP may notify the user when an unspecified\
    \ socket is bound.\n   If the timeout is specified, then the current default timeout\
    \ for\n   this connection is changed to the new one. This can affect not only\n\
    \   all letters sent including and after this one, but also those which\n   have\
    \ not yet been sent, since the timeout is kept in the TCB and not\n   associated\
    \ with each letter sent. Of course, a time is maintained for\n   each internetwork\
    \ packet formed so as to determine how long each of\n   these has been on the\
    \ retransmission queue.\n   In the simplest implementation, SEND would not return\
    \ control to the\n   sending process until either the transmission was complete\
    \ or the\n   timeout had been exceeded. This simple method is highly subject to\n\
    \   deadlocks and is not recommended. [For example both sides of the\n   connection\
    \ try to do SEND's before doing any RECEIVE's.] A more\n   sophisticated implementation\
    \ would return immediately to allow the\n   process to run concurrently with network\
    \ I/O, and, furthermore, to\n   allow multiple SENDs to be in progress concurrently.\
    \ Multiple SENDs\n   are served in first come, first served order, so the TCP\
    \ will queue\n   those it cannot service immediately.\n   NOTA BENE: In order\
    \ for the process to distinguish among error or\n   success indications for different\
    \ letters, the buffer address should\n   be returned along with the coded response\
    \ to the SEND request. We\n   will offer an example event code format in section\
    \ 2.4, showing the\n   information which should be returned to the calling process.\n\
    \   The semantics of the INTERRUPT call are described later, but this\n   call\
    \ can have an effect on letters which have been given to the TCP\n   but not yet\
    \ sent. In particular, all such letters are flushed by the\n   source TCP. Thus\
    \ one of the responses to a SEND may be \"flushed due\n   to interrupt.\"\n  \
    \ Responses from the TCP which may occur as a result of this call are\n   detailed\
    \ in section 2.4.\n"
- title: 2.3.4  RECEIVE LETTER
  contents:
  - "2.3.4  RECEIVE LETTER\n   Format: RECEIVE(local connection name, buffer address,\
    \ byte count)\n   This command allocates a receiving buffer associated with the\n\
    \   specified connection. If no OPEN precedes this command or the calling\n  \
    \ process is not authorized to use this connection, an error is\n   returned.\n\
    \   In the simplest implementation, control would not return to the\n   calling\
    \ program until either a letter was received, or some error\n   occurred, but\
    \ this scheme is highly subject to deadlocks [see section\n   2.3.3]. A more sophisticated\
    \ implementation would permit several\n   RECEIVE's to be outstanding at once,\
    \ These would be filled as letters\n   arrive. This strategy permits increased\
    \ throughput, at the cost of a\n   more elaborate scheme [possibly asynchronous]\
    \ to notify the calling\n   program that a letter has been received.\n   If insufficient\
    \ buffer space is given to reassemble a complete\n   letter, an indication that\
    \ the buffer holds a partial letter will be\n   given; the buffer will be filled\
    \ with as much data as it can hold.\n   The remaining parts of a partly delivered\
    \ letter will be placed in\n   buffers as they are made available via successive\
    \ RECEIVES. If a\n   number of RECEIVES are outstanding, they may be filled with\
    \ parts of\n   a single long letter or with at most one letter each. The event\
    \ codes\n   associated with each RECEIVE will indicate what is contained in the\n\
    \   buffer.\n   To distinguish among several outstanding RECEIVES, and to take\
    \ care\n   of the case that a letter is smaller than the buffer supplied, the\n\
    \   event code is accompanied by both a buffer pointer and a byte count\n   indicating\
    \ the actual length of the letter received.\n   The semantics of the INTERRUPT\
    \ system call are discussed later, but\n   this call can have an effect on outstanding\
    \ RECEIVES. When the TCP\n   receives an INTERRUPT, it will flush all data currently\
    \ queued up\n   awaiting receipt by the receiving process. If no data is waiting,\
    \ but\n   several buffers have been made available by anticipatory RECEIVE\n \
    \  commands, these buffers are returned to the process with an error\n   indicating\
    \ that any data that might have been placed in those buffers\n   has been flushed.\
    \ This enables the receiving process to synchronize\n   its RECEIVES with the\
    \ interrupt. That is, the process can distinguish\n   between RECEIVES issued\
    \ before the receipt of the INTERRUPT and these\n   issued afterwards.\n   Responses\
    \ from the TCP which may occur as a result of this call are\n   detailed in section\
    \ 2.4.\n"
- title: 2.3.5  CLOSE CONNECTION
  contents:
  - "2.3.5  CLOSE CONNECTION\n   Format: CLOSE(local connection name)\n   This command\
    \ causes the connection specified to be closed. If the\n   connection is not open\
    \ or the calling process is not authorized to\n   use this connection, an error\
    \ is returned. Any unfilled receive\n   buffers or pending send buffers will be\
    \ returned to the user with\n   event codes indicating they were aborted due to\
    \ the CLOSE. Users\n   should wait for event codes for each SEND before closing\
    \ the\n   connection if they wish to be certain that all letters were\n   successfully\
    \ delivered.\n   The user may CLOSE the connection at any time on his own initiative,\n\
    \   or in response to various prompts from the TCP [remote close\n   executed,\
    \ transmission timeout exceeded, destination inaccessible].\n   Because closing\
    \ a connection requires communication with the foreign\n   TCP, connections may\
    \ remain in the closing state for a short time.\n   Attempts to reopen the connection\
    \ before the TCP replies to the CLOSE\n   command will result in errors.\n   Responses\
    \ from the TCP which may occur as a result of this call are\n   detailed in section\
    \ 2.4.\n"
- title: 2.3.6  INTERRUPT
  contents:
  - "2.3.6  INTERRUPT\n   Format: INTERRUPT(local connection name)\n   A special control\
    \ signal is sent to the destination indicating an\n   interrupt condition. This\
    \ facility can be used to simulate \"break\"\n   signals from terminals or error\
    \ or completion codes from I/O devices,\n   for example. The semantics of this\
    \ signal to the receiving process\n   are unspecified. The receiving TCP will\
    \ signal the interrupt to the\n   receiving process immediately upon receipt,\
    \ and will also flush any\n   outstanding letters waiting to be delivered. Since\
    \ it is possib1e to\n   tell where in the letter stream this command was invoked,\
    \ it is\n   possible for the receiving TCP to flush only preceding data. The\n\
    \   sending TCP will flush any letters pending transmission, returning a\n   special\
    \ error code to indicate the flush.\n   If the connection is not open or the calling\
    \ process is not\n   authorized to use this connection, an error is returned.\n\
    \   Responses from the TCP which may occur as a result of this call are\n   detailed\
    \ in section 2.4.\n"
- title: 2.3.7  STATUS
  contents:
  - "2.3.7  STATUS\n   Format: STATUS(local connection name)\n   This command returns\
    \ a data block containing the following\n   information:\n    local socket, foreign\
    \ socket, local connection name, receive window,\n    send window, connection\
    \ state, number of letters awaiting\n    acknowledgment, number of letters pending\
    \ receipt [including partial\n    ones], default transmission timeout\n    Depending\
    \ on the state of the connection, some of this information\n    may not be available\
    \ or meaningful. If the calling process is not\n    authorized to use this connection,\
    \ an error is returned. This\n    prevents unauthorized processes from gaining\
    \ information about a\n    connection.\n    Responses from the TCP which may occur\
    \ as a result of this call are\n    detailed in section 2.4.\n"
- title: 2.4  TCP TO USER MESSAGES
  contents:
  - '2.4  TCP TO USER MESSAGES

    '
- title: 2.4.1  TYPE CODES
  contents:
  - "2.4.1  TYPE CODES\n    All messages include a type code which identifies the\
    \ type of user\n    call to which the message applies. Types are:\n    0 - General\
    \ message, does not apply to a particular user call\n    1 - Applies to OPEN\n\
    \    2 - Applies to CLOSE\n    3 - Applies to INTERRUPT\n    10 - Applies to SEND\n\
    \    20 - Applies to RECEIVE\n    30 - Applies to STATUS\n"
- title: 2.4.2  MESSAGE FORMAT [notional]
  contents:
  - "2.4.2  MESSAGE FORMAT [notional]\n    All messages include the following three\
    \ fields:\n      Type code\n      Local connection name\n      Event code\n  \
    \ For message types 0-3 [General, Open, Close, Interrupt] only these\n   three\
    \ fields are necessary.\n   For message type 10 [Send] one additional field is\
    \ necessary:\n      Buffer address\n   For message type 20 [Receive] three additional\
    \ fields are necessary:\n      Buffer address\n      Byte count\n      End-of-letter\
    \ flag\n   For message type 30 [status] additional data might include;\n     \
    \ Local socket, foreign socket\n      Send window [measures buffer space at foreign\
    \ TCP]\n      Receive window [measures buffer space at local TCP]\n      Connection\
    \ state [see section 4.3.6]\n      Number of letters awaiting acknowledgment\n\
    \      Number of letters awaiting receipt\n      Retransmission timeout\n"
- title: 2.4.3 EVENT CODES
  contents:
  - "2.4.3 EVENT CODES\n   The event code specifies the particular event that the\
    \ TCP wishes to\n   communicate to the user.\n   In addition to the event code,\
    \ three flags may be useful to classify\n   the event into major categories and\
    \ facilitate event processing by\n   the user:\n      E flag: set if event is\
    \ an error\n      L/F flag: indicates whether event was generated by Local TCP,\
    \ or\n      Foreign TCP or network\n      P/T flag: indicates whether the event\
    \ is Permanent or Temporary\n      [retry may succeed]\n   Events are encoded\
    \ into 8 bits with the high order bits set to\n   indicate the state of the E,\
    \ L/F, and P/T flags, respectively.\n   Events specified so far are listed below\
    \ with their codes and flag\n   settings. A * means a flag does not apply or can\
    \ take both values for\n   this event. Additional events may be defined in the\
    \ course of\n   experimentation.\n      0  0**  general success\n      1  ELP\
    \  connection illegal for this process\n      2  OF*  unspecified foreign socket\
    \ has become bound\n      3  ELP  connection not open\n      4  ELT  no room for\
    \ TCB\n      5  ELT  foreign socket unspecified\n      6  ELP  connection already\
    \ open\n         EFP  unacceptable SYN [or SYN/ACK] arrived at foreign\n     \
    \ TCP. Note: This is not a misprint, the local meaning is different\n      from\
    \ foreign.\n      7  EFP  connection does not exist at foreign TCP\n      8  EFT\
    \  foreign TCP inaccessible [may have subcases]\n      9  ELT  retransmission\
    \ timeout\n      10 E*P  buffer flushed due to interrupt\n      11 OF*  interrupt\
    \ to user\n      12 **P  connection closing\n      13 E**  general error\n   \
    \   14 E*P  connection reset\n   Possible events for each message type are as\
    \ follows:\n      Type 0[general]: 2,11,12,14\n      Type 1[open]: 0,1,4,6,13\n\
    \      Type 2[close]: 0,1,3,13\n      Type 3[interrupt]: 0,1,3,5,7,8,9,12,13\n\
    \      Type 10[send]: 0,1,3,5,7,8,9,10,11,12,13\n      Type 20[receive]: 0,1,3,10,12,13\n\
    \      Type 30[status]: 0,1,13\n   Note that events 6(foreign), 7, 8 are generated\
    \ at the foreign TCP or\n   in the network[s], and these same codes are used in\
    \ the error field\n   of the internet packet [see section 4.2.1].\n"
- title: 3.  HIGHER LEVEL PROTOCOLS
  contents:
  - '3.  HIGHER LEVEL PROTOCOLS

    '
- title: 3.1  INTRODUCTION
  contents:
  - "3.1  INTRODUCTION\n   It is envisioned that the TCP will be able to support higher\
    \ level\n   protocols efficiently. It should be easy to interface existing\n \
    \  ARPANET protocols like TELNET and FTP to the TCP.\n"
- title: 3.2  WELL KNOWN SOCKETS
  contents:
  - "3.2  WELL KNOWN SOCKETS\n   At some point, a set of well known 24 bit port numbers\
    \ must be\n   picked. The type of service associated with the well known ports\n\
    \   might include:\n      (a)  Logger\n      (b)  FTP (File transfer protocol)\n\
    \      (c)  RJE (Remote job entry)\n      (d)  Host status\n      (e)  TTY Test\n\
    \      (f)  HELP - descriptive, interactive system documentation\n   WE RESERVE\
    \ WELL KNOWN SOCKET 0 (24 bits of 0) for global messages\n   destined for a particular\
    \ TCP but not related to any particular\n   connection. We imagine that this socket\
    \ would be used for unusual TCP\n   synchronization (e.g. RESET ALL) or for testing\
    \ purposes (e.g.\n   sending letters to TRASHCAN or ECHO). This does not conflict\
    \ with the\n   usage that if a socket is 0, it is unspecified, since no user can\n\
    \   SEND, CLOSE, or INTERRUPT on socket 0.\n"
- title: 3.3  RECONNECTION PROTOCOL (RCP)
  contents:
  - "3.3  RECONNECTION PROTOCOL (RCP)\n   Port identifiers fall into two categories:\
    \ permanent and transient.\n   For example, a Logger process is generally assigned\
    \ a port identifier\n   that is fixed and well known. Transient processes will\
    \ in general\n   have ID's which are dynamically assigned.\n   In the distributed\
    \ processing environment of the network, two\n   processes that don't have well\
    \ known port identifiers may often wish\n   to communicate. This can be achieved\
    \ with the help of a well known\n   process using a reconnection protocol. Such\
    \ a protocol is briefly\n   outlined using the communication facilities provided\
    \ by the TCP. It\n   essentially provides a mechanism by which port identifiers\
    \ are\n   exchanged in order to establish a connection between a pair of\n   sockets.\n\
    \   Such a protoco1 can be used to achieve the dynamic establishment of\n   new\
    \ connections in order to have multiple processes solving a problem\n   cooperatively,\
    \ or to provide a user process access to a server\n   process via a logger, when\
    \ the logger's end of the connection can not\n   be invisibly passed to the server\
    \ process.\n   A paper on this subject by R. Schantz [SCHA74] discusses some of\
    \ the\n   issues associated with reconnection, and some of the ideas contained\n\
    \   therein went into the design of the protocol outlined below.\n   In the ARPANET,\
    \ a protocol was implemented which would allow a\n   process to connect to a well\
    \ known socket, thus making an implicit\n   request for service, and then be switched\
    \ to another socket so that\n   the well known socket could be freed for use by\
    \ others. Since sockets\n   in our TCP are permitted to have connections with\
    \ more than one\n   foreign socket, this facility may not be explicitly needed\
    \ (i.e.\n   connections <A,B> and <A,C> are distinguishable).\n   However. the\
    \ well known socket may be in one network and the actual\n   service socket(s)\
    \ may be in another network (or at least in another\n   TCP). Thus, the invisible\
    \ switching of a connection from one port to\n   another within a TCP may not\
    \ be sufficient as an \"Initial Connection\n   Protocol\". We imagine that a process\
    \ wishes to use socket N1.T1.Q to\n   access well known socket N2.T2.P. However,\
    \ the process associated\n   with socket N2.T2.P will actually start up a new\
    \ process somewhere\n   which will use N3.T3.S as its server socket. The N(i)\
    \ and T(i) may be\n   distinct or the same. The user will send to N2.T2.P the\
    \ relevant user\n   information such as user name, password, and account. The\
    \ server will\n   start up the server process and send to N1.T1.Q the actual service\n\
    \   socket ldentif1er: N3.T3.S. The connection (N1.TI.Q,N2.T2.P) can then\n  \
    \ be closed, and the user can do a RECEIVE on (N1.T1.Q,N3.T3.S). The\n   serving\
    \ process can SEND on (N3.T3.S,N1.T1.Q). There are many\n   variations on this\
    \ scheme, some involving the user process doing a\n   RECEIVE on a different socket\
    \ (e.g. (N1.T1.X,U.U.U)) with the server\n   doing SEND on (N3.T3.S,N1.T1.X).\
    \  Without showing all the detail of\n   synchronization of sequence numbers and\
    \ the like, we can illustrate\n   the exchange as shown below.\n      USER   \
    \                          SERVER\n                                       1. RECEIVE(N2.T2.P,U.U.U)\n\
    \      1. SEND (N1.T1.Q,N2.T2.P)==>\n                                   <== 2.\
    \ SEND(N2.T2.P,N1.T1.Q)\n                                          With \"N3.T3.S\"\
    \ as data\n      2. RECEIVE(N1.T1.Q,N2.T2.P)\n      3. CLOSE(N1.T1.Q,N2.T2.P)==>\n\
    \                                   <:= 3. CLOSE(N2.T2.P,N1.T1.Q)\n      4. RECEIVE(N1.T1.Q,N3.T3.S)\n\
    \                                   <== 4. SEND(N3.T3.S,N1.T1.Q)\n   At this point,\
    \ a connection is open between N1.T1.Q and N3.T3.S. A\n   variation might be to\
    \ have the user do an extra RECEIVE on\n   (N1.T1.X,U.U.U) and have the data \"\
    N1.T1.X\" be sent in the first user\n   SEND. Then, the server can start up the\
    \ real serving process and do a\n   SEND on (N3.T3.S,N1.T1.X) without having to\
    \ send the \"N3.T3.S\" data\n   to the user. Or perhaps both server and receiver\
    \ exchange this data,\n   to assure security of the ultimate connection (i.e.\
    \ some wild process\n   might try to connect to N1.T1.X if it is merely RECEIVING\
    \ on foreign\n   socket U.U.U.).\n   We do not propose any specific reconnection\
    \ protocol here, but leave\n   this to further deliberation, since it is really\
    \ a user level\n   protocol issue.\n"
- title: 4.  TCP IMPLEMENTATION
  contents:
  - '4.  TCP IMPLEMENTATION

    '
- title: 4.1  INTRODUCTION
  contents:
  - "4.1  INTRODUCTION\n   Conceptually, the TCP is made up of several processes.\
    \ Some of these\n   deal with USER/TCP commands, and others with packets arriving\
    \ from\n   the network. The TCP also has an internal measurement facility which\n\
    \   can be activated remotely.\n   Any particular TCP could be viewed in a number\
    \ of ways. It could be\n   implemented as an independent process, servicing many\
    \ user processes.\n   It could be viewed as a set of re-entrant library routines\
    \ which\n   share a common interface to the local PSN, and common buffer storage.\n\
    \   It could even be viewed as a set of processes, some handling the\n   user,\
    \ some the input of packets from the net, and some the output of\n   packets to\
    \ the net.\n"
- title: 4.2  TCP DATA STRUCTURES
  contents:
  - '4.2  TCP DATA STRUCTURES

    '
- title: 4.2.1  INTERNETWORK PACKET FONMAT
  contents:
  - "4.2.1  INTERNETWORK PACKET FONMAT\n   8 bits: Internet information\n      2 bits:\
    \ Reserved for local PSN use\n      2 bits: Header format (11 in binary)\n   \
    \   4 bits: Protocol version number\n   8 bits: Header length in octets (32 is\
    \ the current value)\n   16 bits: Length of text in octets\n   32 bits: Packet\
    \ sequence number\n   32 bits: Acknowledgment number (i.e. sequence number of\
    \ next octet\n   expected).\n   16 bits: Window size (in octets)\n   16 bits:\
    \ Control Information\n      Listed from high to low order:\n      SYN: Request\
    \ to synchronize sending sequence numbers\n      ACK: There is a valid acknowledgment\
    \ in the 32 bit ACK field\n      FIN: Sender will stop SENDing and RECEIVEing\
    \ on this connection\n      DSN: The sender has stopped using sequence numbers\
    \ and wants to\n      initiate a new sequence number for sending.\n      EOS:\
    \ This packet is the end of a segment and therefore has a\n      checksum in the\
    \ 16 bit checksum field. If this bit is not set, the\n      16 bit checksum field\
    \ is to be ignored. The bit is usually set,\n      but if fragmentation at a GATEWAY\
    \ occurs, the packets preceding\n      the last one will not have checksums, and\
    \ the last packet will\n      have the checksum for the entire original fragment\
    \ (segment) as it\n      was calculated by the sending TCP.\n      EOL: This packet\
    \ contains the last fragment of a letter. The EOS\n      bit will always be set\
    \ in this case.\n      INT: The sender wants to INTERRUPT on this connection.\n\
    \      XXX: six (6) unused control bits\n      OD: three (3) bits of control dispatch:\n\
    \         000: Null (the control octet contents should be ignored}\n         001:\
    \ Event Code is present in the control octet. These were\n         defined in\
    \ section 2.4.3.\n         010: Special Functions\n         011: Reject (codes\
    \ as yet undefined)\n         1XX: Unused\n   8 bits: Control Data Octet\n   \
    \   If CD is 000 then this octet is to be ignored.\n      If CD is 001, this octet\
    \ contains event codes defined in section\n      2.4.3\n      If CD is 010, this\
    \ octet contains a special function code as\n      defined below:\n         0:\
    \ RESET all connections between Source and Destination TCPs\n         l: RESET\
    \ the specific connection referenced in this packet\n         2: ECHO return packet\
    \ to sender with the special function code\n         ECHOR (Echo Reply).\n   \
    \      3: QUERY Query status of connection referenced in this packet\n       \
    \  4: STATUS Reply to QUERY with requested status.\n         5: ECHOR Echo Reply\n\
    \         6: TRASH Discard packet without acknowledgment\n         >6: Unused\n\
    \         Note: Special function packets not pertaining to a particular\n    \
    \     connection [RESET all, ECHO, ECHOR, and TRASH] are normally\n         sent\
    \ using socket zero as described in section 3.2.\n      If CD is 01l, this octet\
    \ contains an as yet undefined REJECT code.\n      If CD is 1XX, this octet is\
    \ undefined.\n   4 bits: Length of destination network address in 4 bit units\
    \ (current\n   value is 1)\n   4 bits: Destination network address\n      1010-1111\
    \ are addresses of ARPANET, UCL, CYCLADES, NPL, CADC, and\n      EPSS respectively.\n\
    \   16 bits: Destination TCP address\n   8 bits: Padding\n   4 bits: length of\
    \ source network address in 4 bit units (current\n   value is 1)\n   4 bits: source\
    \ network address (as for destination address)\n   16 bits: Source TCP address\n\
    \   24 bits: Destination port address\n   24 bits: Source port address\n   16\
    \ bits: Checksum (if EOS bit is set)\n"
- title: 4.2.2  TRANSMISSION CONTROL BLOCK
  contents:
  - "4.2.2  TRANSMISSION CONTROL BLOCK\n   It is highly likely that any implementation\
    \ will include shared data\n   structures among parts of the TCP and some asynchronous\
    \ means of\n   signaling users when letters have been delivered.\n   One typical\
    \ data structure is the Transmission Control Block (TCB)\n   which is created\
    \ and maintained during the lifetime of a given\n   connection. The TCB contains\
    \ the following information (field sizes\n   are notional only and may vary from\
    \ one implementation to another):\n      16 bits: Local connection name\n    \
    \  48 bits: Local socket\n      48 bits: Foreign socket\n      16 bits: Receive\
    \ window size in octets\n      32 bits: Receive left window edge (next sequence\
    \ number expected)\n      16 bits: Receive packet buffer size of TCB (may be less\
    \ than\n      window)\n      16 bits: Send window size in octets\n      32 bits:\
    \ Send left window edge (earliest unacknowledged octet)\n      32 bits: Next packet\
    \ sequence number\n      16 bits: Send packet buffer size of TCB (may be less\
    \ than window)\n      8 bits: Connection state\n         E/C - 1 if TCP has been\
    \ synchronized at least once (i.e. has\n         been established, else O, meaning\
    \ it is closed; this bit is\n         reset after FINS are exchanged and the user\
    \ has done a CLOSE).\n         The bit is not reset if the connection is only\
    \ desynchronized\n         on send or receive or both directions.\n         SS\
    \ - SYNCed on send side (if set) else desynchronized\n         SR - SYNCed on\
    \ receive side (if set, else desynchronized)\n   16 bits: Special flags\n    \
    \  S1 - SYN sent if set\n      S2 - SYN verified if set\n      R - SYN received\
    \ if set\n      Y - FIN sent if set\n      C - CLOSE from local user received\
    \ if set\n      U - Foreign socket unspecified if set\n      SDS - Send side DSN\
    \ sent if set\n      SDV - Send side DSN verified if set\n      RDR - Receive\
    \ side DSN received if set\n   Initially, all bits are off [no pun intended] (i.e.\
    \ SS, SR, E/C, S1,\n   S2, R, F, C, SDS, SDV, RDR =0). When R is set, so is SR.\
    \ When S1 and\n   S2 are both set, so is SS. SR is reset when RDR is set. SS is\
    \ reset\n   when both SDS and SDV are set. These bits are used to keep track of\n\
    \   connection state and to aid in arriving packet processing (e.g. Can\n   sequence\
    \ number be validated? Only if SR is set.).\n   16 bits: Retransmission timeout\
    \ (in eighths of a second#]\n   16 bits: Head of Send buffer queue [buffers SENT\
    \ from user to TCP,\n   but not packetized]\n   16 bits: Tail of Send buffer queue\n\
    \   16 bits: Pointer to last octet packetized in partially packetized\n   buffer\
    \ (refers to the buffer at the head of the queue)\n   16 bits: Head of Send packet\
    \ queue\n   16 bits: Tail of Send packet queue\n   16 bits: Head of Packetized\
    \ buffer Queue\n   16 bits: Tail of Packetized buffer queue\n   16 bits: Head\
    \ of Retransmit packet queue\n   16 bits: Tail of Retransmit packet queue\n  \
    \ 16 bits: Head of Receive buffer queue [queue of buffers given by user\n   to\
    \ RECEIVE letters, but unfilled]\n   16 bits: Tail of Receive buffer queue\n \
    \  16 bits: Head of Receive packet queue\n   16 bits: Tail of receive packet queue\n\
    \   16 bits: Pointer to last contiguous receive packet\n   16 bits: Pointer to\
    \ last octet filled in partly filled buffer\n   16 bits: Pointer to next octet\
    \ to read from partly emptied packet\n      [Note: The above two pointers refer\
    \ to the head of the receive\n      buffer and receive packet queues respectively]\n\
    \   16 bits: Forward TCB pointer\n   16 bits: Backward TCB pointer\n"
- title: 4.3  CONNECTION MANAGEMENT
  contents:
  - '4.3  CONNECTION MANAGEMENT

    '
- title: 4.3.1  INITIAL SEQUENCE NUMBER SELECTION
  contents:
  - "4.3.1  INITIAL SEQUENCE NUMBER SELECTION\n   The protocol places no restriction\
    \ on a particular connection being\n   used over and over again. New instances\
    \ of a connection will be\n   referred to as incarnations of the connection. The\
    \ problem that\n   arises owing to this is, \"how does the TCP identify duplicate\
    \ packets\n   from previous incarnations of the connection?\". This problem becomes\n\
    \   harmfully apparent if the connection is being opened and closed in\n   quick\
    \ succession, or if the connection breaks with loss of memory and\n   is then\
    \ reestablished.\n   The essence of the solution [TOML74] is that the initial\
    \ sequence\n   number [ISN] must be chosen so that a particular sequence number\
    \ can\n   never refer to an \"o1d\" octet, Once the connection is established\
    \ the\n   sequencing mechanism provided by the TCP filters out duplicates.\n \
    \  For an association to be established or initialized, the two TCP's\n   must\
    \ synchronize on each other's initial sequence numbers. Hence the\n   solution\
    \ requires a suitable mechanism for picking an initial\n   sequence number [ISN],\
    \ and a slightly involved handshake to exchange\n   the ISN's. A \"three way handshake\"\
    \ is necessary because sequence\n   numbers are not tied to a global clock in\
    \ the network, and TCP's may\n   have different mechanisms for picking the ISN's.\
    \ The receiver of the\n   first SYN has no way of knowing whether the packet was\
    \ an old delayed\n   one or not, unless it remembers the last sequence number\
    \ used on the\n   connection which is not always possible, and so it must ask\
    \ the\n   sender to verify this SYN.\n   The \"three way handshake\" and the advantages\
    \ of a \"clock-driven\"\n   scheme are discussed in [TOML74]. More on the subject,\
    \ and algorithms\n   for implementing the clock-driven scheme can be found in\
    \ [DALA74].\n"
- title: 4.3.2 ESTABLISHING A CONNECTION
  contents:
  - "4.3.2 ESTABLISHING A CONNECTION\n   The \"three way handshake\" is essentially\
    \ a unidirectional attempt to\n   establish the connection, i.e. there is an initiator\
    \ and a responder.\n   The TCP's should however be able to establish the connection\
    \ even if\n   a simultaneous attempt is made by both TCP's to establish the\n\
    \   connection. Simultaneous attempts are treated like \"collisions\" in\n   \"\
    Aloha\" systems and these conflicts are resolved into unidirectional\n   attempts\
    \ to establish the connection. This scheme was adopted because\n      (i) Connections\
    \ will normally have a passive and an active end,\n      and so the mechanism\
    \ should in most cases be as simple as\n      possible.\n      (ii) It is easy\
    \ to implement as special cases do not have to be\n      accounted for.\n   The\
    \ example below indicates what a three way handshake between TCP's\n   A and B\
    \ looks like\n         A                                                 B\n \
    \        --> <SEQ x><SYN>                                  -->\n         <-- <SEQ\
    \ y><SYN, ACK x+l>                         <--\n         --> <SEQ x+1><ACK y+l><DATA\
    \ BYTES>                -->\n   The receiver of a \"SYN\" is able to determine\
    \ whether the \"SYN\" was\n   real (and not an old duplicate) when a positive\
    \ \"ACK\" is returned for\n   the receiver's \"SYN,ACK\" in response to the \"\
    SYN\". The sender of a\n   \"SYN\" gets verification on receipt of a \"SYN,ACK\"\
    \ whose \"ACK\" part\n   references the sequence number proposed in the original\
    \ \"SYN\" [pun\n   intended]. If the TCP is in the state where it is waiting for\
    \ a\n   response to its SYN, but gets a SYN instead, then it always thinks\n \
    \  this is a collision and goes into the state prior to having sent the\n   SYN,\
    \ i.e. it forgets that it had sent a SYN. The TCP will try to\n   establish the\
    \ connection again after some time, unless it has to\n   respond to an arriving\
    \ SYN. Even if the wait times in the two TCPs\n   are the same, the varying delays\
    \ in network transmission will usually\n   be adequate to avoid a collision on\
    \ the next cycle of attempts to\n   send SYN.\n   When establishing a connection,\
    \ the state of the TCP is represented\n   by 3 bits --\n      S1 S2 R\n      S1\
    \ = 1 -- SYN sent\n      S2 = 1 -- My SYN verified\n      R = 1 -- SYN received\n\
    \   Some examples of attempts to establish the connection are now shown.\n   The\
    \ state of the connection is indicated when a change occurs. We\n   specifically\
    \ do not show the cases in which connection\n   synchronization is carried out\
    \ with packets containing both SYN and\n   data. We do this to simplify the explanation,\
    \ but we do not rule out\n   an implementation which is capable of dealing with\
    \ data arriving in\n   the first packet (it has to be stored temporarily without\n\
    \   acknowledgment or delivery to the user until the arriving SYN has\n   been\
    \ verified).\n   The \"three way handshake\" now looks like --\n             \
    \ A                                            B\n      ------------         \
    \                             ------------\n      S1 S2 R                    \
    \                            S1 S2 R\n      0  0 0                           \
    \                      0  0 0\n             --> <SEQ x><SYN>                 \
    \          -->\n      1  0 0                                                 0\
    \  0 1\n             <-- <SEQ y><SYN, ACK x+l>                  <--\n      1 \
    \ 1 1                                                 1  0 1\n             -->\
    \ <SEQ x+1><ACK y+1>(DATA OCTETS)        -->\n      1  1 1                   \
    \                              1  1 1\n   The scenario for a simultaneous attempt\
    \ to establish the connection\n   without the arrival of any delayed duplicates\
    \ is --\n                    A                                     B\n       \
    \     ------------                               ------------\n            S1\
    \ S2 R                                         S1 S2 R\n             0  0 0  \
    \                                        0  0 0\n      (M1)   1  0 0 --> <SEQ\
    \ x><SYN>                    ...\n      (M2)   0  0 0 <-- <SEQ y><SYN)       \
    \             <--  1  0 0\n      (M1)              B returns no SYN sent     \
    \      -->  0  0 0\n      (M1)   1  0 0 --> <SEQ z><SYN>      *             -->\
    \  0  0 1\n      (M3)   1  1 1 <-- <SEQ y+1><SYN,ACK z+1>          <--  1  0 1\n\
    \      (M4)   1  1 1 --> <SEQ z+1><ACK y+1><DATA>        -->  1  1 1\n      Note:\
    \ \"...\" means that a message does not arrive, but is delayed\n      in the network.\
    \ State changes are upon arrival or upon departure\n      of a given message,\
    \ as the case may be. Packets containing the SYN\n      or INT or DSN bits implicitly\
    \ contain a \"dummy\" data octet which\n      is never delivered to the user,\
    \ but which causes the packet\n      sequence numbers to be incremented by 1 even\
    \ if no real data is\n      sent. This permits the acknowledgment of these controls\
    \ without\n      acknowledging receipt of any data which might also have been\n\
    \      carried in the packet. A packet containing a FIN bit has a dummy\n    \
    \  octet following the last octet of data (if any) in the packet.\n      * Once\
    \ in state 000 sender selects new ISN z when attempting to\n      establish the\
    \ connection again.\n"
- title: 4.3.3 HALF-OPEN CONNECTIONS
  contents:
  - "4.3.3 HALF-OPEN CONNECTIONS\n   An established connection is said to be a \"\
    half-open\" connection if\n   one of the TCP's has closed the connection at its\
    \ end without the\n   knowledge of the other, or if the two ends of the connection\
    \ have\n   become desynchronized owing to a crash that resulted in loss of\n \
    \  memory. Such connections will automatically become reset if an\n   attempt\
    \ is made to send data in either direction. However, half-open\n   connections\
    \ are expected to be unusual, and the recovery procedure is\n   somewhat involved.\n\
    \   If one end of the connection no longer exists, then any attempt by\n   the\
    \ other user to send any data on it will result in the sender\n   receiving the\
    \ event code \"Connection does not exist at foreign TCP\".\n   Such an error message\
    \ should indicate to the user process that\n   something is wrong and it is expected\
    \ to CLOSE the connection.\n   Assume that two user processes A and B are communicating\
    \ with one\n   another when a crash occurs causing loss of memory to B's TCP.\n\
    \   Depending on the operating system supporting B's TCP, it is likely\n   that\
    \ some error recovery mechanism exists. When the TCP is up again B\n   is likely\
    \ to start again from the beginning or from a recovery point.\n   As a result\
    \ B will probably try to OPEN the connection again or try\n   to SEND on the connection\
    \ it believes open. In the latter case 1t\n   receives the error message \"connection\
    \ not open\" from the local TCP.\n   In an attempt to establish the connection\
    \ B's TCP will send a packet\n   containing SYN. A's TCP thinks that the connection\
    \ is already\n   established and so will respond with the error \"unacceptable\
    \ SYN (or\n   SYN/ACK) arrived at foreign TCP\". B's TCP knows that this refers\
    \ to\n   the SYN it just sent out, and so should reset the connection and\n  \
    \ inform the user process of this fact.\n   It may happen that B is passive and\
    \ only wants to receive data. In\n   this case A's data will not reach B because\
    \ the TCP at B thinks the\n   connection is not established. As a result A'S TCP\
    \ will timeout and\n   send a QRY to B's TCP. B's TCP will send STATUS saying\
    \ the connection\n   is not synched. A's TCP will treat this as if an implicit\
    \ CLOSE had\n   occurred and tell the user process, A, that the connection is\n\
    \   closing. A is expected to respond with a CLOSE command to his TCP.\n   However,\
    \ A's TCP does not send a FIN to B's TCP, since it would not\n   be accepted anyway\
    \ on the unsynced connection. Eventually A will try\n   to reopen the connection\
    \ or B will give up and CLOSE. If B CLOSES,\n   B's TCP will simply delete the\
    \ connection since it was not\n   established as far as B's TCP is concerned.\
    \ No message will be sent\n   to A'S TCP as a result.\n"
- title: 4.3.4  RESYNCHRONIZING A CONNECTION
  contents:
  - "4.3.4  RESYNCHRONIZING A CONNECTION\n   Details of resynchronization have not\
    \ yet been specified since the\n   need for this should be infrequent in the initial\
    \ testing stages.\n"
- title: 4.3.5 CLOSING A CONNECTION
  contents:
  - "4.3.5 CLOSING A CONNECTION\n   There are essentially three cases:\n      a) The\
    \ user initiates by telling the TCP to CLOSE the connection\n      b) The remote\
    \ TCP initiates by sending a FIN control signal\n      c) Both users CLOSE simultaneously\n\
    \   Two bits are used to maintain control over the closing of a\n   connection:\
    \ these are called the \"FIN sent\" bit [F] and the \"USER\n   Closed\" bit, [C]\
    \ respectively. The control procedure uses these two\n   bits to assure that the\
    \ connection is properly closed.\n   Case 1: Local user initiates the close\n\
    \      In this case, both the F and C bits are initially zero, but the C\n   \
    \   bit is set immediately upon receipt of the user call \"CLOSE.\" When\n   \
    \   the FIN is sent out by the TCP, the F bit is set. All pending\n      RECEIVES\
    \ are terminated and the user is told that they have been\n      prematurely terminated\
    \ (\"connection closing\"} without data.\n      Similarly, any pending SENDS are\
    \ terminated with the same\n      response, \"connection closing.\"\n      Several\
    \ responses may arrive as the result of sending a FIN. The\n      one which is\
    \ generally expected is a matching FIN. When this is\n      received, the TCB\
    \ CAN BE ELIMINATED. If a \"connection does not\n      exist at foreign TCP\"\
    \ message comes in response to the FIN, then\n      the TCB can likewise be eliminated.\
    \ If no response is forthcoming,\n      or if \"Foreign TCP inaccessible\" arrives\
    \ then the resolution is\n      moot. One might simply timeout and discard the\
    \ TCB. Since the\n      local user wants to CLOSE anyway, this is probably satisfactory,\n\
    \      although it will leave a potential \"half-open\" connection at the\n  \
    \    other side. We deal with half open connections in section 4.3.3.\n      When\
    \ the acknowledging FIN arrives after the connection state bits\n      are set\
    \ (F=1, C=1), then the TCB can be deleted.\n   Case 2: TCP receives a FIN from\
    \ the network\n      First of all, a FIN must have a sequence number which lies\
    \ in the\n      valid receive window. If not, it is discarded and the left window\n\
    \      edge is sent as acknowledgment. If the FIN can be processed, it is\n  \
    \    handled (possibly out of order, since it is taken as an imperative\n    \
    \  to shut down the connection). All pending RECEIVES and SENDS are\n      responded\
    \ to by showing that they were terminated by the other\n      side's close request\
    \ (i.e. \"connection closing\"). The user is also\n      told by an unsolicited\
    \ event or signal that the connection has\n      been closed (in some systems,\
    \ the user might have to request\n      STATUS to get this information). Finally,\
    \ the TCP sends FIN in\n      response.\n      Thus, because a FIN arrived, a\
    \ FIN is sent back, so the F bit is\n      set. However, the TCB stays around\
    \ until the local user does a\n      CLOSE in acknowledgment of the unsolicited\
    \ signal that the\n      connection has been closed by the other side. Thus, the\
    \ C bit\n      remains unset until this happens. If the C and F bits go from (F=1\n\
    \      C=O) to (F=l, C=1), then the connection is closed and the TCB can\n   \
    \   be removed.\n   Case 3: both users close simultaneously\n      If this happens,\
    \ both connections will be in the (F=1, C=1) state.\n      When the FINs arrive,\
    \ the connections w11i be shut down. If one\n      FIN fails to arrive, we have\
    \ two choices. One is to insist on\n      acknowledgments for FINs, in which case\
    \ the missing one will be\n      retransmitted. Another is merely to permit the\
    \ half-open\n      connection to remain (we prefer this solution}. It can timeout\n\
    \      independently and go away after a while. If an attempt is made to\n   \
    \   reestablish the connection, the initiator will discover the\n      existence\
    \ of the open connection since an \"inappropriate SYN\n      received\" message\
    \ will be sent by the TCP which holds the \"half-\n      open\" connection. The\
    \ receiver of this message can tell the other\n      TCP to reset the connection.\
    \ We cannot permit the holder of the\n      half-open connection to reset automatically\
    \ on receipt of the SYN\n      since its receipt is not necessarily prima facie\
    \ evidence of a\n      half open connection. (The SYN could be a delayed duplicate.)\n"
- title: 4.3.6.  CONNECTION STATE and its relation to USER and INCOMING CONTROL
  contents:
  - "4.3.6.  CONNECTION STATE and its relation to USER and INCOMING CONTROL\n   REQUESTS\n\
    \   In order to formalize the action taken by the TCP when it receives\n   commands\
    \ from the User, or Control information from the network, we\n   define a connection\
    \ to be in one of 7 states at any instant. These\n   are known as the TCB Major\
    \ States. Each Major State is simply a\n   convenient name for a particular setting\
    \ or group of settings of the\n   state bits, as follows:\n      S1 S2  R  U \
    \ F  C   #   name\n       -  -  -  -  -  -   0   no TCB\n       0  0  0 0/1 0\
    \  0   1   unsync\n       1  0  0  0  0  0   2   SYN sent\n       1  0  1 0/1\
    \ 0  0   3   SYN received\n       1  1  1  0  0  0   4   established\n       1\
    \ 0/1 1 0/1 1  1   5   FIN wait\n       1  1  1  0  1  0   6   FIN received\n\
    \   The connection moves from state to state as shown below. The\n   transition\
    \ from one state to another will be represented as\n      [X, Y]<cause><action>\n\
    \   which means that there is a transition from state X to state Y owing\n   to\
    \ <cause>. The action taken by the TCP is specified as <action>. We\n   use this\
    \ notation to give the important state transitions, often\n   simplifying the\
    \ cause and action fields to take into account a number\n   of situations. Figure\
    \ 1 illustrates these transitions in traditional\n   state diagram form. Section\
    \ 4.4.6 and section 4.4.7 fully specify the\n   effect of all User commands and\
    \ Control information arriving from the\n   network.\n      [0,l] <OPEN> <create\
    \ TCB>\n      [1,2] <SEND,INTERRUPT, or collision timeout> <send SYN>\n      [1,3]\
    \ <SYN arrives> <send SYN,ACK>\n      [1,0] <CLOSE> <remove TCB>\n      [2,1]\
    \ <SYN arrives (collision)> <set timeout, forget SYNs>\n      [2,0] <CLOSE> <remove\
    \ TCB>\n      [2,4] <appropriate SYN,ACK arrives> <send ACK>\n      [3,4] <appropriate\
    \ ACK arrives> <none>\n      [3,1] <error arrives or timeout> <(forget SYN)>\n\
    \      [3,5] <CLOSE> <send FIN>\n      [4,5] <CLOSE> <send FIN>\n      [4,6] <appropriate\
    \ FIN arrives> <send FIN, inform user>\n      [5,0] <FIN or error arrives, or\
    \ timeout> <remove TCB>\n      [6,0] <CLOSE> <remove TCB>\n"
- title: 4.4  STRUCTURE 0F THE TCP
  contents:
  - '4.4  STRUCTURE 0F THE TCP

    '
- title: 4.4.l  INTRODUCTION [See figure 2.1]
  contents:
  - "4.4.l  INTRODUCTION [See figure 2.1]\n   There are many possible implementations\
    \ of the TCP. We offer one\n   conceptual framework in which to view the various\
    \ algorithms that\n   make up the TCP design. In our concept, the TCP is written\
    \ in two\n   parts, an interrupt or signal driven part (consisting of four\n \
    \  processes), and a reentrant library of subroutines or system calls\n   which\
    \ interface the user process to the TCP. The subroutines\n   communicate with\
    \ the interrupt part through shared data structures\n   (TCB's, shared buffer\
    \ queues etc.). The four processes are the Output\n   Packet Handler which sends\
    \ packets to the packet switch; the\n   Packetizer which formats letters into\
    \ internet packets; the Input\n   Packet Handler which processes incoming packets;\
    \ and the Reassembler\n   which builds letters for users.\n   The ultimate bottleneck\
    \ is the pipe through which arriving and\n   departing packets must travel. This\
    \ is the Host/Packet Switch\n   interface. The interrupt driven TCP shares among\
    \ all TCB's its\n   limited packet buffer resources for sending and receiving\
    \ packets.\n   From the standpoint of controlling buffer congestion, it appears\n\
    \   better to TREAT INCOMING PACKETS WITH HIGHER PRIORITY THAN OUTGOING\n   PACKETS.\
    \ That is, packet buffers which can be released by copying\n   their contents\
    \ into user buffers clearly help to reduce congestion.\n   Neither the packetizer\
    \ nor the input packet handler should be allowed\n   to take up all available\
    \ packet buffer space; an analogous problem\n   arises in the IMP in the allocation\
    \ of store and forward, and\n   reassembly buffer space. One policy is to permit\
    \ neither contender\n   more than, say, two-thirds of the space. The buffer allocation\n\
    \   routines can enforce these limits and reject buffer requests as\n   needed.\
    \ Conceptually, the scheduler can monitor the amounts of\n   storage dedicated\
    \ to the input and output routines, and can force\n   either to sleep if its buffer\
    \ allocation exceeds the limit.\n   As an example, we can consider what happens\
    \ when a user executes a\n   SEND call to the TCP service routines. The buffer\
    \ containing the\n   letter is placed on a SEND buffer queue associated with the\
    \ user's\n   TCB. A 'packetizer' process is awakened to look through all the TCB's\n\
    \   for 'packetizing' work. The packetizer will keep a roving pointer\n   through\
    \ the TCB list which enables it to pick up new buffers from the\n   TCB queue\
    \ and packetize them into output buffers. The packetizer\n   takes no more than\
    \ one letter at a time from any single TCB. The\n   packetizer attempts to maintain\
    \ a non-empty queue of output packets\n   so that the output handler will not\
    \ fall idle waiting for the\n   packetizing operation. However, since arriving\
    \ packets compete with\n   departing packets, care must be taken to prevent either\
    \ class from\n   occupying all of the shared packet buffer space. Similarly since\
    \ the\n   TCB's all compete for space in service to their connections, neither\n\
    \   input nor output packet space should be dominated by any one TCB.\n   When\
    \ a packet is created, it is placed on a FIFO SEND packet queue\n   associated\
    \ with its origin TCB. The packetizer wakes the output\n   handler and then continues\
    \ to packetize a few more buffers, perhaps,\n   before going to sleep. The output\
    \ handler is awakened either by a\n   'hungry' packet switch or by the packetizer;\
    \ in either case, it uses\n   a roving TCB pointer to select the next TCB for\
    \ service. The send\n   packet queue can be used as a 'work queue' for the output\
    \ handler.\n   After a packet has been sent, but usually before an ACK is returned,\n\
    \   the output handler moves the packet to a retransmission queue\n   associated\
    \ with each TCB.\n   Retransmission timeouts can refer to specific packets and\
    \ the\n   retransmission list can be searched for the specific packet. If an\n\
    \   ACK is received, the retransmission entry can be removed from the\n   retransmit\
    \ queue. The send packet queue contains only packets waiting\n   to be sent for\
    \ the first time. INTERRUPT requests can remove entries\n   in both the send packet\
    \ queue and the retransmit packet queue.\n   Since packets are never in more than\
    \ one queue at a time, it appears\n   possible for INT, FIN or RESET commands\
    \ to remove packets from the\n   receive, send, or retransmit packet queues with\
    \ the assurance that an\n   already issued signal to enter the reassembler, the\
    \ packetizer or the\n   output handler will not be confusing.\n   Handling the\
    \ INTERRUPT and CLOSE functions can however require some\n   care to avoid confusing\
    \ the scheduler, and the various processes. The\n   scheduler must maintain status\
    \ information for the processes. This\n   information includes the current TCB\
    \ being serviced. When an\n   INTERRUPT is issued by a local process, the output\
    \ queue of letters\n   associated with the local port reference is to be deleted.\
    \ The\n   packetizer, for example, may however be working at that time on the\n\
    \   same queue. As usual, simultaneous reading and writing of the TCB\n   queue\
    \ pointers must be inhibited through some sort of semaphore or\n   lockout mechanism.\
    \ When the packetizer wants to serve the next send\n   buffer queue, it must lock\
    \ out all other access to the queue, remove\n   the head of the queue (assuming\
    \ of course that there are enough\n   buffers for packetization), advance the\
    \ head of the queue, and then\n   unlock access to the queue.\n   If the packetizer\
    \ keeps only a TCB pointer in a global place called\n   CPTCB (current packetizer\
    \ TCB address), and always uses the address\n   in CPTCB to find the TCB in which\
    \ to examine the send buffer queue,\n   then removal of the output buffer queue\
    \ does not require changes to\n   any working storage belonging to the packetizer.\
    \ Even more important,\n   the arrival and processing of a RESET or CLOSE, which\
    \ clears the\n   system of a given TCB, can update the CPTCB pointer, as long\
    \ as the\n   removal does not occur while the packetizer is still working on the\n\
    \   TCB.\n   Incoming packets are examined by the input packet handler. Here they\n\
    \   are checked for valid connection sockets, and acknowledgments are\n   processed,\
    \ causing packets to be removed, possibly, from the SEND or\n   RETRANSMIT packet\
    \ queues as needed. As an example, consider the\n   receipt of a valid FIN request\
    \ on a particular TCB. If a FIN had not\n   been sent before (i.e. F bit not set),\
    \ then a FIN packet is\n   constructed and sent after having cleared out the SEND\
    \ buffer and\n   SEND packet queues as well as the RETRANSMIT queue. Otherwise,\
    \ if the\n   F and C bits are both set, all queues are emptied and the TCB is\n\
    \   returned to free storage.\n   Packets which should be reassembled into letters\
    \ and sent to users\n   are queued by the input packet handler, on the receive\
    \ packet queue,\n   for processing by the reassembly process. The reassembler\
    \ looks at\n   its FIFO work queue and tries to move packets into user buffers\
    \ which\n   are queued up in an input buffer queue on each TCB. If a packet has\n\
    \   arrived out of order, it can be queued for processing in the correct\n   sequence.\
    \ Each time a packet is moved into a user buffer, the left\n   window edge of\
    \ the receiving TCB is moved to the right so that\n   outgoing packets can carry\
    \ the correct ACK information. If the SEND\n   buffer queue is empty, then the\
    \ reassembler creates a packet to carry\n   the ACK.\n   As packets are moved\
    \ 1nto buffers and they are filled, the buffers\n   are dequeued from the RECEIVE\
    \ buffer queue and passed to the user.\n   The reassembler can also be awakened\
    \ by the RECEIVE user call should\n   it have a non-empty receive packet queue\
    \ with an empty RECEIVE buffer\n   queue. The awakened reassembler goes to work\
    \ on each TCB, keeping a\n   roving pointer, and sleeping if a cycle is made of\
    \ all TCB's without\n   finding any work.\n"
- title: 4.4.2  INPUT PACKET HANDLER [See figure 2.2]
  contents:
  - "4.4.2  INPUT PACKET HANDLER [See figure 2.2]\n   The Input Packet Handler is\
    \ awakened when a packet arrives from the\n   network. It first verifies that\
    \ the packet is for an existing TCB\n   (i.e. the local and foreign socket numbers\
    \ are matched with those of\n   existing TCB's). If this fails, an error message\
    \ is constructed and\n   queued on the send packet queue of a dummy TCB. A signal\
    \ is also sent\n   to the output packet handler. Generally, things to be transmitted\n\
    \   from the dummy TCB have a default retransmission timeout of zero, and\n  \
    \ will not be retransmitted. (We use the idea of a dummy TCB so that\n   all packets\
    \ containing errors, or RESET can be sent by the output\n   packet handler, instead\
    \ of having the originator of them interface to\n   the net. These packets, it\
    \ will be noticed, do not belong to any\n   TCB).\n   The input packet handler\
    \ looks out for control or error information\n   and acts appropriately. Section\
    \ 4.4.7 discusses this in greater\n   detail, but as an example, if the incoming\
    \ packet is a RESET request\n   of any kind (i.e. all connections from designated\
    \ TCP or given\n   connection), and is believable, then the input packet handler\
    \ clears\n   out the related TCB(s), empties the send and receive packet queues,\n\
    \   and prepares error returns for outstanding user SEND(s) and\n   RECEIVE(s)\
    \ on each reset TCB. The TCB's are marked unused and\n   returned to storage.\
    \ If the RESET refers to an unknown connection, it\n   is ignored.\n   Any ACK's\
    \ contained in incoming packets are used to update the send\n   left window edge,\
    \ and to remove the ACK'ed packets from the TCB\n   retransmit packet queue. If\
    \ the packet being removed was the end of a\n   user buffer, then the buffer must\
    \ be dequeued from the packetized\n   buffer queue, and the User informed. The\
    \ packetizer is also signaled.\n   Only one signal, or one for each packet, will\
    \ have to be sent,\n   depending on the scheduling scheme for the processes. See\
    \ section\n   4.4.7 for a detailed discussion.\n   The packet sequence number,\
    \ the current receive window size, and the\n   receive left window edge determine\
    \ whether the packet lies within the\n   window or outside of it.\n      Let W\
    \ = window size\n         S = size of sequence number space\n         L = left\
    \ window edge\n         R = L+W-1 = right window edge\n         x = sequence number\
    \ to be tested\n      For any sequence number, x, if\n         (R-x) mod S <=\
    \ W\n      then x is within the window.\n   A packet should be rejected only if\
    \ all of it lies outside the\n   window. This is easily tested by letting x be,\
    \ first the packet\n   sequence number, and then the sum of packet sequence number\
    \ and\n   packet text length, less one. If the packet lies outside the window,\n\
    \   and there are no packets waiting to be sent, then the input packet\n   handler\
    \ should construct a dummy ACK and queue it for output on the\n   send packet\
    \ queue, and signal the output packet handler. Successfully\n   received packets\
    \ are placed on the receive packet queue in the\n   appropriate sequence order,\
    \ and the reassembler signaled.\n   The packet window check can not be made if\
    \ the associated TCB is not\n   in the 'established' state, so care must be taken\
    \ to check for\n   control and TCB state before doing the window check.\n"
- title: 4.4.3  REASSEMBLER [See figure 2.3]
  contents:
  - "4.4.3  REASSEMBLER [See figure 2.3]\n   The Reassembler process is activated\
    \ by both the Input Packet Handler\n   and the RECEIVE user call. While the reassembler\
    \ is asleep, if\n   multiple signals arrive, all but one can be discarded. This\
    \ is\n   important as the reassembler does not know the source of the signal.\n\
    \   This is so in order that \"dangling\" signals from work in TCB's that\n  \
    \ have subsequently been removed don't confuse it. Each signal simply\n   means\
    \ that there may be work to be done. If the reassembler is awake\n   when a signal\
    \ arrives, it may be necessary to put 1t in a\n   \"hyperawake\" state so that\
    \ even if the reassembler tries to quit, the\n   scheduler will run it one more\
    \ time.\n   When the reassembler is awakened it looks at the receive packet queue\n\
    \   for each TCB. If there are some packets there then it sees whether\n   the\
    \ RECEIVE buffer queue is empty. If it is then the reassembler\n   gives up on\
    \ this TCB and goes on to the next one, otherwise if the\n   first packet matches\
    \ the left window edge, then the packet can be\n   moved into the User's buffer.\
    \ The reassembler keeps transferring\n   packets into the User's buffer until\
    \ the letter is completely\n   transferred, or something causes it to stop. Note\
    \ that a buffer may\n   be partly filled and then a sequence 'hole' is encountered\
    \ in the\n   receive packet queue. The reassembler must mark progress so that\
    \ the\n   buffer can be filled up starting at the right place when the 'hole'\n\
    \   is filled. Similarly a packet might be only partially emptied when a\n   buffer\
    \ is filled, so progress in the packet must be marked.\n   If a letter was successfully\
    \ transferred to a User buffer then the\n   reassembler signals the User that\
    \ a letter has arrived and dequeues\n   the buffer associated with it from the\
    \ TCB RECEIVE buffer queue. If\n   the buffer is filled then the User is signaled\
    \ and the buffer\n   dequeued as before. The event code indicates whether the\
    \ buffer\n   contains all or part of a letter, as described in section 2.4.\n\
    \   In every case when a packet is delivered to a buffer, the receive\n   left\
    \ window edge is updated, and the packetizer is signaled. This\n   updating must\
    \ take account of the extra octet included in the\n   sequencing for certain control\
    \ functions [SYN, INT, FIN, DSN]. If the\n   send packet queue is empty then the\
    \ reassembler must create a packet\n   to carry the ACK, and place it on the send\
    \ packet queue.\n   Note that the reassembler never works on a TCB for more than\
    \ one User\n   buffer's worth of time, in order to give all TCB's equal service.\n\
    \   Scheduling of the reassembler is a big issue, but perhaps running to\n   completion\
    \ will be satisfactory, or else it can be time sliced. In\n   the latter case\
    \ it will continue from where it left off, but a new\n   signal may have arrived\
    \ producing some possible work. This work will\n   be processed as part of the\
    \ old incomplete signal, and so some\n   wasteful processing may occur when the\
    \ reassembler wakes up again.\n   This is the general problem of trying to implement\
    \ a protocol that is\n   fundamentally asynchronous, but at least it is immune\
    \ to harmful\n   race-conditions. E.g. if we were to have the reassembler 'remove'\
    \ the\n   signal that caused it to wake up, just before it went to sleep (in\n\
    \   order that new arriving ones were discarded) then a new signal may\n   arrive\
    \ at a critical time causing 1t not to be recognized; thus\n   leaving some work\
    \ pending, and this may result in a deadlock [see\n   previous comments on \"\
    hyperawake\" state].\n"
- title: 4.4.4  PACKETIZER [See figure 2.4]
  contents:
  - "4.4.4  PACKETIZER [See figure 2.4]\n   The Packetizer process gets work from\
    \ both the Input Packet Handler\n   and the SEND user call. The signal from the\
    \ SEND user call indicates\n   that there is something new to send, while the\
    \ one from the input\n   packet handler indicates that more TCP buffers may be\
    \ available from\n   delivered packets. This latter signal is to prevent deadlocks\
    \ in\n   certain kind of scheduling schemes. We assume the same treatment of\n\
    \   signals as discussed in section 4.4.3.\n   When the packetizer is awakened\
    \ it looks at the SEND buffer queue for\n   each TCB. If there is a new or partial\
    \ letter awaiting packetization,\n   it tries to packetize the letter, TCB buffer\
    \ and window permitting.\n   It packetizes no more than one letter for a TCB before\
    \ servicing\n   another TCB. For every packet produced it signals the output packet\n\
    \   handler (to prevent deadlock in a time sliced scheduling scheme). If\n   a\
    \ 'run till completion' scheme is used then one signal only need be\n   produced,\
    \ the first time a packet is produced since awakening. If\n   packetization is\
    \ not possible the packetizer goes on to the next TCB.\n   If a partial buffer\
    \ was transferred then the packetizer must mark\n   progress in the SEND buffer\
    \ queue. Completely packetized buffers are\n   dequeued from the SEND buffer queue,\
    \ and placed on a Packetized\n   buffer queue, so that the buffer can be returned\
    \ to the user when an\n   ACK for the last bit is received.\n   When the packetizer\
    \ packetizes a letter it must see whether it is the\n   first piece of data being\
    \ sent on the connection, in which case it\n   must include the SYN bit. Some\
    \ implementations may not permit data to\n   be sent with SYN and others may discard\
    \ any data received with SYN.\n   The Packetizer goes to sleep if it finds no\
    \ more work at any TCB.\n"
- title: 4.4.5  OUTPUT PACKET HANDLER [see figure 2.5]
  contents:
  - "4.4.5  OUTPUT PACKET HANDLER [see figure 2.5]\n   When activated by the packetizer,\
    \ or the input packet handler, or\n   some of the user call routines, the Output\
    \ Packet Handler attempts to\n   transmit packets on the net (may involve going\
    \ through some other\n   network interface program). It looks at the TCB's in\
    \ turn,\n   transmitting some packets from the send packet queue. These are\n\
    \   dequeued and put on the retransmit queue along with the time when\n   they\
    \ should be retransmitted.\n   All data packets that are transmitted have the\
    \ latest receive left\n   window edge in the ACK field. Error and control messages\
    \ may have no\n   ACK [ACK bit off], or set the ACK field to refer to a received\n\
    \   packet's sequence number.\n   The RETRANSMIT PROCESS:\n   This process can\
    \ either be viewed as a separate process, or as part\n   of the output packet\
    \ handler. Its implementation can vary; it could\n   either perform its function,\
    \ by being woken up at regular intervals,\n   or when the retransmission time\
    \ occurs for every packet put on the\n   retransmit queue. In the first case the\
    \ retransmit queue for each TCB\n   is examined to see if there is anything to\
    \ retransmit. If there is, a\n   packet is placed on the send packet queue of\
    \ the corresponding TCB.\n   The output packet handler is also signaled.\n   Another\
    \ \"demon\" process monitors all user Send buffers and\n   retransmittable control\
    \ messages sent on each connection, but not yet\n   acknowledged. If the global\
    \ retransmission timeout is exceeded for\n   any of these, the User is notified\
    \ and he may choose to continue or\n   close the connection. A QUERY packet may\
    \ also be sent to ascertain\n   the state of the connection [this facilitates\
    \ recovery from half open\n   connections as described in section 4.3.3].\n"
- title: 4.4.6  USER CALL PROCESSING
  contents:
  - "4.4.6  USER CALL PROCESSING\n   OPEN [See figure 3.1]\n      1. If the process\
    \ calling does not own the specified local socket,\n      return with <type 1><ELP\
    \ 1 \"connection illegal for this process\">.\n      2. If no foreign socket is\
    \ specified, construct a new TCB and add\n      it to the list of existing TCB's.\
    \ Select a new local connection\n      name and return it along with <type 1><OLP\
    \ 0 \"success\">. If there\n      is no room for the TCB, respond with <type 1><ELT\
    \ 4 \"No room for\n      TCB\">.\n      3. If a foreign socket is specified, verify\
    \ that there is no\n      existing TCB with the same <local socket, foreign socket>\
    \ pair\n      (i.e. same connection), otherwise return <type l><ELP 6\n      \"\
    connection already open\">. If there is no TCB space, return as in\n      (2),\
    \ otherwise, create the TCB and link it with the others,\n      returning a local\
    \ connection name with the success event code.\n      Note: if a TCB is created,\
    \ be sure to copy the timeout parameter\n      into it, and set the \"U\" bit\
    \ to 0 if a foreign socket is\n      specified, else set U to 1 (to show unspecified\
    \ foreign socket).\n   SEND [see figure 3.2]\n      1. Search for TCB with local\
    \ connection name specified. If none\n      found, return <type 10><ELP 3 \"connection\
    \ not open\">\n      2. If TCB is found, check foreign socket specification. If\
    \ not set\n      (i.e. U = 1 in TCB), return <type 10><ELT 5 \"foreign socket\n\
    \      unspecified\">. If the connection is in the \"closing\" state (i.e.\n \
    \     state 5 or 6), return <type 3><ELP 12 \"connection closing\"> and do\n \
    \     not process the buffer.\n      3. Put the buffer on the Send buffer queue\
    \ and signal the\n      packetizer that there is work to do.\n   INTERRUPT [see\
    \ figure 3.3]\n      1. Validate existence of the referenced connection, sending\
    \ out\n      error messages of the form <type 3><ELP 3 \"connection not open\"\
    >\n      or <type 3><ELT 5 \"foreign socket unspecified\"> as appropriate. If\n\
    \      the local connection refers to a connection not accessible to the\n   \
    \   process interrupting, send <type 3><ELP 1 \"connection illegal for\n     \
    \ this process\">.\n      2. If the connection is in the \"closing\" state (i.e.\
    \ states 5 or\n      6), return <type 3><ELT 12 \"connection closing\"> and do\
    \ not send\n      an INT packet to the destination.\n      3. Any pending SEND\
    \ buffers should be returned with <type 10><ELP\n      10 \"buffer flushed due\
    \ to interrupt\">. An INT packet should be\n      created and placed on the output\
    \ packet queue, and the output\n      packet handler should be signaled.\n   RECEIVE\
    \ [See figure 3.4]\n      1. If the caller does not have access to the referenced\
    \ local\n      connection name, return <type 20><ELP 1 \"connection illegal for\n\
    \      this process\">. And if the connection is not open, return <type\n    \
    \  20><ELP 3 \"connection not open\"). If the connection is in the\n      closing\
    \ state (e.g. a FIN has been received or a user CLOSE is\n      being processed),\
    \ return <type 20><ELP 12 \"connection closing\">.\n      2. Otherwise, put the\
    \ buffer on the receive buffer queue and\n      signal the reassembler that buffer\
    \ space is available.\n   CLOSE [See figure 3.5]\n      1. If the connection is\
    \ not accessible to the caller, return <type\n      2><ELP 1 \"connection illegal\
    \ for this process\">. If there is no\n      such connection respond with <type\
    \ 2><ELP 3 \"connection not\n      open\">.\n      2. If the R bit is 0 (i.e.\
    \ connection is in state 1 or 2), simply\n      remove the TCB.\n      3. If the\
    \ R bit is set and the F bit is set, then remove the TCB.\n      4. Otherwise,\
    \ if the R bit is set, but F is 0 (i.e. states 3 or\n      4), return all buffers\
    \ to the User with <type x><ELP 12\n      \"connection closing\">, clear all output\
    \ and input packet queues\n      for this connection, create a FIN packet, and\
    \ signal the output\n      packet handler. Set the C and F bits to show this action.\n\
    \   STATUS [See figure 3.6]\n      1. If the connection is illegal for the caller\
    \ to access, send\n      <type 30><ELP 1 \"connection illegal for this process\"\
    >.\n      2. If the connection does not exist, return <type 30><ELP 3\n      \"\
    connection not open\">.\n      3. Otherwise set status information from the TCB\
    \ and return it via\n      <type 30><O-T 0 \"status data...\">.\n"
- title: 4.4.7  NETWORK CONTROL PROCESSING
  contents:
  - "4.4.7  NETWORK CONTROL PROCESSING\n   The Input Packet Handler examines the header\
    \ to see if there is any\n   control information or error codes present. We do\
    \ not discuss the\n   action taken for various special function codes, as it is\
    \ often\n   implementation dependent, but we describe those that affect the state\n\
    \   of the connection. After initial screening by the IPC [see section\n   4.4.2\
    \ and figure 2.2], control and error packets are processed as\n   shown in figures\
    \ 4.l-4.7. [ACK and data processing is done within the\n   IPC.]\n"
- title: 4.4.8  TCP ERROR HANDLING
  contents:
  - "4.4.8  TCP ERROR HANDLING\n   Error messages have CD=001 and do not carry user\
    \ data. Depending on\n   the error, zero or more octets of error information will\
    \ be carried\n   in the packet text field. We explicitly assume that this data\
    \ is\n   restricted in length so as to fall below the GATEWAY fragmentation\n\
    \   threshold (probably 512 bits of data and header). Errors generally\n   refer\
    \ to specific connections, so the source and destination socket\n   identifiers\
    \ are relevant here. The ACK field of an error packet\n   contains the sequence\
    \ number of the packet that caused the error, and\n   the ACK bit is off. [RESET\
    \ and STATUS special functions may use the\n   ACK field in the same way.] This\
    \ allows the receiver of an error\n   message to determine which packet caused\
    \ the error. Error packets are\n   not ACK'ed or retransmitted.\n"
- title: 4.5.  BUFFER AND WINDOW ALLOCATION
  contents:
  - '4.5.  BUFFER AND WINDOW ALLOCATION

    '
- title: 4.5.1  INTRODUCTION
  contents:
  - "4.5.1  INTRODUCTION\n   The TCP manages buffer and window allocation on connections\
    \ for two\n   main purposes: equitably sharing limited TCP buffer space among\
    \ all\n   connections (multiplexing function), and limiting attempts to send\n\
    \   packets, so that the receiver is not swamped (flow control function).\n  \
    \ For further details on the operation and advantages of the window\n   mechanism\
    \ see CEKA74.\n   Good allocation schemes are one of the hardest problems of TCP\n\
    \   design, and much experimentation must be done to develop efficient\n   and\
    \ effective algorithms. Hence the following suggestions are merely\n   initial\
    \ thoughts. Different implementations are encouraged with the\n   hope that results\
    \ can be compared and better schemes developed.\n   Several of the measurements\
    \ discussed in a later section are aimed at\n   providing information on the performance\
    \ of allocation mechanisms.\n   This should aid in determining significant parameters\
    \ and evaluating\n   alternate schemes.\n"
- title: 4.5.2 The SEND Side
  contents:
  - "4.5.2 The SEND Side\n   The window is determined by the receiver. Currently the\
    \ sender has no\n   control over the SEND window size, and never transmits beyond\
    \ the\n   right window edge. There exists the possibility of specifying two\n\
    \   more special function codes so that the sender can request the\n   receiver\
    \ to INCREASE or DECREASE the window size, without specifying\n   by how much.\
    \ The receiver, of course, needn't satisfy this request.\n   Buffers must be allocated\
    \ for outgoing packets from a TCP buffer\n   pool. The TCP may not be willing\
    \ to allocate a full window's worth of\n   buffers, so buffer space for a connection\
    \ may be less than what the\n   window would permit. No deadlocks are possible\
    \ even if there is\n   insufficient buffer or window space for one letter, since\
    \ the\n   receiver will ACK parts of letters as they are put into the user's\n\
    \   buffer, thus advancing the window and freeing buffers for the\n   remainder\
    \ of the letter.\n   It is not mandatory that the TCP buffer outgoing packets\
    \ until\n   acknowledgments for them are received, since it is possible to\n \
    \  reconstruct them from the actual letters sent by the user.\n   However, for\
    \ purposes of retransmission and processing efficiency it\n   is very convenient\
    \ to do.\n"
- title: 4.5.3  The RECEIVE Side
  contents:
  - "4.5.3  The RECEIVE Side\n   At the receiving side there are two requirements\
    \ for buffering:\n   (l) Rate Discrepancy:\n      If the sender produces data\
    \ much faster or much slower than the\n      receiver consumes it, little buffering\
    \ is needed to maintain the\n      receiver at near maximum rate of operation.\
    \ Simple queuing\n      analysis indicates that when the production and consumption\n\
    \      (arrival and service) rates are similar in magnitude, more\n      buffering\
    \ is needed to reduce the effect of stochastic or bursty\n      arrivals and to\
    \ keep the receiver busy.\n   (2) Disorderly Arrivals:\n      When packets arrive\
    \ out of order, they must be buffered until the\n      missing packets arrive\
    \ so that packets (or letters) are delivered\n      in sequence. We do not advocate\
    \ the philosophy that they be\n      discarded, unless they have to be, otherwise\
    \ a poor effective\n      bandwidth may be observed. Path length, packet size,\
    \ traffic\n      level, routing, timeouts, window size, and other factors affect\n\
    \      the amount by which packets come out of order. This is expected to\n  \
    \    be a major area of investigation.\n   The considerations for choosing an\
    \ appropriate window are as follows:\n   Suppose that the receiver knows the sender's\
    \ retransmission timeout,\n   also, that the receiver's acceptance rate is 'U'\
    \ bits/sec, and the\n   window size is 'W' bits. Ignoring line errors and other\
    \ traffic, the\n   sender transmits at a rate between W/K and the maximum line\
    \ rate (the\n   sender can send a window's worth of data each timeout period).\n\
    \   If W/K is greater than U, the difference must be retransmissions\n   which\
    \ is undesirable, so the window should be reduced to W', such\n   that W'/K is\
    \ approximately equal to U. This may mean that the entire\n   bandwidth of the\
    \ transmission channel is not being used, but it is\n   the fastest rate at which\
    \ the receiver is accepting data, and the\n   line capacity is free for other\
    \ users. This is exactly the same case\n   where the rates of the sender and receiver\
    \ were almost equal, and so\n   more buffering is needed. Thus we see that line\
    \ utilization and\n   retransmissions can be traded off against buffering.\n \
    \  If the receiver does not accept data fast enough (by not performing\n   sufficient\
    \ RECEIVES) the sender may continue retransmitting since\n   unaccepted data will\
    \ not be ACK'ed. In this case the receiver should\n   reduce the window size to\
    \ \"throttle\" the sender and inhibit useless\n   retransmissions.\n   Receiver\
    \ window control:\n      If the user at the receiving side is not accepting data,\
    \ the\n      window should be reduced to zero. In particular, if all TCP\n   \
    \   incoming packet buffers for a connection are filled with received\n      packets,\
    \ the window must go to zero to prevent retransmissions\n      until the user\
    \ accepts some packets.\n      Short term flow control:\n      Let F = the number\
    \ of user receive buffers filled\n         B = the total user receive buffers\n\
    \         W = the long-term or nominal window size\n         W' = the window size\
    \ returned to the sender\n      then a possible value for W' is\n         W' =\
    \ W*[1-F/B]**a\n      The value of 'a' should be greater than one, in order to\
    \ shut the\n      window faster as buffers run out. The values of W' and F actually\n\
    \      used could be averages of recent values, in order to get smooth\n     \
    \ control. Note that W' is constantly being recomputed, while the\n      value\
    \ of W, which sets the upper limit of W', only changes slowly\n      in response\
    \ to other factors.\n      The value of W can be large (up to half the sequence\
    \ number space)\n      to allow for good throughput on high delay channels. The\
    \ sender\n      needn't allocate W worth of buffer space anyway. The long-term\n\
    \      variation of W to match flow requirements may be a separate\n      question\n\
    \   This short-term mechanism for flow control allows some buffering in\n   the\
    \ two TCP's at either end, (as much as they are willing), and the\n   rest in\
    \ the user process at the send side where the data is being\n   created. Hence\
    \ the cost of buffering to smooth out bursty traffic is\n   borne partly by the\
    \ TCP's, and partly by the user at the send side.\n   None of it is borne by the\
    \ communication subnet.\n"
- title: 5.  NETWORK MEASUREMENT PLANS FOR TCP
  contents:
  - '5.  NETWORK MEASUREMENT PLANS FOR TCP

    '
- title: 5.1  USERLEVEL DIAGNOSTICS
  contents:
  - "5.1  USERLEVEL DIAGNOSTICS\n   We have in mind a program which will exercise\
    \ a given TCP, causing it\n   to cycle through a number of states; opening, closing,\
    \ and\n   transmitting on a variety of connections. This program will collect\n\
    \   statistics and will generally try to detect deviation from TCP\n   functional\
    \ specifications. Clearly there will have to be a copy of\n   this program both\
    \ at the local site being tested and some site which\n   has a certified TCP.\
    \ So we will have to produce a specification for\n   this user level diagnostic\
    \ program also.\n   There needs to be a master and a slave side to all this so\
    \ the master\n   can tell the slave what's going wrong with the test.\n"
- title: 5.2  SINGLE CONNECTION MEASUREMENTS
  contents:
  - "5.2  SINGLE CONNECTION MEASUREMENTS\n   Round trip delay times\n      Time from\
    \ moment the packet is sent by the TCP to the time that\n      the ACK is received\
    \ by the TCP.\n      Time from the moment the USER issues the SEND to the time\
    \ that the\n      USER gets the successful return code.\n         Note: packet\
    \ size should be used to distinguish from one set of\n         round trip times\
    \ and another.\n         Network destination, and current configuration and traffic\
    \ load\n         may also be issues of importance that must be taken into\n  \
    \       account.\n         What if the destination TCP decides to queue up ACKs\
    \ and send a\n         single ACK after a while? How does this affect round trip\n\
    \         statistics?\n         What about out of order arrivals and the bunched\
    \ ACK for all of\n         them?\n         The histogram of round trip times include\
    \ retransmission times\n         and these must be taken into account in the analysis\
    \ and\n         evaluation of the collected data.\n         Packet size statistics\n\
    \      Histogram of packet length in both directions on the full duplex\n    \
    \  connection.\n      Histogram of letter size in both directions.\n   Measure\
    \ of disorderly arrival\n      Distance from the first octet of arriving packet\
    \ to the left\n      window edge. A histogram of this measure gives an idea of\
    \ the out\n      of order nature of packet arrivals. It will be 0 for packets\n\
    \      arriving in order.\n   Retransmission Histogram\n   Effective throughput\n\
    \      This is the effective rate at which the left edge of the window\n     \
    \ advances. The time interval over which the measure is made is a\n      parameter\
    \ of the measurement experiment. The shorter the interval,\n      the more bursty\
    \ we would expect the measure to be.\n      It is possible to measure effective\
    \ data throughput in both\n      directions from one TCP by observing the rate\
    \ at which the left\n      window edge is moving on ACK sent and received for\
    \ the two\n      windows.\n      Since throughput is largely dependent upon buffer\
    \ allocation and\n      window size, we must record these values also. Varying\
    \ window for\n      a fixed file transmission might be a good way to discover\
    \ the\n      sensitivity of throughput to window size.\n   Output measurement\n\
    \      The throughput measurement is for data only, but includes\n      retransmission.\
    \ The output rate should include all octets\n      transmitted and will give a\
    \ measure of retransmission overhead.\n      Output rate also includes packet\
    \ format overhead octets as well as\n      data.\n   Utilization\n      The effective\
    \ throughput divided by the output rate gives a\n      measure of utilization\
    \ of the communication connection.\n   Window and buffer allocation measurements\n\
    \      Histogram of letters outstanding, measured at the instant of SEND\n   \
    \   receipt by TCP from user or at instant of arrival of a letter for\n      a\
    \ receiving user.\n      Buffers in use on the SEND side upon packet departure\
    \ into the\n      net; buffers in use on the RECEIVE side upon delivery of packet\n\
    \      into a USER Buffer.\n"
- title: 5.3  MULTICONNECTION MEASUREMENTS
  contents:
  - "5.3  MULTICONNECTION MEASUREMENTS\n   Statistics on User Commands sent to the\
    \ local TCP\n   Statistics of error or success codes returned [histogram of each\
    \ type\n   of error or return response]\n   Statistics of control bit use\n  \
    \    Counter for each control bit over all packets emitted by the TCP\n      and\
    \ another for packets accepted\n   Count data carrying packets\n   Count ACK packets\
    \ with no data\n   Error packets distribution by error type code received from\
    \ the net\n   and sent out into the net\n"
- title: 5.4  MEASUREMENT IMPLEMENTATION PHILOSOPHY
  contents:
  - "5.4  MEASUREMENT IMPLEMENTATION PHILOSOPHY\n   We view the measurement process\
    \ as something which occurs internal to\n   the TCP but which is controllable\
    \ from outside. A well known socket\n   owned by the TCP can be used to accept\
    \ control which will select one\n   or more measurement classes to be collected.\
    \ The data would be\n   periodically sent to a designated foreign socket which\
    \ would absorb\n   the data for later processing, in the manner currently used\
    \ in the\n   ARPANET IMPs. Each measurement class has its own data packet format\n\
    \   to make the job of parsing and analyzing the data easier.\n   We would restrict\
    \ access to TCP measurement control to a few\n   designated sites [e.g. NMC, SU-DSL,\
    \ BBN]. This is easily done by\n   setting up listening control connections on\
    \ partially specified\n   foreign sockets.\n"
- title: 6.  SCHEDULE OF IMPLEMENTATION
  contents:
  - '6.  SCHEDULE OF IMPLEMENTATION

    '
- title: 7.  REFERENCES
  contents:
  - "7.  REFERENCES\n   1. CEKA74\n      V. Cerf and R. Kahn, \"A Protocol For Packet\
    \ Network\n      Intercommunication,\" IEEE Transactions on Communication, vol.\
    \ C-\n      2O, No. 5. May 1974, pp. 637-648.\n   2. CERF74\n      V. Cerf, \"\
    An Assessment of ARPANET Protocols,\" in Proceedings of\n      the Jerusalem Conference\
    \ on Information Technology, July l974\n      [RFC#635, INWG Note # ***].\n  \
    \ 3.CESU74\n      V. Cerf and C. Sunshine, \"Protocols and Gateways for the\n\
    \      Interconnection of Packet Switching Networks,\" Proc. of the\n      Subconference\
    \ on Computer Nets, Seventh Hawaii International\n      Conference on Systems\
    \ Science, January 1974.\n   4. HEKA70\n      F. Heart, R.E. Kahn, et al, \"The\
    \ Interface Message Processor for\n      the ARPA Computer Network,\" AFIPS 1970\
    \ SJCC Proceedings, vol. 36,\n      Atlantic City, AFIPS Press, New Jersey, pp.\
    \ 551-567.\n   5. POUZ74\n      L. Pouzin, \"CIGALE, the packet switching machine\
    \ of the CYCLADES\n      computer network,\" Proceedings of the IFIP74 Congress,\
    \ Stockholm,\n      Sweden.\n   6. ROWE74\n      L. Roberts and B. Wessler, \"\
    Computer Network Development to\n      achieve resource sharing,\" AFIPS 1970,\
    \ SJCC Proceedings, vol. 36,\n      Atlantic City, AFIPS Press, New Jersey, pp.\
    \ 543-549.\n   7. POUZ73\n      L. Pouzin, \"Presentation and major design aspects\
    \ of the CYCLADES\n      Computer Network,\" Data Networks: Analysis and Design,\
    \ Third Data\n      Communications Symposium, St. Petersburg, Florida, November\
    \ 1973,\n      pp. 80-87.\n   8. SCWI71\n      R. Scantlebury and P.T. Wilkinson,\
    \ \"The Design of a Switching\n      System to allow remote Access to Computer\
    \ Services by other\n      computers and Terminal Devices,\" Second Symposium\
    \ on Problems in\n      the Optimization of Data Communication Systems Proceedings,\
    \ Palo\n      Alto, California, 0ctober 1971, pp. 160-167.\n   9. POST72\n   \
    \   J. Postel, \"Official Initial Connection Protocol,\" Current Network\n   \
    \   Protocols, Network Information Center, Stanford Research\n      Institute,\
    \ Menlo Park, California. January 1972 (NIC 7101).\n   10. CACR70\n      C.S.\
    \ Carr, S.D. Crocker, and V.G. Cerf, \"Host-Host Communication\n      Protocol\
    \ in the ARPA Network,\" AFIPS Conference Proceedings, vol.\n      36, 1970 SJCC,\
    \ AFIPS Press, Montvale, N.J.\n   11. ZIEL74\n      H. Zimmerman and M. Elie,\
    \ \"Transport Protocol. Standard Host-Host\n      Protocol for heterogeneous computer\
    \ networks,\" INWG#61, April\n      1974.\n   12. CRHE72\n      S. D. Crocker,\
    \ J. F. Heafner, R. M. Metcalfe and J. B. Postel,\n      \"Function-oriented protocols\
    \ for the ARPA Computer Network,\" AFIPS\n      Conference Proceedings, vol. 41,\
    \ 1972 FJCC, AFIPS Press, Montvale,\n      N.J.\n   13. DALA74\n      Y. Dalal,\
    \ \"More on selecting sequence numbers,\" INWG Protocol Note\n      #4, October\
    \ 1974.\n   14. SUNS74\n      C. Sunshine, \"Issues in communication protocol\
    \ design -- formal\n      correctness.\" INWG Protocol Note #5, October 1974\n\
    \   BELS74\n      D. Belsnes, \"Note on single message communication,\" INWG Protocol\n\
    \      Note #3. September 1974.\n   16. TOML74\n      R. Tomlinson, \"Selecting\
    \ sequence numbers,\" INWG Protocol Note #2,\n      September 1974.\n   17. SCHA74\n\
    \      R. Schantz, \"Reconnection Protocol\", private communication;\n      available\
    \ from Schantz at BBN.\n   18. POUZ74A\n      L. Pouzin, \"A proposal for interconnecting\
    \ packet switching\n      networks, INWG Note #60, March 1974 [also submitted\
    \ to EUROCOMP\n      74].\n   19. DLMG74\n      D. Lloyd, M. Galland, and P. T.\
    \ Kirstein, \"Aims and objectives of\n      internetwork experiments,\" to be\
    \ published as an INWG Experiments\n      Note.\n   20. MCKE73\n      A. McKenzie,\
    \ \"Host-Host Protocol for the ARPANET,\" NIC # 8246,\n      Stanford Research\
    \ Institute [also in ARPANET Protocols Notebook\n      NIC 7104].\n   21. BELS74A\n\
    \      D. Belsnes, \"Flow control in packet switching networks,\" INWG Note\n\
    \      #63, October 1974.\n"
- title: 'FIGURE 1: TCB Major States'
  contents:
  - "FIGURE 1: TCB Major States\n                              0-no TCB\n      \\\
    ____________________________________________________________/\n              \
    \         OPEN    |    A   CLOSE           CLOSE    A\n                    ----------\
    \ |    | ----------      ---------- |\n                    set up TCB |    | remove\
    \ TCB      remove TCB |\n                               |    |               \
    \             |\n                               |    |       collision retry,\
    \     |\n        SYN arrives          __V____|__       SEND, INTER        |\n\
    \       -------------        / S1=0     \\    ----------------     |\n       send\
    \ SYN, ACK       |  S2=0 F=0  |       send SYN         |\n     ______________________|\
    \  R=0  C=0  |_____________________   |\n    |                      |  U=0/1 \
    \    |                     |  |\n    |                      |            |   SYN\
    \ arrives       |  |\n    |      error,timeout   |   1-OPEN   |   -----------\
    \       |  |\n    |      -------------    \\__________/    collision;        |\
    \  |\n    |        clear TCB         A    A       set timeout       |  |\n   \
    \ |     _____________________|    |_____________________    |  |\n  __V____|__\
    \                                             _|___V__|_\n / S1=1     \\     \
    \                                      / S1=1     \\\n"
- title: '|  S2=0 F=0  |                                         |  S2=0 F=0  |'
  contents:
  - '|  S2=0 F=0  |                                         |  S2=0 F=0  |

    '
- title: '|  R=1  C=0  |                       SYN, ACK arrives  |  R=0  C=0  |'
  contents:
  - '|  R=1  C=0  |                       SYN, ACK arrives  |  R=0  C=0  |

    '
- title: '|  U=0/1     |  ACK arrives          ----------------  |  U=0       |'
  contents:
  - '|  U=0/1     |  ACK arrives          ----------------  |  U=0       |

    '
- title: '|            |  -----------              send ACK      |            |'
  contents:
  - '|            |  -----------              send ACK      |            |

    '
- title: '| 3-SYN rcvd |_________________       _________________| 2-SYN sent |'
  contents:
  - "| 3-SYN rcvd |_________________       _________________| 2-SYN sent |\n \\__________/\
    \                  |     |                  \\__________/\n    |             \
    \           __V_____V__\n    |                       / S1=1      \\\n    |  CLOSE\
    \               |  S2=1 F=0   |\n    | --------             |  R=1  C=0   |  \
    \   FIN arrives\n    | send FIN             |  U=0        | -------------------\n\
    \    |                      |             | tell user, send FIN\n    |      ________________|4-established|______________________\n\
    \    |     |    CLOSE        \\___________/                       |\n    |   \
    \  |   -------                                           |\n  __V_____V_  send\
    \ FIN                                   _______V__\n / S1=1     \\           \
    \                                / S1=1     \\\n"
- title: '| S2=0/1 F=1 |     timeout or                          |  S2=1 F=1  |'
  contents:
  - '| S2=0/1 F=1 |     timeout or                          |  S2=1 F=1  |

    '
- title: '|  R=1   C=1 | FIN, error, arrives            CLOSE    |  R=1  C=0  |'
  contents:
  - '|  R=1   C=1 | FIN, error, arrives            CLOSE    |  R=1  C=0  |

    '
- title: '|  U=0/1     | -------------------          ---------- |  U=0       |'
  contents:
  - '|  U=0/1     | -------------------          ---------- |  U=0       |

    '
- title: '|            |     remove TCB               remove TCB |            |'
  contents:
  - '|            |     remove TCB               remove TCB |            |

    '
- title: '| 5-FIN wait |_____________________       _____________| 6-FIN rcvd |'
  contents:
  - "| 5-FIN wait |_____________________       _____________| 6-FIN rcvd |\n \\__________/\
    \                      |     |              \\__________/\n                  \
    \                 |     |\n       ____________________________V_____V_______________________\n\
    \      /                                                          \\\n       \
    \                           0-no TCB\n"
- title: 'FIGURE 2.1: Structure of the TCP'
  contents:
  - "FIGURE 2.1: Structure of the TCP\n      |       _____________            _______________\
    \       |\n      |      |             |          |               |      |\n  \
    \    |      |             |          | INPUT PACKET  |<---->|\n      |      |\
    \ REASSEMBLER |          |    HANDLER    |      |\n      |      |_____________|\
    \          |_______________|      |\n      |             |_______________    \
    \      |              |\n      |                             |         |     \
    \         |\n      |       _________             |         |              |\n\
    \      |      |         |          __V_________V____          |  NETWORK\n   \
    \   |<=====| SYSTEM  |         |                 |         |    or\n      |  \
    \    |  CALLS  |<========|       TCB's     |<========|   some\n"
- title: USERS |=====>|   or    |         |        and      |         |  NETWORK
  contents:
  - "USERS |=====>|   or    |         |        and      |         |  NETWORK\n   \
    \   |      |  USER   |========>|ASSOCIATED QUEUES|========>| INTERFACE\n     \
    \ |<---->|INTERFACE|         |_________________|         |  PROGRAM\n      | \
    \     |_________|            A         A              |\n      |             \
    \                |         |              |\n      |               ______________|\
    \         |              |\n      |       _______|_____            _______|_______\
    \       |\n      |      |             |          |               |      |\n  \
    \    |      | PACKETIZER  |          | OUTPUT PACKET |      |\n      |      |\
    \             |          |    HANDLER    |<---->|\n      |      |_____________|\
    \          |_______________|      |\n      |                                 \
    \                     |\n     =======> Logical or physical flow of data (packets/letters)\n\
    \     -------> \"Interaction\"\n     NOTE:    The signalling of processes by others\
    \ is not shown\n"
- title: 'FIGURE 2.2a:                               ________'
  contents:
  - 'FIGURE 2.2a:                               ________

    '
- title: Address Check                             / Begin  \
  contents:
  - "Address Check                             / Begin  \\\n                     \
    \                     \\________/\n                                          \
    \     |\n                                              _V_\n                 \
    \                          .'     '.\n                                       \
    \  .' packet  '.\n                                       .'   foreign   '.\n \
    \                 ___________________.'  socket matches '.\n                 |\
    \                no  '.  a TCB local  .'\n                 |                 \
    \     '.   socket  .'\n                 |                        '.   ?   .'\n\
    \                 |                          '.___.'\n                 |     \
    \                        | yes\n                 |                           \
    \ _V_\n                 |                         .'     '.\n                \
    \ |                       .' packet  '.           ___\n                 |    \
    \                 .'local socket '.        /   \\\n                 |        \
    \           .'  matches fully  '.____\\| YES |\n                 |           \
    \         '. specified TCB .'     / \\___/\n                 |               \
    \       '.fgn socket .'\n                 |                        '.   ?   .'\n\
    \                _V_                         '.___.'\n             .'     '. \
    \                        | no\n           .'   SYN,  '.                      _V_\n\
    \         .'FIN,INT,DSN, '.                 .'     '.\n  _____.'or text length>0\
    \ './_____       .' matches '.\n |  no  '.   or QUERY    .' \\     |    .'partly\
    \ spec. '.\n |        '.           .'         |___.'  or unspec. TCB '.\n |  \
    \        '.   ?   .'            no  '.     foreign   .'\n |            '.___.'\
    \                  '.   socket  .'\n |               | yes                   '.\
    \   ?   .'\n |     __________V_________                 '.___.'\n |    |     \
    \               |                   | yes\n |    |   Create error 7   |      \
    \            _V_\n |    | packet. Signal OPH |               .'     '.\n |   \
    \ |____________________|             .' packet  '.\n |               |       \
    \        ______.' has SYN set '.\n |           ____V____          |   no  '. \
    \          .'\n |          |         |         |         '.   ?   .'\n |_________\\\
    | discard |/________|          '.___.'\n           /|_________|\\            \
    \          |\n                 |                           _V_\n             \
    \   _V_                         /   \\\n               /   \\                \
    \       | YES |\n              | NO  |                       \\___/\n        \
    \       \\___/\n"
- title: 'FIGURE 2.2b-1:                         _______'
  contents:
  - 'FIGURE 2.2b-1:                         _______

    '
- title: Input Packet Handler                  / Begin \
  contents:
  - "Input Packet Handler                  / Begin \\\n                          \
    \            \\_______/\n                                          |\n ________________________________________\\\
    |/_________________________\n"
- title: '|                              A         /|\                         |'
  contents:
  - '|                              A         /|\                         |

    '
- title: '|                              |          |                          |'
  contents:
  - '|                              |          |                          |

    '
- title: '|                              |         _V_                         |'
  contents:
  - '|                              |         _V_                         |

    '
- title: '|                              |       .''   ''.          _______      |'
  contents:
  - '|                              |       .''   ''.          _______      |

    '
- title: '|                              |     .'' input ''.       | go to |     |'
  contents:
  - '|                              |     .'' input ''.       | go to |     |

    '
- title: '|                              |   .''  packet   ''.____\| sleep |     |'
  contents:
  - '|                              |   .''  packet   ''.____\| sleep |     |

    '
- title: '|                              |    ''.available.''  no /|_______|     |'
  contents:
  - '|                              |    ''.available.''  no /|_______|     |

    '
- title: '|                              |      ''.__?__.''                      |'
  contents:
  - '|                              |      ''.__?__.''                      |

    '
- title: '|                              |          | yes                      |'
  contents:
  - '|                              |          | yes                      |

    '
- title: '|                              |         _V_                         |'
  contents:
  - '|                              |         _V_                         |

    '
- title: '|                              |       .''   ''.                       |'
  contents:
  - '|                              |       .''   ''.                       |

    '
- title: '|   .->SPECIAL FUNCT. Fig 4.7  |     .''address''.                     |'
  contents:
  - '|   .->SPECIAL FUNCT. Fig 4.7  |     .''address''.                     |

    '
- title: '|   | .->ERR Fig 4.5,4.6       |___.'' check OK  ''.                   |'
  contents:
  - '|   | .->ERR Fig 4.5,4.6       |___.'' check OK  ''.                   |

    '
- title: '|   | | .->SYN Fig 4.1,4.2      no  ''.    ?    .''                    |'
  contents:
  - '|   | | .->SYN Fig 4.1,4.2      no  ''.    ?    .''                    |

    '
- title: '|   | | | .->INT Fig 4.3              ''._____.''                      |'
  contents:
  - '|   | | | .->INT Fig 4.3              ''._____.''                      |

    '
- title: '|   | | | | .->FIN Fig 4.4                | yes              ________|_'
  contents:
  - '|   | | | | .->FIN Fig 4.4                | yes              ________|_

    '
- title: '|   | | | | |                            _V_                | discard  |'
  contents:
  - '|   | | | | |                            _V_                | discard  |

    '
- title: '|  _|_|_|_|_|___________               .''   ''.              |(or queue)|'
  contents:
  - '|  _|_|_|_|_|___________               .''   ''.              |(or queue)|

    '
- title: '|  |                    |            .'' error ''.            |__________|'
  contents:
  - '|  |                    |            .'' error ''.            |__________|

    '
- title: '|<-| Control Processing |/_________.''or control ''.                   A'
  contents:
  - "|<-| Control Processing |/_________.'or control '.                   A\n   |____________________|\\\
    \     yes  '.    ?    .'                    |\n        |                     \
    \        '._____.'                      |\n        | (INT with data)         \
    \        | no                       |\n        |                             \
    \    |                          |\n        V                                _V_\
    \                         |\n      to \"X\"                           .'   '.\
    \              .        |\n  in Fig 2.2b-2                      .'(estab)'.  \
    \        .' '.      |\n                              _____.' R=S1=S2=1 '.----->.'seq.#'.--->|\n\
    \                             | yes  '.    ?    .'  no    '.OK .'  no |\n    \
    \                         |        '._____.'            '.'       |\n        \
    \                     |                              | yes    |\n            \
    \                 |    _______________           |        |\n                \
    \             |   | Set S2=1, U=0 |          V        |\n                    \
    \         |   | Notify user   |         .'.       |\n                        \
    \     |<--| with event 2  |       .'ACK'.     |\n                            \
    \ |   | if U was 1    |<-----'.  OK .'--->'\n                             |  \
    \ |_______________|  yes   '. .'   no\n                             |        \
    \                      '\n                             V\n                   \
    \        to \"Y\"\n                       in Fig 2.2b-2\n"
- title: 'FIGURE 2.2b-2: Input Packet Handler (continued)'
  contents:
  - "FIGURE 2.2b-2: Input Packet Handler (continued)\n                           \
    \ \"Y\"\n                             |\n           .'.              _V_\n   \
    \      .'txt'.          .'   '.        ______________________________\n      \
    \ .'lgth>0 '.      .'within '.     |Use ACK to advance send window|\n"
- title: ',<----''. or DSN  .''<---''. window  .''--->|Release ACK''ed packets from   |'
  contents:
  - ',<----''. or DSN  .''<---''. window  .''--->|Release ACK''ed packets from   |

    '
- title: '|  no   ''.  ?  .''   no   ''.  ?  .''  yes |retransmit or send queues.
    If |'
  contents:
  - '|  no   ''.  ?  .''   no   ''.  ?  .''  yes |retransmit or send queues. If |

    '
- title: '|         ''._.''            ''._.''        |any packet had EB bit set     |'
  contents:
  - '|         ''._.''            ''._.''        |any packet had EB bit set     |

    '
- title: '|           | yes                       |remove buffer from Packetized |'
  contents:
  - '|           | yes                       |remove buffer from Packetized |

    '
- title: '|   ________V____________________       |buffer queue and inform user  |'
  contents:
  - '|   ________V____________________       |buffer queue and inform user  |

    '
- title: '|  |Create ACK packet. Put on    |      |(success). Signal Packetizer. |'
  contents:
  - '|  |Create ACK packet. Put on    |      |(success). Signal Packetizer. |

    '
- title: '|<-|Send packet queue. Signal OPH|      |______________________________|'
  contents:
  - '|<-|Send packet queue. Signal OPH|      |______________________________|

    '
- title: '|  |_____________________________|                      |'
  contents:
  - '|  |_____________________________|                      |

    '
- title: '|                                                       |'
  contents:
  - '|                                                       |

    '
- title: '|          _____________________________________________|'
  contents:
  - '|          _____________________________________________|

    '
- title: '|         |'
  contents:
  - '|         |

    '
- title: '|         |'
  contents:
  - '|         |

    '
- title: '|         |                      "X"'
  contents:
  - '|         |                      "X"

    '
- title: '|         |                       |'
  contents:
  - '|         |                       |

    '
- title: '|        _V_                     _V_              _____________________'
  contents:
  - '|        _V_                     _V_              _____________________

    '
- title: '|      .''   ''.                 .''TCB''.           |Put packet on        |'
  contents:
  - '|      .''   ''.                 .''TCB''.           |Put packet on        |

    '
- title: '|    .'' text  ''.   yes       .''Receive''.   yes   |Receive packet queue
    |'
  contents:
  - '|    .'' text  ''.   yes       .''Receive''.   yes   |Receive packet queue |

    '
- title: '|  .'' length>0  ''.-------->.''  buffer   ''.------>|in the right order.  |'
  contents:
  - '|  .'' length>0  ''.-------->.''  buffer   ''.------>|in the right order.  |

    '
- title: '|   ''. or DSN  .''   A       ''.available.''        |Signal Reassembler.  |'
  contents:
  - '|   ''. or DSN  .''   A       ''.available.''        |Signal Reassembler.  |

    '
- title: '|     ''.  ?  .''     |         ''.  ?  .''          |_____________________|'
  contents:
  - '|     ''.  ?  .''     |         ''.  ?  .''          |_____________________|

    '
- title: '|       ''._.''       |           ''._.''                           |'
  contents:
  - '|       ''._.''       |           ''._.''                           |

    '
- title: '|         | no      |             | no                          |'
  contents:
  - '|         | no      |             | no                          |

    '
- title: '|         |         |            _V_                            |'
  contents:
  - '|         |         |            _V_                            |

    '
- title: '|________\|         |          .''   ''.                          |'
  contents:
  - "|________\\|         |          .'   '.                          |\n        \
    \ /|         |        .' seq # '.         ________       |\n          |      \
    \   |      .' of packet '.  yes |Discard |      |\n          |         |     '.\
    \  highest so .'---->|packet  |----->|\n          |         |       '.   far \
    \  .'       |________|      |\n          |         |         '.  ?  .'       \
    \                  |\n          |         |           '._.'                  \
    \         |\n          |         |             | no                          |\n\
    \          |         |      _______V______________               |\n         \
    \ |         |     |Discard packet with   |              |\n          |       \
    \  |_____|highest seq. no from  |              |\n          |               |Receive\
    \ packet queue. |              |\n          |               |______________________|\
    \              |\n          |                                                \
    \     |\n          |_____________________________________________________|\n \
    \                                 |\n                                  V\n   \
    \                   to \"Begin\" in Fig 2.2b-1\n"
- title: 'FIGURE 2.3-1: Reassembler'
  contents:
  - "FIGURE 2.3-1: Reassembler\n       _______\n      / Begin \\\n      \\_______/\n\
    \          |\n          |\n          |<----------------------------------------------.\n\
    \          |                      _____                    | yes\n    ______V_____\
    \               .'     '.                 _|_\n   |Get ready   |            .'\
    \ Receive '.   yes       .'any'.\n   |for next TCB|--------->.'Packet Queue '.-------->.'\
    \ more  '.\n   |____________|     A     '.  empty ?  .'     A     '.work?.'\n\
    \                      |       '._______.'       |       '._.'\n             \
    \         |            | no         |         | no\n   \"R\"------>---------'\
    \          __V__          |     ____V____\n                               .' is\
    \  '.        |    |  Go to  |\n                             .' packet  '.    \
    \  |    |  Sleep  |\n  .--<----------------------'.DSN with no.'     |    |_________|\n\
    \  |                     yes   '. data? .'       |\n  |                      \
    \       '.___.'         |\n  |                                | no         |\n\
    \  |                              __V__          |\n  |                      \
    \      .'     '.        |\n  |                          .' Receive '.  yes |\n\
    \  |                        .'Buffer Queue '.--->|\n  |                      \
    \   '.  empty ?  .'     |\n  |  ________________         '._______.'       |\n\
    \  | |Copy from packet|             | no         |<-------------\"S\"\n  | |to\
    \ buffer until |           __V__          |\n  | |one is exhausted|         .'First'.\
    \        |\n  | |Update receive  | yes   .' packet  '.   no |\n  | |window.  \
    \       |<----.'matches Recv '.--->'\n  | |________________|      '.left window.'\n\
    \  |         |                 '. edge ?.'\n  |       __V__                 '.___.'\n\
    \  |     .'Send '.\n  |   .' Packet  '.   yes  _____________________________\n\
    \  | .' Queue empty '.---->|Create ACK packet containing |\n  |  '.     ?    \
    \ .'      |new window. Signal OPH.      |\n  |    '._______.'        |_____________________________|\n\
    \  |      no |                            |\n  |         |                   \
    \         |\n  |         '--------------------------->|\n  |                 \
    \                     |\n  V                                      V\n"
- title: to "T"                                 to "U"
  contents:
  - 'to "T"                                 to "U"

    '
- title: in Fig 2.3-2                        in Fig 2.3-2
  contents:
  - 'in Fig 2.3-2                        in Fig 2.3-2

    '
- title: 'FIGURE 2.3-2:  Reassembler (continued)'
  contents:
  - "FIGURE 2.3-2:  Reassembler (continued)\n     \"T\"                          \
    \      \"U\"\n      |                                  |\n      |            \
    \                      |           _____________\n   ___V____           ___  \
    \            __V__        |Mark progress|\n  |process |  yes   .'   '.    yes\
    \   .'whole'.  no  |in packet.   |\n  |  DSN   |<-----.'  DSN  '.<-----.' packet\
    \  '.--->|Return buffer|--->.\n  |________|       '. set?.'        '.copied?.'\
    \     |to user.     |    |\n      |              '._.'            '.___.'    \
    \   |_____________|    |\n      |                | no                        \
    \                    |\n      '--------------->|                             \
    \                  |\n                       |                               \
    \                |\n                     __V__              __________________________\
    \     |\n                   .' EOL '.  yes      |Return buffer to user.    | \
    \   |\n                  '.  set? .'--------->|Return packet to free     |--->|\n\
    \                    '.___.'            |storage. Signal Packetizer|    |\n  \
    \                  no |               |__________________________|    |\n    \
    \                   |                   A                           |\n      \
    \               __V__                 |                           |\n        \
    \           .' full'.               |                           |\n          \
    \        '. buffer.'--------------'                           |\n            \
    \        '.___.'   yes                                      |\n              \
    \         | no                                            |\n                \
    \       |                                               |\n    ___________________V__________________\
    \                             |\n   |Mark progress in buffer. Return packet| \
    \                           |\n   |to free storage. Signal Packetizer.   |   \
    \                ,--------'\n   |______________________________________|     \
    \              |\n                       |                                   \
    \   |\n                       |                                      |\n     \
    \                  V                                      V\n              to\
    \ \"R\" in Fig 2.3-1                    to \"S\" in Fig 2.3-1\n"
- title: 'FIGURE 2.4: Packetizer'
  contents:
  - "FIGURE 2.4: Packetizer\n    _______               ________________________\n\
    \   / Begin \\____________\\| Get ready for next TCB |/___________________\n \
    \  \\_______/            /|________________________|\\                   |\n \
    \                                     |                                |\n   \
    \                                 __V__               _____          |\n     \
    \                             .'Send '.           .' any '.        |\n       \
    \                     no  .' Buffer  '.  yes  .'  more   '.  yes |\n         \
    \        .-------------'.   Queue   .'---->'.   work    .'-----'\n           \
    \      |               '.empty? .'   A     '.   ?   .'\n     ____________V____________\
    \     '.___.'     |       '.___.'\n    |Pick packet size depend- |           \
    \     |          | no\n"
- title: ',-->|ing on send buffer, TCB  |                |    ______V______'
  contents:
  - ',-->|ing on send buffer, TCB  |                |    ______V______

    '
- title: '|   |buffer space, window, etc|                |   | go to sleep |'
  contents:
  - '|   |buffer space, window, etc|                |   | go to sleep |

    '
- title: '|   |_________________________|                |   |_____________|'
  contents:
  - '|   |_________________________|                |   |_____________|

    '
- title: '|                |                             |'
  contents:
  - '|                |                             |

    '
- title: '|              __V__                           |'
  contents:
  - '|              __V__                           |

    '
- title: '|            .''Send ''.                         |'
  contents:
  - '|            .''Send ''.                         |

    '
- title: '|          .'' window  ''.  no                   |'
  contents:
  - '|          .'' window  ''.  no                   |

    '
- title: '|         ''.has room ? .''--------------------->|'
  contents:
  - '|         ''.has room ? .''--------------------->|

    '
- title: '|           ''._______.''                        |'
  contents:
  - '|           ''._______.''                        |

    '
- title: '|                | yes                         |'
  contents:
  - '|                | yes                         |

    '
- title: '|              __V__                           |'
  contents:
  - '|              __V__                           |

    '
- title: '|            .'' TCB ''.                         |'
  contents:
  - '|            .'' TCB ''.                         |

    '
- title: '|          .'' buffer  ''.   no                  |'
  contents:
  - '|          .'' buffer  ''.   no                  |

    '
- title: '|        .''space avail- ''.---------------------'''
  contents:
  - '|        .''space avail- ''.---------------------''

    '
- title: '|         ''.  able ?   .''                   A'
  contents:
  - '|         ''.  able ?   .''                   A

    '
- title: '|           ''._______.''                     |'
  contents:
  - '|           ''._______.''                     |

    '
- title: '|                | yes                      |'
  contents:
  - '|                | yes                      |

    '
- title: '|   _____________V____________     _________|_______     ____________'
  contents:
  - '|   _____________V____________     _________|_______     ____________

    '
- title: '|  |Copy from Send buffer to  |   |Move buffer from |   |Set EOL bit |'
  contents:
  - '|  |Copy from Send buffer to  |   |Move buffer from |   |Set EOL bit |

    '
- title: '|  |packet until packet full. |   |Send queue to    |<--|in packet   |'
  contents:
  - '|  |packet until packet full. |   |Send queue to    |<--|in packet   |

    '
- title: '|  |Put packet on Send packet |   |packetized queue |   |header      |'
  contents:
  - '|  |Put packet on Send packet |   |packetized queue |   |header      |

    '
- title: '|  |queue. Signal OPH.        |   |_________________|   |____________|'
  contents:
  - '|  |queue. Signal OPH.        |   |_________________|   |____________|

    '
- title: '|  |__________________________|             A                  A'
  contents:
  - '|  |__________________________|             A                  A

    '
- title: '|                |                          | no               |'
  contents:
  - '|                |                          | no               |

    '
- title: '|              __V__                      __|__                |'
  contents:
  - '|              __V__                      __|__                |

    '
- title: '|            .''whole''.                  .'' EOL ''.              |'
  contents:
  - '|            .''whole''.                  .'' EOL ''.              |

    '
- title: '|          .''  Send   ''.  yes         .'' set in  ''.  yes       |'
  contents:
  - '|          .''  Send   ''.  yes         .'' set in  ''.  yes       |

    '
- title: '|         ''.  buffer   .''----------->''.   Send    .''-----------'''
  contents:
  - '|         ''.  buffer   .''----------->''.   Send    .''-----------''

    '
- title: '|           ''.copied?.''                ''.buffer?.'''
  contents:
  - '|           ''.copied?.''                ''.buffer?.''

    '
- title: '|             ''.___.''                    ''.___.'''
  contents:
  - '|             ''.___.''                    ''.___.''

    '
- title: '|                | no'
  contents:
  - '|                | no

    '
- title: '|   _____________V__________'
  contents:
  - '|   _____________V__________

    '
- title: '|  |Note in TCB where in    |'
  contents:
  - "|  |Note in TCB where in    |\n --|Send buffer we stopped. |\n   |________________________|\n"
- title: 'FIGURE 2.5a:'
  contents:
  - 'FIGURE 2.5a:

    '
- title: Output Packet Handler
  contents:
  - "Output Packet Handler\n                                        _______\n    \
    \                                   / Begin \\\n                             \
    \          \\_______/\n                                           |\n        \
    \                                   |<--------------------------.\n          \
    \                     ____________V___________                |\n            \
    \                  | Get ready for next TCB |               |\n              \
    \                |________________________|               |\n                \
    \                      |                                |\n"
- title: ',------------------------------------>|                                |'
  contents:
  - ',------------------------------------>|                                |

    '
- title: '|                                   __V__               _____          |'
  contents:
  - '|                                   __V__               _____          |

    '
- title: '|               _____             .''Send ''.           .'' any ''.        |'
  contents:
  - '|               _____             .''Send ''.           .'' any ''.        |

    '
- title: '|        yes  .'' ACK ''.     no  .'' Buffer  ''.  yes  .''  more   ''.  yes
    |'
  contents:
  - '|        yes  .'' ACK ''.     no  .'' Buffer  ''.  yes  .''  more   ''.  yes
    |

    '
- title: '|      .-----''.bit set.''<------''.   Queue   .''---->''.   work    .''-----'''
  contents:
  - '|      .-----''.bit set.''<------''.   Queue   .''---->''.   work    .''-----''

    '
- title: '|      |       ''.___.''           ''.empty? .''    A    ''.   ?   .'''
  contents:
  - '|      |       ''.___.''           ''.empty? .''    A    ''.   ?   .''

    '
- title: '|      |       no |________        ''.___.''      |      ''.___.'''
  contents:
  - '|      |       no |________        ''.___.''      |      ''.___.''

    '
- title: '|      |                   |__________          |         | no'
  contents:
  - '|      |                   |__________          |         | no

    '
- title: '|  ____V__________________            |         |         |'
  contents:
  - '|  ____V__________________            |         |         |

    '
- title: '| |Put latest receive left|   ________v______   |   ______V______'
  contents:
  - '| |Put latest receive left|   ________v______   |   ______V______

    '
- title: '| |window edge in ACK.    |->|Transmit packet|  |  | go to sleep |'
  contents:
  - '| |window edge in ACK.    |->|Transmit packet|  |  | go to sleep |

    '
- title: '| |_______________________|  |_______________|  |  |_____________|'
  contents:
  - '| |_______________________|  |_______________|  |  |_____________|

    '
- title: '|                                     |         |'
  contents:
  - '|                                     |         |

    '
- title: '|     ________________              __V__       |'
  contents:
  - '|     ________________              __V__       |

    '
- title: '|    |Return packet to|           .''pckt ''.     |_________________'
  contents:
  - '|    |Return packet to|           .''pckt ''.     |_________________

    '
- title: '|    |buffer pool as  |    no   .''seq # to ''.                     |'
  contents:
  - '|    |buffer pool as  |    no   .''seq # to ''.                     |

    '
- title: '|    |it has been     |<------.''rgt of Send  ''.                   |'
  contents:
  - '|    |it has been     |<------.''rgt of Send  ''.                   |

    '
- title: '|    |ACKed           |        ''.left window.''                    |'
  contents:
  - '|    |ACKed           |        ''.left window.''                    |

    '
- title: '|    |________________|          ''.  edge .''                      |'
  contents:
  - '|    |________________|          ''.  edge .''                      |

    '
- title: '|             |                    ''.___.''                        |'
  contents:
  - '|             |                    ''.___.''                        |

    '
- title: '|             |                       | yes                       |'
  contents:
  - '|             |                       | yes                       |

    '
- title: '|             |        _______________V________________           |'
  contents:
  - '|             |        _______________V________________           |

    '
- title: '|             |       |Move packet to retransmit queue;|          |'
  contents:
  - '|             |       |Move packet to retransmit queue;|          |

    '
- title: '|             |       |set new retrans. time for it.   |          |'
  contents:
  - '|             |       |set new retrans. time for it.   |          |

    '
- title: '|             |       |________________________________|          |'
  contents:
  - '|             |       |________________________________|          |

    '
- title: '|             |                       |                           |'
  contents:
  - '|             |                       |                           |

    '
- title: '|             ''---------------------->|                           |'
  contents:
  - '|             ''---------------------->|                           |

    '
- title: '|                                   __V__                         |'
  contents:
  - '|                                   __V__                         |

    '
- title: '|                            no   .''Time ''.   yes                 |'
  contents:
  - "|                            no   .'Time '.   yes                 |\n -------------------------------.'to\
    \ switch'.---------------------'\n                                 '.TCB's? .'\n\
    \                                   '.___.'\n"
- title: 'FIGURE 2.5b:'
  contents:
  - 'FIGURE 2.5b:

    '
- title: Retransmit Process
  contents:
  - "Retransmit Process\n                                _______\n               \
    \                / Begin \\\n                               \\_______/\n     \
    \                              |\n                                   |<----------------------------------.\n\
    \                       ____________V___________                        |\n  \
    \                    | Get ready for next TCB |                       |\n    \
    \                  |________________________|                       |\n      \
    \                             |                                   |\n .-------------------------------->|\
    \                                   |\n |                               __V__\
    \                                 |\n |                             .' Any '.\
    \                _____          |\n |                           .'packet's '.\
    \            .' any '.        |\n |                         .'retrans. time'.\
    \  no    .'  more   '.  yes |\n |                        '. has occurred  .'----->'.\
    \   work    .'-----'\n |                          '.  for this .'          '.\
    \   ?   .'\n |                            '. TCB ? .'              '.___.'\n |\
    \                              '.___.'                   |\n |               \
    \                  | yes                  | no\n |                           \
    \      |                ______V______\n |                         ________V________\
    \       | go to sleep |\n |                        |Move packet to   |      |_____________|\n\
    \ '------------------------|Send Packet      |\n                          |queue.\
    \ Signal OPH|\n                          |_________________|\n"
- title: 'FIGURE 3.1:'
  contents:
  - 'FIGURE 3.1:

    '
- title: OPEN
  contents:
  - "OPEN\n                                 _______\n                            \
    \    / Begin \\\n                                \\_______/\n                \
    \                    |\n                                  __V__\n            \
    \                    .'User '.          _______\n                            \
    \  .'permitted'.   no  |       |\n                            .'  access to  '.---->|error\
    \ 1|------------.\n                             '.this local .'      |_______|\
    \            |\n                               '.socket?.'                   \
    \          |\n                                 '.___.'                       \
    \        |\n                                    | yes                        \
    \      |\n                                  __V__                            \
    \    |\n                                .' fgn '.                            \
    \  |\n                         yes  .' socket  '.  no                        |\n\
    \                       .-----'. specified .'----.                      |\n  \
    \                     |       '.   ?   .'      |                      |\n    \
    \                 __V__       '.___.'      __V__         _______    |\n   _______\
    \         .'conn-'.                .'space'.  no  |       |   |\n  |       | \
    \ yes .' ection  '.             '.for TCB.'---->|error 4|-->|\n"
- title: ',-|error 6|<----''.  already  .''              ''.___.''       |_______|   |'
  contents:
  - ',-|error 6|<----''.  already  .''              ''.___.''       |_______|   |

    '
- title: '| |_______|       ''.exists?.''                   | yes                  |'
  contents:
  - '| |_______|       ''.exists?.''                   | yes                  |

    '
- title: '|                   ''.___.''                     |                      |'
  contents:
  - '|                   ''.___.''                     |                      |

    '
- title: '|                      | no                 ____V__________            |'
  contents:
  - '|                      | no                 ____V__________            |

    '
- title: '|   _______          __V__                 |Create TCB. Set|           |'
  contents:
  - '|   _______          __V__                 |Create TCB. Set|           |

    '
- title: '|  |       |   no  .''space''.               |S1=S2=R=F=C=1  |           |'
  contents:
  - '|  |       |   no  .''space''.               |S1=S2=R=F=C=1  |           |

    '
- title: '|<-|error 4|<-----''.for TCB.''              |Set U=1        |           |'
  contents:
  - '|<-|error 4|<-----''.for TCB.''              |Set U=1        |           |

    '
- title: '|  |_______|        ''.___.''                |_______________|           |'
  contents:
  - '|  |_______|        ''.___.''                |_______________|           |

    '
- title: '|                      | yes                       |                   |'
  contents:
  - '|                      | yes                       |                   |

    '
- title: '|                      |                           |                   |'
  contents:
  - '|                      |                           |                   |

    '
- title: '|             _________V__________                 |                   |'
  contents:
  - '|             _________V__________                 |                   |

    '
- title: '|            |Create TCB. Set U=0 |                |                   |'
  contents:
  - '|            |Create TCB. Set U=0 |                |                   |

    '
- title: '|            |Set S1=S2=R=F=C=1   |                |                   |'
  contents:
  - '|            |Set S1=S2=R=F=C=1   |                |                   |

    '
- title: '|            |____________________|                |                   |'
  contents:
  - '|            |____________________|                |                   |

    '
- title: '|                      |                           |                   |'
  contents:
  - '|                      |                           |                   |

    '
- title: '|                      ''-------------.-------------''                   |'
  contents:
  - '|                      ''-------------.-------------''                   |

    '
- title: '|                                    |                                 |'
  contents:
  - '|                                    |                                 |

    '
- title: '|               _____________________V__________________               |'
  contents:
  - '|               _____________________V__________________               |

    '
- title: '|              |Return local connection name and Success|              |'
  contents:
  - '|              |Return local connection name and Success|              |

    '
- title: '|              |________________________________________|              |'
  contents:
  - '|              |________________________________________|              |

    '
- title: '|                                    |                                 |'
  contents:
  - "|                                    |                                 |\n ----------------------------------->|<--------------------------------'\n\
    \                                 ____V___\n                                /\
    \ Return \\\n                                \\________/\n"
- title: 'FIGURE 3.2:'
  contents:
  - 'FIGURE 3.2:

    '
- title: SEND
  contents:
  - "SEND\n                   _______\n                  / Begin \\\n            \
    \      \\_______/\n                      |\n                    __V__\n      \
    \            .'conn-'.\n                .' ection  '.               _________\n\
    \              .'  legal for  '.  no        |         |\n             '. this\
    \ process  .'---------->| error 1 |-----------.\n               '.     ?     .'\
    \             |_________|           |\n                 '._______.'          \
    \                           |\n                      | yes                   \
    \                   |\n                    __V__                             \
    \           |\n                  .'conn-'.                 _________         \
    \   |\n                .' ection  '.   no         |         |           |\n  \
    \            .'    open     '.----------->| error 3 |---------->|\n          \
    \     '.     ?     .'             |_________|           |\n                 '._______.'\
    \                                     |\n                      | yes         \
    \                             |\n                    __V__                   \
    \                     |\n                  .' fgn '.                 _________\
    \            |\n                .' socket  '.  no          |         |       \
    \    |\n               '. specified .'------------>| error 5 |---------->|\n \
    \                '.(U=0)? .'               |_________|           |\n         \
    \          '.___.'                                       |\n                 \
    \     | yes                                      |\n                    __V__\
    \                                        |\n                  .'conn-'.      \
    \           _________            |\n                .' ection  '.  yes       \
    \  |         |           |\n               '. closing ? .'------------>| error\
    \ 12|---------->|\n                 '.(F,C=1).'               |_________|    \
    \       |\n                   '.___.'                                       |\n\
    \                      | no                                       |\n  ____________________V________________________________\
    \          |\n |Put buffer on Send Buffer queue and signal Packetizer|       \
    \  |\n |_____________________________________________________|         |\n   \
    \                   |                                          |\n           \
    \           |<-----------------------------------------'\n                  ____V___\n\
    \                 / Return \\\n                 \\________/\n"
- title: 'FIGURE 3.3:'
  contents:
  - 'FIGURE 3.3:

    '
- title: INTERRUPT
  contents:
  - "INTERRUPT\n                   _______\n                  / Begin \\\n       \
    \           \\_______/\n                      |\n                      |\n   \
    \                   V\n                Same as SEND\n                      | \
    \                                         |\n                      |         \
    \                                 |\n  ____________________V_________________________\
    \                 |\n |Return any pending Send buffers with code 10. |       \
    \         |\n |Create INT packet on outgoing packet queue.   |               \
    \ |\n |Signal Output Packet Handler.                 |                |\n |______________________________________________|\
    \                |\n                      |                                  \
    \        |\n                      |<-----------------------------------------'\n\
    \                  ____V___\n                 / Return \\\n                 \\\
    ________/\n"
- title: 'FIGURE 3.4:'
  contents:
  - 'FIGURE 3.4:

    '
- title: RECEIVE
  contents:
  - "RECEIVE\n                   _______\n                  / Begin \\\n         \
    \         \\_______/\n                      |\n                    __V__\n   \
    \               .'conn-'.\n                .' ection  '.               _________\n\
    \              .'  legal for  '.  no        |         |\n             '. this\
    \ process  .'---------->| error 1 |-----------.\n               '.     ?     .'\
    \             |_________|           |\n                 '._______.'          \
    \                           |\n                      | yes                   \
    \                   |\n                     _V_                              \
    \           |\n                   .'   '.                                    \
    \   |\n                 .'       '.                                     |\n  \
    \             .'connection '.                                   |\n          \
    \   .'     state     '.                                 |\n            :___________________:\
    \                   _________    |\n               |      |      |           \
    \          |         |   |\n           1-4 |  5,6 |    0 '-------------------->|\
    \ error 3 |-->|\n               |      '---------------------.      |_________|\
    \   |\n     __________V__________                  |                    |\n  \
    \  |Put buffer on Receive|                 |       _________    |\n    |Buffer\
    \ queue. Signal |                 |      |         |   |\n    |Reassembler   \
    \       |                 '----->| error 12|-->|\n    |_____________________|\
    \                        |_________|   |\n               |                   \
    \                              |\n               |<------------------------------------------------'\n\
    \           ____V___\n          / Return \\\n          \\________/\n"
- title: 'FIGURE 3.5:'
  contents:
  - 'FIGURE 3.5:

    '
- title: CLOSE
  contents:
  - "CLOSE\n                   _______\n                  / Begin \\\n           \
    \       \\_______/\n                      |\n                    __V__\n     \
    \             .'conn-'.\n                .' ection  '.               _________\n\
    \              .'  legal for  '.  no        |         |\n             '. this\
    \ process  .'---------->| error 1 |-----------.\n               '.     ?     .'\
    \             |_________|           |\n                 '._______.'          \
    \                           |\n                      | yes                   \
    \                   |\n                     _V_                              \
    \           |\n                   .'   '.                                    \
    \   |\n                 .'       '.                                     |\n  \
    \             .'connection '.                                   |\n          \
    \   .'     state     '.                                 |\n            :___________________:\
    \                   _________    |\n            5|   |3,4  |1,2,6  |0        \
    \          |         |   |\n             |   |     |       '------------------>|\
    \ error 3 |-->|\n"
- title: ',------------''   |     ''-------------------.       |_________|   |'
  contents:
  - ',------------''   |     ''-------------------.       |_________|   |

    '
- title: '|  ______________V______________________   |                     |'
  contents:
  - '|  ______________V______________________   |                     |

    '
- title: '| |Return all buffers to user with error|  |     ___________     |'
  contents:
  - '| |Return all buffers to user with error|  |     ___________     |

    '
- title: '| |12; clear all packet queues, create  |  |    |Remove TCB |    |'
  contents:
  - '| |12; clear all packet queues, create  |  |    |Remove TCB |    |

    '
- title: '| |FIN packet, signal Output Packet     |  ''--->|Return     |--->|'
  contents:
  - '| |FIN packet, signal Output Packet     |  ''--->|Return     |--->|

    '
- title: '| |Handler, set C=F=1                   |       |Success    |    |'
  contents:
  - '| |Handler, set C=F=1                   |       |Success    |    |

    '
- title: '| |_____________________________________|       |___________|    |'
  contents:
  - '| |_____________________________________|       |___________|    |

    '
- title: '|                      |                                         |'
  contents:
  - "|                      |                                         |\n --------------------->|<----------------------------------------'\n\
    \                   ____V___\n                  / Return \\\n                \
    \  \\________/\n"
- title: 'FIGURE 3.6:'
  contents:
  - 'FIGURE 3.6:

    '
- title: STATUS
  contents:
  - "STATUS\n                   _______\n                  / Begin \\\n          \
    \        \\_______/\n                      |\n                    __V__\n    \
    \              .'conn-'.\n                .' ection  '.               _________\n\
    \              .'  legal for  '.  no        |         |\n             '. this\
    \ process  .'---------->| error 1 |-----------.\n               '.     ?     .'\
    \             |_________|           |\n                 '._______.'          \
    \                           |\n                      | yes                   \
    \                   |\n                    __V__                   __________\
    \           |\n                  .'conn-'.                |Return    |       \
    \   |\n                .' ection  '.  no          |state=0 or|          |\n  \
    \             '.   open ?  .'------------>|error 3   |--------->|\n          \
    \       '._______.'               |__________|          |\n                  \
    \    | yes                                      |\n           ___________V___________\
    \                               |\n          |Fill in reply from TCB.|       \
    \                       |\n          |Return Success to user.|               \
    \               |\n          |_______________________|                       \
    \       |\n                      |                                          |\n\
    \                      |<-----------------------------------------'\n        \
    \          ____V___\n                 / Return \\\n                 \\________/\n"
- title: 'FIGURE 4.1:'
  contents:
  - 'FIGURE 4.1:

    '
- title: SYN (no ACK)
  contents:
  - "SYN (no ACK)\n                              _______\n                       \
    \      / Begin \\\n                             \\_______/\n                 \
    \                |\n                                _V_\n                    \
    \          .'   '.\n                            .'       '.\n                \
    \          .' S1, S2, R '.\n                        .'       ?       '.\n    \
    \                   :___________________: 1,1,1        _________\n __________\
    \             |     |     |     | (states 4-6) |         |\n"
- title: '|Treat as a|      1,0,1 |     |     |     ''------------->| error 6 |-->.'
  contents:
  - '|Treat as a|      1,0,1 |     |     |     ''------------->| error 6 |-->.

    '
- title: '|duplicate.|<-----------''     |     |                    |_________|   |'
  contents:
  - '|duplicate.|<-----------''     |     |                    |_________|   |

    '
- title: '|Retransmit|                  |     | 1.0,0                            |'
  contents:
  - '|Retransmit|                  |     | 1.0,0                            |

    '
- title: '|SYN, ACK  |            0,0,0 |     | (Syn sent)   ________________    |'
  contents:
  - '|SYN, ACK  |            0,0,0 |     | (Syn sent)   ________________    |

    '
- title: '|__________|      (listening) |     ''------------>|Collision: Clear|   |'
  contents:
  - "|__________|      (listening) |     '------------>|Collision: Clear|   |\n  \
    \   |                        |                   |S1, set timeout,|   |\n    \
    \ |   _____________________V________________   |remove SYN from |-->|\n     |\
    \  |Set R=S1=1. If U=1 set foreign socket |  |retransmit queue|   |\n     |  |in\
    \ TCB to match packet local socket.  |  |________________|   |\n     |  |Send\
    \ SYN, ACK. Signal OPH. Fill in TCB|                       |\n     |  |with send\
    \ window, receive sequence #. |                       |\n     |  |______________________________________|\
    \                       |\n     |                        |                   \
    \                     |\n     |                        |                     \
    \                   |\n     '----------------------->|<---------------------------------------'\n\
    \                           ___V__\n                          / Done \\\n    \
    \                      \\______/\n"
- title: 'FIGURE 4.2:'
  contents:
  - 'FIGURE 4.2:

    '
- title: SYN,ACK
  contents:
  - "SYN,ACK\n                        _______\n                       / Begin \\\n\
    \                       \\_______/\n                           |\n           \
    \              __V__\n                       .'     '.\n                     .'\
    \ State 2 '.  no\n                    '.S1=1;S2=R=0.'----------------.\n     \
    \                 '.   ?   .'                  |\n                        '.___.'\
    \                    |\n                           | yes                   |\n\
    \                         __V__              _______V______\n                \
    \       .' ACK '.   no      |              |\n                     .' correct\
    \ '.-------->| send error 6 |\n                      '.   ?   .'          |______________|\n\
    \                        '.___.'                    |\n                      \
    \     | yes                   |\n                  _________V_________       \
    \       |\n                 |Set S2=R=1. Process|             |\n            \
    \     |ACK. Send ACK.     |             |\n                 |___________________|\
    \             |\n                           |                       |\n      \
    \                     |<----------------------'\n                        ___V__\n\
    \                       / Done \\\n                       \\______/\n"
- title: 'FIGURE 4.3:'
  contents:
  - 'FIGURE 4.3:

    '
- title: INT (from net)
  contents:
  - "INT (from net)\n                   _______       ____________\n             \
    \     / Begin \\____\\|Process ACK |\n                  \\_______/    /|(may set\
    \ S2)|------.\n                                |____________|      |\n       \
    \                                             |\n                            \
    \                      __V__\n                        ____________           \
    \ .' in  '.\n                       | Discard    |     no  .' state 4 '.\n   \
    \           .<-------| (or queue) |<-------'. S1=S2=R=1 .'\n              |  \
    \      |____________|          '. F=0 ? .'\n              |                  \
    \                '.___.'\n              |                                    \
    \ | yes\n              |                                   __V__\n           \
    \   |         ____________            .'     '.\n              |        | ACK\
    \ and    |     no  .' within  '.\n              |<-------| discard    |<-------'.\
    \  window   .'\n              |        |____________|          '.   ?   .'\n \
    \             |                                  '.___.'\n              |    \
    \                                 | yes\n              |         ____________________________V_______________\n\
    \              |        |Move Receive Left window edge to sequence   |\n     \
    \         |        |number of INT. Return event 10 with any     |\n          \
    \    |        |pending Receive buffers. Ruturn event 11 to |\n              |\
    \        |user. Send ACK for INT.                     |\n              |     \
    \   |____________________________________________|\n              |          \
    \                           |\n              |                               \
    \    __V__\n              |                 see       yes   .'data '.\n      \
    \        |              Figure<----------.' in this '.\n              |      \
    \           2.2            '.packet?.'\n              |                      \
    \            '.___.'\n              |                                     | no\n\
    \              '------------------------------------>|\n                     \
    \                            ___V__\n                                        \
    \        / Done \\\n                                                \\______/\n"
- title: 'FIGURE 4.4:'
  contents:
  - 'FIGURE 4.4:

    '
- title: FIN
  contents:
  - "FIN\n                 _______       ____________\n                / Begin \\\
    ____\\|Process ACK |\n                \\_______/    /|(may set S2)|------.\n \
    \                             |____________|      |\n                        \
    \                          |\n                                               \
    \ __V__\n                                              .'     '.\n           \
    \                             no  .'S1=S2=R=1'.\n                            .--------------'.\
    \  (estab-  .'\n                            |                '.lished).'\n   \
    \                         |                  '.___.'\n                       \
    \     |                     | yes\n                            |             \
    \      __V__\n                      ______V_____            .'     '.\n      \
    \               |            |     no  .' within  '.\n   .-----------------| discard\
    \    |<-------'.  window   .'\n   |                 |____________|          '.\
    \   ?   .'\n   |                                           '.___.'\n   |     \
    \                                         | yes\n   |                        \
    \                    __V__\n   |                             (state 4) 0  .'F\
    \ bit'.  1 (state 5)\n   |                            .------------'. value .'------------.\n\
    \   |                            |              '.___.'              |\n   | \
    \  _________________________V________                           |\n   |  |Return\
    \ all user buffers (event 12)|     _____________________V__\n   |  |Clear all\
    \ packet queues. Send FIN |    |Return success to User's|\n   |  |packet. Set\
    \ F=1. Inform user      |    |CLOSE.  Remove TCB.     |\n   |  |\"connection closing\"\
    \ (event 12)   |    |________________________|\n   |  |__________________________________|\
    \                 |\n   |                  |                                 \
    \   |\n   '----------------->|<-----------------------------------'\n        \
    \           ___V__\n                  / Done \\\n                  \\______/\n"
- title: 'FIGURE 4.5:'
  contents:
  - 'FIGURE 4.5:

    '
- title: Error 6 (bad SYN)
  contents:
  - "Error 6 (bad SYN)\n                _______\n               / Begin \\\n     \
    \          \\_______/\n                   |\n                   |\n          \
    \       __V__\n               .'     '.\n             .'refers to'.\n        \
    \   .'current pckt?'.                      _________\n         .'(ACK matches\
    \ seq '.  no               |         |\n        '.  # of packet on   .'----------------->|\
    \ discard |-----------.\n          '.retrans or send.'                    |_________|\
    \           |\n            '.  queues?) .'                                   \
    \         |\n              '._______.'                                       \
    \       |\n                   | yes                                          \
    \     |\n                   |                                                \
    \   |\n                  _V_                                                 \
    \ |\n                .'   '.   1 (state 3)                                  |\n\
    \              .' value '.--------------------------------.             |\n  \
    \             '. of R.'  bad SYN,ACK                    |             |\n    \
    \             '._.'                                   |             |\n      \
    \             |                                     |             |\n        \
    \           | 0 (state 2)                         |             |\n          \
    \         | bad SYN                             |             |\n __________________V__________________\
    \            _______V______       |\n"
- title: '|Other side is established. Send RESET|          |Clear S1, R   |      |'
  contents:
  - '|Other side is established. Send RESET|          |Clear S1, R   |      |

    '
- title: '|(put error packet''s seq. # in ACK    |          |Remove SYN,ACK|      |'
  contents:
  - '|(put error packet''s seq. # in ACK    |          |Remove SYN,ACK|      |

    '
- title: '|field. Return all user buffers with  |          |from retrans  |      |'
  contents:
  - '|field. Return all user buffers with  |          |from retrans  |      |

    '
- title: '|code 14. Inform user with event 14   |          |queue.        |      |'
  contents:
  - '|code 14. Inform user with event 14   |          |queue.        |      |

    '
- title: '|_____________________________________|          |______________|      |'
  contents:
  - "|_____________________________________|          |______________|      |\n  \
    \                 |                                     |             |\n    \
    \               |                                     V             |\n      \
    \             |<--------------------------------------------------'\n        \
    \        ___V__\n               / Done \\\n               \\______/\n"
- title: 'FIGURE 4.6:'
  contents:
  - 'FIGURE 4.6:

    '
- title: Error 7,8
  contents:
  - "Error 7,8\n                   _______\n                  / Begin \\\n       \
    \           \\_______/\n                      |\n                    __V__\n \
    \                 .'     '.\n                .'refers to'.                   \
    \  _________\n              .'   current   '.  no              |         |\n \
    \            '. packet (check .'---------------->| discard |-----------.\n   \
    \            '.   ACK)?   .'         A         |_________|           |\n     \
    \            '._______.'           |                               |\n       \
    \               | yes            |                               |\n         \
    \            _V_               |                               |\n           \
    \        .'   '.             |                               |\n             \
    \    .'       '.           |                               |\n               .'connection\
    \ '.         |                               |\n             .'     state    \
    \ '.       |                               |\n            :___________________:\
    \      |                               |\n           4|   5|   3|   2|   6|  \
    \    |                               |\n    .-------'    |    |    |    '------'\
    \                               |\n    |            |    |    '-----------------------------.\
    \             |\n    |            |    '-------------.                    |  \
    \           |\n    |            |                  |                    |    \
    \         |\n ___V___     ____V_______     ______V_______     ________V_________\
    \    |\n"
- title: '|Pass to|   |Remove TCB. |   |Clear S1, R.  |   |Discard. SYN will |   |'
  contents:
  - '|Pass to|   |Remove TCB. |   |Clear S1, R.  |   |Discard. SYN will |   |

    '
- title: '|user   |   |Return      |   |Remove SYN,ACK|   |be retrans to     |   |'
  contents:
  - '|user   |   |Return      |   |Remove SYN,ACK|   |be retrans to     |   |

    '
- title: '|_______|   |success to  |   |from transmit |   |avoid receiver    |   |'
  contents:
  - "|_______|   |success to  |   |from transmit |   |avoid receiver    |   |\n  \
    \  |       |user's CLOSE|   |queue (go to  |   |having to queue it|   |\n    |\
    \       |____________|   |state 1).     |   |__________________|   |\n    |  \
    \          |           |______________|            |             |\n    |    \
    \        V                  |                    V             |\n    '------------------------------>|<---------------------------------'\n\
    \                                 ___V__\n                                / Done\
    \ \\\n                                \\______/\n"
- title: 'FIGURE 4.7:'
  contents:
  - 'FIGURE 4.7:

    '
- title: RESET
  contents:
  - "RESET\n                                _______\n                            \
    \   / Begin \\\n                               \\_______/\n                  \
    \                 |\n                                 __V__\n                \
    \           no  .'Reset'.  yes\n                 .------------'. All ? .'------------------.\n\
    \                 |              '.___.'                    |\n              \
    \   |                                _________V_________\n                 | \
    \                              |Clear all TCB's for|\n                 |     \
    \                          |foreign TCP. Inform|\n                 |         \
    \                      |users with event 14|\n                 |             \
    \                  |___________________|\n               __V__               \
    \                        |\n             .' Is  '.             _________     \
    \          |\n           .'  RESET  '.   no     |         |              |\n \
    \        .'believable ? '.------->| discard |------------->|\n          '.(check\
    \ ACK .'         |_________|              |\n            '.field) .'         \
    \                           |\n              '.___.'                         \
    \             |\n                 | yes                                     |\n\
    \ ________________V________________                         |\n"
- title: '|Clear all queues for this TCB.   |                        |'
  contents:
  - '|Clear all queues for this TCB.   |                        |

    '
- title: '|Return event 14 for user buffers.|                        |'
  contents:
  - '|Return event 14 for user buffers.|                        |

    '
- title: '|Inform User with event 14.       |                        |'
  contents:
  - '|Inform User with event 14.       |                        |

    '
- title: '|_________________________________|                        |'
  contents:
  - "|_________________________________|                        |\n              \
    \   |                                         |\n                 |<----------------------------------------'\n\
    \              ___V__\n             / Done \\\n             \\______/\n      \
    \ [ This RFC was put into machine readable form for entry ]\n       [ into the\
    \ online RFC archives by Alex McKenzie with    ]\n       [ support from GTE, formerly\
    \ BBN Corp.           2/2000 ]\n"
