- contents:
  - "                  Rules for Designing Protocols Using\n          the Generalized
    Packet/Message Format from RFC 5444\n"
  title: __initial_text__
- contents:
  - "Abstract\n   RFC 5444 specifies a generalized Mobile Ad Hoc Network (MANET)\n
    \  packet/message format and describes an intended use for multiplexed\n   MANET
    routing protocol messages; this use is mandated by RFC 5498\n   when using the
    MANET port or protocol number that it specifies.  This\n   document updates RFC
    5444 by providing rules and recommendations for\n   how the multiplexer operates
    and how protocols can use the\n   packet/message format.  In particular, the mandatory
    rules prohibit a\n   number of uses that have been suggested in various proposals
    and that\n   would have led to interoperability problems, to the impediment of\n
    \  protocol extension development, and/or to an inability to use\n   optional
    generic parsers.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8245.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. History and Purpose ........................................4\n      1.2.
    Features of RFC 5444 .......................................4\n           1.2.1.
    Packet/Message Format ...............................5\n           1.2.2. Multiplexing
    and Demultiplexing .....................7\n      1.3. Status of This Document
    ....................................8\n   2. Terminology .....................................................8\n
    \  3. Applicability Statement .........................................9\n   4.
    Information Transmission ........................................9\n      4.1.
    Where to Record Information ................................9\n      4.2. Message
    and TLV Type Allocation ...........................10\n      4.3. Message Recognition
    .......................................11\n      4.4. Message Multiplexing and
    Packets ..........................11\n           4.4.1. Packet Transmission ................................12\n
    \          4.4.2. Packet Reception ...................................13\n      4.5.
    Messages, Addresses, and Attributes .......................15\n      4.6. Addresses
    Require Attributes ..............................16\n      4.7. TLVs ......................................................18\n
    \     4.8. Message Integrity .........................................19\n   5.
    Structure ......................................................19\n   6. Message
    Efficiency .............................................20\n      6.1. Address
    Block Compression .................................21\n      6.2. TLVs ......................................................22\n
    \     6.3. TLV Values ................................................23\n   7.
    Security Considerations ........................................24\n   8. IANA
    Considerations ............................................24\n   9. References
    .....................................................25\n      9.1. Normative
    References ......................................25\n      9.2. Informative References
    ....................................25\n   Appendix A. Information Representation
    ............................27\n   Appendix B. Automation ............................................28\n
    \  Acknowledgments ...................................................28\n   Authors'
    Addresses ................................................29\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   [RFC5444] specifies a generalized packet/message format
    that is\n   designed for use by MANET routing protocols.\n   [RFC5444] was designed
    following experiences with [RFC3626], which\n   attempted to provide a packet/message
    format accommodating diverse\n   protocol extensions but did not fully succeed.
    \ [RFC5444] was\n   designed as a common building block for use by both proactive
    and\n   reactive MANET routing protocols.\n   [RFC5498] mandates the use of this
    packet/message format and of the\n   packet multiplexing process described in
    an appendix to [RFC5444] by\n   protocols operating over the MANET IP protocol
    and UDP port numbers\n   that were allocated by [RFC5498].\n"
  - contents:
    - "1.1.  History and Purpose\n   Since the publication of [RFC5444] in 2009, several
      RFCs have been\n   published, including [RFC5497], [RFC6130], [RFC6621], [RFC7181],\n
      \  [RFC7182], [RFC7183], [RFC7188], [RFC7631], and [RFC7722], that use\n   the
      format of [RFC5444].  The ITU-T recommendation [G9903] also uses\n   the format
      of [RFC5444] for encoding some of its control signals.  In\n   developing these
      specifications, experience with the use of [RFC5444]\n   has been acquired,
      specifically with respect to how to write\n   specifications using [RFC5444]
      so as to ensure forward compatibility\n   of a protocol with future extensions,
      to enable the creation of\n   efficient messages, and to enable the use of an
      efficient and generic\n   parser for all protocols using [RFC5444].\n   During
      the same time period, other suggestions have been made to use\n   [RFC5444]
      in a manner that would inhibit the development of\n   interoperable protocol
      extensions, that would potentially lead to\n   inefficiencies, or that would
      lead to incompatibilities with generic\n   parsers for [RFC5444].  While these
      uses were not all explicitly\n   prohibited by [RFC5444], they are strongly
      discouraged.  This\n   document is intended to prohibit such uses, to present
      experiences\n   from designing protocols using [RFC5444], and to provide these
      as\n   guidelines (with their rationale) for future protocol designs using\n
      \  [RFC5444].\n"
    title: 1.1.  History and Purpose
  - contents:
    - "1.2.  Features of RFC 5444\n   [RFC5444] performs two main functions:\n   o
      \ It defines a packet/message format for use by MANET routing\n      protocols.
      \ As far as [RFC5444] is concerned, it is up to each\n      protocol that uses
      it to implement the required message parsing\n      and formation.  It is natural,
      especially when implementing more\n      than one such protocol, to implement
      these processes using\n      protocol-independent packet/message creation and
      parsing\n      procedures, however, this is not required by [RFC5444].  Some\n
      \     comments in this document might be particularly applicable to such\n      a
      case, but all that is required is that the messages passed to\n      and from
      protocols are correctly formatted and that packets\n      containing those messages
      are correctly formatted as described in\n      the following point.\n   o  Appendix
      A of [RFC5444], combined with the intended usage\n      described in Appendix
      B of [RFC5444], specifies a multiplexing and\n      demultiplexing process whereby
      an entity that can be referred to\n      as the \"RFC 5444 multiplexer\" manages
      packets that travel a single\n      (logical) hop and contain messages that
      are owned by individual\n      protocols.  Note that in this document, the \"RFC
      5444 multiplexer\"\n      is referred to as the \"multiplexer\", or as the \"demultiplexer\"\n
      \     when performing that function.  A packet can contain messages from\n      more
      than one protocol.  This process is mandated for use on the\n      MANET UDP
      port and IP protocol (alternative means for the\n      transport of packets)
      by [RFC5498].  The multiplexer is\n      responsible for creating packets and
      for parsing Packet Headers,\n      extracting messages, and passing them to
      the appropriate protocol\n      according to their type (the first octet in
      the message).\n"
    - contents:
      - "1.2.1.  Packet/Message Format\n   Among the characteristics and design objectives
        of the packet/message\n   format of [RFC5444] are the following:\n   o  It
        is designed for carrying MANET routing protocol control\n      signals.\n
        \  o  It defines a packet as a Packet Header with a set of Packet TLVs\n      (Type-Length-Value
        structures), followed by a set of messages.\n      Each message has a well-defined
        structure consisting of a Message\n      Header (designed for making processing
        and forwarding decisions)\n      followed by a set of Message TLVs, and a
        set of (address, type,\n      value) associations using Address Blocks and
        their Address Block\n      TLVs.  The packet/message format from [RFC5444]
        then enables the\n      use of simple and generic parsing logic for Packet
        Headers,\n      Message Headers, and message content.\n      A packet can
        include messages from different protocols, such as\n      the Neighborhood
        Discovery Protocol (NHDP) [RFC6130] and the\n      Optimized Link State Routing
        Protocol version 2 (OLSRv2)\n      [RFC7181], in a single transmission.  This
        was observed in\n      [RFC3626] to be beneficial, especially in wireless
        networks where\n      media contention can be significant.\n   o  Its packets
        are designed to travel between two neighboring\n      interfaces, which will
        result in a single decrement of the IPv4\n      TTL or IPv6 hop limit.  The
        Packet Header and any Packet TLVs can\n      thus convey information relevant
        to that link (for example, the\n      Packet Sequence Number can be used to
        count transmission successes\n      across that link).  Packets are designed
        to be constructed for a\n      single-hop transmission; a packet transmission
        following a\n      successful packet reception is (by design) a new packet
        that can\n      include all, some, or none of the received messages, plus
        possibly\n      additional messages either received in separate packets or\n
        \     generated locally at that router.  Messages can thus travel more\n      than
        one hop and are designed to carry end-to-end protocol\n      signals.\n   o
        \ It supports \"internal extensibility\" using TLVs; an extension can\n      add
        information to an existing message without that information\n      rendering
        the message unparseable or unusable by a router that\n      does not support
        the extension.  An extension is typically of the\n      protocol that created
        the message to be extended, for example,\n      [RFC7181] adds information
        to the HELLO messages created by\n      [RFC6130].  However, an extension
        can also be independent of the\n      protocol; for example, [RFC7182] can
        add Integrity Check Value\n      (ICV) and timestamp information to any message
        (or to a packet,\n      thus extending the multiplexer).\n      Information,
        in the form of TLVs, can be added to the message as a\n      whole (such as
        the integrity information specified in [RFC7182])\n      or can be associated
        with specific addresses in the message (such\n      as the Multipoint Relay
        (MPR) selection and link metric\n      information added to HELLO messages
        by [RFC7181]).  An extension\n      can also add addresses to a message.\n
        \  o  It uses address aggregation into compact Address Blocks by\n      exploiting
        commonalities between addresses.  In many deployments,\n      addresses (IPv4
        and IPv6) used on interfaces share a common prefix\n      that need not be
        repeated.  Using IPv6, several addresses (of the\n      same interface) might
        have common interface identifiers that need\n      not be repeated.\n   o
        \ It sets up common namespaces, formats, and data structures for use\n      by
        different protocols where common parsing logic can be used.\n      For example,
        [RFC5497] defines a generic TLV format for\n      representing time information
        (such as interval time or validity\n      time).\n   o  It contains a minimal
        Message Header (a maximum of five elements:\n      type, originator, sequence
        number, hop count, and hop limit) that\n      permit decisions regarding whether
        to locally process a message or\n      forward a message (thus enabling MANET-wide
        flooding of a message)\n      without processing the body of the message.\n"
      title: 1.2.1.  Packet/Message Format
    - contents:
      - "1.2.2.  Multiplexing and Demultiplexing\n   The multiplexer (and demultiplexer)
        is defined in Appendix A of\n   [RFC5444].  Its purpose is to allow multiple
        protocols to share the\n   same IP protocol or UDP port.  That sharing was
        made necessary by the\n   separation of [RFC6130] from [RFC7181] as separate
        protocols and by\n   the allocation of a single IP protocol and UDP port to
        all MANET\n   protocols, including those protocols following [RFC5498], which\n
        \  states:\n      All interoperable protocols running on these well-known
        IANA\n      allocations MUST conform to [RFC5444].  [RFC5444] provides a\n
        \     common format that enables one or more protocols to share the IANA\n
        \     allocations defined in this document unambiguously.\n   The multiplexer
        is the mechanism in [RFC5444] that enables that\n   sharing.\n   The primary
        purposes of the multiplexer are to:\n   o  Accept messages from MANET protocols,
        which also indicate over\n      which interface(s) the messages are to be
        sent and to which\n      destination address.  The latter can be a unicast
        address or the\n      \"LL-MANET-Routers\" link-local multicast address defined
        in\n      [RFC5498].\n   o  Collect messages (possibly from multiple protocols)
        for the same\n      local interface and destination, into packets to be sent
        one\n      logical hop, and to send packets using the MANET UDP port or IP\n
        \     protocol defined in [RFC5498].\n   o  Extract messages from received
        packets and pass them to their\n      owning protocols.\n   The multiplexer's
        relationship is with the protocols that own the\n   corresponding Message
        Types.  Where those protocols have their own\n   relationships (for example,
        as extensions), this is the\n   responsibility of the protocols.  For example,
        OLSRv2 [RFC7181]\n   extends the HELLO messages created by NHDP [RFC6130].
        \ However, the\n   multiplexer will deliver HELLO messages to NHDP and will
        expect to\n   receive HELLO messages from NHDP; the relationship between NHDP
        and\n   OLSRv2 is between those two protocols.\n   The multiplexer is also
        responsible for the Packet Header, including\n   any Packet Sequence Number
        and Packet TLVs.  It can accept some\n   additional instructions from protocols,
        can pass additional\n   information to protocols, and will follow some additional
        rules; see\n   Section 4.4.\n"
      title: 1.2.2.  Multiplexing and Demultiplexing
    title: 1.2.  Features of RFC 5444
  - contents:
    - "1.3.  Status of This Document\n   This document updates [RFC5444] and is published
      on the Standards\n   Track (rather than as Informational) because it specifies
      and\n   mandates constraints on the use of [RFC5444] that, if not followed,\n
      \  make forms of extensions of those protocols impossible, impede the\n   ability
      to generate efficient messages, or make desirable forms of\n   generic parsers
      impossible.\n   Each use of key words from [RFC2119] (see Section 2) can be\n
      \  considered an update to [RFC5444].  In most cases, these codify\n   obvious
      best practice or constrain the use of [RFC5444] in the\n   circumstances where
      this specification is applicable (see Section 3).\n   In a few circumstances,
      operation of [RFC5444] is modified.  These\n   are all circumstances that do
      not occur in its main and current uses,\n   specifically by [RFC6130] and [RFC7181]
      (that might already include\n   the requirement, particularly through [RFC7188]).
      \ That such\n   modifying cases are an update to [RFC5444] is explicitly indicated
      in\n   this specification.\n"
    title: 1.3.  Status of This Document
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n   Use of those key words applies directly to existing and future\n
    \  implementations of [RFC5444].  It also applies to existing and future\n   protocols
    that use or update that RFC.\n   This document uses the terminology and notation
    defined in [RFC5444];\n   the terms \"packet\", \"Packet Header\", \"message\",
    \"Message Header\",\n   \"address\", \"Address Block\", \"TLV\", \"TLV Block\",
    and other related\n   terms are to be interpreted as described therein.\n   Additionally,
    this document uses the following terminology:\n   Full Type (of TLV):  As per
    [RFC5444], the 16-bit combination of the\n      TLV Type and Type Extension is
    given the symbolic name\n      <tlv-fulltype>.  This document uses the term \"Full
    Type\", which is\n      not used in [RFC5444], but is assigned (by this document)
    as\n      standard terminology.\n   Owning Protocol:  As per [RFC5444], for each
    Message Type, a protocol\n      -- unless specified otherwise, the one making
    the IANA reservation\n      for that Message Type -- is designated as the \"owning
    protocol\" of\n      that Message Type.  The demultiplexer inspects the Message
    Type of\n      each received message and delivers each message to its\n      corresponding
    \"owning protocol\".\n"
  title: 2.  Terminology
- contents:
  - "3.  Applicability Statement\n   This document does not specify a protocol but
    documents constraints\n   on how to design protocols that use the generic packet/message
    format\n   defined in [RFC5444] that, if not followed, makes forms of extensions\n
    \  of those protocols impossible, impedes the ability to generate\n   efficient
    (small) messages, or makes desirable forms of generic\n   parsers impossible.
    \ The use of the [RFC5444] format is mandated by\n   [RFC5498] for all protocols
    running over the MANET protocol and port,\n   defined therein.  Thus, the constraints
    in this document apply to all\n   protocols running over the MANET IP protocol
    or UDP port.  The\n   constraints are strongly recommended for other uses of [RFC5444].\n"
  title: 3.  Applicability Statement
- contents:
  - "4.  Information Transmission\n   Protocols need to transmit information from
    one instance implementing\n   the protocol to another.\n"
  - contents:
    - "4.1.  Where to Record Information\n   A protocol has the following choices
      as to where to put information\n   for transmission:\n   o  in a TLV to be added
      to the Packet Header;\n   o  in a message of a type owned by another protocol;
      or\n   o  in a message of a type owned by the protocol.\n   The first case (a
      Packet TLV) can only be used when the information\n   is to be carried one hop.
      \ It SHOULD only be used either where the\n   information relates to the packet
      as a whole (for example, packet\n   integrity check values and timestamps, as
      specified in [RFC7182]) or\n   if the information is expected to have a wider
      application than a\n   single protocol.  A protocol can also request that the
      Packet Header\n   include Packet Sequence Numbers but does not control those
      numbers.\n   The second case (in a message of a type owned by another protocol)
      is\n   only possible if the adding protocol is an extension to the owning\n
      \  protocol; for example, OLSRv2 [RFC7181] is an extension of NHDP\n   [RFC6130].\n
      \  The third case is the normal case for a new protocol.\n   A protocol extension
      can either be simply an update of the protocol\n   (the third case) or be a
      new protocol that also updates another\n   protocol (the second case).  An example
      of the latter is that OLSRv2\n   [RFC7181] is a protocol that also extends the
      HELLO message owned by\n   NHDP [RFC6130]; it is thus an example of both the
      second and third\n   cases (the latter using the OLSRv2 owned Topology Control
      (TC)\n   message).  An extension to [RFC5444], such as [RFC7182], is\n   considered
      to be an extension to all protocols.  Protocols SHOULD be\n   designed to enable
      extension by any of these means to be possible,\n   and some of the rules in
      this document (in Sections 4.6 and 4.8,\n   specifically) are to help facilitate
      that.\n"
    title: 4.1.  Where to Record Information
  - contents:
    - "4.2.  Message and TLV Type Allocation\n   Protocols SHOULD be conservative
      in the number of new Message Types\n   that they require, as the total available
      number of allocatable\n   Message Types is only 224.  Protocol design SHOULD
      consider whether\n   different functions can be implemented by differences in
      TLVs carried\n   in the same Message Type rather than using multiple Message
      Types.\n   The TLV Type space, although greater than the Message Type space,\n
      \  SHOULD also be used efficiently.  The Full Type of a TLV occupies two\n   octets;
      thus, there are many more available TLV Full Types than there\n   are Message
      Types.  However, in some cases (currently LINK_METRIC\n   from [RFC7181] and
      ICV and TIMESTAMP from [RFC7182], all in the\n   global TLV Type space), a TLV
      Type with a complete set of 256 TLV\n   Full Types is defined (but not necessarily
      allocated).\n   Each Message Type has an associated block of Message-Type-specific\n
      \  TLV Types (128 to 233, each with 256 type extensions) both for\n   Address
      Block TLV Types and Message TLV Types.  TLV Types from within\n   these blocks
      SHOULD be used in preference to the Message-Type-\n   independent Message TLV
      Types (0 to 127, each with 256 type\n   extensions) when a TLV is specific to
      a message.\n   The Expert Review guidelines in [RFC5444] are updated accordingly,
      as\n   described in Section 8.\n"
    title: 4.2.  Message and TLV Type Allocation
  - contents:
    - "4.3.  Message Recognition\n   A message contains a Message Header and a Message
      Body; note that the\n   Message TLV Block is considered part of the latter.
      \ The Message\n   Header contains information whose primary purpose is to decide\n
      \  whether to process the message and whether to forward the message.\n   A
      protocol might need to recognize whether a message, especially a\n   flooded
      message, is one that it has previously received (for example,\n   to determine
      whether to process and/or forward it, or to discard it).\n   A message can be
      recognized as one that has been previously seen if\n   it contains sufficient
      information in its Message Header.  A message\n   MUST be so recognized by the
      combination of its Message Type,\n   Originator Address, and Message Sequence
      Number.  The inclusion of\n   Message Type allows each protocol to manage its
      own Message Sequence\n   Numbers and also allows for the possibility that different
      Message\n   Types can have greatly differing transmission rates.  As an example\n
      \  of such use, [RFC7181] contains a general purpose process for\n   managing
      processing and forwarding decisions, although specifically\n   for use with
      MPR flooding.  (Blind flooding can be handled similarly\n   by assuming that
      all other routers are MPR selectors; it is not\n   necessary in this case to
      differentiate between interfaces on which a\n   message is received.)\n   Most
      protocol information is thus contained in the Message Body.  A\n   model of
      how such information can be viewed is described in Sections\n   4.5 and 4.6.
      \ To use that model, addresses (for example, of\n   neighboring or otherwise
      known routers) SHOULD be recorded in Address\n   Blocks, not as data in TLVs.
      \ Recording addresses in TLV Value fields\n   both breaks the model of addresses
      as identities and associated\n   information (attributes) and also inhibits
      address compression.\n   However, in some cases, alternative addresses (e.g.,
      hardware\n   addresses when the Address Block is recording IP addresses) can
      be\n   carried as TLV Values.  Note that a message contains a Message\n   Address
      Length field that can be used to allow carrying alternative\n   message sizes,
      but only one length of addresses can be used in a\n   single message, in all
      Address Blocks and the Originator Address, and\n   is established by the router
      and protocol generating the message.\n"
    title: 4.3.  Message Recognition
  - contents:
    - "4.4.  Message Multiplexing and Packets\n   The multiplexer has to handle message
      multiplexing into packets and\n   the transmission of said packets, as well
      as packet reception and\n   demultiplexing into messages.  The multiplexer and
      the protocols that\n   use it are subject to the following rules.\n"
    - contents:
      - "4.4.1.  Packet Transmission\n   Packets are formed for transmission through
        the following steps:\n   o  Outgoing messages are created by their owning
        protocol and MAY be\n      modified by any extending protocols if the owning
        protocol permits\n      this.  Messages MAY also be forwarded by their owning
        protocol.\n      It is strongly RECOMMENDED that messages are not modified
        in the\n      latter case, other than updates to their hop count and hop limit\n
        \     fields, as described in Section 7.1.1 of [RFC5444].  Note that\n      this
        includes having an identical octet representation, including\n      not allowing
        a different TLV representation of the same\n      information.  This is because
        it enables end-to-end authentication\n      that ignores (zeros) those two
        fields (only), as is done in the\n      Message TLV ICV (Integrity Check Value)
        calculations in [RFC7182].\n      Protocols MUST document their behavior with
        regard to\n      modifiability of messages.\n   o  Outgoing messages are then
        sent to the multiplexer.  The owning\n      protocol MUST indicate which interface(s)
        the messages are to be\n      sent on and their destination address.  Note
        that packets travel\n      one hop; the destination is therefore either a
        link-local\n      multicast address (if the packet is being multicast) or
        the\n      address of the neighbor interface to which the packet is sent.\n
        \  o  The owning protocol MAY request that messages are kept together in\n
        \     a packet; the multiplexer SHOULD respect this request if at all\n      possible.
        \ The multiplexer SHOULD combine messages that are sent\n      on the same
        interface in a packet, whether from the same or\n      different protocols,
        provided that in so doing the multiplexer\n      does not cause an IP packet
        to exceed the current Maximum\n      Transmission Unit (MTU).  Note that the
        multiplexer cannot\n      fragment messages; creating suitably sized messages
        that will not\n      cause the MTU to be exceeded if sent in a single message
        packet is\n      the responsibility of the protocol generating the message.
        \ If a\n      larger message is created, then only IP fragmentation is available\n
        \     to allow the packet to be sent; this is generally considered\n      undesirable,
        especially when transmission can be unreliable.\n   o  The multiplexer MAY
        delay messages in order to assemble more\n      efficient packets.  It MUST
        respect any constraints on such delays\n      requested by the protocol if
        it is practical to do so.\n   o  If requested by a protocol, the multiplexer
        MUST (and otherwise\n      MAY) include a Packet Sequence Number in the packet.
        \ Such a\n      request MUST be respected as long as the protocol is active.
        \ Note\n      that the errata to [RFC5444] indicates that the Packet Sequence\n
        \     Number SHOULD be specific to the interface on which the packet is\n
        \     sent.  This specification updates [RFC5444] by requiring that this\n
        \     sequence number MUST be specific to that interface and also that\n      separate
        sequence numbers MUST be maintained for each destination\n      to which packets
        are sent with included Packet Sequence Numbers.\n      Addition of Packet
        Sequence Numbers MUST be consistent (i.e., for\n      each interface and destination,
        the Packet Sequence Number MUST be\n      added to all packets or to none).\n
        \  o  An extension to the multiplexer MAY add TLVs to the packet.  It\n      MAY
        also add TLVs to the messages, in which case it is considered\n      as also
        extending the corresponding protocols.  For example,\n      [RFC7182] can
        be used by the multiplexer to add Packet TLVs or\n      Message TLVs, or it
        can be used by the protocol to add Message\n      TLVs.\n"
      title: 4.4.1.  Packet Transmission
    - contents:
      - "4.4.2.  Packet Reception\n   When a packet is received, the following steps
        are performed by the\n   demultiplexer and by protocols:\n   o  The Packet
        Header and the organization into the messages that it\n      contains MUST
        be verified by the demultiplexer.\n   o  The packet and/or the messages it
        contains MAY also be verified by\n      an extension to the demultiplexer,
        such as [RFC7182].\n   o  Each message MUST be sent to its owning protocol
        or discarded if\n      the Message Type is not recognized.  The demultiplexer
        MUST also\n      make available to the protocol the Packet Header and the
        source\n      and destination addresses in the IP datagram that included the\n
        \     packet.\n   o  The demultiplexer MUST remove any Message TLVs that were
        added by\n      an extension to the multiplexer.  The message MUST be passed
        on to\n      the protocol exactly as received from (another instance of) the\n
        \     protocol.  This is, in part, an implementation detail.  For\n      example,
        an implementation of the multiplexer and of [RFC7182]\n      could add a Message
        TLV either in the multiplexer or in the\n      protocol and remove it in the
        same place on reception.  An\n      implementation MUST ensure that the message
        passed to a protocol\n      is as it would be passed from that protocol by
        the same\n      implementation, i.e., that the combined implementation on
        a router\n      is self-consistent, and that messages included in packets
        by the\n      multiplexer are independent of this implementation detail.\n
        \  o  The owning protocol MUST verify each message for correctness; it\n      MUST
        allow any extending protocol(s) to also contribute to this\n      verification.\n
        \  o  The owning protocol MUST process each message.  In some cases,\n      which
        will be defined in the protocol specification, this\n      processing will
        determine that the message will be ignored.\n      Except in the latter case,
        the owning protocol MUST also allow any\n      extending protocols to process
        the message.\n   o  The owning protocol MUST manage the hop count and/or hop
        limit in\n      the message.  It is RECOMMENDED that these are handled as\n
        \     described in Appendix B of [RFC5444]; they MUST be so handled if\n      using
        hop-count-dependent TLVs such as those defined in [RFC5497].\n"
      - contents:
        - "4.4.2.1.  Other Information\n   In addition to the messages between the
          multiplexer and the protocols\n   in each direction, the following additional
          information (summarized\n   from other sections in this specification) can
          be exchanged.\n   o  The packet source and destination addresses MUST be
          sent from the\n      demultiplexer to the protocol.\n   o  The Packet Header,
          including the Packet Sequence Number, MUST be\n      sent from the (de)multiplexer
          to the protocol if present.  (An\n      implementation MAY choose to only
          do so or only report the Packet\n      Sequence Number, on request.)\n   o
          \ A protocol MAY require that all outgoing packets contain a Packet\n      Sequence
          Number.\n   o  The interface over which a message is to be sent and its\n
          \     destination address MUST be sent from protocol to multiplexer.\n      The
          destination address MAY be a multicast address, in particular,\n      the
          LL-MANET-Routers link-local multicast address defined in\n      [RFC5498].\n
          \  o  A request to keep messages together in one packet MAY be sent from\n
          \     protocol to multiplexer.\n   o  A requested maximum message delay
          MAY be sent from protocol to\n      multiplexer.\n   The protocol SHOULD
          also be aware of the MTU that will apply to its\n   messages, if this is
          available.\n"
        title: 4.4.2.1.  Other Information
      title: 4.4.2.  Packet Reception
    title: 4.4.  Message Multiplexing and Packets
  - contents:
    - "4.5.  Messages, Addresses, and Attributes\n   The information in a Message
      Body, including Message TLVs and Address\n   Block TLVs, consists of:\n   o
      \ Attributes of the message, in which each attribute consists of a\n      Full
      Type, a length, and a Value (of that length).\n   o  A set of addresses, which
      are carried in one or more Address\n      Blocks.\n   o  Attributes of each
      address, in which each attribute consists of a\n      Full Type, a length, and
      a Value (of that length).\n   Attributes are carried in TLVs.  For Message TLVs,
      the mapping from\n   TLV to attribute is one to one.  For Address Block TLVs,
      the mapping\n   from TLV to attribute is one to many: one TLV can carry attributes\n
      \  for multiple addresses, but only one attribute per address.\n   Attributes
      for different addresses can be the same or different.\n   [RFC5444] requires
      that when a TLV Full Type is defined, then it MUST\n   also define how to handle
      the cases of multiple TLVs of the same type\n   applying to the same information
      element - i.e., when more than one\n   Packet TLV of the same TLV Full Type
      is included in the same Packet\n   Header, when more than one Message TLV of
      the same TLV Full Type is\n   included in the same Message TLV Block, or when
      more than one Address\n   Block TLV of the same TLV Full Type applies to the
      same value of any\n   address.  It is RECOMMENDED that when defining a new TLV
      Full Type, a\n   rule of the following form is adopted.\n   o  If used, there
      MUST be only one TLV of that Full Type associated\n      with the packet (Packet
      TLV), message (Message TLV), or any value\n      of any address (Address Block
      TLV).\n   Note that this applies to address values; an address can appear more\n
      \  than once in a message, but the restriction on associating TLVs with\n   addresses
      covers all copies of that address.  It is RECOMMENDED that\n   addresses are
      not repeated in a message.\n   A conceptual way to view this information is
      described in Appendix A.\n"
    title: 4.5.  Messages, Addresses, and Attributes
  - contents:
    - "4.6.  Addresses Require Attributes\n   It is not mandatory in [RFC5444] to
      associate an address with\n   attributes using Address Block TLVs.  Information
      about an address\n   could thus, in principle, be carried using:\n   o  The
      simple presence of an address.\n   o  The ordering of addresses in an Address
      Block.\n   o  The use of different meanings for different Address Blocks.\n
      \  This specification, however, requires that those methods of carrying\n   information
      MUST NOT be used for any protocol using [RFC5444].\n   Information about the
      meaning of an address MUST only be carried\n   using Address Block TLVs.\n   In
      addition, rules for the extensibility of OLSRv2 and NHDP are\n   described in
      [RFC7188].  This specification extends their\n   applicability to other uses
      of [RFC5444].\n   These rules are:\n   o  A protocol MUST NOT assign any meaning
      to the presence or absence\n      of an address (either in a Message or in a
      given Address Block in\n      a Message), to the ordering of addresses in an
      Address Block, or\n      to the division of addresses among Address Blocks.\n
      \  o  A protocol MUST NOT reject a message based on the inclusion of a\n      TLV
      of an unrecognized type.  The protocol MUST ignore any such\n      TLVs when
      processing the message.  The protocol MUST NOT remove or\n      change any such
      TLVs if the message is to be forwarded unchanged.\n   o  A protocol MUST NOT
      reject a message based on the inclusion of an\n      unrecognized Value in a
      TLV of a recognized type.  The protocol\n      MUST ignore any such Values when
      processing the message but MUST\n      NOT ignore recognized Values in such
      a TLV.  The protocol MUST NOT\n      remove or change any such TLVs if the message
      is to be forwarded\n      unchanged.\n   o  Similar restrictions to the two
      preceding points apply to the\n      demultiplexer, which also MUST NOT reject
      a packet based on an\n      unrecognized message; although it will reject any
      such messages,\n      it MUST deliver any other messages in the packet to their
      owning\n      protocols.\n   The following points indicate the reasons for these
      rules based on\n   considerations of extensibility and efficiency.\n   Assigning
      a meaning to the presence, absence, or location of an\n   address would reduce
      the extensibility of the protocol, prevent the\n   approach to information representation
      described in Appendix A, and\n   reduce the options available for message optimization
      described in\n   Section 6.\n   To consider how the simple presence of an address
      conveying\n   information would have restricted the development of an extension,\n
      \  two examples are considered: one actual (included in the base\n   specification,
      but which could have been added later) and one\n   hypothetical.\n   The basic
      function of NHDP's HELLO messages [RFC6130] is to indicate\n   that addresses
      are of neighbors, using the LINK_STATUS and\n   OTHER_NEIGHB TLVs.  (The message
      can also indicate the router's own\n   addresses, which could also serve as
      a further example.)\n   An extension to NHDP might decide to use the HELLO message
      to report\n   that an address is one that could be used for a specialized purpose\n
      \  rather than for normal NHDP-based purposes.  Such an example already\n   exists
      in the use of LOST Values in the LINK_STATUS and OTHER_NEIGHB\n   TLVs to report
      that an address is of a router known not to be a\n   neighbor.\n   A future
      example could be to indicate that an address is to be added\n   to a \"blacklist\"
      of addresses not to be used.  This would use a new\n   TLV (or a new Value of
      an existing TLV, see below).  If no other TLVs\n   were attached to such a blacklisted
      address, then an unmodified\n   implementation of NHDP would ignore that address,
      as required; if any\n   other TLVs were attached to that address, then that
      implementation\n   would process that address for those TLVs.  Had NHDP been
      designed so\n   that just the presence of an address indicated a neighbor, this\n
      \  blacklist extension would not be possible, as an unmodified\n   implementation
      of NHDP would treat all blacklisted addresses as\n   neighbors.\n   Rejecting
      a message because it contains an unrecognized TLV Type or\n   an unrecognized
      TLV Value reduces the extensibility of the protocol.\n   For example, OLSRv2
      [RFC7181] is, among other things, an extension to\n   NHDP.  It adds information
      to addresses in an NHDP HELLO message\n   using a LINK_METRIC TLV.  A non-OLSRv2
      implementation of NHDP (for\n   example, to support Simplified Multicast Flooding
      (SMF) [RFC6621])\n   will still process the HELLO message, ignoring the LINK_METRIC
      TLVs.\n   Also, the blacklisting described in the example above could be\n   signaled
      not with a new TLV but with a new Value of a LINK_STATUS or\n   OTHER_NEIGHB
      TLV (requiring an IANA allocation as described in\n   [RFC7188]), as is already
      done in the LOST case.\n   The creation of Multi-Topology OLSRv2 (MT-OLSRv2)
      [RFC7722], as an\n   extension to OLSRv2 that can interoperate with unextended
      instances\n   of OLSRv2, would not have been possible without these restrictions\n
      \  (which were applied to NHDP and OLSRv2 by [RFC7188]).\n   These restrictions
      do not, however, mean that added information is\n   completely ignored for purposes
      of the base protocol.  Suppose that a\n   faulty implementation of OLSRv2 (including
      NHDP) creates a HELLO\n   message that assigns two different values of the same
      link metric to\n   an address, something that is not permitted by [RFC7181].
      \ A\n   receiving OLSRv2-aware implementation of NHDP will reject such a\n   message,
      even though a receiving OLSRv2-unaware implementation of\n   NHDP will process
      it.  This is because the OLSRv2-aware\n   implementation has access to additional
      information (that the HELLO\n   message is definitely invalid and the message
      is best ignored) as it\n   is unknown what other errors it might contain.\n"
    title: 4.6.  Addresses Require Attributes
  - contents:
    - "4.7.  TLVs\n   Within a message, the attributes are represented by TLVs.\n
      \  Particularly for Address Block TLVs, different TLVs can represent the\n   same
      information.  For example, using the LINK_STATUS TLV defined in\n   [RFC6130],
      if some addresses have Value SYMMETRIC and some have Value\n   HEARD, arranged
      in that order, then this information can be\n   represented using two single-value
      TLVs or one multivalue TLV.  The\n   latter can be used even if the addresses
      are not so ordered.\n   A protocol MAY use any representation of information
      using TLVs that\n   convey the required information.  A protocol SHOULD use
      an efficient\n   representation, but this is a quality of implementation issue.
      \ A\n   protocol MUST recognize any permitted representation of the\n   information;
      even if it chooses to, for example, only use multivalue\n   TLVs, it MUST recognize
      single-value TLVs (and vice versa).\n   A protocol defining new TLVs MUST respect
      the naming and\n   organizational rules in [RFC7631].  It SHOULD follow the
      guidance in\n   [RFC7188], see Section 6.3.  (This specification does not, however,\n
      \  relax the application of [RFC7188] where it is mandated.)\n"
    title: 4.7.  TLVs
  - contents:
    - "4.8.  Message Integrity\n   In addition to not rejecting a message due to unknown
      TLVs or TLV\n   Values, a protocol MUST NOT reject a message based on the inclusion\n
      \  of a TLV of an unrecognized type.  The protocol MUST ignore any such\n   TLVs
      when processing the message.  The protocol MUST NOT remove or\n   change any
      such TLVs if the message is to be forwarded unchanged.\n   Such behavior may
      have the following consequences:\n   o  It might disrupt the operation of an
      extension of which it is\n      unaware.  Note that it is the responsibility
      of a protocol\n      extension to handle interoperation with unextended instances
      of\n      the protocol.  For example, OLSRv2 [RFC7181] adds an MPR_WILLING\n
      \     TLV to HELLO messages (created by NHDP [RFC6130], of which it is\n      an
      extension) to recognize this case (and for other reasons).\n   o  It would prevent
      the operation of end-to-end message\n      authentication using [RFC7182] or
      any similar mechanism.  The use\n      of immutable (apart from hop count and/or
      hop limit) messages by a\n      protocol is strongly RECOMMENDED for that reason.\n"
    title: 4.8.  Message Integrity
  title: 4.  Information Transmission
- contents:
  - "5.  Structure\n   This section concerns the properties of the format defined
    in\n   [RFC5444] itself, rather than the properties of protocols using it.\n   The
    elements defined in [RFC5444] have structures that are managed by\n   a number
    of flags fields:\n   o  Packet flags field (4 bits, 2 used) that manages the contents
    of\n      the Packet Header.\n   o  Message flags field (4 bits, 4 used) that
    manages the contents of\n      the Message Header.\n   o  Address Block flags
    field (8 bits, 4 used) that manages the\n      contents of an Address Block.\n
    \  o  TLV flags field (8 bits, 5 used) that manages the contents of a\n      TLV.\n
    \  Note that all of these flags are structural; they specify which\n   elements
    are present or absent, field lengths, or whether a field has\n   one or multiple
    values in it.\n   In the current version of [RFC5444], indicated by version number
    0 in\n   the <version> field of the Packet Header, unused bits in these flags\n
    \  fields are stated as \"are RESERVED and SHOULD each be cleared ('0')\n   on
    transmission and SHOULD be ignored on reception\".  For the\n   avoidance of any
    compatibility issues, with regard to version number\n   0, this is updated to
    \"MUST each be cleared ('0') on transmission and\n   MUST be ignored on reception\".\n
    \  If a specification updating [RFC5444] introduces new flags in one of\n   the
    flags fields of a packet, Address Block, or TLV (there being no\n   unused flags
    in the message flags field), the following rules MUST be\n   followed:\n   o  The
    version number contained in the <version> field of the Packet\n      Header MUST
    NOT be 0.\n   o  The new flag(s) MUST indicate the structure of the corresponding\n
    \     packet, Address Block, or TLV.  They MUST NOT be used to indicate\n      any
    other semantics, such as message forwarding behavior.\n   An update that would
    be incompatible with the current specification\n   of [RFC5444] SHOULD NOT be
    created unless there is a pressing reason\n   for it that cannot be satisfied
    using the current specification\n   (e.g., by use of a suitable Message TLV or
    Address Block TLV).\n   During the development of [RFC5444] (and since publication
    thereof),\n   some proposals have been made to use these RESERVED flags to specify\n
    \  behavior rather than structure, message forwarding in particular.\n   These
    proposals were, after due consideration, not accepted for a\n   number of reasons.
    \ These reasons include that message forwarding, in\n   particular, is protocol
    specific; for example, [RFC7181] forwards\n   messages using its MPR mechanism
    rather than a \"blind\" flooding\n   mechanism.  (These proposals were made during
    the development of\n   [RFC5444] when there were still unused message flags.  Later
    addition\n   of a 4-bit Message Address Length field later left no unused message\n
    \  flags, but other flags fields still have unused flags.)\n"
  title: 5.  Structure
- contents:
  - "6.  Message Efficiency\n   The ability to organize addresses into the same or
    different Address\n   Blocks and to change the order of addresses within an Address
    Block\n   (as well as the flexibility of the TLV specification) enables\n   avoiding
    unnecessary repetition of information and can consequently\n   generate smaller
    messages.  There are no algorithms for address\n   organization, compression,
    or for TLV usage in [RFC5444]; any\n   algorithms that leave the information content
    unchanged MAY be used\n   when generating a message.  See also Appendix B.\n"
  - contents:
    - "6.1.  Address Block Compression\n   [RFC5444] allows the addresses in an Address
      Block to be compressed.\n   A protocol generating a message SHOULD compress
      addresses as much as\n   it can.\n   Addresses in an Address Block consist of
      a Head, a Mid, and a Tail,\n   where all addresses in an Address Block have
      the same Head and Tail\n   but different Mids.  Each has a length that is greater
      than or equal\n   to zero, the sum of the lengths being the address length.
      \ (The Mid\n   length is deduced from this relationship.)  Compression is possible\n
      \  when the Head and/or the Tail have non-zero length.  An additional\n   compression
      is possible when the Tail consists of all zero-valued\n   octets.  Expected
      use cases include IPv4 and IPv6 addresses from\n   within the same prefix and
      that therefore have a common Head, IPv4\n   subnets with a common zero-valued
      Tail, and IPv6 addresses with a\n   common Tail representing an interface identifier
      as well as having a\n   possible common Head.  Note that when, for example,
      IPv4 addresses\n   have a common Head, their Tail will usually have length zero.\n
      \  For example:\n   o  The IPv4 addresses 192.0.2.1 and 192.0.2.2 would, for
      greatest\n      efficiency, have a 3-octet Head, a 1-octet Mid, and a 0-octet\n
      \     Tail.\n   o  The IPv6 addresses 2001:DB8:prefix1:interface and\n      2001:DB8:prefix2:interface
      that use the same interface identifier\n      but completely different prefixes
      (except as noted) would, for\n      greatest efficiency, have a 4-octet head,
      a 4-octet Mid, and an\n      8-octet Tail.  (They could have a larger Head and/or
      Tail and a\n      smaller Mid if the prefixes have any octets in common.)\n
      \  Putting addresses into a message efficiently also requires\n   consideration
      of the following:\n   o  The split of the addresses into Address Blocks.\n   o
      \ The order of the addresses within the Address Blocks.\n   This split and/or
      ordering is for efficiency only; it does not\n   provide any information.  The
      split of the addresses affects both the\n   address compression and the TLV
      efficiency (see Section 6.2); the\n   order of the addresses within an Address
      Block affects only the TLV\n   efficiency.  However, using more Address Blocks
      than needed can\n   increase the message size due to the overhead of each Address
      Block\n   and the following TLV Block, and/or if additional TLVs are now\n   required.\n
      \  The order of addresses can be as simple as sorting the addresses, but\n   if
      many addresses have the same TLV Types attached, it might be more\n   useful
      to put these addresses together, either within the same\n   Address Block as
      other addresses or in a separate Address Block.  A\n   separate Address Block
      might also improve address compression, for\n   example, if more than one address
      form is used (such as from\n   independent subnets).  An example of the possible
      use of address\n   ordering is a HELLO message from [RFC6130] that could be
      generated\n   with local interface addresses first and neighbor addresses later.\n
      \  These could be in separate Address Blocks.\n"
    title: 6.1.  Address Block Compression
  - contents:
    - "6.2.  TLVs\n   When considering TLVs, the main opportunities for creating more\n
      \  efficient messages are in Address Block TLVs rather than Message\n   TLVs.
      \ The approaches described here apply to each Address Block.\n   An Address
      Block TLV provides attributes for one address or a\n   contiguous (as stored
      in the Address Block) set of addresses (with a\n   special case for when this
      set is of all of the addresses in the\n   Address Block).  When associated with
      more than one address, a TLV\n   can be single value (associating the same attribute
      with each\n   address) or multivalue (associating a separate attribute with
      each\n   address).\n   The approach that is simplest to implement is to use
      multivalue TLVs\n   that cover all affected addresses.  However, unless care
      is taken to\n   order addresses appropriately, these affected addresses might
      not all\n   be contiguous.  Some approaches to this are the following:\n   o
      \ Reorder the addresses.  It is, for example, possible (though not\n      straightforward,
      and beyond the scope of this document to describe\n      exactly how) to order
      all addresses in HELLO message as specified\n      in [RFC6130] so that all
      TLVs used only cover contiguous\n      addresses.  This is even possible if
      the MPR TLV specified in\n      OLSRv2 [RFC7181] is added; but it is not possible,
      in general, if\n      the LINK_METRIC TLV specified in OLSRv2 [RFC7181] is also
      added.\n   o  Allow the TLV to span over addresses that do not need the\n      corresponding
      attribute and use a Value that indicates no\n      information; see Section
      6.3.\n   o  Use more than one TLV.  Note that this can be efficient when the\n
      \     TLVs become single-value TLVs.  In a typical case where a\n      LINK_STATUS
      TLV uses only the Values HEARD and SYMMETRIC, with\n      enough addresses sorted
      appropriately, two single-value TLVs can\n      be more efficient than one multivalue
      TLV.  If only one Value is\n      involved (such as NHDP in a steady state with
      LINK_STATUS equal to\n      SYMMETRIC in all cases) then one single-value TLV
      SHOULD always be\n      used.\n"
    title: 6.2.  TLVs
  - contents:
    - "6.3.  TLV Values\n   If, for example, an Address Block contains five addresses,
      the first\n   two and the last two requiring Values assigned using a LINK_STATUS\n
      \  TLV but the third does not, then this can be indicated using two\n   TLVs.
      \ It is, however, more efficient to do this with one multivalue\n   LINK_STATUS
      TLV, assigning the third address the Value UNSPECIFIED\n   (as defined in [RFC7188]).
      \ In general, use of UNSPECIFIED Values\n   allows use of fewer TLVs and is
      thus often an efficiency gain;\n   however, a long run of consecutive UNSPECIFIED
      Values (more than the\n   overhead of a TLV) can make use of more TLVs more
      efficient.\n   Some other TLVs might need a different approach.  As noted in\n
      \  [RFC7188], but implicitly permissible before then, the LINK_METRIC\n   TLV
      (defined in [RFC7181]) has two octet Values whose first four bits\n   are flags
      indicating whether the metric applies in four cases; if\n   these are all zero,
      then the metric does not apply in this case,\n   which is thus the equivalent
      of an UNSPECIFIED Value.\n   [RFC7188] requires that protocols that extend [RFC6130]
      and [RFC7181]\n   allow unspecified values in TLVs where applicable; it is here\n
      \  RECOMMENDED that all protocols follow that advice.  In particular, it\n   is
      RECOMMENDED that when defining an Address Block TLV with discrete\n   Values,
      an UNSPECIFIED Value is defined with the same value (255),\n   and a modified
      approach should be used where possible for other\n   Address Block TLVs (for
      example, as is done for a LINK_METRIC TLV,\n   though not necessarily using
      that exact approach).\n   It might be argued that provision of an unspecified
      value (of any\n   form) to allow an Address Block TLV to cover unaffected addresses
      is\n   not always necessary because addresses can be reordered to avoid\n   this.
      \ However, ordering addresses to avoid this for all TLVs that\n   might be used
      is not, in general, possible.\n   In addition, [RFC7188] recommends that if
      a TLV Value (per address\n   for an Address Block TLV) has a single-length that
      does not match the\n   defined length for that TLV Type, then the following
      rules are\n   adopted:\n   o  If the received single-length is greater than
      the expected single\n      length, then the excess octets MUST be ignored.\n
      \  o  If the received single-length is less than the expected single\n      length,
      then the absent octets MUST be considered to have all bits\n      cleared (0).\n
      \  This specification RECOMMENDS a similar rule for all protocols\n   defining
      new TLVs.\n"
    title: 6.3.  TLV Values
  title: 6.  Message Efficiency
- contents:
  - "7.  Security Considerations\n   This document does not specify a protocol but
    provides rules and\n   recommendations for how to design protocols using [RFC5444],
    whose\n   security considerations apply.\n   If the recommendation from Section
    4.4.1 is followed, which specifies\n   that messages are not modified (except
    for hop count and hop limit)\n   when forwarded, then the security framework for
    [RFC5444] (specified\n   in [RFC7182]) can be used in full.  If that recommendation
    is not\n   followed, then the Packet TLVs from [RFC7182] can be used, but the\n
    \  Message TLVs from [RFC7182] cannot be used as intended.\n   In either case,
    a protocol using [RFC5444] MUST document whether it\n   is using [RFC7182] and
    if so, how.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   The Expert Review guidelines in [RFC5444] are updated
    to include the\n   general requirement that:\n   o  The Designated Expert will
    consider the limited TLV and\n      (especially) Message Type space when considering
    whether a\n      requested allocation is allowed and whether a more efficient\n
    \     allocation than that requested is possible.\n   IANA has added this document
    as a reference for the following Mobile\n   Ad hoc NETwork (MANET) Parameters
    registries:\n   o  Message Types\n   o  Packet TLV Types\n   o  Message TLV Types\n
    \  o  Address Block TLV Types\n"
  title: 8.  IANA Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC5444]  Clausen, T., Dearlove, C., Dean, J., and C. Adjih,\n              \"Generalized
      Mobile Ad Hoc Network (MANET) Packet/Message\n              Format\", RFC 5444,
      DOI 10.17487/RFC5444, February 2009,\n              <https://www.rfc-editor.org/info/rfc5444>.\n
      \  [RFC5498]  Chakeres, I., \"IANA Allocations for Mobile Ad Hoc Network\n              (MANET)
      Protocols\", RFC 5498, DOI 10.17487/RFC5498, March\n              2009, <https://www.rfc-editor.org/info/rfc5498>.\n
      \  [RFC7182]  Herberg, U., Clausen, T., and C. Dearlove, \"Integrity\n              Check
      Value and Timestamp TLV Definitions for Mobile Ad\n              Hoc Networks
      (MANETs)\", RFC 7182, DOI 10.17487/RFC7182,\n              April 2014, <https://www.rfc-editor.org/info/rfc7182>.\n
      \  [RFC7631]  Dearlove, C. and T. Clausen, \"TLV Naming in the Mobile Ad\n              Hoc
      Network (MANET) Generalized Packet/Message Format\",\n              RFC 7631,
      DOI 10.17487/RFC7631, September 2015,\n              <https://www.rfc-editor.org/info/rfc7631>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [G9903]    ITU-T, \"G.9903 : Narrowband orthogonal
      frequency division\n              multiplexing power line communication transceivers
      for\n              G3-PLC networks\", ITU-T Recommendation G.9903, August\n
      \             2017.\n   [RFC3626]  Clausen, T., Ed. and P. Jacquet, Ed., \"Optimized
      Link\n              State Routing Protocol (OLSR)\", RFC 3626,\n              DOI
      10.17487/RFC3626, October 2003,\n              <https://www.rfc-editor.org/info/rfc3626>.\n
      \  [RFC5497]  Clausen, T. and C. Dearlove, \"Representing Multi-Value\n              Time
      in Mobile Ad Hoc Networks (MANETs)\", RFC 5497,\n              DOI 10.17487/RFC5497,
      March 2009,\n              <https://www.rfc-editor.org/info/rfc5497>.\n   [RFC6130]
      \ Clausen, T., Dearlove, C., and J. Dean, \"Mobile Ad Hoc\n              Network
      (MANET) Neighborhood Discovery Protocol (NHDP)\",\n              RFC 6130, DOI
      10.17487/RFC6130, April 2011,\n              <https://www.rfc-editor.org/info/rfc6130>.\n
      \  [RFC6621]  Macker, J., Ed., \"Simplified Multicast Forwarding\",\n              RFC
      6621, DOI 10.17487/RFC6621, May 2012,\n              <https://www.rfc-editor.org/info/rfc6621>.\n
      \  [RFC7181]  Clausen, T., Dearlove, C., Jacquet, P., and U. Herberg,\n              \"The
      Optimized Link State Routing Protocol Version 2\",\n              RFC 7181,
      DOI 10.17487/RFC7181, April 2014,\n              <https://www.rfc-editor.org/info/rfc7181>.\n
      \  [RFC7183]  Herberg, U., Dearlove, C., and T. Clausen, \"Integrity\n              Protection
      for the Neighborhood Discovery Protocol (NHDP)\n              and Optimized
      Link State Routing Protocol Version 2\n              (OLSRv2)\", RFC 7183, DOI
      10.17487/RFC7183, April 2014,\n              <https://www.rfc-editor.org/info/rfc7183>.\n
      \  [RFC7188]  Dearlove, C. and T. Clausen, \"Optimized Link State Routing\n
      \             Protocol Version 2 (OLSRv2) and MANET Neighborhood\n              Discovery
      Protocol (NHDP) Extension TLVs\", RFC 7188,\n              DOI 10.17487/RFC7188,
      April 2014,\n              <https://www.rfc-editor.org/info/rfc7188>.\n   [RFC7722]
      \ Dearlove, C. and T. Clausen, \"Multi-Topology Extension for\n              the
      Optimized Link State Routing Protocol Version 2\n              (OLSRv2)\", RFC
      7722, DOI 10.17487/RFC7722, December 2015,\n              <https://www.rfc-editor.org/info/rfc7722>.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  Information Representation\n   This section describes a conceptual
    way to consider the information\n   in a message.  It can be used as the basis
    of an approach to parsing\n   a message from the information that it contains
    and to creating a\n   message from the information that it is to contain.  However,
    there\n   is no requirement that a protocol does so.  This approach can be used\n
    \  either to inform a protocol design or by a protocol (or generic\n   parser)
    implementer.\n   A message (excluding the Message Header) can be represented by
    two,\n   possibly multivalued, maps:\n   o  Message: (Full Type) -> (length, Value)\n
    \  o  Address: (address, Full Type) -> (length, Value)\n   These maps (plus a
    representation of the Message Header) can be the\n   basis for a generic representation
    of information in a message.  Such\n   maps can be created by parsing the message
    or can be constructed\n   using the protocol rules for creating a message and
    later converted\n   into the octet form of the message specified in [RFC5444].\n
    \  While of course any implementation of software that represents\n   software
    in the above form can specify an Application Programming\n   Interface (API) for
    that software, such an interface is not proposed\n   here.  First, a full API
    would be specific to a programming language.\n   Second, even within the above
    framework, there are alternative\n   approaches to such an interface.  For example,
    and for illustrative\n   purposes only, consider the alternative address mappings:\n
    \  o  Input: address and Full Type.  Output: list of (length, Value)\n      pairs.
    \ Note that for most Full Types, it will be known in advance\n      that this
    list will have a length of zero or one.  The list of\n      addresses that can
    be used as inputs with non-empty output would\n      need to be provided as a
    separate output.\n   o  Input: Full Type.  Output: list of (address, length, Value)\n
    \     triples.  As this list length can be significant, a possible\n      output
    will be of one or two iterators that will allow iterating\n      through that
    list.  (One iterator that can detect the end of the\n      list or a pair of iterators
    specifying a range.)\n   Additional differences in the interface might relate
    to, for example,\n   the ordering of output lists.\n"
  title: Appendix A.  Information Representation
- contents:
  - "Appendix B.  Automation\n   There is scope for creating a protocol-independent
    optimizer for\n   [RFC5444] messages that performs appropriate address re-organization\n
    \  (ordering and Address Block separation) and TLV changes (of number,\n   of
    being single value or multivalue, and use of unspecified values)\n   to create
    more compact messages.  The possible gain depends on the\n   efficiency of the
    original message creation and the specific details\n   of the message.  Note that
    this process cannot be TLV Type\n   independent; for example, a LINK_METRIC TLV
    has a more complicated\n   Value structure than a LINK_STATUS TLV does if using
    UNSPECIFIED\n   Values.\n   Such a protocol-independent optimizer MAY be used
    by the router\n   generating a message but MUST NOT be used on a message that
    is\n   forwarded unchanged by a router.\n"
  title: Appendix B.  Automation
- contents:
  - "Acknowledgments\n   The authors thank Cedric Adjih (INRIA) and Justin Dean (NRL)
    for\n   their contributions as authors of RFC 5444.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Thomas Clausen\n   Ecole Polytechnique\n   91128 Palaiseau
    Cedex\n   France\n   Phone: +33-6-6058-9349\n   Email: T.Clausen@computer.org\n
    \  URI:   http://www.thomasclausen.org\n   Christopher Dearlove\n   BAE Systems
    Applied Intelligence Laboratories\n   West Hanningfield Road\n   Great Baddow,
    Chelmsford\n   United Kingdom\n   Email: chris.dearlove@baesystems.com\n   URI:
    \  http://www.baesystems.com\n   Ulrich Herberg\n   Email: ulrich@herberg.name\n
    \  URI:   http://www.herberg.name\n   Henning Rogge\n   Fraunhofer FKIE\n   Fraunhofer
    Strasse 20\n   53343 Wachtberg\n   Germany\n   Email: henning.rogge@fkie.fraunhofer.de\n"
  title: Authors' Addresses
