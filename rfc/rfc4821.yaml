- title: __initial_text__
  contents:
  - '                 Packetization Layer Path MTU Discovery

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a robust method for Path MTU Discovery\n\
    \   (PMTUD) that relies on TCP or some other Packetization Layer to probe\n  \
    \ an Internet path with progressively larger packets.  This method is\n   described\
    \ as an extension to RFC 1191 and RFC 1981, which specify\n   ICMP-based Path\
    \ MTU Discovery for IP versions 4 and 6, respectively.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Overview . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  Terminology  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  6\n   4.  Requirements . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  9\n   5.  Layering . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 10\n     5.1.  Accounting for Header Sizes  . . . . . . . . . . . . . .\
    \ . 10\n     5.2.  Storing PMTU Information . . . . . . . . . . . . . . . . .\
    \ 11\n     5.3.  Accounting for IPsec . . . . . . . . . . . . . . . . . . . 12\n\
    \     5.4.  Multicast  . . . . . . . . . . . . . . . . . . . . . . . . 12\n  \
    \ 6.  Common Packetization Properties  . . . . . . . . . . . . . . . 13\n    \
    \ 6.1.  Mechanism to Detect Loss . . . . . . . . . . . . . . . . . 13\n     6.2.\
    \  Generating Probes  . . . . . . . . . . . . . . . . . . . . 13\n   7.  The Probing\
    \ Method . . . . . . . . . . . . . . . . . . . . . . 14\n     7.1.  Packet Size\
    \ Ranges . . . . . . . . . . . . . . . . . . . . 14\n     7.2.  Selecting Initial\
    \ Values . . . . . . . . . . . . . . . . . 16\n     7.3.  Selecting Probe Size\
    \ . . . . . . . . . . . . . . . . . . . 17\n     7.4.  Probing Preconditions \
    \ . . . . . . . . . . . . . . . . . . 18\n     7.5.  Conducting a Probe . . .\
    \ . . . . . . . . . . . . . . . . . 18\n     7.6.  Response to Probe Results \
    \ . . . . . . . . . . . . . . . . 19\n       7.6.1.  Probe Success  . . . . .\
    \ . . . . . . . . . . . . . . . 19\n       7.6.2.  Probe Failure  . . . . . .\
    \ . . . . . . . . . . . . . . 19\n       7.6.3.  Probe Timeout Failure  . . .\
    \ . . . . . . . . . . . . . 20\n       7.6.4.  Probe Inconclusive . . . . . .\
    \ . . . . . . . . . . . . 20\n     7.7.  Full-Stop Timeout  . . . . . . . . .\
    \ . . . . . . . . . . . 20\n     7.8.  MTU Verification . . . . . . . . . . .\
    \ . . . . . . . . . . 21\n   8.  Host Fragmentation . . . . . . . . . . . . .\
    \ . . . . . . . . . 22\n   9.  Application Probing  . . . . . . . . . . . . .\
    \ . . . . . . . . 23\n   10. Specific Packetization Layers  . . . . . . . . .\
    \ . . . . . . . 23\n     10.1. Probing Method Using TCP . . . . . . . . . . .\
    \ . . . . . . 23\n     10.2. Probing Method Using SCTP  . . . . . . . . . . .\
    \ . . . . . 25\n     10.3. Probing Method for IP Fragmentation  . . . . . . .\
    \ . . . . 26\n     10.4. Probing Method Using Applications  . . . . . . . . .\
    \ . . . 27\n   11. Security Considerations  . . . . . . . . . . . . . . . . .\
    \ . . 28\n   12. References . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . 28\n     12.1. Normative References . . . . . . . . . . . . . . . . . . .\
    \ 28\n     12.2. Informative References . . . . . . . . . . . . . . . . . . 29\n\
    \   Appendix A.  Acknowledgments . . . . . . . . . . . . . . . . . . . 31\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes a method for Packetization Layer\
    \ Path MTU\n   Discovery (PLPMTUD), which is an extension to existing Path MTU\n\
    \   Discovery methods described in [RFC1191] and [RFC1981].  In the\n   absence\
    \ of ICMP messages, the proper MTU is determined by starting\n   with small packets\
    \ and probing with successively larger packets.  The\n   bulk of the algorithm\
    \ is implemented above IP, in the transport layer\n   (e.g., TCP) or other \"\
    Packetization Protocol\" that is responsible for\n   determining packet boundaries.\n\
    \   This document does not update RFC 1191 or RFC 1981; however, since it\n  \
    \ supports correct operation without ICMP, it implicitly relaxes some\n   of the\
    \ requirements for the algorithms specified in those documents.\n   The methods\
    \ described in this document rely on features of existing\n   protocols.  They\
    \ apply to many transport protocols over IPv4 and\n   IPv6.  They do not require\
    \ cooperation from the lower layers (except\n   that they are consistent about\
    \ which packet sizes are acceptable) or\n   from peers.  As the methods apply\
    \ only to senders, variants in\n   implementations will not cause interoperability\
    \ problems.\n   For sake of clarity, we uniformly prefer TCP and IPv6 terminology.\n\
    \   In the terminology section, we also present the analogous IPv4 terms\n   and\
    \ concepts for the IPv6 terminology.  In a few situations, we\n   describe specific\
    \ details that are different between IPv4 and IPv6.\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to\
    \ be interpreted as described in [RFC2119].\n   This document is a product of\
    \ the Path MTU Discovery (PMTUD) working\n   group of the IETF and draws heavily\
    \ on RFC 1191 and RFC 1981 for\n   terminology, ideas, and some of the text.\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   Packetization Layer Path MTU Discovery (PLPMTUD) is a method\
    \ for TCP\n   or other Packetization Protocols to dynamically discover the MTU\
    \ of a\n   path by probing with progressively larger packets.  It is most\n  \
    \ efficient when used in conjunction with the ICMP-based Path MTU\n   Discovery\
    \ mechanism as specified in RFC 1191 and RFC 1981, but\n   resolves many of the\
    \ robustness problems of the classical techniques\n   since it does not depend\
    \ on the delivery of ICMP messages.\n   This method is applicable to TCP and other\
    \ transport- or application-\n   level protocols that are responsible for choosing\
    \ packet boundaries\n   (e.g., segment sizes) and have an acknowledgment structure\
    \ that\n   delivers to the sender accurate and timely indications of which\n \
    \  packets were lost.\n   The general strategy is for the Packetization Layer\
    \ to find an\n   appropriate Path MTU by probing the path with progressively larger\n\
    \   packets.  If a probe packet is successfully delivered, then the\n   effective\
    \ Path MTU is raised to the probe size.\n   The isolated loss of a probe packet\
    \ (with or without an ICMP Packet\n   Too Big message) is treated as an indication\
    \ of an MTU limit, and not\n   as a congestion indicator.  In this case alone,\
    \ the Packetization\n   Protocol is permitted to retransmit any missing data without\n\
    \   adjusting the congestion window.\n   If there is a timeout or additional packets\
    \ are lost during the\n   probing process, the probe is considered to be inconclusive\
    \ (e.g.,\n   the lost probe does not necessarily indicate that the probe exceeded\n\
    \   the Path MTU).  Furthermore, the losses are treated like any other\n   congestion\
    \ indication: window or rate adjustments are mandatory per\n   the relevant congestion\
    \ control standards [RFC2914].  Probing can\n   resume after a delay that is determined\
    \ by the nature of the detected\n   failure.\n   PLPMTUD uses a searching technique\
    \ to find the Path MTU.  Each\n   conclusive probe narrows the MTU search range,\
    \ either by raising the\n   lower limit on a successful probe or lowering the\
    \ upper limit on a\n   failed probe, converging toward the true Path MTU.  For\
    \ most\n   transport layers, the search should be stopped once the range is\n\
    \   narrow enough that the benefit of a larger effective Path MTU is\n   smaller\
    \ than the search overhead of finding it.\n   The most likely (and least serious)\
    \ probe failure is due to the link\n   experiencing congestion-related losses\
    \ while probing.  In this case,\n   it is appropriate to retry a probe of the\
    \ same size as soon as the\n   Packetization Layer has fully adapted to the congestion\
    \ and recovered\n   from the losses.  In other cases, additional losses or timeouts\n\
    \   indicate problems with the link or Packetization Layer.  In these\n   situations,\
    \ it is desirable to use longer delays depending on the\n   severity of the error.\n\
    \   An optional verification process can be used to detect situations\n   where\
    \ raising the MTU raises the packet loss rate.  For example, if a\n   link is\
    \ striped across multiple physical channels with inconsistent\n   MTUs, it is\
    \ possible that a probe will be delivered even if it is too\n   large for some\
    \ of the physical channels.  In such cases, raising the\n   Path MTU to the probe\
    \ size can cause severe packet loss and abysmal\n   performance.  After raising\
    \ the MTU, the new MTU size can be verified\n   by monitoring the loss rate.\n\
    \   Packetization Layer PMTUD (PLPMTUD) introduces some flexibility in\n   the\
    \ implementation of classical Path MTU Discovery.  It can be\n   configured to\
    \ perform just ICMP black hole recovery to increase the\n   robustness of classical\
    \ Path MTU Discovery, or at the other extreme,\n   all ICMP processing can be\
    \ disabled and PLPMTUD can completely\n   replace classical Path MTU Discovery.\n\
    \   Classical Path MTU Discovery is subject to protocol failures\n   (connection\
    \ hangs) if ICMP Packet Too Big (PTB) messages are not\n   delivered or processed\
    \ for some reason [RFC2923].  With PLPMTUD,\n   classical Path MTU Discovery can\
    \ be modified to include additional\n   consistency checks without increasing\
    \ the risk of connection hangs\n   due to spurious failures of the additional\
    \ checks.  Such changes to\n   classical Path MTU Discovery are beyond the scope\
    \ of this document.\n   In the limiting case, all ICMP PTB messages might be unconditionally\n\
    \   ignored, and PLPMTUD can be used as the sole method to discover the\n   Path\
    \ MTU.  In this configuration, PLPMTUD parallels congestion\n   control.  An end-to-end\
    \ transport protocol adjusts properties of the\n   data stream (window size or\
    \ packet size) while using packet losses to\n   deduce the appropriateness of\
    \ the adjustments.  This technique seems\n   to be more philosophically consistent\
    \ with the end-to-end principle\n   of the Internet than relying on ICMP messages\
    \ containing transcribed\n   headers of multiple protocol layers.\n   Most of\
    \ the difficulty in implementing PLPMTUD arises because it\n   needs to be implemented\
    \ in several different places within a single\n   node.  In general, each Packetization\
    \ Protocol needs to have its own\n   implementation of PLPMTUD.  Furthermore,\
    \ the natural mechanism to\n   share Path MTU information between concurrent or\
    \ subsequent\n   connections is a path information cache in the IP layer.  The\
    \ various\n   Packetization Protocols need to have the means to access and update\n\
    \   the shared cache in the IP layer.  This memo describes PLPMTUD in\n   terms\
    \ of its primary subsystems without fully describing how they are\n   assembled\
    \ into a complete implementation.\n   The vast majority of the implementation\
    \ details described in this\n   document are recommendations based on experiences\
    \ with earlier\n   versions of Path MTU Discovery.  These recommendations are\
    \ motivated\n   by a desire to maximize robustness of PLPMTUD in the presence\
    \ of less\n   than ideal network conditions as they exist in the field.\n   This\
    \ document does not contain a complete description of an\n   implementation. \
    \ It only sketches details that do not affect\n   interoperability with other\
    \ implementations and have strong\n   externally imposed optimality criteria (e.g.,\
    \ the MTU searching and\n   caching heuristics).  Other details are explicitly\
    \ included because\n   there is an obvious alternative implementation that doesn't\
    \ work well\n   in some (possibly subtle) case.\n   Section 3 provides a complete\
    \ glossary of terms.\n   Section 4 describes the details of PLPMTUD that affect\n\
    \   interoperability with other standards or Internet protocols.\n   Section 5\
    \ describes how to partition PLPMTUD into layers, and how to\n   manage the path\
    \ information cache in the IP layer.\n   Section 6 describes the general Packetization\
    \ Layer properties and\n   features needed to implement PLPMTUD.\n   Section 7\
    \ describes how to use probes to search for the Path MTU.\n   Section 8 recommends\
    \ using IPv4 fragmentation in a configuration that\n   mimics IPv6 functionality,\
    \ to minimize future problems migrating to\n   IPv6.\n   Section 9 describes a\
    \ programming interface for implementing PLPMTUD\n   in applications that choose\
    \ their own packet boundaries and for tools\n   to be able to diagnose path problems\
    \ that interfere with Path MTU\n   Discovery.\n   Section 10 discusses implementation\
    \ details for specific protocols,\n   including TCP.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   We use the following terms in this document:\n   IP:  Either\
    \ IPv4 [RFC0791] or IPv6 [RFC2460].\n   Node:  A device that implements IP.\n\
    \   Upper layer:  A protocol layer immediately above IP.  Examples are\n     \
    \ transport protocols such as TCP and UDP, control protocols such as\n      ICMP,\
    \ routing protocols such as OSPF, and Internet or lower-layer\n      protocols\
    \ being \"tunneled\" over (i.e., encapsulated in) IP such as\n      IPX, AppleTalk,\
    \ or IP itself.\n   Link:  A communication facility or medium over which nodes\
    \ can\n      communicate at the link layer, i.e., the layer immediately below\n\
    \      IP.  Examples are Ethernets (simple or bridged); PPP links; X.25,\n   \
    \   Frame Relay, or Asynchronous Transfer Mode (ATM) networks; and\n      Internet\
    \ (or higher) layer \"tunnels\", such as tunnels over IPv4 or\n      IPv6.  Occasionally\
    \ we use the slightly more general term \"lower\n      layer\" for this concept.\n\
    \   Interface:  A node's attachment to a link.\n   Address:  An IP layer identifier\
    \ for an interface or a set of\n      interfaces.\n   Packet:  An IP header plus\
    \ payload.\n   MTU:  Maximum Transmission Unit, the size in bytes of the largest\
    \ IP\n      packet, including the IP header and payload, that can be\n      transmitted\
    \ on a link or path.  Note that this could more properly\n      be called the\
    \ IP MTU, to be consistent with how other standards\n      organizations use the\
    \ acronym MTU.\n   Link MTU:  The Maximum Transmission Unit, i.e., maximum IP\
    \ packet\n      size in bytes, that can be conveyed in one piece over a link.\
    \  Be\n      aware that this definition is different from the definition used\n\
    \      by other standards organizations.\n      For IETF documents, link MTU is\
    \ uniformly defined as the IP MTU\n      over the link.  This includes the IP\
    \ header, but excludes link\n      layer headers and other framing that is not\
    \ part of IP or the IP\n      payload.\n      Be aware that other standards organizations\
    \ generally define link\n      MTU to include the link layer headers.\n   Path:\
    \  The set of links traversed by a packet between a source node\n      and a destination\
    \ node.\n   Path MTU, or PMTU:  The minimum link MTU of all the links in a path\n\
    \      between a source node and a destination node.\n   Classical Path MTU Discovery:\
    \  Process described in RFC 1191 and RFC\n      1981, in which nodes rely on ICMP\
    \ Packet Too Big (PTB) messages to\n      learn the MTU of a path.\n   Packetization\
    \ Layer:  The layer of the network stack that segments\n      data into packets.\n\
    \   Effective PMTU:  The current estimated value for PMTU used by a\n      Packetization\
    \ Layer for segmentation.\n   PLPMTUD:  Packetization Layer Path MTU Discovery,\
    \ the method\n      described in this document, which is an extension to classical\n\
    \      PMTU Discovery.\n   PTB (Packet Too Big) message:  An ICMP message reporting\
    \ that an IP\n      packet is too large to forward.  This is the IPv6 term that\n\
    \      corresponds to the IPv4 ICMP \"Fragmentation Needed and DF Set\"\n    \
    \  message.\n   Flow:  A context in which MTU Discovery algorithms can be invoked.\n\
    \      This is naturally an instance of a Packetization Protocol, for\n      example,\
    \ one side of a TCP connection.\n   MSS:  The TCP Maximum Segment Size [RFC0793],\
    \ the maximum payload\n      size available to the TCP layer.  This is typically\
    \ the Path MTU\n      minus the size of the IP and TCP headers.\n   Probe packet:\
    \  A packet that is being used to test a path for a\n      larger MTU.\n   Probe\
    \ size:  The size of a packet being used to probe for a larger\n      MTU, including\
    \ IP headers.\n   Probe gap:  The payload data that will be lost and need to be\n\
    \      retransmitted if the probe is not delivered.\n   Leading window:  Any unacknowledged\
    \ data in a flow at the time a\n      probe is sent.\n   Trailing window:  Any\
    \ data in a flow sent after a probe, but before\n      the probe is acknowledged.\n\
    \   Search strategy:  The heuristics used to choose successive probe\n      sizes\
    \ to converge on the proper Path MTU, as described in\n      Section 7.3.\n  \
    \ Full-stop timeout:  A timeout where none of the packets transmitted\n      after\
    \ some event are acknowledged by the receiver, including any\n      retransmissions.\
    \  This is taken as an indication of some failure\n      condition in the network,\
    \ such as a routing change onto a link\n      with a smaller MTU.  This is described\
    \ in more detail in\n      Section 7.7.\n"
- title: 4.  Requirements
  contents:
  - "4.  Requirements\n   All links MUST enforce their MTU: links that might non-\n\
    \   deterministically deliver packets that are larger than their rated\n   MTU\
    \ MUST consistently discard such packets.\n   In the distant past, there were\
    \ a small number of network devices\n   that did not enforce MTU, but could not\
    \ reliably deliver oversized\n   packets.  For example, some early bit-wise Ethernet\
    \ repeaters would\n   forward arbitrarily sized packets, but could not do so reliably\
    \ due\n   to finite hardware data clock stability.  This is the only\n   requirement\
    \ that PLPMTUD places on lower layers.  It is important\n   that this requirement\
    \ be explicit to forestall the future\n   standardization or deployment of technologies\
    \ that might be\n   incompatible with PLPMTUD.\n   All hosts SHOULD use IPv4 fragmentation\
    \ in a mode that mimics IPv6\n   functionality.  All fragmentation SHOULD be done\
    \ on the host, and all\n   IPv4 packets, including fragments, SHOULD have the\
    \ DF bit set such\n   that they will not be fragmented (again) in the network.\
    \  See\n   Section 8.\n   The requirements below only apply to those implementations\
    \ that\n   include PLPMTUD.\n   To use PLPMTUD, a Packetization Layer MUST have\
    \ a loss reporting\n   mechanism that provides the sender with timely and accurate\n\
    \   indications of which packets were lost in the network.\n   Normal congestion\
    \ control algorithms MUST remain in effect under all\n   conditions except when\
    \ only an isolated probe packet is detected as\n   lost.  In this case alone,\
    \ the normal congestion (window or data\n   rate) reduction SHOULD be suppressed.\
    \  If any other data loss is\n   detected, standard congestion control MUST take\
    \ place.\n   Suppressed congestion control MUST be rate limited such that it\n\
    \   occurs less frequently than the worst-case loss rate for TCP\n   congestion\
    \ control at a comparable data rate over the same path\n   (i.e., less than the\
    \ \"TCP-friendly\" loss rate [tcp-friendly]).  This\n   SHOULD be enforced by\
    \ requiring a minimum headway between a\n   suppressed congestion adjustment (due\
    \ to a failed probe) and the next\n   attempted probe, which is equal to one round-trip\
    \ time for each\n   packet permitted by the congestion window.  This is discussed\
    \ further\n   in Section 7.6.2.\n   Whenever the MTU is raised, the congestion\
    \ state variables MUST be\n   rescaled so as not to raise the window size in bytes\
    \ (or data rate in\n   bytes per seconds).\n   Whenever the MTU is reduced (e.g.,\
    \ when processing ICMP PTB\n   messages), the congestion state variable SHOULD\
    \ be rescaled so as not\n   to raise the window size in packets.\n   If PLPMTUD\
    \ updates the MTU for a particular path, all Packetization\n   Layer sessions\
    \ that share the path representation (as described in\n   Section 5.2) SHOULD\
    \ be notified to make use of the new MTU and make\n   the required congestion\
    \ control adjustments.\n   All implementations MUST include mechanisms for applications\
    \ to\n   selectively transmit packets larger than the current effective Path\n\
    \   MTU, but smaller than the first-hop link MTU.  This is necessary to\n   implement\
    \ PLPMTUD using a connectionless protocol within an\n   application and to implement\
    \ diagnostic tools that do not rely on the\n   operating system's implementation\
    \ of Path MTU Discovery.  See\n   Section 9 for further discussion.\n   Implementations\
    \ MAY use different heuristics to select the initial\n   effective Path MTU for\
    \ each protocol.  Connectionless protocols and\n   protocols that do not support\
    \ PLPMTUD SHOULD have their own default\n   value for the initial effective Path\
    \ MTU, which can be set to a more\n   conservative (smaller) value than the initial\
    \ value used by TCP and\n   other protocols that are well suited to PLPMTUD. \
    \ There SHOULD be\n   per-protocol and per-route limits on the initial effective\
    \ Path MTU\n   (eff_pmtu) and the upper searching limit (search_high).  See\n\
    \   Section 7.2 for further discussion.\n"
- title: 5.  Layering
  contents:
  - "5.  Layering\n   Packetization Layer Path MTU Discovery is most easily implemented\
    \ by\n   splitting its functions between layers.  The IP layer is the best\n \
    \  place to keep shared state, collect the ICMP messages, track IP\n   header\
    \ sizes, and manage MTU information provided by the link layer\n   interfaces.\
    \  However, the procedures that PLPMTUD uses for probing\n   and verification\
    \ of the Path MTU are very tightly coupled to features\n   of the Packetization\
    \ Layers, such as data recovery and congestion\n   control state machines.\n \
    \  Note that this layering approach is a direct extension of the advice\n   in\
    \ the current PMTUD specifications in RFC 1191 and RFC 1981.\n"
- title: 5.1.  Accounting for Header Sizes
  contents:
  - "5.1.  Accounting for Header Sizes\n   The way in which PLPMTUD operates across\
    \ multiple layers requires a\n   mechanism for accounting header sizes at all\
    \ layers between IP and\n   the Packetization Layer (inclusive).  When transmitting\
    \ non-probe\n   packets, it is sufficient for the Packetization Layer to ensure\
    \ an\n   upper bound on final IP packet size, so as not to exceed the current\n\
    \   effective Path MTU.  All Packetization Layers participating in\n   classical\
    \ Path MTU Discovery have this requirement already.  When\n   conducting a probe,\
    \ the Packetization Layer MUST determine the probe\n   packet's final size including\
    \ IP headers.  This requirement is\n   specific to PLPMTUD, and satisfying it\
    \ may require additional inter-\n   layer communication in existing implementations.\n"
- title: 5.2.  Storing PMTU Information
  contents:
  - "5.2.  Storing PMTU Information\n   This memo uses the concept of a \"flow\" to\
    \ define the scope of the\n   Path MTU Discovery algorithms.  For many implementations,\
    \ a flow\n   would naturally correspond to an instance of each protocol (i.e.,\n\
    \   each connection or session).  In such implementations, the algorithms\n  \
    \ described in this document are performed within each session for each\n   protocol.\
    \  The observed PMTU (eff_pmtu in Section 7.1) MAY be shared\n   between different\
    \ flows with a common path representation.\n   Alternatively, PLPMTUD could be\
    \ implemented such that its complete\n   state is associated with the path representations.\
    \  Such an\n   implementation could use multiple connections or sessions for each\n\
    \   probe sequence.  This approach is likely to converge much more\n   quickly\
    \ in some environments, such as where an application uses many\n   small connections,\
    \ each of which is too short to complete the Path\n   MTU Discovery process.\n\
    \   Within a single implementation, different protocols can use either of\n  \
    \ these two approaches.  Due to protocol specific differences in\n   constraints\
    \ on generating probes (Section 6.2) and the MTU searching\n   algorithm (Section\
    \ 7.3), it may not be feasible for different\n   Packetization Layer protocols\
    \ to share PLPMTUD state.  This suggests\n   that it may be possible for some\
    \ protocols to share probing state,\n   but other protocols can only share observed\
    \ PMTU.  In this case, the\n   different protocols will have different PMTU convergence\
    \ properties.\n   The IP layer SHOULD be used to store the cached PMTU value and\
    \ other\n   shared state such as MTU values reported by ICMP PTB messages.\n \
    \  Ideally, this shared state should be associated with a specific path\n   traversed\
    \ by packets exchanged between the source and destination\n   nodes.  However,\
    \ in most cases a node will not have enough\n   information to completely and\
    \ accurately identify such a path.\n   Rather, a node must associate a PMTU value\
    \ with some local\n   representation of a path.  It is left to the implementation\
    \ to select\n   the local representation of a path.\n   An implementation MAY\
    \ use the destination address as the local\n   representation of a path.  The\
    \ PMTU value associated with a\n   destination would be the minimum PMTU learned\
    \ across the set of all\n   paths in use to that destination.  The set of paths\
    \ in use to a\n   particular destination is expected to be small, in many cases\n\
    \   consisting of a single path.  This approach will result in the use of\n  \
    \ optimally sized packets on a per-destination basis, and integrates\n   nicely\
    \ with the conceptual model of a host as described in [RFC2461]:\n   a PMTU value\
    \ could be stored with the corresponding entry in the\n   destination cache. \
    \ Since Network Address Translators (NATs) and\n   other forms of middle boxes\
    \ may exhibit differing PMTUs\n   simultaneously at a single IP address, the minimum\
    \ value SHOULD be\n   stored.\n   Network or subnet numbers MUST NOT be used as\
    \ representations of a\n   path, because there is not a general mechanism to determine\
    \ the\n   network mask at the remote host.\n   For source-routed packets (i.e.,\
    \ packets containing an IPv6 routing\n   header, or IPv4 Loose Source and Record\
    \ Route (LSRR) or Strict Source\n   and Record Route (SSRR) options), the source\
    \ route MAY further\n   qualify the local representation of a path.  An implementation\
    \ MAY\n   use source route information in the local representation of a path.\n\
    \   If IPv6 flows are in use, an implementation MAY use the 3-tuple of\n   the\
    \ Flow label and the source and destination addresses\n   [RFC2460][RFC3697] as\
    \ the local representation of a path.  Such an\n   approach could theoretically\
    \ result in the use of optimally sized\n   packets on a per-flow basis, providing\
    \ finer granularity than MTU\n   values maintained on a per-destination basis.\n"
- title: 5.3.  Accounting for IPsec
  contents:
  - "5.3.  Accounting for IPsec\n   This document does not take a stance on the placement\
    \ of IP Security\n   (IPsec) [RFC2401], which logically sits between IP and the\n\
    \   Packetization Layer.  A PLPMTUD implementation can treat IPsec either\n  \
    \ as part of IP or as part of the Packetization Layer, as long as the\n   accounting\
    \ is consistent within the implementation.  If IPsec is\n   treated as part of\
    \ the IP layer, then each security association to a\n   remote node may need to\
    \ be treated as a separate path.  If IPsec is\n   treated as part of the Packetization\
    \ Layer, the IPsec header size\n   MUST be included in the Packetization Layer's\
    \ header size\n   calculations.\n"
- title: 5.4.  Multicast
  contents:
  - "5.4.  Multicast\n   In the case of a multicast destination address, copies of\
    \ a packet\n   may traverse many different paths to reach many different nodes.\
    \  The\n   local representation of the \"path\" to a multicast destination must\
    \ in\n   fact represent a potentially large set of paths.\n   Minimally, an implementation\
    \ MAY maintain a single MTU value to be\n   used for all multicast packets originated\
    \ from the node.  This MTU\n   SHOULD be sufficiently small that it is expected\
    \ to be less than the\n   Path MTU of all paths comprising the multicast tree.\
    \  If a Path MTU\n   of less than the configured multicast MTU is learned via\
    \ unicast\n   means, the multicast MTU MAY be reduced to this value.  This approach\n\
    \   is likely to result in the use of smaller packets than is necessary\n   for\
    \ many paths.\n   If the application using multicast gets complete delivery reports\n\
    \   (unlikely since this requirement has poor scaling properties),\n   PLPMTUD\
    \ MAY be implemented in multicast protocols such that the\n   smallest path MTU\
    \ learned across a group becomes the effective MTU\n   for that group.\n"
- title: 6.  Common Packetization Properties
  contents:
  - "6.  Common Packetization Properties\n   This section describes general Packetization\
    \ Layer properties and\n   characteristics needed to implement PLPMTUD.  It also\
    \ describes some\n   implementation issues that are common to all Packetization\
    \ Layers.\n"
- title: 6.1.  Mechanism to Detect Loss
  contents:
  - "6.1.  Mechanism to Detect Loss\n   It is important that the Packetization Layer\
    \ has a timely and robust\n   mechanism for detecting and reporting losses.  PLPMTUD\
    \ makes MTU\n   adjustments on the basis of detected losses.  Any delays or\n\
    \   inaccuracy in loss notification is likely to result in incorrect MTU\n   decisions\
    \ or slow convergence.  It is important that the mechanism\n   can robustly distinguish\
    \ between the isolated loss of just a probe\n   and other losses in the probe's\
    \ leading and trailing windows.\n   It is best if Packetization Protocols use\
    \ an explicit loss detection\n   mechanism such as a Selective Acknowledgment\
    \ (SACK) scoreboard\n   [RFC3517] or ACK Vector [RFC4340] to distinguish real\
    \ losses from\n   reordered data, although implicit mechanisms such as TCP Reno\
    \ style\n   duplicate acknowledgments counting are sufficient.\n   PLPMTUD can\
    \ also be implemented in protocols that rely on timeouts as\n   their primary\
    \ mechanism for loss recovery; however, timeouts SHOULD\n   NOT be used as the\
    \ primary mechanism for loss indication unless there\n   are no other alternatives.\n"
- title: 6.2.  Generating Probes
  contents:
  - "6.2.  Generating Probes\n   There are several possible ways to alter Packetization\
    \ Layers to\n   generate probes.  The different techniques incur different overheads\n\
    \   in three areas: difficulty in generating the probe packet (in terms\n   of\
    \ Packetization Layer implementation complexity and extra data\n   motion), possible\
    \ additional network capacity consumed by the probes,\n   and the overhead of\
    \ recovering from failed probes (both network and\n   protocol overheads).\n \
    \  Some protocols might be extended to allow arbitrary padding with\n   dummy\
    \ data.  This greatly simplifies the implementation because the\n   probing can\
    \ be performed without participation from higher layers and\n   if the probe fails,\
    \ the missing data (the \"probe gap\") is ensured to\n   fit within the current\
    \ MTU when it is retransmitted.  This is\n   probably the most appropriate method\
    \ for protocols that support\n   arbitrary length options or multiplexing within\
    \ the protocol itself.\n   Many Packetization Layer protocols can carry pure control\
    \ messages\n   (without any data from higher protocol layers), which can be padded\n\
    \   to arbitrary lengths.  For example, the SCTP PAD chunk can be used in\n  \
    \ this manner (see Section 10.2).  This approach has the advantage that\n   nothing\
    \ needs to be retransmitted if the probe is lost.\n   These techniques do not\
    \ work for TCP, because there is not a separate\n   length field or other mechanism\
    \ to differentiate between padding and\n   real payload data.  With TCP the only\
    \ approach is to send additional\n   payload data in an over-sized segment.  There\
    \ are at least two\n   variants of this approach, discussed in Section 10.1.\n\
    \   In a few cases, there may be no reasonable mechanisms to generate\n   probes\
    \ within the Packetization Layer protocol itself.  As a last\n   resort, it may\
    \ be possible to rely on an adjunct protocol, such as\n   ICMP ECHO (\"ping\"\
    ), to send probe packets.  See Section 10.3 for\n   further discussion of this\
    \ approach.\n"
- title: 7.  The Probing Method
  contents:
  - "7.  The Probing Method\n   This section describes the details of the MTU probing\
    \ method,\n   including how to send probes and process error indications necessary\n\
    \   to search for the Path MTU.\n"
- title: 7.1.  Packet Size Ranges
  contents:
  - "7.1.  Packet Size Ranges\n   This document describes the probing method using\
    \ three state\n   variables:\n   search_low:  The smallest useful probe size,\
    \ minus one.  The network\n      is expected to be able to deliver packets of\
    \ size search_low.\n   search_high:  The greatest useful probe size.  Packets\
    \ of size\n      search_high are expected to be too large for the network to\n\
    \      deliver.\n   eff_pmtu:  The effective PMTU for this flow.  This is the\
    \ largest\n      non-probe packet permitted by PLPMTUD for the path.\n       \
    \        search_low          eff_pmtu         search_high\n                  \
    \ |                   |                  |\n           ...------------------------->\n\
    \               non-probe size range\n                   <-------------------------------------->\n\
    \                               probe size range\n                           \
    \      Figure 1\n   When transmitting non-probes, the Packetization Layer SHOULD\
    \ create\n   packets of a size less than or equal to eff_pmtu.\n   When transmitting\
    \ probes, the Packetization Layer MUST select a probe\n   size that is larger\
    \ than search_low and smaller than or equal to\n   search_high.\n   When probing\
    \ upward, eff_pmtu always equals search_low.  In other\n   states, such as initial\
    \ conditions, after ICMP PTB message processing\n   or following PLPMTUD on another\
    \ flow sharing the same path\n   representation, eff_pmtu may be different from\
    \ search_low.  Normally,\n   eff_pmtu will be greater than or equal to search_low\
    \ and less than\n   search_high.  It is generally expected but not required that\
    \ probe\n   size will be greater than eff_pmtu.\n   For initial conditions when\
    \ there is no information about the path,\n   eff_pmtu may be greater than search_low.\
    \  The initial value of\n   search_low SHOULD be conservatively low, but performance\
    \ may be\n   better if eff_pmtu starts at a higher, less conservative, value.\
    \  See\n   Section 7.2.\n   If eff_pmtu is larger than search_low, it is explicitly\
    \ permitted to\n   send non-probe packets larger than search_low.  When such a\
    \ packet is\n   acknowledged, it is effectively an \"implicit probe\" and search_low\n\
    \   SHOULD be raised to the size of the acknowledged packet.  However, if\n  \
    \ an \"implicit probe\" is lost, it MUST NOT be treated as a probe\n   failure\
    \ as a true probe would be.  If eff_pmtu is too large, this\n   condition will\
    \ only be detected with ICMP PTB messages or black hole\n   discovery (see Section\
    \ 7.7).\n"
- title: 7.2.  Selecting Initial Values
  contents:
  - "7.2.  Selecting Initial Values\n   The initial value for search_high SHOULD be\
    \ the largest possible\n   packet that might be supported by the flow.  This may\
    \ be limited by\n   the local interface MTU, by an explicit protocol mechanism\
    \ such as\n   the TCP MSS option, or by an intrinsic limit such as the size of\
    \ a\n   protocol length field.  In addition, the initial value for\n   search_high\
    \ MAY be limited by a configuration option to prevent\n   probing above some maximum\
    \ size.  Search_high is likely to be the\n   same as the initial Path MTU as computed\
    \ by the classical Path MTU\n   Discovery algorithm.\n   It is RECOMMENDED that\
    \ search_low be initially set to an MTU size\n   that is likely to work over a\
    \ very wide range of environments.  Given\n   today's technologies, a value of\
    \ 1024 bytes is probably safe enough.\n   The initial value for search_low SHOULD\
    \ be configurable.\n   Properly functioning Path MTU Discovery is critical to\
    \ the robust and\n   efficient operation of the Internet.  Any major change (as\
    \ described\n   in this document) has the potential to be very disruptive if it\n\
    \   causes any unexpected changes in protocol behaviors.  The selection\n   of\
    \ the initial value for eff_pmtu determines to what extent a PLPMTUD\n   implementation's\
    \ behavior resembles classical PMTUD in cases where\n   the classical method is\
    \ sufficient.\n   A conservative configuration would be to set eff_pmtu to search_high,\n\
    \   and rely on ICMP PTB messages to set the eff_pmtu down as\n   appropriate.\
    \  In this configuration, classical PMTUD is fully\n   functional and PLPMTUD\
    \ is only invoked to recover from ICMP black\n   holes through the procedure described\
    \ in Section 7.7.\n   In some cases, where it is known that classical PMTUD is\
    \ likely to\n   fail (for example, if ICMP PTB messages are administratively disabled\n\
    \   for security reasons), using a small initial eff_pmtu will avoid the\n   costly\
    \ timeouts required for black hole detection.  The trade-off is\n   that using\
    \ a smaller than necessary initial eff_pmtu might cause\n   reduced performance.\n\
    \   Note that the initial eff_pmtu can be any value in the range\n   search_low\
    \ to search_high.  An initial eff_pmtu of 1400 bytes might\n   be a good compromise\
    \ because it would be safe for nearly all tunnels\n   over all common networking\
    \ gear, and yet close to the optimal MTU for\n   the majority of paths in the\
    \ Internet today.  This might be improved\n   by using some statistics of other\
    \ recent flows: for example, the\n   initial eff_pmtu for a flow might be set\
    \ to the median of the probe\n   size for all recent successful probes.\n   Since\
    \ the cost of PLPMTUD is dominated by the protocol specific\n   overheads of generating\
    \ and processing probes, it is probably\n   desirable for each protocol to have\
    \ its own heuristics to select the\n   initial eff_pmtu.  It is especially important\
    \ that connectionless\n   protocols and other protocols that may not receive clear\
    \ indications\n   of ICMP black holes use conservative (smaller) initial values\
    \ for\n   eff_pmtu, as described in Section 10.3.\n   There SHOULD be per-protocol\
    \ and per-route configuration options to\n   override initial values for eff_pmtu\
    \ and other PLPMTUD state\n   variables.\n"
- title: 7.3.  Selecting Probe Size
  contents:
  - "7.3.  Selecting Probe Size\n   The probe may have a size anywhere in the \"probe\
    \ size range\"\n   described above.  However, a number of factors affect the selection\n\
    \   of an appropriate size.  A simple strategy might be to do a binary\n   search\
    \ halving the probe size range with each probe.  However, for\n   some protocols,\
    \ such as TCP, failed probes are more expensive than\n   successful ones, since\
    \ data in a failed probe will need to be\n   retransmitted.  For such protocols,\
    \ a strategy that raises the probe\n   size in smaller increments might have lower\
    \ overhead.  For many\n   protocols, both at and above the Packetization Layer,\
    \ the benefit of\n   increasing MTU sizes may follow a step function such that\
    \ it is not\n   advantageous to probe within certain regions at all.\n   As an\
    \ optimization, it may be appropriate to probe at certain common\n   or expected\
    \ MTU sizes, for example, 1500 bytes for standard Ethernet,\n   or 1500 bytes\
    \ minus header sizes for tunnel protocols.\n   Some protocols may use other mechanisms\
    \ to choose the probe sizes.\n   For example, protocols that have certain natural\
    \ data block sizes\n   might simply assemble messages from a number of blocks\
    \ until the\n   total size is smaller than search_high, and if possible larger\
    \ than\n   search_low.\n   Each Packetization Layer MUST determine when probing\
    \ has converged,\n   that is, when the probe size range is small enough that further\n\
    \   probing is no longer worth its cost.  When probing has converged, a\n   timer\
    \ SHOULD be set.  When the timer expires, search_high should be\n   reset to its\
    \ initial value (described above) so that probing can\n   resume.  Thus, if the\
    \ path changes, increasing the Path MTU, then the\n   flow will eventually take\
    \ advantage of it.  The value for this timer\n   MUST NOT be less than 5 minutes\
    \ and is recommended to be 10 minutes,\n   per RFC 1981.\n"
- title: 7.4.  Probing Preconditions
  contents:
  - "7.4.  Probing Preconditions\n   Before sending a probe, the flow MUST meet at\
    \ least the following\n   conditions:\n   o  It has no outstanding probes or losses.\n\
    \   o  If the last probe failed or was inconclusive, then the probe\n      timeout\
    \ has expired (see Section 7.6.2).\n   o  The available window is greater than\
    \ the probe size.\n   o  For a protocol using in-band data for probing, enough\
    \ data is\n      available to send the probe.\n   In addition, the timely loss\
    \ detection algorithms in most protocols\n   have pre-conditions that SHOULD be\
    \ satisfied before sending a probe.\n   For example, TCP Fast Retransmit is not\
    \ robust unless there are\n   sufficient segments following a probe; that is,\
    \ the sender SHOULD\n   have enough data queued and sufficient receiver window\
    \ to send the\n   probe plus at least Tcprexmtthresh [RFC2760] additional segments.\n\
    \   This restriction may inhibit probing in some protocol states, such as\n  \
    \ too close to the end of a connection, or when the window is too\n   small.\n\
    \   Protocols MAY delay sending non-probes in order to accumulate enough\n   data\
    \ to meet the pre-conditions for probing.  The delayed sending\n   algorithm SHOULD\
    \ use some self-scaling technique to appropriately\n   limit the time that the\
    \ data is delayed.  For example, the returning\n   ACKs can be used to prevent\
    \ the window from falling by more than the\n   amount of data needed for the probe.\n"
- title: 7.5.  Conducting a Probe
  contents:
  - "7.5.  Conducting a Probe\n   Once a probe size in the appropriate range has been\
    \ selected, and the\n   above preconditions have been met, the Packetization Layer\
    \ MAY\n   conduct a probe.  To do so, it creates a probe packet such that its\n\
    \   size, including the outermost IP headers, is equal to the probe size.\n  \
    \ After sending the probe it awaits a response, which will have one of\n   the\
    \ following results:\n   Success:  The probe is acknowledged as having been received\
    \ by the\n      remote host.\n   Failure:  A protocol mechanism indicates that\
    \ the probe was lost, but\n      no packets in the leading or trailing window\
    \ were lost.\n   Timeout failure:  A protocol mechanism indicates that the probe\
    \ was\n      lost, and no packets in the leading window were lost, but is\n  \
    \    unable to determine whether any packets in the trailing window\n      were\
    \ lost.  For example, loss is detected by a timeout, and\n      go-back-n retransmission\
    \ is used.\n   Inconclusive:  The probe was lost in addition to other packets\
    \ in the\n      leading or trailing windows.\n"
- title: 7.6.  Response to Probe Results
  contents:
  - "7.6.  Response to Probe Results\n   When a probe has completed, the result SHOULD\
    \ be processed as\n   follows, categorized by the probe's result type.\n"
- title: 7.6.1.  Probe Success
  contents:
  - "7.6.1.  Probe Success\n   When the probe is delivered, it is an indication that\
    \ the Path MTU is\n   at least as large as the probe size.  Set search_low to\
    \ the probe\n   size.  If the probe size is larger than the eff_pmtu, raise eff_pmtu\n\
    \   to the probe size.  The probe size might be smaller than the eff_pmtu\n  \
    \ if the flow has not been using the full MTU of the path because it is\n   subject\
    \ to some other limitation, such as available data in an\n   interactive session.\n\
    \   Note that if a flow's packets are routed via multiple paths, or over\n   a\
    \ path with a non-deterministic MTU, delivery of a single probe\n   packet does\
    \ not indicate that all packets of that size will be\n   delivered.  To be robust\
    \ in such a case, the Packetization Layer\n   SHOULD conduct MTU verification\
    \ as described in Section 7.8.\n"
- title: 7.6.2.  Probe Failure
  contents:
  - "7.6.2.  Probe Failure\n   When only the probe is lost, it is treated as an indication\
    \ that the\n   Path MTU is smaller than the probe size.  In this case alone, the\n\
    \   loss SHOULD NOT be interpreted as congestion signal.\n   In the absence of\
    \ other indications, set search_high to the probe\n   size minus one.  The eff_pmtu\
    \ might be larger than the probe size if\n   the flow has not been using the full\
    \ MTU of the path because it is\n   subject to some other limitation, such as\
    \ available data in an\n   interactive session.  If eff_pmtu is larger than the\
    \ probe size,\n   eff_pmtu MUST be reduced to no larger than search_high, and\
    \ SHOULD be\n   reduced to search_low, as the eff_pmtu has been determined to\
    \ be\n   invalid, similar to after a full-stop timeout (see Section 7.7).\n  \
    \ If an ICMP PTB message is received matching the probe packet, then\n   search_high\
    \ and eff_pmtu MAY be set from the MTU value indicated in\n   the message.  Note\
    \ that the ICMP message may be received either\n   before or after the protocol\
    \ loss indication.\n   A probe failure event is the one situation under which\
    \ the\n   Packetization Layer SHOULD ignore loss as a congestion signal.\n   Because\
    \ there is some small risk that suppressing congestion control\n   might have\
    \ unanticipated consequences (even for one isolated loss),\n   it is REQUIRED\
    \ that probe failure events be less frequent than the\n   normal period for losses\
    \ under standard congestion control.\n   Specifically, after a probe failure event\
    \ and suppressed congestion\n   control, PLPMTUD MUST NOT probe again until an\
    \ interval that is\n   larger than the expected interval between congestion control\
    \ events.\n   See Section 4 for details.  The simplest estimate of the interval\
    \ to\n   the next congestion event is the same number of round trips as the\n\
    \   current congestion window in packets.\n"
- title: 7.6.3.  Probe Timeout Failure
  contents:
  - "7.6.3.  Probe Timeout Failure\n   If the loss was detected with a timeout and\
    \ repaired with go-back-n\n   retransmission, then congestion window reduction\
    \ will be necessary.\n   The relatively high price of a failed probe in this case\
    \ may merit a\n   longer time interval until the next probe.  A time interval\
    \ that is\n   five times the non-timeout failure case (Section 7.6.2) is\n   RECOMMENDED.\n"
- title: 7.6.4.  Probe Inconclusive
  contents:
  - "7.6.4.  Probe Inconclusive\n   The presence of other losses near the loss of\
    \ the probe may indicate\n   that the probe was lost due to congestion rather\
    \ than due to an MTU\n   limitation.  In this case, the state variables eff_pmtu,\
    \ search_low,\n   and search_high SHOULD NOT be updated, and the same-sized probe\n\
    \   SHOULD be attempted again as soon as the probing preconditions are\n   met\
    \ (i.e., once the packetization layer has no outstanding\n   unrecovered losses).\
    \  At this point, it is particularly appropriate\n   to re-probe since the flow's\
    \ congestion window will be at its lowest\n   point, minimizing the probability\
    \ of congestive losses.\n"
- title: 7.7.  Full-Stop Timeout
  contents:
  - "7.7.  Full-Stop Timeout\n   Under all conditions, a full-stop timeout (also known\
    \ as a\n   \"persistent timeout\" in other documents) SHOULD be taken as an\n\
    \   indication of some significantly disruptive event in the network,\n   such\
    \ as a router failure or a routing change to a path with a smaller\n   MTU.  For\
    \ TCP, this occurs when the R1 timeout threshold described by\n   [RFC1122] expires.\n\
    \   If there is a full-stop timeout and there was not an ICMP message\n   indicating\
    \ a reason (PTB, Net unreachable, etc., or the ICMP message\n   was ignored for\
    \ some reason), the RECOMMENDED first recovery action\n   is to treat this as\
    \ a detected ICMP black hole as defined in\n   [RFC2923].\n   The response to\
    \ a detected black hole depends on the current values\n   for search_low and eff_pmtu.\
    \  If eff_pmtu is larger than search_low,\n   set eff_pmtu to search_low.  Otherwise,\
    \ set both eff_pmtu and\n   search_low to the initial value for search_low.  Upon\
    \ additional\n   successive timeouts, search_low and eff_pmtu SHOULD be halved,\
    \ with a\n   lower bound of 68 bytes for IPv4 and 1280 bytes for IPv6.  Even lower\n\
    \   lower bounds MAY be permitted to support limited operation over links\n  \
    \ with MTUs that are smaller than permitted by the IP specifications.\n"
- title: 7.8.  MTU Verification
  contents:
  - "7.8.  MTU Verification\n   It is possible for a flow to simultaneously traverse\
    \ multiple paths,\n   but an implementation will only be able to keep a single\
    \ path\n   representation for the flow.  If the paths have different MTUs,\n \
    \  storing the minimum MTU of all paths in the flow's path\n   representation\
    \ will result in correct behavior.  If ICMP PTB messages\n   are delivered, then\
    \ classical PMTUD will work correctly in this\n   situation.\n   If ICMP delivery\
    \ fails, breaking classical PMTUD, the connection will\n   rely solely on PLPMTUD.\
    \  In this case, PLPMTUD may fail as well since\n   it assumes a flow traverses\
    \ a path with a single MTU.  A probe with a\n   size greater than the minimum\
    \ but smaller than the maximum of the\n   Path MTUs may be successful.  However,\
    \ upon raising the flow's\n   effective PMTU, the loss rate will significantly\
    \ increase.  The flow\n   may still make progress, but the resultant loss rate\
    \ is likely to be\n   unacceptable.  For example, when using two-way round-robin\
    \ striping,\n   50% of full-sized packets would be dropped.\n   Striping in this\
    \ manner is often operationally undesirable for other\n   reasons (e.g., due to\
    \ packet reordering) and is usually avoided by\n   hashing each flow to a single\
    \ path.  However, to increase robustness,\n   an implementation SHOULD implement\
    \ some form of MTU verification,\n   such that if increasing eff_pmtu results\
    \ in a sharp increase in loss\n   rate, it will fall back to using a lower MTU.\n\
    \   A RECOMMENDED strategy would be to save the value of eff_pmtu before\n   raising\
    \ it.  Then, if loss rate rises above a threshold for a period\n   of time (e.g.,\
    \ loss rate is higher than 10% over multiple\n   retransmission timeout (RTO)\
    \ intervals), then the new MTU is\n   considered incorrect.  The saved value of\
    \ eff_pmtu SHOULD be\n   restored, and search_high reduced in the same manner\
    \ as in a probe\n   failure.  PLPMTUD implementations SHOULD implement MTU verification.\n"
- title: 8.  Host Fragmentation
  contents:
  - "8.  Host Fragmentation\n   Packetization Layers SHOULD avoid sending messages\
    \ that will require\n   fragmentation [Kent87] [frag-errors].  However, entirely\
    \ preventing\n   fragmentation is not always possible.  Some Packetization Layers,\n\
    \   such as a UDP application outside the kernel, may be unable to change\n  \
    \ the size of messages it sends, resulting in datagram sizes that\n   exceed the\
    \ Path MTU.\n   IPv4 permitted such applications to send packets without the DF\
    \ bit\n   set.  Oversized packets without the DF bit set would be fragmented in\n\
    \   the network or sending host when they encountered a link with an MTU\n   smaller\
    \ than the packet.  In some case, packets could be fragmented\n   more than once\
    \ if there were cascaded links with progressively\n   smaller MTUs.  This approach\
    \ is NOT RECOMMENDED.\n   It is RECOMMENDED that IPv4 implementations use a strategy\
    \ that\n   mimics IPv6 functionality.  When an application sends datagrams that\n\
    \   are larger than the effective Path MTU, they SHOULD be fragmented to\n   the\
    \ Path MTU in the host IP layer even if they are smaller than the\n   MTU of the\
    \ first link, directly attached to the host.  The DF bit\n   SHOULD be set on\
    \ the fragments, so they will not be fragmented again\n   in the network.  This\
    \ technique will minimize the likelihood that\n   applications will rely on IPv4\
    \ fragmentation in a way that cannot be\n   implemented in IPv6.  At least one\
    \ major operating system already\n   uses this strategy.  Section 9 describes\
    \ some exceptions to this rule\n   when the application is sending oversized packets\
    \ for probing or\n   diagnostic purposes.\n   Since protocols that do not implement\
    \ PLPMTUD are still subject to\n   problems due to ICMP black holes, it may be\
    \ desirable to limit to\n   these protocols to \"safe\" MTUs likely to work on\
    \ any path (e.g., 1280\n   bytes).  Allow any protocol implementing PLPMTUD to\
    \ operate over the\n   full range supported by the lower layer.\n   Note that\
    \ IP fragmentation divides data into packets, so it is\n   minimally a Packetization\
    \ Layer.  However, it does not have a\n   mechanism to detect lost packets, so\
    \ it cannot support a native\n   implementation of PLPMTUD.  Fragmentation-based\
    \ PLPMTUD requires an\n   adjunct protocol as described in Section 10.3.\n"
- title: 9.  Application Probing
  contents:
  - "9.  Application Probing\n   All implementations MUST include a mechanism where\
    \ applications using\n   connectionless protocols can send their own probes. \
    \ This is\n   necessary to implement PLPMTUD in an application protocol as\n \
    \  described in Section 10.4 or to implement diagnostic tools for\n   debugging\
    \ problems with PMTUD.  There MUST be a mechanism that\n   permits an application\
    \ to send datagrams that are larger than\n   eff_pmtu, the operating systems estimate\
    \ of the Path MTU, without\n   being fragmented.  If these are IPv4 packets, they\
    \ MUST have the DF\n   bit set.\n   At this time, most operating systems support\
    \ two modes for sending\n   datagrams: one that silently fragments packets that\
    \ are too large,\n   and another that rejects packets that are too large.  Neither\
    \ of\n   these modes is suitable for implementing PLPMTUD in an application or\n\
    \   diagnosing problems with Path MTU Discovery.  A third mode is\n   REQUIRED\
    \ where the datagram is sent even if it is larger than the\n   current estimate\
    \ of the Path MTU.\n   Implementing PLPMTUD in an application also requires a\
    \ mechanism\n   where the application can inform the operating system about the\n\
    \   outcome of the probe as described in Section 7.6, or directly update\n   search_low,\
    \ search_high, and eff_pmtu, described in Section 7.1.\n   Diagnostic applications\
    \ are useful for finding PMTUD problems, such\n   as those that might be caused\
    \ by a defective router that returns ICMP\n   PTB messages with incorrect size\
    \ information.  Such problems can be\n   most quickly located with a tool that\
    \ can send probes of any\n   specified size, and collect and display all returned\
    \ ICMP PTB\n   messages.\n"
- title: 10.  Specific Packetization Layers
  contents:
  - "10.  Specific Packetization Layers\n   All Packetization Layer protocols must\
    \ consider all of the issues\n   discussed in Section 6.  For many protocols,\
    \ it is straightforward to\n   address these issues.  This section discusses specific\
    \ details for\n   implementing PLPMTUD with a couple of protocols.  It is hoped\
    \ that\n   the descriptions here will be sufficient illustration for\n   implementers\
    \ to adapt to additional protocols.\n"
- title: 10.1.  Probing Method Using TCP
  contents:
  - "10.1.  Probing Method Using TCP\n   TCP has no mechanism to distinguish in-band\
    \ data from padding.\n   Therefore, TCP must generate probes by appropriately\
    \ segmenting data.\n   There are two approaches to segmentation: overlapping and\
    \ non-\n   overlapping.\n   In the non-overlapping method, data is segmented such\
    \ that the probe\n   and any subsequent segments contain no overlapping data.\
    \  If the\n   probe is lost, the \"probe gap\" will be a full probe size minus\n\
    \   headers.  Data in the probe gap will need to be retransmitted with\n   multiple\
    \ smaller segments.\n             TCP sequence number\n           t   <---->\n\
    \           i         <-------->           (probe)\n           m             \
    \      <---->\n           e\n                         .\n                    \
    \     .                (probe lost)\n                         .\n            \
    \         <---->               (probe gap retransmitted)\n                   \
    \        <-->\n                                 Figure 2\n   An alternate approach\
    \ is to send subsequent data overlapping the\n   probe such that the probe gap\
    \ is equal in length to the current MSS.\n   In the case of a successful probe,\
    \ this has added overhead in that it\n   will send some data twice, but it will\
    \ have to retransmit only one\n   segment after a lost probe.  When a probe succeeds,\
    \ there will likely\n   be some duplicate acknowledgments generated due to the\
    \ duplicate data\n   sent.  It is important that these duplicate acknowledgments\
    \ not\n   trigger Fast Retransmit.  As such, an implementation using this\n  \
    \ approach SHOULD limit the probe size to three times the current MSS\n   (causing\
    \ at most 2 duplicate acknowledgments), or appropriately\n   adjust its duplicate\
    \ acknowledgment threshold for data immediately\n   after a successful probe.\n\
    \             TCP sequence number\n           t   <---->\n           i       \
    \  <-------->           (probe)\n           m               <---->\n         \
    \  e                     <---->\n                         .\n                \
    \         .                (probe lost)\n                         .\n        \
    \             <---->               (probe gap retransmitted)\n               \
    \                  Figure 3\n   The choice of which segmentation method to use\
    \ should be based on\n   what is simplest and most efficient for a given TCP implementation.\n"
- title: 10.2.  Probing Method Using SCTP
  contents:
  - "10.2.  Probing Method Using SCTP\n   In the Stream Control Transmission Protocol\
    \ (SCTP) [RFC2960], the\n   application writes messages to SCTP, which divides\
    \ the data into\n   smaller \"chunks\" suitable for transmission through the network.\
    \  Each\n   chunk is assigned a Transmission Sequence Number (TSN).  Once a TSN\n\
    \   has been transmitted, SCTP cannot change the chunk size.  SCTP multi-\n  \
    \ path support normally requires SCTP to choose a chunk size such that\n   its\
    \ messages to fit the smallest PMTU of all paths.  Although not\n   required,\
    \ implementations may bundle multiple data chunks together to\n   make larger\
    \ IP packets to send on paths with a larger PMTU.  Note\n   that SCTP must independently\
    \ probe the PMTU on each path to the peer.\n   The RECOMMENDED method for generating\
    \ probes is to add a chunk\n   consisting only of padding to an SCTP message.\
    \  The PAD chunk defined\n   in [RFC4820] SHOULD be attached to a minimum length\
    \ HEARTBEAT (HB)\n   chunk to build a probe packet.  This method is fully compatible\
    \ with\n   all current SCTP implementations.\n   SCTP MAY also probe with a method\
    \ similar to TCP's described above,\n   using inline data.  Using such a method\
    \ has the advantage that\n   successful probes have no additional overhead; however,\
    \ failed probes\n   will require retransmission of data, which may impact flow\n\
    \   performance.\n"
- title: 10.3.  Probing Method for IP Fragmentation
  contents:
  - "10.3.  Probing Method for IP Fragmentation\n   There are a few protocols and\
    \ applications that normally send large\n   datagrams and rely on IP fragmentation\
    \ to deliver them.  It has been\n   known for a long time that this has some undesirable\
    \ consequences\n   [Kent87].  More recently, it has come to light that IPv4\n\
    \   fragmentation is not sufficiently robust for general use in today's\n   Internet.\
    \  The 16-bit IP identification field is not large enough to\n   prevent frequent\
    \ mis-associated IP fragments, and the TCP and UDP\n   checksums are insufficient\
    \ to prevent the resulting corrupted data\n   from being delivered to higher protocol\
    \ layers [frag-errors].\n   As mentioned in Section 8, datagram protocols (such\
    \ as UDP) might\n   rely on IP fragmentation as a Packetization Layer.  However,\
    \ using IP\n   fragmentation to implement PLPMTUD is problematic because the IP\n\
    \   layer has no mechanism to determine whether the packets are\n   ultimately\
    \ delivered to the far node, without direct participation by\n   the application.\n\
    \   To support IP fragmentation as a Packetization Layer under an\n   unmodified\
    \ application, an implementation SHOULD rely on the Path MTU\n   sharing described\
    \ in Section 5.2 plus an adjunct protocol to probe\n   the Path MTU.  There are\
    \ a number of protocols that might be used for\n   the purpose, such as ICMP ECHO\
    \ and ECHO REPLY, or \"traceroute\" style\n   UDP datagrams that trigger ICMP\
    \ messages.  Use of ICMP ECHO and ECHO\n   REPLY will probe both forward and return\
    \ paths, so the sender will\n   only be able to take advantage of the minimum\
    \ of the two.  Other\n   methods that probe only the forward path are preferred\
    \ if available.\n   All of these approaches have a number of potential robustness\n\
    \   problems.  The most likely failures are due to losses unrelated to\n   MTU\
    \ (e.g., nodes that discard some protocol types).  These non-MTU-\n   related\
    \ losses can prevent PLPMTUD from raising the MTU, forcing IP\n   fragmentation\
    \ to use a smaller MTU than necessary.  Since these\n   failures are not likely\
    \ to cause interoperability problems they are\n   relatively benign.\n   However,\
    \ other more serious failure modes do exist, such as might be\n   caused by middle\
    \ boxes or upper-layer routers that choose different\n   paths for different protocol\
    \ types or sessions.  In such\n   environments, adjunct protocols may legitimately\
    \ experience a\n   different Path MTU than the primary protocol.  If the adjunct\n\
    \   protocol finds a larger MTU than the primary protocol, PLPMTUD may\n   select\
    \ an MTU that is not usable by the primary protocol.  Although\n   this is a potentially\
    \ serious problem, this sort of situation is\n   likely to be viewed as incorrect\
    \ by a large number of observers, and\n   thus there will be strong motivation\
    \ to correct it.\n   Since connectionless protocols might not keep enough state\
    \ to\n   effectively diagnose MTU black holes, it would be more robust to err\n\
    \   on the side of using too small of an initial MTU (e.g., 1 kByte or\n   less)\
    \ prior to probing a path to measure the MTU.  For this reason,\n   implementations\
    \ that use IP fragmentation SHOULD use an initial\n   eff_pmtu, which is selected\
    \ as described in Section 7.2, except using\n   a separate global control for\
    \ the default initial eff_mtu for\n   connectionless protocols.\n   Connectionless\
    \ protocols also introduce an additional problem with\n   maintaining the path\
    \ information cache: there are no events\n   corresponding to connection establishment\
    \ and tear-down to use to\n   manage the cache itself.  A natural approach would\
    \ be to keep an\n   immutable cache entry for the \"default path\", which has\
    \ a eff_pmtu\n   that is fixed at the initial value for connectionless protocols.\
    \  The\n   adjunct Path MTU Discovery protocol would be invoked once the number\n\
    \   of fragmented datagrams to any particular destination reaches some\n   configurable\
    \ threshold (e.g., 5 datagrams).  A new path cache entry\n   would be created\
    \ when the adjunct protocol updates eff_pmtu, and\n   deleted on the basis of\
    \ a timer or a Least Recently Used cache\n   replacement algorithm.\n"
- title: 10.4.  Probing Method Using Applications
  contents:
  - "10.4.  Probing Method Using Applications\n   The disadvantages of relying on\
    \ IP fragmentation and an adjunct\n   protocol to perform Path MTU Discovery can\
    \ be overcome by\n   implementing Path MTU Discovery within the application itself,\
    \ using\n   the application's own protocol.  The application must have some\n\
    \   suitable method for generating probes and have an accurate and timely\n  \
    \ mechanism to determine whether the probes were lost.\n   Ideally, the application\
    \ protocol includes a lightweight echo\n   function that confirms message delivery,\
    \ plus a mechanism for padding\n   the messages out to the desired probe size,\
    \ such that the padding is\n   not echoed.  This combination (akin to the SCTP\
    \ HB plus PAD) is\n   RECOMMENDED because an application can separately measure\
    \ the MTU of\n   each direction on a path with asymmetrical MTUs.\n   For protocols\
    \ that cannot implement PLPMTUD with \"echo plus pad\",\n   there are often alternate\
    \ methods for generating probes.  For\n   example, the protocol may have a variable\
    \ length echo that\n   effectively measures minimum MTU of both the forward and\
    \ return\n   path's, or there may be a way to add padding to regular messages\n\
    \   carrying real application data.  There may also be alternate ways to\n   segment\
    \ application data to generate probes, or as a last resort, it\n   may be feasible\
    \ to extend the protocol with new message types\n   specifically to support MTU\
    \ discovery.\n   Note that if it is necessary to add new message types to support\n\
    \   PLPMTUD, the most general approach is to add ECHO and PAD messages,\n   which\
    \ permit the greatest possible latitude in how an application-\n   specific implementation\
    \ of PLPMTUD interacts with other applications\n   and protocols on the same end\
    \ system.\n   All application probing techniques require the ability to send\n\
    \   messages that are larger than the current eff_pmtu described in\n   Section\
    \ 9.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   Under all conditions, the PLPMTUD procedures\
    \ described in this\n   document are at least as secure as the current standard\
    \ Path MTU\n   Discovery procedures described in RFC 1191 and RFC 1981.\n   Since\
    \ PLPMTUD is designed for robust operation without any ICMP or\n   other messages\
    \ from the network, it can be configured to ignore all\n   ICMP messages, either\
    \ globally or on a per-application basis.  In\n   such a configuration, it cannot\
    \ be attacked unless the attacker can\n   identify and cause probe packets to\
    \ be lost.  Attacking PLPMTUD\n   reduces performance, but not as much as attacking\
    \ congestion control\n   by causing arbitrary packets to be lost.  Such an attacker\
    \ might do\n   far more damage by completely disrupting specific protocols, such\
    \ as\n   DNS.\n   Since packetization protocols may share state with each other,\
    \ if one\n   packetization protocol (particularly an application) were hostile\
    \ to\n   other protocols on the same host, it could harm performance in the\n\
    \   other protocols by reducing the effective MTU.  If a packetization\n   protocol\
    \ is untrusted, it should not be allowed to write to shared\n   state.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC0791]       Postel, J., \"Internet Protocol\"\
    , STD 5, RFC 791,\n                   September 1981.\n   [RFC1191]       Mogul,\
    \ J. and S. Deering, \"Path MTU discovery\",\n                   RFC 1191, November\
    \ 1990.\n   [RFC1981]       McCann, J., Deering, S., and J. Mogul, \"Path MTU\n\
    \                   Discovery for IP version 6\", RFC 1981, August 1996.\n   [RFC2119]\
    \       Bradner, S., \"Key words for use in RFCs to Indicate\n               \
    \    Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2460]       Deering,\
    \ S. and R. Hinden, \"Internet Protocol,\n                   Version 6 (IPv6)\
    \ Specification\", RFC 2460,\n                   December 1998.\n   [RFC0793]\
    \       Postel, J., \"Transmission Control Protocol\", STD 7,\n              \
    \     RFC 793, September 1981.\n   [RFC3697]       Rajahalme, J., Conta, A., Carpenter,\
    \ B., and S.\n                   Deering, \"IPv6 Flow Label Specification\", RFC\
    \ 3697,\n                   March 2004.\n   [RFC2960]       Stewart, R., Xie,\
    \ Q., Morneault, K., Sharp, C.,\n                   Schwarzbauer, H., Taylor,\
    \ T., Rytina, I., Kalla, M.,\n                   Zhang, L., and V. Paxson, \"\
    Stream Control\n                   Transmission Protocol\", RFC 2960, October\
    \ 2000.\n   [RFC4820]       Tuexen, M., Stewart, R., and P. Lei, \"Padding Chunk\n\
    \                   and Parameter for the Stream Control Transmission\n      \
    \             Protocol (SCTP)\", RFC 4820, March 2007.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [RFC2760]       Allman, M., Dawkins, S., Glover,\
    \ D., Griner, J.,\n                   Tran, D., Henderson, T., Heidemann, J.,\
    \ Touch, J.,\n                   Kruse, H., Ostermann, S., Scott, K., and J. Semke,\n\
    \                   \"Ongoing TCP Research Related to Satellites\",\n        \
    \           RFC 2760, February 2000.\n   [RFC1122]       Braden, R., \"Requirements\
    \ for Internet Hosts -\n                   Communication Layers\", STD 3, RFC\
    \ 1122, October 1989.\n   [RFC2923]       Lahey, K., \"TCP Problems with Path\
    \ MTU Discovery\",\n                   RFC 2923, September 2000.\n   [RFC2401]\
    \       Kent, S. and R. Atkinson, \"Security Architecture for\n              \
    \     the Internet Protocol\", RFC 2401, November 1998.\n   [RFC2914]       Floyd,\
    \ S., \"Congestion Control Principles\", BCP 41,\n                   RFC 2914,\
    \ September 2000.\n   [RFC2461]       Narten, T., Nordmark, E., and W. Simpson,\
    \ \"Neighbor\n                   Discovery for IP Version 6 (IPv6)\", RFC 2461,\n\
    \                   December 1998.\n   [RFC3517]       Blanton, E., Allman, M.,\
    \ Fall, K., and L. Wang, \"A\n                   Conservative Selective Acknowledgment\
    \ (SACK)-based\n                   Loss Recovery Algorithm for TCP\", RFC 3517,\n\
    \                   April 2003.\n   [RFC4340]       Kohler, E., Handley, M., and\
    \ S. Floyd, \"Datagram\n                   Congestion Control Protocol (DCCP)\"\
    , RFC 4340,\n                   March 2006.\n   [Kent87]        Kent, C. and J.\
    \ Mogul, \"Fragmentation considered\n                   harmful\", Proc. SIGCOMM\
    \ '87 vol. 17, No. 5,\n                   October 1987.\n   [tcp-friendly]  Mahdavi,\
    \ J. and S. Floyd, \"TCP-Friendly Unicast Rate-\n                   Based Flow\
    \ Control\", Technical note sent to the\n                   end2end-interest mailing\
    \ list , January 1997, <http:/\n                   /www.psc.edu/networking/papers/tcp_friendly.html>.\n\
    \   [frag-errors]   Heffner, J., \"IPv4 Reassembly Errors at High Data\n     \
    \              Rates\", Work in Progress, December 2007.\n"
- title: Appendix A.  Acknowledgments
  contents:
  - "Appendix A.  Acknowledgments\n   Many ideas and even some of the text come directly\
    \ from RFC 1191 and\n   RFC 1981.\n   Many people made significant contributions\
    \ to this document,\n   including: Randall Stewart for SCTP text, Michael Richardson\
    \ for\n   material from an earlier ID on tunnels that ignore DF, Stanislav\n \
    \  Shalunov for the idea that pure PLPMTUD parallels congestion control,\n   and\
    \ Matt Zekauskas for maintaining focus during the meetings.  Thanks\n   to the\
    \ early implementors: Kevin Lahey, John Heffner, and Rao Shoaib,\n   who provided\
    \ concrete feedback on weaknesses in earlier versions.\n   Thanks also to all\
    \ of the people who made constructive comments in\n   the working group meetings\
    \ and on the mailing list.  We are sure we\n   have missed many deserving people.\n\
    \   Matt Mathis and John Heffner are supported in this work by a grant\n   from\
    \ Cisco Systems, Inc.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Matt Mathis\n   Pittsburgh Supercomputing Center\n   4400\
    \ Fifth Avenue\n   Pittsburgh, PA  15213\n   USA\n   Phone: 412-268-3319\n   EMail:\
    \ mathis@psc.edu\n   John W. Heffner\n   Pittsburgh Supercomputing Center\n  \
    \ 4400 Fifth Avenue\n   Pittsburgh, PA  15213\n   US\n   Phone: 412-268-2329\n\
    \   EMail: jheffner@psc.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
