- title: __initial_text__
  contents:
  - '                Hypertext Transfer Protocol -- HTTP/1.1

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n\
    \   protocol for distributed, collaborative, hypermedia information\n   systems.\
    \ It is a generic, stateless, object-oriented protocol which\n   can be used for\
    \ many tasks, such as name servers and distributed\n   object management systems,\
    \ through extension of its request methods.\n   A feature of HTTP is the typing\
    \ and negotiation of data\n   representation, allowing systems to be built independently\
    \ of the\n   data being transferred.\n   HTTP has been in use by the World-Wide\
    \ Web global information\n   initiative since 1990. This specification defines\
    \ the protocol\n   referred to as \"HTTP/1.1\".\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    3.2 Uniform Resource Identifiers ........................18\n\
    \     3.2.1 General Syntax ...................................18\n     3.2.2 http\
    \ URL .........................................19\n     3.2.3 URI Comparison ...................................20\n\
    \    3.3 Date/Time Formats ...................................21\n     3.3.1 Full\
    \ Date ........................................21\n     3.3.2 Delta Seconds ....................................22\n\
    \    3.4 Character Sets ......................................22\n    3.5 Content\
    \ Codings .....................................23\n    3.6 Transfer Codings ....................................24\n\
    \    3.7 Media Types .........................................25\n     3.7.1 Canonicalization\
    \ and Text Defaults ...............26\n     3.7.2 Multipart Types ..................................27\n\
    \    3.8 Product Tokens ......................................28\n    3.9 Quality\
    \ Values ......................................28\n    3.10 Language Tags ......................................28\n\
    \    3.11 Entity Tags ........................................29\n    3.12 Range\
    \ Units ........................................30\n   4 HTTP Message............................................30\n\
    \    4.1 Message Types .......................................30\n    4.2 Message\
    \ Headers .....................................31\n    4.3 Message Body ........................................32\n\
    \    4.4 Message Length ......................................32\n    4.5 General\
    \ Header Fields ...............................34\n   5 Request.................................................34\n\
    \    5.1 Request-Line ........................................34\n     5.1.1 Method\
    \ ...........................................35\n     5.1.2 Request-URI ......................................35\n\
    \    5.2 The Resource Identified by a Request ................37\n    5.3 Request\
    \ Header Fields ...............................37\n   6 Response................................................38\n\
    \    6.1 Status-Line .........................................38\n     6.1.1 Status\
    \ Code and Reason Phrase ....................39\n    6.2 Response Header Fields\
    \ ..............................41\n   7 Entity..................................................41\n\
    \    7.1 Entity Header Fields ................................41\n    7.2 Entity\
    \ Body .........................................42\n     7.2.1 Type .............................................42\n\
    \     7.2.2 Length ...........................................43\n   8 Connections.............................................43\n\
    \    8.1 Persistent Connections ..............................43\n     8.1.1 Purpose\
    \ ..........................................43\n     8.1.2 Overall Operation ................................44\n\
    \     8.1.3 Proxy Servers ....................................45\n     8.1.4 Practical\
    \ Considerations .........................45\n    8.2 Message Transmission Requirements\
    \ ...................46\n   9 Method Definitions......................................48\n\
    \    9.1 Safe and Idempotent Methods .........................48\n     9.1.1 Safe\
    \ Methods .....................................48\n     9.1.2 Idempotent Methods\
    \ ...............................49\n    9.2 OPTIONS .............................................49\n\
    \    9.3 GET .................................................50\n    9.4 HEAD\
    \ ................................................50\n    9.5 POST ................................................51\n\
    \    9.6 PUT .................................................52\n    9.7 DELETE\
    \ ..............................................53\n    9.8 TRACE ...............................................53\n\
    \   10 Status Code Definitions................................53\n    10.1 Informational\
    \ 1xx ..................................54\n     10.1.1 100 Continue ....................................54\n\
    \     10.1.2 101 Switching Protocols .........................54\n    10.2 Successful\
    \ 2xx .....................................54\n     10.2.1 200 OK ..........................................54\n\
    \     10.2.2 201 Created .....................................55\n     10.2.3\
    \ 202 Accepted ....................................55\n     10.2.4 203 Non-Authoritative\
    \ Information ...............55\n     10.2.5 204 No Content ..................................55\n\
    \     10.2.6 205 Reset Content ...............................56\n     10.2.7\
    \ 206 Partial Content .............................56\n    10.3 Redirection 3xx\
    \ ....................................56\n     10.3.1 300 Multiple Choices ............................57\n\
    \     10.3.2 301 Moved Permanently ...........................57\n     10.3.3\
    \ 302 Moved Temporarily ...........................58\n     10.3.4 303 See Other\
    \ ...................................58\n     10.3.5 304 Not Modified ................................58\n\
    \     10.3.6 305 Use Proxy ...................................59\n    10.4 Client\
    \ Error 4xx ...................................59\n     10.4.1 400 Bad Request\
    \ .................................60\n     10.4.2 401 Unauthorized ................................60\n\
    \     10.4.3 402 Payment Required ............................60\n     10.4.4\
    \ 403 Forbidden ...................................60\n     10.4.5 404 Not Found\
    \ ...................................60\n     10.4.6 405 Method Not Allowed ..........................61\n\
    \     10.4.7 406 Not Acceptable ..............................61\n     10.4.8\
    \ 407 Proxy Authentication Required ...............61\n     10.4.9 408 Request\
    \ Timeout .............................62\n     10.4.10 409 Conflict ...................................62\n\
    \     10.4.11 410 Gone .......................................62\n     10.4.12\
    \ 411 Length Required ............................63\n     10.4.13 412 Precondition\
    \ Failed ........................63\n     10.4.14 413 Request Entity Too Large\
    \ ...................63\n     10.4.15 414 Request-URI Too Long .......................63\n\
    \     10.4.16 415 Unsupported Media Type .....................63\n    10.5 Server\
    \ Error 5xx ...................................64\n     10.5.1 500 Internal Server\
    \ Error .......................64\n     10.5.2 501 Not Implemented .............................64\n\
    \     10.5.3 502 Bad Gateway .................................64\n     10.5.4\
    \ 503 Service Unavailable .........................64\n     10.5.5 504 Gateway\
    \ Timeout .............................64\n     10.5.6 505 HTTP Version Not Supported\
    \ ..................65\n   11 Access Authentication..................................65\n\
    \    11.1 Basic Authentication Scheme ........................66\n    11.2 Digest\
    \ Authentication Scheme .......................67\n   12 Content Negotiation....................................67\n\
    \    12.1 Server-driven Negotiation ..........................68\n    12.2 Agent-driven\
    \ Negotiation ...........................69\n    12.3 Transparent Negotiation\
    \ ............................70\n   13 Caching in HTTP........................................70\n\
    \     13.1.1 Cache Correctness ...............................72\n     13.1.2\
    \ Warnings ........................................73\n     13.1.3 Cache-control\
    \ Mechanisms ........................74\n     13.1.4 Explicit User Agent Warnings\
    \ ....................74\n     13.1.5 Exceptions to the Rules and Warnings ............75\n\
    \     13.1.6 Client-controlled Behavior ......................75\n    13.2 Expiration\
    \ Model ...................................75\n     13.2.1 Server-Specified Expiration\
    \ .....................75\n     13.2.2 Heuristic Expiration ............................76\n\
    \     13.2.3 Age Calculations ................................77\n     13.2.4\
    \ Expiration Calculations .........................79\n     13.2.5 Disambiguating\
    \ Expiration Values ................80\n     13.2.6 Disambiguating Multiple Responses\
    \ ...............80\n    13.3 Validation Model ...................................81\n\
    \     13.3.1 Last-modified Dates .............................82\n     13.3.2\
    \ Entity Tag Cache Validators .....................82\n     13.3.3 Weak and Strong\
    \ Validators ......................82\n     13.3.4 Rules for When to Use Entity\
    \ Tags and Last-\n     modified Dates..........................................85\n\
    \     13.3.5 Non-validating Conditionals .....................86\n    13.4 Response\
    \ Cachability ...............................86\n    13.5 Constructing Responses\
    \ From Caches .................87\n     13.5.1 End-to-end and Hop-by-hop Headers\
    \ ...............88\n     13.5.2 Non-modifiable Headers ..........................88\n\
    \     13.5.3 Combining Headers ...............................89\n     13.5.4\
    \ Combining Byte Ranges ...........................90\n    13.6 Caching Negotiated\
    \ Responses .......................90\n    13.7 Shared and Non-Shared Caches .......................91\n\
    \    13.8 Errors or Incomplete Response Cache Behavior .......91\n    13.9 Side\
    \ Effects of GET and HEAD .......................92\n    13.10 Invalidation After\
    \ Updates or Deletions ...........92\n    13.11 Write-Through Mandatory ...........................93\n\
    \    13.12 Cache Replacement .................................93\n    13.13 History\
    \ Lists .....................................93\n   14 Header Field Definitions...............................94\n\
    \    14.1 Accept .............................................95\n    14.2 Accept-Charset\
    \ .....................................97\n    14.3 Accept-Encoding ....................................97\n\
    \    14.4 Accept-Language ....................................98\n    14.5 Accept-Ranges\
    \ ......................................99\n    14.6 Age ................................................99\n\
    \    14.7 Allow .............................................100\n    14.8 Authorization\
    \ .....................................100\n    14.9 Cache-Control .....................................101\n\
    \     14.9.1 What is Cachable ...............................103\n     14.9.2\
    \ What May be Stored by Caches ...................103\n     14.9.3 Modifications\
    \ of the Basic Expiration Mechanism 104\n     14.9.4 Cache Revalidation and Reload\
    \ Controls .........105\n     14.9.5 No-Transform Directive .........................107\n\
    \     14.9.6 Cache Control Extensions .......................108\n    14.10 Connection\
    \ .......................................109\n    14.11 Content-Base .....................................109\n\
    \    14.12 Content-Encoding .................................110\n    14.13 Content-Language\
    \ .................................110\n    14.14 Content-Length ...................................111\n\
    \    14.15 Content-Location .................................112\n    14.16 Content-MD5\
    \ ......................................113\n    14.17 Content-Range ....................................114\n\
    \    14.18 Content-Type .....................................116\n    14.19 Date\
    \ .............................................116\n    14.20 ETag .............................................117\n\
    \    14.21 Expires ..........................................117\n    14.22 From\
    \ .............................................118\n    14.23 Host .............................................119\n\
    \    14.24 If-Modified-Since ................................119\n    14.25 If-Match\
    \ .........................................121\n    14.26 If-None-Match ....................................122\n\
    \    14.27 If-Range .........................................123\n    14.28 If-Unmodified-Since\
    \ ..............................124\n    14.29 Last-Modified ....................................124\n\
    \    14.30 Location .........................................125\n    14.31 Max-Forwards\
    \ .....................................125\n    14.32 Pragma ...........................................126\n\
    \    14.33 Proxy-Authenticate ...............................127\n    14.34 Proxy-Authorization\
    \ ..............................127\n    14.35 Public ...........................................127\n\
    \    14.36 Range ............................................128\n     14.36.1\
    \ Byte Ranges ...................................128\n     14.36.2 Range Retrieval\
    \ Requests ......................130\n    14.37 Referer ..........................................131\n\
    \    14.38 Retry-After ......................................131\n    14.39 Server\
    \ ...........................................132\n    14.40 Transfer-Encoding\
    \ ................................132\n    14.41 Upgrade ..........................................132\n\
    \    14.42 User-Agent .......................................134\n    14.43 Vary\
    \ .............................................134\n    14.44 Via ..............................................135\n\
    \    14.45 Warning ..........................................137\n    14.46 WWW-Authenticate\
    \ .................................139\n   15 Security Considerations...............................139\n\
    \    15.1 Authentication of Clients .........................139\n    15.2 Offering\
    \ a Choice of Authentication Schemes .......140\n    15.3 Abuse of Server Log\
    \ Information ...................141\n    15.4 Transfer of Sensitive Information\
    \ .................141\n    15.5 Attacks Based On File and Path Names ..............142\n\
    \    15.6 Personal Information ..............................143\n    15.7 Privacy\
    \ Issues Connected to Accept Headers ........143\n    15.8 DNS Spoofing ......................................144\n\
    \    15.9 Location Headers and Spoofing .....................144\n   16 Acknowledgments.......................................144\n\
    \   17 References............................................146\n   18 Authors'\
    \ Addresses....................................149\n   19 Appendices............................................150\n\
    \    19.1 Internet Media Type message/http ..................150\n    19.2 Internet\
    \ Media Type multipart/byteranges ..........150\n    19.3 Tolerant Applications\
    \ .............................151\n    19.4 Differences Between HTTP Entities\
    \ and\n    MIME Entities...........................................152\n     19.4.1\
    \ Conversion to Canonical Form ...................152\n     19.4.2 Conversion\
    \ of Date Formats .....................153\n     19.4.3 Introduction of Content-Encoding\
    \ ...............153\n     19.4.4 No Content-Transfer-Encoding ...................153\n\
    \     19.4.5 HTTP Header Fields in Multipart Body-Parts .....153\n     19.4.6\
    \ Introduction of Transfer-Encoding ..............154\n     19.4.7 MIME-Version\
    \ ...................................154\n    19.5 Changes from HTTP/1.0 .............................154\n\
    \     19.5.1 Changes to Simplify Multi-homed Web Servers and\n     Conserve IP\
    \ Addresses .................................155\n    19.6 Additional Features\
    \ ...............................156\n     19.6.1 Additional Request Methods .....................156\n\
    \     19.6.2 Additional Header Field Definitions ............156\n    19.7 Compatibility\
    \ with Previous Versions ..............160\n     19.7.1 Compatibility with HTTP/1.0\
    \ Persistent\n     Connections............................................161\n"
- title: 1 Introduction
  contents:
  - '1 Introduction

    '
- title: 1.1 Purpose
  contents:
  - "1.1 Purpose\n   The Hypertext Transfer Protocol (HTTP) is an application-level\n\
    \   protocol for distributed, collaborative, hypermedia information\n   systems.\
    \ HTTP has been in use by the World-Wide Web global\n   information initiative\
    \ since 1990. The first version of HTTP,\n   referred to as HTTP/0.9, was a simple\
    \ protocol for raw data transfer\n   across the Internet. HTTP/1.0, as defined\
    \ by RFC 1945 [6], improved\n   the protocol by allowing messages to be in the\
    \ format of MIME-like\n   messages, containing metainformation about the data\
    \ transferred and\n   modifiers on the request/response semantics. However, HTTP/1.0\
    \ does\n   not sufficiently take into consideration the effects of hierarchical\n\
    \   proxies, caching, the need for persistent connections, and virtual\n   hosts.\
    \ In addition, the proliferation of incompletely-implemented\n   applications\
    \ calling themselves \"HTTP/1.0\" has necessitated a\n   protocol version change\
    \ in order for two communicating applications\n   to determine each other's true\
    \ capabilities.\n   This specification defines the protocol referred to as \"\
    HTTP/1.1\".\n   This protocol includes more stringent requirements than HTTP/1.0\
    \ in\n   order to ensure reliable implementation of its features.\n   Practical\
    \ information systems require more functionality than simple\n   retrieval, including\
    \ search, front-end update, and annotation. HTTP\n   allows an open-ended set\
    \ of methods that indicate the purpose of a\n   request. It builds on the discipline\
    \ of reference provided by the\n   Uniform Resource Identifier (URI) [3][20],\
    \ as a location (URL) [4] or\n   name (URN) , for indicating the resource to which\
    \ a method is to be\n   applied. Messages are passed in a format similar to that\
    \ used by\n   Internet mail as defined by the Multipurpose Internet Mail Extensions\n\
    \   (MIME).\n   HTTP is also used as a generic protocol for communication between\n\
    \   user agents and proxies/gateways to other Internet systems, including\n  \
    \ those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],\n   and WAIS\
    \ [10] protocols. In this way, HTTP allows basic hypermedia\n   access to resources\
    \ available from diverse applications.\n"
- title: 1.2 Requirements
  contents:
  - "1.2 Requirements\n   This specification uses the same words as RFC 1123 [8] for\
    \ defining\n   the significance of each particular requirement. These words are:\n\
    \   MUST\n      This word or the adjective \"required\" means that the item is\
    \ an\n      absolute requirement of the specification.\n   SHOULD\n      This\
    \ word or the adjective \"recommended\" means that there may\n      exist valid\
    \ reasons in particular circumstances to ignore this\n      item, but the full\
    \ implications should be understood and the case\n      carefully weighed before\
    \ choosing a different course.\n   MAY\n      This word or the adjective \"optional\"\
    \ means that this item is\n      truly optional. One vendor may choose to include\
    \ the item because\n      a particular marketplace requires it or because it enhances\
    \ the\n      product, for example; another vendor may omit the same item.\n  \
    \ An implementation is not compliant if it fails to satisfy one or more\n   of\
    \ the MUST requirements for the protocols it implements. An\n   implementation\
    \ that satisfies all the MUST and all the SHOULD\n   requirements for its protocols\
    \ is said to be \"unconditionally\n   compliant\"; one that satisfies all the\
    \ MUST requirements but not all\n   the SHOULD requirements for its protocols\
    \ is said to be\n   \"conditionally compliant.\"\n"
- title: 1.3 Terminology
  contents:
  - "1.3 Terminology\n   This specification uses a number of terms to refer to the\
    \ roles\n   played by participants in, and objects of, the HTTP communication.\n\
    \   connection\n      A transport layer virtual circuit established between two\
    \ programs\n      for the purpose of communication.\n   message\n      The basic\
    \ unit of HTTP communication, consisting of a structured\n      sequence of octets\
    \ matching the syntax defined in section 4 and\n      transmitted via the connection.\n\
    \   request\n      An HTTP request message, as defined in section 5.\n   response\n\
    \      An HTTP response message, as defined in section 6.\n   resource\n     \
    \ A network data object or service that can be identified by a URI,\n      as\
    \ defined in section 3.2. Resources may be available in multiple\n      representations\
    \ (e.g. multiple languages, data formats, size,\n      resolutions) or vary in\
    \ other ways.\n   entity\n      The information transferred as the payload of\
    \ a request or\n      response. An entity consists of metainformation in the form\
    \ of\n      entity-header fields and content in the form of an entity-body, as\n\
    \      described in section 7.\n   representation\n      An entity included with\
    \ a response that is subject to content\n      negotiation, as described in section\
    \ 12. There may exist multiple\n      representations associated with a particular\
    \ response status.\n   content negotiation\n      The mechanism for selecting\
    \ the appropriate representation when\n      servicing a request, as described\
    \ in section 12. The\n      representation of entities in any response can be\
    \ negotiated\n      (including error responses).\n   variant\n      A resource\
    \ may have one, or more than one, representation(s)\n      associated with it\
    \ at any given instant. Each of these\n      representations is termed a `variant.'\
    \ Use of the term `variant'\n      does not necessarily imply that the resource\
    \ is subject to content\n      negotiation.\n   client\n      A program that establishes\
    \ connections for the purpose of sending\n      requests.\n   user agent\n   \
    \   The client which initiates a request. These are often browsers,\n      editors,\
    \ spiders (web-traversing robots), or other end user tools.\n   server\n     \
    \ An application program that accepts connections in order to\n      service requests\
    \ by sending back responses. Any given program may\n      be capable of being\
    \ both a client and a server; our use of these\n      terms refers only to the\
    \ role being performed by the program for a\n      particular connection, rather\
    \ than to the program's capabilities\n      in general.  Likewise, any server\
    \ may act as an origin server,\n      proxy, gateway, or tunnel, switching behavior\
    \ based on the nature\n      of each request.\n   origin server\n      The server\
    \ on which a given resource resides or is to be created.\n   proxy\n      An intermediary\
    \ program which acts as both a server and a client\n      for the purpose of making\
    \ requests on behalf of other clients.\n      Requests are serviced internally\
    \ or by passing them on, with\n      possible translation, to other servers. A\
    \ proxy must implement\n      both the client and server requirements of this\
    \ specification.\n   gateway\n      A server which acts as an intermediary for\
    \ some other server.\n      Unlike a proxy, a gateway receives requests as if\
    \ it were the\n      origin server for the requested resource; the requesting\
    \ client\n      may not be aware that it is communicating with a gateway.\n  \
    \ tunnel\n      An intermediary program which is acting as a blind relay between\n\
    \      two connections. Once active, a tunnel is not considered a party\n    \
    \  to the HTTP communication, though the tunnel may have been\n      initiated\
    \ by an HTTP request. The tunnel ceases to exist when both\n      ends of the\
    \ relayed connections are closed.\n   cache\n      A program's local store of\
    \ response messages and the subsystem\n      that controls its message storage,\
    \ retrieval, and deletion. A\n      cache stores cachable responses in order to\
    \ reduce the response\n      time and network bandwidth consumption on future,\
    \ equivalent\n      requests. Any client or server may include a cache, though\
    \ a cache\n      cannot be used by a server that is acting as a tunnel.\n   cachable\n\
    \      A response is cachable if a cache is allowed to store a copy of\n     \
    \ the response message for use in answering subsequent requests. The\n      rules\
    \ for determining the cachability of HTTP responses are\n      defined in section\
    \ 13. Even if a resource is cachable, there may\n      be additional constraints\
    \ on whether a cache can use the cached\n      copy for a particular request.\n\
    \   first-hand\n      A response is first-hand if it comes directly and without\n\
    \      unnecessary delay from the origin server, perhaps via one or more\n   \
    \   proxies. A response is also first-hand if its validity has just\n      been\
    \ checked directly with the origin server.\n   explicit expiration time\n    \
    \  The time at which the origin server intends that an entity should\n      no\
    \ longer be returned by a cache without further validation.\n   heuristic expiration\
    \ time\n      An expiration time assigned by a cache when no explicit expiration\n\
    \      time is available.\n   age\n      The age of a response is the time since\
    \ it was sent by, or\n      successfully validated with, the origin server.\n\
    \   freshness lifetime\n      The length of time between the generation of a response\
    \ and its\n      expiration time.\n   fresh\n      A response is fresh if its\
    \ age has not yet exceeded its freshness\n      lifetime.\n   stale\n      A response\
    \ is stale if its age has passed its freshness lifetime.\n   semantically transparent\n\
    \      A cache behaves in a \"semantically transparent\" manner, with\n      respect\
    \ to a particular response, when its use affects neither the\n      requesting\
    \ client nor the origin server, except to improve\n      performance. When a cache\
    \ is semantically transparent, the client\n      receives exactly the same response\
    \ (except for hop-by-hop headers)\n      that it would have received had its request\
    \ been handled directly\n      by the origin server.\n   validator\n      A protocol\
    \ element (e.g., an entity tag or a Last-Modified time)\n      that is used to\
    \ find out whether a cache entry is an equivalent\n      copy of an entity.\n"
- title: 1.4 Overall Operation
  contents:
  - "1.4 Overall Operation\n   The HTTP protocol is a request/response protocol. A\
    \ client sends a\n   request to the server in the form of a request method, URI,\
    \ and\n   protocol version, followed by a MIME-like message containing request\n\
    \   modifiers, client information, and possible body content over a\n   connection\
    \ with a server. The server responds with a status line,\n   including the message's\
    \ protocol version and a success or error code,\n   followed by a MIME-like message\
    \ containing server information, entity\n   metainformation, and possible entity-body\
    \ content. The relationship\n   between HTTP and MIME is described in appendix\
    \ 19.4.\n   Most HTTP communication is initiated by a user agent and consists\
    \ of\n   a request to be applied to a resource on some origin server. In the\n\
    \   simplest case, this may be accomplished via a single connection (v)\n   between\
    \ the user agent (UA) and the origin server (O).\n             request chain ------------------------>\n\
    \          UA -------------------v------------------- O\n             <-----------------------\
    \ response chain\n   A more complicated situation occurs when one or more intermediaries\n\
    \   are present in the request/response chain. There are three common\n   forms\
    \ of intermediary: proxy, gateway, and tunnel. A proxy is a\n   forwarding agent,\
    \ receiving requests for a URI in its absolute form,\n   rewriting all or part\
    \ of the message, and forwarding the reformatted\n   request toward the server\
    \ identified by the URI. A gateway is a\n   receiving agent, acting as a layer\
    \ above some other server(s) and, if\n   necessary, translating the requests to\
    \ the underlying server's\n   protocol. A tunnel acts as a relay point between\
    \ two connections\n   without changing the messages; tunnels are used when the\n\
    \   communication needs to pass through an intermediary (such as a\n   firewall)\
    \ even when the intermediary cannot understand the contents\n   of the messages.\n\
    \             request chain -------------------------------------->\n        \
    \  UA -----v----- A -----v----- B -----v----- C -----v----- O\n             <-------------------------------------\
    \ response chain\n   The figure above shows three intermediaries (A, B, and C)\
    \ between the\n   user agent and origin server. A request or response message\
    \ that\n   travels the whole chain will pass through four separate connections.\n\
    \   This distinction is important because some HTTP communication options\n  \
    \ may apply only to the connection with the nearest, non-tunnel\n   neighbor,\
    \ only to the end-points of the chain, or to all connections\n   along the chain.\
    \  Although the diagram is linear, each participant\n   may be engaged in multiple,\
    \ simultaneous communications. For example,\n   B may be receiving requests from\
    \ many clients other than A, and/or\n   forwarding requests to servers other than\
    \ C, at the same time that it\n   is handling A's request.\n   Any party to the\
    \ communication which is not acting as a tunnel may\n   employ an internal cache\
    \ for handling requests. The effect of a cache\n   is that the request/response\
    \ chain is shortened if one of the\n   participants along the chain has a cached\
    \ response applicable to that\n   request. The following illustrates the resulting\
    \ chain if B has a\n   cached copy of an earlier response from O (via C) for a\
    \ request which\n   has not been cached by UA or A.\n             request chain\
    \ ---------->\n          UA -----v----- A -----v----- B - - - - - - C - - - -\
    \ - - O\n             <--------- response chain\n   Not all responses are usefully\
    \ cachable, and some requests may\n   contain modifiers which place special requirements\
    \ on cache behavior.\n   HTTP requirements for cache behavior and cachable responses\
    \ are\n   defined in section 13.\n   In fact, there are a wide variety of architectures\
    \ and configurations\n   of caches and proxies currently being experimented with\
    \ or deployed\n   across the World Wide Web; these systems include national hierarchies\n\
    \   of proxy caches to save transoceanic bandwidth, systems that\n   broadcast\
    \ or multicast cache entries, organizations that distribute\n   subsets of cached\
    \ data via CD-ROM, and so on. HTTP systems are used\n   in corporate intranets\
    \ over high-bandwidth links, and for access via\n   PDAs with low-power radio\
    \ links and intermittent connectivity. The\n   goal of HTTP/1.1 is to support\
    \ the wide diversity of configurations\n   already deployed while introducing\
    \ protocol constructs that meet the\n   needs of those who build web applications\
    \ that require high\n   reliability and, failing that, at least reliable indications\
    \ of\n   failure.\n   HTTP communication usually takes place over TCP/IP connections.\
    \ The\n   default port is TCP 80, but other ports can be used. This does not\n\
    \   preclude HTTP from being implemented on top of any other protocol on\n   the\
    \ Internet, or on other networks. HTTP only presumes a reliable\n   transport;\
    \ any protocol that provides such guarantees can be used;\n   the mapping of the\
    \ HTTP/1.1 request and response structures onto the\n   transport data units of\
    \ the protocol in question is outside the scope\n   of this specification.\n \
    \  In HTTP/1.0, most implementations used a new connection for each\n   request/response\
    \ exchange. In HTTP/1.1, a connection may be used for\n   one or more request/response\
    \ exchanges, although connections may be\n   closed for a variety of reasons (see\
    \ section 8.1).\n"
- title: 2 Notational Conventions and Generic Grammar
  contents:
  - '2 Notational Conventions and Generic Grammar

    '
- title: 2.1 Augmented BNF
  contents:
  - "2.1 Augmented BNF\n   All of the mechanisms specified in this document are described\
    \ in\n   both prose and an augmented Backus-Naur Form (BNF) similar to that\n\
    \   used by RFC 822 [9]. Implementers will need to be familiar with the\n   notation\
    \ in order to understand this specification. The augmented BNF\n   includes the\
    \ following constructs:\n"
- title: name = definition
  contents:
  - "name = definition\n     The name of a rule is simply the name itself (without\
    \ any enclosing\n     \"<\" and \">\") and is separated from its definition by\
    \ the equal \"=\"\n     character. Whitespace is only significant in that indentation\
    \ of\n     continuation lines is used to indicate a rule definition that spans\n\
    \     more than one line. Certain basic rules are in uppercase, such as\n    \
    \ SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle brackets are used\n     within definitions\
    \ whenever their presence will facilitate\n     discerning the use of rule names.\n"
- title: '"literal"'
  contents:
  - "\"literal\"\n     Quotation marks surround literal text. Unless stated otherwise,\
    \ the\n          text is case-insensitive.\n"
- title: rule1 | rule2
  contents:
  - "rule1 | rule2\n     Elements separated by a bar (\"|\") are alternatives, e.g.,\
    \ \"yes |\n     no\" will accept yes or no.\n"
- title: (rule1 rule2)
  contents:
  - "(rule1 rule2)\n     Elements enclosed in parentheses are treated as a single\
    \ element.\n     Thus, \"(elem (foo | bar) elem)\" allows the token sequences\
    \ \"elem\n     foo elem\" and \"elem bar elem\".\n"
- title: '*rule'
  contents:
  - "*rule\n     The character \"*\" preceding an element indicates repetition. The\n\
    \     full form is \"<n>*<m>element\" indicating at least <n> and at most\n  \
    \   <m> occurrences of element. Default values are 0 and infinity so\n     that\
    \ \"*(element)\" allows any number, including zero; \"1*element\"\n     requires\
    \ at least one; and \"1*2element\" allows one or two.\n"
- title: '[rule]'
  contents:
  - "[rule]\n     Square brackets enclose optional elements; \"[foo bar]\" is\n  \
    \   equivalent to \"*1(foo bar)\".\n"
- title: N rule
  contents:
  - "N rule\n     Specific repetition: \"<n>(element)\" is equivalent to\n     \"\
    <n>*<n>(element)\"; that is, exactly <n> occurrences of (element).\n     Thus\
    \ 2DIGIT is a 2-digit number, and 3ALPHA is a string of three\n     alphabetic\
    \ characters.\n"
- title: '#rule'
  contents:
  - "#rule\n     A construct \"#\" is defined, similar to \"*\", for defining lists\
    \ of\n     elements. The full form is \"<n>#<m>element \" indicating at least\n\
    \     <n> and at most <m> elements, each separated by one or more commas\n   \
    \  (\",\") and optional linear whitespace (LWS). This makes the usual\n     form\
    \ of lists very easy; a rule such as \"( *LWS element *( *LWS \",\"\n     *LWS\
    \ element )) \" can be shown as \"1#element\". Wherever this\n     construct is\
    \ used, null elements are allowed, but do not contribute\n     to the count of\
    \ elements present.  That is, \"(element), , (element)\n     \" is permitted,\
    \ but counts as only two elements. Therefore, where\n     at least one element\
    \ is required, at least one non-null element\n     must be present. Default values\
    \ are 0 and infinity so that\n     \"#element\" allows any number, including zero;\
    \ \"1#element\" requires\n     at least one; and \"1#2element\" allows one or\
    \ two.\n"
- title: ; comment
  contents:
  - "; comment\n     A semi-colon, set off some distance to the right of rule text,\n\
    \     starts a comment that continues to the end of line. This is a\n     simple\
    \ way of including useful notes in parallel with the\n     specifications.\n"
- title: implied *LWS
  contents:
  - "implied *LWS\n     The grammar described by this specification is word-based.\
    \ Except\n     where noted otherwise, linear whitespace (LWS) can be included\n\
    \     between any two adjacent words (token or quoted-string), and\n     between\
    \ adjacent tokens and delimiters (tspecials), without\n     changing the interpretation\
    \ of a field. At least one delimiter\n     (tspecials) must exist between any\
    \ two tokens, since they would\n     otherwise be interpreted as a single token.\n"
- title: 2.2 Basic Rules
  contents:
  - "2.2 Basic Rules\n   The following rules are used throughout this specification\
    \ to\n   describe basic parsing constructs. The US-ASCII coded character set\n\
    \   is defined by ANSI X3.4-1986 [21].\n          OCTET          = <any 8-bit\
    \ sequence of data>\n          CHAR           = <any US-ASCII character (octets\
    \ 0 - 127)>\n          UPALPHA        = <any US-ASCII uppercase letter \"A\"..\"\
    Z\">\n          LOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\n\
    \          ALPHA          = UPALPHA | LOALPHA\n          DIGIT          = <any\
    \ US-ASCII digit \"0\"..\"9\">\n          CTL            = <any US-ASCII control\
    \ character\n                           (octets 0 - 31) and DEL (127)>\n     \
    \     CR             = <US-ASCII CR, carriage return (13)>\n          LF     \
    \        = <US-ASCII LF, linefeed (10)>\n          SP             = <US-ASCII\
    \ SP, space (32)>\n          HT             = <US-ASCII HT, horizontal-tab (9)>\n\
    \          <\">            = <US-ASCII double-quote mark (34)>\n   HTTP/1.1 defines\
    \ the sequence CR LF as the end-of-line marker for all\n   protocol elements except\
    \ the entity-body (see appendix 19.3 for\n   tolerant applications). The end-of-line\
    \ marker within an entity-body\n   is defined by its associated media type, as\
    \ described in section 3.7.\n          CRLF           = CR LF\n   HTTP/1.1 headers\
    \ can be folded onto multiple lines if the\n   continuation line begins with a\
    \ space or horizontal tab. All linear\n   white space, including folding, has\
    \ the same semantics as SP.\n          LWS            = [CRLF] 1*( SP | HT )\n\
    \   The TEXT rule is only used for descriptive field contents and values\n   that\
    \ are not intended to be interpreted by the message parser. Words\n   of *TEXT\
    \ may contain characters from character sets other than ISO\n   8859-1 [22] only\
    \ when encoded according to the rules of RFC 1522\n   [14].\n          TEXT  \
    \         = <any OCTET except CTLs,\n                           but including\
    \ LWS>\n   Hexadecimal numeric characters are used in several protocol elements.\n\
    \          HEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n  \
    \                       | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n\
    \   Many HTTP/1.1 header field values consist of words separated by LWS\n   or\
    \ special characters. These special characters MUST be in a quoted\n   string\
    \ to be used within a parameter value.\n          token          = 1*<any CHAR\
    \ except CTLs or tspecials>\n          tspecials      = \"(\" | \")\" | \"<\"\
    \ | \">\" | \"@\"\n                         | \",\" | \";\" | \":\" | \"\\\" |\
    \ <\">\n                         | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n   \
    \                      | \"{\" | \"}\" | SP | HT\n   Comments can be included\
    \ in some HTTP header fields by surrounding\n   the comment text with parentheses.\
    \ Comments are only allowed in\n   fields containing \"comment\" as part of their\
    \ field value definition.\n   In all other fields, parentheses are considered\
    \ part of the field\n   value.\n          comment        = \"(\" *( ctext | comment\
    \ ) \")\"\n          ctext          = <any TEXT excluding \"(\" and \")\">\n \
    \  A string of text is parsed as a single word if it is quoted using\n   double-quote\
    \ marks.\n          quoted-string  = ( <\"> *(qdtext) <\"> )\n          qdtext\
    \         = <any TEXT except <\">>\n   The backslash character (\"\\\") may be\
    \ used as a single-character quoting\n   mechanism only within quoted-string and\
    \ comment constructs.\n          quoted-pair    = \"\\\" CHAR\n"
- title: 3 Protocol Parameters
  contents:
  - '3 Protocol Parameters

    '
- title: 3.1 HTTP Version
  contents:
  - "3.1 HTTP Version\n   HTTP uses a \"<major>.<minor>\" numbering scheme to indicate\
    \ versions\n   of the protocol. The protocol versioning policy is intended to\
    \ allow\n   the sender to indicate the format of a message and its capacity for\n\
    \   understanding further HTTP communication, rather than the features\n   obtained\
    \ via that communication. No change is made to the version\n   number for the\
    \ addition of message components which do not affect\n   communication behavior\
    \ or which only add to extensible field values.\n   The <minor> number is incremented\
    \ when the changes made to the\n   protocol add features which do not change the\
    \ general message parsing\n   algorithm, but which may add to the message semantics\
    \ and imply\n   additional capabilities of the sender. The <major> number is\n\
    \   incremented when the format of a message within the protocol is\n   changed.\n\
    \   The version of an HTTP message is indicated by an HTTP-Version field\n   in\
    \ the first line of the message.\n          HTTP-Version   = \"HTTP\" \"/\" 1*DIGIT\
    \ \".\" 1*DIGIT\n   Note that the major and minor numbers MUST be treated as separate\n\
    \   integers and that each may be incremented higher than a single digit.\n  \
    \ Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is\n   lower\
    \ than HTTP/12.3. Leading zeros MUST be ignored by recipients and\n   MUST NOT\
    \ be sent.\n   Applications sending Request or Response messages, as defined by\
    \ this\n   specification, MUST include an HTTP-Version of \"HTTP/1.1\". Use of\n\
    \   this version number indicates that the sending application is at\n   least\
    \ conditionally compliant with this specification.\n   The HTTP version of an\
    \ application is the highest HTTP version for\n   which the application is at\
    \ least conditionally compliant.\n   Proxy and gateway applications must be careful\
    \ when forwarding\n   messages in protocol versions different from that of the\
    \ application.\n   Since the protocol version indicates the protocol capability\
    \ of the\n   sender, a proxy/gateway MUST never send a message with a version\n\
    \   indicator which is greater than its actual version; if a higher\n   version\
    \ request is received, the proxy/gateway MUST either downgrade\n   the request\
    \ version, respond with an error, or switch to tunnel\n   behavior. Requests with\
    \ a version lower than that of the\n   proxy/gateway's version MAY be upgraded\
    \ before being forwarded; the\n   proxy/gateway's response to that request MUST\
    \ be in the same major\n   version as the request.\n     Note: Converting between\
    \ versions of HTTP may involve modification\n     of header fields required or\
    \ forbidden by the versions involved.\n"
- title: 3.2 Uniform Resource Identifiers
  contents:
  - "3.2 Uniform Resource Identifiers\n   URIs have been known by many names: WWW\
    \ addresses, Universal Document\n   Identifiers, Universal Resource Identifiers\
    \ , and finally the\n   combination of Uniform Resource Locators (URL)  and Names\
    \ (URN). As\n   far as HTTP is concerned, Uniform Resource Identifiers are simply\n\
    \   formatted strings which identify--via name, location, or any other\n   characteristic--a\
    \ resource.\n"
- title: 3.2.1 General Syntax
  contents:
  - "3.2.1 General Syntax\n   URIs in HTTP can be represented in absolute form or\
    \ relative to some\n   known base URI, depending upon the context of their use.\
    \ The two\n   forms are differentiated by the fact that absolute URIs always begin\n\
    \   with a scheme name followed by a colon.\n          URI            = ( absoluteURI\
    \ | relativeURI ) [ \"#\" fragment ]\n          absoluteURI    = scheme \":\"\
    \ *( uchar | reserved )\n          relativeURI    = net_path | abs_path | rel_path\n\
    \          net_path       = \"//\" net_loc [ abs_path ]\n          abs_path  \
    \     = \"/\" rel_path\n          rel_path       = [ path ] [ \";\" params ] [\
    \ \"?\" query ]\n          path           = fsegment *( \"/\" segment )\n    \
    \      fsegment       = 1*pchar\n          segment        = *pchar\n         \
    \ params         = param *( \";\" param )\n          param          = *( pchar\
    \ | \"/\" )\n          scheme         = 1*( ALPHA | DIGIT | \"+\" | \"-\" | \"\
    .\" )\n          net_loc        = *( pchar | \";\" | \"?\" )\n          query\
    \          = *( uchar | reserved )\n          fragment       = *( uchar | reserved\
    \ )\n          pchar          = uchar | \":\" | \"@\" | \"&\" | \"=\" | \"+\"\n\
    \          uchar          = unreserved | escape\n          unreserved     = ALPHA\
    \ | DIGIT | safe | extra | national\n          escape         = \"%\" HEX HEX\n\
    \          reserved       = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"\
    =\" | \"+\"\n          extra          = \"!\" | \"*\" | \"'\" | \"(\" | \")\"\
    \ | \",\"\n          safe           = \"$\" | \"-\" | \"_\" | \".\"\n        \
    \  unsafe         = CTL | SP | <\"> | \"#\" | \"%\" | \"<\" | \">\"\n        \
    \  national       = <any OCTET excluding ALPHA, DIGIT,\n                     \
    \      reserved, extra, safe, and unsafe>\n   For definitive information on URL\
    \ syntax and semantics, see RFC 1738\n   [4] and RFC 1808 [11]. The BNF above\
    \ includes national characters not\n   allowed in valid URLs as specified by RFC\
    \ 1738, since HTTP servers\n   are not restricted in the set of unreserved characters\
    \ allowed to\n   represent the rel_path part of addresses, and HTTP proxies may\n\
    \   receive requests for URIs not defined by RFC 1738.\n   The HTTP protocol does\
    \ not place any a priori limit on the length of\n   a URI. Servers MUST be able\
    \ to handle the URI of any resource they\n   serve, and SHOULD be able to handle\
    \ URIs of unbounded length if they\n   provide GET-based forms that could generate\
    \ such URIs. A server\n   SHOULD return 414 (Request-URI Too Long) status if a\
    \ URI is longer\n   than the server can handle (see section 10.4.15).\n     Note:\
    \ Servers should be cautious about depending on URI lengths\n     above 255 bytes,\
    \ because some older client or proxy implementations\n     may not properly support\
    \ these lengths.\n"
- title: 3.2.2 http URL
  contents:
  - "3.2.2 http URL\n   The \"http\" scheme is used to locate network resources via\
    \ the HTTP\n   protocol. This section defines the scheme-specific syntax and\n\
    \   semantics for http URLs.\n          http_URL       = \"http:\" \"//\" host\
    \ [ \":\" port ] [ abs_path ]\n          host           = <A legal Internet host\
    \ domain name\n                            or IP address (in dotted-decimal form),\n\
    \                            as defined by Section 2.1 of RFC 1123>\n        \
    \  port           = *DIGIT\n   If the port is empty or not given, port 80 is assumed.\
    \ The semantics\n   are that the identified resource is located at the server\
    \ listening\n   for TCP connections on that port of that host, and the Request-URI\n\
    \   for the resource is abs_path. The use of IP addresses in URL's SHOULD\n  \
    \ be avoided whenever possible (see RFC 1900 [24]). If the abs_path is\n   not\
    \ present in the URL, it MUST be given as \"/\" when used as a\n   Request-URI\
    \ for a resource (section 5.1.2).\n"
- title: 3.2.3 URI Comparison
  contents:
  - "3.2.3 URI Comparison\n   When comparing two URIs to decide if they match or not,\
    \ a client\n   SHOULD use a case-sensitive octet-by-octet comparison of the entire\n\
    \   URIs, with these exceptions:\n     o  A port that is empty or not given is\
    \ equivalent to the default\n        port for that URI;\n     o  Comparisons of\
    \ host names MUST be case-insensitive;\n     o  Comparisons of scheme names MUST\
    \ be case-insensitive;\n     o  An empty abs_path is equivalent to an abs_path\
    \ of \"/\".\n   Characters other than those in the \"reserved\" and \"unsafe\"\
    \ sets (see\n   section 3.2) are equivalent to their \"\"%\" HEX HEX\" encodings.\n\
    \   For example, the following three URIs are equivalent:\n         http://abc.com:80/~smith/home.html\n\
    \         http://ABC.com/%7Esmith/home.html\n         http://ABC.com:/%7esmith/home.html\n"
- title: 3.3 Date/Time Formats
  contents:
  - '3.3 Date/Time Formats

    '
- title: 3.3.1 Full Date
  contents:
  - "3.3.1 Full Date\n   HTTP applications have historically allowed three different\
    \ formats\n   for the representation of date/time stamps:\n          Sun, 06 Nov\
    \ 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123\n          Sunday, 06-Nov-94\
    \ 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036\n          Sun Nov  6 08:49:37\
    \ 1994       ; ANSI C's asctime() format\n   The first format is preferred as\
    \ an Internet standard and represents\n   a fixed-length subset of that defined\
    \ by RFC 1123  (an update to RFC\n   822).  The second format is in common use,\
    \ but is based on the\n   obsolete RFC 850 [12] date format and lacks a four-digit\
    \ year.\n   HTTP/1.1 clients and servers that parse the date value MUST accept\n\
    \   all three formats (for compatibility with HTTP/1.0), though they MUST\n  \
    \ only generate the RFC 1123 format for representing HTTP-date values\n   in header\
    \ fields.\n     Note: Recipients of date values are encouraged to be robust in\n\
    \     accepting date values that may have been sent by non-HTTP\n     applications,\
    \ as is sometimes the case when retrieving or posting\n     messages via proxies/gateways\
    \ to SMTP or NNTP.\n   All HTTP date/time stamps MUST be represented in Greenwich\
    \ Mean Time\n   (GMT), without exception. This is indicated in the first two formats\n\
    \   by the inclusion of \"GMT\" as the three-letter abbreviation for time\n  \
    \ zone, and MUST be assumed when reading the asctime format.\n          HTTP-date\
    \    = rfc1123-date | rfc850-date | asctime-date\n          rfc1123-date = wkday\
    \ \",\" SP date1 SP time SP \"GMT\"\n          rfc850-date  = weekday \",\" SP\
    \ date2 SP time SP \"GMT\"\n          asctime-date = wkday SP date3 SP time SP\
    \ 4DIGIT\n          date1        = 2DIGIT SP month SP 4DIGIT\n               \
    \          ; day month year (e.g., 02 Jun 1982)\n          date2        = 2DIGIT\
    \ \"-\" month \"-\" 2DIGIT\n                         ; day-month-year (e.g., 02-Jun-82)\n\
    \          date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n               \
    \          ; month day (e.g., Jun  2)\n          time         = 2DIGIT \":\" 2DIGIT\
    \ \":\" 2DIGIT\n                         ; 00:00:00 - 23:59:59\n          wkday\
    \        = \"Mon\" | \"Tue\" | \"Wed\"\n                       | \"Thu\" | \"\
    Fri\" | \"Sat\" | \"Sun\"\n          weekday      = \"Monday\" | \"Tuesday\" |\
    \ \"Wednesday\"\n                       | \"Thursday\" | \"Friday\" | \"Saturday\"\
    \ | \"Sunday\"\n          month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\
    \n                       | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n           \
    \            | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n     Note: HTTP requirements\
    \ for the date/time stamp format apply only\n     to their usage within the protocol\
    \ stream. Clients and servers are\n     not required to use these formats for\
    \ user presentation, request\n     logging, etc.\n"
- title: 3.3.2 Delta Seconds
  contents:
  - "3.3.2 Delta Seconds\n   Some HTTP header fields allow a time value to be specified\
    \ as an\n   integer number of seconds, represented in decimal, after the time\n\
    \   that the message was received.\n          delta-seconds  = 1*DIGIT\n"
- title: 3.4 Character Sets
  contents:
  - "3.4 Character Sets\n   HTTP uses the same definition of the term \"character\
    \ set\" as that\n   described for MIME:\n     The term \"character set\" is used\
    \ in this document to refer to a\n     method used with one or more tables to\
    \ convert a sequence of octets\n     into a sequence of characters. Note that\
    \ unconditional conversion\n     in the other direction is not required, in that\
    \ not all characters\n     may be available in a given character set and a character\
    \ set may\n     provide more than one sequence of octets to represent a particular\n\
    \     character. This definition is intended to allow various kinds of\n     character\
    \ encodings, from simple single-table mappings such as US-\n     ASCII to complex\
    \ table switching methods such as those that use ISO\n     2022's techniques.\
    \ However, the definition associated with a MIME\n     character set name MUST\
    \ fully specify the mapping to be performed\n     from octets to characters. In\
    \ particular, use of external profiling\n     information to determine the exact\
    \ mapping is not permitted.\n     Note: This use of the term \"character set\"\
    \ is more commonly\n     referred to as a \"character encoding.\" However, since\
    \ HTTP and MIME\n     share the same registry, it is important that the terminology\
    \ also\n     be shared.\n   HTTP character sets are identified by case-insensitive\
    \ tokens. The\n   complete set of tokens is defined by the IANA Character Set\
    \ registry\n   [19].\n          charset = token\n   Although HTTP allows an arbitrary\
    \ token to be used as a charset\n   value, any token that has a predefined value\
    \ within the IANA\n   Character Set registry MUST represent the character set\
    \ defined by\n   that registry.  Applications SHOULD limit their use of character\
    \ sets\n   to those defined by the IANA registry.\n"
- title: 3.5 Content Codings
  contents:
  - "3.5 Content Codings\n   Content coding values indicate an encoding transformation\
    \ that has\n   been or can be applied to an entity. Content codings are primarily\n\
    \   used to allow a document to be compressed or otherwise usefully\n   transformed\
    \ without losing the identity of its underlying media type\n   and without loss\
    \ of information. Frequently, the entity is stored in\n   coded form, transmitted\
    \ directly, and only decoded by the recipient.\n          content-coding   = token\n\
    \   All content-coding values are case-insensitive. HTTP/1.1 uses\n   content-coding\
    \ values in the Accept-Encoding (section 14.3) and\n   Content-Encoding (section\
    \ 14.12) header fields. Although the value\n   describes the content-coding, what\
    \ is more important is that it\n   indicates what decoding mechanism will be required\
    \ to remove the\n   encoding.\n   The Internet Assigned Numbers Authority (IANA)\
    \ acts as a registry for\n   content-coding value tokens. Initially, the registry\
    \ contains the\n   following tokens:\n   gzip An encoding format produced by the\
    \ file compression program \"gzip\"\n        (GNU zip) as described in RFC 1952\
    \ [25]. This format is a Lempel-\n        Ziv coding (LZ77) with a 32 bit CRC.\n\
    \   compress\n        The encoding format produced by the common UNIX file compression\n\
    \        program \"compress\". This format is an adaptive Lempel-Ziv-Welch\n \
    \       coding (LZW).\n     Note: Use of program names for the identification\
    \ of encoding\n     formats is not desirable and should be discouraged for future\n\
    \     encodings. Their use here is representative of historical practice,\n  \
    \   not good design. For compatibility with previous implementations of\n    \
    \ HTTP, applications should consider \"x-gzip\" and \"x-compress\" to be\n   \
    \  equivalent to \"gzip\" and \"compress\" respectively.\n   deflate The \"zlib\"\
    \ format defined in RFC 1950[31] in combination with\n        the \"deflate\"\
    \ compression mechanism described in RFC 1951[29].\n   New content-coding value\
    \ tokens should be registered; to allow\n   interoperability between clients and\
    \ servers, specifications of the\n   content coding algorithms needed to implement\
    \ a new value should be\n   publicly available and adequate for independent implementation,\
    \ and\n   conform to the purpose of content coding defined in this section.\n"
- title: 3.6 Transfer Codings
  contents:
  - "3.6 Transfer Codings\n   Transfer coding values are used to indicate an encoding\n\
    \   transformation that has been, can be, or may need to be applied to an\n  \
    \ entity-body in order to ensure \"safe transport\" through the network.\n   This\
    \ differs from a content coding in that the transfer coding is a\n   property\
    \ of the message, not of the original entity.\n          transfer-coding     \
    \    = \"chunked\" | transfer-extension\n          transfer-extension      = token\n\
    \   All transfer-coding values are case-insensitive. HTTP/1.1 uses\n   transfer\
    \ coding values in the Transfer-Encoding header field (section\n   14.40).\n \
    \  Transfer codings are analogous to the Content-Transfer-Encoding\n   values\
    \ of MIME , which were designed to enable safe transport of\n   binary data over\
    \ a 7-bit transport service. However, safe transport\n   has a different focus\
    \ for an 8bit-clean transfer protocol. In HTTP,\n   the only unsafe characteristic\
    \ of message-bodies is the difficulty in\n   determining the exact body length\
    \ (section 7.2.2), or the desire to\n   encrypt data over a shared transport.\n\
    \   The chunked encoding modifies the body of a message in order to\n   transfer\
    \ it as a series of chunks, each with its own size indicator,\n   followed by\
    \ an optional footer containing entity-header fields. This\n   allows dynamically-produced\
    \ content to be transferred along with the\n   information necessary for the recipient\
    \ to verify that it has\n   received the full message.\n       Chunked-Body  \
    \ = *chunk\n                        \"0\" CRLF\n                        footer\n\
    \                        CRLF\n       chunk          = chunk-size [ chunk-ext\
    \ ] CRLF\n                        chunk-data CRLF\n       hex-no-zero    = <HEX\
    \ excluding \"0\">\n       chunk-size     = hex-no-zero *HEX\n       chunk-ext\
    \      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-value ] )\n       chunk-ext-name\
    \ = token\n       chunk-ext-val  = token | quoted-string\n       chunk-data  \
    \   = chunk-size(OCTET)\n       footer         = *entity-header\n   The chunked\
    \ encoding is ended by a zero-sized chunk followed by the\n   footer, which is\
    \ terminated by an empty line. The purpose of the\n   footer is to provide an\
    \ efficient way to supply information about an\n   entity that is generated dynamically;\
    \ applications MUST NOT send\n   header fields in the footer which are not explicitly\
    \ defined as being\n   appropriate for the footer, such as Content-MD5 or future\
    \ extensions\n   to HTTP for digital signatures or other facilities.\n   An example\
    \ process for decoding a Chunked-Body is presented in\n   appendix 19.4.6.\n \
    \  All HTTP/1.1 applications MUST be able to receive and decode the\n   \"chunked\"\
    \ transfer coding, and MUST ignore transfer coding extensions\n   they do not\
    \ understand. A server which receives an entity-body with a\n   transfer-coding\
    \ it does not understand SHOULD return 501\n   (Unimplemented), and close the\
    \ connection. A server MUST NOT send\n   transfer-codings to an HTTP/1.0 client.\n"
- title: 3.7 Media Types
  contents:
  - "3.7 Media Types\n   HTTP uses Internet Media Types  in the Content-Type (section\
    \ 14.18)\n   and Accept (section 14.1) header fields in order to provide open\
    \ and\n   extensible data typing and type negotiation.\n          media-type \
    \    = type \"/\" subtype *( \";\" parameter )\n          type           = token\n\
    \          subtype        = token\n   Parameters may follow the type/subtype in\
    \ the form of attribute/value\n   pairs.\n          parameter      = attribute\
    \ \"=\" value\n          attribute      = token\n          value          = token\
    \ | quoted-string\n   The type, subtype, and parameter attribute names are case-\n\
    \   insensitive.  Parameter values may or may not be case-sensitive,\n   depending\
    \ on the semantics of the parameter name. Linear white space\n   (LWS) MUST NOT\
    \ be used between the type and subtype, nor between an\n   attribute and its value.\
    \ User agents that recognize the media-type\n   MUST process (or arrange to be\
    \ processed by any external applications\n   used to process that type/subtype\
    \ by the user agent) the parameters\n   for that MIME type as described by that\
    \ type/subtype definition to\n   the and inform the user of any problems discovered.\n\
    \     Note: some older HTTP applications do not recognize media type\n     parameters.\
    \ When sending data to older HTTP applications,\n     implementations should only\
    \ use media type parameters when they are\n     required by that type/subtype\
    \ definition.\n   Media-type values are registered with the Internet Assigned\
    \ Number\n   Authority (IANA). The media type registration process is outlined\
    \ in\n   RFC 2048 [17]. Use of non-registered media types is discouraged.\n"
- title: 3.7.1 Canonicalization and Text Defaults
  contents:
  - "3.7.1 Canonicalization and Text Defaults\n   Internet media types are registered\
    \ with a canonical form. In\n   general, an entity-body transferred via HTTP messages\
    \ MUST be\n   represented in the appropriate canonical form prior to its\n   transmission;\
    \ the exception is \"text\" types, as defined in the next\n   paragraph.\n   When\
    \ in canonical form, media subtypes of the \"text\" type use CRLF as\n   the text\
    \ line break. HTTP relaxes this requirement and allows the\n   transport of text\
    \ media with plain CR or LF alone representing a line\n   break when it is done\
    \ consistently for an entire entity-body. HTTP\n   applications MUST accept CRLF,\
    \ bare CR, and bare LF as being\n   representative of a line break in text media\
    \ received via HTTP. In\n   addition, if the text is represented in a character\
    \ set that does not\n   use octets 13 and 10 for CR and LF respectively, as is\
    \ the case for\n   some multi-byte character sets, HTTP allows the use of whatever\
    \ octet\n   sequences are defined by that character set to represent the\n   equivalent\
    \ of CR and LF for line breaks. This flexibility regarding\n   line breaks applies\
    \ only to text media in the entity-body; a bare CR\n   or LF MUST NOT be substituted\
    \ for CRLF within any of the HTTP control\n   structures (such as header fields\
    \ and multipart boundaries).\n   If an entity-body is encoded with a Content-Encoding,\
    \ the underlying\n   data MUST be in a form defined above prior to being encoded.\n\
    \   The \"charset\" parameter is used with some media types to define the\n  \
    \ character set (section 3.4) of the data. When no explicit charset\n   parameter\
    \ is provided by the sender, media subtypes of the \"text\"\n   type are defined\
    \ to have a default charset value of \"ISO-8859-1\" when\n   received via HTTP.\
    \ Data in character sets other than \"ISO-8859-1\" or\n   its subsets MUST be\
    \ labeled with an appropriate charset value.\n   Some HTTP/1.0 software has interpreted\
    \ a Content-Type header without\n   charset parameter incorrectly to mean \"recipient\
    \ should guess.\"\n   Senders wishing to defeat this behavior MAY include a charset\n\
    \   parameter even when the charset is ISO-8859-1 and SHOULD do so when\n   it\
    \ is known that it will not confuse the recipient.\n   Unfortunately, some older\
    \ HTTP/1.0 clients did not deal properly with\n   an explicit charset parameter.\
    \ HTTP/1.1 recipients MUST respect the\n   charset label provided by the sender;\
    \ and those user agents that have\n   a provision to \"guess\" a charset MUST\
    \ use the charset from the\n   content-type field if they support that charset,\
    \ rather than the\n   recipient's preference, when initially displaying a document.\n"
- title: 3.7.2 Multipart Types
  contents:
  - "3.7.2 Multipart Types\n   MIME provides for a number of \"multipart\" types --\
    \ encapsulations of\n   one or more entities within a single message-body. All\
    \ multipart\n   types share a common syntax, as defined in  MIME [7], and MUST\n\
    \   include a boundary parameter as part of the media type value. The\n   message\
    \ body is itself a protocol element and MUST therefore use only\n   CRLF to represent\
    \ line breaks between body-parts. Unlike in MIME, the\n   epilogue of any multipart\
    \ message MUST be empty; HTTP applications\n   MUST NOT transmit the epilogue\
    \ (even if the original multipart\n   contains an epilogue).\n   In HTTP, multipart\
    \ body-parts MAY contain header fields which are\n   significant to the meaning\
    \ of that part. A Content-Location header\n   field (section 14.15) SHOULD be\
    \ included in the body-part of each\n   enclosed entity that can be identified\
    \ by a URL.\n   In general, an HTTP user agent SHOULD follow the same or similar\n\
    \   behavior as a MIME user agent would upon receipt of a multipart type.\n  \
    \ If an application receives an unrecognized multipart subtype, the\n   application\
    \ MUST treat it as being equivalent to \"multipart/mixed\".\n     Note: The \"\
    multipart/form-data\" type has been specifically defined\n     for carrying form\
    \ data suitable for processing via the POST request\n     method, as described\
    \ in RFC 1867 [15].\n"
- title: 3.8 Product Tokens
  contents:
  - "3.8 Product Tokens\n   Product tokens are used to allow communicating applications\
    \ to\n   identify themselves by software name and version. Most fields using\n\
    \   product tokens also allow sub-products which form a significant part\n   of\
    \ the application to be listed, separated by whitespace. By\n   convention, the\
    \ products are listed in order of their significance\n   for identifying the application.\n\
    \          product         = token [\"/\" product-version]\n          product-version\
    \ = token\n   Examples:\n          User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\
    \          Server: Apache/0.8.4\n   Product tokens should be short and to the\
    \ point -- use of them for\n   advertising or other non-essential information\
    \ is explicitly\n   forbidden.  Although any token character may appear in a product-\n\
    \   version, this token SHOULD only be used for a version identifier\n   (i.e.,\
    \ successive versions of the same product SHOULD only differ in\n   the product-version\
    \ portion of the product value).\n"
- title: 3.9 Quality Values
  contents:
  - "3.9 Quality Values\n   HTTP content negotiation (section 12) uses short \"floating\
    \ point\"\n   numbers to indicate the relative importance (\"weight\") of various\n\
    \   negotiable parameters. A weight is normalized to a real number in the\n  \
    \ range 0 through 1, where 0 is the minimum and 1 the maximum value.\n   HTTP/1.1\
    \ applications MUST NOT generate more than three digits after\n   the decimal\
    \ point. User configuration of these values SHOULD also be\n   limited in this\
    \ fashion.\n          qvalue         = ( \"0\" [ \".\" 0*3DIGIT ] )\n        \
    \                 | ( \"1\" [ \".\" 0*3(\"0\") ] )\n   \"Quality values\" is a\
    \ misnomer, since these values merely represent\n   relative degradation in desired\
    \ quality.\n"
- title: 3.10 Language Tags
  contents:
  - "3.10 Language Tags\n   A language tag identifies a natural language spoken, written,\
    \ or\n   otherwise conveyed by human beings for communication of information\n\
    \   to other human beings. Computer languages are explicitly excluded.\n   HTTP\
    \ uses language tags within the Accept-Language and Content-\n   Language fields.\n\
    \   The syntax and registry of HTTP language tags is the same as that\n   defined\
    \ by RFC 1766 [1]. In summary, a language tag is composed of 1\n   or more parts:\
    \ A primary language tag and a possibly empty series of\n   subtags:\n       \
    \    language-tag  = primary-tag *( \"-\" subtag )\n           primary-tag   =\
    \ 1*8ALPHA\n           subtag        = 1*8ALPHA\n   Whitespace is not allowed\
    \ within the tag and all tags are case-\n   insensitive. The name space of language\
    \ tags is administered by the\n   IANA. Example tags include:\n          en, en-US,\
    \ en-cockney, i-cherokee, x-pig-latin\n   where any two-letter primary-tag is\
    \ an ISO 639 language abbreviation\n   and any two-letter initial subtag is an\
    \ ISO 3166 country code. (The\n   last three tags above are not registered tags;\
    \ all but the last are\n   examples of tags which could be registered in future.)\n"
- title: 3.11 Entity Tags
  contents:
  - "3.11 Entity Tags\n   Entity tags are used for comparing two or more entities\
    \ from the same\n   requested resource. HTTP/1.1 uses entity tags in the ETag\
    \ (section\n   14.20), If-Match (section 14.25), If-None-Match (section 14.26),\
    \ and\n   If-Range (section 14.27) header fields. The definition of how they\n\
    \   are used and compared as cache validators is in section 13.3.3. An\n   entity\
    \ tag consists of an opaque quoted string, possibly prefixed by\n   a weakness\
    \ indicator.\n         entity-tag = [ weak ] opaque-tag\n         weak       =\
    \ \"W/\"\n         opaque-tag = quoted-string\n   A \"strong entity tag\" may\
    \ be shared by two entities of a resource\n   only if they are equivalent by octet\
    \ equality.\n   A \"weak entity tag,\" indicated by the \"W/\" prefix, may be\
    \ shared by\n   two entities of a resource only if the entities are equivalent\
    \ and\n   could be substituted for each other with no significant change in\n\
    \   semantics. A weak entity tag can only be used for weak comparison.\n   An\
    \ entity tag MUST be unique across all versions of all entities\n   associated\
    \ with a particular resource. A given entity tag value may\n   be used for entities\
    \ obtained by requests on different URIs without\n   implying anything about the\
    \ equivalence of those entities.\n"
- title: 3.12 Range Units
  contents:
  - "3.12 Range Units\n   HTTP/1.1 allows a client to request that only part (a range\
    \ of) the\n   response entity be included within the response. HTTP/1.1 uses range\n\
    \   units in the Range (section 14.36) and Content-Range (section 14.17)\n   header\
    \ fields. An entity may be broken down into subranges according\n   to various\
    \ structural units.\n         range-unit       = bytes-unit | other-range-unit\n\
    \         bytes-unit       = \"bytes\"\n         other-range-unit = token\n"
- title: The only range unit defined by HTTP/1.1 is "bytes". HTTP/1.1
  contents:
  - "The only range unit defined by HTTP/1.1 is \"bytes\". HTTP/1.1\n   implementations\
    \ may ignore ranges specified using other units.\n   HTTP/1.1 has been designed\
    \ to allow implementations of applications\n   that do not depend on knowledge\
    \ of ranges.\n"
- title: 4 HTTP Message
  contents:
  - '4 HTTP Message

    '
- title: 4.1 Message Types
  contents:
  - "4.1 Message Types\n   HTTP messages consist of requests from client to server\
    \ and responses\n   from server to client.\n          HTTP-message   = Request\
    \ | Response     ; HTTP/1.1 messages\n   Request (section 5) and Response (section\
    \ 6) messages use the generic\n   message format of RFC 822 [9] for transferring\
    \ entities (the payload\n   of the message). Both types of message consist of\
    \ a start-line, one\n   or more header fields (also known as \"headers\"), an\
    \ empty line (i.e.,\n   a line with nothing preceding the CRLF) indicating the\
    \ end of the\n   header fields, and an optional message-body.\n           generic-message\
    \ = start-line\n                             *message-header\n               \
    \              CRLF\n                             [ message-body ]\n         \
    \  start-line      = Request-Line | Status-Line\n   In the interest of robustness,\
    \ servers SHOULD ignore any empty\n   line(s) received where a Request-Line is\
    \ expected. In other words, if\n   the server is reading the protocol stream at\
    \ the beginning of a\n   message and receives a CRLF first, it should ignore the\
    \ CRLF.\n     Note: certain buggy HTTP/1.0 client implementations generate an\n\
    \     extra CRLF's after a POST request. To restate what is explicitly\n     forbidden\
    \ by the BNF, an HTTP/1.1 client must not preface or follow\n     a request with\
    \ an extra CRLF.\n"
- title: 4.2 Message Headers
  contents:
  - "4.2 Message Headers\n   HTTP header fields, which include general-header (section\
    \ 4.5),\n   request-header (section 5.3), response-header (section 6.2), and\n\
    \   entity-header (section 7.1) fields, follow the same generic format as\n  \
    \ that given in Section 3.1 of RFC 822 [9]. Each header field consists\n   of\
    \ a name followed by a colon (\":\") and the field value. Field names\n   are\
    \ case-insensitive. The field value may be preceded by any amount\n   of LWS,\
    \ though a single SP is preferred. Header fields can be\n   extended over multiple\
    \ lines by preceding each extra line with at\n   least one SP or HT.  Applications\
    \ SHOULD follow \"common form\" when\n   generating HTTP constructs, since there\
    \ might exist some\n   implementations that fail to accept anything beyond the\
    \ common forms.\n          message-header = field-name \":\" [ field-value ] CRLF\n\
    \          field-name     = token\n          field-value    = *( field-content\
    \ | LWS )\n          field-content  = <the OCTETs making up the field-value\n\
    \                           and consisting of either *TEXT or combinations\n \
    \                          of token, tspecials, and quoted-string>\n   The order\
    \ in which header fields with differing field names are\n   received is not significant.\
    \ However, it is \"good practice\" to send\n   general-header fields first, followed\
    \ by request-header or response-\n   header fields, and ending with the entity-header\
    \ fields.\n   Multiple message-header fields with the same field-name may be\n\
    \   present in a message if and only if the entire field-value for that\n   header\
    \ field is defined as a comma-separated list [i.e., #(values)].\n   It MUST be\
    \ possible to combine the multiple header fields into one\n   \"field-name: field-value\"\
    \ pair, without changing the semantics of the\n   message, by appending each subsequent\
    \ field-value to the first, each\n   separated by a comma. The order in which\
    \ header fields with the same\n   field-name are received is therefore significant\
    \ to the\n   interpretation of the combined field value, and thus a proxy MUST\
    \ NOT\n   change the order of these field values when a message is forwarded.\n"
- title: 4.3 Message Body
  contents:
  - "4.3 Message Body\n   The message-body (if any) of an HTTP message is used to\
    \ carry the\n   entity-body associated with the request or response. The message-body\n\
    \   differs from the entity-body only when a transfer coding has been\n   applied,\
    \ as indicated by the Transfer-Encoding header field (section\n   14.40).\n  \
    \        message-body = entity-body\n                       | <entity-body encoded\
    \ as per Transfer-Encoding>\n   Transfer-Encoding MUST be used to indicate any\
    \ transfer codings\n   applied by an application to ensure safe and proper transfer\
    \ of the\n   message.  Transfer-Encoding is a property of the message, not of\
    \ the\n   entity, and thus can be added or removed by any application along the\n\
    \   request/response chain.\n   The rules for when a message-body is allowed in\
    \ a message differ for\n   requests and responses.\n   The presence of a message-body\
    \ in a request is signaled by the\n   inclusion of a Content-Length or Transfer-Encoding\
    \ header field in\n   the request's message-headers. A message-body MAY be included\
    \ in a\n   request only when the request method (section 5.1.1) allows an\n  \
    \ entity-body.\n   For response messages, whether or not a message-body is included\
    \ with\n   a message is dependent on both the request method and the response\n\
    \   status code (section 6.1.1). All responses to the HEAD request method\n  \
    \ MUST NOT include a message-body, even though the presence of entity-\n   header\
    \ fields might lead one to believe they do. All 1xx\n   (informational), 204 (no\
    \ content), and 304 (not modified) responses\n   MUST NOT include a message-body.\
    \ All other responses do include a\n   message-body, although it may be of zero\
    \ length.\n"
- title: 4.4 Message Length
  contents:
  - "4.4 Message Length\n   When a message-body is included with a message, the length\
    \ of that\n   body is determined by one of the following (in order of precedence):\n\
    \   1. Any response message which MUST NOT include a message-body\n     (such\
    \ as the 1xx, 204, and 304 responses and any response to a HEAD\n     request)\
    \ is always terminated by the first empty line after the\n     header fields,\
    \ regardless of the entity-header fields present in the\n     message.\n   2.\
    \ If a Transfer-Encoding header field (section 14.40) is present and\n     indicates\
    \ that the \"chunked\" transfer coding has been applied, then\n     the length\
    \ is defined by the chunked encoding (section 3.6).\n   3. If a Content-Length\
    \ header field (section 14.14) is present, its\n     value in bytes represents\
    \ the length of the message-body.\n   4. If the message uses the media type \"\
    multipart/byteranges\", which is\n     self-delimiting, then that defines the\
    \ length. This media type MUST\n     NOT be used unless the sender knows that\
    \ the recipient can parse it;\n     the presence in a request of a Range header\
    \ with multiple byte-range\n     specifiers implies that the client can parse\
    \ multipart/byteranges\n     responses.\n   5. By the server closing the connection.\
    \ (Closing the connection\n     cannot be used to indicate the end of a request\
    \ body, since that\n     would leave no possibility for the server to send back\
    \ a response.)\n   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests\n\
    \   containing a message-body MUST include a valid Content-Length header\n   field\
    \ unless the server is known to be HTTP/1.1 compliant. If a\n   request contains\
    \ a message-body and a Content-Length is not given,\n   the server SHOULD respond\
    \ with 400 (bad request) if it cannot\n   determine the length of the message,\
    \ or with 411 (length required) if\n   it wishes to insist on receiving a valid\
    \ Content-Length.\n   All HTTP/1.1 applications that receive entities MUST accept\
    \ the\n   \"chunked\" transfer coding (section 3.6), thus allowing this mechanism\n\
    \   to be used for messages when the message length cannot be determined\n   in\
    \ advance.\n   Messages MUST NOT include both a Content-Length header field and\
    \ the\n   \"chunked\" transfer coding. If both are received, the Content-Length\n\
    \   MUST be ignored.\n   When a Content-Length is given in a message where a message-body\
    \ is\n   allowed, its field value MUST exactly match the number of OCTETs in\n\
    \   the message-body. HTTP/1.1 user agents MUST notify the user when an\n   invalid\
    \ length is received and detected.\n"
- title: 4.5 General Header Fields
  contents:
  - "4.5 General Header Fields\n   There are a few header fields which have general\
    \ applicability for\n   both request and response messages, but which do not apply\
    \ to the\n   entity being transferred. These header fields apply only to the\n\
    \   message being transmitted.\n          general-header = Cache-Control     \
    \       ; Section 14.9\n                         | Connection               ;\
    \ Section 14.10\n                         | Date                     ; Section\
    \ 14.19\n                         | Pragma                   ; Section 14.32\n\
    \                         | Transfer-Encoding        ; Section 14.40\n       \
    \                  | Upgrade                  ; Section 14.41\n              \
    \           | Via                      ; Section 14.44\n   General-header field\
    \ names can be extended reliably only in\n   combination with a change in the\
    \ protocol version. However, new or\n   experimental header fields may be given\
    \ the semantics of general\n   header fields if all parties in the communication\
    \ recognize them to\n   be general-header fields.  Unrecognized header fields\
    \ are treated as\n   entity-header fields.\n"
- title: 5 Request
  contents:
  - "5 Request\n   A request message from a client to a server includes, within the\n\
    \   first line of that message, the method to be applied to the resource,\n  \
    \ the identifier of the resource, and the protocol version in use.\n         \
    \  Request       = Request-Line              ; Section 5.1\n                 \
    \          *( general-header         ; Section 4.5\n                         \
    \   | request-header         ; Section 5.3\n                            | entity-header\
    \ )        ; Section 7.1\n                           CRLF\n                  \
    \         [ message-body ]          ; Section 7.2\n"
- title: 5.1 Request-Line
  contents:
  - "5.1 Request-Line\n   The Request-Line begins with a method token, followed by\
    \ the\n   Request-URI and the protocol version, and ending with CRLF. The\n  \
    \ elements are separated by SP characters. No CR or LF are allowed\n   except\
    \ in the final CRLF sequence.\n          Request-Line   = Method SP Request-URI\
    \ SP HTTP-Version CRLF\n"
- title: 5.1.1 Method
  contents:
  - "5.1.1 Method\n   The Method token indicates the method to be performed on the\
    \ resource\n   identified by the Request-URI. The method is case-sensitive.\n\
    \          Method         = \"OPTIONS\"                ; Section 9.2\n       \
    \                  | \"GET\"                    ; Section 9.3\n              \
    \           | \"HEAD\"                   ; Section 9.4\n                     \
    \    | \"POST\"                   ; Section 9.5\n                         | \"\
    PUT\"                    ; Section 9.6\n                         | \"DELETE\"\
    \                 ; Section 9.7\n                         | \"TRACE\"        \
    \          ; Section 9.8\n                         | extension-method\n      \
    \    extension-method = token\n   The list of methods allowed by a resource can\
    \ be specified in an\n   Allow header field (section 14.7). The return code of\
    \ the response\n   always notifies the client whether a method is currently allowed\
    \ on a\n   resource, since the set of allowed methods can change dynamically.\n\
    \   Servers SHOULD return the status code 405 (Method Not Allowed) if the\n  \
    \ method is known by the server but not allowed for the requested\n   resource,\
    \ and 501 (Not Implemented) if the method is unrecognized or\n   not implemented\
    \ by the server. The list of methods known by a server\n   can be listed in a\
    \ Public response-header field (section 14.35).\n   The methods GET and HEAD MUST\
    \ be supported by all general-purpose\n   servers. All other methods are optional;\
    \ however, if the above\n   methods are implemented, they MUST be implemented\
    \ with the same\n   semantics as those specified in section 9.\n"
- title: 5.1.2 Request-URI
  contents:
  - "5.1.2 Request-URI\n   The Request-URI is a Uniform Resource Identifier (section\
    \ 3.2) and\n   identifies the resource upon which to apply the request.\n    \
    \      Request-URI    = \"*\" | absoluteURI | abs_path\n   The three options for\
    \ Request-URI are dependent on the nature of the\n   request. The asterisk \"\
    *\" means that the request does not apply to a\n   particular resource, but to\
    \ the server itself, and is only allowed\n   when the method used does not necessarily\
    \ apply to a resource. One\n   example would be\n          OPTIONS * HTTP/1.1\n\
    \   The absoluteURI form is required when the request is being made to a\n   proxy.\
    \ The proxy is requested to forward the request or service it\n   from a valid\
    \ cache, and return the response. Note that the proxy MAY\n   forward the request\
    \ on to another proxy or directly to the server\n   specified by the absoluteURI.\
    \ In order to avoid request loops, a\n   proxy MUST be able to recognize all of\
    \ its server names, including\n   any aliases, local variations, and the numeric\
    \ IP address. An example\n   Request-Line would be:\n          GET http://www.w3.org/pub/WWW/TheProject.html\
    \ HTTP/1.1\n   To allow for transition to absoluteURIs in all requests in future\n\
    \   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI\n   form\
    \ in requests, even though HTTP/1.1 clients will only generate\n   them in requests\
    \ to proxies.\n   The most common form of Request-URI is that used to identify\
    \ a\n   resource on an origin server or gateway. In this case the absolute\n \
    \  path of the URI MUST be transmitted (see section 3.2.1, abs_path) as\n   the\
    \ Request-URI, and the network location of the URI (net_loc) MUST\n   be transmitted\
    \ in a Host header field. For example, a client wishing\n   to retrieve the resource\
    \ above directly from the origin server would\n   create a TCP connection to port\
    \ 80 of the host \"www.w3.org\" and send\n   the lines:\n          GET /pub/WWW/TheProject.html\
    \ HTTP/1.1\n          Host: www.w3.org\n   followed by the remainder of the Request.\
    \ Note that the absolute path\n   cannot be empty; if none is present in the original\
    \ URI, it MUST be\n   given as \"/\" (the server root).\n   If a proxy receives\
    \ a request without any path in the Request-URI and\n   the method specified is\
    \ capable of supporting the asterisk form of\n   request, then the last proxy\
    \ on the request chain MUST forward the\n   request with \"*\" as the final Request-URI.\
    \ For example, the request\n          OPTIONS http://www.ics.uci.edu:8001 HTTP/1.1\n\
    \   would be forwarded by the proxy as\n          OPTIONS * HTTP/1.1\n       \
    \   Host: www.ics.uci.edu:8001\n   after connecting to port 8001 of host \"www.ics.uci.edu\"\
    .\n   The Request-URI is transmitted in the format specified in section\n   3.2.1.\
    \  The origin server MUST decode the Request-URI in order to\n   properly interpret\
    \ the request. Servers SHOULD respond to invalid\n   Request-URIs with an appropriate\
    \ status code.\n   In requests that they forward, proxies MUST NOT rewrite the\n\
    \   \"abs_path\" part of a Request-URI in any way except as noted above to\n \
    \  replace a null abs_path with \"*\", no matter what the proxy does in\n   its\
    \ internal implementation.\n     Note: The \"no rewrite\" rule prevents the proxy\
    \ from changing the\n     meaning of the request when the origin server is improperly\
    \ using a\n     non-reserved URL character for a reserved purpose. Implementers\n\
    \     should be aware that some pre-HTTP/1.1 proxies have been known to\n    \
    \ rewrite the Request-URI.\n"
- title: 5.2 The Resource Identified by a Request
  contents:
  - "5.2 The Resource Identified by a Request\n   HTTP/1.1 origin servers SHOULD be\
    \ aware that the exact resource\n   identified by an Internet request is determined\
    \ by examining both the\n   Request-URI and the Host header field.\n   An origin\
    \ server that does not allow resources to differ by the\n   requested host MAY\
    \ ignore the Host header field value. (But see\n   section 19.5.1 for other requirements\
    \ on Host support in HTTP/1.1.)\n   An origin server that does differentiate resources\
    \ based on the host\n   requested (sometimes referred to as virtual hosts or vanity\n\
    \   hostnames) MUST use the following rules for determining the requested\n  \
    \ resource on an HTTP/1.1 request:\n     1. If Request-URI is an absoluteURI,\
    \ the host is part of the\n        Request-URI. Any Host header field value in\
    \ the request MUST be\n        ignored.\n     2. If the Request-URI is not an\
    \ absoluteURI, and the request\n        includes a Host header field, the host\
    \ is determined by the Host\n        header field value.\n     3. If the host\
    \ as determined by rule 1 or 2 is not a valid host on\n        the server, the\
    \ response MUST be a 400 (Bad Request) error\n        message.\n   Recipients\
    \ of an HTTP/1.0 request that lacks a Host header field MAY\n   attempt to use\
    \ heuristics (e.g., examination of the URI path for\n   something unique to a\
    \ particular host) in order to determine what\n   exact resource is being requested.\n"
- title: 5.3 Request Header Fields
  contents:
  - "5.3 Request Header Fields\n   The request-header fields allow the client to pass\
    \ additional\n   information about the request, and about the client itself, to\
    \ the\n   server. These fields act as request modifiers, with semantics\n   equivalent\
    \ to the parameters on a programming language method\n   invocation.\n       \
    \   request-header = Accept                   ; Section 14.1\n               \
    \          | Accept-Charset           ; Section 14.2\n                       \
    \  | Accept-Encoding          ; Section 14.3\n                         | Accept-Language\
    \          ; Section 14.4\n                         | Authorization          \
    \  ; Section 14.8\n                         | From                     ; Section\
    \ 14.22\n                         | Host                     ; Section 14.23\n\
    \                         | If-Modified-Since        ; Section 14.24\n       \
    \                  | If-Match                 ; Section 14.25\n              \
    \           | If-None-Match            ; Section 14.26\n                     \
    \    | If-Range                 ; Section 14.27\n                         | If-Unmodified-Since\
    \      ; Section 14.28\n                         | Max-Forwards             ;\
    \ Section 14.31\n                         | Proxy-Authorization      ; Section\
    \ 14.34\n                         | Range                    ; Section 14.36\n\
    \                         | Referer                  ; Section 14.37\n       \
    \                  | User-Agent               ; Section 14.42\n   Request-header\
    \ field names can be extended reliably only in\n   combination with a change in\
    \ the protocol version. However, new or\n   experimental header fields MAY be\
    \ given the semantics of request-\n   header fields if all parties in the communication\
    \ recognize them to\n   be request-header fields.  Unrecognized header fields\
    \ are treated as\n   entity-header fields.\n"
- title: 6 Response
  contents:
  - "6 Response\n   After receiving and interpreting a request message, a server responds\n\
    \   with an HTTP response message.\n       Response      = Status-Line       \
    \        ; Section 6.1\n                       *( general-header         ; Section\
    \ 4.5\n                        | response-header        ; Section 6.2\n      \
    \                  | entity-header )        ; Section 7.1\n                  \
    \     CRLF\n                       [ message-body ]          ; Section 7.2\n"
- title: 6.1 Status-Line
  contents:
  - "6.1 Status-Line\n   The first line of a Response message is the Status-Line,\
    \ consisting\n   of the protocol version followed by a numeric status code and\
    \ its\n   associated textual phrase, with each element separated by SP\n   characters.\
    \  No CR or LF is allowed except in the final CRLF\n   sequence.\n       Status-Line\
    \ = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n"
- title: 6.1.1 Status Code and Reason Phrase
  contents:
  - "6.1.1 Status Code and Reason Phrase\n   The Status-Code element is a 3-digit\
    \ integer result code of the\n   attempt to understand and satisfy the request.\
    \ These codes are fully\n   defined in section 10. The Reason-Phrase is intended\
    \ to give a short\n   textual description of the Status-Code. The Status-Code\
    \ is intended\n   for use by automata and the Reason-Phrase is intended for the\
    \ human\n   user. The client is not required to examine or display the Reason-\n\
    \   Phrase.\n   The first digit of the Status-Code defines the class of response.\
    \ The\n   last two digits do not have any categorization role. There are 5\n \
    \  values for the first digit:\n     o  1xx: Informational - Request received,\
    \ continuing process\n     o  2xx: Success - The action was successfully received,\
    \ understood,\n        and accepted\n     o  3xx: Redirection - Further action\
    \ must be taken in order to\n        complete the request\n     o  4xx: Client\
    \ Error - The request contains bad syntax or cannot be\n        fulfilled\n  \
    \   o  5xx: Server Error - The server failed to fulfill an apparently\n      \
    \  valid request\n   The individual values of the numeric status codes defined\
    \ for\n   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are\n\
    \   presented below. The reason phrases listed here are only recommended\n   --\
    \ they may be replaced by local equivalents without affecting the\n   protocol.\n\
    \          Status-Code    = \"100\"   ; Continue\n                         | \"\
    101\"   ; Switching Protocols\n                         | \"200\"   ; OK\n   \
    \                      | \"201\"   ; Created\n                         | \"202\"\
    \   ; Accepted\n                         | \"203\"   ; Non-Authoritative Information\n\
    \                         | \"204\"   ; No Content\n                         |\
    \ \"205\"   ; Reset Content\n                         | \"206\"   ; Partial Content\n\
    \                         | \"300\"   ; Multiple Choices\n                   \
    \      | \"301\"   ; Moved Permanently\n                         | \"302\"   ;\
    \ Moved Temporarily\n                         | \"303\"   ; See Other\n      \
    \                   | \"304\"   ; Not Modified\n                         | \"\
    305\"   ; Use Proxy\n                         | \"400\"   ; Bad Request\n    \
    \                     | \"401\"   ; Unauthorized\n                         | \"\
    402\"   ; Payment Required\n                         | \"403\"   ; Forbidden\n\
    \                         | \"404\"   ; Not Found\n                         |\
    \ \"405\"   ; Method Not Allowed\n                         | \"406\"   ; Not Acceptable\n\
    \                         | \"407\"   ; Proxy Authentication Required\n      \
    \                   | \"408\"   ; Request Time-out\n                         |\
    \ \"409\"   ; Conflict\n                         | \"410\"   ; Gone\n        \
    \                 | \"411\"   ; Length Required\n                         | \"\
    412\"   ; Precondition Failed\n                         | \"413\"   ; Request\
    \ Entity Too Large\n                         | \"414\"   ; Request-URI Too Large\n\
    \                         | \"415\"   ; Unsupported Media Type\n             \
    \            | \"500\"   ; Internal Server Error\n                         | \"\
    501\"   ; Not Implemented\n                         | \"502\"   ; Bad Gateway\n\
    \                         | \"503\"   ; Service Unavailable\n                \
    \         | \"504\"   ; Gateway Time-out\n                         | \"505\" \
    \  ; HTTP Version not supported\n                         | extension-code\n \
    \         extension-code = 3DIGIT\n          Reason-Phrase  = *<TEXT, excluding\
    \ CR, LF>\n   HTTP status codes are extensible. HTTP applications are not required\n\
    \   to understand the meaning of all registered status codes, though such\n  \
    \ understanding is obviously desirable. However, applications MUST\n   understand\
    \ the class of any status code, as indicated by the first\n   digit, and treat\
    \ any unrecognized response as being equivalent to the\n   x00 status code of\
    \ that class, with the exception that an\n   unrecognized response MUST NOT be\
    \ cached. For example, if an\n   unrecognized status code of 431 is received by\
    \ the client, it can\n   safely assume that there was something wrong with its\
    \ request and\n   treat the response as if it had received a 400 status code.\
    \ In such\n   cases, user agents SHOULD present to the user the entity returned\n\
    \   with the response, since that entity is likely to include human-\n   readable\
    \ information which will explain the unusual status.\n"
- title: 6.2 Response Header Fields
  contents:
  - "6.2 Response Header Fields\n   The response-header fields allow the server to\
    \ pass additional\n   information about the response which cannot be placed in\
    \ the Status-\n   Line. These header fields give information about the server\
    \ and about\n   further access to the resource identified by the Request-URI.\n\
    \          response-header = Age                     ; Section 14.6\n        \
    \                  | Location                ; Section 14.30\n               \
    \           | Proxy-Authenticate      ; Section 14.33\n                      \
    \    | Public                  ; Section 14.35\n                          | Retry-After\
    \             ; Section 14.38\n                          | Server            \
    \      ; Section 14.39\n                          | Vary                    ;\
    \ Section 14.43\n                          | Warning                 ; Section\
    \ 14.45\n                          | WWW-Authenticate        ; Section 14.46\n\
    \   Response-header field names can be extended reliably only in\n   combination\
    \ with a change in the protocol version. However, new or\n   experimental header\
    \ fields MAY be given the semantics of response-\n   header fields if all parties\
    \ in the communication recognize them to\n   be response-header fields. Unrecognized\
    \ header fields are treated as\n   entity-header fields.\n"
- title: 7 Entity
  contents:
  - "7 Entity\n   Request and Response messages MAY transfer an entity if not otherwise\n\
    \   restricted by the request method or response status code. An entity\n   consists\
    \ of entity-header fields and an entity-body, although some\n   responses will\
    \ only include the entity-headers.\n   In this section, both sender and recipient\
    \ refer to either the client\n   or the server, depending on who sends and who\
    \ receives the entity.\n"
- title: 7.1 Entity Header Fields
  contents:
  - "7.1 Entity Header Fields\n   Entity-header fields define optional metainformation\
    \ about the\n   entity-body or, if no body is present, about the resource identified\n\
    \   by the request.\n          entity-header  = Allow                    ; Section\
    \ 14.7\n                         | Content-Base             ; Section 14.11\n\
    \                         | Content-Encoding         ; Section 14.12\n       \
    \                  | Content-Language         ; Section 14.13\n              \
    \           | Content-Length           ; Section 14.14\n                     \
    \    | Content-Location         ; Section 14.15\n                         | Content-MD5\
    \              ; Section 14.16\n                         | Content-Range     \
    \       ; Section 14.17\n                         | Content-Type             ;\
    \ Section 14.18\n                         | ETag                     ; Section\
    \ 14.20\n                         | Expires                  ; Section 14.21\n\
    \                         | Last-Modified            ; Section 14.29\n       \
    \                  | extension-header\n          extension-header = message-header\n\
    \   The extension-header mechanism allows additional entity-header fields\n  \
    \ to be defined without changing the protocol, but these fields cannot\n   be\
    \ assumed to be recognizable by the recipient. Unrecognized header\n   fields\
    \ SHOULD be ignored by the recipient and forwarded by proxies.\n"
- title: 7.2 Entity Body
  contents:
  - "7.2 Entity Body\n   The entity-body (if any) sent with an HTTP request or response\
    \ is in\n   a format and encoding defined by the entity-header fields.\n     \
    \     entity-body    = *OCTET\n   An entity-body is only present in a message\
    \ when a message-body is\n   present, as described in section 4.3. The entity-body\
    \ is obtained\n   from the message-body by decoding any Transfer-Encoding that\
    \ may have\n   been applied to ensure safe and proper transfer of the message.\n"
- title: 7.2.1 Type
  contents:
  - "7.2.1 Type\n   When an entity-body is included with a message, the data type\
    \ of that\n   body is determined via the header fields Content-Type and Content-\n\
    \   Encoding. These define a two-layer, ordered encoding model:\n          entity-body\
    \ := Content-Encoding( Content-Type( data ) )\n   Content-Type specifies the media\
    \ type of the underlying data.\n   Content-Encoding may be used to indicate any\
    \ additional content\n   codings applied to the data, usually for the purpose\
    \ of data\n   compression, that are a property of the requested resource. There\
    \ is\n   no default encoding.\n   Any HTTP/1.1 message containing an entity-body\
    \ SHOULD include a\n   Content-Type header field defining the media type of that\
    \ body. If\n   and only if the media type is not given by a Content-Type field,\
    \ the\n   recipient MAY attempt to guess the media type via inspection of its\n\
    \   content and/or the name extension(s) of the URL used to identify the\n   resource.\
    \ If the media type remains unknown, the recipient SHOULD\n   treat it as type\
    \ \"application/octet-stream\".\n"
- title: 7.2.2 Length
  contents:
  - "7.2.2 Length\n   The length of an entity-body is the length of the message-body\
    \ after\n   any transfer codings have been removed. Section 4.4 defines how the\n\
    \   length of a message-body is determined.\n"
- title: 8 Connections
  contents:
  - '8 Connections

    '
- title: 8.1 Persistent Connections
  contents:
  - '8.1 Persistent Connections

    '
- title: 8.1.1 Purpose
  contents:
  - "8.1.1 Purpose\n   Prior to persistent connections, a separate TCP connection\
    \ was\n   established to fetch each URL, increasing the load on HTTP servers\n\
    \   and causing congestion on the Internet. The use of inline images and\n   other\
    \ associated data often requires a client to make multiple\n   requests of the\
    \ same server in a short amount of time. Analyses of\n   these performance problems\
    \ are available [30][27]; analysis and\n   results from a prototype implementation\
    \ are in [26].\n   Persistent HTTP connections have a number of advantages:\n\
    \     o  By opening and closing fewer TCP connections, CPU time is saved,\n  \
    \      and memory used for TCP protocol control blocks is also saved.\n     o\
    \  HTTP requests and responses can be pipelined on a connection.\n        Pipelining\
    \ allows a client to make multiple requests without\n        waiting for each\
    \ response, allowing a single TCP connection to be\n        used much more efficiently,\
    \ with much lower elapsed time.\n     o  Network congestion is reduced by reducing\
    \ the number of packets\n        caused by TCP opens, and by allowing TCP sufficient\
    \ time to\n        determine the congestion state of the network.\n     o  HTTP\
    \ can evolve more gracefully; since errors can be reported\n        without the\
    \ penalty of closing the TCP connection. Clients using\n        future versions\
    \ of HTTP might optimistically try a new feature, but\n        if communicating\
    \ with an older server, retry with old semantics\n        after an error is reported.\n\
    \   HTTP implementations SHOULD implement persistent connections.\n"
- title: 8.1.2 Overall Operation
  contents:
  - "8.1.2 Overall Operation\n   A significant difference between HTTP/1.1 and earlier\
    \ versions of\n   HTTP is that persistent connections are the default behavior\
    \ of any\n   HTTP connection. That is, unless otherwise indicated, the client\
    \ may\n   assume that the server will maintain a persistent connection.\n   Persistent\
    \ connections provide a mechanism by which a client and a\n   server can signal\
    \ the close of a TCP connection. This signaling takes\n   place using the Connection\
    \ header field. Once a close has been\n   signaled, the client MUST not send any\
    \ more requests on that\n   connection.\n"
- title: 8.1.2.1 Negotiation
  contents:
  - "8.1.2.1 Negotiation\n   An HTTP/1.1 server MAY assume that a HTTP/1.1 client\
    \ intends to\n   maintain a persistent connection unless a Connection header including\n\
    \   the connection-token \"close\" was sent in the request. If the server\n  \
    \ chooses to close the connection immediately after sending the\n   response,\
    \ it SHOULD send a Connection header including the\n   connection-token close.\n\
    \   An HTTP/1.1 client MAY expect a connection to remain open, but would\n   decide\
    \ to keep it open based on whether the response from a server\n   contains a Connection\
    \ header with the connection-token close. In case\n   the client does not want\
    \ to maintain a connection for more than that\n   request, it SHOULD send a Connection\
    \ header including the\n   connection-token close.\n   If either the client or\
    \ the server sends the close token in the\n   Connection header, that request\
    \ becomes the last one for the\n   connection.\n   Clients and servers SHOULD\
    \ NOT assume that a persistent connection is\n   maintained for HTTP versions\
    \ less than 1.1 unless it is explicitly\n   signaled. See section 19.7.1 for more\
    \ information on backwards\n   compatibility with HTTP/1.0 clients.\n   In order\
    \ to remain persistent, all messages on the connection must\n   have a self-defined\
    \ message length (i.e., one not defined by closure\n   of the connection), as\
    \ described in section 4.4.\n"
- title: 8.1.2.2 Pipelining
  contents:
  - "8.1.2.2 Pipelining\n   A client that supports persistent connections MAY \"pipeline\"\
    \ its\n   requests (i.e., send multiple requests without waiting for each\n  \
    \ response). A server MUST send its responses to those requests in the\n   same\
    \ order that the requests were received.\n   Clients which assume persistent connections\
    \ and pipeline immediately\n   after connection establishment SHOULD be prepared\
    \ to retry their\n   connection if the first pipelined attempt fails. If a client\
    \ does\n   such a retry, it MUST NOT pipeline before it knows the connection is\n\
    \   persistent. Clients MUST also be prepared to resend their requests if\n  \
    \ the server closes the connection before sending all of the\n   corresponding\
    \ responses.\n"
- title: 8.1.3 Proxy Servers
  contents:
  - "8.1.3 Proxy Servers\n   It is especially important that proxies correctly implement\
    \ the\n   properties of the Connection header field as specified in 14.2.1.\n\
    \   The proxy server MUST signal persistent connections separately with\n   its\
    \ clients and the origin servers (or other proxy servers) that it\n   connects\
    \ to. Each persistent connection applies to only one transport\n   link.\n   A\
    \ proxy server MUST NOT establish a persistent connection with an\n   HTTP/1.0\
    \ client.\n"
- title: 8.1.4 Practical Considerations
  contents:
  - "8.1.4 Practical Considerations\n   Servers will usually have some time-out value\
    \ beyond which they will\n   no longer maintain an inactive connection. Proxy\
    \ servers might make\n   this a higher value since it is likely that the client\
    \ will be making\n   more connections through the same server. The use of persistent\n\
    \   connections places no requirements on the length of this time-out for\n  \
    \ either the client or the server.\n   When a client or server wishes to time-out\
    \ it SHOULD issue a graceful\n   close on the transport connection. Clients and\
    \ servers SHOULD both\n   constantly watch for the other side of the transport\
    \ close, and\n   respond to it as appropriate. If a client or server does not\
    \ detect\n   the other side's close promptly it could cause unnecessary resource\n\
    \   drain on the network.\n   A client, server, or proxy MAY close the transport\
    \ connection at any\n   time. For example, a client MAY have started to send a\
    \ new request at\n   the same time that the server has decided to close the \"\
    idle\"\n   connection. From the server's point of view, the connection is being\n\
    \   closed while it was idle, but from the client's point of view, a\n   request\
    \ is in progress.\n   This means that clients, servers, and proxies MUST be able\
    \ to recover\n   from asynchronous close events. Client software SHOULD reopen\
    \ the\n   transport connection and retransmit the aborted request without user\n\
    \   interaction so long as the request method is idempotent (see section\n   9.1.2);\
    \ other methods MUST NOT be automatically retried, although\n   user agents MAY\
    \ offer a human operator the choice of retrying the\n   request.\n   However,\
    \ this automatic retry SHOULD NOT be repeated if the second\n   request fails.\n\
    \   Servers SHOULD always respond to at least one request per connection,\n  \
    \ if at all possible. Servers SHOULD NOT close a connection in the\n   middle\
    \ of transmitting a response, unless a network or client failure\n   is suspected.\n\
    \   Clients that use persistent connections SHOULD limit the number of\n   simultaneous\
    \ connections that they maintain to a given server. A\n   single-user client SHOULD\
    \ maintain AT MOST 2 connections with any\n   server or proxy. A proxy SHOULD\
    \ use up to 2*N connections to another\n   server or proxy, where N is the number\
    \ of simultaneously active\n   users. These guidelines are intended to improve\
    \ HTTP response times\n   and avoid congestion of the Internet or other networks.\n"
- title: 8.2 Message Transmission Requirements
  contents:
  - '8.2 Message Transmission Requirements

    '
- title: 'General requirements:'
  contents:
  - 'General requirements:

    '
- title: o  HTTP/1.1 servers SHOULD maintain persistent connections and use
  contents:
  - "o  HTTP/1.1 servers SHOULD maintain persistent connections and use\n   TCP's\
    \ flow control mechanisms to resolve temporary overloads,\n   rather than terminating\
    \ connections with the expectation that\n   clients will retry. The latter technique\
    \ can exacerbate network\n   congestion.\n"
- title: o  An HTTP/1.1 (or later) client sending a message-body SHOULD monitor
  contents:
  - "o  An HTTP/1.1 (or later) client sending a message-body SHOULD monitor\n   the\
    \ network connection for an error status while it is transmitting\n   the request.\
    \ If the client sees an error status, it SHOULD\n   immediately cease transmitting\
    \ the body. If the body is being sent\n   using a \"chunked\" encoding (section\
    \ 3.6), a zero length chunk and\n   empty footer MAY be used to prematurely mark\
    \ the end of the\n   message. If the body was preceded by a Content-Length header,\
    \ the\n   client MUST close the connection.\n"
- title: o  An HTTP/1.1 (or later) client MUST be prepared to accept a 100
  contents:
  - "o  An HTTP/1.1 (or later) client MUST be prepared to accept a 100\n   (Continue)\
    \ status followed by a regular response.\n"
- title: o  An HTTP/1.1 (or later) server that receives a request from a
  contents:
  - "o  An HTTP/1.1 (or later) server that receives a request from a\n   HTTP/1.0\
    \ (or earlier) client MUST NOT transmit the 100 (continue)\n   response; it SHOULD\
    \ either wait for the request to be completed\n   normally (thus avoiding an interrupted\
    \ request) or close the\n   connection prematurely.\n   Upon receiving a method\
    \ subject to these requirements from an\n   HTTP/1.1 (or later) client, an HTTP/1.1\
    \ (or later) server MUST either\n   respond with 100 (Continue) status and continue\
    \ to read from the\n   input stream, or respond with an error status. If it responds\
    \ with an\n   error status, it MAY close the transport (TCP) connection or it\
    \ MAY\n   continue to read and discard the rest of the request. It MUST NOT\n\
    \   perform the requested method if it returns an error status.\n   Clients SHOULD\
    \ remember the version number of at least the most\n   recently used server; if\
    \ an HTTP/1.1 client has seen an HTTP/1.1 or\n   later response from the server,\
    \ and it sees the connection close\n   before receiving any status from the server,\
    \ the client SHOULD retry\n   the request without user interaction so long as\
    \ the request method is\n   idempotent (see section 9.1.2); other methods MUST\
    \ NOT be\n   automatically retried, although user agents MAY offer a human\n \
    \  operator the choice of retrying the request.. If the client does\n   retry\
    \ the request, the client\n     o  MUST first send the request header fields,\
    \ and then\n     o  MUST wait for the server to respond with either a 100 (Continue)\n\
    \        response, in which case the client should continue, or with an\n    \
    \    error status.\n   If an HTTP/1.1 client has not seen an HTTP/1.1 or later\
    \ response from\n   the server, it should assume that the server implements HTTP/1.0\
    \ or\n   older and will not use the 100 (Continue) response. If in this case\n\
    \   the client sees the connection close before receiving any status from\n  \
    \ the server, the client SHOULD retry the request. If the client does\n   retry\
    \ the request to this HTTP/1.0 server, it should use the\n   following \"binary\
    \ exponential backoff\" algorithm to be assured of\n   obtaining a reliable response:\n\
    \  1. Initiate a new connection to the server\n  2. Transmit the request-headers\n\
    \  3. Initialize a variable R to the estimated round-trip time to the\n     server\
    \ (e.g., based on the time it took to establish the\n     connection), or to a\
    \ constant value of 5 seconds if the round-trip\n     time is not available.\n\
    \  4. Compute T = R * (2**N), where N is the number of previous retries\n    \
    \ of this request.\n  5. Wait either for an error response from the server, or\
    \ for T seconds\n     (whichever comes first)\n  6. If no error response is received,\
    \ after T seconds transmit the body\n     of the request.\n  7. If client sees\
    \ that the connection is closed prematurely, repeat\n     from step 1 until the\
    \ request is accepted, an error response is\n     received, or the user becomes\
    \ impatient and terminates the retry\n     process.\n   No matter what the server\
    \ version, if an error status is received,\n   the client\n  o  MUST NOT continue\
    \ and\n  o  MUST close the connection if it has not completed sending the\n  \
    \   message.\n   An HTTP/1.1 (or later) client that sees the connection close\
    \ after\n   receiving a 100 (Continue) but before receiving any other status\n\
    \   SHOULD retry the request, and need not wait for 100 (Continue)\n   response\
    \ (but MAY do so if this simplifies the implementation).\n"
- title: 9 Method Definitions
  contents:
  - "9 Method Definitions\n   The set of common methods for HTTP/1.1 is defined below.\
    \ Although\n   this set can be expanded, additional methods cannot be assumed\
    \ to\n   share the same semantics for separately extended clients and servers.\n\
    \   The Host request-header field (section 14.23) MUST accompany all\n   HTTP/1.1\
    \ requests.\n"
- title: 9.1 Safe and Idempotent Methods
  contents:
  - '9.1 Safe and Idempotent Methods

    '
- title: 9.1.1 Safe Methods
  contents:
  - "9.1.1 Safe Methods\n   Implementers should be aware that the software represents\
    \ the user in\n   their interactions over the Internet, and should be careful\
    \ to allow\n   the user to be aware of any actions they may take which may have\
    \ an\n   unexpected significance to themselves or others.\n   In particular, the\
    \ convention has been established that the GET and\n   HEAD methods should never\
    \ have the significance of taking an action\n   other than retrieval. These methods\
    \ should be considered \"safe.\" This\n   allows user agents to represent other\
    \ methods, such as POST, PUT and\n   DELETE, in a special way, so that the user\
    \ is made aware of the fact\n   that a possibly unsafe action is being requested.\n\
    \   Naturally, it is not possible to ensure that the server does not\n   generate\
    \ side-effects as a result of performing a GET request; in\n   fact, some dynamic\
    \ resources consider that a feature. The important\n   distinction here is that\
    \ the user did not request the side-effects,\n   so therefore cannot be held accountable\
    \ for them.\n"
- title: 9.1.2 Idempotent Methods
  contents:
  - "9.1.2 Idempotent Methods\n   Methods may also have the property of \"idempotence\"\
    \ in that (aside\n   from error or expiration issues) the side-effects of  N >\
    \ 0 identical\n   requests is the same as for a single request. The methods GET,\
    \ HEAD,\n   PUT and DELETE share this property.\n"
- title: 9.2 OPTIONS
  contents:
  - "9.2 OPTIONS\n   The OPTIONS method represents a request for information about\
    \ the\n   communication options available on the request/response chain\n   identified\
    \ by the Request-URI. This method allows the client to\n   determine the options\
    \ and/or requirements associated with a resource,\n   or the capabilities of a\
    \ server, without implying a resource action\n   or initiating a resource retrieval.\n\
    \   Unless the server's response is an error, the response MUST NOT\n   include\
    \ entity information other than what can be considered as\n   communication options\
    \ (e.g., Allow is appropriate, but Content-Type\n   is not). Responses to this\
    \ method are not cachable.\n   If the Request-URI is an asterisk (\"*\"), the\
    \ OPTIONS request is\n   intended to apply to the server as a whole. A 200 response\
    \ SHOULD\n   include any header fields which indicate optional features\n   implemented\
    \ by the server (e.g., Public), including any extensions\n   not defined by this\
    \ specification, in addition to any applicable\n   general or response-header\
    \ fields. As described in section 5.1.2, an\n   \"OPTIONS *\" request can be applied\
    \ through a proxy by specifying the\n   destination server in the Request-URI\
    \ without any path information.\n   If the Request-URI is not an asterisk, the\
    \ OPTIONS request applies\n   only to the options that are available when communicating\
    \ with that\n   resource.  A 200 response SHOULD include any header fields which\n\
    \   indicate optional features implemented by the server and applicable\n   to\
    \ that resource (e.g., Allow), including any extensions not defined\n   by this\
    \ specification, in addition to any applicable general or\n   response-header\
    \ fields. If the OPTIONS request passes through a\n   proxy, the proxy MUST edit\
    \ the response to exclude those options\n   which apply to a proxy's capabilities\
    \ and which are known to be\n   unavailable through that proxy.\n"
- title: 9.3 GET
  contents:
  - "9.3 GET\n   The GET method means retrieve whatever information (in the form of\
    \ an\n   entity) is identified by the Request-URI. If the Request-URI refers\n\
    \   to a data-producing process, it is the produced data which shall be\n   returned\
    \ as the entity in the response and not the source text of the\n   process, unless\
    \ that text happens to be the output of the process.\n   The semantics of the\
    \ GET method change to a \"conditional GET\" if the\n   request message includes\
    \ an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range\
    \ header field. A conditional GET\n   method requests that the entity be transferred\
    \ only under the\n   circumstances described by the conditional header field(s).\
    \ The\n   conditional GET method is intended to reduce unnecessary network\n \
    \  usage by allowing cached entities to be refreshed without requiring\n   multiple\
    \ requests or transferring data already held by the client.\n   The semantics\
    \ of the GET method change to a \"partial GET\" if the\n   request message includes\
    \ a Range header field. A partial GET requests\n   that only part of the entity\
    \ be transferred, as described in section\n   14.36. The partial GET method is\
    \ intended to reduce unnecessary\n   network usage by allowing partially-retrieved\
    \ entities to be\n   completed without transferring data already held by the client.\n\
    \   The response to a GET request is cachable if and only if it meets the\n  \
    \ requirements for HTTP caching described in section 13.\n"
- title: 9.4 HEAD
  contents:
  - "9.4 HEAD\n   The HEAD method is identical to GET except that the server MUST\
    \ NOT\n   return a message-body in the response. The metainformation contained\n\
    \   in the HTTP headers in response to a HEAD request SHOULD be identical\n  \
    \ to the information sent in response to a GET request. This method can\n   be\
    \ used for obtaining metainformation about the entity implied by the\n   request\
    \ without transferring the entity-body itself. This method is\n   often used for\
    \ testing hypertext links for validity, accessibility,\n   and recent modification.\n\
    \   The response to a HEAD request may be cachable in the sense that the\n   information\
    \ contained in the response may be used to update a\n   previously cached entity\
    \ from that resource. If the new field values\n   indicate that the cached entity\
    \ differs from the current entity (as\n   would be indicated by a change in Content-Length,\
    \ Content-MD5, ETag\n   or Last-Modified), then the cache MUST treat the cache\
    \ entry as\n   stale.\n"
- title: 9.5 POST
  contents:
  - "9.5 POST\n   The POST method is used to request that the destination server accept\n\
    \   the entity enclosed in the request as a new subordinate of the\n   resource\
    \ identified by the Request-URI in the Request-Line. POST is\n   designed to allow\
    \ a uniform method to cover the following functions:\n     o  Annotation of existing\
    \ resources;\n     o  Posting a message to a bulletin board, newsgroup, mailing\
    \ list,\n        or similar group of articles;\n     o  Providing a block of data,\
    \ such as the result of submitting a\n        form, to a data-handling process;\n\
    \     o  Extending a database through an append operation.\n   The actual function\
    \ performed by the POST method is determined by the\n   server and is usually\
    \ dependent on the Request-URI. The posted entity\n   is subordinate to that URI\
    \ in the same way that a file is subordinate\n   to a directory containing it,\
    \ a news article is subordinate to a\n   newsgroup to which it is posted, or a\
    \ record is subordinate to a\n   database.\n   The action performed by the POST\
    \ method might not result in a\n   resource that can be identified by a URI. In\
    \ this case, either 200\n   (OK) or 204 (No Content) is the appropriate response\
    \ status,\n   depending on whether or not the response includes an entity that\n\
    \   describes the result.\n   If a resource has been created on the origin server,\
    \ the response\n   SHOULD be 201 (Created) and contain an entity which describes\
    \ the\n   status of the request and refers to the new resource, and a Location\n\
    \   header (see section 14.30).\n   Responses to this method are not cachable,\
    \ unless the response\n   includes appropriate Cache-Control or Expires header\
    \ fields. However,\n   the 303 (See Other) response can be used to direct the\
    \ user agent to\n   retrieve a cachable resource.\n   POST requests must obey\
    \ the message transmission requirements set out\n   in section 8.2.\n"
- title: 9.6 PUT
  contents:
  - "9.6 PUT\n   The PUT method requests that the enclosed entity be stored under\
    \ the\n   supplied Request-URI. If the Request-URI refers to an already\n   existing\
    \ resource, the enclosed entity SHOULD be considered as a\n   modified version\
    \ of the one residing on the origin server. If the\n   Request-URI does not point\
    \ to an existing resource, and that URI is\n   capable of being defined as a new\
    \ resource by the requesting user\n   agent, the origin server can create the\
    \ resource with that URI. If a\n   new resource is created, the origin server\
    \ MUST inform the user agent\n   via the 201 (Created) response.  If an existing\
    \ resource is modified,\n   either the 200 (OK) or 204 (No Content) response codes\
    \ SHOULD be sent\n   to indicate successful completion of the request. If the\
    \ resource\n   could not be created or modified with the Request-URI, an appropriate\n\
    \   error response SHOULD be given that reflects the nature of the\n   problem.\
    \ The recipient of the entity MUST NOT ignore any Content-*\n   (e.g. Content-Range)\
    \ headers that it does not understand or implement\n   and MUST return a 501 (Not\
    \ Implemented) response in such cases.\n   If the request passes through a cache\
    \ and the Request-URI identifies\n   one or more currently cached entities, those\
    \ entries should be\n   treated as stale. Responses to this method are not cachable.\n\
    \   The fundamental difference between the POST and PUT requests is\n   reflected\
    \ in the different meaning of the Request-URI. The URI in a\n   POST request identifies\
    \ the resource that will handle the enclosed\n   entity.  That resource may be\
    \ a data-accepting process, a gateway to\n   some other protocol, or a separate\
    \ entity that accepts annotations.\n   In contrast, the URI in a PUT request identifies\
    \ the entity enclosed\n   with the request -- the user agent knows what URI is\
    \ intended and the\n   server MUST NOT attempt to apply the request to some other\
    \ resource.\n   If the server desires that the request be applied to a different\
    \ URI,\n   it MUST send a 301 (Moved Permanently) response; the user agent MAY\n\
    \   then make its own decision regarding whether or not to redirect the\n   request.\n\
    \   A single resource MAY be identified by many different URIs. For\n   example,\
    \ an article may have a URI for identifying \"the current\n   version\" which\
    \ is separate from the URI identifying each particular\n   version. In this case,\
    \ a PUT request on a general URI may result in\n   several other URIs being defined\
    \ by the origin server.\n   HTTP/1.1 does not define how a PUT method affects\
    \ the state of an\n   origin server.\n   PUT requests must obey the message transmission\
    \ requirements set out\n   in section 8.2.\n"
- title: 9.7 DELETE
  contents:
  - "9.7 DELETE\n   The DELETE method requests that the origin server delete the resource\n\
    \   identified by the Request-URI. This method MAY be overridden by human\n  \
    \ intervention (or other means) on the origin server. The client cannot\n   be\
    \ guaranteed that the operation has been carried out, even if the\n   status code\
    \ returned from the origin server indicates that the action\n   has been completed\
    \ successfully. However, the server SHOULD not\n   indicate success unless, at\
    \ the time the response is given, it\n   intends to delete the resource or move\
    \ it to an inaccessible\n   location.\n   A successful response SHOULD be 200\
    \ (OK) if the response includes an\n   entity describing the status, 202 (Accepted)\
    \ if the action has not\n   yet been enacted, or 204 (No Content) if the response\
    \ is OK but does\n   not include an entity.\n   If the request passes through\
    \ a cache and the Request-URI identifies\n   one or more currently cached entities,\
    \ those entries should be\n   treated as stale. Responses to this method are not\
    \ cachable.\n"
- title: 9.8 TRACE
  contents:
  - "9.8 TRACE\n   The TRACE method is used to invoke a remote, application-layer\
    \ loop-\n   back of the request message. The final recipient of the request\n\
    \   SHOULD reflect the message received back to the client as the\n   entity-body\
    \ of a 200 (OK) response. The final recipient is either the\n   origin server\
    \ or the first proxy or gateway to receive a Max-Forwards\n   value of zero (0)\
    \ in the request (see section 14.31). A TRACE request\n   MUST NOT include an\
    \ entity.\n   TRACE allows the client to see what is being received at the other\n\
    \   end of the request chain and use that data for testing or diagnostic\n   information.\
    \ The value of the Via header field (section 14.44) is of\n   particular interest,\
    \ since it acts as a trace of the request chain.\n   Use of the Max-Forwards header\
    \ field allows the client to limit the\n   length of the request chain, which\
    \ is useful for testing a chain of\n   proxies forwarding messages in an infinite\
    \ loop.\n   If successful, the response SHOULD contain the entire request message\n\
    \   in the entity-body, with a Content-Type of \"message/http\". Responses\n \
    \  to this method MUST NOT be cached.\n"
- title: 10 Status Code Definitions
  contents:
  - "10 Status Code Definitions\n   Each Status-Code is described below, including\
    \ a description of which\n   method(s) it can follow and any metainformation required\
    \ in the\n   response.\n"
- title: 10.1 Informational 1xx
  contents:
  - "10.1 Informational 1xx\n   This class of status code indicates a provisional\
    \ response,\n   consisting only of the Status-Line and optional headers, and is\n\
    \   terminated by an empty line. Since HTTP/1.0 did not define any 1xx\n   status\
    \ codes, servers MUST NOT send a 1xx response to an HTTP/1.0\n   client except\
    \ under experimental conditions.\n"
- title: 10.1.1 100 Continue
  contents:
  - "10.1.1 100 Continue\n   The client may continue with its request. This interim\
    \ response is\n   used to inform the client that the initial part of the request\
    \ has\n   been received and has not yet been rejected by the server. The client\n\
    \   SHOULD continue by sending the remainder of the request or, if the\n   request\
    \ has already been completed, ignore this response. The server\n   MUST send a\
    \ final response after the request has been completed.\n"
- title: 10.1.2 101 Switching Protocols
  contents:
  - "10.1.2 101 Switching Protocols\n   The server understands and is willing to comply\
    \ with the client's\n   request, via the Upgrade message header field (section\
    \ 14.41), for a\n   change in the application protocol being used on this connection.\
    \ The\n   server will switch protocols to those defined by the response's\n  \
    \ Upgrade header field immediately after the empty line which\n   terminates the\
    \ 101 response.\n   The protocol should only be switched when it is advantageous\
    \ to do\n   so.  For example, switching to a newer version of HTTP is\n   advantageous\
    \ over older versions, and switching to a real-time,\n   synchronous protocol\
    \ may be advantageous when delivering resources\n   that use such features.\n"
- title: 10.2 Successful 2xx
  contents:
  - "10.2 Successful 2xx\n   This class of status code indicates that the client's\
    \ request was\n   successfully received, understood, and accepted.\n"
- title: 10.2.1 200 OK
  contents:
  - "10.2.1 200 OK\n   The request has succeeded. The information returned with the\
    \ response\n   is dependent on the method used in the request, for example:\n\
    \   GET  an entity corresponding to the requested resource is sent in the\n  \
    \      response;\n   HEAD the entity-header fields corresponding to the requested\
    \ resource\n        are sent in the response without any message-body;\n   POST\
    \ an entity describing or containing the result of the action;\n   TRACE an entity\
    \ containing the request message as received by the end\n        server.\n"
- title: 10.2.2 201 Created
  contents:
  - "10.2.2 201 Created\n   The request has been fulfilled and resulted in a new resource\
    \ being\n   created. The newly created resource can be referenced by the URI(s)\n\
    \   returned in the entity of the response, with the most specific URL\n   for\
    \ the resource given by a Location header field. The origin server\n   MUST create\
    \ the resource before returning the 201 status code. If the\n   action cannot\
    \ be carried out immediately, the server should respond\n   with 202 (Accepted)\
    \ response instead.\n"
- title: 10.2.3 202 Accepted
  contents:
  - "10.2.3 202 Accepted\n   The request has been accepted for processing, but the\
    \ processing has\n   not been completed. The request MAY or MAY NOT eventually\
    \ be acted\n   upon, as it MAY be disallowed when processing actually takes place.\n\
    \   There is no facility for re-sending a status code from an\n   asynchronous\
    \ operation such as this.\n   The 202 response is intentionally non-committal.\
    \ Its purpose is to\n   allow a server to accept a request for some other process\
    \ (perhaps a\n   batch-oriented process that is only run once per day) without\n\
    \   requiring that the user agent's connection to the server persist\n   until\
    \ the process is completed. The entity returned with this\n   response SHOULD\
    \ include an indication of the request's current status\n   and either a pointer\
    \ to a status monitor or some estimate of when the\n   user can expect the request\
    \ to be fulfilled.\n"
- title: 10.2.4 203 Non-Authoritative Information
  contents:
  - "10.2.4 203 Non-Authoritative Information\n   The returned metainformation in\
    \ the entity-header is not the\n   definitive set as available from the origin\
    \ server, but is gathered\n   from a local or a third-party copy. The set presented\
    \ MAY be a subset\n   or superset of the original version. For example, including\
    \ local\n   annotation information about the resource MAY result in a superset\
    \ of\n   the metainformation known by the origin server. Use of this response\n\
    \   code is not required and is only appropriate when the response would\n   otherwise\
    \ be 200 (OK).\n"
- title: 10.2.5 204 No Content
  contents:
  - "10.2.5 204 No Content\n   The server has fulfilled the request but there is no\
    \ new information\n   to send back. If the client is a user agent, it SHOULD NOT\
    \ change its\n   document view from that which caused the request to be sent.\
    \ This\n   response is primarily intended to allow input for actions to take\n\
    \   place without causing a change to the user agent's active document\n   view.\
    \ The response MAY include new metainformation in the form of\n   entity-headers,\
    \ which SHOULD apply to the document currently in the\n   user agent's active\
    \ view.\n   The 204 response MUST NOT include a message-body, and thus is always\n\
    \   terminated by the first empty line after the header fields.\n"
- title: 10.2.6 205 Reset Content
  contents:
  - "10.2.6 205 Reset Content\n   The server has fulfilled the request and the user\
    \ agent SHOULD reset\n   the document view which caused the request to be sent.\
    \ This response\n   is primarily intended to allow input for actions to take place\
    \ via\n   user input, followed by a clearing of the form in which the input is\n\
    \   given so that the user can easily initiate another input action. The\n   response\
    \ MUST NOT include an entity.\n"
- title: 10.2.7 206 Partial Content
  contents:
  - "10.2.7 206 Partial Content\n   The server has fulfilled the partial GET request\
    \ for the resource.\n   The request must have included a Range header field (section\
    \ 14.36)\n   indicating the desired range. The response MUST include either a\n\
    \   Content-Range header field (section 14.17) indicating the range\n   included\
    \ with this response, or a multipart/byteranges Content-Type\n   including Content-Range\
    \ fields for each part. If multipart/byteranges\n   is not used, the Content-Length\
    \ header field in the response MUST\n   match the actual number of OCTETs transmitted\
    \ in the message-body.\n   A cache that does not support the Range and Content-Range\
    \ headers\n   MUST NOT cache 206 (Partial) responses.\n"
- title: 10.3 Redirection 3xx
  contents:
  - "10.3 Redirection 3xx\n   This class of status code indicates that further action\
    \ needs to be\n   taken by the user agent in order to fulfill the request. The\
    \ action\n   required MAY be carried out by the user agent without interaction\n\
    \   with the user if and only if the method used in the second request is\n  \
    \ GET or HEAD. A user agent SHOULD NOT automatically redirect a request\n   more\
    \ than 5 times, since such redirections usually indicate an\n   infinite loop.\n"
- title: 10.3.1 300 Multiple Choices
  contents:
  - "10.3.1 300 Multiple Choices\n   The requested resource corresponds to any one\
    \ of a set of\n   representations, each with its own specific location, and agent-\n\
    \   driven negotiation information (section 12) is being provided so that\n  \
    \ the user (or user agent) can select a preferred representation and\n   redirect\
    \ its request to that location.\n   Unless it was a HEAD request, the response\
    \ SHOULD include an entity\n   containing a list of resource characteristics and\
    \ location(s) from\n   which the user or user agent can choose the one most appropriate.\
    \ The\n   entity format is specified by the media type given in the Content-\n\
    \   Type header field. Depending upon the format and the capabilities of\n   the\
    \ user agent, selection of the most appropriate choice may be\n   performed automatically.\
    \  However, this specification does not define\n   any standard for such automatic\
    \ selection.\n   If the server has a preferred choice of representation, it SHOULD\n\
    \   include the specific URL for that representation in the Location\n   field;\
    \ user agents MAY use the Location field value for automatic\n   redirection.\
    \  This response is cachable unless indicated otherwise.\n"
- title: 10.3.2 301 Moved Permanently
  contents:
  - "10.3.2 301 Moved Permanently\n   The requested resource has been assigned a new\
    \ permanent URI and any\n   future references to this resource SHOULD be done\
    \ using one of the\n   returned URIs. Clients with link editing capabilities SHOULD\n\
    \   automatically re-link references to the Request-URI to one or more of\n  \
    \ the new references returned by the server, where possible. This\n   response\
    \ is cachable unless indicated otherwise.\n   If the new URI is a location, its\
    \ URL SHOULD be given by the Location\n   field in the response. Unless the request\
    \ method was HEAD, the entity\n   of the response SHOULD contain a short hypertext\
    \ note with a\n   hyperlink to the new URI(s).\n   If the 301 status code is received\
    \ in response to a request other\n   than GET or HEAD, the user agent MUST NOT\
    \ automatically redirect the\n   request unless it can be confirmed by the user,\
    \ since this might\n   change the conditions under which the request was issued.\n\
    \     Note: When automatically redirecting a POST request after receiving\n  \
    \   a 301 status code, some existing HTTP/1.0 user agents will\n     erroneously\
    \ change it into a GET request.\n"
- title: 10.3.3 302 Moved Temporarily
  contents:
  - "10.3.3 302 Moved Temporarily\n   The requested resource resides temporarily under\
    \ a different URI.\n   Since the redirection may be altered on occasion, the client\
    \ SHOULD\n   continue to use the Request-URI for future requests. This response\
    \ is\n   only cachable if indicated by a Cache-Control or Expires header\n   field.\n\
    \   If the new URI is a location, its URL SHOULD be given by the Location\n  \
    \ field in the response. Unless the request method was HEAD, the entity\n   of\
    \ the response SHOULD contain a short hypertext note with a\n   hyperlink to the\
    \ new URI(s).\n   If the 302 status code is received in response to a request\
    \ other\n   than GET or HEAD, the user agent MUST NOT automatically redirect the\n\
    \   request unless it can be confirmed by the user, since this might\n   change\
    \ the conditions under which the request was issued.\n     Note: When automatically\
    \ redirecting a POST request after receiving\n     a 302 status code, some existing\
    \ HTTP/1.0 user agents will\n     erroneously change it into a GET request.\n"
- title: 10.3.4 303 See Other
  contents:
  - "10.3.4 303 See Other\n   The response to the request can be found under a different\
    \ URI and\n   SHOULD be retrieved using a GET method on that resource. This method\n\
    \   exists primarily to allow the output of a POST-activated script to\n   redirect\
    \ the user agent to a selected resource. The new URI is not a\n   substitute reference\
    \ for the originally requested resource. The 303\n   response is not cachable,\
    \ but the response to the second (redirected)\n   request MAY be cachable.\n \
    \  If the new URI is a location, its URL SHOULD be given by the Location\n   field\
    \ in the response. Unless the request method was HEAD, the entity\n   of the response\
    \ SHOULD contain a short hypertext note with a\n   hyperlink to the new URI(s).\n"
- title: 10.3.5 304 Not Modified
  contents:
  - "10.3.5 304 Not Modified\n   If the client has performed a conditional GET request\
    \ and access is\n   allowed, but the document has not been modified, the server\
    \ SHOULD\n   respond with this status code. The response MUST NOT contain a\n\
    \   message-body.\n   The response MUST include the following header fields:\n\
    \  o  Date\n  o  ETag and/or Content-Location, if the header would have been sent\
    \ in\n     a 200 response to the same request\n  o  Expires, Cache-Control, and/or\
    \ Vary, if the field-value might\n     differ from that sent in any previous response\
    \ for the same variant\n   If the conditional GET used a strong cache validator\
    \ (see section\n   13.3.3), the response SHOULD NOT include other entity-headers.\n\
    \   Otherwise (i.e., the conditional GET used a weak validator), the\n   response\
    \ MUST NOT include other entity-headers; this prevents\n   inconsistencies between\
    \ cached entity-bodies and updated headers.\n   If a 304 response indicates an\
    \ entity not currently cached, then the\n   cache MUST disregard the response\
    \ and repeat the request without the\n   conditional.\n   If a cache uses a received\
    \ 304 response to update a cache entry, the\n   cache MUST update the entry to\
    \ reflect any new field values given in\n   the response.\n   The 304 response\
    \ MUST NOT include a message-body, and thus is always\n   terminated by the first\
    \ empty line after the header fields.\n"
- title: 10.3.6 305 Use Proxy
  contents:
  - "10.3.6 305 Use Proxy\n   The requested resource MUST be accessed through the\
    \ proxy given by\n   the Location field. The Location field gives the URL of the\
    \ proxy.\n   The recipient is expected to repeat the request via the proxy.\n"
- title: 10.4 Client Error 4xx
  contents:
  - "10.4 Client Error 4xx\n   The 4xx class of status code is intended for cases\
    \ in which the\n   client seems to have erred. Except when responding to a HEAD\
    \ request,\n   the server SHOULD include an entity containing an explanation of\
    \ the\n   error situation, and whether it is a temporary or permanent\n   condition.\
    \ These status codes are applicable to any request method.\n   User agents SHOULD\
    \ display any included entity to the user.\n     Note: If the client is sending\
    \ data, a server implementation using\n     TCP should be careful to ensure that\
    \ the client acknowledges\n     receipt of the packet(s) containing the response,\
    \ before the server\n     closes the input connection. If the client continues\
    \ sending data\n     to the server after the close, the server's TCP stack will\
    \ send a\n     reset packet to the client, which may erase the client's\n    \
    \ unacknowledged input buffers before they can be read and\n     interpreted by\
    \ the HTTP application.\n"
- title: 10.4.1 400 Bad Request
  contents:
  - "10.4.1 400 Bad Request\n   The request could not be understood by the server\
    \ due to malformed\n   syntax. The client SHOULD NOT repeat the request without\n\
    \   modifications.\n"
- title: 10.4.2 401 Unauthorized
  contents:
  - "10.4.2 401 Unauthorized\n   The request requires user authentication. The response\
    \ MUST include a\n   WWW-Authenticate header field (section 14.46) containing\
    \ a challenge\n   applicable to the requested resource. The client MAY repeat\
    \ the\n   request with a suitable Authorization header field (section 14.8). If\n\
    \   the request already included Authorization credentials, then the 401\n   response\
    \ indicates that authorization has been refused for those\n   credentials. If\
    \ the 401 response contains the same challenge as the\n   prior response, and\
    \ the user agent has already attempted\n   authentication at least once, then\
    \ the user SHOULD be presented the\n   entity that was given in the response,\
    \ since that entity MAY include\n   relevant diagnostic information. HTTP access\
    \ authentication is\n   explained in section 11.\n"
- title: 10.4.3 402 Payment Required
  contents:
  - "10.4.3 402 Payment Required\n   This code is reserved for future use.\n"
- title: 10.4.4 403 Forbidden
  contents:
  - "10.4.4 403 Forbidden\n   The server understood the request, but is refusing to\
    \ fulfill it.\n   Authorization will not help and the request SHOULD NOT be repeated.\n\
    \   If the request method was not HEAD and the server wishes to make\n   public\
    \ why the request has not been fulfilled, it SHOULD describe the\n   reason for\
    \ the refusal in the entity. This status code is commonly\n   used when the server\
    \ does not wish to reveal exactly why the request\n   has been refused, or when\
    \ no other response is applicable.\n"
- title: 10.4.5 404 Not Found
  contents:
  - "10.4.5 404 Not Found\n   The server has not found anything matching the Request-URI.\
    \ No\n   indication is given of whether the condition is temporary or\n   permanent.\n\
    \   If the server does not wish to make this information available to the\n  \
    \ client, the status code 403 (Forbidden) can be used instead. The 410\n   (Gone)\
    \ status code SHOULD be used if the server knows, through some\n   internally\
    \ configurable mechanism, that an old resource is\n   permanently unavailable\
    \ and has no forwarding address.\n"
- title: 10.4.6 405 Method Not Allowed
  contents:
  - "10.4.6 405 Method Not Allowed\n   The method specified in the Request-Line is\
    \ not allowed for the\n   resource identified by the Request-URI. The response\
    \ MUST include an\n   Allow header containing a list of valid methods for the\
    \ requested\n   resource.\n"
- title: 10.4.7 406 Not Acceptable
  contents:
  - "10.4.7 406 Not Acceptable\n   The resource identified by the request is only\
    \ capable of generating\n   response entities which have content characteristics\
    \ not acceptable\n   according to the accept headers sent in the request.\n  \
    \ Unless it was a HEAD request, the response SHOULD include an entity\n   containing\
    \ a list of available entity characteristics and location(s)\n   from which the\
    \ user or user agent can choose the one most\n   appropriate.  The entity format\
    \ is specified by the media type given\n   in the Content-Type header field. Depending\
    \ upon the format and the\n   capabilities of the user agent, selection of the\
    \ most appropriate\n   choice may be performed automatically. However, this specification\n\
    \   does not define any standard for such automatic selection.\n     Note: HTTP/1.1\
    \ servers are allowed to return responses which are\n     not acceptable according\
    \ to the accept headers sent in the request.\n     In some cases, this may even\
    \ be preferable to sending a 406\n     response. User agents are encouraged to\
    \ inspect the headers of an\n     incoming response to determine if it is acceptable.\
    \ If the response\n     could be unacceptable, a user agent SHOULD temporarily\
    \ stop receipt\n     of more data and query the user for a decision on further\
    \ actions.\n"
- title: 10.4.8 407 Proxy Authentication Required
  contents:
  - "10.4.8 407 Proxy Authentication Required\n   This code is similar to 401 (Unauthorized),\
    \ but indicates that the\n   client MUST first authenticate itself with the proxy.\
    \ The proxy MUST\n   return a Proxy-Authenticate header field (section 14.33)\
    \ containing a\n   challenge applicable to the proxy for the requested resource.\
    \ The\n   client MAY repeat the request with a suitable Proxy-Authorization\n\
    \   header field (section 14.34). HTTP access authentication is explained\n  \
    \ in section 11.\n"
- title: 10.4.9 408 Request Timeout
  contents:
  - "10.4.9 408 Request Timeout\n   The client did not produce a request within the\
    \ time that the server\n   was prepared to wait. The client MAY repeat the request\
    \ without\n   modifications at any later time.\n"
- title: 10.4.10 409 Conflict
  contents:
  - "10.4.10 409 Conflict\n   The request could not be completed due to a conflict\
    \ with the current\n   state of the resource. This code is only allowed in situations\
    \ where\n   it is expected that the user might be able to resolve the conflict\n\
    \   and resubmit the request. The response body SHOULD include enough\n   information\
    \ for the user to recognize the source of the conflict.\n   Ideally, the response\
    \ entity would include enough information for the\n   user or user agent to fix\
    \ the problem; however, that may not be\n   possible and is not required.\n  \
    \ Conflicts are most likely to occur in response to a PUT request. If\n   versioning\
    \ is being used and the entity being PUT includes changes to\n   a resource which\
    \ conflict with those made by an earlier (third-party)\n   request, the server\
    \ MAY use the 409 response to indicate that it\n   can't complete the request.\
    \ In this case, the response entity SHOULD\n   contain a list of the differences\
    \ between the two versions in a\n   format defined by the response Content-Type.\n"
- title: 10.4.11 410 Gone
  contents:
  - "10.4.11 410 Gone\n   The requested resource is no longer available at the server\
    \ and no\n   forwarding address is known. This condition SHOULD be considered\n\
    \   permanent. Clients with link editing capabilities SHOULD delete\n   references\
    \ to the Request-URI after user approval. If the server does\n   not know, or\
    \ has no facility to determine, whether or not the\n   condition is permanent,\
    \ the status code 404 (Not Found) SHOULD be\n   used instead.  This response is\
    \ cachable unless indicated otherwise.\n   The 410 response is primarily intended\
    \ to assist the task of web\n   maintenance by notifying the recipient that the\
    \ resource is\n   intentionally unavailable and that the server owners desire\
    \ that\n   remote links to that resource be removed. Such an event is common for\n\
    \   limited-time, promotional services and for resources belonging to\n   individuals\
    \ no longer working at the server's site. It is not\n   necessary to mark all\
    \ permanently unavailable resources as \"gone\" or\n   to keep the mark for any\
    \ length of time -- that is left to the\n   discretion of the server owner.\n"
- title: 10.4.12 411 Length Required
  contents:
  - "10.4.12 411 Length Required\n   The server refuses to accept the request without\
    \ a defined Content-\n   Length. The client MAY repeat the request if it adds\
    \ a valid\n   Content-Length header field containing the length of the message-body\n\
    \   in the request message.\n"
- title: 10.4.13 412 Precondition Failed
  contents:
  - "10.4.13 412 Precondition Failed\n   The precondition given in one or more of\
    \ the request-header fields\n   evaluated to false when it was tested on the server.\
    \ This response\n   code allows the client to place preconditions on the current\
    \ resource\n   metainformation (header field data) and thus prevent the requested\n\
    \   method from being applied to a resource other than the one intended.\n"
- title: 10.4.14 413 Request Entity Too Large
  contents:
  - "10.4.14 413 Request Entity Too Large\n   The server is refusing to process a\
    \ request because the request\n   entity is larger than the server is willing\
    \ or able to process. The\n   server may close the connection to prevent the client\
    \ from continuing\n   the request.\n   If the condition is temporary, the server\
    \ SHOULD include a Retry-\n   After header field to indicate that it is temporary\
    \ and after what\n   time the client may try again.\n"
- title: 10.4.15 414 Request-URI Too Long
  contents:
  - "10.4.15 414 Request-URI Too Long\n   The server is refusing to service the request\
    \ because the Request-URI\n   is longer than the server is willing to interpret.\
    \ This rare\n   condition is only likely to occur when a client has improperly\n\
    \   converted a POST request to a GET request with long query\n   information,\
    \ when the client has descended into a URL \"black hole\" of\n   redirection (e.g.,\
    \ a redirected URL prefix that points to a suffix of\n   itself), or when the\
    \ server is under attack by a client attempting to\n   exploit security holes\
    \ present in some servers using fixed-length\n   buffers for reading or manipulating\
    \ the Request-URI.\n"
- title: 10.4.16 415 Unsupported Media Type
  contents:
  - "10.4.16 415 Unsupported Media Type\n   The server is refusing to service the\
    \ request because the entity of\n   the request is in a format not supported by\
    \ the requested resource\n   for the requested method.\n"
- title: 10.5 Server Error 5xx
  contents:
  - "10.5 Server Error 5xx\n   Response status codes beginning with the digit \"5\"\
    \ indicate cases in\n   which the server is aware that it has erred or is incapable\
    \ of\n   performing the request. Except when responding to a HEAD request, the\n\
    \   server SHOULD include an entity containing an explanation of the\n   error\
    \ situation, and whether it is a temporary or permanent\n   condition. User agents\
    \ SHOULD display any included entity to the\n   user. These response codes are\
    \ applicable to any request method.\n"
- title: 10.5.1 500 Internal Server Error
  contents:
  - "10.5.1 500 Internal Server Error\n   The server encountered an unexpected condition\
    \ which prevented it\n   from fulfilling the request.\n"
- title: 10.5.2 501 Not Implemented
  contents:
  - "10.5.2 501 Not Implemented\n   The server does not support the functionality\
    \ required to fulfill the\n   request. This is the appropriate response when the\
    \ server does not\n   recognize the request method and is not capable of supporting\
    \ it for\n   any resource.\n"
- title: 10.5.3 502 Bad Gateway
  contents:
  - "10.5.3 502 Bad Gateway\n   The server, while acting as a gateway or proxy, received\
    \ an invalid\n   response from the upstream server it accessed in attempting to\n\
    \   fulfill the request.\n"
- title: 10.5.4 503 Service Unavailable
  contents:
  - "10.5.4 503 Service Unavailable\n   The server is currently unable to handle the\
    \ request due to a\n   temporary overloading or maintenance of the server. The\
    \ implication\n   is that this is a temporary condition which will be alleviated\
    \ after\n   some delay. If known, the length of the delay may be indicated in\
    \ a\n   Retry-After header.  If no Retry-After is given, the client SHOULD\n \
    \  handle the response as it would for a 500 response.\n     Note: The existence\
    \ of the 503 status code does not imply that a\n     server must use it when becoming\
    \ overloaded. Some servers may wish\n     to simply refuse the connection.\n"
- title: 10.5.5 504 Gateway Timeout
  contents:
  - "10.5.5 504 Gateway Timeout\n   The server, while acting as a gateway or proxy,\
    \ did not receive a\n   timely response from the upstream server it accessed in\
    \ attempting to\n   complete the request.\n"
- title: 10.5.6 505 HTTP Version Not Supported
  contents:
  - "10.5.6 505 HTTP Version Not Supported\n   The server does not support, or refuses\
    \ to support, the HTTP protocol\n   version that was used in the request message.\
    \ The server is\n   indicating that it is unable or unwilling to complete the\
    \ request\n   using the same major version as the client, as described in section\n\
    \   3.1, other than with this error message. The response SHOULD contain\n   an\
    \ entity describing why that version is not supported and what other\n   protocols\
    \ are supported by that server.\n"
- title: 11 Access Authentication
  contents:
  - "11 Access Authentication\n   HTTP provides a simple challenge-response authentication\
    \ mechanism\n   which MAY be used by a server to challenge a client request and\
    \ by a\n   client to provide authentication information. It uses an extensible,\n\
    \   case-insensitive token to identify the authentication scheme,\n   followed\
    \ by a comma-separated list of attribute-value pairs which\n   carry the parameters\
    \ necessary for achieving authentication via that\n   scheme.\n          auth-scheme\
    \    = token\n          auth-param     = token \"=\" quoted-string\n   The 401\
    \ (Unauthorized) response message is used by an origin server\n   to challenge\
    \ the authorization of a user agent. This response MUST\n   include a WWW-Authenticate\
    \ header field containing at least one\n   challenge applicable to the requested\
    \ resource.\n          challenge      = auth-scheme 1*SP realm *( \",\" auth-param\
    \ )\n          realm          = \"realm\" \"=\" realm-value\n          realm-value\
    \    = quoted-string\n   The realm attribute (case-insensitive) is required for\
    \ all\n   authentication schemes which issue a challenge. The realm value\n  \
    \ (case-sensitive), in combination with the canonical root URL (see\n   section\
    \ 5.1.2) of the server being accessed, defines the protection\n   space. These\
    \ realms allow the protected resources on a server to be\n   partitioned into\
    \ a set of protection spaces, each with its own\n   authentication scheme and/or\
    \ authorization database. The realm value\n   is a string, generally assigned\
    \ by the origin server, which may have\n   additional semantics specific to the\
    \ authentication scheme.\n   A user agent that wishes to authenticate itself with\
    \ a server--\n   usually, but not necessarily, after receiving a 401 or 411 response-\n\
    \   -MAY do so by including an Authorization header field with the\n   request.\
    \ The Authorization field value consists of credentials\n   containing the authentication\
    \ information of the user agent for the\n   realm of the resource being requested.\n\
    \          credentials    = basic-credentials\n                         | auth-scheme\
    \ #auth-param\n   The domain over which credentials can be automatically applied\
    \ by a\n   user agent is determined by the protection space. If a prior request\n\
    \   has been authorized, the same credentials MAY be reused for all other\n  \
    \ requests within that protection space for a period of time determined\n   by\
    \ the authentication scheme, parameters, and/or user preference.\n   Unless otherwise\
    \ defined by the authentication scheme, a single\n   protection space cannot extend\
    \ outside the scope of its server.\n   If the server does not wish to accept the\
    \ credentials sent with a\n   request, it SHOULD return a 401 (Unauthorized) response.\
    \ The response\n   MUST include a WWW-Authenticate header field containing the\
    \ (possibly\n   new) challenge applicable to the requested resource and an entity\n\
    \   explaining the refusal.\n   The HTTP protocol does not restrict applications\
    \ to this simple\n   challenge-response mechanism for access authentication. Additional\n\
    \   mechanisms MAY be used, such as encryption at the transport level or\n   via\
    \ message encapsulation, and with additional header fields\n   specifying authentication\
    \ information. However, these additional\n   mechanisms are not defined by this\
    \ specification.\n   Proxies MUST be completely transparent regarding user agent\n\
    \   authentication. That is, they MUST forward the WWW-Authenticate and\n   Authorization\
    \ headers untouched, and follow the rules found in\n   section 14.8.\n   HTTP/1.1\
    \ allows a client to pass authentication information to and\n   from a proxy via\
    \ the Proxy-Authenticate and Proxy-Authorization\n   headers.\n"
- title: 11.1 Basic Authentication Scheme
  contents:
  - "11.1 Basic Authentication Scheme\n   The \"basic\" authentication scheme is based\
    \ on the model that the user\n   agent must authenticate itself with a user-ID\
    \ and a password for each\n   realm. The realm value should be considered an opaque\
    \ string which\n   can only be compared for equality with other realms on that\
    \ server.\n   The server will service the request only if it can validate the\n\
    \   user-ID and password for the protection space of the Request-URI.\n   There\
    \ are no optional authentication parameters.\n   Upon receipt of an unauthorized\
    \ request for a URI within the\n   protection space, the server MAY respond with\
    \ a challenge like the\n   following:\n          WWW-Authenticate: Basic realm=\"\
    WallyWorld\"\n   where \"WallyWorld\" is the string assigned by the server to\
    \ identify\n   the protection space of the Request-URI.\n   To receive authorization,\
    \ the client sends the userid and password,\n   separated by a single colon (\"\
    :\") character, within a base64  encoded\n   string in the credentials.\n    \
    \      basic-credentials = \"Basic\" SP basic-cookie\n          basic-cookie \
    \  = <base64 [7] encoding of user-pass,\n                           except not\
    \ limited to 76 char/line>\n          user-pass   = userid \":\" password\n  \
    \        userid      = *<TEXT excluding \":\">\n          password    = *TEXT\n\
    \   Userids might be case sensitive.\n   If the user agent wishes to send the\
    \ userid \"Aladdin\" and password\n   \"open sesame\", it would use the following\
    \ header field:\n          Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n\
    \   See section 15 for security considerations associated with Basic\n   authentication.\n"
- title: 11.2 Digest Authentication Scheme
  contents:
  - "11.2 Digest Authentication Scheme\n   A digest authentication for HTTP is specified\
    \ in RFC 2069 [32].\n"
- title: 12 Content Negotiation
  contents:
  - "12 Content Negotiation\n   Most HTTP responses include an entity which contains\
    \ information for\n   interpretation by a human user. Naturally, it is desirable\
    \ to supply\n   the user with the \"best available\" entity corresponding to the\n\
    \   request.  Unfortunately for servers and caches, not all users have\n   the\
    \ same preferences for what is \"best,\" and not all user agents are\n   equally\
    \ capable of rendering all entity types. For that reason, HTTP\n   has provisions\
    \ for several mechanisms for \"content negotiation\" --\n   the process of selecting\
    \ the best representation for a given response\n   when there are multiple representations\
    \ available.\n     Note: This is not called \"format negotiation\" because the\
    \ alternate\n     representations may be of the same media type, but use different\n\
    \     capabilities of that type, be in different languages, etc.\n   Any response\
    \ containing an entity-body MAY be subject to negotiation,\n   including error\
    \ responses.\n   There are two kinds of content negotiation which are possible\
    \ in\n   HTTP: server-driven and agent-driven negotiation. These two kinds of\n\
    \   negotiation are orthogonal and thus may be used separately or in\n   combination.\
    \ One method of combination, referred to as transparent\n   negotiation, occurs\
    \ when a cache uses the agent-driven negotiation\n   information provided by the\
    \ origin server in order to provide\n   server-driven negotiation for subsequent\
    \ requests.\n"
- title: 12.1 Server-driven Negotiation
  contents:
  - "12.1 Server-driven Negotiation\n   If the selection of the best representation\
    \ for a response is made by\n   an algorithm located at the server, it is called\
    \ server-driven\n   negotiation.  Selection is based on the available representations\
    \ of\n   the response (the dimensions over which it can vary; e.g. language,\n\
    \   content-coding, etc.) and the contents of particular header fields in\n  \
    \ the request message or on other information pertaining to the request\n   (such\
    \ as the network address of the client).\n   Server-driven negotiation is advantageous\
    \ when the algorithm for\n   selecting from among the available representations\
    \ is difficult to\n   describe to the user agent, or when the server desires to\
    \ send its\n   \"best guess\" to the client along with the first response (hoping\
    \ to\n   avoid the round-trip delay of a subsequent request if the \"best\n  \
    \ guess\" is good enough for the user). In order to improve the server's\n   guess,\
    \ the user agent MAY include request header fields (Accept,\n   Accept-Language,\
    \ Accept-Encoding, etc.) which describe its\n   preferences for such a response.\n\
    \   Server-driven negotiation has disadvantages:\n"
- title: 1. It is impossible for the server to accurately determine what might be
  contents:
  - "1. It is impossible for the server to accurately determine what might be\n  \"\
    best\" for any given user, since that would require complete\n  knowledge of both\
    \ the capabilities of the user agent and the intended\n  use for the response\
    \ (e.g., does the user want to view it on screen\n  or print it on paper?).\n"
- title: 2. Having the user agent describe its capabilities in every request can
  contents:
  - "2. Having the user agent describe its capabilities in every request can\n  be\
    \ both very inefficient (given that only a small percentage of\n  responses have\
    \ multiple representations) and a potential violation of\n  the user's privacy.\n"
- title: 3. It complicates the implementation of an origin server and the
  contents:
  - "3. It complicates the implementation of an origin server and the\n  algorithms\
    \ for generating responses to a request.\n"
- title: 4. It may limit a public cache's ability to use the same response for
  contents:
  - "4. It may limit a public cache's ability to use the same response for\n  multiple\
    \ user's requests.\n   HTTP/1.1 includes the following request-header fields for\
    \ enabling\n   server-driven negotiation through description of user agent\n \
    \  capabilities and user preferences: Accept (section 14.1), Accept-\n   Charset\
    \ (section 14.2), Accept-Encoding (section 14.3), Accept-\n   Language (section\
    \ 14.4), and User-Agent (section 14.42). However, an\n   origin server is not\
    \ limited to these dimensions and MAY vary the\n   response based on any aspect\
    \ of the request, including information\n   outside the request-header fields\
    \ or within extension header fields\n   not defined by this specification.\n \
    \  HTTP/1.1 origin servers MUST include an appropriate Vary header field\n   (section\
    \ 14.43) in any cachable response based on server-driven\n   negotiation. The\
    \ Vary header field describes the dimensions over\n   which the response might\
    \ vary (i.e. the dimensions over which the\n   origin server picks its \"best\
    \ guess\" response from multiple\n   representations).\n   HTTP/1.1 public caches\
    \ MUST recognize the Vary header field when it\n   is included in a response and\
    \ obey the requirements described in\n   section 13.6 that describes the interactions\
    \ between caching and\n   content negotiation.\n"
- title: 12.2 Agent-driven Negotiation
  contents:
  - "12.2 Agent-driven Negotiation\n   With agent-driven negotiation, selection of\
    \ the best representation\n   for a response is performed by the user agent after\
    \ receiving an\n   initial response from the origin server. Selection is based\
    \ on a list\n   of the available representations of the response included within\
    \ the\n   header fields (this specification reserves the field-name Alternates,\n\
    \   as described in appendix 19.6.2.1) or entity-body of the initial\n   response,\
    \ with each representation identified by its own URI.\n   Selection from among\
    \ the representations may be performed\n   automatically (if the user agent is\
    \ capable of doing so) or manually\n   by the user selecting from a generated\
    \ (possibly hypertext) menu.\n   Agent-driven negotiation is advantageous when\
    \ the response would vary\n   over commonly-used dimensions (such as type, language,\
    \ or encoding),\n   when the origin server is unable to determine a user agent's\n\
    \   capabilities from examining the request, and generally when public\n   caches\
    \ are used to distribute server load and reduce network usage.\n   Agent-driven\
    \ negotiation suffers from the disadvantage of needing a\n   second request to\
    \ obtain the best alternate representation. This\n   second request is only efficient\
    \ when caching is used. In addition,\n   this specification does not define any\
    \ mechanism for supporting\n   automatic selection, though it also does not prevent\
    \ any such\n   mechanism from being developed as an extension and used within\n\
    \   HTTP/1.1.\n   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)\n\
    \   status codes for enabling agent-driven negotiation when the server is\n  \
    \ unwilling or unable to provide a varying response using server-driven\n   negotiation.\n"
- title: 12.3 Transparent Negotiation
  contents:
  - "12.3 Transparent Negotiation\n   Transparent negotiation is a combination of\
    \ both server-driven and\n   agent-driven negotiation. When a cache is supplied\
    \ with a form of the\n   list of available representations of the response (as\
    \ in agent-driven\n   negotiation) and the dimensions of variance are completely\
    \ understood\n   by the cache, then the cache becomes capable of performing server-\n\
    \   driven negotiation on behalf of the origin server for subsequent\n   requests\
    \ on that resource.\n   Transparent negotiation has the advantage of distributing\
    \ the\n   negotiation work that would otherwise be required of the origin\n  \
    \ server and also removing the second request delay of agent-driven\n   negotiation\
    \ when the cache is able to correctly guess the right\n   response.\n   This specification\
    \ does not define any mechanism for transparent\n   negotiation, though it also\
    \ does not prevent any such mechanism from\n   being developed as an extension\
    \ and used within HTTP/1.1. An HTTP/1.1\n   cache performing transparent negotiation\
    \ MUST include a Vary header\n   field in the response (defining the dimensions\
    \ of its variance) if it\n   is cachable to ensure correct interoperation with\
    \ all HTTP/1.1\n   clients. The agent-driven negotiation information supplied\
    \ by the\n   origin server SHOULD be included with the transparently negotiated\n\
    \   response.\n"
- title: 13 Caching in HTTP
  contents:
  - "13 Caching in HTTP\n   HTTP is typically used for distributed information systems,\
    \ where\n   performance can be improved by the use of response caches. The\n \
    \  HTTP/1.1 protocol includes a number of elements intended to make\n   caching\
    \ work as well as possible. Because these elements are\n   inextricable from other\
    \ aspects of the protocol, and because they\n   interact with each other, it is\
    \ useful to describe the basic caching\n   design of HTTP separately from the\
    \ detailed descriptions of methods,\n   headers, response codes, etc.\n   Caching\
    \ would be useless if it did not significantly improve\n   performance. The goal\
    \ of caching in HTTP/1.1 is to eliminate the need\n   to send requests in many\
    \ cases, and to eliminate the need to send\n   full responses in many other cases.\
    \ The former reduces the number of\n   network round-trips required for many operations;\
    \ we use an\n   \"expiration\" mechanism for this purpose (see section 13.2).\
    \ The\n   latter reduces network bandwidth requirements; we use a \"validation\"\
    \n   mechanism for this purpose (see section 13.3).\n   Requirements for performance,\
    \ availability, and disconnected\n   operation require us to be able to relax\
    \ the goal of semantic\n   transparency. The HTTP/1.1 protocol allows origin servers,\
    \ caches,\n   and clients to explicitly reduce transparency when necessary.\n\
    \   However, because non-transparent operation may confuse non-expert\n   users,\
    \ and may be incompatible with certain server applications (such\n   as those\
    \ for ordering merchandise), the protocol requires that\n   transparency be relaxed\n\
    \  o  only by an explicit protocol-level request when relaxed by client\n    \
    \ or origin server\n  o  only with an explicit warning to the end user when relaxed\
    \ by cache\n     or client\n   Therefore, the HTTP/1.1 protocol provides these\
    \ important elements:\n  1. Protocol features that provide full semantic transparency\
    \ when this\n     is required by all parties.\n  2. Protocol features that allow\
    \ an origin server or user agent to\n     explicitly request and control non-transparent\
    \ operation.\n  3. Protocol features that allow a cache to attach warnings to\n\
    \     responses that do not preserve the requested approximation of\n     semantic\
    \ transparency.\n   A basic principle is that it must be possible for the clients\
    \ to\n   detect any potential relaxation of semantic transparency.\n     Note:\
    \ The server, cache, or client implementer may be faced with\n     design decisions\
    \ not explicitly discussed in this specification. If\n     a decision may affect\
    \ semantic transparency, the implementer ought\n     to err on the side of maintaining\
    \ transparency unless a careful and\n     complete analysis shows significant\
    \ benefits in breaking\n     transparency.\n"
- title: 13.1.1 Cache Correctness
  contents:
  - "13.1.1 Cache Correctness\n   A correct cache MUST respond to a request with the\
    \ most up-to-date\n   response held by the cache that is appropriate to the request\
    \ (see\n   sections 13.2.5, 13.2.6, and 13.12) which meets one of the following\n\
    \   conditions:\n  1. It has been checked for equivalence with what the origin\
    \ server\n     would have returned by revalidating the response with the origin\n\
    \     server (section 13.3);\n  2. It is \"fresh enough\" (see section 13.2).\
    \ In the default case, this\n     means it meets the least restrictive freshness\
    \ requirement of the\n     client, server, and cache (see section 14.9); if the\
    \ origin server\n     so specifies, it is the freshness requirement of the origin\
    \ server\n     alone.\n  3. It includes a warning if the freshness demand of the\
    \ client or the\n     origin server is violated (see section 13.1.5 and 14.45).\n\
    \  4. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect), or\n    \
    \ error (4xx or 5xx) response message.\n   If the cache can not communicate with\
    \ the origin server, then a\n   correct cache SHOULD respond as above if the response\
    \ can be\n   correctly served from the cache; if not it MUST return an error or\n\
    \   warning indicating that there was a communication failure.\n   If a cache\
    \ receives a response (either an entire response, or a 304\n   (Not Modified)\
    \ response) that it would normally forward to the\n   requesting client, and the\
    \ received response is no longer fresh, the\n   cache SHOULD forward it to the\
    \ requesting client without adding a new\n   Warning (but without removing any\
    \ existing Warning headers). A cache\n   SHOULD NOT attempt to revalidate a response\
    \ simply because that\n   response became stale in transit; this might lead to\
    \ an infinite\n   loop. An user agent that receives a stale response without a\
    \ Warning\n   MAY display a warning indication to the user.\n"
- title: 13.1.2 Warnings
  contents:
  - "13.1.2 Warnings\n   Whenever a cache returns a response that is neither first-hand\
    \ nor\n   \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it\n\
    \   must attach a warning to that effect, using a Warning response-\n   header.\
    \ This warning allows clients to take appropriate action.\n   Warnings may be\
    \ used for other purposes, both cache-related and\n   otherwise. The use of a\
    \ warning, rather than an error status code,\n   distinguish these responses from\
    \ true failures.\n   Warnings are always cachable, because they never weaken the\n\
    \   transparency of a response. This means that warnings can be passed to\n  \
    \ HTTP/1.0 caches without danger; such caches will simply pass the\n   warning\
    \ along as an entity-header in the response.\n   Warnings are assigned numbers\
    \ between 0 and 99. This specification\n   defines the code numbers and meanings\
    \ of each currently assigned\n   warnings, allowing a client or cache to take\
    \ automated action in some\n   (but not all) cases.\n   Warnings also carry a\
    \ warning text. The text may be in any\n   appropriate natural language (perhaps\
    \ based on the client's Accept\n   headers), and include an optional indication\
    \ of what character set is\n   used.\n   Multiple warnings may be attached to\
    \ a response (either by the origin\n   server or by a cache), including multiple\
    \ warnings with the same code\n   number. For example, a server may provide the\
    \ same warning with texts\n   in both English and Basque.\n   When multiple warnings\
    \ are attached to a response, it may not be\n   practical or reasonable to display\
    \ all of them to the user. This\n   version of HTTP does not specify strict priority\
    \ rules for deciding\n   which warnings to display and in what order, but does\
    \ suggest some\n   heuristics.\n   The Warning header and the currently defined\
    \ warnings are described\n   in section 14.45.\n"
- title: 13.1.3 Cache-control Mechanisms
  contents:
  - "13.1.3 Cache-control Mechanisms\n   The basic cache mechanisms in HTTP/1.1 (server-specified\
    \ expiration\n   times and validators) are implicit directives to caches. In some\n\
    \   cases, a server or client may need to provide explicit directives to\n   the\
    \ HTTP caches. We use the Cache-Control header for this purpose.\n   The Cache-Control\
    \ header allows a client or server to transmit a\n   variety of directives in\
    \ either requests or responses. These\n   directives typically override the default\
    \ caching algorithms. As a\n   general rule, if there is any apparent conflict\
    \ between header\n   values, the most restrictive interpretation should be applied\
    \ (that\n   is, the one that is most likely to preserve semantic transparency).\n\
    \   However, in some cases, Cache-Control directives are explicitly\n   specified\
    \ as weakening the approximation of semantic transparency\n   (for example, \"\
    max-stale\" or \"public\").\n   The Cache-Control directives are described in\
    \ detail in section 14.9.\n"
- title: 13.1.4 Explicit User Agent Warnings
  contents:
  - "13.1.4 Explicit User Agent Warnings\n   Many user agents make it possible for\
    \ users to override the basic\n   caching mechanisms. For example, the user agent\
    \ may allow the user to\n   specify that cached entities (even explicitly stale\
    \ ones) are never\n   validated. Or the user agent might habitually add \"Cache-Control:\n\
    \   max-stale=3600\" to every request. The user should have to explicitly\n  \
    \ request either non-transparent behavior, or behavior that results in\n   abnormally\
    \ ineffective caching.\n   If the user has overridden the basic caching mechanisms,\
    \ the user\n   agent should explicitly indicate to the user whenever this results\
    \ in\n   the display of information that might not meet the server's\n   transparency\
    \ requirements (in particular, if the displayed entity is\n   known to be stale).\
    \ Since the protocol normally allows the user agent\n   to determine if responses\
    \ are stale or not, this indication need only\n   be displayed when this actually\
    \ happens. The indication need not be a\n   dialog box; it could be an icon (for\
    \ example, a picture of a rotting\n   fish) or some other visual indicator.\n\
    \   If the user has overridden the caching mechanisms in a way that would\n  \
    \ abnormally reduce the effectiveness of caches, the user agent should\n   continually\
    \ display an indication (for example, a picture of currency\n   in flames) so\
    \ that the user does not inadvertently consume excess\n   resources or suffer\
    \ from excessive latency.\n"
- title: 13.1.5 Exceptions to the Rules and Warnings
  contents:
  - "13.1.5 Exceptions to the Rules and Warnings\n   In some cases, the operator of\
    \ a cache may choose to configure it to\n   return stale responses even when not\
    \ requested by clients. This\n   decision should not be made lightly, but may\
    \ be necessary for reasons\n   of availability or performance, especially when\
    \ the cache is poorly\n   connected to the origin server. Whenever a cache returns\
    \ a stale\n   response, it MUST mark it as such (using a Warning header). This\n\
    \   allows the client software to alert the user that there may be a\n   potential\
    \ problem.\n   It also allows the user agent to take steps to obtain a first-hand\
    \ or\n   fresh response. For this reason, a cache SHOULD NOT return a stale\n\
    \   response if the client explicitly requests a first-hand or fresh one,\n  \
    \ unless it is impossible to comply for technical or policy reasons.\n"
- title: 13.1.6 Client-controlled Behavior
  contents:
  - "13.1.6 Client-controlled Behavior\n   While the origin server (and to a lesser\
    \ extent, intermediate caches,\n   by their contribution to the age of a response)\
    \ are the primary\n   source of expiration information, in some cases the client\
    \ may need\n   to control a cache's decision about whether to return a cached\n\
    \   response without validating it. Clients do this using several\n   directives\
    \ of the Cache-Control header.\n   A client's request may specify the maximum\
    \ age it is willing to\n   accept of an unvalidated response; specifying a value\
    \ of zero forces\n   the cache(s) to revalidate all responses. A client may also\
    \ specify\n   the minimum time remaining before a response expires. Both of these\n\
    \   options increase constraints on the behavior of caches, and so cannot\n  \
    \ further relax the cache's approximation of semantic transparency.\n   A client\
    \ may also specify that it will accept stale responses, up to\n   some maximum\
    \ amount of staleness. This loosens the constraints on the\n   caches, and so\
    \ may violate the origin server's specified constraints\n   on semantic transparency,\
    \ but may be necessary to support\n   disconnected operation, or high availability\
    \ in the face of poor\n   connectivity.\n"
- title: 13.2 Expiration Model
  contents:
  - '13.2 Expiration Model

    '
- title: 13.2.1 Server-Specified Expiration
  contents:
  - "13.2.1 Server-Specified Expiration\n   HTTP caching works best when caches can\
    \ entirely avoid making\n   requests to the origin server. The primary mechanism\
    \ for avoiding\n   requests is for an origin server to provide an explicit expiration\n\
    \   time in the future, indicating that a response may be used to satisfy\n  \
    \ subsequent requests.  In other words, a cache can return a fresh\n   response\
    \ without first contacting the server.\n   Our expectation is that servers will\
    \ assign future explicit\n   expiration times to responses in the belief that\
    \ the entity is not\n   likely to change, in a semantically significant way, before\
    \ the\n   expiration time is reached. This normally preserves semantic\n   transparency,\
    \ as long as the server's expiration times are carefully\n   chosen.\n   The expiration\
    \ mechanism applies only to responses taken from a cache\n   and not to first-hand\
    \ responses forwarded immediately to the\n   requesting client.\n   If an origin\
    \ server wishes to force a semantically transparent cache\n   to validate every\
    \ request, it may assign an explicit expiration time\n   in the past. This means\
    \ that the response is always stale, and so the\n   cache SHOULD validate it before\
    \ using it for subsequent requests. See\n   section 14.9.4 for a more restrictive\
    \ way to force revalidation.\n   If an origin server wishes to force any HTTP/1.1\
    \ cache, no matter how\n   it is configured, to validate every request, it should\
    \ use the\n   \"must-revalidate\" Cache-Control directive (see section 14.9).\n\
    \   Servers specify explicit expiration times using either the Expires\n   header,\
    \ or the max-age directive of the Cache-Control header.\n   An expiration time\
    \ cannot be used to force a user agent to refresh\n   its display or reload a\
    \ resource; its semantics apply only to caching\n   mechanisms, and such mechanisms\
    \ need only check a resource's\n   expiration status when a new request for that\
    \ resource is initiated.\n   See section 13.13 for explanation of the difference\
    \ between caches\n   and history mechanisms.\n"
- title: 13.2.2 Heuristic Expiration
  contents:
  - "13.2.2 Heuristic Expiration\n   Since origin servers do not always provide explicit\
    \ expiration times,\n   HTTP caches typically assign heuristic expiration times,\
    \ employing\n   algorithms that use other header values (such as the Last-Modified\n\
    \   time) to estimate a plausible expiration time. The HTTP/1.1\n   specification\
    \ does not provide specific algorithms, but does impose\n   worst-case constraints\
    \ on their results. Since heuristic expiration\n   times may compromise semantic\
    \ transparency, they should be used\n   cautiously, and we encourage origin servers\
    \ to provide explicit\n   expiration times as much as possible.\n"
- title: 13.2.3 Age Calculations
  contents:
  - "13.2.3 Age Calculations\n   In order to know if a cached entry is fresh, a cache\
    \ needs to know if\n   its age exceeds its freshness lifetime. We discuss how\
    \ to calculate\n   the latter in section 13.2.4; this section describes how to\
    \ calculate\n   the age of a response or cache entry.\n   In this discussion,\
    \ we use the term \"now\" to mean \"the current value\n   of the clock at the\
    \ host performing the calculation.\" Hosts that use\n   HTTP, but especially hosts\
    \ running origin servers and caches, should\n   use NTP [28] or some similar protocol\
    \ to synchronize their clocks to\n   a globally accurate time standard.\n   Also\
    \ note that HTTP/1.1 requires origin servers to send a Date header\n   with every\
    \ response, giving the time at which the response was\n   generated. We use the\
    \ term \"date_value\" to denote the value of the\n   Date header, in a form appropriate\
    \ for arithmetic operations.\n   HTTP/1.1 uses the Age response-header to help\
    \ convey age information\n   between caches. The Age header value is the sender's\
    \ estimate of the\n   amount of time since the response was generated at the origin\
    \ server.\n   In the case of a cached response that has been revalidated with\
    \ the\n   origin server, the Age value is based on the time of revalidation,\n\
    \   not of the original response.\n   In essence, the Age value is the sum of\
    \ the time that the response\n   has been resident in each of the caches along\
    \ the path from the\n   origin server, plus the amount of time it has been in\
    \ transit along\n   network paths.\n   We use the term \"age_value\" to denote\
    \ the value of the Age header, in\n   a form appropriate for arithmetic operations.\n\
    \   A response's age can be calculated in two entirely independent ways:\n   \
    \  1. now minus date_value, if the local clock is reasonably well\n        synchronized\
    \ to the origin server's clock. If the result is\n        negative, the result\
    \ is replaced by zero.\n     2. age_value, if all of the caches along the response\
    \ path\n        implement HTTP/1.1.\n   Given that we have two independent ways\
    \ to compute the age of a\n   response when it is received, we can combine these\
    \ as\n          corrected_received_age = max(now - date_value, age_value)\n  \
    \ and as long as we have either nearly synchronized clocks or all-\n   HTTP/1.1\
    \ paths, one gets a reliable (conservative) result.\n   Note that this correction\
    \ is applied at each HTTP/1.1 cache along the\n   path, so that if there is an\
    \ HTTP/1.0 cache in the path, the correct\n   received age is computed as long\
    \ as the receiving cache's clock is\n   nearly in sync. We don't need end-to-end\
    \ clock synchronization\n   (although it is good to have), and there is no explicit\
    \ clock\n   synchronization step.\n   Because of network-imposed delays, some\
    \ significant interval may pass\n   from the time that a server generates a response\
    \ and the time it is\n   received at the next outbound cache or client. If uncorrected,\
    \ this\n   delay could result in improperly low ages.\n   Because the request\
    \ that resulted in the returned Age value must have\n   been initiated prior to\
    \ that Age value's generation, we can correct\n   for delays imposed by the network\
    \ by recording the time at which the\n   request was initiated. Then, when an\
    \ Age value is received, it MUST\n   be interpreted relative to the time the request\
    \ was initiated, not\n   the time that the response was received. This algorithm\
    \ results in\n   conservative behavior no matter how much delay is experienced.\
    \ So, we\n   compute:\n         corrected_initial_age = corrected_received_age\n\
    \                               + (now - request_time)\n   where \"request_time\"\
    \ is the time (according to the local clock) when\n   the request that elicited\
    \ this response was sent.\n   Summary of age calculation algorithm, when a cache\
    \ receives a\n   response:\n      /*\n       * age_value\n       *      is the\
    \ value of Age: header received by the cache with\n       *              this\
    \ response.\n       * date_value\n       *      is the value of the origin server's\
    \ Date: header\n       * request_time\n       *      is the (local) time when\
    \ the cache made the request\n       *              that resulted in this cached\
    \ response\n       * response_time\n       *      is the (local) time when the\
    \ cache received the\n       *              response\n       * now\n       * \
    \     is the current (local) time\n       */\n      apparent_age = max(0, response_time\
    \ - date_value);\n      corrected_received_age = max(apparent_age, age_value);\n\
    \      response_delay = response_time - request_time;\n      corrected_initial_age\
    \ = corrected_received_age + response_delay;\n      resident_time = now - response_time;\n\
    \      current_age   = corrected_initial_age + resident_time;\n   When a cache\
    \ sends a response, it must add to the\n   corrected_initial_age the amount of\
    \ time that the response was\n   resident locally. It must then transmit this\
    \ total age, using the Age\n   header, to the next recipient cache.\n     Note\
    \ that a client cannot reliably tell that a response is first-\n     hand, but\
    \ the presence of an Age header indicates that a response\n     is definitely\
    \ not first-hand. Also, if the Date in a response is\n     earlier than the client's\
    \ local request time, the response is\n     probably not first-hand (in the absence\
    \ of serious clock skew).\n"
- title: 13.2.4 Expiration Calculations
  contents:
  - "13.2.4 Expiration Calculations\n   In order to decide whether a response is fresh\
    \ or stale, we need to\n   compare its freshness lifetime to its age. The age\
    \ is calculated as\n   described in section 13.2.3; this section describes how\
    \ to calculate\n   the freshness lifetime, and to determine if a response has\
    \ expired.\n   In the discussion below, the values can be represented in any form\n\
    \   appropriate for arithmetic operations.\n   We use the term \"expires_value\"\
    \ to denote the value of the Expires\n   header. We use the term \"max_age_value\"\
    \ to denote an appropriate\n   value of the number of seconds carried by the max-age\
    \ directive of\n   the Cache-Control header in a response (see section 14.10.\n\
    \   The max-age directive takes priority over Expires, so if max-age is\n   present\
    \ in a response, the calculation is simply:\n         freshness_lifetime = max_age_value\n\
    \   Otherwise, if Expires is present in the response, the calculation is:\n  \
    \       freshness_lifetime = expires_value - date_value\n   Note that neither\
    \ of these calculations is vulnerable to clock skew,\n   since all of the information\
    \ comes from the origin server.\n   If neither Expires nor Cache-Control: max-age\
    \ appears in the\n   response, and the response does not include other restrictions\
    \ on\n   caching, the cache MAY compute a freshness lifetime using a\n   heuristic.\
    \ If the value is greater than 24 hours, the cache must\n   attach Warning 13\
    \ to any response whose age is more than 24 hours if\n   such warning has not\
    \ already been added.\n   Also, if the response does have a Last-Modified time,\
    \ the heuristic\n   expiration value SHOULD be no more than some fraction of the\
    \ interval\n   since that time. A typical setting of this fraction might be 10%.\n\
    \   The calculation to determine if a response has expired is quite\n   simple:\n\
    \         response_is_fresh = (freshness_lifetime > current_age)\n"
- title: 13.2.5 Disambiguating Expiration Values
  contents:
  - "13.2.5 Disambiguating Expiration Values\n   Because expiration values are assigned\
    \ optimistically, it is possible\n   for two caches to contain fresh values for\
    \ the same resource that are\n   different.\n   If a client performing a retrieval\
    \ receives a non-first-hand response\n   for a request that was already fresh\
    \ in its own cache, and the Date\n   header in its existing cache entry is newer\
    \ than the Date on the new\n   response, then the client MAY ignore the response.\
    \ If so, it MAY\n   retry the request with a \"Cache-Control: max-age=0\" directive\
    \ (see\n   section 14.9), to force a check with the origin server.\n   If a cache\
    \ has two fresh responses for the same representation with\n   different validators,\
    \ it MUST use the one with the more recent Date\n   header. This situation may\
    \ arise because the cache is pooling\n   responses from other caches, or because\
    \ a client has asked for a\n   reload or a revalidation of an apparently fresh\
    \ cache entry.\n"
- title: 13.2.6 Disambiguating Multiple Responses
  contents:
  - "13.2.6 Disambiguating Multiple Responses\n   Because a client may be receiving\
    \ responses via multiple paths, so\n   that some responses flow through one set\
    \ of caches and other\n   responses flow through a different set of caches, a\
    \ client may\n   receive responses in an order different from that in which the\
    \ origin\n   server sent them. We would like the client to use the most recently\n\
    \   generated response, even if older responses are still apparently\n   fresh.\n\
    \   Neither the entity tag nor the expiration value can impose an\n   ordering\
    \ on responses, since it is possible that a later response\n   intentionally carries\
    \ an earlier expiration time. However, the\n   HTTP/1.1 specification requires\
    \ the transmission of Date headers on\n   every response, and the Date values\
    \ are ordered to a granularity of\n   one second.\n   When a client tries to revalidate\
    \ a cache entry, and the response it\n   receives contains a Date header that\
    \ appears to be older than the one\n   for the existing entry, then the client\
    \ SHOULD repeat the request\n   unconditionally, and include\n          Cache-Control:\
    \ max-age=0\n   to force any intermediate caches to validate their copies directly\n\
    \   with the origin server, or\n          Cache-Control: no-cache\n   to force\
    \ any intermediate caches to obtain a new copy from the origin\n   server.\n \
    \  If the Date values are equal, then the client may use either response\n   (or\
    \ may, if it is being extremely prudent, request a new response).\n   Servers\
    \ MUST NOT depend on clients being able to choose\n   deterministically between\
    \ responses generated during the same second,\n   if their expiration times overlap.\n"
- title: 13.3 Validation Model
  contents:
  - "13.3 Validation Model\n   When a cache has a stale entry that it would like to\
    \ use as a\n   response to a client's request, it first has to check with the\
    \ origin\n   server (or possibly an intermediate cache with a fresh response)\
    \ to\n   see if its cached entry is still usable. We call this \"validating\"\n\
    \   the cache entry.  Since we do not want to have to pay the overhead of\n  \
    \ retransmitting the full response if the cached entry is good, and we\n   do\
    \ not want to pay the overhead of an extra round trip if the cached\n   entry\
    \ is invalid, the HTTP/1.1 protocol supports the use of\n   conditional methods.\n\
    \   The key protocol features for supporting conditional methods are\n   those\
    \ concerned with \"cache validators.\" When an origin server\n   generates a full\
    \ response, it attaches some sort of validator to it,\n   which is kept with the\
    \ cache entry. When a client (user agent or\n   proxy cache) makes a conditional\
    \ request for a resource for which it\n   has a cache entry, it includes the associated\
    \ validator in the\n   request.\n   The server then checks that validator against\
    \ the current validator\n   for the entity, and, if they match, it responds with\
    \ a special status\n   code (usually, 304 (Not Modified)) and no entity-body.\
    \ Otherwise, it\n   returns a full response (including entity-body). Thus, we\
    \ avoid\n   transmitting the full response if the validator matches, and we avoid\n\
    \   an extra round trip if it does not match.\n     Note: the comparison functions\
    \ used to decide if validators match\n     are defined in section 13.3.3.\n  \
    \ In HTTP/1.1, a conditional request looks exactly the same as a normal\n   request\
    \ for the same resource, except that it carries a special\n   header (which includes\
    \ the validator) that implicitly turns the\n   method (usually, GET) into a conditional.\n\
    \   The protocol includes both positive and negative senses of cache-\n   validating\
    \ conditions. That is, it is possible to request either that\n   a method be performed\
    \ if and only if a validator matches or if and\n   only if no validators match.\n\
    \     Note: a response that lacks a validator may still be cached, and\n     served\
    \ from cache until it expires, unless this is explicitly\n     prohibited by a\
    \ Cache-Control directive. However, a cache cannot do\n     a conditional retrieval\
    \ if it does not have a validator for the\n     entity, which means it will not\
    \ be refreshable after it expires.\n"
- title: 13.3.1 Last-modified Dates
  contents:
  - "13.3.1 Last-modified Dates\n   The Last-Modified entity-header field value is\
    \ often used as a cache\n   validator. In simple terms, a cache entry is considered\
    \ to be valid\n   if the entity has not been modified since the Last-Modified\
    \ value.\n"
- title: 13.3.2 Entity Tag Cache Validators
  contents:
  - "13.3.2 Entity Tag Cache Validators\n   The ETag entity-header field value, an\
    \ entity tag, provides for an\n   \"opaque\" cache validator. This may allow more\
    \ reliable validation in\n   situations where it is inconvenient to store modification\
    \ dates,\n   where the one-second resolution of HTTP date values is not\n   sufficient,\
    \ or where the origin server wishes to avoid certain\n   paradoxes that may arise\
    \ from the use of modification dates.\n   Entity Tags are described in section\
    \ 3.11. The headers used with\n   entity tags are described in sections 14.20,\
    \ 14.25, 14.26 and 14.43.\n"
- title: 13.3.3 Weak and Strong Validators
  contents:
  - "13.3.3 Weak and Strong Validators\n   Since both origin servers and caches will\
    \ compare two validators to\n   decide if they represent the same or different\
    \ entities, one normally\n   would expect that if the entity (the entity-body\
    \ or any entity-\n   headers) changes in any way, then the associated validator\
    \ would\n   change as well.  If this is true, then we call this validator a\n\
    \   \"strong validator.\"\n   However, there may be cases when a server prefers\
    \ to change the\n   validator only on semantically significant changes, and not\
    \ when\n   insignificant aspects of the entity change. A validator that does not\n\
    \   always change when the resource changes is a \"weak validator.\"\n   Entity\
    \ tags are normally \"strong validators,\" but the protocol\n   provides a mechanism\
    \ to tag an entity tag as \"weak.\" One can think of\n   a strong validator as\
    \ one that changes whenever the bits of an entity\n   changes, while a weak value\
    \ changes whenever the meaning of an entity\n   changes.  Alternatively, one can\
    \ think of a strong validator as part\n   of an identifier for a specific entity,\
    \ while a weak validator is\n   part of an identifier for a set of semantically\
    \ equivalent entities.\n     Note: One example of a strong validator is an integer\
    \ that is\n     incremented in stable storage every time an entity is changed.\n\
    \     An entity's modification time, if represented with one-second\n     resolution,\
    \ could be a weak validator, since it is possible that\n     the resource may\
    \ be modified twice during a single second.\n     Support for weak validators\
    \ is optional; however, weak validators\n     allow for more efficient caching\
    \ of equivalent objects; for\n     example, a hit counter on a site is probably\
    \ good enough if it is\n     updated every few days or weeks, and any value during\
    \ that period\n     is likely \"good enough\" to be equivalent.\n     A \"use\"\
    \ of a validator is either when a client generates a request\n     and includes\
    \ the validator in a validating header field, or when a\n     server compares\
    \ two validators.\n   Strong validators are usable in any context. Weak validators\
    \ are only\n   usable in contexts that do not depend on exact equality of an entity.\n\
    \   For example, either kind is usable for a conditional GET of a full\n   entity.\
    \ However, only a strong validator is usable for a sub-range\n   retrieval, since\
    \ otherwise the client may end up with an internally\n   inconsistent entity.\n\
    \   The only function that the HTTP/1.1 protocol defines on validators is\n  \
    \ comparison. There are two validator comparison functions, depending\n   on whether\
    \ the comparison context allows the use of weak validators\n   or not:\n  o  The\
    \ strong comparison function: in order to be considered equal,\n     both validators\
    \ must be identical in every way, and neither may be\n     weak.\n  o  The weak\
    \ comparison function: in order to be considered equal, both\n     validators\
    \ must be identical in every way, but either or both of\n     them may be tagged\
    \ as \"weak\" without affecting the result.\n   The weak comparison function MAY\
    \ be used for simple (non-subrange)\n   GET requests. The strong comparison function\
    \ MUST be used in all\n   other cases.\n   An entity tag is strong unless it is\
    \ explicitly tagged as weak.\n   Section 3.11 gives the syntax for entity tags.\n\
    \   A Last-Modified time, when used as a validator in a request, is\n   implicitly\
    \ weak unless it is possible to deduce that it is strong,\n   using the following\
    \ rules:\n  o  The validator is being compared by an origin server to the actual\n\
    \     current validator for the entity and,\n  o  That origin server reliably\
    \ knows that the associated entity did\n     not change twice during the second\
    \ covered by the presented\n     validator.\n"
- title: or
  contents:
  - "or\n  o  The validator is about to be used by a client in an If-Modified-\n \
    \    Since or If-Unmodified-Since header, because the client has a cache\n   \
    \  entry for the associated entity, and\n  o  That cache entry includes a Date\
    \ value, which gives the time when\n     the origin server sent the original response,\
    \ and\n  o  The presented Last-Modified time is at least 60 seconds before the\n\
    \     Date value.\n"
- title: or
  contents:
  - "or\n  o  The validator is being compared by an intermediate cache to the\n  \
    \   validator stored in its cache entry for the entity, and\n  o  That cache entry\
    \ includes a Date value, which gives the time when\n     the origin server sent\
    \ the original response, and\n  o  The presented Last-Modified time is at least\
    \ 60 seconds before the\n     Date value.\n   This method relies on the fact that\
    \ if two different responses were\n   sent by the origin server during the same\
    \ second, but both had the\n   same Last-Modified time, then at least one of those\
    \ responses would\n   have a Date value equal to its Last-Modified time. The arbitrary\
    \ 60-\n   second limit guards against the possibility that the Date and Last-\n\
    \   Modified values are generated from different clocks, or at somewhat\n   different\
    \ times during the preparation of the response. An\n   implementation may use\
    \ a value larger than 60 seconds, if it is\n   believed that 60 seconds is too\
    \ short.\n   If a client wishes to perform a sub-range retrieval on a value for\n\
    \   which it has only a Last-Modified time and no opaque validator, it\n   may\
    \ do this only if the Last-Modified time is strong in the sense\n   described\
    \ here.\n   A cache or origin server receiving a cache-conditional request, other\n\
    \   than a full-body GET request, MUST use the strong comparison function\n  \
    \ to evaluate the condition.\n   These rules allow HTTP/1.1 caches and clients\
    \ to safely perform sub-\n   range retrievals on values that have been obtained\
    \ from HTTP/1.0\n   servers.\n"
- title: 13.3.4 Rules for When to Use Entity Tags and Last-modified Dates
  contents:
  - "13.3.4 Rules for When to Use Entity Tags and Last-modified Dates\n   We adopt\
    \ a set of rules and recommendations for origin servers,\n   clients, and caches\
    \ regarding when various validator types should be\n   used, and for what purposes.\n\
    \   HTTP/1.1 origin servers:\n  o  SHOULD send an entity tag validator unless\
    \ it is not feasible to\n     generate one.\n  o  MAY send a weak entity tag instead\
    \ of a strong entity tag, if\n     performance considerations support the use\
    \ of weak entity tags, or\n     if it is unfeasible to send a strong entity tag.\n\
    \  o  SHOULD send a Last-Modified value if it is feasible to send one,\n     unless\
    \ the risk of a breakdown in semantic transparency that could\n     result from\
    \ using this date in an If-Modified-Since header would\n     lead to serious problems.\n\
    \   In other words, the preferred behavior for an HTTP/1.1 origin server\n   is\
    \ to send both a strong entity tag and a Last-Modified value.\n   In order to\
    \ be legal, a strong entity tag MUST change whenever the\n   associated entity\
    \ value changes in any way. A weak entity tag SHOULD\n   change whenever the associated\
    \ entity changes in a semantically\n   significant way.\n     Note: in order to\
    \ provide semantically transparent caching, an\n     origin server must avoid\
    \ reusing a specific strong entity tag value\n     for two different entities,\
    \ or reusing a specific weak entity tag\n     value for two semantically different\
    \ entities. Cache entries may\n     persist for arbitrarily long periods, regardless\
    \ of expiration\n     times, so it may be inappropriate to expect that a cache\
    \ will never\n     again attempt to validate an entry using a validator that it\n\
    \     obtained at some point in the past.\n   HTTP/1.1 clients:\n     o  If an\
    \ entity tag has been provided by the origin server, MUST\n        use that entity\
    \ tag in any cache-conditional request (using\n        If-Match or If-None-Match).\n\
    \     o  If only a Last-Modified value has been provided by the origin\n     \
    \   server, SHOULD use that value in non-subrange cache-conditional\n        requests\
    \ (using If-Modified-Since).\n     o  If only a Last-Modified value has been provided\
    \ by an HTTP/1.0\n        origin server, MAY use that value in subrange cache-conditional\n\
    \        requests (using If-Unmodified-Since:). The user agent should\n      \
    \  provide a way to disable this, in case of difficulty.\n     o  If both an entity\
    \ tag and a Last-Modified value have been\n        provided by the origin server,\
    \ SHOULD use both validators in\n        cache-conditional requests. This allows\
    \ both HTTP/1.0 and\n        HTTP/1.1 caches to respond appropriately.\n   An\
    \ HTTP/1.1 cache, upon receiving a request, MUST use the most\n   restrictive\
    \ validator when deciding whether the client's cache entry\n   matches the cache's\
    \ own cache entry. This is only an issue when the\n   request contains both an\
    \ entity tag and a last-modified-date\n   validator (If-Modified-Since or If-Unmodified-Since).\n\
    \     A note on rationale: The general principle behind these rules is\n     that\
    \ HTTP/1.1 servers and clients should transmit as much non-\n     redundant information\
    \ as is available in their responses and\n     requests. HTTP/1.1 systems receiving\
    \ this information will make the\n     most conservative assumptions about the\
    \ validators they receive.\n     HTTP/1.0 clients and caches will ignore entity\
    \ tags. Generally,\n     last-modified values received or used by these systems\
    \ will support\n     transparent and efficient caching, and so HTTP/1.1 origin\
    \ servers\n     should provide Last-Modified values. In those rare cases where\
    \ the\n     use of a Last-Modified value as a validator by an HTTP/1.0 system\n\
    \     could result in a serious problem, then HTTP/1.1 origin servers\n     should\
    \ not provide one.\n"
- title: 13.3.5 Non-validating Conditionals
  contents:
  - "13.3.5 Non-validating Conditionals\n   The principle behind entity tags is that\
    \ only the service author\n   knows the semantics of a resource well enough to\
    \ select an\n   appropriate cache validation mechanism, and the specification\
    \ of any\n   validator comparison function more complex than byte-equality would\n\
    \   open up a can of worms.  Thus, comparisons of any other headers\n   (except\
    \ Last-Modified, for compatibility with HTTP/1.0) are never\n   used for purposes\
    \ of validating a cache entry.\n"
- title: 13.4 Response Cachability
  contents:
  - "13.4 Response Cachability\n   Unless specifically constrained by a Cache-Control\
    \ (section 14.9)\n   directive, a caching system may always store a successful\
    \ response\n   (see section 13.8) as a cache entry, may return it without validation\n\
    \   if it is fresh, and may return it after successful validation. If\n   there\
    \ is neither a cache validator nor an explicit expiration time\n   associated\
    \ with a response, we do not expect it to be cached, but\n   certain caches may\
    \ violate this expectation (for example, when little\n   or no network connectivity\
    \ is available). A client can usually detect\n   that such a response was taken\
    \ from a cache by comparing the Date\n   header to the current time.\n     Note\
    \ that some HTTP/1.0 caches are known to violate this\n     expectation without\
    \ providing any Warning.\n   However, in some cases it may be inappropriate for\
    \ a cache to retain\n   an entity, or to return it in response to a subsequent\
    \ request. This\n   may be because absolute semantic transparency is deemed necessary\
    \ by\n   the service author, or because of security or privacy considerations.\n\
    \   Certain Cache-Control directives are therefore provided so that the\n   server\
    \ can indicate that certain resource entities, or portions\n   thereof, may not\
    \ be cached regardless of other considerations.\n   Note that section 14.8 normally\
    \ prevents a shared cache from saving\n   and returning a response to a previous\
    \ request if that request\n   included an Authorization header.\n   A response\
    \ received with a status code of 200, 203, 206, 300, 301 or\n   410 may be stored\
    \ by a cache and used in reply to a subsequent\n   request, subject to the expiration\
    \ mechanism, unless a Cache-Control\n   directive prohibits caching. However,\
    \ a cache that does not support\n   the Range and Content-Range headers MUST NOT\
    \ cache 206 (Partial\n   Content) responses.\n   A response received with any\
    \ other status code MUST NOT be returned\n   in a reply to a subsequent request\
    \ unless there are Cache-Control\n   directives or another header(s) that explicitly\
    \ allow it. For\n   example, these include the following: an Expires header (section\n\
    \   14.21); a \"max-age\", \"must-revalidate\", \"proxy-revalidate\", \"public\"\
    \n   or \"private\" Cache-Control directive (section 14.9).\n"
- title: 13.5 Constructing Responses From Caches
  contents:
  - "13.5 Constructing Responses From Caches\n   The purpose of an HTTP cache is to\
    \ store information received in\n   response to requests, for use in responding\
    \ to future requests. In\n   many cases, a cache simply returns the appropriate\
    \ parts of a\n   response to the requester. However, if the cache holds a cache\
    \ entry\n   based on a previous response, it may have to combine parts of a new\n\
    \   response with what is held in the cache entry.\n"
- title: 13.5.1 End-to-end and Hop-by-hop Headers
  contents:
  - "13.5.1 End-to-end and Hop-by-hop Headers\n   For the purpose of defining the\
    \ behavior of caches and non-caching\n   proxies, we divide HTTP headers into\
    \ two categories:\n  o  End-to-end headers, which must be transmitted to the\n\
    \     ultimate recipient of a request or response. End-to-end\n     headers in\
    \ responses must be stored as part of a cache entry\n     and transmitted in any\
    \ response formed from a cache entry.\n  o  Hop-by-hop headers, which are meaningful\
    \ only for a single\n     transport-level connection, and are not stored by caches\
    \ or\n     forwarded by proxies.\n   The following HTTP/1.1 headers are hop-by-hop\
    \ headers:\n     o  Connection\n     o  Keep-Alive\n     o  Public\n     o  Proxy-Authenticate\n\
    \     o  Transfer-Encoding\n     o  Upgrade\n   All other headers defined by HTTP/1.1\
    \ are end-to-end headers.\n   Hop-by-hop headers introduced in future versions\
    \ of HTTP MUST be\n   listed in a Connection header, as described in section 14.10.\n"
- title: 13.5.2 Non-modifiable Headers
  contents:
  - "13.5.2 Non-modifiable Headers\n   Some features of the HTTP/1.1 protocol, such\
    \ as Digest\n   Authentication, depend on the value of certain end-to-end headers.\
    \ A\n   cache or non-caching proxy SHOULD NOT modify an end-to-end header\n  \
    \ unless the definition of that header requires or specifically allows\n   that.\n\
    \   A cache or non-caching proxy MUST NOT modify any of the following\n   fields\
    \ in a request or response, nor may it add any of these fields\n   if not already\
    \ present:\n     o  Content-Location\n     o  ETag\n     o  Expires\n     o  Last-Modified\n\
    \   A cache or non-caching proxy MUST NOT modify or add any of the\n   following\
    \ fields in a response that contains the no-transform Cache-\n   Control directive,\
    \ or in any request:\n     o  Content-Encoding\n     o  Content-Length\n     o\
    \  Content-Range\n     o  Content-Type\n   A cache or non-caching proxy MAY modify\
    \ or add these fields in a\n   response that does not include no-transform, but\
    \ if it does so, it\n   MUST add a Warning 14 (Transformation applied) if one\
    \ does not\n   already appear in the response.\n     Warning: unnecessary modification\
    \ of end-to-end headers may cause\n     authentication failures if stronger authentication\
    \ mechanisms are\n     introduced in later versions of HTTP. Such authentication\n\
    \     mechanisms may rely on the values of header fields not listed here.\n"
- title: 13.5.3 Combining Headers
  contents:
  - "13.5.3 Combining Headers\n   When a cache makes a validating request to a server,\
    \ and the server\n   provides a 304 (Not Modified) response, the cache must construct\
    \ a\n   response to send to the requesting client. The cache uses the\n   entity-body\
    \ stored in the cache entry as the entity-body of this\n   outgoing response.\
    \ The end-to-end headers stored in the cache entry\n   are used for the constructed\
    \ response, except that any end-to-end\n   headers provided in the 304 response\
    \ MUST replace the corresponding\n   headers from the cache entry. Unless the\
    \ cache decides to remove the\n   cache entry, it MUST also replace the end-to-end\
    \ headers stored with\n   the cache entry with corresponding headers received\
    \ in the incoming\n   response.\n   In other words, the set of end-to-end headers\
    \ received in the\n   incoming response overrides all corresponding end-to-end\
    \ headers\n   stored with the cache entry. The cache may add Warning headers (see\n\
    \   section 14.45) to this set.\n   If a header field-name in the incoming response\
    \ matches more than one\n   header in the cache entry, all such old headers are\
    \ replaced.\n     Note: this rule allows an origin server to use a 304 (Not Modified)\n\
    \     response to update any header associated with a previous response\n    \
    \ for the same entity, although it might not always be meaningful or\n     correct\
    \ to do so. This rule does not allow an origin server to use\n     a 304 (not\
    \ Modified) response to entirely delete a header that it\n     had provided with\
    \ a previous response.\n"
- title: 13.5.4 Combining Byte Ranges
  contents:
  - "13.5.4 Combining Byte Ranges\n   A response may transfer only a subrange of the\
    \ bytes of an entity-\n   body, either because the request included one or more\
    \ Range\n   specifications, or because a connection was broken prematurely. After\n\
    \   several such transfers, a cache may have received several ranges of\n   the\
    \ same entity-body.\n   If a cache has a stored non-empty set of subranges for\
    \ an entity, and\n   an incoming response transfers another subrange, the cache\
    \ MAY\n   combine the new subrange with the existing set if both the following\n\
    \   conditions are met:\n     o  Both the incoming response and the cache entry\
    \ must have a cache\n        validator.\n     o  The two cache validators must\
    \ match using the strong comparison\n        function (see section 13.3.3).\n\
    \   If either requirement is not meant, the cache must use only the most\n   recent\
    \ partial response (based on the Date values transmitted with\n   every response,\
    \ and using the incoming response if these values are\n   equal or missing), and\
    \ must discard the other partial information.\n"
- title: 13.6 Caching Negotiated Responses
  contents:
  - "13.6 Caching Negotiated Responses\n   Use of server-driven content negotiation\
    \ (section 12), as indicated\n   by the presence of a Vary header field in a response,\
    \ alters the\n   conditions and procedure by which a cache can use the response\
    \ for\n   subsequent requests.\n   A server MUST use the Vary header field (section\
    \ 14.43) to inform a\n   cache of what header field dimensions are used to select\
    \ among\n   multiple representations of a cachable response. A cache may use the\n\
    \   selected representation (the entity included with that particular\n   response)\
    \ for replying to subsequent requests on that resource only\n   when the subsequent\
    \ requests have the same or equivalent values for\n   all header fields specified\
    \ in the Vary response-header. Requests\n   with a different value for one or\
    \ more of those header fields would\n   be forwarded toward the origin server.\n\
    \   If an entity tag was assigned to the representation, the forwarded\n   request\
    \ SHOULD be conditional and include the entity tags in an If-\n   None-Match header\
    \ field from all its cache entries for the Request-\n   URI. This conveys to the\
    \ server the set of entities currently held by\n   the cache, so that if any one\
    \ of these entities matches the requested\n   entity, the server can use the ETag\
    \ header in its 304 (Not Modified)\n   response to tell the cache which entry\
    \ is appropriate. If the\n   entity-tag of the new response matches that of an\
    \ existing entry, the\n   new response SHOULD be used to update the header fields\
    \ of the\n   existing entry, and the result MUST be returned to the client.\n\
    \   The Vary header field may also inform the cache that the\n   representation\
    \ was selected using criteria not limited to the\n   request-headers; in this\
    \ case, a cache MUST NOT use the response in a\n   reply to a subsequent request\
    \ unless the cache relays the new request\n   to the origin server in a conditional\
    \ request and the server responds\n   with 304 (Not Modified), including an entity\
    \ tag or Content-Location\n   that indicates which entity should be used.\n  \
    \ If any of the existing cache entries contains only partial content\n   for the\
    \ associated entity, its entity-tag SHOULD NOT be included in\n   the If-None-Match\
    \ header unless the request is for a range that would\n   be fully satisfied by\
    \ that entry.\n   If a cache receives a successful response whose Content-Location\n\
    \   field matches that of an existing cache entry for the same Request-\n   URI,\
    \ whose entity-tag differs from that of the existing entry, and\n   whose Date\
    \ is more recent than that of the existing entry, the\n   existing entry SHOULD\
    \ NOT be returned in response to future requests,\n   and should be deleted from\
    \ the cache.\n"
- title: 13.7 Shared and Non-Shared Caches
  contents:
  - "13.7 Shared and Non-Shared Caches\n   For reasons of security and privacy, it\
    \ is necessary to make a\n   distinction between \"shared\" and \"non-shared\"\
    \ caches. A non-shared\n   cache is one that is accessible only to a single user.\
    \ Accessibility\n   in this case SHOULD be enforced by appropriate security mechanisms.\n\
    \   All other caches are considered to be \"shared.\" Other sections of\n   this\
    \ specification place certain constraints on the operation of\n   shared caches\
    \ in order to prevent loss of privacy or failure of\n   access controls.\n"
- title: 13.8 Errors or Incomplete Response Cache Behavior
  contents:
  - "13.8 Errors or Incomplete Response Cache Behavior\n   A cache that receives an\
    \ incomplete response (for example, with fewer\n   bytes of data than specified\
    \ in a Content-Length header) may store\n   the response. However, the cache MUST\
    \ treat this as a partial\n   response.  Partial responses may be combined as\
    \ described in section\n   13.5.4; the result might be a full response or might\
    \ still be\n   partial. A cache MUST NOT return a partial response to a client\n\
    \   without explicitly marking it as such, using the 206 (Partial\n   Content)\
    \ status code. A cache MUST NOT return a partial response\n   using a status code\
    \ of 200 (OK).\n   If a cache receives a 5xx response while attempting to revalidate\
    \ an\n   entry, it may either forward this response to the requesting client,\n\
    \   or act as if the server failed to respond. In the latter case, it MAY\n  \
    \ return a previously received response unless the cached entry\n   includes the\
    \ \"must-revalidate\" Cache-Control directive (see section\n   14.9).\n"
- title: 13.9 Side Effects of GET and HEAD
  contents:
  - "13.9 Side Effects of GET and HEAD\n   Unless the origin server explicitly prohibits\
    \ the caching of their\n   responses, the application of GET and HEAD methods\
    \ to any resources\n   SHOULD NOT have side effects that would lead to erroneous\
    \ behavior if\n   these responses are taken from a cache. They may still have\
    \ side\n   effects, but a cache is not required to consider such side effects\
    \ in\n   its caching decisions. Caches are always expected to observe an\n   origin\
    \ server's explicit restrictions on caching.\n   We note one exception to this\
    \ rule: since some applications have\n   traditionally used GETs and HEADs with\
    \ query URLs (those containing a\n   \"?\" in the rel_path part) to perform operations\
    \ with significant side\n   effects, caches MUST NOT treat responses to such URLs\
    \ as fresh unless\n   the server provides an explicit expiration time. This specifically\n\
    \   means that responses from HTTP/1.0 servers for such URIs should not\n   be\
    \ taken from a cache. See section 9.1.1 for related information.\n"
- title: 13.10 Invalidation After Updates or Deletions
  contents:
  - "13.10 Invalidation After Updates or Deletions\n   The effect of certain methods\
    \ at the origin server may cause one or\n   more existing cache entries to become\
    \ non-transparently invalid. That\n   is, although they may continue to be \"\
    fresh,\" they do not accurately\n   reflect what the origin server would return\
    \ for a new request.\n   There is no way for the HTTP protocol to guarantee that\
    \ all such\n   cache entries are marked invalid. For example, the request that\n\
    \   caused the change at the origin server may not have gone through the\n   proxy\
    \ where a cache entry is stored. However, several rules help\n   reduce the likelihood\
    \ of erroneous behavior.\n   In this section, the phrase \"invalidate an entity\"\
    \ means that the\n   cache should either remove all instances of that entity from\
    \ its\n   storage, or should mark these as \"invalid\" and in need of a mandatory\n\
    \   revalidation before they can be returned in response to a subsequent\n   request.\n\
    \   Some HTTP methods may invalidate an entity. This is either the entity\n  \
    \ referred to by the Request-URI, or by the Location or Content-\n   Location\
    \ response-headers (if present). These methods are:\n     o  PUT\n     o  DELETE\n\
    \     o  POST\n   In order to prevent denial of service attacks, an invalidation\
    \ based\n   on the URI in a Location or Content-Location header MUST only be\n\
    \   performed if the host part is the same as in the Request-URI.\n"
- title: 13.11 Write-Through Mandatory
  contents:
  - "13.11 Write-Through Mandatory\n   All methods that may be expected to cause modifications\
    \ to the origin\n   server's resources MUST be written through to the origin server.\
    \ This\n   currently includes all methods except for GET and HEAD. A cache MUST\n\
    \   NOT reply to such a request from a client before having transmitted\n   the\
    \ request to the inbound server, and having received a\n   corresponding response\
    \ from the inbound server. This does not prevent\n   a cache from sending a 100\
    \ (Continue) response before the inbound\n   server has replied.\n   The alternative\
    \ (known as \"write-back\" or \"copy-back\" caching) is not\n   allowed in HTTP/1.1,\
    \ due to the difficulty of providing consistent\n   updates and the problems arising\
    \ from server, cache, or network\n   failure prior to write-back.\n"
- title: 13.12 Cache Replacement
  contents:
  - "13.12 Cache Replacement\n   If a new cachable (see sections 14.9.2, 13.2.5, 13.2.6\
    \ and 13.8)\n   response is received from a resource while any existing responses\
    \ for\n   the same resource are cached, the cache SHOULD use the new response\n\
    \   to reply to the current request. It may insert it into cache storage\n   and\
    \ may, if it meets all other requirements, use it to respond to any\n   future\
    \ requests that would previously have caused the old response to\n   be returned.\
    \ If it inserts the new response into cache storage it\n   should follow the rules\
    \ in section 13.5.3.\n     Note: a new response that has an older Date header\
    \ value than\n     existing cached responses is not cachable.\n"
- title: 13.13 History Lists
  contents:
  - "13.13 History Lists\n   User agents often have history mechanisms, such as \"\
    Back\" buttons and\n   history lists, which can be used to redisplay an entity\
    \ retrieved\n   earlier in a session.\n   History mechanisms and caches are different.\
    \ In particular history\n   mechanisms SHOULD NOT try to show a semantically transparent\
    \ view of\n   the current state of a resource. Rather, a history mechanism is\
    \ meant\n   to show exactly what the user saw at the time when the resource was\n\
    \   retrieved.\n   By default, an expiration time does not apply to history mechanisms.\n\
    \   If the entity is still in storage, a history mechanism should display\n  \
    \ it even if the entity has expired, unless the user has specifically\n   configured\
    \ the agent to refresh expired history documents.\n   This should not be construed\
    \ to prohibit the history mechanism from\n   telling the user that a view may\
    \ be stale.\n     Note: if history list mechanisms unnecessarily prevent users\
    \ from\n     viewing stale resources, this will tend to force service authors\
    \ to\n     avoid using HTTP expiration controls and cache controls when they\n\
    \     would otherwise like to. Service authors may consider it important\n   \
    \  that users not be presented with error messages or warning messages\n     when\
    \ they use navigation controls (such as BACK) to view previously\n     fetched\
    \ resources. Even though sometimes such resources ought not\n     to cached, or\
    \ ought to expire quickly, user interface\n     considerations may force service\
    \ authors to resort to other means\n     of preventing caching (e.g. \"once-only\"\
    \ URLs) in order not to\n     suffer the effects of improperly functioning history\
    \ mechanisms.\n"
- title: 14 Header Field Definitions
  contents:
  - "14 Header Field Definitions\n   This section defines the syntax and semantics\
    \ of all standard\n   HTTP/1.1 header fields. For entity-header fields, both sender\
    \ and\n   recipient refer to either the client or the server, depending on who\n\
    \   sends and who receives the entity.\n"
- title: 14.1 Accept
  contents:
  - "14.1 Accept\n   The Accept request-header field can be used to specify certain\
    \ media\n   types which are acceptable for the response. Accept headers can be\n\
    \   used to indicate that the request is specifically limited to a small\n   set\
    \ of desired types, as in the case of a request for an in-line\n   image.\n  \
    \        Accept         = \"Accept\" \":\"\n                           #( media-range\
    \ [ accept-params ] )\n          media-range    = ( \"*/*\"\n                \
    \           | ( type \"/\" \"*\" )\n                           | ( type \"/\"\
    \ subtype )\n                           ) *( \";\" parameter )\n          accept-params\
    \  = \";\" \"q\" \"=\" qvalue *( accept-extension )\n          accept-extension\
    \ = \";\" token [ \"=\" ( token | quoted-string ) ]\n   The asterisk \"*\" character\
    \ is used to group media types into ranges,\n   with \"*/*\" indicating all media\
    \ types and \"type/*\" indicating all\n   subtypes of that type. The media-range\
    \ MAY include media type\n   parameters that are applicable to that range.\n \
    \  Each media-range MAY be followed by one or more accept-params,\n   beginning\
    \ with the \"q\" parameter for indicating a relative quality\n   factor. The first\
    \ \"q\" parameter (if any) separates the media-range\n   parameter(s) from the\
    \ accept-params. Quality factors allow the user\n   or user agent to indicate\
    \ the relative degree of preference for that\n   media-range, using the qvalue\
    \ scale from 0 to 1 (section 3.9). The\n   default value is q=1.\n     Note: Use\
    \ of the \"q\" parameter name to separate media type\n     parameters from Accept\
    \ extension parameters is due to historical\n     practice.  Although this prevents\
    \ any media type parameter named\n     \"q\" from being used with a media range,\
    \ such an event is believed\n     to be unlikely given the lack of any \"q\" parameters\
    \ in the IANA\n     media type registry and the rare usage of any media type parameters\n\
    \     in Accept. Future media types should be discouraged from\n     registering\
    \ any parameter named \"q\".\n   The example\n          Accept: audio/*; q=0.2,\
    \ audio/basic\n   SHOULD be interpreted as \"I prefer audio/basic, but send me\
    \ any audio\n   type if it is the best available after an 80% mark-down in quality.\"\
    \n   If no Accept header field is present, then it is assumed that the\n   client\
    \ accepts all media types. If an Accept header field is present,\n   and if the\
    \ server cannot send a response which is acceptable\n   according to the combined\
    \ Accept field value, then the server SHOULD\n   send a 406 (not acceptable) response.\n\
    \   A more elaborate example is\n          Accept: text/plain; q=0.5, text/html,\n\
    \                  text/x-dvi; q=0.8, text/x-c\n   Verbally, this would be interpreted\
    \ as \"text/html and text/x-c are\n   the preferred media types, but if they do\
    \ not exist, then send the\n   text/x-dvi entity, and if that does not exist,\
    \ send the text/plain\n   entity.\"\n   Media ranges can be overridden by more\
    \ specific media ranges or\n   specific media types. If more than one media range\
    \ applies to a given\n   type, the most specific reference has precedence. For\
    \ example,\n          Accept: text/*, text/html, text/html;level=1, */*\n   have\
    \ the following precedence:\n          1) text/html;level=1\n          2) text/html\n\
    \          3) text/*\n          4) */*\n   The media type quality factor associated\
    \ with a given type is\n   determined by finding the media range with the highest\
    \ precedence\n   which matches that type. For example,\n          Accept: text/*;q=0.3,\
    \ text/html;q=0.7, text/html;level=1,\n                  text/html;level=2;q=0.4,\
    \ */*;q=0.5\n   would cause the following values to be associated:\n         \
    \ text/html;level=1         = 1\n          text/html                 = 0.7\n \
    \         text/plain                = 0.3\n          image/jpeg              \
    \  = 0.5\n          text/html;level=2         = 0.4\n          text/html;level=3\
    \         = 0.7\n     Note: A user agent may be provided with a default set of\
    \ quality\n     values for certain media ranges. However, unless the user agent\
    \ is\n     a closed system which cannot interact with other rendering agents,\n\
    \     this default set should be configurable by the user.\n"
- title: 14.2 Accept-Charset
  contents:
  - "14.2 Accept-Charset\n   The Accept-Charset request-header field can be used to\
    \ indicate what\n   character sets are acceptable for the response. This field\
    \ allows\n   clients capable of understanding more comprehensive or special-\n\
    \   purpose character sets to signal that capability to a server which is\n  \
    \ capable of representing documents in those character sets. The ISO-\n   8859-1\
    \ character set can be assumed to be acceptable to all user\n   agents.\n    \
    \      Accept-Charset = \"Accept-Charset\" \":\"\n                    1#( charset\
    \ [ \";\" \"q\" \"=\" qvalue ] )\n   Character set values are described in section\
    \ 3.4. Each charset may\n   be given an associated quality value which represents\
    \ the user's\n   preference for that charset. The default value is q=1. An example\
    \ is\n          Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n   If no Accept-Charset\
    \ header is present, the default is that any\n   character set is acceptable.\
    \ If an Accept-Charset header is present,\n   and if the server cannot send a\
    \ response which is acceptable\n   according to the Accept-Charset header, then\
    \ the server SHOULD send\n   an error response with the 406 (not acceptable) status\
    \ code, though\n   the sending of an unacceptable response is also allowed.\n"
- title: 14.3 Accept-Encoding
  contents:
  - "14.3 Accept-Encoding\n   The Accept-Encoding request-header field is similar\
    \ to Accept, but\n   restricts the content-coding values (section 14.12) which\
    \ are\n   acceptable in the response.\n          Accept-Encoding  = \"Accept-Encoding\"\
    \ \":\"\n                                    #( content-coding )\n   An example\
    \ of its use is\n          Accept-Encoding: compress, gzip\n   If no Accept-Encoding\
    \ header is present in a request, the server MAY\n   assume that the client will\
    \ accept any content coding. If an Accept-\n   Encoding header is present, and\
    \ if the server cannot send a response\n   which is acceptable according to the\
    \ Accept-Encoding header, then the\n   server SHOULD send an error response with\
    \ the 406 (Not Acceptable)\n   status code.\n   An empty Accept-Encoding value\
    \ indicates none are acceptable.\n"
- title: 14.4 Accept-Language
  contents:
  - "14.4 Accept-Language\n   The Accept-Language request-header field is similar\
    \ to Accept, but\n   restricts the set of natural languages that are preferred\
    \ as a\n   response to the request.\n          Accept-Language = \"Accept-Language\"\
    \ \":\"\n                            1#( language-range [ \";\" \"q\" \"=\" qvalue\
    \ ] )\n          language-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\"\
    \ )\n   Each language-range MAY be given an associated quality value which\n \
    \  represents an estimate of the user's preference for the languages\n   specified\
    \ by that range. The quality value defaults to \"q=1\". For\n   example,\n   \
    \       Accept-Language: da, en-gb;q=0.8, en;q=0.7\n   would mean: \"I prefer\
    \ Danish, but will accept British English and\n   other types of English.\" A\
    \ language-range matches a language-tag if\n   it exactly equals the tag, or if\
    \ it exactly equals a prefix of the\n   tag such that the first tag character\
    \ following the prefix is \"-\".\n   The special range \"*\", if present in the\
    \ Accept-Language field,\n   matches every tag not matched by any other range\
    \ present in the\n   Accept-Language field.\n     Note: This use of a prefix matching\
    \ rule does not imply that\n     language tags are assigned to languages in such\
    \ a way that it is\n     always true that if a user understands a language with\
    \ a certain\n     tag, then this user will also understand all languages with\
    \ tags\n     for which this tag is a prefix. The prefix rule simply allows the\n\
    \     use of prefix tags if this is the case.\n   The language quality factor\
    \ assigned to a language-tag by the\n   Accept-Language field is the quality value\
    \ of the longest language-\n   range in the field that matches the language-tag.\
    \ If no language-\n   range in the field matches the tag, the language quality\
    \ factor\n   assigned is 0. If no Accept-Language header is present in the\n \
    \  request, the server SHOULD assume that all languages are equally\n   acceptable.\
    \ If an Accept-Language header is present, then all\n   languages which are assigned\
    \ a quality factor greater than 0 are\n   acceptable.\n   It may be contrary to\
    \ the privacy expectations of the user to send an\n   Accept-Language header with\
    \ the complete linguistic preferences of\n   the user in every request. For a\
    \ discussion of this issue, see\n   section 15.7.\n     Note: As intelligibility\
    \ is highly dependent on the individual\n     user, it is recommended that client\
    \ applications make the choice of\n     linguistic preference available to the\
    \ user. If the choice is not\n     made available, then the Accept-Language header\
    \ field must not be\n     given in the request.\n"
- title: 14.5 Accept-Ranges
  contents:
  - "14.5 Accept-Ranges\n   The Accept-Ranges response-header field allows the server\
    \ to indicate\n   its acceptance of range requests for a resource:\n         \
    \ Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\n          acceptable-ranges\
    \ = 1#range-unit | \"none\"\n   Origin servers that accept byte-range requests\
    \ MAY send\n          Accept-Ranges: bytes\n   but are not required to do so.\
    \ Clients MAY generate byte-range\n   requests without having received this header\
    \ for the resource\n   involved.\n   Servers that do not accept any kind of range\
    \ request for a  resource\n   MAY send\n          Accept-Ranges: none\n   to advise\
    \ the client not to attempt a range request.\n"
- title: 14.6 Age
  contents:
  - "14.6 Age\n   The Age response-header field conveys the sender's estimate of the\n\
    \   amount of time since the response (or its revalidation) was generated\n  \
    \ at the origin server. A cached response is \"fresh\" if its age does\n   not\
    \ exceed its freshness lifetime. Age values are calculated as\n   specified in\
    \ section 13.2.3.\n           Age = \"Age\" \":\" age-value\n           age-value\
    \ = delta-seconds\n   Age values are non-negative decimal integers, representing\
    \ time in\n   seconds.\n   If a cache receives a value larger than the largest\
    \ positive integer\n   it can represent, or if any of its age calculations overflows,\
    \ it\n   MUST transmit an Age header with a value of 2147483648 (2^31).\n   HTTP/1.1\
    \ caches MUST send an Age header in every response. Caches\n   SHOULD use an arithmetic\
    \ type of at least 31 bits of range.\n"
- title: 14.7 Allow
  contents:
  - "14.7 Allow\n   The Allow entity-header field lists the set of methods supported\
    \ by\n   the resource identified by the Request-URI. The purpose of this field\n\
    \   is strictly to inform the recipient of valid methods associated with\n   the\
    \ resource. An Allow header field MUST be present in a 405 (Method\n   Not Allowed)\
    \ response.\n          Allow          = \"Allow\" \":\" 1#method\n   Example of\
    \ use:\n          Allow: GET, HEAD, PUT\n   This field cannot prevent a client\
    \ from trying other methods.\n   However, the indications given by the Allow header\
    \ field value SHOULD\n   be followed. The actual set of allowed methods is defined\
    \ by the\n   origin server at the time of each request.\n   The Allow header field\
    \ MAY be provided with a PUT request to\n   recommend the methods to be supported\
    \ by the new or modified\n   resource. The server is not required to support these\
    \ methods and\n   SHOULD include an Allow header in the response giving the actual\n\
    \   supported methods.\n   A proxy MUST NOT modify the Allow header field even\
    \ if it does not\n   understand all the methods specified, since the user agent\
    \ MAY have\n   other means of communicating with the origin server.\n   The Allow\
    \ header field does not indicate what methods are implemented\n   at the server\
    \ level. Servers MAY use the Public response-header field\n   (section 14.35)\
    \ to describe what methods are implemented on the\n   server as a whole.\n"
- title: 14.8 Authorization
  contents:
  - "14.8 Authorization\n   A user agent that wishes to authenticate itself with a\
    \ server--\n   usually, but not necessarily, after receiving a 401 response--MAY\
    \ do\n   so by including an Authorization request-header field with the\n   request.\
    \ The Authorization field value consists of credentials\n   containing the authentication\
    \ information of the user agent for the\n   realm of the resource being requested.\n\
    \          Authorization  = \"Authorization\" \":\" credentials\n   HTTP access\
    \ authentication is described in section 11. If a request\n   is authenticated\
    \ and a realm specified, the same credentials SHOULD\n   be valid for all other\
    \ requests within this realm.\n   When a shared cache (see section 13.7) receives\
    \ a request containing\n   an Authorization field, it MUST NOT return the corresponding\
    \ response\n   as a reply to any other request, unless one of the following specific\n\
    \   exceptions holds:\n     1. If the response includes the \"proxy-revalidate\"\
    \ Cache-Control\n        directive, the cache MAY use that response in replying\
    \ to a\n        subsequent request, but a proxy cache MUST first revalidate it\
    \ with\n        the origin server, using the request-headers from the new request\n\
    \        to allow the origin server to authenticate the new request.\n     2.\
    \ If the response includes the \"must-revalidate\" Cache-Control\n        directive,\
    \ the cache MAY use that response in replying to a\n        subsequent request,\
    \ but all caches MUST first revalidate it with\n        the origin server, using\
    \ the request-headers from the new request\n        to allow the origin server\
    \ to authenticate the new request.\n     3. If the response includes the \"public\"\
    \ Cache-Control directive, it\n        may be returned in reply to any subsequent\
    \ request.\n"
- title: 14.9 Cache-Control
  contents:
  - "14.9 Cache-Control\n   The Cache-Control general-header field is used to specify\
    \ directives\n   that MUST be obeyed by all caching mechanisms along the\n   request/response\
    \ chain. The directives specify behavior intended to\n   prevent caches from adversely\
    \ interfering with the request or\n   response. These directives typically override\
    \ the default caching\n   algorithms. Cache directives are unidirectional in that\
    \ the presence\n   of a directive in a request does not imply that the same directive\n\
    \   should be given in the response.\n     Note that HTTP/1.0 caches may not implement\
    \ Cache-Control and may\n     only implement Pragma: no-cache (see section 14.32).\n\
    \   Cache directives must be passed through by a proxy or gateway\n   application,\
    \ regardless of their significance to that application,\n   since the directives\
    \ may be applicable to all recipients along the\n   request/response chain. It\
    \ is not possible to specify a cache-\n   directive for a specific cache.\n  \
    \        Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\n       \
    \   cache-directive = cache-request-directive\n                          | cache-response-directive\n\
    \          cache-request-directive =\n                            \"no-cache\"\
    \ [ \"=\" <\"> 1#field-name <\"> ]\n                          | \"no-store\"\n\
    \                          | \"max-age\" \"=\" delta-seconds\n               \
    \           | \"max-stale\" [ \"=\" delta-seconds ]\n                        \
    \  | \"min-fresh\" \"=\" delta-seconds\n                          | \"only-if-cached\"\
    \n                          | cache-extension\n          cache-response-directive\
    \ =\n                            \"public\"\n                          | \"private\"\
    \ [ \"=\" <\"> 1#field-name <\"> ]\n                          | \"no-cache\" [\
    \ \"=\" <\"> 1#field-name <\"> ]\n                          | \"no-store\"\n \
    \                         | \"no-transform\"\n                          | \"must-revalidate\"\
    \n                          | \"proxy-revalidate\"\n                         \
    \ | \"max-age\" \"=\" delta-seconds\n                          | cache-extension\n\
    \          cache-extension = token [ \"=\" ( token | quoted-string ) ]\n   When\
    \ a directive appears without any 1#field-name parameter, the\n   directive applies\
    \ to the entire request or response. When such a\n   directive appears with a\
    \ 1#field-name parameter, it applies only to\n   the named field or fields, and\
    \ not to the rest of the request or\n   response.  This mechanism supports extensibility;\
    \ implementations of\n   future versions of the HTTP protocol may apply these\
    \ directives to\n   header fields not defined in HTTP/1.1.\n   The cache-control\
    \ directives can be broken down into these general\n   categories:\n     o  Restrictions\
    \ on what is cachable; these may only be imposed by the\n        origin server.\n\
    \     o  Restrictions on what may be stored by a cache; these may be imposed\n\
    \        by either the origin server or the user agent.\n     o  Modifications\
    \ of the basic expiration mechanism; these may be\n        imposed by either the\
    \ origin server or the user agent.\n     o  Controls over cache revalidation and\
    \ reload; these may only be\n        imposed by a user agent.\n     o  Control\
    \ over transformation of entities.\n     o  Extensions to the caching system.\n"
- title: 14.9.1 What is Cachable
  contents:
  - "14.9.1 What is Cachable\n   By default, a response is cachable if the requirements\
    \ of the request\n   method, request header fields, and the response status indicate\
    \ that\n   it is cachable. Section 13.4 summarizes these defaults for\n   cachability.\
    \ The following Cache-Control response directives allow an\n   origin server to\
    \ override the default cachability of a response:\n"
- title: public
  contents:
  - "public\n  Indicates that the response is cachable by any cache, even if it\n\
    \  would normally be non-cachable or cachable only within a non-shared\n  cache.\
    \ (See also Authorization, section 14.8, for additional\n  details.)\n"
- title: private
  contents:
  - "private\n  Indicates that all or part of the response message is intended for\
    \ a\n  single user and MUST NOT be cached by a shared cache. This allows an\n\
    \  origin server to state that the specified parts of the response are\n  intended\
    \ for only one user and are not a valid response for requests\n  by other users.\
    \ A private (non-shared) cache may cache the response.\n  Note: This usage of\
    \ the word private only controls where the\n  response may be cached, and cannot\
    \ ensure the privacy of the\n  message content.\n"
- title: no-cache
  contents:
  - "no-cache\n  Indicates that all or part of the response message MUST NOT be cached\n\
    \  anywhere. This allows an origin server to prevent caching even by\n  caches\
    \ that have been configured to return stale responses to client\n  requests.\n\
    \  Note: Most HTTP/1.0 caches will not recognize or obey this\n  directive.\n"
- title: 14.9.2 What May be Stored by Caches
  contents:
  - "14.9.2 What May be Stored by Caches\n   The purpose of the no-store directive\
    \ is to prevent the inadvertent\n   release or retention of sensitive information\
    \ (for example, on backup\n   tapes). The no-store directive applies to the entire\
    \ message, and may\n   be sent either in a response or in a request. If sent in\
    \ a request, a\n   cache MUST NOT store any part of either this request or any\
    \ response\n   to it. If sent in a response, a cache MUST NOT store any part of\n\
    \   either this response or the request that elicited it. This directive\n   applies\
    \ to both non-shared and shared caches. \"MUST NOT store\" in\n   this context\
    \ means that the cache MUST NOT intentionally store the\n   information in non-volatile\
    \ storage, and MUST make a best-effort\n   attempt to remove the information from\
    \ volatile storage as promptly\n   as possible after forwarding it.\n   Even when\
    \ this directive is associated with a response, users may\n   explicitly store\
    \ such a response outside of the caching system (e.g.,\n   with a \"Save As\"\
    \ dialog). History buffers may store such responses as\n   part of their normal\
    \ operation.\n   The purpose of this directive is to meet the stated requirements\
    \ of\n   certain users and service authors who are concerned about accidental\n\
    \   releases of information via unanticipated accesses to cache data\n   structures.\
    \ While the use of this directive may improve privacy in\n   some cases, we caution\
    \ that it is NOT in any way a reliable or\n   sufficient mechanism for ensuring\
    \ privacy. In particular, malicious\n   or compromised caches may not recognize\
    \ or obey this directive; and\n   communications networks may be vulnerable to\
    \ eavesdropping.\n"
- title: 14.9.3 Modifications of the Basic Expiration Mechanism
  contents:
  - "14.9.3 Modifications of the Basic Expiration Mechanism\n   The expiration time\
    \ of an entity may be specified by the origin\n   server using the Expires header\
    \ (see section 14.21). Alternatively,\n   it may be specified using the max-age\
    \ directive in a response.\n   If a response includes both an Expires header and\
    \ a max-age\n   directive, the max-age directive overrides the Expires header,\
    \ even\n   if the Expires header is more restrictive. This rule allows an origin\n\
    \   server to provide, for a given response, a longer expiration time to\n   an\
    \ HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This may be\n   useful\
    \ if certain HTTP/1.0 caches improperly calculate ages or\n   expiration times,\
    \ perhaps due to desynchronized clocks.\n     Note: most older caches, not compliant\
    \ with this specification, do\n     not implement any Cache-Control directives.\
    \  An origin server\n     wishing to use a Cache-Control directive that restricts,\
    \ but does\n     not prevent, caching by an HTTP/1.1-compliant cache may exploit\
    \ the\n     requirement that the max-age directive overrides the Expires\n   \
    \  header, and the fact that non-HTTP/1.1-compliant caches do not\n     observe\
    \ the max-age directive.\n   Other directives allow an user agent to modify the\
    \ basic expiration\n   mechanism. These directives may be specified on a request:\n\
    \   max-age\n     Indicates that the client is willing to accept a response whose\
    \ age\n     is no greater than the specified time in seconds. Unless max-stale\n\
    \     directive is also included, the client is not willing to accept a\n    \
    \ stale response.\n   min-fresh\n     Indicates that the client is willing to\
    \ accept a response whose\n     freshness lifetime is no less than its current\
    \ age plus the\n     specified time in seconds. That is, the client wants a response\n\
    \     that will still be fresh for at least the specified number of\n     seconds.\n\
    \   max-stale\n     Indicates that the client is willing to accept a response\
    \ that has\n     exceeded its expiration time. If max-stale is assigned a value,\n\
    \     then the client is willing to accept a response that has exceeded\n    \
    \ its expiration time by no more than the specified number of\n     seconds. If\
    \ no value is assigned to max-stale, then the client is\n     willing to accept\
    \ a stale response of any age.\n   If a cache returns a stale response, either\
    \ because of a max-stale\n   directive on a request, or because the cache is configured\
    \ to\n   override the expiration time of a response, the cache MUST attach a\n\
    \   Warning header to the stale response, using Warning 10 (Response is\n   stale).\n"
- title: 14.9.4 Cache Revalidation and Reload Controls
  contents:
  - "14.9.4 Cache Revalidation and Reload Controls\n   Sometimes an user agent may\
    \ want or need to insist that a cache\n   revalidate its cache entry with the\
    \ origin server (and not just with\n   the next cache along the path to the origin\
    \ server), or to reload its\n   cache entry from the origin server. End-to-end\
    \ revalidation may be\n   necessary if either the cache or the origin server has\
    \ overestimated\n   the expiration time of the cached response. End-to-end reload\
    \ may be\n   necessary if the cache entry has become corrupted for some reason.\n\
    \   End-to-end revalidation may be requested either when the client does\n   not\
    \ have its own local cached copy, in which case we call it\n   \"unspecified end-to-end\
    \ revalidation\", or when the client does have a\n   local cached copy, in which\
    \ case we call it \"specific end-to-end\n   revalidation.\"\n   The client can\
    \ specify these three kinds of action using Cache-\n   Control request directives:\n\
    \   End-to-end reload\n     The request includes a \"no-cache\" Cache-Control\
    \ directive or, for\n     compatibility with HTTP/1.0 clients, \"Pragma: no-cache\"\
    . No field\n     names may be included with the no-cache directive in a request.\
    \ The\n     server MUST NOT use a cached copy when responding to such a\n    \
    \ request.\n   Specific end-to-end revalidation\n     The request includes a \"\
    max-age=0\" Cache-Control directive, which\n     forces each cache along the path\
    \ to the origin server to revalidate\n     its own entry, if any, with the next\
    \ cache or server. The initial\n     request includes a cache-validating conditional\
    \ with the client's\n     current validator.\n   Unspecified end-to-end revalidation\n\
    \     The request includes \"max-age=0\" Cache-Control directive, which\n    \
    \ forces each cache along the path to the origin server to revalidate\n     its\
    \ own entry, if any, with the next cache or server. The initial\n     request\
    \ does not include a cache-validating conditional; the first\n     cache along\
    \ the path (if any) that holds a cache entry for this\n     resource includes\
    \ a cache-validating conditional with its current\n     validator.\n   When an\
    \ intermediate cache is forced, by means of a max-age=0\n   directive, to revalidate\
    \ its own cache entry, and the client has\n   supplied its own validator in the\
    \ request, the supplied validator may\n   differ from the validator currently\
    \ stored with the cache entry. In\n   this case, the cache may use either validator\
    \ in making its own\n   request without affecting semantic transparency.\n   However,\
    \ the choice of validator may affect performance. The best\n   approach is for\
    \ the intermediate cache to use its own validator when\n   making its request.\
    \ If the server replies with 304 (Not Modified),\n   then the cache should return\
    \ its now validated copy to the client\n   with a 200 (OK) response. If the server\
    \ replies with a new entity and\n   cache validator, however, the intermediate\
    \ cache should compare the\n   returned validator with the one provided in the\
    \ client's request,\n   using the strong comparison function. If the client's\
    \ validator is\n   equal to the origin server's, then the intermediate cache simply\n\
    \   returns 304 (Not Modified). Otherwise, it returns the new entity with\n  \
    \ a 200 (OK) response.\n   If a request includes the no-cache directive, it should\
    \ not include\n   min-fresh, max-stale, or max-age.\n   In some cases, such as\
    \ times of extremely poor network connectivity,\n   a client may want a cache\
    \ to return only those responses that it\n   currently has stored, and not to\
    \ reload or revalidate with the origin\n   server. To do this, the client may\
    \ include the only-if-cached\n   directive in a request. If it receives this directive,\
    \ a cache SHOULD\n   either respond using a cached entry that is consistent with\
    \ the other\n   constraints of the request, or respond with a 504 (Gateway Timeout)\n\
    \   status. However, if a group of caches is being operated as a unified\n   system\
    \ with good internal connectivity, such a request MAY be\n   forwarded within\
    \ that group of caches.\n   Because a cache may be configured to ignore a server's\
    \ specified\n   expiration time, and because a client request may include a max-stale\n\
    \   directive (which has a similar effect), the protocol also includes a\n   mechanism\
    \ for the origin server to require revalidation of a cache\n   entry on any subsequent\
    \ use. When the must-revalidate directive is\n   present in a response received\
    \ by a cache, that cache MUST NOT use\n   the entry after it becomes stale to\
    \ respond to a subsequent request\n   without first revalidating it with the origin\
    \ server. (I.e., the\n   cache must do an end-to-end revalidation every time,\
    \ if, based solely\n   on the origin server's Expires or max-age value, the cached\
    \ response\n   is stale.)\n   The must-revalidate directive is necessary to support\
    \ reliable\n   operation for certain protocol features. In all circumstances an\n\
    \   HTTP/1.1 cache MUST obey the must-revalidate directive; in\n   particular,\
    \ if the cache cannot reach the origin server for any\n   reason, it MUST generate\
    \ a 504 (Gateway Timeout) response.\n   Servers should send the must-revalidate\
    \ directive if and only if\n   failure to revalidate a request on the entity could\
    \ result in\n   incorrect operation, such as a silently unexecuted financial\n\
    \   transaction.  Recipients MUST NOT take any automated action that\n   violates\
    \ this directive, and MUST NOT automatically provide an\n   unvalidated copy of\
    \ the entity if revalidation fails.\n   Although this is not recommended, user\
    \ agents operating under severe\n   connectivity constraints may violate this\
    \ directive but, if so, MUST\n   explicitly warn the user that an unvalidated\
    \ response has been\n   provided.  The warning MUST be provided on each unvalidated\
    \ access,\n   and SHOULD require explicit user confirmation.\n   The proxy-revalidate\
    \ directive has the same meaning as the must-\n   revalidate directive, except\
    \ that it does not apply to non-shared\n   user agent caches. It can be used on\
    \ a response to an authenticated\n   request to permit the user's cache to store\
    \ and later return the\n   response without needing to revalidate it (since it\
    \ has already been\n   authenticated once by that user), while still requiring\
    \ proxies that\n   service many users to revalidate each time (in order to make\
    \ sure\n   that each user has been authenticated). Note that such authenticated\n\
    \   responses also need the public cache control directive in order to\n   allow\
    \ them to be cached at all.\n"
- title: 14.9.5 No-Transform Directive
  contents:
  - "14.9.5 No-Transform Directive\n   Implementers of intermediate caches (proxies)\
    \ have found it useful to\n   convert the media type of certain entity bodies.\
    \ A proxy might, for\n   example, convert between image formats in order to save\
    \ cache space\n   or to reduce the amount of traffic on a slow link. HTTP has\
    \ to date\n   been silent on these transformations.\n   Serious operational problems\
    \ have already occurred, however, when\n   these transformations have been applied\
    \ to entity bodies intended for\n   certain kinds of applications. For example,\
    \ applications for medical\n   imaging, scientific data analysis and those using\
    \ end-to-end\n   authentication, all depend on receiving an entity body that is\
    \ bit\n   for bit identical to the original entity-body.\n   Therefore, if a response\
    \ includes the no-transform directive, an\n   intermediate cache or proxy MUST\
    \ NOT change those headers that are\n   listed in section 13.5.2 as being subject\
    \ to the no-transform\n   directive.  This implies that the cache or proxy must\
    \ not change any\n   aspect of the entity-body that is specified by these headers.\n"
- title: 14.9.6 Cache Control Extensions
  contents:
  - "14.9.6 Cache Control Extensions\n   The Cache-Control header field can be extended\
    \ through the use of one\n   or more cache-extension tokens, each with an optional\
    \ assigned value.\n   Informational extensions (those which do not require a change\
    \ in\n   cache behavior) may be added without changing the semantics of other\n\
    \   directives. Behavioral extensions are designed to work by acting as\n   modifiers\
    \ to the existing base of cache directives. Both the new\n   directive and the\
    \ standard directive are supplied, such that\n   applications which do not understand\
    \ the new directive will default\n   to the behavior specified by the standard\
    \ directive, and those that\n   understand the new directive will recognize it\
    \ as modifying the\n   requirements associated with the standard directive.  In\
    \ this way,\n   extensions to the Cache-Control directives can be made without\n\
    \   requiring changes to the base protocol.\n   This extension mechanism depends\
    \ on a HTTP cache obeying all of the\n   cache-control directives defined for\
    \ its native HTTP-version, obeying\n   certain extensions, and ignoring all directives\
    \ that it does not\n   understand.\n   For example, consider a hypothetical new\
    \ response directive called\n   \"community\" which acts as a modifier to the\
    \ \"private\" directive. We\n   define this new directive to mean that, in addition\
    \ to any non-shared\n   cache, any cache which is shared only by members of the\
    \ community\n   named within its value may cache the response. An origin server\n\
    \   wishing to allow the \"UCI\" community to use an otherwise private\n   response\
    \ in their shared cache(s) may do so by including\n          Cache-Control: private,\
    \ community=\"UCI\"\n   A cache seeing this header field will act correctly even\
    \ if the cache\n   does not understand the \"community\" cache-extension, since\
    \ it will\n   also see and understand the \"private\" directive and thus default\
    \ to\n   the safe behavior.\n   Unrecognized cache-directives MUST be ignored;\
    \ it is assumed that any\n   cache-directive likely to be unrecognized by an HTTP/1.1\
    \ cache will\n   be combined with standard directives (or the response's default\n\
    \   cachability) such that the cache behavior will remain minimally\n   correct\
    \ even if the cache does not understand the extension(s).\n"
- title: 14.10 Connection
  contents:
  - "14.10 Connection\n   The Connection general-header field allows the sender to\
    \ specify\n   options that are desired for that particular connection and MUST\
    \ NOT\n   be communicated by proxies over further connections.\n   The Connection\
    \ header has the following grammar:\n          Connection-header = \"Connection\"\
    \ \":\" 1#(connection-token)\n          connection-token  = token\n   HTTP/1.1\
    \ proxies MUST parse the Connection header field before a\n   message is forwarded\
    \ and, for each connection-token in this field,\n   remove any header field(s)\
    \ from the message with the same name as the\n   connection-token. Connection\
    \ options are signaled by the presence of\n   a connection-token in the Connection\
    \ header field, not by any\n   corresponding additional header field(s), since\
    \ the additional header\n   field may not be sent if there are no parameters associated\
    \ with that\n   connection option.  HTTP/1.1 defines the \"close\" connection\
    \ option\n   for the sender to signal that the connection will be closed after\n\
    \   completion of the response. For example,\n          Connection: close\n  \
    \ in either the request or the response header fields indicates that\n   the connection\
    \ should not be considered `persistent' (section 8.1)\n   after the current request/response\
    \ is complete.\n   HTTP/1.1 applications that do not support persistent connections\
    \ MUST\n   include the \"close\" connection option in every message.\n"
- title: 14.11 Content-Base
  contents:
  - "14.11 Content-Base\n   The Content-Base entity-header field may be used to specify\
    \ the base\n   URI for resolving relative URLs within the entity. This header\
    \ field\n   is described as Base in RFC 1808, which is expected to be revised.\n\
    \          Content-Base      = \"Content-Base\" \":\" absoluteURI\n   If no Content-Base\
    \ field is present, the base URI of an entity is\n   defined either by its Content-Location\
    \ (if that Content-Location URI\n   is an absolute URI) or the URI used to initiate\
    \ the request, in that\n   order of precedence. Note, however, that the base URI\
    \ of the contents\n   within the entity-body may be redefined within that entity-body.\n"
- title: 14.12 Content-Encoding
  contents:
  - "14.12 Content-Encoding\n   The Content-Encoding entity-header field is used as\
    \ a modifier to the\n   media-type. When present, its value indicates what additional\
    \ content\n   codings have been applied to the entity-body, and thus what decoding\n\
    \   mechanisms MUST be applied in order to obtain the media-type\n   referenced\
    \ by the Content-Type header field. Content-Encoding is\n   primarily used to\
    \ allow a document to be compressed without losing\n   the identity of its underlying\
    \ media type.\n          Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\n\
    \   Content codings are defined in section 3.5. An example of its use is\n   \
    \       Content-Encoding: gzip\n   The Content-Encoding is a characteristic of\
    \ the entity identified by\n   the Request-URI. Typically, the entity-body is\
    \ stored with this\n   encoding and is only decoded before rendering or analogous\
    \ usage.\n   If multiple encodings have been applied to an entity, the content\n\
    \   codings MUST be listed in the order in which they were applied.\n   Additional\
    \ information about the encoding parameters MAY be provided\n   by other entity-header\
    \ fields not defined by this specification.\n"
- title: 14.13 Content-Language
  contents:
  - "14.13 Content-Language\n   The Content-Language entity-header field describes\
    \ the natural\n   language(s) of the intended audience for the enclosed entity.\
    \ Note\n   that this may not be equivalent to all the languages used within the\n\
    \   entity-body.\n          Content-Language  = \"Content-Language\" \":\" 1#language-tag\n\
    \   Language tags are defined in section 3.10. The primary purpose of\n   Content-Language\
    \ is to allow a user to identify and differentiate\n   entities according to the\
    \ user's own preferred language. Thus, if the\n   body content is intended only\
    \ for a Danish-literate audience, the\n   appropriate field is\n          Content-Language:\
    \ da\n   If no Content-Language is specified, the default is that the content\n\
    \   is intended for all language audiences. This may mean that the sender\n  \
    \ does not consider it to be specific to any natural language, or that\n   the\
    \ sender does not know for which language it is intended.\n   Multiple languages\
    \ MAY be listed for content that is intended for\n   multiple audiences. For example,\
    \ a rendition of the \"Treaty of\n   Waitangi,\" presented simultaneously in the\
    \ original Maori and English\n   versions, would call for\n          Content-Language:\
    \ mi, en\n   However, just because multiple languages are present within an entity\n\
    \   does not mean that it is intended for multiple linguistic audiences.\n   An\
    \ example would be a beginner's language primer, such as \"A First\n   Lesson\
    \ in Latin,\" which is clearly intended to be used by an\n   English-literate\
    \ audience. In this case, the Content-Language should\n   only include \"en\"\
    .\n   Content-Language may be applied to any media type -- it is not\n   limited\
    \ to textual documents.\n"
- title: 14.14 Content-Length
  contents:
  - "14.14 Content-Length\n   The Content-Length entity-header field indicates the\
    \ size of the\n   message-body, in decimal number of octets, sent to the recipient\
    \ or,\n   in the case of the HEAD method, the size of the entity-body that\n \
    \  would have been sent had the request been a GET.\n          Content-Length\
    \    = \"Content-Length\" \":\" 1*DIGIT\n   An example is\n          Content-Length:\
    \ 3495\n   Applications SHOULD use this field to indicate the size of the\n  \
    \ message-body to be transferred, regardless of the media type of the\n   entity.\
    \ It must be possible for the recipient to reliably determine\n   the end of HTTP/1.1\
    \ requests containing an entity-body, e.g., because\n   the request has a valid\
    \ Content-Length field, uses Transfer-Encoding:\n   chunked or a multipart body.\n\
    \   Any Content-Length greater than or equal to zero is a valid value.\n   Section\
    \ 4.4 describes how to determine the length of a message-body\n   if a Content-Length\
    \ is not given.\n     Note: The meaning of this field is significantly different\
    \ from the\n     corresponding definition in MIME, where it is an optional field\n\
    \     used within the \"message/external-body\" content-type. In HTTP, it\n  \
    \   SHOULD be sent whenever the message's length can be determined\n     prior\
    \ to being transferred.\n"
- title: 14.15 Content-Location
  contents:
  - "14.15 Content-Location\n   The Content-Location entity-header field may be used\
    \ to supply the\n   resource location for the entity enclosed in the message.\
    \ In the case\n   where a resource has multiple entities associated with it, and\
    \ those\n   entities actually have separate locations by which they might be\n\
    \   individually accessed, the server should provide a Content-Location\n   for\
    \ the particular variant which is returned. In addition, a server\n   SHOULD provide\
    \ a Content-Location for the resource corresponding to\n   the response entity.\n\
    \          Content-Location = \"Content-Location\" \":\"\n                   \
    \         ( absoluteURI | relativeURI )\n   If no Content-Base header field is\
    \ present, the value of Content-\n   Location also defines the base URL for the\
    \ entity (see section\n   14.11).\n   The Content-Location value is not a replacement\
    \ for the original\n   requested URI; it is only a statement of the location of\
    \ the resource\n   corresponding to this particular entity at the time of the\
    \ request.\n   Future requests MAY use the Content-Location URI if the desire\
    \ is to\n   identify the source of that particular entity.\n   A cache cannot\
    \ assume that an entity with a Content-Location\n   different from the URI used\
    \ to retrieve it can be used to respond to\n   later requests on that Content-Location\
    \ URI. However, the Content-\n   Location can be used to differentiate between\
    \ multiple entities\n   retrieved from a single requested resource, as described\
    \ in section\n   13.6.\n   If the Content-Location is a relative URI, the URI\
    \ is interpreted\n   relative to any Content-Base URI provided in the response.\
    \ If no\n   Content-Base is provided, the relative URI is interpreted relative\
    \ to\n   the Request-URI.\n"
- title: 14.16 Content-MD5
  contents:
  - "14.16 Content-MD5\n   The Content-MD5 entity-header field, as defined in RFC\
    \ 1864 [23], is\n   an MD5 digest of the entity-body for the purpose of providing\
    \ an\n   end-to-end message integrity check (MIC) of the entity-body. (Note: a\n\
    \   MIC is good for detecting accidental modification of the entity-body\n   in\
    \ transit, but is not proof against malicious attacks.)\n           Content-MD5\
    \   = \"Content-MD5\" \":\" md5-digest\n           md5-digest   = <base64 of 128\
    \ bit MD5 digest as per RFC 1864>\n   The Content-MD5 header field may be generated\
    \ by an origin server to\n   function as an integrity check of the entity-body.\
    \ Only origin\n   servers may generate the Content-MD5 header field; proxies and\n\
    \   gateways MUST NOT generate it, as this would defeat its value as an\n   end-to-end\
    \ integrity check. Any recipient of the entity-body,\n   including gateways and\
    \ proxies, MAY check that the digest value in\n   this header field matches that\
    \ of the entity-body as received.\n   The MD5 digest is computed based on the\
    \ content of the entity-body,\n   including any Content-Encoding that has been\
    \ applied, but not\n   including any Transfer-Encoding that may have been applied\
    \ to the\n   message-body. If the message is received with a Transfer-Encoding,\n\
    \   that encoding must be removed prior to checking the Content-MD5 value\n  \
    \ against the received entity.\n   This has the result that the digest is computed\
    \ on the octets of the\n   entity-body exactly as, and in the order that, they\
    \ would be sent if\n   no Transfer-Encoding were being applied.\n   HTTP extends\
    \ RFC 1864 to permit the digest to be computed for MIME\n   composite media-types\
    \ (e.g., multipart/* and message/rfc822), but\n   this does not change how the\
    \ digest is computed as defined in the\n   preceding paragraph.\n     Note: There\
    \ are several consequences of this. The entity-body for\n     composite types\
    \ may contain many body-parts, each with its own MIME\n     and HTTP headers (including\
    \ Content-MD5, Content-Transfer-Encoding,\n     and Content-Encoding headers).\
    \ If a body-part has a Content-\n     Transfer-Encoding or Content-Encoding header,\
    \ it is assumed that\n     the content of the body-part has had the encoding applied,\
    \ and the\n     body-part is included in the Content-MD5 digest as is -- i.e.,\n\
    \     after the application. The Transfer-Encoding header field is not\n     allowed\
    \ within body-parts.\n     Note: while the definition of Content-MD5 is exactly\
    \ the same for\n     HTTP as in RFC 1864 for MIME entity-bodies, there are several\
    \ ways\n     in which the application of Content-MD5 to HTTP entity-bodies\n \
    \    differs from its application to MIME entity-bodies. One is that\n     HTTP,\
    \ unlike MIME, does not use Content-Transfer-Encoding, and does\n     use Transfer-Encoding\
    \ and Content-Encoding. Another is that HTTP\n     more frequently uses binary\
    \ content types than MIME, so it is worth\n     noting that, in such cases, the\
    \ byte order used to compute the\n     digest is the transmission byte order defined\
    \ for the type. Lastly,\n     HTTP allows transmission of text types with any\
    \ of several line\n     break conventions and not just the canonical form using\
    \ CRLF.\n     Conversion of all line breaks to CRLF should not be done before\n\
    \     computing or checking the digest: the line break convention used in\n  \
    \   the text actually transmitted should be left unaltered when\n     computing\
    \ the digest.\n"
- title: 14.17 Content-Range
  contents:
  - "14.17 Content-Range\n   The Content-Range entity-header is sent with a partial\
    \ entity-body to\n   specify where in the full entity-body the partial body should\
    \ be\n   inserted. It also indicates the total size of the full entity-body.\n\
    \   When a server returns a partial response to a client, it must\n   describe\
    \ both the extent of the range covered by the response, and\n   the length of\
    \ the entire entity-body.\n          Content-Range = \"Content-Range\" \":\" content-range-spec\n\
    \          content-range-spec      = byte-content-range-spec\n          byte-content-range-spec\
    \ = bytes-unit SP first-byte-pos \"-\"\n                                    last-byte-pos\
    \ \"/\" entity-length\n          entity-length           = 1*DIGIT\n   Unlike\
    \ byte-ranges-specifier values, a byte-content-range-spec may\n   only specify\
    \ one range, and must contain absolute byte positions for\n   both the first and\
    \ last byte of the range.\n   A byte-content-range-spec whose last-byte-pos value\
    \ is less than its\n   first-byte-pos value, or whose entity-length value is less\
    \ than or\n   equal to its last-byte-pos value, is invalid. The recipient of an\n\
    \   invalid byte-content-range-spec MUST ignore it and any content\n   transferred\
    \ along with it.\n   Examples of byte-content-range-spec values, assuming that\
    \ the entity\n   contains a total of 1234 bytes:\n     o  The first 500 bytes:\n\
    \          bytes 0-499/1234\n     o  The second 500 bytes:\n          bytes 500-999/1234\n\
    \     o  All except for the first 500 bytes:\n          bytes 500-1233/1234\n\
    \     o  The last 500 bytes:\n          bytes 734-1233/1234\n   When an HTTP message\
    \ includes the content of a single range (for\n   example, a response to a request\
    \ for a single range, or to a request\n   for a set of ranges that overlap without\
    \ any holes), this content is\n   transmitted with a Content-Range header, and\
    \ a Content-Length header\n   showing the number of bytes actually transferred.\
    \ For example,\n          HTTP/1.1 206 Partial content\n          Date: Wed, 15\
    \ Nov 1995 06:25:24 GMT\n          Last-modified: Wed, 15 Nov 1995 04:58:08 GMT\n\
    \          Content-Range: bytes 21010-47021/47022\n          Content-Length: 26012\n\
    \          Content-Type: image/gif\n   When an HTTP message includes the content\
    \ of multiple ranges (for\n   example, a response to a request for multiple non-overlapping\n\
    \   ranges), these are transmitted as a multipart MIME message. The\n   multipart\
    \ MIME content-type used for this purpose is defined in this\n   specification\
    \ to be \"multipart/byteranges\". See appendix 19.2 for its\n   definition.\n\
    \   A client that cannot decode a MIME multipart/byteranges message\n   should\
    \ not ask for multiple byte-ranges in a single request.\n   When a client requests\
    \ multiple byte-ranges in one request, the\n   server SHOULD return them in the\
    \ order that they appeared in the\n   request.\n   If the server ignores a byte-range-spec\
    \ because it is invalid, the\n   server should treat the request as if the invalid\
    \ Range header field\n   did not exist. (Normally, this means return a 200 response\
    \ containing\n   the full entity). The reason is that the only time a client will\
    \ make\n   such an invalid request is when the entity is smaller than the entity\n\
    \   retrieved by a prior request.\n"
- title: 14.18 Content-Type
  contents:
  - "14.18 Content-Type\n   The Content-Type entity-header field indicates the media\
    \ type of the\n   entity-body sent to the recipient or, in the case of the HEAD\
    \ method,\n   the media type that would have been sent had the request been a\
    \ GET.\n          Content-Type   = \"Content-Type\" \":\" media-type\n   Media\
    \ types are defined in section 3.7. An example of the field is\n          Content-Type:\
    \ text/html; charset=ISO-8859-4\n   Further discussion of methods for identifying\
    \ the media type of an\n   entity is provided in section 7.2.1.\n"
- title: 14.19 Date
  contents:
  - "14.19 Date\n   The Date general-header field represents the date and time at\
    \ which\n   the message was originated, having the same semantics as orig-date\
    \ in\n   RFC 822. The field value is an HTTP-date, as described in section\n \
    \  3.3.1.\n          Date  = \"Date\" \":\" HTTP-date\n   An example is\n    \
    \      Date: Tue, 15 Nov 1994 08:12:31 GMT\n   If a message is received via direct\
    \ connection with the user agent\n   (in the case of requests) or the origin server\
    \ (in the case of\n   responses), then the date can be assumed to be the current\
    \ date at\n   the receiving end. However, since the date--as it is believed by\
    \ the\n   origin--is important for evaluating cached responses, origin servers\n\
    \   MUST include a Date header field in all responses. Clients SHOULD\n   only\
    \ send a Date header field in messages that include an entity-\n   body, as in\
    \ the case of the PUT and POST requests, and even then it\n   is optional. A received\
    \ message which does not have a Date header\n   field SHOULD be assigned one by\
    \ the recipient if the message will be\n   cached by that recipient or gatewayed\
    \ via a protocol which requires a\n   Date.\n   In theory, the date SHOULD represent\
    \ the moment just before the\n   entity is generated. In practice, the date can\
    \ be generated at any\n   time during the message origination without affecting\
    \ its semantic\n   value.\n   The format of the Date is an absolute date and time\
    \ as defined by\n   HTTP-date in section 3.3; it MUST be sent in RFC1123 [8]-date\
    \ format.\n"
- title: 14.20 ETag
  contents:
  - "14.20 ETag\n   The ETag entity-header field defines the entity tag for the\n\
    \   associated entity. The headers used with entity tags are described in\n  \
    \ sections 14.20, 14.25, 14.26 and 14.43. The entity tag may be used\n   for comparison\
    \ with other entities from the same resource (see\n   section 13.3.2).\n     \
    \    ETag = \"ETag\" \":\" entity-tag\n   Examples:\n         ETag: \"xyzzy\"\n\
    \         ETag: W/\"xyzzy\"\n         ETag: \"\"\n"
- title: 14.21 Expires
  contents:
  - "14.21 Expires\n   The Expires entity-header field gives the date/time after which\
    \ the\n   response should be considered stale. A stale cache entry may not\n \
    \  normally be returned by a cache (either a proxy cache or an user\n   agent\
    \ cache) unless it is first validated with the origin server (or\n   with an intermediate\
    \ cache that has a fresh copy of the entity). See\n   section 13.2 for further\
    \ discussion of the expiration model.\n   The presence of an Expires field does\
    \ not imply that the original\n   resource will change or cease to exist at, before,\
    \ or after that\n   time.\n   The format is an absolute date and time as defined\
    \ by HTTP-date in\n   section 3.3; it MUST be in RFC1123-date format:\n      \
    \   Expires = \"Expires\" \":\" HTTP-date\n   An example of its use is\n     \
    \    Expires: Thu, 01 Dec 1994 16:00:00 GMT\n     Note: if a response includes\
    \ a Cache-Control field with the max-age\n     directive, that directive overrides\
    \ the Expires field.\n   HTTP/1.1 clients and caches MUST treat other invalid\
    \ date formats,\n   especially including the value \"0\", as in the past (i.e.,\
    \ \"already\n   expired\").\n   To mark a response as \"already expired,\" an\
    \ origin server should use\n   an Expires date that is equal to the Date header\
    \ value. (See the\n   rules for expiration calculations in section 13.2.4.)\n\
    \   To mark a response as \"never expires,\" an origin server should use an\n\
    \   Expires date approximately one year from the time the response is\n   sent.\
    \  HTTP/1.1 servers should not send Expires dates more than one\n   year in the\
    \ future.\n   The presence of an Expires header field with a date value of some\n\
    \   time in the future on an response that otherwise would by default be\n   non-cacheable\
    \ indicates that the response is cachable, unless\n   indicated otherwise by a\
    \ Cache-Control header field (section 14.9).\n"
- title: 14.22 From
  contents:
  - "14.22 From\n   The From request-header field, if given, SHOULD contain an Internet\n\
    \   e-mail address for the human user who controls the requesting user\n   agent.\
    \  The address SHOULD be machine-usable, as defined by mailbox\n   in RFC 822\
    \ (as updated by RFC 1123 ):\n          From   = \"From\" \":\" mailbox\n   An\
    \ example is:\n          From: webmaster@w3.org\n   This header field MAY be used\
    \ for logging purposes and as a means for\n   identifying the source of invalid\
    \ or unwanted requests. It SHOULD NOT\n   be used as an insecure form of access\
    \ protection. The interpretation\n   of this field is that the request is being\
    \ performed on behalf of the\n   person given, who accepts responsibility for\
    \ the method performed. In\n   particular, robot agents SHOULD include this header\
    \ so that the\n   person responsible for running the robot can be contacted if\
    \ problems\n   occur on the receiving end.\n   The Internet e-mail address in\
    \ this field MAY be separate from the\n   Internet host which issued the request.\
    \ For example, when a request\n   is passed through a proxy the original issuer's\
    \ address SHOULD be\n   used.\n     Note: The client SHOULD not send the From\
    \ header field without the\n     user's approval, as it may conflict with the\
    \ user's privacy\n     interests or their site's security policy. It is strongly\n\
    \     recommended that the user be able to disable, enable, and modify\n     the\
    \ value of this field at any time prior to a request.\n"
- title: 14.23 Host
  contents:
  - "14.23 Host\n   The Host request-header field specifies the Internet host and\
    \ port\n   number of the resource being requested, as obtained from the original\n\
    \   URL given by the user or referring resource (generally an HTTP URL,\n   as\
    \ described in section 3.2.2). The Host field value MUST represent\n   the network\
    \ location of the origin server or gateway given by the\n   original URL. This\
    \ allows the origin server or gateway to\n   differentiate between internally-ambiguous\
    \ URLs, such as the root \"/\"\n   URL of a server for multiple host names on\
    \ a single IP address.\n          Host = \"Host\" \":\" host [ \":\" port ]  \
    \  ; Section 3.2.2\n   A \"host\" without any trailing port information implies\
    \ the default\n   port for the service requested (e.g., \"80\" for an HTTP URL).\
    \ For\n   example, a request on the origin server for\n   <http://www.w3.org/pub/WWW/>\
    \ MUST include:\n          GET /pub/WWW/ HTTP/1.1\n          Host: www.w3.org\n\
    \   A client MUST include a Host header field in all HTTP/1.1 request\n   messages\
    \ on the Internet (i.e., on any message corresponding to a\n   request for a URL\
    \ which includes an Internet host address for the\n   service being requested).\
    \ If the Host field is not already present,\n   an HTTP/1.1 proxy MUST add a Host\
    \ field to the request message prior\n   to forwarding it on the Internet. All\
    \ Internet-based HTTP/1.1 servers\n   MUST respond with a 400 status code to any\
    \ HTTP/1.1 request message\n   which lacks a Host header field.\n   See sections\
    \ 5.2 and 19.5.1 for other requirements relating to Host.\n"
- title: 14.24 If-Modified-Since
  contents:
  - "14.24 If-Modified-Since\n   The If-Modified-Since request-header field is used\
    \ with the GET\n   method to make it conditional: if the requested variant has\
    \ not been\n   modified since the time specified in this field, an entity will\
    \ not\n   be returned from the server; instead, a 304 (not modified) response\n\
    \   will be returned without any message-body.\n          If-Modified-Since =\
    \ \"If-Modified-Since\" \":\" HTTP-date\n   An example of the field is:\n    \
    \      If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n   A GET method with\
    \ an If-Modified-Since header and no Range header\n   requests that the identified\
    \ entity be transferred only if it has\n   been modified since the date given\
    \ by the If-Modified-Since header.\n   The algorithm for determining this includes\
    \ the following cases:\n   a)If the request would normally result in anything\
    \ other than a 200\n     (OK) status, or if the passed If-Modified-Since date\
    \ is invalid, the\n     response is exactly the same as for a normal GET. A date\
    \ which is\n     later than the server's current time is invalid.\n   b)If the\
    \ variant has been modified since the If-Modified-Since date,\n     the response\
    \ is exactly the same as for a normal GET.\n   c)If the variant has not been modified\
    \ since a valid If-Modified-Since\n     date, the server MUST return a 304 (Not\
    \ Modified) response.\n   The purpose of this feature is to allow efficient updates\
    \ of cached\n   information with a minimum amount of transaction overhead.\n \
    \    Note that the Range request-header field modifies the meaning of\n     If-Modified-Since;\
    \ see section 14.36 for full details.\n     Note that If-Modified-Since times\
    \ are interpreted by the server,\n     whose clock may not be synchronized with\
    \ the client.\n   Note that if a client uses an arbitrary date in the If-Modified-Since\n\
    \   header instead of a date taken from the Last-Modified header for the\n   same\
    \ request, the client should be aware of the fact that this date\n   is interpreted\
    \ in the server's understanding of time. The client\n   should consider unsynchronized\
    \ clocks and rounding problems due to\n   the different encodings of time between\
    \ the client and server. This\n   includes the possibility of race conditions\
    \ if the document has\n   changed between the time it was first requested and\
    \ the If-Modified-\n   Since date of a subsequent request, and the possibility\
    \ of clock-\n   skew-related problems if the If-Modified-Since date is derived\
    \ from\n   the client's clock without correction to the server's clock.\n   Corrections\
    \ for different time bases between client and server are at\n   best approximate\
    \ due to network latency.\n"
- title: 14.25 If-Match
  contents:
  - "14.25 If-Match\n   The If-Match request-header field is used with a method to\
    \ make it\n   conditional. A client that has one or more entities previously\n\
    \   obtained from the resource can verify that one of those entities is\n   current\
    \ by including a list of their associated entity tags in the\n   If-Match header\
    \ field. The purpose of this feature is to allow\n   efficient updates of cached\
    \ information with a minimum amount of\n   transaction overhead. It is also used,\
    \ on updating requests, to\n   prevent inadvertent modification of the wrong version\
    \ of a resource.\n   As a special case, the value \"*\" matches any current entity\
    \ of the\n   resource.\n          If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag\
    \ )\n   If any of the entity tags match the entity tag of the entity that\n  \
    \ would have been returned in the response to a similar GET request\n   (without\
    \ the If-Match header) on that resource, or if \"*\" is given\n   and any current\
    \ entity exists for that resource, then the server MAY\n   perform the requested\
    \ method as if the If-Match header field did not\n   exist.\n   A server MUST\
    \ use the strong comparison function (see section 3.11)\n   to compare the entity\
    \ tags in If-Match.\n   If none of the entity tags match, or if \"*\" is given\
    \ and no current\n   entity exists, the server MUST NOT perform the requested\
    \ method, and\n   MUST return a 412 (Precondition Failed) response. This behavior\
    \ is\n   most useful when the client wants to prevent an updating method, such\n\
    \   as PUT, from modifying a resource that has changed since the client\n   last\
    \ retrieved it.\n   If the request would, without the If-Match header field, result\
    \ in\n   anything other than a 2xx status, then the If-Match header MUST be\n\
    \   ignored.\n   The meaning of \"If-Match: *\" is that the method SHOULD be performed\n\
    \   if the representation selected by the origin server (or by a cache,\n   possibly\
    \ using the Vary mechanism, see section 14.43) exists, and\n   MUST NOT be performed\
    \ if the representation does not exist.\n   A request intended to update a resource\
    \ (e.g., a PUT) MAY include an\n   If-Match header field to signal that the request\
    \ method MUST NOT be\n   applied if the entity corresponding to the If-Match value\
    \ (a single\n   entity tag) is no longer a representation of that resource.  This\n\
    \   allows the user to indicate that they do not wish the request to be\n   successful\
    \ if the resource has been changed without their knowledge.\n   Examples:\n  \
    \        If-Match: \"xyzzy\"\n          If-Match: \"xyzzy\", \"r2d2xxxx\", \"\
    c3piozzzz\"\n          If-Match: *\n"
- title: 14.26 If-None-Match
  contents:
  - "14.26 If-None-Match\n   The If-None-Match request-header field is used with a\
    \ method to make\n   it conditional. A client that has one or more entities previously\n\
    \   obtained from the resource can verify that none of those entities is\n   current\
    \ by including a list of their associated entity tags in the\n   If-None-Match\
    \ header field. The purpose of this feature is to allow\n   efficient updates\
    \ of cached information with a minimum amount of\n   transaction overhead. It\
    \ is also used, on updating requests, to\n   prevent inadvertent modification\
    \ of a resource which was not known to\n   exist.\n   As a special case, the value\
    \ \"*\" matches any current entity of the\n   resource.\n          If-None-Match\
    \ = \"If-None-Match\" \":\" ( \"*\" | 1#entity-tag )\n   If any of the entity\
    \ tags match the entity tag of the entity that\n   would have been returned in\
    \ the response to a similar GET request\n   (without the If-None-Match header)\
    \ on that resource, or if \"*\" is\n   given and any current entity exists for\
    \ that resource, then the\n   server MUST NOT perform the requested method. Instead,\
    \ if the request\n   method was GET or HEAD, the server SHOULD respond with a\
    \ 304 (Not\n   Modified) response, including the cache-related entity-header fields\n\
    \   (particularly ETag) of one of the entities that matched. For all\n   other\
    \ request methods, the server MUST respond with a status of 412\n   (Precondition\
    \ Failed).\n   See section 13.3.3 for rules on how to determine if two entity\
    \ tags\n   match. The weak comparison function can only be used with GET or HEAD\n\
    \   requests.\n   If none of the entity tags match, or if \"*\" is given and no\
    \ current\n   entity exists, then the server MAY perform the requested method\
    \ as if\n   the If-None-Match header field did not exist.\n   If the request would,\
    \ without the If-None-Match header field, result\n   in anything other than a\
    \ 2xx status, then the If-None-Match header\n   MUST be ignored.\n   The meaning\
    \ of \"If-None-Match: *\" is that the method MUST NOT be\n   performed if the\
    \ representation selected by the origin server (or by\n   a cache, possibly using\
    \ the Vary mechanism, see section 14.43)\n   exists, and SHOULD be performed if\
    \ the representation does not exist.\n   This feature may be useful in preventing\
    \ races between PUT\n   operations.\n   Examples:\n          If-None-Match: \"\
    xyzzy\"\n          If-None-Match: W/\"xyzzy\"\n          If-None-Match: \"xyzzy\"\
    , \"r2d2xxxx\", \"c3piozzzz\"\n          If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\"\
    , W/\"c3piozzzz\"\n          If-None-Match: *\n"
- title: 14.27 If-Range
  contents:
  - "14.27 If-Range\n   If a client has a partial copy of an entity in its cache,\
    \ and wishes\n   to have an up-to-date copy of the entire entity in its cache,\
    \ it\n   could use the Range request-header with a conditional GET (using\n  \
    \ either or both of If-Unmodified-Since and If-Match.) However, if the\n   condition\
    \ fails because the entity has been modified, the client\n   would then have to\
    \ make a second request to obtain the entire current\n   entity-body.\n   The\
    \ If-Range header allows a client to \"short-circuit\" the second\n   request.\
    \ Informally, its meaning is `if the entity is unchanged, send\n   me the part(s)\
    \ that I am missing; otherwise, send me the entire new\n   entity.'\n        \
    \   If-Range = \"If-Range\" \":\" ( entity-tag | HTTP-date )\n   If the client\
    \ has no entity tag for an entity, but does have a Last-\n   Modified date, it\
    \ may use that date in a If-Range header. (The server\n   can distinguish between\
    \ a valid HTTP-date and any form of entity-tag\n   by examining no more than two\
    \ characters.) The If-Range header should\n   only be used together with a Range\
    \ header, and must be ignored if the\n   request does not include a Range header,\
    \ or if the server does not\n   support the sub-range operation.\n   If the entity\
    \ tag given in the If-Range header matches the current\n   entity tag for the\
    \ entity, then the server should provide the\n   specified sub-range of the entity\
    \ using a 206 (Partial content)\n   response. If the entity tag does not match,\
    \ then the server should\n   return the entire entity using a 200 (OK) response.\n"
- title: 14.28 If-Unmodified-Since
  contents:
  - "14.28 If-Unmodified-Since\n   The If-Unmodified-Since request-header field is\
    \ used with a method to\n   make it conditional. If the requested resource has\
    \ not been modified\n   since the time specified in this field, the server should\
    \ perform the\n   requested operation as if the If-Unmodified-Since header were\
    \ not\n   present.\n   If the requested variant has been modified since the specified\
    \ time,\n   the server MUST NOT perform the requested operation, and MUST return\n\
    \   a 412 (Precondition Failed).\n         If-Unmodified-Since = \"If-Unmodified-Since\"\
    \ \":\" HTTP-date\n   An example of the field is:\n          If-Unmodified-Since:\
    \ Sat, 29 Oct 1994 19:43:31 GMT\n   If the request normally (i.e., without the\
    \ If-Unmodified-Since\n   header) would result in anything other than a 2xx status,\
    \ the If-\n   Unmodified-Since header should be ignored.\n   If the specified\
    \ date is invalid, the header is ignored.\n"
- title: 14.29 Last-Modified
  contents:
  - "14.29 Last-Modified\n   The Last-Modified entity-header field indicates the date\
    \ and time at\n   which the origin server believes the variant was last modified.\n\
    \          Last-Modified  = \"Last-Modified\" \":\" HTTP-date\n   An example of\
    \ its use is\n          Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n   The exact\
    \ meaning of this header field depends on the implementation\n   of the origin\
    \ server and the nature of the original resource. For\n   files, it may be just\
    \ the file system last-modified time. For\n   entities with dynamically included\
    \ parts, it may be the most recent\n   of the set of last-modify times for its\
    \ component parts. For database\n   gateways, it may be the last-update time stamp\
    \ of the record. For\n   virtual objects, it may be the last time the internal\
    \ state changed.\n   An origin server MUST NOT send a Last-Modified date which\
    \ is later\n   than the server's time of message origination. In such cases, where\n\
    \   the resource's last modification would indicate some time in the\n   future,\
    \ the server MUST replace that date with the message\n   origination date.\n \
    \  An origin server should obtain the Last-Modified value of the entity\n   as\
    \ close as possible to the time that it generates the Date value of\n   its response.\
    \ This allows a recipient to make an accurate assessment\n   of the entity's modification\
    \ time, especially if the entity changes\n   near the time that the response is\
    \ generated.\n   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.\n"
- title: 14.30 Location
  contents:
  - "14.30 Location\n   The Location response-header field is used to redirect the\
    \ recipient\n   to a location other than the Request-URI for completion of the\n\
    \   request or identification of a new resource. For 201 (Created)\n   responses,\
    \ the Location is that of the new resource which was created\n   by the request.\
    \  For 3xx responses, the location SHOULD indicate the\n   server's preferred\
    \ URL for automatic redirection to the resource. The\n   field value consists\
    \ of a single absolute URL.\n          Location       = \"Location\" \":\" absoluteURI\n\
    \   An example is\n          Location: http://www.w3.org/pub/WWW/People.html\n\
    \     Note: The Content-Location header field (section 14.15) differs\n     from\
    \ Location in that the Content-Location identifies the original\n     location\
    \ of the entity enclosed in the request. It is therefore\n     possible for a\
    \ response to contain header fields for both Location\n     and Content-Location.\
    \ Also see section 13.10 for cache requirements\n     of some methods.\n"
- title: 14.31 Max-Forwards
  contents:
  - "14.31 Max-Forwards\n   The Max-Forwards request-header field may be used with\
    \ the TRACE\n   method (section 14.31) to limit the number of proxies or gateways\n\
    \   that can forward the request to the next inbound server. This can be\n   useful\
    \ when the client is attempting to trace a request chain which\n   appears to\
    \ be failing or looping in mid-chain.\n          Max-Forwards   = \"Max-Forwards\"\
    \ \":\" 1*DIGIT\n   The Max-Forwards value is a decimal integer indicating the\
    \ remaining\n   number of times this request message may be forwarded.\n   Each\
    \ proxy or gateway recipient of a TRACE request containing a Max-\n   Forwards\
    \ header field SHOULD check and update its value prior to\n   forwarding the request.\
    \ If the received value is zero (0), the\n   recipient SHOULD NOT forward the\
    \ request; instead, it SHOULD respond\n   as the final recipient with a 200 (OK)\
    \ response containing the\n   received request message as the response entity-body\
    \ (as described in\n   section 9.8). If the received Max-Forwards value is greater\
    \ than\n   zero, then the forwarded message SHOULD contain an updated Max-\n \
    \  Forwards field with a value decremented by one (1).\n   The Max-Forwards header\
    \ field SHOULD be ignored for all other methods\n   defined by this specification\
    \ and for any extension methods for which\n   it is not explicitly referred to\
    \ as part of that method definition.\n"
- title: 14.32 Pragma
  contents:
  - "14.32 Pragma\n   The Pragma general-header field is used to include implementation-\n\
    \   specific directives that may apply to any recipient along the\n   request/response\
    \ chain. All pragma directives specify optional\n   behavior from the viewpoint\
    \ of the protocol; however, some systems\n   MAY require that behavior be consistent\
    \ with the directives.\n          Pragma            = \"Pragma\" \":\" 1#pragma-directive\n\
    \          pragma-directive  = \"no-cache\" | extension-pragma\n          extension-pragma\
    \  = token [ \"=\" ( token | quoted-string ) ]\n   When the no-cache directive\
    \ is present in a request message, an\n   application SHOULD forward the request\
    \ toward the origin server even\n   if it has a cached copy of what is being requested.\
    \ This pragma\n   directive has the same semantics as the no-cache cache-directive\
    \ (see\n   section 14.9) and is defined here for backwards compatibility with\n\
    \   HTTP/1.0.  Clients SHOULD include both header fields when a no-cache\n   request\
    \ is sent to a server not known to be HTTP/1.1 compliant.\n   Pragma directives\
    \ MUST be passed through by a proxy or gateway\n   application, regardless of\
    \ their significance to that application,\n   since the directives may be applicable\
    \ to all recipients along the\n   request/response chain. It is not possible to\
    \ specify a pragma for a\n   specific recipient; however, any pragma directive\
    \ not relevant to a\n   recipient SHOULD be ignored by that recipient.\n   HTTP/1.1\
    \ clients SHOULD NOT send the Pragma request-header. HTTP/1.1\n   caches SHOULD\
    \ treat \"Pragma: no-cache\" as if the client had sent\n   \"Cache-Control: no-cache\"\
    . No new Pragma directives will be defined\n   in HTTP.\n"
- title: 14.33 Proxy-Authenticate
  contents:
  - "14.33 Proxy-Authenticate\n   The Proxy-Authenticate response-header field MUST\
    \ be included as part\n   of a 407 (Proxy Authentication Required) response. The\
    \ field value\n   consists of a challenge that indicates the authentication scheme\
    \ and\n   parameters applicable to the proxy for this Request-URI.\n         \
    \ Proxy-Authenticate  = \"Proxy-Authenticate\" \":\" challenge\n   The HTTP access\
    \ authentication process is described in section 11.\n   Unlike WWW-Authenticate,\
    \ the Proxy-Authenticate header field applies\n   only to the current connection\
    \ and SHOULD NOT be passed on to\n   downstream clients. However, an intermediate\
    \ proxy may need to obtain\n   its own credentials by requesting them from the\
    \ downstream client,\n   which in some circumstances will appear as if the proxy\
    \ is forwarding\n   the Proxy-Authenticate header field.\n"
- title: 14.34 Proxy-Authorization
  contents:
  - "14.34 Proxy-Authorization\n   The Proxy-Authorization request-header field allows\
    \ the client to\n   identify itself (or its user) to a proxy which requires\n\
    \   authentication.  The Proxy-Authorization field value consists of\n   credentials\
    \ containing the authentication information of the user\n   agent for the proxy\
    \ and/or realm of the resource being requested.\n       Proxy-Authorization  \
    \   = \"Proxy-Authorization\" \":\" credentials\n   The HTTP access authentication\
    \ process is described in section 11.\n   Unlike Authorization, the Proxy-Authorization\
    \ header field applies\n   only to the next outbound proxy that demanded authentication\
    \ using\n   the Proxy-Authenticate field. When multiple proxies are used in a\n\
    \   chain, the Proxy-Authorization header field is consumed by the first\n   outbound\
    \ proxy that was expecting to receive credentials. A proxy MAY\n   relay the credentials\
    \ from the client request to the next proxy if\n   that is the mechanism by which\
    \ the proxies cooperatively authenticate\n   a given request.\n"
- title: 14.35 Public
  contents:
  - "14.35 Public\n   The Public response-header field lists the set of methods supported\n\
    \   by the server. The purpose of this field is strictly to inform the\n   recipient\
    \ of the capabilities of the server regarding unusual\n   methods.  The methods\
    \ listed may or may not be applicable to the\n   Request-URI; the Allow header\
    \ field (section 14.7) MAY be used to\n   indicate methods allowed for a particular\
    \ URI.\n          Public         = \"Public\" \":\" 1#method\n   Example of use:\n\
    \          Public: OPTIONS, MGET, MHEAD, GET, HEAD\n   This header field applies\
    \ only to the server directly connected to\n   the client (i.e., the nearest neighbor\
    \ in a chain of connections). If\n   the response passes through a proxy, the\
    \ proxy MUST either remove the\n   Public header field or replace it with one\
    \ applicable to its own\n   capabilities.\n"
- title: 14.36 Range
  contents:
  - '14.36 Range

    '
- title: 14.36.1 Byte Ranges
  contents:
  - "14.36.1 Byte Ranges\n   Since all HTTP entities are represented in HTTP messages\
    \ as sequences\n   of bytes, the concept of a byte range is meaningful for any\
    \ HTTP\n   entity.  (However, not all clients and servers need to support byte-\n\
    \   range operations.)\n   Byte range specifications in HTTP apply to the sequence\
    \ of bytes in\n   the entity-body (not necessarily the same as the message-body).\n\
    \   A byte range operation may specify a single range of bytes, or a set\n   of\
    \ ranges within a single entity.\n       ranges-specifier = byte-ranges-specifier\n\
    \       byte-ranges-specifier = bytes-unit \"=\" byte-range-set\n       byte-range-set\
    \  = 1#( byte-range-spec | suffix-byte-range-spec )\n       byte-range-spec =\
    \ first-byte-pos \"-\" [last-byte-pos]\n       first-byte-pos  = 1*DIGIT\n   \
    \    last-byte-pos   = 1*DIGIT\n   The first-byte-pos value in a byte-range-spec\
    \ gives the byte-offset\n   of the first byte in a range. The last-byte-pos value\
    \ gives the\n   byte-offset of the last byte in the range; that is, the byte\n\
    \   positions specified are inclusive. Byte offsets start at zero.\n   If the\
    \ last-byte-pos value is present, it must be greater than or\n   equal to the\
    \ first-byte-pos in that byte-range-spec, or the byte-\n   range-spec is invalid.\
    \ The recipient of an invalid byte-range-spec\n   must ignore it.\n   If the last-byte-pos\
    \ value is absent, or if the value is greater than\n   or equal to the current\
    \ length of the entity-body, last-byte-pos is\n   taken to be equal to one less\
    \ than the current length of the entity-\n   body in bytes.\n   By its choice\
    \ of last-byte-pos, a client can limit the number of\n   bytes retrieved without\
    \ knowing the size of the entity.\n          suffix-byte-range-spec = \"-\" suffix-length\n\
    \          suffix-length = 1*DIGIT\n   A suffix-byte-range-spec is used to specify\
    \ the suffix of the\n   entity-body, of a length given by the suffix-length value.\
    \ (That is,\n   this form specifies the last N bytes of an entity-body.) If the\n\
    \   entity is shorter than the specified suffix-length, the entire\n   entity-body\
    \ is used.\n   Examples of byte-ranges-specifier values (assuming an entity-body\
    \ of\n   length 10000):\n     o  The first 500 bytes (byte offsets 0-499, inclusive):\n\
    \          bytes=0-499\n     o  The second 500 bytes (byte offsets 500-999, inclusive):\n\
    \          bytes=500-999\n     o  The final 500 bytes (byte offsets 9500-9999,\
    \ inclusive):\n          bytes=-500\n     o  Or\n          bytes=9500-\n     o\
    \  The first and last bytes only (bytes 0 and 9999):\n          bytes=0-0,-1\n\
    \     o  Several legal but not canonical specifications of the second\n      \
    \  500 bytes (byte offsets 500-999, inclusive):\n          bytes=500-600,601-999\n\
    \          bytes=500-700,601-999\n"
- title: 14.36.2 Range Retrieval Requests
  contents:
  - "14.36.2 Range Retrieval Requests\n   HTTP retrieval requests using conditional\
    \ or unconditional GET\n   methods may request one or more sub-ranges of the entity,\
    \ instead of\n   the entire entity, using the Range request header, which applies\
    \ to\n   the entity returned as the result of the request:\n         Range = \"\
    Range\" \":\" ranges-specifier\n   A server MAY ignore the Range header. However,\
    \ HTTP/1.1 origin\n   servers and intermediate caches SHOULD support byte ranges\
    \ when\n   possible, since Range supports efficient recovery from partially\n\
    \   failed transfers, and supports efficient partial retrieval of large\n   entities.\n\
    \   If the server supports the Range header and the specified range or\n   ranges\
    \ are appropriate for the entity:\n     o  The presence of a Range header in an\
    \ unconditional GET modifies\n        what is returned if the GET is otherwise\
    \ successful. In other\n        words, the response carries a status code of 206\
    \ (Partial\n        Content) instead of 200 (OK).\n     o  The presence of a Range\
    \ header in a conditional GET (a request\n        using one or both of If-Modified-Since\
    \ and If-None-Match, or\n        one or both of If-Unmodified-Since and If-Match)\
    \ modifies what\n        is returned if the GET is otherwise successful and the\
    \ condition\n        is true. It does not affect the 304 (Not Modified) response\n\
    \        returned if the conditional is false.\n   In some cases, it may be more\
    \ appropriate to use the If-Range header\n   (see section 14.27) in addition to\
    \ the Range header.\n   If a proxy that supports ranges receives a Range request,\
    \ forwards\n   the request to an inbound server, and receives an entire entity\
    \ in\n   reply, it SHOULD only return the requested range to its client. It\n\
    \   SHOULD store the entire received response in its cache, if that is\n   consistent\
    \ with its cache allocation policies.\n"
- title: 14.37 Referer
  contents:
  - "14.37 Referer\n   The Referer[sic] request-header field allows the client to\
    \ specify,\n   for the server's benefit, the address (URI) of the resource from\n\
    \   which the Request-URI was obtained (the \"referrer\", although the\n   header\
    \ field is misspelled.) The Referer request-header allows a\n   server to generate\
    \ lists of back-links to resources for interest,\n   logging, optimized caching,\
    \ etc. It also allows obsolete or mistyped\n   links to be traced for maintenance.\
    \ The Referer field MUST NOT be\n   sent if the Request-URI was obtained from\
    \ a source that does not have\n   its own URI, such as input from the user keyboard.\n\
    \        Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n  \
    \ Example:\n        Referer: http://www.w3.org/hypertext/DataSources/Overview.html\n\
    \   If the field value is a partial URI, it SHOULD be interpreted\n   relative\
    \ to the Request-URI. The URI MUST NOT include a fragment.\n     Note: Because\
    \ the source of a link may be private information or\n     may reveal an otherwise\
    \ private information source, it is strongly\n     recommended that the user be\
    \ able to select whether or not the\n     Referer field is sent. For example,\
    \ a browser client could have a\n     toggle switch for browsing openly/anonymously,\
    \ which would\n     respectively enable/disable the sending of Referer and From\n\
    \     information.\n"
- title: 14.38 Retry-After
  contents:
  - "14.38 Retry-After\n   The Retry-After response-header field can be used with\
    \ a 503 (Service\n   Unavailable) response to indicate how long the service is\
    \ expected to\n   be unavailable to the requesting client. The value of this field\
    \ can\n   be either an HTTP-date or an integer number of seconds (in decimal)\n\
    \   after the time of the response.\n          Retry-After  = \"Retry-After\"\
    \ \":\" ( HTTP-date | delta-seconds )\n   Two examples of its use are\n      \
    \    Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\n          Retry-After: 120\n\
    \   In the latter example, the delay is 2 minutes.\n"
- title: 14.39 Server
  contents:
  - "14.39 Server\n   The Server response-header field contains information about\
    \ the\n   software used by the origin server to handle the request. The field\n\
    \   can contain multiple product tokens (section 3.8) and comments\n   identifying\
    \ the server and any significant subproducts. The product\n   tokens are listed\
    \ in order of their significance for identifying the\n   application.\n      \
    \    Server         = \"Server\" \":\" 1*( product | comment )\n   Example:\n\
    \          Server: CERN/3.0 libwww/2.17\n   If the response is being forwarded\
    \ through a proxy, the proxy\n   application MUST NOT modify the Server response-header.\
    \ Instead, it\n   SHOULD include a Via field (as described in section 14.44).\n\
    \     Note: Revealing the specific software version of the server may\n     allow\
    \ the server machine to become more vulnerable to attacks\n     against software\
    \ that is known to contain security holes. Server\n     implementers are encouraged\
    \ to make this field a configurable\n     option.\n"
- title: 14.40 Transfer-Encoding
  contents:
  - "14.40 Transfer-Encoding\n   The Transfer-Encoding general-header field indicates\
    \ what (if any)\n   type of transformation has been applied to the message body\
    \ in order\n   to safely transfer it between the sender and the recipient. This\n\
    \   differs from the Content-Encoding in that the transfer coding is a\n   property\
    \ of the message, not of the entity.\n          Transfer-Encoding       = \"Transfer-Encoding\"\
    \ \":\" 1#transfer-\n   coding\n   Transfer codings are defined in section 3.6.\
    \ An example is:\n          Transfer-Encoding: chunked\n   Many older HTTP/1.0\
    \ applications do not understand the Transfer-\n   Encoding header.\n"
- title: 14.41 Upgrade
  contents:
  - "14.41 Upgrade\n   The Upgrade general-header allows the client to specify what\n\
    \   additional communication protocols it supports and would like to use\n   if\
    \ the server finds it appropriate to switch protocols. The server\n   MUST use\
    \ the Upgrade header field within a 101 (Switching Protocols)\n   response to\
    \ indicate which protocol(s) are being switched.\n          Upgrade        = \"\
    Upgrade\" \":\" 1#product\n   For example,\n          Upgrade: HTTP/2.0, SHTTP/1.3,\
    \ IRC/6.9, RTA/x11\n   The Upgrade header field is intended to provide a simple\
    \ mechanism\n   for transition from HTTP/1.1 to some other, incompatible protocol.\
    \ It\n   does so by allowing the client to advertise its desire to use another\n\
    \   protocol, such as a later version of HTTP with a higher major version\n  \
    \ number, even though the current request has been made using HTTP/1.1.\n   This\
    \ eases the difficult transition between incompatible protocols by\n   allowing\
    \ the client to initiate a request in the more commonly\n   supported protocol\
    \ while indicating to the server that it would like\n   to use a \"better\" protocol\
    \ if available (where \"better\" is determined\n   by the server, possibly according\
    \ to the nature of the method and/or\n   resource being requested).\n   The Upgrade\
    \ header field only applies to switching application-layer\n   protocols upon\
    \ the existing transport-layer connection. Upgrade\n   cannot be used to insist\
    \ on a protocol change; its acceptance and use\n   by the server is optional.\
    \ The capabilities and nature of the\n   application-layer communication after\
    \ the protocol change is entirely\n   dependent upon the new protocol chosen,\
    \ although the first action\n   after changing the protocol MUST be a response\
    \ to the initial HTTP\n   request containing the Upgrade header field.\n   The\
    \ Upgrade header field only applies to the immediate connection.\n   Therefore,\
    \ the upgrade keyword MUST be supplied within a Connection\n   header field (section\
    \ 14.10) whenever Upgrade is present in an\n   HTTP/1.1 message.\n   The Upgrade\
    \ header field cannot be used to indicate a switch to a\n   protocol on a different\
    \ connection. For that purpose, it is more\n   appropriate to use a 301, 302,\
    \ 303, or 305 redirection response.\n   This specification only defines the protocol\
    \ name \"HTTP\" for use by\n   the family of Hypertext Transfer Protocols, as\
    \ defined by the HTTP\n   version rules of section 3.1 and future updates to this\n\
    \   specification. Any token can be used as a protocol name; however, it\n   will\
    \ only be useful if both the client and server associate the name\n   with the\
    \ same protocol.\n"
- title: 14.42 User-Agent
  contents:
  - "14.42 User-Agent\n   The User-Agent request-header field contains information\
    \ about the\n   user agent originating the request. This is for statistical purposes,\n\
    \   the tracing of protocol violations, and automated recognition of user\n  \
    \ agents for the sake of tailoring responses to avoid particular user\n   agent\
    \ limitations. User agents SHOULD include this field with\n   requests. The field\
    \ can contain multiple product tokens (section 3.8)\n   and comments identifying\
    \ the agent and any subproducts which form a\n   significant part of the user\
    \ agent. By convention, the product tokens\n   are listed in order of their significance\
    \ for identifying the\n   application.\n          User-Agent     = \"User-Agent\"\
    \ \":\" 1*( product | comment )\n   Example:\n          User-Agent: CERN-LineMode/2.15\
    \ libwww/2.17b3\n"
- title: 14.43 Vary
  contents:
  - "14.43 Vary\n   The Vary response-header field is used by a server to signal that\
    \ the\n   response entity was selected from the available representations of\n\
    \   the response using server-driven negotiation (section 12). Field-\n   names\
    \ listed in Vary headers are those of request-headers. The Vary\n   field value\
    \ indicates either that the given set of header fields\n   encompass the dimensions\
    \ over which the representation might vary, or\n   that the dimensions of variance\
    \ are unspecified (\"*\") and thus may\n   vary over any aspect of future requests.\n\
    \          Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )\n   An HTTP/1.1 server\
    \ MUST include an appropriate Vary header field with\n   any cachable response\
    \ that is subject to server-driven negotiation.\n   Doing so allows a cache to\
    \ properly interpret future requests on that\n   resource and informs the user\
    \ agent about the presence of negotiation\n   on that resource. A server SHOULD\
    \ include an appropriate Vary header\n   field with a non-cachable response that\
    \ is subject to server-driven\n   negotiation, since this might provide the user\
    \ agent with useful\n   information about the dimensions over which the response\
    \ might vary.\n   The set of header fields named by the Vary field value is known\
    \ as\n   the \"selecting\" request-headers.\n   When the cache receives a subsequent\
    \ request whose Request-URI\n   specifies one or more cache entries including\
    \ a Vary header, the\n   cache MUST NOT use such a cache entry to construct a\
    \ response to the\n   new request unless all of the headers named in the cached\
    \ Vary header\n   are present in the new request, and all of the stored selecting\n\
    \   request-headers from the previous request match the corresponding\n   headers\
    \ in the new request.\n   The selecting request-headers from two requests are\
    \ defined to match\n   if and only if the selecting request-headers in the first\
    \ request can\n   be transformed to the selecting request-headers in the second\
    \ request\n   by adding or removing linear whitespace (LWS) at places where this\
    \ is\n   allowed by the corresponding BNF, and/or combining multiple message-\n\
    \   header fields with the same field name following the rules about\n   message\
    \ headers in section 4.2.\n   A Vary field value of \"*\" signals that unspecified\
    \ parameters,\n   possibly other than the contents of request-header fields (e.g.,\
    \ the\n   network address of the client), play a role in the selection of the\n\
    \   response representation. Subsequent requests on that resource can\n   only\
    \ be properly interpreted by the origin server, and thus a cache\n   MUST forward\
    \ a (possibly conditional) request even when it has a\n   fresh response cached\
    \ for the resource. See section 13.6 for use of\n   the Vary header by caches.\n\
    \   A Vary field value consisting of a list of field-names signals that\n   the\
    \ representation selected for the response is based on a selection\n   algorithm\
    \ which considers ONLY the listed request-header field values\n   in selecting\
    \ the most appropriate representation. A cache MAY assume\n   that the same selection\
    \ will be made for future requests with the\n   same values for the listed field\
    \ names, for the duration of time in\n   which the response is fresh.\n   The\
    \ field-names given are not limited to the set of standard\n   request-header\
    \ fields defined by this specification. Field names are\n   case-insensitive.\n"
- title: 14.44 Via
  contents:
  - "14.44 Via\n   The Via general-header field MUST be used by gateways and proxies\
    \ to\n   indicate the intermediate protocols and recipients between the user\n\
    \   agent and the server on requests, and between the origin server and\n   the\
    \ client on responses. It is analogous to the \"Received\" field of\n   RFC 822\
    \ and is intended to be used for tracking message forwards,\n   avoiding request\
    \ loops, and identifying the protocol capabilities of\n   all senders along the\
    \ request/response chain.\n      Via =  \"Via\" \":\" 1#( received-protocol received-by\
    \ [ comment ] )\n      received-protocol = [ protocol-name \"/\" ] protocol-version\n\
    \      protocol-name     = token\n      protocol-version  = token\n      received-by\
    \       = ( host [ \":\" port ] ) | pseudonym\n      pseudonym         = token\n\
    \   The received-protocol indicates the protocol version of the message\n   received\
    \ by the server or client along each segment of the\n   request/response chain.\
    \ The received-protocol version is appended to\n   the Via field value when the\
    \ message is forwarded so that information\n   about the protocol capabilities\
    \ of upstream applications remains\n   visible to all recipients.\n   The protocol-name\
    \ is optional if and only if it would be \"HTTP\". The\n   received-by field is\
    \ normally the host and optional port number of a\n   recipient server or client\
    \ that subsequently forwarded the message.\n   However, if the real host is considered\
    \ to be sensitive information,\n   it MAY be replaced by a pseudonym. If the port\
    \ is not given, it MAY\n   be assumed to be the default port of the received-protocol.\n\
    \   Multiple Via field values represent each proxy or gateway that has\n   forwarded\
    \ the message. Each recipient MUST append its information\n   such that the end\
    \ result is ordered according to the sequence of\n   forwarding applications.\n\
    \   Comments MAY be used in the Via header field to identify the software\n  \
    \ of the recipient proxy or gateway, analogous to the User-Agent and\n   Server\
    \ header fields. However, all comments in the Via field are\n   optional and MAY\
    \ be removed by any recipient prior to forwarding the\n   message.\n   For example,\
    \ a request message could be sent from an HTTP/1.0 user\n   agent to an internal\
    \ proxy code-named \"fred\", which uses HTTP/1.1 to\n   forward the request to\
    \ a public proxy at nowhere.com, which completes\n   the request by forwarding\
    \ it to the origin server at www.ics.uci.edu.\n   The request received by www.ics.uci.edu\
    \ would then have the following\n   Via header field:\n          Via: 1.0 fred,\
    \ 1.1 nowhere.com (Apache/1.1)\n   Proxies and gateways used as a portal through\
    \ a network firewall\n   SHOULD NOT, by default, forward the names and ports of\
    \ hosts within\n   the firewall region. This information SHOULD only be propagated\
    \ if\n   explicitly enabled. If not enabled, the received-by host of any host\n\
    \   behind the firewall SHOULD be replaced by an appropriate pseudonym\n   for\
    \ that host.\n   For organizations that have strong privacy requirements for hiding\n\
    \   internal structures, a proxy MAY combine an ordered subsequence of\n   Via\
    \ header field entries with identical received-protocol values into\n   a single\
    \ such entry. For example,\n          Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0\
    \ lucy\n           could be collapsed to\n          Via: 1.0 ricky, 1.1 mertz,\
    \ 1.0 lucy\n   Applications SHOULD NOT combine multiple entries unless they are\
    \ all\n   under the same organizational control and the hosts have already been\n\
    \   replaced by pseudonyms. Applications MUST NOT combine entries which\n   have\
    \ different received-protocol values.\n"
- title: 14.45 Warning
  contents:
  - "14.45 Warning\n   The Warning response-header field is used to carry additional\n\
    \   information about the status of a response which may not be reflected\n  \
    \ by the response status code. This information is typically, though\n   not exclusively,\
    \ used to warn about a possible lack of semantic\n   transparency from caching\
    \ operations.\n   Warning headers are sent with responses using:\n          Warning\
    \    = \"Warning\" \":\" 1#warning-value\n          warning-value = warn-code\
    \ SP warn-agent SP warn-text\n          warn-code  = 2DIGIT\n          warn-agent\
    \ = ( host [ \":\" port ] ) | pseudonym\n                          ; the name\
    \ or pseudonym of the server adding\n                          ; the Warning header,\
    \ for use in debugging\n          warn-text  = quoted-string\n   A response may\
    \ carry more than one Warning header.\n   The warn-text should be in a natural\
    \ language and character set that\n   is most likely to be intelligible to the\
    \ human user receiving the\n   response.  This decision may be based on any available\
    \ knowledge,\n   such as the location of the cache or user, the Accept-Language\
    \ field\n   in a request, the Content-Language field in a response, etc. The\n\
    \   default language is English and the default character set is ISO-\n   8859-1.\n\
    \   If a character set other than ISO-8859-1 is used, it MUST be encoded\n   in\
    \ the warn-text using the method described in RFC 1522 [14].\n   Any server or\
    \ cache may add Warning headers to a response. New\n   Warning headers should\
    \ be added after any existing Warning headers. A\n   cache MUST NOT delete any\
    \ Warning header that it received with a\n   response. However, if a cache successfully\
    \ validates a cache entry,\n   it SHOULD remove any Warning headers previously\
    \ attached to that\n   entry except as specified for specific Warning codes. It\
    \ MUST then\n   add any Warning headers received in the validating response. In\
    \ other\n   words, Warning headers are those that would be attached to the most\n\
    \   recent relevant response.\n   When multiple Warning headers are attached to\
    \ a response, the user\n   agent SHOULD display as many of them as possible, in\
    \ the order that\n   they appear in the response. If it is not possible to display\
    \ all of\n   the warnings, the user agent should follow these heuristics:\n  \
    \   o  Warnings that appear early in the response take priority over those\n \
    \       appearing later in the response.\n     o  Warnings in the user's preferred\
    \ character set take priority over\n        warnings in other character sets but\
    \ with identical warn-codes and\n        warn-agents.\n   Systems that generate\
    \ multiple Warning headers should order them with\n   this user agent behavior\
    \ in mind.\n   This is a list of the currently-defined warn-codes, each with a\n\
    \   recommended warn-text in English, and a description of its meaning.\n"
- title: 10 Response is stale
  contents:
  - "10 Response is stale\n  MUST be included whenever the returned response is stale.\
    \ A cache may\n  add this warning to any response, but may never remove it until\
    \ the\n  response is known to be fresh.\n"
- title: 11 Revalidation failed
  contents:
  - "11 Revalidation failed\n  MUST be included if a cache returns a stale response\
    \ because an\n  attempt to revalidate the response failed, due to an inability\
    \ to\n  reach the server. A cache may add this warning to any response, but\n\
    \  may never remove it until the response is successfully revalidated.\n"
- title: 12 Disconnected operation
  contents:
  - "12 Disconnected operation\n   SHOULD be included if the cache is intentionally\
    \ disconnected from\n  the rest of the network for a period of time.\n"
- title: 13 Heuristic expiration
  contents:
  - "13 Heuristic expiration\n  MUST be included if the cache heuristically chose\
    \ a freshness\n  lifetime greater than 24 hours and the response's age is greater\
    \ than\n  24 hours.\n"
- title: 14 Transformation applied
  contents:
  - "14 Transformation applied\n  MUST be added by an intermediate cache or proxy\
    \ if it applies any\n  transformation changing the content-coding (as specified\
    \ in the\n  Content-Encoding header) or media-type (as specified in the\n  Content-Type\
    \ header) of the response, unless this Warning code\n  already appears in the\
    \ response. MUST NOT be deleted from a response\n  even after revalidation.\n"
- title: 99 Miscellaneous warning
  contents:
  - "99 Miscellaneous warning\n  The warning text may include arbitrary information\
    \ to be presented to\n  a human user, or logged. A system receiving this warning\
    \ MUST NOT\n  take any automated action.\n"
- title: 14.46 WWW-Authenticate
  contents:
  - "14.46 WWW-Authenticate\n   The WWW-Authenticate response-header field MUST be\
    \ included in 401\n   (Unauthorized) response messages. The field value consists\
    \ of at\n   least one challenge that indicates the authentication scheme(s) and\n\
    \   parameters applicable to the Request-URI.\n          WWW-Authenticate  = \"\
    WWW-Authenticate\" \":\" 1#challenge\n   The HTTP access authentication process\
    \ is described in section 11.\n   User agents MUST take special care in parsing\
    \ the WWW-Authenticate\n   field value if it contains more than one challenge,\
    \ or if more than\n   one WWW-Authenticate header field is provided, since the\
    \ contents of\n   a challenge may itself contain a comma-separated list of\n \
    \  authentication parameters.\n"
- title: 15 Security Considerations
  contents:
  - "15 Security Considerations\n   This section is meant to inform application developers,\
    \ information\n   providers, and users of the security limitations in HTTP/1.1\
    \ as\n   described by this document. The discussion does not include\n   definitive\
    \ solutions to the problems revealed, though it does make\n   some suggestions\
    \ for reducing security risks.\n"
- title: 15.1 Authentication of Clients
  contents:
  - "15.1 Authentication of Clients\n   The Basic authentication scheme is not a secure\
    \ method of user\n   authentication, nor does it in any way protect the entity,\
    \ which is\n   transmitted in clear text across the physical network used as the\n\
    \   carrier. HTTP does not prevent additional authentication schemes and\n   encryption\
    \ mechanisms from being employed to increase security or the\n   addition of enhancements\
    \ (such as schemes to use one-time passwords)\n   to Basic authentication.\n \
    \  The most serious flaw in Basic authentication is that it results in\n   the\
    \ essentially clear text transmission of the user's password over\n   the physical\
    \ network. It is this problem which Digest Authentication\n   attempts to address.\n\
    \   Because Basic authentication involves the clear text transmission of\n   passwords\
    \ it SHOULD never be used (without enhancements) to protect\n   sensitive or valuable\
    \ information.\n   A common use of Basic authentication is for identification\
    \ purposes\n   -- requiring the user to provide a user name and password as a\
    \ means\n   of identification, for example, for purposes of gathering accurate\n\
    \   usage statistics on a server. When used in this way it is tempting to\n  \
    \ think that there is no danger in its use if illicit access to the\n   protected\
    \ documents is not a major concern. This is only correct if\n   the server issues\
    \ both user name and password to the users and in\n   particular does not allow\
    \ the user to choose his or her own password.\n   The danger arises because naive\
    \ users frequently reuse a single\n   password to avoid the task of maintaining\
    \ multiple passwords.\n   If a server permits users to select their own passwords,\
    \ then the\n   threat is not only illicit access to documents on the server but\
    \ also\n   illicit access to the accounts of all users who have chosen to use\n\
    \   their account password. If users are allowed to choose their own\n   password\
    \ that also means the server must maintain files containing\n   the (presumably\
    \ encrypted) passwords. Many of these may be the\n   account passwords of users\
    \ perhaps at distant sites. The owner or\n   administrator of such a system could\
    \ conceivably incur liability if\n   this information is not maintained in a secure\
    \ fashion.\n   Basic Authentication is also vulnerable to spoofing by counterfeit\n\
    \   servers. If a user can be led to believe that he is connecting to a\n   host\
    \ containing information protected by basic authentication when in\n   fact he\
    \ is connecting to a hostile server or gateway then the\n   attacker can request\
    \ a password, store it for later use, and feign an\n   error. This type of attack\
    \ is not possible with Digest Authentication\n   [32]. Server implementers SHOULD\
    \ guard against the possibility of\n   this sort of counterfeiting by gateways\
    \ or CGI scripts. In particular\n   it is very dangerous for a server to simply\
    \ turn over a connection to\n   a gateway since that gateway can then use the\
    \ persistent connection\n   mechanism to engage in multiple transactions with\
    \ the client while\n   impersonating the original server in a way that is not\
    \ detectable by\n   the client.\n"
- title: 15.2 Offering a Choice of Authentication Schemes
  contents:
  - "15.2 Offering a Choice of Authentication Schemes\n   An HTTP/1.1 server may return\
    \ multiple challenges with a 401\n   (Authenticate) response, and each challenge\
    \ may use a different\n   scheme.  The order of the challenges returned to the\
    \ user agent is in\n   the order that the server would prefer they be chosen.\
    \ The server\n   should order its challenges with the \"most secure\" authentication\n\
    \   scheme first. A user agent should choose as the challenge to be made\n   to\
    \ the user the first one that the user agent understands.\n   When the server\
    \ offers choices of authentication schemes using the\n   WWW-Authenticate header,\
    \ the \"security\" of the authentication is only\n   as malicious user could capture\
    \ the set of challenges and try to\n   authenticate him/herself using the weakest\
    \ of the authentication\n   schemes. Thus, the ordering serves more to protect\
    \ the user's\n   credentials than the server's information.\n   A possible man-in-the-middle\
    \ (MITM) attack would be to add a weak\n   authentication scheme to the set of\
    \ choices, hoping that the client\n   will use one that exposes the user's credentials\
    \ (e.g. password). For\n   this reason, the client should always use the strongest\
    \ scheme that\n   it understands from the choices accepted.\n   An even better\
    \ MITM attack would be to remove all offered choices,\n   and to insert a challenge\
    \ that requests Basic authentication. For\n   this reason, user agents that are\
    \ concerned about this kind of attack\n   could remember the strongest authentication\
    \ scheme ever requested by\n   a server and produce a warning message that requires\
    \ user\n   confirmation before using a weaker one. A particularly insidious way\n\
    \   to mount such a MITM attack would be to offer a \"free\" proxy caching\n \
    \  service to gullible users.\n"
- title: 15.3 Abuse of Server Log Information
  contents:
  - "15.3 Abuse of Server Log Information\n   A server is in the position to save\
    \ personal data about a user's\n   requests which may identify their reading patterns\
    \ or subjects of\n   interest. This information is clearly confidential in nature\
    \ and its\n   handling may be constrained by law in certain countries. People\
    \ using\n   the HTTP protocol to provide data are responsible for ensuring that\n\
    \   such material is not distributed without the permission of any\n   individuals\
    \ that are identifiable by the published results.\n"
- title: 15.4 Transfer of Sensitive Information
  contents:
  - "15.4 Transfer of Sensitive Information\n   Like any generic data transfer protocol,\
    \ HTTP cannot regulate the\n   content of the data that is transferred, nor is\
    \ there any a priori\n   method of determining the sensitivity of any particular\
    \ piece of\n   information within the context of any given request. Therefore,\n\
    \   applications SHOULD supply as much control over this information as\n   possible\
    \ to the provider of that information. Four header fields are\n   worth special\
    \ mention in this context: Server, Via, Referer and From.\n   Revealing the specific\
    \ software version of the server may allow the\n   server machine to become more\
    \ vulnerable to attacks against software\n   that is known to contain security\
    \ holes. Implementers SHOULD make the\n   Server header field a configurable option.\n\
    \   Proxies which serve as a portal through a network firewall SHOULD\n   take\
    \ special precautions regarding the transfer of header information\n   that identifies\
    \ the hosts behind the firewall. In particular, they\n   SHOULD remove, or replace\
    \ with sanitized versions, any Via fields\n   generated behind the firewall.\n\
    \   The Referer field allows reading patterns to be studied and reverse\n   links\
    \ drawn. Although it can be very useful, its power can be abused\n   if user details\
    \ are not separated from the information contained in\n   the Referer. Even when\
    \ the personal information has been removed, the\n   Referer field may indicate\
    \ a private document's URI whose publication\n   would be inappropriate.\n   The\
    \ information sent in the From field might conflict with the user's\n   privacy\
    \ interests or their site's security policy, and hence it\n   SHOULD NOT be transmitted\
    \ without the user being able to disable,\n   enable, and modify the contents\
    \ of the field. The user MUST be able\n   to set the contents of this field within\
    \ a user preference or\n   application defaults configuration.\n   We suggest,\
    \ though do not require, that a convenient toggle interface\n   be provided for\
    \ the user to enable or disable the sending of From and\n   Referer information.\n"
- title: 15.5 Attacks Based On File and Path Names
  contents:
  - "15.5 Attacks Based On File and Path Names\n   Implementations of HTTP origin\
    \ servers SHOULD be careful to restrict\n   the documents returned by HTTP requests\
    \ to be only those that were\n   intended by the server administrators. If an\
    \ HTTP server translates\n   HTTP URIs directly into file system calls, the server\
    \ MUST take\n   special care not to serve files that were not intended to be\n\
    \   delivered to HTTP clients.  For example, UNIX, Microsoft Windows, and\n  \
    \ other operating systems use \"..\" as a path component to indicate a\n   directory\
    \ level above the current one. On such a system, an HTTP\n   server MUST disallow\
    \ any such construct in the Request-URI if it\n   would otherwise allow access\
    \ to a resource outside those intended to\n   be accessible via the HTTP server.\
    \ Similarly, files intended for\n   reference only internally to the server (such\
    \ as access control\n   files, configuration files, and script code) MUST be protected\
    \ from\n   inappropriate retrieval, since they might contain sensitive\n   information.\
    \ Experience has shown that minor bugs in such HTTP server\n   implementations\
    \ have turned into security risks.\n"
- title: 15.6 Personal Information
  contents:
  - "15.6 Personal Information\n   HTTP clients are often privy to large amounts of\
    \ personal information\n   (e.g. the user's name, location, mail address, passwords,\
    \ encryption\n   keys, etc.), and SHOULD be very careful to prevent unintentional\n\
    \   leakage of this information via the HTTP protocol to other sources.\n   We\
    \ very strongly recommend that a convenient interface be provided\n   for the\
    \ user to control dissemination of such information, and that\n   designers and\
    \ implementers be particularly careful in this area.\n   History shows that errors\
    \ in this area are often both serious\n   security and/or privacy problems, and\
    \ often generate highly adverse\n   publicity for the implementer's company.\n"
- title: 15.7 Privacy Issues Connected to Accept Headers
  contents:
  - "15.7 Privacy Issues Connected to Accept Headers\n   Accept request-headers can\
    \ reveal information about the user to all\n   servers which are accessed. The\
    \ Accept-Language header in particular\n   can reveal information the user would\
    \ consider to be of a private\n   nature, because the understanding of particular\
    \ languages is often\n   strongly correlated to the membership of a particular\
    \ ethnic group.\n   User agents which offer the option to configure the contents\
    \ of an\n   Accept-Language header to be sent in every request are strongly\n\
    \   encouraged to let the configuration process include a message which\n   makes\
    \ the user aware of the loss of privacy involved.\n   An approach that limits\
    \ the loss of privacy would be for a user agent\n   to omit the sending of Accept-Language\
    \ headers by default, and to ask\n   the user whether it should start sending\
    \ Accept-Language headers to a\n   server if it detects, by looking for any Vary\
    \ response-header fields\n   generated by the server, that such sending could\
    \ improve the quality\n   of service.\n   Elaborate user-customized accept header\
    \ fields sent in every request,\n   in particular if these include quality values,\
    \ can be used by servers\n   as relatively reliable and long-lived user identifiers.\
    \ Such user\n   identifiers would allow content providers to do click-trail tracking,\n\
    \   and would allow collaborating content providers to match cross-server\n  \
    \ click-trails or form submissions of individual users. Note that for\n   many\
    \ users not behind a proxy, the network address of the host\n   running the user\
    \ agent will also serve as a long-lived user\n   identifier. In environments where\
    \ proxies are used to enhance\n   privacy, user agents should be conservative\
    \ in offering accept header\n   configuration options to end users. As an extreme\
    \ privacy measure,\n   proxies could filter the accept headers in relayed requests.\
    \ General\n   purpose user agents which provide a high degree of header\n   configurability\
    \ should warn users about the loss of privacy which can\n   be involved.\n"
- title: 15.8 DNS Spoofing
  contents:
  - "15.8 DNS Spoofing\n   Clients using HTTP rely heavily on the Domain Name Service,\
    \ and are\n   thus generally prone to security attacks based on the deliberate\n\
    \   mis-association of IP addresses and DNS names. Clients need to be\n   cautious\
    \ in assuming the continuing validity of an IP number/DNS name\n   association.\n\
    \   In particular, HTTP clients SHOULD rely on their name resolver for\n   confirmation\
    \ of an IP number/DNS name association, rather than\n   caching the result of\
    \ previous host name lookups. Many platforms\n   already can cache host name lookups\
    \ locally when appropriate, and\n   they SHOULD be configured to do so. These\
    \ lookups should be cached,\n   however, only when the TTL (Time To Live) information\
    \ reported by the\n   name server makes it likely that the cached information\
    \ will remain\n   useful.\n   If HTTP clients cache the results of host name lookups\
    \ in order to\n   achieve a performance improvement, they MUST observe the TTL\n\
    \   information reported by DNS.\n   If HTTP clients do not observe this rule,\
    \ they could be spoofed when\n   a previously-accessed server's IP address changes.\
    \ As network\n   renumbering is expected to become increasingly common, the\n\
    \   possibility of this form of attack will grow. Observing this\n   requirement\
    \ thus reduces this potential security vulnerability.\n   This requirement also\
    \ improves the load-balancing behavior of clients\n   for replicated servers using\
    \ the same DNS name and reduces the\n   likelihood of a user's experiencing failure\
    \ in accessing sites which\n   use that strategy.\n"
- title: 15.9 Location Headers and Spoofing
  contents:
  - "15.9 Location Headers and Spoofing\n   If a single server supports multiple organizations\
    \ that do not trust\n   one another, then it must check the values of Location\
    \ and Content-\n   Location headers in responses that are generated under control\
    \ of\n   said organizations to make sure that they do not attempt to\n   invalidate\
    \ resources over which they have no authority.\n"
- title: 16 Acknowledgments
  contents:
  - "16 Acknowledgments\n   This specification makes heavy use of the augmented BNF\
    \ and generic\n   constructs defined by David H. Crocker for RFC 822. Similarly,\
    \ it\n   reuses many of the definitions provided by Nathaniel Borenstein and\n\
    \   Ned Freed for MIME. We hope that their inclusion in this\n   specification\
    \ will help reduce past confusion over the relationship\n   between HTTP and Internet\
    \ mail message formats.\n   The HTTP protocol has evolved considerably over the\
    \ past four years.\n   It has benefited from a large and active developer community--the\n\
    \   many people who have participated on the www-talk mailing list--and\n   it\
    \ is that community which has been most responsible for the success\n   of HTTP\
    \ and of the World-Wide Web in general. Marc Andreessen, Robert\n   Cailliau,\
    \ Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois\n   Groff, Phillip\
    \ M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob\n   McCool, Lou Montulli, Dave\
    \ Raggett, Tony Sanders, and Marc\n   VanHeyningen deserve special recognition\
    \ for their efforts in\n   defining early aspects of the protocol.\n   This document\
    \ has benefited greatly from the comments of all those\n   participating in the\
    \ HTTP-WG. In addition to those already mentioned,\n   the following individuals\
    \ have contributed to this specification:\n          Gary Adams              \
    \    Albert Lunde\n          Harald Tveit Alvestrand     John C. Mallery\n   \
    \       Keith Ball                  Jean-Philippe Martin-Flatin\n          Brian\
    \ Behlendorf            Larry Masinter\n          Paul Burchard              \
    \ Mitra\n          Maurizio Codogno            David Morris\n          Mike Cowlishaw\
    \              Gavin Nicol\n          Roman Czyborra              Bill Perry\n\
    \          Michael A. Dolan            Jeffrey Perry\n          David J. Fiander\
    \            Scott Powers\n          Alan Freier                 Owen Rees\n \
    \         Marc Hedlund                Luigi Rizzo\n          Greg Herlihy    \
    \            David Robinson\n          Koen Holtman                Marc Salomon\n\
    \          Alex Hopmann                Rich Salz\n          Bob Jernigan     \
    \           Allan M. Schiffman\n          Shel Kaphan                 Jim Seidman\n\
    \          Rohit Khare                 Chuck Shotton\n          John Klensin \
    \               Eric W. Sink\n          Martijn Koster              Simon E. Spero\n\
    \          Alexei Kosut                Richard N. Taylor\n          David M. Kristol\
    \            Robert S. Thau\n          Daniel LaLiberte            Bill (BearHeart)\
    \ Weinman\n          Ben Laurie                  Francois Yergeau\n          Paul\
    \ J. Leach               Mary Ellen Zurko\n          Daniel DuBois\n   Much of\
    \ the content and presentation of the caching design is due to\n   suggestions\
    \ and comments from individuals including: Shel Kaphan,\n   Paul Leach, Koen Holtman,\
    \ David Morris, and Larry Masinter.\n   Most of the specification of ranges is\
    \ based on work originally done\n   by Ari Luotonen and John Franks, with additional\
    \ input from Steve\n   Zilles.\n   Thanks to the \"cave men\" of Palo Alto. You\
    \ know who you are.\n   Jim Gettys (the current editor of this document) wishes\
    \ particularly\n   to thank Roy Fielding, the previous editor of this document,\
    \ along\n   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen\n  \
    \ Holtman, John Franks, Alex Hopmann, and Larry Masinter for their\n   help.\n"
- title: 17 References
  contents:
  - "17 References\n   [1] Alvestrand, H., \"Tags for the identification of languages\"\
    , RFC\n   1766, UNINETT, March 1995.\n   [2] Anklesaria, F., McCahill, M., Lindner,\
    \ P., Johnson, D., Torrey,\n   D., and B. Alberti. \"The Internet Gopher Protocol:\
    \ (a distributed\n   document search and retrieval protocol)\", RFC 1436, University\
    \ of\n   Minnesota, March 1993.\n   [3] Berners-Lee, T., \"Universal Resource\
    \ Identifiers in WWW\", A\n   Unifying Syntax for the Expression of Names and\
    \ Addresses of Objects\n   on the Network as used in the World-Wide Web\", RFC\
    \ 1630, CERN, June\n   1994.\n   [4] Berners-Lee, T., Masinter, L., and M. McCahill,\
    \ \"Uniform Resource\n   Locators (URL)\", RFC 1738, CERN, Xerox PARC, University\
    \ of Minnesota,\n   December 1994.\n   [5] Berners-Lee, T., and D. Connolly, \"\
    HyperText Markup Language\n   Specification - 2.0\", RFC 1866, MIT/LCS, November\
    \ 1995.\n   [6] Berners-Lee, T., Fielding, R., and H. Frystyk, \"Hypertext\n \
    \  Transfer Protocol -- HTTP/1.0.\", RFC 1945 MIT/LCS, UC Irvine, May\n   1996.\n\
    \   [7] Freed, N., and N. Borenstein, \"Multipurpose Internet Mail\n   Extensions\
    \ (MIME) Part One: Format of Internet Message Bodies\", RFC\n   2045, Innosoft,\
    \ First Virtual, November 1996.\n   [8] Braden, R., \"Requirements for Internet\
    \ hosts - application and\n   support\", STD 3,  RFC 1123, IETF, October 1989.\n\
    \   [9] Crocker, D., \"Standard for the Format of ARPA Internet Text\n   Messages\"\
    , STD 11, RFC 822, UDEL, August 1982.\n   [10] Davis, F., Kahle, B., Morris, H.,\
    \ Salem, J., Shen, T., Wang, R.,\n   Sui, J., and M. Grinbaum. \"WAIS Interface\
    \ Protocol Prototype\n   Functional Specification\", (v1.5), Thinking Machines\
    \ Corporation,\n   April 1990.\n   [11] Fielding, R., \"Relative Uniform Resource\
    \ Locators\", RFC 1808, UC\n   Irvine, June 1995.\n   [12] Horton, M., and R.\
    \ Adams. \"Standard for interchange of USENET\n   messages\", RFC 1036, AT&T Bell\
    \ Laboratories, Center for Seismic\n   Studies, December 1987.\n   [13] Kantor,\
    \ B., and P. Lapsley. \"Network News Transfer Protocol.\" A\n   Proposed Standard\
    \ for the Stream-Based Transmission of News\", RFC\n   977, UC San Diego, UC Berkeley,\
    \ February 1986.\n   [14] Moore, K., \"MIME (Multipurpose Internet Mail Extensions)\
    \ Part\n   Three: Message Header Extensions for Non-ASCII Text\", RFC 2047,\n\
    \   University of Tennessee, November 1996.\n   [15] Nebel, E., and L. Masinter.\
    \ \"Form-based File Upload in HTML\",\n   RFC 1867, Xerox Corporation, November\
    \ 1995.\n   [16] Postel, J., \"Simple Mail Transfer Protocol\", STD 10, RFC 821,\n\
    \   USC/ISI, August 1982.\n   [17] Postel, J., \"Media Type Registration Procedure\"\
    , RFC 2048,\n   USC/ISI, November 1996.\n   [18] Postel, J., and J. Reynolds,\
    \ \"File Transfer Protocol (FTP)\", STD\n   9, RFC 959, USC/ISI, October 1985.\n\
    \   [19] Reynolds, J., and J. Postel, \"Assigned Numbers\", STD 2, RFC\n   1700,\
    \ USC/ISI, October 1994.\n   [20] Sollins, K., and L. Masinter, \"Functional Requirements\
    \ for\n   Uniform Resource Names\", RFC 1737, MIT/LCS, Xerox Corporation,\n  \
    \ December 1994.\n   [21] US-ASCII. Coded Character Set - 7-Bit American Standard\
    \ Code for\n   Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.\n\
    \   [22] ISO-8859. International Standard -- Information Processing --\n     8-bit\
    \ Single-Byte Coded Graphic Character Sets --\n     Part 1: Latin alphabet No.\
    \ 1, ISO 8859-1:1987.\n     Part 2: Latin alphabet No. 2, ISO 8859-2, 1987.\n\
    \     Part 3: Latin alphabet No. 3, ISO 8859-3, 1988.\n     Part 4: Latin alphabet\
    \ No. 4, ISO 8859-4, 1988.\n     Part 5: Latin/Cyrillic alphabet, ISO 8859-5,\
    \ 1988.\n     Part 6: Latin/Arabic alphabet, ISO 8859-6, 1987.\n     Part 7: Latin/Greek\
    \ alphabet, ISO 8859-7, 1987.\n     Part 8: Latin/Hebrew alphabet, ISO 8859-8,\
    \ 1988.\n     Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.\n   [23] Meyers,\
    \ J., and M. Rose \"The Content-MD5 Header Field\", RFC\n   1864, Carnegie Mellon,\
    \ Dover Beach Consulting, October, 1995.\n   [24] Carpenter, B., and Y. Rekhter,\
    \ \"Renumbering Needs Work\", RFC\n   1900, IAB, February 1996.\n   [25] Deutsch,\
    \ P., \"GZIP file format specification version 4.3.\" RFC\n   1952, Aladdin Enterprises,\
    \ May 1996.\n   [26] Venkata N. Padmanabhan and Jeffrey C. Mogul. Improving HTTP\n\
    \   Latency. Computer Networks and ISDN Systems, v. 28, pp. 25-35, Dec.\n   1995.\
    \  Slightly revised version of paper in Proc. 2nd International\n   WWW Conf.\
    \ '94: Mosaic and the Web, Oct. 1994, which is available at\n   http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/\n\
    \   HTTPLatency.html.\n   [27] Joe Touch, John Heidemann, and Katia Obraczka,\
    \ \"Analysis of HTTP\n   Performance\", <URL: http://www.isi.edu/lsam/ib/http-perf/>,\n\
    \   USC/Information Sciences Institute, June 1996\n   [28] Mills, D., \"Network\
    \ Time Protocol, Version 3, Specification,\n   Implementation and Analysis\",\
    \ RFC 1305, University of Delaware, March\n   1992.\n   [29] Deutsch, P., \"DEFLATE\
    \ Compressed Data Format Specification\n   version 1.3.\" RFC 1951, Aladdin Enterprises,\
    \ May 1996.\n   [30] Spero, S., \"Analysis of HTTP Performance Problems\"\n  \
    \ <URL:http://sunsite.unc.edu/mdma-release/http-prob.html>.\n   [31] Deutsch,\
    \ P., and J-L. Gailly, \"ZLIB Compressed Data Format\n   Specification version\
    \ 3.3\", RFC 1950, Aladdin Enterprises, Info-ZIP,\n   May 1996.\n   [32] Franks,\
    \ J., Hallam-Baker, P., Hostetler, J., Leach, P.,\n   Luotonen, A., Sink, E.,\
    \ and L. Stewart, \"An Extension to HTTP :\n   Digest Access Authentication\"\
    , RFC 2069, January 1997.\n"
- title: 18 Authors' Addresses
  contents:
  - "18 Authors' Addresses\n   Roy T. Fielding\n   Department of Information and Computer\
    \ Science\n   University of California\n   Irvine, CA 92717-3425, USA\n   Fax:\
    \ +1 (714) 824-4056\n   EMail: fielding@ics.uci.edu\n   Jim Gettys\n   MIT Laboratory\
    \ for Computer Science\n   545 Technology Square\n   Cambridge, MA 02139, USA\n\
    \   Fax: +1 (617) 258 8682\n   EMail: jg@w3.org\n   Jeffrey C. Mogul\n   Western\
    \ Research Laboratory\n   Digital Equipment Corporation\n   250 University Avenue\n\
    \   Palo Alto, California, 94305, USA\n   EMail: mogul@wrl.dec.com\n   Henrik\
    \ Frystyk Nielsen\n   W3 Consortium\n   MIT Laboratory for Computer Science\n\
    \   545 Technology Square\n   Cambridge, MA 02139, USA\n   Fax: +1 (617) 258 8682\n\
    \   EMail: frystyk@w3.org\n   Tim Berners-Lee\n   Director, W3 Consortium\n  \
    \ MIT Laboratory for Computer Science\n   545 Technology Square\n   Cambridge,\
    \ MA 02139, USA\n   Fax: +1 (617) 258 8682\n   EMail: timbl@w3.org\n"
- title: 19 Appendices
  contents:
  - '19 Appendices

    '
- title: 19.1 Internet Media Type message/http
  contents:
  - "19.1 Internet Media Type message/http\n   In addition to defining the HTTP/1.1\
    \ protocol, this document serves\n   as the specification for the Internet media\
    \ type \"message/http\". The\n   following is to be registered with IANA.\n  \
    \     Media Type name:         message\n       Media subtype name:      http\n\
    \       Required parameters:     none\n       Optional parameters:     version,\
    \ msgtype\n        version: The HTTP-Version number of the enclosed message\n\
    \                 (e.g., \"1.1\"). If not present, the version can be\n      \
    \           determined from the first line of the body.\n        msgtype: The\
    \ message type -- \"request\" or \"response\". If not\n                 present,\
    \ the type can be determined from the first\n                 line of the body.\n\
    \       Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n\
    \                                permitted\n       Security considerations: none\n"
- title: 19.2 Internet Media Type multipart/byteranges
  contents:
  - "19.2 Internet Media Type multipart/byteranges\n   When an HTTP message includes\
    \ the content of multiple ranges (for\n   example, a response to a request for\
    \ multiple non-overlapping\n   ranges), these are transmitted as a multipart MIME\
    \ message. The\n   multipart media type for this purpose is called\n   \"multipart/byteranges\"\
    .\n   The multipart/byteranges media type includes two or more parts, each\n \
    \  with its own Content-Type and Content-Range fields. The parts are\n   separated\
    \ using a MIME boundary parameter.\n          Media Type name:         multipart\n\
    \          Media subtype name:      byteranges\n          Required parameters:\
    \     boundary\n          Optional parameters:     none\n          Encoding considerations:\
    \ only \"7bit\", \"8bit\", or \"binary\" are\n                               \
    \    permitted\n          Security considerations: none\n"
- title: 'For example:'
  contents:
  - "For example:\n   HTTP/1.1 206 Partial content\n   Date: Wed, 15 Nov 1995 06:25:24\
    \ GMT\n   Last-modified: Wed, 15 Nov 1995 04:58:08 GMT\n   Content-type: multipart/byteranges;\
    \ boundary=THIS_STRING_SEPARATES\n   --THIS_STRING_SEPARATES\n   Content-type:\
    \ application/pdf\n   Content-range: bytes 500-999/8000\n   ...the first range...\n\
    \   --THIS_STRING_SEPARATES\n   Content-type: application/pdf\n   Content-range:\
    \ bytes 7000-7999/8000\n   ...the second range\n   --THIS_STRING_SEPARATES--\n"
- title: 19.3 Tolerant Applications
  contents:
  - "19.3 Tolerant Applications\n   Although this document specifies the requirements\
    \ for the generation\n   of HTTP/1.1 messages, not all applications will be correct\
    \ in their\n   implementation. We therefore recommend that operational applications\n\
    \   be tolerant of deviations whenever those deviations can be\n   interpreted\
    \ unambiguously.\n   Clients SHOULD be tolerant in parsing the Status-Line and\
    \ servers\n   tolerant when parsing the Request-Line. In particular, they SHOULD\n\
    \   accept any amount of SP or HT characters between fields, even though\n   only\
    \ a single SP is required.\n   The line terminator for message-header fields is\
    \ the sequence CRLF.\n   However, we recommend that applications, when parsing\
    \ such headers,\n   recognize a single LF as a line terminator and ignore the\
    \ leading CR.\n   The character set of an entity-body should be labeled as the\
    \ lowest\n   common denominator of the character codes used within that body,\
    \ with\n   the exception that no label is preferred over the labels US-ASCII or\n\
    \   ISO-8859-1.\n   Additional rules for requirements on parsing and encoding\
    \ of dates\n   and other potential problems with date encodings include:\n  o\
    \  HTTP/1.1 clients and caches should assume that an RFC-850 date\n     which\
    \ appears to be more than 50 years in the future is in fact\n     in the past\
    \ (this helps solve the \"year 2000\" problem).\n  o  An HTTP/1.1 implementation\
    \ may internally represent a parsed\n     Expires date as earlier than the proper\
    \ value, but MUST NOT\n     internally represent a parsed Expires date as later\
    \ than the\n     proper value.\n  o  All expiration-related calculations must\
    \ be done in GMT. The\n     local time zone MUST NOT influence the calculation\
    \ or comparison\n     of an age or expiration time.\n  o  If an HTTP header incorrectly\
    \ carries a date value with a time\n     zone other than GMT, it must be converted\
    \ into GMT using the most\n     conservative possible conversion.\n"
- title: 19.4 Differences Between HTTP Entities and MIME Entities
  contents:
  - "19.4 Differences Between HTTP Entities and MIME Entities\n   HTTP/1.1 uses many\
    \ of the constructs defined for Internet Mail (RFC\n   822) and the Multipurpose\
    \ Internet Mail Extensions (MIME ) to allow\n   entities to be transmitted in\
    \ an open variety of representations and\n   with extensible mechanisms. However,\
    \ MIME [7] discusses mail, and\n   HTTP has a few features that are different\
    \ from those described in\n   MIME.  These differences were carefully chosen to\
    \ optimize\n   performance over binary connections, to allow greater freedom in\
    \ the\n   use of new media types, to make date comparisons easier, and to\n  \
    \ acknowledge the practice of some early HTTP servers and clients.\n   This appendix\
    \ describes specific areas where HTTP differs from MIME.\n   Proxies and gateways\
    \ to strict MIME environments SHOULD be aware of\n   these differences and provide\
    \ the appropriate conversions where\n   necessary. Proxies and gateways from MIME\
    \ environments to HTTP also\n   need to be aware of the differences because some\
    \ conversions may be\n   required.\n"
- title: 19.4.1 Conversion to Canonical Form
  contents:
  - "19.4.1 Conversion to Canonical Form\n   MIME requires that an Internet mail entity\
    \ be converted to canonical\n   form prior to being transferred.  Section 3.7.1\
    \ of this document\n   describes the forms allowed for subtypes of the \"text\"\
    \ media type\n   when transmitted over HTTP. MIME requires that content with a\
    \ type of\n   \"text\" represent line breaks as CRLF and forbids the use of CR\
    \ or LF\n   outside of line break sequences.  HTTP allows CRLF, bare CR, and bare\n\
    \   LF to indicate a line break within text content when a message is\n   transmitted\
    \ over HTTP.\n   Where it is possible, a proxy or gateway from HTTP to a strict\
    \ MIME\n   environment SHOULD translate all line breaks within the text media\n\
    \   types described in section 3.7.1 of this document to the MIME\n   canonical\
    \ form of CRLF. Note, however, that this may be complicated\n   by the presence\
    \ of a Content-Encoding and by the fact that HTTP\n   allows the use of some character\
    \ sets which do not use octets 13 and\n   10 to represent CR and LF, as is the\
    \ case for some multi-byte\n   character sets.\n"
- title: 19.4.2 Conversion of Date Formats
  contents:
  - "19.4.2 Conversion of Date Formats\n   HTTP/1.1 uses a restricted set of date\
    \ formats (section 3.3.1) to\n   simplify the process of date comparison. Proxies\
    \ and gateways from\n   other protocols SHOULD ensure that any Date header field\
    \ present in a\n   message conforms to one of the HTTP/1.1 formats and rewrite\
    \ the date\n   if necessary.\n"
- title: 19.4.3 Introduction of Content-Encoding
  contents:
  - "19.4.3 Introduction of Content-Encoding\n   MIME does not include any concept\
    \ equivalent to HTTP/1.1's Content-\n   Encoding header field. Since this acts\
    \ as a modifier on the media\n   type, proxies and gateways from HTTP to MIME-compliant\
    \ protocols MUST\n   either change the value of the Content-Type header field\
    \ or decode\n   the entity-body before forwarding the message. (Some experimental\n\
    \   applications of Content-Type for Internet mail have used a media-type\n  \
    \ parameter of \";conversions=<content-coding>\" to perform an equivalent\n  \
    \ function as Content-Encoding. However, this parameter is not part of\n   MIME.)\n"
- title: 19.4.4 No Content-Transfer-Encoding
  contents:
  - "19.4.4 No Content-Transfer-Encoding\n   HTTP does not use the Content-Transfer-Encoding\
    \ (CTE) field of MIME.\n   Proxies and gateways from MIME-compliant protocols\
    \ to HTTP MUST\n   remove any non-identity CTE (\"quoted-printable\" or \"base64\"\
    ) encoding\n   prior to delivering the response message to an HTTP client.\n \
    \  Proxies and gateways from HTTP to MIME-compliant protocols are\n   responsible\
    \ for ensuring that the message is in the correct format\n   and encoding for\
    \ safe transport on that protocol, where \"safe\n   transport\" is defined by\
    \ the limitations of the protocol being used.\n   Such a proxy or gateway SHOULD\
    \ label the data with an appropriate\n   Content-Transfer-Encoding if doing so\
    \ will improve the likelihood of\n   safe transport over the destination protocol.\n"
- title: 19.4.5 HTTP Header Fields in Multipart Body-Parts
  contents:
  - "19.4.5 HTTP Header Fields in Multipart Body-Parts\n   In MIME, most header fields\
    \ in multipart body-parts are generally\n   ignored unless the field name begins\
    \ with \"Content-\". In HTTP/1.1,\n   multipart body-parts may contain any HTTP\
    \ header fields which are\n   significant to the meaning of that part.\n"
- title: 19.4.6 Introduction of Transfer-Encoding
  contents:
  - "19.4.6 Introduction of Transfer-Encoding\n   HTTP/1.1 introduces the Transfer-Encoding\
    \ header field (section\n   14.40).  Proxies/gateways MUST remove any transfer\
    \ coding prior to\n   forwarding a message via a MIME-compliant protocol.\n  \
    \ A process for decoding the \"chunked\" transfer coding (section 3.6)\n   can\
    \ be represented in pseudo-code as:\n          length := 0\n          read chunk-size,\
    \ chunk-ext (if any) and CRLF\n          while (chunk-size > 0) {\n          \
    \   read chunk-data and CRLF\n             append chunk-data to entity-body\n\
    \             length := length + chunk-size\n             read chunk-size and\
    \ CRLF\n          }\n          read entity-header\n          while (entity-header\
    \ not empty) {\n             append entity-header to existing header fields\n\
    \             read entity-header\n          }\n          Content-Length := length\n\
    \          Remove \"chunked\" from Transfer-Encoding\n"
- title: 19.4.7 MIME-Version
  contents:
  - "19.4.7 MIME-Version\n   HTTP is not a MIME-compliant protocol (see appendix 19.4).\
    \ However,\n   HTTP/1.1 messages may include a single MIME-Version general-header\n\
    \   field to indicate what version of the MIME protocol was used to\n   construct\
    \ the message. Use of the MIME-Version header field indicates\n   that the message\
    \ is in full compliance with the MIME protocol.\n   Proxies/gateways are responsible\
    \ for ensuring full compliance (where\n   possible) when exporting HTTP messages\
    \ to strict MIME environments.\n          MIME-Version   = \"MIME-Version\" \"\
    :\" 1*DIGIT \".\" 1*DIGIT\n   MIME version \"1.0\" is the default for use in HTTP/1.1.\
    \ However,\n   HTTP/1.1 message parsing and semantics are defined by this document\n\
    \   and not the MIME specification.\n"
- title: 19.5 Changes from HTTP/1.0
  contents:
  - "19.5 Changes from HTTP/1.0\n   This section summarizes major differences between\
    \ versions HTTP/1.0\n   and HTTP/1.1.\n"
- title: 19.5.1 Changes to Simplify Multi-homed Web Servers and Conserve IP
  contents:
  - "19.5.1 Changes to Simplify Multi-homed Web Servers and Conserve IP\n       Addresses\n\
    \   The requirements that clients and servers support the Host request-\n   header,\
    \ report an error if the Host request-header (section 14.23) is\n   missing from\
    \ an HTTP/1.1 request, and accept absolute URIs (section\n   5.1.2) are among\
    \ the most important changes defined by this\n   specification.\n   Older HTTP/1.0\
    \ clients assumed a one-to-one relationship of IP\n   addresses and servers; there\
    \ was no other established mechanism for\n   distinguishing the intended server\
    \ of a request than the IP address\n   to which that request was directed. The\
    \ changes outlined above will\n   allow the Internet, once older HTTP clients\
    \ are no longer common, to\n   support multiple Web sites from a single IP address,\
    \ greatly\n   simplifying large operational Web servers, where allocation of many\n\
    \   IP addresses to a single host has created serious problems. The\n   Internet\
    \ will also be able to recover the IP addresses that have been\n   allocated for\
    \ the sole purpose of allowing special-purpose domain\n   names to be used in\
    \ root-level HTTP URLs. Given the rate of growth of\n   the Web, and the number\
    \ of servers already deployed, it is extremely\n   important that all implementations\
    \ of HTTP (including updates to\n   existing HTTP/1.0 applications) correctly\
    \ implement these\n   requirements:\n     o  Both clients and servers MUST support\
    \ the Host request-header.\n     o  Host request-headers are required in HTTP/1.1\
    \ requests.\n     o  Servers MUST report a 400 (Bad Request) error if an HTTP/1.1\n\
    \        request does not include a Host request-header.\n     o  Servers MUST\
    \ accept absolute URIs.\n"
- title: 19.6 Additional Features
  contents:
  - "19.6 Additional Features\n   This appendix documents protocol elements used by\
    \ some existing HTTP\n   implementations, but not consistently and correctly across\
    \ most\n   HTTP/1.1 applications. Implementers should be aware of these\n   features,\
    \ but cannot rely upon their presence in, or interoperability\n   with, other\
    \ HTTP/1.1 applications. Some of these describe proposed\n   experimental features,\
    \ and some describe features that experimental\n   deployment found lacking that\
    \ are now addressed in the base HTTP/1.1\n   specification.\n"
- title: 19.6.1 Additional Request Methods
  contents:
  - '19.6.1 Additional Request Methods

    '
- title: 19.6.1.1 PATCH
  contents:
  - "19.6.1.1 PATCH\n   The PATCH method is similar to PUT except that the entity\
    \ contains a\n   list of differences between the original version of the resource\n\
    \   identified by the Request-URI and the desired content of the resource\n  \
    \ after the PATCH action has been applied. The list of differences is\n   in a\
    \ format defined by the media type of the entity (e.g.,\n   \"application/diff\"\
    ) and MUST include sufficient information to allow\n   the server to recreate\
    \ the changes necessary to convert the original\n   version of the resource to\
    \ the desired version.\n   If the request passes through a cache and the Request-URI\
    \ identifies\n   a currently cached entity, that entity MUST be removed from the\n\
    \   cache.  Responses to this method are not cachable.\n   The actual method for\
    \ determining how the patched resource is placed,\n   and what happens to its\
    \ predecessor, is defined entirely by the\n   origin server. If the original version\
    \ of the resource being patched\n   included a Content-Version header field, the\
    \ request entity MUST\n   include a Derived-From header field corresponding to\
    \ the value of the\n   original Content-Version header field. Applications are\
    \ encouraged to\n   use these fields for constructing versioning relationships\
    \ and\n   resolving version conflicts.\n   PATCH requests must obey the message\
    \ transmission requirements set\n   out in section 8.2.\n   Caches that implement\
    \ PATCH should invalidate cached responses as\n   defined in section 13.10 for\
    \ PUT.\n"
- title: 19.6.1.2 LINK
  contents:
  - "19.6.1.2 LINK\n   The LINK method establishes one or more Link relationships\
    \ between\n   the existing resource identified by the Request-URI and other\n\
    \   existing resources. The difference between LINK and other methods\n   allowing\
    \ links to be established between resources is that the LINK\n   method does not\
    \ allow any message-body to be sent in the request and\n   does not directly result\
    \ in the creation of new resources.\n   If the request passes through a cache\
    \ and the Request-URI identifies\n   a currently cached entity, that entity MUST\
    \ be removed from the\n   cache.  Responses to this method are not cachable.\n\
    \   Caches that implement LINK should invalidate cached responses as\n   defined\
    \ in section 13.10 for PUT.\n"
- title: 19.6.1.3 UNLINK
  contents:
  - "19.6.1.3 UNLINK\n   The UNLINK method removes one or more Link relationships\
    \ from the\n   existing resource identified by the Request-URI. These relationships\n\
    \   may have been established using the LINK method or by any other\n   method\
    \ supporting the Link header. The removal of a link to a\n   resource does not\
    \ imply that the resource ceases to exist or becomes\n   inaccessible for future\
    \ references.\n   If the request passes through a cache and the Request-URI identifies\n\
    \   a currently cached entity, that entity MUST be removed from the\n   cache.\
    \  Responses to this method are not cachable.\n   Caches that implement UNLINK\
    \ should invalidate cached responses as\n   defined in section 13.10 for PUT.\n"
- title: 19.6.2 Additional Header Field Definitions
  contents:
  - '19.6.2 Additional Header Field Definitions

    '
- title: 19.6.2.1 Alternates
  contents:
  - "19.6.2.1 Alternates\n   The Alternates response-header field has been proposed\
    \ as a means for\n   the origin server to inform the client about other available\n\
    \   representations of the requested resource, along with their\n   distinguishing\
    \ attributes, and thus providing a more reliable means\n   for a user agent to\
    \ perform subsequent selection of another\n   representation which better fits\
    \ the desires of its user (described\n   as agent-driven negotiation in section\
    \ 12).\n   The Alternates header field is orthogonal to the Vary header field\
    \ in\n   that both may coexist in a message without affecting the\n   interpretation\
    \ of the response or the available representations. It\n   is expected that Alternates\
    \ will provide a significant improvement\n   over the server-driven negotiation\
    \ provided by the Vary field for\n   those resources that vary over common dimensions\
    \ like type and\n   language.\n   The Alternates header field will be defined\
    \ in a future\n   specification.\n"
- title: 19.6.2.2 Content-Version
  contents:
  - "19.6.2.2 Content-Version\n   The Content-Version entity-header field defines\
    \ the version tag\n   associated with a rendition of an evolving entity. Together\
    \ with the\n   Derived-From field described in section 19.6.2.3, it allows a group\n\
    \   of people to work simultaneously on the creation of a work as an\n   iterative\
    \ process. The field should be used to allow evolution of a\n   particular work\
    \ along a single path rather than derived works or\n   renditions in different\
    \ representations.\n          Content-Version = \"Content-Version\" \":\" quoted-string\n\
    \   Examples of the Content-Version field include:\n          Content-Version:\
    \ \"2.1.2\"\n          Content-Version: \"Fred 19950116-12:26:48\"\n         \
    \ Content-Version: \"2.5a4-omega7\"\n"
- title: 19.6.2.3 Derived-From
  contents:
  - "19.6.2.3 Derived-From\n   The Derived-From entity-header field can be used to\
    \ indicate the\n   version tag of the resource from which the enclosed entity\
    \ was\n   derived before modifications were made by the sender. This field is\n\
    \   used to help manage the process of merging successive changes to a\n   resource,\
    \ particularly when such changes are being made in parallel\n   and from multiple\
    \ sources.\n          Derived-From   = \"Derived-From\" \":\" quoted-string\n\
    \   An example use of the field is:\n          Derived-From: \"2.1.1\"\n   The\
    \ Derived-From field is required for PUT and PATCH requests if the\n   entity\
    \ being sent was previously retrieved from the same URI and a\n   Content-Version\
    \ header was included with the entity when it was last\n   retrieved.\n"
- title: 19.6.2.4 Link
  contents:
  - "19.6.2.4 Link\n   The Link entity-header field provides a means for describing\
    \ a\n   relationship between two resources, generally between the requested\n\
    \   resource and some other resource. An entity MAY include multiple Link\n  \
    \ values. Links at the metainformation level typically indicate\n   relationships\
    \ like hierarchical structure and navigation paths. The\n   Link field is semantically\
    \ equivalent to the <LINK> element in\n   HTML.[5]\n          Link           =\
    \ \"Link\" \":\" #(\"<\" URI \">\" *( \";\" link-param )\n          link-param\
    \     = ( ( \"rel\" \"=\" relationship )\n                             | ( \"\
    rev\" \"=\" relationship )\n                             | ( \"title\" \"=\" quoted-string\
    \ )\n                             | ( \"anchor\" \"=\" <\"> URI <\"> )\n     \
    \                        | ( link-extension ) )\n          link-extension = token\
    \ [ \"=\" ( token | quoted-string ) ]\n          relationship   = sgml-name\n\
    \                         | ( <\"> sgml-name *( SP sgml-name) <\"> )\n       \
    \   sgml-name      = ALPHA *( ALPHA | DIGIT | \".\" | \"-\" )\n   Relationship\
    \ values are case-insensitive and MAY be extended within\n   the constraints of\
    \ the sgml-name syntax. The title parameter MAY be\n   used to label the destination\
    \ of a link such that it can be used as\n   identification within a human-readable\
    \ menu. The anchor parameter MAY\n   be used to indicate a source anchor other\
    \ than the entire current\n   resource, such as a fragment of this resource or\
    \ a third resource.\n   Examples of usage include:\n       Link: <http://www.cern.ch/TheBook/chapter2>;\
    \ rel=\"Previous\"\n       Link: <mailto:timbl@w3.org>; rev=\"Made\"; title=\"\
    Tim Berners-Lee\"\n   The first example indicates that chapter2 is previous to\
    \ this\n   resource in a logical navigation path. The second indicates that the\n\
    \   person responsible for making the resource available is identified by\n  \
    \ the given e-mail address.\n"
- title: 19.6.2.5 URI
  contents:
  - "19.6.2.5 URI\n   The URI header field has, in past versions of this specification,\n\
    \   been used as a combination of the existing Location, Content-\n   Location,\
    \ and Vary header fields as well as the future Alternates\n   field (above). Its\
    \ primary purpose has been to include a list of\n   additional URIs for the resource,\
    \ including names and mirror\n   locations. However, it has become clear that\
    \ the combination of many\n   different functions within this single field has\
    \ been a barrier to\n   consistently and correctly implementing any of those functions.\n\
    \   Furthermore, we believe that the identification of names and mirror\n   locations\
    \ would be better performed via the Link header field. The\n   URI header field\
    \ is therefore deprecated in favor of those other\n   fields.\n          URI-header\
    \    = \"URI\" \":\" 1#( \"<\" URI \">\" )\n"
- title: 19.7 Compatibility with Previous Versions
  contents:
  - "19.7 Compatibility with Previous Versions\n   It is beyond the scope of a protocol\
    \ specification to mandate\n   compliance with previous versions. HTTP/1.1 was\
    \ deliberately\n   designed, however, to make supporting previous versions easy.\
    \ It is\n   worth noting that at the time of composing this specification, we\n\
    \   would expect commercial HTTP/1.1 servers to:\n  o  recognize the format of\
    \ the Request-Line for HTTP/0.9, 1.0, and 1.1\n     requests;\n  o  understand\
    \ any valid request in the format of HTTP/0.9, 1.0, or\n     1.1;\n  o  respond\
    \ appropriately with a message in the same major version used\n     by the client.\n\
    \   And we would expect HTTP/1.1 clients to:\n  o  recognize the format of the\
    \ Status-Line for HTTP/1.0 and 1.1\n     responses;\n  o  understand any valid\
    \ response in the format of HTTP/0.9, 1.0, or\n     1.1.\n   For most implementations\
    \ of HTTP/1.0, each connection is established\n   by the client prior to the request\
    \ and closed by the server after\n   sending the response. A few implementations\
    \ implement the Keep-Alive\n   version of persistent connections described in\
    \ section 19.7.1.1.\n"
- title: 19.7.1 Compatibility with HTTP/1.0 Persistent Connections
  contents:
  - "19.7.1 Compatibility with HTTP/1.0 Persistent Connections\n   Some clients and\
    \ servers may wish to be compatible with some previous\n   implementations of\
    \ persistent connections in HTTP/1.0 clients and\n   servers. Persistent connections\
    \ in HTTP/1.0 must be explicitly\n   negotiated as they are not the default behavior.\
    \ HTTP/1.0\n   experimental implementations of persistent connections are faulty,\n\
    \   and the new facilities in HTTP/1.1 are designed to rectify these\n   problems.\
    \ The problem was that some existing 1.0 clients may be\n   sending Keep-Alive\
    \ to a proxy server that doesn't understand\n   Connection, which would then erroneously\
    \ forward it to the next\n   inbound server, which would establish the Keep-Alive\
    \ connection and\n   result in a hung HTTP/1.0 proxy waiting for the close on\
    \ the\n   response. The result is that HTTP/1.0 clients must be prevented from\n\
    \   using Keep-Alive when talking to proxies.\n   However, talking to proxies\
    \ is the most important use of persistent\n   connections, so that prohibition\
    \ is clearly unacceptable. Therefore,\n   we need some other mechanism for indicating\
    \ a persistent connection\n   is desired, which is safe to use even when talking\
    \ to an old proxy\n   that ignores Connection. Persistent connections are the\
    \ default for\n   HTTP/1.1 messages; we introduce a new keyword (Connection: close)\
    \ for\n   declaring non-persistence.\n   The following describes the original\
    \ HTTP/1.0 form of persistent\n   connections.\n   When it connects to an origin\
    \ server, an HTTP client MAY send the\n   Keep-Alive connection-token in addition\
    \ to the Persist connection-\n   token:\n          Connection: Keep-Alive\n  \
    \ An HTTP/1.0 server would then respond with the Keep-Alive connection\n   token\
    \ and the client may proceed with an HTTP/1.0 (or Keep-Alive)\n   persistent connection.\n\
    \   An HTTP/1.1 server may also establish persistent connections with\n   HTTP/1.0\
    \ clients upon receipt of a Keep-Alive connection token.\n   However, a persistent\
    \ connection with an HTTP/1.0 client cannot make\n   use of the chunked transfer-coding,\
    \ and therefore MUST use a\n   Content-Length for marking the ending boundary\
    \ of each message.\n   A client MUST NOT send the Keep-Alive connection token\
    \ to a proxy\n   server as HTTP/1.0 proxy servers do not obey the rules of HTTP/1.1\n\
    \   for parsing the Connection header field.\n"
- title: 19.7.1.1 The Keep-Alive Header
  contents:
  - "19.7.1.1 The Keep-Alive Header\n   When the Keep-Alive connection-token has been\
    \ transmitted with a\n   request or a response, a Keep-Alive header field MAY\
    \ also be\n   included. The Keep-Alive header field takes the following form:\n\
    \          Keep-Alive-header = \"Keep-Alive\" \":\" 0# keepalive-param\n     \
    \     keepalive-param = param-name \"=\" value\n   The Keep-Alive header itself\
    \ is optional, and is used only if a\n   parameter is being sent. HTTP/1.1 does\
    \ not define any parameters.\n   If the Keep-Alive header is sent, the corresponding\
    \ connection token\n   MUST be transmitted. The Keep-Alive header MUST be ignored\
    \ if\n   received without the connection token.\n"
