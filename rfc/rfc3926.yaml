- title: __initial_text__
  contents:
  - '          FLUTE - File Delivery over Unidirectional Transport

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines FLUTE, a protocol for the unidirectional\n\
    \   delivery of files over the Internet, which is particularly suited to\n   multicast\
    \ networks.  The specification builds on Asynchronous Layered\n   Coding, the\
    \ base protocol designed for massively scalable multicast\n   distribution.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n       1.1.  Applicability Statement  . . . . . . . . . . .\
    \ . . . . .  3\n             1.1.1.  The Target Application Space . . . . . .\
    \ . . . .  3\n             1.1.2.  The Target Scale . . . . . . . . . . . . .\
    \ . . .  4\n             1.1.3.  Intended Environments  . . . . . . . . . . .\
    \ . .  4\n             1.1.4.  Weaknesses . . . . . . . . . . . . . . . . . .\
    \ .  4\n   2.  Conventions used in this Document. . . . . . . . . . . . . . .\
    \  5\n   3.  File delivery  . . . . . . . . . . . . . . . . . . . . . . . .  5\n\
    \       3.1.  File delivery session  . . . . . . . . . . . . . . . . .  6\n  \
    \     3.2.  File Delivery Table. . . . . . . . . . . . . . . . . . .  8\n    \
    \   3.3.  Dynamics of FDT Instances within file delivery session .  9\n      \
    \ 3.4.  Structure of FDT Instance packets. . . . . . . . . . . . 11\n        \
    \     3.4.1.  Format of FDT Instance Header  . . . . . . . . . 12\n          \
    \   3.4.2.  Syntax of FDT Instance . . . . . . . . . . . . . 13\n            \
    \ 3.4.3.  Content Encoding of FDT Instance . . . . . . . . 16\n       3.5.  Multiplexing\
    \ of files within a file delivery session . . 17\n   4.  Channels, congestion\
    \ control and timing  . . . . . . . . . . . 18\n   5.  Delivering FEC Object Transmission\
    \ Information . . . . . . . . 19\n       5.1.  Use of EXT_FTI for delivery of\
    \ FEC Object Transmission\n             Information. . . . . . . . . . . . . .\
    \ . . . . . . . . . 20\n             5.1.1.  General EXT_FTI format . . . . .\
    \ . . . . . . . . 20\n             5.1.2.  FEC Encoding ID specific formats for\
    \ EXT_FTI . . 21\n       5.2.  Use of FDT for delivery of FEC Object Transmission\n\
    \             Information. . . . . . . . . . . . . . . . . . . . . . . 25\n  \
    \ 6.  Describing file delivery sessions. . . . . . . . . . . . . . . 25\n   7.\
    \  Security Considerations  . . . . . . . . . . . . . . . . . . . 26\n   8.  IANA\
    \ Considerations  . . . . . . . . . . . . . . . . . . . . . 29\n   9.  Acknowledgements\
    \ . . . . . . . . . . . . . . . . . . . . . . . 29\n       Normative References\
    \ . . . . . . . . . . . . . . . . . . . . . 29\n       Informative References\
    \ . . . . . . . . . . . . . . . . . . . . 30\n   A.  Receiver operation (informative)\
    \ . . . . . . . . . . . . . . . 32\n   B.  Example of FDT Instance (informative).\
    \ . . . . . . . . . . . . 33\n       Authors' Addresses . . . . . . . . . . .\
    \ . . . . . . . . . . . 34\n       Full Copyright Statement . . . . . . . . .\
    \ . . . . . . . . . . 35\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines FLUTE version 1, a protocol for unidirectional\n\
    \   delivery of files over the Internet.  The specification builds on\n   Asynchronous\
    \ Layered Coding (ALC), version 1 [2], the base protocol\n   designed for massively\
    \ scalable multicast distribution.  ALC defines\n   transport of arbitrary binary\
    \ objects.  For file delivery\n   applications mere transport of objects is not\
    \ enough, however.  The\n   end systems need to know what the objects actually\
    \ represent.  This\n   document specifies a technique called FLUTE - a mechanism\
    \ for\n   signaling and mapping the properties of files to concepts of ALC in\
    \ a\n   way that allows receivers to assign those parameters for received\n  \
    \ objects.  Consequently, throughout this document the term 'file'\n   relates\
    \ to an 'object' as discussed in ALC.  Although this\n   specification frequently\
    \ makes use of multicast addressing as an\n   example, the techniques are similarly\
    \ applicable for use with unicast\n   addressing.\n   This document defines a\
    \ specific transport application of ALC, adding\n   the following specifications:\n\
    \   -  Definition of a file delivery session built on top of ALC,\n      including\
    \ transport details and timing constraints.\n   -  In-band signalling of the transport\
    \ parameters of the ALC session.\n   -  In-band signalling of the properties of\
    \ delivered files.\n   -  Details associated with the multiplexing of multiple\
    \ files within\n      a session.\n   This specification is structured as follows.\
    \  Section 3 begins by\n   defining the concept of the file delivery session.\
    \  Following that it\n   introduces the File Delivery Table that forms the core\
    \ part of this\n   specification.  Further, it discusses multiplexing issues of\n\
    \   transport objects within a file delivery session.  Section 4\n   describes\
    \ the use of congestion control and channels with FLUTE.\n   Section 5 defines\
    \ how the Forward Error Correction (FEC) Object\n   Transmission Information is\
    \ to be delivered within a file delivery\n   session.  Section 6 defines the required\
    \ parameters for describing\n   file delivery sessions in a general case.  Section\
    \ 7 outlines\n   security considerations regarding file delivery with FLUTE. \
    \ Last,\n   there are two informative appendices.  The first appendix describes\n\
    \   an envisioned receiver operation for the receiver of the file\n   delivery\
    \ session.  The second appendix gives an example of File\n   Delivery Table.\n\
    \   Statement of Intent\n      This memo contains part of the definitions necessary\
    \ to fully\n      specify a Reliable Multicast Transport protocol in accordance\
    \ with\n      RFC2357.  As per RFC2357, the use of any reliable multicast\n  \
    \    protocol in the Internet requires an adequate congestion control\n      scheme.\n\
    \      While waiting for such a scheme to be available, or for an\n      existing\
    \ scheme to be proven adequate, the Reliable Multicast\n      Transport working\
    \ group (RMT) publishes this Request for Comments\n      in the \"Experimental\"\
    \ category.\n      It is the intent of RMT to re-submit this specification as\
    \ an IETF\n      Proposed Standard as soon as the above condition is met.\n"
- title: 1.1.  Applicability Statement
  contents:
  - '1.1.  Applicability Statement

    '
- title: 1.1.1.  The Target Application Space
  contents:
  - "1.1.1.  The Target Application Space\n   FLUTE is applicable to the delivery\
    \ of large and small files to many\n   hosts, using delivery sessions of several\
    \ seconds or more.  For\n   instance, FLUTE could be used for the delivery of\
    \ large software\n   updates to many hosts simultaneously.  It could also be used\
    \ for\n   continuous, but segmented, data such as time-lined text for\n   subtitling\
    \ - potentially leveraging its layering inheritance from ALC\n   and LCT to scale\
    \ the richness of the session to the congestion status\n   of the network.  It\
    \ is also suitable for the basic transport of\n   metadata, for example SDP [12]\
    \ files which enable user applications\n   to access multimedia sessions.\n"
- title: 1.1.2.  The Target Scale
  contents:
  - "1.1.2.  The Target Scale\n   Massive scalability is a primary design goal for\
    \ FLUTE.  IP multicast\n   is inherently massively scalable, but the best effort\
    \ service that it\n   provides does not provide session management functionality,\n\
    \   congestion control or reliability.  FLUTE provides all of this using\n   ALC\
    \ and IP multicast without sacrificing any of the inherent\n   scalability of\
    \ IP multicast.\n"
- title: 1.1.3.  Intended Environments
  contents:
  - "1.1.3.  Intended Environments\n   All of the environmental requirements and considerations\
    \ that apply\n   to the ALC building block [2] and to any additional building\
    \ blocks\n   that FLUTE uses also apply to FLUTE.\n   FLUTE can be used with both\
    \ multicast and unicast delivery, but it's\n   primary application is for unidirectional\
    \ multicast file delivery.\n   FLUTE requires connectivity between a sender and\
    \ receivers but does\n   not require connectivity from receivers to a sender.\
    \  FLUTE\n   inherently works with all types of networks, including LANs, WANs,\n\
    \   Intranets, the Internet, asymmetric networks, wireless networks, and\n   satellite\
    \ networks.\n   FLUTE is compatible with both IPv4 or IPv6 as no part of the packet\n\
    \   is IP version specific.  FLUTE works with both multicast models:\n   Any-Source\
    \ Multicast (ASM) [13] and the Source-Specific Multicast\n   (SSM) [15].\n   FLUTE\
    \ is applicable for both Internet use, with a suitable congestion\n   control\
    \ building block, and provisioned/controlled systems, such as\n   delivery over\
    \ wireless broadcast radio systems.\n"
- title: 1.1.4.  Weaknesses
  contents:
  - "1.1.4.  Weaknesses\n   Some networks are not amenable to some congestion control\
    \ protocols\n   that could be used with FLUTE.  In particular, for a satellite\
    \ or\n   wireless network, there may be no mechanism for receivers to\n   effectively\
    \ reduce their reception rate since there may be a fixed\n   transmission rate\
    \ allocated to the session.\n   FLUTE provides reliability using the FEC building\
    \ block.  This will\n   reduce the error rate as seen by applications.  However,\
    \ FLUTE does\n   not provide a method for senders to verify the reception success\
    \ of\n   receivers, and the specification of such a method is outside the\n  \
    \ scope of this document.\n"
- title: 2.  Conventions used in this Document
  contents:
  - "2.  Conventions used in this Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [1].\n   The terms \"object\" and \"transport object\" are consistent\
    \ with the\n   definitions in ALC [2] and LCT [3].  The terms \"file\" and \"\
    source\n   object\" are pseudonyms for \"object\".\n"
- title: 3.  File delivery
  contents:
  - "3.  File delivery\n   Asynchronous Layered Coding [2] is a protocol designed\
    \ for delivery\n   of arbitrary binary objects.  It is especially suitable for\
    \ massively\n   scalable, unidirectional, multicast distribution.  ALC provides\
    \ the\n   basic transport for FLUTE, and thus FLUTE inherits the requirements\n\
    \   of ALC.\n   This specification is designed for the delivery of files.  The\
    \ core\n   of this specification is to define how the properties of the files\n\
    \   are carried in-band together with the delivered files.\n   As an example,\
    \ let us consider a 5200 byte file referred to by\n   \"http://www.example.com/docs/file.txt\"\
    .  Using the example, the\n   following properties describe the properties that\
    \ need to be conveyed\n   by the file delivery protocol.\n   *  Identifier of\
    \ the file, expressed as a URI.  This identifier may\n      be globally unique.\
    \  The identifier may also provide a location\n      for the file.  In the above\
    \ example: \"http://www.example.com/docs/\n      file.txt\".\n   *  File name\
    \ (usually, this can be concluded from the URI).  In the\n      above example:\
    \ \"file.txt\".\n   *  File type, expressed as MIME media type (usually, this\
    \ can also be\n      concluded from the extension of the file name).  In the above\n\
    \      example: \"text/plain\".  If an explicit value for the MIME type is\n \
    \     provided separately from the file extension and does not match the\n   \
    \   MIME type of the file extension then the explicitly provided value\n     \
    \ MUST be used as the MIME type.\n   *  File size, expressed in bytes.  In the\
    \ above example: \"5200\".  If\n      the file is content encoded then this is\
    \ the file size before\n      content encoding.\n   *  Content encoding of the\
    \ file, within transport.  In the above\n      example, the file could be encoded\
    \ using ZLIB [10].  In this case\n      the size of the transport object carrying\
    \ the file would probably\n      differ from the file size.  The transport object\
    \ size is delivered\n      to receivers as part of the FLUTE protocol.\n   * \
    \ Security properties of the file such as digital signatures,\n      message digests,\
    \ etc.  For example, one could use S/MIME [18] as\n      the content encoding\
    \ type for files with this authentication\n      wrapper, and one could use XML-DSIG\
    \ [19] to digitally sign an FDT\n      Instance.\n"
- title: 3.1.  File delivery session
  contents:
  - "3.1.  File delivery session\n   ALC is a protocol instantiation of Layered Coding\
    \ Transport building\n   block (LCT) [3].  Thus ALC inherits the session concept\
    \ of LCT.  In\n   this document we will use the concept ALC/LCT session to collectively\n\
    \   denote the interchangeable terms ALC session and LCT session.\n   An ALC/LCT\
    \ session consists of a set of logically grouped ALC/LCT\n   channels associated\
    \ with a single sender sending packets with ALC/LCT\n   headers for one or more\
    \ objects.  An ALC/LCT channel is defined by\n   the combination of a sender and\
    \ an address associated with the\n   channel by the sender.  A receiver joins\
    \ a channel to start receiving\n   the data packets sent to the channel by the\
    \ sender, and a receiver\n   leaves a channel to stop receiving data packets from\
    \ the channel.\n   One of the fields carried in the ALC/LCT header is the Transport\n\
    \   Session Identifier (TSI).  The TSI is scoped by the source IP\n   address,\
    \ and the (source IP address, TSI) pair uniquely identifies a\n   session, i.e.,\
    \ the receiver uses this pair carried in each packet to\n   uniquely identify\
    \ from which session the packet was received.  In\n   case multiple objects are\
    \ carried within a session, the Transport\n   Object Identifier (TOI) field within\
    \ the ALC/LCT header identifies\n   from which object the data in the packet was\
    \ generated.  Note that\n   each object is associated with a unique TOI within\
    \ the scope of a\n   session.\n   If the sender is not assigned a permanent IP\
    \ address accessible to\n   receivers, but instead, packets that can be received\
    \ by receivers\n   containing a temporary IP address for packets sent by the sender,\n\
    \   then the TSI is scoped by this temporary IP address of the sender for\n  \
    \ the duration of the session.  As an example, the sender may be behind\n   a\
    \ Network Address Translation (NAT) device that temporarily assigns\n   an IP\
    \ address for the sender that is accessible to receivers, and in\n   this case\
    \ the TSI is scoped by the temporary IP address assigned by\n   the NAT that will\
    \ appear in packets received by the receiver.  As\n   another example, the sender\
    \ may send its original packets using IPv6,\n   but some portions of the network\
    \ may not be IPv6 capable and thus\n   there may be an IPv6 to IPv4 translator\
    \ that changes the IP address\n   of the packets to a different IPv4 address.\
    \  In this case, receivers\n   in the IPv4 portion of the network will receive\
    \ packets containing\n   the IPv4 address, and thus the TSI for them is scoped\
    \ by the IPv4\n   address.  How the IP address of the sender to be used to scope\
    \ the\n   session by receivers is delivered to receivers, whether it is a\n  \
    \ permanent IP address or a temporary IP address, is outside the scope\n   of\
    \ this document.\n   When FLUTE is used for file delivery over ALC the following\
    \ rules\n   apply:\n   *  The ALC/LCT session is called file delivery session.\n\
    \   *  The ALC/LCT concept of 'object' denotes either a 'file' or a 'File\n  \
    \    Delivery Table Instance' (section 3.2)\n   *  The TOI field MUST be included\
    \ in ALC packets sent within a FLUTE\n      session, with the exception that ALC\
    \ packets sent in a FLUTE\n      session with the Close Session (A) flag set to\
    \ 1 (signaling the\n      end of the session) and that contain no payload (carrying\
    \ no\n      information for any file or FDT) SHALL NOT carry the TOI.  See\n \
    \     Section 5.1 of RFC 3451 [3] for the LCT definition of the Close\n      Session\
    \ flag, and see Section 4.2 of RFC 3450 [2] for an example\n      of its use within\
    \ an ALC packet.\n   *  The TOI value '0' is reserved for delivery of File Delivery\
    \ Table\n      Instances.  Each File Delivery Table Instance is uniquely\n   \
    \   identified by an FDT Instance ID.\n   *  Each file in a file delivery session\
    \ MUST be associated with a TOI\n      (>0) in the scope of that session.\n  \
    \ *  Information carried in the headers and the payload of a packet is\n     \
    \ scoped by the source IP address and the TSI.  Information\n      particular\
    \ to the object carried in the headers and the payload of\n      a packet is further\
    \ scoped by the TOI for file objects, and is\n      further scoped by both the\
    \ TOI and the FDT Instance ID for FDT\n      Instance objects.\n"
- title: 3.2.  File Delivery Table
  contents:
  - "3.2.  File Delivery Table\n   The File Delivery Table (FDT) provides a means\
    \ to describe various\n   attributes associated with files that are to be delivered\
    \ within the\n   file delivery session.  The following lists are examples of such\n\
    \   attributes, and are not intended to be mutually exclusive nor\n   exhaustive.\n\
    \   Attributes related to the delivery of file:\n   -  TOI value that represents\
    \ the file\n   -  FEC Object Transmission Information (including the FEC Encoding\
    \ ID\n      and, if relevant, the FEC Instance ID)\n   -  Size of the transport\
    \ object carrying the file\n   -  Aggregate rate of sending packets to all channels\n\
    \   Attributes related to the file itself:\n   -  Name, Identification and Location\
    \ of file (specified by the URI)\n   -  MIME media type of file\n   -  Size of\
    \ file\n   -  Encoding of file\n   -  Message digest of file\n   Some of these\
    \ attributes MUST be included in the file description\n   entry for a file, others\
    \ are optional, as defined in section 3.4.2.\n   Logically, the FDT is a set of\
    \ file description entries for files to\n   be delivered in the session.  Each\
    \ file description entry MUST\n   include the TOI for the file that it describes\
    \ and the URI\n   identifying the file.  The TOI is included in each ALC/LCT data\n\
    \   packet during the delivery of the file, and thus the TOI carried in\n   the\
    \ file description entry is how the receiver determines which\n   ALC/LCT data\
    \ packets contain information about which file.  Each file\n   description entry\
    \ may also contain one or more descriptors that map\n   the above-mentioned attributes\
    \ to the file.\n   Each file delivery session MUST have an FDT that is local to\
    \ the\n   given session.  The FDT MUST provide a file description entry mapped\n\
    \   to a TOI for each file appearing within the session.  An object that\n   is\
    \ delivered within the ALC session, but not described in the FDT, is\n   not considered\
    \ a 'file' belonging to the file delivery session.\n   Handling of these unmapped\
    \ TOIs (TOIs that are not resolved by the\n   FDT) is out of scope of this specification.\n\
    \   Within the file delivery session the FDT is delivered as FDT\n   Instances.\
    \  An FDT Instance contains one or more file description\n   entries of the FDT.\
    \  Any FDT Instance can be equal to, a subset of, a\n   superset of, or complement\
    \ any other FDT Instance.  A certain FDT\n   Instance may be repeated several\
    \ times during a session, even after\n   subsequent FDT Instances (with higher\
    \ FDT Instance ID numbers) have\n   been transmitted.  Each FDT Instance contains\
    \ at least a single file\n   description entry and at most the complete FDT of\
    \ the file delivery\n   session.\n   A receiver of the file delivery session keeps\
    \ an FDT database for\n   received file description entries.  The receiver maintains\
    \ the\n   database, for example, upon reception of FDT Instances.  Thus, at any\n\
    \   given time the contents of the FDT database represent the receiver's\n   current\
    \ view of the FDT of the file delivery session.  Since each\n   receiver behaves\
    \ independently of other receivers, it SHOULD NOT be\n   assumed that the contents\
    \ of the FDT database are the same for all\n   the receivers of a given file delivery\
    \ session.\n   Since FDT database is an abstract concept, the structure and the\n\
    \   maintaining of the FDT database are left to individual\n   implementations\
    \ and are thus out of scope of this specification.\n"
- title: 3.3.  Dynamics of FDT Instances within file delivery session
  contents:
  - "3.3.  Dynamics of FDT Instances within file delivery session\n   The following\
    \ rules define the dynamics of the FDT Instances within a\n   file delivery session:\n\
    \   *  For every file delivered within a file delivery session there MUST\n  \
    \    be a file description entry included in at least one FDT Instance\n     \
    \ sent within the session.  A file description entry contains at a\n      minimum\
    \ the mapping between the TOI and the URI.\n   *  An FDT Instance MAY appear in\
    \ any part of the file delivery\n      session and packets for an FDT Instance\
    \ MAY be interleaved with\n      packets for other files or other FDT Instances\
    \ within a session.\n   *  The TOI value of '0' MUST be reserved for delivery\
    \ of FDT\n      Instances.  The use of other TOI values for FDT Instances is\n\
    \      outside the scope of this specification.\n   *  FDT Instance is identified\
    \ by the use of a new fixed length LCT\n      Header Extension EXT_FDT (defined\
    \ later in this section).  Each\n      FDT Instance is uniquely identified within\
    \ the file delivery\n      session by its FDT Instance ID.  Any ALC/LCT packet\
    \ carrying FDT\n      Instance (indicated by TOI = 0) MUST include EXT_FDT.\n\
    \   *  It is RECOMMENDED that FDT Instance that contains the file\n      description\
    \ entry for a file is sent prior to the sending of the\n      described file within\
    \ a file delivery session.\n   *  Within a file delivery session, any TOI > 0\
    \ MAY be described more\n      than once.  An example: previous FDT Instance 0\
    \ describes TOI of\n      value '3'.  Now, subsequent FDT Instances can either\
    \ keep TOI '3'\n      unmodified on the table, not include it, or complement the\n\
    \      description.  However, subsequent FDT Instances MUST NOT change\n     \
    \ the parameters already described for a specific TOI.\n   *  An FDT Instance\
    \ is valid until its expiration time.  The\n      expiration time is expressed\
    \ within the FDT Instance payload as a\n      32 bit data field.  The value of\
    \ the data field represents the 32\n      most significant bits of a 64 bit Network\
    \ Time Protocol (NTP) [5]\n      time value.  These 32 bits provide an unsigned\
    \ integer\n      representing the time in seconds relative to 0 hours 1 January\n\
    \      1900.  Handling of wraparound of the 32 bit time is outside the\n     \
    \ scope of NTP and FLUTE.\n   *  The receiver SHOULD NOT use a received FDT Instance\
    \ to interpret\n      packets received beyond the expiration time of the FDT Instance.\n\
    \   *  A sender MUST use an expiry time in the future upon creation of an\n  \
    \    FDT Instance relative to its Sender Current Time (SCT).\n   *  Any FEC Encoding\
    \ ID MAY be used for the sending of FDT Instances.\n      The default is to use\
    \ FEC Encoding ID 0 for the sending of FDT\n      Instances.  (Note that since\
    \ FEC Encoding ID 0 is the default for\n      FLUTE, this implies that Source\
    \ Block Number and Encoding Symbol\n      ID lengths both default to 16 bits each.)\n\
    \   Generally, a receiver needs to receive an FDT Instance describing a\n   file\
    \ before it is able to recover the file itself.  In this sense FDT\n   Instances\
    \ are of higher priority than files.  Thus, it is RECOMMENDED\n   that FDT Instances\
    \ describing a file be sent with at least as much\n   reliability within a session\
    \ (more often or with more FEC protection)\n   as the files they describe.  In\
    \ particular, if FDT Instances are\n   longer than one packet payload in length\
    \ it is RECOMMENDED that an\n   FEC code that provides protection against loss\
    \ be used for delivering\n   FDT Instances.  How often the description of a file\
    \ is sent in an FDT\n   Instance or how much FEC protection is provided for each\
    \ FDT Instance\n   (if the FDT Instance is longer than one packet payload) is\
    \ dependent\n   on the particular application and outside the scope of this document.\n"
- title: 3.4.  Structure of FDT Instance packets
  contents:
  - "3.4.  Structure of FDT Instance packets\n   FDT Instances are carried in ALC\
    \ packets with TOI = 0 and with an\n   additional REQUIRED LCT Header extension\
    \ called the FDT Instance\n   Header.  The FDT Instance Header (EXT_FDT) contains\
    \ the FDT Instance\n   ID that uniquely identifies FDT Instances within a file\
    \ delivery\n   session.  The FDT Instance Header is placed in the same way as\
    \ any\n   other LCT extension header.  There MAY be other LCT extension headers\n\
    \   in use.\n   The LCT extension headers are followed by the FEC Payload ID,\
    \ and\n   finally the Encoding Symbols for the FDT Instance which contains one\n\
    \   or more file description entries.  A FDT Instance MAY span several\n   ALC\
    \ packets - the number of ALC packets is a function of the file\n   attributes\
    \ associated with the FDT Instance.  The FDT Instance Header\n   is carried in\
    \ each ALC packet carrying the FDT Instance.  The FDT\n   Instance Header is identical\
    \ for all ALC/LCT packets for a particular\n   FDT Instance.\n   The overall format\
    \ of ALC/LCT packets carrying an FDT Instance is\n   depicted in the Figure 1\
    \ below.  All integer fields are carried in\n   \"big-endian\" or \"network order\"\
    \ format, that is, most significant\n   byte (octet) first.  As defined in [2],\
    \ all ALC/LCT packets are sent\n   using UDP.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         UDP header                            |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Default LCT header (with TOI = 0)              |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          LCT header extensions (EXT_FDT, EXT_FTI, etc.)       |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       FEC Payload ID                          |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              Encoding Symbol(s) for FDT Instance              |\n   |  \
    \                         ...                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 1 - Overall FDT Packet\n"
- title: 3.4.1.  Format of FDT Instance Header
  contents:
  - "3.4.1.  Format of FDT Instance Header\n   FDT Instance Header (EXT_FDT) is a\
    \ new fixed length, ALC PI specific\n   LCT header extension [3].  The Header\
    \ Extension Type (HET) for the\n   extension is 192.  Its format is defined below:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   HET = 192   |   V   |          FDT Instance ID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version of FLUTE (V), 4 bits:\n   This document specifies FLUTE version 1.\
    \  Hence in any ALC packet\n   that carries FDT Instance and that belongs to the\
    \ file delivery\n   session as specified in this specification MUST set this field\
    \ to\n   '1'.\n   FDT Instance ID, 20 bits:\n   For each file delivery session\
    \ the numbering of FDT Instances starts\n   from '0' and is incremented by one\
    \ for each subsequent FDT Instance.\n   After reaching the maximum value (2^20-1),\
    \ the numbering starts again\n   from '0'.  When wraparound from 2^20-1 to 0 occurs,\
    \ 0 is considered\n   higher than 2^20-1.  A new FDT Instance reusing a previous\
    \ FDT\n   Instance ID number, due to wraparound, may not implicitly expire the\n\
    \   previous FDT Instance with the same ID.  It would be reasonable for\n   FLUTE\
    \ Senders to only construct and deliver FDT Instances with\n   wraparound IDs\
    \ after the previous FDT Instance using the same ID has\n   expired.   However,\
    \ mandatory receiver behavior for handling FDT\n   Instance ID wraparound and\
    \ other special situations (for example,\n   missing FDT Instance IDs resulting\
    \ in larger increments than one) is\n   outside the scope of this specification\
    \ and left to individual\n   implementations of FLUTE.\n"
- title: 3.4.2.  Syntax of FDT Instance
  contents:
  - "3.4.2.  Syntax of FDT Instance\n   The FDT Instance contains file description\
    \ entries that provide the\n   mapping functionality described in 3.2 above.\n\
    \   The FDT Instance is an XML structure that has a single root element\n   \"\
    FDT-Instance\".  The \"FDT-Instance\" element MUST contain \"Expires\"\n   attribute,\
    \ which tells the expiry time of the FDT Instance.  In\n   addition, the \"FDT-Instance\"\
    \ element MAY contain the \"Complete\"\n   attribute (boolean), which, when TRUE,\
    \ signals that no new data will\n   be provided in future FDT Instances within\
    \ this session (i.e., that\n   either FDT Instances with higher ID numbers will\
    \ not be used or if\n   they are used, will only provide identical file parameters\
    \ to those\n   already given in this and previous FDT Instances).  For example,\
    \ this\n   may be used to provide a complete list of files in an entire FLUTE\n\
    \   session (a \"complete FDT\").\n   The \"FDT-Instance\" element MAY contain\
    \ attributes that give common\n   parameters for all files of an FDT Instance.\
    \  These attributes MAY\n   also be provided for individual files in the \"File\"\
    \ element.  Where\n   the same attribute appears in both the \"FDT-Instance\"\
    \ and the \"File\"\n   elements, the value of the attribute provided in the \"\
    File\" element\n   takes precedence.\n   For each file to be declared in the given\
    \ FDT Instance there is a\n   single file description entry in the FDT Instance.\
    \  Each entry is\n   represented by element \"File\" which is a child element\
    \ of the FDT\n   Instance structure.\n   The attributes of \"File\" element in\
    \ the XML structure represent the\n   attributes given to the file that is delivered\
    \ in the file delivery\n   session.  The value of the XML attribute name corresponds\
    \ to MIME\n   field name and the XML attribute value corresponds to the value\
    \ of\n   the MIME field body.  Each \"File\" element MUST contain at least two\n\
    \   attributes \"TOI\" and \"Content-Location\".  \"TOI\" MUST be assigned a\n\
    \   valid TOI value as described in section 3.3 above.  \"Content-\n   Location\"\
    \ MUST be assigned a valid URI as defined in [6].\n   In addition to mandatory\
    \ attributes, the \"FDT-Instance\" element and\n   the \"File\" element MAY contain\
    \ other attributes of which the\n   following are specifically pointed out.\n\
    \   *  Where the MIME type is described, the attribute \"Content-Type\"\n    \
    \  MUST be used for the purpose as defined in [6].\n   *  Where the length is\
    \ described, the attribute \"Content-Length\" MUST\n      be used for the purpose\
    \ as defined in [6].  The transfer length is\n      defined to be the length of\
    \ the object transported in bytes.  It\n      is often important to convey the\
    \ transfer length to receivers,\n      because the source block structure needs\
    \ to be known for the FEC\n      decoder to be applied to recover source blocks\
    \ of the file, and\n      the transfer length is often needed to properly determine\
    \ the\n      source block structure of the file.  There generally will be a\n\
    \      difference between the length of the original file and the\n      transfer\
    \ length if content encoding is applied to the file before\n      transport, and\
    \ thus the \"Content-Encoding\" attribute is used.  If\n      the file is not\
    \ content encoded before transport (and thus the\n      \"Content-Encoding\" attribute\
    \ is not used) then the transfer length\n      is the length of the original file,\
    \ and in this case the\n      \"Content-Length\" is also the transfer length.\
    \  However, if the\n      file is content encoded before transport (and thus the\
    \ \"Content-\n      Encoding\" attribute is used), e.g., if compression is applied\n\
    \      before transport to reduce the number of bytes that need to be\n      transferred,\
    \ then the transfer length is generally different than\n      the length of the\
    \ original file, and in this case the attribute\n      \"Transfer-Length\" MAY\
    \ be used to carry the transfer length.\n   *  Where the content encoding scheme\
    \ is described, the attribute\n      \"Content-Encoding\" MUST be used for the\
    \ purpose as defined in [6].\n   *  Where the MD5 message digest is described,\
    \ the attribute\n      \"Content-MD5\" MUST be used for the purpose as defined\
    \ in [6].\n   *  The FEC Object Transmission Information attributes as described\
    \ in\n      section 5.2.\n   The following specifies the XML Schema [8][9] for\
    \ FDT Instance:\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xs:schema\
    \ xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n              xmlns:fl=\"http://www.example.com/flute\"\
    \n              elementFormDefault:xs=\"qualified\"\n              targetNamespace:xs=\"\
    http://www.example.com/flute\">\n    <xs:element name=\"FDT-Instance\">\n    \
    \ <xs:complexType>\n      <xs:sequence>\n       <xs:element name=\"File\" maxOccurs=\"\
    unbounded\">\n        <xs:complexType>\n         <xs:attribute name=\"Content-Location\"\
    \n                       type=\"xs:anyURI\"\n                       use=\"required\"\
    />\n         <xs:attribute name=\"TOI\"\n                       type=\"xs:positiveInteger\"\
    \n                       use=\"required\"/>\n         <xs:attribute name=\"Content-Length\"\
    \n                       type=\"xs:unsignedLong\"\n                       use=\"\
    optional\"/>\n         <xs:attribute name=\"Transfer-Length\"\n              \
    \         type=\"xs:unsignedLong\"\n                       use=\"optional\"/>\n\
    \         <xs:attribute name=\"Content-Type\"\n                       type=\"\
    xs:string\"\n                       use=\"optional\"/>\n         <xs:attribute\
    \ name=\"Content-Encoding\"\n                       type=\"xs:string\"\n     \
    \                  use=\"optional\"/>\n         <xs:attribute name=\"Content-MD5\"\
    \n                       type=\"xs:base64Binary\"\n                       use=\"\
    optional\"/>\n         <xs:attribute name=\"FEC-OTI-FEC-Encoding-ID\"\n      \
    \                 type=\"xs:unsignedLong\"\n                       use=\"optional\"\
    />\n         <xs:attribute name=\"FEC-OTI-FEC-Instance-ID\"\n                \
    \       type=\"xs:unsignedLong\"\n                       use=\"optional\"/>\n\
    \         <xs:attribute name=\"FEC-OTI-Maximum-Source-Block-Length\"\n       \
    \                type=\"xs:unsignedLong\"\n                       use=\"optional\"\
    />\n         <xs:attribute name=\"FEC-OTI-Encoding-Symbol-Length\"\n         \
    \              type=\"xs:unsignedLong\"\n                       use=\"optional\"\
    />\n         <xs:attribute name=\"FEC-OTI-Max-Number-of-Encoding-Symbols\"\n \
    \                      type=\"xs:unsignedLong\"\n                       use=\"\
    optional\"/>\n         <xs:anyAttribute processContents=\"skip\"/>\n        </xs:complexType>\n\
    \       </xs:element>\n      </xs:sequence>\n      <xs:attribute name=\"Expires\"\
    \n                    type=\"xs:string\"\n                    use=\"required\"\
    />\n      <xs:attribute name=\"Complete\"\n                    type=\"xs:boolean\"\
    \n                    use=\"optional\"/>\n      <xs:attribute name=\"Content-Type\"\
    \n                    type=\"xs:string\"\n                    use=\"optional\"\
    />\n      <xs:attribute name=\"Content-Encoding\"\n                    type=\"\
    xs:string\"\n                    use=\"optional\"/>\n      <xs:attribute name=\"\
    FEC-OTI-FEC-Encoding-ID\"\n                    type=\"xs:unsignedLong\"\n    \
    \                use=\"optional\"/>\n      <xs:attribute name=\"FEC-OTI-FEC-Instance-ID\"\
    \n                    type=\"xs:unsignedLong\"\n                    use=\"optional\"\
    />\n      <xs:attribute name=\"FEC-OTI-Maximum-Source-Block-Length\"\n       \
    \             type=\"xs:unsignedLong\"\n                    use=\"optional\"/>\n\
    \      <xs:attribute name=\"FEC-OTI-Encoding-Symbol-Length\"\n               \
    \     type=\"xs:unsignedLong\"\n                    use=\"optional\"/>\n     \
    \ <xs:attribute name=\"FEC-OTI-Max-Number-of-Encoding-Symbols\"\n            \
    \        type=\"xs:unsignedLong\"\n                    use=\"optional\"/>\n  \
    \    <xs:anyAttribute processContents=\"skip\"/>\n     </xs:complexType>\n   \
    \ </xs:element>\n   </xs:schema>\n   Any valid FDT Instance must use the above\
    \ XML Schema.  This way FDT\n   provides extensibility to support private attributes\
    \ within the file\n   description entries.  Those could be, for example, the attributes\n\
    \   related to the delivery of the file (timing, packet transmission\n   rate,\
    \ etc.).\n   In case the basic FDT XML Schema is extended in terms of new\n  \
    \ descriptors, for attributes applying to a single file, those MUST be\n   placed\
    \ within the attributes of the element \"File\".  For attributes\n   applying\
    \ to all files described by the current FDT Instance, those\n   MUST be placed\
    \ within the element \"FDT-Instance\".  It is RECOMMENDED\n   that the new descriptors\
    \ applied in the FDT are in the format of MIME\n   fields and are either defined\
    \ in the HTTP/1.1 specification [6] or\n   another well-known specification.\n"
- title: 3.4.3.  Content Encoding of FDT Instance
  contents:
  - "3.4.3.  Content Encoding of FDT Instance\n   The FDT Instance itself MAY be content\
    \ encoded, for example\n   compressed.  This specification defines FDT Instance\
    \ Content Encoding\n   Header (EXT_CENC).  EXT_CENC is a new fixed length, ALC\
    \ PI specific\n   LCT header extension [3].  The Header Extension Type (HET) for\
    \ the\n   extension is 193.  If the FDT Instance is content encoded, the\n   EXT_CENC\
    \ MUST be used to signal the content encoding type.  In that\n   case, EXT_CENC\
    \ header extension MUST be used in all ALC packets\n   carrying the same FDT Instance\
    \ ID.  Consequently, when EXT_CENC\n   header is used, it MUST be used together\
    \ with a proper FDT Instance\n   Header (EXT_FDT).  Within a file delivery session,\
    \ FDT Instances that\n   are not content encoded and FDT Instances that are content\
    \ encoded\n   MAY both appear.  If content encoding is not used for a given FDT\n\
    \   Instance, the EXT_CENC MUST NOT be used in any packet carrying the\n   FDT\
    \ Instance.  The format of EXT_CENC is defined below:\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   HET = 193   |     CENC      |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Content Encoding Algorithm (CENC), 8 bits:\n   This field signals the content\
    \ encoding algorithm used in the FDT\n   Instance payload.  The definition of\
    \ this field is outside the scope\n   of this specification.  Applicable content\
    \ encoding algorithms\n   include, for example, ZLIB [10], DEFLATE [16] and GZIP\
    \ [17].\n   Reserved, 16 bits:\n   This field MUST be set to all '0'.\n"
- title: 3.5.  Multiplexing of files within a file delivery session
  contents:
  - "3.5.  Multiplexing of files within a file delivery session\n   The delivered\
    \ files are carried as transport objects (identified with\n   TOIs) in the file\
    \ delivery session.  All these objects, including the\n   FDT Instances, MAY be\
    \ multiplexed in any order and in parallel with\n   each other within a session,\
    \ i.e., packets for one file MAY be\n   interleaved with packets for other files\
    \ or other FDT Instances\n   within a session.\n   Multiple FDT Instances MAY\
    \ be delivered in a single session using TOI\n   = 0.  In this case, it is RECOMMENDED\
    \ that the sending of a previous\n   FDT Instance SHOULD end before the sending\
    \ of the next FDT Instance\n   starts.  However, due to unexpected network conditions,\
    \ packets for\n   the FDT Instances MAY be interleaved.  A receiver can determine\
    \ which\n   FDT Instance a packet contains information about since the FDT\n \
    \  Instances are uniquely identified by their FDT Instance ID carried in\n   the\
    \ EXT_FDT headers.\n"
- title: 4.  Channels, congestion control and timing
  contents:
  - "4.  Channels, congestion control and timing\n   ALC/LCT has a concept of channels\
    \ and congestion control.  There are\n   four scenarios FLUTE is envisioned to\
    \ be applied.\n   (a) Use a single channel and a single-rate congestion control\n\
    \       protocol.\n   (b) Use multiple channels and a multiple-rate congestion\
    \ control\n       protocol.  In this case the FDT Instances MAY be delivered on\n\
    \       more than one channel.\n   (c) Use a single channel without congestion\
    \ control supplied by ALC,\n       but only when in a controlled network environment\
    \ where flow/\n       congestion control is being provided by other means.\n \
    \  (d) Use multiple channels without congestion control supplied by ALC,\n   \
    \    but only when in a controlled network environment where flow/\n       congestion\
    \ control is being provided by other means.  In this\n       case the FDT Instances\
    \ MAY be delivered on more than one channel.\n   When using just one channel for\
    \ a file delivery session, as in (a)\n   and (c), the notion of 'prior' and 'after'\
    \ are intuitively defined\n   for the delivery of objects with respect to their\
    \ delivery times.\n   However, if multiple channels are used, as in (b) and (d),\
    \ it is not\n   straightforward to state that an object was delivered 'prior'\
    \ to the\n   other.  An object may begin to be delivered on one or more of those\n\
    \   channels before the delivery of a second object begins.  However, the\n  \
    \ use of multiple channels/layers may complete the delivery of the\n   second\
    \ object before the first.  This is not a problem when objects\n   are delivered\
    \ sequentially using a single channel.  Thus, if the\n   application of FLUTE\
    \ has a mandatory or critical requirement that the\n   first transport object\
    \ must complete 'prior' to the second one, it is\n   RECOMMENDED that only a single\
    \ channel is used for the file delivery\n   session.\n   Furthermore, if multiple\
    \ channels are used then a receiver joined to\n   the session at a low reception\
    \ rate will only be joined to the lower\n   layers of the session.  Thus, since\
    \ the reception of FDT Instances is\n   of higher priority than the reception\
    \ of files (because the reception\n   of files depends on the reception of an\
    \ FDT Instance describing it),\n   the following is RECOMMENDED:\n   1. The layers\
    \ to which packets for FDT Instances are sent SHOULD NOT\n      be biased towards\
    \ those layers to which lower rate receivers are\n      not joined.  For example,\
    \ it is ok to put all the packets for an\n      FDT Instance into the lowest layer\
    \ (if this layer carries enough\n      packets to deliver the FDT to higher rate\
    \ receivers in a\n      reasonable amount of time), but it is not ok to put all\
    \ the\n      packets for an FDT Instance into the higher layers that only high\n\
    \      rate receivers will receive.\n   2. If FDT Instances are generally longer\
    \ than one Encoding Symbol in\n      length and some packets for FDT Instances\
    \ are sent to layers that\n      lower rate receivers do not receive, an FEC Encoding\
    \ other than\n      FEC Encoding ID 0 SHOULD be used to deliver FDT Instances.\
    \  This\n      is because in this case, even when there is no packet loss in the\n\
    \      network, a lower rate receiver will not receive all packets sent\n    \
    \  for an FDT Instance.\n"
- title: 5.  Delivering FEC Object Transmission Information
  contents:
  - "5.  Delivering FEC Object Transmission Information\n   FLUTE inherits the use\
    \ of FEC building block [4] from ALC.  When\n   using FLUTE for file delivery\
    \ over ALC the FEC Object Transmission\n   Information MUST be delivered in-band\
    \ within the file delivery\n   session.  In this section, two methods are specified\
    \ for FLUTE for\n   this purpose: the use of ALC specific LCT extension header\
    \ EXT_FTI\n   [2] and the use of FDT.\n   The receiver of file delivery session\
    \ MUST support delivery of FEC\n   Object Transmission Information using the EXT_FTI\
    \ for the FDT\n   Instances carried using TOI value 0.  For the TOI values other\
    \ than 0\n   the receiver MUST support both methods: the use of EXT_FTI and the\n\
    \   use of FDT.\n   The FEC Object Transmission Information that needs to be delivered\
    \ to\n   receivers MUST be exactly the same whether it is delivered using\n  \
    \ EXT_FTI or using FDT (or both).  Section 5.1 describes the required\n   FEC\
    \ Object Transmission Information that MUST be delivered to\n   receivers for\
    \ various FEC Encoding IDs.  In addition, it describes\n   the delivery using\
    \ EXT_FTI.  Section 5.2 describes the delivery using\n   FDT.\n   The FEC Object\
    \ Transmission Information regarding a given TOI may be\n   available from several\
    \ sources.  In this case, it is RECOMMENDED that\n   the receiver of the file\
    \ delivery session prioritizes the sources in\n   the following way (in the order\
    \ of decreasing priority).\n   1. FEC Object Transmission Information that is\
    \ available in EXT_FTI.\n   2. FEC Object Transmission Information that is available\
    \ in the FDT.\n"
- title: 5.1.  Use of EXT_FTI for delivery of FEC Object Transmission Information
  contents:
  - "5.1.  Use of EXT_FTI for delivery of FEC Object Transmission Information\n  \
    \ As specified in [2], the EXT_FTI header extension is intended to\n   carry the\
    \ FEC Object Transmission Information for an object in-band.\n   It is left up\
    \ to individual implementations to decide how frequently\n   and in which ALC\
    \ packets the EXT_FTI header extension is included.\n   In environments with higher\
    \ packet loss rate, the EXT_FTI might need\n   to be included more frequently\
    \ in ALC packets than in environments\n   with low error probability.  The EXT_FTI\
    \ MUST be included in at least\n   one sent ALC packet for each FDT Instance.\n\
    \   The ALC specification does not define the format or the processing of\n  \
    \ the EXT_FTI header extension.  The following sections specify EXT_FTI\n   when\
    \ used in FLUTE.\n   In FLUTE, the FEC Encoding ID (8 bits) is carried in the\
    \ Codepoint\n   field of the ALC/LCT header.\n"
- title: 5.1.1.  General EXT_FTI format
  contents:
  - "5.1.1.  General EXT_FTI format\n   The general EXT_FTI format specifies the structure\
    \ and those\n   attributes of FEC Object Transmission Information that are applicable\n\
    \   to any FEC Encoding ID.\n    0                   1                   2   \
    \                3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   HET = 64    |     HEL       |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                       Transfer Length\
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   FEC Instance ID             | FEC Enc. ID Specific Format   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Header Extension Type (HET), 8 bits:\n   64 as defined in [2].\n   Header\
    \ Extension Length (HEL), 8 bits:\n   The length of the whole Header Extension\
    \ field, expressed in\n   multiples of 32-bit words.  This length includes the\
    \ FEC Encoding ID\n   specific format part.\n   Transfer Length, 48 bits:\n  \
    \ The length of the transport object that carries the file in bytes.\n   (This\
    \ is the same as the file length if the file is not content\n   encoded.)\n  \
    \ FEC Instance ID, optional, 16 bits:\n   This field is used for FEC Instance\
    \ ID.  It is only present if the\n   value of FEC Encoding ID is in the range\
    \ of 128-255.  When the value\n   of FEC Encoding ID is in the range of 0-127,\
    \ this field is set to 0.\n   FEC Encoding ID Specific Format:\n   Different FEC\
    \ encoding schemes will need different sets of encoding\n   parameters.  Thus,\
    \ the structure and length of this field depends on\n   FEC Encoding ID.  The\
    \ next sections specify structure of this field\n   for FEC Encoding ID numbers\
    \ 0, 128, 129, and 130.\n"
- title: 5.1.2.  FEC Encoding ID specific formats for EXT_FTI
  contents:
  - '5.1.2.  FEC Encoding ID specific formats for EXT_FTI

    '
- title: 5.1.2.1.  FEC Encoding IDs 0, 128, and 130
  contents:
  - "5.1.2.1.  FEC Encoding IDs 0, 128, and 130\n   FEC Encoding ID 0 is 'Compact\
    \ No-Code FEC' (Fully-Specified) [7].\n   FEC Encoding ID 128 is 'Small Block,\
    \ Large Block and Expandable FEC'\n   (Under-Specified) [4].  FEC Encoding ID\
    \ 130 is 'Compact FEC' (Under-\n   Specified) [7].  For these FEC Encoding IDs,\
    \ the FEC Encoding ID\n   specific format of EXT_FTI is defined as follows.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                \
    \                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      General EXT_FTI format\
    \       |    Encoding Symbol Length     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Maximum Source Block Length                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Encoding Symbol Length, 16 bits:\n   Length of Encoding Symbol in bytes.\n\
    \   All Encoding Symbols of a transport object MUST be equal to this\n   length,\
    \ with the optional exception of the last source symbol of the\n   last source\
    \ block (so that redundant padding is not mandatory in this\n   last symbol).\
    \  This last source symbol MUST be logically padded out\n   with zeroes when another\
    \ Encoding Symbol is computed based on this\n   source symbol to ensure the same\
    \ interpretation of this Encoding\n   Symbol value by the sender and receiver.\
    \  However, this padding does\n   not actually need to be sent with the data of\
    \ the last source symbol.\n   Maximum Source Block Length, 32 bits:\n   The maximum\
    \ number of source symbols per source block.\n   This EXT_FTI specification requires\
    \ that an algorithm is known to\n   both sender and receivers for determining\
    \ the size of all source\n   blocks of the transport object that carries the file\
    \ identified by\n   the TOI (or within the FDT Instance identified by the TOI\
    \ and the FDT\n   Instance ID).  The algorithm SHOULD be the same for all files\
    \ using\n   the same FEC Encoding ID within a session.\n   Section 5.1.2.3 describes\
    \ an algorithm that is RECOMMENDED for this\n   use.\n   For the FEC Encoding\
    \ IDs 0, 128 and 130, this algorithm is the only\n   well known way the receiver\
    \ can determine the length of each source\n   block.  Thus, the algorithm does\
    \ two things: (a) it tells the\n   receiver the length of each particular source\
    \ block as it is\n   receiving packets for that source block - this is essential\
    \ to all of\n   these FEC schemes; and, (b) it provides the source block structure\n\
    \   immediately to the receiver so that the receiver can determine where\n   to\
    \ save recovered source blocks at the beginning of the reception of\n   data packets\
    \ for the file - this is an optimization which is\n   essential for some implementations.\n"
- title: 5.1.2.2.  FEC Encoding ID 129
  contents:
  - "5.1.2.2.  FEC Encoding ID 129\n   Small Block Systematic FEC (Under-Specified).\
    \  The FEC Encoding ID\n   specific format of EXT_FTI is defined as follows.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                \
    \                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      General EXT_FTI format\
    \       |    Encoding Symbol Length     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Maximum Source Block Length  | Max. Num. of Encoding Symbols |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Encoding Symbol Length, 16 bits:\n   Length of Encoding Symbol in bytes.\n\
    \   All Encoding Symbols of a transport object MUST be equal to this\n   length,\
    \ with the optional exception of the last source symbol of the\n   last source\
    \ block (so that redundant padding is not mandatory in this\n   last symbol).\
    \  This last source symbol MUST be logically padded out\n   with zeroes when another\
    \ Encoding Symbol is computed based on this\n   source symbol to ensure the same\
    \ interpretation of this Encoding\n   Symbol value by the sender and receiver.\
    \  However, this padding need\n   not be actually sent with the data of the last\
    \ source symbol.\n   Maximum Source Block Length, 16 bits:\n   The maximum number\
    \ of source symbols per source block.\n   Maximum Number of Encoding Symbols,\
    \ 16 bits:\n   Maximum number of Encoding Symbols that can be generated for a\
    \ source\n   block.\n   This EXT_FTI specification requires that an algorithm\
    \ is known to\n   both sender and receivers for determining the size of all source\n\
    \   blocks of the transport object that carries the file identified by\n   the\
    \ TOI (or within the FDT Instance identified by the TOI and the FDT\n   Instance\
    \ ID).  The algorithm SHOULD be the same for all files using\n   the same FEC\
    \ Encoding ID within a session.\n   Section 5.1.2.3 describes an algorithm that\
    \ is RECOMMENDED for this\n   use.  For FEC Encoding ID 129 the FEC Payload ID\
    \ in each data packet\n   already contains the source block length for the source\
    \ block\n   corresponding to the Encoding Symbol carried in the data packet.\n\
    \   Thus, the algorithm for computing source blocks for FEC Encoding ID\n   129\
    \ could be to just use the source block lengths carried in data\n   packets within\
    \ the FEC Payload ID.  However, the algorithm described\n   in Section 5.1.2.3\
    \ is useful for the receiver to compute the source\n   block structure at the\
    \ beginning of the reception of data packets for\n   the file.  If the algorithm\
    \ described in Section 5.1.2.3 is used then\n   it MUST be the case that the source\
    \ block lengths that appear in data\n   packets agree with the source block lengths\
    \ calculated by the\n   algorithm.\n"
- title: 5.1.2.3.  Algorithm for Computing Source Block Structure
  contents:
  - "5.1.2.3.  Algorithm for Computing Source Block Structure\n   This algorithm computes\
    \ a source block structure so that all source\n   blocks are as close to being\
    \ equal length as possible.  A first\n   number of source blocks are of the same\
    \ larger length, and the\n   remaining second number of source blocks are sent\
    \ of the same smaller\n   length.  The total number of source blocks (N), the\
    \ first number of\n   source blocks (I), the second number of source blocks (N-I),\
    \ the\n   larger length (A_large) and the smaller length (A_small) are\n   calculated\
    \ thus,\n      Input:\n         B -- Maximum Source Block Length, i.e., the maximum\
    \ number of\n              source symbols per source block\n         L -- Transfer\
    \ Length in bytes\n         E -- Encoding Symbol Length in bytes\n      Output:\n\
    \         N -- The number of source blocks into which the transport\n        \
    \      object is partitioned.\n         The number and lengths of source symbols\
    \ in each of the N\n         source blocks.\n      Algorithm:\n      (a) The number\
    \ of source symbols in the transport object is\n          computed as T = L/E\
    \ rounded up to the nearest integer.\n      (b) The transport object is partitioned\
    \ into N source blocks,\n          where N = T/B rounded up to the nearest integer\n\
    \      (c) The average length of a source block, A = T/N\n          (this may\
    \ be non-integer)\n      (d) A_large = A rounded up to the nearest integer\n \
    \         (it will always be the case that the value of A_large is at\n      \
    \    most B)\n      (e) A_small = A rounded down to the nearest integer\n    \
    \      (if A is an integer A_small = A_large,\n          and otherwise A_small\
    \ = A_large - 1)\n      (f) The fractional part of A, A_fraction = A - A_small\n\
    \      (g) I = A_fraction * N\n          (I is an integer between 0 and N-1)\n\
    \      (h) Each of the first I source blocks consists of A_large source\n    \
    \      symbols, each source symbol is E bytes in length.  Each of the\n      \
    \    remaining N-I source blocks consist of A_small source symbols,\n        \
    \  each source symbol is E bytes in length except that the last\n          source\
    \ symbol of the last source block is L-(((L-1)/E) rounded\n          down to the\
    \ nearest integer)*E bytes in length.\n   Note, this algorithm does not imply\
    \ implementation by floating point\n   arithmetic and integer arithmetic may be\
    \ used to avoid potential\n   floating point rounding errors.\n"
- title: 5.2.  Use of FDT for delivery of FEC Object Transmission Information
  contents:
  - "5.2.  Use of FDT for delivery of FEC Object Transmission Information\n   The\
    \ FDT delivers FEC Object Transmission Information for each file\n   using an\
    \ appropriate attribute within the \"FDT-Instance\" or the\n   \"File\" element\
    \ of the FDT structure.  For future FEC Encoding IDs, if\n   the attributes listed\
    \ below do not fulfill the needs of describing\n   the FEC Object Transmission\
    \ Information then additional new\n   attributes MAY be used.\n   *  \"Transfer-Length\"\
    \ is semantically equivalent with the field\n      \"Transfer Length\" of EXT_FTI.\n\
    \   *  \"FEC-OTI-FEC-Encoding-ID\" is semantically equivalent with the\n     \
    \ field \"FEC Encoding ID\" as carried in the Codepoint field of the\n      ALC/LCT\
    \ header.\n   *  \"FEC-OTI-FEC-Instance-ID\" is semantically equivalent with the\n\
    \      field \"FEC Instance ID\" of EXT_FTI.\n   *  \"FEC-OTI-Maximum-Source-Block-Length\"\
    \ is semantically equivalent\n      with the field \"Maximum Source Block Length\"\
    \ of EXT_FTI for FEC\n      Encoding IDs 0, 128 and 130, and semantically equivalent\
    \ with the\n      field \"Maximum Source Block Length\" of EXT_FTI for FEC Encoding\
    \ ID\n      129.\n   *  \"FEC-OTI-Encoding-Symbol-Length\" is semantically equivalent\
    \ with\n      the field \"Encoding Symbol Length\" of EXT_FTI for FEC Encoding\
    \ IDs\n      0, 128, 129 and 130.\n   *  \"FEC-OTI-Max-Number-of-Encoding-Symbols\"\
    \ is semantically\n      equivalent with the field \"Maximum Number of Encoding\
    \ Symbols\" of\n      EXT_FTI for FEC Encoding ID 129.\n"
- title: 6.  Describing file delivery sessions
  contents:
  - "6.  Describing file delivery sessions\n      To start receiving a file delivery\
    \ session, the receiver needs to\n      know transport parameters associated with\
    \ the session.\n      Interpreting these parameters and starting the reception\
    \ therefore\n      represents the entry point from which thereafter the receiver\n\
    \      operation falls into the scope of this specification.  According\n    \
    \  to [2], the transport parameters of an ALC/LCT session that the\n      receiver\
    \ needs to know are:\n   *  The source IP address;\n   *  The number of channels\
    \ in the session;\n   *  The destination IP address and port number for each channel\
    \ in the\n      session;\n   *  The Transport Session Identifier (TSI) of the\
    \ session;\n   *  An indication that the session is a FLUTE session.  The need\
    \ to\n      demultiplex objects upon reception is implicit in any use of\n   \
    \   FLUTE, and this fulfills the ALC requirement of an indication of\n      whether\
    \ or not a session carries packets for more than one object\n      (all FLUTE\
    \ sessions carry packets for more than one object).\n      Optionally, the following\
    \ parameters MAY be associated with the\n      session (Note, the list is not\
    \ exhaustive):\n   *  The start time and end time of the session;\n   *  FEC Encoding\
    \ ID and FEC Instance ID when the default FEC Encoding\n      ID 0 is not used\
    \ for the delivery of FDT;\n   *  Content Encoding format if optional content\
    \ encoding of FDT\n      Instance is used, e.g., compression;\n   *  Some information\
    \ that tells receiver, in the first place, that the\n      session contains files\
    \ that are of interest.\n   It is envisioned that these parameters would be described\
    \ according\n   to some session description syntax (such as SDP [12] or XML based)\n\
    \   and held in a file which would be acquired by the receiver before the\n  \
    \ FLUTE session begins by means of some transport protocol (such as\n   Session\
    \ Announcement Protocol [11], email, HTTP [6], SIP [22], manual\n   pre-configuration,\
    \ etc.) However, the way in which the receiver\n   discovers the above-mentioned\
    \ parameters is out of scope of this\n   document, as it is for LCT and ALC. \
    \ In particular, this\n   specification does not mandate or exclude any mechanism.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The security considerations that apply to, and\
    \ are described in, ALC\n   [2], LCT [3] and FEC [4] also apply to FLUTE.  In\
    \ addition, any\n   security considerations that apply to any congestion control\
    \ building\n   block used in conjunction with FLUTE also apply to FLUTE.\n   Because\
    \ of the use of FEC, FLUTE is especially vulnerable to denial-\n   of-service\
    \ attacks by attackers that try to send forged packets to\n   the session which\
    \ would prevent successful reconstruction or cause\n   inaccurate reconstruction\
    \ of large portions of the FDT or file by\n   receivers.  Like ALC, FLUTE is particularly\
    \ affected by such an\n   attack because many receivers may receive the same forged\
    \ packet.  A\n   malicious attacker may spoof file packets and cause incorrect\n\
    \   recovery of a file.\n   Even more damaging, a malicious forger may spoof FDT\
    \ Instance\n   packets, for example sending packets with erroneous FDT-Instance\n\
    \   fields.  Many attacks can follow this approach.  For instance a\n   malicious\
    \ attacker may alter the Content-Location field of TOI 'n',\n   to make it point\
    \ to a system file or a user configuration file.\n   Then, TOI 'n' can carry a\
    \ Trojan Horse or some other type of virus.\n   It is thus STRONGLY RECOMMENDED\
    \ that the FLUTE delivery service at\n   the receiver does not have write access\
    \ to the system files or\n   directories, or any other critical areas.  As described\
    \ for MIME\n   [20][21], special consideration should be paid to the security\n\
    \   implications of any MIME types that can cause the remote execution of\n  \
    \ any actions in the recipient's environment.  Note, RFC 1521 [21]\n   describes\
    \ important security issues for this environment, even though\n   its protocol\
    \ is obsoleted by RFC 2048 [20].\n   Another example is generating a bad Content-MD5\
    \ sum, leading\n   receivers to reject the associated file that will be declared\n\
    \   corrupted.  The Content-Encoding can also be modified, which also\n   prevents\
    \ the receivers to correctly handle the associated file.\n   These examples show\
    \ that the FDT information is critical to the FLUTE\n   delivery service.\n  \
    \ At the application level, it is RECOMMENDED that an integrity check\n   on the\
    \ entire received object be done once the object is\n   reconstructed to ensure\
    \ it is the same as the sent object, especially\n   for objects that are FDT Instances.\
    \  Moreover, in order to obtain\n   strong cryptographic integrity protection\
    \ a digital signature\n   verifiable by the receiver SHOULD be used to provide\
    \ this application\n   level integrity check.  However, if even one corrupted\
    \ or forged\n   packet is used to reconstruct the object, it is likely that the\n\
    \   received object will be reconstructed incorrectly.  This will\n   appropriately\
    \ cause the integrity check to fail and, in this case,\n   the inaccurately reconstructed\
    \ object SHOULD be discarded.  Thus, the\n   acceptance of a single forged packet\
    \ can be an effective denial of\n   service attack for distributing objects, but\
    \ an object integrity\n   check at least prevents inadvertent use of inaccurately\
    \ reconstructed\n   objects.  The specification of an application level integrity\
    \ check\n   of the received object is outside the scope of this document.\n  \
    \ At the packet level, it is RECOMMENDED that a packet level\n   authentication\
    \ be used to ensure that each received packet is an\n   authentic and uncorrupted\
    \ packet containing FEC data for the object\n   arriving from the specified sender.\
    \  Packet level authentication has\n   the advantage that corrupt or forged packets\
    \ can be discarded\n   individually and the received authenticated packets can\
    \ be used to\n   accurately reconstruct the object.  Thus, the effect of a denial\
    \ of\n   service attack that injects forged packets is proportional only to\n\
    \   the number of forged packets, and not to the object size.  Although\n   there\
    \ is currently no IETF standard that specifies how to do\n   multicast packet\
    \ level authentication, TESLA [14] is a known\n   multicast packet authentication\
    \ scheme that would work.\n   In addition to providing protection against reconstruction\
    \ of\n   inaccurate objects, packet level authentication can also provide some\n\
    \   protection against denial of service attacks on the multiple rate\n   congestion\
    \ control.  Attackers can try to inject forged packets with\n   incorrect congestion\
    \ control information into the multicast stream,\n   thereby potentially adversely\
    \ affecting network elements and\n   receivers downstream of the attack, and much\
    \ less significantly the\n   rest of the network and other receivers.  Thus, it\
    \ is also\n   RECOMMENDED that packet level authentication be used to protect\n\
    \   against such attacks.  TESLA [14] can also be used to some extent to\n   limit\
    \ the damage caused by such attacks.  However, with TESLA a\n   receiver can only\
    \ determine if a packet is authentic several seconds\n   after it is received,\
    \ and thus an attack against the congestion\n   control protocol can be effective\
    \ for several seconds before the\n   receiver can react to slow down the session\
    \ reception rate.\n   Reverse Path Forwarding checks SHOULD be enabled in all\
    \ network\n   routers and switches along the path from the sender to receivers\
    \ to\n   limit the possibility of a bad agent injecting forged packets into\n\
    \   the multicast tree data path.\n   A receiver with an incorrect or corrupted\
    \ implementation of the\n   multiple rate congestion control building block may\
    \ affect health of\n   the network in the path between the sender and the receiver,\
    \ and may\n   also affect the reception rates of other receivers joined to the\n\
    \   session.  It is therefore RECOMMENDED that receivers be required to\n   identify\
    \ themselves as legitimate before they receive the Session\n   Description needed\
    \ to join the session.  How receivers identify\n   themselves as legitimate is\
    \ outside the scope of this document.\n   Another vulnerability of FLUTE is the\
    \ potential of receivers\n   obtaining an incorrect Session Description for the\
    \ session.  The\n   consequences of this could be that legitimate receivers with\
    \ the\n   wrong Session Description are unable to correctly receive the session\n\
    \   content, or that receivers inadvertently try to receive at a much\n   higher\
    \ rate than they are capable of, thereby disrupting traffic in\n   portions of\
    \ the network.  To avoid these problems, it is RECOMMENDED\n   that measures be\
    \ taken to prevent receivers from accepting incorrect\n   Session Descriptions,\
    \ e.g., by using source authentication to ensure\n   that receivers only accept\
    \ legitimate Session Descriptions from\n   authorized senders.  How this is done\
    \ is outside the scope of this\n   document.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   No information in this specification is directly\
    \ subject to IANA\n   registration.  However, building blocks components used\
    \ by ALC may\n   introduce additional IANA considerations.  In particular, the\
    \ FEC\n   building block used by FLUTE does require IANA registration of the\n\
    \   FEC codec used.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   The following persons have contributed to this specification:\
    \ Brian\n   Adamson, Mark Handley, Esa Jalonen, Roger Kermode, Juha-Pekka Luoma,\n\
    \   Jani Peltotalo, Sami Peltotalo, Topi Pohjolainen, and Lorenzo\n   Vicisano.\
    \  The authors would like to thank all the contributors for\n   their valuable\
    \ work in reviewing and providing feedback regarding\n   this specification.\n"
- title: Normative References
  contents:
  - "Normative References\n   [1]   Bradner, S., \"Key words for use in RFCs to Indicate\
    \ Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n   [2]   Luby,\
    \ M., Gemmell, J., Vicisano, L., Rizzo, L., and J.\n         Crowcroft, \"Asynchronous\
    \ Layered Coding (ALC) Protocol\n         Instantiation\", RFC 3450, December\
    \ 2002.\n   [3]   Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M.,\n\
    \         and J. Crowcroft, \"Layered Coding Transport (LCT) Building\n      \
    \   Block\", RFC 3451, December 2002.\n   [4]   Luby, M., Vicisano, L., Gemmell,\
    \ J., Rizzo, L., Handley, M.,\n         and J. Crowcroft, \"Forward Error Correction\
    \ (FEC) Building\n         Block\", RFC 3452, December 2002.\n   [5]   Mills,\
    \ D., \"Network Time Protocol (Version 3) Specification,\n         Implementation\"\
    , RFC 1305, March 1992.\n   [6]   Fielding,  R., Gettys, J., Mogul, J., Frystyk,\
    \ H., Masinter,\n         L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer\
    \ Protocol\n         -- HTTP/1.1\", RFC 2616, June 1999.\n   [7]   Luby, M. and\
    \ L. Vicisano, \"Compact Forward Error Correction\n         (FEC) Schemes\", RFC\
    \ 3695, February 2004.\n   [8]   Thompson, H., Beech, D., Maloney, M. and N. Mendelsohn,\
    \ \"XML\n         Schema Part 1: Structures\", W3C Recommendation, May 2001.\n\
    \   [9]   Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes\", W3C\n \
    \        Recommendation, May 2001.\n"
- title: Informative References
  contents:
  - "Informative References\n   [10]  Deutsch, P. and J-L. Gailly, \"ZLIB Compressed\
    \ Data Format\n         Specification version 3.3\", RFC 1950, May 1996.\n   [11]\
    \  Handley, M., Perkins, C., and E. Whelan, \"Session Announcement\n         Protocol\"\
    , RFC 2974, October 2000.\n   [12]  Handley, M. and V. Jacobson, \"SDP: Session\
    \ Description\n         Protocol\", RFC 2327, April 1998.\n   [13]  Deering, S.,\
    \ \"Host extensions for IP multicasting\", STD 5, RFC\n         1112, August 1989.\n\
    \   [14]  Perrig, A., Canetti, R., Song, D., and J. Tygar, \"Efficient and\n \
    \        Secure Source Authentication for Multicast, Network and\n         Distributed\
    \ System Security Symposium, NDSS 2001, pp. 35-46.\",\n         February 2001.\n\
    \   [15]  Holbrook, H., \"A Channel Model for Multicast, Ph.D.\n         Dissertation,\
    \ Stanford University, Department of Computer\n         Science, Stanford, California\"\
    , August 2001.\n   [16]  Deutsch, P., \"DEFLATE Compressed Data Format Specification\n\
    \         version 1.3\", RFC 1951, May 1996.\n   [17]  Deutsch, P., \"GZIP file\
    \ format specification version 4.3\", RFC\n         1952, May 1996.\n   [18] \
    \ Ramsdell, B., \"Secure/Multipurpose Internet Mail Extensions\n         (S/MIME)\
    \ Version 3.1 Message Specification\", RFC 3851, July\n         2004.\n   [19]\
    \  Eastlake, D., Reagle, J., and D. Solo, \"(Extensible Markup\n         Language)\
    \ XML-Signature Syntax and Processing\", RFC 3275, March\n         2002.\n   [20]\
    \  Freed, N., Klensin, J., and J. Postel, \"Multipurpose Internet\n         Mail\
    \ Extensions (MIME) Part Four: Registration Procedures\", RFC\n         2048,\
    \ November 1996.\n   [21]  Moore, K., \"MIME (Multipurpose Internet Mail Extensions)\
    \ Part\n         Three: Message Header Extensions for Non-ASCII Text\", RFC 1521,\n\
    \         November 1996.\n   [22]  Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston, A.,\n         Peterson, J., Sparks, R., Handley, M., and E. Schooler,\
    \ \"SIP:\n         session initiation protocol\", RFC 3261, June 2002.\n"
- title: Appendix A.  Receiver operation (informative)
  contents:
  - "Appendix A.  Receiver operation (informative)\n   This section gives an example\
    \ how the receiver of the file delivery\n   session may operate.  Instead of a\
    \ detailed state-by-state\n   specification the following should be interpreted\
    \ as a rough sequence\n   of an envisioned file delivery receiver.\n   1. The\
    \ receiver obtains the description of the file delivery session\n      identified\
    \ by the pair: (source IP address,  Transport Session\n      Identifier).  The\
    \ receiver also obtains the destination IP\n      addresses and respective ports\
    \ associated with the file delivery\n      session.\n   2. The receiver joins\
    \ the channels in order to receive packets\n      associated with the file delivery\
    \ session.  The receiver may\n      schedule this join operation utilizing the\
    \ timing information\n      contained in a possible description of the file delivery\
    \ session.\n   3. The receiver receives ALC/LCT packets associated with the file\n\
    \      delivery session.  The receiver checks that the packets match the\n   \
    \   declared Transport Session Identifier.  If not, packets are\n      silently\
    \ discarded.\n   4. While receiving, the receiver demultiplexes packets based\
    \ on their\n      TOI and stores the relevant packet information in an appropriate\n\
    \      area for recovery of the corresponding file.  Multiple files can\n    \
    \  be reconstructed concurrently.\n   5. Receiver recovers an object.  An object\
    \ can be recovered when an\n      appropriate set of packets containing Encoding\
    \ Symbols for the\n      transport object have been received.  An appropriate\
    \ set of\n      packets is dependent on the properties of the FEC Encoding ID\
    \ and\n      FEC Instance ID, and on other information contained in the FEC\n\
    \      Object Transmission Information.\n   6. If the recovered object was an\
    \ FDT Instance with FDT Instance ID\n      'N', the receiver parses the payload\
    \ of the instance 'N' of FDT\n      and updates its FDT database accordingly.\
    \  The receiver identifies\n      FDT Instances within a file delivery session\
    \ by the EXT_FDT header\n      extension.  Any object that is delivered using\
    \ EXT_FDT header\n      extension is an FDT Instance, uniquely identified by the\
    \ FDT\n      Instance ID.  Note that TOI '0' is exclusively reserved for FDT\n\
    \      delivery.\n   7. If the object recovered is not an FDT Instance but a file,\
    \ the\n      receiver looks up its FDT database to get the properties described\n\
    \      in the database, and assigns file with the given properties.  The\n   \
    \   receiver also checks that received content length matches with the\n     \
    \ description in the database.  Optionally, if MD5 checksum has been\n      used,\
    \ the receiver checks that calculated MD5 matches with the\n      description\
    \ in the FDT database.\n   8. The actions the receiver takes with imperfectly\
    \ received files\n      (missing data, mismatching digestive, etc.) is outside\
    \ the scope\n      of this specification.  When a file is recovered before the\n\
    \      associated file description entry is available, a possible\n      behavior\
    \ is to wait until an FDT Instance is received that\n      includes the missing\
    \ properties.\n   9. If the file delivery session end time has not been reached\
    \ go back\n      to 3.  Otherwise end.\n"
- title: Appendix B.  Example of FDT Instance (informative)
  contents:
  - 'Appendix B.  Example of FDT Instance (informative)

    '
- title: <?xml version="1.0" encoding="UTF-8"?>
  contents:
  - '<?xml version="1.0" encoding="UTF-8"?>

    '
- title: <FDT-Instance xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  contents:
  - '<FDT-Instance xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

    '
- title: xmlns:fl="http://www.example.com/flute"
  contents:
  - 'xmlns:fl="http://www.example.com/flute"

    '
- title: xsi:schemaLocation="http://www.example.com/flute-fdt.xsd"
  contents:
  - 'xsi:schemaLocation="http://www.example.com/flute-fdt.xsd"

    '
- title: Expires="2890842807">
  contents:
  - "Expires=\"2890842807\">\n        <File\n           Content-Location=\"http://www.example.com/menu/tracklist.html\"\
    \n           TOI=\"1\"\n           Content-Type=\"text/html\"/>\n        <File\n\
    \           Content-Location=\"http://www.example.com/tracks/track1.mp3\"\n  \
    \         TOI=\"2\"\n           Content-Length=\"6100\"\n           Content-Type=\"\
    audio/mp3\"\n           Content-Encoding=\"gzip\"\n           Content-MD5=\"+VP5IrWploFkZWc11iLDdA==\"\
    \n           Some-Private-Extension-Tag=\"abc123\"/>\n"
- title: </FDT-Instance>
  contents:
  - '</FDT-Instance>

    '
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Toni Paila\n   Nokia\n   Itamerenkatu 11-13\n   Helsinki\
    \  FIN-00180\n   Finland\n   EMail: toni.paila@nokia.com\n   Michael Luby\n  \
    \ Digital Fountain\n   39141 Civic Center Dr.\n   Suite 300\n   Fremont, CA  94538\n\
    \   USA\n   EMail: luby@digitalfountain.com\n   Rami Lehtonen\n   TeliaSonera\n\
    \   Hatanpaan valtatie 18\n   Tampere  FIN-33100\n   Finland\n   EMail: rami.lehtonen@teliasonera.com\n\
    \   Vincent Roca\n   INRIA Rhone-Alpes\n   655, av. de l'Europe\n   Montbonnot\n\
    \   St Ismier cedex  38334\n   France\n   EMail: vincent.roca@inrialpes.fr\n \
    \  Rod Walsh\n   Nokia\n   Visiokatu 1\n   Tampere  FIN-33720\n   Finland\n  \
    \ EMail: rod.walsh@nokia.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/S HE\n   REPRESENTS\
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE\n   INTERNET ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ IETF's procedures with respect to rights in IETF Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
