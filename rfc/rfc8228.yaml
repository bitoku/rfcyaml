- title: __initial_text__
  contents:
  - "   Guidance on Designing Label Generation Rulesets (LGRs) Supporting\n      \
    \                       Variant Labels\n"
- title: Abstract
  contents:
  - "Abstract\n   Rules for validating identifier labels and alternate representations\n\
    \   of those labels (variants) are known as Label Generation Rulesets\n   (LGRs);\
    \ they are used for the implementation of identifier systems\n   such as Internationalized\
    \ Domain Names (IDNs).  This document\n   describes ways to design LGRs to support\
    \ variant labels.  In\n   designing LGRs, it is important to ensure that the label\
    \ generation\n   rules are consistent and well behaved in the presence of variants.\n\
    \   The design decisions can then be expressed using the XML\n   representation\
    \ of LGRs that is defined in RFC 7940.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It has been approved for\
    \ publication by the Internet\n   Engineering Steering Group (IESG).  Not all\
    \ documents approved by the\n   IESG are a candidate for any level of Internet\
    \ Standard; see\n   Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc8228.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Variant Relations . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n   3.  Symmetry and Transitivity . . . . . . . . . . . . . . .\
    \ . . .   5\n   4.  A Word on Notation  . . . . . . . . . . . . . . . . . . .\
    \ . .   5\n   5.  Variant Mappings  . . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n   6.  Variant Labels  . . . . . . . . . . . . . . . . . . . . . . .\
    \   7\n   7.  Variant Types and Label Dispositions  . . . . . . . . . . . .  \
    \ 7\n   8.  Allocatable Variants  . . . . . . . . . . . . . . . . . . . .   8\n\
    \   9.  Blocked Variants  . . . . . . . . . . . . . . . . . . . . . .   9\n  \
    \ 10. Pure Variant Labels . . . . . . . . . . . . . . . . . . . . .  10\n   11.\
    \ Reflexive Variants  . . . . . . . . . . . . . . . . . . . . .  11\n   12. Limiting\
    \ Allocatable Variants by Subtyping  . . . . . . . . .  12\n   13. Allowing Mixed\
    \ Originals  . . . . . . . . . . . . . . . . . .  14\n   14. Handling Out-of-Repertoire\
    \ Variants . . . . . . . . . . . . .  15\n   15. Conditional Variants  . . . .\
    \ . . . . . . . . . . . . . . . .  16\n   16. Making Conditional Variants Well\
    \ Behaved  . . . . . . . . . .  18\n   17. Variants for Sequences  . . . . . .\
    \ . . . . . . . . . . . . .  19\n   18. Corresponding XML Notation  . . . . .\
    \ . . . . . . . . . . . .  21\n   19. IANA Considerations . . . . . . . . . .\
    \ . . . . . . . . . . .  22\n   20. Security Considerations . . . . . . . . .\
    \ . . . . . . . . . .  23\n   21. References  . . . . . . . . . . . . . . . .\
    \ . . . . . . . . .  23\n     21.1.  Normative References . . . . . . . . . .\
    \ . . . . . . . .  23\n     21.2.  Informative References . . . . . . . . . .\
    \ . . . . . . .  23\n   Acknowledgments . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  24\n   Author's Address  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  24\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Label Generation Rulesets (LGRs) that define the set of\
    \ permissible\n   labels may be applied to identifier systems that rely on labels,\
    \ such\n   as the Domain Name System (DNS) [RFC1034] [RFC1035].  To date, LGRs\n\
    \   have mostly been used to define policies for implementing\n   Internationalized\
    \ Domain Names (IDNs) using IDNA2008 [RFC5890]\n   [RFC5891] [RFC5892] [RFC5893]\
    \ [RFC5894] in the DNS.  This document\n   aims to discuss the generation of LGRs\
    \ for such circumstances, but\n   the techniques and considerations here are almost\
    \ certainly\n   applicable to a wider range of internationalized identifiers.\n\
    \   In addition to determining whether a given label is eligible, LGRs\n   may\
    \ also define the condition under which alternate representations\n   of these\
    \ labels, so-called \"variant labels\", may exist and their\n   status (disposition).\
    \  In the most general sense, variant labels are\n   typically labels that are\
    \ either visually or semantically\n   indistinguishable from another label in\
    \ the context of the writing\n   system or script supported by the LGR.  Unlike\
    \ merely similar labels,\n   where there may be a measurable degree of similarity,\
    \ variant labels\n   considered here represent a form of equivalence in meaning\
    \ or\n   appearance.  What constitutes an appropriate variant in any writing\n\
    \   system or given context, particularly in the DNS, is assumed to have\n   been\
    \ determined ahead of time and therefore is not a subject of this\n   document.\n\
    \   Once identified, variant labels are typically delegated to some\n   entity\
    \ together with the applied-for label, or permanently reserved,\n   based on the\
    \ disposition derived from the LGR.  Correctly defined,\n   variant labels can\
    \ improve the security of an LGR, yet successfully\n   defining variant rules\
    \ for an LGR so that the result is well behaved\n   is not always trivial.  This\
    \ document describes the basic\n   considerations and constraints that must be\
    \ taken into account and\n   gives examples of what might be use cases for different\
    \ types of\n   variant specifications in an LGR.\n   This document does not address\
    \ whether variants are an appropriate\n   means to solve any given issue or the\
    \ basis on which they should be\n   defined.  It is intended to explain in more\
    \ detail the effects of\n   various declarations and the trade-offs in making\
    \ design choices.  It\n   implicitly assumes that any LGR will be expressed using\
    \ the XML\n   representation defined in [RFC7940] and therefore conforms to any\n\
    \   requirements stated therein.  Purely for clarity of exposition,\n   examples\
    \ in this document use a more compact notation than the XML\n   syntax defined\
    \ in [RFC7940].  However, the reader is expected to have\n   some familiarity\
    \ with the concepts described in that RFC (see\n   Section 4).\n   The user of\
    \ any identifier system, such as the DNS, interacts with it\n   in the context\
    \ of labels; variants are experienced as variant labels,\n   i.e., two (or more)\
    \ labels that are functionally \"same as\" under the\n   conventions of the writing\
    \ system used, even though their code point\n   sequences are different.  An LGR\
    \ specification, on the other hand,\n   defines variant mappings between code\
    \ points and, only in a secondary\n   step, derives the variant labels from these\
    \ mappings.  For a\n   discussion of this process, see [RFC7940].\n   The designer\
    \ of an LGR can control whether some or all of the variant\n   labels created\
    \ from an original label should be allocatable, i.e.,\n   available for allocation\
    \ (to the original applicant), or whether some\n   or all of these labels should\
    \ be blocked instead, i.e., remain not\n   allocatable (to anyone).  This document\
    \ describes how this choice of\n   label disposition is accomplished (see Section\
    \ 7).\n   The choice of desired label disposition would be based on the\n   expectations\
    \ of the users of the particular zone; it is not the\n   subject of this document.\
    \  Likewise, this document does not address\n   the possibility of an LGR defining\
    \ custom label dispositions.\n   Instead, this document suggests ways of designing\
    \ an LGR to achieve\n   the selected design choice for handling variants in the\
    \ context of\n   the two standard label dispositions: \"allocatable\" and \"blocked\"\
    .\n   The information in this document is based on operational experience\n  \
    \ gained in developing LGRs for a wide number of languages and scripts\n   using\
    \ RFC 7940.  This information is provided here as a benefit to\n   the wider community.\
    \  It does not alter or change the specification\n   found in RFC 7940 in any\
    \ way.\n"
- title: 2.  Variant Relations
  contents:
  - "2.  Variant Relations\n   A variant relation is fundamentally a \"same as\" relation;\
    \ in other\n   words, it is an equivalence relation.  Now, the strictest sense\
    \ of\n   \"same as\" would be equality, and for any equality, we have both\n \
    \  symmetry\n     A = B => B = A\n   and transitivity\n     A = B and B = C =>\
    \ A = C\n   The variant relation with its functional sense of \"same as\" must\n\
    \   really satisfy the same constraint.  Once we say A is the \"same as\"\n  \
    \ B, we also assert that B is the \"same as\" A.  In this document, the\n   symbol\
    \ \"~\" means \"has a variant relation with\".  Thus, we get\n     A ~ B => B\
    \ ~ A\n   Likewise, if we make the same claim for B and C (B ~ C), then we get\n\
    \   A ~ C, because if B is the \"same as\" both A and C, then A must be the\n\
    \   \"same as\" C:\n     A ~ B and B ~ C => A ~ C\n"
- title: 3.  Symmetry and Transitivity
  contents:
  - "3.  Symmetry and Transitivity\n   Not all potential relations between labels\
    \ constitute equivalence,\n   and those that do not are not transitive and may\
    \ not be symmetric.\n   For example, the degree to which labels are confusable\
    \ is not\n   transitive: two labels can be confusingly similar to a third without\n\
    \   necessarily being confusable with each other, such as when the third\n   one\
    \ has a shape that is \"in between\" the other two.  In contrast, a\n   relation\
    \ based on identical or effectively identical appearance would\n   meet the criterion\
    \ of transitivity, and we would consider it a\n   variant relation.  Examples\
    \ of variant relations include other forms\n   of equivalence, such as semantic\
    \ equivalence.\n   Using [RFC7940], a set of mappings could be defined that is\
    \ neither\n   symmetric nor transitive; such a specification would be formally\n\
    \   valid.  However, a symmetric and transitive set of mappings is\n   strongly\
    \ preferred as a basis for an LGR, not least because of the\n   benefits from\
    \ an implementation point of view; for example, if all\n   mappings are symmetric\
    \ and transitive, it greatly simplifies the\n   check for collisions between labels\
    \ with variants.  For this reason,\n   we will limit the discussion in this document\
    \ to those relations that\n   are symmetric and transitive.  Incidentally, it\
    \ is often\n   straightforward to verify mechanically whether an LGR is symmetric\n\
    \   and/or transitive and to compute any mappings required to make it so\n   (but\
    \ see Section 15).\n"
- title: 4.  A Word on Notation
  contents:
  - "4.  A Word on Notation\n   [RFC7940] defines an XML schema for Label Generation\
    \ Rulesets in\n   general and variant code points and sequences in particular\
    \ (see\n   Section 18).  That notation is rather verbose and can easily obscure\n\
    \   salient features to anyone not trained to read XML.  For this reason,\n  \
    \ this document uses a symbolic shorthand notation in presenting the\n   examples\
    \ for discussion.  This shorthand is merely a didactic tool\n   for presentation\
    \ and is not intended as an alternative to or\n   replacement for the XML syntax\
    \ that is used in formally specifying an\n   LGR under [RFC7940].\n   When it\
    \ comes time to capture the LGR in a formal definition, the\n   notation used\
    \ for any of the examples in this document can be\n   converted to the XML format\
    \ as described in Section 18.\n"
- title: 5.  Variant Mappings
  contents:
  - "5.  Variant Mappings\n   So far, we have treated variant relations as simple\
    \ \"same as\"\n   relations, ignoring that each relation representing equivalence\
    \ would\n   consist of a symmetric pair of reciprocal mappings.  In this\n   document,\
    \ the symbol \"-->\" means \"maps to\".\n   A ~ B => A --> B, B --> A\n   In an\
    \ LGR, these mappings are not defined directly between labels but\n   between\
    \ code points (or code point sequences; see Section 17).  In\n   the transitive\
    \ case, given\n   A ~ B => A --> B, B --> A\n   A ~ C => A --> C, C --> A\n  \
    \ we also get\n   B ~ C => B --> C, C --> B\n   for a total of six possible mappings.\
    \  Conventionally, these are\n   listed in tables in order of the source code\
    \ point, like so:\n     A --> B\n     A --> C\n     B --> A\n     B --> C\n  \
    \   C --> A\n     C --> B\n   As we can see, A, B, and C can each be mapped two\
    \ ways.\n"
- title: 6.  Variant Labels
  contents:
  - "6.  Variant Labels\n   To create a variant label, each code point in the original\
    \ label is\n   successively replaced by all variant code points defined by a mapping\n\
    \   from the original code point.  For a label AAA (the letter \"A\" three\n \
    \  times), the variant labels (given the mappings from the transitive\n   example\
    \ above) would be\n     AAB\n     ABA\n     ABB\n     BAA\n     BAB\n     BBA\n\
    \     BBB\n     AAC\n     ...\n     CCC\n   So far, we have merely defined what\
    \ the variant labels are, but we\n   have not considered their possible dispositions.\
    \  In the next\n   section, we discuss how to set up the variant mappings so that\
    \ some\n   variant labels are mutually exclusive (blocked), but some may be\n\
    \   allocated to the same applicant as the original label (allocatable).\n"
- title: 7.  Variant Types and Label Dispositions
  contents:
  - "7.  Variant Types and Label Dispositions\n   Assume we wanted to allow a variant\
    \ relation between code points O\n   and A, and perhaps between O and B or O and\
    \ C as well.  Assuming\n   transitivity, this would give us:\n     O ~ A ~ B ~\
    \ C\n   Now, further assume that we would like to distinguish the case where\n\
    \   someone applies for OOO from the case where someone applies for the\n   label\
    \ ABC.  In this case, we would like to allocate only the applied-\n   for label\
    \ OOO, but in the latter case, we would like to also allow\n   the allocation\
    \ of either the label OOO or the variant label ABC, or\n   both, but not of any\
    \ of the other possible variant labels, like OAO,\n   BCO, or the like.  (A real-world\
    \ example might be the case where O\n   represents an unaccented letter, while\
    \ A, B, and C might represent\n   various accented forms of the same letter. \
    \ Because unaccented\n   letters are a common fallback, there might be a desire\
    \ to allocate an\n   unaccented label as a variant, but not the other way around.)\n\
    \   How would we specify such a distinction?\n   The answer lies in labeling the\
    \ mappings A --> O, B --> O, and C -->\n   O with the type \"allocatable\" and\
    \ the mappings O --> A, O --> B, and\n   O --> C with the type \"blocked\".  In\
    \ this document, the symbol \"x-->\"\n   means \"maps with type blocked\", and\
    \ the symbol \"a-->\" means \"maps\n   with type allocatable\".  Thus:\n     O\
    \  x--> A\n     O  x--> B\n     O  x--> C\n     A  a--> O\n     B  a--> O\n  \
    \   C  a--> O\n   When we generate all permutations of labels, we use mappings\
    \ with\n   different types depending on which code points we start from.  The\n\
    \   set of all permuted variant labels would be the same, but the\n   disposition\
    \ of the variant label depends on which label we start from\n   (we call that\
    \ label the \"original\" or \"applied-for\" label).\n   In creating an LGR with\
    \ variants, all variant mappings should always\n   be labeled with a type ([RFC7940]\
    \ does not formally require a type,\n   but any well-behaved LGR would be fully\
    \ typed).  By default, these\n   types correspond directly to the dispositions\
    \ for variant labels,\n   with the most restrictive type determining the disposition\
    \ of the\n   variant label.  However, as we shall see later, it is sometimes\n\
    \   useful to assign types from a wider array of values than the final\n   dispositions\
    \ for the labels and then define explicitly how to derive\n   label dispositions\
    \ from them.\n"
- title: 8.  Allocatable Variants
  contents:
  - "8.  Allocatable Variants\n   If we start with AAA and use the mappings from Section\
    \ 7, the\n   permutation OOO will be the result of applying the mapping A a-->\
    \ O\n   at each code point.  That is, only mappings with type \"a\"\n   (allocatable)\
    \ were used.  To know whether we can allocate both the\n   label OOO and the original\
    \ label AAA, we track the types of the\n   mappings used in generating the label.\n\
    \   We record the variant types for each of the variant mappings used in\n   creating\
    \ the permutation in an ordered list.  Such an ordered list of\n   variant types\
    \ is called a \"variant type list\".  In running text, we\n   often show it enclosed\
    \ in square brackets.  For example, [a x -]\n   means the variant label was derived\
    \ from a variant mapping with the\n   \"a\" variant type in the first code point\
    \ position, \"x\" in the second\n   code point position, and the original code\
    \ point in the third\n   position (\"-\" means \"no variant mapping\").\n   For\
    \ our example permutation, we get the following variant type list\n   (brackets\
    \ dropped):\n     AAA --> OOO : a a a\n   From the variant type list, we derive\
    \ a \"variant type set\", denoted\n   by curly braces, that contains an unordered\
    \ set of unique variant\n   types in the variant type list.  For the variant type\
    \ list for the\n   given permutation, [a a a], the variant type set is { a },\
    \ which has\n   a single element \"a\".\n   Deciding whether to allow the allocation\
    \ of a variant label then\n   amounts to deriving a disposition for the variant\
    \ label from the\n   variant type set created from the variant mappings that were\
    \ used to\n   create the label.  For example, the derivation\n     if \"all variants\"\
    \ = \"a\" => set label disposition to \"allocatable\"\n   would allow OOO to be\
    \ allocated, because the types of all variant\n   mappings used to create that\
    \ variant label from AAA are \"a\".\n   The \"all-variants\" condition is tolerant\
    \ of an extra \"-\" in the\n   variant set (unlike the \"only-variants\" condition\
    \ described in\n   Section 10).  So, had we started with AOA, OAA, or AAO, the\
    \ variant\n   set for the permuted variant OOO would have been { a - } because\
    \ in\n   each case one of the code points remains the same code point as the\n\
    \   original.  The \"-\" means that because of the absence of a mapping O\n  \
    \ --> O, there is no variant type for the O in each of these labels.\n   The \"\
    all-variants\" = \"a\" condition ignores the \"-\", so using the\n   derivation\
    \ from above, we find that OOO is an allocatable variant for\n   each of the labels\
    \ AOA, OAA, or AAO.\n   Allocatable variant labels, especially large numbers of\
    \ allocatable\n   variants per label, incur a certain cost to users of the LGR.\
    \  A\n   well-behaved LGR will minimize the number of allocatable variants.\n"
- title: 9.  Blocked Variants
  contents:
  - "9.  Blocked Variants\n   Blocked variants are not available to another registrant.\
    \  They\n   therefore protect the applicant of the original label from someone\n\
    \   else registering a label that is the \"same as\" under some user-\n   perceived\
    \ metric.  Blocked variants can be a useful tool even for\n   scripts for which\
    \ no allocatable labels are ever defined.\n   If we start with OOO and use the\
    \ mappings from Section 7, the\n   permutation AAA will have been the result of\
    \ applying only mappings\n   with type \"blocked\", and we cannot allocate the\
    \ label AAA, only the\n   original label OOO.  This corresponds to the following\
    \ derivation:\n     if \"any variants\" = \"x\" => set label disposition to \"\
    blocked\"\n   Additionally, to prevent allocating ABO as a variant label for AAA,\n\
    \   we need to make sure that the mapping A --> B has been defined with\n   type\
    \ \"blocked\", as in\n     A  x--> B\n   so that\n     AAA --> ABO: - x a.\n \
    \  Thus, the set {x a} contains at least one \"x\" and satisfies the\n   derivation\
    \ of a blocked disposition for ABO when AAA is applied for.\n   If an LGR results\
    \ in a symmetric and transitive set of variant\n   labels, then the task of determining\
    \ whether a label or its variants\n   collide with another label or its variants\
    \ can be implemented very\n   efficiently.  Symmetry and transitivity imply that\
    \ sets of labels\n   that are mutual variants of each other are disjoint from\
    \ all other\n   such sets.  Only labels within the same set can be variants of\
    \ each\n   other.  Identifying the variant set can be an O(1) operation, and\n\
    \   enumerating all variants is not necessary.\n"
- title: 10.  Pure Variant Labels
  contents:
  - "10.  Pure Variant Labels\n   Now, if we wanted to prevent allocation of AOA when\
    \ we start from\n   AAA, we would need a rule disallowing a mix of original code\
    \ points\n   and variant code points; this is easily accomplished by use of the\n\
    \   \"only-variants\" qualifier, which requires that the label consist\n   entirely\
    \ of variants and that all the variants are from the same set\n   of types.\n\
    \     if \"only-variants\" = \"a\" => set label disposition to \"allocatable\"\
    \n   The two code points A in AOA are not arrived at by variant mappings,\n  \
    \ because the code points are unchanged and no variant mappings are\n   defined\
    \ for A --> A.  So, in our example, the set of variant mapping\n   types is\n\
    \     AAA --> AOA:  - a -\n   but unlike the \"all-variants\" condition, \"only-variants\"\
    \ requires a\n   variant type set { a } corresponding to a variant type list [a\
    \ a a]\n   (no - allowed).  By adding a final derivation\n     else if \"any-variants\"\
    \ = \"a\" => set label disposition to \"blocked\"\n   and executing that derivation\
    \ only on any remaining labels, we\n   disallow AOA when starting from AAA but\
    \ still allow OOO.\n   Derivation conditions are always applied in order, with\
    \ later\n   derivations only applying to labels that did not match any earlier\n\
    \   conditions, as indicated by the use of \"else\" in the last example.\n   In\
    \ other words, they form a cascade.\n"
- title: 11.  Reflexive Variants
  contents:
  - "11.  Reflexive Variants\n   But what if we started from AOA?  We would expect\
    \ the original label\n   OOO to be allocatable, but, using the mappings from Section\
    \ 7, the\n   variant type set would be\n     AOA --> OOO:  a - a\n   because the\
    \ middle O is unchanged from the original code point.  Here\n   is where we use\
    \ a reflexive mapping.  Realizing that O is the \"same\n   as\" O, we can map\
    \ it to itself.  This is normally redundant, but\n   adding an explicit reflexive\
    \ mapping allows us to specify a\n   disposition on that mapping:\n     O  a-->\
    \ O\n   With that, the variant type list for AOA --> OOO becomes:\n     AOA -->\
    \ OOO: a a a\n   and the label OOO again passes the derivation condition\n   \
    \  if \"only-variants\" = \"a\" => set label disposition to \"allocatable\"\n\
    \   as desired.  This use of reflexive variants is typical whenever\n   derivations\
    \ with the \"only-variants\" qualifier are used.  If any code\n   point uses a\
    \ reflexive variant, a well-behaved LGR would specify an\n   appropriate reflexive\
    \ variant for all code points.\n"
- title: 12.  Limiting Allocatable Variants by Subtyping
  contents:
  - "12.  Limiting Allocatable Variants by Subtyping\n   As we have seen, the number\
    \ of variant labels can potentially be\n   large, due to combinatorics.  Sometimes\
    \ it is possible to divide\n   variants into categories and to stipulate that\
    \ only variant labels\n   with variants from the same category should be allocatable.\
    \  For some\n   LGRs, this constraint can be implemented by a rule that disallows\n\
    \   code points from different categories to occur in the same\n   allocatable\
    \ label.  For other LGRs, the appropriate mechanism may be\n   dividing the allocatable\
    \ variants into subtypes.\n   To recap, in the standard case, a code point C can\
    \ have (up to) two\n   types of variant mappings\n     C  x--> X\n     C  a-->\
    \ A\n   where a--> means a variant mapping with type \"allocatable\" and x-->\n\
    \   means \"blocked\".  For the purpose of the following discussion, we\n   name\
    \ the target code point with the corresponding uppercase letter.\n   Subtyping\
    \ allows us to distinguish among different types of\n   allocatable variants.\
    \  For example, we can define three new types:\n   \"s\", \"t\", and \"b\".  Of\
    \ these, \"s\" and \"t\" are mutually incompatible,\n   but \"b\" is compatible\
    \ with either \"s\" or \"t\" (in this case, \"b\"\n   stands for \"both\").  A\
    \ real-world example for this might be variant\n   mappings appropriate for \"\
    simplified\" or \"traditional\" Chinese\n   variants, or appropriate for both.\n\
    \   With subtypes defined as above, a code point C might have (up to)\n   four\
    \ types of variant mappings\n     C  x--> X\n     C  s--> S\n     C  t--> T\n\
    \     C  b--> B\n   and explicit reflexive mappings of one of these types\n  \
    \   C  s--> C\n     C  t--> C\n     C  b--> C\n   As before, all mappings must\
    \ have one and only one type, but each\n   code point may map to any number of\
    \ other code points.\n   We define the compatibility of \"b\" with \"t\" or \"\
    s\" by our choice of\n   derivation conditions as follows\n     if \"any-variants\"\
    \ = \"x\" =>  blocked\n     else if \"only-variants\" = \"s\" or \"b\" =>  allocatable\n\
    \     else if \"only-variants\" = \"t\" or \"b\" =>  allocatable\n     else if\
    \ \"any-variants\" = \"s\" or \"t\" or \"b\" =>  blocked\n   An original label\
    \ of four code points\n     CCCC\n   may have many variant labels, such as this\
    \ example listed with its\n   corresponding variant type list:\n     CCCC -->\
    \ XSTB : x s t b\n   This variant label is blocked because to get from C to B\
    \ required\n   x-->.  (Because variant mappings are defined for specific source\
    \ code\n   points, we need to show the starting label for each of these\n   examples,\
    \ not merely the code points in the variant label.)  The\n   variant label\n \
    \    CCCC --> SSBB : s s b b\n   is allocatable, because the variant type list\
    \ contains only\n   allocatable mappings of subtype \"s\" or \"b\", which we have\
    \ defined as\n   being compatible by our choice of derivations.  The actual set\
    \ of\n   variant types {s, b} has only two members, but the examples are\n   easier\
    \ to follow if we list each type.  The label\n     CCCC --> TTBB : t t b b\n \
    \  is again allocatable, because the variant type set {t, b} contains\n   only\
    \ allocatable mappings of the mutually compatible allocatable\n   subtypes \"\
    t\" or \"b\".  In contrast,\n     CCCC --> SSTT : s s t t\n   is not allocatable,\
    \ because the type set contains incompatible\n   subtypes \"t\" and \"s\" and\
    \ thus would be blocked by the final\n   derivation.\n   The variant labels\n\
    \     CCCC --> CSBB : c s b b\n     CCCC --> CTBB : c t b b\n   are only allocatable\
    \ based on the subtype for the C --> C mapping,\n   which is denoted here by \"\
    c\" and (depending on what was chosen for\n   the type of the reflexive mapping)\
    \ could correspond to \"s\", \"t\", or\n   \"b\".\n   If the subtype is \"s\"\
    , the first of these two labels is allocatable;\n   if it is \"t\", the second\
    \ of these two labels is allocatable; if it is\n   \"b\", both labels are allocatable.\n\
    \   So far, the scheme does not seem to have brought any huge reduction\n   in\
    \ allocatable variant labels, but that is because we tacitly assumed\n   that\
    \ C could have all three types of allocatable variants \"s\", \"t\",\n   and \"\
    b\" at the same time.\n   In a real-world example, the types \"s\", \"t\", and\
    \ \"b\" are assigned so\n   that each code point C normally has, at most, one\
    \ non-reflexive\n   variant mapping labeled with one of these subtypes, and all\
    \ other\n   mappings would be assigned type \"x\" (blocked).  This holds true\
    \ for\n   most code points in existing tables (such as those used in current\n\
    \   IDN Top-Level Domains (TLDs)), although certain code points have\n   exceptionally\
    \ complex variant relations and may have an extra\n   mapping.\n"
- title: 13.  Allowing Mixed Originals
  contents:
  - "13.  Allowing Mixed Originals\n   If the desire is to allow original labels (but\
    \ not variant labels)\n   that are s/t mixed, then the scheme needs to be slightly\
    \ refined to\n   distinguish between reflexive and non-reflexive variants.  In\
    \ this\n   document, the symbol \"r-n\" means \"a reflexive (identity) mapping\
    \ of\n   type 'n'\".  The reflexive mappings of the preceding section thus\n \
    \  become:\n   C  r-s--> C\n   C  r-t--> C\n   C  r-b--> C\n   With this convention,\
    \ and redefining the derivations\n   if \"any-variants\" = \"x\" =>  blocked\n\
    \   else if \"only-variants\" = \"s\" or \"r-s\" or \"b\" or \"r-b\" => allocatable\n\
    \   else if \"only-variants\" = \"t\" or \"r-t\" or \"b\" or \"r-b\" => allocatable\n\
    \   else if \"any-variants\" = \"s\" or \"t\" or \"b\"  => blocked\n   else =>\
    \ allocatable\n   any labels that contain only reflexive mappings of otherwise\
    \ mixed\n   type (in other words, any mixed original label) now fall through,\
    \ and\n   their disposition is set to \"allocatable\" in the final derivation.\n\
    \   In a well-behaved LGR, it is preferable to explicitly define the\n   derivation\
    \ for allocatable labels instead of using a fall through.\n   In the derivation\
    \ above, code points without any variant mappings\n   fall through and become\
    \ allocatable by default if they are part of an\n   original label.  Especially\
    \ in a large repertoire, it can be\n   difficult to identify which code points\
    \ are affected.  Instead, it is\n   preferable to mark them with their own reflexive\
    \ mapping type\n   \"neither\" or \"r-n\".\n     C  r-n--> C\n   With that, we\
    \ can change\n     else =>  allocatable\n   to\n     else if \"only-variants\"\
    \ = \"r-s\" or \"r-t\" or \"r-b\" or \"r-n\"\n          =>  allocatable\n    \
    \ else => invalid\n   This makes the intent more explicit, and by ensuring that\
    \ all code\n   points in the LGR have a reflexive mapping of some kind, it is\
    \ easier\n   to verify the correct assignment of their types.\n"
- title: 14.  Handling Out-of-Repertoire Variants
  contents:
  - "14.  Handling Out-of-Repertoire Variants\n   At first, it may seem counterintuitive\
    \ to define variants that map to\n   code points that are not part of the repertoire.\
    \  However, for zones\n   for which multiple LGRs are defined, there may be situations\
    \ where\n   labels valid under one LGR should be blocked if a label under another\n\
    \   LGR is already delegated.  This situation can arise whether or not\n   the\
    \ repertoires of the affected LGRs overlap and, where repertoires\n   overlap,\
    \ whether or not the labels are both restricted to the common\n   subset.\n  \
    \ In order to handle this exclusion relation through definition of\n   variants,\
    \ it is necessary to be able to specify variant mappings to\n   some code point\
    \ X that is outside an LGR's repertoire, R:\n     C  x--> X : where C = elementOf(R)\
    \ and X != elementOf(R)\n   Because of symmetry, it is necessary to also specify\
    \ the inverse\n   mapping in the LGR:\n     X  x--> C : where X != elementOf(R)\
    \ and C = elementOf(R)\n   This makes X a source of variant mappings, and it becomes\
    \ necessary\n   to identify X as being outside the repertoire, so that any attempt\
    \ to\n   apply for a label containing X will lead to a disposition of\n   \"invalid\"\
    , just as if X had never been listed in the LGR.  The\n   mechanism to do this\
    \ uses reflexive variants but with a new type of\n   reflexive mapping of \"out-of-repertoire-var\"\
    , shown as \"r-o-->\":\n     X  r-o--> X\n   This indicates X != elementOf(R),\
    \ as long as the LGR is provided with\n   a suitable derivation, so that any label\
    \ containing \"r-o-->\" is\n   assigned a disposition of \"invalid\", just as\
    \ if X was any other code\n   point not part of the repertoire.  The derivation\
    \ used is:\n     if \"any-variant\" = \"out-of-repertoire-var\" => invalid\n \
    \  It is inserted ahead of any other derivation of the \"any-variant\"\n   kind\
    \ in the chain of derivations.  As a result, instead of the\n   minimum two symmetric\
    \ variants, for any out-of-repertoire variants,\n   there are a minimum of three\
    \ variant mappings defined:\n     C  x--> X\n     X  x--> C\n     X  r-o--> X\n\
    \   where C = elementOf(R) and X != elementOf(R).\n   Because no variant label\
    \ with any code point outside the repertoire\n   could ever be allocated, the\
    \ only logical choice for the non-\n   reflexive mappings to out-of-repertoire\
    \ code points is \"blocked\".\n"
- title: 15.  Conditional Variants
  contents:
  - "15.  Conditional Variants\n   Variant mappings are based on whether code points\
    \ are \"same as\" to\n   the user.  In some writing systems, code points change\
    \ shape based on\n   where they occur in the word (positional forms).  Some code\
    \ points\n   have matching shapes in some positions but not in others.  In such\n\
    \   cases, the variant mapping exists only for some possible positions\n   or,\
    \ more generally, only for some contexts.  For other contexts, the\n   variant\
    \ mapping does not exist.\n   For example, take two code points that have the\
    \ same shape at the end\n   of a label (or in final position) but not in any other\
    \ position.  In\n   that case, they are variants only when they occur in the final\n\
    \   position, something we indicate like this:\n     final: C --> D\n   In cursively\
    \ connected scripts, like Arabic, a code point may take\n   its final form when\
    \ next to any following code point that interrupts\n   the cursive connection,\
    \ not just at the end of a label.  (We ignore\n   the isolated form to keep the\
    \ discussion simple; if included, \"final\"\n   might be \"final-or-isolate\"\
    , for example).\n   From symmetry, we expect that the mapping D --> C should also\
    \ exist\n   only when the code point D is in final position.  (Similar\n   considerations\
    \ apply to transitivity.)\n   Sometimes a code point has a final form that is\
    \ practically the same\n   as that of some other code point while sharing initial\
    \ and medial\n   forms with another.\n     final: C --> D\n     !final: C -->\
    \ E\n   Here, the case where the condition is the opposite of final is shown\n\
    \   as \"!final\".\n   Because shapes differ by position, when a context is applied\
    \ to a\n   variant mapping, it is treated independently from the same mapping\
    \ in\n   other contexts.  This extends to the assignment of types.  For\n   example,\
    \ the mapping C --> F may be \"allocatable\" in final position\n   but \"blocked\"\
    \ in any other context:\n     final:  C  a--> F\n     !final: C  x--> F\n   Now,\
    \ the type assigned to the forward mapping is independent of the\n   reverse symmetric\
    \ mapping or any transitive mappings.  Imagine a\n   situation where the symmetric\
    \ mapping is defined as F a--> C, that\n   is, all mappings from F to C are \"\
    allocatable\":\n     final: F  a--> C\n     !final: F  a-->C\n   Why not simply\
    \ write F a--> C?  Because the forward mapping is\n   divided by context.  Adding\
    \ a context makes the two forward variant\n   mappings distinct, and that needs\
    \ to be accounted for explicitly in\n   the reverse mappings so that human and\
    \ machine readers can easily\n   verify symmetry and transitivity of the variant\
    \ mappings in the LGR.\n   (This is true even though the two opposite contexts\
    \ of \"final\" and\n   \"!final\" should together cover all possible cases.)\n"
- title: 16.  Making Conditional Variants Well Behaved
  contents:
  - "16.  Making Conditional Variants Well Behaved\n   To ensure that LGR with contextual\
    \ variants is well behaved, it is\n   best to always use \"fully qualified\" variant\
    \ mappings that always\n   agree in the names of the context rules for forward\
    \ and reverse\n   mappings.  It is also necessary to ensure that no label can\
    \ match\n   more than one context for the same mapping.  Using mutually exclusive\n\
    \   contexts, such as \"final\" and \"!final\", is an easy way to ensure\n   that.\n\
    \   However, it is not always necessary to define dual or multiple\n   contexts\
    \ that together cover all possible cases.  For example, here\n   are two contexts\
    \ that do not cover all possible positional contexts:\n     final: C --> D\n \
    \    initial: C --> D.\n   A well-behaved LGR using these two contexts would define\
    \ all\n   symmetric and transitive mappings involving C, D, and their variants\n\
    \   consistently in terms of the two conditions \"final\" and \"initial\" and\n\
    \   ensure that both cannot be satisfied at the same time by some label.\n   In\
    \ addition to never defining the same mapping with two contexts that\n   may be\
    \ satisfied by the same label, a well-behaved LGR never combines\n   a variant\
    \ mapping with a context with the same variant mapping\n   without a context:\n\
    \     context: C --> D\n     C --> D\n   Inadvertent mixing of conditional and\
    \ unconditional variants can be\n   detected and flagged by a parser, but verifying\
    \ that two formally\n   distinct contexts are never satisfied by the same label\
    \ would depend\n   on the interaction between labels and context rules, which\
    \ means that\n   it will be up to the LGR designer to ensure that the LGR is well\n\
    \   behaved.\n   A well-behaved LGR never assigns conditions on a reflexive variant,\n\
    \   as that is effectively no different from having a context on the code\n  \
    \ point itself; the latter is preferred.\n   Finally, for symmetry to work as\
    \ expected, the context must be\n   defined such that it is satisfied for both\
    \ the original code point in\n   the context of the original label and for the\
    \ variant code point in\n   the variant label.  In other words, the context should\
    \ be \"stable\n   under variant substitution\" anywhere in the label.\n   Positional\
    \ contexts usually satisfy this last condition; for example,\n   a code point\
    \ that interrupts a cursive connection would likely share\n   this property with\
    \ any of its variants.  However, as it is possible\n   in principle to define\
    \ other kinds of contexts, it is necessary to\n   make sure that the LGR is well\
    \ behaved in this aspect at the time the\n   LGR is designed.\n   Due to the difficulty\
    \ in verifying these constraints mechanically, it\n   is essential that an LGR\
    \ designer document the reasons why the LGR\n   can be expected to meet them and\
    \ the details of the techniques used\n   to ensure that outcome.  This information\
    \ should be found in the\n   description element of the LGR.\n   In summary, conditional\
    \ contexts can be useful for some cases, but\n   additional care must be taken\
    \ to ensure that an LGR containing\n   conditional contexts is well behaved. \
    \ LGR designers would be well\n   advised to avoid using conditional contexts\
    \ and to prefer\n   unconditional rules whenever practical, even though it will\n\
    \   doubtlessly reduce the number of labels practically available.\n"
- title: 17.  Variants for Sequences
  contents:
  - "17.  Variants for Sequences\n   Variant mappings can be defined between sequences\
    \ or between a code\n   point and a sequence.  For example, one might define a\
    \ \"blocked\"\n   variant between the sequence \"rn\" and the code point \"m\"\
    \ because they\n   are practically indistinguishable in common UI fonts.\n   Such\
    \ variants are no different from variants defined between single\n   code points,\
    \ except if a sequence is defined such that there is a\n   code point or shorter\
    \ sequence that is a prefix (initial subsequence)\n   and both it and the remainder\
    \ are also part of the repertoire.  In\n   that case, it is possible to create\
    \ duplicate variants with\n   conflicting dispositions.\n   The following shows\
    \ such an example resulting in conflicting\n   reflexive variants:\n     A  a-->\
    \ C\n     AB  x--> CD\n   where AB is a sequence with an initial subsequence of\
    \ A.  For\n   example, B might be a combining code point used in sequence AB.\
    \  If B\n   only occurs in the sequence, there is no issue, but if B also occurs\n\
    \   by itself, for example:\n     B  a--> D\n   then a label \"AB\" might correspond\
    \ to either {A}{B}, that is, the two\n   code points, or {AB}, the sequence, where\
    \ the curly braces show the\n   sequence boundaries as they would be applied during\
    \ label validation\n   and variant mapping.\n   A label AB would then generate\
    \ the \"allocatable\" variant label {C}{D}\n   and the \"blocked\" variant label\
    \ {CD}, thus creating two variant\n   labels with conflicting dispositions.\n\
    \   For the example of a blocked variant between \"m\" and \"rn\" (and vice\n\
    \   versa), there is no issue as long as \"r\" and \"n\" do not have variant\n\
    \   mappings of their own, so that there cannot be multiple variant\n   labels\
    \ for the same input.  However, it is preferable to avoid\n   ambiguities altogether\
    \ where possible.\n   The easiest way to avoid an ambiguous segmentation into\
    \ sequences is\n   by never allowing both a sequence and all of its constituent\
    \ parts\n   simultaneously as independent parts of the repertoire, for example,\n\
    \   by not defining B by itself as a member of the repertoire.\n   Sequences are\
    \ often used for combining sequences that consist of a\n   base character B followed\
    \ by one or more combining marks C.  By\n   enumerating all sequences in which\
    \ a certain combining mark is\n   expected and by not listing the combining mark\
    \ by itself in the LGR,\n   the mark cannot occur outside of these specifically\
    \ enumerated\n   contexts.  In cases where enumeration is not possible or practicable,\n\
    \   other techniques can be used to prevent ambiguous segmentation, for\n   example,\
    \ a context rule on code points that disallows B preceding C\n   in any label\
    \ except as part of a predefined sequence or class of\n   sequences.  The details\
    \ of such techniques are outside the scope of\n   this document (see [RFC7940]\
    \ for information on context rules for\n   code points).\n"
- title: 18.  Corresponding XML Notation
  contents:
  - "18.  Corresponding XML Notation\n   The XML format defined in [RFC7940] corresponds\
    \ fairly directly to\n   the notation used for variant mappings in this document.\
    \  (There is\n   no notation in the RFC for variant type sets).  In an LGR document,\
    \ a\n   simple member of a repertoire that does not have any variants is\n   listed\
    \ as:\n   <char cp=\"nnnn\" />\n   where nnnn is the [UNICODE] code point value\
    \ in the standard\n   uppercase hexadecimal notation padded to at least 4 digits\
    \ and\n   without leading \"U+\".  For a code point sequence of length 2, the\
    \ XML\n   notation becomes:\n   <char cp=\"uuuu vvvvv\" />\n   Variant mappings\
    \ are defined by nesting <var> elements inside the\n   <char> element.  For example,\
    \ a variant relation of type \"blocked\"\n     C  x--> X\n   is expressed as\n\
    \     <char cp=\"nnnn\">\n       <var cp=\"mmmm\" type=\"blocked\" />\n     </char>\n\
    \   where \"x-->\" identifies a \"blocked\" type.  (Other types include\n   \"\
    a-->\" for \"allocatable\", for example.  Here, nnnn and mmmm are the\n   [UNICODE]\
    \ code point values for C and X, respectively.  Either C or X\n   could be a code\
    \ point sequence or a single code point.\n   A reflexive mapping is specified\
    \ the same way, except that it always\n   uses the same code point value for both\
    \ the <char> and <var> element,\n   for example:\n     X  r-o--> X\n   would correspond\
    \ to\n   <char cp=\"nnnn\"><var cp=\"nnnn\" type=\"out-of-repertoire-var\" /></char>\n\
    \   Multiple <var> elements may be nested inside a single <char> element,\n  \
    \ but their \"cp\" values must be distinct (unless attributes for context\n  \
    \ rules are present and the combination of \"cp\" value and context\n   attributes\
    \ are distinct).\n     <char cp=\"nnnn\">\n       <var cp=\"kkkk\" type=\"allocatable\"\
    \ />\n       <var cp=\"mmmm\" type=\"blocked\" />\n     </char>\n   A set of conditional\
    \ variants like\n     final: C  a--> K\n     !final: C  x--> K\n   would correspond\
    \ to\n     <var cp=\"kkkk\" when=\"final\" type=\"allocatable\" />\n     <var\
    \ cp=\"kkkk\" not-when=\"final\" type=\"blocked\" />\n   where the string \"final\"\
    \ references a name of a context rule.\n   Context rules are defined in [RFC7940];\
    \ they conceptually correspond\n   to regular expressions.  The details of how\
    \ to create and define\n   these rules are outside the scope of this document.\
    \  If the label\n   matches the context defined in the rule, the variant mapping\
    \ is valid\n   and takes part in further processing.  Otherwise, it is invalid\
    \ and\n   ignored.  Using the \"not-when\" attribute inverts the sense of the\n\
    \   match.  The two attributes are mutually exclusive.\n   A derivation of a variant\
    \ label disposition\n     if \"only-variants\" = \"s\" or \"b\" => allocatable\n\
    \   is expressed as\n     <action disp=\"allocatable\" only-variants= \"s b\"\
    \ />\n   Instead of using \"if\" and \"else if\", the <action> elements implicitly\n\
    \   form a cascade, where the first action triggered defines the\n   disposition\
    \ of the label.  The order of action elements is thus\n   significant.\n   For\
    \ the full specification of the XML format, see [RFC7940].\n"
- title: 19.  IANA Considerations
  contents:
  - "19.  IANA Considerations\n   This document does not require any IANA actions.\n"
- title: 20.  Security Considerations
  contents:
  - "20.  Security Considerations\n   As described in [RFC7940], variants may be used\
    \ as a tool to reduce\n   certain avenues of attack in security-relevant identifiers\
    \ by\n   allowing certain labels to be \"mutually exclusive or registered only\n\
    \   to the same user\".  However, if indiscriminately designed, variants\n   may\
    \ themselves contribute to risks to the security or usability of\n   the identifiers,\
    \ whether resulting from an ambiguous definition or\n   from allowing too many\
    \ allocatable variants per label.\n   The information in this document is intended\
    \ to allow the reader to\n   design a specification of an LGR that is \"well behaved\"\
    \ with respect\n   to variants; as used here, this term refers to an LGR that\
    \ is\n   predictable in its effects to the LGR author (and reviewer) and more\n\
    \   reliable in its implementation.\n   A well-behaved LGR is not merely one that\
    \ can be expressed in\n   [RFC7940], but, in addition, it actively avoids certain\
    \ edge cases\n   not prevented by the schema, such as those that would result\
    \ in\n   ambiguities in the specification of the intended disposition for some\n\
    \   variant labels.  By applying the additional considerations introduced\n  \
    \ in this document, including adding certain declarations that are\n   optional\
    \ under the schema and may not alter the results of processing\n   a label, such\
    \ an LGR becomes easier to review and its implementations\n   easier to verify.\n\
    \   It should be noted that variants are an important part, but only a\n   part,\
    \ of an LGR design.  There are many other features of an LGR that\n   this document\
    \ does not touch upon.  Also, the question of whether to\n   define variants at\
    \ all, or what labels are to be considered variants\n   of each other, is not\
    \ addressed here.\n"
- title: 21.  References
  contents:
  - '21.  References

    '
- title: 21.1.  Normative References
  contents:
  - "21.1.  Normative References\n   [RFC7940]  Davies, K. and A. Freytag, \"Representing\
    \ Label Generation\n              Rulesets Using XML\", RFC 7940, DOI 10.17487/RFC7940,\n\
    \              August 2016, <https://www.rfc-editor.org/info/rfc7940>.\n"
- title: 21.2.  Informative References
  contents:
  - "21.2.  Informative References\n   [RFC1034]  Mockapetris, P., \"Domain names\
    \ - concepts and facilities\",\n              STD 13, RFC 1034, DOI 10.17487/RFC1034,\
    \ November 1987,\n              <https://www.rfc-editor.org/info/rfc1034>.\n \
    \  [RFC1035]  Mockapetris, P., \"Domain names - implementation and\n         \
    \     specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035,\n             \
    \ November 1987, <https://www.rfc-editor.org/info/rfc1035>.\n   [RFC5890]  Klensin,\
    \ J., \"Internationalized Domain Names for\n              Applications (IDNA):\
    \ Definitions and Document Framework\",\n              RFC 5890, DOI 10.17487/RFC5890,\
    \ August 2010,\n              <https://www.rfc-editor.org/info/rfc5890>.\n   [RFC5891]\
    \  Klensin, J., \"Internationalized Domain Names in\n              Applications\
    \ (IDNA): Protocol\", RFC 5891,\n              DOI 10.17487/RFC5891, August 2010,\n\
    \              <https://www.rfc-editor.org/info/rfc5891>.\n   [RFC5892]  Faltstrom,\
    \ P., Ed., \"The Unicode Code Points and\n              Internationalized Domain\
    \ Names for Applications (IDNA)\",\n              RFC 5892, DOI 10.17487/RFC5892,\
    \ August 2010,\n              <https://www.rfc-editor.org/info/rfc5892>.\n   [RFC5893]\
    \  Alvestrand, H., Ed. and C. Karp, \"Right-to-Left Scripts\n              for\
    \ Internationalized Domain Names for Applications\n              (IDNA)\", RFC\
    \ 5893, DOI 10.17487/RFC5893, August 2010,\n              <https://www.rfc-editor.org/info/rfc5893>.\n\
    \   [RFC5894]  Klensin, J., \"Internationalized Domain Names for\n           \
    \   Applications (IDNA): Background, Explanation, and\n              Rationale\"\
    , RFC 5894, DOI 10.17487/RFC5894, August 2010,\n              <https://www.rfc-editor.org/info/rfc5894>.\n\
    \   [UNICODE]  The Unicode Consortium, \"The Unicode Standard\",\n           \
    \   <http://www.unicode.org/versions/latest/>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Contributions that have shaped this document have been provided\
    \ by\n   Marc Blanchet, Ben Campbell, Patrik Faltstrom, Scott Hollenbeck,\n  \
    \ Mirja Kuehlewind, Sarmad Hussain, John Klensin, Alexey Melnikov,\n   Nicholas\
    \ Ostler, Michel Suignard, Andrew Sullivan, Wil Tan, and\n   Suzanne Woolf.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Asmus Freytag\n   Email: asmus@unicode.org\n"
