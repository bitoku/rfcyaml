- title: __initial_text__
  contents:
  - '    The Resource Public Key Infrastructure (RPKI) to Router Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   In order to verifiably validate the origin Autonomous Systems of\
    \ BGP\n   announcements, routers need a simple but reliable mechanism to\n   receive\
    \ Resource Public Key Infrastructure (RFC 6480) prefix origin\n   data from a\
    \ trusted cache.  This document describes a protocol to\n   deliver validated\
    \ prefix origin data to routers.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6810.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Requirements Language  . . . . . . . . . . . . .\
    \ . . . . .  3\n   2.  Glossary . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  3\n   3.  Deployment Structure . . . . . . . . . . . . . . . . . .\
    \ . . .  4\n   4.  Operational Overview . . . . . . . . . . . . . . . . . . .\
    \ . .  4\n   5.  Protocol Data Units (PDUs) . . . . . . . . . . . . . . . . .\
    \ .  6\n     5.1.  Fields of a PDU  . . . . . . . . . . . . . . . . . . . . .\
    \  6\n     5.2.  Serial Notify  . . . . . . . . . . . . . . . . . . . . . .  8\n\
    \     5.3.  Serial Query . . . . . . . . . . . . . . . . . . . . . . .  8\n  \
    \   5.4.  Reset Query  . . . . . . . . . . . . . . . . . . . . . . .  9\n    \
    \ 5.5.  Cache Response . . . . . . . . . . . . . . . . . . . . . .  9\n     5.6.\
    \  IPv4 Prefix  . . . . . . . . . . . . . . . . . . . . . . . 10\n     5.7.  IPv6\
    \ Prefix  . . . . . . . . . . . . . . . . . . . . . . . 11\n     5.8.  End of\
    \ Data  . . . . . . . . . . . . . . . . . . . . . . . 12\n     5.9.  Cache Reset\
    \  . . . . . . . . . . . . . . . . . . . . . . . 12\n     5.10. Error Report .\
    \ . . . . . . . . . . . . . . . . . . . . . . 12\n   6.  Protocol Sequences .\
    \ . . . . . . . . . . . . . . . . . . . . . 14\n     6.1.  Start or Restart .\
    \ . . . . . . . . . . . . . . . . . . . . 14\n     6.2.  Typical Exchange . .\
    \ . . . . . . . . . . . . . . . . . . . 15\n     6.3.  No Incremental Update Available\
    \  . . . . . . . . . . . . . 15\n     6.4.  Cache Has No Data Available  . . .\
    \ . . . . . . . . . . . . 16\n   7.  Transport  . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 17\n     7.1.  SSH Transport  . . . . . . . . . . . .\
    \ . . . . . . . . . . 18\n     7.2.  TLS Transport  . . . . . . . . . . . . .\
    \ . . . . . . . . . 18\n     7.3.  TCP MD5 Transport  . . . . . . . . . . . .\
    \ . . . . . . . . 19\n     7.4.  TCP-AO Transport . . . . . . . . . . . . . .\
    \ . . . . . . . 19\n   8.  Router-Cache Setup . . . . . . . . . . . . . . . .\
    \ . . . . . . 20\n   9.  Deployment Scenarios . . . . . . . . . . . . . . . .\
    \ . . . . . 21\n   10. Error Codes  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 22\n   11. Security Considerations  . . . . . . . . . . . . . . . .\
    \ . . . 23\n   12. IANA Considerations  . . . . . . . . . . . . . . . . . . .\
    \ . . 24\n   13. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . .\
    \ . 25\n   14. References . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 25\n     14.1. Normative References . . . . . . . . . . . . . . . . . . . 25\n\
    \     14.2. Informative References . . . . . . . . . . . . . . . . . . 26\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In order to verifiably validate the origin Autonomous Systems\
    \ (ASes)\n   of BGP announcements, routers need a simple but reliable mechanism\
    \ to\n   receive Resource Public Key Infrastructure (RPKI) [RFC6480]\n   cryptographically\
    \ validated prefix origin data from a trusted cache.\n   This document describes\
    \ a protocol to deliver validated prefix origin\n   data to routers.  The design\
    \ is intentionally constrained to be\n   usable on much of the current generation\
    \ of ISP router platforms.\n   Section 3 describes the deployment structure, and\
    \ Section 4 then\n   presents an operational overview.  The binary payloads of\
    \ the\n   protocol are formally described in Section 5, and the expected PDU\n\
    \   sequences are described in Section 6.  The transport protocol options\n  \
    \ are described in Section 7.  Section 8 details how routers and caches\n   are\
    \ configured to connect and authenticate.  Section 9 describes\n   likely deployment\
    \ scenarios.  The traditional security and IANA\n   considerations end the document.\n\
    \   The protocol is extensible in order to support new PDUs with new\n   semantics,\
    \ if deployment experience indicates they are needed.  PDUs\n   are versioned\
    \ should deployment experience call for change.\n   For an implementation (not\
    \ interoperability) report, see [RTR-IMPL]\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119]\n   only when they appear in all upper case.  They may\
    \ also appear in\n   lower or mixed case as English words, without special meaning.\n"
- title: 2.  Glossary
  contents:
  - "2.  Glossary\n   The following terms are used with special meaning.\n   Global\
    \ RPKI:  The authoritative data of the RPKI are published in a\n      distributed\
    \ set of servers at the IANA, Regional Internet\n      Registries (RIRs), National\
    \ Internet Registry (NIRs), and ISPs;\n      see [RFC6481].\n   Cache:  A coalesced\
    \ copy of the RPKI, which is periodically fetched/\n      refreshed directly or\
    \ indirectly from the Global RPKI using the\n      [RFC5781] protocol/tools. \
    \ Relying party software is used to\n      gather and validate the distributed\
    \ data of the RPKI into a cache.\n      Trusting this cache further is a matter\
    \ between the provider of\n      the cache and a relying party.\n   Serial Number:\
    \  A 32-bit strictly increasing unsigned integer that\n      wraps from 2^32-1\
    \ to 0.  It denotes the logical version of a\n      cache.  A cache increments\
    \ the value when it successfully updates\n      its data from a parent cache or\
    \ from primary RPKI data.  As a\n      cache is receiving, new incoming data and\
    \ implicit deletes are\n      associated with the new serial but MUST NOT be sent\
    \ until the\n      fetch is complete.  A Serial Number is not commensurate between\n\
    \      caches, nor need it be maintained across resets of the cache\n      server.\
    \  See [RFC1982] on DNS Serial Number Arithmetic for too\n      much detail on\
    \ the topic.\n   Session ID:  When a cache server is started, it generates a session\n\
    \      identifier to uniquely identify the instance of the cache and to\n    \
    \  bind it to the sequence of Serial Numbers that cache instance will\n      generate.\
    \  This allows the router to restart a failed session\n      knowing that the\
    \ Serial Number it is using is commensurate with\n      that of the cache.\n"
- title: 3.  Deployment Structure
  contents:
  - "3.  Deployment Structure\n   Deployment of the RPKI to reach routers has a three-level\
    \ structure\n   as follows:\n   Global RPKI:  The authoritative data of the RPKI\
    \ are published in a\n      distributed set of servers, RPKI publication repositories,\
    \ e.g.,\n      the IANA, RIRs, NIRs, and ISPs, see [RFC6481].\n   Local Caches:\
    \  A local set of one or more collected and verified\n      caches.  A relying\
    \ party, e.g., router or other client, MUST have\n      a trust relationship with,\
    \ and a trusted transport channel to, any\n      authoritative cache(s) it uses.\n\
    \   Routers:  A router fetches data from a local cache using the protocol\n  \
    \    described in this document.  It is said to be a client of the\n      cache.\
    \  There MAY be mechanisms for the router to assure itself of\n      the authenticity\
    \ of the cache and to authenticate itself to the\n      cache.\n"
- title: 4.  Operational Overview
  contents:
  - "4.  Operational Overview\n   A router establishes and keeps open a connection\
    \ to one or more\n   caches with which it has client/server relationships.  It\
    \ is\n   configured with a semi-ordered list of caches, and establishes a\n  \
    \ connection to the most preferred cache, or set of caches, which\n   accept the\
    \ connections.\n   The router MUST choose the most preferred, by configuration,\
    \ cache or\n   set of caches so that the operator may control load on their caches\n\
    \   and the Global RPKI.\n   Periodically, the router sends to the cache the Serial\
    \ Number of the\n   highest numbered data it has received from that cache, i.e.,\
    \ the\n   router's current Serial Number.  When a router establishes a new\n \
    \  connection to a cache, or wishes to reset a current relationship, it\n   sends\
    \ a Reset Query.\n   The Cache responds with all data records that have Serial\
    \ Numbers\n   greater than that in the router's query.  This may be the null set,\n\
    \   in which case the End of Data PDU is still sent.  Note that 'greater'\n  \
    \ must take wrap-around into account, see [RFC1982].\n   When the router has received\
    \ all data records from the cache, it sets\n   its current Serial Number to that\
    \ of the Serial Number in the End of\n   Data PDU.\n   When the cache updates\
    \ its database, it sends a Notify message to\n   every currently connected router.\
    \  This is a hint that now would be a\n   good time for the router to poll for\
    \ an update, but is only a hint.\n   The protocol requires the router to poll\
    \ for updates periodically in\n   any case.\n   Strictly speaking, a router could\
    \ track a cache simply by asking for\n   a complete data set every time it updates,\
    \ but this would be very\n   inefficient.  The Serial Number based incremental\
    \ update mechanism\n   allows an efficient transfer of just the data records that\
    \ have\n   changed since last update.  As with any update protocol based on\n\
    \   incremental transfers, the router must be prepared to fall back to a\n   full\
    \ transfer if for any reason the cache is unable to provide the\n   necessary\
    \ incremental data.  Unlike some incremental transfer\n   protocols, this protocol\
    \ requires the router to make an explicit\n   request to start the fallback process;\
    \ this is deliberate, as the\n   cache has no way of knowing whether the router\
    \ has also established\n   sessions with other caches that may be able to provide\
    \ better\n   service.\n   As a cache server must evaluate certificates and ROAs\
    \ (Route Origin\n   Attestations; see [RFC6480]), which are time dependent, servers'\n\
    \   clocks MUST be correct to a tolerance of approximately an hour.\n"
- title: 5.  Protocol Data Units (PDUs)
  contents:
  - "5.  Protocol Data Units (PDUs)\n   The exchanges between the cache and the router\
    \ are sequences of\n   exchanges of the following PDUs according to the rules\
    \ described in\n   Section 6.\n   Fields with unspecified content MUST be zero\
    \ on transmission and MAY\n   be ignored on receipt.\n"
- title: 5.1.  Fields of a PDU
  contents:
  - "5.1.  Fields of a PDU\n   PDUs contain the following data elements:\n   Protocol\
    \ Version:  An eight-bit unsigned integer, currently 0,\n      denoting the version\
    \ of this protocol.\n   PDU Type:  An eight-bit unsigned integer, denoting the\
    \ type of the\n      PDU, e.g., IPv4 Prefix, etc.\n   Serial Number:  The Serial\
    \ Number of the RPKI Cache when this set of\n      PDUs was received from an upstream\
    \ cache server or gathered from\n      the Global RPKI.  A cache increments its\
    \ Serial Number when\n      completing a rigorously validated update from a parent\
    \ cache or\n      the Global RPKI.\n   Session ID:  When a cache server is started,\
    \ it generates a Session\n      ID to identify the instance of the cache and to\
    \ bind it to the\n      sequence of Serial Numbers that cache instance will generate.\n\
    \      This allows the router to restart a failed session knowing that\n     \
    \ the Serial Number it is using is commensurate with that of the\n      cache.\
    \  If, at any time, either the router or the cache finds the\n      value of the\
    \ session identifier is not the same as the other's,\n      they MUST completely\
    \ drop the session and the router MUST flush\n      all data learned from that\
    \ cache.\n      Should a cache erroneously reuse a Session ID so that a router\n\
    \      does not realize that the session has changed (old session ID and\n   \
    \   new session ID have same numeric value), the router may become\n      confused\
    \ as to the content of the cache.  The time it takes the\n      router to discover\
    \ it is confused will depend on whether the\n      Serial Numbers are also reused.\
    \  If the Serial Numbers in the old\n      and new sessions are different enough,\
    \ the cache will respond to\n      the router's Serial Query with a Cache Reset,\
    \ which will solve the\n      problem.  If, however, the Serial Numbers are close,\
    \ the cache may\n      respond with a Cache Response, which may not be enough\
    \ to bring\n      the router into sync.  In such cases, it's likely but not certain\n\
    \      that the router will detect some discrepancy between the state\n      that\
    \ the cache expects and its own state.  For example, the Cache\n      Response\
    \ may tell the router to drop a record that the router does\n      not hold, or\
    \ may tell the router to add a record that the router\n      already has.  In\
    \ such cases, a router will detect the error and\n      reset the session.  The\
    \ one case in which the router may stay out\n      of sync is when nothing in\
    \ the Cache Response contradicts any data\n      currently held by the router.\n\
    \      Using persistent storage for the session identifier or a clock-\n     \
    \ based scheme for generating session identifiers should avoid the\n      risk\
    \ of session identifier collisions.\n      The Session ID might be a pseudo-random\
    \ value, a strictly\n      increasing value if the cache has reliable storage,\
    \ etc.\n   Length:  A 32-bit unsigned integer that has as its value the count\
    \ of\n      the bytes in the entire PDU, including the eight bytes of header\n\
    \      that end with the length field.\n   Flags:  The lowest order bit of the\
    \ Flags field is 1 for an\n      announcement and 0 for a withdrawal, whether\
    \ this PDU announces a\n      new right to announce the prefix or withdraws a\
    \ previously\n      announced right.  A withdraw effectively deletes one previously\n\
    \      announced IPvX (IPv4 or IPv6) Prefix PDU with the exact same\n      Prefix,\
    \ Length, Max-Len, and Autonomous System Number (ASN).\n   Prefix Length:  An\
    \ 8-bit unsigned integer denoting the shortest\n      prefix allowed for the prefix.\n\
    \   Max Length:  An 8-bit unsigned integer denoting the longest prefix\n     \
    \ allowed by the prefix.  This MUST NOT be less than the Prefix\n      Length\
    \ element.\n   Prefix:  The IPv4 or IPv6 prefix of the ROA.\n   Autonomous System\
    \ Number:  ASN allowed to announce this prefix, a\n      32-bit unsigned integer.\n\
    \   Zero:  Fields shown as zero or reserved MUST be zero.  The value of\n    \
    \  such a field MUST be ignored on receipt.\n"
- title: 5.2.  Serial Notify
  contents:
  - "5.2.  Serial Notify\n   The cache notifies the router that the cache has new\
    \ data.\n   The Session ID reassures the router that the Serial Numbers are\n\
    \   commensurate, i.e., the cache session has not been changed.\n   Serial Notify\
    \ is the only message that the cache can send that is not\n   in response to a\
    \ message from the router.\n   0          8          16         24        31\n\
    \   .-------------------------------------------.\n   | Protocol |   PDU    |\
    \                     |\n   | Version  |   Type   |     Session ID      |\n  \
    \ |    0     |    0     |                     |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |                Length=12\
    \                  |\n   |                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |               Serial Number\
    \               |\n   |                                           |\n   `-------------------------------------------'\n"
- title: 5.3.  Serial Query
  contents:
  - "5.3.  Serial Query\n   Serial Query: The router sends Serial Query to ask the\
    \ cache for all\n   payload PDUs that have Serial Numbers higher than the Serial\
    \ Number\n   in the Serial Query.\n   The cache replies to this query with a Cache\
    \ Response PDU\n   (Section 5.5) if the cache has a, possibly null, record of\
    \ the\n   changes since the Serial Number specified by the router.  If there\n\
    \   have been no changes since the router last queried, the cache sends\n   an\
    \ End Of Data PDU.\n   If the cache does not have the data needed to update the\
    \ router,\n   perhaps because its records do not go back to the Serial Number\
    \ in\n   the Serial Query, then it responds with a Cache Reset PDU\n   (Section\
    \ 5.9).\n   The Session ID tells the cache what instance the router expects to\n\
    \   ensure that the Serial Numbers are commensurate, i.e., the cache\n   session\
    \ has not been changed.\n   0          8          16         24        31\n  \
    \ .-------------------------------------------.\n   | Protocol |   PDU    |  \
    \                   |\n   | Version  |   Type   |     Session ID      |\n   |\
    \    0     |    1     |                     |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |                 Length=12\
    \                 |\n   |                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |               Serial Number\
    \               |\n   |                                           |\n   `-------------------------------------------'\n"
- title: 5.4.  Reset Query
  contents:
  - "5.4.  Reset Query\n   Reset Query: The router tells the cache that it wants to\
    \ receive the\n   total active, current, non-withdrawn database.  The cache responds\n\
    \   with a Cache Response PDU (Section 5.5).\n   0          8          16    \
    \     24        31\n   .-------------------------------------------.\n   | Protocol\
    \ |   PDU    |                     |\n   | Version  |   Type   |    reserved =\
    \ zero  |\n   |    0     |    2     |                     |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |                 Length=8\
    \                  |\n   |                                           |\n   `-------------------------------------------'\n"
- title: 5.5.  Cache Response
  contents:
  - "5.5.  Cache Response\n   Cache Response: The cache responds with zero or more\
    \ payload PDUs.\n   When replying to a Serial Query request (Section 5.3), the\
    \ cache\n   sends the set of all data records it has with Serial Numbers greater\n\
    \   than that sent by the client router.  When replying to a Reset Query,\n  \
    \ the cache sends the set of all data records it has; in this case, the\n   withdraw/announce\
    \ field in the payload PDUs MUST have the value 1\n   (announce).\n   In response\
    \ to a Reset Query, the new value of the Session ID tells\n   the router the instance\
    \ of the cache session for future confirmation.\n   In response to a Serial Query,\
    \ the Session ID being the same\n   reassures the router that the Serial Numbers\
    \ are commensurate, i.e.,\n   the cache session has not changed.\n   0       \
    \   8          16         24        31\n   .-------------------------------------------.\n\
    \   | Protocol |   PDU    |                     |\n   | Version  |   Type   |\
    \     Session ID      |\n   |    0     |    3     |                     |\n  \
    \ +-------------------------------------------+\n   |                        \
    \                   |\n   |                 Length=8                  |\n   |\
    \                                           |\n   `-------------------------------------------'\n"
- title: 5.6.  IPv4 Prefix
  contents:
  - "5.6.  IPv4 Prefix\n   0          8          16         24        31\n   .-------------------------------------------.\n\
    \   | Protocol |   PDU    |                     |\n   | Version  |   Type   |\
    \    reserved = zero  |\n   |    0     |    4     |                     |\n  \
    \ +-------------------------------------------+\n   |                        \
    \                   |\n   |                 Length=20                 |\n   |\
    \                                           |\n   +-------------------------------------------+\n\
    \   |          |  Prefix  |   Max    |          |\n   |  Flags   |  Length  |\
    \  Length  |   zero   |\n   |          |   0..32  |   0..32  |          |\n  \
    \ +-------------------------------------------+\n   |                        \
    \                   |\n   |                IPv4 Prefix                |\n   |\
    \                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |         Autonomous System\
    \ Number          |\n   |                                           |\n   `-------------------------------------------'\n\
    \   The lowest order bit of the Flags field is 1 for an announcement and\n   0\
    \ for a withdrawal.\n   In the RPKI, nothing prevents a signing certificate from\
    \ issuing two\n   identical ROAs.  In this case, there would be no semantic difference\n\
    \   between the objects, merely a process redundancy.\n   In the RPKI, there is\
    \ also an actual need for what might appear to a\n   router as identical IPvX\
    \ PDUs.  This can occur when an upstream\n   certificate is being reissued or\
    \ there is an address ownership\n   transfer up the validation chain.  The ROA\
    \ would be identical in the\n   router sense, i.e., have the same {Prefix, Len,\
    \ Max-Len, ASN}, but a\n   different validation path in the RPKI.  This is important\
    \ to the\n   RPKI, but not to the router.\n   The cache server MUST ensure that\
    \ it has told the router client to\n   have one and only one IPvX PDU for a unique\
    \ {Prefix, Len, Max-Len,\n   ASN} at any one point in time.  Should the router\
    \ client receive an\n   IPvX PDU with a {Prefix, Len, Max-Len, ASN} identical\
    \ to one it\n   already has active, it SHOULD raise a Duplicate Announcement Received\n\
    \   error.\n"
- title: 5.7.  IPv6 Prefix
  contents:
  - "5.7.  IPv6 Prefix\n   0          8          16         24        31\n   .-------------------------------------------.\n\
    \   | Protocol |   PDU    |                     |\n   | Version  |   Type   |\
    \    reserved = zero  |\n   |    0     |    6     |                     |\n  \
    \ +-------------------------------------------+\n   |                        \
    \                   |\n   |                 Length=32                 |\n   |\
    \                                           |\n   +-------------------------------------------+\n\
    \   |          |  Prefix  |   Max    |          |\n   |  Flags   |  Length  |\
    \  Length  |   zero   |\n   |          |  0..128  |  0..128  |          |\n  \
    \ +-------------------------------------------+\n   |                        \
    \                   |\n   +---                                     ---+\n   |\
    \                                           |\n   +---            IPv6 Prefix\
    \              ---+\n   |                                           |\n   +---\
    \                                     ---+\n   |                             \
    \              |\n   +-------------------------------------------+\n   |     \
    \                                      |\n   |         Autonomous System Number\
    \          |\n   |                                           |\n   `-------------------------------------------'\n\
    \   Analogous to the IPv4 Prefix PDU, it has 96 more bits and no magic.\n"
- title: 5.8.  End of Data
  contents:
  - "5.8.  End of Data\n   End of Data: The cache tells the router it has no more\
    \ data for the\n   request.\n   The Session ID MUST be the same as that of the\
    \ corresponding Cache\n   Response that began the, possibly null, sequence of\
    \ data PDUs.\n   0          8          16         24        31\n   .-------------------------------------------.\n\
    \   | Protocol |   PDU    |                     |\n   | Version  |   Type   |\
    \     Session ID      |\n   |    0     |    7     |                     |\n  \
    \ +-------------------------------------------+\n   |                        \
    \                   |\n   |                 Length=12                 |\n   |\
    \                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |               Serial Number\
    \               |\n   |                                           |\n   `-------------------------------------------'\n"
- title: 5.9.  Cache Reset
  contents:
  - "5.9.  Cache Reset\n   The cache may respond to a Serial Query informing the router\
    \ that the\n   cache cannot provide an incremental update starting from the Serial\n\
    \   Number specified by the router.  The router must decide whether to\n   issue\
    \ a Reset Query or switch to a different cache.\n   0          8          16 \
    \        24        31\n   .-------------------------------------------.\n   |\
    \ Protocol |   PDU    |                     |\n   | Version  |   Type   |    reserved\
    \ = zero  |\n   |    0     |    8     |                     |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |                 Length=8\
    \                  |\n   |                                           |\n   `-------------------------------------------'\n"
- title: 5.10.  Error Report
  contents:
  - "5.10.  Error Report\n   This PDU is used by either party to report an error to\
    \ the other.\n   Error reports are only sent as responses to other PDUs.\n   The\
    \ Error Code is described in Section 10.\n   If the error is generic (e.g., \"\
    Internal Error\") and not associated\n   with the PDU to which it is responding,\
    \ the Erroneous PDU field MUST\n   be empty and the Length of Encapsulated PDU\
    \ field MUST be zero.\n   An Error Report PDU MUST NOT be sent for an Error Report\
    \ PDU.  If an\n   erroneous Error Report PDU is received, the session SHOULD be\n\
    \   dropped.\n   If the error is associated with a PDU of excessive length, i.e.,\
    \ too\n   long to be any legal PDU other than another Error Report, or a\n   possibly\
    \ corrupt length, the Erroneous PDU field MAY be truncated.\n   The diagnostic\
    \ text is optional; if not present, the Length of Error\n   Text field MUST be\
    \ zero.  If error text is present, it MUST be a\n   string in UTF-8 encoding (see\
    \ [RFC3269]).\n   0          8          16         24        31\n   .-------------------------------------------.\n\
    \   | Protocol |   PDU    |                     |\n   | Version  |   Type   |\
    \     Error Code      |\n   |    0     |    10    |                     |\n  \
    \ +-------------------------------------------+\n   |                        \
    \                   |\n   |                  Length                   |\n   |\
    \                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |       Length of Encapsulated\
    \ PDU          |\n   |                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   ~           Copy of Erroneous\
    \ PDU           ~\n   |                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |           Length of Error\
    \ Text            |\n   |                                           |\n   +-------------------------------------------+\n\
    \   |                                           |\n   |              Arbitrary\
    \ Text               |\n   |                    of                     |\n   ~\
    \          Error Diagnostic Message         ~\n   |                          \
    \                 |\n   `-------------------------------------------'\n"
- title: 6.  Protocol Sequences
  contents:
  - "6.  Protocol Sequences\n   The sequences of PDU transmissions fall into three\
    \ conversations as\n   follows:\n"
- title: 6.1.  Start or Restart
  contents:
  - "6.1.  Start or Restart\n   Cache                         Router\n     ~     \
    \                        ~\n     | <----- Reset Query -------- | R requests data\
    \ (or Serial Query)\n     |                             |\n     | ----- Cache\
    \ Response -----> | C confirms request\n     | ------- IPvX Prefix ------> | C\
    \ sends zero or more\n     | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix\n\
    \     | ------- IPvX Prefix ------> |   Payload PDUs\n     | ------  End of Data\
    \ ------> | C sends End of Data\n     |                             |   and sends\
    \ new serial\n     ~                             ~\n   When a transport session\
    \ is first established, the router MAY send a\n   Reset Query and the cache responds\
    \ with a data sequence of all data\n   it contains.\n   Alternatively, if the\
    \ router has significant unexpired data from a\n   broken session with the same\
    \ cache, it MAY start with a Serial Query\n   containing the Session ID from the\
    \ previous session to ensure the\n   Serial Numbers are commensurate.\n   This\
    \ Reset Query sequence is also used when the router receives a\n   Cache Reset,\
    \ chooses a new cache, or fears that it has otherwise lost\n   its way.\n   To\
    \ limit the length of time a cache must keep the data necessary to\n   generate\
    \ incremental updates, a router MUST send either a Serial\n   Query or a Reset\
    \ Query no less frequently than once an hour.  This\n   also acts as a keep-alive\
    \ at the application layer.\n   As the cache MAY not keep updates for little more\
    \ than one hour, the\n   router MUST have a polling interval of no greater than\
    \ once an hour.\n"
- title: 6.2.  Typical Exchange
  contents:
  - "6.2.  Typical Exchange\n   Cache                         Router\n     ~     \
    \                        ~\n     | -------- Notify ----------> |  (optional)\n\
    \     |                             |\n     | <----- Serial Query ------- | R\
    \ requests data\n     |                             |\n     | ----- Cache Response\
    \ -----> | C confirms request\n     | ------- IPvX Prefix ------> | C sends zero\
    \ or more\n     | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix\n     |\
    \ ------- IPvX Prefix ------> |   Payload PDUs\n     | ------  End of Data ------>\
    \ | C sends End of Data\n     |                             |   and sends new\
    \ serial\n     ~                             ~\n   The cache server SHOULD send\
    \ a notify PDU with its current Serial\n   Number when the cache's serial changes,\
    \ with the expectation that the\n   router MAY then issue a Serial Query earlier\
    \ than it otherwise might.\n   This is analogous to DNS NOTIFY in [RFC1996]. \
    \ The cache MUST rate\n   limit Serial Notifies to no more frequently than one\
    \ per minute.\n   When the transport layer is up and either a timer has gone off\
    \ in the\n   router, or the cache has sent a Notify, the router queries for new\n\
    \   data by sending a Serial Query, and the cache sends all data newer\n   than\
    \ the serial in the Serial Query.\n   To limit the length of time a cache must\
    \ keep old withdraws, a router\n   MUST send either a Serial Query or a Reset\
    \ Query no less frequently\n   than once an hour.\n"
- title: 6.3.  No Incremental Update Available
  contents:
  - "6.3.  No Incremental Update Available\n   Cache                         Router\n\
    \     ~                             ~\n     | <-----  Serial Query ------ | R\
    \ requests data\n     | ------- Cache Reset ------> | C cannot supply update\n\
    \     |                             |   from specified serial\n     | <------\
    \ Reset Query ------- | R requests new data\n     | ----- Cache Response ----->\
    \ | C confirms request\n     | ------- IPvX Prefix ------> | C sends zero or more\n\
    \     | ------- IPvX Prefix ------> |   IPv4 and IPv6 Prefix\n     | ------- IPvX\
    \ Prefix ------> |   Payload PDUs\n     | ------  End of Data ------> | C sends\
    \ End of Data\n     |                             |   and sends new serial\n \
    \    ~                             ~\n   The cache may respond to a Serial Query\
    \ with a Cache Reset, informing\n   the router that the cache cannot supply an\
    \ incremental update from\n   the Serial Number specified by the router.  This\
    \ might be because the\n   cache has lost state, or because the router has waited\
    \ too long\n   between polls and the cache has cleaned up old data that it no\
    \ longer\n   believes it needs, or because the cache has run out of storage space\n\
    \   and had to expire some old data early.  Regardless of how this state\n   arose,\
    \ the cache replies with a Cache Reset to tell the router that\n   it cannot honor\
    \ the request.  When a router receives this, the router\n   SHOULD attempt to\
    \ connect to any more preferred caches in its cache\n   list.  If there are no\
    \ more preferred caches, it MUST issue a Reset\n   Query and get an entire new\
    \ load from the cache.\n"
- title: 6.4.  Cache Has No Data Available
  contents:
  - "6.4.  Cache Has No Data Available\n   Cache                         Router\n\
    \     ~                             ~\n     | <-----  Serial Query ------ | R\
    \ requests data\n     | ---- Error Report PDU ----> | C No Data Available\n  \
    \   ~                             ~\n   Cache                         Router\n\
    \     ~                             ~\n     | <-----  Reset Query ------- | R\
    \ requests data\n     | ---- Error Report PDU ----> | C No Data Available\n  \
    \   ~                             ~\n   The cache may respond to either a Serial\
    \ Query or a Reset Query\n   informing the router that the cache cannot supply\
    \ any update at all.\n   The most likely cause is that the cache has lost state,\
    \ perhaps due\n   to a restart, and has not yet recovered.  While it is possible\
    \ that a\n   cache might go into such a state without dropping any of its active\n\
    \   sessions, a router is more likely to see this behavior when it\n   initially\
    \ connects and issues a Reset Query while the cache is still\n   rebuilding its\
    \ database.\n   When a router receives this kind of error, the router SHOULD attempt\n\
    \   to connect to any other caches in its cache list, in preference\n   order.\
    \  If no other caches are available, the router MUST issue\n   periodic Reset\
    \ Queries until it gets a new usable load from the\n   cache.\n"
- title: 7.  Transport
  contents:
  - "7.  Transport\n   The transport-layer session between a router and a cache carries\
    \ the\n   binary PDUs in a persistent session.\n   To prevent cache spoofing and\
    \ DoS attacks by illegitimate routers, it\n   is highly desirable that the router\
    \ and the cache be authenticated to\n   each other.  Integrity protection for\
    \ payloads is also desirable to\n   protect against monkey-in-the-middle (MITM)\
    \ attacks.  Unfortunately,\n   there is no protocol to do so on all currently\
    \ used platforms.\n   Therefore, as of the writing of this document, there is\
    \ no mandatory-\n   to-implement transport that provides authentication and integrity\n\
    \   protection.\n   To reduce exposure to dropped but non-terminated sessions,\
    \ both\n   caches and routers SHOULD enable keep-alives when available in the\n\
    \   chosen transport protocol.\n   It is expected that, when the TCP Authentication\
    \ Option (TCP-AO)\n   [RFC5925] is available on all platforms deployed by operators,\
    \ it\n   will become the mandatory-to-implement transport.\n   Caches and routers\
    \ MUST implement unprotected transport over TCP\n   using a port, rpki-rtr (323);\
    \ see Section 12.  Operators SHOULD use\n   procedural means, e.g., access control\
    \ lists (ACLs), to reduce the\n   exposure to authentication issues.\n   Caches\
    \ and routers SHOULD use TCP-AO, SSHv2, TCP MD5, or IPsec\n   transport.\n   If\
    \ unprotected TCP is the transport, the cache and routers MUST be on\n   the same\
    \ trusted and controlled network.\n   If available to the operator, caches and\
    \ routers MUST use one of the\n   following more protected protocols.\n   Caches\
    \ and routers SHOULD use TCP-AO transport [RFC5925] over the\n   rpki-rtr port.\n\
    \   Caches and routers MAY use SSHv2 transport [RFC4252] using a the\n   normal\
    \ SSH port.  For an example, see Section 7.1.\n   Caches and routers MAY use TCP\
    \ MD5 transport [RFC2385] using the\n   rpki-rtr port.  Note that TCP MD5 has\
    \ been obsoleted by TCP-AO\n   [RFC5925].\n   Caches and routers MAY use IPsec\
    \ transport [RFC4301] using the rpki-\n   rtr port.\n   Caches and routers MAY\
    \ use TLS transport [RFC5246] using a port,\n   rpki-rtr-tls (324); see Section\
    \ 12.\n"
- title: 7.1.  SSH Transport
  contents:
  - "7.1.  SSH Transport\n   To run over SSH, the client router first establishes\
    \ an SSH transport\n   connection using the SSHv2 transport protocol, and the\
    \ client and\n   server exchange keys for message integrity and encryption.  The\n\
    \   client then invokes the \"ssh-userauth\" service to authenticate the\n   application,\
    \ as described in the SSH authentication protocol\n   [RFC4252].  Once the application\
    \ has been successfully authenticated,\n   the client invokes the \"ssh-connection\"\
    \ service, also known as the\n   SSH connection protocol.\n   After the ssh-connection\
    \ service is established, the client opens a\n   channel of type \"session\",\
    \ which results in an SSH session.\n   Once the SSH session has been established,\
    \ the application invokes\n   the application transport as an SSH subsystem called\
    \ \"rpki-rtr\".\n   Subsystem support is a feature of SSH version 2 (SSHv2) and\
    \ is not\n   included in SSHv1.  Running this protocol as an SSH subsystem avoids\n\
    \   the need for the application to recognize shell prompts or skip over\n   extraneous\
    \ information, such as a system message that is sent at\n   shell start-up.\n\
    \   It is assumed that the router and cache have exchanged keys out of\n   band\
    \ by some reasonably secured means.\n   Cache servers supporting SSH transport\
    \ MUST accept RSA and Digital\n   Signature Algorithm (DSA) authentication and\
    \ SHOULD accept Elliptic\n   Curve Digital Signature Algorithm (ECDSA) authentication.\
    \  User\n   authentication MUST be supported; host authentication MAY be\n   supported.\
    \  Implementations MAY support password authentication.\n   Client routers SHOULD\
    \ verify the public key of the cache to avoid\n   monkey-in-the-middle attacks.\n"
- title: 7.2.  TLS Transport
  contents:
  - "7.2.  TLS Transport\n   Client routers using TLS transport MUST present client-side\n\
    \   certificates to authenticate themselves to the cache in order to\n   allow\
    \ the cache to manage the load by rejecting connections from\n   unauthorized\
    \ routers.  In principle, any type of certificate and\n   certificate authority\
    \ (CA) may be used; however, in general, cache\n   operators will wish to create\
    \ their own small-scale CA and issue\n   certificates to each authorized router.\
    \  This simplifies credential\n   rollover; any unrevoked, unexpired certificate\
    \ from the proper CA may\n   be used.\n   Certificates used to authenticate client\
    \ routers in this protocol\n   MUST include a subjectAltName extension [RFC5280]\
    \ containing one or\n   more iPAddress identities; when authenticating the router's\n\
    \   certificate, the cache MUST check the IP address of the TLS\n   connection\
    \ against these iPAddress identities and SHOULD reject the\n   connection if none\
    \ of the iPAddress identities match the connection.\n   Routers MUST also verify\
    \ the cache's TLS server certificate, using\n   subjectAltName dNSName identities\
    \ as described in [RFC6125], to avoid\n   monkey-in-the-middle attacks.  The rules\
    \ and guidelines defined in\n   [RFC6125] apply here, with the following considerations:\n\
    \      Support for DNS-ID identifier type (that is, the dNSName identity\n   \
    \   in the subjectAltName extension) is REQUIRED in rpki-rtr server\n      and\
    \ client implementations that use TLS.  Certification\n      authorities that\
    \ issue rpki-rtr server certificates MUST support\n      the DNS-ID identifier\
    \ type, and the DNS-ID identifier type MUST be\n      present in rpki-rtr server\
    \ certificates.\n      DNS names in rpki-rtr server certificates SHOULD NOT contain\
    \ the\n      wildcard character \"*\".\n      rpki-rtr implementations that use\
    \ TLS MUST NOT use CN-ID\n      identifiers; a CN field may be present in the\
    \ server certificate's\n      subject name, but MUST NOT be used for authentication\
    \ within the\n      rules described in [RFC6125].\n      The client router MUST\
    \ set its \"reference identifier\" to the DNS\n      name of the rpki-rtr cache.\n"
- title: 7.3.  TCP MD5 Transport
  contents:
  - "7.3.  TCP MD5 Transport\n   If TCP MD5 is used, implementations MUST support\
    \ key lengths of at\n   least 80 printable ASCII bytes, per Section 4.5 of [RFC2385].\n\
    \   Implementations MUST also support hexadecimal sequences of at least\n   32\
    \ characters, i.e., 128 bits.\n   Key rollover with TCP MD5 is problematic.  Cache\
    \ servers SHOULD\n   support [RFC4808].\n"
- title: 7.4.  TCP-AO Transport
  contents:
  - "7.4.  TCP-AO Transport\n   Implementations MUST support key lengths of at least\
    \ 80 printable\n   ASCII bytes.  Implementations MUST also support hexadecimal\
    \ sequences\n   of at least 32 characters, i.e., 128 bits.  MAC (Message\n   Authentication\
    \ Code) lengths of at least 96 bits MUST be supported,\n   per Section 5.1 of\
    \ [RFC5925].\n   The cryptographic algorithms and associated parameters described\
    \ in\n   [RFC5926] MUST be supported.\n"
- title: 8.  Router-Cache Setup
  contents:
  - "8.  Router-Cache Setup\n   A cache has the public authentication data for each\
    \ router it is\n   configured to support.\n   A router may be configured to peer\
    \ with a selection of caches, and a\n   cache may be configured to support a selection\
    \ of routers.  Each must\n   have the name of, and authentication data for, each\
    \ peer.  In\n   addition, in a router, this list has a non-unique preference value\n\
    \   for each server.  This preference merely denotes proximity, not\n   trust,\
    \ preferred belief, etc.  The client router attempts to\n   establish a session\
    \ with each potential serving cache in preference\n   order, and then starts to\
    \ load data from the most preferred cache to\n   which it can connect and authenticate.\
    \  The router's list of caches\n   has the following elements:\n   Preference:\
    \  An unsigned integer denoting the router's preference to\n      connect to that\
    \ cache; the lower the value, the more preferred.\n   Name:  The IP address or\
    \ fully qualified domain name of the cache.\n   Key:  Any needed public key of\
    \ the cache.\n   MyKey:  Any needed private key or certificate of this client.\n\
    \   Due to the distributed nature of the RPKI, caches simply cannot be\n   rigorously\
    \ synchronous.  A client may hold data from multiple caches\n   but MUST keep\
    \ the data marked as to source, as later updates MUST\n   affect the correct data.\n\
    \   Just as there may be more than one covering ROA from a single cache,\n   there\
    \ may be multiple covering ROAs from multiple caches.  The\n   results are as\
    \ described in [RFC6811].\n   If data from multiple caches are held, implementations\
    \ MUST NOT\n   distinguish between data sources when performing validation.\n\
    \   When a more preferred cache becomes available, if resources allow, it\n  \
    \ would be prudent for the client to start fetching from that cache.\n   The client\
    \ SHOULD attempt to maintain at least one set of data,\n   regardless of whether\
    \ it has chosen a different cache or established\n   a new connection to the previous\
    \ cache.\n   A client MAY drop the data from a particular cache when it is fully\n\
    \   in sync with one or more other caches.\n   A client SHOULD delete the data\
    \ from a cache when it has been unable\n   to refresh from that cache for a configurable\
    \ timer value.  The\n   default for that value is twice the polling period for\
    \ that cache.\n   If a client loses connectivity to a cache it is using, or otherwise\n\
    \   decides to switch to a new cache, it SHOULD retain the data from the\n   previous\
    \ cache until it has a full set of data from one or more other\n   caches.  Note\
    \ that this may already be true at the point of\n   connection loss if the client\
    \ has connections to more than one cache.\n"
- title: 9.  Deployment Scenarios
  contents:
  - "9.  Deployment Scenarios\n   For illustration, we present three likely deployment\
    \ scenarios.\n   Small End Site:  The small multihomed end site may wish to outsource\n\
    \      the RPKI cache to one or more of their upstream ISPs.  They would\n   \
    \   exchange authentication material with the ISP using some out-of-\n      band\
    \ mechanism, and their router(s) would connect to the cache(s)\n      of one or\
    \ more upstream ISPs.  The ISPs would likely deploy caches\n      intended for\
    \ customer use separately from the caches with which\n      their own BGP speakers\
    \ peer.\n   Large End Site:  A larger multihomed end site might run one or more\n\
    \      caches, arranging them in a hierarchy of client caches, each\n      fetching\
    \ from a serving cache that is closer to the Global RPKI.\n      They might configure\
    \ fall-back peerings to upstream ISP caches.\n   ISP Backbone:  A large ISP would\
    \ likely have one or more redundant\n      caches in each major point of presence\
    \ (PoP), and these caches\n      would fetch from each other in an ISP-dependent\
    \ topology so as not\n      to place undue load on the Global RPKI.\n   Experience\
    \ with large DNS cache deployments has shown that complex\n   topologies are ill-advised\
    \ as it is easy to make errors in the graph,\n   e.g., not maintain a loop-free\
    \ condition.\n   Of course, these are illustrations and there are other possible\n\
    \   deployment strategies.  It is expected that minimizing load on the\n   Global\
    \ RPKI servers will be a major consideration.\n   To keep load on Global RPKI\
    \ services from unnecessary peaks, it is\n   recommended that primary caches that\
    \ load from the distributed Global\n   RPKI not do so all at the same times, e.g.,\
    \ on the hour.  Choose a\n   random time, perhaps the ISP's AS number modulo 60\
    \ and jitter the\n   inter-fetch timing.\n"
- title: 10.  Error Codes
  contents:
  - "10.  Error Codes\n   This section contains a preliminary list of error codes.\
    \  The authors\n   expect additions to the list this section during development\
    \ of the\n   initial implementations.  There is an IANA registry where valid error\n\
    \   codes are listed; see Section 12.  Errors that are considered fatal\n   SHOULD\
    \ cause the session to be dropped.\n   0: Corrupt Data (fatal):  The receiver\
    \ believes the received PDU to\n      be corrupt in a manner not specified by\
    \ other error codes.\n   1: Internal Error (fatal):  The party reporting the error\
    \ experienced\n      some kind of internal error unrelated to protocol operation\
    \ (ran\n      out of memory, a coding assertion failed, et cetera).\n   2: No\
    \ Data Available:  The cache believes itself to be in good\n      working order,\
    \ but is unable to answer either a Serial Query or a\n      Reset Query because\
    \ it has no useful data available at this time.\n      This is likely to be a\
    \ temporary error, and most likely indicates\n      that the cache has not yet\
    \ completed pulling down an initial\n      current data set from the Global RPKI\
    \ system after some kind of\n      event that invalidated whatever data it might\
    \ have previously held\n      (reboot, network partition, et cetera).\n   3: Invalid\
    \ Request (fatal):  The cache server believes the client's\n      request to be\
    \ invalid.\n   4: Unsupported Protocol Version (fatal):  The Protocol Version\
    \ is not\n      known by the receiver of the PDU.\n   5: Unsupported PDU Type\
    \ (fatal):  The PDU Type is not known by the\n      receiver of the PDU.\n   6:\
    \ Withdrawal of Unknown Record (fatal):  The received PDU has Flag=0\n      but\
    \ a record for the {Prefix, Len, Max-Len, ASN} tuple does not\n      exist in\
    \ the receiver's database.\n   7: Duplicate Announcement Received (fatal):  The\
    \ received PDU has an\n      identical {Prefix, Len, Max-Len, ASN} tuple as a\
    \ PDU that is still\n      active in the router.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   As this document describes a security protocol,\
    \ many aspects of\n   security interest are described in the relevant sections.\
    \  This\n   section points out issues that may not be obvious in other sections.\n\
    \   Cache Validation:  In order for a collection of caches as described\n    \
    \  in Section 9 to guarantee a consistent view, they need to be given\n      consistent\
    \ trust anchors to use in their internal validation\n      process.  Distribution\
    \ of a consistent trust anchor is assumed to\n      be out of band.\n   Cache\
    \ Peer Identification:  The router initiates a transport session\n      to a cache,\
    \ which it identifies by either IP address or fully\n      qualified domain name.\
    \  Be aware that a DNS or address spoofing\n      attack could make the correct\
    \ cache unreachable.  No session would\n      be established, as the authorization\
    \ keys would not match.\n   Transport Security:  The RPKI relies on object, not\
    \ server or\n      transport, trust.  That is, the IANA root trust anchor is\n\
    \      distributed to all caches through some out-of-band means, and can\n   \
    \   then be used by each cache to validate certificates and ROAs all\n      the\
    \ way down the tree.  The inter-cache relationships are based on\n      this object\
    \ security model; hence, the inter-cache transport can\n      be lightly protected.\n\
    \      But, this protocol document assumes that the routers cannot do the\n  \
    \    validation cryptography.  Hence, the last link, from cache to\n      router,\
    \ is secured by server authentication and transport-level\n      security.  This\
    \ is dangerous, as server authentication and\n      transport have very different\
    \ threat models than object security.\n      So, the strength of the trust relationship\
    \ and the transport\n      between the router(s) and the cache(s) are critical.\
    \  You're\n      betting your routing on this.\n      While we cannot say the\
    \ cache must be on the same LAN, if only due\n      to the issue of an enterprise\
    \ wanting to off-load the cache task\n      to their upstream ISP(s), locality,\
    \ trust, and control are very\n      critical issues here.  The cache(s) really\
    \ SHOULD be as close, in\n      the sense of controlled and protected (against\
    \ DDoS, MITM)\n      transport, to the router(s) as possible.  It also SHOULD\
    \ be\n      topologically close so that a minimum of validated routing data\n\
    \      are needed to bootstrap a router's access to a cache.\n      The identity\
    \ of the cache server SHOULD be verified and\n      authenticated by the router\
    \ client, and vice versa, before any\n      data are exchanged.\n      Transports\
    \ that cannot provide the necessary authentication and\n      integrity (see Section\
    \ 7) must rely on network design and\n      operational controls to provide protection\
    \ against spoofing/\n      corruption attacks.  As pointed out in Section 7, TCP-AO\
    \ is the\n      long-term plan.  Protocols that provide integrity and authenticity\n\
    \      SHOULD be used, and if they cannot, i.e., TCP is used as the\n      transport,\
    \ the router and cache MUST be on the same trusted,\n      controlled network.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   IANA has assigned 'well-known' TCP Port Numbers\
    \ to the RPKI-Router\n   Protocol for the following, see Section 7:\n        \
    \   rpki-rtr\n           rpki-rtr-tls\n   IANA has created a registry for tuples\
    \ of Protocol Version / PDU\n   Type, each of which may range from 0 to 255. \
    \ The name of the\n   registry is \"rpki-rtr-pdu\".  The policy for adding to\
    \ the registry is\n   RFC Required per [RFC5226], either Standards Track or Experimental.\n\
    \   The initial entries are as follows:\n           Protocol   PDU\n         \
    \  Version    Type  Description\n           --------   ----  ---------------\n\
    \               0        0   Serial Notify\n               0        1   Serial\
    \ Query\n               0        2   Reset Query\n               0        3  \
    \ Cache Response\n               0        4   IPv4 Prefix\n               0  \
    \      6   IPv6 Prefix\n               0        7   End of Data\n            \
    \   0        8   Cache Reset\n               0       10   Error Report\n     \
    \          0      255   Reserved\n   IANA has created a registry for Error Codes\
    \ 0 to 255.  The name of\n   the registry is \"rpki-rtr-error\".  The policy for\
    \ adding to the\n   registry is Expert Review per [RFC5226], where the responsible\
    \ IESG\n   Area Director should appoint the Expert Reviewer.  The initial\n  \
    \ entries should be as follows:\n           Error\n           Code    Description\n\
    \           -----   ----------------\n               0   Corrupt Data\n      \
    \         1   Internal Error\n               2   No Data Available\n         \
    \      3   Invalid Request\n               4   Unsupported Protocol Version\n\
    \               5   Unsupported PDU Type\n               6   Withdrawal of Unknown\
    \ Record\n               7   Duplicate Announcement Received\n             255\
    \   Reserved\n   IANA has added an SSH Connection Protocol Subsystem Name, as\
    \ defined\n   in [RFC4250], of 'rpki-rtr'.\n"
- title: 13.  Acknowledgments
  contents:
  - "13.  Acknowledgments\n   The authors wish to thank Steve Bellovin, Rex Fernando,\
    \ Paul Hoffman,\n   Russ Housley, Pradosh Mohapatra, Keyur Patel, Sandy Murphy,\
    \ Robert\n   Raszuk, John Scudder, Ruediger Volk, and David Ward.  Particular\n\
    \   thanks go to Hannes Gredler for showing us the dangers of unnecessary\n  \
    \ fields.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC1982]   Elz, R. and R. Bush, \"Serial Number\
    \ Arithmetic\",\n               RFC 1982, August 1996.\n   [RFC2119]   Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n               Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC2385]   Heffernan, A., \"Protection of\
    \ BGP Sessions via the TCP\n               MD5 Signature Option\", RFC 2385, August\
    \ 1998.\n   [RFC3269]   Kermode, R. and L. Vicisano, \"Author Guidelines for\n\
    \               Reliable Multicast Transport (RMT) Building Blocks and\n     \
    \          Protocol Instantiation documents\", RFC 3269, April 2002.\n   [RFC4250]\
    \   Lehtinen, S. and C. Lonvick, \"The Secure Shell (SSH)\n               Protocol\
    \ Assigned Numbers\", RFC 4250, January 2006.\n   [RFC4252]   Ylonen, T. and C.\
    \ Lonvick, \"The Secure Shell (SSH)\n               Authentication Protocol\"\
    , RFC 4252, January 2006.\n   [RFC4301]   Kent, S. and K. Seo, \"Security Architecture\
    \ for the\n               Internet Protocol\", RFC 4301, December 2005.\n   [RFC5226]\
    \   Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              \
    \ IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n               May\
    \ 2008.\n   [RFC5246]   Dierks, T. and E. Rescorla, \"The Transport Layer Security\n\
    \               (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n   [RFC5280]\
    \   Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n               Housley,\
    \ R., and W. Polk, \"Internet X.509 Public Key\n               Infrastructure\
    \ Certificate and Certificate Revocation\n               List (CRL) Profile\"\
    , RFC 5280, May 2008.\n   [RFC5925]   Touch, J., Mankin, A., and R. Bonica, \"\
    The TCP\n               Authentication Option\", RFC 5925, June 2010.\n   [RFC5926]\
    \   Lebovitz, G. and E. Rescorla, \"Cryptographic Algorithms\n               for\
    \ the TCP Authentication Option (TCP-AO)\", RFC 5926,\n               June 2010.\n\
    \   [RFC6125]   Saint-Andre, P. and J. Hodges, \"Representation and\n        \
    \       Verification of Domain-Based Application Service Identity\n          \
    \     within Internet Public Key Infrastructure Using X.509\n               (PKIX)\
    \ Certificates in the Context of Transport Layer\n               Security (TLS)\"\
    , RFC 6125, March 2011.\n   [RFC6811]   Mohapatra, P., Scudder, J., Ward, D.,\
    \ Bush, R., and R.\n               Austein, \"BGP Prefix Origin Validation\",\
    \ RFC 6811,\n               January 2013.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [RFC1996]   Vixie, P., \"A Mechanism for Prompt\
    \ Notification of Zone\n               Changes (DNS NOTIFY)\", RFC 1996, August\
    \ 1996.\n   [RFC4808]   Bellovin, S., \"Key Change Strategies for TCP-MD5\",\n\
    \               RFC 4808, March 2007.\n   [RFC5781]   Weiler, S., Ward, D., and\
    \ R. Housley, \"The rsync URI\n               Scheme\", RFC 5781, February 2010.\n\
    \   [RFC6480]   Lepinski, M. and S. Kent, \"An Infrastructure to Support\n   \
    \            Secure Internet Routing\", RFC 6480, February 2012.\n   [RFC6481]\
    \   Huston, G., Loomans, R., and G. Michaelson, \"A Profile\n               for\
    \ Resource Certificate Repository Structure\", RFC 6481,\n               February\
    \ 2012.\n   [RTR-IMPL]  Bush, R., Austein, R., Patel, K., Gredler, H., and M.\n\
    \               Waehlisch, \"RPKI Router Implementation Report\", Work\n     \
    \          in Progress, January 2012.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Randy Bush\n   Internet Initiative Japan\n   5147 Crystal\
    \ Springs\n   Bainbridge Island, WA  98110\n   US\n   EMail: randy@psg.com\n \
    \  Rob Austein\n   Dragon Research Labs\n   EMail: sra@hactrn.net\n"
