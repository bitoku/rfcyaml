- title: __initial_text__
  contents:
  - "       Enhanced Compressed RTP (CRTP) for Links with High Delay,\n          \
    \            Packet Loss and Reordering\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a header compression scheme for point to\n\
    \   point links with packet loss and long delays.  It is based on\n   Compressed\
    \ Real-time Transport Protocol (CRTP), the IP/UDP/RTP header\n   compression described\
    \ in RFC 2508.  CRTP does not perform well on\n   such links: packet loss results\
    \ in context corruption and due to the\n   long delay, many more packets are discarded\
    \ before the context is\n   repaired.  To correct the behavior of CRTP over such\
    \ links, a few\n   extensions to the protocol are specified here.  The extensions\
    \ aim to\n   reduce context corruption by changing the way the compressor updates\n\
    \   the context at the decompressor: updates are repeated and include\n   updates\
    \ to full and differential context parameters.  With these\n   extensions, CRTP\
    \ performs well over links with packet loss, packet\n   reordering and long delays.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction .................................................\
    \  2\n       1.1.  CRTP Operation .........................................  4\n\
    \       1.2.  How do contexts get corrupted? .........................  4\n  \
    \     1.3.  Preventing context corruption ..........................  5\n    \
    \   1.4.  Specification of Requirements ..........................  5\n   2. \
    \ Enhanced CRTP ................................................  5\n       2.1.\
    \  Extended COMPRESSED_UDP packet .........................  6\n       2.2.  CRTP\
    \ Headers Checksum .................................. 11\n       2.3.  Achieving\
    \ robust operation ............................. 13\n             2.3.1.  Examples\
    \ ....................................... 15\n   3.  Negotiating usage of enhanced-CRTP\
    \ ........................... 18\n   4.  Security Considerations ......................................\
    \ 18\n   5.  Acknowledgements ............................................. 19\n\
    \   6.  References ................................................... 19\n  \
    \     6.1.  Normative References ................................... 19\n    \
    \   6.2.  Informative References ................................. 20\n   7. \
    \ Intellectual Property Rights Notice .......................... 20\n   8.  Authors'\
    \ Addresses ........................................... 21\n   9.  Full Copyright\
    \ Statement ..................................... 22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   RTP header compression (CRTP) as described in RFC 2508 was\
    \ designed\n   to reduce the header overhead of IP/UDP/RTP datagrams by compressing\n\
    \   the three headers.  The IP/UDP/RTP headers are compressed to 2-4\n   bytes\
    \ most of the time.\n   CRTP was designed for reliable point to point links with\
    \ short\n   delays.  It does not perform well over links with high rate of packet\n\
    \   loss, packet reordering and long delays.\n   An example of such a link is\
    \ a PPP session that is tunneled using an\n   IP level tunneling protocol such\
    \ as L2TP.  Packets within the tunnel\n   are carried by an IP network and hence\
    \ may get lost and reordered.\n   The longer the tunnel, the longer the round\
    \ trip time.\n   Another example is an IP network that uses layer 2 technologies\
    \ such\n   as ATM and Frame Relay for the access portion of the network.  Layer\n\
    \   2 transport networks such as ATM and Frame Relay behave like point to\n  \
    \ point serial links in that they do not reorder packets.  In addition,\n   Frame\
    \ Relay and ATM virtual circuits used as IP access technologies\n   often have\
    \ a low bit rate associated with them.  These virtual\n   circuits differ from\
    \ low speed serial links in that they may span a\n   larger physical distance\
    \ than a point to point serial link. Speed of\n   light delays within the layer\
    \ 2 transport network will result in\n   higher round trip delays between the\
    \ endpoints of the circuit.  In\n   addition, congestion within the layer 2 transport\
    \ network may result\n   in an effective drop rate for the virtual circuit which\
    \ is\n   significantly higher than error rates typically experienced on point\n\
    \   to point serial links.\n   It may be desirable to extend existing CRTP implementations\
    \ for use\n   also over IP tunnels and other virtual circuits, where packet losses,\n\
    \   reordering, and long delays are common characteristics.  To address\n   these\
    \ scenarios, this document defines modifications and extensions\n   to CRTP to\
    \ increase robustness to both packet loss and misordering\n   between the compressor\
    \ and the decompressor.  This is achieved by\n   repeating updates and allowing\
    \ the sending of absolute (uncompressed)\n   values in addition to delta values\
    \ for selected context parameters.\n   Although these new mechanisms impose some\
    \ additional overhead, the\n   overall compression is still substantial. The enhanced\
    \ CRTP, as\n   defined in this document, is thus suitable for many applications\
    \ in\n   the scenarios discussed above, e.g., tunneling and other virtual\n  \
    \ circuits.\n   RFC 3095 defines another RTP header compression scheme called\
    \ Robust\n   Header Compression [ROHC].  ROHC was developed with wireless links\
    \ as\n   the main target, and introduced new compression mechanisms with the\n\
    \   primary objective to achieve the combination of robustness against\n   packet\
    \ loss and maximal compression efficiency.  ROHC is expected to\n   be the preferred\
    \ compression mechanism over links where compression\n   efficiency is important.\
    \  However, ROHC was designed with the same\n   link assumptions as CRTP, e.g.,\
    \ that the compression scheme should\n   not have to tolerate misordering of compressed\
    \ packets between the\n   compressor and decompressor, which may occur when packets\
    \ are carried\n   in an IP tunnel across multiple hops.\n   At some time in the\
    \ future, enhancements may be defined for ROHC to\n   allow it to perform well\
    \ in the presence of misordering of compressed\n   packets.  The result might\
    \ be more efficient than the compression\n   protocol specified in this document.\
    \  However, there are many\n   environments for which the enhanced CRTP defined\
    \ here may be the\n   preferred choice.  In particular, for those environments\
    \ where CRTP\n   is already implemented, the additional effort required to implement\n\
    \   the extensions defined here is expected to be small. There are also\n   cases\
    \ where the implementation simplicity of this enhanced CRTP\n   relative to ROHC\
    \ is more important than the performance advantages of\n   ROHC.\n"
- title: 1.1.  CRTP Operation
  contents:
  - "1.1.  CRTP Operation\n   During compression of an RTP stream, a session context\
    \ is defined.\n   For each context, the session state is established and shared\
    \ between\n   the compressor and the decompressor.  Once the context state is\n\
    \   established, compressed packets may be sent.\n   The context state consists\
    \ of the full IP/UDP/RTP headers, a few\n   first order differential values, a\
    \ link sequence number, a generation\n   number and a delta encoding table.\n\
    \   The headers part of the context is set by the FULL_HEADER packet that\n  \
    \ always starts a compression session.  The first order differential\n   values\
    \ (delta values) are set by sending COMPRESSED_RTP packets that\n   include updates\
    \ to the delta values.\n   The context state must be synchronized between compressor\
    \ and\n   decompressor for successful decompression to take place.  If the\n \
    \  context gets out of sync, the decompressor is not able to restore the\n   compressed\
    \ headers accurately.  The decompressor invalidates the\n   context and sends\
    \ a CONTEXT_STATE packet to the compressor indicating\n   that the context has\
    \ been corrupted.  To resume compression, the\n   compressor must re-establish\
    \ the context.\n   During the time the context is corrupted, the decompressor\
    \ discards\n   all the packets received for that context.  Since the context repair\n\
    \   mechanism in CRTP involves feedback from the decompressor, context\n   repair\
    \ takes at least as much time as the round trip time of the\n   link.  If the\
    \ round trip time of the link is long, and especially if\n   the link bandwidth\
    \ is high, many packets will be discarded before the\n   context is repaired.\
    \  On such links it is desirable to minimize\n   context invalidation.\n"
- title: 1.2.  How do contexts get corrupted?
  contents:
  - "1.2.  How do contexts get corrupted?\n   As long as the fields in the combined\
    \ IP/UDP/RTP headers change as\n   expected for the sequence of packets in a session,\
    \ those headers can\n   be compressed, and the decompressor can fully restore\
    \ the compressed\n   headers using the context state.  When the headers don't\
    \ change as\n   expected it's necessary to update some of the full or the delta\n\
    \   values of the context.  For example, the RTP timestamp is expected to\n  \
    \ increment by delta RTP timestamp (dT).  If silence suppression is\n   used,\
    \ packets are not sent during silence periods.  Then when voice\n   activity resumes,\
    \ packets are sent again, but the RTP timestamp is\n   incremented by a large\
    \ value and not by dT.  In this case an update\n   must be sent.\n   If a packet\
    \ that includes an update to some context state values is\n   lost, the state\
    \ at the decompressor is not updated.  The shared state\n   is now different at\
    \ the compressor and decompressor.  When the next\n   packet arrives at the decompressor,\
    \ the decompressor will fail to\n   restore the compressed headers accurately\
    \ since the context state at\n   the decompressor is different than the state\
    \ at the compressor.\n"
- title: 1.3.  Preventing context corruption
  contents:
  - "1.3.  Preventing context corruption\n   Note that the decompressor fails not\
    \ when a packet is lost, but when\n   the next compressed packet arrives.  If\
    \ the next packet happens to\n   include the same context update as in the lost\
    \ packet, the context at\n   the decompressor may be updated successfully and\
    \ decompression may\n   continue uninterrupted.  If the lost packet included an\
    \ update to a\n   delta field such as the delta RTP timestamp (dT), the next packet\n\
    \   can't compensate for the loss since the update of a delta value is\n   relative\
    \ to the previous packet which was lost.  But if the update is\n   for an absolute\
    \ value such as the full RTP timestamp or the RTP\n   payload type, this update\
    \ can be repeated in the next packet\n   independently of the lost packet.  Hence\
    \ it is useful to be able to\n   update the absolute values of the context.\n\
    \   The next chapter describes several extensions to CRTP that add the\n   capability\
    \ to selectively update absolute values of the context,\n   rather than sending\
    \ a FULL_HEADER packet, in addition to the existing\n   updates of the delta values.\
    \  This enhanced version of CRTP is\n   intended to minimize context invalidation\
    \ and thus improve the\n   performance over lossy links with a long round trip\
    \ time.\n"
- title: 1.4.  Specification of Requirements
  contents:
  - "1.4.  Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Enhanced CRTP
  contents:
  - "2.  Enhanced CRTP\n   This chapter specifies the changes in this enhanced version\
    \ of CRTP.\n   They are:\n   -  Extensions to the COMPRESSED_UDP packet to allow\
    \ updating the\n      differential RTP values in the decompressor context and\
    \ to\n      selectively update the absolute IPv4 ID and the following RTP\n  \
    \    values: sequence number, timestamp, payload type, CSRC count and\n      CSRC\
    \ list.  This allows context sync to be maintained even with\n      some packet\
    \ loss.\n   -  A \"headers checksum\" to be inserted by the compressor and removed\n\
    \      by the decompressor when the UDP checksum is not present so that\n    \
    \  validation of the decompressed headers is still possible.  This\n      allows\
    \ the decompressor to verify that context sync has not been\n      lost after\
    \ a packet loss.\n   An algorithm is then described to use these changes with\
    \ repeated\n   updates to achieve robust operation over links with packet loss\
    \ and\n   long delay.\n"
- title: 2.1.  Extended COMPRESSED_UDP packet
  contents:
  - "2.1.  Extended COMPRESSED_UDP packet\n   It is possible to accommodate some packet\
    \ loss between the compressor\n   and decompressor using the \"twice\" algorithm\
    \ in RFC 2508 so long as\n   the context remains in sync.  In that algorithm,\
    \ the delta values are\n   added to the previous context twice (or more) to effect\
    \ the change\n   that would have occurred if the missing packets had arrived.\
    \  The\n   result is verified with the UDP checksum.  Keeping the context in\n\
    \   sync requires reliably communicating both the absolute value and the\n   delta\
    \ value whenever the delta value changes.  For many environments,\n   sufficient\
    \ reliability can be achieved by repeating the update with\n   each of several\
    \ successive packets.\n   The COMPRESSED_UDP packet satisfies the need to communicate\
    \ the\n   absolute values of the differential RTP fields, but it is specified\n\
    \   in RFC 2508 to reset the delta RTP timestamp.  That limitation can be\n  \
    \ removed with the following simple change: RFC 2508 describes the\n   format\
    \ of COMPRESSED_UDP as being the same as COMPRESSED_RTP except\n   that the M,\
    \ S and T bits are always 0 and the corresponding delta\n   fields are never included.\
    \  This enhanced version of CRTP changes\n   that specification to say that the\
    \ T bit MAY be nonzero to indicate\n   that the delta RTP timestamp is included\
    \ explicitly rather than being\n   reset to zero.\n   A second change adds another\
    \ byte of flag bits to the COMPRESSED_UDP\n   packet to allow only selected individual\
    \ uncompressed fields of the\n   RTP header to be included in the packet rather\
    \ than carrying the full\n   RTP header as part of the UDP data.  The additional\
    \ flags do increase\n   computational complexity somewhat, but the corresponding\
    \ increase in\n   bit efficiency is important when the differential field updates\
    \ are\n   communicated multiple times in successive COMPRESSED_UDP packets.\n\
    \   With this change, there are flag bits to indicate inclusion of both\n   delta\
    \ values and absolute values, so the flag nomenclature is\n   changed.  The original\
    \ S, T, I bits which indicate the inclusion of\n   deltas are renamed dS, dT,\
    \ dI, and the inclusion of absolute values\n   is indicated by S, T, I.  The M\
    \ bit is absolute as before.  A new\n   flag P indicates inclusion of the absolute\
    \ RTP payload type value and\n   another flag C indicates the inclusion of the\
    \ CSRC count.  When C=1,\n   an additional byte is added following the two flag\
    \ bytes to include\n   the absolute value of the four-bit CC field in the RTP\
    \ header.\n   The last of the three changes to the COMPRESSED_UDP packet deals\
    \ with\n   updating the IPv4 ID field.  For this field, the COMPRESSED_UDP\n \
    \  packet as specified in RFC 2508 can already convey a new value for\n   the\
    \ delta IPv4 ID, but not the absolute value which is only conveyed\n   by the\
    \ FULL_HEADER packet.  Therefore, a new flag I is added to the\n   COMPRESSED_UDP\
    \ packet to indicate inclusion of the absolute IPv4 ID\n   value.  The I flag\
    \ replaces the dS flag which is not needed in the\n   COMPRESSED_UDP packet since\
    \ the delta RTP sequence number always\n   remains 1 in the decompressor context\
    \ and hence does not need to be\n   updated.  Note that IPv6 does not have an\
    \ IP ID field, so when\n   compressing IPv6 packets both the I and the dI flags\
    \ are always set\n   to 0.\n   The format of the flags/sequence byte for the original\
    \ COMPRESSED_UDP\n   packet is shown here for reference:\n      +---+---+---+---+---+---+---+---+\n\
    \      | 0 | 0 | 0 |dI | link sequence |\n      +---+---+---+---+---+---+---+---+\n\
    \   The new definition of the flags/sequence byte plus an extension flags\n  \
    \ byte for the COMPRESSED_UDP packet is as follows, where the new F\n   flag indicates\
    \ the inclusion of the extension flags byte:\n      +---+---+---+---+---+---+---+---+\n\
    \      | F | I |dT |dI | link sequence |\n      +---+---+---+---+---+---+---+---+\n\
    \      : M : S : T : P : C : 0 : 0 : 0 :  (if F = 1)\n      +...+...+...+...+...+...+...+...+\n\
    \   dI  = delta IPv4 ID\n   dT  = delta RTP timestamp\n   I   = absolute IPv4\
    \ ID\n   F   = additional flags byte\n   M   = marker bit\n   S   = absolute RTP\
    \ sequence number\n   T   = absolute RTP timestamp\n   P   = RTP payload type\n\
    \   C   = CSRC count\n   CID = Context ID\n   When F=0, there is only one flags\
    \ byte, and the only available flags\n   are: dI, dT and I.  In this case the\
    \ packet includes the full RTP\n   header.  As in RFC 2508, if dI=0, the decompressor\
    \ does not change\n   deltaI.  If dT=0, the decompressor sets deltaT to 0.\n \
    \  When C=1, an additional byte is added following the two flag bytes.\n   This\
    \ byte includes the CC, the count of CSRC identifiers, in its\n   lower 4 bits:\n\
    \      +---+---+---+---+---+---+---+---+\n      | F | I |dT |dI | link sequence\
    \ |\n      +---+---+---+---+---+---+---+---+\n      : M : S : T : P : C : 0 :\
    \ 0 : 0 :  (if F = 1)\n      +...+...+...+...+...+...+...+...+\n      : 0 : 0\
    \ : 0 : 0 :      CC       :  (if C = 1)\n      +...+...+...+...+...............+\n\
    \   The bits marked \"0\" in the second flag byte and the CC byte SHOULD be\n\
    \   set to zero by the sender and SHOULD be ignored by the receiver.\n   Some\
    \ example packet formats will illustrate the use of the new flags.\n   First,\
    \ when F=0, the \"traditional\" COMPRESSED_UDP packet which\n   carries the full\
    \ RTP header as part of the UDP data:\n        0   1   2   3   4   5   6   7\n\
    \      +...............................+\n      :   msb of session context ID\
    \   :  (if 16-bit CID)\n      +-------------------------------+\n      |   lsb\
    \ of session context ID   |\n      +---+---+---+---+---+---+---+---+\n      |F=0|\
    \ I |dT |dI | link sequence |\n      +---+---+---+---+---+---+---+---+\n     \
    \ :                               :\n      +         UDP checksum          + \
    \ (if nonzero in context)\n      :                               :\n      +...............................+\n\
    \      :                               :\n      +        \"RANDOM\" fields   \
    \     +  (if encapsulated)\n      :                               :\n      +...............................+\n\
    \      :         delta IPv4 ID         :  (if dI = 1)\n      +...............................+\n\
    \      :      delta RTP timestamp      :  (if dT = 1)\n      +...............................+\n\
    \      :                               :\n      +           IPv4 ID          \
    \   +  (if I = 1)\n      :                               :\n      +...............................+\n\
    \      |           UDP data            |\n      :   (uncompressed RTP header)\
    \   :\n   When F=1, there is an additional flags byte and the available flags\n\
    \   are: dI, dT, I, M, S, T, P, C.  If C=1, there is an additional byte\n   that\
    \ includes the number of CSRC identifiers.  When F=1, the packet\n   does not\
    \ include the full RTP header, but includes selected fields\n   from the RTP header\
    \ as specified by the flags.  As in RFC 2508, if\n   dI=0 the decompressor does\
    \ not change deltaI.  However, in contrast\n   to RFC 2508, if dT=0 the decompressor\
    \ KEEPS THE CURRENT deltaT in the\n   context (DOES NOT set deltaT to 0).\n  \
    \ An enhanced COMPRESSED_UDP packet is similar in contents and behavior\n   to\
    \ a COMPRESSED_RTP packet, but it has more flag bits, some of which\n   correspond\
    \ to absolute values for RTP header fields.\n   COMPRESSED_UDP with individual\
    \ RTP fields, when F=1:\n     0   1   2   3   4   5   6   7\n   +...............................+\n\
    \   :   msb of session context ID   :  (if 16-bit CID)\n   +-------------------------------+\n\
    \   |   lsb of session context ID   |\n   +---+---+---+---+---+---+---+---+\n\
    \   |F=1| I |dT |dI | link sequence |\n   +---+---+---+---+---+---+---+---+\n\
    \   | M | S | T | P | C | 0 | 0 | 0 |\n   +---+---+---+---+---+---+---+---+\n\
    \   : 0 : 0 : 0 : 0 :      CC       :  (if C = 1)\n   +...+...+...+...+...............+\n\
    \   :                               :\n   +         UDP checksum          +  (if\
    \ nonzero in context)\n   :                               :\n   +...............................+\n\
    \   :                               :\n   :        \"RANDOM\" fields        :\
    \  (if encapsulated)\n   :                               :\n   +...............................+\n\
    \   :         delta IPv4 ID         :  (if dI = 1)\n   +...............................+\n\
    \   :      delta RTP timestamp      :  (if dT = 1)\n   +...............................+\n\
    \   :                               :\n   +           IPv4 ID             +  (if\
    \ I = 1)\n   :                               :\n   +...............................+\n\
    \   :                               :\n   +     RTP sequence number       +  (if\
    \ S = 1)\n   :                               :\n   +...............................+\n\
    \   :                               :\n   +                               +\n\
    \   :                               :\n   +         RTP timestamp         +  (if\
    \ T = 1)\n   :                               :\n   +                         \
    \      +\n   :                               :\n   +...............................+\n\
    \   :       RTP payload type        :  (if P = 1)\n   +...............................+\n\
    \   :                               :\n   :           CSRC list           :  (if\
    \ CC > 0)\n   :                               :\n   +...............................+\n\
    \   :                               :\n   :      RTP header extension     :  (if\
    \ X set in context)\n   :                               :\n   +-------------------------------+\n\
    \   |                               |\n   /           RTP data            /\n\
    \   /                               /\n   |                               |\n\
    \   +-------------------------------+\n   :            padding            :  (if\
    \ P set in context)\n   +...............................+\n   Usage for the enhanced\
    \ COMPRESSED_UDP packet:\n   It is useful for the compressor to periodically refresh\
    \ the state of\n   the decompressor to avoid having the decompressor send CONTEXT_STATE\n\
    \   messages in the case of unrecoverable packet loss.  Using the flags\n   F=0\
    \ and I=1, dI=1, dT=1, the COMPRESSED_UDP packet refreshes all the\n   context\
    \ parameters.\n   When compression is done over a lossy link with a long round\
    \ trip\n   delay, we want to minimize context invalidation.  If the delta values\n\
    \   are changing frequently, the context might get invalidated often.  In\n  \
    \ such cases the compressor MAY choose to always send absolute values\n   and\
    \ never delta values, using COMPRESSED_UDP packets with the flags\n   F=1, and\
    \ any of S, T, I as necessary.\n"
- title: 2.2.  CRTP Headers Checksum
  contents:
  - "2.2.  CRTP Headers Checksum\n   RFC 2508, in Section 3.3.5, describes how the\
    \ UDP checksum may be\n   used to validate header reconstruction periodically\
    \ or when the\n   \"twice\" algorithm is used.  When a UDP checksum is not present\
    \ (has\n   value zero) in a stream, such validation would not be possible.  To\n\
    \   cover that case, this enhanced CRTP provides an option whereby the\n   compressor\
    \ MAY replace the null UDP checksum with a 16-bit headers\n   checksum (HDRCKSUM)\
    \ which is subsequently removed by the decompressor\n   after validation.  Note\
    \ that this option is never used with IPv6\n   since a null UDP checksum is not\
    \ allowed.\n   A new flag C in the FULL_HEADER packet, as specified below, indicates\n\
    \   when set that all COMPRESSED_UDP and COMPRESSED_RTP packets sent in\n   that\
    \ context will have HDRCKSUM inserted.  The compressor MAY set the\n   C flag\
    \ when UDP packet carried in the FULL_HEADER packet originally\n   contained a\
    \ checksum value of zero. If the C flag is set, the\n   FULL_HEADER packet itself\
    \ MUST also have the HDRCKSUM inserted.  If a\n   packet in the same stream subsequently\
    \ arrives at the compressor with\n   a UDP checksum present, then a new FULL_HEADER\
    \ packet MUST be sent\n   with the flag cleared to re-establish the context.\n\
    \   The HDRCKSUM is calculated in the same way as a UDP checksum except\n   that\
    \ it does not cover all of the UDP data.  That is, the HDRCKSUM is\n   the 16-bit\
    \ one's complement of the one's complement sum of the\n   pseudo-IP header (as\
    \ defined for UDP), the UDP header, the first 12\n   bytes of the UDP data which\
    \ are assumed to hold the fixed part of an\n   RTP header, and the CSRC list.\
    \  The extended part of the RTP header\n   beyond the CSRC list and the RTP data\
    \ will not be included in the\n   HDRCKSUM.  The HDRCKSUM is placed in the COMPRESSED_UDP\
    \ or\n   COMPRESSED_RTP packet where a UDP checksum would have been.  The\n  \
    \ decompressor MUST zero out the UDP checksum field in the\n   reconstructed packets.\n\
    \   For a non-RTP context, there may be fewer than 12 UDP data bytes\n   present.\
    \  The IP and UDP headers can still be compressed into a\n   COMPRESSED_UDP packet.\
    \  For this case, the HDRCKSUM is calculated\n   over the pseudo-IP header, the\
    \ UDP header, and the UDP data bytes\n   that are present.  If the number of data\
    \ bytes is odd, then a zero\n   padding byte is appended for the purpose of calculating\
    \ the checksum,\n   but not transmitted.\n   The HDRCKSUM does not validate the\
    \ RTP data.  If the link layer is\n   configured to deliver packets without checking\
    \ for errors, then\n   errors in the RTP data will not be detected.  Over such\
    \ links, the\n   compressor SHOULD add the HDRCKSUM if a UDP checksum is not present,\n\
    \   and the decompressor SHOULD validate each reconstructed packet to\n   make\
    \ sure that at least the headers are correct.  This ensures that\n   the packet\
    \ will be delivered to the right destination.  If only\n   HDRCKSUM is available,\
    \ the RTP data will be delivered even if it\n   includes errors.  This might be\
    \ a desirable feature for applications\n   that can tolerate errors in the RTP\
    \ data.  The same holds for the\n   extended part of the RTP header beyond the\
    \ CSRC list.\n   Here is the format of the FULL_HEADER length fields with the\
    \ new flag\n   C to indicate that a header checksum will be added in COMPRESSED_UDP\n\
    \   and COMPRESSED_RTP packets:\n   For 8-bit context ID:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|1| Generation|      CID      |  First length field\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |            0        |C|  seq  |  Second\
    \ length field\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  C=1: HDRCKSUM will be added\n\
    \   For 16-bit context ID:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |1|1| Generation|\
    \ 0   |C|  seq  |  First length field\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  C=1:\
    \ HDRCKSUM will be added\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         \
    \     CID              |  Second length field\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 2.3.  Achieving robust operation
  contents:
  - "2.3.  Achieving robust operation\n   Enhanced CRTP achieves robust operation\
    \ by sending changes multiple\n   times to keep the compressor and decompressor\
    \ in sync.  This method\n   is characterized by a number \"N\" that represents\
    \ the quality of the\n   link between the hosts.  What it means is that the probability\
    \ of\n   more than N adjacent packets getting lost on this link is small.  For\n\
    \   every change in a full value or a delta value, if the compressor\n   includes\
    \ the change in N+1 consecutive packets, then the decompressor\n   can keep its\
    \ context state in sync with the compressor using the\n   \"twice\" algorithm\
    \ so long as no more than N adjacent packets are\n   lost.\n   Since updates are\
    \ repeated in N+1 packets, if at least one of these\n   N+1 update packets is\
    \ received by the decompressor, both the full and\n   delta values in the context\
    \ at the decompressor will get updated and\n   its context will stay synchronized\
    \ with the context at the\n   compressor.  We can conclude that as long as less\
    \ than N+1 adjacent\n   packets are lost, the context at the decompressor is guaranteed\
    \ to be\n   synchronized with the context at the compressor, and use of the\n\
    \   \"twice\" algorithm to recover from packet loss will successfully\n   update\
    \ the context and restore the compressed packets.\n   The link sequence number\
    \ cycles in 16 packets, so it's not always\n   clear how many packets were lost.\
    \  For example, if the previous link\n   sequence number was 5 and the current\
    \ number is 4, one possibility is\n   that 15 packets were lost, but another possibility\
    \ is that due to\n   misordering packet 5 arrived before packet 4 and they are\
    \ really\n   adjacent.  If there is an interpretation of the link sequence numbers\n\
    \   that could be a gap of less than N+1, the \"twice\" algorithm may be\n   applied\
    \ that many times and verified with the UDP checksum (or the\n   HDRCKSUM).\n\
    \   When more than N packets are lost, all of the repetitions of an\n   update\
    \ might have been lost.  The context state may then be different\n   at the compressor\
    \ and decompressor.  The decompressor can still try\n   to recover by making one\
    \ or more guesses for how many packets were\n   lost and then applying the \"\
    twice\" algorithm that many times.\n   However, since the IPv4 ID field is not\
    \ included in the checksum,\n   this does not validate the IPv4 ID.\n   The conclusion\
    \ is that for IPv4 if more than N packets were lost, the\n   decompressor SHOULD\
    \ NOT try to recover using the \"twice\" algorithm\n   and instead SHOULD invalidate\
    \ the context and send a CONTEXT_STATE\n   packet.  In IPv6 the decompressor MAY\
    \ always try to recover from\n   packet loss by using the \"twice\" algorithm\
    \ and verifying the result\n   with the UDP checksum.\n   It is up to the implementation\
    \ to derive an appropriate N for a link.\n   The value is maintained independently\
    \ for each context and is not\n   required to be the same for all contexts.  When\
    \ compressing a new\n   stream, the compressor sets a value of N for that context\
    \ and sends\n   N+1 FULL_HEADER packets.  The compressor MUST also repeat each\n\
    \   subsequent COMPRESSED_UDP update N+1 times.  The value of N may be\n   changed\
    \ for an existing context by sending a new sequence of\n   FULL_HEADER packets.\n\
    \   The decompressor learns the value of N by counting the number of\n   times\
    \ the FULL_HEADER packet is repeated and storing the resulting\n   value in the\
    \ corresponding context.  If some of the FULL_HEADER\n   packets are lost, the\
    \ decompressor may still be able to determine the\n   correct value of N by observing\
    \ the change in the 4-bit sequence\n   number carried in the FULL_HEADER packets.\
    \  Any inaccuracy in the\n   counting will lead the decompressor to assume a smaller\
    \ value of N\n   than the compressor is sending.  This is safe in that the only\n\
    \   negative consequence is that the decompressor might send a\n   CONTEXT_STATE\
    \ packet when it was not really necessary to do so.  In\n   response, the compressor\
    \ will send FULL_HEADER packets again,\n   providing another opportunity for the\
    \ decompressor to count the\n   correct N.\n   The sending of FULL_HEADER packets\
    \ is also triggered by a change in\n   one of the fields held constant in the\
    \ context, such as the IP TOS.\n   If such a change should occur while the compressor\
    \ is in the middle\n   of sending the N+1 FULL_HEADER packets, then the compressor\
    \ MUST send\n   N+1 FULL_HEADER packets after making the change.  This could cause\n\
    \   the decompressor to receive more than N+1 FULL_HEADER packets in a\n   row\
    \ with the result that it assumes a larger value for N than is\n   correct.  That\
    \ could lead to an undetected loss of context\n   synchronization.  Therefore,\
    \ the compressor MUST change the\n   \"generation\" number in the context and\
    \ in the FULL_HEADER packet when\n   it begins sending the sequence of N+1 FULL_HEADER\
    \ packets so the\n   decompressor can detect the new sequence.  For IPv4, this\
    \ is a change\n   in behavior relative to RFC 2508.\n   CONTEXT_STATE packets\
    \ SHOULD also be repeated N+1 times (using the\n   same sequence number for each\
    \ context) to provide a similar measure\n   of robustness against packet loss.\
    \  Here N can be the largest N of\n   all contexts included in the CONTEXT_STATE\
    \ packet, or any number the\n   decompressor finds necessary in order to ensure\
    \ robustness.\n"
- title: 2.3.1.  Examples
  contents:
  - "2.3.1.  Examples\n   Here are some examples to demonstrate the robust operation\
    \ of\n   enhanced CRTP using N+1 repetitions of updates.  In this stream the\n\
    \   audio codec sends a sample every 10 milliseconds.  The first\n   talkspurt\
    \ is 1 second long.  Then there are 2 seconds of silence,\n   then another talkspurt.\
    \  We also assume in this first example that\n   the IPv4 ID field does not increment\
    \ at a constant rate because the\n   host is generating other uncorrelated traffic\
    \ streams at the same\n   time and therefore the delta IPv4 ID changes for each\
    \ packet.\n   In these examples, we will use some short notations:\n    FH   \
    \ FULL_HEADER\n    CR    COMPRESSED_RTP\n    CU    COMPRESSED_UDP\n   When operating\
    \ on a link with low loss, we can just use\n   COMPRESSED_RTP packets in the basic\
    \ CRTP method specified in RFC\n   2508.  We might have the following packet sequence:\n\
    \    seq Time pkt    updates and comments\n     #       type\n    1   10   FH\n\
    \    2   20   CR     dI dT=10\n    3   30   CR     dI\n    4   40   CR     dI\n\
    \    ...\n    100 1000 CR     dI\n    101 3010 CR     dI dT=2010\n    102 3020\
    \ CR     dI dT=10\n    103 3030 CR     dI\n    104 3040 CR     dI\n    ...\n \
    \  In the above sequence, if a packet is lost we cannot recover (\"twice\"\n \
    \  will not work due to the unpredictable IPv4 ID) and the context must\n   be\
    \ invalidated.\n   Here is the same example using the enhanced CRTP method specified\
    \ in\n   this document, when N=2.  Note that the compressor only sends the\n \
    \  absolute IPv4 ID (I) and not the delta IPv4 ID (dI).\n    seq Time pkt  CU\
    \ flags            updates and comments\n     #       type F I dT dI M S T P\n\
    \    1   10   FH\n    2   20   FH                             repeat constant\
    \ fields\n    3   30   FH                             repeat constant fields\n\
    \    4   40   CU   1 1  1  0 M 0 1 0   I T=40 dT=10\n    5   50   CU   1 1  1\
    \  0 M 0 1 0   I T=50 dT=10 repeat update T & dT\n    6   60   CU   1 1  1  0\
    \ M 0 1 0   I T=60 dT=10 repeat update T & dT\n    7   70   CU   1 1  0  0 M 0\
    \ 0 0   I\n    8   80   CU   1 1  0  0 M 0 0 0   I\n    ...\n    100 1000 CU \
    \  1 1  0  0 M 0 0 0   I\n    101 3010 CU   1 1  0  0 M 0 1 0   I T=3010  T changed,\
    \ keep deltas\n    102 3020 CU   1 1  0  0 M 0 1 0   I T=3020  repeat updated\
    \ T\n    103 3030 CU   1 1  0  0 M 0 1 0   I T=3030  repeat updated T\n    104\
    \ 3040 CU   1 1  0  0 M 0 0 0   I\n    105 3050 CU   1 1  0  0 M 0 0 0   I\n \
    \   ...\n   This second example is the same sequence, but assuming the delta IP\n\
    \   ID is constant.  First the basic CRTP for a lossless link:\n    seq Time pkt\
    \    updates and comments\n     #       type\n    1   10   FH\n    2   20   CR\
    \     dI dT=10\n    3   30   CR\n    4   40   CR\n    ...\n    100 1000 CR\n \
    \   101 3010 CR     dT=2010\n    102 3020 CR     dT=10\n    103 3030 CR\n    104\
    \ 3040 CR\n    ...\n   For the equivalent sequence in enhanced CRTP, the more\
    \ efficient\n   COMPRESSED_RTP packet can still be used once the deltas are all\n\
    \   established:\n    seq Time pkt  CU flags            updates and comments\n\
    \     #       type F I dT dI M S T P\n    1   10   FH\n    2   20   FH       \
    \                      repeat constant fields\n    3   30   FH               \
    \              repeat constant fields\n    4   40   CU   1 1  1  1 M 0 1 0   I\
    \ dI T=40 dT=10\n    5   50   CU   1 1  1  1 M 0 1 0   I dI T=50 dT=10  repeat\
    \ updates\n    6   60   CU   1 1  1  1 M 0 1 0   I dI T=60 dT=10  repeat updates\n\
    \    7   70   CR\n    8   80   CR\n    ...\n    100 1000 CR\n    101 3010 CU \
    \  1 0  0  0 M 0 1 0   T=3010  T changed, keep deltas\n    102 3020 CU   1 0 \
    \ 0  0 M 0 1 0   T=3020  repeat updated T\n    103 3030 CU   1 0  0  0 M 0 1 0\
    \   T=3030  repeat updated T\n    104 3040 CR\n    105 3050 CR\n    ...\n   Here\
    \ is the second example when using IPv6.  First the basic CRTP for\n   a lossless\
    \ link:\n    seq Time pkt    updates and comments\n     #       type\n    1  \
    \ 10   FH\n    2   20   CR     dT=10\n    3   30   CR\n    4   40   CR\n    ...\n\
    \    100 1000 CR\n    101 3010 CR     dT=2010\n    102 3020 CR     dT=10\n   \
    \ 103 3030 CR\n    104 3040 CR\n    ...\n   For the equivalent sequence in enhanced\
    \ CRTP, the more efficient\n   COMPRESSED_RTP packet can still be used once the\
    \ deltas are all\n   established:\n    seq Time pkt  CU flags            updates\
    \ and comments\n     #       type F I dT dI M S T P\n    1   10   FH\n    2  \
    \ 20   FH                             repeat constant fields\n    3   30   FH\
    \                             repeat constant fields\n    4   40   CU   1 0  1\
    \  0 M 0 1 0   T=40 dT=10\n    5   50   CU   1 0  1  0 M 0 1 0   T=50 dT=10  repeat\
    \ updates\n    6   60   CU   1 0  1  0 M 0 1 0   T=60 dT=10  repeat updates\n\
    \    7   70   CR\n    8   80   CR\n    ...\n    100 1000 CR\n    101 3010 CU \
    \  1 0  0  0 M 0 1 0   T=3010  T changed, keep deltas\n    102 3020 CU   1 0 \
    \ 0  0 M 0 1 0   T=3020  repeat updated T\n    103 3030 CU   1 0  0  0 M 0 1 0\
    \   T=3030  repeat updated T\n    104 3040 CR\n    105 3050 CR\n    ...\n"
- title: 3.  Negotiating usage of enhanced-CRTP
  contents:
  - "3.  Negotiating usage of enhanced-CRTP\n   The use of IP/UDP/RTP compression\
    \ (CRTP) over a particular link is a\n   function of the link-layer protocol.\
    \  It is expected that negotiation\n   of the use of CRTP will be defined separately\
    \ for each link layer.\n   For link layers that already have defined a negotiation\
    \ for the use\n   of CRTP as specified in RFC 2508, an extension to that negotiation\n\
    \   will be required to indicate use of the enhanced CRTP defined in this\n  \
    \ document since the syntax of the existing packet formats has been\n   extended.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   Because encryption eliminates the redundancy\
    \ that this compression\n   scheme tries to exploit, there is some inducement\
    \ to forego\n   encryption in order to achieve operation over a low-bandwidth\
    \ link.\n   However, for those cases where encryption of data and not headers\
    \ is\n   satisfactory, RTP does specify an alternative encryption method in\n\
    \   which only the RTP payload is encrypted and the headers are left in\n   the\
    \ clear [SRTP].  That would allow compression to still be applied.\n   A malfunctioning\
    \ or malicious compressor could cause the decompressor\n   to reconstitute packets\
    \ that do not match the original packets but\n   still have valid IP, UDP and\
    \ RTP headers and possibly even valid UDP\n   check-sums.  Such corruption may\
    \ be detected with end-to-end\n   authentication and integrity mechanisms which\
    \ will not be affected by\n   the compression.  Constant portions of authentication\
    \ headers will be\n   compressed as described in [IPHCOMP].\n   No authentication\
    \ is performed on the CONTEXT_STATE control packet\n   sent by this protocol.\
    \  An attacker with access to the link between\n   the decompressor and compressor\
    \ could inject false CONTEXT_STATE\n   packets and cause compression efficiency\
    \ to be reduced, probably\n   resulting in congestion on the link.  However, an\
    \ attacker with\n   access to the link could also disrupt the traffic in many\
    \ other ways.\n   A potential denial-of-service threat exists when using compression\n\
    \   techniques that have non-uniform receiver-end computational load. The\n  \
    \ attacker can inject pathological datagrams into the stream which are\n   complex\
    \ to decompress and cause the receiver to be overloaded and\n   degrading processing\
    \ of other streams.  However, this compression\n   does not exhibit any significant\
    \ non-uniformity.\n"
- title: 5.  Acknowledgements
  contents:
  - "5.  Acknowledgements\n   The authors would like to thank Van Jacobson, co-author\
    \ of RFC 2508,\n   and the authors of RFC 2507, Mikael Degermark, Bjorn Nordgren,\
    \ and\n   Stephen Pink.  The authors would also like to thank Dana Blair,\n  \
    \ Francois Le Faucheur, Tim Gleeson, Matt Madison, Hussein Salama,\n   Mallik\
    \ Tatipamula, Mike Thomas, Alex Tweedly, Herb Wildfeuer,\n   Andrew Johnson, and\
    \ Dan Wing.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [CRTP]    Casner, S. and V. Jacobson, \"Compressing\
    \ IP/UDP/RTP Headers\n             for Low-Speed Serial Links\", RFC 2508, February\
    \ 1999.\n   [IPHCOMP] Degermark, M., Nordgren, B. and S. Pink, \"IP Header\n \
    \            Compression\", RFC 2507, February 1999.\n   [IPCPHC]  Koren, T.,\
    \ Casner, S. and C. Bormann, \"IP Header\n             Compression over PPP\"\
    , RFC 3544, July 2003.\n   [KEYW]    Bradner, S. \"Key words for use in RFCs to\
    \ Indicate\n             Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RTP]     Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson,\n  \
    \           \"RTP: A Transport Protocol for Real-Time Applications\", RFC\n  \
    \           3550, July 2003.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [ROHC]    Bormann, C., Burmeister, C., Degermark,\
    \ M., Fukushima, H.,\n             Hannu, H., Jonsson, L., Hakenberg, R., Koren,\
    \ T., Le, K.,\n             Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K.,\
    \ Wiebke,\n             T., Yoshimura, T. and H. Zheng, \"RObust Header Compression\n\
    \             (ROHC): Framework and four profiles: RTP, UDP, ESP, and\n      \
    \       uncompressed\", RFC 3095, July 2001.\n   [SRTP]    Baugher, M., McGrew,\
    \ D., Carrara, E., Naslund, M. and K.\n             Norrman, \"The Secure Real-time\
    \ Transport Protocol\", Work in\n             Progress.\n"
- title: 7.  Intellectual Property Rights Notice
  contents:
  - "7.  Intellectual Property Rights Notice\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 8.  Authors' Addresses
  contents:
  - "8.  Authors' Addresses\n   Tmima Koren\n   Cisco Systems, Inc.\n   170 West Tasman\
    \ Drive\n   San Jose, CA  95134-1706\n   USA\n   EMail: tmima@cisco.com\n   Stephen\
    \ L. Casner\n   Packet Design\n   3400 Hillview Avenue, Building 3\n   Palo Alto,\
    \ CA  94304\n   USA\n   EMail: casner@acm.org\n   John Geevarghese\n   Motorola\
    \ India Electronics Ltd.\n   No. 33 A Ulsoor Road\n   Bangalore, India\n   EMail:\
    \ geevjohn@hotmail.com\n   Bruce Thompson\n   Cisco Systems, Inc.\n   170 West\
    \ Tasman Drive\n   San Jose, CA  95134-1706\n   USA\n   EMail: brucet@cisco.com\n\
    \   Patrick Ruddy\n   Cisco Systems, Inc.\n   3rd Floor\n   96 Commercial Street\n\
    \   Leith, Edinburgh  EH6 6LX\n   Scotland\n   EMail: pruddy@cisco.com\n"
- title: 9.  Full Copyright Statement
  contents:
  - "9.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
