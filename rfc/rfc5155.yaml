- contents:
  - '     DNS Security (DNSSEC) Hashed Authenticated Denial of Existence

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   The Domain Name System Security (DNSSEC) Extensions introduced the\n
    \  NSEC resource record (RR) for authenticated denial of existence.\n   This document
    introduces an alternative resource record, NSEC3, which\n   similarly provides
    authenticated denial of existence.  However, it\n   also provides measures against
    zone enumeration and permits gradual\n   expansion of delegation-centric zones.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n     1.1.  Rationale  . . . . . . . . . . . . . . . . . . . .
    . . . .  4\n     1.2.  Requirements . . . . . . . . . . . . . . . . . . . . .
    . .  4\n     1.3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n   2.  Backwards Compatibility  . . . . . . . . . . . . . . . . . . .  6\n
    \  3.  The NSEC3 Resource Record  . . . . . . . . . . . . . . . . . .  7\n     3.1.
    \ RDATA Fields . . . . . . . . . . . . . . . . . . . . . . .  8\n       3.1.1.
    \ Hash Algorithm . . . . . . . . . . . . . . . . . . . .  8\n       3.1.2.  Flags
    \ . . . . . . . . . . . . . . . . . . . . . . . .  8\n       3.1.3.  Iterations
    . . . . . . . . . . . . . . . . . . . . . .  8\n       3.1.4.  Salt Length  .
    . . . . . . . . . . . . . . . . . . . .  8\n       3.1.5.  Salt . . . . . . .
    . . . . . . . . . . . . . . . . . .  8\n       3.1.6.  Hash Length  . . . . .
    . . . . . . . . . . . . . . . .  9\n       3.1.7.  Next Hashed Owner Name . .
    . . . . . . . . . . . . . .  9\n       3.1.8.  Type Bit Maps  . . . . . . . .
    . . . . . . . . . . . .  9\n     3.2.  NSEC3 RDATA Wire Format  . . . . . . .
    . . . . . . . . . .  9\n       3.2.1.  Type Bit Maps Encoding . . . . . . . .
    . . . . . . . . 10\n     3.3.  Presentation Format  . . . . . . . . . . . . .
    . . . . . . 11\n   4.  The NSEC3PARAM Resource Record . . . . . . . . . . . .
    . . . . 12\n     4.1.  RDATA Fields . . . . . . . . . . . . . . . . . . . . .
    . . 12\n       4.1.1.  Hash Algorithm . . . . . . . . . . . . . . . . . . . .
    12\n       4.1.2.  Flag Fields  . . . . . . . . . . . . . . . . . . . . . 12\n
    \      4.1.3.  Iterations . . . . . . . . . . . . . . . . . . . . . . 13\n       4.1.4.
    \ Salt Length  . . . . . . . . . . . . . . . . . . . . . 13\n       4.1.5.  Salt
    . . . . . . . . . . . . . . . . . . . . . . . . . 13\n     4.2.  NSEC3PARAM RDATA
    Wire Format . . . . . . . . . . . . . . . 13\n     4.3.  Presentation Format  .
    . . . . . . . . . . . . . . . . . . 14\n   5.  Calculation of the Hash  . . .
    . . . . . . . . . . . . . . . . 14\n   6.  Opt-Out  . . . . . . . . . . . . .
    . . . . . . . . . . . . . . 15\n   7.  Authoritative Server Considerations  .
    . . . . . . . . . . . . 16\n     7.1.  Zone Signing . . . . . . . . . . . . .
    . . . . . . . . . . 16\n     7.2.  Zone Serving . . . . . . . . . . . . . . .
    . . . . . . . . 17\n       7.2.1.  Closest Encloser Proof . . . . . . . . . .
    . . . . . . 18\n       7.2.2.  Name Error Responses . . . . . . . . . . . . .
    . . . . 19\n       7.2.3.  No Data Responses, QTYPE is not DS . . . . . . . .
    . . 19\n       7.2.4.  No Data Responses, QTYPE is DS . . . . . . . . . . . .
    19\n       7.2.5.  Wildcard No Data Responses . . . . . . . . . . . . . . 19\n
    \      7.2.6.  Wildcard Answer Responses  . . . . . . . . . . . . . . 20\n       7.2.7.
    \ Referrals to Unsigned Subzones . . . . . . . . . . . . 20\n       7.2.8.  Responding
    to Queries for NSEC3 Owner Names  . . . . . 20\n       7.2.9.  Server Response
    to a Run-Time Collision  . . . . . . . 21\n     7.3.  Secondary Servers  . . .
    . . . . . . . . . . . . . . . . . 21\n     7.4.  Zones Using Unknown Hash Algorithms
    \ . . . . . . . . . . . 21\n     7.5.  Dynamic Update . . . . . . . . . . . .
    . . . . . . . . . . 21\n   8.  Validator Considerations . . . . . . . . . . .
    . . . . . . . . 23\n     8.1.  Responses with Unknown Hash Types  . . . . . .
    . . . . . . 23\n     8.2.  Verifying NSEC3 RRs  . . . . . . . . . . . . . . .
    . . . . 23\n     8.3.  Closest Encloser Proof . . . . . . . . . . . . . . . .
    . . 23\n     8.4.  Validating Name Error Responses  . . . . . . . . . . . . .
    24\n     8.5.  Validating No Data Responses, QTYPE is not DS  . . . . . . 24\n
    \    8.6.  Validating No Data Responses, QTYPE is DS  . . . . . . . . 24\n     8.7.
    \ Validating Wildcard No Data Responses  . . . . . . . . . . 25\n     8.8.  Validating
    Wildcard Answer Responses . . . . . . . . . . . 25\n     8.9.  Validating Referrals
    to Unsigned Subzones  . . . . . . . . 25\n   9.  Resolver Considerations  . .
    . . . . . . . . . . . . . . . . . 26\n     9.1.  NSEC3 Resource Record Caching
    \ . . . . . . . . . . . . . . 26\n     9.2.  Use of the AD Bit  . . . . . . .
    . . . . . . . . . . . . . 26\n   10. Special Considerations . . . . . . . . .
    . . . . . . . . . . . 26\n     10.1. Domain Name Length Restrictions  . . . .
    . . . . . . . . . 26\n     10.2. DNAME at the Zone Apex . . . . . . . . . . .
    . . . . . . . 27\n     10.3. Iterations . . . . . . . . . . . . . . . . . . .
    . . . . . 27\n     10.4. Transitioning a Signed Zone from NSEC to NSEC3 . . .
    . . . 28\n     10.5. Transitioning a Signed Zone from NSEC3 to NSEC . . . . .
    . 28\n   11. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 29\n
    \  12. Security Considerations  . . . . . . . . . . . . . . . . . . . 30\n     12.1.
    Hashing Considerations . . . . . . . . . . . . . . . . . . 30\n       12.1.1.
    Dictionary Attacks . . . . . . . . . . . . . . . . . . 30\n       12.1.2. Collisions
    . . . . . . . . . . . . . . . . . . . . . . 31\n       12.1.3. Transitioning to
    a New Hash Algorithm  . . . . . . . . 31\n       12.1.4. Using High Iteration
    Values  . . . . . . . . . . . . . 31\n     12.2. Opt-Out Considerations . . .
    . . . . . . . . . . . . . . . 32\n     12.3. Other Considerations . . . . . .
    . . . . . . . . . . . . . 33\n   13. References . . . . . . . . . . . . . . .
    . . . . . . . . . . . 33\n     13.1. Normative References . . . . . . . . . .
    . . . . . . . . . 33\n     13.2. Informative References . . . . . . . . . . .
    . . . . . . . 34\n   Appendix A.  Example Zone  . . . . . . . . . . . . . . .
    . . . . . 35\n   Appendix B.  Example Responses . . . . . . . . . . . . . . .
    . . . 40\n     B.1.  Name Error . . . . . . . . . . . . . . . . . . . . . . .
    . 40\n     B.2.  No Data Error  . . . . . . . . . . . . . . . . . . . . . . 42\n
    \      B.2.1.  No Data Error, Empty Non-Terminal  . . . . . . . . . . 43\n     B.3.
    \ Referral to an Opt-Out Unsigned Zone . . . . . . . . . . . 44\n     B.4.  Wildcard
    Expansion . . . . . . . . . . . . . . . . . . . . 45\n     B.5.  Wildcard No Data
    Error . . . . . . . . . . . . . . . . . . 46\n     B.6.  DS Child Zone No Data
    Error  . . . . . . . . . . . . . . . 48\n   Appendix C.  Special Considerations
    \ . . . . . . . . . . . . . . . 48\n     C.1.  Salting  . . . . . . . . . . .
    . . . . . . . . . . . . . . 49\n     C.2.  Hash Collision . . . . . . . . . .
    . . . . . . . . . . . . 49\n       C.2.1.  Avoiding Hash Collisions During Generation
    . . . . . . 50\n       C.2.2.  Second Preimage Requirement Analysis . . . . .
    . . . . 50\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  title: 1.  Introduction
- contents:
  - "1.1.  Rationale\n   The DNS Security Extensions included the NSEC RR to provide\n
    \  authenticated denial of existence.  Though the NSEC RR meets the\n   requirements
    for authenticated denial of existence, it introduces a\n   side-effect in that
    the contents of a zone can be enumerated.  This\n   property introduces undesired
    policy issues.\n   The enumeration is enabled by the set of NSEC records that
    exists\n   inside a signed zone.  An NSEC record lists two names that are\n   ordered
    canonically, in order to show that nothing exists between the\n   two names.  The
    complete set of NSEC records lists all the names in a\n   zone.  It is trivial
    to enumerate the content of a zone by querying\n   for names that do not exist.\n
    \  An enumerated zone can be used, for example, as a source of probable\n   e-mail
    addresses for spam, or as a key for multiple WHOIS queries to\n   reveal registrant
    data that many registries may have legal\n   obligations to protect.  Many registries
    therefore prohibit the\n   copying of their zone data; however, the use of NSEC
    RRs renders\n   these policies unenforceable.\n   A second problem is that the
    cost to cryptographically secure\n   delegations to unsigned zones is high, relative
    to the perceived\n   security benefit, in two cases: large, delegation-centric
    zones, and\n   zones where insecure delegations will be updated rapidly.  In these\n
    \  cases, the costs of maintaining the NSEC RR chain may be extremely\n   high
    and use of the \"Opt-Out\" convention may be more appropriate (for\n   these unsecured
    zones).\n   This document presents the NSEC3 Resource Record which can be used
    as\n   an alternative to NSEC to mitigate these issues.\n   Earlier work to address
    these issues include [DNSEXT-NO], [RFC4956],\n   and [DNSEXT-NSEC2v2].\n"
  title: 1.1.  Rationale
- contents:
  - "1.2.  Requirements\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [RFC2119].\n"
  title: 1.2.  Requirements
- contents:
  - "1.3.  Terminology\n   The reader is assumed to be familiar with the basic DNS
    and DNSSEC\n   concepts described in [RFC1034], [RFC1035], [RFC4033], [RFC4034],\n
    \  [RFC4035], and subsequent RFCs that update them: [RFC2136],\n   [RFC2181],
    and [RFC2308].\n   The following terminology is used throughout this document:\n
    \  Zone enumeration:  the practice of discovering the full content of a\n      zone
    via successive queries.  Zone enumeration was non-trivial\n      prior to the
    introduction of DNSSEC.\n   Original owner name:  the owner name corresponding
    to a hashed owner\n      name.\n   Hashed owner name:  the owner name created
    after applying the hash\n      function to an owner name.\n   Hash order:  the
    order in which hashed owner names are arranged\n      according to their numerical
    value, treating the leftmost (lowest\n      numbered) octet as the most significant
    octet.  Note that this\n      order is the same as the canonical DNS name order
    specified in\n      [RFC4034], when the hashed owner names are in base32, encoded
    with\n      an Extended Hex Alphabet [RFC4648].\n   Empty non-terminal:  a domain
    name that owns no resource records, but\n      has one or more subdomains that
    do.\n   Delegation:  an NS RRSet with a name different from the current zone\n
    \     apex (non-zone-apex), signifying a delegation to a child zone.\n   Secure
    delegation:  a name containing a delegation (NS RRSet) and a\n      signed DS
    RRSet, signifying a delegation to a signed child zone.\n   Insecure delegation:
    \ a name containing a delegation (NS RRSet), but\n      lacking a DS RRSet, signifying
    a delegation to an unsigned child\n      zone.\n   Opt-Out NSEC3 resource record:
    \ an NSEC3 resource record that has the\n      Opt-Out flag set to 1.\n   Opt-Out
    zone:  a zone with at least one Opt-Out NSEC3 RR.\n   Closest encloser:  the longest
    existing ancestor of a name.  See also\n      Section 3.3.1 of [RFC4592].\n   Closest
    provable encloser:  the longest ancestor of a name that can\n      be proven to
    exist.  Note that this is only different from the\n      closest encloser in an
    Opt-Out zone.\n   Next closer name:  the name one label longer than the closest\n
    \     provable encloser of a name.\n   Base32:  the \"Base 32 Encoding with Extended
    Hex Alphabet\" as\n      specified in [RFC4648].  Note that trailing padding characters\n
    \     (\"=\") are not used in the NSEC3 specification.\n   To cover:  An NSEC3
    RR is said to \"cover\" a name if the hash of the\n      name or \"next closer\"
    name falls between the owner name and the\n      next hashed owner name of the
    NSEC3.  In other words, if it proves\n      the nonexistence of the name, either
    directly or by proving the\n      nonexistence of an ancestor of the name.\n   To
    match:  An NSEC3 RR is said to \"match\" a name if the owner name of\n      the
    NSEC3 RR is the same as the hashed owner name of that name.\n"
  title: 1.3.  Terminology
- contents:
  - "2.  Backwards Compatibility\n   This specification describes a protocol change
    that is not generally\n   backwards compatible with [RFC4033], [RFC4034], and
    [RFC4035].  In\n   particular, security-aware resolvers that are unaware of this\n
    \  specification (NSEC3-unaware resolvers) may fail to validate the\n   responses
    introduced by this document.\n   In order to aid deployment, this specification
    uses a signaling\n   technique to prevent NSEC3-unaware resolvers from attempting
    to\n   validate responses from NSEC3-signed zones.\n   This specification allocates
    two new DNSKEY algorithm identifiers for\n   this purpose.  Algorithm 6, DSA-NSEC3-SHA1
    is an alias for algorithm\n   3, DSA.  Algorithm 7, RSASHA1-NSEC3-SHA1 is an alias
    for algorithm 5,\n   RSASHA1.  These are not new algorithms, they are additional\n
    \  identifiers for the existing algorithms.\n   Zones signed according to this
    specification MUST only use these\n   algorithm identifiers for their DNSKEY RRs.
    \ Because these new\n   identifiers will be unknown algorithms to existing, NSEC3-unaware\n
    \  resolvers, those resolvers will then treat responses from the NSEC3\n   signed
    zone as insecure, as detailed in Section 5.2 of [RFC4035].\n   These algorithm
    identifiers are used with the NSEC3 hash algorithm\n   SHA1.  Using other NSEC3
    hash algorithms requires allocation of a new\n   alias (see Section 12.1.3).\n
    \  Security aware resolvers that are aware of this specification MUST\n   recognize
    the new algorithm identifiers and treat them as equivalent\n   to the algorithms
    that they alias.\n   A methodology for transitioning from a DNSSEC signed zone
    to a zone\n   signed using NSEC3 is discussed in Section 10.4.\n"
  title: 2.  Backwards Compatibility
- contents:
  - "3.  The NSEC3 Resource Record\n   The NSEC3 Resource Record (RR) provides authenticated
    denial of\n   existence for DNS Resource Record Sets.\n   The NSEC3 RR lists RR
    types present at the original owner name of the\n   NSEC3 RR.  It includes the
    next hashed owner name in the hash order\n   of the zone.  The complete set of
    NSEC3 RRs in a zone indicates which\n   RRSets exist for the original owner name
    of the RR and form a chain\n   of hashed owner names in the zone.  This information
    is used to\n   provide authenticated denial of existence for DNS data.  To provide\n
    \  protection against zone enumeration, the owner names used in the\n   NSEC3
    RR are cryptographic hashes of the original owner name\n   prepended as a single
    label to the name of the zone.  The NSEC3 RR\n   indicates which hash function
    is used to construct the hash, which\n   salt is used, and how many iterations
    of the hash function are\n   performed over the original owner name.  The hashing
    technique is\n   described fully in Section 5.\n   Hashed owner names of unsigned
    delegations may be excluded from the\n   chain.  An NSEC3 RR whose span covers
    the hash of an owner name or\n   \"next closer\" name of an unsigned delegation
    is referred to as an\n   Opt-Out NSEC3 RR and is indicated by the presence of
    a flag.\n   The owner name for the NSEC3 RR is the base32 encoding of the hashed\n
    \  owner name prepended as a single label to the name of the zone.\n   The type
    value for the NSEC3 RR is 50.\n   The NSEC3 RR RDATA format is class independent
    and is described\n   below.\n   The class MUST be the same as the class of the
    original owner name.\n   The NSEC3 RR SHOULD have the same TTL value as the SOA
    minimum TTL\n   field.  This is in the spirit of negative caching [RFC2308].\n"
  title: 3.  The NSEC3 Resource Record
- contents:
  - '3.1.  RDATA Fields

    '
  title: 3.1.  RDATA Fields
- contents:
  - "3.1.1.  Hash Algorithm\n   The Hash Algorithm field identifies the cryptographic
    hash algorithm\n   used to construct the hash-value.\n   The values for this field
    are defined in the NSEC3 hash algorithm\n   registry defined in Section 11.\n"
  title: 3.1.1.  Hash Algorithm
- contents:
  - "3.1.2.  Flags\n   The Flags field contains 8 one-bit flags that can be used to
    indicate\n   different processing.  All undefined flags must be zero.  The only\n
    \  flag defined by this specification is the Opt-Out flag.\n"
  title: 3.1.2.  Flags
- contents:
  - "3.1.2.1.  Opt-Out Flag\n   If the Opt-Out flag is set, the NSEC3 record covers
    zero or more\n   unsigned delegations.\n   If the Opt-Out flag is clear, the NSEC3
    record covers zero unsigned\n   delegations.\n   The Opt-Out Flag indicates whether
    this NSEC3 RR may cover unsigned\n   delegations.  It is the least significant
    bit in the Flags field.\n   See Section 6 for details about the use of this flag.\n"
  title: 3.1.2.1.  Opt-Out Flag
- contents:
  - "3.1.3.  Iterations\n   The Iterations field defines the number of additional
    times the hash\n   function has been performed.  More iterations result in greater\n
    \  resiliency of the hash value against dictionary attacks, but at a\n   higher
    computational cost for both the server and resolver.  See\n   Section 5 for details
    of the use of this field, and Section 10.3 for\n   limitations on the value.\n"
  title: 3.1.3.  Iterations
- contents:
  - "3.1.4.  Salt Length\n   The Salt Length field defines the length of the Salt
    field in octets,\n   ranging in value from 0 to 255.\n"
  title: 3.1.4.  Salt Length
- contents:
  - "3.1.5.  Salt\n   The Salt field is appended to the original owner name before
    hashing\n   in order to defend against pre-calculated dictionary attacks.  See\n
    \  Section 5 for details on how the salt is used.\n"
  title: 3.1.5.  Salt
- contents:
  - "3.1.6.  Hash Length\n   The Hash Length field defines the length of the Next
    Hashed Owner\n   Name field, ranging in value from 1 to 255 octets.\n"
  title: 3.1.6.  Hash Length
- contents:
  - "3.1.7.  Next Hashed Owner Name\n   The Next Hashed Owner Name field contains
    the next hashed owner name\n   in hash order.  This value is in binary format.
    \ Given the ordered\n   set of all hashed owner names, the Next Hashed Owner Name
    field\n   contains the hash of an owner name that immediately follows the owner\n
    \  name of the given NSEC3 RR.  The value of the Next Hashed Owner Name\n   field
    in the last NSEC3 RR in the zone is the same as the hashed\n   owner name of the
    first NSEC3 RR in the zone in hash order.  Note\n   that, unlike the owner name
    of the NSEC3 RR, the value of this field\n   does not contain the appended zone
    name.\n"
  title: 3.1.7.  Next Hashed Owner Name
- contents:
  - "3.1.8.  Type Bit Maps\n   The Type Bit Maps field identifies the RRSet types
    that exist at the\n   original owner name of the NSEC3 RR.\n"
  title: 3.1.8.  Type Bit Maps
- contents:
  - "3.2.  NSEC3 RDATA Wire Format\n   The RDATA of the NSEC3 RR is as shown below:\n
    \                       1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2
    3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |   Hash Alg.   |     Flags     |          Iterations           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |  Salt Length  |                     Salt                      /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |  Hash Length  |             Next Hashed Owner Name            /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  /                         Type Bit Maps                         /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  Hash Algorithm is a single octet.\n   Flags field is a single octet, the Opt-Out
    flag is the least\n   significant bit, as shown below:\n    0 1 2 3 4 5 6 7\n
    \  +-+-+-+-+-+-+-+-+\n   |             |O|\n   +-+-+-+-+-+-+-+-+\n   Iterations
    is represented as a 16-bit unsigned integer, with the most\n   significant bit
    first.\n   Salt Length is represented as an unsigned octet.  Salt Length\n   represents
    the length of the Salt field in octets.  If the value is\n   zero, the following
    Salt field is omitted.\n   Salt, if present, is encoded as a sequence of binary
    octets.  The\n   length of this field is determined by the preceding Salt Length\n
    \  field.\n   Hash Length is represented as an unsigned octet.  Hash Length\n
    \  represents the length of the Next Hashed Owner Name field in octets.\n   The
    next hashed owner name is not base32 encoded, unlike the owner\n   name of the
    NSEC3 RR.  It is the unmodified binary hash value.  It\n   does not include the
    name of the containing zone.  The length of this\n   field is determined by the
    preceding Hash Length field.\n"
  title: 3.2.  NSEC3 RDATA Wire Format
- contents:
  - "3.2.1.  Type Bit Maps Encoding\n   The encoding of the Type Bit Maps field is
    the same as that used by\n   the NSEC RR, described in [RFC4034].  It is explained
    and clarified\n   here for clarity.\n   The RR type space is split into 256 window
    blocks, each representing\n   the low-order 8 bits of the 16-bit RR type space.
    \ Each block that\n   has at least one active RR type is encoded using a single
    octet\n   window number (from 0 to 255), a single octet bitmap length (from 1\n
    \  to 32) indicating the number of octets used for the bitmap of the\n   window
    block, and up to 32 octets (256 bits) of bitmap.\n   Blocks are present in the
    NSEC3 RR RDATA in increasing numerical\n   order.\n      Type Bit Maps Field =
    ( Window Block # | Bitmap Length | Bitmap )+\n      where \"|\" denotes concatenation.\n
    \  Each bitmap encodes the low-order 8 bits of RR types within the\n   window
    block, in network bit order.  The first bit is bit 0.  For\n   window block 0,
    bit 1 corresponds to RR type 1 (A), bit 2 corresponds\n   to RR type 2 (NS), and
    so forth.  For window block 1, bit 1\n   corresponds to RR type 257, bit 2 to
    RR type 258.  If a bit is set to\n   1, it indicates that an RRSet of that type
    is present for the\n   original owner name of the NSEC3 RR.  If a bit is set to
    0, it\n   indicates that no RRSet of that type is present for the original\n   owner
    name of the NSEC3 RR.\n   Since bit 0 in window block 0 refers to the non-existing
    RR type 0,\n   it MUST be set to 0.  After verification, the validator MUST ignore\n
    \  the value of bit 0 in window block 0.\n   Bits representing Meta-TYPEs or QTYPEs
    as specified in Section 3.1 of\n   [RFC2929] or within the range reserved for
    assignment only to QTYPEs\n   and Meta-TYPEs MUST be set to 0, since they do not
    appear in zone\n   data.  If encountered, they must be ignored upon reading.\n
    \  Blocks with no types present MUST NOT be included.  Trailing zero\n   octets
    in the bitmap MUST be omitted.  The length of the bitmap of\n   each block is
    determined by the type code with the largest numerical\n   value, within that
    block, among the set of RR types present at the\n   original owner name of the
    NSEC3 RR.  Trailing octets not specified\n   MUST be interpreted as zero octets.\n"
  title: 3.2.1.  Type Bit Maps Encoding
- contents:
  - "3.3.  Presentation Format\n   The presentation format of the RDATA portion is
    as follows:\n   o  The Hash Algorithm field is represented as an unsigned decimal\n
    \     integer.  The value has a maximum of 255.\n   o  The Flags field is represented
    as an unsigned decimal integer.\n      The value has a maximum of 255.\n   o  The
    Iterations field is represented as an unsigned decimal\n      integer.  The value
    is between 0 and 65535, inclusive.\n   o  The Salt Length field is not represented.\n
    \  o  The Salt field is represented as a sequence of case-insensitive\n      hexadecimal
    digits.  Whitespace is not allowed within the\n      sequence.  The Salt field
    is represented as \"-\" (without the\n      quotes) when the Salt Length field
    has a value of 0.\n   o  The Hash Length field is not represented.\n   o  The
    Next Hashed Owner Name field is represented as an unpadded\n      sequence of
    case-insensitive base32 digits, without whitespace.\n   o  The Type Bit Maps field
    is represented as a sequence of RR type\n      mnemonics.  When the mnemonic is
    not known, the TYPE\n      representation as described in Section 5 of [RFC3597]
    MUST be\n      used.\n"
  title: 3.3.  Presentation Format
- contents:
  - "4.  The NSEC3PARAM Resource Record\n   The NSEC3PARAM RR contains the NSEC3 parameters
    (hash algorithm,\n   flags, iterations, and salt) needed by authoritative servers
    to\n   calculate hashed owner names.  The presence of an NSEC3PARAM RR at a\n
    \  zone apex indicates that the specified parameters may be used by\n   authoritative
    servers to choose an appropriate set of NSEC3 RRs for\n   negative responses.
    \ The NSEC3PARAM RR is not used by validators or\n   resolvers.\n   If an NSEC3PARAM
    RR is present at the apex of a zone with a Flags\n   field value of zero, then
    there MUST be an NSEC3 RR using the same\n   hash algorithm, iterations, and salt
    parameters present at every\n   hashed owner name in the zone.  That is, the zone
    MUST contain a\n   complete set of NSEC3 RRs with the same hash algorithm, iterations,\n
    \  and salt parameters.\n   The owner name for the NSEC3PARAM RR is the name of
    the zone apex.\n   The type value for the NSEC3PARAM RR is 51.\n   The NSEC3PARAM
    RR RDATA format is class independent and is described\n   below.\n   The class
    MUST be the same as the NSEC3 RRs to which this RR refers.\n"
  title: 4.  The NSEC3PARAM Resource Record
- contents:
  - "4.1.  RDATA Fields\n   The RDATA for this RR mirrors the first four fields in
    the NSEC3 RR.\n"
  title: 4.1.  RDATA Fields
- contents:
  - "4.1.1.  Hash Algorithm\n   The Hash Algorithm field identifies the cryptographic
    hash algorithm\n   used to construct the hash-value.\n   The acceptable values
    are the same as the corresponding field in the\n   NSEC3 RR.\n"
  title: 4.1.1.  Hash Algorithm
- contents:
  - "4.1.2.  Flag Fields\n   The Opt-Out flag is not used and is set to zero.\n   All
    other flags are reserved for future use, and must be zero.\n   NSEC3PARAM RRs
    with a Flags field value other than zero MUST be\n   ignored.\n"
  title: 4.1.2.  Flag Fields
- contents:
  - "4.1.3.  Iterations\n   The Iterations field defines the number of additional
    times the hash\n   is performed.\n   Its acceptable values are the same as the
    corresponding field in the\n   NSEC3 RR.\n"
  title: 4.1.3.  Iterations
- contents:
  - "4.1.4.  Salt Length\n   The Salt Length field defines the length of the salt
    in octets,\n   ranging in value from 0 to 255.\n"
  title: 4.1.4.  Salt Length
- contents:
  - "4.1.5.  Salt\n   The Salt field is appended to the original owner name before
    hashing.\n"
  title: 4.1.5.  Salt
- contents:
  - "4.2.  NSEC3PARAM RDATA Wire Format\n   The RDATA of the NSEC3PARAM RR is as shown
    below:\n                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |   Hash Alg.   |     Flags     |          Iterations           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |  Salt Length  |                     Salt                      /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  Hash Algorithm is a single octet.\n   Flags field is a single octet.\n   Iterations
    is represented as a 16-bit unsigned integer, with the most\n   significant bit
    first.\n   Salt Length is represented as an unsigned octet.  Salt Length\n   represents
    the length of the following Salt field in octets.  If the\n   value is zero, the
    Salt field is omitted.\n   Salt, if present, is encoded as a sequence of binary
    octets.  The\n   length of this field is determined by the preceding Salt Length\n
    \  field.\n"
  title: 4.2.  NSEC3PARAM RDATA Wire Format
- contents:
  - "4.3.  Presentation Format\n   The presentation format of the RDATA portion is
    as follows:\n   o  The Hash Algorithm field is represented as an unsigned decimal\n
    \     integer.  The value has a maximum of 255.\n   o  The Flags field is represented
    as an unsigned decimal integer.\n      The value has a maximum value of 255.\n
    \  o  The Iterations field is represented as an unsigned decimal\n      integer.
    \ The value is between 0 and 65535, inclusive.\n   o  The Salt Length field is
    not represented.\n   o  The Salt field is represented as a sequence of case-insensitive\n
    \     hexadecimal digits.  Whitespace is not allowed within the\n      sequence.
    \ This field is represented as \"-\" (without the quotes)\n      when the Salt
    Length field is zero.\n"
  title: 4.3.  Presentation Format
- contents:
  - "5.  Calculation of the Hash\n   The hash calculation uses three of the NSEC3
    RDATA fields: Hash\n   Algorithm, Salt, and Iterations.\n   Define H(x) to be
    the hash of x using the Hash Algorithm selected by\n   the NSEC3 RR, k to be the
    number of Iterations, and || to indicate\n   concatenation.  Then define:\n      IH(salt,
    x, 0) = H(x || salt), and\n      IH(salt, x, k) = H(IH(salt, x, k-1) || salt),
    if k > 0\n   Then the calculated hash of an owner name is\n      IH(salt, owner
    name, iterations),\n   where the owner name is in the canonical form, defined
    as:\n   The wire format of the owner name where:\n   1.  The owner name is fully
    expanded (no DNS name compression) and\n       fully qualified;\n   2.  All uppercase
    US-ASCII letters are replaced by the corresponding\n       lowercase US-ASCII
    letters;\n   3.  If the owner name is a wildcard name, the owner name is in its\n
    \      original unexpanded form, including the \"*\" label (no wildcard\n       substitution);\n
    \  This form is as defined in Section 6.2 of [RFC4034].\n   The method to calculate
    the Hash is based on [RFC2898].\n"
  title: 5.  Calculation of the Hash
- contents:
  - "6.  Opt-Out\n   In this specification, as in [RFC4033], [RFC4034] and [RFC4035],
    NS\n   RRSets at delegation points are not signed and may be accompanied by\n
    \  a DS RRSet.  With the Opt-Out bit clear, the security status of the\n   child
    zone is determined by the presence or absence of this DS RRSet,\n   cryptographically
    proven by the signed NSEC3 RR at the hashed owner\n   name of the delegation.
    \ Setting the Opt-Out flag modifies this by\n   allowing insecure delegations
    to exist within the signed zone without\n   a corresponding NSEC3 RR at the hashed
    owner name of the delegation.\n   An Opt-Out NSEC3 RR is said to cover a delegation
    if the hash of the\n   owner name or \"next closer\" name of the delegation is
    between the\n   owner name of the NSEC3 RR and the next hashed owner name.\n   An
    Opt-Out NSEC3 RR does not assert the existence or non-existence of\n   the insecure
    delegations that it may cover.  This allows for the\n   addition or removal of
    these delegations without recalculating or re-\n   signing RRs in the NSEC3 RR
    chain.  However, Opt-Out NSEC3 RRs do\n   assert the (non)existence of other,
    authoritative RRSets.\n   An Opt-Out NSEC3 RR MAY have the same original owner
    name as an\n   insecure delegation.  In this case, the delegation is proven insecure\n
    \  by the lack of a DS bit in the type map and the signed NSEC3 RR does\n   assert
    the existence of the delegation.\n   Zones using Opt-Out MAY contain a mixture
    of Opt-Out NSEC3 RRs and\n   non-Opt-Out NSEC3 RRs.  If an NSEC3 RR is not Opt-Out,
    there MUST NOT\n   be any hashed owner names of insecure delegations (nor any
    other RRs)\n   between it and the name indicated by the next hashed owner name
    in\n   the NSEC3 RDATA.  If it is Opt-Out, it MUST only cover hashed owner\n   names
    or hashed \"next closer\" names of insecure delegations.\n   The effects of the
    Opt-Out flag on signing, serving, and validating\n   responses are covered in
    following sections.\n"
  title: 6.  Opt-Out
- contents:
  - '7.  Authoritative Server Considerations

    '
  title: 7.  Authoritative Server Considerations
- contents:
  - "7.1.  Zone Signing\n   Zones using NSEC3 must satisfy the following properties:\n
    \  o  Each owner name within the zone that owns authoritative RRSets\n      MUST
    have a corresponding NSEC3 RR.  Owner names that correspond\n      to unsigned
    delegations MAY have a corresponding NSEC3 RR.\n      However, if there is not
    a corresponding NSEC3 RR, there MUST be\n      an Opt-Out NSEC3 RR that covers
    the \"next closer\" name to the\n      delegation.  Other non-authoritative RRs
    are not represented by\n      NSEC3 RRs.\n   o  Each empty non-terminal MUST have
    a corresponding NSEC3 RR, unless\n      the empty non-terminal is only derived
    from an insecure delegation\n      covered by an Opt-Out NSEC3 RR.\n   o  The
    TTL value for any NSEC3 RR SHOULD be the same as the minimum\n      TTL value
    field in the zone SOA RR.\n   o  The Type Bit Maps field of every NSEC3 RR in
    a signed zone MUST\n      indicate the presence of all types present at the original
    owner\n      name, except for the types solely contributed by an NSEC3 RR\n      itself.
    \ Note that this means that the NSEC3 type itself will\n      never be present
    in the Type Bit Maps.\n   The following steps describe a method of proper construction
    of NSEC3\n   RRs.  This is not the only such possible method.\n   1.  Select the
    hash algorithm and the values for salt and iterations.\n   2.  For each unique
    original owner name in the zone add an NSEC3 RR.\n       *  If Opt-Out is being
    used, owner names of unsigned delegations\n          MAY be excluded.\n       *
    \ The owner name of the NSEC3 RR is the hash of the original\n          owner
    name, prepended as a single label to the zone name.\n       *  The Next Hashed
    Owner Name field is left blank for the moment.\n       *  If Opt-Out is being
    used, set the Opt-Out bit to one.\n       *  For collision detection purposes,
    optionally keep track of the\n          original owner name with the NSEC3 RR.\n
    \      *  Additionally, for collision detection purposes, optionally\n          create
    an additional NSEC3 RR corresponding to the original\n          owner name with
    the asterisk label prepended (i.e., as if a\n          wildcard existed as a child
    of this owner name) and keep track\n          of this original owner name.  Mark
    this NSEC3 RR as temporary.\n   3.  For each RRSet at the original owner name,
    set the corresponding\n       bit in the Type Bit Maps field.\n   4.  If the difference
    in number of labels between the apex and the\n       original owner name is greater
    than 1, additional NSEC3 RRs need\n       to be added for every empty non-terminal
    between the apex and the\n       original owner name.  This process may generate
    NSEC3 RRs with\n       duplicate hashed owner names.  Optionally, for collision\n
    \      detection, track the original owner names of these NSEC3 RRs and\n       create
    temporary NSEC3 RRs for wildcard collisions in a similar\n       fashion to step
    1.\n   5.  Sort the set of NSEC3 RRs into hash order.\n   6.  Combine NSEC3 RRs
    with identical hashed owner names by replacing\n       them with a single NSEC3
    RR with the Type Bit Maps field\n       consisting of the union of the types represented
    by the set of\n       NSEC3 RRs.  If the original owner name was tracked, then\n
    \      collisions may be detected when combining, as all of the matching\n       NSEC3
    RRs should have the same original owner name.  Discard any\n       possible temporary
    NSEC3 RRs.\n   7.  In each NSEC3 RR, insert the next hashed owner name by using
    the\n       value of the next NSEC3 RR in hash order.  The next hashed owner\n
    \      name of the last NSEC3 RR in the zone contains the value of the\n       hashed
    owner name of the first NSEC3 RR in the hash order.\n   8.  Finally, add an NSEC3PARAM
    RR with the same Hash Algorithm,\n       Iterations, and Salt fields to the zone
    apex.\n   If a hash collision is detected, then a new salt has to be chosen,\n
    \  and the signing process restarted.\n"
  title: 7.1.  Zone Signing
- contents:
  - "7.2.  Zone Serving\n   This specification modifies DNSSEC-enabled DNS responses
    generated by\n   authoritative servers.  In particular, it replaces the use of
    NSEC\n   RRs in such responses with NSEC3 RRs.\n   In the following response cases,
    the NSEC RRs dictated by DNSSEC\n   [RFC4035] are replaced with NSEC3 RRs that
    prove the same facts.\n   Responses that would not contain NSEC RRs are unchanged
    by this\n   specification.\n   When returning responses containing multiple NSEC3
    RRs, all of the\n   NSEC3 RRs MUST use the same hash algorithm, iteration, and
    salt\n   values.  The Flags field value MUST be either zero or one.\n"
  title: 7.2.  Zone Serving
- contents:
  - "7.2.1.  Closest Encloser Proof\n   For many NSEC3 responses a proof of the closest
    encloser is required.\n   This is a proof that some ancestor of the QNAME is the
    closest\n   encloser of QNAME.\n   This proof consists of (up to) two different
    NSEC3 RRs:\n   o  An NSEC3 RR that matches the closest (provable) encloser.\n
    \  o  An NSEC3 RR that covers the \"next closer\" name to the closest\n      encloser.\n
    \  The first NSEC3 RR essentially proposes a possible closest encloser,\n   and
    proves that the particular encloser does, in fact, exist.  The\n   second NSEC3
    RR proves that the possible closest encloser is the\n   closest, and proves that
    the QNAME (and any ancestors between QNAME\n   and the closest encloser) does
    not exist.\n   These NSEC3 RRs are collectively referred to as the \"closest encloser\n
    \  proof\" in the subsequent descriptions.\n   For example, the closest encloser
    proof for the nonexistent\n   \"alpha.beta.gamma.example.\" owner name might prove
    that\n   \"gamma.example.\" is the closest encloser.  This response would\n   contain
    the NSEC3 RR that matches \"gamma.example.\", and would also\n   contain the NSEC3
    RR that covers \"beta.gamma.example.\" (which is the\n   \"next closer\" name).\n
    \  It is possible, when using Opt-Out (Section 6), to not be able to\n   prove
    the actual closest encloser because it is, or is part of an\n   insecure delegation
    covered by an Opt-Out span.  In this case,\n   instead of proving the actual closest
    encloser, the closest provable\n   encloser is used.  That is, the closest enclosing
    authoritative name\n   is used instead.  In this case, the set of NSEC3 RRs used
    for this\n   proof is referred to as the \"closest provable encloser proof\".\n"
  title: 7.2.1.  Closest Encloser Proof
- contents:
  - "7.2.2.  Name Error Responses\n   To prove the nonexistence of QNAME, a closest
    encloser proof and an\n   NSEC3 RR covering the (nonexistent) wildcard RR at the
    closest\n   encloser MUST be included in the response.  This collection of (up\n
    \  to) three NSEC3 RRs proves both that QNAME does not exist and that a\n   wildcard
    that could have matched QNAME also does not exist.\n   For example, if \"gamma.example.\"
    is the closest provable encloser to\n   QNAME, then an NSEC3 RR covering \"*.gamma.example.\"
    is included in\n   the authority section of the response.\n"
  title: 7.2.2.  Name Error Responses
- contents:
  - "7.2.3.  No Data Responses, QTYPE is not DS\n   The server MUST include the NSEC3
    RR that matches QNAME.  This NSEC3\n   RR MUST NOT have the bits corresponding
    to either the QTYPE or CNAME\n   set in its Type Bit Maps field.\n"
  title: 7.2.3.  No Data Responses, QTYPE is not DS
- contents:
  - "7.2.4.  No Data Responses, QTYPE is DS\n   If there is an NSEC3 RR that matches
    QNAME, the server MUST return it\n   in the response.  The bits corresponding
    with DS and CNAME MUST NOT\n   be set in the Type Bit Maps field of this NSEC3
    RR.\n   If no NSEC3 RR matches QNAME, the server MUST return a closest\n   provable
    encloser proof for QNAME.  The NSEC3 RR that covers the\n   \"next closer\" name
    MUST have the Opt-Out bit set (note that this is\n   true by definition -- if
    the Opt-Out bit is not set, something has\n   gone wrong).\n   If a server is
    authoritative for both sides of a zone cut at QNAME,\n   the server MUST return
    the proof from the parent side of the zone\n   cut.\n"
  title: 7.2.4.  No Data Responses, QTYPE is DS
- contents:
  - "7.2.5.  Wildcard No Data Responses\n   If there is a wildcard match for QNAME,
    but QTYPE is not present at\n   that name, the response MUST include a closest
    encloser proof for\n   QNAME and MUST include the NSEC3 RR that matches the wildcard.
    \ This\n   combination proves both that QNAME itself does not exist and that a\n
    \  wildcard that matches QNAME does exist.  Note that the closest\n   encloser
    to QNAME MUST be the immediate ancestor of the wildcard RR\n   (if this is not
    the case, then something has gone wrong).\n"
  title: 7.2.5.  Wildcard No Data Responses
- contents:
  - "7.2.6.  Wildcard Answer Responses\n   If there is a wildcard match for QNAME
    and QTYPE, then, in addition\n   to the expanded wildcard RRSet returned in the
    answer section of the\n   response, proof that the wildcard match was valid must
    be returned.\n   This proof is accomplished by proving that both QNAME does not
    exist\n   and that the closest encloser of the QNAME and the immediate ancestor\n
    \  of the wildcard are the same (i.e., the correct wildcard matched).\n   To this
    end, the NSEC3 RR that covers the \"next closer\" name of the\n   immediate ancestor
    of the wildcard MUST be returned.  It is not\n   necessary to return an NSEC3
    RR that matches the closest encloser, as\n   the existence of this closest encloser
    is proven by the presence of\n   the expanded wildcard in the response.\n"
  title: 7.2.6.  Wildcard Answer Responses
- contents:
  - "7.2.7.  Referrals to Unsigned Subzones\n   If there is an NSEC3 RR that matches
    the delegation name, then that\n   NSEC3 RR MUST be included in the response.
    \ The DS bit in the type\n   bit maps of the NSEC3 RR MUST NOT be set.\n   If
    the zone is Opt-Out, then there may not be an NSEC3 RR\n   corresponding to the
    delegation.  In this case, the closest provable\n   encloser proof MUST be included
    in the response.  The included NSEC3\n   RR that covers the \"next closer\" name
    for the delegation MUST have\n   the Opt-Out flag set to one.  (Note that this
    will be the case unless\n   something has gone wrong).\n"
  title: 7.2.7.  Referrals to Unsigned Subzones
- contents:
  - "7.2.8.  Responding to Queries for NSEC3 Owner Names\n   The owner names of NSEC3
    RRs are not represented in the NSEC3 RR\n   chain like other owner names.  As
    a result, each NSEC3 owner name is\n   covered by another NSEC3 RR, effectively
    negating the existence of\n   the NSEC3 RR.  This is a paradox, since the existence
    of an NSEC3 RR\n   can be proven by its RRSIG RRSet.\n   If the following conditions
    are all true:\n   o  the QNAME equals the owner name of an existing NSEC3 RR,
    and\n   o  no RR types exist at the QNAME, nor at any descendant of QNAME,\n   then
    the response MUST be constructed as a Name Error response\n   (Section 7.2.2).
    \ Or, in other words, the authoritative name server\n   will act as if the owner
    name of the NSEC3 RR did not exist.\n   Note that NSEC3 RRs are returned as a
    result of an AXFR or IXFR\n   query.\n"
  title: 7.2.8.  Responding to Queries for NSEC3 Owner Names
- contents:
  - "7.2.9.  Server Response to a Run-Time Collision\n   If the hash of a non-existing
    QNAME collides with the owner name of\n   an existing NSEC3 RR, then the server
    will be unable to return a\n   response that proves that QNAME does not exist.
    \ In this case, the\n   server MUST return a response with an RCODE of 2 (server
    failure).\n   Note that with the hash algorithm specified in this document, SHA-1,\n
    \  such collisions are highly unlikely.\n"
  title: 7.2.9.  Server Response to a Run-Time Collision
- contents:
  - "7.3.  Secondary Servers\n   Secondary servers (and perhaps other entities) need
    to reliably\n   determine which NSEC3 parameters (i.e., hash, salt, and iterations)\n
    \  are present at every hashed owner name, in order to be able to choose\n   an
    appropriate set of NSEC3 RRs for negative responses.  This is\n   indicated by
    an NSEC3PARAM RR present at the zone apex.\n   If there are multiple NSEC3PARAM
    RRs present, there are multiple\n   valid NSEC3 chains present.  The server must
    choose one of them, but\n   may use any criteria to do so.\n"
  title: 7.3.  Secondary Servers
- contents:
  - "7.4.  Zones Using Unknown Hash Algorithms\n   Zones that are signed according
    to this specification, but are using\n   an unrecognized NSEC3 hash algorithm
    value, cannot be effectively\n   served.  Such zones SHOULD be rejected when loading.
    \ Servers SHOULD\n   respond with RCODE=2 (server failure) responses when handling
    queries\n   that would fall under such zones.\n"
  title: 7.4.  Zones Using Unknown Hash Algorithms
- contents:
  - "7.5.  Dynamic Update\n   A zone signed using NSEC3 may accept dynamic updates
    [RFC2136].\n   However, NSEC3 introduces some special considerations for dynamic\n
    \  updates.\n   Adding and removing names in a zone MUST account for the creation
    or\n   removal of empty non-terminals.\n   o  When removing a name with a corresponding
    NSEC3 RR, any NSEC3 RRs\n      corresponding to empty non-terminals created by
    that name MUST be\n      removed.  Note that more than one name may be asserting
    the\n      existence of a particular empty non-terminal.\n   o  When adding a
    name that requires adding an NSEC3 RR, NSEC3 RRs\n      MUST also be added for
    any empty non-terminals that are created.\n      That is, if there is not an existing
    NSEC3 RR matching an empty\n      non-terminal, it must be created and added.\n
    \  The presence of Opt-Out in a zone means that some additions or\n   delegations
    of names will not require changes to the NSEC3 RRs in a\n   zone.\n   o  When
    removing a delegation RRSet, if that delegation does not have\n      a matching
    NSEC3 RR, then it was opted out.  In this case, nothing\n      further needs to
    be done.\n   o  When adding a delegation RRSet, if the \"next closer\" name of
    the\n      delegation is covered by an existing Opt-Out NSEC3 RR, then the\n      delegation
    MAY be added without modifying the NSEC3 RRs in the\n      zone.\n   The presence
    of Opt-Out in a zone means that when adding or removing\n   NSEC3 RRs, the value
    of the Opt-Out flag that should be set in new or\n   modified NSEC3 RRs is ambiguous.
    \ Servers SHOULD follow this set of\n   basic rules to resolve the ambiguity.\n
    \  The central concept to these rules is that the state of the Opt-Out\n   flag
    of the covering NSEC3 RR is preserved.\n   o  When removing an NSEC3 RR, the value
    of the Opt-Out flag for the\n      previous NSEC3 RR (the one whose next hashed
    owner name is\n      modified) should not be changed.\n   o  When adding an NSEC3
    RR, the value of the Opt-Out flag is set to\n      the value of the Opt-Out flag
    of the NSEC3 RR that previously\n      covered the owner name of the NSEC3 RR.
    \ That is, the now previous\n      NSEC3 RR.\n   If the zone in question is consistent
    with its use of the Opt-Out\n   flag (that is, all NSEC3 RRs in the zone have
    the same value for the\n   flag) then these rules will retain that consistency.
    \ If the zone is\n   not consistent in the use of the flag (i.e., a partially
    Opt-Out\n   zone), then these rules will not retain the same pattern of use of\n
    \  the Opt-Out flag.\n   For zones that partially use the Opt-Out flag, if there
    is a logical\n   pattern for that use, the pattern could be maintained by using
    a\n   local policy on the server.\n"
  title: 7.5.  Dynamic Update
- contents:
  - '8.  Validator Considerations

    '
  title: 8.  Validator Considerations
- contents:
  - "8.1.  Responses with Unknown Hash Types\n   A validator MUST ignore NSEC3 RRs
    with unknown hash types.  The\n   practical result of this is that responses containing
    only such NSEC3\n   RRs will generally be considered bogus.\n"
  title: 8.1.  Responses with Unknown Hash Types
- contents:
  - "8.2.  Verifying NSEC3 RRs\n   A validator MUST ignore NSEC3 RRs with a Flag fields
    value other than\n   zero or one.\n   A validator MAY treat a response as bogus
    if the response contains\n   NSEC3 RRs that contain different values for hash
    algorithm,\n   iterations, or salt from each other for that zone.\n"
  title: 8.2.  Verifying NSEC3 RRs
- contents:
  - "8.3.  Closest Encloser Proof\n   In order to verify a closest encloser proof,
    the validator MUST find\n   the longest name, X, such that\n   o  X is an ancestor
    of QNAME that is matched by an NSEC3 RR present\n      in the response.  This
    is a candidate for the closest encloser,\n      and\n   o  The name one label
    longer than X (but still an ancestor of -- or\n      equal to -- QNAME) is covered
    by an NSEC3 RR present in the\n      response.\n   One possible algorithm for
    verifying this proof is as follows:\n   1.  Set SNAME=QNAME.  Clear the flag.\n
    \  2.  Check whether SNAME exists:\n       *  If there is no NSEC3 RR in the response
    that matches SNAME\n          (i.e., an NSEC3 RR whose owner name is the same
    as the hash of\n          SNAME, prepended as a single label to the zone name),
    clear\n          the flag.\n       *  If there is an NSEC3 RR in the response
    that covers SNAME, set\n          the flag.\n       *  If there is a matching
    NSEC3 RR in the response and the flag\n          was set, then the proof is complete,
    and SNAME is the closest\n          encloser.\n       *  If there is a matching
    NSEC3 RR in the response, but the flag\n          is not set, then the response
    is bogus.\n   3.  Truncate SNAME by one label from the left, go to step 2.\n   Once
    the closest encloser has been discovered, the validator MUST\n   check that the
    NSEC3 RR that has the closest encloser as the original\n   owner name is from
    the proper zone.  The DNAME type bit must not be\n   set and the NS type bit may
    only be set if the SOA type bit is set.\n   If this is not the case, it would
    be an indication that an attacker\n   is using them to falsely deny the existence
    of RRs for which the\n   server is not authoritative.\n   In the following descriptions,
    the phrase \"a closest (provable)\n   encloser proof for X\" means that the algorithm
    above (or an\n   equivalent algorithm) proves that X does not exist by proving
    that an\n   ancestor of X is its closest encloser.\n"
  title: 8.3.  Closest Encloser Proof
- contents:
  - "8.4.  Validating Name Error Responses\n   A validator MUST verify that there
    is a closest encloser proof for\n   QNAME present in the response and that there
    is an NSEC3 RR that\n   covers the wildcard at the closest encloser (i.e., the
    name formed by\n   prepending the asterisk label to the closest encloser).\n"
  title: 8.4.  Validating Name Error Responses
- contents:
  - "8.5.  Validating No Data Responses, QTYPE is not DS\n   The validator MUST verify
    that an NSEC3 RR that matches QNAME is\n   present and that both the QTYPE and
    the CNAME type are not set in its\n   Type Bit Maps field.\n   Note that this
    test also covers the case where the NSEC3 RR exists\n   because it corresponds
    to an empty non-terminal, in which case the\n   NSEC3 RR will have an empty Type
    Bit Maps field.\n"
  title: 8.5.  Validating No Data Responses, QTYPE is not DS
- contents:
  - "8.6.  Validating No Data Responses, QTYPE is DS\n   If there is an NSEC3 RR that
    matches QNAME present in the response,\n   then that NSEC3 RR MUST NOT have the
    bits corresponding to DS and\n   CNAME set in its Type Bit Maps field.\n   If
    there is no such NSEC3 RR, then the validator MUST verify that a\n   closest provable
    encloser proof for QNAME is present in the response,\n   and that the NSEC3 RR
    that covers the \"next closer\" name has the Opt-\n   Out bit set.\n"
  title: 8.6.  Validating No Data Responses, QTYPE is DS
- contents:
  - "8.7.  Validating Wildcard No Data Responses\n   The validator MUST verify a closest
    encloser proof for QNAME and MUST\n   find an NSEC3 RR present in the response
    that matches the wildcard\n   name generated by prepending the asterisk label
    to the closest\n   encloser.  Furthermore, the bits corresponding to both QTYPE
    and\n   CNAME MUST NOT be set in the wildcard matching NSEC3 RR.\n"
  title: 8.7.  Validating Wildcard No Data Responses
- contents:
  - "8.8.  Validating Wildcard Answer Responses\n   The verified wildcard answer RRSet
    in the response provides the\n   validator with a (candidate) closest encloser
    for QNAME.  This\n   closest encloser is the immediate ancestor to the generating\n
    \  wildcard.\n   Validators MUST verify that there is an NSEC3 RR that covers
    the\n   \"next closer\" name to QNAME present in the response.  This proves\n
    \  that QNAME itself did not exist and that the correct wildcard was\n   used
    to generate the response.\n"
  title: 8.8.  Validating Wildcard Answer Responses
- contents:
  - "8.9.  Validating Referrals to Unsigned Subzones\n   The delegation name in a
    referral is the owner name of the NS RRSet\n   present in the authority section
    of the referral response.\n   If there is an NSEC3 RR present in the response
    that matches the\n   delegation name, then the validator MUST ensure that the
    NS bit is\n   set and that the DS bit is not set in the Type Bit Maps field of
    the\n   NSEC3 RR.  The validator MUST also ensure that the NSEC3 RR is from\n
    \  the correct (i.e., parent) zone.  This is done by ensuring that the\n   SOA
    bit is not set in the Type Bit Maps field of this NSEC3 RR.\n   Note that the
    presence of an NS bit implies the absence of a DNAME\n   bit, so there is no need
    to check for the DNAME bit in the Type Bit\n   Maps field of the NSEC3 RR.\n   If
    there is no NSEC3 RR present that matches the delegation name,\n   then the validator
    MUST verify a closest provable encloser proof for\n   the delegation name.  The
    validator MUST verify that the Opt-Out bit\n   is set in the NSEC3 RR that covers
    the \"next closer\" name to the\n   delegation name.\n"
  title: 8.9.  Validating Referrals to Unsigned Subzones
- contents:
  - '9.  Resolver Considerations

    '
  title: 9.  Resolver Considerations
- contents:
  - "9.1.  NSEC3 Resource Record Caching\n   Caching resolvers MUST be able to retrieve
    the appropriate NSEC3 RRs\n   when returning responses that contain them.  In
    DNSSEC [RFC4035], in\n   many cases it is possible to find the correct NSEC RR
    to return in a\n   response by name (e.g., when returning a referral, the NSEC
    RR will\n   always have the same owner name as the delegation).  With this\n   specification,
    that will not be true, nor will a cache be able to\n   calculate the name(s) of
    the appropriate NSEC3 RR(s).\n   Implementations may need to use new methods for
    caching and\n   retrieving NSEC3 RRs.\n"
  title: 9.1.  NSEC3 Resource Record Caching
- contents:
  - "9.2.  Use of the AD Bit\n   The AD bit, as defined by [RFC4035], MUST NOT be
    set when returning a\n   response containing a closest (provable) encloser proof
    in which the\n   NSEC3 RR that covers the \"next closer\" name has the Opt-Out
    bit set.\n   This rule is based on what this closest encloser proof actually\n
    \  proves: names that would be covered by the Opt-Out NSEC3 RR may or\n   may
    not exist as insecure delegations.  As such, not all the data in\n   responses
    containing such closest encloser proofs will have been\n   cryptographically verified,
    so the AD bit cannot be set.\n"
  title: 9.2.  Use of the AD Bit
- contents:
  - '10.  Special Considerations

    '
  title: 10.  Special Considerations
- contents:
  - "10.1.  Domain Name Length Restrictions\n   Zones signed using this specification
    have additional domain name\n   length restrictions imposed upon them.  In particular,
    zones with\n   names that, when converted into hashed owner names exceed the 255\n
    \  octet length limit imposed by [RFC1035], cannot use this\n   specification.\n
    \  The actual maximum length of a domain name in a particular zone\n   depends
    on both the length of the zone name (versus the whole domain\n   name) and the
    particular hash function used.\n   As an example, SHA-1 produces a hash of 160
    bits.  The base-32\n   encoding of 160 bits results in 32 characters.  The 32
    characters are\n   prepended to the name of the zone as a single label, which
    includes a\n   length field of a single octet.  The maximum length of the zone
    name,\n   when using SHA-1, is 222 octets (255 - 33).\n"
  title: 10.1.  Domain Name Length Restrictions
- contents:
  - "10.2.  DNAME at the Zone Apex\n   The DNAME specification in Section 3 of [RFC2672]
    has a 'no-\n   descendants' limitation.  If a DNAME RR is present at node N, there\n
    \  MUST be no data at any descendant of N.\n   If N is the apex of the zone, there
    will be NSEC3 and RRSIG types\n   present at descendants of N.  This specification
    updates the DNAME\n   specification to allow NSEC3 and RRSIG types at descendants
    of the\n   apex regardless of the existence of DNAME at the apex.\n"
  title: 10.2.  DNAME at the Zone Apex
- contents:
  - "10.3.  Iterations\n   Setting the number of iterations used allows the zone owner
    to choose\n   the cost of computing a hash, and therefore the cost of generating
    a\n   dictionary.  Note that this is distinct from the effect of salt,\n   which
    prevents the use of a single precomputed dictionary for all\n   time.\n   Obviously
    the number of iterations also affects the zone owner's cost\n   of signing and
    serving the zone as well as the validator's cost of\n   verifying responses from
    the zone.  We therefore impose an upper\n   limit on the number of iterations.
    \ We base this on the number of\n   iterations that approximates the cost of verifying
    an RRSet.\n   The limits, therefore, are based on the size of the smallest zone\n
    \  signing key, rounded up to the nearest table value (or rounded down\n   if
    the key is larger than the largest table value).\n   A zone owner MUST NOT use
    a value higher than shown in the table\n   below for iterations for the given
    key size.  A resolver MAY treat a\n   response with a higher value as insecure,
    after the validator has\n   verified that the signature over the NSEC3 RR is correct.\n
    \                        +----------+------------+\n                         |
    Key Size | Iterations |\n                         +----------+------------+\n
    \                        | 1024     | 150        |\n                         |
    2048     | 500        |\n                         | 4096     | 2,500      |\n
    \                        +----------+------------+\n   This table is based on
    an approximation of the ratio between the cost\n   of an SHA-1 calculation and
    the cost of an RSA verification for keys\n   of size 1024 bits (150 to 1), 2048
    bits (500 to 1), and 4096 bits\n   (2500 to 1).\n   The ratio between SHA-1 calculation
    and DSA verification is higher\n   (1500 to 1 for keys of size 1024).  A higher
    iteration count degrades\n   performance, while DSA verification is already more
    expensive than\n   RSA for the same key size.  Therefore the values in the table
    MUST be\n   used independent of the key algorithm.\n"
  title: 10.3.  Iterations
- contents:
  - "10.4.  Transitioning a Signed Zone from NSEC to NSEC3\n   When transitioning
    an already signed and trusted zone to this\n   specification, care must be taken
    to prevent client validation\n   failures during the process.\n   The basic procedure
    is as follows:\n   1.  Transition all DNSKEYs to DNSKEYs using the algorithm aliases\n
    \      described in Section 2.  The actual method for safely and\n       securely
    changing the DNSKEY RRSet of the zone is outside the\n       scope of this specification.
    \ However, the end result MUST be\n       that all DS RRs in the parent use the
    specified algorithm\n       aliases.\n       After this transition is complete,
    all NSEC3-unaware clients will\n       treat the zone as insecure.  At this point,
    the authoritative\n       server still returns negative and wildcard responses
    that contain\n       NSEC RRs.\n   2.  Add signed NSEC3 RRs to the zone, either
    incrementally or all at\n       once.  If adding incrementally, then the last
    RRSet added MUST be\n       the NSEC3PARAM RRSet.\n   3.  Upon the addition of
    the NSEC3PARAM RRSet, the server switches to\n       serving negative and wildcard
    responses with NSEC3 RRs according\n       to this specification.\n   4.  Remove
    the NSEC RRs either incrementally or all at once.\n"
  title: 10.4.  Transitioning a Signed Zone from NSEC to NSEC3
- contents:
  - "10.5.  Transitioning a Signed Zone from NSEC3 to NSEC\n   To safely transition
    back to a DNSSEC [RFC4035] signed zone, simply\n   reverse the procedure above:\n
    \  1.  Add NSEC RRs incrementally or all at once.\n   2.  Remove the NSEC3PARAM
    RRSet.  This will signal the server to use\n       the NSEC RRs for negative and
    wildcard responses.\n   3.  Remove the NSEC3 RRs either incrementally or all at
    once.\n   4.  Transition all of the DNSKEYs to DNSSEC algorithm identifiers.\n
    \      After this transition is complete, all NSEC3-unaware clients will\n       treat
    the zone as secure.\n"
  title: 10.5.  Transitioning a Signed Zone from NSEC3 to NSEC
- contents:
  - "11.  IANA Considerations\n   Although the NSEC3 and NSEC3PARAM RR formats include
    a hash algorithm\n   parameter, this document does not define a particular mechanism
    for\n   safely transitioning from one NSEC3 hash algorithm to another.  When\n
    \  specifying a new hash algorithm for use with NSEC3, a transition\n   mechanism
    MUST also be defined.\n   This document updates the IANA registry \"DOMAIN NAME
    SYSTEM\n   PARAMETERS\" (http://www.iana.org/assignments/dns-parameters) in sub-\n
    \  registry \"TYPES\", by defining two new types.  Section 3 defines the\n   NSEC3
    RR type 50.  Section 4 defines the NSEC3PARAM RR type 51.\n   This document updates
    the IANA registry \"DNS SECURITY ALGORITHM\n   NUMBERS -- per [RFC4035]\"\n   (http://www.iana.org/assignments/dns-sec-alg-numbers).
    \ Section 2\n   defines the aliases DSA-NSEC3-SHA1 (6) and RSASHA1-NSEC3-SHA1
    (7) for\n   respectively existing registrations DSA and RSASHA1 in combination\n
    \  with NSEC3 hash algorithm SHA1.\n   Since these algorithm numbers are aliases
    for existing DNSKEY\n   algorithm numbers, the flags that exist for the original
    algorithm\n   are valid for the alias algorithm.\n   This document creates a new
    IANA registry for NSEC3 flags.  This\n   registry is named \"DNSSEC NSEC3 Flags\".
    \ The initial contents of this\n   registry are:\n     0   1   2   3   4   5   6
    \  7\n   +---+---+---+---+---+---+---+---+\n   |   |   |   |   |   |   |   |Opt|\n
    \  |   |   |   |   |   |   |   |Out|\n   +---+---+---+---+---+---+---+---+\n      bit
    7 is the Opt-Out flag.\n      bits 0 - 6 are available for assignment.\n   Assignment
    of additional NSEC3 Flags in this registry requires IETF\n   Standards Action
    [RFC2434].\n   This document creates a new IANA registry for NSEC3PARAM flags.
    \ This\n   registry is named \"DNSSEC NSEC3PARAM Flags\".  The initial contents
    of\n   this registry are:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n
    \  |   |   |   |   |   |   |   | 0 |\n   +---+---+---+---+---+---+---+---+\n      bit
    7 is reserved and must be 0.\n      bits 0 - 6 are available for assignment.\n
    \  Assignment of additional NSEC3PARAM Flags in this registry requires\n   IETF
    Standards Action [RFC2434].\n   Finally, this document creates a new IANA registry
    for NSEC3 hash\n   algorithms.  This registry is named \"DNSSEC NSEC3 Hash Algorithms\".\n
    \  The initial contents of this registry are:\n      0 is Reserved.\n      1 is
    SHA-1.\n      2-255 Available for assignment.\n   Assignment of additional NSEC3
    hash algorithms in this registry\n   requires IETF Standards Action [RFC2434].\n"
  title: 11.  IANA Considerations
- contents:
  - '12.  Security Considerations

    '
  title: 12.  Security Considerations
- contents:
  - '12.1.  Hashing Considerations

    '
  title: 12.1.  Hashing Considerations
- contents:
  - "12.1.1.  Dictionary Attacks\n   The NSEC3 RRs are still susceptible to dictionary
    attacks (i.e., the\n   attacker retrieves all the NSEC3 RRs, then calculates the
    hashes of\n   all likely domain names, comparing against the hashes found in the\n
    \  NSEC3 RRs, and thus enumerating the zone).  These are substantially\n   more
    expensive than enumerating the original NSEC RRs would have\n   been, and in any
    case, such an attack could also be used directly\n   against the name server itself
    by performing queries for all likely\n   names, though this would obviously be
    more detectable.  The expense\n   of this off-line attack can be chosen by setting
    the number of\n   iterations in the NSEC3 RR.\n   Zones are also susceptible to
    a pre-calculated dictionary attack --\n   that is, a list of hashes for all likely
    names is computed once, then\n   NSEC3 RR is scanned periodically and compared
    against the precomputed\n   hashes.  This attack is prevented by changing the
    salt on a regular\n   basis.\n   The salt SHOULD be at least 64 bits long and
    unpredictable, so that\n   an attacker cannot anticipate the value of the salt
    and compute the\n   next set of dictionaries before the zone is published.\n"
  title: 12.1.1.  Dictionary Attacks
- contents:
  - "12.1.2.  Collisions\n   Hash collisions between QNAME and the owner name of an
    NSEC3 RR may\n   occur.  When they do, it will be impossible to prove the non-\n
    \  existence of the colliding QNAME.  However, with SHA-1, this is\n   highly
    unlikely (on the order of 1 in 2^160).  Note that DNSSEC\n   already relies on
    the presumption that a cryptographic hash function\n   is second pre-image resistant,
    since these hash functions are used\n   for generating and validating signatures
    and DS RRs.\n"
  title: 12.1.2.  Collisions
- contents:
  - "12.1.3.  Transitioning to a New Hash Algorithm\n   Although the NSEC3 and NSEC3PARAM
    RR formats include a hash algorithm\n   parameter, this document does not define
    a particular mechanism for\n   safely transitioning from one NSEC3 hash algorithm
    to another.  When\n   specifying a new hash algorithm for use with NSEC3, a transition\n
    \  mechanism MUST also be defined.  It is possible that the only\n   practical
    and palatable transition mechanisms may require an\n   intermediate transition
    to an insecure state, or to a state that uses\n   NSEC records instead of NSEC3.\n"
  title: 12.1.3.  Transitioning to a New Hash Algorithm
- contents:
  - "12.1.4.  Using High Iteration Values\n   Since validators should treat responses
    containing NSEC3 RRs with\n   high iteration values as insecure, presence of just
    one signed NSEC3\n   RR with a high iteration value in a zone provides attackers
    with a\n   possible downgrade attack.\n   The attack is simply to remove any existing
    NSEC3 RRs from a\n   response, and replace or add a single (or multiple) NSEC3
    RR that\n   uses a high iterations value to the response.  Validators will then\n
    \  be forced to treat the response as insecure.  This attack would be\n   effective
    only when all of following conditions are met:\n   o  There is at least one signed
    NSEC3 RR that uses a high iterations\n      value present in the zone.\n   o  The
    attacker has access to one or more of these NSEC3 RRs.  This\n      is trivially
    true when the NSEC3 RRs with high iteration values\n      are being returned in
    typical responses, but may also be true if\n      the attacker can access the
    zone via AXFR or IXFR queries, or any\n      other methodology.\n   Using a high
    number of iterations also introduces an additional\n   denial-of-service opportunity
    against servers, since servers must\n   calculate several hashes per negative
    or wildcard response.\n"
  title: 12.1.4.  Using High Iteration Values
- contents:
  - "12.2.  Opt-Out Considerations\n   The Opt-Out Flag (O) allows for unsigned names,
    in the form of\n   delegations to unsigned zones, to exist within an otherwise
    signed\n   zone.  All unsigned names are, by definition, insecure, and their\n
    \  validity or existence cannot be cryptographically proven.\n   In general:\n
    \  o  Resource records with unsigned names (whether existing or not)\n      suffer
    from the same vulnerabilities as RRs in an unsigned zone.\n      These vulnerabilities
    are described in more detail in [RFC3833]\n      (note in particular Section 2.3,
    \"Name Chaining\" and Section 2.6,\n      \"Authenticated Denial of Domain Names\").\n
    \  o  Resource records with signed names have the same security whether\n      or
    not Opt-Out is used.\n   Note that with or without Opt-Out, an insecure delegation
    may be\n   undetectably altered by an attacker.  Because of this, the primary\n
    \  difference in security when using Opt-Out is the loss of the ability\n   to
    prove the existence or nonexistence of an insecure delegation\n   within the span
    of an Opt-Out NSEC3 RR.\n   In particular, this means that a malicious entity
    may be able to\n   insert or delete RRs with unsigned names.  These RRs are normally
    NS\n   RRs, but this also includes signed wildcard expansions (while the\n   wildcard
    RR itself is signed, its expanded name is an unsigned name).\n   Note that being
    able to add a delegation is functionally equivalent\n   to being able to add any
    RR type: an attacker merely has to forge a\n   delegation to name server under
    his/her control and place whatever\n   RRs needed at the subzone apex.\n   While
    in particular cases, this issue may not present a significant\n   security problem,
    in general it should not be lightly dismissed.\n   Therefore, it is strongly RECOMMENDED
    that Opt-Out be used sparingly.\n   In particular, zone signing tools SHOULD NOT
    default to using Opt-\n   Out, and MAY choose to not support Opt-Out at all.\n"
  title: 12.2.  Opt-Out Considerations
- contents:
  - "12.3.  Other Considerations\n   Walking the NSEC3 RRs will reveal the total number
    of RRs in the zone\n   (plus empty non-terminals), and also what types there are.
    \ This\n   could be mitigated by adding dummy entries, but certainly an upper\n
    \  limit can always be found.\n"
  title: 12.3.  Other Considerations
- contents:
  - '13.  References

    '
  title: 13.  References
- contents:
  - "13.1.  Normative References\n   [RFC1034]         Mockapetris, P., \"Domain names
    - concepts and\n                     facilities\", STD 13, RFC 1034, November
    1987.\n   [RFC1035]         Mockapetris, P., \"Domain names - implementation and\n
    \                    specification\", STD 13, RFC 1035, November 1987.\n   [RFC2119]
    \        Bradner, S., \"Key words for use in RFCs to Indicate\n                     Requirement
    Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2136]         Vixie, P., Thomson,
    S., Rekhter, Y., and J. Bound,\n                     \"Dynamic Updates in the
    Domain Name System (DNS\n                     UPDATE)\", RFC 2136, April 1997.\n
    \  [RFC2181]         Elz, R. and R. Bush, \"Clarifications to the DNS\n                     Specification\",
    RFC 2181, July 1997.\n   [RFC2308]         Andrews, M., \"Negative Caching of
    DNS Queries (DNS\n                     NCACHE)\", RFC 2308, March 1998.\n   [RFC2434]
    \        Narten, T. and H. Alvestrand, \"Guidelines for\n                     Writing
    an IANA Considerations Section in RFCs\",\n                     BCP 26, RFC 2434,
    October 1998.\n   [RFC2929]         Eastlake, D., Brunner-Williams, E., and B.
    Manning,\n                     \"Domain Name System (DNS) IANA Considerations\",\n
    \                    BCP 42, RFC 2929, September 2000.\n   [RFC3597]         Gustafsson,
    A., \"Handling of Unknown DNS Resource\n                     Record (RR) Types\",
    RFC 3597, September 2003.\n   [RFC4033]         Arends, R., Austein, R., Larson,
    M., Massey, D.,\n                     and S. Rose, \"DNS Security Introduction
    and\n                     Requirements\", RFC 4033, March 2005.\n   [RFC4034]
    \        Arends, R., Austein, R., Larson, M., Massey, D.,\n                     and
    S. Rose, \"Resource Records for the DNS Security\n                     Extensions\",
    RFC 4034, March 2005.\n   [RFC4035]         Arends, R., Austein, R., Larson, M.,
    Massey, D.,\n                     and S. Rose, \"Protocol Modifications for the
    DNS\n                     Security Extensions\", RFC 4035, March 2005.\n   [RFC4648]
    \        Josefsson, S., \"The Base16, Base32, and Base64 Data\n                     Encodings\",
    RFC 4648, October 2006.\n"
  title: 13.1.  Normative References
- contents:
  - "13.2.  Informative References\n   [DNSEXT-NO]       Josefsson, S., \"Authenticating
    Denial of Existence\n                     in DNS with Minimum Disclosure\", Work
    in Progress,\n                     July 2000.\n   [DNSEXT-NSEC2v2]  Laurie, B.,
    \"DNSSEC NSEC2 Owner and RDATA Format\",\n                     Work in Progress,
    December 2004.\n   [RFC2672]         Crawford, M., \"Non-Terminal DNS Name Redirection\",\n
    \                    RFC 2672, August 1999.\n   [RFC2898]         Kaliski, B.,
    \"PKCS #5: Password-Based Cryptography\n                     Specification Version
    2.0\", RFC 2898,\n                     September 2000.\n   [RFC3833]         Atkins,
    D. and R. Austein, \"Threat Analysis of the\n                     Domain Name
    System (DNS)\", RFC 3833, August 2004.\n   [RFC4592]         Lewis, E., \"The
    Role of Wildcards in the Domain\n                     Name System\", RFC 4592,
    July 2006.\n   [RFC4956]         Arends, R., Kosters, M., and D. Blacka, \"DNS\n
    \                    Security (DNSSEC) Opt-In\", RFC 4956, July 2007.\n"
  title: 13.2.  Informative References
- contents:
  - "Appendix A.  Example Zone\n   This is a zone showing its NSEC3 RRs.  They can
    also be used as test\n   vectors for the hash algorithm.\n   The overall TTL and
    class are specified in the SOA RR, and are\n   subsequently omitted for clarity.\n
    \  The zone is preceded by a list that contains the hashes of the\n   original
    ownernames.\n   ; H(example)       = 0p9mhaveqvm6t7vbl5lop2u3t2rp3tom\n   ; H(a.example)
    \    = 35mthgpgcu1qg68fab165klnsnk3dpvl\n   ; H(ai.example)    = gjeqe526plbf1g8mklp59enfd789njgi\n
    \  ; H(ns1.example)   = 2t7b4g4vsa5smi47k61mv5bv1a22bojr\n   ; H(ns2.example)
    \  = q04jkcevqvmu85r014c7dkba38o0ji5r\n   ; H(w.example)     = k8udemvp1j2f7eg6jebps17vp3n8i58h\n
    \  ; H(*.w.example)   = r53bq7cc2uvmubfu5ocmm6pers9tk9en\n   ; H(x.w.example)
    \  = b4um86eghhds6nea196smvmlo4ors995\n   ; H(y.w.example)   = ji6neoaepv8b5o6k4ev33abha8ht9fgc\n
    \  ; H(x.y.w.example) = 2vptu5timamqttgl4luu9kg21e0aor3s\n   ; H(xx.example)    =
    t644ebqk9bibcna874givr6joj62mlhv\n   ; H(2t7b4g4vsa5smi47k61mv5bv1a22bojr.example)\n
    \  ;                  = kohar7mbb8dc2ce8a9qvl8hon4k53uhi\n   example. 3600  IN
    SOA  ns1.example. bugs.x.w.example. 1 3600 300 (\n                          3600000
    3600 )\n                  RRSIG   SOA 7 1 3600 20150420235959 20051021000000 (\n
    \                         40430 example.\n                          Hu25UIyNPmvPIVBrldN+9Mlp9Zql39qaUd8i\n
    \                         q4ZLlYWfUUbbAS41pG+68z81q1xhkYAcEyHd\n                          VI2LmKusbZsT0Q==
    )\n                  NS      ns1.example.\n                  NS      ns2.example.\n
    \                 RRSIG   NS 7 1 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          PVOgtMK1HHeSTau+HwDWC8Ts+6C8qtqd4pQJ\n                          qOtdEVgg+MA+ai4fWDEhu3qHJyLcQ9tbD2vv\n
    \                         CnMXjtz6SyObxA== )\n                  MX      1 xx.example.\n
    \                 RRSIG   MX 7 1 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          GgQ1A9xs47k42VPvpL/a1BWUz/6XsnHkjotw\n                          9So8MQtZtl2wJBsnOQsaoHrRCrRbyriEl/GZ\n
    \                         n9Mto/Kx+wBo+w== )\n                  DNSKEY  256 3
    7 AwEAAaetidLzsKWUt4swWR8yu0wPHPiUi8LU (\n                          sAD0QPWU+wzt89epO6tHzkMBVDkC7qphQO2h\n
    \                         TY4hHn9npWFRw5BYubE= )\n                  DNSKEY  257
    3 7 AwEAAcUlFV1vhmqx6NSOUOq2R/dsR7Xm3upJ (\n                          j7IommWSpJABVfW8Q0rOvXdM6kzt+TAu92L9\n
    \                         AbsUdblMFin8CVF3n4s= )\n                  RRSIG   DNSKEY
    7 1 3600 20150420235959 (\n                          20051021000000 12708 example.\n
    \                         AuU4juU9RaxescSmStrQks3Gh9FblGBlVU31\n                          uzMZ/U/FpsUb8aC6QZS+sTsJXnLnz7flGOsm\n
    \                         MGQZf3bH+QsCtg== )\n                  NSEC3PARAM 1 0
    12 aabbccdd\n                  RRSIG   NSEC3PARAM 7 1 3600 20150420235959 (\n
    \                         20051021000000 40430 example.\n                          C1Gl8tPZNtnjlrYWDeeUV/sGLCyy/IHie2re\n
    \                         rN05XSA3Pq0U3+4VvGWYWdUMfflOdxqnXHwJ\n                          TLQsjlkynhG6Cg==
    )\n   0p9mhaveqvm6t7vbl5lop2u3t2rp3tom.example. NSEC3 1 1 12 aabbccdd (\n                          2t7b4g4vsa5smi47k61mv5bv1a22bojr
    MX DNSKEY NS\n                          SOA NSEC3PARAM RRSIG )\n                  RRSIG
    \  NSEC3 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          OSgWSm26B+cS+dDL8b5QrWr/dEWhtCsKlwKL\n                          IBHYH6blRxK9rC0bMJPwQ4mLIuw85H2EY762\n
    \                         BOCXJZMnpuwhpA== )\n   2t7b4g4vsa5smi47k61mv5bv1a22bojr.example.
    A 192.0.2.127\n                  RRSIG   A 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          h6c++bzhRuWWt2bykN6mjaTNBcXNq5UuL5Ed\n
    \                         K+iDP4eY8I0kSiKaCjg3tC1SQkeloMeub2GW\n                          k8p6xHMPZumXlw==
    )\n                  NSEC3   1 1 12 aabbccdd (\n                          2vptu5timamqttgl4luu9kg21e0aor3s
    A RRSIG )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          OmBvJ1Vgg1hCKMXHFiNeIYHK9XVW0iLDLwJN\n
    \                         4TFoNxZuP03gAXEI634YwOc4YBNITrj413iq\n                          NI6mRk/r1dOSUw==
    )\n   2vptu5timamqttgl4luu9kg21e0aor3s.example. NSEC3 1 1 12 aabbccdd (\n                          35mthgpgcu1qg68fab165klnsnk3dpvl
    MX RRSIG )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          KL1V2oFYghNV0Hm7Tf2vpJjM6l+0g1JCcVYG\n
    \                         VfI0lKrhPmTsOA96cLEACgo1x8I7kApJX+ob\n                          TuktZ+sdsZPY1w==
    )\n   35mthgpgcu1qg68fab165klnsnk3dpvl.example. NSEC3 1 1 12 aabbccdd (\n                          b4um86eghhds6nea196smvmlo4ors995
    NS DS RRSIG )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          g6jPUUpduAJKRljUsN8gB4UagAX0NxY9shwQ\n
    \                         Aynzo8EUWH+z6hEIBlUTPGj15eZll6VhQqgZ\n                          XtAIR3chwgW+SA==
    )\n   a.example.     NS      ns1.a.example.\n                  NS      ns2.a.example.\n
    \                 DS      58470 5 1 (\n                          3079F1593EBAD6DC121E202A8B766A6A4837206C
    )\n                  RRSIG   DS 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          XacFcQVHLVzdoc45EJhN616zQ4mEXtE8FzUh\n                          M2KWjfy1VfRKD9r1MeVGwwoukOKgJxBPFsWo\n
    \                         o722vZ4UZ2dIdA== )\n   ns1.a.example. A       192.0.2.5\n
    \  ns2.a.example. A       192.0.2.6\n   ai.example.    A       192.0.2.9\n                  RRSIG
    \  A 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          hVe+wKYMlObTRPhX0NL67GxeZfdxqr/QeR6F\n                          tfdAj5+FgYxyzPEjIzvKWy00hWIl6wD3Vws+\n
    \                         rznEn8sQ64UdqA== )\n                  HINFO   \"KLH-10\"
    \"ITS\"\n                  RRSIG   HINFO 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          Yi42uOq43eyO6qXHNvwwfFnIustWgV5urFcx\n
    \                         enkLvs6pKRh00VBjODmf3Z4nMO7IOl6nHSQ1\n                          v0wLHpEZG7Xj2w==
    )\n                  AAAA    2001:db8:0:0:0:0:f00:baa9\n                  RRSIG
    \  AAAA 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          LcdxKaCB5bGZwPDg+3JJ4O02zoMBrjxqlf6W\n                          uaHQZZfTUpb9Nf2nxFGe2XRPfR5tpJT6GdRG\n
    \                         cHueLuXkMjBArQ== )\n   b4um86eghhds6nea196smvmlo4ors995.example.
    NSEC3 1 1 12 aabbccdd (\n                          gjeqe526plbf1g8mklp59enfd789njgi
    MX RRSIG )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          ZkPG3M32lmoHM6pa3D6gZFGB/rhL//Bs3Omh\n
    \                         5u4m/CUiwtblEVOaAKKZd7S959OeiX43aLX3\n                          pOv0TSTyiTxIZg==
    )\n   c.example.     NS      ns1.c.example.\n                  NS      ns2.c.example.\n
    \  ns1.c.example. A       192.0.2.7\n   ns2.c.example. A       192.0.2.8\n   gjeqe526plbf1g8mklp59enfd789njgi.example.
    NSEC3 1 1 12 aabbccdd (\n                          ji6neoaepv8b5o6k4ev33abha8ht9fgc
    HINFO A AAAA\n                          RRSIG )\n                  RRSIG   NSEC3
    7 2 3600 20150420235959 20051021000000 (\n                          40430 example.\n
    \                         IVnezTJ9iqblFF97vPSmfXZ5Zozngx3KX3by\n                          LTZC4QBH2dFWhf6scrGFZB980AfCxoD9qbbK\n
    \                         Dy+rdGIeRSVNyw== )\n   ji6neoaepv8b5o6k4ev33abha8ht9fgc.example.
    NSEC3 1 1 12 aabbccdd (\n                          k8udemvp1j2f7eg6jebps17vp3n8i58h
    )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000 (\n
    \                         40430 example.\n                          gPkFp1s2QDQ6wQzcg1uSebZ61W33rUBDcTj7\n
    \                         2F3kQ490fEdp7k1BUIfbcZtPbX3YCpE+sIt0\n                          MpzVSKfTwx4uYA==
    )\n   k8udemvp1j2f7eg6jebps17vp3n8i58h.example. NSEC3 1 1 12 aabbccdd (\n                          kohar7mbb8dc2ce8a9qvl8hon4k53uhi
    )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000 (\n
    \                         40430 example.\n                          FtXGbvF0+wf8iWkyo73enAuVx03klN+pILBK\n
    \                         S6qCcftVtfH4yVzsEZquJ27NHR7ruxJWDNMt\n                          Otx7w9WfcIg62A==
    )\n   kohar7mbb8dc2ce8a9qvl8hon4k53uhi.example. NSEC3 1 1 12 aabbccdd (\n                          q04jkcevqvmu85r014c7dkba38o0ji5r
    A RRSIG )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          VrDXs2uVW21N08SyQIz88zml+y4ZCInTwgDr\n
    \                         6zz43yAg+LFERjOrj3Ojct51ac7Dp4eZbf9F\n                          QJazmASFKGxGXg==
    )\n   ns1.example.   A       192.0.2.1\n                  RRSIG   A 7 2 3600 20150420235959
    20051021000000 (\n                          40430 example.\n                          bu6kx73n6XEunoVGuRfAgY7EF/AJqHy7hj0j\n
    \                         kiqJjB0dOrx3wuz9SaBeGfqWIdn/uta3SavN\n                          4FRvZR9SCFHF5Q==
    )\n   ns2.example.   A       192.0.2.2\n                  RRSIG   A 7 2 3600 20150420235959
    20051021000000 (\n                          40430 example.\n                          ktQ3TqE0CfRfki0Rb/Ip5BM0VnxelbuejCC4\n
    \                         zpLbFKA/7eD7UNAwxMgxJPtbdST+syjYSJaj\n                          4IHfeX6n8vfoGA==
    )\n   q04jkcevqvmu85r014c7dkba38o0ji5r.example. NSEC3 1 1 12 aabbccdd (\n                          r53bq7cc2uvmubfu5ocmm6pers9tk9en
    A RRSIG )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          hV5I89b+4FHJDATp09g4bbN0R1F845CaXpL3\n
    \                         ZxlMKimoPAyqletMlEWwLfFia7sdpSzn+ZlN\n                          NlkxWcLsIlMmUg==
    )\n   r53bq7cc2uvmubfu5ocmm6pers9tk9en.example. NSEC3 1 1 12 aabbccdd (\n                          t644ebqk9bibcna874givr6joj62mlhv
    MX RRSIG )\n                  RRSIG   NSEC3 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          aupviViruXs4bDg9rCbezzBMf9h1ZlDvbW/C\n
    \                         ZFKulIGXXLj8B/fsDJarXVDA9bnUoRhEbKp+\n                          HF1FWKW7RIJdtQ==
    )\n   t644ebqk9bibcna874givr6joj62mlhv.example. NSEC3 1 1 12 aabbccdd (\n                          0p9mhaveqvm6t7vbl5lop2u3t2rp3tom
    HINFO A AAAA\n                          RRSIG )\n                  RRSIG   NSEC3
    7 2 3600 20150420235959 20051021000000 (\n                          40430 example.\n
    \                         RAjGECB8P7O+F4Pa4Dx3tC0M+Z3KmlLKImca\n                          fb9XWwx+NWUNz7NBEDBQHivIyKPVDkChcePI\n
    \                         X1xPl1ATNa+8Dw== )\n   *.w.example.   MX      1 ai.example.\n
    \                 RRSIG   MX 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          CikebjQwGQPwijVcxgcZcSJKtfynugtlBiKb\n                          9FcBTrmOoyQ4InoWVudhCWsh/URX3lc4WRUM\n
    \                         ivEBP6+4KS3ldA== )\n   x.w.example.   MX      1 xx.example.\n
    \                 RRSIG   MX 7 3 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          IrK3tq/tHFIBF0scHiE/1IwMAvckS/55hAVv\n                          QyxTFbkAdDloP3NbZzu+yoSsr3b3OX6qbBpY\n
    \                         7WCtwwekLKRAwQ== )\n   x.y.w.example. MX      1 xx.example.\n
    \                 RRSIG   MX 7 4 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          MqSt5HqJIN8+SLlzTOImrh5h9Xa6gDvAW/Gn\n                          nbdPc6Z7nXvCpLPJj/5lCwx3VuzVOjkbvXze\n
    \                         8/8Ccl2Zn2hbug== )\n   xx.example.    A       192.0.2.10\n
    \                 RRSIG   A 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          T35hBWEZ017VC5u2c4OriKyVn/pu+fVK4AlX\n                          YOxJ6iQylfV2HQIKjv6b7DzINB3aF/wjJqgX\n
    \                         pQvhq+Ac6+ZiFg== )\n                  HINFO   \"KLH-10\"
    \"TOPS-20\"\n                  RRSIG   HINFO 7 2 3600 20150420235959 20051021000000
    (\n                          40430 example.\n                          KimG+rDd+7VA1zRsu0ITNAQUTRlpnsmqWrih\n
    \                         FRnU+bRa93v2e5oFNFYCs3Rqgv62K93N7AhW\n                          6Jfqj/8NzWjvKg==
    )\n                  AAAA    2001:db8:0:0:0:0:f00:baaa\n                  RRSIG
    \  AAAA 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          IXBcXORITNwd8h3gNwyxtYFvAupS/CYWufVe\n                          uBUX0O25ivBCULjZjpDxFSxfohb/KA7YRdxE\n
    \                         NzYfMItpILl/Xw== )\n"
  title: Appendix A.  Example Zone
- contents:
  - "Appendix B.  Example Responses\n   The examples in this section show response
    messages using the signed\n   zone example in Appendix A.\n"
  title: Appendix B.  Example Responses
- contents:
  - "B.1.  Name Error\n   An authoritative name error.  The NSEC3 RRs prove that the
    name does\n   not exist and that there is no wildcard RR that should have been\n
    \  expanded.\n"
  - ';; Header: QR AA DO RCODE=3

    '
  - ';;

    '
  - ';; Question

    '
  - 'a.c.x.w.example.         IN A

    '
  - ';; Answer

    '
  - ';; (empty)

    '
  - ';; Authority

    '
  - "example.       SOA     ns1.example. bugs.x.w.example. 1 3600 300 (\n                       3600000
    3600 )\n"
  - "example.       RRSIG   SOA 7 1 3600 20150420235959 20051021000000 (\n                       40430
    example.\n                       Hu25UIyNPmvPIVBrldN+9Mlp9Zql39qaUd8i\n                       q4ZLlYWfUUbbAS41pG+68z81q1xhkYAcEyHd\n
    \                      VI2LmKusbZsT0Q== )\n"
  - ';; NSEC3 RR that covers the "next closer" name (c.x.w.example)

    '
  - ';; H(c.x.w.example) = 0va5bpr2ou0vk0lbqeeljri88laipsfh

    '
  - "0p9mhaveqvm6t7vbl5lop2u3t2rp3tom.example. NSEC3 1 1 12 aabbccdd (\n                       2t7b4g4vsa5smi47k61mv5bv1a22bojr
    MX DNSKEY NS\n                       SOA NSEC3PARAM RRSIG )\n"
  - "0p9mhaveqvm6t7vbl5lop2u3t2rp3tom.example. RRSIG NSEC3 7 2 3600 (\n                       20150420235959
    20051021000000 40430 example.\n                       OSgWSm26B+cS+dDL8b5QrWr/dEWhtCsKlwKL\n
    \                      IBHYH6blRxK9rC0bMJPwQ4mLIuw85H2EY762\n                       BOCXJZMnpuwhpA==
    )\n"
  - ';; NSEC3 RR that matches the closest encloser (x.w.example)

    '
  - ';; H(x.w.example) = b4um86eghhds6nea196smvmlo4ors995

    '
  - "b4um86eghhds6nea196smvmlo4ors995.example. NSEC3 1 1 12 aabbccdd (\n                       gjeqe526plbf1g8mklp59enfd789njgi
    MX RRSIG )\n"
  - "b4um86eghhds6nea196smvmlo4ors995.example. RRSIG NSEC3 7 2 3600 (\n                       20150420235959
    20051021000000 40430 example.\n                       ZkPG3M32lmoHM6pa3D6gZFGB/rhL//Bs3Omh\n
    \                      5u4m/CUiwtblEVOaAKKZd7S959OeiX43aLX3\n                       pOv0TSTyiTxIZg==
    )\n"
  - ';; NSEC3 RR that covers wildcard at the closest encloser (*.x.w.example)

    '
  - ';; H(*.x.w.example) = 92pqneegtaue7pjatc3l3qnk738c6v5m

    '
  - "35mthgpgcu1qg68fab165klnsnk3dpvl.example. NSEC3 1 1 12 aabbccdd (\n                       b4um86eghhds6nea196smvmlo4ors995
    NS DS RRSIG )\n"
  - "35mthgpgcu1qg68fab165klnsnk3dpvl.example. RRSIG NSEC3 7 2 3600 (\n                       20150420235959
    20051021000000 40430 example.\n                       g6jPUUpduAJKRljUsN8gB4UagAX0NxY9shwQ\n
    \                      Aynzo8EUWH+z6hEIBlUTPGj15eZll6VhQqgZ\n                       XtAIR3chwgW+SA==
    )\n"
  - ';; Additional

    '
  - ";; (empty)\n   The query returned three NSEC3 RRs that prove that the requested
    data\n   does not exist and that no wildcard expansion applies.  The negative\n
    \  response is authenticated by verifying the NSEC3 RRs.  The\n   corresponding
    RRSIGs indicate that the NSEC3 RRs are signed by an\n   \"example\" DNSKEY of
    algorithm 7 and with key tag 40430.  The resolver\n   needs the corresponding
    DNSKEY RR in order to authenticate this\n   answer.\n   One of the owner names
    of the NSEC3 RRs matches the closest encloser.\n   One of the NSEC3 RRs prove
    that there exists no longer name.  One of\n   the NSEC3 RRs prove that there exists
    no wildcard RRSets that should\n   have been expanded.  The closest encloser can
    be found by applying\n   the algorithm in Section 8.3.\n   In the above example,
    the name 'x.w.example' hashes to\n   'b4um86eghhds6nea196smvmlo4ors995'.  This
    indicates that this might\n   be the closest encloser.  To prove that 'c.x.w.example'
    and\n   '*.x.w.example' do not exist, these names are hashed to,\n   respectively,
    '0va5bpr2ou0vk0lbqeeljri88laipsfh' and\n   '92pqneegtaue7pjatc3l3qnk738c6v5m'.
    \ The first and last NSEC3 RRs\n   prove that these hashed owner names do not
    exist.\n"
  title: B.1.  Name Error
- contents:
  - "B.2.  No Data Error\n   A \"no data\" response.  The NSEC3 RR proves that the
    name exists and\n   that the requested RR type does not.\n"
  - ';; Header: QR AA DO RCODE=0

    '
  - ';;

    '
  - ';; Question

    '
  - 'ns1.example.        IN MX

    '
  - ';; Answer

    '
  - ';; (empty)

    '
  - ';; Authority

    '
  - "example.       SOA     ns1.example. bugs.x.w.example. 1 3600 300 (\n                       3600000
    3600 )\n"
  - "example.       RRSIG   SOA 7 1 3600 20150420235959 20051021000000 (\n                       40430
    example.\n                       Hu25UIyNPmvPIVBrldN+9Mlp9Zql39qaUd8i\n                       q4ZLlYWfUUbbAS41pG+68z81q1xhkYAcEyHd\n
    \                      VI2LmKusbZsT0Q== )\n"
  - ';; NSEC3 RR matches the QNAME and shows that the MX type bit is not set.

    '
  - "2t7b4g4vsa5smi47k61mv5bv1a22bojr.example. NSEC3 1 1 12 aabbccdd (\n                       2vptu5timamqttgl4luu9kg21e0aor3s
    A RRSIG )\n"
  - "2t7b4g4vsa5smi47k61mv5bv1a22bojr.example. RRSIG NSEC3 7 2 3600 (\n                       20150420235959
    20051021000000 40430 example.\n                       OmBvJ1Vgg1hCKMXHFiNeIYHK9XVW0iLDLwJN\n
    \                      4TFoNxZuP03gAXEI634YwOc4YBNITrj413iq\n                       NI6mRk/r1dOSUw==
    )\n"
  - ';; Additional

    '
  - ";; (empty)\n   The query returned an NSEC3 RR that proves that the requested
    name\n   exists (\"ns1.example.\" hashes to \"2t7b4g4vsa5smi47k61mv5bv1a22bojr\"),\n
    \  but the requested RR type does not exist (type MX is absent in the\n   type
    code list of the NSEC3 RR), and was not a CNAME (type CNAME is\n   also absent
    in the type code list of the NSEC3 RR).\n"
  title: B.2.  No Data Error
- contents:
  - "B.2.1.  No Data Error, Empty Non-Terminal\n   A \"no data\" response because
    of an empty non-terminal.  The NSEC3 RR\n   proves that the name exists and that
    the requested RR type does not.\n ;; Header: QR AA DO RCODE=0\n ;;\n ;; Question\n
    y.w.example.        IN A\n ;; Answer\n ;; (empty)\n ;; Authority\n example.       SOA
    \    ns1.example. bugs.x.w.example. 1 3600 300 (\n                        3600000
    3600 )\n example.       RRSIG   SOA 7 1 3600 20150420235959 20051021000000 (\n
    \                       40430 example.\n                        Hu25UIyNPmvPIVBrldN+9Mlp9Zql39qaUd8i\n
    \                       q4ZLlYWfUUbbAS41pG+68z81q1xhkYAcEyHd\n                        VI2LmKusbZsT0Q==
    )\n ;; NSEC3 RR matches the QNAME and shows that the A type bit is not set.\n
    ji6neoaepv8b5o6k4ev33abha8ht9fgc.example. NSEC3 1 1 12 aabbccdd (\n                        k8udemvp1j2f7eg6jebps17vp3n8i58h
    )\n ji6neoaepv8b5o6k4ev33abha8ht9fgc.example. RRSIG NSEC3 7 2 3600 (\n                        20150420235959
    20051021000000 40430 example.\n                        gPkFp1s2QDQ6wQzcg1uSebZ61W33rUBDcTj7\n
    \                       2F3kQ490fEdp7k1BUIfbcZtPbX3YCpE+sIt0\n                        MpzVSKfTwx4uYA==
    )\n ;; Additional\n ;; (empty)\n   The query returned an NSEC3 RR that proves
    that the requested name\n   exists (\"y.w.example.\" hashes to \"ji6neoaepv8b5o6k4ev33abha8ht9fgc\"),\n
    \  but the requested RR type does not exist (Type A is absent in the\n   Type
    Bit Maps field of the NSEC3 RR).  Note that, unlike an empty\n   non-terminal
    proof using NSECs, this is identical to a No Data Error.\n   This example is solely
    mentioned to be complete.\n"
  title: B.2.1.  No Data Error, Empty Non-Terminal
- contents:
  - "B.3.  Referral to an Opt-Out Unsigned Zone\n   The NSEC3 RRs prove that nothing
    for this delegation was signed.\n   There is no proof that the unsigned delegation
    exists.\n   ;; Header: QR DO RCODE=0\n   ;;\n   ;; Question\n   mc.c.example.
    \      IN MX\n   ;; Answer\n   ;; (empty)\n   ;; Authority\n   c.example.     NS
    \     ns1.c.example.\n                  NS      ns2.c.example.\n   ;; NSEC3 RR
    that covers the \"next closer\" name (c.example)\n   ;; H(c.example) = 4g6p9u5gvfshp30pqecj98b3maqbn1ck\n
    \  35mthgpgcu1qg68fab165klnsnk3dpvl.example. NSEC3 1 1 12 aabbccdd (\n                          b4um86eghhds6nea196smvmlo4ors995
    NS DS RRSIG )\n   35mthgpgcu1qg68fab165klnsnk3dpvl.example. RRSIG NSEC3 7 2 3600
    (\n                          20150420235959 20051021000000 40430 example.\n                          g6jPUUpduAJKRljUsN8gB4UagAX0NxY9shwQ\n
    \                         Aynzo8EUWH+z6hEIBlUTPGj15eZll6VhQqgZ\n                          XtAIR3chwgW+SA==
    )\n   ;; NSEC3 RR that matches the closest encloser (example)\n   ;; H(example)
    = 0p9mhaveqvm6t7vbl5lop2u3t2rp3tom\n   0p9mhaveqvm6t7vbl5lop2u3t2rp3tom.example.
    NSEC3 1 1 12 aabbccdd (\n                          2t7b4g4vsa5smi47k61mv5bv1a22bojr
    MX DNSKEY NS\n                          SOA NSEC3PARAM RRSIG )\n   0p9mhaveqvm6t7vbl5lop2u3t2rp3tom.example.
    RRSIG NSEC3 7 2 3600 (\n                          20150420235959 20051021000000
    40430 example.\n                          OSgWSm26B+cS+dDL8b5QrWr/dEWhtCsKlwKL\n
    \                         IBHYH6blRxK9rC0bMJPwQ4mLIuw85H2EY762\n                          BOCXJZMnpuwhpA==
    )\n   ;; Additional\n   ns1.c.example. A       192.0.2.7\n   ns2.c.example. A
    \      192.0.2.8\n   The query returned a referral to the unsigned \"c.example.\"
    zone.  The\n   response contains the closest provable encloser of \"c.example\"
    to be\n   \"example\", since the hash of \"c.example\"\n   (\"4g6p9u5gvfshp30pqecj98b3maqbn1ck\")
    is covered by the first NSEC3 RR\n   and its Opt-Out bit is set.\n"
  title: B.3.  Referral to an Opt-Out Unsigned Zone
- contents:
  - "B.4.  Wildcard Expansion\n   A query that was answered with a response containing
    a wildcard\n   expansion.  The label count in the RRSIG RRSet in the answer section\n
    \  indicates that a wildcard RRSet was expanded to produce this\n   response,
    and the NSEC3 RR proves that no \"next closer\" name exists\n   in the zone.\n
    \  ;; Header: QR AA DO RCODE=0\n   ;;\n   ;; Question\n   a.z.w.example. IN MX\n
    \  ;; Answer\n   a.z.w.example. MX      1 ai.example.\n   a.z.w.example. RRSIG
    \  MX 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          CikebjQwGQPwijVcxgcZcSJKtfynugtlBiKb\n                          9FcBTrmOoyQ4InoWVudhCWsh/URX3lc4WRUM\n
    \                         ivEBP6+4KS3ldA== )\n   ;; Authority\n   example.       NS
    \     ns1.example.\n   example.       NS      ns2.example.\n   example.       RRSIG
    \  NS 7 1 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          PVOgtMK1HHeSTau+HwDWC8Ts+6C8qtqd4pQJ\n                          qOtdEVgg+MA+ai4fWDEhu3qHJyLcQ9tbD2vv\n
    \                         CnMXjtz6SyObxA== )\n   ;; NSEC3 RR that covers the \"next
    closer\" name (z.w.example)\n   ;; H(z.w.example) = qlu7gtfaeh0ek0c05ksfhdpbcgglbe03\n
    \  q04jkcevqvmu85r014c7dkba38o0ji5r.example. NSEC3 1 1 12 aabbccdd (\n                          r53bq7cc2uvmubfu5ocmm6pers9tk9en
    A RRSIG )\n   q04jkcevqvmu85r014c7dkba38o0ji5r.example. RRSIG NSEC3 7 2 3600 (\n
    \                         20150420235959 20051021000000 40430 example.\n                          hV5I89b+4FHJDATp09g4bbN0R1F845CaXpL3\n
    \                         ZxlMKimoPAyqletMlEWwLfFia7sdpSzn+ZlN\n                          NlkxWcLsIlMmUg==
    )\n   ;; Additional\n   ai.example.    A       192.0.2.9\n   ai.example.    RRSIG
    \  A 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          hVe+wKYMlObTRPhX0NL67GxeZfdxqr/QeR6F\n                          tfdAj5+FgYxyzPEjIzvKWy00hWIl6wD3Vws+\n
    \                         rznEn8sQ64UdqA== )\n   ai.example.    AAAA    2001:db8:0:0:0:0:f00:baa9\n
    \  ai.example.    RRSIG   AAAA 7 2 3600 20150420235959 20051021000000 (\n                          40430
    example.\n                          LcdxKaCB5bGZwPDg+3JJ4O02zoMBrjxqlf6W\n                          uaHQZZfTUpb9Nf2nxFGe2XRPfR5tpJT6GdRG\n
    \                         cHueLuXkMjBArQ== )\n   The query returned an answer
    that was produced as a result of a\n   wildcard expansion.  The answer section
    contains a wildcard RRSet\n   expanded as it would be in a traditional DNS response.
    \ The RRSIG\n   Labels field value of 2 indicates that the answer is the result
    of a\n   wildcard expansion, as the \"a.z.w.example\" name contains 4 labels.\n
    \  This also shows that \"w.example\" exists, so there is no need for an\n   NSEC3
    RR that matches the closest encloser.\n   The NSEC3 RR proves that no closer match
    could have been used to\n   answer this query.\n"
  title: B.4.  Wildcard Expansion
- contents:
  - "B.5.  Wildcard No Data Error\n   A \"no data\" response for a name covered by
    a wildcard.  The NSEC3 RRs\n   prove that the matching wildcard name does not
    have any RRs of the\n   requested type and that no closer match exists in the
    zone.\n   ;; Header: QR AA DO RCODE=0\n   ;;\n   ;; Question\n   a.z.w.example.
    \     IN AAAA\n   ;; Answer\n   ;; (empty)\n   ;; Authority\n   example.       SOA
    \    ns1.example. bugs.x.w.example. 1 3600 300 (\n                          3600000
    3600 )\n   example.       RRSIG   SOA 7 1 3600 20150420235959 20051021000000 (\n
    \                         40430 example.\n                          Hu25UIyNPmvPIVBrldN+9Mlp9Zql39qaUd8i\n
    \                         q4ZLlYWfUUbbAS41pG+68z81q1xhkYAcEyHd\n                          VI2LmKusbZsT0Q==
    )\n   ;; NSEC3 RR that matches the closest encloser (w.example)\n   ;; H(w.example)
    = k8udemvp1j2f7eg6jebps17vp3n8i58h\n   k8udemvp1j2f7eg6jebps17vp3n8i58h.example.
    NSEC3 1 1 12 aabbccdd (\n                          kohar7mbb8dc2ce8a9qvl8hon4k53uhi
    )\n   k8udemvp1j2f7eg6jebps17vp3n8i58h.example. RRSIG NSEC3 7 2 3600 (\n                          20150420235959
    20051021000000 40430 example.\n                          FtXGbvF0+wf8iWkyo73enAuVx03klN+pILBK\n
    \                         S6qCcftVtfH4yVzsEZquJ27NHR7ruxJWDNMt\n                          Otx7w9WfcIg62A==
    )\n   ;; NSEC3 RR that covers the \"next closer\" name (z.w.example)\n   ;; H(z.w.example)
    = qlu7gtfaeh0ek0c05ksfhdpbcgglbe03\n   q04jkcevqvmu85r014c7dkba38o0ji5r.example.
    NSEC3 1 1 12 aabbccdd (\n                          r53bq7cc2uvmubfu5ocmm6pers9tk9en
    A RRSIG )\n   q04jkcevqvmu85r014c7dkba38o0ji5r.example. RRSIG NSEC3 7 2 3600 (\n
    \                         20150420235959 20051021000000 40430 example.\n                          hV5I89b+4FHJDATp09g4bbN0R1F845CaXpL3\n
    \                         ZxlMKimoPAyqletMlEWwLfFia7sdpSzn+ZlN\n                          NlkxWcLsIlMmUg==
    )\n   ;; NSEC3 RR that matches a wildcard at the closest encloser.\n   ;; H(*.w.example)
    = r53bq7cc2uvmubfu5ocmm6pers9tk9en\n   r53bq7cc2uvmubfu5ocmm6pers9tk9en.example.
    NSEC3 1 1 12 aabbccdd (\n                          t644ebqk9bibcna874givr6joj62mlhv
    MX RRSIG )\n   r53bq7cc2uvmubfu5ocmm6pers9tk9en.example. RRSIG NSEC3 7 2 3600
    (\n                          20150420235959 20051021000000 40430 example.\n                          aupviViruXs4bDg9rCbezzBMf9h1ZlDvbW/C\n
    \                         ZFKulIGXXLj8B/fsDJarXVDA9bnUoRhEbKp+\n                          HF1FWKW7RIJdtQ==
    )\n   ;; Additional\n   ;; (empty)\n   The query returned the NSEC3 RRs that prove
    that the requested data\n   does not exist and no wildcard RR applies.\n"
  title: B.5.  Wildcard No Data Error
- contents:
  - "B.6.  DS Child Zone No Data Error\n   A \"no data\" response for a QTYPE=DS query
    that was mistakenly sent to\n   a name server for the child zone.\n"
  - ';; Header: QR AA DO RCODE=0

    '
  - ';;

    '
  - ';; Question

    '
  - 'example.            IN DS

    '
  - ';; Answer

    '
  - ';; (empty)

    '
  - ';; Authority

    '
  - "example.       SOA     ns1.example. bugs.x.w.example. 1 3600 300 (\n                       3600000
    3600 )\n"
  - "example.       RRSIG   SOA 7 1 3600 20150420235959 20051021000000 (\n                       40430
    example.\n                       Hu25UIyNPmvPIVBrldN+9Mlp9Zql39qaUd8i\n                       q4ZLlYWfUUbbAS41pG+68z81q1xhkYAcEyHd\n
    \                      VI2LmKusbZsT0Q== )\n"
  - ';; NSEC3 RR matches the QNAME and shows that the DS type bit is not set.

    '
  - "0p9mhaveqvm6t7vbl5lop2u3t2rp3tom.example. NSEC3 1 1 12 aabbccdd (\n                       2t7b4g4vsa5smi47k61mv5bv1a22bojr
    MX DNSKEY NS\n                       SOA NSEC3PARAM RRSIG )\n"
  - "0p9mhaveqvm6t7vbl5lop2u3t2rp3tom.example. RRSIG NSEC3 7 2 3600\n                       20150420235959
    20051021000000 40430 example.\n                       OSgWSm26B+cS+dDL8b5QrWr/dEWhtCsKlwKL\n
    \                      IBHYH6blRxK9rC0bMJPwQ4mLIuw85H2EY762\n                       BOCXJZMnpuwhpA==
    )\n"
  - ';; Additional

    '
  - ";; (empty)\n   The query returned an NSEC3 RR showing that the requested was\n
    \  answered by the server authoritative for the zone \"example\".  The\n   NSEC3
    RR indicates the presence of an SOA RR, showing that this NSEC3\n   RR is from
    the apex of the child, not from the zone cut of the\n   parent.  Queries for the
    \"example\" DS RRSet should be sent to the\n   parent servers (which are in this
    case the root servers).\n"
  title: B.6.  DS Child Zone No Data Error
- contents:
  - "Appendix C.  Special Considerations\n   The following paragraphs clarify specific
    behavior and explain\n   special considerations for implementations.\n"
  title: Appendix C.  Special Considerations
- contents:
  - "C.1.  Salting\n   Augmenting original owner names with salt before hashing increases\n
    \  the cost of a dictionary of pre-generated hash-values.  For every bit\n   of
    salt, the cost of a precomputed dictionary doubles (because there\n   must be
    an entry for each word combined with each possible salt\n   value).  The NSEC3
    RR can use a maximum of 2040 bits (255 octets) of\n   salt, multiplying the cost
    by 2^2040.  This means that an attacker\n   must, in practice, recompute the dictionary
    each time the salt is\n   changed.\n   Including a salt, regardless of size, does
    not affect the cost of\n   constructing NSEC3 RRs.  It does increase the size
    of the NSEC3 RR.\n   There MUST be at least one complete set of NSEC3 RRs for
    the zone\n   using the same salt value.\n   The salt SHOULD be changed periodically
    to prevent pre-computation\n   using a single salt.  It is RECOMMENDED that the
    salt be changed for\n   every re-signing.\n   Note that this could cause a resolver
    to see RRs with different salt\n   values for the same zone.  This is harmless,
    since each RR stands\n   alone (that is, it denies the set of owner names whose
    hashes, using\n   the salt in the NSEC3 RR, fall between the two hashes in the
    NSEC3\n   RR) -- it is only the server that needs a complete set of NSEC3 RRs\n
    \  with the same salt in order to be able to answer every possible\n   query.\n
    \  There is no prohibition with having NSEC3 RRs with different salts\n   within
    the same zone.  However, in order for authoritative servers to\n   be able to
    consistently find covering NSEC3 RRs, the authoritative\n   server MUST choose
    a single set of parameters (algorithm, salt, and\n   iterations) to use when selecting
    NSEC3 RRs.\n"
  title: C.1.  Salting
- contents:
  - "C.2.  Hash Collision\n   Hash collisions occur when different messages have the
    same hash\n   value.  The expected number of domain names needed to give a 1 in
    2\n   chance of a single collision is about 2^(n/2) for a hash of length n\n   bits
    (i.e., 2^80 for SHA-1).  Though this probability is extremely\n   low, the following
    paragraphs deal with avoiding collisions and\n   assessing possible damage in
    the event of an attack using hash\n   collisions.\n"
  title: C.2.  Hash Collision
- contents:
  - "C.2.1.  Avoiding Hash Collisions During Generation\n   During generation of NSEC3
    RRs, hash values are supposedly unique.\n   In the (academic) case of a collision
    occurring, an alternative salt\n   MUST be chosen and all hash values MUST be
    regenerated.\n"
  title: C.2.1.  Avoiding Hash Collisions During Generation
- contents:
  - "C.2.2.  Second Preimage Requirement Analysis\n   A cryptographic hash function
    has a second-preimage resistance\n   property.  The second-preimage resistance
    property means that it is\n   computationally infeasible to find another message
    with the same hash\n   value as a given message, i.e., given preimage X, to find
    a second\n   preimage X' != X such that hash(X) = hash(X').  The work factor for\n
    \  finding a second preimage is of the order of 2^160 for SHA-1.  To\n   mount
    an attack using an existing NSEC3 RR, an adversary needs to\n   find a second
    preimage.\n   Assuming an adversary is capable of mounting such an extreme attack,\n
    \  the actual damage is that a response message can be generated that\n   claims
    that a certain QNAME (i.e., the second pre-image) does exist,\n   while in reality
    QNAME does not exist (a false positive), which will\n   either cause a security-aware
    resolver to re-query for the non-\n   existent name, or to fail the initial query.
    \ Note that the adversary\n   can't mount this attack on an existing name, but
    only on a name that\n   the adversary can't choose and that does not yet exist.\n"
  title: C.2.2.  Second Preimage Requirement Analysis
- contents:
  - "Authors' Addresses\n   Ben Laurie\n   Nominet\n   17 Perryn Road\n   London  W3
    7LR\n   England\n   Phone: +44 20 8735 0686\n   EMail: ben@links.org\n   Geoffrey
    Sisson\n   Nominet\n   Minerva House\n   Edmund Halley Road\n   Oxford Science
    Park\n   Oxford  OX4 4DQ\n   UNITED KINGDOM\n   Phone: +44 1865 332211\n   EMail:
    geoff-s@panix.com\n   Roy Arends\n   Nominet\n   Minerva House\n   Edmund Halley
    Road\n   Oxford Science Park\n   Oxford  OX4 4DQ\n   UNITED KINGDOM\n   Phone:
    +44 1865 332211\n   EMail: roy@nominet.org.uk\n   David Blacka\n   VeriSign, Inc.\n
    \  21355 Ridgetop Circle\n   Dulles, VA  20166\n   US\n   Phone: +1 703 948 3200\n
    \  EMail: davidb@verisign.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
