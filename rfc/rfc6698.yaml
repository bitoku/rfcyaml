- title: __initial_text__
  contents:
  - "         The DNS-Based Authentication of Named Entities (DANE)\n            \
    \ Transport Layer Security (TLS) Protocol: TLSA\n"
- title: Abstract
  contents:
  - "Abstract\n   Encrypted communication on the Internet often uses Transport Layer\n\
    \   Security (TLS), which depends on third parties to certify the keys\n   used.\
    \  This document improves on that situation by enabling the\n   administrators\
    \ of domain names to specify the keys used in that\n   domain's TLS servers. \
    \ This requires matching improvements in TLS\n   client software, but no change\
    \ in TLS server software.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6698.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Background and Motivation ..................................3\n  \
    \    1.2. Securing the Association of a Domain Name with a\n           Server's\
    \ Certificate .......................................4\n      1.3. Method for\
    \ Securing Certificate Associations ...............5\n      1.4. Terminology ................................................6\n\
    \   2. The TLSA Resource Record ........................................7\n  \
    \    2.1. TLSA RDATA Wire Format .....................................7\n    \
    \       2.1.1. The Certificate Usage Field .........................7\n      \
    \     2.1.2. The Selector Field ..................................8\n        \
    \   2.1.3. The Matching Type Field .............................9\n          \
    \ 2.1.4. The Certificate Association Data Field ..............9\n      2.2. TLSA\
    \ RR Presentation Format ................................9\n      2.3. TLSA RR\
    \ Examples ..........................................10\n   3. Domain Names for\
    \ TLSA Certificate Associations .................10\n   4. Use of TLSA Records\
    \ in TLS .....................................11\n      4.1. Usable Certificate\
    \ Associations ...........................11\n   5. TLSA and DANE Use Cases and\
    \ Requirements .......................13\n   6. Mandatory-to-Implement Features\
    \ ................................15\n   7. IANA Considerations ............................................15\n\
    \      7.1. TLSA RRtype ...............................................15\n  \
    \    7.2. TLSA Certificate Usages ...................................15\n    \
    \  7.3. TLSA Selectors ............................................16\n      7.4.\
    \ TLSA Matching Types .......................................16\n   8. Security\
    \ Considerations ........................................16\n      8.1. Comparing\
    \ DANE to Public CAs ..............................18\n           8.1.1. Risk\
    \ of Key Compromise .............................19\n           8.1.2. Impact\
    \ of Key Compromise ...........................20\n           8.1.3. Detection\
    \ of Key Compromise ........................20\n           8.1.4. Spoofing Hostnames\
    \ .................................20\n      8.2. DNS Caching ...............................................21\n\
    \      8.3. External DNSSEC Validators ................................21\n  \
    \ 9. Acknowledgements ...............................................22\n   10.\
    \ References ....................................................22\n      10.1.\
    \ Normative References .....................................22\n      10.2. Informative\
    \ References ...................................23\n   Appendix A. Operational\
    \ Considerations for Deploying TLSA\n               Records ...............................................25\n\
    \     A.1. Creating TLSA Records ......................................25\n  \
    \     A.1.1. Ambiguities and Corner Cases When TLS Clients\n              Build\
    \ Trust Chains .....................................26\n       A.1.2. Choosing\
    \ a Selector Type ...............................26\n     A.2. Provisioning TLSA\
    \ Records in DNS ...........................28\n       A.2.1. Provisioning TLSA\
    \ Records with Aliases .................28\n     A.3. Securing the Last Hop ......................................30\n\
    \     A.4. Handling Certificate Rollover ..............................31\n  \
    \ Appendix B. Pseudocode for Using TLSA .............................32\n    \
    \ B.1. Helper Functions ...........................................32\n     B.2.\
    \ Main TLSA Pseudocode .......................................33\n   Appendix\
    \ C. Examples ..............................................35\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Background and Motivation
  contents:
  - "1.1.  Background and Motivation\n   Applications that communicate over the Internet\
    \ often need to prevent\n   eavesdropping, tampering, or forgery of their communications.\
    \  The\n   Transport Layer Security (TLS) protocol provides this kind of\n   communications\
    \ security over the Internet, using channel encryption.\n   The security properties\
    \ of encryption systems depend strongly on the\n   keys that they use.  If secret\
    \ keys are revealed, or if public keys\n   can be replaced by fake keys (that\
    \ is, a key not corresponding to the\n   entity identified in the certificate),\
    \ these systems provide little\n   or no security.\n   TLS uses certificates to\
    \ bind keys and names.  A certificate combines\n   a published key with other\
    \ information such as the name of the\n   service that uses the key, and this\
    \ combination is digitally signed\n   by another key.  Having a key in a certificate\
    \ is only helpful if one\n   trusts the other key that signed the certificate.\
    \  If that other key\n   was itself revealed or substituted, then its signature\
    \ is worthless\n   in proving anything about the first key.\n   On the Internet,\
    \ this problem has been solved for years by entities\n   called \"Certification\
    \ Authorities\" (CAs).  CAs protect their secret\n   key vigorously, while supplying\
    \ their public key to the software\n   vendors who build TLS clients.  They then\
    \ sign certificates, and\n   supply those to TLS servers.  TLS client software\
    \ uses a set of these\n   CA keys as \"trust anchors\" to validate the signatures\
    \ on certificates\n   that the client receives from TLS servers.  Client software\
    \ typically\n   allows any CA to usefully sign any other certificate.\n   The\
    \ public CA model upon which TLS has depended is fundamentally\n   vulnerable\
    \ because it allows any of these CAs to issue a certificate\n   for any domain\
    \ name.  A single trusted CA that betrays its trust,\n   either voluntarily or\
    \ by providing less-than-vigorous protection for\n   its secrets and capabilities,\
    \ can undermine the security offered by\n   any certificates employed with TLS.\
    \  This problem arises because a\n   compromised CA can issue a replacement certificate\
    \ that contains a\n   fake key.  Recent experiences with compromises of CAs or\
    \ their\n   trusted partners have led to very serious security problems, such\
    \ as\n   the governments of multiple countries attempting to wiretap and/or\n\
    \   subvert major TLS-protected web sites trusted by millions of users.\n   The\
    \ DNS Security Extensions (DNSSEC) provide a similar model that\n   involves trusted\
    \ keys signing the information for untrusted keys.\n   However, DNSSEC provides\
    \ three significant improvements.  Keys are\n   tied to names in the Domain Name\
    \ System (DNS), rather than to\n   arbitrary identifying strings; this is more\
    \ convenient for Internet\n   protocols.  Signed keys for any domain are accessible\
    \ online through\n   a straightforward query using the standard DNSSEC protocol,\
    \ so there\n   is no problem distributing the signed keys.  Most significantly,\
    \ the\n   keys associated with a domain name can only be signed by a key\n   associated\
    \ with the parent of that domain name; for example, the keys\n   for \"example.com\"\
    \ can only be signed by the keys for \"com\", and the\n   keys for \"com\" can\
    \ only be signed by the DNS root.  This prevents an\n   untrustworthy signer from\
    \ compromising anyone's keys except those in\n   their own subdomains.  Like TLS,\
    \ DNSSEC relies on public keys that\n   come built into the DNSSEC client software,\
    \ but these keys come only\n   from a single root domain rather than from a multiplicity\
    \ of CAs.\n   DNS-Based Authentication of Named Entities (DANE) offers the option\n\
    \   to use the DNSSEC infrastructure to store and sign keys and\n   certificates\
    \ that are used by TLS.  DANE is envisioned as a\n   preferable basis for binding\
    \ public keys to DNS names, because the\n   entities that vouch for the binding\
    \ of public key data to DNS names\n   are the same entities responsible for managing\
    \ the DNS names in\n   question.  While the resulting system still has residual\
    \ security\n   vulnerabilities, it restricts the scope of assertions that can\
    \ be\n   made by any entity, consistent with the naming scope imposed by the\n\
    \   DNS hierarchy.  As a result, DANE embodies the security \"principle of\n \
    \  least privilege\" that is lacking in the current public CA model.\n"
- title: 1.2.  Securing the Association of a Domain Name with a Server's
  contents:
  - "1.2.  Securing the Association of a Domain Name with a Server's\n      Certificate\n\
    \   A TLS client begins a connection by exchanging messages with a TLS\n   server.\
    \  For many application protocols, it looks up the server's\n   name using the\
    \ DNS to get an Internet Protocol (IP) address\n   associated with the name. \
    \ It then begins a connection to a\n   particular port at that address, and sends\
    \ an initial message there.\n   However, the client does not yet know whether\
    \ an adversary is\n   intercepting and/or altering its communication before it\
    \ reaches the\n   TLS server.  It does not even know whether the real TLS server\n\
    \   associated with that domain name has ever received its initial\n   messages.\n\
    \   The first response from the server in TLS may contain a certificate.\n   In\
    \ order for the TLS client to authenticate that it is talking to the\n   expected\
    \ TLS server, the client must validate that this certificate\n   is associated\
    \ with the domain name used by the client to get to the\n   server.  Currently,\
    \ the client must extract the domain name from the\n   certificate and must successfully\
    \ validate the certificate, including\n   chaining to a trust anchor.\n   There\
    \ is a different way to authenticate the association of the\n   server's certificate\
    \ with the intended domain name without trusting\n   an external CA.  Given that\
    \ the DNS administrator for a domain name\n   is authorized to give identifying\
    \ information about the zone, it\n   makes sense to allow that administrator to\
    \ also make an authoritative\n   binding between the domain name and a certificate\
    \ that might be used\n   by a host at that domain name.  The easiest way to do\
    \ this is to use\n   the DNS, securing the binding with DNSSEC.\n   There are\
    \ many use cases for such functionality.  [RFC6394] lists the\n   ones to which\
    \ the DNS RRtype in this document apply.  [RFC6394] also\n   lists many requirements,\
    \ most of which this document is believed to\n   meet.  Section 5 covers the applicability\
    \ of this document to the use\n   cases in detail.  The protocol in this document\
    \ can generally be\n   referred to as the \"DANE TLSA\" protocol.  (\"TLSA\" does\
    \ not stand for\n   anything; it is just the name of the RRtype.)\n   This document\
    \ applies to both TLS [RFC5246] and Datagram TLS (DTLS)\n   [RFC6347].  In order\
    \ to make the document more readable, it mostly\n   only talks about \"TLS\",\
    \ but in all cases, it means \"TLS or DTLS\".\n   Although the references in this\
    \ paragraph are to TLS and DTLS\n   version 1.2, the DANE TLSA protocol can also\
    \ be used with earlier\n   versions of TLS and DTLS.\n   This document only relates\
    \ to securely associating certificates for\n   TLS and DTLS with host names; retrieving\
    \ certificates from DNS for\n   other protocols is handled in other documents.\
    \  For example, keys for\n   IPsec are covered in [RFC4025], and keys for Secure\
    \ SHell (SSH) are\n   covered in [RFC4255].\n"
- title: 1.3.  Method for Securing Certificate Associations
  contents:
  - "1.3.  Method for Securing Certificate Associations\n   A certificate association\
    \ is formed from a piece of information\n   identifying a certificate and the\
    \ domain name where the server\n   application runs.  The combination of a trust\
    \ anchor and a domain\n   name can also be a certificate association.\n   A DNS\
    \ query can return multiple certificate associations, such as in\n   the case\
    \ of a server that is changing from one certificate to another\n   (described\
    \ in more detail in Appendix A.4).\n   This document only applies to PKIX [RFC5280]\
    \ certificates, not\n   certificates of other formats.\n   This document defines\
    \ a secure method to associate the certificate\n   that is obtained from the TLS\
    \ server with a domain name using DNS;\n   the DNS information needs to be protected\
    \ by DNSSEC.  Because the\n   certificate association was retrieved based on a\
    \ DNS query, the\n   domain name in the query is by definition associated with\
    \ the\n   certificate.  Note that this document does not cover how to associate\n\
    \   certificates with domain names for application protocols that depend\n   on\
    \ SRV, NAPTR, and similar DNS resource records.  It is expected that\n   future\
    \ documents will cover methods for making those associations,\n   and those documents\
    \ may or may not need to update this one.\n   DNSSEC, which is defined in [RFC4033],\
    \ [RFC4034], and [RFC4035], uses\n   cryptographic keys and digital signatures\
    \ to provide authentication\n   of DNS data.  Information that is retrieved from\
    \ the DNS and that is\n   validated using DNSSEC is thereby proved to be the authoritative\n\
    \   data.  The DNSSEC signature needs to be validated on all responses\n   that\
    \ use DNSSEC in order to assure the proof of origin of the data.\n   This document\
    \ does not specify how DNSSEC validation occurs because\n   there are many different\
    \ proposals for how a client might get\n   validated DNSSEC results, such as from\
    \ a DNSSEC-aware resolver that\n   is coded in the application, from a trusted\
    \ DNSSEC resolver on the\n   machine on which the application is running, or from\
    \ a trusted DNSSEC\n   resolver with which the application is communicating over\
    \ an\n   authenticated and integrity-protected channel or network.  This is\n\
    \   described in more detail in Section 7 of [RFC4033].\n   This document only\
    \ relates to getting the DNS information for the\n   certificate association securely\
    \ using DNSSEC; other secure DNS\n   mechanisms are out of scope.\n"
- title: 1.4.  Terminology
  contents:
  - "1.4.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ RFC 2119 [RFC2119].\n   This document also makes use of standard PKIX, DNSSEC,\
    \ TLS, and DNS\n   terminology.  See [RFC5280], [RFC4033], [RFC5246], and STD\
    \ 13\n   [RFC1034] [RFC1035], respectively, for these terms.  In addition,\n \
    \  terms related to TLS-protected application services and DNS names are\n   taken\
    \ from [RFC6125].\n"
- title: 2.  The TLSA Resource Record
  contents:
  - "2.  The TLSA Resource Record\n   The TLSA DNS resource record (RR) is used to\
    \ associate a TLS server\n   certificate or public key with the domain name where\
    \ the record is\n   found, thus forming a \"TLSA certificate association\".  The\
    \ semantics\n   of how the TLSA RR is interpreted are given later in this document.\n\
    \   The type value for the TLSA RR type is defined in Section 7.1.\n   The TLSA\
    \ RR is class independent.\n   The TLSA RR has no special Time to Live (TTL) requirements.\n"
- title: 2.1.  TLSA RDATA Wire Format
  contents:
  - "2.1.  TLSA RDATA Wire Format\n   The RDATA for a TLSA RR consists of a one-octet\
    \ certificate usage\n   field, a one-octet selector field, a one-octet matching\
    \ type field,\n   and the certificate association data field.\n              \
    \          1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Cert. Usage  |   Selector    | Matching Type |               /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \               /\n   /                                                      \
    \         /\n   /                 Certificate Association Data               \
    \   /\n   /                                                               /\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 2.1.1.  The Certificate Usage Field
  contents:
  - "2.1.1.  The Certificate Usage Field\n   A one-octet value, called \"certificate\
    \ usage\", specifies the provided\n   association that will be used to match the\
    \ certificate presented in\n   the TLS handshake.  This value is defined in a\
    \ new IANA registry (see\n   Section 7.2) in order to make it easier to add additional\
    \ certificate\n   usages in the future.  The certificate usages defined in this\n\
    \   document are:\n      0 -- Certificate usage 0 is used to specify a CA certificate,\
    \ or\n      the public key of such a certificate, that MUST be found in any of\n\
    \      the PKIX certification paths for the end entity certificate given\n   \
    \   by the server in TLS.  This certificate usage is sometimes\n      referred\
    \ to as \"CA constraint\" because it limits which CA can be\n      used to issue\
    \ certificates for a given service on a host.  The\n      presented certificate\
    \ MUST pass PKIX certification path\n      validation, and a CA certificate that\
    \ matches the TLSA record MUST\n      be included as part of a valid certification\
    \ path.  Because this\n      certificate usage allows both trust anchors and CA\
    \ certificates,\n      the certificate might or might not have the basicConstraints\n\
    \      extension present.\n      1 -- Certificate usage 1 is used to specify an\
    \ end entity\n      certificate, or the public key of such a certificate, that\
    \ MUST be\n      matched with the end entity certificate given by the server in\n\
    \      TLS.  This certificate usage is sometimes referred to as \"service\n  \
    \    certificate constraint\" because it limits which end entity\n      certificate\
    \ can be used by a given service on a host.  The target\n      certificate MUST\
    \ pass PKIX certification path validation and MUST\n      match the TLSA record.\n\
    \      2 -- Certificate usage 2 is used to specify a certificate, or the\n   \
    \   public key of such a certificate, that MUST be used as the trust\n      anchor\
    \ when validating the end entity certificate given by the\n      server in TLS.\
    \  This certificate usage is sometimes referred to as\n      \"trust anchor assertion\"\
    \ and allows a domain name administrator to\n      specify a new trust anchor\
    \ -- for example, if the domain issues\n      its own certificates under its own\
    \ CA that is not expected to be\n      in the end users' collection of trust anchors.\
    \  The target\n      certificate MUST pass PKIX certification path validation,\
    \ with any\n      certificate matching the TLSA record considered to be a trust\n\
    \      anchor for this certification path validation.\n      3 -- Certificate\
    \ usage 3 is used to specify a certificate, or the\n      public key of such a\
    \ certificate, that MUST match the end entity\n      certificate given by the\
    \ server in TLS.  This certificate usage is\n      sometimes referred to as \"\
    domain-issued certificate\" because it\n      allows for a domain name administrator\
    \ to issue certificates for a\n      domain without involving a third-party CA.\
    \  The target certificate\n      MUST match the TLSA record.  The difference between\
    \ certificate\n      usage 1 and certificate usage 3 is that certificate usage\
    \ 1\n      requires that the certificate pass PKIX validation, but PKIX\n    \
    \  validation is not tested for certificate usage 3.\n   The certificate usages\
    \ defined in this document explicitly only apply\n   to PKIX-formatted certificates\
    \ in DER encoding [X.690].  If TLS\n   allows other formats later, or if extensions\
    \ to this RRtype are made\n   that accept other formats for certificates, those\
    \ certificates will\n   need their own certificate usage values.\n"
- title: 2.1.2.  The Selector Field
  contents:
  - "2.1.2.  The Selector Field\n   A one-octet value, called \"selector\", specifies\
    \ which part of the TLS\n   certificate presented by the server will be matched\
    \ against the\n   association data.  This value is defined in a new IANA registry\
    \ (see\n   Section 7.3).  The selectors defined in this document are:\n      0\
    \ -- Full certificate: the Certificate binary structure as defined\n      in [RFC5280]\n\
    \      1 -- SubjectPublicKeyInfo: DER-encoded binary structure as defined\n  \
    \    in [RFC5280]\n   (Note that the use of \"selector\" in this document is completely\n\
    \   unrelated to the use of \"selector\" in DomainKeys Identified Mail\n   (DKIM)\
    \ [RFC6376].)\n"
- title: 2.1.3.  The Matching Type Field
  contents:
  - "2.1.3.  The Matching Type Field\n   A one-octet value, called \"matching type\"\
    , specifies how the\n   certificate association is presented.  This value is defined\
    \ in a new\n   IANA registry (see Section 7.4).  The types defined in this document\n\
    \   are:\n      0 -- Exact match on selected content\n      1 -- SHA-256 hash\
    \ of selected content [RFC6234]\n      2 -- SHA-512 hash of selected content [RFC6234]\n\
    \   If the TLSA record's matching type is a hash, having the record use\n   the\
    \ same hash algorithm that was used in the signature in the\n   certificate (if\
    \ possible) will assist clients that support a small\n   number of hash algorithms.\n"
- title: 2.1.4.  The Certificate Association Data Field
  contents:
  - "2.1.4.  The Certificate Association Data Field\n   This field specifies the \"\
    certificate association data\" to be\n   matched.  These bytes are either raw\
    \ data (that is, the full\n   certificate or its SubjectPublicKeyInfo, depending\
    \ on the selector)\n   for matching type 0, or the hash of the raw data for matching\
    \ types 1\n   and 2.  The data refers to the certificate in the association, not\
    \ to\n   the TLS ASN.1 Certificate object.\n"
- title: 2.2.  TLSA RR Presentation Format
  contents:
  - "2.2.  TLSA RR Presentation Format\n   The presentation format of the RDATA portion\
    \ (as defined in\n   [RFC1035]) is as follows:\n   o  The certificate usage field\
    \ MUST be represented as an 8-bit\n      unsigned integer.\n   o  The selector\
    \ field MUST be represented as an 8-bit unsigned\n      integer.\n   o  The matching\
    \ type field MUST be represented as an 8-bit unsigned\n      integer.\n   o  The\
    \ certificate association data field MUST be represented as a\n      string of\
    \ hexadecimal characters.  Whitespace is allowed within\n      the string of hexadecimal\
    \ characters, as described in [RFC1035].\n"
- title: 2.3.  TLSA RR Examples
  contents:
  - "2.3.  TLSA RR Examples\n   In the following examples, the domain name is formed\
    \ using the rules\n   in Section 3.\n   An example of a hashed (SHA-256) association\
    \ of a PKIX CA\n   certificate:\n   _443._tcp.www.example.com. IN TLSA (\n   \
    \   0 0 1 d2abde240d7cd3ee6b4b28c54df034b9\n            7983a1d16e8a410e4561cb106618e971\
    \ )\n   An example of a hashed (SHA-512) subject public key association of a\n\
    \   PKIX end entity certificate:\n   _443._tcp.www.example.com. IN TLSA (\n  \
    \    1 1 2 92003ba34942dc74152e2f2c408d29ec\n            a5a520e7f2e06bb944f4dca346baf63c\n\
    \            1b177615d466f6c4b71c216a50292bd5\n            8c9ebdd2f74e38fe51ffd48c43326cbc\
    \ )\n   An example of a full certificate association of a PKIX end entity\n  \
    \ certificate:\n   _443._tcp.www.example.com. IN TLSA (\n      3 0 0 30820307308201efa003020102020...\
    \ )\n"
- title: 3.  Domain Names for TLSA Certificate Associations
  contents:
  - "3.  Domain Names for TLSA Certificate Associations\n   Unless there is a protocol-specific\
    \ specification that is different\n   than this one, TLSA resource records are\
    \ stored at a prefixed DNS\n   domain name.  The prefix is prepared in the following\
    \ manner:\n   1.  The decimal representation of the port number on which a TLS-\n\
    \       based service is assumed to exist is prepended with an underscore\n  \
    \     character (\"_\") to become the left-most label in the prepared\n      \
    \ domain name.  This number has no leading zeros.\n   2.  The protocol name of\
    \ the transport on which a TLS-based service\n       is assumed to exist is prepended\
    \ with an underscore character\n       (\"_\") to become the second left-most\
    \ label in the prepared domain\n       name.  The transport names defined for\
    \ this protocol are \"tcp\",\n       \"udp\", and \"sctp\".\n   3.  The base domain\
    \ name is appended to the result of step 2 to\n       complete the prepared domain\
    \ name.  The base domain name is the\n       fully qualified DNS domain name [RFC1035]\
    \ of the TLS server, with\n       the additional restriction that every label\
    \ MUST meet the rules\n       of [RFC0952].  The latter restriction means that,\
    \ if the query is\n       for an internationalized domain name, it MUST use the\
    \ A-label\n       form as defined in [RFC5890].\n   For example, to request a\
    \ TLSA resource record for an HTTP server\n   running TLS on port 443 at \"www.example.com\"\
    ,\n   \"_443._tcp.www.example.com\" is used in the request.  To request a\n  \
    \ TLSA resource record for an SMTP server running the STARTTLS protocol\n   on\
    \ port 25 at \"mail.example.com\", \"_25._tcp.mail.example.com\" is\n   used.\n"
- title: 4.  Use of TLSA Records in TLS
  contents:
  - "4.  Use of TLSA Records in TLS\n   Section 2.1 of this document defines the mandatory\
    \ matching rules for\n   the data from the TLSA certificate associations and the\
    \ certificates\n   received from the TLS server.\n   The TLS session that is to\
    \ be set up MUST be for the specific port\n   number and transport name that was\
    \ given in the TLSA query.\n   Some specifications for applications that run over\
    \ TLS, such as\n   [RFC2818] for HTTP, require that the server's certificate have\
    \ a\n   domain name that matches the host name expected by the client.  Some\n\
    \   specifications, such as [RFC6125], detail how to match the identity\n   given\
    \ in a PKIX certificate with those expected by the user.\n   If a TLSA record\
    \ has certificate usage 2, the corresponding TLS\n   server SHOULD send the certificate\
    \ that is referenced just like it\n   currently sends intermediate certificates.\n"
- title: 4.1.  Usable Certificate Associations
  contents:
  - "4.1.  Usable Certificate Associations\n   An implementation of this protocol\
    \ makes a DNS query for TLSA\n   records, validates these records using DNSSEC,\
    \ and uses the resulting\n   TLSA records and validation status to modify its\
    \ responses to the TLS\n   server.\n   Determining whether a TLSA RRSet can be\
    \ used MUST be based on the\n   DNSSEC validation state (as defined in [RFC4033]).\n\
    \   o  A TLSA RRSet whose DNSSEC validation state is secure MUST be used\n   \
    \   as a certificate association for TLS unless a local policy would\n      prohibit\
    \ the use of the specific certificate association in the\n      secure TLSA RRSet.\n\
    \   o  If the DNSSEC validation state on the response to the request for\n   \
    \   the TLSA RRSet is bogus, this MUST cause TLS not to be started or,\n     \
    \ if the TLS negotiation is already in progress, MUST cause the\n      connection\
    \ to be aborted.\n   o  A TLSA RRSet whose DNSSEC validation state is indeterminate\
    \ or\n      insecure cannot be used for TLS and MUST be considered unusable.\n\
    \   Clients that validate the DNSSEC signatures themselves MUST use\n   standard\
    \ DNSSEC validation procedures.  Clients that rely on another\n   entity to perform\
    \ the DNSSEC signature validation MUST use a secure\n   mechanism between themselves\
    \ and the validator.  Examples of secure\n   transports to other hosts include\
    \ TSIG [RFC2845], SIG(0) [RFC2931],\n   and IPsec [RFC6071].  Note that it is\
    \ not sufficient to use secure\n   transport to a DNS resolver that does not do\
    \ DNSSEC signature\n   validation.  See Section 8.3 for more security considerations\
    \ related\n   to external validators.\n   If a certificate association contains\
    \ a certificate usage, selector,\n   or matching type that is not understood by\
    \ the TLS client, that\n   certificate association MUST be considered unusable.\
    \  If the\n   comparison data for a certificate is malformed, the certificate\n\
    \   association MUST be considered unusable.\n   If a certificate association\
    \ contains a matching type or certificate\n   association data that uses a cryptographic\
    \ algorithm that is\n   considered too weak for the TLS client's policy, the certificate\n\
    \   association MUST be considered unusable.\n   If an application receives zero\
    \ usable certificate associations from\n   a DNS request or from its cache, it\
    \ processes TLS in the normal\n   fashion without any input from the TLSA records.\
    \  If an application\n   receives one or more usable certificate associations,\
    \ it attempts to\n   match each certificate association with the TLS server's\
    \ end entity\n   certificate until a successful match is found.  During the TLS\n\
    \   handshake, if none of the certificate associations matches the\n   certificate\
    \ given by the TLS server, the TLS client MUST abort the\n   handshake.\n   An\
    \ attacker who is able to divert a user to a server under his\n   control is also\
    \ likely to be able to block DNS requests from the user\n   or DNS responses being\
    \ sent to the user.  Thus, in order to achieve\n   any security benefit from certificate\
    \ usage 0 or 1, an application\n   that sends a request for TLSA records needs\
    \ to get either a valid\n   signed response containing TLSA records or verification\
    \ that the\n   domain is insecure or indeterminate.  If a request for a TLSA record\n\
    \   does not meet one of those two criteria but the application continues\n  \
    \ with the TLS handshake anyway, the application has gotten no benefit\n   from\
    \ TLSA and SHOULD NOT make any internal or external indication\n   that TLSA was\
    \ applied.  If an application has a configuration setting\n   that has turned\
    \ on TLSA use, or has any indication that TLSA is in\n   use (regardless of whether\
    \ or not this is configurable), that\n   application either MUST NOT start a TLS\
    \ connection or it MUST abort a\n   TLS handshake if both of the two criteria\
    \ above are not met.\n   The application can perform the TLSA lookup before initiating\
    \ the TLS\n   handshake, or do it during the TLS handshake: the choice is up to\
    \ the\n   client.\n"
- title: 5.  TLSA and DANE Use Cases and Requirements
  contents:
  - "5.  TLSA and DANE Use Cases and Requirements\n   The different types of certificate\
    \ associations defined in TLSA are\n   matched with various sections of [RFC6394].\
    \  The use cases from\n   Section 3 of [RFC6394] are covered in this document\
    \ as follows:\n   3.1 CA Constraints -- Implemented using certificate usage 0.\n\
    \   3.2 Certificate Constraints -- Implemented using certificate usage 1.\n  \
    \ 3.3 Trust Anchor Assertion and Domain-Issued Certificates --\n      Implemented\
    \ using certificate usages 2 and 3, respectively.\n   The requirements from Section\
    \ 4 of [RFC6394] are covered in this\n   document as follows:\n   Multiple Ports\
    \ -- The TLSA records for different application services\n      running on a single\
    \ host can be distinguished through the service\n      name and port number prefixed\
    \ to the host name (see Section 3).\n   No Downgrade -- Section 4 specifies the\
    \ conditions under which a\n      client can process and act upon TLSA records.\
    \  Specifically, if\n      the DNSSEC status for the TLSA resource record set\
    \ is determined\n      to be bogus, the TLS connection (if started) will fail.\n\
    \   Encapsulation -- Encapsulation is covered in the TLSA response\n      semantics.\n\
    \   Predictability -- The appendices of this specification provide\n      operational\
    \ considerations and implementation guidance in order to\n      enable application\
    \ developers to form a consistent interpretation\n      of the recommended client\
    \ behavior.\n   Opportunistic Security -- If a client conformant to this\n   \
    \   specification can reliably determine the presence of a TLSA\n      record,\
    \ it will attempt to use this information.  Conversely, if a\n      client can\
    \ reliably determine the absence of any TLSA record, it\n      will fall back\
    \ to processing TLS in the normal fashion.  This is\n      discussed in Section\
    \ 4.\n   Combination -- Multiple TLSA records can be published for a given\n \
    \     host name, thus enabling the client to construct multiple TLSA\n      certificate\
    \ associations that reflect different assertions.  No\n      support is provided\
    \ to combine two TLSA certificate associations\n      in a single operation.\n\
    \   Roll-over -- TLSA records are processed in the normal manner within\n    \
    \  the scope of the DNS protocol, including the TTL expiration of the\n      records.\
    \  This ensures that clients will not latch onto assertions\n      made by expired\
    \ TLSA records, and will be able to transition from\n      using one public key\
    \ or certificate usage to another.\n   Simple Key Management -- The SubjectPublicKeyInfo\
    \ selector in the\n      TLSA record provides a mode that enables a domain holder\
    \ to only\n      have to maintain a single long-lived public/private key pair\n\
    \      without the need to manage certificates.  Appendix A outlines the\n   \
    \   usefulness and the potential downsides to using this mode.\n   Minimal Dependencies\
    \ -- This specification relies on DNSSEC to\n      protect the origin authenticity\
    \ and integrity of the TLSA resource\n      record set.  Additionally, if DNSSEC\
    \ validation is not performed\n      on the system that wishes to use TLSA certificate\
    \ bindings, this\n      specification requires that the \"last mile\" be over\
    \ a secure\n      transport.  There are no other deployment dependencies for this\n\
    \      approach.\n   Minimal Options -- The operating modes map precisely to the\
    \ DANE use\n      cases and requirements.  DNSSEC use is mandatory in that this\n\
    \      specification encourages applications to use only those TLSA\n      records\
    \ that are shown to be validated.\n   Wildcards -- Wildcards are covered in a\
    \ limited manner in the TLSA\n      request syntax; see Appendix A.\n   Redirection\
    \ -- Redirection is covered in the TLSA request syntax; see\n      Appendix A.\n"
- title: 6.  Mandatory-to-Implement Features
  contents:
  - "6.  Mandatory-to-Implement Features\n   TLS clients conforming to this specification\
    \ MUST be able to\n   correctly interpret TLSA records with certificate usages\
    \ 0, 1, 2,\n   and 3.  TLS clients conforming to this specification MUST be able\
    \ to\n   compare a certificate association with a certificate from the TLS\n \
    \  handshake using selector types 0 and 1, and matching type 0 (no hash\n   used)\
    \ and matching type 1 (SHA-256), and SHOULD be able to make such\n   comparisons\
    \ with matching type 2 (SHA-512).\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   IANA has made the assignments in this section.\n\
    \   In the following sections, \"RFC Required\" was chosen for TLSA\n   certificate\
    \ usages and \"Specification Required\" for selectors and\n   matching types because\
    \ of the amount of detail that is likely to be\n   needed for implementers to\
    \ correctly implement new certificate usages\n   as compared to new selectors\
    \ and matching types.\n"
- title: 7.1.  TLSA RRtype
  contents:
  - "7.1.  TLSA RRtype\n   This document uses a new DNS RR type, TLSA, whose value\
    \ (52) was\n   allocated by IANA from the Resource Record (RR) TYPEs subregistry\
    \ of\n   the Domain Name System (DNS) Parameters registry.\n"
- title: 7.2.  TLSA Certificate Usages
  contents:
  - "7.2.  TLSA Certificate Usages\n   This document creates a new registry, \"TLSA\
    \ Certificate Usages\".  The\n   registry policy is \"RFC Required\".  The initial\
    \ entries in the\n   registry are:\n   Value    Short description            \
    \           Reference\n   ----------------------------------------------------------\n\
    \   0        CA constraint                           RFC 6698\n   1        Service\
    \ certificate constraint          RFC 6698\n   2        Trust anchor assertion\
    \                  RFC 6698\n   3        Domain-issued certificate           \
    \    RFC 6698\n   4-254    Unassigned\n   255      Private use\n   Applications\
    \ to the registry can request specific values that have\n   yet to be assigned.\n"
- title: 7.3.  TLSA Selectors
  contents:
  - "7.3.  TLSA Selectors\n   This document creates a new registry, \"TLSA Selectors\"\
    .  The registry\n   policy is \"Specification Required\".  The initial entries\
    \ in the\n   registry are:\n   Value    Short description                    \
    \   Reference\n   ----------------------------------------------------------\n\
    \   0        Full certificate                        RFC 6698\n   1        SubjectPublicKeyInfo\
    \                    RFC 6698\n   2-254    Unassigned\n   255      Private use\n\
    \   Applications to the registry can request specific values that have\n   yet\
    \ to be assigned.\n"
- title: 7.4.  TLSA Matching Types
  contents:
  - "7.4.  TLSA Matching Types\n   This document creates a new registry, \"TLSA Matching\
    \ Types\".  The\n   registry policy is \"Specification Required\".  The initial\
    \ entries in\n   the registry are:\n   Value    Short description            \
    \           Reference\n   ----------------------------------------------------------\n\
    \   0        No hash used                            RFC 6698\n   1        SHA-256\
    \                                 RFC 6234\n   2        SHA-512              \
    \                   RFC 6234\n   3-254    Unassigned\n   255      Private use\n\
    \   Applications to the registry can request specific values that have\n   yet\
    \ to be assigned.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The security of the DNS RRtype described in this\
    \ document relies on\n   the security of DNSSEC to verify that the TLSA record\
    \ has not been\n   altered.\n   A rogue DNS administrator who changes the A, AAAA,\
    \ and/or TLSA\n   records for a domain name can cause the client to go to an\n\
    \   unauthorized server that will appear authorized, unless the client\n   performs\
    \ PKIX certification path validation and rejects the\n   certificate.  That administrator\
    \ could probably get a certificate\n   issued by some CA anyway, so this is not\
    \ an additional threat.\n   If the authentication mechanism for adding or changing\
    \ TLSA data in a\n   zone is weaker than the authentication mechanism for changing\
    \ the A\n   and/or AAAA records, a man-in-the-middle who can redirect traffic\
    \ to\n   his site may be able to impersonate the attacked host in TLS if he\n\
    \   can use the weaker authentication mechanism.  A better design for\n   authenticating\
    \ DNS would be to have the same level of authentication\n   used for all DNS additions\
    \ and changes for a particular domain name.\n   Secure Socket Layer (SSL) proxies\
    \ can sometimes act as a man-in-the-\n   middle for TLS clients.  In these scenarios,\
    \ the clients add a new\n   trust anchor whose private key is kept on the SSL\
    \ proxy; the proxy\n   intercepts TLS requests, creates a new TLS session with\
    \ the intended\n   host, and sets up a TLS session with the client using a certificate\n\
    \   that chains to the trust anchor installed in the client by the proxy.\n  \
    \ In such environments, using TLSA records will prevent the SSL proxy\n   from\
    \ functioning as expected because the TLS client will get a\n   certificate association\
    \ from the DNS that will not match the\n   certificate that the SSL proxy uses\
    \ with the client.  The client,\n   seeing the proxy's new certificate for the\
    \ supposed destination, will\n   not set up a TLS session.\n   Client treatment\
    \ of any information included in the trust anchor is a\n   matter of local policy.\
    \  This specification does not mandate that\n   such information be inspected\
    \ or validated by the server's domain\n   name administrator.\n   If a server's\
    \ certificate is revoked, or if an intermediate CA in a\n   chain between the\
    \ server and a trust anchor has its certificate\n   revoked, a TLSA record with\
    \ a certificate usage of 2 that matches the\n   revoked certificate would in essence\
    \ override the revocation because\n   the client would treat that revoked certificate\
    \ as a trust anchor and\n   thus not check its revocation status.  Because of\
    \ this, domain\n   administrators need to be responsible for being sure that the\
    \ keys or\n   certificates used in TLSA records with a certificate usage of 2\
    \ are\n   in fact able to be used as reliable trust anchors.\n   Certificates\
    \ that are delivered in TLSA with certificate usage 2\n   fundamentally change\
    \ the way the TLS server's end entity certificate\n   is evaluated.  For example,\
    \ the server's certificate might chain to\n   an existing CA through an intermediate\
    \ CA that has certain policy\n   restrictions, and the certificate would not pass\
    \ those restrictions\n   and thus normally be rejected.  That intermediate CA\
    \ could issue\n   itself a new certificate without the policy restrictions and\
    \ tell its\n   customers to use that certificate with certificate usage 2.  This\
    \ in\n   essence allows an intermediate CA to become a trust anchor for\n   certificates\
    \ that the end user might have expected to chain to an\n   existing trust anchor.\n\
    \   If an administrator wishes to stop using a TLSA record, the\n   administrator\
    \ can simply remove it from the DNS.  Normal clients will\n   stop using the TLSA\
    \ record after the TTL has expired.  Replay attacks\n   against the TLSA record\
    \ are not possible after the expiration date on\n   the RRsig of the TLSA record\
    \ that was removed.\n   Generators of TLSA records should be aware that the client's\
    \ full\n   trust of a certificate association retrieved from a TLSA record may\n\
    \   be a matter of local policy.  While such trust is limited to the\n   specific\
    \ domain name, protocol, and port for which the TLSA query was\n   made, local\
    \ policy may decline to accept the certificate (for reasons\n   such as weak cryptography),\
    \ as is also the case with PKIX trust\n   anchors.\n"
- title: 8.1.  Comparing DANE to Public CAs
  contents:
  - "8.1.  Comparing DANE to Public CAs\n   As stated above, the security of the DNS\
    \ RRtype described in this\n   document relies on the security of DNSSEC to verify\
    \ that the TLSA\n   record has not been altered.  This section describes where\
    \ the\n   security of public CAs and the security of TLSA are similar and\n  \
    \ different.  This section applies equally to other security-related\n   DNS RRtypes\
    \ such as keys for IPsec and SSH.\n   DNSSEC forms certificates (the binding of\
    \ an identity to a key) by\n   combining a DNSKEY, DS, or DLV resource record\
    \ with an associated\n   RRSIG record.  These records then form a signing chain\
    \ extending from\n   the client's trust anchors to the RR of interest.\n   Although\
    \ the DNSSEC protocol does not enforce it, DNSKEYs are often\n   marked with a\
    \ SEP flag indicating whether the key is a Zone Signing\n   Key (ZSK) or a Key\
    \ Signing Key (KSK).  ZSKs protect records in the\n   zone (including DS and DLV\
    \ records), and KSKs protect ZSK DNSKEY\n   records.  This allows KSKs to be stored\
    \ offline.\n   The TLSA RRtype allows keys from the DNSSEC PKI hierarchy to\n\
    \   authenticate keys wrapped in PKIX certificates for a particular host\n   name,\
    \ protocol, and port.\n   With the exception of the DLV RRtype, all of these certificates\n\
    \   constrain the keys they identify to names that are within the zone\n   signing\
    \ the certificate.  In order for a domain's DLV resource\n   records to be honored,\
    \ the domain must be configured as a DLV domain,\n   and the domain's DNSKEYs\
    \ must be configured as trust anchors or be\n   authentic [RFC5074].\n"
- title: 8.1.1.  Risk of Key Compromise
  contents:
  - "8.1.1.  Risk of Key Compromise\n   The risk that a given certificate that has\
    \ a valid signing chain is\n   fake is related to the number of keys that can\
    \ contribute to the\n   validation of the certificate, the quality of protection\
    \ each private\n   key receives, the value of each key to an attacker, and the\
    \ value of\n   falsifying the certificate.\n   DNSSEC allows any set of domains\
    \ to be configured as trust anchors\n   and/or DLVs, but most clients are likely\
    \ to use the root zone as\n   their only trust anchor.  Also, because a given\
    \ DNSKEY can only sign\n   resource records for that zone, the number of private\
    \ keys capable of\n   compromising a given TLSA resource record is limited to\
    \ the number of\n   zones between the TLSA resource record and the nearest trust\
    \ anchor,\n   plus any configured DLV domains.  Typically, this will be six keys,\n\
    \   half of which will be KSKs.\n   PKIX only describes how to validate a certificate\
    \ based on a client-\n   chosen set of trust anchors, but says nothing about how\
    \ many trust\n   anchors to use or how they should be constrained.  As currently\n\
    \   deployed, most PKIX clients use a large number of trust anchors\n   provided\
    \ with the client or operating system software.  These trust\n   anchors are selected\
    \ carefully, but with a desire for broad\n   interoperability.  The trust anchors\
    \ and CA certificates for public\n   CAs rarely have name constraints applied.\n\
    \   A combination of technical protections, process controls, and\n   personnel\
    \ experience contribute to the quality of security that keys\n   receive.\n  \
    \ o  The security surrounding DNSSEC DNSKEYs varies significantly.  The\n    \
    \  KSK/ZSK split allows the KSK to be stored offline and protected\n      more\
    \ carefully than the ZSK, but not all domains do so.  The\n      security applied\
    \ to a zone's DNSKEYs should be proportional to the\n      value of the domain,\
    \ but that is difficult to estimate.  For\n      example, the root DNSKEY has\
    \ protections and controls comparable\n      to or exceeding those of public CAs.\
    \  On the other end of the\n      spectrum, small domains might provide no more\
    \ protection to their\n      keys than they do to their other data.\n   o  The\
    \ security surrounding public CAs also varies.  However, due to\n      financial\
    \ incentives and standards imposed by clients for\n      acceptance into their\
    \ trust anchor stores, CAs generally employ\n      security experts and protect\
    \ their keys carefully, though highly\n      public compromises have occurred.\n"
- title: 8.1.2.  Impact of Key Compromise
  contents:
  - "8.1.2.  Impact of Key Compromise\n   The impact of a key compromise differs significantly\
    \ between the two\n   models.\n   o  DNSKEYs are inherently limited in what they\
    \ can sign, so a\n      compromise of the DNSKEY for \"example.com\" provides\
    \ no avenue of\n      attack against \"example.org\".  Even the impact of a compromise\
    \ of\n      .com's DNSKEY, while considerable, would be limited to .com\n    \
    \  domains.  Only the compromise of the root DNSKEY would have the\n      equivalent\
    \ impact of an unconstrained public CA.\n   o  Public CAs are not typically constrained\
    \ in what names they can\n      sign, and therefore a compromise of even one CA\
    \ allows the\n      attacker to generate a certificate for any name in the DNS.\
    \  A\n      domain holder can get a certificate from any willing CA, or even\n\
    \      multiple CAs simultaneously, making it impossible for a client to\n   \
    \   determine whether the certificate it is validating is legitimate\n      or\
    \ fraudulent.\n   Because a TLSA certificate association is constrained to its\n\
    \   associated name, protocol, and port, the PKIX certificate is\n   similarly\
    \ constrained, even if its public CAs signing the certificate\n   (if any) are\
    \ not.\n"
- title: 8.1.3.  Detection of Key Compromise
  contents:
  - "8.1.3.  Detection of Key Compromise\n   If a key is compromised, rapid and reliable\
    \ detection is important in\n   order to limit the impact of the compromise. \
    \ In this regard, neither\n   model prevents an attacker from near-invisibly attacking\
    \ their\n   victim, provided that the necessary keys are compromised.\n   If a\
    \ public CA is compromised, only the victim will see the\n   fraudulent certificate,\
    \ as there is typically no publicly accessible\n   directory of all the certificates\
    \ issued by a CA that can be\n   inspected.  DNS resource records are typically\
    \ published publicly.\n   However, the attacker could also allow the uncompromised\
    \ records to\n   be published to the Internet as usual but provide a compromised\
    \ DNS\n   view to the victim to achieve the same effect.\n"
- title: 8.1.4.  Spoofing Hostnames
  contents:
  - "8.1.4.  Spoofing Hostnames\n   Some CAs implement technical controls to ensure\
    \ that certificates are\n   not issued to domains with names similar to domains\
    \ that are popular\n   and prone to attack.  Of course, an attacker can attempt\
    \ to\n   circumvent this restriction by finding a CA willing to issue the\n  \
    \ certificate anyway.  However, by using DNSSEC and TLSA, the attacker\n   can\
    \ circumvent this check completely.\n"
- title: 8.2.  DNS Caching
  contents:
  - "8.2.  DNS Caching\n   Implementations of this protocol rely heavily on the DNS,\
    \ and are\n   thus prone to security attacks based on the deliberate\n   mis-association\
    \ of TLSA records and DNS names.  Implementations need\n   to be cautious in assuming\
    \ the continuing validity of an association\n   between a TLSA record and a DNS\
    \ name.\n   In particular, implementations SHOULD rely on their DNS resolver for\n\
    \   confirmation of an association between a TLSA record and a DNS name,\n   rather\
    \ than caching the result of previous domain name lookups.  Many\n   platforms\
    \ already can cache domain name lookups locally when\n   appropriate, and they\
    \ SHOULD be configured to do so.  It is proper\n   for these lookups to be cached,\
    \ however, only when the TTL (Time To\n   Live) information reported by the DNS\
    \ makes it likely that the cached\n   information will remain useful.\n   If implementations\
    \ cache the results of domain name lookups in order\n   to achieve a performance\
    \ improvement, they MUST observe the TTL\n   information reported by DNS.  Implementations\
    \ that fail to follow\n   this rule could be spoofed or have access denied when\
    \ a previously\n   accessed server's TLSA record changes, such as during a certificate\n\
    \   rollover.\n"
- title: 8.3.  External DNSSEC Validators
  contents:
  - "8.3.  External DNSSEC Validators\n   Due to a lack of DNSSEC support in the most\
    \ commonly deployed stub\n   resolvers today, some ISPs have begun checking DNSSEC\
    \ in the\n   recursive resolvers they provide to their customers, setting the\n\
    \   Authentic Data (AD) flag as appropriate.  DNSSEC-aware clients could\n   use\
    \ that data, ignoring the fact that the DNSSEC data has been\n   validated externally.\
    \  Because there is typically no authentication\n   of the recursive resolver\
    \ or integrity protection of the data and AD\n   flag between the client and the\
    \ recursive resolver, this can be\n   trivially spoofed by an attacker.\n   However,\
    \ even with secure communications between a host and the\n   external validating\
    \ resolver, there is a risk that the external\n   validator could become compromised.\
    \  Nothing prevents a compromised\n   external DNSSEC validator from claiming\
    \ that all the records it\n   provides are secure, even if the data is falsified,\
    \ unless the client\n   checks the DNSSEC data itself (rendering the external\
    \ validator\n   unnecessary).\n   For this reason, DNSSEC validation is best performed\
    \ on-host, even\n   when a secure path to an external validator is available.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   Many of the ideas in this document have been discussed\
    \ over many\n   years.  More recently, the ideas have been discussed by the authors\n\
    \   and others in a more focused fashion.  In particular, some of the\n   ideas\
    \ and words here originated with Paul Vixie, Dan Kaminsky, Jeff\n   Hodges, Phillip\
    \ Hallam-Baker, Simon Josefsson, Warren Kumari, Adam\n   Langley, Ben Laurie,\
    \ Ilari Liusvaara, Ondrej Mikle, Scott Schmit,\n   Ondrej Sury, Richard Barnes,\
    \ Jim Schaad, Stephen Farrell, Suresh\n   Krishnaswamy, Peter Palfrader, Pieter\
    \ Lexis, Wouter Wijngaards, John\n   Gilmore, and Murray Kucherawy.\n   This document\
    \ has also been greatly helped by many active\n   participants of the DANE Working\
    \ Group.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names -\
    \ concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n\
    \   [RFC1035]  Mockapetris, P., \"Domain names - implementation and\n        \
    \      specification\", STD 13, RFC 1035, November 1987.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC4033]  Arends, R., Austein, R., Larson,\
    \ M., Massey, D., and S.\n              Rose, \"DNS Security Introduction and\
    \ Requirements\",\n              RFC 4033, March 2005.\n   [RFC4034]  Arends,\
    \ R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"Resource\
    \ Records for the DNS Security Extensions\",\n              RFC 4034, March 2005.\n\
    \   [RFC4035]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n     \
    \         Rose, \"Protocol Modifications for the DNS Security\n              Extensions\"\
    , RFC 4035, March 2005.\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport\
    \ Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August\
    \ 2008.\n   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n \
    \             Housley, R., and W. Polk, \"Internet X.509 Public Key\n        \
    \      Infrastructure Certificate and Certificate Revocation List\n          \
    \    (CRL) Profile\", RFC 5280, May 2008.\n   [RFC6125]  Saint-Andre, P. and J.\
    \ Hodges, \"Representation and\n              Verification of Domain-Based Application\
    \ Service Identity\n              within Internet Public Key Infrastructure Using\
    \ X.509\n              (PKIX) Certificates in the Context of Transport Layer\n\
    \              Security (TLS)\", RFC 6125, March 2011.\n   [RFC6347]  Rescorla,\
    \ E. and N. Modadugu, \"Datagram Transport Layer\n              Security Version\
    \ 1.2\", RFC 6347, January 2012.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [RFC0952]  Harrenstien, K., Stahl, M., and\
    \ E. Feinler, \"DoD Internet\n              host table specification\", RFC 952,\
    \ October 1985.\n   [RFC2782]  Gulbrandsen, A., Vixie, P., and L. Esibov, \"A\
    \ DNS RR for\n              specifying the location of services (DNS SRV)\", RFC\
    \ 2782,\n              February 2000.\n   [RFC2818]  Rescorla, E., \"HTTP Over\
    \ TLS\", RFC 2818, May 2000.\n   [RFC2845]  Vixie, P., Gudmundsson, O., Eastlake\
    \ 3rd, D., and B.\n              Wellington, \"Secret Key Transaction Authentication\
    \ for DNS\n              (TSIG)\", RFC 2845, May 2000.\n   [RFC2931]  Eastlake\
    \ 3rd, D., \"DNS Request and Transaction Signatures\n              ( SIG(0)s)\"\
    , RFC 2931, September 2000.\n   [RFC4025]  Richardson, M., \"A Method for Storing\
    \ IPsec Keying\n              Material in DNS\", RFC 4025, March 2005.\n   [RFC4255]\
    \  Schlyter, J. and W. Griffin, \"Using DNS to Securely\n              Publish\
    \ Secure Shell (SSH) Key Fingerprints\", RFC 4255,\n              January 2006.\n\
    \   [RFC4641]  Kolkman, O. and R. Gieben, \"DNSSEC Operational Practices\",\n\
    \              RFC 4641, September 2006.\n   [RFC5074]  Weiler, S., \"DNSSEC Lookaside\
    \ Validation (DLV)\", RFC 5074,\n              November 2007.\n   [RFC5890]  Klensin,\
    \ J., \"Internationalized Domain Names for\n              Applications (IDNA):\
    \ Definitions and Document Framework\",\n              RFC 5890, August 2010.\n\
    \   [RFC6066]  Eastlake 3rd, D., \"Transport Layer Security (TLS)\n          \
    \    Extensions: Extension Definitions\", RFC 6066,\n              January 2011.\n\
    \   [RFC6071]  Frankel, S. and S. Krishnan, \"IP Security (IPsec) and\n      \
    \        Internet Key Exchange (IKE) Document Roadmap\", RFC 6071,\n         \
    \     February 2011.\n   [RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure\
    \ Hash Algorithms\n              (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\
    \ May 2011.\n   [RFC6376]  Crocker, D., Ed., Hansen, T., Ed., and M. Kucherawy,\
    \ Ed.,\n              \"DomainKeys Identified Mail (DKIM) Signatures\", RFC 6376,\n\
    \              September 2011.\n   [RFC6394]  Barnes, R., \"Use Cases and Requirements\
    \ for DNS-Based\n              Authentication of Named Entities (DANE)\", RFC\
    \ 6394,\n              October 2011.\n   [X.690]    \"Recommendation ITU-T X.690\
    \ (2002) | ISO/IEC 8825-1:2002,\n              Information technology - ASN.1\
    \ encoding rules:\n              Specification of Basic Encoding Rules (BER),\
    \ Canonical\n              Encoding Rules (CER) and Distinguished Encoding Rules\n\
    \              (DER)\", July 2002.\n"
- title: Appendix A.  Operational Considerations for Deploying TLSA Records
  contents:
  - 'Appendix A.  Operational Considerations for Deploying TLSA Records

    '
- title: A.1.  Creating TLSA Records
  contents:
  - "A.1.  Creating TLSA Records\n   When creating TLSA records, care must be taken\
    \ to avoid\n   misconfigurations.  Section 4 of this document states that a TLSA\n\
    \   RRSet whose validation state is secure MUST be used.  This means that\n  \
    \ the existence of such a RRSet effectively disables other forms of\n   name and\
    \ path validation.  A misconfigured TLSA RRSet will\n   effectively disable access\
    \ to the TLS server for all conforming\n   clients, and this document does not\
    \ provide any means of making a\n   gradual transition to using TLSA.\n   When\
    \ creating TLSA records with certificate usage 0 (CA certificate)\n   or usage\
    \ 2 (trust anchor), one needs to understand the implications\n   when choosing\
    \ between selector type 0 (Full certificate) and 1\n   (SubjectPublicKeyInfo).\
    \  A careful choice is required because\n   different methods for building trust\
    \ chains are used by different TLS\n   clients.  The following outlines the cases\
    \ that one ought to be aware\n   of and discusses the implications of the choice\
    \ of selector type.\n   Certificate usage 2 is not affected by the different types\
    \ of chain\n   building when the end entity certificate is the same as the trust\n\
    \   anchor certificate.\n"
- title: A.1.1.  Ambiguities and Corner Cases When TLS Clients Build Trust Chains
  contents:
  - "A.1.1.  Ambiguities and Corner Cases When TLS Clients Build Trust Chains\n  \
    \ TLS clients can implement their own chain-building code rather than\n   rely\
    \ on the chain presented by the TLS server.  This means that,\n   except for the\
    \ end entity certificate, any certificate presented in\n   the suggested chain\
    \ might or might not be present in the final chain\n   built by the client.\n\
    \   Certificates that the client can use to replace certificates from the\n  \
    \ original chain include:\n   o  Client's trust anchors\n   o  Certificates cached\
    \ locally\n   o  Certificates retrieved from a URI listed in an Authority\n  \
    \    Information Access X.509v3 extension\n   CAs frequently reissue certificates\
    \ with different validity periods,\n   signature algorithms (such as a different\
    \ hash algorithm in the\n   signature algorithm), CA key pairs (such as for a\
    \ cross-certificate),\n   or PKIX extensions where the public key and subject\
    \ remain the same.\n   These reissued certificates are the certificates that the\
    \ TLS client\n   can use in place of an original certificate.\n   Clients are\
    \ known to exchange or remove certificates that could cause\n   TLSA certificate\
    \ associations that rely on the full certificate to\n   fail.  For example:\n\
    \   o  The client considers the signature algorithm of a certificate to\n    \
    \  no longer be sufficiently secure.\n   o  The client might not have an associated\
    \ root certificate in its\n      trust store and instead uses a cross-certificate\
    \ with an identical\n      subject and public key.\n"
- title: A.1.2.  Choosing a Selector Type
  contents:
  - "A.1.2.  Choosing a Selector Type\n   In this section, \"false-negative failure\"\
    \ means that a client will\n   not accept the TLSA certificate association for\
    \ a certificate\n   designated by the DNS administrator.  Also, \"false-positive\n\
    \   acceptance\" means that the client accepts a TLSA association for a\n   certificate\
    \ that is not designated by the DNS administrator.\n"
- title: A.1.2.1.  Selector Type 0 (Full Certificate)
  contents:
  - "A.1.2.1.  Selector Type 0 (Full Certificate)\n   The \"Full certificate\" selector\
    \ provides the most precise\n   specification of a TLSA certificate association,\
    \ capturing all\n   fields of the PKIX certificate.  For a DNS administrator,\
    \ the best\n   course to avoid false-negative failures in the client when using\
    \ this\n   selector is:\n   1.  If a CA issued a replacement certificate, don't\
    \ associate to CA\n       certificates that have a signature algorithm with a\
    \ hash that is\n       considered weak by local policy.\n   2.  Determine how\
    \ common client applications process the TLSA\n       certificate association\
    \ using a fresh client installation -- that\n       is, with the local certificate\
    \ cache empty.\n"
- title: A.1.2.2.  Selector Type 1 (SubjectPublicKeyInfo)
  contents:
  - "A.1.2.2.  Selector Type 1 (SubjectPublicKeyInfo)\n   A SubjectPublicKeyInfo selector\
    \ gives greater flexibility in avoiding\n   some false-negative failures caused\
    \ by trust-chain-building\n   algorithms used in clients.\n   One specific use\
    \ case ought to be noted: creating a TLSA certificate\n   association to CA certificate\
    \ I1 that directly signed end entity\n   certificate S1 of the server.  The case\
    \ can be illustrated by the\n   following graph:\n           +----+          \
    \            +----+\n           | I1 |                      | I2 |\n         \
    \  +----+                      +----+\n              |                       \
    \    |\n              v                           v\n           +----+       \
    \               +----+\n           | S1 |                      | S1 |\n      \
    \     +----+                      +----+\n   Certificate chain sent by    A different\
    \ validation path\n   server in TLS handshake      built by the TLS client\n \
    \  I2 is a reissued version of CA certificate I1 (that is, it has a\n   different\
    \ hash in its signature algorithm).\n   In the above scenario, both certificates\
    \ I1 and I2 that sign S1 need\n   to have identical SubjectPublicKeyInfo fields\
    \ because the key used to\n   sign S1 is fixed.  An association to SubjectPublicKeyInfo\
    \ (selector\n   type 1) will always succeed in such a case, but an association\
    \ with a\n   full certificate (selector type 0) might not work due to a false-\n\
    \   negative failure.\n   The attack surface is a bit broader compared to the\
    \ \"Full\n   certificate\" selector: the DNS administrator might unintentionally\n\
    \   specify an association that would lead to false-positive acceptance.\n   o\
    \  The administrator must know or trust that the CA does not engage\n      in\
    \ bad practices, such as not sharing the key of I1 for unrelated\n      CA certificates\
    \ (which would lead to trust-chain redirection).  If\n      possible, the administrator\
    \ ought to review all CA certificates\n      that have the same SubjectPublicKeyInfo\
    \ field.\n   o  The administrator ought to understand whether some PKIX extension\n\
    \      may adversely affect security of the association.  If possible,\n     \
    \ administrators ought to review all CA certificates that share the\n      SubjectPublicKeyInfo.\n\
    \   o  The administrator ought to understand that any CA could, in the\n     \
    \ future, issue a certificate that contains the same\n      SubjectPublicKeyInfo.\
    \  Therefore, new chains can crop up in the\n      future without any warning.\n\
    \   Using the SubjectPublicKeyInfo selector for association with a\n   certificate\
    \ in a chain above I1 needs to be decided on a case-by-case\n   basis: there are\
    \ too many possibilities based on the issuing CA's\n   practices.  Unless the\
    \ full implications of such an association are\n   understood by the administrator,\
    \ using selector type 0 is a better\n   option from a security perspective.\n"
- title: A.2.  Provisioning TLSA Records in DNS
  contents:
  - 'A.2.  Provisioning TLSA Records in DNS

    '
- title: A.2.1.  Provisioning TLSA Records with Aliases
  contents:
  - "A.2.1.  Provisioning TLSA Records with Aliases\n   The TLSA resource record is\
    \ not special in the DNS; it acts exactly\n   like any other RRtype where the\
    \ queried name has one or more labels\n   prefixed to the base name, such as the\
    \ SRV RRtype [RFC2782].  This\n   affects the way that the TLSA resource record\
    \ is used when aliasing\n   in the DNS.\n   Note that the IETF sometimes adds\
    \ new types of aliasing in the DNS.\n   If that happens in the future, those aliases\
    \ might affect TLSA\n   records, hopefully in a good way.\n"
- title: A.2.1.1.  Provisioning TLSA Records with CNAME Records
  contents:
  - "A.2.1.1.  Provisioning TLSA Records with CNAME Records\n   Using CNAME to alias\
    \ in DNS only aliases from the exact name given,\n   not any zones below the given\
    \ name.  For example, assume that a zone\n   file has only the following:\n  \
    \ sub1.example.com.          IN CNAME sub2.example.com.\n   In this case, a request\
    \ for the A record at \"bottom.sub1.example.com\"\n   would not return any records\
    \ because the CNAME given only aliases the\n   name given.  Assume, instead, the\
    \ zone file has the following:\n   sub3.example.com.          IN CNAME sub4.example.com.\n\
    \   bottom.sub3.example.com.   IN CNAME bottom.sub4.example.com.\n   In this case,\
    \ a request for the A record at bottom.sub3.example.com\n   would in fact return\
    \ whatever value for the A record exists at\n   bottom.sub4.example.com.\n   Application\
    \ implementations and full-service resolvers request DNS\n   records using libraries\
    \ that automatically follow CNAME (and DNAME)\n   aliasing.  This allows hosts\
    \ to put TLSA records in their own zones\n   or to use CNAME to do redirection.\n\
    \   If the owner of the original domain wants a TLSA record for the same,\n  \
    \ they simply enter it under the defined prefix:\n   ; No TLSA record in target\
    \ domain\n   ;\n   sub5.example.com.            IN CNAME sub6.example.com.\n \
    \  _443._tcp.sub5.example.com.  IN TLSA 1 1 1 308202c5308201ab...\n   sub6.example.com.\
    \            IN A 192.0.2.1\n   sub6.example.com.            IN AAAA 2001:db8::1\n\
    \   If the owner of the original domain wants to have the target domain\n   host\
    \ the TLSA record, the original domain uses a CNAME record:\n   ; TLSA record\
    \ for original domain has CNAME to target domain\n   ;\n   sub5.example.com. \
    \           IN CNAME sub6.example.com.\n   _443._tcp.sub5.example.com.  IN CNAME\
    \ _443._tcp.sub6.example.com.\n   sub6.example.com.            IN A 192.0.2.1\n\
    \   sub6.example.com.            IN AAAA 2001:db8::1\n   _443._tcp.sub6.example.com.\
    \  IN TLSA 1 1 1 536a570ac49d9ba4...\n   Note that it is acceptable for both the\
    \ original domain and the\n   target domain to have TLSA records, but the two\
    \ records are\n   unrelated.  Consider the following:\n   ; TLSA record in both\
    \ the original and target domain\n   ;\n   sub5.example.com.            IN CNAME\
    \ sub6.example.com.\n   _443._tcp.sub5.example.com.  IN TLSA 1 1 1 308202c5308201ab...\n\
    \   sub6.example.com.            IN A 192.0.2.1\n   sub6.example.com.        \
    \    IN AAAA 2001:db8::1\n   _443._tcp.sub6.example.com.  IN TLSA 1 1 1 ac49d9ba4570ac49...\n\
    \   In this example, someone looking for the TLSA record for\n   sub5.example.com\
    \ would always get the record whose value starts with\n   \"308202c5308201ab\"\
    ; the TLSA record whose value starts with\n   \"ac49d9ba4570ac49\" would only\
    \ be sought by someone who is looking for\n   the TLSA record for sub6.example.com,\
    \ and never for sub5.example.com.\n   Note that deploying different certificates\
    \ for multiple services\n   located at a shared TLS listener often requires the\
    \ use of TLS SNI\n   (Server Name Indication) [RFC6066].\n   Note that these methods\
    \ use the normal method for DNS aliasing using\n   CNAME: the DNS client requests\
    \ the record type that they actually\n   want.\n"
- title: A.2.1.2.  Provisioning TLSA Records with DNAME Records
  contents:
  - "A.2.1.2.  Provisioning TLSA Records with DNAME Records\n   Using DNAME records\
    \ allows a zone owner to alias an entire subtree of\n   names below the name that\
    \ has the DNAME.  This allows the wholesale\n   aliasing of prefixed records such\
    \ as those used by TLSA, SRV, and so\n   on without aliasing the name itself.\
    \  However, because DNAME can only\n   be used for subtrees of a base name, it\
    \ is rarely used to alias\n   individual hosts that might also be running TLS.\n\
    \   ; TLSA record in target domain, visible in original domain via DNAME\n   ;\n\
    \   sub5.example.com.            IN CNAME sub6.example.com.\n   _tcp.sub5.example.com.\
    \       IN DNAME _tcp.sub6.example.com.\n   sub6.example.com.            IN A\
    \ 192.0.2.1\n   sub6.example.com.            IN AAAA 2001:db8::1\n   _443._tcp.sub6.example.com.\
    \  IN TLSA 1 1 1 536a570ac49d9ba4...\n"
- title: A.2.1.3.  Provisioning TLSA Records with Wildcards
  contents:
  - "A.2.1.3.  Provisioning TLSA Records with Wildcards\n   Wildcards are generally\
    \ not terribly useful for RRtypes that require\n   prefixing because one can only\
    \ wildcard at a layer below the host\n   name.  For example, if one wants to have\
    \ the same TLSA record for\n   every TCP port for www.example.com, the result\
    \ might be:\n   *._tcp.www.example.com.    IN TLSA 1 1 1 5c1502a6549c423b...\n\
    \   This is possibly useful in some scenarios where the same service is\n   offered\
    \ on many ports or the same certificate and/or key is used for\n   all services\
    \ on a host.  Note that the domain being searched for is\n   not necessarily related\
    \ to the domain name found in the certificate,\n   so a certificate with a wildcard\
    \ in it is not searched for using a\n   wildcard in the search request.\n"
- title: A.3.  Securing the Last Hop
  contents:
  - "A.3.  Securing the Last Hop\n   As described in Section 4, an application processing\
    \ TLSA records\n   must know the DNSSEC validity of those records.  There are\
    \ many ways\n   for the application to determine this securely, and this\n   specification\
    \ does not mandate any single method.\n   Some common methods for an application\
    \ to know the DNSSEC validity of\n   TLSA records include:\n   o  The application\
    \ can have its own DNS resolver and DNSSEC\n      validation stack.\n   o  The\
    \ application can communicate through a trusted channel (such as\n      requests\
    \ to the operating system under which the application is\n      running) to a\
    \ local DNS resolver that does DNSSEC validation.\n   o  The application can communicate\
    \ through a secured channel (such as\n      requests running over TLS, IPsec,\
    \ TSIG, or SIG(0)) to a non-local\n      DNS resolver that does DNSSEC validation.\n\
    \   o  The application can communicate through a secured channel (such as\n  \
    \    requests running over TLS, IPsec, TSIG, or SIG(0)) to a non-local\n     \
    \ DNS resolver that does not do DNSSEC validation, but gets\n      responses through\
    \ a secured channel from a different DNS resolver\n      that does DNSSEC validation.\n"
- title: A.4.  Handling Certificate Rollover
  contents:
  - "A.4.  Handling Certificate Rollover\n   Certificate rollover is handled in much\
    \ the same way as for rolling\n   DNSSEC zone signing keys using the pre-publish\
    \ key rollover method\n   [RFC4641].  Suppose example.com has a single TLSA record\
    \ for a TLS\n   service on TCP port 990:\n   _990._tcp.example.com IN TLSA 1 1\
    \ 1 1CFC98A706BCF3683015...\n   To start the rollover process, obtain or generate\
    \ the new certificate\n   or SubjectPublicKeyInfo to be used after the rollover\
    \ and generate\n   the new TLSA record.  Add that record alongside the old one:\n\
    \   _990._tcp.example.com IN TLSA 1 1 1 1CFC98A706BCF3683015...\n   _990._tcp.example.com\
    \ IN TLSA 1 1 1 62D5414CD1CC657E3D30...\n   After the new records have propagated\
    \ to the authoritative\n   nameservers and the TTL of the old record has expired,\
    \ switch to the\n   new certificate on the TLS server.  Once this has occurred,\
    \ the old\n   TLSA record can be removed:\n   _990._tcp.example.com IN TLSA 1\
    \ 1 1 62D5414CD1CC657E3D30...\n   This completes the certificate rollover.\n"
- title: Appendix B.  Pseudocode for Using TLSA
  contents:
  - "Appendix B.  Pseudocode for Using TLSA\n   This appendix describes, in pseudocode\
    \ format, the interactions given\n   earlier in this specification.  If the steps\
    \ below disagree with the\n   text earlier in the document, the steps earlier\
    \ in the document ought\n   to be considered correct and this text incorrect.\n\
    \   Note that this pseudocode is more strict than the normative text.\n   For\
    \ instance, it forces an order on the evaluation of criteria, which\n   is not\
    \ mandatory from the normative text.\n"
- title: B.1.  Helper Functions
  contents:
  - "B.1.  Helper Functions\n   // implement the function for exiting\n   function\
    \ Finish (F) = {\n     if (F == ABORT_TLS) {\n       abort the TLS handshake or\
    \ prevent TLS from starting\n       exit\n     }\n     if (F == NO_TLSA) {\n \
    \      fall back to non-TLSA certificate validation\n       exit\n     }\n   \
    \  if (F == ACCEPT) {\n       accept the TLS connection\n       exit\n     }\n\
    \     // unreachable\n   }\n   // implement the selector function\n   function\
    \ Select (S, X) = {\n     // Full certificate\n     if (S == 0) {\n       return\
    \ X in DER encoding\n     }\n     // SubjectPublicKeyInfo\n     if (S == 1) {\n\
    \       return X.SubjectPublicKeyInfo in DER encoding\n     }\n     // unreachable\n\
    \   }\n   // implement the matching function\n   function Match (M, X, Y) {\n\
    \     // Exact match on selected content\n     if (M == 0) {\n       return (X\
    \ == Y)\n     }\n     // SHA-256 hash of selected content\n     if (M == 1) {\n\
    \       return (SHA-256(X) == Y)\n     }\n     // SHA-512 hash of selected content\n\
    \     if (M == 2) {\n       return (SHA-512(X) == Y)\n     }\n     // unreachable\n\
    \   }\n"
- title: B.2.  Main TLSA Pseudocode
  contents:
  - "B.2.  Main TLSA Pseudocode\n   TLS connect using [transport] to [name] on [port]\
    \ and receiving end\n   entity cert C for the TLS server:\n   (TLSArecords, ValState)\
    \ = DNSSECValidatedLookup(\n     domainname=_[port]._[transport].[name], RRtype=TLSA)\n\
    \   // check for states that would change processing\n   if (ValState == BOGUS)\
    \ {\n     Finish(ABORT_TLS)\n   }\n   if ((ValState == INDETERMINATE) or (ValState\
    \ == INSECURE)) {\n     Finish(NO_TLSA)\n   }\n   // if here, ValState must be\
    \ SECURE\n   for each R in TLSArecords {\n     // unusable records include unknown\
    \ certUsage, unknown\n     // selectorType, unknown matchingType, erroneous RDATA,\
    \ and\n     // prohibited by local policy\n     if (R is unusable) {\n       remove\
    \ R from TLSArecords\n     }\n   }\n   if (length(TLSArecords) == 0) {\n     Finish(NO_TLSA)\n\
    \   }\n   // A TLS client might have multiple trust anchors that it might use\n\
    \   //    when validating the TLS server's end entity (EE) certificate.\n   //\
    \    Also, there can be multiple PKIX certification paths for the\n   //    certificates\
    \ given by the server in TLS.  Thus, there are\n   //    possibly many chains\
    \ that might need to be tested during\n   //    PKIX path validation.\n   for\
    \ each R in TLSArecords {\n     // pass PKIX certificate validation and chain\
    \ through a CA cert\n     //    that comes from TLSA\n     if (R.certUsage ==\
    \ 0) {\n       for each PKIX certification path H {\n         if (C passes PKIX\
    \ certification path validation in H) {\n           for each D in H {\n      \
    \       if ((D is a CA certificate) and\n                 Match(R.matchingType,\
    \ Select(R.selectorType, D),\n                       R.cert)) {\n            \
    \   Finish(ACCEPT)\n             }\n           }\n         }\n       }\n     }\n\
    \     // pass PKIX certificate validation and match EE cert from TLSA\n     if\
    \ (R.certUsage == 1) {\n       for each PKIX certification path H {\n        \
    \ if ((C passes PKIX certificate validation in H) and\n                 Match(R.matchingType,\
    \ Select(R.selectorType, C),\n                 R.cert)) {\n             Finish(ACCEPT)\n\
    \         }\n       }\n     }\n     // pass PKIX certification validation using\
    \ TLSA record as the\n     //    trust anchor\n     if (R.certUsage == 2) {\n\
    \       // the following assert() is merely a formalization of the\n       //\
    \ \"trust anchor\" condition for a certificate D matching R\n       assert(Match(R.matchingType,\
    \ Select(R.selectorType, D), R.cert))\n       for each PKIX certification path\
    \ H that has certificate D\n           matching R as the trust anchor {\n    \
    \     if (C passes PKIX validation in H) {\n           Finish(ACCEPT);\n     \
    \    }\n       }\n     }\n     // match the TLSA record and the TLS certificate\n\
    \     if (R.certUsage == 3) {\n       if Match(R.matchingType, Select(R.selectorType,\
    \ C), R.cert)\n         Finish(ACCEPT)\n       }\n     }\n   }\n   // if here,\
    \ then none of the TLSA records ended in \"Finish(ACCEPT)\"\n   //   so abort\
    \ TLS\n   Finish(ABORT_TLS)\n"
- title: Appendix C.  Examples
  contents:
  - "Appendix C.  Examples\n   The following are examples of self-signed certificates\
    \ that have been\n   generated with various selectors and matching types.  They\
    \ were\n   generated with one piece of software, and validated by an individual\n\
    \   using other tools.\n   S = Selector\n   M = Matching Type\n   S M Association\
    \ Data\n   0 0 30820454308202BC020900AB58D24E77AD2AF6300D06092A86\n       4886F70D0101050500306C310B3009060355040613024E4C31163014\n\
    \       0603550408130D4E6F6F72642D486F6C6C616E643112301006035504\n       071309416D7374657264616D310C300A060355040A13034F53333123\n\
    \       30210603550403131A64616E652E6B6965762E70726163746963756D\n       2E6F73332E6E6C301E170D3132303131363136353730335A170D3232\n\
    \       303131333136353730335A306C310B3009060355040613024E4C3116\n       30140603550408130D4E6F6F72642D486F6C6C616E64311230100603\n\
    \       5504071309416D7374657264616D310C300A060355040A13034F5333\n       312330210603550403131A64616E652E6B6965762E70726163746963\n\
    \       756D2E6F73332E6E6C308201A2300D06092A864886F70D0101010500\n       0382018F003082018A0282018100E62C84A5AFE59F0A2A6B250DEE68\n\
    \       7AC8C5C604F57D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B\n       6AD5DEA0C8771C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE\n\
    \       281A68230B24B9DA1A98DCBE51195B60E42FD7517C328D983E26A827\n       C877AB914EE4C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D5\n\
    \       8C389CC3D6D8C20662E19CF768F32441B7F7D14AEA8966CE7C32A172\n       2AB38623D008029A9E4702883F8B977A1A1E5292BF8AD72239D40393\n\
    \       37B86A3AC60FA001290452177BF1798609A05A130F033457A5212629\n       FBDDB8E70E2A9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D\n\
    \       4BD77DFA34035563C126AA2C3328B900E7990AC9787F01DA82F74C3D\n       4B6674CCECE1FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE775\n\
    \       6213BD3D60831175BE290442B4AFC5AE6F46B769855A067C1097E617\n       962529E166F22AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A44\n\
    \       9C8D0D31BC683C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2\n       DDFF6B4CAC050203010001300D06092A864886F70D01010505000382\n\
    \       0181002B2ABE063E9C86AC4A1F7835372091079C8276A9C2C5D1EC57\n       64DE523FDDABDEAB3FD34E6FE6CBA054580A6785A663595D90132B93\n\
    \       D473929E81FA0887D2FFF78A81C7D014B97778AB6AC9E5E690F6F5A9\n       E92BB5FBAB71B857AE69B6E18BDCCB0BA6FCD9D4B084A34F3635148C\n\
    \       495D48FE635903B888EC1DEB2610548EDD48D63F86513A4562469831\n       48C0D5DB82D73A4C350A42BB661D763430FC6C8E5F9D13EA1B76AA52\n\
    \       A4C358E5EA04000F794618303AB6CEEA4E9A8E9C74D73C1B0B7BAF16\n       DEDE7696B5E2F206F777100F5727E1684D4132F5E692F47AF6756EA8\n\
    \       B421000BE031B5D8F0220E436B51FB154FE9595333C13A2403F9DE08\n       E5DDC5A22FD6182E339593E26374450220BC14F3E40FF33F084526B0\n\
    \       9C34250702E8A352B332CCCB0F9DE2CF2B338823B92AFC61C0B6B8AB\n       DB5AF718ED8DDA97C298E46B82A01B14814868CFA4F2C36268BFFF4A\n\
    \       591F42658BF75918902D3E426DFE1D5FF0FC6A212071F6DA8BD833FE\n       2E560D87775E8EE9333C05B6FB8EB56589D910DB5EA903\n\
    \   0 1 EFDDF0D915C7BDC5782C0881E1B2A95AD099FBDD06D7B1F779\n       82D9364338D955\n\
    \   0 2 81EE7F6C0ECC6B09B7785A9418F54432DE630DD54DC6EE9E3C\n       49DE547708D236D4C413C3E97E44F969E635958AA410495844127C04\n\
    \       883503E5B024CF7A8F6A94\n   1 0 308201A2300D06092A864886F70D01010105000382018F0030\n\
    \       82018A0282018100E62C84A5AFE59F0A2A6B250DEE687AC8C5C604F5\n       7D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B6AD5DEA0C877\n\
    \       1C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE281A68230B24\n       B9DA1A98DCBE51195B60E42FD7517C328D983E26A827C877AB914EE4\n\
    \       C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D58C389CC3D6D8\n       C20662E19CF768F32441B7F7D14AEA8966CE7C32A1722AB38623D008\n\
    \       029A9E4702883F8B977A1A1E5292BF8AD72239D4039337B86A3AC60F\n       A001290452177BF1798609A05A130F033457A5212629FBDDB8E70E2A\n\
    \       9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D4BD77DFA3403\n       5563C126AA2C3328B900E7990AC9787F01DA82F74C3D4B6674CCECE1\n\
    \       FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE7756213BD3D6083\n       1175BE290442B4AFC5AE6F46B769855A067C1097E617962529E166F2\n\
    \       2AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A449C8D0D31BC68\n       3C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2DDFF6B4CAC05\n\
    \       0203010001\n   1 1 8755CDAA8FE24EF16CC0F2C918063185E433FAAF1415664911\n\
    \       D9E30A924138C4\n   1 2 D43165B4CDF8F8660AECCCC5344D9D9AE45FFD7E6AAB7AB9EE\n\
    \       C169B58E11F227ED90C17330CC17B5CCEF0390066008C720CEC6AAE5\n       33A934B3A2D7E232C94AB4\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Paul Hoffman\n   VPN Consortium\n   EMail: paul.hoffman@vpnc.org\n\
    \   Jakob Schlyter\n   Kirei AB\n   EMail: jakob@kirei.se\n"
