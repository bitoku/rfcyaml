- contents:
  - '                   Routing Policy System Replication

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n
    \  The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n
    \  \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n
    \  document are to be interpreted as described in RFC 2119.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   The RIPE database specifications and RPSL define languages used
    as\n   the basis for representing information in a routing policy system.  A\n
    \  repository for routing policy system information is known as a\n   routing
    registry.  A routing registry provides a means of exchanging\n   information needed
    to address many issues of importance to the\n   operation of the Internet.  The
    implementation and deployment of a\n   routing policy system must maintain some
    degree of integrity to be of\n   any use.  The Routing Policy System Security
    RFC [3] addresses the\n   need to assure integrity of the data by proposing an
    authentication\n   and authorization model.  This document addresses the need
    to\n   distribute data over multiple repositories and delegate authority for\n
    \  data subsets to other repositories without compromising the\n   authorization
    model established in Routing Policy System Security\n   RFC.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1  Overview . . . . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n   2  Data Representation  . . . . . . . . . . . . . . . . . .
    . . .   4\n   3  Authentication and Authorization . . . . . . . . . . . . . .
    .   5\n   4  Repository Hierarchy . . . . . . . . . . . . . . . . . . . . .   6\n
    \  5  Additions to RPSL  . . . . . . . . . . . . . . . . . . . . . .   6\n      5.1
    \ repository object . . . . . . . . . . . . . . . . . . . .   7\n      5.2  delegated
    attribute . . . . . . . . . . . . . . . . . . .   9\n      5.3  integrity attribute
    . . . . . . . . . . . . . . . . . . .  10\n   6  Interactions with a Repository
    or Mirror . . . . . . . . . . .  11\n      6.1  Initial Transaction Submission
    \ . . . . . . . . . . . . .  12\n      6.2  Redistribution of Transactions  .
    . . . . . . . . . . . .  12\n      6.3  Transaction Commit and Confirmation .
    . . . . . . . . . .  12\n   7  Data Format Summaries, Transaction Encapsulation
    and Processing 13\n      7.1  Transaction Submit and Confirm  . . . . . . . .
    . . . . .  13\n      7.2  Redistribution of Transactions  . . . . . . . . . .
    . . .  16\n      7.3  Redistribution Protocol Description . . . . . . . . . .
    .  16\n           7.3.1 Explicitly Requesting Transactions  . . . . . . . .  21\n
    \          7.3.2 Heartbeat Processing  . . . . . . . . . . . . . . .  22\n      7.4
    \ Transaction Commit  . . . . . . . . . . . . . . . . . . .  23\n      7.5  Database
    Snapshot . . . . . . . . . . . . . . . . . . . .  24\n      7.6  Authenticating
    Operations . . . . . . . . . . . . . . . .  25\n   A  Examples . . . . . . . .
    . . . . . . . . . . . . . . . . . . .  27\n      A.1  Initial Object Submission
    and Redistribution  . . . . . .  27\n      A.2  Transaction Redistribution Encoding
    . . . . . . . . . . .  29\n      A.3  Transaction Protocol Encoding . . . . .
    . . . . . . . . .  31\n      A.4  Transaction Redistribution  . . . . . . . .
    . . . . . . .  32\n   B  Technical Discussion . . . . . . . . . . . . . . . .
    . . . . .  35\n      B.1  Server Processing . . . . . . . . . . . . . . . . .
    . . .  35\n           B.1.1 getting connected . . . . . . . . . . . . . . . .
    .  35\n           B.1.2 rolling transaction logs forward and back . . . . .  35\n
    \          B.1.3 committing or disposing of transactions . . . . . .  36\n           B.1.4
    dealing with concurrency  . . . . . . . . . . . . .  36\n      B.2  Repository
    Mirroring for Redundancy . . . . . . . . . . .  36\n      B.3  Trust Relationships
    . . . . . . . . . . . . . . . . . . .  37\n      B.4  A Router as a Minimal Mirror
    \ . . . . . . . . . . . . . .  38\n      B.5  Dealing with Errors . . . . . .
    . . . . . . . . . . . . .  38\n   C  Deployment Considerations  . . . . . . .
    . . . . . . . . . . .  39\n   D  Privacy of Contact Information . . . . . . .
    . . . . . . . . .  39\n   References  . . . . . . . . . . . . . . . . . . . .
    . . . . . . .  40\n   Security Considerations . . . . . . . . . . . . . . . .
    . . . . .  41\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . .
    . . .  41\n   Full Copyright Statement  . . . . . . . . . . . . . . . . . . .
    .  42\n"
  title: Table of Contents
- contents:
  - "1  Overview\n   A routing registry must maintain some degree of integrity to
    be of\n   any use.  The IRR is increasingly used for purposes that have a\n   stronger
    requirement for data integrity and security.  There is also\n   a desire to further
    decentralize the IRR. This document proposes a\n   means of decentralizing the
    routing registry in a way that is\n   consistent with the usage of the IRR and
    which avoids compromising\n   data integrity and security even if the IRR is distributed
    among less\n   trusted repositories.\n   Two methods of authenticating the routing
    registry information have\n   been proposed.\n   authorization and authentication
    checks on transactions:  The\n      integrity of the routing registry data is
    insured by repeating\n      authorization checks as transactions are processed.
    \ As\n      transactions are flooded each remote registry has the option to\n
    \     repeat the authorization and authentication checks.  This scales\n      with
    the total number of changes to the registry regardless of how\n      many registries
    exist.  When querying, the integrity of the\n      repository must be such that
    it can be trusted.  If an\n      organization is unwilling to trust any of the
    available\n      repositories or mirrors they have the option to run their own\n
    \     mirror and repeat authorization checks at that mirror site.\n      Queries
    can then be directed to a mirror under their own\n      administration which presumably
    can be trusted.\n   signing routing registry objects:  An alternate which appears
    on the\n      surface to be attractive is signing the objects themselves.\n      Closer
    examination reveals that the approach of signing objects by\n      itself is flawed
    and when used in addition to signing transactions\n      and rechecking authorizations
    as changes are made adds nothing.\n      In order for an insertion of critical
    objects such as inetnums and\n      routes to be valid, authorization checks must
    be made which allow\n      the insertion.  The objects on which those authorization
    checks\n      are made may later change.  In order to later repeat the\n      authorization
    checks the state of other objects, possibly in other\n      repositories would
    have to be known.  If the repository were not\n      trusted then the change history
    on the object would have to be\n      traced back to the object's insertion.  If
    the repository were not\n      trusted, the change history of any object that
    was depended upon\n      for authorization would also have to be rechecked.  This
    trace\n      back would have to go back to the epoch or at least to a point\n
    \     where only trusted objects were being relied upon for the\n      authorizations.
    \ If the depth of the search is at all limited,\n      authorization could be
    falsified simply by exceeding the search\n      depth with a chain of authorization
    references back to falsified\n      objects.  This would be grossly inefficient.
    \ Simply verifying\n      that an object is signed provides no assurance that
    addition of\n      the object addition was properly authorized.\n   A minor distinction
    is made between a repository and a mirror.  A\n   repository has responsibility
    for the initial authorization and\n   authentication checks for transactions related
    to its local objects\n   which are then flooded to adjacent repositories.  A mirror
    receives\n   flooded transactions from remote repositories but is not the\n   authoritative
    source for any objects.  From a protocol standpoint,\n   repositories and mirrors
    appear identical in the flooding topology.\n   Either a repository or a mirror
    may recheck all or a subset of\n   transactions that are flooded to it.  A repository
    or mirror may\n   elect not to recheck authorization and authentication on transactions\n
    \  received from a trusted adjacency on the grounds that the adjacent\n   repository
    is trusted and would not have flooded the information\n   unless authorization
    and authentication checks had been made.\n   If it can be arranged that all adjacencies
    are trusted for a given\n   mirror, then there is no need to implement the code
    to check\n   authorization and authentication.  There is only a need to be able
    to\n   check the signatures on the flooded transactions of the adjacent\n   repository.
    \ This is an important special case because it could allow\n   a router to act
    as a mirror.  Only changes to the registry database\n   would be received through
    flooding, which is a very low volume.  Only\n   the signature of the adjacent
    mirror or repository would have to be\n   checked.\n"
  title: 1  Overview
- contents:
  - "2  Data Representation\n   RPSL provides a complete description of the contents
    of a routing\n   repository [1].  Many RPSL data objects remain unchanged from
    the\n   RIPE, and RPSL references the RIPE-181 specification as recorded in\n
    \  RFC-1786 [2].  RPSL provides external data representation.  Data may\n   be
    stored differently internal to a routing registry.  The integrity\n   of the distributed
    registry data requires the use of the\n   authorization and authentication additions
    to RPSL described in [3].\n   Some additions to RPSL are needed to locate all
    of the repositories\n   after having located one of them and to make certain parameters\n
    \  selectable on a per repository basis readily available.  These\n   additions
    are described in Section 5.\n   Some form of encapsulation must be used to exchange
    data.  The de-\n   facto encapsulation has been that which the RIPE tools accept,
    a\n   plain text file or plain text in the body of an RFC-822 formatted\n   mail
    message with information needed for authentication derived from\n   the mail headers.
    \ Merit has slightly modified this using the PGP\n   signed portion of a plain
    text file or PGP signed portion of the body\n   of a mail message.\n   The exchange
    that occurs during flooding differs from the initial\n   submission.  In order
    to repeat the authorization checks the state of\n   all repositories containing
    objects referenced by the authorization\n   checks needs to be known.  To accomplish
    this a sequence number is\n   associated with each transaction in a repository
    and the flooded\n   transactions must contain the sequence number of each repository
    on\n   which authorization of the transaction depends.\n   In order to repeat
    authorization checks it must be possible to\n   retrieve back revisions of objects.
    \ How this is accomplished is a\n   matter local to the implementation.  One method
    which is quite simple\n   is to keep the traversal data structures to all current
    objects even\n   if the state is deleted, keep the sequence number that the version
    of\n   the object became effective and keep back links to prior versions of\n
    \  the objects.  Finding a prior version of an object involves looking\n   back
    through the references until the sequence number of the version\n   of the object
    is less than or equal to the sequence number being\n   searched for.\n   The existing
    very simple forms of encapsulation are adequate for the\n   initial submission
    of a database transaction and should be retained\n   as long as needed for backward
    compatibility.  A more robust\n   encapsulation and submission protocol, with
    optional confirmation is\n   defined in Section 6.1.  An encapsulation suitable
    for exchange of\n   transaction between repositories is addressed in Section 6.
    \ Query\n   encapsulation and protocol is outside the scope of this document.\n"
  title: 2  Data Representation
- contents:
  - "3  Authentication and Authorization\n   Control must be exercised over who can
    make changes and what changes\n   they can make.  The distinction of who vs what
    separates\n   authentication from authorization.\n   o  Authentication is the
    means to determine who is attempting to make\n      a change.\n   o  Authorization
    is the determination of whether a transaction\n      passing a specific authentication
    check is allowed to perform a\n      given operation.\n   A submitted transaction
    contains a claimed identity.  Depending on\n   the type of transaction, the authorization
    will depend on related\n   objects.\n   The \"mnt-by\", \"mnt-routes\", or \"mnt-lower\"
    attributes in those\n   related objects reference \"maintainer\" objects.  Those
    maintainer\n   objects contain \"auth\" attributes.  The auth attributes contain
    an\n   authorization method and data which generally contains the claimed\n   identity
    and some form of public encryption key used to authenticate\n   the claim.\n   Authentication
    is done on transactions.  Authentication should also\n   be done between repositories
    to insure the integrity of the\n   information exchange.  In order to comply with
    import, export, and\n   use restrictions throughout the world no encryption capability
    is\n   specified.  Transactions must not be encrypted because it may be\n   illegal
    to use decryption software in some parts of the world.\n"
  title: 3  Authentication and Authorization
- contents:
  - "4  Repository Hierarchy\n   With multiple repositories, \"repository\" objects
    are needed to\n   propagate the existence of new repositories and provide an automated\n
    \  means to determine the supported methods of access and other\n   characteristics
    of the repository.  The repository object is\n   described in Section 5.\n   In
    each repository there should be a special repository object named\n   ROOT. This
    should point to the root repository or to a higher level\n   repository.  This
    is to allow queries to be directed to the local\n   repository but refer to the
    full set of registries for resolution of\n   hierarchically allocated objects.\n
    \  Each repository may have an \"expire\" attribute.  The expire attribute\n   is
    used to determine if a repository must be updated before a local\n   transaction
    that depends on it can proceed.\n   The repository object also contains attributes
    describing the access\n   methods and supported authentication methods of the
    repository.  The\n   \"query-address\" attribute provides a host name and a port
    number used\n   to direct queries.  The \"response-auth-type\" attribute provides
    the\n   authentication types that may be used by the repository when\n   responding
    to queries.  The \"submit-address\" attribute provides a\n   host name and a port
    number used to submit objects to the repository.\n   The \"submit-auth-type\"
    attribute provides the authentication types\n   that may be used by the repository
    when responding to submissions.\n"
  title: 4  Repository Hierarchy
- contents:
  - "5  Additions to RPSL\n   There are very few additions to RPSL defined here.  The
    additions to\n   RPSL are referred to as RPSL \"objects\".  They reside in the\n
    \  repository database and can be retrieved with ordinary queries.\n   Objects
    consist of \"attributes\", which are name/value pairs.\n   Attributes may be mandatory
    or optional.  They may be single or\n   multiple.  One or more attributes may
    be part of a key field.  Some\n   attributes may have the requirement of being
    unique.\n   Most of the data formats described in this document are\n   encapsulations
    used in transaction exchanges.  These are referred to\n   as \"meta-objects\".
    \ These \"meta-objects\", unlike RPSL \"objects\" do\n   not reside in the database
    but some must be retained in a transaction\n   log.  A similar format is used
    to represent \"meta-objects\".  They\n   also consist of \"attributes\" which
    are name/value pairs.\n   This section contains all of the additions to RPSL described
    in this\n   document.  This section describes only RPSL objects.  Other sections\n
    \  described only meta-objects.\n"
  - contents:
    - "5.1  repository object\n   A root repository must be agreed upon.  Ideally
      such a repository\n   would contain only top level delegations and pointers
      to other\n   repositories used in these delegations.  It would be wise to allow\n
      \  only cryptographically strong transactions in the root repository\n   [3].\n
      \  The root repository contains references to other repositories.  An\n   object
      of the following form identifies another repository.\n     repository:         RIPE\n
      \    query-address:      whois://whois.ripe.net\n     response-auth-type: PGPKEY-23F5CE35
      # pointer to key-cert object\n     response-auth-type: none\n     remarks:            you
      can request rsa signature on queries\n     remarks:            PGP required
      on submissions\n     submit-address:     mailto://auto-dbm@ripe.net\n     submit-address:
      \    rps-query://whois.ripe.net:43\n     submit-auth-type:   pgp-key, crypt-pw,
      mail-from\n     remarks:            these are the authentication types supported\n
      \    mnt-by:             maint-ripe-db\n     expire:             0000 04:00:00\n
      \    heartbeat-interval: 0000 01:00:00\n     ...\n     remarks:            admin
      and technical contact, etc\n     source:             IANA\n   The attributes
      of the repository object are listed below.\n     repository      key  mandatory
      \ single\n     query-address        mandatory  multiple\n     response-auth-type
      \  mandatory  multiple\n     submit-address       mandatory  multiple\n     submit-auth-type
      \    mandatory  multiple\n     repository-cert      mandatory  multiple\n     expire
      \              mandatory  single\n     heartbeat-interval   mandatory  single\n
      \    descr                optional   multiple\n     remarks              optional
      \  multiple\n     admin-c              mandatory  multiple\n     tech-c               mandatory
      \ multiple\n     notify               optional   multiple\n     mnt-by               mandatory
      \ multiple\n     changed              mandatory  multiple\n     source               mandatory
      \ single\n   In the above object type only a small number of the attribute types\n
      \  are new.  These are:\n   repository  This attribute provides the name of
      the repository.  This\n      is the key field for the object and is single and
      must be globally\n      unique.  This is the same name used in the source attribute
      of all\n      objects in that repository.\n   query-address  This attribute
      provides a url for directing queries.\n      \"rps-query\" or \"whois\" can
      be used as the protocol identifier.\n   response-auth-type  This attribute provides
      an authentication type\n      that may be used by the repository when responding
      to user\n      queries.  Its syntax and semantics is same as the auth attribute\n
      \     of the maintainer class.\n   submit-address  This attribute provides a
      url for submitting objects\n      to the repository.\n   submit-auth-type  This
      attribute provides the authentication types\n      that are allowed by the repository
      for users when submitting\n      registrations.\n   repository-cert  This attribute
      provides a reference to a public key\n      certificate in the form of an RPSL
      key-cert object.  This\n      attribute can be multiple to allow the repository
      to use more than\n      one method of signature.\n   heartbeat-interval  Heartbeat
      meta-objects are sent by this\n      repository at the rate of one heartbeat
      meta-object per the\n      interval indicated.  The value of this attribute
      shall be\n      expressed in the form \"dddd hh:mm:ss\", where the \"dddd\"
      represents\n      days, \"hh\" represents hours, \"mm\" minutes and \"ss\" seconds.\n
      \  expire  If no heartbeat or new registrations are received from a\n      repository
      for expire period, objects from this repository should\n      be considered
      non-authoritative, and cannot be used for\n      authorization purposes.  The
      value of this attribute shall be\n      expressed in the form \"dddd hh:mm:ss\",
      where the \"dddd\" represents\n      days, \"hh\" represents hours, \"mm\" minutes
      and \"ss\" seconds.  This\n      value should be bigger than heartbeat-interval.\n
      \  Please note that the \"heartbeat\" meta-objects mentioned above, like\n   other
      meta-objects described in this document are part of the\n   protocol to exchange
      information but are not placed in the database\n   itself.  See Section 7.3.2
      for a description of the heartbeat meta-\n   object.\n   The remaining attributes
      in the repository object are defined in\n   RPSL.\n"
    title: 5.1  repository object
  - contents:
    - "5.2  delegated attribute\n   For many RPSL object types a particular entry
      should appear only in\n   one repository.  These are the object types for which
      there is a\n   natural hierarchy, \"as-block\", \"aut-num\", \"inetnum\", and
      \"route\".  In\n   order to facilitate putting an object in another repository,
      a\n   \"delegated\" attribute is added.\n   delegated  The delegated attribute
      is allowed in any object type with\n      a hierarchy.  This attribute indicates
      that further searches for\n      object in the hierarchy must be made in one
      or more alternate\n      repositories.  The current repository may be listed.
      \ The ability\n      to list more than one repository serves only to accommodate\n
      \     grandfathered objects (those created prior to using an\n      authorization
      model).  The value of a delegated attribute is a\n      list of repository names.\n
      \  If an object contains a \"delegated\" attribute, an exact key field\n   match
      of the object may also be contained in each repository listed\n   in the \"delegated\"
      attribute.  For the purpose of authorizing changes\n   only the \"mnt-by\" in
      the object in the repository being modified is\n   considered.\n   The following
      is an example of the use of a \"delegated\" attribute.\n     inetnum:        193.0.0.0
      - 193.0.0.255\n     delegated:      RIPE\n     ...\n     source:         IANA\n
      \  This inetnum simply delegates the storage of any more specific\n   inetnum
      objects overlapping the stated range to the RIPE repository.\n   An exact match
      of this inetnum may also exist in the RIPE repository\n   to provide hooks for
      the attributes referencing maintainer objects.\n   In this case, when adding
      objects to the RIPE repository, the \"mnt-\n   lower\", \"mnt-routes\", and
      \"mnt-by\" fields in the IANA inetnum object\n   will not be considered, instead
      the values in the RIPE copy will be\n   used.\n"
    title: 5.2  delegated attribute
  - contents:
    - "5.3  integrity attribute\n   The \"integrity\" attribute can be contained in
      any RPSL object.  It is\n   intended solely as a means to facilitate a transition
      period during\n   which some data has been moved from repositories prior to
      the use of\n   a strong authorization model and is therefore questionable, or
      when\n   some repositories are not properly checking authorization.\n   The
      \"integrity\" attribute may have the values \"legacy\", \"no-auth\",\n   \"auth-failed\",
      or \"authorized\".  If absent, the integrity is\n   considered to be \"authorized\".
      \ The integrity values have the\n   following meanings:\n   legacy:  This data
      existed prior to the use of an adequate\n      authorization model.  The data
      is highly suspect.\n   no-auth:  This data was added to a repository during
      an initial\n      transition use of an authorization model but authorization\n
      \     depended on other objects whose integrity was not \"authorized\".\n      Such
      an addition is being allowed during the transition but would\n      be disallowed
      later.\n   auth-failed:  The authoritative repository is not checking\n      authorization.
      \ Had it been doing so, authorization would have\n      failed.  This attribute
      may be added by a repository that is\n      mirroring before placing the object
      in its local storage, or can\n      add this attribute to an encapsulating meta-object
      used to further\n      propagate the transaction.  If the failure to enforce\n
      \     authorization is intentional and part of a transition (for\n      example,
      issuing warnings only), then the authoritative repository\n      may add this
      attribute to the encapsulating meta-object used to\n      further propagate
      the transaction.\n   authorized:  Authorization checks were passed.  The maintainer\n
      \     contained a \"referral-by\" attribute, a form of authentication\n      deemed
      adequate by the repository was used, and all objects that\n      were needed
      for authorization were objects whose integrity was\n      \"authorized\".\n
      \  Normally once an object is added to a repository another object\n   cannot
      overwrite it unless authorized to do so by the maintainers\n   referenced by
      the \"mnt-by\" attributes in the object itself.  If the\n   integrity attribute
      is anything but \"authorized\", an object can be\n   overwritten or deleted
      by any transaction that would have been a\n   properly authorized addition had
      the object of lesser integrity not\n   existed.\n   During such a transition
      grandfathered data and data added without\n   proper authorization becomes advisory
      until a properly authorized\n   addition occurs.  After transition additions
      of this type would no\n   longer be accepted.  Those objects already added without
      proper\n   authorization would remain but would be marked as candidates for\n
      \  replacement.\n"
    title: 5.3  integrity attribute
  title: 5  Additions to RPSL
- contents:
  - "6  Interactions with a Repository or Mirror\n   This section presents an overview
    of the transaction distribution\n   mechanisms.  The detailed format of the meta-objects
    for\n   encapsulating and distributing transactions, and the rules for\n   processing
    meta-objects are described in Section 7.  There are a few\n   different types
    of interactions between routing repositories or\n   mirrors.\n   Initial submission
    of transactions:  Transactions may include\n      additions, changes, and deletions.
    \ A transaction may operate on\n      more than one object and must be treated
    as an atomic operation.\n      By definition initial submission of transactions
    is not applicable\n      to a mirror.  Initial submission of transactions is described
    in\n      Section 6.1.\n   Redistribution of Transactions:  The primary purpose
    of the\n      interactions between registries is the redistribution of\n      transactions.
    \ There are a number of ways to redistribute\n      transactions.  This is discussed
    in Section 6.2.\n   Queries:  Query interactions are outside the scope of this
    document.\n   Transaction Commit and Confirmation:  Repositories may optionally\n
    \     implement a commit protocol and a completion indication that gives\n      the
    submitter of a transaction a response that indicates that a\n      transaction
    has been successful and will not be lost by a crash of\n      the local repository.
    \ A submitter may optionally request such a\n      confirmation.  This is discussed
    in Section 6.3.\n"
  - contents:
    - "6.1  Initial Transaction Submission\n   The simplest form of transaction submission
      is an object or set of\n   objects submitted with RFC-822 email encapsulation.
      \ This form is\n   still supported for backwards compatibility.  A preferred
      form allows\n   some meta-information to be included in the submission, such
      as a\n   preferred form of confirmation.  Where either encapsulation is used,\n
      \  the submitter will connect to a host and port specified in the\n   repository
      object.  This allows immediate confirmation.  If an email\n   interface similar
      to the interface provided by the existing RIPE code\n   is desired, then an
      external program can provide the email interface.\n   The encapsulation of a
      transaction submission and response is\n   described in detail in Section 7.\n"
    title: 6.1  Initial Transaction Submission
  - contents:
    - "6.2  Redistribution of Transactions\n   Redistribution of transactions can
      be accomplished using one of:\n   1. A repository snapshot is a request for
      the complete contents of a\n      given repository.  This is usually done when
      starting up a new\n      repository or mirror or when recovering from a disaster,
      such as a\n      disk crash.\n   2. A transaction sequence exchange is a request
      for a specific set of\n      transactions.  Often the request is for the most
      recent sequence\n      number known to a mirror to the last transactions.  This
      is used\n      in polling.\n   3. Transaction flooding is accomplished through
      a unicast adjacency.\n   This section describes the operations somewhat qualitatively.
      \ Data\n   formats and state diagrams are provided in Section 7.\n"
    title: 6.2  Redistribution of Transactions
  - contents:
    - "6.3  Transaction Commit and Confirmation\n   If a submission requires a strong
      confirmation of completion, or if a\n   higher degree of protection against
      false positive confirmation is\n   desired as a matter of repository policy,
      a commit may be performed.\n   A commit request is a request from the repository
      processing an\n   initial transaction submission to another repository to confirm
      that\n   they have been able to advance the transaction sequence up to the\n
      \  sequence number immediately below the transaction in the request and\n   are
      willing to accept the transaction in the request as a further\n   advance in
      the sequence.  This indicates that either the\n   authorization was rechecked
      by the responding repository and passed\n   or that the responding repository
      trusts the requesting repository\n   and has accepted the transaction.\n   A
      commit request can be sent to more than one alternate repository.\n   One commit
      completion response is sufficient to respond to the\n   submitter with a positive
      confirmation that the transaction has been\n   completed.  However, the repository
      or submitter may optionally\n   require more than one.\n"
    title: 6.3  Transaction Commit and Confirmation
  title: 6  Interactions with a Repository or Mirror
- contents:
  - "7  Data Format Summaries, Transaction Encapsulation and Processing\n   RIPE-181
    [2] and RPSL [1] data is represented externally as ASCII\n   text.  Objects consist
    of a set of attributes.  Attributes are\n   name/value pairs.  A single attribute
    is represented as a single line\n   with the name followed by a colon followed
    by whitespace characters\n   (space, tab, or line continuation) and followed by
    the value.  Within\n   a value all consecutive whitespace characters is equivalent
    to a\n   single space.  Line continuation is supported by putting a white\n   space
    or '+' character to the beginning of the continuation lines.\n   An object is
    externally represented as a sequence of attributes.\n   Objects are separated
    by blank lines.\n   Protocol interactions between registries are activated by
    passing\n   \"meta objects\".  Meta objects are not part of RPSL but conform to\n
    \  RPSL object representation.  They serve mostly as delimiters to the\n   protocol
    messages or to carry the request for an operation.\n"
  - contents:
    - "7.1  Transaction Submit and Confirm\n   The de-facto method for submitting
      database changes has been via\n   email.  This method should be supported by
      an external application.\n   Merit has added the pgp-from authentication method
      to the RADB\n   (replaced by \"pgpkey\" in [4]), where the mail headers are
      essentially\n   ignored and the body of the mail message must be PGP signed.\n
      \  This specification defines a different encapsulation for transaction\n   submission.
      \ When submitting a group of objects to a repository, a\n   user MUST append
      to that group of objects, exactly one \"timestamp\"\n   and one or more \"signature\"
      meta-objects, in that order.\n   The \"timestamp\" meta-object contains a single
      attribute:\n   timestamp  This attribute is mandatory and single-valued.  This\n
      \     attribute specifies the time at which the user submits the\n      transaction
      to the repository.  The format of this attribute is\n      \"YYYYMMDD hh:mm:ss
      [+/-]xx:yy\", where \"YYYY\" specifies the four\n      digit year, \"MM\" represents
      the month, \"DD\" the date, \"hh\" the\n      hour, \"mm\" the minutes, \"ss\"
      the seconds of the timestamp, and\n      \"xx\" and \"yy\" represents the hours
      and minutes respectively that\n      that timestamp is ahead or behind UTC.\n
      \  A repository may reject a transaction which does not include the\n   \"timestamp\"
      meta-object.  The timestamp object is used to prevent\n   replaying registrations.
      \ How this is actually used is a local\n   matter.  For example, a repository
      can accept a transaction only if\n   the value of the timestamp attribute is
      greater than the timestamp\n   attribute in the previous registration received
      from this user\n   (maintainer), or the repository may only accept transactions
      with\n   timestamps within its expire window.\n   Each \"signature\" meta-object
      contains a single attribute:\n   signature  This attribute is mandatory and
      single-valued.  This\n      attribute, a block of free text, contains the signature\n
      \     corresponding to the authentication method used for the\n      transaction.
      \ When the authentication method is a cryptographic\n      hash (as in PGP-based
      authentication), the signature must include\n      all text up to (but not including)
      the last blank line before the\n      first \"signature\" meta-object.\n   A
      repository must reject a transaction that does not include any\n   \"signature\"
      meta-object.\n   The group of objects submitted by the user, together with the\n
      \  \"timestamp\" and \"signature\" meta-objects, constitute the \"submitted\n
      \  text\" of the transaction.\n   The protocol used for submitting a transaction,
      and for receiving\n   confirmation of locally committed transactions, is not
      specified in\n   this document.  This protocol may define additional encapsulations\n
      \  around the submitted text.  The rest of this section gives an example\n   of
      one such protocol.  Implementations are free to choose another\n   encapsulation.\n
      \  The meta-objects \"transaction-submit-begin\" and \"transaction-submit-\n
      \  end\" delimit a transaction.  A transaction is handled as an atomic\n   operation.
      \ If any part of the transaction fails none of the changes\n   take effect.
      \ For this reason a transaction can only operate on a\n   single database.\n
      \  A socket connection is used to request queries or submit\n   transactions.
      \ An email interface may be provided by an external\n   program that connects
      to the socket.  A socket connection must use\n   the \"transaction-submit-begin\"
      and \"transaction-submit-end\"\n   delimiters but can request a legacy style
      confirmation.  Multiple\n   transactions may be sent prior to the response for
      any single\n   transaction.  Transactions may not complete in the order sent.\n
      \  The \"transaction-submit-begin\" meta-object may contain the following\n
      \  attributes.\n   transaction-submit-begin  This attribute is mandatory and
      single.\n      The value of the attribute contains name of the database and
      an\n      identifier that must be unique over the course of the socket\n      connection.\n
      \  response-auth-type  This attribute is optional and multiple.  The\n      remainder
      of the line specifies an authentication type that would\n      be acceptable
      in the response.  This is used to request a response\n      cryptographically
      signed by the repository.\n   transaction-confirm-type  This attribute is optional
      and single.  A\n      confirmation type keyword must be provided.  Keywords
      are \"none\",\n      \"legacy\", \"normal\", \"commit\".  The confirmation type
      can be\n      followed by the option \"verbose\".\n   The \"transaction-submit-end
      meta-object consists of a single\n   attribute by the same name.  It must contain
      the same database name\n   and identifier as the corresponding \"transaction-submit-begin\"\n
      \  attribute.\n   Unless the confirmation type is \"none\" a confirmation is
      sent.  If\n   the confirmation type is \"legacy\", then an email message of
      the form\n   currently sent by the RIPE database code will be returned on the\n
      \  socket (suitable for submission to the sendmail program).\n   A \"normal\"
      confirmation does not require completion of the commit\n   protocol.  A \"commit\"
      confirmation does.  A \"verbose\" confirmation\n   may contain additional detail.\n
      \  A transaction confirmation is returned as a \"transaction-confirm\"\n   meta-object.
      \ The \"transaction-confirm\" meta-object may have the\n   following attributes.\n
      \  transaction-confirm  This attribute is mandatory and single.  It\n      contains
      the database name and identifier associated with the\n      transaction.\n   confirmed-operation
      \ This attribute is optional and multiple.  It\n      contains one of the keywords
      \"add\", \"delete\" or \"modify\" followed\n      by the object type and key
      fields of the object operated on.\n   commit-status  This attribute is mandatory
      and single.  It contains\n      one of the keywords \"succeeded, \"error\",
      or \"held\".  The \"error\"\n      keyword may be followed by an optional text
      string.  The \"held\"\n      keyword is returned when a repository containing
      a dependent\n      object for authorization has expired.\n"
    title: 7.1  Transaction Submit and Confirm
  - contents:
    - "7.2  Redistribution of Transactions\n   In order to redistribute transactions,
      each repository maintains a\n   TCP connection with one or more other repositories.
      \ After locally\n   committing a submitted transaction, a repository assigns
      a sequence\n   number to the transaction, signs and encapsulates the transaction,\n
      \  and then sends one copy to each neighboring (or \"peer\") repository.\n   In
      turn, each repository authenticates the transaction (as described\n   in Section
      7.6), may re-sign the transaction and redistributes the\n   transaction to its
      neighbors.  We use the term \"originating\n   repository\" to distinguish the
      repository that redistributes a\n   locally submitted transaction.\n   This
      document also specifies two other methods for redistributing\n   transactions
      to other repositories:  a database snapshot format used\n   for initializing
      a new registry, and a polling technique used by\n   mirrors.\n   In this section,
      we first describe how a repository may encapsulate\n   the submitted text of
      a transaction.  We then describe the protocol\n   for flooding transactions
      or polling for transactions, and the\n   database snapshot contents and format.\n"
    title: 7.2  Redistribution of Transactions
  - contents:
    - "7.3  Redistribution Protocol Description\n   The originating repository must
      first authenticate a submitted\n   transaction using methods described in [3].\n
      \  Before redistributing a transaction, the originating repository must\n   encapsulate
      the submitted text of the transaction with several meta-\n   objects, which
      are described below.\n   The originating repository must prepend the submitted
      text with\n   exactly one \"transaction-label\" meta-object.  This meta-object\n
      \  contains the following attributes:\n   transaction-label  This attribute
      is mandatory and single.  The value\n      of this attribute conforms to the
      syntax of an RPSL word, and\n      represents a globally unique identifier for
      the database to which\n      this transaction is added.\n   sequence  This attribute
      is mandatory and single.  The value of this\n      attribute is an RPSL integer
      specifying the sequence number\n      assigned by the originating repository
      to the transaction.\n      Successive transactions distributed by the same originating\n
      \     repository have successive sequence numbers.  The first\n      transaction
      originated by a registry is assigned a sequence number\n      1.  Each repository
      must use sequence numbers drawn from a range\n      at least as large as 64
      bit unsigned integers.\n   timestamp  This attribute is mandatory and single-valued.
      \ This\n      attribute specifies the time at which the originating repository\n
      \     encapsulates the submitted text.  The format of this attribute is\n      \"YYYYMMDD
      hh:mm:ss [+/-]xx:yy\", where \"YYYY\" specifies the four\n      digit year,
      \"MM\" represents the month, \"DD\" the date, \"hh\" the\n      hour, \"mm\"
      the minutes, \"ss\" the seconds of the timestamp, and\n      \"xx\" and \"yy\"
      represents the hours and minutes respectively that\n      that timestamp is
      ahead or behind UTC.\n   integrity  This attribute is optional and single-valued.
      \ It may have\n      the values \"legacy\", \"no-auth\", \"auth-failed\", or
      \"authorized\".\n      If absent, the integrity is considered to be \"authorized\".\n
      \  The originating repository may append to the submitted text one or\n   more
      \"auth-dependency\" meta-objects.  These meta-objects are used to\n   indicate
      which other repositories' objects were used by the\n   originating registry
      to authenticate the submitted text.  The \"auth-\n   dependency\" meta-objects
      should be ordered from the most preferred\n   repository to the least preferred
      repository.  This order is used by\n   a remote repository to tie break between
      the multiple registrations\n   of an object with the same level of integrity.
      \ The \"auth-dependency\"\n   meta-object contains the following attributes:\n
      \  auth-dependency  This attribute mandatory and single-valued.  It\n      equals
      a repository name from which an object is used to\n      authorize/authenticate
      this transaction.\n   sequence  This attribute mandatory and single-valued.
      \ It equals the\n      transaction sequence number of the dependent repository
      known at\n      the originating repository at the time of processing this\n
      \     transaction.\n   timestamp  This attribute mandatory and single-valued.
      \ It equals the\n      timestamp of the dependent repository known at the originating\n
      \     repository at the time of processing this transaction.\n   If the originating
      repository needs to modify submitted objects in a\n   way that the remote repositories
      can not re-create, it can append an\n   \"override-objects\" meta-object followed
      by the modified versions of\n   these objects.  An example modification can
      be auto assignment of NIC\n   handles.  The \"override-objects\" meta-object
      contains the following\n   attributes:\n   override-objects  A free text remark.\n
      \  Other repositories may or may not honor override requests, or limit\n   the
      kinds of overrides they allow.\n   Following this, the originating repository
      must append exactly one\n   \"repository-signature\" meta-object.  The \"repository-signature\"\n
      \  meta-object contains the following attributes:\n   repository-signature  This
      attribute is mandatory and single-valued.\n      It contains the name of the
      repository.\n   integrity  This attribute is optional and single-valued.  It
      may have\n      the values \"legacy\", \"no-auth\", \"auth-failed\", or \"authorized\".\n
      \     If absent, the value is same as the value in the transaction-\n      label.
      \ If a different value is used, the value here takes\n      precedence.\n   signature
      \ This attribute is optional and single-valued.  This\n      attribute, a block
      of free text, contains the repository's\n      signature using the key in the
      repository-cert attribute of the\n      repository object.  When the authentication
      method is a\n      cryptographic hash (as in PGP-based authentication), the
      signature\n      must include all text upto (but not including) this attribute.\n
      \     That is, the \"repository-signature\" and \"integrity\" attributes of\n
      \     this object are included.  This attribute is optional since\n      cryptographic
      authentication may not be available everywhere.\n      However, its use where
      it is available is highly recommended.\n   A repository must reject a redistributed
      transaction that does not\n   include any \"repository-signature\" meta-object.\n
      \  The transaction-label, the submitted text, the dependency objects,\n   the
      override-objects, the overridden objects, and the repository's\n   signature
      together constitute what we call the \"redistributed text\".\n   In preparation
      for redistributing the transaction to other\n   repositories, the originating
      repository must perform the following\n   protocol encapsulation.  This protocol
      encapsulation may involve\n   transforming the redistributed text according
      to one of the\n   \"transfer-method\"s described below.\n   The transformed
      redistributed text is first prepended with exactly\n   one \"transaction-begin\"
      meta-object.  One newline character separates\n   this meta-object from the
      redistributed text.  This meta-object has\n   the following attributes:\n   transaction-begin
      \ This attribute is mandatory and single.  The value\n      of this attribute
      is the length, in bytes, of the transformed\n      redistributed text.\n   transfer-method
      \ This attribute is optional and single-valued.  Its\n      value is either
      \"gzip\", or \"plain\".  The value of the attribute\n      describes the kind
      of text encoding that the repository has\n      performed on the redistributed
      text.  If this attribute is not\n      specified, its value is assumed to be
      \"plain\".  An implementation\n      must be capable of encoding and decoding
      both of these types.\n   The \"transaction-begin\" meta-object and the transformed
      redistributed\n   text constitute what we call the \"transmitted text\".  The
      originating\n   repository may distribute the transmitted text to one or more
      peer\n   repositories.\n   When a repository receives the transmitted text of
      a transaction, it\n   must perform the following steps.  After performing the
      following\n   steps, a transaction may be marked successful or failed.\n   1.
      It must decapsulate the \"transaction-begin\" meta-object, then\n      decode
      the original redistributed text according to the value of\n      the transfer-method
      attribute specified in the \"transaction-begin\"\n      meta-object.\n   2.
      It should then extract the \"transaction-label\" meta-object from\n      the
      transmitted text.  If this transaction has already been\n      processed, or
      is currently being held, the repository must\n      silently discard this incarnation
      of the same transaction.\n   3. It should verify that the signature of the originating
      repository\n      matches the first \"repository-signature\" meta-object in
      the\n      redistributed text following the \"auth-dependency\" meta-objects.\n
      \  4. If not all previous (i.e., those with a lower sequence number)\n      transactions
      from the same repository have been received or\n      completely processed,
      the repository must \"hold\" this transaction.\n   5. It may check whether any
      subsequent \"repository-signature\" meta-\n      objects were appended by a
      trusted repository.  If so, this\n      indicates that the trusted repository
      verified the transaction's\n      integrity and marked its conclusion in the
      integrity attribute of\n      this object.  The repository may verify the trusted
      repositories\n      signature and also mark the transaction with the same integrity,\n
      \     and skip the remaining steps.\n   6. It should verify the syntactic correctness
      of the transaction.  An\n      implementation may allow configurable levels
      of syntactic\n      conformance with RPSL [1].  This enables RPSL extensions
      to be\n      incrementally deployed in the distributed registry scheme.\n   7.
      The repository must authorize and authenticate this transaction.\n      To do
      this, it may need to reference objects and transactions from\n      other repositories.
      \ If these objects are not available, the\n      repository must \"hold\" this
      transaction as described in Section\n      7.6, until it can be authorized and
      authenticated later.  In order\n      to verify authorization/authentication
      of this transaction, the\n      repository must not use an object from a repository
      not mentioned\n      in an \"auth-dependency\" meta-object.  The repository
      should also\n      only use the latest objects (by rolling back to earlier versions\n
      \     if necessary) which are within the transaction sequence numbers of\n      the
      \"auth-dependency\" meta-objects.\n   A non-originating repository must redistribute
      a failed transaction\n   in order not to cause a gap in the sequence.  (If the
      transaction was\n   to fail at the originating registry, it would simply not
      be assigned\n   a sequence number).\n   To the redistributed text of a transaction,
      a repository may append\n   another \"repository-signature\" meta-object.  This
      indicates that the\n   repository has verified the transaction's integrity and
      marked it in\n   the \"integrity\" attribute of this object.  The signature
      covers the\n   new redistributed text from (and including) the transaction-label\n
      \  object to this object's signature attribute (including the\n   \"repository-signature\"
      and \"integrity\" attributes of this object, but\n   excluding the \"signature\"
      attribute).  The original redistributed\n   text, together with the new \"repository-signature\"
      meta-object\n   constitutes the modified redistributed text.\n   To redistribute
      a successful or failed transaction, the repository\n   must encapsulate the
      (original or modified) redistributed text with a\n   \"transaction-begin\" object.
      \ This step is essentially the same as\n   that performed by the originating
      repository (except that the\n   repository is free to use a different \"transfer-method\"
      from the one\n   that was in the received transaction.\n"
    - contents:
      - "7.3.1  Explicitly Requesting Transactions\n   A repository may also explicitly
        request one or more transactions\n   belonging to a specified originating
        repository.  This is useful for\n   catching up after a repository has been
        off-line for a period of\n   time.  It is also useful for mirrors which intermittently
        poll a\n   repository for recently received transactions.\n   To request a
        range of transactions from a peer, a repository must\n   send a \"transaction-request\"
        meta-object to the peer.  A\n   \"transaction-request\" meta-object may contain
        the following\n   attributes:\n   transaction-request  This attribute is mandatory
        and single.  It\n      contains the name of the database whose transactions
        are being\n      requested.\n   sequence-begin  This attribute is optional
        and single.  It contains\n      the sequence number of the first transaction
        being requested.\n   sequence-end  This attribute is optional and single.
        \ It contains the\n      sequence number of the last transaction being requested.\n
        \  Upon receiving a \"transaction-request\" object, a repository performs\n
        \  the following actions.  If the \"sequence-begin\" attribute is not\n   specified,
        the repository assumes the request first sequence number\n   to be 1.  The
        last sequence number is the lesser of the value of the\n   \"sequence-end\"
        attributed and the highest completed transaction in\n   the corresponding
        database.  The repository then, in order, transmits\n   the requested range
        of transactions.  Each transaction is prepared\n   exactly according to the
        rules for redistribution specified in\n   Section 7.3.\n   After transmitting
        all the transactions, the peer repository must\n   send a \"transaction-response\"
        meta-object.  This meta-object has the\n   following attributes:\n   transaction-response
        \ This attribute is mandatory and single.  It\n      contains the name of
        the database whose transactions are were\n      requested.\n   sequence-begin
        \ This attribute is optional and mandatory.  It\n      contains the value
        of the \"sequence-begin\" attribute in the\n      original request.  It is
        omitted if the corresponding attribute\n      was not specified in the original
        request.\n   sequence-end  This attribute is optional and mandatory.  It contains\n
        \     the value of the \"sequence-end\" attribute in the original request.\n
        \     It is omitted if the corresponding attribute was not specified in\n
        \     the original request.\n   After receiving a \"transaction-response\"
        meta-object, a repository\n   may tear down the TCP connection to its peer.
        \ This is useful for\n   mirrors that intermittently resynchronize transactions
        with a\n   repository.  If the TCP connection stays open, repositories exchange\n
        \  subsequent transactions according to the redistribution mechanism\n   specified
        in Section  7.3.  While a repository is responding to a\n   transaction-request,
        it MAY forward heartbeats and other transactions\n   from the requested repository
        towards the requestor.\n"
      title: 7.3.1  Explicitly Requesting Transactions
    - contents:
      - "7.3.2  Heartbeat Processing\n   Each repository that has originated at least
        one transaction must\n   periodically send a \"heartbeat\" meta-object.  The
        interval between\n   two successive transmissions of this meta-object is configurable
        but\n   must be less than 1 day.  This meta-object serves to indicate the\n
        \  liveness of a particular repository.  The repository liveness\n   determines
        how long transactions are held (See Section 7.6).\n   The \"heartbeat\" meta-object
        contains the following attributes:\n   heartbeat  This attribute is mandatory
        and single.  It contains the\n      name of the repository which originates
        this meta-object.\n   sequence  This attribute is mandatory and single.  It
        contains the\n      highest transaction sequence number that has been assigned
        by the\n      repository.\n   timestamp  This attribute is mandatory and single.
        \ It contains the\n      time at which this meta-object was generated.  The
        format of this\n      attribute is \"YYYYMMDD hh:mm:ss [+/-]xx:yy\", where
        \"YYYY\"\n      specifies the four digit year, \"MM\" represents the month,
        \"DD\" the\n      date, \"hh\" the hour, \"mm\" the minutes, \"ss\" the seconds
        of the\n      timestamp, and \"xx\" and \"yy\" represents the hours and minutes\n
        \     respectively that that timestamp is ahead or behind UTC.\n   Upon receiving
        a heartbeat meta-object, a repository must first check\n   the timestamp of
        the latest previously received heartbeat message.\n   If that timestamp exceeds
        the timestamp in the received heartbeat\n   message, the repository must silently
        discard the heartbeat message.\n   Otherwise, it must record the timestamp
        and sequence number in the\n   heartbeat message, and redistribute the heartbeat
        message, without\n   modification, to each of its peer repositories.\n   If
        the heartbeat message is from a repository previously unknown to\n   the recipient,
        the recipient may send a \"transaction-request\" to one\n   or more of its
        peers to obtain all transactions belonging to the\n   corresponding database.
        \ If the heartbeat message contains a sequence\n   number higher than the
        highest sequence number processed by the\n   recipient, the recipient may
        send a \"transaction-request\" to one or\n   more of its peers to obtain all
        transactions belonging to the\n   corresponding database.\n"
      title: 7.3.2  Heartbeat Processing
    title: 7.3  Redistribution Protocol Description
  - contents:
    - "7.4  Transaction Commit\n   Submitters may require stronger confirmation of
      commit for their\n   transactions (Section 6.3).  This section describes a simple\n
      \  request-response protocol by which a repository may provide this\n   stronger
      confirmation, by verifying if one or more other repositories\n   have committed
      the transaction.  Implementation of this request-\n   response protocol is optional.\n
      \  After it has redistributed a transaction, the originating repository\n   may
      request a commit confirmation from one or more peer repositories\n   by sending
      to them a \"commit-request\" meta-object.  The \"commit-\n   request\" contains
      two attributes:\n   commit-request  This attribute is mandatory and single.
      \ It contains\n      the name of the database for whom a commit confirmation
      is being\n      requested.\n   sequence  This attribute is mandatory and single.
      \ It contains the\n      transaction sequence number for which a commit confirmation
      is\n      being requested.\n   A repository that receives a \"commit-request\"
      must not redistribute\n   the request.  It must delay the response until the
      corresponding\n   transaction has been processed.  For this reason, the repository
      must\n   keep state about pending commit requests.  It should discard this\n
      \  state if the connection to the requester is lost before the response\n   is
      sent.  In that event, it is the responsibility of the requester to\n   resend
      the request.\n   Once a transaction has been processed (Section 7.3), a repository\n
      \  must check to see if there exists any pending commit request for the\n   transaction.
      \ If so, it must send a \"commit-response\" meta-object to\n   the requester.
      \ This meta-object has three attributes:\n   commit-response  This attribute
      is mandatory and single.  It contains\n      the name of the database for whom
      a commit response is being sent.\n   sequence  This attribute is mandatory and
      single.  It contains the\n      transaction sequence number for which a commit
      response is being\n      sent.\n   commit-status  This attribute is mandatory
      and single.  It contains\n      one of the keywords \"held\", \"error\", or
      \"succeeded\".  The \"error\"\n      keyword may be followed by an optional
      text string.  The \"held\"\n      keyword is returned when a repository containing
      a dependent\n      object for authorization has expired.\n"
    title: 7.4  Transaction Commit
  - contents:
    - "7.5  Database Snapshot\n   A database snapshot provides a complete copy of
      a database.  It is\n   intended only for repository initialization or disaster
      recovery.  A\n   database snapshot is an out of band mechanism.  A set of files
      are\n   created periodically at the source repository.  These files are then\n
      \  transferred to the requestor out of band (e.g.  ftp transfer).  The\n   objects
      in these files are then registered locally.\n   A snapshot of repository X contains
      the following set of files:\n   X.db  This file contains the RPSL objects of
      repository X, separated\n      by blank lines.  In addition to the RPSL objects
      and blank lines,\n      comment lines can be present.  Comment lines start with
      the\n      character '#'.  The comment lines are ignored.  The file X.db ends\n
      \     in a special comment line \"# eof\".\n   X.<class>.db  This optional file
      if present contains the RPSL objects\n      in X.db that are of class <class>.
      \ The format of the file is same\n      as that of X.db.\n   X.transaction-label
      \ This file contains a transaction-label object\n      that records the timestamp
      and the latest sequence number of the\n      repository at the time of the snapshot.\n
      \  Each of these files can be optionally compressed uzing gzip.  This is\n   signified
      by appending the suffix .gz to the file name.  Each of\n   these files can optionally
      be PGP signed.  In this case, the detached\n   signature with ASCII armoring
      and platform-independent text mode is\n   stored in a file whose name is constructed
      by appending .sig to the\n   file name of the file being signed.\n   In order
      to construct a repository's contents from a snapshot, a\n   repository downloads
      these files.  After uncompressing and checking\n   signatures, the repository
      records these objects in its database.  No\n   RPS authorization/authentication
      is done on these objects.  The\n   transaction-label object provides the seed
      for the replication\n   protocol to receive the follow on transactions from
      this repository.\n   Hence, it is not crucial to download an up to the minute
      snapshot.\n   After successfully playing a snapshot, it is possible that a\n
      \  repository may receive a transaction from a third repository that has\n   a
      dependency on an earlier version of one of the objects in the\n   snapshot.
      \ This can only happen within the expire period of the\n   repository being
      downloaded, plus any possible network partition\n   period.  This dependency
      is only important if the repository wants to\n   re-verify RPS authorization/authentication.
      \ There are three allowed\n   alternatives in this case.  The simplest alternative
      is for the\n   repository to accept the transaction and mark it with integrity
      \"no-\n   auth\".  The second choice is to only peer with trusted repositories\n
      \  during this time period, and accept the transaction with the same\n   integrity
      as the trusted repository (possibly as \"authorized\").  The\n   most preferred
      alternative is not to download an up to the minute\n   snapshot, but to download
      an older snapshot, at minimum twice the\n   repositories expire time, in practice
      few days older.  Upon replaying\n   an older snapshot, the replication protocol
      will fetch the more\n   current transactions from this repository.  Together
      they provide the\n   necessary versions of objects to re-verify rps\n   authorization/authentication.\n"
    title: 7.5  Database Snapshot
  - contents:
    - "7.6  Authenticating Operations\n   The \"signature\" and \"repository-signature\"
      meta-objects represent\n   signatures.  Where multiple of these objects are
      present, the\n   signatures should be over the original contents, not over other\n
      \  signatures.  This allows signatures to be checked in any order.\n   A maintainer
      can also sign a transaction using several authentication\n   methods (some of
      which may be available in some repositories only).\n   In the case of PGP, implementations
      should allow the signatures of\n   the \"signature\" and \"repository-signature\"
      meta-objects to be either\n   the detached signatures produced by PGP or regular
      signatures\n   produced by PGP. In either case, ASCII armoring and platform-\n
      \  independent text mode should be used.\n   Note that the RPSL objects themselves
      are not signed but the entire\n   transaction body is signed.  When exchanging
      transactions among\n   registries, the meta-objects (e.g.  \"auth-dependency\")
      prior to the\n   first \"repository-signature\" meta object in the redistributed
      text\n   are also signed over.\n   Transactions must remain intact, including
      the signatures, even if an\n   authentication method provided by the submitter
      is not used by a\n   repository handling the message.  An originating repository
      may chose\n   to remove clear text passwords signatures from a transaction,
      and\n   replace it with the keyword \"clear-text-passwd\" followed by the\n
      \  maintainer's id.\n     signature: clear-text-passwd <maintainer-name>\n   Note
      that this does not make the system less secure since clear text\n   password
      is an indication of total trust to the originating\n   repository by the maintainer.\n
      \  A repository may sign a transaction that it verified.  If at any\n   point
      the signature of a trusted repository is encountered, no\n   further authorization
      or authentication is needed.\n"
    - "A  Examples\n   RPSL provides an external representation of RPSL objects and\n
      \  attributes.  An attribute is a name/value pair.  RPSL is line\n   oriented.
      \ Line continuation is supported, however most attributes\n   fit on a single
      line.  The attribute name is followed by a colon,\n   then any amount of whitespace,
      then the attribute value.  An example\n   of the ASCII representation of an
      RPSL attribute is the following:\n       route:     140.222.0.0/16\n   An RPSL
      object is a set of attributes.  Objects are separated from\n   each other by
      one or more blank lines.  An example of a complete RPSL\n   object follows:\n
      \      route:         140.222.0.0/16\n       descr:         ANS Communications\n
      \      origin:        AS1673\n       member-of:     RS-ANSOSPFAGGREGATE\n       mnt-by:
      \       ANS\n       changed:       tck@ans.net 19980115\n       source:        ANS\n"
    title: 7.6  Authenticating Operations
  - contents:
    - "A.1  Initial Object Submission and Redistribution\n   Figure 1 outlines the
      steps involved in submitting an object and the\n   initial redistribution from
      the authoritative registry to its flooding\n   peers.\n   If the authorization
      check requires objects from other repositories,\n   then the sequence numbers
      of the local copies of those databases is\n   required for mirrors to recheck
      the authorization.\n   To simply resubmit the object from the prior example,
      the submitter or\n   a client application program acting on the submitter's
      behalf must\n   submit a transaction.  The legacy method was to send PGP signed
      email.\n   The preferred method is for an interactive program to encapsulate
      a\n   request between \"transaction-submit-begin\" and\n   \"transaction-submit-end\"
      meta-objects and encapsulate that as a\n   signed block as in the following
      example:\n    +--------------+\n    |  Transaction |\n    |  signed by   |\n
      \   |  submitter   |\n    +--------------+\n           |\n           |  1\n
      \          v\n    +---------------------+  2\n    |  Primary repository |---->+----------+\n
      \   |  identified by      |     | database |\n    |  RPSL source        |<----+----------+\n
      \   +---------------------+  3\n           |\n           |  4\n           v\n
      \   +----------------+\n    |  Redistributed |\n    |  transaction   |\n    +----------------+\n
      \   1.  submit object\n    2.  authorization check\n    3.  sequence needed
      for authorization\n    4.  redistribute\n   Figure 1:  Initial Object Submission
      and Redistribution\n    transaction-submit-begin:  ANS 1\n    response-auth-type:
      \       PGP\n    transaction-confirm-type:  normal\n    route:         140.222.0.0/16\n
      \   descr:         ANS Communications\n    origin:        AS1673\n    member-of:
      \    RS-ANSOSPFAGGREGATE\n    mnt-by:        ANS\n    changed:       curtis@ans.net
      19990401\n    source:        ANS\n    timestamp: 19990401 10:30:00 +08:00\n
      \   signature:\n    + -----BEGIN PGP SIGNATURE-----\n    + Version: PGP for
      Personal Privacy 5.0\n    + MessageID: UZi4b7kjlzP7rb72pATPywPxYfQj4gXI\n    +\n
      \   + iQCVAwUANsrwkP/OhQ1cphB9AQFOvwP/Ts8qn3FRRLQQHKmQGzy2IxOTiF0QXB4U\n    +
      Xzb3gEvfeg8NWhAI32zBw/D6FjkEw7P6wDFDeok52A1SA/xdP5wYE8heWQmMJQLX\n    + Avf8W49d3CF3qzh59UC0ALtA5BjI3r37ubzTf3mgtw+ONqVJ5+lB5upWbqKN9zqv\n
      \   + PGBIEN3/NlM=\n    + =c93c\n    + -----END PGP SIGNATURE-----\n    transaction-submit-end:
      \   ANS 1\n   The signature covers the everything after the first blank line
      after\n   the \"transaction-submit-begin\" object to the last blank line before\n
      \  the \"signature\" meta-object.  If multiple signatures are needed, it\n   would
      be quite easy to email this block and ask the other party to\n   add a signature-block
      and return or submit the transaction.  Because\n   of delay in obtaining multiple
      signatures the accuracy of the\n   \"timestamp\" cannot be strictly enforced.
      \ Enforcing accuracy to\n   within the \"expire\" time of the database might
      be a reasonable\n   compromise.  The tradeoff is between convenience, allowing
      a longer\n   time to obtain multiple signatures, and increased time of exposure
      to\n   replay attack.\n   The ANS repository would look at its local database
      and make\n   authorization checks.  If the authorization passes, then the sequence\n
      \  number of any other database needed for the authorization is\n   obtained.\n
      \  If this operation was successful, then a confirmation would be\n   returned.
      \ The confirmation would be of the form:\n    transaction-confirm:  ANS 1\n
      \   confirmed-operation:  change route 140.222.0.0/16 AS1673\n    commit-status:
      \       commit\n    timestamp:            19990401 10:30:10 +05:00\n"
    title: A.1  Initial Object Submission and Redistribution
  - contents:
    - "A.2  Transaction Redistribution Encoding\n   Having passed the authorization
      check the transaction is given a\n   sequence number and stored in the local
      transaction log and is then\n   flooded.  The meta-object flooded to another
      database would be signed\n   by the repository and would be of the following
      form:\n    transaction-label: ANS\n    sequence: 6666\n    timestamp: 19990401
      13:30:10 +05:00\n    integrity: authorized\n    route:         140.222.0.0/16\n
      \   descr:         ANS Communications\n    origin:        AS1673\n    member-of:
      \    RS-ANSOSPFAGGREGATE\n    mnt-by:        ANS\n    changed:       curtis@ans.net
      19990401\n    source:        ANS\n    timestamp: 19990401 10:30:00 +08:00\n
      \   signature:\n    + -----BEGIN PGP SIGNATURE-----\n    + Version: PGP for
      Personal Privacy 5.0\n    + MessageID: UZi4b7kjlzP7rb72pATPywPxYfQj4gXI\n    +\n
      \   + iQCVAwUANsrwkP/OhQ1cphB9AQFOvwP/Ts8qn3FRRLQQHKmQGzy2IxOTiF0QXB4U\n    +
      Xzb3gEvfeg8NWhAI32zBw/D6FjkEw7P6wDFDeok52A1SA/xdP5wYE8heWQmMJQLX\n    + Avf8W49d3CF3qzh59UC0ALtA5BjI3r37ubzTf3mgtw+ONqVJ5+lB5upWbqKN9zqv\n
      \   + PGBIEN3/NlM=\n    + =c93c\n    + -----END PGP SIGNATURE-----\n    auth-dependency:
      ARIN\n    sequence: 555\n    timestamp: 19990401 13:30:08 +05:00\n    auth-dependency:
      RADB\n    sequence: 4567\n    timestamp: 19990401 13:27:54 +05:00\n    repository-signature:
      ANS\n    signature:\n    + -----BEGIN PGP SIGNATURE-----\n    + Version: PGP
      for Personal Privacy 5.0\n    + MessageID: UZi4b7kjlzP7rb72pATPywPxYfQj4gXI\n
      \   +\n    + iQCVAwUANsrwkP/OhQ1cphB9AQFOvwP/Ts8qn3FRRLQQHKmQGzy2IxOTiF0QXB4U\n
      \   + Xzb3gEvfeg8NWhAI32zBw/D6FjkEw7P6wDFDeok52A1SA/xdP5wYE8heWQmMJQLX\n    +
      Avf8W49d3CF3qzh59UC0ALtA5BjI3r37ubzTf3mgtw+ONqVJ5+lB5upWbqKN9zqv\n    + PGBIEN3/NlM=\n
      \   + =c93c\n    + -----END PGP SIGNATURE-----\n   Note that the repository-signature
      above is a detached signature for\n   another file and is illustrative only.
      \ The repository-signature\n   covers from the \"transaction-label\" meta-object
      (including) to the\n   last blank line before the first \"repository-signature\"
      meta-object\n   (excluding the last blank line and the \"repository-signature\"\n
      \  object).\n"
    title: A.2  Transaction Redistribution Encoding
  - contents:
    - "A.3  Transaction Protocol Encoding\n    transaction-begin: 1276\n    transfer-method:
      plain\n    transaction-label: ANS\n    sequence: 6666\n    timestamp: 19990401
      13:30:10 +05:00\n    integrity: authorized\n    route:         140.222.0.0/16\n
      \   descr:         ANS Communications\n    origin:        AS1673\n    member-of:
      \    RS-ANSOSPFAGGREGATE\n    mnt-by:        ANS\n    changed:       curtis@ans.net
      19990401\n    source:        ANS\n    timestamp: 19990401 10:30:00 +08:00\n
      \   signature:\n    + -----BEGIN PGP SIGNATURE-----\n    + Version: PGP for
      Personal Privacy 5.0\n    + MessageID: UZi4b7kjlzP7rb72pATPywPxYfQj4gXI\n    +\n
      \   + iQCVAwUANsrwkP/OhQ1cphB9AQFOvwP/Ts8qn3FRRLQQHKmQGzy2IxOTiF0QXB4U\n    +
      Xzb3gEvfeg8NWhAI32zBw/D6FjkEw7P6wDFDeok52A1SA/xdP5wYE8heWQmMJQLX\n    + Avf8W49d3CF3qzh59UC0ALtA5BjI3r37ubzTf3mgtw+ONqVJ5+lB5upWbqKN9zqv\n
      \   + PGBIEN3/NlM=\n    + =c93c\n    + -----END PGP SIGNATURE-----\n    auth-dependency:
      ARIN\n    sequence: 555\n    timestamp: 19990401 13:30:08 +05:00\n    auth-dependency:
      RADB\n    sequence: 4567\n    timestamp: 19990401 13:27:54 +05:00\n    repository-signature:
      ANS\n    signature:\n    + -----BEGIN PGP SIGNATURE-----\n    + Version: PGP
      for Personal Privacy 5.0\n    + MessageID: UZi4b7kjlzP7rb72pATPywPxYfQj4gXI\n
      \   +\n    + iQCVAwUANsrwkP/OhQ1cphB9AQFOvwP/Ts8qn3FRRLQQHKmQGzy2IxOTiF0QXB4U\n
      \   + Xzb3gEvfeg8NWhAI32zBw/D6FjkEw7P6wDFDeok52A1SA/xdP5wYE8heWQmMJQLX\n    +
      Avf8W49d3CF3qzh59UC0ALtA5BjI3r37ubzTf3mgtw+ONqVJ5+lB5upWbqKN9zqv\n    + PGBIEN3/NlM=\n
      \   + =c93c\n    + -----END PGP SIGNATURE-----\n   Before the transaction is
      sent to a peer, the repository prepends a\n   \"transaction-begin\" meta-object.
      \ The value of the \"transaction-\n   begin\" attribute is the number of octets
      in the transaction, not\n   counting the \"transaction-begin\" meta-object and
      the first blank line\n   after it.\n   Separating transaction-begin and transaction-label
      objects enables\n   different encodings at different flooding peerings.\n"
    title: A.3  Transaction Protocol Encoding
  - contents:
    - "A.4  Transaction Redistribution\n   The last step in Figure 1 was redistributing
      the submitter's\n   transaction through flooding (or later through polling).
      \ Figure 2\n   illustrates the further redistribution of the transaction.\n
      \  If the authorization check was repeated, the mirror may optionally\n   add
      a repository-signature before passing the transaction any\n   further.  A \"signature\"
      can be added within that block.  The previous\n   signatures should not be signed.\n
      \  Figure 3 illustrates the special case referred to as a \"lightweight\n   mirror\".
      \ This is specifically intended for routers.\n   The lightweight mirror must
      trust the mirror from which it gets a\n   feed.  This is a safe assumption if
      the two are under the same\n   administration (the mirror providing the feed
      is a host owned by the\n   same ISP who owns the routers).  The lightweight
      mirror simply checks\n   the signature of the adjacent repository to insure
      data integrity.\n    +----------------+\n    |  Redistributed |\n    |  transaction
      \  |\n    +----------------+\n           |\n           |  1\n           v\n
      \   +--------------------+  2\n    |                    |---->+----------+\n
      \   |  Mirror repository |     | database |\n    |                    |<----+----------+\n
      \   +--------------------+  3\n           |\n           |  4\n           v\n
      \   +------------------+\n    |+----------------+|\n    ||  Redistributed ||\n
      \   ||  transaction   ||\n    |+----------------+|\n    |  Optional        |\n
      \   |  signature       |\n    +------------------+\n    1.  redistribute transaction\n
      \   2.  recheck authorization against full DB at the\n        time of the transaction
      using sequence numbers\n    3.  authorization pass/fail\n    4.  optionally
      sign then redistribute\n   Figure 2:  Further Transaction Redistribution\n    +----------------+\n
      \   |  Redistributed |\n    |  transaction   |\n    +----------------+\n           |
      \ 1\n           v\n    +--------------------+  2\n    |                    |---->+----------+\n
      \   |  Mirror repository |     | database |\n    |                    |<----+----------+\n
      \   +--------------------+  3\n           |  4\n           v\n    +----------------+\n
      \   |  Redistributed |\n    |  transaction   |\n    +----------------+\n           |
      \ 5\n           v\n    +--------------------+\n    |  Lightweight       |  6
      \ +----------+\n    |  Mirror repository |---->| database |\n    |  (router?)
      \        |     +----------+\n    +--------------------+\n    1.  redistribute
      transaction\n    2.  recheck authorization against full DB at the\n        time
      of the transaction using sequence numbers\n    3.  authorization pass/fail\n
      \   4.  sign and redistribute\n    5.  just check mirror signature\n    6.  apply
      change with no authorization check\n   Figure 3:  Redistribution to Lightweight
      Mirrors\n"
    - 'B  Technical Discussion

      '
    title: A.4  Transaction Redistribution
  - contents:
    - "B.1  Server Processing\n   This document does not mandate any particular software
      design,\n   programming language choice, or underlying database or underlying\n
      \  operating system.  Examples are given solely for illustrative\n   purposes.\n"
    - contents:
      - "B.1.1  getting connected\n   There are two primary methods of communicating
        with a repository\n   server.  E-mail can be sent to the server.  This method
        may be\n   deprecated but at least needs to be supported during transition.
        \ The\n   second method is preferred, connect directly to a TCP socket.\n
        \  Traditionally the whois service is supported for simple queries.  It\n
        \  might be wise to retain the whois port connection solely for simple\n   queries
        and use a second port not in the reserved number space for\n   all other operations
        including queries except those queries using the\n   whois unstructured single
        line query format.\n   There are two styles of handling connection initiation
        is the\n   dedicated daemon, in the style of BSD sendmail, or launching through\n
        \  a general purpose daemon such as BSD inetd.  E-mail is normally\n   handled
        sequentially and can be handled by a front end program which\n   will make
        the connection to a socket in the process as acting as a\n   mail delivery
        agent.\n"
      title: B.1.1  getting connected
    - contents:
      - "B.1.2  rolling transaction logs forward and back\n   There is a need to be
        able to easily look back at previous states of\n   any database in order to
        repeat authorization checks at the time of a\n   transaction.  This is difficult
        to do with the RIPE database\n   implementation, which uses a sequentially
        written ASCII file and a\n   set of Berkeley DB maintained index files for
        traversal.  At the very\n   minimum, the way in which deletes or replacements
        are implemented\n   would need to be altered.\n   In order to easily support
        a view back at prior versions of objects,\n   the sequence number of the transaction
        at which each object was\n   entered would need to be kept with the object.
        \ A pointer would be\n   needed back to the previous state of the object.
        \ A deletion would\n   need to be implemented as a new object with a deleted
        attribute,\n   replacing the previous version of the object but retaining
        a pointer\n   back to it.\n   A separate transaction log needs to be maintained.
        \ Beyond some age,\n   the older versions of objects and the the older transaction
        log\n   entries can be removed although it is probably wise to archive them.\n"
      title: B.1.2  rolling transaction logs forward and back
    - contents:
      - "B.1.3  committing or disposing of transactions\n   The ability to commit
        large transaction, or reject them as a whole\n   poses problems for simplistic
        database designs.  This form of commit\n   operation can be supported quite
        easily using memory mapped files.\n   The changes can be made in virtual memory
        only and then either\n   committed or disposed of.\n"
      title: B.1.3  committing or disposing of transactions
    - contents:
      - "B.1.4  dealing with concurrency\n   Multiple connections may be active.  In
        addition, a single connection\n   may have multiple outstanding operations.
        \ It makes sense to have a\n   single process or thread coordinate the responses
        for a given\n   connection and have multiple processes or threads each tending
        to a\n   single operation.  The operations may complete in random order.\n
        \  Locking on reads is not essential.  Locking before write access is\n   essential.
        \ The simplest approach to locking is to lock at the\n   database granularity
        or at the database and object type granularity.\n   Finer locking granularity
        can also be implemented.  Because there are\n   multiple databases, deadlock
        avoidance must be considered.  The usual\n   deadlock avoidance mechanism
        is to acquire all necessary locks in a\n   single operation or acquire locks
        in a prescribed order.\n"
      title: B.1.4  dealing with concurrency
    title: B.1  Server Processing
  - contents:
    - "B.2  Repository Mirroring for Redundancy\n   There are numerous reasons why
      the operator of a repository might\n   mirror their own repository.  Possibly
      the most obvious are\n   redundancy and the relative ease of disaster recovery.
      \ Another\n   reason might be the widespread use of a small number of\n   implementations
      (but more than one) and the desire to insure that the\n   major repository software
      releases will accept a transaction before\n   fully committing to the transaction.\n
      \  The operation of a repository mirror used for redundancy is quite\n   straightforward.
      \ The transactions of the primary repository host can\n   be immediately fed
      to the redundant repository host.  For tighter\n   assurances that false positive
      confirmations will be sent, as a\n   matter of policy the primary repository
      host can require commit\n   confirmation before making a transaction sequence
      publicly available.\n   There are many ways in which the integrity of local
      data can be\n   assured regardless of a local crash in the midst of transaction
      disk\n   writes.  For example, transactions can be implemented as memory\n   mapped
      file operations, with disk synchronization used as the local\n   commit mechanism,
      and disposal of memory copies of pages used to\n   handle commit failures.  The
      old pages can be written to a separate\n   file, the new pages written into
      the database.  The transaction can\n   be logged and old pages file can then
      be removed.  In the event of a\n   crash, the existence of a old pages file
      and the lack of a record of\n   the transaction completing would trigger a transaction
      roll back by\n   writing the old pages back to the database file.\n   The primary
      repository host can still sustain severe damage such as a\n   disk crash.  If
      the primary repository host becomes corrupted, the\n   use of a mirror repository
      host provides a backup and can provide a\n   rapid recovery from disaster by
      simply reversing roles.\n   If a mirror is set up using a different software
      implementation with\n   commit mirror confirmation required, any transaction
      which fails due\n   a software bug will be deferred indefinitely allowing other\n
      \  transactions to proceed rather than halting the remote processing of\n   all
      transactions until the bug is fixed everywhere.\n"
    title: B.2  Repository Mirroring for Redundancy
  - contents:
    - "B.3  Trust Relationships\n   If all repositories trust each other then there
      is never a need to\n   repeat authorization checks.  This enables a convenient
      interim step\n   for deployment prior to the completion of software supporting
      that\n   capability.  The opposite case is where no repository trusts any\n
      \  other repository.  In this case, all repositories must roll forward\n   transactions
      gradually, checking the authorization of each remote\n   transaction.\n   It
      is likely that repositories will trust a subset of other\n   repositories.  This
      trust can reduce the amount of processing a\n   repository required to maintain
      mirror images of the full set of\n   data.  For example, a subset of repositories
      might be trustworthy in\n   that they take reasonable security measures, the
      organizations\n   themselves have the integrity not to alter data, and these\n
      \  repositories trust only a limited set of similar repositories.  If\n   any
      one of these repositories receives a transaction sequence and\n   repeats the
      authorization checks, other major repositories which\n   trusts that repository
      need not repeat the checks.  In addition,\n   trust need not be mutual to reap
      some benefit in reduced processing.\n   As a transaction sequence is passed
      from repository to repository\n   each repository signs the transaction sequence
      before forwarding it.\n   If a receiving repository finds that any trusted repository
      has\n   signed the transaction sequence it can be considered authorized since\n
      \  the trusted repository either trusted a preceding repository or\n   repeated
      the authorization checks.\n"
    title: B.3  Trust Relationships
  - contents:
    - "B.4  A Router as a Minimal Mirror\n   A router could serve as a minimal repository
      mirror.  The following\n   simplifications can be made.\n   1. No support for
      repeating authorization checks or transaction\n      authentication checks need
      be coded in the router.\n   2. The router must be adjacent only to trusted mirrors,
      generally\n      operated by the same organization.\n   3. The router would
      only check the authentication of the adjacent\n      repository mirrors.\n   4.
      No support for transaction submission or query need be coded in\n      the router.
      \ No commit support is needed.\n   5. The router can dispose of any object types
      or attributes not\n      needed for configuration of route filters.\n   The
      need to update router configurations could be significantly\n   reduced if the
      router were capable of acting as a limited repository\n   mirror.\n   A significant
      amount of non-volatile storage would be needed.  There\n   are currently an
      estimated 100 transactions per day.  If storage were\n   flash memory with a
      limited number of writes, or if there were some\n   other reason to avoid writing
      to flash, the router could only update\n   the non-volatile copy every few days.
      \ A transaction sequence request\n   can be made to get an update in the event
      of a crash, returning only\n   a few hundred updates after losing a few days
      of deferred writes.\n   The routers can still take a frequent or continuous
      feed of\n   transactions.\n   Alternately, router filters can be reconfigured
      periodically as they\n   are today.\n"
    title: B.4  A Router as a Minimal Mirror
  - contents:
    - "B.5  Dealing with Errors\n   If verification of an authorization check fails,
      the entire\n   transaction must be rejected and no further advancement of the\n
      \  repository can occur until the originating repository corrects the\n   problem.
      \ If the problem is due to a software bug, the offending\n   transaction can
      be removed manually once the problem is corrected.\n   If a software bug exists
      in the receiving software, then the\n   transaction sequence is stalled until
      the bug is corrected.  It is\n   better for software to error on the side of
      denying a transaction\n   than acceptance, since an error on the side of acceptance
      will\n   require later removal of the effects of the transaction.\n"
    title: B.5  Dealing with Errors
  title: 7  Data Format Summaries, Transaction Encapsulation and Processing
- contents:
  - "C  Deployment Considerations\n   This section described deployment considerations.
    \ The intention is\n   to raise issues rather than to provide a deployment plan.\n
    \  This document calls for a transaction exchange mechanism similar to\n   but
    not identical to the existing \"near real time mirroring\"\n   supported by the
    code base widely used by the routing registries.  As\n   an initial step, the
    transaction exchange can be implemented without\n   the commit protocol or the
    ability to recheck transaction\n   authorization.  This is a fairly minimal step
    from the existing\n   capabilities.\n   The transition can be staged as follows:\n
    \  1. Modify the format of \"near real time mirroring\" transaction\n      exchange
    to conform to the specifications of this document.\n   2. Implement commit protocol
    and confirmation support.\n   3. Implement remote recheck of authorization.  Prior
    to this step all\n      repositories must be trusted.\n   4. Allow further decentralization
    of the repositories.\n"
  title: C  Deployment Considerations
- contents:
  - "D  Privacy of Contact Information\n   The routing registries have contained contact
    information.  The\n   redistribution of this contact information has been a delicate
    issue\n   and in some countries has legal implications.\n   The person and role
    objects contain contact information.  These\n   objects are referenced by NIC-handles.
    \ There are some attributes\n   such as the \"changed\" and \"notify\" attributes
    that require an email\n   address.  All of the fields that currently require an
    email address\n   must also accept a NIC-handle.\n   The person and role objects
    should not be redistributed by default.\n   If a submission contains an email
    address in a field such as a\n   changed field rather than a NIC-handle the submitter
    should be aware\n   that they are allowing that email address to be redistributed
    and\n   forfeiting any privacy.  Repositories which do not feel that prior\n   warnings
    of this forfeiture are sufficient legal protection should\n   reject the submission
    requesting that a NIC-handle be used.\n   Queries to role and person objects arriving
    at a mirror must be\n   referred to the authoritative repository where whatever\n
    \  authentication, restrictions, or limitations deemed appropriate by\n   that
    repository can be enforced directly.\n   Software should make it possible to restrict
    the redistribution of\n   other entire object types as long as those object types
    are not\n   required for the authorization of additions of other object types.\n
    \  It is not possible to redistribute objects with attributes removed or\n   altered
    since this would invalidate the submitter's signature and\n   make subsequent
    authentication checks impossible.  Repositories\n   should not redistribute a
    subset of the objects of a given type.\n   Software should also not let a transaction
    contain both\n   redistributable (e.g.  policy objects) and non-redustributable\n
    \  objects (e.g.  person) since there is no way to verify the signature\n   of
    these transactions without the non-redustributable objects.\n   When redistributing
    legacy data, contact information in attributes\n   such as \"changed\" and \"notify\"
    should be stripped to maintain\n   privacy.  The \"integrity\" attribute on these
    objects should already\n   be set to \"legacy\" indicating that their origin is
    questionable, so\n   the issue of not being able to recheck signatures is not
    as\n   significant.\n"
  title: D  Privacy of Contact Information
- contents:
  - "References\n   [1]  Alaettinoglu, C., Villamizar, C., Gerich, E., Kessens, D.,\n
    \       Meyer, D., Bates, T., Karrenberg, D. and M. Terpstra, \"Routing\n        Policy
    Specification Language\", RFC 2622, June 1999.\n   [2]  Bates, T., Gerich, E.,
    Joncheray, L., Jouanigot, J-M.,\n        Karrenberg, D., Terpstra, M. and J. Yu,
    \"Representation of IP\n        Routing Policies in a Routing Registry (ripe-81++)\",
    RFC 1786,\n        March 1995.\n   [3]  Villamizar, C., Alaettinoglu, C., Meyer,
    D. and S. Murphy,\n        \"Routing Policy System Security\", RFC 2725, June
    1999.\n   [4]  Zsako, J., \"PGP Authentication for RIPE Database Updates\", RFC\n
    \       2726, December 1999.\n"
  title: References
- contents:
  - "Security Considerations\n   An authentication and authorization model for routing
    policy object\n   submission is provided by [3].  Cryptographic authentication
    is\n   addressed by [4].  This document provides a protocol for the exchange\n
    \  of information among distributed routing registries such that the\n   authorization
    model provided by [3] can be adhered to by all\n   registries and any deviation
    (hopefully accidental) from those rules\n   on the part of a registry can be identified
    by other registries or\n   mirrors.\n"
  title: Security Considerations
- contents:
  - "Authors' Addresses\n   Curtis Villamizar\n   Avici Systems\n   EMail: curtis@avici.com\n
    \  Cengiz Alaettinoglu\n   ISI\n   EMail: cengiz@ISI.EDU\n   Ramesh Govindan\n
    \  ISI\n   EMail: govindan@ISI.EDU\n   David M. Meyer\n   Cisco\n   EMail: dmm@cisco.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
