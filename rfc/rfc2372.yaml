- title: __initial_text__
  contents:
  - "            Transaction Internet Protocol - Requirements and\n              \
    \          Supplemental Information\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the purpose (usage scenarios), and\n   requirements\
    \ for the Transaction Internet Protocol [1]. It is\n   intended to help qualify\
    \ the necessary features and functions of the\n   protocol. It also provides supplemental\
    \ information to aid\n   understanding and facilitate implementation of the TIP\
    \ protocol.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction                                      \
    \         2\n   2.  The Transaction Internet Protocol                        \
    \  3\n   3.  Scope                                                      4\n  \
    \ 4.  Anticipated Usage of TIP                                   4\n   5.  TIP\
    \ Compliant Systems                                      4\n   6.  Relationship\
    \ to the X/Open DTP Model                       5\n   7.  Example TIP Usage Scenario\
    \                                 5\n   8.  TIP Transaction Recovery         \
    \                          9\n   9.  TIP Transaction and Application Message Serialisation\
    \     10\n   10. TIP Protocol and Local Actions                            10\n\
    \   11. Security Considerations                                   11\n   12. TIP\
    \ Requirements                                          11\n       References\
    \                                                14\n       Authors' Addresses\
    \                                        15\n       Comments                 \
    \                                 15\n   A.  An Example TIP Transaction Manager\
    \ API                    16\n       Full Copyright Statement                 \
    \                 24\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   Transactions are a very useful programming paradigm, greatly\n\
    \   simplifying the writing of distributed applications. When\n   transactions\
    \ are employed, no matter how many distributed application\n   components participate\
    \ in a particular unit-of-work, the number of\n   possible outcomes is reduced\
    \ to only two; that is, either all of the\n   work completed successfully, or\
    \ none of it did (this characteristic\n   is known as atomicity). Applications\
    \ programming is therefore much\n   less complex since the programmer does not\
    \ have to deal with a\n   multitude of possible failure scenarios. Typically,\
    \ transaction\n   semantics are provided by some underlying system infrastructure\n\
    \   (usually in the form of products such as Transaction Processing\n   Monitors,\
    \ and/or Databases). This infrastructure deals with failures,\n   and performs\
    \ the necessary recovery actions to guarantee the property\n   of atomicity. The\
    \ use of transactions enables the development of\n   reliable distributed applications\
    \ which would otherwise be difficult,\n   if not impossible.\n   A key technology\
    \ required to support distributed transactions is the\n   two-phase commit protocol\
    \ (2-pc). 2-pc protocols have been used in\n   commercial Transaction Processing\
    \ (TP) systems for many years, and\n   are well understood (e.g. the LU6.2 2-pc\
    \ (syncpoint) protocol was\n   first implemented more than 12 years ago). Today\
    \ a number of\n   different 2-pc protocols are supported by a variety of TP monitor\
    \ and\n   database products. 2-pc is used between the components participating\n\
    \   in a distributed unit-of-work (transaction) to ensure agreement by\n   all\
    \ parties regarding the outcome of that work (regardless of any\n   failure).\n\
    \   Today both standard and proprietary 2-pc protocols exist. These\n   protocols\
    \ typically employ a \"one-pipe\" model. That is, the\n   transaction and application\
    \ protocols are tightly-integrated,\n   executing over the same communications\
    \ channel. An application may\n   use only the particular communications mechanism\
    \ associated with the\n   transaction protocol. The standard protocols (OSI TP,\
    \ LU6.2) are\n   complex, with a large footprint and extensive configuration and\n\
    \   administration requirements. For these reasons they are not very\n   widely\
    \ deployed. The net of all this is restricted application\n   flexibility and\
    \ interoperability if transactions are to be used.\n   Applications may wish to\
    \ use a number of communications protocols for\n   which there are no transactional\
    \ variants (e.g. HTTP), and be\n   deployed in very heterogeneous application\
    \ environments.\n   In summary, transactions greatly simplify the programming\
    \ of\n   distributed applications, and the 2-pc protocol is a key\n   transactional\
    \ technology. Current 2-pc protocols only offer\n   transaction semantics to a\
    \ limited set of applications, operating\n   within a special-purpose (complex,\
    \ homogeneous) infrastructure, using\n   a particular set of intercommunication\
    \ protocols. The restrictions\n   thus imposed by current 2-pc protocols limits\
    \ the widespread use of\n   the transaction paradigm, thereby inhibiting the development\
    \ of new\n   distributed business applications.\n   (See [2] for more information\
    \ re transactions, atomicity, and two-\n   phase commit protocols in general.)\n"
- title: 2. The Transaction Internet Protocol (TIP)
  contents:
  - "2. The Transaction Internet Protocol (TIP)\n   TIP is a 2-pc protocol which is\
    \ intended to provide ubiquitous\n   distributed transaction support, in a heterogeneous\
    \ (networked)\n   environment. TIP removes the restrictions of current 2-pc protocols\n\
    \   and enables the development of new distributed business applications.\n  \
    \ This goal is achieved primarily by satisfying two key requirements:\n   1) Keep\
    \ the protocol simple (yet functionally sufficient). If the\n      protocol is\
    \ complex it will not be widely deployed or quickly\n      adopted. Simplicity\
    \ also means suitability to a wide range of\n      application environments.\n\
    \   2) Enable the protocol to be used with any applications\n      communications\
    \ protocol (e.g. HTTP). This ensures heterogeneous\n      environments can participate\
    \ in distributed work.\n   TIP does not reinvent the 2-pc protocol itself, the\
    \ well-known\n   presumed-abort 2-pc protocol is used as a basis. Rather the novelty\n\
    \   and utility of TIP is in its separation from the application\n   communications\
    \ protocol (the two-pipe model).\n      +-------------+ Application Communication\
    \ +-------------+\n      | Application |---------------------------| Application\
    \ |\n      |   Program   |         \"Pipe 1\"          |   Program   |\n     \
    \ +-------------+                           +-------------+\n             |  \
    \                                       |\n             | TIP TM API         \
    \          TIP TM API |\n             |                                      \
    \   |\n    +-----------------+   TIP 2-pc Protocol   +-----------------+\n   \
    \ | TIP Transaction |-----------------------| TIP Transaction |\n    |     Manager\
    \     |       \"Pipe 2\"        |     Manager     |\n    +-----------------+ \
    \                      +-----------------+\n                 Fig 1: The two-pipe\
    \ nature of TIP\n"
- title: 3. Scope
  contents:
  - "3. Scope\n   TIP does not describe how business transactions or electronic\n\
    \   commerce are to be conducted on the internet, it specifies only the\n   2-pc\
    \ transaction protocol (which is an aid in the development of such\n   applications).\
    \ e.g. TIP does not provide a mechanism for non-\n   repudiation. Such protocols\
    \ might be a subject for subsequent IETF\n   activity, once the requirements for\
    \ general electronic commerce are\n   better understood. TIP does not preclude\
    \ the later definition of\n   these protocols.\n   TIP does not specify Application\
    \ Programming Interfaces (note that an\n   example TIP TM API is included in this\
    \ document (Appendix A), as an\n   aid to understanding).\n"
- title: 4. Anticipated Usage of TIP
  contents:
  - "4. Anticipated Usage of TIP\n   As described above, transactions are a very useful\
    \ tool in\n   simplifying the programming of distributed applications. TIP is\n\
    \   therefore targeted at any application that involves distributed work.\n  \
    \ Such applications may comprise components executing within a single\n   system,\
    \ across a corporate intranet, across the internet, or any\n   other distributed\
    \ system configuration. The application may be of\n   \"enterprise\" class (requiring\
    \ high-levels of performance and\n   availability), or be less demanding. TIP\
    \ is intended to be generally\n   applicable, meeting the requirements of any\
    \ application type which\n   would benefit from the provision of transaction semantics.\n"
- title: 5. TIP Compliant Systems
  contents:
  - "5. TIP Compliant Systems\n   There are two classes of TIP compliant Transaction\
    \ Manager system:\n   1) Client-only systems. Those which provide an application\n\
    \      interface to demarcate TIP transactions, but which do not offer\n     \
    \ access to local recoverable resources. Such a lightweight\n      implementation\
    \ is useful for systems which host client\n      applications only (e.g. desktop\
    \ machines). Such client systems may\n      be unreliable, and are not appropriate\
    \ as transaction coordinators\n      (their unavailability might cause resources\
    \ on other transaction\n      participant systems to remain locked and unavailable).\
    \ These so-\n      called \"volatile client\" systems therefore delegate the\n\
    \      responsibility to coordinate the transaction (and recover from\n      failures),\
    \ to other \"full\" (server) TIP system implementations.\n      For these lightweight\
    \ systems, only the TIP IDENTIFY, BEGIN,\n      COMMIT, and ABORT commands are\
    \ needed; no transaction log is\n      required.\n   2) Server systems. Those\
    \ which offer the above support, plus TIP\n      transaction coordination and\
    \ recovery services. These systems may\n      also provide access to recoverable\
    \ resources (e.g. relational\n      databases). Server systems support all TIP\
    \ commands, and provide a\n      recoverable transaction log.\n   A TIP compliant\
    \ Transaction Manager (TM), will also supply\n   application programming interfaces\
    \ to demarcate transactions (e.g.\n   the X/Open TX interface [3]), plus commands\
    \ to generate TIP URLs, to\n   PUSH/PULL TIP transactions, and to set the current\
    \ TIP transaction\n   context. TIP support can be added to TMs with existing APIs\
    \ and 2-pc\n   protocols, and transactions may comprise both proprietary and TIP\n\
    \   transaction branches (it is assumed existing TM implementations will\n   provide\
    \ \"TIP gateway\" facilities which will coordinate between TIP\n   and other transaction\
    \ protocols).\n"
- title: 6. Relationship to the X/Open DTP Model
  contents:
  - "6. Relationship to the X/Open DTP Model\n   The X/Open Distributed Transaction\
    \ Processing (DTP) Model [4] defines\n   four components: 1) Application Program\
    \ (AP), 2) Transaction Manager\n   (TM), 3) Resource Manager (RM), and 4) Communications\
    \ Resource\n   Manager (CRM). In this model, TIP defines a TM to TM interoperability\n\
    \   protocol, which is independent of application communications (there\n   is\
    \ no such equivalent protocol specified by X/Open, where all\n   transaction and\
    \ application communication occurs between CRMs (the\n   one-pipe model)).  Programmatic\
    \ interfaces between the AP and TM/RM\n   are unaffected by, and may be used with\
    \ TIP. The TM to RM interaction\n   is defined via the X/Open XA interface specification\
    \ [5].  TIP is\n   compatible with XA, and a TIP transaction may comprise applications\n\
    \   accessing multiple RMs where the XA interface is being used to\n   coordinate\
    \ the RM transaction branches.\n"
- title: 7. Example TIP Usage Scenario
  contents:
  - "7. Example TIP Usage Scenario\n   It is expected that a typical internet usage\
    \ of TIP will involve\n   applications using the agency model. In this model,\
    \ the client node\n   itself is not directly involved in the TIP protocol at all,\
    \ and does\n   not need the services of a local TIP TM. Instead, an agency (server)\n\
    \   application handles the dialogue with the client, and is responsible\n   for\
    \ the coordination of the TIP transaction. The agency works with\n   other service\
    \ providers to deliver the service to the client. e.g. as\n   a Travel Agency\
    \ acts as an intermediate between airlines/hotels/etc\n   and the customer. A\
    \ big benefit of this model is that the agency is\n   trusted by the service providers,\
    \ and there are fewer such agencies\n   (compared to user clients), so issues\
    \ of security and performance are\n   reduced.\n   Consider a Travel Agency example.\
    \ A client running a web browser on a\n   network PC accesses the Travel Agency\
    \ web page. Via pages served up\n   by the agency (which may in turn be constructed\
    \ from pages provided\n   by the airline and hotel servers), the client creates\
    \ an itinerary\n   involving flights and hotel choices. Finally, the client clicks\
    \ the\n   \"make reservation\" button. At this point the following sequence of\n\
    \   events occurs (user-written application code is invoked by the\n   various\
    \ web servers, via any of the standard or proprietary\n   techniques available\
    \ (e.g. CGI)):\n   1) The travel agency begins a local transaction, and gets a\
    \ TIP URL\n      for this transaction (both of these functions are performed using\n\
    \      the API of the local TM. e.g. \"tip_xid_to_url()\" would return the\n \
    \     TIP URL for the local transaction). The TIP URL contains the\n      listening\
    \ endpoint IP address of the local TM and the transaction\n      identifier of\
    \ the local transaction.\n   2) The travel agency application sends a request\
    \ to the airline\n      server (via some protocol (e.g. HTTP)), requesting the\n\
    \      \"book_flight\" service, passing the flights selected by the client,\n\
    \      and the TIP URL (obtained in 1. above).\n   3) The request is received\
    \ by the airline server which invokes the\n      book_flight application. This\
    \ application retrieves the TIP URL\n      from the input data, and passes this\
    \ on a \"tip_pull()\" API request\n      to its local TM. The tip_pull() function\
    \ causes the following to\n      occur:\n      a. the local TM creates a local\
    \ transaction (under which the\n         work will be performed),\n      b. if\
    \ a TIP connection does not already exist to the superior\n         (travel agency)\
    \ TM (as identified via the IP address passed in\n         the TIP URL), one is\
    \ created and an IDENTIFY exchange occurs\n         (if multiplexing is to be\
    \ used on the connection, this is\n         followed by a MULTIPLEX exchange),\n\
    \      c. a PULL command is sent to the superior TM,\n      d. in response to\
    \ the PULL, the superior TM associates the\n         subordinate (airline) TM\
    \ with the transaction (by associating\n         the connection with the transaction),\
    \ and sends a PULLED\n         response to the subordinate TM,\n      e. the subordinate\
    \ TM returns control to the book_flight\n         application, which is now executing\
    \ in the context of the newly\n         created local transaction.\n   4) The\
    \ book_flight application does its work (which may involve\n      access to a\
    \ recoverable resource manager (e.g. an RDBMS), in which\n      case the local\
    \ TM will associate the RM with the local transaction\n      (via the XA interface\
    \ or whatever)).\n   5) The book_flight application returns to the travel agency\n\
    \      application indicating success.\n   6) Steps 2-5 are then repeated with\
    \ the hotel server \"book_room\"\n      application. At the conclusion of this,\
    \ the superior TM has\n      registered two subordinate TMs as participants in\
    \ the transaction,\n      there are TIP connections between the agency TM and\
    \ the airline\n      and hotel TMs, and there are inflight transactions at the\
    \ airline\n      and hotel servers. [Note that steps 2-5 and 6 could be performed\n\
    \      in parallel.]\n   7) The travel agency application issues a \"commit transaction\"\
    \n      request (using the API of the local TM). The local TM sends a\n      PREPARE\
    \ command on the TIP connections to the airline and hotel\n      TMs (as these\
    \ are registered as subordinate transaction\n      participants).\n   8) The TMs\
    \ at the airline and hotel servers perform the\n      necessary steps to prepare\
    \ their local recoverable resources (e.g.\n      by issuing xa_prepare() requests).\
    \ If successful, the subordinate\n      TMs change their TIP transaction state\
    \ to Prepared, and log\n      recovery information (e.g. local and superior transaction\
    \ branch\n      identifiers, and the IP address of the superior TM). The\n   \
    \   subordinate TMs then send PREPARED commands to the superior TM.\n   9) If\
    \ both subordinates respond PREPARED, the superior TM logs that\n      the transaction\
    \ is Committed, with recovery information (e.g.\n      local and subordinate transaction\
    \ identifiers, and subordinate TM\n      IP addresses). The superior TM then sends\
    \ COMMIT commands on the\n      two subordinate TIP connections.\n   10) The TMs\
    \ at the airline and hotel servers perform the\n       necessary steps to commit\
    \ their local recoverable resources (e.g.\n       by issuing xa_commit() requests).\
    \ The subordinate TMs forget the\n       transaction. The subordinate TMs then\
    \ send COMITTED commands to\n       the superior TM.\n   11) The superior TM forgets\
    \ the transaction. The TIP connections\n       between the superior and subordinate\
    \ TMs return to Idle state\n       (not associated with any transaction). The\
    \ superior TM returns\n       success to the travel agency application \"commit\
    \ transaction\"\n       request.\n   12) The travel agency application returns\
    \ \"reservation made\" to the\n       client.\n   This example illustrates the\
    \ use of PULL. If PUSH were to be used\n   instead, events 2) and 3) above would\
    \ change as follows:\n   2) The travel agency application:\n      a.  passes the\
    \ TIP URL obtained in 1. above, together with the\n          listening endpoint\
    \ address of the TM at the airline server, to\n          its local TM via a \"\
    tip_push()\" API request. The tip_push()\n          function causes the following\
    \ to occur:\n          i. if a TIP connection does not already exist to the\n\
    \             subordinate (airline server) TM (as identified via the IP\n    \
    \         address passed on the tip_push), one is created and an\n           \
    \  IDENTIFY exchange occurs (if multiplexing is to be used on\n             the\
    \ connection, this is followed by a MULTIPLEX exchange),\n          ii. a PUSH\
    \ command is sent to the subordinate TM,\n          iii. in response to the PUSH,\
    \ the subordinate TM creates a\n               local transaction, associates this\
    \ transaction with the\n               connection, and sends a PUSHED response\
    \ to the superior\n               TM,\n          iv. in response to the PUSHED\
    \ response, the superior TM\n              associates the subordinate TM with\
    \ the transaction,\n          v. the superior TM returns control to the travel\
    \ agency\n             application.\n      b.  the travel agency application sends\
    \ a request to the airline\n         server (via some protocol (e.g. HTTP)), requesting\
    \ the\n         \"book_flight\" service, passing the flights selected by the\n\
    \         client, and the TIP URL (obtained in 1 above).\n   3) The request is\
    \ received by the airline server which invokes the\n      book_flight application.\
    \ This application retrieves the TIP URL\n      from the input data, and passes\
    \ this on a \"tip_pull()\" API request\n      to its local TM. Since the local\
    \ TM has already \"seen\" this URL\n      (it was already pushed), it simply returns\
    \ to the book_flight\n      application, which is now executing in the context\
    \ of the\n      previously created local transaction.\n   [Note that although\
    \ in this example the transaction coordinator role\n   is performed by a node\
    \ which is also a participant in the transaction\n   (the Travel Agency), other\
    \ configurations are possible (e.g. where\n   the transaction coordinator role\
    \ is performed by a non-participant\n   3rd-party node).]\n"
- title: 8. TIP Transaction Recovery
  contents:
  - "8. TIP Transaction Recovery\n   Until the transaction reaches the Prepared state,\
    \ any failure results\n   in the transaction being aborted. If an error occurs\
    \ once the\n   transaction has reached the Prepared state, then transaction recovery\n\
    \   must be performed. Recovery behaviour is different for superior and\n   subordinate;\
    \ the details depend upon the outcome of the transaction\n   (committed or aborted),\
    \ and the precise point at which failure\n   occurs.\n   In the travel agency\
    \ application for example, if the connection to\n   the hotel server fails before\
    \ the COMMIT command has been received by\n   the hotel TM, then (once the connection\
    \ is restored):\n   1)  The superior (travel agency) TM sends a RECONNECT command\n\
    \      (passing the subordinate transaction identifier (recovered from\n     \
    \ the transaction log if necessary)).\n   2) The subordinate (hotel) TM responds\
    \ RECONNECTED (since it never\n      received the COMMIT command, and still has\
    \ the transaction in\n      Prepared state (if the failure had occurred after\
    \ the subordinate\n      had responded COMMITTED, then the subordinate would have\
    \ forgotten\n      the transaction, and responded NOTRECONNECTED to the RECONNECT\n\
    \      command)).\n   3) The superior TM sends a COMMIT command. The subordinate\
    \ TM\n      commits the transaction and responds COMMITTED. The transaction is\n\
    \      now resolved.\n   4) If the subordinate TM restores the connection to the\
    \ superior TM\n      before receiving a RECONNECT command, then it may send a\
    \ QUERY\n      command. In this case, the superior TM will respond QUERIEDEXISTS,\n\
    \      and the subordinate TM should wait for the superior to send a\n      RECONNECT\
    \ command. If the transaction had been aborted, then the\n      superior may respond\
    \ QUERIEDNOTFOUND, in which case the\n      subordinate should abort the transaction\
    \ (note that the superior\n      is not obliged to send a RECONNECT command for\
    \ an aborted\n      transaction (i.e. it could just forget the transaction after\n\
    \      sending ABORT and before receiving an ABORTED response)).\n   There are\
    \ failure circumstances in which the client application (the\n   one calling \"\
    commit\") may not receive a response indicating the final\n   outcome of the transaction\
    \ (even though the transaction itself is\n   successfully completed). This is\
    \ a common problem, and one not unique\n   to TIP. In such circumstances, it is\
    \ up to the application to\n   ascertain the final outcome of the transaction\
    \ (a TIP TM may\n   facilitate this by providing some implementation specific\
    \ mechanism.\n   e.g. writing the outcome to a user-log).\n"
- title: 9. TIP Transaction and Application Message Serialisation
  contents:
  - "9. TIP Transaction and Application Message Serialisation\n   A relationship exists\
    \ between TIP commands and application messages:\n   a TIP transaction must not\
    \ be committed until it is certain that all\n   participants have properly registered,\
    \ and have finished work on the\n   transaction. Because of the two-pipe nature\
    \ of TIP, this behaviour\n   cannot necessarily be enforced by the TIP system\
    \ itself (although it\n   may be possible in some implementations). It is therefore\
    \ incumbent\n   upon the application to behave properly.  Generally, an application\n\
    \   must not:\n   1)  call it's local TMs \"commit\" function when it has any\
    \ requests\n       associated with the transaction still outstanding.\n   2) \
    \ positively respond to a transactional request from a partner\n       application\
    \ prior to having registered it's local TM with the\n       transaction.\n"
- title: 10. TIP Protocol and Local Actions
  contents:
  - "10. TIP Protocol and Local Actions\n   In order to ensure that transaction atomicity\
    \ is properly guaranteed,\n   a system implementing TIP must perform other local\
    \ actions at certain\n   points in the protocol exchange. These actions pertain\
    \ to the\n   creation and deletion of transaction \"log-records\" (the necessary\n\
    \   information which survives failures and ensures that transaction\n   recovery\
    \ is correctly executed). The following information regarding\n   the relationship\
    \ between the TIP protocol and logging events is\n   advisory, and is not intended\
    \ to be definitive (see [2] for more\n   discussion on this subject):\n   1) before\
    \ sending a PREPARED response, the system should create\n      a prepared-recovery-record\
    \ for the transaction.\n   2) having created a prepared-recovery-record, this\
    \ record should not\n      be deleted until after:\n      a.  an ABORT message\
    \ is received; or\n      b.  a COMMIT message is received; or\n      c.  a QUERIEDNOTFOUND\
    \ response is received.\n   3) the system should not send a COMMITTED or NOTRECONNECTED\
    \ message\n      if a prepared-recovery-record exists.\n   4) before creating\
    \ a commit-recovery-record for the transaction, the\n      system should have\
    \ received a PREPARED response.\n   5) before sending a COMMIT message in Prepared\
    \ state, the system\n      should have created a commit-recovery-record for the\
    \ transaction.\n   6) having created a commit-recovery-record, this record should\
    \ not be\n      deleted until after:\n      a.  a COMMITTED message is received;\
    \ or\n      b.  a NOTRECONNECTED message is received.\n"
- title: 11. Security Considerations
  contents:
  - "11. Security Considerations\n   The means by which applications communicate and\
    \ perform distributed\n   work are outside the scope of the TIP protocol. The\
    \ mechanisms used\n   for authentication and authorisation of clients to access\
    \ programs\n   and information on a particular system are part of the application\n\
    \   communications protocol and the application execution infrastructure.\n  \
    \ Use of the TIP protocol does not affect these considerations.\n   Security relates\
    \ to the TIP protocol itself inasmuch that systems\n   require to protect themselves\
    \ from the receipt of unauthorised TIP\n   commands, or the impersonation of a\
    \ trusted partner TIP TM.  Probably\n   the worst consequence of this is the possibility\
    \ of undetected data\n   inconsistency resulting from violations of the TIP commitment\n\
    \   protocol (e.g. a COMMIT command is injected on a TIP connection in\n   place\
    \ of an ABORT command). TIP uses the Transport Layer Security\n   protocol [6]\
    \ to restrict access to only trusted partners (i.e. to\n   control from which\
    \ remote endpoints TIP transactions will be\n   accepted, and to verify that an\
    \ end-point is genuine), and to encrypt\n   TIP commands. Usage of TLS (or not)\
    \ is negotiated between partner TIP\n   TMs. See [1] for details of how TLS is\
    \ used with TIP.\n   TIP TM implementations will also likely provide local means\
    \ to time-\n   out and abort transactions which have not completed within some\
    \ time\n   period (thereby preventing unavailability of resources due to\n   malicious\
    \ intent). Transaction time-out also serves as a means of\n   deadlock resolution.\n"
- title: 12. TIP Requirements
  contents:
  - "12. TIP Requirements\n   Most of these requirements stem from the primary objective\
    \ of making\n   transactions a ubiquitous system service, available to all\n \
    \  application classes (much as TCP may be assumed to be available\n   everywhere).\
    \ In general this requires imposing as few restrictions\n   regarding the use\
    \ of TIP as possible (applications should not be\n   required to execute in some\
    \ \"special\" environment in order to use\n   transactions), and keeping the protocol\
    \ simple and efficient. This\n   enables the widespread implementation of TIP\
    \ (it's cheap to do), on a\n   wide range of systems (it's cheap to run).\n  \
    \ 1) Application Communications Protocol Independence\n      The TIP protocol\
    \ must be defined independently of the\n      communications protocol used for\
    \ transferring application data, to\n      allow TIP usage in conjunction with\
    \ any application protocol.  It\n      must be possible for applications using\
    \ arbitrary communications\n      protocols to begin, end, and propagate TIP transactions.\n\
    \      This implies that the TIP protocol employ a 2-pipe model of\n      operation.\
    \ This model requires the separation of application\n      communications and\
    \ transaction coordination, into two discrete\n      communication channels (pipes).\
    \ This separation enables the use of\n      the transaction coordination protocol\
    \ (TIP), with any application\n      communications protocol (e.g. HTTP, ODBC,\
    \ plain TCP/UDP, etc).\n   2) Support for Transaction Semantics\n      The TIP\
    \ protocol must provide the functionality of the de-facto\n      standard presumed-abort\
    \ 2-pc protocol, to guarantee transactional\n      atomicity even in the event\
    \ of failure. It should provide a means\n      to construct the transaction tree,\
    \ as well as provide commitment\n      and recovery functions.\n   3) Application\
    \ Transaction Propagation and Interoperability\n      In order to facilitate protocol\
    \ independence, application\n      interoperability, and provide a means for TIP\
    \ transaction context\n      propagation, a standard representation of the TIP\
    \ transaction\n      context information is required (in the form of a URL). This\n\
    \      information must include the listening endpoint address of the\n      partner\
    \ TIP TM, and transaction identifier information.\n   4) Ease of Implementation\n\
    \      The TIP protocol must be simple to implement. It should support\n     \
    \ only those features necessary to provide a useful, performant 2-pc\n      protocol\
    \ service. The protocol should not add complexity in the\n      form of extraneous\
    \ optimisations.\n   5) Suitability for All Application Classes\n      The TIP\
    \ protocol should be complete and robust enough not only for\n      electronic\
    \ commerce on the web, but also for intranet applications\n      and for traditional\
    \ TP applications spanning heterogenous\n      transaction manager environments.\
    \ The protocol should be\n      performant and scaleable enough to meet the needs\
    \ of low to very\n      high throughput applications.\n      a. the TIP protocol\
    \ should support the concept of client-only\n         transaction participants\
    \ (useful for ultra-lightweight\n         implementations on low-end platforms).\n\
    \      b. since some clients may be unreliable, TIP must provide support\n   \
    \      for delegation of transaction coordination (to a more reliable\n      \
    \   (trusted) node).\n      c. the TIP protocol must scale between 1 and n (>\
    \ 1) concurrent\n         transactions per TCP connection.\n      d. TIP commands\
    \ should be able to be concatenated (pipelined).\n      e. TIP should be compatible\
    \ with the X/Open XA interface.\n   6) Security\n      The TIP protocol must be\
    \ compatible with existing security\n      mechanisms, potentially including encryption,\
    \ firewalls, and\n      authorization mechanisms (e.g. TLS may be used to authenticate\
    \ the\n      sender of a TIP command, and for encryption of TIP commands).\n \
    \     Nothing in the protocol definition should prevent TIP working\n      within\
    \ any security environment.\n   7) TIP Protocol Transport Independence\n     \
    \ It would be beneficial to some applications to allow the TIP\n      protocol\
    \ to flow over different transport protocols. The benefit\n      is when using\
    \ different transport protocols for the application\n      data, the same transport\
    \ can be used for the TIP 2PC protocol. TIP\n      must therefore not preclude\
    \ use with other transport protocols.\n   8) Recovery\n      Recovery semantics\
    \ need to be defined sufficiently to avoid\n      ambiguous results in the event\
    \ of any type of communications\n      transport failure.\n   9) Extensibility\n\
    \      The TIP protocol should be able to be extended, whilst maintaining\n  \
    \    compatibility with previous versions.\n"
- title: References
  contents:
  - "References\n   [1]  Lyon, J., Evans, K., and J. Klein, \"The Transaction Internet\n\
    \        Protocol Version 3.0\", RFC 2371, July 1998.\n   [2]  Transaction Processing:\
    \ Concepts and Techniques.  Morgan\n        Kaufmann Publishers. (ISBN 1-55860-190-2).\
    \  J. Gray, A. Reuter.\n   [3]  X/Open CAE Specification, April 1995, Distributed\
    \ Transaction\n        Processing: The TX Specification. (ISBN 1-85912-094-6).\n\
    \   [4]  X/Open Guide, November 1993, Distributed Transaction Processing:\n  \
    \      Reference Model Version 2. (ISBN 1-85912-019-9).\n   [5]  X/Open CAE Specification,\
    \ December 1991, Distributed Transaction\n        Processing: The XA Specification.\
    \  (ISBN 1-872630-24-3).\n   [6]  Dierks, T., et. al., \"The TLS Protocol Version\
    \ 1.0\", Work in\n        Progress.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Keith Evans\n   Tandem Computers Inc, LOC 252-30\n   5425\
    \ Stevens Creek Blvd\n   Santa Clara, CA 95051-7200, USA\n   Phone: +1 (408) 285\
    \ 5314\n   Fax:   +1 (408) 285 5245\n   EMail: Keith.Evans@Tandem.Com\n   Johannes\
    \ Klein\n   Tandem Computers Inc.\n   10555 Ridgeview Court\n   Cupertino, CA\
    \ 95014-0789, USA\n   Phone: +1 (408) 285 0453\n   Fax:   +1 (408) 285 9818\n\
    \   EMail: Johannes.Klein@Tandem.Com\n   Jim Lyon\n   Microsoft Corporation\n\
    \   One Microsoft Way\n   Redmond, WA  98052-6399, USA\n   Phone: +1 (206) 936\
    \ 0867\n   Fax:   +1 (206) 936 7329\n   EMail: JimLyon@Microsoft.Com\n"
- title: Comments
  contents:
  - "Comments\n   Please send comments on this document to the authors at\n   <JimLyon@Microsoft.Com>,\
    \ <Keith.Evans@Tandem.Com>,\n   <Johannes.Klein@Tandem.Com>, or to the TIP mailing\
    \ list at\n   <Tip@Tandem.Com>. You can subscribe to the TIP mailing list by\n\
    \   sending  mail to <Listserv@Lists.Tandem.Com> with the line\n   \"subscribe\
    \ tip <full name>\" somewhere in the body of the message.\n"
- title: Appendix A. An Example TIP Transaction Manager Application Programming
  contents:
  - "Appendix A. An Example TIP Transaction Manager Application Programming\n    \
    \        Interface.\n   Note that this API is included solely for informational\
    \ purposes, and\n   is not part of the formal TIP specification (TIP conformant\n\
    \   implementations are free to define alternative APIs).\n   1) tip_open() -\
    \ establish a connection to a TIP TM.\n      Synopsis\n         int tip_open ([out]\
    \ tip_handle_t *ptiptm)\n      Parameters\n         ptiptm [out]\n           \
    \      Pointer to the TIP TM handle.\n      Description\n         tip_open() establishes\
    \ a connection to a TIP TM. The call\n         returns a handle which identifies\
    \ the TIP TM. This function\n         must be called before any work can be performed\
    \ on a TIP\n         transaction.\n      Return Values\n         [TIPOK]\n   \
    \            Connection has been successfully established.\n         [TIPNOTCONNECTED]\n\
    \               User has been disconnected from the TIP TM.\n         [TIPNOTCONFIGURED]\n\
    \               TIP TM has not been configured.\n         [TIPTRANSIENT]\n   \
    \            Too many openers; re-try the open.\n         [TIPERROR]\n       \
    \        An unexpected error occurred.\n   2) tip_close() - close a connection\
    \ to a TIP TM.\n      Synopsis\n         int tip_close([in] tip_handle_t handle)\n\
    \      Parameters\n         handle [in]\n                 The TIP TM handle.\n\
    \      Description\n         tip_close() closes a connection to a TIP TM. All\
    \ outstanding\n         requests associated with that connection will be cancelled.\n\
    \      Return Values\n         [TIPOK]\n               Connection has been successfully\
    \ closed.\n         [TIPINVALIDPARM]\n               Invalid connection handle\
    \ specified.\n         [TIPERROR]\n               An unexpected error occurred.\n\
    \   3) tip_push() - export a local transaction to a remote node and\n        \
    \           return a TIP transaction identifier for the\n                   associated\
    \ remote transaction.\n      Synopsis\n         int tip_push ([in] tip_handle_t\
    \ TM,\n                       [in] char *tm_url,\n                       [in]\
    \ void *plocal_xid,\n                       [out] char *pxid_url,\n          \
    \             [in] unsigned int url_length)\n      Parameters\n         TM [in]\n\
    \                 The TIP TM handle.\n         tm_url [in]\n                 Pointer\
    \ to the TIP URL of the remote transaction manager.\n                 A TIP URL\
    \ for a transaction manager takes the form:\n                 TIP://<host>[:<port>]\n\
    \         plocal_xid [in]\n                 Pointer to the local transaction identifier.\
    \ The\n                 structure of the transaction identifier is defined by\
    \ the\n                 local transaction manager.\n         pxid_url [out]\n\
    \                 Pointer to the TIP URL of the associated remote\n          \
    \       transaction. A TIP URL for a transaction takes the form:\n           \
    \      TIP://<host>[:<port>]/<transaction identifier>\n         url_length [in]\n\
    \                 The size in bytes of the buffer for the remote\n           \
    \      transaction URL.\n      Description\n         tip_push() exports (pushes)\
    \ a local transaction to a remote\n         node. If a local transaction identifier\
    \ is not supplied, the\n         caller's current transaction context is used.\
    \ The call returns\n         a TIP URL for the associated remote transaction.\
    \ The TIP\n         transaction identifier may be passed on application requests\
    \ to\n         the remote node (as part of a TIP URL). The receiving process\n\
    \         uses this information in order to do work on behalf of the\n       \
    \  transaction.\n      Return Values\n         [TIPOK]\n               Transaction\
    \ has been successfully pushed to the remote\n               node.\n         [TIPINVALIDXID]\n\
    \               An invalid transaction identifier has been provided.\n       \
    \  [TIPNOCURRENTTX]\n               Process is currently not associated with a\
    \ transaction\n               (and none was supplied).\n         [TIPINVALIDHANDLE]\n\
    \               Invalid connection handle specified.\n         [TIPNOTPUSHED]\n\
    \               Transaction could not be pushed to the remote node.\n        \
    \ [TIPNOTCONNECTED]\n               Caller has been disconnected from the TIP\
    \ TM.\n         [TIPINVALIDURL]\n               Invalid endpoint URL is provided.\n\
    \         [TIPTRANSIENT]\n               Transient error occurred; re-try the\
    \ operation.\n         [TIPTRUNCATED]\n               Insufficient buffer size\
    \ is specified for the TIP\n               transaction identifier.\n         [TIPERROR]\n\
    \               An unexpected error occurred.\n   4) tip_pull() - create a local\
    \ transaction and join it with the TIP\n                   transaction.\n    \
    \  Synopsis\n         int tip_pull([in] tip_handle_t TM,\n                   \
    \   [in] char *pxid_url,\n                      [out] void *plocal_xid,\n    \
    \                  [in] unsigned int xid_length)\n      Parameters\n         TM\
    \ [in]\n               The TIP TM handle.\n         pxid_url [in]\n          \
    \     Pointer to the TIP URL of the associated remote\n               transaction.\
    \ A TIP URL for a transaction takes the form:\n               TIP://<host>[:<port>]/<transaction\
    \ identifier>\n         plocal_xid [out]\n               Pointer to the local\
    \ transaction identifier. The\n               structure of the transaction identifier\
    \ is defined by the\n               local transaction manager.\n         xid_length\
    \ [in]\n               The size in bytes of the buffer for the local transaction\n\
    \               identifier.\n      Description\n         tip_pull() creates a\
    \ local transaction and joins the local\n         transaction with the TIP transaction\
    \ (the caller becomes a\n         subordinate participant in the TIP transaction).\
    \ The remote TIP\n         TM is identified via the URL (*pxid_url). The local\
    \ transaction\n         identifier is returned. If a local transaction has already\
    \ been\n         created for the TIP transaction identifier supplied, then\n \
    \        [TIPOK] is returned (with the local transaction identifier),\n      \
    \   and no other action is taken.\n      Return Values\n         [TIPOK]\n   \
    \            The local transaction has been successfully created\n           \
    \    and joined with the TIP transaction.\n         [TIPINVALIDHANDLE]\n     \
    \          Invalid connection handle specified.\n         [TIPTRUNCATED]\n   \
    \            Insufficient buffer size is specified for the local\n           \
    \    transaction identifier.\n         [TIPNOTPULLED]\n               Joining\
    \ of the local transaction with the TIP\n               transaction has failed.\n\
    \         [TIPNOTCONNECTED]\n               Caller has been disconnected from\
    \ the TIP TM.\n         [TIPINVALIDURL]\n               Invalid URL has been supplied.\n\
    \         [TIPTRANSIENT]\n               Transient error occurred; retry the operation.\n\
    \         [TIPERROR]\n               An unexpected error occurred.\n   5) tip_pull_async()\
    \ - create a local transaction and join it with the\n                        \
    \ TIP transaction. Control is returned to the\n                         caller\
    \ as soon as a local transaction is\n                         created.\n     \
    \ Synopsis\n         int tip_pull_async ([in] tip_handle_t TM\n              \
    \               [in] char *pxid_url,\n                             [out] void\
    \ *plocal_xid,\n                             [in] unsigned int xid_length)\n \
    \     Parameters\n         TM [in]\n               The TIP gateway handle.\n \
    \        pxid_url [in]\n               Pointer to the TIP URL of the associated\
    \ remote\n               transaction. A TIP URL for a transaction takes the form:\n\
    \               TIP://<host>[:<port>]/<transaction identifier>\n         plocal_xid\
    \ [out]\n               Pointer to the local transaction identifier. The\n   \
    \            structure of the transaction identifier is defined by the\n     \
    \          local transaction manager.\n         xid_length [in]\n            \
    \   The size in bytes of the buffer for the local transaction\n              \
    \ identifier.\n      Description\n         tip_pull_async() creates a local transaction\
    \ and joins the\n         local transaction with the TIP transaction (the caller\n\
    \         becomes a subordinate participant in the TIP transaction). The\n   \
    \      remote TIP TM is identified via the URL (*pxid_url). The local\n      \
    \   transaction identifier is returned. A call to tip_pull_async()\n         returns\
    \ immediately after the local transaction has been\n         created (before the\
    \ TIP PULL protocol command is sent). A\n         subsequent call to tip_pull_complete()\
    \ must be issued to check\n         for successful completion of the pull request.\n\
    \      Return Values\n         [TIPOK]\n               The local transaction has\
    \ been successfully created.\n         [TIPINVALIDHANDLE]\n               Invalid\
    \ connection handle specified.\n         [TIPNOTCONNECTED]\n               User\
    \ has been disconnected from the TIP TM.\n         [TIPINVALIDURL]\n         \
    \      Invalid URL has been supplied.\n         [TIPTRANSIENT]\n             \
    \  Transient error has occurred; retry the operation.\n         [TIPTRUNCATED]\n\
    \               Insufficient buffer size is specified for the local\n        \
    \       transaction identifier.\n         [TIPERROR]\n               An unexpected\
    \ error occurred.\n   6) tip_pull_complete() - check whether a previous tip_pull_async()\n\
    \                            request has been successfully completed.\n      Synopsis\n\
    \         int tip_pull_complete ([in] tip_handle_t TM,\n                     \
    \           [in] void *plocal_xid)\n      Parameters\n         TM [in]\n     \
    \          The TIP TM handle.\n         plocal_xid [in]\n               Pointer\
    \ to the local transaction identifier. The\n               structure of the transaction\
    \ identifier is defined by the\n               local transaction manager.\n  \
    \    Description\n         tip_pull_complete() checks whether a previous call\
    \ to\n         tip_pull_async() has been successfully completed. i.e. whether\n\
    \         the local transaction has been successfully joined with the TIP\n  \
    \       transaction. The caller supplies the local transaction\n         identifier\
    \ returned by the previous call to tip_pull_async().\n         Repeated calls\
    \ to tip_pull_complete() for the same local\n         transaction identifier are\
    \ idempotent.\n      Return Values\n         [TIPOK]\n               The local\
    \ transaction has been successfully joined with\n               the TIP transaction.\n\
    \         [TIPINVALIDHANDLE]\n               Invalid connection handle specified.\n\
    \         [TIPINVALIDXID]\n               An invalid transaction identifier has\
    \ been provided.\n         [TIPNOTPULLED]\n               Joining of the local\
    \ transaction with the TIP transaction\n               has failed. The local transaction\
    \ has been aborted.\n         [TIPNOTCONNECTED]\n               Caller has been\
    \ disconnected from the TIP TM.\n         [TIPERROR]\n               An unexpected\
    \ error occurred.\n   7) tip_xid_to_url() - return a TIP transaction identifier\
    \ for a local\n                         transaction identifier.\n      Synopsis\n\
    \         int tip_xid_to_url ([in] tip_handle_t TM,\n                        \
    \     [in] void *plocal_xid,\n                             [out] char *pxid_url,\n\
    \                             [in] unsigned int url_length)\n      Parameters\n\
    \         TM [in]\n               The TIP TM handle.\n         plocal_xid [in]\n\
    \               Pointer to the local transaction identifier. The\n           \
    \    structure of the transaction identifier is defined by the\n             \
    \  local transaction manager.\n         pxid_url [out]\n               Pointer\
    \ to the TIP URL of the local transaction.\n               A TIP URL for a transaction\
    \ takes the form:\n               TIP://<host>[:<port>]/<transaction identifier>\n\
    \         url_length [in]\n               The size in bytes of the buffer for\
    \ the TIP URL.\n      Description\n         tip_xid_to_url() returns a TIP transaction\
    \ identifier for a\n         local transaction identifier. The TIP transaction\
    \ identifier\n         can be passed to remote applications to enable them to\
    \ do work\n         on the transaction. e.g. to pull the local transaction to\
    \ the\n         remote node. If a local transaction identifier is not supplied,\n\
    \         the caller's current transaction context is used. The constant\n   \
    \      TIPURLSIZE defines the size of a TIP transaction identifier in\n      \
    \   bytes. This value is implementation specific.\n      Return Values\n     \
    \    [TIPOK]\n               TIP transaction identifier has been returned.\n \
    \        [TIPNOTCONNECTED]\n               Caller has been disconnected from the\
    \ TIP TM.\n         [TIPNOCURRENTTX]\n               Process is currently not\
    \ associated with a transaction\n               (and none was supplied).\n   \
    \      [TIPINVALIDXID]\n               An invalid local transaction identifier\
    \ has been\n               supplied.\n         [TIPTRUNCATED]\n              \
    \ Insufficient buffer size is specified for the TIP\n               transaction\
    \ identifier.\n         [TIPERROR]\n               An unexpected error occurred.\n\
    \   8) tip_url_to_xid() - return a local transaction identifier for a TIP\n  \
    \                       transaction identifier.\n      Synopsis\n           int\
    \ tip_url_to_xid ([in] tip_handle_t TM,\n                             [in] char\
    \ *pxid_url,\n                             [out] void *plocal_xid,\n         \
    \                    [in] unsigned int xid_length)\n      Parameters\n       \
    \  TM [in]\n               The TIP TM handle.\n         pxid_url [in]\n      \
    \         Pointer to the TIP URL of the local transaction. A TIP\n           \
    \    URL for a transaction takes the form:\n               TIP://<host>[:<port>]/<transaction\
    \ identifier>\n         plocal_xid [out]\n               Pointer to the local\
    \ transaction identifier. The\n               structure of the transaction identifier\
    \ is defined by the\n               local transaction manager.\n         xid_length\
    \ [in]\n               The size in bytes of the buffer for the local transaction\n\
    \               identifier.\n      Description\n         tip_url_to_xid() returns\
    \ a local transaction identifier for a\n         TIP transaction identifier (note\
    \ that the local transaction\n         must have previously been created via a\
    \ tip_push(), or tip_pull\n         (or tip_pull_async()). The constant TIPXIDSIZE\
    \ defines the size\n         of a local transaction identifier in bytes. This\
    \ value is\n         implementation specific.\n      Return Values\n         [TIPOK]\n\
    \               Local transaction identifier is returned.\n         [TIPINVALIDURL]\n\
    \               An invalid TIP transaction identifier has been provided.\n   \
    \      [TIPTRUNCATED]\n               Insufficient buffer size is specified for\
    \ the local\n               transaction identifier.\n         [TIPERROR]\n   \
    \            An unexpected error occurred.\n"
- title: 9)  tip_get_tm_url() - get the name of the local TIP transaction
  contents:
  - "9)  tip_get_tm_url() - get the name of the local TIP transaction\n          \
    \             manager in TIP URL form.\n    Synopsis\n       int tip_get_tm_url\
    \ ([in] tip_handle_t TM,\n                           [out] char *tm_url,\n   \
    \                        [in] int tm_len);\n    Parameters\n       TM[in]\n  \
    \          The TIP TM handle.\n       tm_url [in]\n            Pointer to the\
    \ TIP URL of the local transaction manager. A\n            TIP URL for a transaction\
    \ manager takes the form:\n            TIP://<host>[:<port>]\n       tm_len [out]\n\
    \            The size in bytes of the buffer for the TIP URL of the local\n  \
    \          transaction manager.\n    Description\n       tip_get_tm_url() gets\
    \ the name of the  local transaction\n       manager in TIP URL form (i.e. TIP://<host>[:<port>])\n\
    \    Return Values\n       [TIPOK]\n             The name of the local transaction\
    \ manager has been\n             successfully returned.\n       [TIPTRUNCATED]\n\
    \             The name of the local transaction manager has been\n           \
    \  truncated due to insufficient buffer size. Retry the\n             operation\
    \ with larger buffer size.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
