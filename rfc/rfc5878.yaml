- title: __initial_text__
  contents:
  - '        Transport Layer Security (TLS) Authorization Extensions

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies authorization extensions to the Transport\n\
    \   Layer Security (TLS) Handshake Protocol.  Extensions are carried in\n   the\
    \ client and server hello messages to confirm that both parties\n   support the\
    \ desired authorization data types.  Then, if supported by\n   both the client\
    \ and the server, authorization information, such as\n   attribute certificates\
    \ (ACs) or Security Assertion Markup Language\n   (SAML) assertions, is exchanged\
    \ in the supplemental data handshake\n   message.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5878.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Transport Layer Security (TLS) protocol ([TLS1.0], [TLS1.1],\n\
    \   [TLS1.2]) is being used in an increasing variety of operational\n   environments,\
    \ including ones that were not envisioned at the time of\n   the original design\
    \ for TLS.  The extensions introduced in this\n   document are designed to enable\
    \ TLS to operate in environments where\n   authorization information needs to\
    \ be exchanged between the client\n   and the server before any protected data\
    \ is exchanged.  The use of\n   these TLS authorization extensions is especially\
    \ attractive when more\n   than one application protocol can make use of the same\
    \ authorization\n   information.\n   The format and content of the authorization\
    \ information carried in\n   these extensions are extensible.  This document references\
    \ Security\n   Assertion Markup Language (SAML) assertion ([SAML1.1], [SAML2.0])\
    \ and\n   X.509 attribute certificate (AC) [ATTRCERT] authorization formats,\n\
    \   but other formats can be used.  Future authorization extensions may\n   include\
    \ any opaque assertion that is digitally signed by a trusted\n   issuer.  Recognizing\
    \ the similarity to certification path validation,\n   this document recommends\
    \ the use of TLS Alert messages related to\n   certificate processing to report\
    \ authorization information processing\n   failures.\n   Straightforward binding\
    \ of identification, authentication, and\n   authorization information to an encrypted\
    \ session is possible when\n   all of these are handled within TLS.  If each application\
    \ requires\n   unique authorization information, then it might best be carried\n\
    \   within the TLS-protected application protocol.  However, care must be\n  \
    \ taken to ensure appropriate bindings when identification,\n   authentication,\
    \ and authorization information are handled at\n   different protocol layers.\n\
    \   This document describes authorization extensions for the TLS\n   Handshake\
    \ Protocol in TLS 1.0, TLS 1.1, and TLS 1.2.  These\n   extensions observe the\
    \ conventions defined for TLS extensions that\n   were originally defined in [TLSEXT1]\
    \ and revised in [TLSEXT2]; TLS\n   extensions are now part of TLS 1.2 [TLS1.2].\
    \  TLS extensions use\n   general extension mechanisms for the client hello message\
    \ and the\n   server hello message.  The extensions described in this document\n\
    \   confirm that both the client and the server support the desired\n   authorization\
    \ data types.  Then, if supported, authorization\n   information is exchanged\
    \ in the supplemental data handshake message\n   [TLSSUPP].\n   The authorization\
    \ extensions may be used in conjunction with TLS 1.0,\n   TLS 1.1, and TLS 1.2.\
    \  The extensions are designed to be backwards\n   compatible, meaning that the\
    \ handshake protocol supplemental data\n   messages will only contain authorization\
    \ information of a particular\n   type if the client indicates support for them\
    \ in the client hello\n   message and the server indicates support for them in\
    \ the server hello\n   message.\n   Clients typically know the context of the\
    \ TLS session that is being\n   set up; thus, the client can use the authorization\
    \ extensions when\n   they are needed.  Servers must accept extended client hello\
    \ messages,\n   even if the server does not \"understand\" all of the listed\n\
    \   extensions.  However, the server will not indicate support for these\n   \"\
    not understood\" extensions.  Then, clients may reject communications\n   with\
    \ servers that do not support the authorization extensions.\n"
- title: 1.1.  Conventions
  contents:
  - "1.1.  Conventions\n   The syntax for the authorization messages is defined using\
    \ the TLS\n   Presentation Language, which is specified in Section 4 of [TLS1.0].\n\
    \   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\"\
    ,\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in\
    \ this\n   document are to be interpreted as described in RFC 2119 [STDWORDS].\n"
- title: 1.2.  Overview
  contents:
  - "1.2.  Overview\n   Figure 1 illustrates the placement of the authorization extensions\n\
    \   and supplemental data messages in the full TLS handshake.\n   The ClientHello\
    \ message includes an indication of the client\n   authorization data formats\
    \ that are supported and an indication of\n   the server authorization data formats\
    \ that are supported.  The\n   ServerHello message contains similar indications,\
    \ but any\n   authorization data formats that are not supported by the server\
    \ are\n   not included.  Both the client and the server MUST indicate support\n\
    \   for the authorization data types.  If the list of mutually supported\n   authorization\
    \ data formats is empty, then the ServerHello message\n   MUST NOT carry the affected\
    \ extension at all.\n   Successful session resumption uses the same authorization\
    \ information\n   as the original session.\n    Client                       \
    \                            Server\n    ClientHello (w/ extensions) -------->\n\
    \                                        ServerHello (w/ extensions)\n       \
    \                                           SupplementalData*\n              \
    \                                         Certificate*\n                     \
    \                            ServerKeyExchange*\n                            \
    \                    CertificateRequest*\n                                <--------\
    \           ServerHelloDone\n    SupplementalData*\n    Certificate*\n    ClientKeyExchange\n\
    \    CertificateVerify*\n    [ChangeCipherSpec]\n    Finished                \
    \    -------->\n                                                 [ChangeCipherSpec]\n\
    \                                <--------                  Finished\n    Application\
    \ Data            <------->          Application Data\n     *  Indicates optional\
    \ or situation-dependent messages that\n        are not always sent.\n     []\
    \ Indicates that ChangeCipherSpec is an independent TLS\n        protocol content\
    \ type; it is not actually a TLS\n        handshake message.\n       Figure 1.\
    \  Authorization Data Exchange in Full TLS Handshake\n"
- title: 2.  Authorization Extension Types
  contents:
  - "2.  Authorization Extension Types\n   The general extension mechanisms enable\
    \ clients and servers to\n   negotiate whether to use specific extensions, and\
    \ how to use specific\n   extensions.  As specified in [TLS1.2], the extension\
    \ format used in\n   the extended client hello message and extended server hello\
    \ message\n   is repeated here for convenience:\n      struct {\n         ExtensionType\
    \ extension_type;\n         opaque extension_data<0..2^16-1>;\n      } Extension;\n\
    \   The extension_type identifies a particular extension type, and the\n   extension_data\
    \ contains information specific to the particular\n   extension type.  This document\
    \ specifies the use of two new extension\n   types: client_authz and server_authz.\
    \  These extension types are\n   described in Section 2.1 and Section 2.2, respectively.\
    \  This\n   specification adds two new types to ExtensionType:\n      enum {\n\
    \        client_authz(7), server_authz(8), (65535)\n      } ExtensionType;\n \
    \  The authorization extensions are relevant when a session is initiated\n   and\
    \ on any subsequent session resumption.  However, a client that\n   requests resumption\
    \ of a session does not know whether the server\n   will have all of the context\
    \ necessary to accept this request, and\n   therefore the client SHOULD send an\
    \ extended client hello message\n   that includes the extension types associated\
    \ with the authorization\n   extensions.  This way, if the resumption request\
    \ is denied, then the\n   authorization extensions will be negotiated as normal.\n\
    \   When a session is resumed, ClientHello is followed immediately by\n   ChangeCipherSpec,\
    \ which does not provide an opportunity for different\n   authorization information\
    \ can be exchanged.  Successful session\n   resumption MUST use the same authorization\
    \ information as the\n   original session.\n"
- title: 2.1.  The client_authz Extension Type
  contents:
  - "2.1.  The client_authz Extension Type\n   Clients MUST include the client_authz\
    \ extension type in the extended\n   client hello message to indicate their desire\
    \ to send authorization\n   data to the server.  The extension_data field indicates\
    \ the format of\n   the authorization data that will be sent in the supplemental\
    \ data\n   handshake message.  The syntax of the client_authz extension_data\n\
    \   field is described in Section 2.3.\n   Servers that receive an extended client\
    \ hello message containing the\n   client_authz extension MUST respond with the\
    \ same client_authz\n   extension in the extended server hello message if the\
    \ server is\n   willing to receive authorization data in the indicated format.\
    \  Any\n   unacceptable formats must be removed from the list provided by the\n\
    \   client.  The client_authz extension MUST be omitted from the extended\n  \
    \ server hello message if the server is not willing to receive\n   authorization\
    \ data in any of the indicated formats.\n"
- title: 2.2.  The server_authz Extension Type
  contents:
  - "2.2.  The server_authz Extension Type\n   Clients MUST include the server_authz\
    \ extension type in the extended\n   client hello message to indicate their desire\
    \ to receive\n   authorization data from the server.  The extension_data field\n\
    \   indicates the format of the authorization data that will be sent in\n   the\
    \ supplemental data handshake message.  The syntax of the\n   server_authz extension_data\
    \ field is described in Section 2.3.\n   Servers that receive an extended client\
    \ hello message containing the\n   server_authz extension MUST respond with the\
    \ same server_authz\n   extension in the extended server hello message if the\
    \ server is\n   willing to provide authorization data in the requested format.\
    \  Any\n   unacceptable formats must be removed from the list provided by the\n\
    \   client.  The server_authz extension MUST be omitted from the extended\n  \
    \ server hello message if the server is not able to provide\n   authorization\
    \ data in any of the indicated formats.\n"
- title: 2.3.  AuthzDataFormat Type
  contents:
  - "2.3.  AuthzDataFormat Type\n   The AuthzDataFormat type is used in both the client_authz\
    \ and the\n   server_authz extensions.  It indicates the format of the\n   authorization\
    \ data that will be transferred.  The AuthzDataFormats\n   type definition is:\n\
    \      enum {\n         x509_attr_cert(0), saml_assertion(1), x509_attr_cert_url(2),\n\
    \         saml_assertion_url(3), (255)\n      } AuthzDataFormat;\n      AuthzDataFormats\
    \ authz_format_list<1..2^8-1>;\n   When the x509_attr_cert value is present, the\
    \ authorization data is\n   an X.509 attribute certificate (AC) that conforms\
    \ to the profile in\n   RFC 5755 [ATTRCERT].\n   When the saml_assertion value\
    \ is present, the authorization data is\n   an assertion composed using the Security\
    \ Assertion Markup Language\n   (SAML) ([SAML1.1], [SAML2.0]).\n   When the x509_attr_cert_url\
    \ value is present, the authorization data\n   is an X.509 AC that conforms to\
    \ the profile in RFC 5755 [ATTRCERT];\n   however, the AC is fetched with the\
    \ supplied URL.  A one-way hash\n   value is provided to ensure that the intended\
    \ AC is obtained.\n   When the saml_assertion_url value is present, the authorization\
    \ data\n   is a SAML assertion; however, the SAML assertion is fetched with the\n\
    \   supplied URL.  A one-way hash value is provided to ensure that the\n   intended\
    \ SAML assertion is obtained.\n   Implementations that support either x509_attr_cert_url\
    \ or\n   saml_assertion_url MUST support URLs that employ the http scheme\n  \
    \ [HTTP].  These implementations MUST confirm that the hash value\n   computed\
    \ on the fetched authorization matches the one received in the\n   handshake.\
    \  Mismatch of the hash values SHOULD be treated as though\n   the authorization\
    \ was not provided, which will result in a\n   bad_certificate_hash_value alert\
    \ (see Section 4).  Implementations\n   MUST deny access if the authorization\
    \ cannot be obtained from the\n   provided URL, by sending a certificate_unobtainable\
    \ alert (see\n   Section 4).\n"
- title: 3.  Supplemental Data Handshake Message Usage
  contents:
  - "3.  Supplemental Data Handshake Message Usage\n   As shown in Figure 1, supplemental\
    \ data can be exchanged in two\n   places in the handshake protocol.  The client_authz\
    \ extension\n   determines what authorization data formats are acceptable for\n\
    \   transfer from the client to the server, and the server_authz\n   extension\
    \ determines what authorization data formats are acceptable\n   for transfer from\
    \ the server to the client.  In both cases, the\n   syntax specified in [TLSSUPP]\
    \ is used along with the authz_data type\n   defined in this document.\n     \
    \ enum {\n         authz_data(16386), (65535)\n      } SupplementalDataType;\n\
    \      struct {\n         SupplementalDataType supplemental_data_type;\n     \
    \    select(SupplementalDataType) {\n            case authz_data:  AuthorizationData;\n\
    \         }\n      } SupplementalData;\n"
- title: 3.1.  Client Authorization Data
  contents:
  - "3.1.  Client Authorization Data\n   The SupplementalData message sent from the\
    \ client to the server\n   contains authorization data associated with the TLS\
    \ client.\n   Following the principle of least privilege, the client ought to\
    \ send\n   the minimal set of authorization information necessary to accomplish\n\
    \   the task at hand.  That is, only those authorizations that are\n   expected\
    \ to be required by the server in order to gain access to the\n   needed server\
    \ resources ought to be included.  The format of the\n   authorization data depends\
    \ on the format negotiated in the\n   client_authz hello message extension.  The\
    \ AuthorizationData\n   structure is described in Section 3.3.\n   In some systems,\
    \ clients present authorization information to the\n   server, and then the server\
    \ provides new authorization information.\n   This type of transaction is not\
    \ supported by SupplementalData\n   messages.  In cases where the client intends\
    \ to request the TLS\n   server to perform authorization translation or expansion\
    \ services,\n   such translation services ought to occur within the ApplicationData\n\
    \   messages, and not within the TLS Handshake Protocol.\n"
- title: 3.2.  Server Authorization Data
  contents:
  - "3.2.  Server Authorization Data\n   The SupplementalData message sent from the\
    \ server to the client\n   contains authorization data associated with the TLS\
    \ server.  This\n   authorization information is expected to include statements\
    \ about the\n   server's qualifications, reputation, accreditation, and so on.\n\
    \   Wherever possible, authorizations that can be misappropriated for\n   fraudulent\
    \ use ought to be avoided.  The format of the authorization\n   data depends on\
    \ the format negotiated in the server_authz hello\n   message extensions.  The\
    \ AuthorizationData structure is described in\n   Section 3.3, and the following\
    \ fictitious example of a single 5-octet\n   SAML assertion illustrates its use:\n\
    \      17             # Handshake.msg_type == supplemental_data(23)\n      00\
    \ 00 11       # Handshake.length = 17\n      00 00 0e       # length of SupplementalData.supp_data\
    \ = 14\n      40 02          # SupplementalDataEntry.supp_data_type = 16386\n\
    \      00 0a          # SupplementalDataEntry.supp_data_length = 10\n      00\
    \ 08          # length of AuthorizationData.authz_data_list = 8\n      01    \
    \         # authz_format = saml_assertion(1)\n      00 05          # length of\
    \ SAMLAssertion\n      aa aa aa aa aa # SAML assertion (fictitious: \"aa aa aa\
    \ aa aa\")\n"
- title: 3.3.  AuthorizationData Type
  contents:
  - "3.3.  AuthorizationData Type\n   The AuthorizationData structure carries authorization\
    \ information for\n   either the client or the server.  The AuthzDataFormat specified\
    \ in\n   Section 2.3 for use in the hello extensions is also used in this\n  \
    \ structure.\n   All of the entries in the authz_data_list MUST employ authorization\n\
    \   data formats that were negotiated in the relevant hello message\n   extension.\n\
    \   The HashAlgorithm type is taken from [TLS1.2], which allows\n   additional\
    \ one-way hash functions to be registered in the IANA TLS\n   HashAlgorithm registry\
    \ in the future.\n      struct{\n         AuthorizationDataEntry authz_data_list<1..2^16-1>;\n\
    \      } AuthorizationData;\n      struct {\n         AuthzDataFormat authz_format;\n\
    \         select (AuthzDataFormat) {\n            case x509_attr_cert:       \
    \  X509AttrCert;\n            case saml_assertion:         SAMLAssertion;\n  \
    \          case x509_attr_cert_url:     URLandHash;\n            case saml_assertion_url:\
    \     URLandHash;\n         }\n      } AuthorizationDataEntry;\n      enum {\n\
    \         x509_attr_cert(0), saml_assertion(1), x509_attr_cert_url(2),\n     \
    \    saml_assertion_url(3), (255)\n      } AuthzDataFormat;\n      opaque X509AttrCert<1..2^16-1>;\n\
    \      opaque SAMLAssertion<1..2^16-1>;\n      struct {\n         opaque url<1..2^16-1>;\n\
    \         HashAlgorithm hash_alg;\n         select (hash_alg) {\n            case\
    \ md5:    MD5Hash;\n            case sha1:   SHA1Hash;\n            case sha224:\
    \ SHA224Hash;\n            case sha256: SHA256Hash;\n            case sha384:\
    \ SHA384Hash;\n            case sha512: SHA512Hash;\n         } hash;\n      }\
    \ URLandHash;\n      enum {\n         none(0), md5(1), sha1(2), sha224(3), sha256(4),\
    \ sha384(5),\n         sha512(6), (255)\n      } HashAlgorithm;\n      opaque\
    \ MD5Hash[16];\n      opaque SHA1Hash[20];\n      opaque SHA224Hash[28];\n   \
    \   opaque SHA256Hash[32];\n      opaque SHA384Hash[48];\n      opaque SHA512Hash[64];\n"
- title: 3.3.1.  X.509 Attribute Certificate
  contents:
  - "3.3.1.  X.509 Attribute Certificate\n   When X509AttrCert is used, the field\
    \ contains an ASN.1 Distinguished\n   Encoding Rules (DER)-encoded X.509 attribute\
    \ certificate (AC) that\n   follows the profile in RFC 5755 [ATTRCERT].  An AC\
    \ is a structure\n   similar to a public key certificate (PKC) [PKIX1]; the main\n\
    \   difference is that the AC contains no public key.  An AC may contain\n   attributes\
    \ that specify group membership, role, security clearance,\n   or other authorization\
    \ information associated with the AC holder.\n   When making an authorization\
    \ decision based on an AC, proper linkage\n   between the AC holder and the public\
    \ key certificate that is\n   transferred in the TLS Certificate message is needed.\
    \  The AC holder\n   field provides this linkage.  The holder field is a SEQUENCE\
    \ allowing\n   three different (optional) syntaxes: baseCertificateID, entityName,\n\
    \   and objectDigestInfo.  In the TLS authorization context, the holder\n   field\
    \ MUST use either the baseCertificateID or entityName.  In the\n   baseCertificateID\
    \ case, the baseCertificateID field MUST match the\n   issuer and serialNumber\
    \ fields in the certificate.  In the entityName\n   case, the entityName MUST\
    \ be the same as the subject field in the\n   certificate or one of the subjectAltName\
    \ extension values in the\n   certificate.  Note that [PKIX1] mandates that the\
    \ subjectAltName\n   extension be present if the subject field contains an empty\n\
    \   distinguished name.\n"
- title: 3.3.2.  SAML Assertion
  contents:
  - "3.3.2.  SAML Assertion\n   When SAMLAssertion is used, the field MUST contain\
    \ well-formed XML\n   [XML1.0] and MUST use either UTF-8 [UTF-8] or UTF-16 [UTF-16]\n\
    \   character encoding.  UTF-8 is the preferred character encoding.  The\n   XML\
    \ text declaration MUST be followed by an <Assertion> element using\n   the AssertionType\
    \ complex type as defined in [SAML1.1] and [SAML2.0].\n   The XML text MUST also\
    \ follow the rules of [XML1.0] for including the\n   Byte Order Mark (BOM) in\
    \ encoded entities.  SAML is an XML-based\n   framework for exchanging security\
    \ information.  This security\n   information is expressed in the form of assertions\
    \ about subjects,\n   where a subject is either human or computer with an identity.\
    \  In\n   this context, the SAML assertions are most likely to convey\n   authentication\
    \ or attribute statements to be used as input to\n   authorization policy governing\
    \ whether subjects are allowed to access\n   certain resources.  Assertions are\
    \ issued by SAML authorities.\n   When making an authorization decision based\
    \ on a SAML assertion,\n   proper linkage between the SAML assertion and the public\
    \ key\n   certificate that is transferred in the TLS Certificate message may be\n\
    \   needed.  A \"Holder of Key\" subject confirmation method in the SAML\n   assertion\
    \ can provide this linkage.  In other scenarios, it may be\n   acceptable to use\
    \ alternate confirmation methods that do not provide\n   a strong binding, such\
    \ as a bearer mechanism.  SAML assertion\n   recipients MUST decide which subject\
    \ confirmation methods are\n   acceptable; such decisions MAY be specific to the\
    \ SAML assertion\n   contents and the TLS session context.\n   There is no general\
    \ requirement that the subject of the SAML\n   assertion correspond directly to\
    \ the subject of the certificate.\n   They may represent the same or different\
    \ entities.  When they are\n   different, SAML also provides a mechanism by which\
    \ the certificate\n   subject can be identified separately from the subject in\
    \ the SAML\n   assertion subject confirmation method.\n   Since the SAML assertion\
    \ is being provided at a part of the TLS\n   handshake that is unencrypted, an\
    \ eavesdropper could replay the same\n   SAML assertion when they establish their\
    \ own TLS session.  This is\n   especially important when a bearer mechanism is\
    \ employed; the\n   recipient of the SAML assertion assumes that the sender is\
    \ an\n   acceptable attesting entity for the SAML assertion.  Some constraints\n\
    \   may be included to limit the context where the bearer mechanism will\n   be\
    \ accepted.  For example, the period of time that the SAML assertion\n   can be\
    \ short-lived (often minutes), the source address can be\n   constrained, or the\
    \ destination endpoint can be identified.  Also,\n   bearer assertions are often\
    \ checked against a cache of SAML assertion\n   unique identifiers that were recently\
    \ received, in order to detect\n   replay.  This is an appropriate countermeasure\
    \ if the bearer\n   assertion is intended to be used just once.  Section 6 provides\
    \ a way\n   to protect authorization information when necessary.\n"
- title: 3.3.3.  URL and Hash
  contents:
  - "3.3.3.  URL and Hash\n   Since the X.509 AC and SAML assertion can be large,\
    \ alternatives\n   provide a URL to obtain the ASN.1 DER-encoded X.509 AC or SAML\n\
    \   assertion.  To ensure that the intended object is obtained, a one-way\n  \
    \ hash value of the object is also included.  Integrity of this one-way\n   hash\
    \ value is provided by the TLS Finished message.\n   Implementations that support\
    \ either x509_attr_cert_url or\n   saml_assertion_url MUST support URLs that employ\
    \ the HTTP scheme.\n   Other schemes may also be supported.  When dereferencing\
    \ these URLs,\n   circular dependencies MUST be avoided.  Avoiding TLS when\n\
    \   dereferencing these URLs is one way to avoid circular dependencies.\n   Therefore,\
    \ clients using the HTTP scheme MUST NOT use these TLS\n   extensions if UPGRADE\
    \ in HTTP [UPGRADE] is used.  For other schemes,\n   similar care must be taken\
    \ to avoid using these TLS extensions.\n   Implementations that support either\
    \ x509_attr_cert_url or\n   saml_assertion_url MUST support both SHA-1 [SHS] and\
    \ SHA-256 [SHS] as\n   one-way hash functions.  Other one-way hash functions may\
    \ also be\n   supported.  Additional one-way hash functions can be added to the\n\
    \   IANA TLS HashAlgorithm registry in the future.\n   Implementations that support\
    \ x509_attr_cert_url MUST support\n   responses that employ the \"application/pkix-attr-cert\"\
    \ Multipurpose\n   Internet Mail Extension (MIME) media type as defined in [ACTYPE].\n\
    \   Implementations that support saml_assertion_url MUST support\n   responses\
    \ that employ the \"application/samlassertion+xml\" MIME type\n   as defined in\
    \ Appendix A of [SAMLBIND].\n   TLS authorizations SHOULD follow the additional\
    \ guidance provided in\n   Section 3.3 of [TLSEXT2] regarding client certificate\
    \ URLs.\n"
- title: 4.  Alert Messages
  contents:
  - "4.  Alert Messages\n   This document specifies the reuse of TLS Alert messages\
    \ related to\n   public key certificate processing for any errors that arise during\n\
    \   authorization processing, while preserving the AlertLevels as\n   authoritatively\
    \ defined in [TLS1.2] or [TLSEXT2].  All alerts used in\n   authorization processing\
    \ are fatal.\n   The following updated definitions for the Alert messages are\
    \ used to\n   describe errors that arise while processing authorizations.  For\
    \ ease\n   of comparison, we reproduce the Alert message definition from\n   Section\
    \ 7.2 of [TLS1.2], augmented with two values defined in\n   [TLSEXT2]:\n     \
    \ enum { warning(1), fatal(2), (255) } AlertLevel;\n      enum {\n          close_notify(0),\n\
    \          unexpected_message(10),\n          bad_record_mac(20),\n          decryption_failed_RESERVED(21),\n\
    \          record_overflow(22),\n          decompression_failure(30),\n      \
    \    handshake_failure(40),\n          no_certificate_RESERVED(41),\n        \
    \  bad_certificate(42),\n          unsupported_certificate(43),\n          certificate_revoked(44),\n\
    \          certificate_expired(45),\n          certificate_unknown(46),\n    \
    \      illegal_parameter(47),\n          unknown_ca(48),\n          access_denied(49),\n\
    \          decode_error(50),\n          decrypt_error(51),\n          export_restriction_RESERVED(60),\n\
    \          protocol_version(70),\n          insufficient_security(71),\n     \
    \     internal_error(80),\n          user_canceled(90),\n          no_renegotiation(100),\n\
    \          unsupported_extension(110),\n          certificate_unobtainable(111),\n\
    \          bad_certificate_hash_value(114),\n          (255)\n      } AlertDescription;\n\
    \      struct {\n          AlertLevel level;\n          AlertDescription description;\n\
    \      } Alert;\n   TLS processing of alerts includes some ambiguity because the\
    \ message\n   does not indicate which certificate in a certification path gave\
    \ rise\n   to the error.  This problem is made slightly worse in this extended\n\
    \   use of alerts, as the alert could be the result of an error in\n   processing\
    \ of either a certificate or an authorization.\n   Implementations that support\
    \ these extensions should be aware of this\n   imprecision.\n   The AlertDescription\
    \ values are used as follows to report errors in\n   authorizations processing:\n\
    \      bad_certificate\n         In certificate processing, bad_certificate indicates\
    \ that a\n         certificate was corrupt, contained signatures that did not\n\
    \         verify correctly, and so on.  Similarly, in authorization\n        \
    \ processing, bad_certificate indicates that an authorization was\n         corrupt,\
    \ contained signatures that did not verify correctly,\n         and so on.  In\
    \ authorization processing, bad_certificate can\n         also indicate that the\
    \ handshake established that an\n         AuthzDataFormat was to be provided,\
    \ but no AuthorizationData of\n         the expected format was provided in SupplementalData.\n\
    \      unsupported_certificate\n         In certificate processing, unsupported_certificate\
    \ indicates\n         that a certificate was of an unsupported type.  Similarly,\
    \ in\n         authorization processing, unsupported_certificate indicates\n \
    \        that AuthorizationData uses a version or format unsupported by\n    \
    \     the implementation.\n      certificate_revoked\n         In certificate\
    \ processing, certificate_revoked indicates that a\n         certificate was revoked\
    \ by its issuer.  Similarly, in\n         authorization processing, certificate_revoked\
    \ indicates that\n         authorization was revoked by its issuer, or a certificate\
    \ that\n         was needed to validate the signature on the authorization was\n\
    \         revoked by its issuer.\n      certificate_expired\n         In certificate\
    \ processing, certificate_expired indicates that a\n         certificate has expired\
    \ or is not currently valid.  Similarly,\n         in authorization processing,\
    \ certificate_expired indicates that\n         an authorization has expired or\
    \ is not currently valid.\n      certificate_unknown\n         In certificate\
    \ processing, certificate_unknown indicates that\n         some other (unspecified)\
    \ issue arose while processing the\n         certificate, rendering it unacceptable.\
    \  Similarly, in\n         authorization processing, certificate_unknown indicates\
    \ that\n         processing of AuthorizationData failed because of other\n   \
    \      (unspecified) issues, including AuthzDataFormat parse errors.\n      unknown_ca\n\
    \         In certificate processing, unknown_ca indicates that a valid\n     \
    \    certification path or partial certification path was received,\n        \
    \ but the certificate was not accepted because the certification\n         authority\
    \ (CA) certificate could not be located or could not be\n         matched with\
    \ a known, trusted CA.  Similarly, in authorization\n         processing, unknown_ca\
    \ indicates that the authorization issuer\n         is not known and trusted.\n\
    \      access_denied\n         In certificate processing, access_denied indicates\
    \ that a valid\n         certificate was received, but when access control was\
    \ applied,\n         the sender decided not to proceed with negotiation.  Similarly,\n\
    \         in authorization processing, access_denied indicates that the\n    \
    \     authorization was not sufficient to grant access.\n      certificate_unobtainable\n\
    \         The client_certificate_url extension defined in RFC 4366\n         [TLSEXT2]\
    \ specifies that download errors lead to a\n         certificate_unobtainable\
    \ alert.  Similarly, in authorization\n         processing, certificate_unobtainable\
    \ indicates that a URL does\n         not result in an authorization.  While certificate\
    \ processing\n         does not require this alert to be fatal, this is a fatal\
    \ alert\n         in authorization processing.\n      bad_certificate_hash_value\n\
    \         In certificate processing, bad_certificate_hash_value indicates\n  \
    \       that a downloaded certificate does not match the expected hash.\n    \
    \     Similarly, in authorization processing,\n         bad_certificate_hash_value\
    \ indicates that a downloaded\n         authorization does not match the expected\
    \ hash.\n"
- title: 5.  IANA Considerations
  contents:
  - "5.  IANA Considerations\n   This document defines two TLS extensions: client_authz(7)\
    \ and\n   server_authz(8).  These extension type values are assigned from the\n\
    \   TLS Extension Type registry defined in [TLSEXT2].\n   This document defines\
    \ one TLS supplemental data type:\n   authz_data(16386).  This supplemental data\
    \ type is assigned from the\n   TLS Supplemental Data Type registry defined in\
    \ [TLSSUPP].\n   This document establishes a new registry, to be maintained by\
    \ IANA,\n   for TLS Authorization Data Formats.  The first four entries in the\n\
    \   registry are x509_attr_cert(0), saml_assertion(1),\n   x509_attr_cert_url(2),\
    \ and saml_assertion_url(3).  TLS Authorization\n   Data Format identifiers with\
    \ values in the inclusive range 0-63\n   (decimal) are assigned via RFC 5226 [IANA]\
    \ IETF Review.  Values from\n   the inclusive range 64-223 (decimal) are assigned\
    \ via RFC 5226\n   Specification Required.  Values from the inclusive range 224-255\n\
    \   (decimal) are reserved for RFC 5226 Private Use.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   A TLS server can support more than one application,\
    \ and each\n   application may include several features, each of which requires\n\
    \   separate authorization checks.  This is the reason that more than one\n  \
    \ piece of authorization information can be provided.\n   A TLS server that requires\
    \ different authorization information for\n   different applications or different\
    \ application features may find\n   that a client has provided sufficient authorization\
    \ information to\n   grant access to a subset of these offerings.  In this situation,\
    \ the\n   TLS Handshake Protocol will complete successfully; however, the\n  \
    \ server must ensure that the client will only be able to use the\n   appropriate\
    \ applications and application features.  That is, the TLS\n   server must deny\
    \ access to the applications and application features\n   for which authorization\
    \ has not been confirmed.\n   In cases where the authorization information itself\
    \ is sensitive, the\n   double handshake technique can be used to provide protection\
    \ for the\n   authorization information.  Figure 2 illustrates the double\n  \
    \ handshake, where the initial handshake does not include any\n   authorization\
    \ extensions, but it does result in protected\n   communications.  Then, a second\
    \ handshake that includes the\n   authorization information is performed using\
    \ the protected\n   communications.  In Figure 2, the number on the right side\
    \ indicates\n   the amount of protection for the TLS message on that line.  A\
    \ zero\n   (0) indicates that there is no communication protection; a one (1)\n\
    \   indicates that protection is provided by the first TLS session; and a\n  \
    \ two (2) indicates that protection is provided by both TLS sessions.\n   The\
    \ placement of the SupplementalData message in the TLS handshake\n   results in\
    \ the server providing its authorization information before\n   the client is\
    \ authenticated.  In many situations, servers will not\n   want to provide authorization\
    \ information until the client is\n   authenticated.  The double handshake illustrated\
    \ in Figure 2 provides\n   a technique to ensure that the parties are mutually\
    \ authenticated\n   before either party provides authorization information.\n\
    \   The use of bearer SAML assertions allows an eavesdropper or a man-in-\n  \
    \ the-middle to capture the SAML assertion and try to reuse it in\n   another\
    \ context.  The constraints discussed in Section 3.3.2 might be\n   effective\
    \ against an eavesdropper, but they are less likely to be\n   effective against\
    \ a man-in-the-middle.  Authentication of both\n   parties in the TLS session,\
    \ which involves the use of client\n   authentication, will prevent an undetected\
    \ man-in-the-middle, and the\n   use of the double handshake illustrated in Figure\
    \ 2 will prevent the\n   disclosure of the bearer SAML assertion to any party\
    \ other than the\n   TLS peer.\n   AuthzDataFormats that point to authorization\
    \ data, such as\n   x509_attr_cert_url and saml_assertion_url, rather than simply\n\
    \   including the authorization data in the handshake, may be exploited\n   by\
    \ an attacker.  Implementations that accept pointers to\n   authorization data\
    \ SHOULD adopt a policy of least privilege that\n   limits the acceptable references\
    \ that they will attempt to use.  For\n   more information, see Section 6.3 of\
    \ [TLSEXT2].\n    Client                                                   Server\n\
    \    ClientHello (no extensions) -------->                            |0\n   \
    \                                     ServerHello (no extensions)  |0\n      \
    \                                                 Certificate*  |0\n         \
    \                                        ServerKeyExchange*  |0\n            \
    \                                    CertificateRequest*  |0\n               \
    \                 <--------           ServerHelloDone  |0\n    Certificate*  \
    \                                                   |0\n    ClientKeyExchange\
    \                                                |0\n    CertificateVerify*  \
    \                                             |0\n    [ChangeCipherSpec]     \
    \                                          |0\n    Finished                  \
    \  -------->                            |1\n                                 \
    \                [ChangeCipherSpec]  |0\n                                <--------\
    \                  Finished  |1\n    ClientHello (w/ extensions) -------->   \
    \                         |1\n                                        ServerHello\
    \ (w/ extensions)  |1\n                                  SupplementalData (w/\
    \ authz data)*  |1\n                                                       Certificate*\
    \  |1\n                                                 ServerKeyExchange*  |1\n\
    \                                                CertificateRequest*  |1\n   \
    \                             <--------           ServerHelloDone  |1\n    SupplementalData\
    \ (w/ authz data)*                                |1\n    Certificate*       \
    \                                              |1\n    ClientKeyExchange     \
    \                                           |1\n    CertificateVerify*       \
    \                                        |1\n    [ChangeCipherSpec]          \
    \                                     |1\n    Finished                    -------->\
    \                            |2\n                                            \
    \     [ChangeCipherSpec]  |1\n                                <--------      \
    \            Finished  |2\n    Application Data            <------->         \
    \ Application Data  |2\n         Figure 2.  Double Handshake To Protect Authorization\
    \ Data\n"
- title: 7.  Acknowledgement
  contents:
  - "7.  Acknowledgement\n   The authors thank Scott Cantor for his assistance with\
    \ the SAML\n   assertion portion of the document.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [ACTYPE]    Housley, R., \"The application/pkix-attr-cert\
    \ Media Type\n               for Attribute Certificates\", RFC 5877, May 2010.\n\
    \   [ATTRCERT]  Farrell, S., Housley, R., and S. Turner, \"An Internet\n     \
    \          Attribute Certificate Profile for Authorization\",\n              \
    \ RFC 5755, January 2010.\n   [HTTP]      Fielding, R., Gettys, J., Mogul, J.,\
    \ Frystyk, H.,\n               Masinter, L., Leach, P., and T. Berners-Lee, \"\
    Hypertext\n               Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n\
    \   [IANA]      Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n  \
    \             IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n     \
    \          May 2008.\n   [PKIX1]     Cooper, D., Santesson, S., Farrell, S., Boeyen,\
    \ S.,\n               Housley, R., and W. Polk, \"Internet X.509 Public Key\n\
    \               Infrastructure Certificate and Certificate Revocation\n      \
    \         List (CRL) Profile\", RFC 5280, May 2008.\n   [SAML1.1]   OASIS Security\
    \ Services Technical Committee, \"Security\n               Assertion Markup Language\
    \ (SAML) Version 1.1\n               Specification Set\", September 2003.\n  \
    \ [SAML2.0]   OASIS Security Services Technical Committee, \"Security\n      \
    \         Assertion Markup Language (SAML) Version 2.0\n               Specification\
    \ Set\", March 2005.\n   [SAMLBIND]  OASIS Security Services Technical Committee,\
    \ \"Bindings\n               for the OASIS Security Assertion Markup Language\
    \ (SAML)\n               V2.0\", March 2005.\n   [SHS]       National Institute\
    \ of Standards and Technology (NIST),\n               FIPS PUB 180-3, Secure Hash\
    \ Standard (SHS), October 2008.\n   [STDWORDS]  Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [TLS1.0]    Dierks, T. and C. Allen, \"The TLS Protocol Version\
    \ 1.0\",\n               RFC 2246, January 1999.\n   [TLS1.1]    Dierks, T. and\
    \ E. Rescorla, \"The Transport Layer Security\n               (TLS) Protocol Version\
    \ 1.1\", RFC 4346, April 2006.\n   [TLS1.2]    Dierks, T. and E. Rescorla, \"\
    The Transport Layer Security\n               (TLS) Protocol Version 1.2\", RFC\
    \ 5246, August 2008.\n   [TLSEXT2]   Blake-Wilson, S., Nystrom, M., Hopwood, D.,\n\
    \               Mikkelsen, J., and T. Wright, \"Transport Layer Security\n   \
    \            (TLS) Extensions\", RFC 4366, April 2006.\n   [TLSSUPP]   Santesson,\
    \ S., \"TLS Handshake Message for Supplemental\n               Data\", RFC 4680,\
    \ October 2006.\n   [UPGRADE]   Khare, R. and S. Lawrence, \"Upgrading to TLS\
    \ Within\n               HTTP/1.1\", RFC 2817, May 2000.\n   [UTF-8]     Yergeau,\
    \ F., \"UTF-8, a transformation format of\n               ISO 10646\", STD 63,\
    \ RFC 3629, November 2003.\n   [UTF-16]    Hoffman, P. and F. Yergeau, \"UTF-16,\
    \ an encoding of\n               ISO 10646\", RFC 2781, February 2000.\n   [XML1.0]\
    \    Bray, T., J. Paoli, C. M. Sperberg-McQueen, E. Maler, and\n             \
    \  F.  Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth\n              \
    \ Edition)\", http://www.w3.org/TR/xml/, November 2008.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [TLSEXT1]   Blake-Wilson, S., Nystrom, M., Hopwood,\
    \ D.,\n               Mikkelsen, J., and T. Wright, \"Transport Layer Security\n\
    \               (TLS) Extensions\", RFC 3546, June 2003.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mark Brown\n   RedPhone Security\n   1199 Falls View Court\n\
    \   Mendota Heights, MN  55118\n   USA\n   EMail: mark@redphonesecurity.com\n\
    \   Russell Housley\n   Vigil Security, LLC\n   918 Spring Knoll Drive\n   Herndon,\
    \ VA  20170\n   USA\n   EMail: housley@vigilsec.com\n"
