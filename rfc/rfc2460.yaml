- title: __initial_text__
  contents:
  - "                  Internet Protocol, Version 6 (IPv6)\n                     \
    \        Specification\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies version 6 of the Internet Protocol (IPv6),\n\
    \   also sometimes referred to as IP Next Generation or IPng.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction..................................................2\n\
    \   2. Terminology...................................................3\n   3.\
    \ IPv6 Header Format............................................4\n   4. IPv6\
    \ Extension Headers........................................6\n       4.1 Extension\
    \ Header Order...................................7\n       4.2 Options..................................................9\n\
    \       4.3 Hop-by-Hop Options Header...............................11\n     \
    \  4.4 Routing Header..........................................12\n       4.5\
    \ Fragment Header.........................................18\n       4.6 Destination\
    \ Options Header..............................23\n       4.7 No Next Header..........................................24\n\
    \   5. Packet Size Issues...........................................24\n   6.\
    \ Flow Labels..................................................25\n   7. Traffic\
    \ Classes..............................................25\n   8. Upper-Layer Protocol\
    \ Issues..................................27\n       8.1 Upper-Layer Checksums...................................27\n\
    \       8.2 Maximum Packet Lifetime.................................28\n     \
    \  8.3 Maximum Upper-Layer Payload Size........................28\n       8.4\
    \ Responding to Packets Carrying Routing Headers..........29\n   Appendix A. Semantics\
    \ and Usage of the Flow Label Field.........30\n   Appendix B. Formatting Guidelines\
    \ for Options...................32\n   Security Considerations.........................................35\n\
    \   Acknowledgments.................................................35\n   Authors'\
    \ Addresses..............................................35\n   References......................................................35\n\
    \   Changes Since RFC-1883..........................................36\n   Full\
    \ Copyright Statement........................................39\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IP version 6 (IPv6) is a new version of the Internet Protocol,\n\
    \   designed as the successor to IP version 4 (IPv4) [RFC-791].  The\n   changes\
    \ from IPv4 to IPv6 fall primarily into the following\n   categories:\n      o\
    \  Expanded Addressing Capabilities\n         IPv6 increases the IP address size\
    \ from 32 bits to 128 bits, to\n         support more levels of addressing hierarchy,\
    \ a much greater\n         number of addressable nodes, and simpler auto-configuration\
    \ of\n         addresses.  The scalability of multicast routing is improved by\n\
    \         adding a \"scope\" field to multicast addresses.  And a new type\n \
    \        of address called an \"anycast address\" is defined, used to send\n \
    \        a packet to any one of a group of nodes.\n      o  Header Format Simplification\n\
    \         Some IPv4 header fields have been dropped or made optional, to\n   \
    \      reduce the common-case processing cost of packet handling and\n       \
    \  to limit the bandwidth cost of the IPv6 header.\n      o  Improved Support\
    \ for Extensions and Options\n         Changes in the way IP header options are\
    \ encoded allows for\n         more efficient forwarding, less stringent limits\
    \ on the length\n         of options, and greater flexibility for introducing\
    \ new options\n         in the future.\n      o  Flow Labeling Capability\n  \
    \       A new capability is added to enable the labeling of packets\n        \
    \ belonging to particular traffic \"flows\" for which the sender\n         requests\
    \ special handling, such as non-default quality of\n         service or \"real-time\"\
    \ service.\n      o  Authentication and Privacy Capabilities\n         Extensions\
    \ to support authentication, data integrity, and\n         (optional) data confidentiality\
    \ are specified for IPv6.\n   This document specifies the basic IPv6 header and\
    \ the initially-\n   defined IPv6 extension headers and options.  It also discusses\
    \ packet\n   size issues, the semantics of flow labels and traffic classes, and\n\
    \   the effects of IPv6 on upper-layer protocols.  The format and\n   semantics\
    \ of IPv6 addresses are specified separately in [ADDRARCH].\n   The IPv6 version\
    \ of ICMP, which all IPv6 implementations are required\n   to include, is specified\
    \ in [ICMPv6].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   node        - a device that implements IPv6.\n   router \
    \     - a node that forwards IPv6 packets not explicitly\n                 addressed\
    \ to itself.  [See Note below].\n   host        - any node that is not a router.\
    \  [See Note below].\n   upper layer - a protocol layer immediately above IPv6.\
    \  Examples are\n                 transport protocols such as TCP and UDP, control\n\
    \                 protocols such as ICMP, routing protocols such as OSPF,\n  \
    \               and internet or lower-layer protocols being \"tunneled\"\n   \
    \              over (i.e., encapsulated in) IPv6 such as IPX,\n              \
    \   AppleTalk, or IPv6 itself.\n   link        - a communication facility or medium\
    \ over which nodes can\n                 communicate at the link layer, i.e.,\
    \ the layer\n                 immediately below IPv6.  Examples are Ethernets\
    \ (simple\n                 or bridged); PPP links; X.25, Frame Relay, or ATM\n\
    \                 networks; and internet (or higher) layer \"tunnels\",\n    \
    \             such as tunnels over IPv4 or IPv6 itself.\n   neighbors   - nodes\
    \ attached to the same link.\n   interface   - a node's attachment to a link.\n\
    \   address     - an IPv6-layer identifier for an interface or a set of\n    \
    \             interfaces.\n   packet      - an IPv6 header plus payload.\n   link\
    \ MTU    - the maximum transmission unit, i.e., maximum packet\n             \
    \    size in octets, that can be conveyed over a link.\n   path MTU    - the minimum\
    \ link MTU of all the links in a path between\n                 a source node\
    \ and a destination node.\n   Note: it is possible, though unusual, for a device\
    \ with multiple\n   interfaces to be configured to forward non-self-destined packets\n\
    \   arriving from some set (fewer than all) of its interfaces, and to\n   discard\
    \ non-self-destined packets arriving from its other interfaces.\n   Such a device\
    \ must obey the protocol requirements for routers when\n   receiving packets from,\
    \ and interacting with neighbors over, the\n   former (forwarding) interfaces.\
    \  It must obey the protocol\n   requirements for hosts when receiving packets\
    \ from, and interacting\n   with neighbors over, the latter (non-forwarding) interfaces.\n"
- title: 3.  IPv6 Header Format
  contents:
  - "3.  IPv6 Header Format\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Version| Traffic Class |           Flow Label                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Payload Length        |  Next Header  |   Hop Limit   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \           Source Address                        +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Destination Address                      +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version              4-bit Internet Protocol version number = 6.\n   Traffic\
    \ Class        8-bit traffic class field.  See section 7.\n   Flow Label     \
    \      20-bit flow label.  See section 6.\n   Payload Length       16-bit unsigned\
    \ integer.  Length of the IPv6\n                        payload, i.e., the rest\
    \ of the packet following\n                        this IPv6 header, in octets.\
    \  (Note that any\n                        extension headers [section 4] present\
    \ are\n                        considered part of the payload, i.e., included\n\
    \                        in the length count.)\n   Next Header          8-bit\
    \ selector.  Identifies the type of header\n                        immediately\
    \ following the IPv6 header.  Uses the\n                        same values as\
    \ the IPv4 Protocol field [RFC-1700\n                        et seq.].\n   Hop\
    \ Limit            8-bit unsigned integer.  Decremented by 1 by\n            \
    \            each node that forwards the packet. The packet\n                \
    \        is discarded if Hop Limit is decremented to\n                       \
    \ zero.\n   Source Address       128-bit address of the originator of the packet.\n\
    \                        See [ADDRARCH].\n   Destination Address  128-bit address\
    \ of the intended recipient of the\n                        packet (possibly not\
    \ the ultimate recipient, if\n                        a Routing header is present).\
    \  See [ADDRARCH]\n                        and section 4.4.\n"
- title: 4.  IPv6 Extension Headers
  contents:
  - "4.  IPv6 Extension Headers\n   In IPv6, optional internet-layer information is\
    \ encoded in separate\n   headers that may be placed between the IPv6 header and\
    \ the upper-\n   layer header in a packet.  There are a small number of such extension\n\
    \   headers, each identified by a distinct Next Header value.  As\n   illustrated\
    \ in these examples, an IPv6 packet may carry zero, one, or\n   more extension\
    \ headers, each identified by the Next Header field of\n   the preceding header:\n\
    \   +---------------+------------------------\n   |  IPv6 header  | TCP header\
    \ + data\n   |               |\n   | Next Header = |\n   |      TCP      |\n \
    \  +---------------+------------------------\n   +---------------+----------------+------------------------\n\
    \   |  IPv6 header  | Routing header | TCP header + data\n   |               |\
    \                |\n   | Next Header = |  Next Header = |\n   |    Routing   \
    \ |      TCP       |\n   +---------------+----------------+------------------------\n\
    \   +---------------+----------------+-----------------+-----------------\n  \
    \ |  IPv6 header  | Routing header | Fragment header | fragment of TCP\n   | \
    \              |                |                 |  header + data\n   | Next\
    \ Header = |  Next Header = |  Next Header =  |\n   |    Routing    |    Fragment\
    \    |       TCP       |\n   +---------------+----------------+-----------------+-----------------\n\
    \   With one exception, extension headers are not examined or processed\n   by\
    \ any node along a packet's delivery path, until the packet reaches\n   the node\
    \ (or each of the set of nodes, in the case of multicast)\n   identified in the\
    \ Destination Address field of the IPv6 header.\n   There, normal demultiplexing\
    \ on the Next Header field of the IPv6\n   header invokes the module to process\
    \ the first extension header, or\n   the upper-layer header if no extension header\
    \ is present.  The\n   contents and semantics of each extension header determine\
    \ whether or\n   not to proceed to the next header.  Therefore, extension headers\
    \ must\n   be processed strictly in the order they appear in the packet; a\n \
    \  receiver must not, for example, scan through a packet looking for a\n   particular\
    \ kind of extension header and process that header prior to\n   processing all\
    \ preceding ones.\n   The exception referred to in the preceding paragraph is\
    \ the Hop-by-\n   Hop Options header, which carries information that must be examined\n\
    \   and processed by every node along a packet's delivery path, including\n  \
    \ the source and destination nodes.  The Hop-by-Hop Options header,\n   when present,\
    \ must immediately follow the IPv6 header.  Its presence\n   is indicated by the\
    \ value zero in the Next Header field of the IPv6\n   header.\n   If, as a result\
    \ of processing a header, a node is required to proceed\n   to the next header\
    \ but the Next Header value in the current header is\n   unrecognized by the node,\
    \ it should discard the packet and send an\n   ICMP Parameter Problem message\
    \ to the source of the packet, with an\n   ICMP Code value of 1 (\"unrecognized\
    \ Next Header type encountered\")\n   and the ICMP Pointer field containing the\
    \ offset of the unrecognized\n   value within the original packet.  The same action\
    \ should be taken if\n   a node encounters a Next Header value of zero in any\
    \ header other\n   than an IPv6 header.\n   Each extension header is an integer\
    \ multiple of 8 octets long, in\n   order to retain 8-octet alignment for subsequent\
    \ headers.  Multi-\n   octet fields within each extension header are aligned on\
    \ their\n   natural boundaries, i.e., fields of width n octets are placed at an\n\
    \   integer multiple of n octets from the start of the header, for n = 1,\n  \
    \ 2, 4, or 8.\n   A full implementation of IPv6 includes implementation of the\n\
    \   following extension headers:\n           Hop-by-Hop Options\n           Routing\
    \ (Type 0)\n           Fragment\n           Destination Options\n           Authentication\n\
    \           Encapsulating Security Payload\n   The first four are specified in\
    \ this document; the last two are\n   specified in [RFC-2402] and [RFC-2406],\
    \ respectively.\n"
- title: 4.1  Extension Header Order
  contents:
  - "4.1  Extension Header Order\n   When more than one extension header is used in\
    \ the same packet, it is\n   recommended that those headers appear in the following\
    \ order:\n           IPv6 header\n           Hop-by-Hop Options header\n     \
    \      Destination Options header (note 1)\n           Routing header\n      \
    \     Fragment header\n           Authentication header (note 2)\n           Encapsulating\
    \ Security Payload header (note 2)\n           Destination Options header (note\
    \ 3)\n           upper-layer header\n           note 1: for options to be processed\
    \ by the first destination\n                   that appears in the IPv6 Destination\
    \ Address field\n                   plus subsequent destinations listed in the\
    \ Routing\n                   header.\n           note 2: additional recommendations\
    \ regarding the relative\n                   order of the Authentication and Encapsulating\n\
    \                   Security Payload headers are given in [RFC-2406].\n      \
    \     note 3: for options to be processed only by the final\n                \
    \   destination of the packet.\n   Each extension header should occur at most\
    \ once, except for the\n   Destination Options header which should occur at most\
    \ twice (once\n   before a Routing header and once before the upper-layer header).\n\
    \   If the upper-layer header is another IPv6 header (in the case of IPv6\n  \
    \ being tunneled over or encapsulated in IPv6), it may be followed by\n   its\
    \ own extension headers, which are separately subject to the same\n   ordering\
    \ recommendations.\n   If and when other extension headers are defined, their\
    \ ordering\n   constraints relative to the above listed headers must be specified.\n\
    \   IPv6 nodes must accept and attempt to process extension headers in\n   any\
    \ order and occurring any number of times in the same packet,\n   except for the\
    \ Hop-by-Hop Options header which is restricted to\n   appear immediately after\
    \ an IPv6 header only.  Nonetheless, it is\n   strongly advised that sources of\
    \ IPv6 packets adhere to the above\n   recommended order until and unless subsequent\
    \ specifications revise\n   that recommendation.\n"
- title: 4.2  Options
  contents:
  - "4.2  Options\n   Two of the currently-defined extension headers -- the Hop-by-Hop\n\
    \   Options header and the Destination Options header -- carry a variable\n  \
    \ number of type-length-value (TLV) encoded \"options\", of the following\n  \
    \ format:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n      | \
    \ Option Type  |  Opt Data Len |  Option Data\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n      Option Type          8-bit identifier of the type of\
    \ option.\n      Opt Data Len         8-bit unsigned integer.  Length of the Option\n\
    \                           Data field of this option, in octets.\n      Option\
    \ Data          Variable-length field.  Option-Type-specific\n               \
    \            data.\n   The sequence of options within a header must be processed\
    \ strictly in\n   the order they appear in the header; a receiver must not, for\n\
    \   example, scan through the header looking for a particular kind of\n   option\
    \ and process that option prior to processing all preceding\n   ones.\n   The\
    \ Option Type identifiers are internally encoded such that their\n   highest-order\
    \ two bits specify the action that must be taken if the\n   processing IPv6 node\
    \ does not recognize the Option Type:\n      00 - skip over this option and continue\
    \ processing the header.\n      01 - discard the packet.\n      10 - discard the\
    \ packet and, regardless of whether or not the\n           packet's Destination\
    \ Address was a multicast address, send an\n           ICMP Parameter Problem,\
    \ Code 2, message to the packet's\n           Source Address, pointing to the\
    \ unrecognized Option Type.\n      11 - discard the packet and, only if the packet's\
    \ Destination\n           Address was not a multicast address, send an ICMP Parameter\n\
    \           Problem, Code 2, message to the packet's Source Address,\n       \
    \    pointing to the unrecognized Option Type.\n   The third-highest-order bit\
    \ of the Option Type specifies whether or\n   not the Option Data of that option\
    \ can change en-route to the\n   packet's final destination.  When an Authentication\
    \ header is present\n   in the packet, for any option whose data may change en-route,\
    \ its\n   entire Option Data field must be treated as zero-valued octets when\n\
    \   computing or verifying the packet's authenticating value.\n      0 - Option\
    \ Data does not change en-route\n      1 - Option Data may change en-route\n \
    \  The three high-order bits described above are to be treated as part\n   of\
    \ the Option Type, not independent of the Option Type.  That is, a\n   particular\
    \ option is identified by a full 8-bit Option Type, not just\n   the low-order\
    \ 5 bits of an Option Type.\n   The same Option Type numbering space is used for\
    \ both the Hop-by-Hop\n   Options header and the Destination Options header. \
    \ However, the\n   specification of a particular option may restrict its use to\
    \ only one\n   of those two headers.\n   Individual options may have specific\
    \ alignment requirements, to\n   ensure that multi-octet values within Option\
    \ Data fields fall on\n   natural boundaries.  The alignment requirement of an\
    \ option is\n   specified using the notation xn+y, meaning the Option Type must\n\
    \   appear at an integer multiple of x octets from the start of the\n   header,\
    \ plus y octets.  For example:\n      2n    means any 2-octet offset from the\
    \ start of the header.\n      8n+2  means any 8-octet offset from the start of\
    \ the header,\n            plus 2 octets.\n   There are two padding options which\
    \ are used when necessary to align\n   subsequent options and to pad out the containing\
    \ header to a multiple\n   of 8 octets in length.  These padding options must\
    \ be recognized by\n   all IPv6 implementations:\n   Pad1 option  (alignment requirement:\
    \ none)\n      +-+-+-+-+-+-+-+-+\n      |       0       |\n      +-+-+-+-+-+-+-+-+\n\
    \      NOTE! the format of the Pad1 option is a special case -- it does\n    \
    \        not have length and value fields.\n      The Pad1 option is used to insert\
    \ one octet of padding into the\n      Options area of a header.  If more than\
    \ one octet of padding is\n      required, the PadN option, described next, should\
    \ be used, rather\n      than multiple Pad1 options.\n   PadN option  (alignment\
    \ requirement: none)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n\
    \      |       1       |  Opt Data Len |  Option Data\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\
    \ - - - - - - - -\n      The PadN option is used to insert two or more octets\
    \ of padding\n      into the Options area of a header.  For N octets of padding,\
    \ the\n      Opt Data Len field contains the value N-2, and the Option Data\n\
    \      consists of N-2 zero-valued octets.\n   Appendix B contains formatting\
    \ guidelines for designing new options.\n"
- title: 4.3  Hop-by-Hop Options Header
  contents:
  - "4.3  Hop-by-Hop Options Header\n   The Hop-by-Hop Options header is used to carry\
    \ optional information\n   that must be examined by every node along a packet's\
    \ delivery path.\n   The Hop-by-Hop Options header is identified by a Next Header\
    \ value of\n   0 in the IPv6 header, and has the following format:\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Next Header  |  Hdr Ext Len  |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    |                                     \
    \                          |\n    .                                          \
    \                     .\n    .                            Options            \
    \                .\n    .                                                    \
    \           .\n    |                                                         \
    \      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the type of header\n    \
    \                    immediately following the Hop-by-Hop Options\n          \
    \              header.  Uses the same values as the IPv4\n                   \
    \     Protocol field [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned\
    \ integer.  Length of the Hop-by-\n                        Hop Options header\
    \ in 8-octet units, not\n                        including the first 8 octets.\n\
    \   Options              Variable-length field, of length such that the\n    \
    \                    complete Hop-by-Hop Options header is an integer\n      \
    \                  multiple of 8 octets long.  Contains one or more\n        \
    \                TLV-encoded options, as described in section\n              \
    \          4.2.\n   The only hop-by-hop options defined in this document are the\
    \ Pad1 and\n   PadN options specified in section 4.2.\n"
- title: 4.4  Routing Header
  contents:
  - "4.4  Routing Header\n   The Routing header is used by an IPv6 source to list\
    \ one or more\n   intermediate nodes to be \"visited\" on the way to a packet's\n\
    \   destination.  This function is very similar to IPv4's Loose Source\n   and\
    \ Record Route option.  The Routing header is identified by a Next\n   Header\
    \ value of 43 in the immediately preceding header, and has the\n   following format:\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    .\
    \                                                               .\n    .     \
    \                  type-specific data                      .\n    .          \
    \                                                     .\n    |               \
    \                                                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the type of header\n    \
    \                    immediately following the Routing header.  Uses\n       \
    \                 the same values as the IPv4 Protocol field\n               \
    \         [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned integer.\
    \  Length of the Routing\n                        header in 8-octet units, not\
    \ including the first\n                        8 octets.\n   Routing Type    \
    \     8-bit identifier of a particular Routing header\n                      \
    \  variant.\n   Segments Left        8-bit unsigned integer.  Number of route\n\
    \                        segments remaining, i.e., number of explicitly\n    \
    \                    listed intermediate nodes still to be visited\n         \
    \               before reaching the final destination.\n   type-specific data\
    \   Variable-length field, of format determined by\n                        the\
    \ Routing Type, and of length such that the\n                        complete\
    \ Routing header is an integer multiple\n                        of 8 octets long.\n\
    \   If, while processing a received packet, a node encounters a Routing\n   header\
    \ with an unrecognized Routing Type value, the required behavior\n   of the node\
    \ depends on the value of the Segments Left field, as\n   follows:\n      If Segments\
    \ Left is zero, the node must ignore the Routing header\n      and proceed to\
    \ process the next header in the packet, whose type\n      is identified by the\
    \ Next Header field in the Routing header.\n      If Segments Left is non-zero,\
    \ the node must discard the packet and\n      send an ICMP Parameter Problem,\
    \ Code 0, message to the packet's\n      Source Address, pointing to the unrecognized\
    \ Routing Type.\n   If, after processing a Routing header of a received packet,\
    \ an\n   intermediate node determines that the packet is to be forwarded onto\n\
    \   a link whose link MTU is less than the size of the packet, the node\n   must\
    \ discard the packet and send an ICMP Packet Too Big message to\n   the packet's\
    \ Source Address.\n   The Type 0 Routing header has the following format:\n  \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |  Next\
    \ Header  |  Hdr Ext Len  | Routing Type=0| Segments Left |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                            Reserved                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                                                               +\n    |     \
    \                                                          |\n    +          \
    \                 Address[1]                          +\n    |               \
    \                                                |\n    +                    \
    \                                           +\n    |                         \
    \                                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                                                               +\n    |     \
    \                                                          |\n    +          \
    \                 Address[2]                          +\n    |               \
    \                                                |\n    +                    \
    \                                           +\n    |                         \
    \                                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    .                               .                               .\n    .\
    \                               .                               .\n    .     \
    \                          .                               .\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \                                                               +\n    |     \
    \                                                          |\n    +          \
    \                 Address[n]                          +\n    |               \
    \                                                |\n    +                    \
    \                                           +\n    |                         \
    \                                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the type of header\n    \
    \                    immediately following the Routing header.  Uses\n       \
    \                 the same values as the IPv4 Protocol field\n               \
    \         [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned integer.\
    \  Length of the Routing\n                        header in 8-octet units, not\
    \ including the first\n                        8 octets.  For the Type 0 Routing\
    \ header, Hdr\n                        Ext Len is equal to two times the number\
    \ of\n                        addresses in the header.\n   Routing Type      \
    \   0.\n   Segments Left        8-bit unsigned integer.  Number of route\n   \
    \                     segments remaining, i.e., number of explicitly\n       \
    \                 listed intermediate nodes still to be visited\n            \
    \            before reaching the final destination.\n   Reserved             32-bit\
    \ reserved field.  Initialized to zero for\n                        transmission;\
    \ ignored on reception.\n   Address[1..n]        Vector of 128-bit addresses,\
    \ numbered 1 to n.\n   Multicast addresses must not appear in a Routing header\
    \ of Type 0, or\n   in the IPv6 Destination Address field of a packet carrying\
    \ a Routing\n   header of Type 0.\n   A Routing header is not examined or processed\
    \ until it reaches the\n   node identified in the Destination Address field of\
    \ the IPv6 header.\n   In that node, dispatching on the Next Header field of the\
    \ immediately\n   preceding header causes the Routing header module to be invoked,\n\
    \   which, in the case of Routing Type 0, performs the following\n   algorithm:\n\
    \   if Segments Left = 0 {\n      proceed to process the next header in the packet,\
    \ whose type is\n      identified by the Next Header field in the Routing header\n\
    \   }\n   else if Hdr Ext Len is odd {\n         send an ICMP Parameter Problem,\
    \ Code 0, message to the Source\n         Address, pointing to the Hdr Ext Len\
    \ field, and discard the\n         packet\n   }\n   else {\n      compute n, the\
    \ number of addresses in the Routing header, by\n      dividing Hdr Ext Len by\
    \ 2\n      if Segments Left is greater than n {\n         send an ICMP Parameter\
    \ Problem, Code 0, message to the Source\n         Address, pointing to the Segments\
    \ Left field, and discard the\n         packet\n      }\n      else {\n      \
    \   decrement Segments Left by 1;\n         compute i, the index of the next address\
    \ to be visited in\n         the address vector, by subtracting Segments Left\
    \ from n\n         if Address [i] or the IPv6 Destination Address is multicast\
    \ {\n            discard the packet\n         }\n         else {\n           \
    \ swap the IPv6 Destination Address and Address[i]\n            if the IPv6 Hop\
    \ Limit is less than or equal to 1 {\n               send an ICMP Time Exceeded\
    \ -- Hop Limit Exceeded in\n               Transit message to the Source Address\
    \ and discard the\n               packet\n            }\n            else {\n\
    \               decrement the Hop Limit by 1\n               resubmit the packet\
    \ to the IPv6 module for transmission\n               to the new destination\n\
    \            }\n         }\n      }\n   }\n   As an example of the effects of\
    \ the above algorithm, consider the\n   case of a source node S sending a packet\
    \ to destination node D, using\n   a Routing header to cause the packet to be\
    \ routed via intermediate\n   nodes I1, I2, and I3.  The values of the relevant\
    \ IPv6 header and\n   Routing header fields on each segment of the delivery path\
    \ would be\n   as follows:\n   As the packet travels from S to I1:\n        Source\
    \ Address = S                  Hdr Ext Len = 6\n        Destination Address =\
    \ I1            Segments Left = 3\n                                          \
    \  Address[1] = I2\n                                            Address[2] = I3\n\
    \                                            Address[3] = D\n   As the packet\
    \ travels from I1 to I2:\n        Source Address = S                  Hdr Ext\
    \ Len = 6\n        Destination Address = I2            Segments Left = 2\n   \
    \                                         Address[1] = I1\n                  \
    \                          Address[2] = I3\n                                 \
    \           Address[3] = D\n   As the packet travels from I2 to I3:\n        Source\
    \ Address = S                  Hdr Ext Len = 6\n        Destination Address =\
    \ I3            Segments Left = 1\n                                          \
    \  Address[1] = I1\n                                            Address[2] = I2\n\
    \                                            Address[3] = D\n   As the packet\
    \ travels from I3 to D:\n        Source Address = S                  Hdr Ext Len\
    \ = 6\n        Destination Address = D             Segments Left = 0\n       \
    \                                     Address[1] = I1\n                      \
    \                      Address[2] = I2\n                                     \
    \       Address[3] = I3\n"
- title: 4.5  Fragment Header
  contents:
  - "4.5  Fragment Header\n   The Fragment header is used by an IPv6 source to send\
    \ a packet larger\n   than would fit in the path MTU to its destination.  (Note:\
    \ unlike\n   IPv4, fragmentation in IPv6 is performed only by source nodes, not\
    \ by\n   routers along a packet's delivery path -- see section 5.)  The\n   Fragment\
    \ header is identified by a Next Header value of 44 in the\n   immediately preceding\
    \ header, and has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Identification                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the initial header\n    \
    \                    type of the Fragmentable Part of the original\n         \
    \               packet (defined below).  Uses the same values as\n           \
    \             the IPv4 Protocol field [RFC-1700 et seq.].\n   Reserved       \
    \      8-bit reserved field.  Initialized to zero for\n                      \
    \  transmission; ignored on reception.\n   Fragment Offset      13-bit unsigned\
    \ integer.  The offset, in 8-octet\n                        units, of the data\
    \ following this header,\n                        relative to the start of the\
    \ Fragmentable Part\n                        of the original packet.\n   Res \
    \                 2-bit reserved field.  Initialized to zero for\n           \
    \             transmission; ignored on reception.\n   M flag               1 =\
    \ more fragments; 0 = last fragment.\n   Identification       32 bits.  See description\
    \ below.\n   In order to send a packet that is too large to fit in the MTU of\
    \ the\n   path to its destination, a source node may divide the packet into\n\
    \   fragments and send each fragment as a separate packet, to be\n   reassembled\
    \ at the receiver.\n   For every packet that is to be fragmented, the source node\
    \ generates\n   an Identification value. The Identification must be different\
    \ than\n   that of any other fragmented packet sent recently* with the same\n\
    \   Source Address and Destination Address.  If a Routing header is\n   present,\
    \ the Destination Address of concern is that of the final\n   destination.\n \
    \     * \"recently\" means within the maximum likely lifetime of a packet,\n \
    \       including transit time from source to destination and time spent\n   \
    \     awaiting reassembly with other fragments of the same packet.\n        However,\
    \ it is not required that a source node know the maximum\n        packet lifetime.\
    \  Rather, it is assumed that the requirement can\n        be met by maintaining\
    \ the Identification value as a simple, 32-\n        bit, \"wrap-around\" counter,\
    \ incremented each time a packet must\n        be fragmented.  It is an implementation\
    \ choice whether to\n        maintain a single counter for the node or multiple\
    \ counters,\n        e.g., one for each of the node's possible source addresses,\
    \ or\n        one for each active (source address, destination address)\n    \
    \    combination.\n   The initial, large, unfragmented packet is referred to as\
    \ the\n   \"original packet\", and it is considered to consist of two parts, as\n\
    \   illustrated:\n   original packet:\n   +------------------+----------------------//-----------------------+\n\
    \   |  Unfragmentable  |                 Fragmentable                  |\n   |\
    \       Part       |                     Part                      |\n   +------------------+----------------------//-----------------------+\n\
    \      The Unfragmentable Part consists of the IPv6 header plus any\n      extension\
    \ headers that must be processed by nodes en route to the\n      destination,\
    \ that is, all headers up to and including the Routing\n      header if present,\
    \ else the Hop-by-Hop Options header if present,\n      else no extension headers.\n\
    \      The Fragmentable Part consists of the rest of the packet, that is,\n  \
    \    any extension headers that need be processed only by the final\n      destination\
    \ node(s), plus the upper-layer header and data.\n   The Fragmentable Part of\
    \ the original packet is divided into\n   fragments, each, except possibly the\
    \ last (\"rightmost\") one, being an\n   integer multiple of 8 octets long.  The\
    \ fragments are transmitted in\n   separate \"fragment packets\" as illustrated:\n\
    \   original packet:\n   +------------------+--------------+--------------+--//--+----------+\n\
    \   |  Unfragmentable  |    first     |    second    |      |   last   |\n   |\
    \       Part       |   fragment   |   fragment   | .... | fragment |\n   +------------------+--------------+--------------+--//--+----------+\n\
    \   fragment packets:\n   +------------------+--------+--------------+\n   | \
    \ Unfragmentable  |Fragment|    first     |\n   |       Part       | Header |\
    \   fragment   |\n   +------------------+--------+--------------+\n   +------------------+--------+--------------+\n\
    \   |  Unfragmentable  |Fragment|    second    |\n   |       Part       | Header\
    \ |   fragment   |\n   +------------------+--------+--------------+\n        \
    \                 o\n                         o\n                         o\n\
    \   +------------------+--------+----------+\n   |  Unfragmentable  |Fragment|\
    \   last   |\n   |       Part       | Header | fragment |\n   +------------------+--------+----------+\n\
    \   Each fragment packet is composed of:\n      (1) The Unfragmentable Part of\
    \ the original packet, with the\n          Payload Length of the original IPv6\
    \ header changed to contain\n          the length of this fragment packet only\
    \ (excluding the length\n          of the IPv6 header itself), and the Next Header\
    \ field of the\n          last header of the Unfragmentable Part changed to 44.\n\
    \      (2) A Fragment header containing:\n               The Next Header value\
    \ that identifies the first header of\n               the Fragmentable Part of\
    \ the original packet.\n               A Fragment Offset containing the offset\
    \ of the fragment,\n               in 8-octet units, relative to the start of\
    \ the\n               Fragmentable Part of the original packet.  The Fragment\n\
    \               Offset of the first (\"leftmost\") fragment is 0.\n          \
    \     An M flag value of 0 if the fragment is the last\n               (\"rightmost\"\
    ) one, else an M flag value of 1.\n               The Identification value generated\
    \ for the original\n               packet.\n      (3) The fragment itself.\n \
    \  The lengths of the fragments must be chosen such that the resulting\n   fragment\
    \ packets fit within the MTU of the path to the packets'\n   destination(s).\n\
    \   At the destination, fragment packets are reassembled into their\n   original,\
    \ unfragmented form, as illustrated:\n   reassembled original packet:\n   +------------------+----------------------//------------------------+\n\
    \   |  Unfragmentable  |                 Fragmentable                   |\n  \
    \ |       Part       |                     Part                       |\n   +------------------+----------------------//------------------------+\n\
    \   The following rules govern reassembly:\n      An original packet is reassembled\
    \ only from fragment packets that\n      have the same Source Address, Destination\
    \ Address, and Fragment\n      Identification.\n      The Unfragmentable Part\
    \ of the reassembled packet consists of all\n      headers up to, but not including,\
    \ the Fragment header of the first\n      fragment packet (that is, the packet\
    \ whose Fragment Offset is\n      zero), with the following two changes:\n   \
    \      The Next Header field of the last header of the Unfragmentable\n      \
    \   Part is obtained from the Next Header field of the first\n         fragment's\
    \ Fragment header.\n         The Payload Length of the reassembled packet is computed\
    \ from\n         the length of the Unfragmentable Part and the length and offset\n\
    \         of the last fragment.  For example, a formula for computing the\n  \
    \       Payload Length of the reassembled original packet is:\n           PL.orig\
    \ = PL.first - FL.first - 8 + (8 * FO.last) + FL.last\n           where\n    \
    \       PL.orig  = Payload Length field of reassembled packet.\n           PL.first\
    \ = Payload Length field of first fragment packet.\n           FL.first = length\
    \ of fragment following Fragment header of\n                      first fragment\
    \ packet.\n           FO.last  = Fragment Offset field of Fragment header of\n\
    \                      last fragment packet.\n           FL.last  = length of\
    \ fragment following Fragment header of\n                      last fragment packet.\n\
    \      The Fragmentable Part of the reassembled packet is constructed\n      from\
    \ the fragments following the Fragment headers in each of the\n      fragment\
    \ packets.  The length of each fragment is computed by\n      subtracting from\
    \ the packet's Payload Length the length of the\n      headers between the IPv6\
    \ header and fragment itself; its relative\n      position in Fragmentable Part\
    \ is computed from its Fragment Offset\n      value.\n      The Fragment header\
    \ is not present in the final, reassembled\n      packet.\n   The following error\
    \ conditions may arise when reassembling fragmented\n   packets:\n      If insufficient\
    \ fragments are received to complete reassembly of a\n      packet within 60 seconds\
    \ of the reception of the first-arriving\n      fragment of that packet, reassembly\
    \ of that packet must be\n      abandoned and all the fragments that have been\
    \ received for that\n      packet must be discarded.  If the first fragment (i.e.,\
    \ the one\n      with a Fragment Offset of zero) has been received, an ICMP Time\n\
    \      Exceeded -- Fragment Reassembly Time Exceeded message should be\n     \
    \ sent to the source of that fragment.\n      If the length of a fragment, as\
    \ derived from the fragment packet's\n      Payload Length field, is not a multiple\
    \ of 8 octets and the M flag\n      of that fragment is 1, then that fragment\
    \ must be discarded and an\n      ICMP Parameter Problem, Code 0, message should\
    \ be sent to the\n      source of the fragment, pointing to the Payload Length\
    \ field of\n      the fragment packet.\n      If the length and offset of a fragment\
    \ are such that the Payload\n      Length of the packet reassembled from that\
    \ fragment would exceed\n      65,535 octets, then that fragment must be discarded\
    \ and an ICMP\n      Parameter Problem, Code 0, message should be sent to the\
    \ source of\n      the fragment, pointing to the Fragment Offset field of the\n\
    \      fragment packet.\n   The following conditions are not expected to occur,\
    \ but are not\n   considered errors if they do:\n      The number and content\
    \ of the headers preceding the Fragment\n      header of different fragments of\
    \ the same original packet may\n      differ.  Whatever headers are present, preceding\
    \ the Fragment\n      header in each fragment packet, are processed when the packets\n\
    \      arrive, prior to queueing the fragments for reassembly.  Only\n      those\
    \ headers in the Offset zero fragment packet are retained in\n      the reassembled\
    \ packet.\n      The Next Header values in the Fragment headers of different\n\
    \      fragments of the same original packet may differ.  Only the value\n   \
    \   from the Offset zero fragment packet is used for reassembly.\n"
- title: 4.6  Destination Options Header
  contents:
  - "4.6  Destination Options Header\n   The Destination Options header is used to\
    \ carry optional information\n   that need be examined only by a packet's destination\
    \ node(s).  The\n   Destination Options header is identified by a Next Header\
    \ value of 60\n   in the immediately preceding header, and has the following format:\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \  Next Header  |  Hdr Ext Len  |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    |                                     \
    \                          |\n    .                                          \
    \                     .\n    .                            Options            \
    \                .\n    .                                                    \
    \           .\n    |                                                         \
    \      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next Header          8-bit selector.  Identifies the type of header\n    \
    \                    immediately following the Destination Options\n         \
    \               header.  Uses the same values as the IPv4\n                  \
    \      Protocol field [RFC-1700 et seq.].\n   Hdr Ext Len          8-bit unsigned\
    \ integer.  Length of the\n                        Destination Options header\
    \ in 8-octet units, not\n                        including the first 8 octets.\n\
    \   Options              Variable-length field, of length such that the\n    \
    \                    complete Destination Options header is an\n             \
    \           integer multiple of 8 octets long.  Contains one\n               \
    \         or  more TLV-encoded options, as described in\n                    \
    \    section 4.2.\n   The only destination options defined in this document are\
    \ the Pad1\n   and PadN options specified in section 4.2.\n   Note that there\
    \ are two possible ways to encode optional destination\n   information in an IPv6\
    \ packet: either as an option in the Destination\n   Options header, or as a separate\
    \ extension header.  The Fragment\n   header and the Authentication header are\
    \ examples of the latter\n   approach.  Which approach can be used depends on\
    \ what action is\n   desired of a destination node that does not understand the\
    \ optional\n   information:\n      o  If the desired action is for the destination\
    \ node to discard\n         the packet and, only if the packet's Destination Address\
    \ is not\n         a multicast address, send an ICMP Unrecognized Type message\
    \ to\n         the packet's Source Address, then the information may be\n    \
    \     encoded either as a separate header or as an option in the\n         Destination\
    \ Options header whose Option Type has the value 11\n         in its highest-order\
    \ two bits.  The choice may depend on such\n         factors as which takes fewer\
    \ octets, or which yields better\n         alignment or more efficient parsing.\n\
    \      o  If any other action is desired, the information must be encoded\n  \
    \       as an option in the Destination Options header whose Option\n        \
    \ Type has the value 00, 01, or 10 in its highest-order two bits,\n         specifying\
    \ the desired action (see section 4.2).\n"
- title: 4.7 No Next Header
  contents:
  - "4.7 No Next Header\n   The value 59 in the Next Header field of an IPv6 header\
    \ or any\n   extension header indicates that there is nothing following that\n\
    \   header.  If the Payload Length field of the IPv6 header indicates the\n  \
    \ presence of octets past the end of a header whose Next Header field\n   contains\
    \ 59, those octets must be ignored, and passed on unchanged if\n   the packet\
    \ is forwarded.\n"
- title: 5. Packet Size Issues
  contents:
  - "5. Packet Size Issues\n   IPv6 requires that every link in the internet have\
    \ an MTU of 1280\n   octets or greater.  On any link that cannot convey a 1280-octet\n\
    \   packet in one piece, link-specific fragmentation and reassembly must\n   be\
    \ provided at a layer below IPv6.\n   Links that have a configurable MTU (for\
    \ example, PPP links [RFC-\n   1661]) must be configured to have an MTU of at\
    \ least 1280 octets; it\n   is recommended that they be configured with an MTU\
    \ of 1500 octets or\n   greater, to accommodate possible encapsulations (i.e.,\
    \ tunneling)\n   without incurring IPv6-layer fragmentation.\n   From each link\
    \ to which a node is directly attached, the node must be\n   able to accept packets\
    \ as large as that link's MTU.\n   It is strongly recommended that IPv6 nodes\
    \ implement Path MTU\n   Discovery [RFC-1981], in order to discover and take advantage\
    \ of path\n   MTUs greater than 1280 octets.  However, a minimal IPv6\n   implementation\
    \ (e.g., in a boot ROM) may simply restrict itself to\n   sending packets no larger\
    \ than 1280 octets, and omit implementation\n   of Path MTU Discovery.\n   In\
    \ order to send a packet larger than a path's MTU, a node may use\n   the IPv6\
    \ Fragment header to fragment the packet at the source and\n   have it reassembled\
    \ at the destination(s).  However, the use of such\n   fragmentation is discouraged\
    \ in any application that is able to\n   adjust its packets to fit the measured\
    \ path MTU (i.e., down to 1280\n   octets).\n   A node must be able to accept\
    \ a fragmented packet that, after\n   reassembly, is as large as 1500 octets.\
    \  A node is permitted to\n   accept fragmented packets that reassemble to more\
    \ than 1500 octets.\n   An upper-layer protocol or application that depends on\
    \ IPv6\n   fragmentation to send packets larger than the MTU of a path should\n\
    \   not send packets larger than 1500 octets unless it has assurance that\n  \
    \ the destination is capable of reassembling packets of that larger\n   size.\n\
    \   In response to an IPv6 packet that is sent to an IPv4 destination\n   (i.e.,\
    \ a packet that undergoes translation from IPv6 to IPv4), the\n   originating\
    \ IPv6 node may receive an ICMP Packet Too Big message\n   reporting a Next-Hop\
    \ MTU less than 1280.  In that case, the IPv6 node\n   is not required to reduce\
    \ the size of subsequent packets to less than\n   1280, but must include a Fragment\
    \ header in those packets so that the\n   IPv6-to-IPv4 translating router can\
    \ obtain a suitable Identification\n   value to use in resulting IPv4 fragments.\
    \  Note that this means the\n   payload may have to be reduced to 1232 octets\
    \ (1280 minus 40 for the\n   IPv6 header and 8 for the Fragment header), and smaller\
    \ still if\n   additional extension headers are used.\n"
- title: 6.  Flow Labels
  contents:
  - "6.  Flow Labels\n   The 20-bit Flow Label field in the IPv6 header may be used\
    \ by a\n   source to label sequences of packets for which it requests special\n\
    \   handling by the IPv6 routers, such as non-default quality of service\n   or\
    \ \"real-time\" service.  This aspect of IPv6 is, at the time of\n   writing,\
    \ still experimental and subject to change as the requirements\n   for flow support\
    \ in the Internet become clearer.  Hosts or routers\n   that do not support the\
    \ functions of the Flow Label field are\n   required to set the field to zero\
    \ when originating a packet, pass the\n   field on unchanged when forwarding a\
    \ packet, and ignore the field\n   when receiving a packet.\n   Appendix A describes\
    \ the current intended semantics and usage of the\n   Flow Label field.\n"
- title: 7.  Traffic Classes
  contents:
  - "7.  Traffic Classes\n   The 8-bit Traffic Class field in the IPv6 header is available\
    \ for use\n   by originating nodes and/or forwarding routers to identify and\n\
    \   distinguish between different classes or priorities of IPv6 packets.\n   At\
    \ the point in time at which this specification is being written,\n   there are\
    \ a number of experiments underway in the use of the IPv4\n   Type of Service\
    \ and/or Precedence bits to provide various forms of\n   \"differentiated service\"\
    \ for IP packets, other than through the use\n   of explicit flow set-up.  The\
    \ Traffic Class field in the IPv6 header\n   is intended to allow similar functionality\
    \ to be supported in IPv6.\n   It is hoped that those experiments will eventually\
    \ lead to agreement\n   on what sorts of traffic classifications are most useful\
    \ for IP\n   packets.  Detailed definitions of the syntax and semantics of all\
    \ or\n   some of the IPv6 Traffic Class bits, whether experimental or intended\n\
    \   for eventual standardization, are to be provided in separate\n   documents.\n\
    \   The following general requirements apply to the Traffic Class field:\n   \
    \   o  The service interface to the IPv6 service within a node must\n        \
    \ provide a means for an upper-layer protocol to supply the value\n         of\
    \ the Traffic Class bits in packets originated by that upper-\n         layer\
    \ protocol.  The default value must be zero for all 8 bits.\n      o  Nodes that\
    \ support a specific (experimental or eventual\n         standard) use of some\
    \ or all of the Traffic Class bits are\n         permitted to change the value\
    \ of those bits in packets that\n         they originate, forward, or receive,\
    \ as required for that\n         specific use.  Nodes should ignore and leave\
    \ unchanged any bits\n         of the Traffic Class field for which they do not\
    \ support a\n         specific use.\n      o  An upper-layer protocol must not\
    \ assume that the value of the\n         Traffic Class bits in a received packet\
    \ are the same as the\n         value sent by the packet's source.\n"
- title: 8. Upper-Layer Protocol Issues
  contents:
  - '8. Upper-Layer Protocol Issues

    '
- title: 8.1 Upper-Layer Checksums
  contents:
  - "8.1 Upper-Layer Checksums\n   Any transport or other upper-layer protocol that\
    \ includes the\n   addresses from the IP header in its checksum computation must\
    \ be\n   modified for use over IPv6, to include the 128-bit IPv6 addresses\n \
    \  instead of 32-bit IPv4 addresses.  In particular, the following\n   illustration\
    \ shows the TCP and UDP \"pseudo-header\" for IPv6:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \           Source Address                        +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Destination Address                      +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Upper-Layer Packet Length                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      zero                     |  Next Header  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      o  If the IPv6 packet contains a Routing header, the Destination\n    \
    \     Address used in the pseudo-header is that of the final\n         destination.\
    \  At the originating node, that address will be in\n         the last element\
    \ of the Routing header; at the recipient(s),\n         that address will be in\
    \ the Destination Address field of the\n         IPv6 header.\n      o  The Next\
    \ Header value in the pseudo-header identifies the\n         upper-layer protocol\
    \ (e.g., 6 for TCP, or 17 for UDP).  It will\n         differ from the Next Header\
    \ value in the IPv6 header if there\n         are extension headers between the\
    \ IPv6 header and the upper-\n         layer header.\n      o  The Upper-Layer\
    \ Packet Length in the pseudo-header is the\n         length of the upper-layer\
    \ header and data (e.g., TCP header\n         plus TCP data).  Some upper-layer\
    \ protocols carry their own\n         length information (e.g., the Length field\
    \ in the UDP header);\n         for such protocols, that is the length used in\
    \ the pseudo-\n         header.  Other protocols (such as TCP) do not carry their\
    \ own\n         length information, in which case the length used in the\n   \
    \      pseudo-header is the Payload Length from the IPv6 header, minus\n     \
    \    the length of any extension headers present between the IPv6\n         header\
    \ and the upper-layer header.\n      o  Unlike IPv4, when UDP packets are originated\
    \ by an IPv6 node,\n         the UDP checksum is not optional.  That is, whenever\n\
    \         originating a UDP packet, an IPv6 node must compute a UDP\n        \
    \ checksum over the packet and the pseudo-header, and, if that\n         computation\
    \ yields a result of zero, it must be changed to hex\n         FFFF for placement\
    \ in the UDP header.  IPv6 receivers must\n         discard UDP packets containing\
    \ a zero checksum, and should log\n         the error.\n   The IPv6 version of\
    \ ICMP [ICMPv6] includes the above pseudo-header in\n   its checksum computation;\
    \ this is a change from the IPv4 version of\n   ICMP, which does not include a\
    \ pseudo-header in its checksum.  The\n   reason for the change is to protect\
    \ ICMP from misdelivery or\n   corruption of those fields of the IPv6 header on\
    \ which it depends,\n   which, unlike IPv4, are not covered by an internet-layer\
    \ checksum.\n   The Next Header field in the pseudo-header for ICMP contains the\n\
    \   value 58, which identifies the IPv6 version of ICMP.\n"
- title: 8.2 Maximum Packet Lifetime
  contents:
  - "8.2 Maximum Packet Lifetime\n   Unlike IPv4, IPv6 nodes are not required to enforce\
    \ maximum packet\n   lifetime.  That is the reason the IPv4 \"Time to Live\" field\
    \ was\n   renamed \"Hop Limit\" in IPv6.  In practice, very few, if any, IPv4\n\
    \   implementations conform to the requirement that they limit packet\n   lifetime,\
    \ so this is not a change in practice.  Any upper-layer\n   protocol that relies\
    \ on the internet layer (whether IPv4 or IPv6) to\n   limit packet lifetime ought\
    \ to be upgraded to provide its own\n   mechanisms for detecting and discarding\
    \ obsolete packets.\n"
- title: 8.3 Maximum Upper-Layer Payload Size
  contents:
  - "8.3 Maximum Upper-Layer Payload Size\n   When computing the maximum payload size\
    \ available for upper-layer\n   data, an upper-layer protocol must take into account\
    \ the larger size\n   of the IPv6 header relative to the IPv4 header.  For example,\
    \ in\n   IPv4, TCP's MSS option is computed as the maximum packet size (a\n  \
    \ default value or a value learned through Path MTU Discovery) minus 40\n   octets\
    \ (20 octets for the minimum-length IPv4 header and 20 octets\n   for the minimum-length\
    \ TCP header).  When using TCP over IPv6, the\n   MSS must be computed as the\
    \ maximum packet size minus 60 octets,\n   because the minimum-length IPv6 header\
    \ (i.e., an IPv6 header with no\n   extension headers) is 20 octets longer than\
    \ a minimum-length IPv4\n   header.\n"
- title: 8.4 Responding to Packets Carrying Routing Headers
  contents:
  - "8.4 Responding to Packets Carrying Routing Headers\n   When an upper-layer protocol\
    \ sends one or more packets in response to\n   a received packet that included\
    \ a Routing header, the response\n   packet(s) must not include a Routing header\
    \ that was automatically\n   derived by \"reversing\" the received Routing header\
    \ UNLESS the\n   integrity and authenticity of the received Source Address and\
    \ Routing\n   header have been verified (e.g., via the use of an Authentication\n\
    \   header in the received packet).  In other words, only the following\n   kinds\
    \ of packets are permitted in response to a received packet\n   bearing a Routing\
    \ header:\n      o  Response packets that do not carry Routing headers.\n    \
    \  o  Response packets that carry Routing headers that were NOT\n         derived\
    \ by reversing the Routing header of the received packet\n         (for example,\
    \ a Routing header supplied by local\n         configuration).\n      o  Response\
    \ packets that carry Routing headers that were derived\n         by reversing\
    \ the Routing header of the received packet IF AND\n         ONLY IF the integrity\
    \ and authenticity of the Source Address\n         and Routing header from the\
    \ received packet have been verified\n         by the responder.\n"
- title: Appendix A. Semantics and Usage of the Flow Label Field
  contents:
  - "Appendix A. Semantics and Usage of the Flow Label Field\n   A flow is a sequence\
    \ of packets sent from a particular source to a\n   particular (unicast or multicast)\
    \ destination for which the source\n   desires special handling by the intervening\
    \ routers.  The nature of\n   that special handling might be conveyed to the routers\
    \ by a control\n   protocol, such as a resource reservation protocol, or by information\n\
    \   within the flow's packets themselves, e.g., in a hop-by-hop option.\n   The\
    \ details of such control protocols or options are beyond the scope\n   of this\
    \ document.\n   There may be multiple active flows from a source to a destination,\
    \ as\n   well as traffic that is not associated with any flow.  A flow is\n  \
    \ uniquely identified by the combination of a source address and a\n   non-zero\
    \ flow label.  Packets that do not belong to a flow carry a\n   flow label of\
    \ zero.\n   A flow label is assigned to a flow by the flow's source node.  New\n\
    \   flow labels must be chosen (pseudo-)randomly and uniformly from the\n   range\
    \ 1 to FFFFF hex.  The purpose of the random allocation is to\n   make any set\
    \ of bits within the Flow Label field suitable for use as\n   a hash key by routers,\
    \ for looking up the state associated with the\n   flow.\n   All packets belonging\
    \ to the same flow must be sent with the same\n   source address, destination\
    \ address, and flow label.  If any of those\n   packets includes a Hop-by-Hop\
    \ Options header, then they all must be\n   originated with the same Hop-by-Hop\
    \ Options header contents\n   (excluding the Next Header field of the Hop-by-Hop\
    \ Options header).\n   If any of those packets includes a Routing header, then\
    \ they all must\n   be originated with the same contents in all extension headers\
    \ up to\n   and including the Routing header (excluding the Next Header field\
    \ in\n   the Routing header).  The routers or destinations are permitted, but\n\
    \   not required, to verify that these conditions are satisfied.  If a\n   violation\
    \ is detected, it should be reported to the source by an ICMP\n   Parameter Problem\
    \ message, Code 0, pointing to the high-order octet\n   of the Flow Label field\
    \ (i.e., offset 1 within the IPv6 packet).\n   The maximum lifetime of any flow-handling\
    \ state established along a\n   flow's path must be specified as part of the description\
    \ of the\n   state-establishment mechanism, e.g., the resource reservation\n \
    \  protocol or the flow-setup hop-by-hop option.  A source must not re-\n   use\
    \ a flow label for a new flow within the maximum lifetime of any\n   flow-handling\
    \ state that might have been established for the prior\n   use of that flow label.\n\
    \   When a node stops and restarts (e.g., as a result of a \"crash\"), it\n  \
    \ must be careful not to use a flow label that it might have used for\n   an earlier\
    \ flow whose lifetime may not have expired yet.  This may be\n   accomplished\
    \ by recording flow label usage on stable storage so that\n   it can be remembered\
    \ across crashes, or by refraining from using any\n   flow labels until the maximum\
    \ lifetime of any possible previously\n   established flows has expired.  If the\
    \ minimum time for rebooting the\n   node is known, that time can be deducted\
    \ from the necessary waiting\n   period before starting to allocate flow labels.\n\
    \   There is no requirement that all, or even most, packets belong to\n   flows,\
    \ i.e., carry non-zero flow labels.  This observation is placed\n   here to remind\
    \ protocol designers and implementors not to assume\n   otherwise.  For example,\
    \ it would be unwise to design a router whose\n   performance would be adequate\
    \ only if most packets belonged to flows,\n   or to design a header compression\
    \ scheme that only worked on packets\n   that belonged to flows.\n"
- title: Appendix B. Formatting Guidelines for Options
  contents:
  - "Appendix B. Formatting Guidelines for Options\n   This appendix gives some advice\
    \ on how to lay out the fields when\n   designing new options to be used in the\
    \ Hop-by-Hop Options header or\n   the Destination Options header, as described\
    \ in section 4.2.  These\n   guidelines are based on the following assumptions:\n\
    \      o  One desirable feature is that any multi-octet fields within the\n  \
    \       Option Data area of an option be aligned on their natural\n         boundaries,\
    \ i.e., fields of width n octets should be placed at\n         an integer multiple\
    \ of n octets from the start of the Hop-by-\n         Hop or Destination Options\
    \ header, for n = 1, 2, 4, or 8.\n      o  Another desirable feature is that the\
    \ Hop-by-Hop or Destination\n         Options header take up as little space as\
    \ possible, subject to\n         the requirement that the header be an integer\
    \ multiple of 8\n         octets long.\n      o  It may be assumed that, when\
    \ either of the option-bearing\n         headers are present, they carry a very\
    \ small number of options,\n         usually only one.\n   These assumptions suggest\
    \ the following approach to laying out the\n   fields of an option: order the\
    \ fields from smallest to largest, with\n   no interior padding, then derive the\
    \ alignment requirement for the\n   entire option based on the alignment requirement\
    \ of the largest field\n   (up to a maximum alignment of 8 octets).  This approach\
    \ is\n   illustrated in the following examples:\n   Example 1\n   If an option\
    \ X required two data fields, one of length 8 octets and\n   one of length 4 octets,\
    \ it would be laid out as follows:\n                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                   | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Its alignment requirement is 8n+2, to ensure that the 8-octet field\n   starts\
    \ at a multiple-of-8 offset from the start of the enclosing\n   header.  A complete\
    \ Hop-by-Hop or Destination Options header\n   containing this one option would\
    \ look as follows:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Example 2\n   If an option Y required three data fields, one of length 4 octets,\n\
    \   one of length 2 octets, and one of length 1 octet, it would be laid\n   out\
    \ as follows:\n                                                   +-+-+-+-+-+-+-+-+\n\
    \                                                   | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Its alignment requirement is 4n+3, to ensure that the 4-octet field\n   starts\
    \ at a multiple-of-4 offset from the start of the enclosing\n   header.  A complete\
    \ Hop-by-Hop or Destination Options header\n   containing this one option would\
    \ look as follows:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Example 3\n   A Hop-by-Hop or Destination Options header containing both options\
    \ X\n   and Y from Examples 1 and 2 would have one of the two following\n   formats,\
    \ depending on which option appeared first:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Next\
    \ Header  | Hdr Ext Len=3 | Pad1 Option=0 | Option Type=Y |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Opt Data Len=7 | 1-octet field |         2-octet field         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | PadN Option=1 |Opt Data Len=4 |       0       |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0       |       0       | Option Type=X |Opt Data Len=12|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         4-octet field                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       8-octet field                         +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   The security features of IPv6 are described in the\
    \ Security\n   Architecture for the Internet Protocol [RFC-2401].\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors gratefully acknowledge the many helpful suggestions\
    \ of\n   the members of the IPng working group, the End-to-End Protocols\n   research\
    \ group, and the Internet Community At Large.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Stephen E. Deering\n   Cisco Systems, Inc.\n   170 West\
    \ Tasman Drive\n   San Jose, CA 95134-1706\n   USA\n   Phone: +1 408 527 8213\n\
    \   Fax:   +1 408 527 8254\n   EMail: deering@cisco.com\n   Robert M. Hinden\n\
    \   Nokia\n   232 Java Drive\n   Sunnyvale, CA 94089\n   USA\n   Phone: +1 408\
    \ 990-2004\n   Fax:   +1 408 743-5677\n   EMail: hinden@iprg.nokia.com\n"
- title: References
  contents:
  - "References\n   [RFC-2401]   Kent, S. and R. Atkinson, \"Security Architecture\
    \ for the\n                Internet Protocol\", RFC 2401, November 1998.\n   [RFC-2402]\
    \   Kent, S. and R. Atkinson, \"IP Authentication Header\",\n                RFC\
    \ 2402, November 1998.\n   [RFC-2406]   Kent, S. and R. Atkinson, \"IP Encapsulating\
    \ Security\n                Protocol (ESP)\", RFC 2406, November 1998.\n   [ICMPv6]\
    \     Conta, A. and S. Deering, \"ICMP for the Internet\n                Protocol\
    \ Version 6 (IPv6)\", RFC 2463, December 1998.\n   [ADDRARCH]   Hinden, R. and\
    \ S. Deering, \"IP Version 6 Addressing\n                Architecture\", RFC 2373,\
    \ July 1998.\n   [RFC-1981]   McCann, J., Mogul, J. and S. Deering, \"Path MTU\n\
    \                Discovery for IP version 6\", RFC 1981, August 1996.\n   [RFC-791]\
    \    Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n                September\
    \ 1981.\n   [RFC-1700]   Reynolds, J. and J. Postel, \"Assigned Numbers\", STD\
    \ 2,\n                RFC 1700, October 1994.  See also:\n                http://www.iana.org/numbers.html\n\
    \   [RFC-1661]   Simpson, W., \"The Point-to-Point Protocol (PPP)\", STD\n   \
    \             51, RFC 1661, July 1994.\n"
- title: CHANGES SINCE RFC-1883
  contents:
  - "CHANGES SINCE RFC-1883\n   This memo has the following changes from RFC-1883.\
    \  Numbers identify\n   the Internet-Draft version in which the change was made.\n\
    \    02) Removed all references to jumbograms and the Jumbo Payload\n        option\
    \ (moved to a separate document).\n    02) Moved most of Flow Label description\
    \ from section 6 to (new)\n        Appendix A.\n    02) In Flow Label description,\
    \ now in Appendix A, corrected maximum\n        Flow Label value from FFFFFF to\
    \ FFFFF (i.e., one less \"F\") due\n        to reduction of size of Flow Label\
    \ field from 24 bits to 20\n        bits.\n    02) Renumbered (relettered?) the\
    \ previous Appendix A to be Appendix\n        B.\n    02) Changed the wording\
    \ of the Security Considerations section to\n        avoid dependency loop between\
    \ this spec and the IPsec specs.\n    02) Updated R. Hinden's email address and\
    \ company affiliation.\n        --------------------------------------------------------\n\
    \    01) In section 3, changed field name \"Class\" to \"Traffic Class\" and\n\
    \        increased its size from 4 to 8 bits.  Decreased size of Flow\n      \
    \  Label field from 24 to 20 bits to compensate for increase in\n        Traffic\
    \ Class field.\n    01) In section 4.1, restored the order of the Authentication\
    \ Header\n        and the ESP header, which were mistakenly swapped in the 00\n\
    \        version of this memo.\n    01) In section 4.4, deleted the Strict/Loose\
    \ Bit Map field and the\n        strict routing functionality from the Type 0\
    \ Routing header, and\n        removed the restriction on number of addresses\
    \ that may be\n        carried in the Type 0 Routing header (was limited to 23\n\
    \        addresses, because of the size of the strict/loose bit map).\n    01)\
    \ In section 5, changed the minimum IPv6 MTU from 576 to 1280\n        octets,\
    \ and added a recommendation that links with configurable\n        MTU (e.g.,\
    \ PPP links) be configured to have an MTU of at least\n        1500 octets.\n\
    \    01) In section 5, deleted the requirement that a node must not send\n   \
    \     fragmented packets that reassemble to more than 1500 octets\n        without\
    \ knowledge of the destination reassembly buffer size, and\n        replaced it\
    \ with a recommendation that upper-layer protocols or\n        applications should\
    \ not do that.\n    01) Replaced reference to the IPv4 Path MTU Discovery spec\
    \ (RFC-\n        1191) with reference to the IPv6 Path MTU Discovery spec (RFC-\n\
    \        1981), and deleted the Notes at the end of section 5 regarding\n    \
    \    Path MTU Discovery, since those details are now covered by RFC-\n       \
    \ 1981.\n    01) In section 6, deleted specification of \"opportunistic\" flow\n\
    \        set-up, and removed all references to the 6-second maximum\n        lifetime\
    \ for opportunistically established flow state.\n    01) In section 7, deleted\
    \ the provisional description of the\n        internal structure and semantics\
    \ of the Traffic Class field, and\n        specified that such descriptions be\
    \ provided in separate\n        documents.\n        --------------------------------------------------------\n\
    \    00) In section 4, corrected the Code value to indicate \"unrecognized\n \
    \       Next Header type encountered\" in an ICMP Parameter Problem\n        message\
    \ (changed from 2 to 1).\n    00) In the description of the Payload Length field\
    \ in section 3, and\n        of the Jumbo Payload Length field in section 4.3,\
    \ made it\n        clearer that extension headers are included in the payload\n\
    \        length count.\n    00) In section 4.1, swapped the order of the Authentication\
    \ header\n        and the ESP header.  (NOTE: this was a mistake, and the change\n\
    \        was undone in version 01.)\n    00) In section 4.2, made it clearer that\
    \ options are identified by\n        the full 8-bit Option Type, not by the low-order\
    \ 5 bits of an\n        Option Type.  Also specified that the same Option Type\
    \ numbering\n        space is used for both Hop-by-Hop Options and Destination\n\
    \        Options headers.\n    00) In section 4.4, added a sentence requiring\
    \ that nodes processing\n        a Routing header must send an ICMP Packet Too\
    \ Big message in\n        response to a packet that is too big to fit in the next\
    \ hop link\n        (rather than, say, performing fragmentation).\n    00) Changed\
    \ the name of the IPv6 Priority field to \"Class\", and\n        replaced the\
    \ previous description of Priority in section 7 with\n        a description of\
    \ the Class field.  Also, excluded this field\n        from the set of fields\
    \ that must remain the same for all packets\n        in the same flow, as specified\
    \ in section 6.\n    00) In the pseudo-header in section 8.1, changed the name\
    \ of the\n        \"Payload Length\" field to \"Upper-Layer Packet Length\". \
    \ Also\n        clarified that, in the case of protocols that carry their own\n\
    \        length info (like non-jumbogram UDP), it is the upper-layer-\n      \
    \  derived length, not the IP-layer-derived length, that is used in\n        the\
    \ pseudo-header.\n    00) Added section 8.4, specifying that upper-layer protocols,\
    \ when\n        responding to a received packet that carried a Routing header,\n\
    \        must not include the reverse of the Routing header in the\n        response\
    \ packet(s) unless the received Routing header was\n        authenticated.\n \
    \   00) Fixed some typos and grammatical errors.\n    00) Authors' contact info\
    \ updated.\n        --------------------------------------------------------\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
