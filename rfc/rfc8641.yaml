- title: __initial_text__
  contents:
  - '        Subscription to YANG Notifications for Datastore Updates

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a mechanism that allows subscriber\n   applications\
    \ to request a continuous and customized stream of updates\n   from a YANG datastore.\
    \  Providing such visibility into updates\n   enables new capabilities based on\
    \ the remote mirroring and monitoring\n   of configuration and operational state.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8641.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Definitions .....................................................4\n  \
    \ 3. Solution Overview ...............................................6\n    \
    \  3.1. Subscription Model .........................................6\n      3.2.\
    \ Negotiation of Subscription Policies .......................7\n      3.3. On-Change\
    \ Considerations ...................................8\n      3.4. Reliability\
    \ Considerations .................................9\n      3.5. Data Encodings\
    \ ............................................10\n      3.6. Defining the Selection\
    \ with a Datastore ...................11\n      3.7. Streaming Updates .........................................12\n\
    \      3.8. Subscription Management ...................................15\n  \
    \    3.9. Receiver Authorization ....................................16\n    \
    \  3.10. On-Change Notifiable Datastore Nodes .....................18\n      3.11.\
    \ Other Considerations .....................................18\n   4. A YANG Data\
    \ Model for Management of Datastore Push\n      Subscriptions ..................................................20\n\
    \      4.1. Overview ..................................................20\n  \
    \    4.2. Subscription Configuration ................................27\n    \
    \  4.3. YANG Notifications ........................................28\n      4.4.\
    \ YANG RPCs .................................................29\n   5. YANG Module\
    \ for YANG-Push ......................................34\n   6. IANA Considerations\
    \ ............................................51\n   7. Security Considerations\
    \ ........................................51\n   8. References .....................................................53\n\
    \      8.1. Normative References ......................................53\n  \
    \    8.2. Informative References ....................................55\n   Appendix\
    \ A. Subscription Errors ...................................56\n     A.1. RPC\
    \ Failures ...............................................56\n     A.2. Failure\
    \ Notifications ......................................57\n   Acknowledgments ...................................................58\n\
    \   Contributors ......................................................58\n  \
    \ Authors' Addresses ................................................58\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Traditional approaches for providing visibility into managed\
    \ entities\n   from a remote system have been built on polling.  With polling,\
    \ data\n   is periodically requested and retrieved by a client from a server to\n\
    \   stay up to date.  However, there are issues associated with polling-\n   based\
    \ management:\n   o  Polling incurs significant latency.  This latency prohibits\
    \ many\n      types of applications.\n   o  Polling cycles may be missed, and\
    \ requests may be delayed or get\n      lost -- often when the network is under\
    \ stress and the need for\n      the data is the greatest.\n   o  Polling requests\
    \ may undergo slight fluctuations, resulting in\n      intervals of different\
    \ lengths.  The resulting data is difficult\n      to calibrate and compare.\n\
    \   o  For applications that monitor for changes, many remote polling\n      cycles\
    \ place unwanted and ultimately wasteful load on the network,\n      devices,\
    \ and applications, particularly when changes occur only\n      infrequently.\n\
    \   A more effective alternative to polling is for an application to\n   receive\
    \ automatic and continuous updates from a targeted subset of a\n   datastore.\
    \  Accordingly, there is a need for a service that\n   (1) allows applications\
    \ to subscribe to updates from a datastore and\n   (2) enables the server (also\
    \ referred to as the \"publisher\") to push\n   and, in effect, stream those updates.\
    \  The requirements for such a\n   service have been documented in [RFC7923].\n\
    \   This document defines a corresponding solution that is built on\n   top of\
    \ [RFC8639].  Supplementing that work are YANG data model\n   augmentations, extended\
    \ RPCs, and new datastore-specific update\n   notifications.  Transport options\
    \ provided in [RFC8639] will work\n   seamlessly with this solution.\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n   This document uses the terminology defined in\
    \ [RFC7950], [RFC8341],\n   [RFC8342], and [RFC8639].  In addition, this document\
    \ defines the\n   following terms:\n   o  Datastore node: A node in the instantiated\
    \ YANG data tree\n      associated with a datastore.  In this document, datastore\
    \ nodes\n      are often also simply referred to as \"objects\".\n   o  Datastore\
    \ node update: A data item containing the current value of\n      a datastore\
    \ node at the time the datastore node update was\n      created, as well as the\
    \ path to the datastore node.\n   o  Datastore subscription: A subscription to\
    \ a stream of datastore\n      node updates.\n   o  Datastore subtree: A datastore\
    \ node and all its descendant\n      datastore nodes.\n   o  On-change subscription:\
    \ A datastore subscription with updates that\n      are triggered when changes\
    \ in subscribed datastore nodes are\n      detected.\n   o  Periodic subscription:\
    \ A datastore subscription with updates that\n      are triggered periodically\
    \ according to some time interval.\n   o  Selection filter: Evaluation and/or\
    \ selection criteria that may be\n      applied against a targeted set of objects.\n\
    \   o  Update record: A representation of one or more datastore node\n      updates.\
    \  In addition, an update record may contain which type of\n      update led to\
    \ the datastore node update (e.g., whether the\n      datastore node was added,\
    \ changed, or deleted).  Also included in\n      the update record may be other\
    \ metadata, such as a subscription ID\n      of the subscription for which the\
    \ update record was generated.  In\n      this document, update records are often\
    \ also simply referred to as\n      \"updates\".\n   o  Update trigger: A mechanism\
    \ that determines when an update record\n      needs to be generated.\n   o  YANG-Push:\
    \ The subscription and push mechanism for datastore\n      updates that is specified\
    \ in this document.\n"
- title: 3.  Solution Overview
  contents:
  - "3.  Solution Overview\n   This document specifies a solution that provides a\
    \ subscription\n   service for updates from a datastore.  This solution supports\
    \ dynamic\n   as well as configured subscriptions to updates of datastore nodes.\n\
    \   Subscriptions specify when notification messages (also referred to as\n  \
    \ \"push updates\") should be sent and what data to include in update\n   records.\
    \  Datastore node updates are subsequently pushed from the\n   publisher to the\
    \ receiver per the terms of the subscription.\n"
- title: 3.1.  Subscription Model
  contents:
  - "3.1.  Subscription Model\n   YANG-Push subscriptions are defined using a YANG\
    \ data model.  This\n   model enhances the subscription model defined in [RFC8639]\
    \ with\n   capabilities that allow subscribers to subscribe to datastore node\n\
    \   updates -- specifically, to specify the update triggers defining when\n  \
    \ to generate update records as well as what to include in an update\n   record.\
    \  Key enhancements include:\n   o  The specification of selection filters that\
    \ identify targeted YANG\n      datastore nodes and/or datastore subtrees for\
    \ which updates are to\n      be pushed.\n   o  The specification of update policies\
    \ that contain conditions that\n      trigger the generation and pushing of new\
    \ update records.  There\n      are two types of subscriptions, distinguished\
    \ by how updates are\n      triggered: periodic and on-change.\n      *  For periodic\
    \ subscriptions, the update trigger is specified by\n         two parameters that\
    \ define when updates are to be pushed.\n         These parameters are (1) the\
    \ period interval with which to\n         report updates and (2) an \"anchor-time\"\
    , i.e., a reference\n         point in time that can be used to calculate at which\
    \ points in\n         time periodic updates need to be assembled and sent.\n \
    \     *  For on-change subscriptions, an update trigger occurs whenever\n    \
    \     a change in the subscribed information is detected.  The\n         following\
    \ additional parameters are included:\n         +  \"dampening-period\": In an\
    \ on-change subscription, detected\n            object changes should be sent\
    \ as quickly as possible.\n            However, it may be undesirable to send\
    \ a rapid series of\n            object changes.  Such behavior has the potential\
    \ to exhaust\n            resources in the publisher or receiver.  In order to\
    \ protect\n            against this type of scenario, a dampening period MAY be\n\
    \            used to specify the interval that has to pass before\n          \
    \  successive update records for the same subscription are\n            generated\
    \ for a receiver.  The dampening period collectively\n            applies to the\
    \ set of all datastore nodes selected by a\n            single subscription. \
    \ This means that when there is a change\n            to one or more subscribed\
    \ objects, an update record\n            containing those objects is created immediately\
    \ (when no\n            dampening period is in effect) or at the end of a dampening\n\
    \            period (when a dampening period is in fact in effect).  If\n    \
    \        multiple changes to a single object occur during a dampening\n      \
    \      period, only the value that is in effect at the time when\n           \
    \ the update record is created is included.  The dampening\n            period\
    \ goes into effect every time the assembly of an update\n            record is\
    \ completed.\n         +  \"change-type\": This parameter can be used to reduce\
    \ the\n            types of datastore changes for which updates are sent (e.g.,\n\
    \            you might only send an update when an object is created or\n    \
    \        deleted, but not when an object value changes).\n         +  \"sync-on-start\"\
    : This parameter defines whether or not a\n            complete \"push-update\"\
    \ (Section 3.7) of all subscribed data\n            will be sent at the beginning\
    \ of a subscription.  Such early\n            synchronization establishes the\
    \ frame of reference for\n            subsequent updates.\n   o  An encoding (using\
    \ anydata) for the contents of periodic and\n      on-change push updates.\n"
- title: 3.2.  Negotiation of Subscription Policies
  contents:
  - "3.2.  Negotiation of Subscription Policies\n   A dynamic subscription request\
    \ SHOULD be declined if a publisher\n   determines that it may be unable to provide\
    \ update records meeting\n   the terms of an \"establish-subscription\" or \"\
    modify-subscription\" RPC\n   request.  In this case, a subscriber may quickly\
    \ follow up with a new\n   RPC request using different parameters.\n   Random\
    \ guessing of different parameters by a subscriber is to be\n   discouraged. \
    \ Therefore, in order to minimize the number of\n   subscription iterations between\
    \ subscriber and publisher, a dynamic\n   subscription supports a simple negotiation\
    \ between subscribers and\n   publishers for subscription parameters.  This negotiation\
    \ is in the\n   form of supplemental information that should be inserted into\
    \ error\n   responses to a failed RPC request.  This returned error response\n\
    \   information, when considered, should increase the likelihood of\n   success\
    \ for subsequent RPC requests.  Such hints include suggested\n   periodic time\
    \ intervals, acceptable dampening periods, and size\n   estimates for the number\
    \ of objects that would be returned from a\n   proposed selection filter.  However,\
    \ there are no guarantees that\n   subsequent requests that consider these hints\
    \ will be accepted.\n"
- title: 3.3.  On-Change Considerations
  contents:
  - "3.3.  On-Change Considerations\n   On-change subscriptions allow receivers to\
    \ receive updates whenever\n   changes to targeted objects occur.  As such, on-change\
    \ subscriptions\n   are particularly effective for data that changes infrequently\
    \ but for\n   which applications need to be quickly notified, with minimal delay,\n\
    \   whenever a change does occur.\n   On-change subscriptions tend to be more\
    \ difficult to implement than\n   periodic subscriptions.  Accordingly, on-change\
    \ subscriptions may not\n   be supported by all implementations or for every object.\n\
    \   Whether or not to accept or reject on-change subscription requests\n   when\
    \ the scope of the subscription contains objects for which\n   on-change is not\
    \ supported is up to the publisher implementation.  A\n   publisher MAY accept\
    \ an on-change subscription even when the scope of\n   the subscription contains\
    \ objects for which on-change is not\n   supported.  In that case, updates are\
    \ sent only for those objects\n   within the scope of the subscription that do\
    \ support on-change\n   updates, whereas other objects are excluded from update\
    \ records, even\n   if their values change.  In order for a subscriber to determine\n\
    \   whether objects support on-change subscriptions, objects are marked\n   accordingly\
    \ on a publisher.  Accordingly, when subscribing, it is the\n   responsibility\
    \ of the subscriber to ensure that it is aware of which\n   objects support on-change\
    \ and which do not.  For more on how objects\n   are so marked, see Section 3.10.\n\
    \   Alternatively, a publisher MAY decide to simply reject an on-change\n   subscription\
    \ if the scope of the subscription contains objects for\n   which on-change is\
    \ not supported.  In the case of a configured\n   subscription, the publisher\
    \ MAY suspend the subscription.\n   To avoid flooding receivers with repeated\
    \ updates for subscriptions\n   containing fast-changing objects or objects with\
    \ oscillating values,\n   an on-change subscription allows for the definition\
    \ of a dampening\n   period.  Once an update record for a given object is generated,\
    \ no\n   other updates for this particular subscription will be created until\n\
    \   the end of the dampening period.  Values sent at the end of the\n   dampening\
    \ period are the values that are current at the end of the\n   dampening period\
    \ of all changed objects.  Changed objects include\n   those objects that were\
    \ deleted or newly created during that\n   dampening period.  If an object has\
    \ returned to its original value\n   (or even has been created and then deleted)\
    \ during the dampening\n   period, that value (and not the interim change) will\
    \ still be sent.\n   This will indicate that churn is occurring on that object.\n\
    \   On-change subscriptions can be refined to let users subscribe only to\n  \
    \ certain types of changes.  For example, a subscriber might only want\n   object\
    \ creations and deletions, but not modifications of object\n   values.\n   Putting\
    \ it all together, the conceptual process for creating an\n   update record as\
    \ part of an on-change subscription is as follows:\n   1.  Just before a change,\
    \ or at the start of a dampening period,\n       evaluate any filtering and any\
    \ access control rules to ensure\n       that a receiver is authorized to view\
    \ all subscribed datastore\n       nodes (filtering out any nodes for which this\
    \ is not the case).\n       The result is a set \"A\" of datastore nodes and subtrees.\n\
    \   2.  Just after a change, or at the end of a dampening period,\n       evaluate\
    \ any filtering and any (possibly new) access control\n       rules.  The result\
    \ is a set \"B\" of datastore nodes and subtrees.\n   3.  Construct an update\
    \ record, which takes the form of a YANG Patch\n       record [RFC8072] for going\
    \ from A to B.\n   4.  If there were any changes made between A and B that canceled\
    \ each\n       other out, insert into the YANG Patch record the last change\n\
    \       made, even if the new value is no different from the original\n      \
    \ value (since changes that were made in the interim were canceled\n       out).\
    \  If the changes involve creating a new datastore node and\n       then deleting\
    \ it, the YANG Patch record will indicate the\n       deletion of the datastore\
    \ node.  Similarly, if the changes\n       involve deleting a new datastore node\
    \ and then recreating it,\n       the YANG Patch record will indicate the creation\
    \ of the\n       datastore node.\n   5.  If the resulting YANG Patch record is\
    \ non-empty, send it to the\n       receiver.\n   Note: In cases where a subscriber\
    \ wants to have separate dampening\n   periods for different objects, the subscriber\
    \ has the option to\n   create multiple subscriptions with different selection\
    \ filters.\n"
- title: 3.4.  Reliability Considerations
  contents:
  - "3.4.  Reliability Considerations\n   A subscription to updates from a datastore\
    \ is intended to obviate the\n   need for polling.  However, in order to do so,\
    \ it is critical that\n   subscribers can rely on the subscription and have confidence\
    \ that\n   they will indeed receive the subscribed updates without having to\n\
    \   worry about updates being silently dropped.  In other words, a\n   subscription\
    \ constitutes a promise on the side of the publisher to\n   provide the receivers\
    \ with updates per the terms of the subscription.\n   Now, there are many reasons\
    \ why a publisher may at some point no\n   longer be able to fulfill the terms\
    \ of the subscription, even if the\n   subscription had been initiated in good\
    \ faith.  For example, the\n   volume of datastore nodes may be larger than anticipated,\
    \ the\n   interval may prove too short to send full updates in rapid\n   succession,\
    \ or an internal problem may prevent objects from being\n   collected.  For this\
    \ reason, the solution defined in this document\n   (1) mandates that a publisher\
    \ notify receivers immediately and\n   reliably whenever it encounters a situation\
    \ in which it is unable to\n   keep the terms of the subscription and (2) provides\
    \ the publisher\n   with the option to suspend the subscription in such a case.\
    \  This\n   includes indicating the fact that an update is incomplete as part\
    \ of\n   a \"push-update\" or \"push-change-update\" notification, as well as\n\
    \   emitting a \"subscription-suspended\" notification as applicable.  This\n\
    \   is described further in Section 3.11.1.\n   A publisher SHOULD reject a request\
    \ for a subscription if it is\n   unlikely that the publisher will be able to\
    \ fulfill the terms of that\n   subscription request.  In such cases, it is preferable\
    \ to have a\n   subscriber request a less resource-intensive subscription than\
    \ to\n   deal with frequently degraded behavior.\n   The solution builds on [RFC8639].\
    \  As defined therein, any loss of an\n   underlying transport connection will\
    \ be detected and result in\n   subscription termination (in the case of dynamic\
    \ subscriptions) or\n   suspension (in the case of configured subscriptions),\
    \ ensuring that\n   situations where the loss of update notifications would go\
    \ unnoticed\n   will not occur.\n"
- title: 3.5.  Data Encodings
  contents:
  - '3.5.  Data Encodings

    '
- title: 3.5.1.  Periodic Subscriptions
  contents:
  - "3.5.1.  Periodic Subscriptions\n   In a periodic subscription, the data included\
    \ as part of an update\n   record corresponds to data that could have been read\
    \ using a\n   retrieval operation.\n"
- title: 3.5.2.  On-Change Subscriptions
  contents:
  - "3.5.2.  On-Change Subscriptions\n   In an on-change subscription, update records\
    \ need to indicate not\n   only values of changed datastore nodes but also the\
    \ types of changes\n   that occurred since the last update.  Therefore, encoding\
    \ rules for\n   data in on-change updates will generally follow YANG Patch operations\n\
    \   as specified in [RFC8072].  The YANG Patch operations will describe\n   what\
    \ needs to be applied to the earlier state reported by the\n   preceding update\
    \ in order to result in the now-current state.  Note\n   that objects referred\
    \ to in an update are not limited to\n   configuration data but can include any\
    \ objects (including operational\n   data), whereas [RFC8072] patches apply only\
    \ to configuration data in\n   configuration datastores.\n   A publisher indicates\
    \ the type of change to a datastore node using\n   the different YANG Patch operations:\
    \ the \"create\" operation is used\n   for newly created objects (except entries\
    \ in a user-ordered list),\n   the \"delete\" operation is used for deleted objects\
    \ (including in\n   user-ordered lists), the \"replace\" operation is used when\
    \ only the\n   object value changes, the \"insert\" operation is used when a new\
    \ entry\n   is inserted in a list, and the \"move\" operation is used when an\n\
    \   existing entry in a user-ordered list is moved.\n   However, a patch must\
    \ be able to do more than just describe the delta\n   from the previous state\
    \ to the current state.  As per Section 3.3, it\n   must also be able to identify\
    \ whether transient changes have occurred\n   on an object during a dampening\
    \ period.  To support this, it is valid\n   to encode a YANG Patch operation so\
    \ that its application would result\n   in no change between the previous state\
    \ and the current state.  This\n   indicates that some churn has occurred on the\
    \ object.  An example of\n   this would be a patch that indicates a \"create\"\
    \ operation for a\n   datastore node where the receiver believes one already exists\
    \ or a\n   \"replace\" operation that replaces a previous value with the same\n\
    \   value.  Note that this means that the \"create\" and \"delete\" errors as\n\
    \   described in [RFC8072], Section 2.5 are not errors in the case of\n   YANG-Push\
    \ (i.e., they are considered valid operations for YANG-Push).\n"
- title: 3.6.  Defining the Selection with a Datastore
  contents:
  - "3.6.  Defining the Selection with a Datastore\n   A subscription must specify\
    \ both the selection filters and the\n   datastore against which these selection\
    \ filters will be applied.\n   This information is used to choose and subsequently\
    \ push data from\n   the publisher's datastore to the receivers.\n   Only a single\
    \ selection filter can be applied to a subscription at a\n   time.  An RPC request\
    \ proposing a new selection filter replaces any\n   existing filter.  The following\
    \ selection filter types are included\n   in the YANG-Push data model and may\
    \ be applied against a datastore:\n   o  subtree: A subtree selection filter identifies\
    \ one or more\n      datastore subtrees.  When specified, update records will\
    \ only come\n      from the datastore nodes of selected datastore subtree(s).\
    \  The\n      syntax and semantics correspond to those specified in [RFC6241],\n\
    \      Section 6.\n   o  xpath: An \"xpath\" selection filter is an XPath expression\
    \ that\n      returns a node set.  (XPath is a query language for selecting\n\
    \      nodes in an XML document; see [XPATH] for details.)  When\n      specified,\
    \ updates will only come from the selected datastore\n      nodes.\n   These filters\
    \ are intended to be used as selectors that define which\n   objects are within\
    \ the scope of a subscription.  A publisher MUST\n   support at least one type\
    \ of selection filter.\n   XPath itself provides powerful filtering constructs,\
    \ and care must be\n   used in filter definition.  Consider an XPath filter that\
    \ only passes\n   a datastore node when an interface is up.  It is up to the receiver\n\
    \   to understand the implications of the presence or absence of objects\n   in\
    \ each update.\n   When the set of selection-filtering criteria is applied for\
    \ a\n   periodic subscription, these criteria are applied whenever a periodic\n\
    \   update record is constructed, and only datastore nodes that pass the\n   filter\
    \ and to which a receiver has access are provided to that\n   receiver.  If the\
    \ same filtering criteria are applied to an on-change\n   subscription, only the\
    \ subset of those datastore nodes supporting\n   on-change is provided.  A datastore\
    \ node that doesn't support\n   on-change is never sent as part of an on-change\
    \ subscription's\n   \"push-update\" or \"push-change-update\" (Section 3.7).\n"
- title: 3.7.  Streaming Updates
  contents:
  - "3.7.  Streaming Updates\n   Contrary to traditional data retrieval requests,\
    \ datastore\n   subscription enables an unbounded series of update records to\
    \ be\n   streamed over time.  Two generic YANG notifications for update\n   records\
    \ have been defined for this scenario: \"push-update\" and\n   \"push-change-update\"\
    .\n   A \"push-update\" notification defines a complete, filtered update of\n\
    \   the datastore per the terms of a subscription.  This type of YANG\n   notification\
    \ is used for continuous updates of periodic\n   subscriptions.  A \"push-update\"\
    \ notification can also be used for the\n   on-change subscriptions in two cases.\
    \  First, it MUST be used as the\n   initial \"push-update\" if there is a need\
    \ to synchronize the receiver\n   at the start of a new subscription.  Second,\
    \ it MAY be sent if the\n   publisher later chooses to resync an on-change subscription.\
    \  The\n   \"push-update\" update record contains an instantiated datastore\n\
    \   subtree with all of the subscribed contents.  The content of the\n   update\
    \ record is equivalent to the contents that would be obtained\n   had the same\
    \ data been explicitly retrieved using a datastore\n   retrieval operation using\
    \ the same transport with the same filters\n   applied.\n   A \"push-change-update\"\
    \ notification is the most common type of update\n   for on-change subscriptions.\
    \  The update record in this case contains\n   the set of changes that datastore\
    \ nodes have undergone since the last\n   notification message.  In other words,\
    \ this indicates which datastore\n   nodes have been created, have been deleted,\
    \ or have had changes to\n   their values.  In cases where multiple changes have\
    \ occurred over the\n   course of a dampening period and the object has not been\
    \ deleted, the\n   object's most current value is reported.  (In other words,\
    \ for each\n   object, only one change is reported, not its entire history.  Doing\n\
    \   so would defeat the purpose of the dampening period.)\n   \"push-update\"\
    \ and \"push-change-update\" are encoded and placed in\n   notification messages\
    \ and are ultimately queued for egress over the\n   specified transport.\n   Figure\
    \ 1 provides an example of a notification message for a\n   subscription tracking\
    \ the operational status of a single Ethernet\n   interface (per [RFC8343]). \
    \ This notification message is encoded XML\n   [W3C.REC-xml-20081126] over the\
    \ Network Configuration Protocol\n   (NETCONF) as per [RFC8640].\n  <notification\
    \ xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n   <eventTime>2017-10-25T08:00:11.22Z</eventTime>\n\
    \   <push-update xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n     <id>1011</id>\n\
    \     <datastore-contents>\n        <interfaces xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\"\
    >\n         <interface>\n           <name>eth0</name>\n           <oper-status>up</oper-status>\n\
    \         </interface>\n       </interfaces>\n     </datastore-contents>\n   </push-update>\n\
    \  </notification>\n                          Figure 1: Push Example\n   Figure\
    \ 2 provides an example of an on-change notification message for\n   the same\
    \ subscription.\n  <notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\"\
    >\n   <eventTime>2017-10-25T08:22:33.44Z</eventTime>\n   <push-change-update\n\
    \        xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n     <id>89</id>\n\
    \     <datastore-changes>\n       <yang-patch>\n         <patch-id>0</patch-id>\n\
    \         <edit>\n           <edit-id>edit1</edit-id>\n           <operation>replace</operation>\n\
    \           <target>/ietf-interfaces:interfaces</target>\n           <value>\n\
    \             <interfaces\n                  xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\"\
    >\n               <interface>\n                 <name>eth0</name>\n          \
    \       <oper-status>down</oper-status>\n               </interface>\n       \
    \      </interfaces>\n           </value>\n         </edit>\n       </yang-patch>\n\
    \     </datastore-changes>\n   </push-change-update>\n  </notification>\n    \
    \   Figure 2: Push Example for an On-Change Notification Message\n   Of note in\
    \ the above example is the \"patch-id\" with a value of \"0\".\n   Per [RFC8072],\
    \ the \"patch-id\" is an arbitrary string.  With\n   YANG-Push, the publisher\
    \ SHOULD put into the \"patch-id\" a counter\n   starting at \"0\" that increments\
    \ with every \"push-change-update\"\n   generated for a subscription.  If used\
    \ as a counter, this counter\n   MUST be reset to \"0\" any time a resynchronization\
    \ occurs (i.e., with\n   the sending of a \"push-update\").  Also, if used as\
    \ a counter, the\n   counter MUST be reset to \"0\" after passing a maximum value\
    \ of\n   \"4294967295\" (i.e., the maximum value that can be represented using\n\
    \   the uint32 data type).  Such a mechanism allows easy identification\n   of\
    \ lost or out-of-sequence update records.\n"
- title: 3.8.  Subscription Management
  contents:
  - "3.8.  Subscription Management\n   The RPCs defined in [RFC8639] have been enhanced\
    \ to support datastore\n   subscription negotiation.  Also, new error codes have\
    \ been added that\n   are able to indicate why a datastore subscription attempt\
    \ has failed,\n   along with new yang-data that MAY be used to include details\
    \ on input\n   parameters that might result in a successful subsequent RPC\n \
    \  invocation.\n   The establishment or modification of a datastore subscription\
    \ can be\n   rejected for multiple reasons, including a subtree request that is\n\
    \   too large or the inability of the publisher to push update records as\n  \
    \ frequently as requested.  In such cases, no subscription is\n   established.\
    \  Instead, a subscription result that includes the reason\n   for the failure\
    \ is returned as part of the RPC response.  As part of\n   this response, a set\
    \ of alternative subscription parameters MAY be\n   returned that would likely\
    \ have resulted in acceptance of the\n   subscription request.  The subscriber\
    \ may consider including such\n   parameters in future subscription attempts.\n\
    \   In the case of a rejected request for establishment of a datastore\n   subscription,\
    \ if there are hints, the hints SHOULD be transported in\n   a yang-data \"establish-subscription-datastore-error-info\"\
    \ container\n   inserted into the RPC error response, in lieu of the \"establish-\n\
    \   subscription-stream-error-info\" that is inserted in the case of a\n   stream\
    \ subscription.\n   Figure 3 shows a tree diagram for \"establish-subscription-datastore-\n\
    \   error-info\".  All tree diagrams used in this document follow the\n   notation\
    \ defined in [RFC8340].\n          yang-data establish-subscription-datastore-error-info\n\
    \            +--ro establish-subscription-datastore-error-info\n             \
    \  +--ro reason?                identityref\n               +--ro period-hint?\
    \           centiseconds\n               +--ro filter-failure-hint?   string\n\
    \               +--ro object-count-estimate? uint32\n               +--ro object-count-limit?\
    \    uint32\n               +--ro kilobytes-estimate?    uint32\n            \
    \   +--ro kilobytes-limit?       uint32\n   Figure 3: \"establish-subscription-datastore-error-info\"\
    \ Tree Diagram\n   Similarly, in the case of a rejected request for modification\
    \ of a\n   datastore subscription, if there are hints, the hints SHOULD be\n \
    \  transported in a yang-data \"modify-subscription-datastore-error-info\"\n \
    \  container inserted into the RPC error response, in lieu of the\n   \"modify-subscription-stream-error-info\"\
    \ that is inserted in the case\n   of a stream subscription.\n   Figure 4 shows\
    \ a tree diagram for \"modify-subscription-datastore-\n   error-info\".\n    \
    \      yang-data modify-subscription-datastore-error-info\n            +--ro modify-subscription-datastore-error-info\n\
    \               +--ro reason?                identityref\n               +--ro\
    \ period-hint?           centiseconds\n               +--ro filter-failure-hint?\
    \   string\n               +--ro object-count-estimate? uint32\n             \
    \  +--ro object-count-limit?    uint32\n               +--ro kilobytes-estimate?\
    \    uint32\n               +--ro kilobytes-limit?       uint32\n     Figure 4:\
    \ \"modify-subscription-datastore-error-info\" Tree Diagram\n"
- title: 3.9.  Receiver Authorization
  contents:
  - "3.9.  Receiver Authorization\n   A receiver of subscription data MUST only be\
    \ sent updates for which\n   it has proper authorization.  A publisher MUST ensure\
    \ that no\n   unauthorized data is included in push updates.  To do so, it needs\
    \ to\n   apply all corresponding checks applicable at the time of a specific\n\
    \   pushed update and, if necessary, silently remove any unauthorized\n   data\
    \ from datastore subtrees.  This enables YANG data that is pushed\n   based on\
    \ subscriptions to be authorized in a way that is equivalent\n   to a regular\
    \ data retrieval (\"get\") operation.\n   Each \"push-update\" and \"push-change-update\"\
    \ MUST have access control\n   applied, as depicted in Figure 5.  This includes\
    \ validating that read\n   access is permitted for any new objects selected since\
    \ the last\n   notification message was sent to a particular receiver.  A publisher\n\
    \   MUST silently omit data nodes from the results that the client is not\n  \
    \ authorized to see.  To accomplish this, implementations SHOULD apply\n   the\
    \ conceptual authorization model of [RFC8341], specifically\n   Section 3.2.4,\
    \ extended to apply analogously to data nodes included\n   in notifications, not\
    \ just <rpc-reply> messages sent in response to\n   <get> and <get-config> requests.\n\
    \                         +-----------------+      +--------------------+\n  \
    \   push-update or -->  | datastore node  |  yes | add datastore node |\n    push-change-update\
    \   | access allowed? | ---> | to update record   |\n                        \
    \ +-----------------+      +--------------------+\n                 Figure 5:\
    \ Access Control for Push Updates\n   A publisher MUST allow for the possibility\
    \ that a subscription's\n   selection filter references nonexistent data or data\
    \ that a receiver\n   is not allowed to access.  Such support permits a receiver\
    \ the\n   ability to monitor the entire lifecycle of some datastore tree\n   without\
    \ needing to explicitly enumerate every individual datastore\n   node.  If, after\
    \ access control has been applied, there are no\n   objects remaining in an update\
    \ record, then the effect varies given\n   if the subscription is a periodic or\
    \ on-change subscription.  For a\n   periodic subscription, an empty \"push-update\"\
    \ notification MUST be\n   sent, so that clients do not get confused into thinking\
    \ that an\n   update was lost.  For an on-change subscription, a \"push-update\"\
    \n   notification MUST NOT be sent, so that clients remain unaware of\n   changes\
    \ made to nodes they don't have read-access for.  By the same\n   token, changes\
    \ to objects that are filtered MUST NOT affect any\n   dampening intervals.\n\
    \   A publisher MAY choose to reject an \"establish-subscription\" request\n \
    \  that selects nonexistent data or data that a receiver is not allowed\n   to\
    \ access.  The error identity \"unchanging-selection\" SHOULD be\n   returned\
    \ as the reason for the rejection.  In addition, a publisher\n   MAY choose to\
    \ terminate a dynamic subscription or suspend a\n   configured receiver when the\
    \ authorization privileges of a receiver\n   change or the access controls for\
    \ subscribed objects change.  In that\n   case, the publisher SHOULD include the\
    \ error identity \"unchanging-\n   selection\" as the reason when sending the\
    \ \"subscription-terminated\"\n   or \"subscription-suspended\" notification,\
    \ respectively.  Such a\n   capability enables the publisher to avoid having to\
    \ support\n   continuous and total filtering of a subscription's content for every\n\
    \   update record.  It also reduces the possibility of leakage of\n   access-controlled\
    \ objects.\n   If read access into previously accessible nodes has been lost due\
    \ to\n   a receiver permissions change, this SHOULD be reported as a patch\n \
    \  \"delete\" operation for on-change subscriptions.  If not capable of\n   handling\
    \ such receiver permission changes with such a \"delete\",\n   publisher implementations\
    \ MUST force dynamic subscription\n   re-establishment or configured subscription\
    \ reinitialization so that\n   appropriate filtering is installed.\n"
- title: 3.10.  On-Change Notifiable Datastore Nodes
  contents:
  - "3.10.  On-Change Notifiable Datastore Nodes\n   In some cases, a publisher supporting\
    \ on-change notifications may not\n   be able to push on-change updates for some\
    \ object types.  Reasons for\n   this might be that the value of the datastore\
    \ node changes frequently\n   (e.g., the in-octets counter as defined in [RFC8343]),\
    \ small object\n   changes are frequent and meaningless (e.g., a temperature gauge\n\
    \   changing 0.1 degrees), or the implementation is not capable of\n   on-change\
    \ notification for a particular object.\n   In those cases, it will be important\
    \ for client applications to have\n   a way to identify for which objects on-change\
    \ notifications are\n   supported and for which ones they are not supported. \
    \ Otherwise,\n   client applications will have no way of knowing whether they\
    \ can\n   indeed rely on their on-change subscription to provide them with the\n\
    \   change updates that they are interested in.  In other words, if\n   implementations\
    \ do not provide a solution and do not support\n   comprehensive on-change notifiability,\
    \ clients of those\n   implementations will have no way of knowing what their\
    \ on-change\n   subscription actually covers.\n   Implementations are therefore\
    \ strongly advised to provide a solution\n   to this problem.  One solution might\
    \ involve making discoverable to\n   clients which objects are on-change notifiable,\
    \ specified using\n   another YANG data model.  Such a solution is specified in\n\
    \   [Yang-Push-Notif-Cap].  Until this solution is standardized,\n   implementations\
    \ SHOULD provide their own solution.\n"
- title: 3.11.  Other Considerations
  contents:
  - '3.11.  Other Considerations

    '
- title: 3.11.1.  Robustness and Reliability
  contents:
  - "3.11.1.  Robustness and Reliability\n   It is important that updates as discussed\
    \ in this document, and\n   on-change updates in particular, do not get lost.\
    \  If the loss of an\n   update is unavoidable, it is critical that the receiver\
    \ be notified\n   accordingly.\n   Update records for a single subscription MUST\
    \ NOT be resequenced\n   prior to transport.\n   It is conceivable that, under\
    \ certain circumstances, a publisher will\n   recognize that it is unable to include\
    \ in an update record the full\n   set of objects desired per the terms of a subscription.\
    \  In this\n   case, the publisher MUST act as follows.\n   o  The publisher MUST\
    \ set the \"incomplete-update\" flag on any update\n      record that is known\
    \ to be missing information.\n   o  The publisher MAY choose to suspend the subscription\
    \ as per\n      [RFC8639].  If the publisher does not create an update record\
    \ at\n      all, it MUST suspend the subscription.\n   o  When resuming an on-change\
    \ subscription, the publisher SHOULD\n      generate a complete patch from the\
    \ previous update record.  If\n      this is not possible and the \"sync-on-start\"\
    \ option is set to\n      \"true\" for the subscription, then the full datastore\
    \ contents MAY\n      be sent via a \"push-update\" instead (effectively replacing\
    \ the\n      previous contents).  If neither scenario above is possible, then\n\
    \      an \"incomplete-update\" flag MUST be included on the next\n      \"push-change-update\"\
    .\n   Note: It is perfectly acceptable to have a series of \"push-change-\n  \
    \ update\" notifications (and even \"push-update\" notifications) serially\n \
    \  queued at the transport layer awaiting transmission.  It is not\n   required\
    \ for the publisher to merge pending update records sent at\n   the same time.\n\
    \   On the receiver side, what action to take when a record with an\n   \"incomplete-update\"\
    \ flag is received depends on the application.  It\n   could simply choose to\
    \ wait and do nothing.  It could choose to\n   resync, actively retrieving all\
    \ subscribed information.  It could\n   also choose to tear down the subscription\
    \ and start a new one,\n   perhaps with a smaller scope that contains fewer objects.\n"
- title: 3.11.2.  Publisher Capacity
  contents:
  - "3.11.2.  Publisher Capacity\n   It is far preferable to decline a subscription\
    \ request than to accept\n   such a request when it cannot be met.\n   Whether\
    \ or not a subscription can be supported will be determined by\n   a combination\
    \ of several factors, such as the subscription update\n   trigger (on-change or\
    \ periodic), the period in which to report\n   changes (one-second periods will\
    \ consume more resources than one-hour\n   periods), the amount of data in the\
    \ datastore subtree that is being\n   subscribed to, and the number and combination\
    \ of other subscriptions\n   that are concurrently being serviced.\n"
- title: 4.  A YANG Data Model for Management of Datastore Push Subscriptions
  contents:
  - '4.  A YANG Data Model for Management of Datastore Push Subscriptions

    '
- title: 4.1.  Overview
  contents:
  - "4.1.  Overview\n   The YANG data model for datastore push subscriptions is depicted\
    \ in\n   Figures 6 through 9.  The tree diagram that is used follows the\n   notation\
    \ defined in [RFC8340].  New schema objects defined here\n   (i.e., beyond those\
    \ from [RFC8639]) are identified with \"yp\".  For\n   the reader's convenience,\
    \ in order to compact the tree\n   representation, some nodes that are defined\
    \ in the ietf-subscribed-\n   notifications YANG module [RFC8639] and therefore\
    \ are not essential\n   to the understanding of the data model defined here have\
    \ been\n   removed.  This is indicated by \"...\" in the diagram where applicable.\n\
    \   Because the tree diagram is quite large, its depiction is broken up\n   into\
    \ four figures.  Figure 6 depicts the augmentations that are\n   introduced in\
    \ YANG module ietf-yang-push to the subscription\n   configuration specified in\
    \ YANG module ietf-subscribed-notifications.\n   module: ietf-subscribed-notifications\n\
    \     ...\n     +--rw filters\n     |  ...\n     |  +--rw yp:selection-filter*\
    \ [filter-id]\n     |     +--rw yp:filter-id                   string\n     |\
    \     +--rw (yp:filter-spec)?\n     |        +--:(yp:datastore-subtree-filter)\n\
    \     |        |  +--rw yp:datastore-subtree-filter?   <anydata>\n     |     \
    \   |          {sn:subtree}?\n     |        +--:(yp:datastore-xpath-filter)\n\
    \     |           +--rw yp:datastore-xpath-filter?     yang:xpath1.0\n     | \
    \                  {sn:xpath}?\n     +--rw subscriptions\n        +--rw subscription*\
    \ [id]\n           |  ...\n           +--rw (target)\n           |  +--:(stream)\n\
    \           |  |   ...\n           |  +--:(yp:datastore)\n           |     +--rw\
    \ yp:datastore                     identityref\n           |     +--rw (yp:selection-filter)?\n\
    \           |        +--:(yp:by-reference)\n           |        |  +--rw yp:selection-filter-ref\n\
    \           |        |          selection-filter-ref\n           |        +--:(yp:within-subscription)\n\
    \           |           +--rw (yp:filter-spec)?\n           |              +--:(yp:datastore-subtree-filter)\n\
    \           |              |  +--rw yp:datastore-subtree-filter?\n           |\
    \              |          <anydata> {sn:subtree}?\n           |              +--:(yp:datastore-xpath-filter)\n\
    \           |                 +--rw yp:datastore-xpath-filter?\n           | \
    \                        yang:xpath1.0 {sn:xpath}?\n           | ...\n       \
    \    +--rw (yp:update-trigger)\n              +--:(yp:periodic)\n            \
    \  |  +--rw yp:periodic!\n              |     +--rw yp:period         centiseconds\n\
    \              |     +--rw yp:anchor-time?   yang:date-and-time\n            \
    \  +--:(yp:on-change) {on-change}?\n                 +--rw yp:on-change!\n   \
    \                 +--rw yp:dampening-period?   centiseconds\n                \
    \    +--rw yp:sync-on-start?      boolean\n                    +--rw yp:excluded-change*\
    \    change-type\n        Figure 6: Data Model Structure: Subscription Configuration\n\
    \   Figure 7 depicts the augmentations of YANG module ietf-yang-push made\n  \
    \ to RPCs specified in YANG module ietf-subscribed-notifications\n   [RFC8639].\
    \  Specifically, these augmentations concern the \"establish-\n   subscription\"\
    \ and \"modify-subscription\" RPCs, which are augmented\n   with parameters that\
    \ are needed to specify datastore push\n   subscriptions.\n     rpcs:\n      \
    \ +---x establish-subscription\n       |  +---w input\n       |  |  ...\n    \
    \   |  |  +---w (target)\n       |  |  |  +--:(stream)\n       |  |  |  |  ...\n\
    \       |  |  |  +--:(yp:datastore)\n       |  |  |     +---w yp:datastore   \
    \                identityref\n       |  |  |     +---w (yp:selection-filter)?\n\
    \       |  |  |        +--:(yp:by-reference)\n       |  |  |        |  +---w yp:selection-filter-ref\n\
    \       |  |  |        |          selection-filter-ref\n       |  |  |       \
    \ +--:(yp:within-subscription)\n       |  |  |           +---w (yp:filter-spec)?\n\
    \       |  |  |              +--:(yp:datastore-subtree-filter)\n       |  |  |\
    \              |  +---w yp:datastore-subtree-filter?\n       |  |  |         \
    \     |          <anydata> {sn:subtree}?\n       |  |  |              +--:(yp:datastore-xpath-filter)\n\
    \       |  |  |                 +---w yp:datastore-xpath-filter?\n       |  |\
    \  |                         yang:xpath1.0 {sn:xpath}?\n       |  |  | ...\n \
    \      |  |  +---w (yp:update-trigger)\n       |  |     +--:(yp:periodic)\n  \
    \     |  |     |  +---w yp:periodic!\n       |  |     |     +---w yp:period  \
    \       centiseconds\n       |  |     |     +---w yp:anchor-time?   yang:date-and-time\n\
    \       |  |     +--:(yp:on-change) {on-change}?\n       |  |        +---w yp:on-change!\n\
    \       |  |           +---w yp:dampening-period?   centiseconds\n       |  |\
    \           +---w yp:sync-on-start?      boolean\n       |  |           +---w\
    \ yp:excluded-change*    change-type\n       |  +--ro output\n       |     +--ro\
    \ id                            subscription-id\n       |     +--ro replay-start-time-revision?\
    \   yang:date-and-time\n       |             {replay}?\n       +---x modify-subscription\n\
    \       |  +---w input\n       |     ...\n       |     +---w (target)\n      \
    \ |     |  ...\n       |     |  +--:(yp:datastore)\n       |     |     +---w yp:datastore\
    \                   identityref\n       |     |     +---w (yp:selection-filter)?\n\
    \       |     |        +--:(yp:by-reference)\n       |     |        |  +---w yp:selection-filter-ref\n\
    \       |     |        |          selection-filter-ref\n       |     |       \
    \ +--:(yp:within-subscription)\n       |     |           +---w (yp:filter-spec)?\n\
    \       |     |              +--:(yp:datastore-subtree-filter)\n       |     |\
    \              |  +---w yp:datastore-subtree-filter?\n       |     |         \
    \     |          <anydata> {sn:subtree}?\n       |     |              +--:(yp:datastore-xpath-filter)\n\
    \       |     |                 +---w yp:datastore-xpath-filter?\n       |   \
    \  |                         yang:xpath1.0 {sn:xpath}?\n       |     | ...\n \
    \      |     +---w (yp:update-trigger)\n       |        +--:(yp:periodic)\n  \
    \     |        |  +---w yp:periodic!\n       |        |     +---w yp:period  \
    \       centiseconds\n       |        |     +---w yp:anchor-time?   yang:date-and-time\n\
    \       |        +--:(yp:on-change) {on-change}?\n       |           +---w yp:on-change!\n\
    \       |              +---w yp:dampening-period?   centiseconds\n       +---x\
    \ delete-subscription\n       |  ...\n       +---x kill-subscription\n       \
    \   ...\n     yang-data (for placement into RPC error responses)\n       ...\n\
    \                   Figure 7: Data Model Structure: RPCs\n   Figure 8 depicts\
    \ augmentations of YANG module ietf-yang-push to the\n   notifications that are\
    \ specified in YANG module ietf-subscribed-\n   notifications.  The augmentations\
    \ allow the inclusion of subscription\n   configuration parameters that are specific\
    \ to datastore push\n   subscriptions as part of \"subscription-started\" and\
    \ \"subscription-\n   modified\" notifications.\n     notifications:\n       +---n\
    \ replay-completed {replay}?\n       |  ...\n       +---n subscription-completed\n\
    \       |  ...\n       +---n subscription-started {configured}?\n       |  | \
    \ ...\n       |  +--ro (target)\n       |  |  ...\n       |  |  +--:(yp:datastore)\n\
    \       |  |     +--ro yp:datastore                   identityref\n       |  |\
    \     +--ro (yp:selection-filter)?\n       |  |        +--:(yp:by-reference)\n\
    \       |  |        |  +--ro yp:selection-filter-ref\n       |  |        |   \
    \       selection-filter-ref\n       |  |        +--:(yp:within-subscription)\n\
    \       |  |           +--ro (yp:filter-spec)?\n       |  |              +--:(yp:datastore-subtree-filter)\n\
    \       |  |              |  +--ro yp:datastore-subtree-filter?\n       |  | \
    \             |          <anydata> {sn:subtree}?\n       |  |              +--:(yp:datastore-xpath-filter)\n\
    \       |  |                 +--ro yp:datastore-xpath-filter?\n       |  |   \
    \                      yang:xpath1.0 {sn:xpath}?\n       |  ...\n       |  +--ro\
    \ (yp:update-trigger)\n       |     +--:(yp:periodic)\n       |     |  +--ro yp:periodic!\n\
    \       |     |     +--ro yp:period         centiseconds\n       |     |     +--ro\
    \ yp:anchor-time?   yang:date-and-time\n       |     +--:(yp:on-change) {on-change}?\n\
    \       |        +--ro yp:on-change!\n       |           +--ro yp:dampening-period?\
    \   centiseconds\n       |           +--ro yp:sync-on-start?      boolean\n  \
    \     |           +--ro yp:excluded-change*    change-type\n       +---n subscription-resumed\n\
    \       |  ...\n       +---n subscription-modified\n       |  ...\n       |  +--ro\
    \ (target)\n       |  |  |  ...\n       |  |  +--:(yp:datastore)\n       |  |\
    \     +--ro yp:datastore                   identityref\n       |  |     +--ro\
    \ (yp:selection-filter)?\n       |  |        +--:(yp:by-reference)\n       | \
    \ |        |  +--ro yp:selection-filter-ref\n       |  |        |          selection-filter-ref\n\
    \       |  |        +--:(yp:within-subscription)\n       |  |           +--ro\
    \ (yp:filter-spec)?\n       |  |              +--:(yp:datastore-subtree-filter)\n\
    \       |  |              |  +--ro yp:datastore-subtree-filter?\n       |  | \
    \             |          <anydata> {sn:subtree}?\n       |  |              +--:(yp:datastore-xpath-filter)\n\
    \       |  |                 +--ro yp:datastore-xpath-filter?\n       |  |   \
    \                      yang:xpath1.0 {sn:xpath}?\n       |  ...\n       |  +--ro\
    \ (yp:update-trigger)?\n       |     +--:(yp:periodic)\n       |     |  +--ro\
    \ yp:periodic!\n       |     |     +--ro yp:period         centiseconds\n    \
    \   |     |     +--ro yp:anchor-time?   yang:date-and-time\n       |     +--:(yp:on-change)\
    \ {on-change}?\n       |        +--ro yp:on-change!\n       |           +--ro\
    \ yp:dampening-period?    centiseconds\n       |           +--ro yp:sync-on-start?\
    \       boolean\n       |           +--ro yp:excluded-change*     change-type\n\
    \       +---n subscription-terminated\n       |  ...\n       +---n subscription-suspended\n\
    \          ...\n               Figure 8: Data Model Structure: Notifications\n\
    \   Finally, Figure 9 depicts the parts of YANG module ietf-yang-push\n   that\
    \ are newly introduced in this document (i.e., that are not simply\n   augmentations\
    \ of another YANG module).\n   module: ietf-yang-push\n     rpcs:\n       +---x\
    \ resync-subscription {on-change}?\n          +---w input\n             +---w\
    \ id    sn:subscription-id\n     yang-data (for placement into RPC error responses):\n\
    \       +-- resync-subscription-error\n       |  +--ro reason?               \
    \    identityref\n       |  +--ro period-hint?              centiseconds\n   \
    \    |  +--ro filter-failure-hint?      string\n       |  +--ro object-count-estimate?\
    \    uint32\n       |  +--ro object-count-limit?       uint32\n       |  +--ro\
    \ kilobytes-estimate?       uint32\n       |  +--ro kilobytes-limit?         \
    \ uint32\n       +-- establish-subscription-error-datastore\n       |  +--ro reason?\
    \                   identityref\n       |  +--ro period-hint?              centiseconds\n\
    \       |  +--ro filter-failure-hint?      string\n       |  +--ro object-count-estimate?\
    \    uint32\n       |  +--ro object-count-limit?       uint32\n       |  +--ro\
    \ kilobytes-estimate?       uint32\n       |  +--ro kilobytes-limit?         \
    \ uint32\n       +-- modify-subscription-error-datastore\n          +--ro reason?\
    \                   identityref\n          +--ro period-hint?              centiseconds\n\
    \          +--ro filter-failure-hint?      string\n          +--ro object-count-estimate?\
    \    uint32\n          +--ro object-count-limit?       uint32\n          +--ro\
    \ kilobytes-estimate?       uint32\n          +--ro kilobytes-limit?         \
    \ uint32\n        notifications:\n          +---n push-update\n          |  +--ro\
    \ id?                   sn:subscription-id\n          |  +--ro datastore-contents?\
    \   <anydata>\n          |  +--ro incomplete-update?    empty\n          +---n\
    \ push-change-update {on-change}?\n             +--ro id?                   sn:subscription-id\n\
    \             +--ro datastore-changes\n             |  +--ro yang-patch\n    \
    \         |     +--ro patch-id    string\n             |     +--ro comment?  \
    \  string\n             |     +--ro edit* [edit-id]\n             |        +--ro\
    \ edit-id      string\n             |        +--ro operation    enumeration\n\
    \             |        +--ro target       target-resource-offset\n           \
    \  |        +--ro point?       target-resource-offset\n             |        +--ro\
    \ where?       enumeration\n             |        +--ro value?       <anydata>\n\
    \             +--ro incomplete-update?    empty\n         Figure 9: Data Model\
    \ Structure: Non-augmentation Portions\n   Selected components of the data model\
    \ are summarized below.\n"
- title: 4.2.  Subscription Configuration
  contents:
  - "4.2.  Subscription Configuration\n   Both configured and dynamic subscriptions\
    \ are represented in the list\n   \"subscription\".  New parameters extending\
    \ the basic subscription data\n   model in [RFC8639] include:\n   o  The targeted\
    \ datastore from which the selection is being made.\n      The potential datastores\
    \ include those from [RFC8342].  A platform\n      may also choose to support\
    \ a custom datastore.\n   o  A selection filter identifying YANG nodes of interest\
    \ in a\n      datastore.  Filter contents are specified via a reference to an\n\
    \      existing filter or via an in-line definition for only that\n      subscription.\
    \  Referenced filters allow an implementation to avoid\n      evaluating filter\
    \ acceptability during a dynamic subscription\n      request.  The \"case\" statement\
    \ differentiates the options.\n   o  For periodic subscriptions, triggered updates\
    \ will occur at the\n      boundaries of a specified time interval.  These boundaries\
    \ can be\n      calculated from the periodic parameters:\n      *  a \"period\"\
    \ that defines the duration between push updates.\n      *  an \"anchor-time\"\
    ; update intervals fall on the points in time\n         that are a multiple of\
    \ a \"period\" from an \"anchor-time\".  If an\n         \"anchor-time\" is not\
    \ provided, then the \"anchor-time\" MUST be\n         set with the creation time\
    \ of the initial update record.\n   o  For on-change subscriptions, assuming that\
    \ any dampening period\n      has completed, triggering occurs whenever a change\
    \ in the\n      subscribed information is detected.  On-change subscriptions have\n\
    \      more-complex semantics that are guided by their own set of\n      parameters:\n\
    \      *  a \"dampening-period\" that specifies the interval that must pass\n\
    \         before a successive update for the subscription is sent.  If no\n  \
    \       dampening period is in effect, the update is sent immediately.\n     \
    \    If a subsequent change is detected, another update is only sent\n       \
    \  once the dampening period has passed for this subscription.\n      *  an \"\
    excluded-change\" that allows the restriction of the types\n         of changes\
    \ for which updates should be sent (e.g., only add to\n         an update record\
    \ on object creation).\n      *  a \"sync-on-start\" that specifies whether a\
    \ complete update with\n         all the subscribed data is to be sent at the\
    \ beginning of a\n         subscription.\n"
- title: 4.3.  YANG Notifications
  contents:
  - '4.3.  YANG Notifications

    '
- title: 4.3.1.  State Change Notifications
  contents:
  - "4.3.1.  State Change Notifications\n   Subscription state notifications and mechanisms\
    \ are reused from\n   [RFC8639].  Notifications \"subscription-started\" and \"\
    subscription-\n   modified\" have been augmented to include the datastore-specific\n\
    \   objects.\n"
- title: 4.3.2.  Notifications for Subscribed Content
  contents:
  - "4.3.2.  Notifications for Subscribed Content\n   Along with the subscribed content,\
    \ there are other objects that might\n   be part of a \"push-update\" or \"push-change-update\"\
    \ notification.\n   o  An \"id\" (that identifies the subscription).  This object\
    \ MUST be\n      transported along with the subscribed contents.  It allows a\n\
    \      receiver to determine which subscription resulted in a particular\n   \
    \   update record.\n   o  An \"incomplete-update\" leaf.  This leaf indicates\
    \ that not all\n      changes that have occurred since the last update are actually\n\
    \      included with this update.  In other words, the publisher has\n      failed\
    \ to fulfill its full subscription obligations.  (For\n      example, a datastore\
    \ was unable to provide the full set of\n      datastore nodes to a publisher\
    \ process.)  To facilitate the\n      resynchronization of on-change subscriptions,\
    \ a publisher MAY\n      subsequently send a \"push-update\" containing a full\
    \ selection\n      snapshot of subscribed data.\n"
- title: 4.4.  YANG RPCs
  contents:
  - "4.4.  YANG RPCs\n   YANG-Push subscriptions are established, modified, and deleted\
    \ using\n   RPCs augmented from [RFC8639].\n"
- title: 4.4.1.  "establish-subscription" RPC
  contents:
  - "4.4.1.  \"establish-subscription\" RPC\n   The subscriber sends an \"establish-subscription\"\
    \ RPC with the\n   parameters listed in Section 3.1.  An example might look like:\n\
    \ <netconf:rpc message-id=\"101\"\n     xmlns:netconf=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\
    >\n   <establish-subscription\n       xmlns=\"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\"\
    \n       xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n     <yp:datastore\n\
    \          xmlns:ds=\"urn:ietf:params:xml:ns:yang:ietf-datastores\">\n       ds:operational\n\
    \     </yp:datastore>\n     <yp:datastore-xpath-filter\n         xmlns:ex=\"https://example.com/sample-data/1.0\"\
    >\n       /ex:foo\n     </yp:datastore-xpath-filter>\n     <yp:periodic>\n   \
    \    <yp:period>500</yp:period>\n     </yp:periodic>\n   </establish-subscription>\n\
    \ </netconf:rpc>\n                  Figure 10: \"establish-subscription\" RPC\n\
    \   A positive response includes the \"id\" of the accepted subscription.\n  \
    \ In that case, a publisher may respond as follows:\n <rpc-reply message-id=\"\
    101\"\n    xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n    <id\n     \
    \ xmlns=\"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\">\n     \
    \  52\n    </id>\n </rpc-reply>\n         Figure 11: \"establish-subscription\"\
    \ Positive RPC Response\n   A subscription can be rejected for multiple reasons,\
    \ including the\n   lack of authorization to establish a subscription, no capacity\
    \ to\n   serve the subscription at the publisher, or the inability of the\n  \
    \ publisher to select datastore content at the requested cadence.\n   If a request\
    \ is rejected because the publisher is not able to serve\n   it, the publisher\
    \ SHOULD include in the returned error hints that\n   help a subscriber understand\
    \ what subscription parameters might have\n   been accepted for the request. \
    \ These hints would be included in the\n   yang-data structure \"establish-subscription-error-datastore\"\
    .\n   However, even with these hints, there are no guarantees that\n   subsequent\
    \ requests will in fact be accepted.\n   The specific parameters to be returned\
    \ as part of the RPC error\n   response depend on the specific transport that\
    \ is used to manage the\n   subscription.  For NETCONF, those parameters are defined\
    \ in\n   [RFC8640].  For example, for the following NETCONF request:\n     <rpc\
    \ message-id=\"101\"\n          xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\
    >\n       <establish-subscription\n           xmlns=\n             \"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\"\
    \n           xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n      \
    \   <yp:datastore\n             xmlns:ds=\"urn:ietf:params:xml:ns:yang:ietf-datastores\"\
    >\n           ds:operational\n         </yp:datastore>\n         <yp:datastore-xpath-filter\n\
    \             xmlns:ex=\"https://example.com/sample-data/1.0\">\n           /ex:foo\n\
    \         </yp:datastore-xpath-filter>\n         <yp:on-change>\n           <yp:dampening-period>100</yp:dampening-period>\n\
    \         </yp:on-change>\n       </establish-subscription>\n     </rpc>\n   \
    \       Figure 12: \"establish-subscription\" Request: Example 2\n   A publisher\
    \ that cannot serve on-change updates but can serve\n   periodic updates might\
    \ return the following NETCONF response:\n <rpc-reply message-id=\"101\"\n   xmlns=\"\
    urn:ietf:params:xml:ns:netconf:base:1.0\"\n   xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\"\
    >\n   <rpc-error>\n     <error-type>application</error-type>\n     <error-tag>operation-failed</error-tag>\n\
    \     <error-severity>error</error-severity>\n     <error-path>/yp:periodic/yp:period</error-path>\n\
    \     <error-info>\n       <yp:establish-subscription-error-datastore>\n     \
    \    <yp:reason>yp:on-change-unsupported</yp:reason>\n       </yp:establish-subscription-error-datastore>\n\
    \     </error-info>\n   </rpc-error>\n </rpc-reply>\n       Figure 13: \"establish-subscription\"\
    \ Error Response: Example 2\n"
- title: 4.4.2.  "modify-subscription" RPC
  contents:
  - "4.4.2.  \"modify-subscription\" RPC\n   The subscriber MAY invoke the \"modify-subscription\"\
    \ RPC for a\n   subscription it previously established.  The subscriber will include\n\
    \   newly desired values in the \"modify-subscription\" RPC.  Parameters\n   not\
    \ included MUST remain unmodified.  Figure 14 provides an example\n   where a\
    \ subscriber attempts to modify the period and datastore XPath\n   filter of a\
    \ subscription using NETCONF.\n     <rpc message-id=\"102\"\n          xmlns=\"\
    urn:ietf:params:xml:ns:netconf:base:1.0\">\n       <modify-subscription\n    \
    \       xmlns=\n             \"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\"\
    \n           xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n      \
    \   <id>1011</id>\n         <yp:datastore\n             xmlns:ds=\"urn:ietf:params:xml:ns:yang:ietf-datastores\"\
    >\n           ds:operational\n         </yp:datastore>\n         <yp:datastore-xpath-filter\n\
    \             xmlns:ex=\"https://example.com/sample-data/1.0\">\n           /ex:bar\n\
    \         </yp:datastore-xpath-filter>\n         <yp:periodic>\n           <yp:period>250</yp:period>\n\
    \         </yp:periodic>\n        </modify-subscription>\n     </rpc>\n      \
    \           Figure 14: \"modify-subscription\" Request\n   The publisher MUST\
    \ respond to the subscription modification request.\n   If the request is rejected,\
    \ the existing subscription is left\n   unchanged, and the publisher MUST send\
    \ an RPC error response.  This\n   response might have hints encapsulated in the\
    \ yang-data structure\n   \"modify-subscription-error-datastore\".  A subscription\
    \ MAY be\n   modified multiple times.\n   The specific parameters to be returned\
    \ as part of the RPC error\n   response depend on the specific transport that\
    \ is used to manage the\n   subscription.  For NETCONF, those parameters are specified\
    \ in\n   [RFC8640].\n   A configured subscription cannot be modified using a\n\
    \   \"modify-subscription\" RPC.  Instead, the configuration needs to be\n   edited\
    \ as needed.\n"
- title: 4.4.3.  "delete-subscription" RPC
  contents:
  - "4.4.3.  \"delete-subscription\" RPC\n   To stop receiving updates from a subscription\
    \ and effectively delete\n   a subscription that had previously been established\
    \ using an\n   \"establish-subscription\" RPC, a subscriber can send a\n   \"\
    delete-subscription\" RPC, which takes as its only input the\n   subscription's\
    \ \"id\".  This RPC is unmodified from [RFC8639].\n"
- title: 4.4.4.  "resync-subscription" RPC
  contents:
  - "4.4.4.  \"resync-subscription\" RPC\n   This RPC is supported only for on-change\
    \ subscriptions previously\n   established using an \"establish-subscription\"\
    \ RPC.  For example:\n      <rpc message-id=\"103\"\n           xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\
    >\n        <resync-subscription\n            xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\"\
    >\n          <id>1011</id>\n        </resync-subscription>\n      </rpc>\n   \
    \                  Figure 15: \"resync-subscription\"\n   On receipt, a publisher\
    \ must either (1) accept the request and\n   quickly follow with a \"push-update\"\
    \ or (2) send an appropriate error\n   in an RPC error response.  In its error\
    \ response, the publisher MAY\n   include, in the yang-data structure \"resync-subscription-error\"\
    ,\n   supplemental information about the reasons for the error.\n"
- title: 4.4.5.  YANG Module Synchronization
  contents:
  - "4.4.5.  YANG Module Synchronization\n   To make subscription requests, the subscriber\
    \ needs to know the YANG\n   datastore schemas used by the publisher.  These schemas\
    \ are available\n   in the YANG library module ietf-yang-library.yang as defined\
    \ in\n   [RFC8525].  The receiver is expected to know the YANG library\n   information\
    \ before starting a subscription.\n   The set of modules, revisions, features,\
    \ and deviations can change at\n   runtime (if supported by the publisher implementation).\
    \  For this\n   purpose, the YANG library provides a simple \"yang-library-change\"\
    \n   notification that informs the subscriber that the library has\n   changed.\
    \  In this case, a subscription may need to be updated to take\n   the updates\
    \ into account.  The receiver may also need to be informed\n   of module changes\
    \ in order to process updates regarding datastore\n   nodes from changed modules\
    \ correctly.\n"
- title: 5.  YANG Module for YANG-Push
  contents:
  - "5.  YANG Module for YANG-Push\n   This YANG module imports typedefs from [RFC6991],\
    \ identities from\n   [RFC8342], the \"yang-data\" extension from [RFC8040], and\
    \ the\n   \"yang-patch\" grouping from [RFC8072].  In addition, it imports and\n\
    \   augments many definitions from [RFC8639].  It also references\n   [RFC6241],\
    \ [XPATH] (\"XML Path Language (XPath) Version 1.0\"), and\n   [RFC7950].\n  \
    \ <CODE BEGINS> file \"ietf-yang-push@2019-09-09.yang\"\n   module ietf-yang-push\
    \ {\n     yang-version 1.1;\n     namespace \"urn:ietf:params:xml:ns:yang:ietf-yang-push\"\
    ;\n     prefix yp;\n     import ietf-yang-types {\n       prefix yang;\n     \
    \  reference\n         \"RFC 6991: Common YANG Data Types\";\n     }\n     import\
    \ ietf-subscribed-notifications {\n       prefix sn;\n       reference\n     \
    \    \"RFC 8639: Subscription to YANG Notifications\";\n     }\n     import ietf-datastores\
    \ {\n       prefix ds;\n       reference\n         \"RFC 8342: Network Management\
    \ Datastore Architecture (NMDA)\";\n     }\n     import ietf-restconf {\n    \
    \   prefix rc;\n       reference\n         \"RFC 8040: RESTCONF Protocol\";\n\
    \     }\n     import ietf-yang-patch {\n       prefix ypatch;\n       reference\n\
    \         \"RFC 8072: YANG Patch Media Type\";\n     }\n     organization\n  \
    \     \"IETF NETCONF (Network Configuration) Working Group\";\n     contact\n\
    \       \"WG Web:  <https:/datatracker.ietf.org/wg/netconf/>\n        WG List:\
    \ <mailto:netconf@ietf.org>\n        Author:  Alexander Clemm\n              \
    \   <mailto:ludwig@clemm.org>\n        Author:  Eric Voit\n                 <mailto:evoit@cisco.com>\"\
    ;\n     description\n       \"This module contains YANG specifications for YANG-Push.\n\
    \        The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL\n     \
    \   NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',\n        'MAY',\
    \ and 'OPTIONAL' in this document are to be interpreted as\n        described\
    \ in BCP 14 (RFC 2119) (RFC 8174) when, and only when,\n        they appear in\
    \ all capitals, as shown here.\n        Copyright (c) 2019 IETF Trust and the\
    \ persons identified as\n        authors of the code.  All rights reserved.\n\
    \        Redistribution and use in source and binary forms, with or\n        without\
    \ modification, is permitted pursuant to, and subject to\n        the license\
    \ terms contained in, the Simplified BSD License set\n        forth in Section\
    \ 4.c of the IETF Trust's Legal Provisions\n        Relating to IETF Documents\n\
    \        (https://trustee.ietf.org/license-info).\n        This version of this\
    \ YANG module is part of RFC 8641; see the\n        RFC itself for full legal\
    \ notices.\";\n     revision 2019-09-09 {\n       description\n         \"Initial\
    \ revision.\";\n       reference\n         \"RFC 8641: Subscriptions to YANG Datastores\"\
    ;\n     }\n     /*\n      * FEATURES\n      */\n     feature on-change {\n   \
    \    description\n         \"This feature indicates that on-change triggered subscriptions\n\
    \          are supported.\";\n     }\n     /*\n      * IDENTITIES\n      */\n\
    \     /* Error type identities for datastore subscription */\n     identity resync-subscription-error\
    \ {\n       description\n         \"Problem found while attempting to fulfill\
    \ a\n          'resync-subscription' RPC request.\";\n     }\n     identity cant-exclude\
    \ {\n       base sn:establish-subscription-error;\n       description\n      \
    \   \"Unable to remove the set of 'excluded-change' parameters.\n          This\
    \ means that the publisher is unable to restrict\n          'push-change-update'\
    \ notifications to just the change types\n          requested for this subscription.\"\
    ;\n     }\n     identity datastore-not-subscribable {\n       base sn:establish-subscription-error;\n\
    \       base sn:subscription-terminated-reason;\n       description\n        \
    \ \"This is not a subscribable datastore.\";\n     }\n     identity no-such-subscription-resync\
    \ {\n       base resync-subscription-error;\n       description\n         \"The\
    \ referenced subscription doesn't exist.  This may be as a\n          result of\
    \ a nonexistent subscription ID, an ID that belongs to\n          another subscriber,\
    \ or an ID for a configured subscription.\";\n     }\n     identity on-change-unsupported\
    \ {\n       base sn:establish-subscription-error;\n       description\n      \
    \   \"On-change is not supported for any objects that are\n          selectable\
    \ by this filter.\";\n     }\n     identity on-change-sync-unsupported {\n   \
    \    base sn:establish-subscription-error;\n       description\n         \"Neither\
    \ 'sync-on-start' nor resynchronization is supported for\n          this subscription.\
    \  This error will be used for two reasons:\n          (1) if an 'establish-subscription'\
    \ RPC includes\n          'sync-on-start' but the publisher can't support sending\
    \ a\n          'push-update' for this subscription for reasons other than\n  \
    \        'on-change-unsupported' or 'sync-too-big'\n          (2) if the 'resync-subscription'\
    \ RPC is invoked for either an\n          existing periodic subscription or an\
    \ on-change subscription\n          that can't support resynchronization.\";\n\
    \     }\n     identity period-unsupported {\n       base sn:establish-subscription-error;\n\
    \       base sn:modify-subscription-error;\n       base sn:subscription-suspended-reason;\n\
    \       description\n         \"The requested time period or 'dampening-period'\
    \ is too short.\n          This can be for both periodic and on-change subscriptions\n\
    \          (with or without dampening).  Hints suggesting alternative\n      \
    \    periods may be returned as supplemental information.\";\n     }\n     identity\
    \ update-too-big {\n       base sn:establish-subscription-error;\n       base\
    \ sn:modify-subscription-error;\n       base sn:subscription-suspended-reason;\n\
    \       description\n         \"Periodic or on-change push update data trees exceed\
    \ a maximum\n          size limit.  Hints on the estimated size of what was too\
    \ big\n          may be returned as supplemental information.\";\n     }\n   \
    \  identity sync-too-big {\n       base sn:establish-subscription-error;\n   \
    \    base sn:modify-subscription-error;\n       base resync-subscription-error;\n\
    \       base sn:subscription-suspended-reason;\n       description\n         \"\
    The 'sync-on-start' or resynchronization data tree exceeds a\n          maximum\
    \ size limit.  Hints on the estimated size of what was\n          too big may\
    \ be returned as supplemental information.\";\n     }\n     identity unchanging-selection\
    \ {\n       base sn:establish-subscription-error;\n       base sn:modify-subscription-error;\n\
    \       base sn:subscription-terminated-reason;\n       description\n        \
    \ \"The selection filter is unlikely to ever select data tree\n          nodes.\
    \  This means that based on the subscriber's current\n          access rights,\
    \ the publisher recognizes that the selection\n          filter is unlikely to\
    \ ever select data tree nodes that change.\n          Examples for this might\
    \ be that the node or subtree doesn't\n          exist, read access is not permitted\
    \ for a receiver, or static\n          objects that only change at reboot have\
    \ been chosen.\";\n     }\n     /*\n      * TYPE DEFINITIONS\n      */\n     typedef\
    \ change-type {\n       type enumeration {\n         enum create {\n         \
    \  description\n             \"A change that refers to the creation of a new\n\
    \              datastore node.\";\n         }\n         enum delete {\n      \
    \     description\n             \"A change that refers to the deletion of a\n\
    \              datastore node.\";\n         }\n         enum insert {\n      \
    \     description\n             \"A change that refers to the insertion of a new\n\
    \              user-ordered datastore node.\";\n         }\n         enum move\
    \ {\n           description\n             \"A change that refers to a reordering\
    \ of the target\n              datastore node.\";\n         }\n         enum replace\
    \ {\n           description\n             \"A change that refers to a replacement\
    \ of the target\n              datastore node's value.\";\n         }\n      \
    \ }\n       description\n         \"Specifies different types of datastore changes.\n\
    \          This type is based on the edit operations defined for\n          YANG\
    \ Patch, with the difference that it is valid for a\n          receiver to process\
    \ an update record that performs a\n          'create' operation on a datastore\
    \ node the receiver believes\n          exists or to process a delete on a datastore\
    \ node the\n          receiver believes is missing.\";\n       reference\n   \
    \      \"RFC 8072: YANG Patch Media Type, Section 2.5\";\n     }\n     typedef\
    \ selection-filter-ref {\n       type leafref {\n         path \"/sn:filters/yp:selection-filter/yp:filter-id\"\
    ;\n       }\n       description\n         \"This type is used to reference a selection\
    \ filter.\";\n     }\n     typedef centiseconds {\n       type uint32;\n     \
    \  description\n         \"A period of time, measured in units of 0.01 seconds.\"\
    ;\n     }\n     /*\n      * GROUP DEFINITIONS\n      */\n     grouping datastore-criteria\
    \ {\n       description\n         \"A grouping to define criteria for which selected\
    \ objects from\n          a targeted datastore should be included in push updates.\"\
    ;\n       leaf datastore {\n         type identityref {\n           base ds:datastore;\n\
    \         }\n         mandatory true;\n         description\n           \"Datastore\
    \ from which to retrieve data.\";\n       }\n       uses selection-filter-objects;\n\
    \     }\n     grouping selection-filter-types {\n       description\n        \
    \ \"This grouping defines the types of selectors for objects\n          from a\
    \ datastore.\";\n       choice filter-spec {\n         description\n         \
    \  \"The content filter specification for this request.\";\n         anydata datastore-subtree-filter\
    \ {\n           if-feature \"sn:subtree\";\n           description\n         \
    \    \"This parameter identifies the portions of the\n              target datastore\
    \ to retrieve.\";\n           reference\n             \"RFC 6241: Network Configuration\
    \ Protocol (NETCONF),\n                        Section 6\";\n         }\n    \
    \     leaf datastore-xpath-filter {\n           if-feature \"sn:xpath\";\n   \
    \        type yang:xpath1.0;\n           description\n             \"This parameter\
    \ contains an XPath expression identifying\n              the portions of the\
    \ target datastore to retrieve.\n              If the expression returns a node\
    \ set, all nodes in the\n              node set are selected by the filter.  Otherwise,\
    \ if the\n              expression does not return a node set, the filter\n  \
    \            doesn't select any nodes.\n              The expression is evaluated\
    \ in the following XPath\n              context:\n              o  The set of\
    \ namespace declarations is the set of prefix\n                 and namespace\
    \ pairs for all YANG modules implemented\n                 by the server, where\
    \ the prefix is the YANG module\n                 name and the namespace is as\
    \ defined by the\n                 'namespace' statement in the YANG module.\n\
    \                 If the leaf is encoded in XML, all namespace\n             \
    \    declarations in scope on the 'stream-xpath-filter'\n                 leaf\
    \ element are added to the set of namespace\n                 declarations.  If\
    \ a prefix found in the XML is\n                 already present in the set of\
    \ namespace declarations,\n                 the namespace in the XML is used.\n\
    \              o  The set of variable bindings is empty.\n              o  The\
    \ function library is comprised of the core\n                 function library\
    \ and the XPath functions defined in\n                 Section 10 in RFC 7950.\n\
    \              o  The context node is the root node of the target\n          \
    \       datastore.\";\n           reference\n             \"XML Path Language\
    \ (XPath) Version 1.0\n              (https://www.w3.org/TR/1999/REC-xpath-19991116)\n\
    \              RFC 7950: The YANG 1.1 Data Modeling Language,\n              \
    \          Section 10\";\n         }\n       }\n     }\n     grouping selection-filter-objects\
    \ {\n       description\n         \"This grouping defines a selector for objects\
    \ from a\n          datastore.\";\n       choice selection-filter {\n        \
    \ description\n           \"The source of the selection filter applied to the\n\
    \            subscription.  This will either (1) come referenced from a\n    \
    \        global list or (2) be provided in the subscription itself.\";\n     \
    \    case by-reference {\n           description\n             \"Incorporates\
    \ a filter that has been configured\n              separately.\";\n          \
    \ leaf selection-filter-ref {\n             type selection-filter-ref;\n     \
    \        mandatory true;\n             description\n               \"References\
    \ an existing selection filter that is to be\n                applied to the subscription.\"\
    ;\n           }\n         }\n         case within-subscription {\n           description\n\
    \             \"A local definition allows a filter to have the same\n        \
    \      lifecycle as the subscription.\";\n           uses selection-filter-types;\n\
    \         }\n       }\n     }\n     grouping update-policy-modifiable {\n    \
    \   description\n         \"This grouping describes the datastore-specific subscription\n\
    \          conditions that can be changed during the lifetime of the\n       \
    \   subscription.\";\n       choice update-trigger {\n         description\n \
    \          \"Defines necessary conditions for sending an event record to\n   \
    \         the subscriber.\";\n         case periodic {\n           container periodic\
    \ {\n             presence \"indicates a periodic subscription\";\n          \
    \   description\n               \"The publisher is requested to periodically notify\
    \ the\n                receiver regarding the current values of the datastore\n\
    \                as defined by the selection filter.\";\n             leaf period\
    \ {\n               type centiseconds;\n               mandatory true;\n     \
    \          description\n                 \"Duration of time that should occur\
    \ between periodic\n                  push updates, in units of 0.01 seconds.\"\
    ;\n             }\n             leaf anchor-time {\n               type yang:date-and-time;\n\
    \               description\n                 \"Designates a timestamp before\
    \ or after which a series\n                  of periodic push updates are determined.\
    \  The next\n                  update will take place at a point in time that\
    \ is a\n                  multiple of a period from the 'anchor-time'.\n     \
    \             For example, for an 'anchor-time' that is set for the\n        \
    \          top of a particular minute and a period interval of a\n           \
    \       minute, updates will be sent at the top of every\n                  minute\
    \ that this subscription is active.\";\n             }\n           }\n       \
    \  }\n         case on-change {\n           if-feature \"on-change\";\n      \
    \     container on-change {\n             presence \"indicates an on-change subscription\"\
    ;\n             description\n               \"The publisher is requested to notify\
    \ the receiver\n                regarding changes in values in the datastore subset\
    \ as\n                defined by a selection filter.\";\n             leaf dampening-period\
    \ {\n               type centiseconds;\n               default \"0\";\n      \
    \         description\n                 \"Specifies the minimum interval between\
    \ the assembly of\n                  successive update records for a single receiver\
    \ of a\n                  subscription.  Whenever subscribed objects change and\n\
    \                  a dampening-period interval (which may be zero) has\n     \
    \             elapsed since the previous update record creation for\n        \
    \          a receiver, any subscribed objects and properties\n               \
    \   that have changed since the previous update record\n                  will\
    \ have their current values marshalled and placed\n                  in a new\
    \ update record.\";\n             }\n           }\n         }\n       }\n    \
    \ }\n     grouping update-policy {\n       description\n         \"This grouping\
    \ describes the datastore-specific subscription\n          conditions of a subscription.\"\
    ;\n       uses update-policy-modifiable {\n         augment \"update-trigger/on-change/on-change\"\
    \ {\n           description\n             \"Includes objects that are not modifiable\
    \ once a\n              subscription is established.\";\n           leaf sync-on-start\
    \ {\n             type boolean;\n             default \"true\";\n            \
    \ description\n               \"When this object is set to 'false', (1) it restricts\
    \ an\n                on-change subscription from sending 'push-update'\n    \
    \            notifications and (2) pushing a full selection per the\n        \
    \        terms of the selection filter MUST NOT be done for\n                this\
    \ subscription.  Only updates about changes\n                (i.e., only 'push-change-update'\
    \ notifications)\n                are sent.  When set to 'true' (the default behavior),\n\
    \                in order to facilitate a receiver's synchronization,\n      \
    \          a full update is sent, via a 'push-update' notification,\n        \
    \        when the subscription starts.  After that,\n                'push-change-update'\
    \ notifications are exclusively sent,\n                unless the publisher chooses\
    \ to resync the subscription\n                via a new 'push-update' notification.\"\
    ;\n           }\n           leaf-list excluded-change {\n             type change-type;\n\
    \             description\n               \"Used to restrict which changes trigger\
    \ an update.  For\n                example, if a 'replace' operation is excluded,\
    \ only the\n                creation and deletion of objects are reported.\";\n\
    \           }\n         }\n       }\n     }\n     grouping hints {\n       description\n\
    \         \"Parameters associated with an error for a subscription\n         \
    \ made upon a datastore.\";\n       leaf period-hint {\n         type centiseconds;\n\
    \         description\n           \"Returned when the requested time period is\
    \ too short.  This\n            hint can assert a viable period for either a periodic\
    \ push\n            cadence or an on-change dampening interval.\";\n       }\n\
    \       leaf filter-failure-hint {\n         type string;\n         description\n\
    \           \"Information describing where and/or why a provided filter\n    \
    \        was unsupportable for a subscription.\";\n       }\n       leaf object-count-estimate\
    \ {\n         type uint32;\n         description\n           \"If there are too\
    \ many objects that could potentially be\n            returned by the selection\
    \ filter, this identifies the\n            estimate of the number of objects that\
    \ the filter would\n            potentially pass.\";\n       }\n       leaf object-count-limit\
    \ {\n         type uint32;\n         description\n           \"If there are too\
    \ many objects that could be returned by\n            the selection filter, this\
    \ identifies the upper limit of\n            the publisher's ability to service\
    \ this subscription.\";\n       }\n       leaf kilobytes-estimate {\n        \
    \ type uint32;\n         description\n           \"If the returned information\
    \ could be beyond the capacity\n            of the publisher, this would identify\
    \ the estimated\n            data size that could result from this selection filter.\"\
    ;\n       }\n       leaf kilobytes-limit {\n         type uint32;\n         description\n\
    \           \"If the returned information would be beyond the capacity\n     \
    \       of the publisher, this identifies the upper limit of the\n           \
    \ publisher's ability to service this subscription.\";\n       }\n     }\n   \
    \  /*\n      * RPCs\n      */\n     rpc resync-subscription {\n       if-feature\
    \ \"on-change\";\n       description\n         \"This RPC allows a subscriber\
    \ of an active on-change\n          subscription to request a full push of objects.\n\
    \          A successful invocation results in a 'push-update' of all\n       \
    \   datastore nodes that the subscriber is permitted to access.\n          This\
    \ RPC can only be invoked on the same session on which the\n          subscription\
    \ is currently active.  In the case of an error, a\n          'resync-subscription-error'\
    \ is sent as part of an error\n          response.\";\n       input {\n      \
    \   leaf id {\n           type sn:subscription-id;\n           mandatory true;\n\
    \           description\n             \"Identifier of the subscription that is\
    \ to be resynced.\";\n         }\n       }\n     }\n     rc:yang-data resync-subscription-error\
    \ {\n       container resync-subscription-error {\n         description\n    \
    \       \"If a 'resync-subscription' RPC fails, the subscription is\n        \
    \    not resynced and the RPC error response MUST indicate the\n            reason\
    \ for this failure.  This yang-data MAY be inserted as\n            structured\
    \ data in a subscription's RPC error response\n            to indicate the reason\
    \ for the failure.\";\n         leaf reason {\n           type identityref {\n\
    \             base resync-subscription-error;\n           }\n           mandatory\
    \ true;\n           description\n             \"Indicates the reason why the publisher\
    \ has declined a\n              request for subscription resynchronization.\"\
    ;\n         }\n         uses hints;\n       }\n     }\n     augment \"/sn:establish-subscription/sn:input\"\
    \ {\n       description\n         \"This augmentation adds additional subscription\
    \ parameters\n          that apply specifically to datastore updates to RPC input.\"\
    ;\n       uses update-policy;\n     }\n     augment \"/sn:establish-subscription/sn:input/sn:target\"\
    \ {\n       description\n         \"This augmentation adds the datastore as a\
    \ valid target\n          for the subscription to RPC input.\";\n       case datastore\
    \ {\n         description\n           \"Information specifying the parameters\
    \ of a request for a\n            datastore subscription.\";\n         uses datastore-criteria;\n\
    \       }\n     }\n     rc:yang-data establish-subscription-datastore-error-info\
    \ {\n       container establish-subscription-datastore-error-info {\n        \
    \ description\n           \"If any 'establish-subscription' RPC parameters are\n\
    \            unsupportable against the datastore, a subscription is not\n    \
    \        created and the RPC error response MUST indicate the reason\n       \
    \     why the subscription failed to be created.  This yang-data\n           \
    \ MAY be inserted as structured data in a subscription's\n            RPC error\
    \ response to indicate the reason for the failure.\n            This yang-data\
    \ MUST be inserted if hints are to be provided\n            back to the subscriber.\"\
    ;\n         leaf reason {\n           type identityref {\n             base sn:establish-subscription-error;\n\
    \           }\n           description\n             \"Indicates the reason why\
    \ the subscription has failed to\n              be created to a targeted datastore.\"\
    ;\n         }\n         uses hints;\n       }\n     }\n     augment \"/sn:modify-subscription/sn:input\"\
    \ {\n       description\n         \"This augmentation adds additional subscription\
    \ parameters\n          specific to datastore updates.\";\n       uses update-policy-modifiable;\n\
    \     }\n     augment \"/sn:modify-subscription/sn:input/sn:target\" {\n     \
    \  description\n         \"This augmentation adds the datastore as a valid target\n\
    \          for the subscription to RPC input.\";\n       case datastore {\n  \
    \       description\n           \"Information specifying the parameters of a request\
    \ for a\n            datastore subscription.\";\n         uses datastore-criteria;\n\
    \       }\n     }\n     rc:yang-data modify-subscription-datastore-error-info\
    \ {\n       container modify-subscription-datastore-error-info {\n         description\n\
    \           \"This yang-data MAY be provided as part of a subscription's\n   \
    \         RPC error response when there is a failure of a\n            'modify-subscription'\
    \ RPC that has been made against a\n            datastore.  This yang-data MUST\
    \ be used if hints are to be\n            provided back to the subscriber.\";\n\
    \         leaf reason {\n           type identityref {\n             base sn:modify-subscription-error;\n\
    \           }\n           description\n             \"Indicates the reason why\
    \ the subscription has failed to\n              be modified.\";\n         }\n\
    \         uses hints;\n       }\n     }\n     /*\n      * NOTIFICATIONS\n    \
    \  */\n     notification push-update {\n       description\n         \"This notification\
    \ contains a push update that in turn contains\n          data subscribed to via\
    \ a subscription.  In the case of a\n          periodic subscription, this notification\
    \ is sent for periodic\n          updates.  It can also be used for synchronization\
    \ updates of\n          an on-change subscription.  This notification shall only\
    \ be\n          sent to receivers of a subscription.  It does not constitute\n\
    \          a general-purpose notification that would be subscribable as\n    \
    \      part of the NETCONF event stream by any receiver.\";\n       leaf id {\n\
    \         type sn:subscription-id;\n         description\n           \"This references\
    \ the subscription that drove the\n            notification to be sent.\";\n \
    \      }\n       anydata datastore-contents {\n         description\n        \
    \   \"This contains the updated data.  It constitutes a snapshot\n           \
    \ at the time of update of the set of data that has been\n            subscribed\
    \ to.  The snapshot corresponds to the same\n            snapshot that would be\
    \ returned in a corresponding 'get'\n            operation with the same selection\
    \ filter parameters\n            applied.\";\n       }\n       leaf incomplete-update\
    \ {\n         type empty;\n         description\n           \"This is a flag that\
    \ indicates that not all datastore\n            nodes subscribed to are included\
    \ with this update.  In\n            other words, the publisher has failed to\
    \ fulfill its full\n            subscription obligations and, despite its best\
    \ efforts, is\n            providing an incomplete set of objects.\";\n      \
    \ }\n     }\n     notification push-change-update {\n       if-feature \"on-change\"\
    ;\n       description\n         \"This notification contains an on-change push\
    \ update.  This\n          notification shall only be sent to the receivers of\
    \ a\n          subscription.  It does not constitute a general-purpose\n     \
    \     notification that would be subscribable as part of the\n          NETCONF\
    \ event stream by any receiver.\";\n       leaf id {\n         type sn:subscription-id;\n\
    \         description\n           \"This references the subscription that drove\
    \ the\n            notification to be sent.\";\n       }\n       container datastore-changes\
    \ {\n         description\n           \"This contains the set of datastore changes\
    \ of the target\n            datastore, starting at the time of the previous update,\
    \ per\n            the terms of the subscription.\";\n         uses ypatch:yang-patch;\n\
    \       }\n       leaf incomplete-update {\n         type empty;\n         description\n\
    \           \"The presence of this object indicates that not all changes\n   \
    \         that have occurred since the last update are included with\n       \
    \     this update.  In other words, the publisher has failed to\n            fulfill\
    \ its full subscription obligations -- for example,\n            in cases where\
    \ it was not able to keep up with a burst of\n            changes.\";\n      \
    \ }\n     }\n     augment \"/sn:subscription-started\" {\n       description\n\
    \         \"This augmentation adds datastore-specific objects to\n          the\
    \ notification that a subscription has started.\";\n       uses update-policy;\n\
    \     }\n     augment \"/sn:subscription-started/sn:target\" {\n       description\n\
    \         \"This augmentation allows the datastore to be included as\n       \
    \   part of the notification that a subscription has started.\";\n       case\
    \ datastore {\n         uses datastore-criteria {\n           refine \"selection-filter/within-subscription\"\
    \ {\n             description\n               \"Specifies the selection filter\
    \ and where it originated\n                from.  If the 'selection-filter-ref'\
    \ is populated, the\n                filter in the subscription came from the\
    \ 'filters'\n                container.  Otherwise, it is populated in-line as\
    \ part\n                of the subscription itself.\";\n           }\n       \
    \  }\n       }\n     }\n     augment \"/sn:subscription-modified\" {\n       description\n\
    \         \"This augmentation adds datastore-specific objects to\n          the\
    \ notification that a subscription has been modified.\";\n       uses update-policy;\n\
    \     }\n     augment \"/sn:subscription-modified/sn:target\" {\n       description\n\
    \         \"This augmentation allows the datastore to be included as\n       \
    \   part of the notification that a subscription has been\n          modified.\"\
    ;\n       case datastore {\n         uses datastore-criteria {\n           refine\
    \ \"selection-filter/within-subscription\" {\n             description\n     \
    \          \"Specifies the selection filter and where it originated\n        \
    \        from.  If the 'selection-filter-ref' is populated, the\n            \
    \    filter in the subscription came from the 'filters'\n                container.\
    \  Otherwise, it is populated in-line as part\n                of the subscription\
    \ itself.\";\n           }\n         }\n       }\n     }\n     /*\n      * DATA\
    \ NODES\n      */\n     augment \"/sn:filters\" {\n       description\n      \
    \   \"This augmentation allows the datastore to be included as part\n        \
    \  of the selection-filtering criteria for a subscription.\";\n       list selection-filter\
    \ {\n         key \"filter-id\";\n         description\n           \"A list of\
    \ preconfigured filters that can be applied\n            to datastore subscriptions.\"\
    ;\n         leaf filter-id {\n           type string;\n           description\n\
    \             \"An identifier to differentiate between selection\n           \
    \   filters.\";\n         }\n         uses selection-filter-types;\n       }\n\
    \     }\n     augment \"/sn:subscriptions/sn:subscription\" {\n       when 'yp:datastore';\n\
    \       description\n         \"This augmentation adds objects to a subscription\
    \ that are\n          specific to a datastore subscription, i.e., a subscription\
    \ to\n          a stream of datastore node updates.\";\n       uses update-policy;\n\
    \     }\n     augment \"/sn:subscriptions/sn:subscription/sn:target\" {\n    \
    \   description\n         \"This augmentation allows the datastore to be included\
    \ as\n          part of the selection-filtering criteria for a subscription.\"\
    ;\n       case datastore {\n         uses datastore-criteria;\n       }\n    \
    \ }\n   }\n   <CODE ENDS>\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   This document registers the following namespace URI\
    \ in the \"IETF XML\n   Registry\" [RFC3688]:\n   URI: urn:ietf:params:xml:ns:yang:ietf-yang-push\n\
    \   Registrant Contact: The IESG.\n   XML: N/A; the requested URI is an XML namespace.\n\
    \   This document registers the following YANG module in the \"YANG Module\n \
    \  Names\" registry [RFC6020]:\n   Name: ietf-yang-push\n   Namespace: urn:ietf:params:xml:ns:yang:ietf-yang-push\n\
    \   Prefix: yp\n   Reference: RFC 8641\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The YANG module specified in this document defines\
    \ a schema for data\n   that is designed to be accessed via network management\
    \ protocols such\n   as NETCONF [RFC6241] or RESTCONF [RFC8040].  The lowest NETCONF\
    \ layer\n   is the secure transport layer, and the mandatory-to-implement secure\n\
    \   transport is Secure Shell (SSH) [RFC6242].  The lowest RESTCONF layer\n  \
    \ is HTTPS, and the mandatory-to-implement secure transport is TLS\n   [RFC8446].\n\
    \   The Network Configuration Access Control Model (NACM) [RFC8341]\n   provides\
    \ the means to restrict access for particular NETCONF or\n   RESTCONF users to\
    \ a preconfigured subset of all available NETCONF or\n   RESTCONF protocol operations\
    \ and content.\n   There are a number of data nodes defined in this YANG module\
    \ that are\n   writable/creatable/deletable (i.e., config true, which is the\n\
    \   default).  These data nodes may be considered sensitive or vulnerable\n  \
    \ in some network environments.  Write operations (e.g., edit-config)\n   to these\
    \ data nodes without proper protection can have a negative\n   effect on network\
    \ operations.  These are the subtrees and data nodes\n   and their sensitivity/vulnerability.\
    \  (It should be noted that the\n   YANG module defined in this document augments\
    \ the YANG module defined\n   in [RFC8639].  All security considerations that\
    \ are listed in\n   [RFC8639] are also relevant for datastore subscriptions. \
    \ In the\n   following list, we focus on the new data nodes that are introduced\
    \ in\n   this document.)\n   o  Subtree \"selection-filter\" under container \"\
    filters\": This subtree\n      allows a subscriber to specify which objects or\
    \ subtrees to\n      include in a datastore subscription.  An attacker could attempt\
    \ to\n      modify the filter.  For example, the filter might be modified to\n\
    \      result in very few objects being filtered in order to attempt to\n    \
    \  overwhelm the receiver.  Alternatively, the filter might be\n      modified\
    \ to result in certain objects being excluded from updates,\n      in which case\
    \ certain changes would go unnoticed.\n   o  Subtree \"datastore\" in choice \"\
    target\" in list \"subscription\":\n      Analogous to \"selection filter\", an\
    \ attacker might attempt to\n      modify the objects being filtered in order\
    \ to overwhelm a receiver\n      with a larger volume of object updates than expected\
    \ or cause\n      certain changes to go unnoticed.\n   o  Choice \"update-trigger\"\
    \ in list \"subscription\": By modifying the\n      update trigger, an attacker\
    \ might alter the updates that are being\n      sent in order to confuse a receiver,\
    \ withhold certain updates to\n      be sent to the receiver, and/or overwhelm\
    \ a receiver.  For\n      example, an attacker might modify the period with which\
    \ updates\n      are reported for a periodic subscription, or it might modify\
    \ the\n      dampening period for an on-change subscription, resulting in a\n\
    \      greater delay for successive updates (potentially affecting the\n     \
    \ responsiveness of applications that depend on the updates) or in a\n      high\
    \ volume of updates (to exhaust receiver resources).\n   The NACM provides one\
    \ means to mitigate these threats on the\n   publisher side.  In order to address\
    \ those threats as a subscriber,\n   the subscriber could monitor the subscription\
    \ configuration for any\n   unexpected changes and subscribe to updates to the\
    \ YANG datastore\n   nodes that represent its datastore subscriptions.  As this\
    \ volume of\n   data is small, a paranoid subscriber could even revert to occasional\n\
    \   polling to guard against a compromised subscription against\n   subscription\
    \ configuration updates itself.\n   Some of the readable data nodes in this YANG\
    \ module may be considered\n   sensitive or vulnerable in some network environments.\
    \  It is thus\n   important to control read access (e.g., via get, get-config,\
    \ or\n   notification) to these data nodes.  These are the subtrees and data\n\
    \   nodes and their sensitivity/vulnerability:\n   o  Subtree \"selection-filter\"\
    \ under container \"filters\": If access\n      control is not properly configured,\
    \ can expose system internals to\n      those who should not have access to this\
    \ information.\n   o  Subtree \"datastore\" in choice \"target\" in list \"subscription\"\
    : If\n      access control is not properly configured, can expose system\n   \
    \   internals to those who should not have access to this information.\n   o \
    \ Choice \"update-trigger\" in list \"subscription\": If access control\n    \
    \  is not properly configured, can expose system internals to those\n      who\
    \ should not have access to this information.\n   Some of the RPC operations in\
    \ this YANG module may be considered\n   sensitive or vulnerable in some network\
    \ environments.  It is thus\n   important to control access to these operations.\
    \  These are the\n   operations and their sensitivity/vulnerability:\n   o  RPC\
    \ \"resync-subscription\": This RPC allows a subscriber of an\n      on-change\
    \ subscription to request a full push of objects in the\n      subscription's\
    \ scope.  This can result in a large volume of data.\n      An attacker could\
    \ attempt to use this RPC to exhaust resources on\n      the server to generate\
    \ the data and could then attempt to\n      overwhelm a receiver with the resulting\
    \ large volume of data.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3688]  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n  \
    \            DOI 10.17487/RFC3688, January 2004,\n              <https://www.rfc-editor.org/info/rfc3688>.\n\
    \   [RFC6020]  Bjorklund, M., Ed., \"YANG - A Data Modeling Language for\n   \
    \           the Network Configuration Protocol (NETCONF)\", RFC 6020,\n      \
    \        DOI 10.17487/RFC6020, October 2010,\n              <https://www.rfc-editor.org/info/rfc6020>.\n\
    \   [RFC6991]  Schoenwaelder, J., Ed., \"Common YANG Data Types\",\n         \
    \     RFC 6991, DOI 10.17487/RFC6991, July 2013,\n              <https://www.rfc-editor.org/info/rfc6991>.\n\
    \   [RFC7950]  Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n\
    \              RFC 7950, DOI 10.17487/RFC7950, August 2016,\n              <https://www.rfc-editor.org/info/rfc7950>.\n\
    \   [RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n       \
    \       Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017,\n          \
    \    <https://www.rfc-editor.org/info/rfc8040>.\n   [RFC8072]  Bierman, A., Bjorklund,\
    \ M., and K. Watsen, \"YANG Patch\n              Media Type\", RFC 8072, DOI 10.17487/RFC8072,\n\
    \              February 2017, <https://www.rfc-editor.org/info/rfc8072>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC 2119\
    \ Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May 2017,\n\
    \              <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8341]  Bierman,\
    \ A. and M. Bjorklund, \"Network Configuration\n              Access Control Model\"\
    , STD 91, RFC 8341,\n              DOI 10.17487/RFC8341, March 2018,\n       \
    \       <https://www.rfc-editor.org/info/rfc8341>.\n   [RFC8342]  Bjorklund, M.,\
    \ Schoenwaelder, J., Shafer, P., Watsen, K.,\n              and R. Wilton, \"\
    Network Management Datastore Architecture\n              (NMDA)\", RFC 8342, DOI\
    \ 10.17487/RFC8342, March 2018,\n              <https://www.rfc-editor.org/info/rfc8342>.\n\
    \   [RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n \
    \             Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n  \
    \            <https://www.rfc-editor.org/info/rfc8446>.\n   [RFC8525]  Bierman,\
    \ A., Bjorklund, M., Schoenwaelder, J., Watsen, K.,\n              and R. Wilton,\
    \ \"YANG Library\", RFC 8525,\n              DOI 10.17487/RFC8525, March 2019,\n\
    \              <https://www.rfc-editor.org/info/rfc8525>.\n   [RFC8639]  Voit,\
    \ E., Clemm, A., Gonzalez Prieto, A., Nilsen-Nygaard,\n              E., and A.\
    \ Tripathy, \"Subscription to YANG Notifications\",\n              RFC 8639, DOI\
    \ 10.17487/RFC8639, September 2019,\n              <https://www.rfc-editor.org/info/rfc8639>.\n\
    \   [W3C.REC-xml-20081126]\n              Bray, T., Paoli, J., Sperberg-McQueen,\
    \ M., Maler, E., and\n              F. Yergeau, \"Extensible Markup Language (XML)\
    \ 1.0 (Fifth\n              Edition)\", World Wide Web Consortium Recommendation\n\
    \              REC-xml-20081126, November 2008,\n              <https://www.w3.org/TR/2008/REC-xml-20081126>.\n\
    \   [XPATH]    Clark, J. and S. DeRose, \"XML Path Language (XPath)\n        \
    \      Version 1.0\", November 1999,\n              <https://www.w3.org/TR/1999/REC-xpath-19991116>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed.,\
    \ Schoenwaelder, J., Ed.,\n              and A. Bierman, Ed., \"Network Configuration\
    \ Protocol\n              (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011,\n\
    \              <https://www.rfc-editor.org/info/rfc6241>.\n   [RFC6242]  Wasserman,\
    \ M., \"Using the NETCONF Protocol over Secure\n              Shell (SSH)\", RFC\
    \ 6242, DOI 10.17487/RFC6242, June 2011,\n              <https://www.rfc-editor.org/info/rfc6242>.\n\
    \   [RFC7923]  Voit, E., Clemm, A., and A. Gonzalez Prieto, \"Requirements\n \
    \             for Subscription to YANG Datastores\", RFC 7923,\n             \
    \ DOI 10.17487/RFC7923, June 2016,\n              <https://www.rfc-editor.org/info/rfc7923>.\n\
    \   [RFC8340]  Bjorklund, M. and L. Berger, Ed., \"YANG Tree Diagrams\",\n   \
    \           BCP 215, RFC 8340, DOI 10.17487/RFC8340, March 2018,\n           \
    \   <https://www.rfc-editor.org/info/rfc8340>.\n   [RFC8343]  Bjorklund, M., \"\
    A YANG Data Model for Interface\n              Management\", RFC 8343, DOI 10.17487/RFC8343,\
    \ March 2018,\n              <https://www.rfc-editor.org/info/rfc8343>.\n   [RFC8640]\
    \  Voit, E., Clemm, A., Gonzalez Prieto, A., Nilsen-Nygaard,\n              E.,\
    \ and A. Tripathy, \"Dynamic Subscription to YANG Events\n              and Datastores\
    \ over NETCONF\", RFC 8640,\n              DOI 10.17487/RFC8640, September 2019,\n\
    \              <https://www.rfc-editor.org/info/rfc8640>.\n   [Yang-Push-Notif-Cap]\n\
    \              Lengyel, B., Clemm, A., and B. Claise, \"Yang-Push\n          \
    \    Notification Capabilities\", Work in Progress,\n              draft-ietf-netconf-notification-capabilities-04,\n\
    \              September 2019.\n"
- title: Appendix A.  Subscription Errors
  contents:
  - 'Appendix A.  Subscription Errors

    '
- title: A.1.  RPC Failures
  contents:
  - "A.1.  RPC Failures\n   Rejection of an RPC for any reason is indicated via an\
    \ RPC error\n   response from the publisher.  Valid RPC errors returned include\
    \ both\n   (1) existing transport-layer RPC error codes, such as those seen with\n\
    \   NETCONF in [RFC6241] and (2) subscription-specific errors, such as\n   those\
    \ defined in the YANG data model.  As a result, how subscription\n   errors are\
    \ encoded in an RPC error response is transport dependent.\n   References to specific\
    \ identities in the ietf-subscribed-\n   notifications YANG module [RFC8639] or\
    \ the ietf-yang-push YANG module\n   may be returned as part of the error responses\
    \ resulting from failed\n   attempts at datastore subscription.  For errors defined\
    \ as part of\n   the ietf-subscribed-notifications YANG module, please refer to\n\
    \   [RFC8639].  The errors defined in this document, grouped per RPC, are\n  \
    \ as follows:\n      establish-subscription          modify-subscription\n   \
    \   ---------------------------     ---------------------\n       cant-exclude\
    \                    period-unsupported\n       datastore-not-subscribable   \
    \   update-too-big\n       on-change-unsupported           sync-too-big\n    \
    \   on-change-sync-unsupported      unchanging-selection\n       period-unsupported\n\
    \       update-too-big                 resync-subscription\n       sync-too-big\
    \                   ----------------------------\n       unchanging-selection\
    \            no-such-subscription-resync\n                                   \
    \    sync-too-big\n   There is one final set of transport-independent RPC error\
    \ elements\n   included in the YANG data model.  These are the four yang-data\n\
    \   structures for failed datastore subscriptions:\n   1.  yang-data \"establish-subscription-error-datastore\"\
    : This MUST be\n       returned if information identifying the reason for an RPC\
    \ error\n       has not been placed elsewhere in the transport portion of a\n\
    \       failed \"establish-subscription\" RPC response.  This MUST be sent\n \
    \      if hints are included.\n   2.  yang-data \"modify-subscription-error-datastore\"\
    : This MUST be\n       returned if information identifying the reason for an RPC\
    \ error\n       has not been placed elsewhere in the transport portion of a\n\
    \       failed \"modify-subscription\" RPC response.  This MUST be sent if\n \
    \      hints are included.\n   3.  yang-data \"sn:delete-subscription-error\"\
    : This MUST be returned\n       if information identifying the reason for an RPC\
    \ error has not\n       been placed elsewhere in the transport portion of a failed\n\
    \       \"delete-subscription\" or \"kill-subscription\" RPC response.\n   4.\
    \  yang-data \"resync-subscription-error\": This MUST be returned if\n       information\
    \ identifying the reason for an RPC error has not been\n       placed elsewhere\
    \ in the transport portion of a failed\n       \"resync-subscription\" RPC response.\n"
- title: A.2.  Failure Notifications
  contents:
  - "A.2.  Failure Notifications\n   A subscription may be unexpectedly terminated\
    \ or suspended\n   independently of any RPC or configuration operation.  In such\
    \ cases,\n   indications of such a failure MUST be provided.  To accomplish this,\n\
    \   a number of errors can be returned as part of the corresponding\n   subscription\
    \ state change notification.  For this purpose, the\n   following error identities\
    \ are introduced in this document, in\n   addition to those that were already\
    \ defined in [RFC8639]:\n   subscription-terminated        subscription-suspended\n\
    \   ---------------------------    ----------------------\n    datastore-not-subscribable\
    \     period-unsupported\n    unchanging-selection           update-too-big\n\
    \                                   synchronization-size\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   For their valuable comments, discussions, and feedback, we\
    \ wish to\n   acknowledge Tim Jenkins, Martin Bjorklund, Kent Watsen, Susan Hares,\n\
    \   Yang Geng, Peipei Guo, Michael Scharf, Guangying Zheng, Tom Petch,\n   Henk\
    \ Birkholz, Reshad Rahman, Qin Wu, Rohit Ranade, and Rob Wilton.\n"
- title: Contributors
  contents:
  - "Contributors\n   The following individuals made substantial contributions to\
    \ this\n   document and should be considered coauthors.  Their contributions\n\
    \   include information contained in the YANG module provided in\n   Section 5\
    \ of this document.\n   Alberto Gonzalez Prieto\n   Microsoft\n   Email: alberto.gonzalez@microsoft.com\n\
    \   Ambika Prasad Tripathy\n   Cisco Systems\n   Email: ambtripa@cisco.com\n \
    \  Einar Nilsen-Nygaard\n   Cisco Systems\n   Email: einarnn@cisco.com\n   Andy\
    \ Bierman\n   YumaWorks\n   Email: andy@yumaworks.com\n   Balazs Lengyel\n   Ericsson\n\
    \   Email: balazs.lengyel@ericsson.com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Alexander Clemm\n   Futurewei\n   Email: ludwig@clemm.org\n\
    \   Eric Voit\n   Cisco Systems\n   Email: evoit@cisco.com\n"
