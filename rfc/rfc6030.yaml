- contents:
  - '                Portable Symmetric Key Container (PSKC)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies a symmetric key format for the transport
    and\n   provisioning of symmetric keys to different types of crypto modules.\n
    \  For example, One-Time Password (OTP) shared secrets or symmetric\n   cryptographic
    keys to strong authentication devices.  A standard key\n   transport format enables
    enterprises to deploy best-of-breed\n   solutions combining components from different
    vendors into the same\n   infrastructure.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6030.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Key Words ..................................................4\n      1.2.
    Version Support ............................................4\n      1.3. Namespace
    Identifiers ......................................5\n           1.3.1. Defined
    Identifiers .................................5\n           1.3.2. Referenced Identifiers
    ..............................5\n   2. Terminology .....................................................6\n
    \  3. Portable Key Container Entities Overview and Relationships ......6\n   4.
    <KeyContainer> Element: The Basics ..............................8\n      4.1.
    <Key>: Embedding Keying Material and Key-Related\n           Information ................................................8\n
    \     4.2. Key Value Encoding ........................................10\n           4.2.1.
    AES Key Value Encoding .............................11\n           4.2.2. Triple-DES
    Key Value Encoding ......................11\n      4.3. Transmission of Supplementary
    Information .................12\n           4.3.1. <DeviceInfo> Element: Unique
    Device\n                  Identification .....................................13\n
    \          4.3.2. <CryptoModuleInfo> Element: CryptoModule\n                  Identification
    .....................................15\n           4.3.3. <UserId> Element: User
    Identification ..............15\n           4.3.4. <AlgorithmParameters> Element:\n
    \                 Supplementary Information for OTP and CR Algorithms 15\n      4.4.
    Transmission of Key Derivation Values .....................17\n   5. Key Policy
    .....................................................19\n      5.1. PIN Algorithm
    Definition ..................................23\n   6. Key Protection Methods
    .........................................23\n      6.1. Encryption Based on Pre-Shared
    Keys .......................24\n           6.1.1. MAC Method .........................................26\n
    \     6.2. Encryption Based on Passphrase-Based Keys .................27\n      6.3.
    Encryption Based on Asymmetric Keys .......................29\n      6.4. Padding
    of Encrypted Values for Non-Padded\n           Encryption Algorithms .....................................31\n
    \  7. Digital Signature ..............................................31\n   8.
    Bulk Provisioning ..............................................33\n   9. Extensibility
    ..................................................35\n   10. PSKC Algorithm Profile
    ........................................36\n      10.1. HOTP .....................................................36\n
    \     10.2. PIN ......................................................37\n   11.
    XML Schema ....................................................38\n   12. IANA
    Considerations ...........................................44\n      12.1. Content-Type
    Registration for 'application/pskc+xml' .....44\n      12.2. XML Schema Registration
    ..................................45\n      12.3. URN Sub-Namespace Registration
    ...........................46\n      12.4. PSKC Algorithm Profile Registry ..........................46\n
    \     12.5. PSKC Version Registry ....................................47\n      12.6.
    Key Usage Registry .......................................47\n   13. Security
    Considerations .......................................48\n      13.1. PSKC Confidentiality
    .....................................49\n      13.2. PSKC Integrity ...........................................50\n
    \     13.3. PSKC Authenticity ........................................50\n   14.
    Contributors ..................................................50\n   15. Acknowledgements
    ..............................................50\n   16. References ....................................................51\n
    \     16.1. Normative References .....................................51\n      16.2.
    Informative References ...................................52\n   Appendix A.  Use
    Cases ............................................54\n     A.1.  Online Use Cases
    ..........................................54\n       A.1.1.  Transport of Keys
    from Server to Cryptographic\n               Module ................................................54\n
    \      A.1.2.  Transport of Keys from Cryptographic Module to\n               Cryptographic
    Module ..................................54\n       A.1.3.  Transport of Keys
    from Cryptographic Module to\n               Server ................................................55\n
    \      A.1.4.  Server-to-Server Bulk Import/Export of Keys ...........55\n     A.2.
    \ Offline Use Cases .........................................55\n       A.2.1.
    \ Server-to-Server Bulk Import/Export of Keys ...........55\n   Appendix B.  Requirements
    .........................................56\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   With the increasing use of symmetric-key-based systems,
    such as\n   encryption of data at rest or systems used for strong authentication,\n
    \  such as those based on One-Time Password (OTP) and Challenge/Response\n   (CR)
    mechanisms, there is a need for vendor interoperability and a\n   standard format
    for importing and exporting (provisioning) symmetric\n   keys.  For instance,
    traditionally, vendors of authentication servers\n   and service providers have
    used proprietary formats for importing and\n   exporting these keys into their
    systems, thus making it hard to use\n   tokens from two different vendors.\n   This
    document defines a standardized XML-based key container, called\n   Portable Symmetric
    Key Container (PSKC), for transporting symmetric\n   keys and key-related metadata.
    \ The document also specifies the\n   information elements that are required when
    the symmetric key is\n   utilized for specific purposes, such as the initial counter
    in the\n   HMAC-Based One-Time Password (HOTP) [HOTP] algorithm.  It also\n   creates
    an IANA registry for algorithm profiles where algorithms,\n   their metadata and
    PSKC transmission profile can be recorded for a\n   centralized, standardized
    reference.\n"
  - contents:
    - "1.1.  Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
    title: 1.1.  Key Words
  - contents:
    - "1.2.  Version Support\n   There is a provision made in the syntax for an explicit
      version\n   number.  Only version \"1.0\" is currently specified.\n   The numbering
      scheme for PSKC versions is \"<major>.<minor>\".  The\n   major and minor numbers
      MUST be treated as separate integers and each\n   number MAY be incremented
      higher than a single digit.  Thus, \"PSKC\n   2.4\" would be a lower version
      than \"PSKC 2.13\", which in turn would\n   be lower than \"PSKC 12.3\".  Leading
      zeros (e.g., \"PSKC 6.01\") MUST be\n   ignored by recipients and MUST NOT be
      sent.\n   The major version number should be incremented only if the message\n
      \  format (e.g., element structure) has changed so dramatically that an\n   older
      version implementation would not be able to interoperate with a\n   newer version.
      \ The minor version number indicates new capabilities,\n   and it MUST be ignored
      by an entity with a smaller minor version\n   number but used for informational
      purposes by the entity with the\n   larger minor version number.\n"
    title: 1.2.  Version Support
  - contents:
    - "1.3.  Namespace Identifiers\n   This document uses Uniform Resource Identifiers
      (URIs) [RFC3986] to\n   identify resources, algorithms, and semantics.\n"
    - contents:
      - "1.3.1.  Defined Identifiers\n   The XML namespace [XMLNS] URI for Version
        1.0 of PSKC is:\n   \"urn:ietf:params:xml:ns:keyprov:pskc\"\n   References
        to qualified elements in the PSKC schema defined in this\n   specification
        and used in the example use the prefix \"pskc\" (defined\n   as xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\").
        \ It is\n   RECOMMENDED to use this namespace in implementations.\n"
      title: 1.3.1.  Defined Identifiers
    - contents:
      - "1.3.2.  Referenced Identifiers\n   The PSKC syntax presented in this document
        relies on algorithm\n   identifiers and elements defined in the XML Signature
        [XMLDSIG]\n   namespace:\n   xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
        \  References to the XML Signature namespace are represented by the\n   prefix
        \"ds\".\n   PSKC also relies on algorithm identifiers and elements defined
        in the\n   XML Encryption [XMLENC] namespace:\n   xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \  References to the XML Encryption namespace are represented by the\n   prefix
        \"xenc\".\n   When protecting keys in transport with passphrase-based keys,
        PSKC\n   also relies on the derived key element defined in the XML Encryption\n
        \  Version 1.1 [XMLENC11] namespace:\n   xmlns:xenc11=\"http://www.w3.org/2009/xmlenc11#\"\n
        \  References to the XML Encryption Version 1.1 namespace are\n   represented
        by the prefix \"xenc11\".\n   When protecting keys in transport with passphrase-based
        keys, PSKC\n   also relies on algorithm identifiers and elements defined in
        the PKCS\n   #5 [PKCS5] namespace:\n   xmlns:pkcs5=\n   \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\"\n
        \  References to the PKCS #5 namespace are represented by the prefix\n   \"pkcs5\".\n"
      title: 1.3.2.  Referenced Identifiers
    title: 1.3.  Namespace Identifiers
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   NOTE: In subsequent sections of the document, we highlight\n
    \  **mandatory** XML elements and attributes.  Optional elements and\n   attributes
    are not explicitly indicated, i.e., if it does not say\n   mandatory, it is optional.\n"
  title: 2.  Terminology
- contents:
  - "3.  Portable Key Container Entities Overview and Relationships\n   The portable
    key container is based on an XML schema definition and\n   contains the following
    main conceptual entities:\n   1.  KeyContainer entity - representing the container
    that carries a\n       number of KeyPackage entities.  A valid container MUST
    carry at\n       least one KeyPackage entity.\n   2.  KeyPackage entity - representing
    the package of at most one key\n       and its related provisioning endpoint or
    current usage endpoint,\n       such as a physical or virtual device and a specific
    CryptoModule.\n   3.  DeviceInfo entity - representing the information about the
    device\n       and criteria to identify uniquely the device.\n   4.  CryptoModuleInfo
    entity - representing the information about the\n       CryptoModule where the
    keys reside or to which they are\n       provisioned.\n   5.  Key entity - representing
    the key transported or provisioned.\n   6.  Data entity - representing a list
    of metadata related to the key,\n       where the element name is the name of
    the metadata and its\n       associated value is either in encrypted (for example,
    for <Data>\n       element <Secret>) or plaintext (for example, the <Data> element\n
    \      <Counter>) form.\n   Figure 1 shows the high-level structure of the PSKC
    data elements.\n      -----------------\n      | KeyContainer  |\n      |---------------|\n
    \     | EncryptionKey |\n      | Signature     |\n      | ...           |\n      -----------------\n
    \             |\n              |\n             /|\\ 1..n\n      ----------------
    \       ----------------\n      | KeyPackage   |    0..1| DeviceInfo   |\n      |--------------|--------|--------------|\n
    \     |              |--      | SerialNumber |\n      ----------------  |     |
    Manufacturer |\n              |         |     | ....         |\n              |
    \        |     ----------------\n             /|\\ 0..1   |\n      ----------------
    \ |     --------------------\n      | Key          |  | 0..1| CryptoModuleInfo
    |\n      |--------------|   -----|------------------|\n      | Id           |
    \       | Id               |\n      | Algorithm    |        |....              |\n
    \     | UserId       |        --------------------\n      | Policy       |\n      |
    ....         |\n      ----------------\n              |\n              |\n             /|\\
    0..n\n          --------------------------------------- -  -\n          |                     |
    \             |\n      ------------------  ----------------  -------- - -\n      |
    Data:Secret    |  | Data:Counter |  | Data:other\n      |----------------|  |--------------|
    \ |-- - -\n      | EncryptedValue |  | PlainValue   |\n      | ValueMAC       |
    \ ----------------\n      ------------------\n             Figure 1: PSKC Data
    Elements Relationship Diagram\n   The following sections describe in detail all
    the entities and\n   related XML schema elements and attributes.\n"
  title: 3.  Portable Key Container Entities Overview and Relationships
- contents:
  - "4.  <KeyContainer> Element: The Basics\n   In its most basic form, a PSKC document
    uses the top-level element\n   <KeyContainer> and a single <KeyPackage> element
    to carry key\n   information.\n   The following example shows a simple PSKC document.
    \ We will use it\n   to describe the structure of the <KeyContainer> element and
    its child\n   elements.\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <KeyContainer
    Version=\"1.0\"\n       Id=\"exampleID1\"\n       xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\">\n
    \      <KeyPackage>\n           <Key Id=\"12345678\"\n               Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
    \              <Issuer>Issuer-A</Issuer>\n               <Data>\n                   <Secret>\n
    \                      <PlainValue>MTIzNA==\n                       </PlainValue>\n
    \                  </Secret>\n               </Data>\n           </Key>\n       </KeyPackage>\n
    \  </KeyContainer>\n                Figure 2: Basic PSKC Key Container Example\n
    \  The attributes of the <KeyContainer> element have the following\n   semantics:\n
    \  'Version':  The 'Version' attribute is used to identify the version\n      of
    the PSKC schema version.  This specification defines the\n      initial version
    (\"1.0\") of the PSKC schema.  This attribute MUST\n      be included.\n   'Id':
    \ The 'Id' attribute carries a unique identifier for the\n      container.  As
    such, it helps to identify a specific key container\n      in cases in which multiple
    containers are embedded in larger XML\n      documents.\n"
  - contents:
    - "4.1.  <Key>: Embedding Keying Material and Key-Related Information\n   The
      following attributes of the <Key> element MUST be included at a\n   minimum:\n
      \  'Id':  This attribute carries a unique identifier for the symmetric\n      key
      in the context of key provisioning exchanges between two\n      parties.  This
      means that if PSKC is used in multiple interactions\n      between a sending
      and receiving party, using different containers\n      referencing the same
      keys, the 'Id' attribute of <Key> MUST use\n      the same value (e.g., after
      initial provisioning, if a system\n      wants to update key metadata values
      in the other system, the value\n      of the 'Id' attribute of the <Key> where
      the metadata is to be\n      updated MUST be the same of the original 'Id' attribute
      value\n      provisioned).  The identifier is defined as a string of\n      alphanumeric
      characters.\n   'Algorithm':  This attribute contains a unique identifier for
      the\n      PSKC algorithm profile.  This profile associates specific\n      semantics
      to the elements and attributes contained in the <Key>\n      element.  This
      document describes profiles for open standards\n      algorithms in Section
      10.  Additional profiles are defined in the\n      following informative document:
      [PSKC-ALGORITHM-PROFILES].\n   The <Key> element has a number of optional child
      elements.  An\n   initial set is described below:\n   <Issuer>:  This element
      represents the name of the party that issued\n      the key.  For example, a
      bank \"Foobar Bank, Inc.\" issuing hardware\n      tokens to their retail banking
      users may set this element to\n      'Foobar Bank, Inc.'.\n   <FriendlyName>:
      \ A human-readable name for the secret key for easier\n      reference.  This
      element serves informational purposes only.  This\n      element is a language-dependent
      string; hence, it SHOULD have an\n      attribute xml:lang=\"xx\" where xx is
      the language identifier as\n      specified in [RFC5646].  If no xml:lang attribute
      is present,\n      implementations MUST assume the language to be English as
      defined\n      by setting the attribute value to 'en' (e.g., xml:lang=\"en\").\n
      \  <AlgorithmParameters>:  This element carries parameters that\n      influence
      the result of the algorithmic computation, for example,\n      response truncation
      and format in OTP and CR algorithms.  A more\n      detailed discussion of the
      element can be found in Section 4.3.4.\n   <Data>:  This element carries data
      about and related to the key.  The\n      following child elements are defined
      for the <Data> element:\n      <Secret>:  This element carries the value of
      the key itself in a\n         binary representation.  Please see Section 4.2
      for more details\n         on Key Value Encoding.\n      <Counter>:  This element
      contains the event counter for event-\n         based OTP algorithms.\n      <Time>:
      \ This element contains the time for time-based OTP\n         algorithms.  (If
      time intervals are used, this element carries\n         the number of time intervals
      passed from a specific start\n         point, normally it is algorithm dependent).\n
      \     <TimeInterval>:  This element carries the time interval value for\n         time-based
      OTP algorithms in seconds (a typical value for this\n         would be 30, indicating
      a time interval of 30 seconds).\n      <TimeDrift>:  This element contains the
      device clock drift value\n         for time-based OTP algorithms.  The integer
      value (positive or\n         negative drift) that indicates the number of time
      intervals\n         that a validation server has established the device clock\n
      \        drifted after the last successful authentication.  So, for\n         example,
      if the last successful authentication established a\n         device time value
      of 8 intervals from a specific start date but\n         the validation server
      determines the time value at 9 intervals,\n         the server SHOULD record
      the drift as -1.\n      All the elements listed above (and those defined in
      the future)\n      obey a simple structure in that they MUST support child elements\n
      \     to convey the data value in either plaintext or encrypted format:\n      Plaintext:
      \ The <PlainValue> element carries a plaintext value\n         that is typed,
      for example, to xs:integer.\n      Encrypted:  The <EncryptedValue> element
      carries an encrypted\n         value.\n      ValueMAC:  The <ValueMAC> element
      is populated with a Message\n         Authentication Code (MAC) generated from
      the encrypted value in\n         case the encryption algorithm does not support
      integrity\n         checks.  The example shown in Figure 2 illustrates the usage
      of\n         the <Data> element with two child elements, namely <Secret> and\n
      \        <Counter>.  Both elements carry a plaintext value within the\n         <PlainValue>
      child element.\n"
    title: '4.1.  <Key>: Embedding Keying Material and Key-Related Information'
  - contents:
    - "4.2.  Key Value Encoding\n   Two parties receiving the same key value OCTET
      STRING, resulting in\n   decoding the xs:base64Binary, inside the <PlainValue>
      or\n   <EncryptedValue> elements, must make use of the key in exactly the\n
      \  same way in order to interoperate.  To ensure that, it is necessary\n   to
      define a correspondence between the OCTET STRING and the notation\n   in the
      standard algorithm description that defines how the key is\n   used.  The next
      sections establish that correspondence for the AES\n   algorithm [FIPS197] and
      the Triple Data Encryption Algorithm (TDEA or\n   Triple DES) [SP800-67].  Unless
      otherwise specified for a specific\n   algorithm, the OCTET STRING encoding
      MUST follow the AES Key Value\n   Encoding.\n"
    - contents:
      - "4.2.1.  AES Key Value Encoding\n   [FIPS197], Section 5.2, titled \"Key Expansion\",
        uses the input key as\n   an array of bytes indexed starting at 0.  The first
        octet of the\n   OCTET STRING SHALL become the key byte in the AES, labeled
        index 0 in\n   [FIPS197]; the succeeding octets of the OCTET STRING SHALL
        become key\n   bytes in AES, in increasing index order.\n   Proper parsing
        and key load of the contents of the OCTET STRING for\n   AES SHALL be determined
        by using the following value for the\n   <PlainValue> element (binaryBase64-encoded)
        to generate and match the\n   key expansion test vectors in [FIPS197], Appendix
        A, for AES\n   Cipher Key: 2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c\n
        \  ...\n    <PlainValue>K34VFiiu0qar9xWICc9PPA==</PlainValue>\n   ...\n"
      title: 4.2.1.  AES Key Value Encoding
    - contents:
      - "4.2.2.  Triple-DES Key Value Encoding\n   A Triple-DES key consists of three
        keys for the cryptographic engine\n   (Key1, Key2, and Key3) that are each
        64 bits (56 key bits and 8\n   parity bits); the three keys are also collectively
        referred to as a\n   key bundle [SP800-67].  A key bundle may employ either
        two or three\n   independent keys.  When only two independent keys are employed\n
        \  (called two-key Triple DES), the same value is used for Key1 and\n   Key3.\n
        \  Each key in a Triple-DES key bundle is expanded into a key schedule\n   according
        to a procedure defined in [SP800-67], Appendix A.  That\n   procedure numbers
        the bits in the key from 1 to 64, with number 1\n   being the leftmost, or
        most significant bit (MSB).  The first octet\n   of the OCTET STRING SHALL
        be bits 1 through 8 of Key1 with bit 1\n   being the MSB.  The second octet
        of the OCTET STRING SHALL be bits 9\n   through 16 of Key1, and so forth,
        so that the trailing octet of the\n   OCTET STRING SHALL be bits 57 through
        64 of Key3 (or Key2 for two-key\n   Triple DES).\n   Proper parsing and key
        load of the contents of the OCTET STRING for\n   Triple DES SHALL be determined
        by using the following <PlainValue>\n   element (binaryBase64-encoded) to
        generate and match the key\n   expansion test vectors in [SP800-67], Appendix
        B, for the key bundle:\n   Key1 = 0123456789ABCDEF\n   Key2 = 23456789ABCDEF01\n
        \  Key3 = 456789ABCDEF0123\n   ...\n    <PlainValue>ASNFZ4mrze8jRWeJq83vAUVniavN7wEj</PlainValue>\n
        \  ...\n"
      title: 4.2.2.  Triple-DES Key Value Encoding
    title: 4.2.  Key Value Encoding
  - contents:
    - "4.3.  Transmission of Supplementary Information\n   A PSKC document can contain
      a number of additional information\n   regarding device identification, cryptographic
      module identification,\n   user identification, and parameters for usage with
      OTP and CR\n   algorithms.  The following example, see Figure 3, is used as
      a\n   reference for the subsequent sub-sections.\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n
      \  <KeyContainer Version=\"1.0\"\n       Id=\"exampleID1\"\n       xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\">\n
      \      <KeyPackage>\n           <DeviceInfo>\n               <Manufacturer>Manufacturer</Manufacturer>\n
      \              <SerialNo>987654321</SerialNo>\n               <UserId>DC=example-bank,DC=net</UserId>\n
      \          </DeviceInfo>\n           <CryptoModuleInfo>\n               <Id>CM_ID_001</Id>\n
      \          </CryptoModuleInfo>\n           <Key Id=\"12345678\"\n               Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
      \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
      \                  <ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
      \              <Data>\n                   <Secret>\n                       <PlainValue>MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=\n
      \                      </PlainValue>\n                   </Secret>\n                   <Counter>\n
      \                      <PlainValue>0</PlainValue>\n                   </Counter>\n
      \              </Data>\n               <UserId>UID=jsmith,DC=example-bank,DC=net</UserId>\n
      \          </Key>\n       </KeyPackage>\n   </KeyContainer>\n       Figure 3:
      PSKC Key Container Example with Supplementary Data\n"
    - contents:
      - "4.3.1.  <DeviceInfo> Element: Unique Device Identification\n   The <DeviceInfo>
        element uniquely identifies the device to which the\n   <KeyPackage> is provisioned.
        \ Since devices can come in different\n   form factors, such as hardware tokens,
        smart-cards, soft tokens in a\n   mobile phone, or as a PC, this element allows
        different child element\n   combinations to be used.  When combined, the values
        of the child\n   elements MUST uniquely identify the device.  For example,
        for\n   hardware tokens, the combination of <SerialNo> and <Manufacturer>\n
        \  elements uniquely identifies a device, but the <SerialNo> element\n   alone
        is insufficient since two different token manufacturers might\n   issue devices
        with the same serial number (similar to the Issuer\n   Distinguished Name
        and serial number of a certificate).\n   The <DeviceInfo> element has the
        following child elements:\n   <Manufacturer>:  This element indicates the
        manufacturer of the\n      device.  Values for the <Manufacturer> element
        MUST be taken from\n      either [OATHMAN] prefixes (i.e., the left column)
        or from the IANA\n      Private Enterprise Number Registry [IANAPENREG], using
        the\n      Organization value.  When the value is taken from [OATHMAN],\n
        \     \"oath.\"  MUST be prepended to the value (e.g., \"oath.<prefix value\n
        \     from [OATHMAN]>\").  When the value is taken from [IANAPENREG],\n      \"iana.\"
        \ MUST be prepended to the value (e.g., \"iana.<Organization\n      value
        from [IANAPENREG]>\").\n   <SerialNo>:  This element contains the serial number
        of the device.\n   <Model>:  This element describes the model of the device
        (e.g., one-\n      button-HOTP-token-V1).\n   <IssueNo>:  This element contains
        the issue number in case there are\n      devices with the same serial number
        so that they can be\n      distinguished by different issue numbers.\n   <DeviceBinding>:
        \ This element allows a provisioning server to ensure\n      that the key
        is going to be loaded into the device for which the\n      key provisioning
        request was approved.  The device is bound to the\n      request using a device
        identifier, e.g., an International Mobile\n      Equipment Identity (IMEI)
        for the phone, or an identifier for a\n      class of identifiers, e.g., those
        for which the keys are protected\n      by a Trusted Platform Module (TPM).\n
        \  <StartDate> and <ExpiryDate>:  These two elements indicate the start\n
        \     and end date of a device (such as the one on a payment card, used\n
        \     when issue numbers are not printed on cards).  The date MUST be\n      expressed
        as a dateTime value in \"canonical representation\"\n      [W3C.REC-xmlschema-2-20041028].
        \ Implementations SHOULD NOT rely\n      on time resolution finer than milliseconds
        and MUST NOT generate\n      time instants that specify leap seconds.  Keys
        that reside on the\n      device SHOULD only be used when the current date
        is after the\n      <StartDate> and before the <ExpiryDate>.  Note that usage\n
        \     enforcement of the keys with respect to the dates MAY only happen\n
        \     on the validation server, as some devices such as smart cards do\n      not
        have an internal clock.  Systems thus SHOULD NOT rely upon the\n      device
        to enforce key usage date restrictions.\n   Depending on the device type,
        certain child elements of the\n   <DeviceInfo> element MUST be included in
        order to uniquely identify a\n   device.  This document does not enumerate
        the different device types\n   and therefore does not list the elements that
        are mandatory for each\n   type of device.\n"
      title: '4.3.1.  <DeviceInfo> Element: Unique Device Identification'
    - contents:
      - "4.3.2.  <CryptoModuleInfo> Element: CryptoModule Identification\n   The <CryptoModuleInfo>
        element identifies the cryptographic module to\n   which the symmetric keys
        are or have been provisioned.  This allows\n   the identification of the specific
        cases where a device MAY contain\n   more than one crypto module (e.g., a
        PC hosting a TPM and a connected\n   token).\n   The <CryptoModuleInfo> element
        has a single child element that MUST\n   be included:\n   <Id>:  This element
        carries a unique identifier for the CryptoModule\n      and is implementation
        specific.  As such, it helps to identify a\n      specific CryptoModule to
        which the key is being or was\n      provisioned.\n"
      title: '4.3.2.  <CryptoModuleInfo> Element: CryptoModule Identification'
    - contents:
      - "4.3.3.  <UserId> Element: User Identification\n   The <UserId> element identifies
        the user of a distinguished name, as\n   defined in [RFC4514], for example,
        UID=jsmith,DC=example,DC=net.\n   Although the syntax of the user identifier
        is defined, there are no\n   semantics associated with this element, i.e.,
        there are no checks\n   enforcing that only a specific user can use this key.
        \ As such, this\n   element is for informational purposes only.\n   This element
        may appear in two places, namely as a child element of\n   the <Key> element,
        where it indicates the user with whom the key is\n   associated, and as a
        child element of the <DeviceInfo> element, where\n   it indicates the user
        with whom the device is associated.\n"
      title: '4.3.3.  <UserId> Element: User Identification'
    - contents:
      - "4.3.4.  <AlgorithmParameters> Element: Supplementary Information for OTP\n
        \       and CR Algorithms\n   The <AlgorithmParameters> element is a child
        element of the <Key>\n   element, and this document defines three child elements:
        <Suite>,\n   <ChallengeFormat>, and <ResponseFormat>.\n   <Suite>:\n      The
        optional <Suite> element defines additional characteristics of\n      the
        algorithm used, which are algorithm specific.  For example, in\n      an HMAC-based
        (Hashed MAC) OTP algorithm, it could designate the\n      strength of the
        hash algorithm used (SHA1, SHA256, etc.).  Please\n      refer to the algorithm
        profile section, Section 10, for the exact\n      semantics of the value for
        each algorithm profile.\n   <ChallengeFormat>:\n      The <ChallengeFormat>
        element defines the characteristics of the\n      challenge in a CR usage
        scenario whereby the following attributes\n      are defined:\n      'Encoding':
        \ This attribute, which MUST be included, defines the\n         encoding of
        the challenge accepted by the device and MUST be\n         one of the following
        values:\n         DECIMAL:  Only numerical digits\n         HEXADECIMAL:  Hexadecimal
        response\n         ALPHANUMERIC:  All letters and numbers (case sensitive)\n
        \        BASE64:  Base-64 encoded, as defined in Section 4 of [RFC4648]\n
        \        BINARY:  Binary data\n      'CheckDigit':  This attribute indicates
        whether a device needs to\n         check the appended Luhn check digit, as
        defined in\n         [ISOIEC7812], contained in a challenge.  This is only
        valid if\n         the 'Encoding' attribute is set to 'DECIMAL'.  A value
        of TRUE\n         indicates that the device will check the appended Luhn check\n
        \        digit in a provided challenge.  A value of FALSE indicates that\n
        \        the device will not check the appended Luhn check digit in the\n
        \        challenge.\n      'Min':  This attribute defines the minimum size
        of the challenge\n         accepted by the device for CR mode and MUST be
        included.  If\n         the 'Encoding' attribute is set to 'DECIMAL', 'HEXADECIMAL',
        or\n         'ALPHANUMERIC', this value indicates the minimum number of\n
        \        digits/characters.  If the 'Encoding' attribute is set to\n         'BASE64'
        or 'BINARY', this value indicates the minimum number\n         of bytes of
        the unencoded value.\n      'Max':  This attribute defines the maximum size
        of the challenge\n         accepted by the device for CR mode and MUST be
        included.  If\n         the 'Encoding' attribute is set to 'DECIMAL', 'HEXADECIMAL',
        or\n         'ALPHANUMERIC', this value indicates the maximum number of\n
        \        digits/characters.  If the 'Encoding' attribute is set to\n         'BASE64'
        or 'BINARY', this value indicates the maximum number\n         of bytes of
        the unencoded value.\n   <ResponseFormat>:\n      The <ResponseFormat> element
        defines the characteristics of the\n      result of a computation and defines
        the format of the OTP or the\n      response to a challenge.  For cases in
        which the key is a PIN\n      value, this element contains the format of the
        PIN itself (e.g.,\n      DECIMAL, length 4 for a 4-digit PIN).  The following
        attributes\n      are defined:\n      'Encoding':  This attribute defines
        the encoding of the response\n         generated by the device, it MUST be
        included and MUST be one of\n         the following values: DECIMAL, HEXADECIMAL,
        ALPHANUMERIC,\n         BASE64, or BINARY.\n      'CheckDigit':  This attribute
        indicates whether the device needs\n         to append a Luhn check digit,
        as defined in [ISOIEC7812], to\n         the response.  This is only valid
        if the 'Encoding' attribute\n         is set to 'DECIMAL'.  If the value is
        TRUE, then the device\n         will append a Luhn check digit to the response.
        \ If the value\n         is FALSE, then the device will not append a Luhn
        check digit to\n         the response.\n      'Length':  This attribute defines
        the length of the response\n         generated by the device and MUST be included.
        \ If the\n         'Encoding' attribute is set to 'DECIMAL', 'HEXADECIMAL',
        or\n         ALPHANUMERIC, this value indicates the number of digits/\n         characters.
        \ If the 'Encoding' attribute is set to 'BASE64' or\n         'BINARY', this
        value indicates the number of bytes of the\n         unencoded value.\n"
      title: '4.3.4.  <AlgorithmParameters> Element: Supplementary Information for
        OTP'
    title: 4.3.  Transmission of Supplementary Information
  - contents:
    - "4.4.  Transmission of Key Derivation Values\n   <KeyProfileId> element, which
      is a child element of the <Key>\n   element, carries a unique identifier used
      between the sending and\n   receiving parties to establish a set of key attribute
      values that are\n   not transmitted within the container but are agreed upon
      between the\n   two parties out of band.  This element will then represent the
      unique\n   reference to a set of key attribute values.  (For example, a smart\n
      \  card application personalization profile id related to specific\n   attribute
      values present on a smart card application that have\n   influence when computing
      a response).\n   For example, in the case of MasterCard's Chip Authentication
      Program\n   [CAP], the sending and the receiving party would agree that\n   KeyProfileId='1'
      represents a certain set of values (e.g., Internet\n   Authentication Flag (IAF)
      set to a specific value).  During\n   transmission of the <KeyContainer>, these
      values would not be\n   transmitted as key attributes but would only be referred
      to via the\n   <KeyProfileId> element set to the specific agreed-upon profile
      (in\n   this case '1').  The receiving party can then associate all relevant\n
      \  key attributes contained in the profile that was agreed upon out of\n   band
      with the imported keys.  Often, this methodology is used between\n   a manufacturing
      service, run by company A, and the validation\n   service, run by company B,
      to avoid repeated transmission of the same\n   set of key attribute values.\n
      \  The <KeyReference> element contains a reference to an external key to\n   be
      used with a key derivation scheme.  In this case, the parent <Key>\n   element
      will not contain the <Secret> subelement of <Data>, in which\n   the key value
      (secret) is transported; only the reference to the\n   external master key is
      transported (e.g., a PKCS #11 key label).\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n
      \  <KeyContainer Version=\"1.0\" Id=\"exampleID1\"\n        xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\">\n
      \      <KeyPackage>\n           <DeviceInfo>\n               <Manufacturer>Manufacturer</Manufacturer>\n
      \              <SerialNo>987654321</SerialNo>\n           </DeviceInfo>\n           <CryptoModuleInfo>\n
      \              <Id>CM_ID_001</Id>\n           </CryptoModuleInfo>\n           <Key
      Id=\"12345678\"\n            Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
      \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
      \                  <ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
      \              <KeyProfileId>keyProfile1</KeyProfileId>\n               <KeyReference>MasterKeyLabel\n
      \              </KeyReference>\n               <Data>\n                   <Counter>\n
      \                      <PlainValue>0</PlainValue>\n                   </Counter>\n
      \              </Data>\n               <Policy>\n                   <KeyUsage>OTP</KeyUsage>\n
      \              </Policy>\n           </Key>\n       </KeyPackage>\n   </KeyContainer>\n
      \  Figure 4: Example of a PSKC Document Transmitting an HOTP Key via Key\n                             Derivation
      Values\n   The key value will be derived using the value of the <SerialNo>\n
      \  element, values agreed upon between the sending and the receiving\n   parties
      and identified by the <KeyProfile> 'keyProfile1', and an\n   externally agreed-upon
      key referenced by the label 'MasterKeyLabel'.\n"
    title: 4.4.  Transmission of Key Derivation Values
  title: '4.  <KeyContainer> Element: The Basics'
- contents:
  - "5.  Key Policy\n   This section illustrates the functionality of the <Policy>
    element\n   within PSKC, which allows a key usage and key PIN protection policy\n
    \  to be attached to a specific key and its related metadata.  This\n   element
    is a child element of the <Key> element.\n   If the <Policy> element contains
    child elements or values within\n   elements/attributes that are not understood
    by the recipient of the\n   PSKC document, then the recipient MUST assume that
    key usage is not\n   permitted.  This statement ensures that the lack of understanding
    of\n   certain extensions does not lead to unintended key usage.\n   We will start
    our description with an example that expands the\n   example shown in Figure 3.\n
    \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <KeyContainer\n       Version=\"1.0\"
    Id=\"exampleID1\"\n       xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\">\n       <KeyPackage>\n
    \          <DeviceInfo>\n               <Manufacturer>Manufacturer</Manufacturer>\n
    \              <SerialNo>987654321</SerialNo>\n           </DeviceInfo>\n           <CryptoModuleInfo>\n
    \              <Id>CM_ID_001</Id>\n           </CryptoModuleInfo>\n           <Key
    Id=\"12345678\"\n               Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
    \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
    \                  <ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
    \              <Data>\n                   <Secret>\n                       <PlainValue>MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=\n
    \                      </PlainValue>\n                   </Secret>\n                   <Counter>\n
    \                      <PlainValue>0</PlainValue>\n                   </Counter>\n
    \              </Data>\n               <Policy>\n                   <PINPolicy
    MinLength=\"4\" MaxLength=\"4\"\n                       PINKeyId=\"123456781\"
    PINEncoding=\"DECIMAL\"\n                       PINUsageMode=\"Local\"/>\n                   <KeyUsage>OTP</KeyUsage>\n
    \              </Policy>\n           </Key>\n       </KeyPackage>\n       <KeyPackage>\n
    \          <DeviceInfo>\n               <Manufacturer>Manufacturer</Manufacturer>\n
    \              <SerialNo>987654321</SerialNo>\n           </DeviceInfo>\n           <CryptoModuleInfo>\n
    \              <Id>CM_ID_001</Id>\n           </CryptoModuleInfo>\n           <Key
    Id=\"123456781\"\n               Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:pin\">\n
    \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
    \                  <ResponseFormat Length=\"4\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
    \              <Data>\n                   <Secret>\n                       <PlainValue>MTIzNA==</PlainValue>\n
    \                  </Secret>\n               </Data>\n           </Key>\n       </KeyPackage>\n
    \  </KeyContainer>\n         Figure 5: Non-Encrypted HOTP Secret Key Protected
    by PIN\n   This document defines the following <Policy> child elements:\n   <StartDate>
    and <ExpiryDate>:  These two elements denote the validity\n      period of a key.
    \ It MUST be ensured that the key is only used\n      between the start and the
    end date (inclusive).  The date MUST be\n      expressed as a dateTime value in
    \"canonical representation\"\n      [W3C.REC-xmlschema-2-20041028].  Implementations
    SHOULD NOT rely\n      on time resolution finer than milliseconds and MUST NOT
    generate\n      time instants that specify leap seconds.  When this element is\n
    \     absent, the current time is assumed as the start time.\n   <NumberOfTransactions>:
    \ The value in this element indicates the\n      maximum number of times a key
    carried within the PSKC document can\n      be used by an application after having
    received it.  When this\n      element is omitted, there is no restriction regarding
    the number\n      of times a key can be used.\n   <KeyUsage>:  The <KeyUsage>
    element puts constraints on the intended\n      usage of the key.  The recipient
    of the PSKC document MUST enforce\n      the key usage.  Currently, the following
    tokens are registered by\n      this document:\n      OTP:  The key MUST only
    be used for OTP generation.\n      CR:  The key MUST only be used for Challenge/Response
    purposes.\n      Encrypt:  The key MUST only be used for data encryption purposes.\n
    \     Integrity:  The key MUST only be used to generate a keyed message\n         digest
    for data integrity or authentication purposes.\n      Verify:  The key MUST only
    be used to verify a keyed message\n         digest for data integrity or authentication
    purposes (this is\n         the opposite key usage of 'Integrity').\n      Unlock:
    \ The key MUST only be used for an inverse Challenge/\n         Response in the
    case where a user has locked the device by\n         entering a wrong PIN too
    many times (for devices with PIN-input\n         capability).\n      Decrypt:
    \ The key MUST only be used for data decryption purposes.\n      KeyWrap:  The
    key MUST only be used for key wrap purposes.\n      Unwrap:  The key MUST only
    be used for key unwrap purposes.\n      Derive:  The key MUST only be used with
    a key derivation function\n         to derive a new key (see also Section 8.2.4
    of [NIST800-57]).\n      Generate:  The key MUST only be used to generate a new
    key based\n         on a random number and the previous value of the key (see
    also\n         Section 8.1.5.2.1 of [NIST800-57]).\n      The element MAY also
    be repeated to allow several key usages to be\n      expressed.  When this element
    is absent, no key usage constraint\n      is assumed, i.e., the key MAY be utilized
    for every usage.\n   <PINPolicy>:  The <PINPolicy> element allows policy about
    the PIN\n      usage to be associated with the key.  The following attributes
    are\n      specified:\n      'PINKeyId':  This attribute carries the unique 'Id'
    attribute vale\n         of the <Key> element held within this <KeyContainer>
    that\n         contains the value of the PIN that protects the key.\n      'PINUsageMode':
    \ This mandatory attribute indicates the way the\n         PIN is used during
    the usage of the key.  The following values\n         are defined:\n         Local:
    \ This value indicates that the PIN is checked locally on\n            the device
    before allowing the key to be used in executing\n            the algorithm.\n
    \        Prepend:  This value indicates that the PIN is prepended to the\n            algorithm
    response; hence, it MUST be checked by the party\n            validating the response.\n
    \        Append:  This value indicates that the PIN is appended to the\n            algorithm
    response; hence, it MUST be checked by the party\n            validating the response.\n
    \        Algorithmic:  This value indicates that the PIN is used as part\n            of
    the algorithm computation.\n      'MaxFailedAttempts':  This attribute indicates
    the maximum number\n         of times the PIN may be entered wrongly before it
    MUST NOT be\n         possible to use the key anymore (typical reasonable values
    are\n         in the positive integer range of at least 2 and no more than\n         10).\n
    \     'MinLength':  This attribute indicates the minimum length of a PIN\n         that
    can be set to protect the associated key.  It MUST NOT be\n         possible to
    set a PIN shorter than this value.  If the\n         'PINFormat' attribute is
    set to 'DECIMAL', 'HEXADECIMAL', or\n         'ALPHANUMERIC', this value indicates
    the number of digits/\n         characters.  If the 'PINFormat' attribute is set
    to 'BASE64' or\n         'BINARY', this value indicates the number of bytes of
    the\n         unencoded value.\n      'MaxLength':  This attribute indicates the
    maximum length of a PIN\n         that can be set to protect this key.  It MUST
    NOT be possible\n         to set a PIN longer than this value.  If the 'PINFormat'\n
    \        attribute is set to 'DECIMAL', 'HEXADECIMAL', or\n         'ALPHANUMERIC',
    this value indicates the number of digits/\n         characters.  If the 'PINFormat'
    attribute is set to 'BASE64' or\n         'BINARY', this value indicates the number
    of bytes of the\n         unencoded value.\n      'PINEncoding':  This attribute
    indicates the encoding of the PIN\n         and MUST be one of the values: DECIMAL,
    HEXADECIMAL,\n         ALPHANUMERIC, BASE64, or BINARY.\n      If the 'PinUsageMode'
    attribute is set to 'Local', then the device\n      MUST enforce the restriction
    indicated in the 'MaxFailedAttempts',\n      'MinLength', 'MaxLength', and 'PINEncoding'
    attributes; otherwise,\n      it MUST be enforced on the server side.\n"
  - contents:
    - "5.1.  PIN Algorithm Definition\n   The PIN algorithm is defined as:\n   boolean
      = comparePIN(K,P)\n   Where:\n      'K' is the stored symmetric credential (PIN)
      in binary format.\n      'P' is the proposed PIN to be compared in binary format.\n
      \  The function comparePIN is a straight octet comparison of K and P.\n   Such
      a comparison MUST yield a value of TRUE (credentials matched)\n   when the octet
      length of K is the same as the octet length of P and\n   all octets comprising
      K are the same as the octets comprising P.\n"
    title: 5.1.  PIN Algorithm Definition
  title: 5.  Key Policy
- contents:
  - "6.  Key Protection Methods\n   With the functionality described in the previous
    sections,\n   information related to keys had to be transmitted in cleartext.
    \ With\n   the help of the <EncryptionKey> element, which is a child element of\n
    \  the <KeyContainer> element, it is possible to encrypt keys and\n   associated
    information.  The level of encryption is applied to the\n   value of individual
    elements and the applied encryption algorithm\n   MUST be the same for all encrypted
    elements.  Keys are protected\n   using the following methods: pre-shared keys,
    passphrase-based keys,\n   and asymmetric keys.  When encryption algorithms are
    used that make\n   use of Initialization Vectors (IVs), for example, AES-128-CBC,
    a\n   random IV value MUST be generated for each value to be encrypted and\n   it
    MUST be prepended to the resulting encrypted value as specified in\n   [XMLENC].\n"
  - contents:
    - "6.1.  Encryption Based on Pre-Shared Keys\n   Figure 6 shows an example that
      illustrates the encryption of the\n   content of the <Secret> element using
      AES-128-CBC and PKCS #5\n   Padding.  The plaintext value of <Secret> is\n   '3132333435363738393031323334353637383930'.
      \ The name of the pre-\n   shared secret is \"Pre-shared-key\", as set in the
      <KeyName> element\n   (which is a child element of the <EncryptionKey> element).
      \ The value\n   of the encryption key used is '12345678901234567890123456789012'.\n
      \  The IV for the MAC key is '11223344556677889900112233445566', and the\n   IV
      for the HOTP key is '000102030405060708090a0b0c0d0e0f'.\n   As AES-128-CBC does
      not provide integrity checks, a keyed MAC is\n   applied to the encrypted value
      using a MAC key and a MAC algorithm as\n   declared in the <MACMethod> element
      (in our example,\n   \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\" is used
      as the\n   algorithm and the value of the MAC key is randomly generated, in
      our\n   case '1122334455667788990011223344556677889900', and encrypted with\n
      \  the above encryption key).  The result of the keyed-MAC computation\n   is
      placed in the <ValueMAC> child element of <Secret>.\n <?xml version=\"1.0\"
      encoding=\"UTF-8\"?>\n <KeyContainer Version=\"1.0\"\n     xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
      \    xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n     xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\">\n
      \    <EncryptionKey>\n         <ds:KeyName>Pre-shared-key</ds:KeyName>\n     </EncryptionKey>\n
      \    <MACMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#hmac-sha1\">\n
      \        <MACKey>\n             <xenc:EncryptionMethod\n             Algorithm=\"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n
      \            <xenc:CipherData>\n                 <xenc:CipherValue>\n     ESIzRFVmd4iZABEiM0RVZgKn6WjLaTC1sbeBMSvIhRejN9vJa2BOlSaMrR7I5wSX\n
      \                </xenc:CipherValue>\n             </xenc:CipherData>\n         </MACKey>\n
      \    </MACMethod>\n     <KeyPackage>\n         <DeviceInfo>\n             <Manufacturer>Manufacturer</Manufacturer>\n
      \            <SerialNo>987654321</SerialNo>\n         </DeviceInfo>\n         <CryptoModuleInfo>\n
      \            <Id>CM_ID_001</Id>\n         </CryptoModuleInfo>\n         <Key
      Id=\"12345678\"\n             Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
      \            <Issuer>Issuer</Issuer>\n             <AlgorithmParameters>\n                 <ResponseFormat
      Length=\"8\" Encoding=\"DECIMAL\"/>\n             </AlgorithmParameters>\n             <Data>\n
      \                <Secret>\n                     <EncryptedValue>\n                         <xenc:EncryptionMethod\n
      \            Algorithm=\"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n                         <xenc:CipherData>\n
      \                            <xenc:CipherValue>\n     AAECAwQFBgcICQoLDA0OD+cIHItlB3Wra1DUpxVvOx2lef1VmNPCMl8jwZqIUqGv\n
      \                            </xenc:CipherValue>\n                         </xenc:CipherData>\n
      \                    </EncryptedValue>\n                     <ValueMAC>Su+NvtQfmvfJzF6bmQiJqoLRExc=\n
      \                    </ValueMAC>\n                 </Secret>\n                 <Counter>\n
      \                    <PlainValue>0</PlainValue>\n                 </Counter>\n
      \            </Data>\n         </Key>\n     </KeyPackage>\n </KeyContainer>\n
      \  Figure 6: AES-128-CBC Encrypted Pre-Shared Secret Key with HMAC-SHA1\n   When
      protecting the payload with pre-shared keys, implementations\n   MUST set the
      name of the specific pre-shared key in the <KeyName>\n   element inside the
      <EncryptionKey> element.  When the encryption\n   method uses a CBC mode that
      requires an explicit initialization\n   vector (IV), the IV MUST be passed by
      prepending it to the encrypted\n   value.\n   For systems implementing PSKC,
      it is RECOMMENDED to support\n   AES-128-CBC (with the URI of\n   http://www.w3.org/2001/04/xmlenc#aes128-cbc)
      and KW-AES128 (with the\n   URI of http://www.w3.org/2001/04/xmlenc#kw-aes128).
      \ Please note that\n   KW-AES128 requires that the key to be protected must
      be a multiple of\n   8 bytes in length.  Hence, if keys of a different length
      have to be\n   protected, then the usage of the key-wrap algorithm with padding,
      as\n   described in [RFC5649] is RECOMMENDED.  Some of the encryption\n   algorithms
      that can optionally be implemented are:\n Algorithm      | Uniform Resource
      Locator (URL)\n ---------------+-------------------------------------------------------\n
      AES192-CBC     | http://www.w3.org/2001/04/xmlenc#aes192-cbc\n AES256-CBC     |
      http://www.w3.org/2001/04/xmlenc#aes256-cbc\n TripleDES-CBC  | http://www.w3.org/2001/04/xmlenc#tripledes-cbc\n
      Camellia128    | http://www.w3.org/2001/04/xmldsig-more#camellia128\n Camellia192
      \   | http://www.w3.org/2001/04/xmldsig-more#camellia192\n Camellia256    |
      http://www.w3.org/2001/04/xmldsig-more#camellia256\n KW-AES128      | http://www.w3.org/2001/04/xmlenc#kw-aes128\n
      KW-AES192      | http://www.w3.org/2001/04/xmlenc#kw-aes192\n KW-AES256      |
      http://www.w3.org/2001/04/xmlenc#kw-aes256\n KW-TripleDES   | http://www.w3.org/2001/04/xmlenc#kw-tripledes\n
      KW-Camellia128 | http://www.w3.org/2001/04/xmldsig-more#kw-camellia128\n KW-Camellia192
      | http://www.w3.org/2001/04/xmldsig-more#kw-camellia192\n KW-Camellia256 | http://www.w3.org/2001/04/xmldsig-more#kw-camellia256\n"
    - contents:
      - "6.1.1.  MAC Method\n   When algorithms without integrity checks are used,
        such as AES-128-\n   CBC, a keyed-MAC value MUST be placed in the <ValueMAC>
        element of\n   the <Data> element.  In this case, the MAC algorithm type MUST
        be set\n   in the <MACMethod> element of the <KeyContainer> element.  The
        MAC\n   key MUST be a randomly generated key by the sender, be pre-agreed\n
        \  upon between the receiver and the sender, or be set by the\n   application
        protocol that carries the PSKC document.  It is\n   RECOMMENDED that the sender
        generate a random MAC key.  When the\n   sender generates such a random MAC
        key, the MAC key material MUST be\n   encrypted with the same encryption key
        specified in <EncryptionKey>\n   element of the key container.  The encryption
        method and encrypted\n   value MUST be set in the <EncryptionMethod> element
        and the\n   <CipherData> element, respectively, of the <MACKey> element in
        the\n   <MACMethod> element.  The <MACKeyReference> element of the\n   <MACMethod>
        element MAY be used to indicate a pre-shared MAC key or a\n   provisioning
        protocol derived MAC key.  For systems implementing\n   PSKC, it is RECOMMENDED
        to implement the HMAC-SHA1 (with the URI of\n   'http://www.w3.org/2000/09/xmldsig#hmac-sha1').
        \ Some of the MAC\n   algorithms that can optionally be implemented are:\n
        \  Algorithm      | Uniform Resource Locator (URL)\n   ---------------+-----------------------------------------------------\n
        \  HMAC-SHA224    | http://www.w3.org/2001/04/xmldsig-more#hmac-sha224\n   HMAC-SHA256
        \   | http://www.w3.org/2001/04/xmldsig-more#hmac-sha256\n   HMAC-SHA384    |
        http://www.w3.org/2001/04/xmldsig-more#hmac-sha384\n   HMAC-SHA512    | http://www.w3.org/2001/04/xmldsig-more#hmac-sha512\n"
      title: 6.1.1.  MAC Method
    title: 6.1.  Encryption Based on Pre-Shared Keys
  - contents:
    - "6.2.  Encryption Based on Passphrase-Based Keys\n   Figure 7 shows an example
      that illustrates the encryption of the\n   content of the <Secret> element using
      passphrase-based key derivation\n   (PBKDF2) to derive the encryption key as
      defined in [PKCS5].  When\n   using passphrase-based key derivation, the <DerivedKey>
      element\n   defined in XML Encryption Version 1.1 [XMLENC11] MUST be used to\n
      \  specify the passphrased-based key.  A <DerivedKey> element is set as\n   the
      child element of <EncryptionKey> element of the key container.\n   The <DerivedKey>
      element is used to specify the key derivation\n   function and related parameters.
      \ The encryption algorithm, in this\n   example, AES-128-CBC (URI\n   'http://www.w3.org/2001/04/xmlenc#aes128-cbc'),
      MUST be set in the\n   'Algorithm' attribute of <EncryptionMethod> element used
      inside the\n   encrypted data elements.\n   When PBKDF2 is used, the 'Algorithm'
      attribute of the <xenc11:\n   KeyDerivationMethod> element MUST be set to the
      URI\n   'http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2'.  The\n
      \  <xenc11:KeyDerivationMethod> element MUST include the <PBKDF2-params>\n   child
      element to indicate the PBKDF2 parameters, such as salt and\n   iteration count.\n
      \  When the encryption method uses a CBC mode that uses an explicit\n   initialization
      vector (IV) other than a derived one, the IV MUST be\n   passed by prepending
      it to the encrypted value.\n   In the example below, the following data is used.\n
      \  Password:   qwerty\n   Salt:   0x123eff3c4a72129c\n   Iteration Count:  1000\n
      \  MAC Key:   0xbdaab8d648e850d25a3289364f7d7eaaf53ce581\n   OTP Secret:   12345678901234567890\n
      \  The derived encryption key is \"0x651e63cd57008476af1ff6422cd02e41\".\n   The
      initialization vector (IV) is\n   \"0xa13be8f92db69ec992d99fd1b5ca05f0\".  This
      key is also used to\n   encrypt the randomly chosen MAC key.  A different IV
      can be used, say\n   \"0xd864d39cbc0cdc8e1ee483b9164b9fa0\", in the example.
      \ The encryption\n   with algorithm \"AES-128-CBC\" follows the specification
      defined in\n   [XMLENC].\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <pskc:KeyContainer\n
      \   xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n    xmlns:xenc11=\"http://www.w3.org/2009/xmlenc11#\"\n
      \   xmlns:pkcs5=\n    \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\"\n
      \   xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" Version=\"1.0\">\n      <pskc:EncryptionKey>\n
      \         <xenc11:DerivedKey>\n              <xenc11:KeyDerivationMethod\n                Algorithm=\n
      \  \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#pbkdf2\">\n
      \                 <pkcs5:PBKDF2-params>\n                      <Salt>\n                          <Specified>Ej7/PEpyEpw=</Specified>\n
      \                     </Salt>\n                      <IterationCount>1000</IterationCount>\n
      \                     <KeyLength>16</KeyLength>\n                      <PRF/>\n
      \                 </pkcs5:PBKDF2-params>\n              </xenc11:KeyDerivationMethod>\n
      \             <xenc:ReferenceList>\n                  <xenc:DataReference URI=\"#ED\"/>\n
      \             </xenc:ReferenceList>\n              <xenc11:MasterKeyName>My
      Password 1</xenc11:MasterKeyName>\n          </xenc11:DerivedKey>\n      </pskc:EncryptionKey>\n
      \     <pskc:MACMethod\n          Algorithm=\"http://www.w3.org/2000/09/xmldsig#hmac-sha1\">\n
      \         <pskc:MACKey>\n              <xenc:EncryptionMethod\n              Algorithm=\"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n
      \             <xenc:CipherData>\n                  <xenc:CipherValue>\n  2GTTnLwM3I4e5IO5FkufoOEiOhNj91fhKRQBtBJYluUDsPOLTfUvoU2dStyOwYZx\n
      \                 </xenc:CipherValue>\n              </xenc:CipherData>\n          </pskc:MACKey>\n
      \     </pskc:MACMethod>\n      <pskc:KeyPackage>\n          <pskc:DeviceInfo>\n
      \             <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n              <pskc:SerialNo>987654321</pskc:SerialNo>\n
      \         </pskc:DeviceInfo>\n          <pskc:CryptoModuleInfo>\n              <pskc:Id>CM_ID_001</pskc:Id>\n
      \         </pskc:CryptoModuleInfo>\n          <pskc:Key Algorithm=\n          \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\"
      Id=\"123456\">\n              <pskc:Issuer>Example-Issuer</pskc:Issuer>\n              <pskc:AlgorithmParameters>\n
      \                 <pskc:ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n
      \             </pskc:AlgorithmParameters>\n              <pskc:Data>\n                  <pskc:Secret>\n
      \                 <pskc:EncryptedValue Id=\"ED\">\n                      <xenc:EncryptionMethod\n
      \                         Algorithm=\n  \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n
      \                         <xenc:CipherData>\n                              <xenc:CipherValue>\n
      \       oTvo+S22nsmS2Z/RtcoF8Hfh+jzMe0RkiafpoDpnoZTjPYZu6V+A4aEn032yCr4f\n                          </xenc:CipherValue>\n
      \                     </xenc:CipherData>\n                      </pskc:EncryptedValue>\n
      \                     <pskc:ValueMAC>LP6xMvjtypbfT9PdkJhBZ+D6O4w=\n                      </pskc:ValueMAC>\n
      \                 </pskc:Secret>\n              </pskc:Data>\n          </pskc:Key>\n
      \     </pskc:KeyPackage>\n  </pskc:KeyContainer>\n      Figure 7: Example of
      a PSKC Document Using Encryption Based on\n                           Passphrase-Based
      Keys\n"
    title: 6.2.  Encryption Based on Passphrase-Based Keys
  - contents:
    - "6.3.  Encryption Based on Asymmetric Keys\n   When using asymmetric keys to
      encrypt child elements of the <Data>\n   element, information about the certificate
      being used MUST be stated\n   in the <X509Data> element, which is a child element
      of the\n   <EncryptionKey> element.  The encryption algorithm MUST be indicated\n
      \  in the 'Algorithm' attribute of the <EncryptionMethod> element.  In\n   the
      example shown in Figure 8, the algorithm is set to\n   'http://www.w3.org/2001/04/xmlenc#rsa_1_5'.\n
      \  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n   <KeyContainer\n       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
      \      xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n       xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
      \      id=\"KC0001\"\n       Version=\"1.0\">\n       <EncryptionKey>\n           <ds:X509Data>\n
      \  <ds:X509Certificate>MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4M\n   Q0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIF\n
      \  Rlc3QwHhcNMDkwMjE3MDkxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVR\n   GMRMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZI\n
      \  hvcNAQEBBQADgY0AMIGJAoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/e\n   DsKjsPyFIODsxeKVV/uA3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJ\n
      \  xBKilAM5aW7C+BQ0RvCxvdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQY\n   JKoZIhvcNAQEFBQADgYEAe875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqf\n
      \  rnRuXJRMeZXaaEGmzY1kLonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w\n   4rnqdkmwZX/NgXg06alnc2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=\n
      \  </ds:X509Certificate>\n           </ds:X509Data>\n       </EncryptionKey>\n
      \      <KeyPackage>\n           <DeviceInfo>\n               <Manufacturer>TokenVendorAcme</Manufacturer>\n
      \              <SerialNo>987654321</SerialNo>\n           </DeviceInfo>\n           <Key\n
      \              Id=\"MBK000000001\"\n               Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
      \              <Issuer>Example-Issuer</Issuer>\n               <AlgorithmParameters>\n
      \                  <ResponseFormat Length=\"6\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
      \              <Data>\n                   <Secret>\n                       <EncryptedValue>\n
      \                          <xenc:EncryptionMethod\n                Algorithm=\"http://www.w3.org/2001/04/xmlenc#rsa_1_5\"/>\n
      \                          <xenc:CipherData>\n   <xenc:CipherValue>hJ+fvpoMPMO9BYpK2rdyQYGIxiATYHTHC7e/sPLKYo5/r1v+4\n
      \  xTYG3gJolCWuVMydJ7Ta0GaiBPHcWa8ctCVYmHKfSz5fdeV5nqbZApe6dofTqhRwZK6\n   Yx4ufevi91cjN2vBpSxYafvN3c3+xIgk0EnTV4iVPRCR0rBwyfFrPc4=\n
      \  </xenc:CipherValue>\n                           </xenc:CipherData>\n                       </EncryptedValue>\n
      \                  </Secret>\n                   <Counter>\n                       <PlainValue>0</PlainValue>\n
      \                  </Counter>\n               </Data>\n           </Key>\n       </KeyPackage>\n
      \  </KeyContainer>\n      Figure 8: Example of a PSKC Document Using Encryption
      Based on\n                              Asymmetric Keys\n   For systems implementing
      PSKC, it is RECOMMENDED to implement the\n   RSA-1.5 algorithm, identified by
      the URI\n   'http://www.w3.org/2001/04/xmlenc#rsa-1_5'.\n   Some of the asymmetric
      encryption algorithms that can optionally be\n   implemented are:\n   Algorithm
      \        | Uniform Resource Locator (URL)\n   ------------------+-------------------------------------------------\n
      \  RSA-OAEP-MGF1P    | http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p\n"
    title: 6.3.  Encryption Based on Asymmetric Keys
  - contents:
    - "6.4.  Padding of Encrypted Values for Non-Padded Encryption Algorithms\n   Padding
      of encrypted values (for example, the key secret value) is\n   required when
      key protection algorithms are used that do not support\n   embedded padding
      and the value to be encrypted is not a multiple of\n   the encryption algorithm
      cipher block length.\n   For example, when transmitting an HOTP key (20 bytes
      long) protected\n   with the AES algorithm in CBC mode (8-byte block cipher),
      padding is\n   required since its length is not a multiple of the 8-byte block\n
      \  length.\n   In these cases, for systems implementing PSKC, it is RECOMMENDED
      to\n   pad the value before encryption using PKCS #5 padding as described in\n
      \  [PKCS5].\n"
    title: 6.4.  Padding of Encrypted Values for Non-Padded Encryption Algorithms
  title: 6.  Key Protection Methods
- contents:
  - "7.  Digital Signature\n   PSKC allows a digital signature to be added to the
    XML document, as a\n   child element of the <KeyContainer> element.  The description
    of the\n   XML digital signature can be found in [XMLDSIG].\n   <?xml version=\"1.0\"
    encoding=\"UTF-8\"?>\n   <KeyContainer\n       xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
    \      xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n       xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
    \      Version=\"1.0\">\n       <KeyPackage>\n           <DeviceInfo>\n               <Manufacturer>TokenVendorAcme</Manufacturer>\n
    \              <SerialNo>0755225266</SerialNo>\n           </DeviceInfo>\n           <Key
    Id=\"123\"\n           Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
    \              <Issuer>Example-Issuer</Issuer>\n               <AlgorithmParameters>\n
    \                  <ResponseFormat Length=\"6\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
    \              <Data>\n                   <Secret>\n                       <PlainValue>\n
    \                          MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=\n                       </PlainValue>\n
    \                  </Secret>\n                   <Counter>\n                       <PlainValue>0</PlainValue>\n
    \                  </Counter>\n               </Data>\n           </Key>\n       </KeyPackage>\n
    \      <Signature>\n           <ds:SignedInfo>\n               <ds:CanonicalizationMethod\n
    \               Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/>\n               <ds:SignatureMethod\n
    \               Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"/>\n               <ds:Reference
    URI=\"#Device\">\n                   <ds:DigestMethod\n                Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>\n
    \                  <ds:DigestValue>\n                       j6lwx3rvEPO0vKtMup4NbeVu8nk=\n
    \                  </ds:DigestValue>\n               </ds:Reference>\n           </ds:SignedInfo>\n
    \          <ds:SignatureValue>\n               j6lwx3rvEPO0vKtMup4NbeVu8nk=\n
    \          </ds:SignatureValue>\n           <ds:KeyInfo>\n               <ds:X509Data>\n
    \                  <ds:X509IssuerSerial>\n                       <ds:X509IssuerName>\n
    \                          CN=Example.com,C=US\n                       </ds:X509IssuerName>\n
    \                      <ds:X509SerialNumber>\n                           12345678\n
    \                      </ds:X509SerialNumber>\n                   </ds:X509IssuerSerial>\n
    \              </ds:X509Data>\n           </ds:KeyInfo>\n       </Signature>\n
    \  </KeyContainer>\n                    Figure 9: Digital Signature Example\n"
  title: 7.  Digital Signature
- contents:
  - "8.  Bulk Provisioning\n   The functionality of bulk provisioning can be accomplished
    by\n   repeating the <KeyPackage> element multiple times within the\n   <KeyContainer>
    element, indicating that multiple keys are provided to\n   different devices or
    cryptographic modules.  The <EncryptionKey>\n   element then applies to all <KeyPackage>
    elements.  When provisioning\n   multiple keys to the same device, the <KeyPackage>
    element is\n   repeated, but the enclosed <DeviceInfo> element will contain the
    same\n   sub-elements that uniquely identify the single device (for example,\n
    \  the keys for the device identified by SerialNo='9999999' in the\n   example
    below).\n   Figure 10 shows an example utilizing these capabilities.\n   <?xml
    version=\"1.0\" encoding=\"UTF-8\"?>\n   <KeyContainer Version=\"1.0\"\n       xmlns=\"urn:ietf:params:xml:ns:keyprov:pskc\">\n
    \      <KeyPackage>\n           <DeviceInfo>\n               <Manufacturer>TokenVendorAcme</Manufacturer>\n
    \              <SerialNo>654321</SerialNo>\n           </DeviceInfo>\n           <Key
    Id=\"1\"\n           Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
    \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
    \                  <ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
    \              <Data>\n                   <Secret>\n                       <PlainValue>\n
    \                          MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=\n                       </PlainValue>\n
    \                  </Secret>\n                   <Counter>\n                       <PlainValue>0</PlainValue>\n
    \                  </Counter>\n               </Data>\n               <Policy>\n
    \                  <StartDate>2006-05-01T00:00:00Z</StartDate>\n                   <ExpiryDate>2006-05-31T00:00:00Z</ExpiryDate>\n
    \              </Policy>\n           </Key>\n       </KeyPackage>\n       <KeyPackage>\n
    \          <DeviceInfo>\n               <Manufacturer>TokenVendorAcme</Manufacturer>\n
    \              <SerialNo>123456</SerialNo>\n           </DeviceInfo>\n           <Key
    Id=\"2\"\n           Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
    \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
    \                  <ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
    \              <Data>\n                   <Secret>\n                       <PlainValue>\n
    \                          MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=\n                       </PlainValue>\n
    \                  </Secret>\n                   <Counter>\n                       <PlainValue>0</PlainValue>\n
    \                  </Counter>\n               </Data>\n               <Policy>\n
    \                  <StartDate>2006-05-01T00:00:00Z</StartDate>\n                   <ExpiryDate>2006-05-31T00:00:00Z</ExpiryDate>\n
    \              </Policy>\n           </Key>\n       </KeyPackage>\n       <KeyPackage>\n
    \          <DeviceInfo>\n               <Manufacturer>TokenVendorAcme</Manufacturer>\n
    \              <SerialNo>9999999</SerialNo>\n           </DeviceInfo>\n           <Key
    Id=\"3\"\n           Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
    \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
    \                  <ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
    \              <Data>\n                   <Secret>\n                       <PlainValue>\n
    \                          MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=\n                       </PlainValue>\n
    \                  </Secret>\n                   <Counter>\n                       <PlainValue>0</PlainValue>\n
    \                  </Counter>\n               </Data>\n               <Policy>\n
    \                  <StartDate>2006-03-01T00:00:00Z</StartDate>\n                   <ExpiryDate>2006-03-31T00:00:00Z</ExpiryDate>\n
    \              </Policy>\n           </Key>\n       </KeyPackage>\n       <KeyPackage>\n
    \          <DeviceInfo>\n               <Manufacturer>TokenVendorAcme</Manufacturer>\n
    \              <SerialNo>9999999</SerialNo>\n           </DeviceInfo>\n           <Key
    Id=\"4\"\n           Algorithm=\"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
    \              <Issuer>Issuer</Issuer>\n               <AlgorithmParameters>\n
    \                  <ResponseFormat Length=\"8\" Encoding=\"DECIMAL\"/>\n               </AlgorithmParameters>\n
    \              <Data>\n                   <Secret>\n                       <PlainValue>\n
    \                          MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=\n                       </PlainValue>\n
    \                  </Secret>\n                   <Counter>\n                       <PlainValue>0</PlainValue>\n
    \                  </Counter>\n               </Data>\n               <Policy>\n
    \                  <StartDate>2006-04-01T00:00:00Z</StartDate>\n                   <ExpiryDate>2006-04-30T00:00:00Z</ExpiryDate>\n
    \              </Policy>\n           </Key>\n       </KeyPackage>\n   </KeyContainer>\n
    \                  Figure 10: Bulk Provisioning Example\n"
  title: 8.  Bulk Provisioning
- contents:
  - "9.  Extensibility\n   This section lists a few common extension points provided
    by PSKC:\n   New PSKC Version:  Whenever it is necessary to define a new version\n
    \     of this document, a new version number has to be allocated to\n      refer
    to the new specification.  The version number is carried\n      inside the 'Version'
    attribute, as described in Section 4, the\n      numbering scheme MUST follow
    Section 1.2, and rules for\n      extensibility are defined in Section 12.\n   New
    XML Elements:  The usage of the XML schema and the available\n      extension
    points allows new XML elements to be added.  Depending\n      on the type of XML
    element, different ways for extensibility are\n      offered.  In some places,
    the <Extensions> element can be used and\n      elsewhere the \"<xs:any namespace=\"##other\"
    processContents=\"lax\"\n      minOccurs=\"0\" maxOccurs=\"unbounded\"/>\" XML
    extension point is\n      utilized.\n   New XML Attributes:  The XML schema allows
    new XML attributes to be\n      added where XML extension points have been defined
    (see \"<xs:\n      anyAttribute namespace=\"##other\"/>\" in Section 11).\n   New
    PSKC Algorithm Profiles:  This document defines two PSKC\n      algorithm profiles,
    see Section 10.  The following informational\n      document describes additional
    profiles [PSKC-ALGORITHM-PROFILES].\n      Further PSKC algorithm profiles can
    be registered as described in\n      Section 12.4.\n   Algorithm URIs:  Section
    6 defines how keys and related data can be\n      protected.  A number of algorithms
    can be used.  New algorithms\n      can be used by pointing to a new algorithm
    URI.\n   Policy:  Section 5 defines policies that can be attached to a key and\n
    \     keying-related data.  The <Policy> element is one such item that\n      allows
    implementers to restrict the use of the key to certain\n      functions, such
    as \"OTP usage only\".  Further values may be\n      registered as described in
    Section 12.\n"
  title: 9.  Extensibility
- contents:
  - '10.  PSKC Algorithm Profile

    '
  - contents:
    - "10.1.  HOTP\n   Common Name:  HOTP\n   Class:  OTP\n   URI:  urn:ietf:params:xml:ns:keyprov:pskc:hotp\n
      \  Algorithm Definition:  [HOTP]\n   Identifier Definition:  (this RFC)\n   Registrant
      Contact:  IESG\n   Deprecated:  FALSE\n   Profiling:\n         The <KeyPackage>
      element MUST be present and the\n         <ResponseFormat> element, which is
      a child element of the\n         <AlgorithmParameters> element, MUST be used
      to indicate the OTP\n         length and the value format.\n         The <Counter>
      element (see Section 4.1) MUST be provided as\n         metadata for the key.\n
      \        The following additional constraints apply:\n         +  The value
      of the <Secret> element MUST contain key material\n            with a length
      of at least 16 octets (128 bits), if it is\n            present.\n         +
      \ The <ResponseFormat> element MUST have the 'Format'\n            attribute
      set to \"DECIMAL\", and the 'Length' attribute MUST\n            indicate a
      length value between 6 and 9 (inclusive).\n         +  The <PINPolicy> element
      MAY be present, but the\n            'PINUsageMode' attribute cannot be set
      to \"Algorithmic\".\n         An example can be found in Figure 3.\n"
    title: 10.1.  HOTP
  - contents:
    - "10.2.  PIN\n   Common Name:  PIN\n   Class:  Symmetric static credential comparison\n
      \  URI:  urn:ietf:params:xml:ns:keyprov:pskc:pin\n   Algorithm Definition:  (this
      RFC) Section 5.1\n   Identifier Definition  (this RFC)\n   Registrant Contact:
      \ IESG\n   Deprecated:  FALSE\n   Profiling:\n         The <Usage> element MAY
      be present, but no attribute of the\n         <Usage> element is required.  The
      <ResponseFormat> element MAY\n         be used to indicate the PIN value format.\n
      \        The <Secret> element (see Section 4.1) MUST be provided.\n         See
      the example in Figure 5\n"
    title: 10.2.  PIN
  title: 10.  PSKC Algorithm Profile
- contents:
  - "11.  XML Schema\n   This section defines the XML schema for PSKC.\n"
  - '<?xml version="1.0" encoding="UTF-8"?>

    '
  - "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n     xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
    \    xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n     xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
    \    targetNamespace=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n     elementFormDefault=\"qualified\"\n
    \    attributeFormDefault=\"unqualified\">\n     <xs:import namespace=\"http://www.w3.org/2000/09/xmldsig#\"\n
    \         schemaLocation=\n"
  - "\"http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/\n          xmldsig-core-schema.xsd\"/>\n
    \    <xs:import namespace=\"http://www.w3.org/2001/04/xmlenc#\"\n          schemaLocation=\n"
  - "\"http://www.w3.org/TR/2002/REC-xmlenc-core-20021210/xenc-schema.xsd\"/>\n     <xs:import
    namespace=\"http://www.w3.org/XML/1998/namespace\"/>\n     <xs:complexType name=\"KeyContainerType\">\n
    \         <xs:sequence>\n               <xs:element name=\"EncryptionKey\"\n                    type=\"ds:KeyInfoType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"MACMethod\"\n                    type=\"pskc:MACMethodType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"KeyPackage\"\n                    type=\"pskc:KeyPackageType\"
    maxOccurs=\"unbounded\"/>\n               <xs:element name=\"Signature\"\n                    type=\"ds:SignatureType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Extensions\"\n                    type=\"pskc:ExtensionsType\"\n
    \                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n
    \         <xs:attribute name=\"Version\"\n               type=\"pskc:VersionType\"
    use=\"required\"/>\n          <xs:attribute name=\"Id\"\n               type=\"xs:ID\"
    use=\"optional\"/>\n     </xs:complexType>\n     <xs:simpleType name=\"VersionType\"
    final=\"restriction\">\n          <xs:restriction base=\"xs:string\">\n               <xs:pattern
    value=\"\\d{1,2}\\.\\d{1,3}\"/>\n          </xs:restriction>\n     </xs:simpleType>\n
    \    <xs:complexType name=\"KeyType\">\n          <xs:sequence>\n               <xs:element
    name=\"Issuer\"\n                    type=\"xs:string\" minOccurs=\"0\"/>\n               <xs:element
    name=\"AlgorithmParameters\"\n                    type=\"pskc:AlgorithmParametersType\"\n
    \                   minOccurs=\"0\"/>\n               <xs:element name=\"KeyProfileId\"\n
    \                   type=\"xs:string\" minOccurs=\"0\"/>\n               <xs:element
    name=\"KeyReference\"\n                    type=\"xs:string\" minOccurs=\"0\"/>\n
    \              <xs:element name=\"FriendlyName\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Data\"\n                    type=\"pskc:KeyDataType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"UserId\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Policy\"\n                    type=\"pskc:PolicyType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Extensions\"\n                    type=\"pskc:ExtensionsType\"
    minOccurs=\"0\"\n                    maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n
    \         <xs:attribute name=\"Id\"\n               type=\"xs:string\" use=\"required\"/>\n
    \         <xs:attribute name=\"Algorithm\"\n               type=\"pskc:KeyAlgorithmType\"
    use=\"optional\"/>\n     </xs:complexType>\n     <xs:complexType name=\"PolicyType\">\n
    \         <xs:sequence>\n               <xs:element name=\"StartDate\"\n                    type=\"xs:dateTime\"
    minOccurs=\"0\"/>\n               <xs:element name=\"ExpiryDate\"\n                    type=\"xs:dateTime\"
    minOccurs=\"0\"/>\n               <xs:element name=\"PINPolicy\"\n                    type=\"pskc:PINPolicyType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"KeyUsage\"\n                    type=\"pskc:KeyUsageType\"\n
    \                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n               <xs:element
    name=\"NumberOfTransactions\"\n                    type=\"xs:nonNegativeInteger\"
    minOccurs=\"0\"/>\n               <xs:any namespace=\"##other\"\n                    minOccurs=\"0\"
    maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n     </xs:complexType>\n
    \    <xs:complexType name=\"KeyDataType\">\n          <xs:sequence>\n               <xs:element
    name=\"Secret\"\n                    type=\"pskc:binaryDataType\" minOccurs=\"0\"/>\n
    \              <xs:element name=\"Counter\"\n                    type=\"pskc:longDataType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Time\"\n                    type=\"pskc:intDataType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"TimeInterval\"\n                    type=\"pskc:intDataType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"TimeDrift\"\n                    type=\"pskc:intDataType\"
    minOccurs=\"0\"/>\n               <xs:any namespace=\"##other\"\n                    processContents=\"lax\"\n
    \                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n
    \    </xs:complexType>\n     <xs:complexType name=\"binaryDataType\">\n          <xs:sequence>\n
    \              <xs:choice>\n                    <xs:element name=\"PlainValue\"\n
    \                        type=\"xs:base64Binary\"/>\n                    <xs:element
    name=\"EncryptedValue\"\n                         type=\"xenc:EncryptedDataType\"/>\n
    \              </xs:choice>\n               <xs:element name=\"ValueMAC\"\n                    type=\"xs:base64Binary\"
    minOccurs=\"0\"/>\n          </xs:sequence>\n     </xs:complexType>\n     <xs:complexType
    name=\"intDataType\">\n          <xs:sequence>\n               <xs:choice>\n                    <xs:element
    name=\"PlainValue\" type=\"xs:int\"/>\n                    <xs:element name=\"EncryptedValue\"\n
    \                        type=\"xenc:EncryptedDataType\"/>\n               </xs:choice>\n
    \              <xs:element name=\"ValueMAC\"\n                    type=\"xs:base64Binary\"
    minOccurs=\"0\"/>\n          </xs:sequence>\n     </xs:complexType>\n     <xs:complexType
    name=\"stringDataType\">\n          <xs:sequence>\n               <xs:choice>\n
    \                   <xs:element name=\"PlainValue\" type=\"xs:string\"/>\n                    <xs:element
    name=\"EncryptedValue\"\n                         type=\"xenc:EncryptedDataType\"/>\n
    \              </xs:choice>\n               <xs:element name=\"ValueMAC\"\n                    type=\"xs:base64Binary\"
    minOccurs=\"0\"/>\n          </xs:sequence>\n     </xs:complexType>\n     <xs:complexType
    name=\"longDataType\">\n          <xs:sequence>\n               <xs:choice>\n
    \                   <xs:element name=\"PlainValue\" type=\"xs:long\"/>\n                    <xs:element
    name=\"EncryptedValue\"\n                         type=\"xenc:EncryptedDataType\"/>\n
    \              </xs:choice>\n               <xs:element name=\"ValueMAC\"\n                    type=\"xs:base64Binary\"
    minOccurs=\"0\"/>\n          </xs:sequence>\n     </xs:complexType>\n     <xs:complexType
    name=\"PINPolicyType\">\n          <xs:attribute name=\"PINKeyId\"\n               type=\"xs:string\"
    use=\"optional\"/>\n          <xs:attribute name=\"PINUsageMode\"\n               type=\"pskc:PINUsageModeType\"/>\n
    \         <xs:attribute name=\"MaxFailedAttempts\"\n               type=\"xs:unsignedInt\"
    use=\"optional\"/>\n          <xs:attribute name=\"MinLength\"\n               type=\"xs:unsignedInt\"
    use=\"optional\"/>\n          <xs:attribute name=\"MaxLength\"\n               type=\"xs:unsignedInt\"
    use=\"optional\"/>\n          <xs:attribute name=\"PINEncoding\"\n               type=\"pskc:ValueFormatType\"
    use=\"optional\"/>\n          <xs:anyAttribute namespace=\"##other\"/>\n     </xs:complexType>\n
    \    <xs:simpleType name=\"PINUsageModeType\">\n          <xs:restriction base=\"xs:string\">\n
    \              <xs:enumeration value=\"Local\"/>\n               <xs:enumeration
    value=\"Prepend\"/>\n               <xs:enumeration value=\"Append\"/>\n               <xs:enumeration
    value=\"Algorithmic\"/>\n          </xs:restriction>\n     </xs:simpleType>\n
    \    <xs:simpleType name=\"KeyUsageType\">\n          <xs:restriction base=\"xs:string\">\n
    \              <xs:enumeration value=\"OTP\"/>\n               <xs:enumeration
    value=\"CR\"/>\n               <xs:enumeration value=\"Encrypt\"/>\n               <xs:enumeration
    value=\"Integrity\"/>\n               <xs:enumeration value=\"Verify\"/>\n               <xs:enumeration
    value=\"Unlock\"/>\n               <xs:enumeration value=\"Decrypt\"/>\n               <xs:enumeration
    value=\"KeyWrap\"/>\n               <xs:enumeration value=\"Unwrap\"/>\n               <xs:enumeration
    value=\"Derive\"/>\n               <xs:enumeration value=\"Generate\"/>\n          </xs:restriction>\n
    \    </xs:simpleType>\n     <xs:complexType name=\"DeviceInfoType\">\n          <xs:sequence>\n
    \              <xs:element name=\"Manufacturer\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"SerialNo\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Model\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"IssueNo\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"DeviceBinding\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"StartDate\"\n                    type=\"xs:dateTime\"
    minOccurs=\"0\"/>\n               <xs:element name=\"ExpiryDate\"\n                    type=\"xs:dateTime\"
    minOccurs=\"0\"/>\n               <xs:element name=\"UserId\"\n                    type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Extensions\"\n                    type=\"pskc:ExtensionsType\"
    minOccurs=\"0\"\n                    maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n
    \    </xs:complexType>\n     <xs:complexType name=\"CryptoModuleInfoType\">\n
    \         <xs:sequence>\n               <xs:element name=\"Id\" type=\"xs:string\"/>\n
    \              <xs:element name=\"Extensions\"\n                    type=\"pskc:ExtensionsType\"
    minOccurs=\"0\"\n                    maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n
    \    </xs:complexType>\n     <xs:complexType name=\"KeyPackageType\">\n          <xs:sequence>\n
    \              <xs:element name=\"DeviceInfo\"\n                    type=\"pskc:DeviceInfoType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"CryptoModuleInfo\"\n                    type=\"pskc:CryptoModuleInfoType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Key\"\n                    type=\"pskc:KeyType\"
    minOccurs=\"0\"/>\n               <xs:element name=\"Extensions\"\n                    type=\"pskc:ExtensionsType\"
    minOccurs=\"0\"\n                    maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n
    \    </xs:complexType>\n     <xs:complexType name=\"AlgorithmParametersType\">\n
    \         <xs:choice>\n               <xs:element name=\"Suite\" type=\"xs:string\"
    minOccurs=\"0\"/>\n               <xs:element name=\"ChallengeFormat\" minOccurs=\"0\">\n
    \                   <xs:complexType>\n                         <xs:attribute name=\"Encoding\"\n
    \                             type=\"pskc:ValueFormatType\"\n                                                      use=\"required\"/>\n
    \                        <xs:attribute name=\"Min\"\n                              type=\"xs:unsignedInt\"
    use=\"required\"/>\n                         <xs:attribute name=\"Max\"\n                              type=\"xs:unsignedInt\"
    use=\"required\"/>\n                         <xs:attribute name=\"CheckDigits\"\n
    \                             type=\"xs:boolean\" default=\"false\"/>\n                    </xs:complexType>\n
    \              </xs:element>\n               <xs:element name=\"ResponseFormat\"
    minOccurs=\"0\">\n                    <xs:complexType>\n                         <xs:attribute
    name=\"Encoding\"\n                              type=\"pskc:ValueFormatType\"\n
    \                                                     use=\"required\"/>\n                         <xs:attribute
    name=\"Length\"\n                              type=\"xs:unsignedInt\" use=\"required\"/>\n
    \                        <xs:attribute name=\"CheckDigits\"\n                              type=\"xs:boolean\"
    default=\"false\"/>\n                    </xs:complexType>\n               </xs:element>\n
    \              <xs:element name=\"Extensions\"\n                    type=\"pskc:ExtensionsType\"
    minOccurs=\"0\"\n                    maxOccurs=\"unbounded\"/>\n          </xs:choice>\n
    \    </xs:complexType>\n     <xs:complexType name=\"ExtensionsType\">\n          <xs:sequence>\n
    \              <xs:any namespace=\"##other\"\n                    processContents=\"lax\"
    maxOccurs=\"unbounded\"/>\n          </xs:sequence>\n          <xs:attribute name=\"definition\"\n
    \              type=\"xs:anyURI\" use=\"optional\"/>\n     </xs:complexType>\n
    \    <xs:simpleType name=\"KeyAlgorithmType\">\n          <xs:restriction base=\"xs:anyURI\"/>\n
    \    </xs:simpleType>\n     <xs:simpleType name=\"ValueFormatType\">\n          <xs:restriction
    base=\"xs:string\">\n               <xs:enumeration value=\"DECIMAL\"/>\n               <xs:enumeration
    value=\"HEXADECIMAL\"/>\n               <xs:enumeration value=\"ALPHANUMERIC\"/>\n
    \              <xs:enumeration value=\"BASE64\"/>\n               <xs:enumeration
    value=\"BINARY\"/>\n          </xs:restriction>\n     </xs:simpleType>\n     <xs:complexType
    name=\"MACMethodType\">\n           <xs:sequence>\n                  <xs:choice>\n
    \                       <xs:element name=\"MACKey\"\n              type=\"xenc:EncryptedDataType\"
    minOccurs=\"0\"/>\n                        <xs:element name=\"MACKeyReference\"\n
    \                               type=\"xs:string\" minOccurs=\"0\"/>\n                        </xs:choice>\n
    \                       <xs:any namespace=\"##other\"\n           processContents=\"lax\"
    minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n       </xs:sequence>\n       <xs:attribute
    name=\"Algorithm\" type=\"xs:anyURI\" use=\"required\"/>\n        </xs:complexType>\n
    \    <xs:element name=\"KeyContainer\"\n          type=\"pskc:KeyContainerType\"/>\n"
  - '</xs:schema>

    '
  title: 11.  XML Schema
- contents:
  - '12.  IANA Considerations

    '
  - contents:
    - "12.1.  Content-Type Registration for 'application/pskc+xml'\n   This specification
      contains the registration of a new media type\n   according to the procedures
      of RFC 4288 [RFC4288] and guidelines in\n   RFC 3023 [RFC3023].\n   MIME media
      type name:  application\n   MIME subtype name:  pskc+xml\n   Required parameters:
      \ There is no required parameter.\n   Optional parameters:  charset\n      Indicates
      the character encoding of enclosed XML.\n   Encoding considerations:  Uses XML,
      which can employ 8-bit\n      characters, depending on the character encoding
      used.  See RFC\n      3023 [RFC3023], Section 3.2.\n   Security considerations:
      \ Please refer to Section 13 of RFC 6030.\n   Interoperability considerations:
      \ None\n   Published specification:  RFC 6030.\n   Applications which use this
      media type:  This media type is being\n      used as a symmetric key container
      format for transport and\n      provisioning of symmetric keys (One-Time Password
      (OTP) shared\n      secrets or symmetric cryptographic keys) to different types
      of\n      strong authentication devices.  As such, it is used for key\n      provisioning
      systems.\n   Additional information:\n      Magic Number:  None\n      File
      Extension:  .pskcxml\n      Macintosh file type code:  'TEXT'\n   Personal and
      email address to contact for further information:\n      Philip Hoyer, Philip.Hoyer@actividentity.com\n
      \  Intended usage:  LIMITED USE\n   Restrictions on usage:  None\n   Author:
      \ This specification is a work item of the IETF KEYPROV\n      working group,
      with mailing list address <keyprov@ietf.org>.\n   Change controller:  The IESG
      <iesg@ietf.org>\n"
    title: 12.1.  Content-Type Registration for 'application/pskc+xml'
  - contents:
    - "12.2.  XML Schema Registration\n   This section registers an XML schema as
      per the guidelines in\n   [RFC3688].\n   URI:  urn:ietf:params:xml:schema:keyprov:pskc\n
      \  Registrant Contact:  IETF KEYPROV Working Group, Philip Hoyer\n      (Philip.Hoyer@actividentity.com).\n
      \  XML Schema:  The XML schema to be registered is contained in\n      Section
      11.  Its first line is\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   and
      its last line is\n   </xs:schema>\n"
    title: 12.2.  XML Schema Registration
  - contents:
    - "12.3.  URN Sub-Namespace Registration\n   This section registers a new XML
      namespace,\n   \"urn:ietf:params:xml:ns:keyprov:pskc\", per the guidelines in\n
      \  [RFC3688].\n   URI:  urn:ietf:params:xml:ns:keyprov:pskc\n   Registrant Contact:
      \ IETF KEYPROV Working Group, Philip Hoyer\n      (Philip.Hoyer@actividentity.com).\n
      \  XML:\n   BEGIN\n   <?xml version=\"1.0\"?>\n   <!DOCTYPE html PUBLIC \"-//W3C//DTD
      XHTML Basic 1.0//EN\"\n     \"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd\">\n
      \  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n   <head>\n     <meta http-equiv=\"content-type\"\n
      \          content=\"text/html;charset=iso-8859-1\"/>\n     <title>PSKC Namespace</title>\n
      \  </head>\n   <body>\n     <h1>Namespace for PSKC</h1>\n     <h2>urn:ietf:params:xml:ns:keyprov:pskc</h2>\n
      \  <p>See <a href=\"http://www.rfc-editor.org/rfc/rfc6030.txt\">\n    RFC 6030</a>.</p>\n
      \  </body>\n   </html>\n   END\n"
    title: 12.3.  URN Sub-Namespace Registration
  - contents:
    - "12.4.  PSKC Algorithm Profile Registry\n   IANA has created a registry for
      PSKC algorithm profiles in accordance\n   with the principles set out in RFC
      5226 [RFC5226].\n   As part of this registry, IANA maintains the following information:\n
      \  Common Name:  The name by which the PSKC algorithm profile is\n      generally
      referred.\n   Class:  The type of PSKC algorithm profile registry entry being\n
      \     created, such as encryption, Message Authentication Code (MAC),\n      One-Time
      Password (OTP), Digest.\n   URI:  The URI to be used to identify the profile.\n
      \  Identifier Definition:  IANA will add a pointer to the specification\n      containing
      information about the PSKC algorithm profile\n      registration.\n   Algorithm
      Definition:  A reference to the stable document in which\n      the algorithm
      being used with the PSKC is defined.\n   Registrant Contact:  Contact information
      about the party submitting\n      the registration request.\n   Deprecated:
      \ TRUE if this entry has been deprecated based on expert\n      approval and
      SHOULD not be used in any new implementations.\n      Otherwise, FALSE.\n   PSKC
      Profiling:  Information about PSKC XML elements and attributes\n      being
      used (or not) with this specific profile of PSKC.\n   PSKC algorithm profile
      identifier registrations are to be subject to\n   Specification Required as
      per RFC 5226 [RFC5226].  Updates can be\n   provided based on expert approval
      only.  Based on expert approval, it\n   is possible to mark entries as \"deprecated\".
      \ A designated expert\n   will be appointed by the IESG.\n   IANA has added
      two initial values to the registry based on the\n   algorithm profiles described
      in Section 10.\n"
    title: 12.4.  PSKC Algorithm Profile Registry
  - contents:
    - "12.5.  PSKC Version Registry\n   IANA has created a registry for PSKC version
      numbers.  The registry\n   has the following structure:\n     PSKC Version              |
      Specification\n   +---------------------------+----------------\n   | 1.0                       |
      RFC 6030\n   Standards action is required to define new versions of PSKC.  It
      is\n   not envisioned to deprecate, delete, or modify existing PSKC\n   versions.\n"
    title: 12.5.  PSKC Version Registry
  - contents:
    - "12.6.  Key Usage Registry\n   IANA has created a registry for key usage.  A
      description of the\n   <KeyUsage> element can be found in Section 5.\n   As
      part of this registry IANA will maintain the following\n   information:\n    Key
      Usage:  The identifier of the Key Usage.\n   Specification:  IANA will add a
      pointer to the specification\n      containing information about the semantics
      of a new Key Usage\n      registration.\n   Deprecated:  TRUE if this entry
      has been deprecated based on expert\n      approval and SHOULD not be used in
      any new implementations.\n      Otherwise, FALSE.\n   IANA has added these initial
      values to the registry:\n     Key Usage     | Specification                |
      Deprecated\n   +---------------+------------------------------+-----------\n
      \  | OTP           | [Section 5 of this document] | FALSE\n   | CR            |
      [Section 5 of this document] | FALSE\n   | Encrypt       | [Section 5 of this
      document] | FALSE\n   | Integrity     | [Section 5 of this document] | FALSE\n
      \  | Verify        | [Section 5 of this document] | FALSE\n   | Unlock        |
      [Section 5 of this document] | FALSE\n   | Decrypt       | [Section 5 of this
      document] | FALSE\n   | KeyWrap       | [Section 5 of this document] | FALSE\n
      \  | Unwrap        | [Section 5 of this document] | FALSE\n   | Derive        |
      [Section 5 of this document] | FALSE\n   | Generate      | [Section 5 of this
      document] | FALSE\n   +---------------+------------------------------+-----------\n
      \  Key Usage Registry registrations are to be subject to Specification\n   Required
      as per RFC 5226 [RFC5226].  Expert Review is required to\n   define new Key
      Usage values.  Updates can be provided based on expert\n   approval only.  Based
      on expert approval, it is possible to mark\n   entries as \"deprecated\".  A
      designated expert will be appointed by\n   the IESG.\n"
    title: 12.6.  Key Usage Registry
  title: 12.  IANA Considerations
- contents:
  - "13.  Security Considerations\n   The portable symmetric key container (PSKC)
    carries sensitive\n   information (e.g., cryptographic keys) and may be transported
    across\n   the boundaries of one secure perimeter to another.  For example, a\n
    \  container residing within the secure perimeter of a back-end\n   provisioning
    server in a secure room may be transported across the\n   Internet to an end-user
    device attached to a personal computer.  This\n   means that special care MUST
    be taken to ensure the confidentiality,\n   integrity, and authenticity of the
    information contained within.\n"
  - contents:
    - "13.1.  PSKC Confidentiality\n   By design, the container allows two main approaches
      to guaranteeing\n   the confidentiality of the information it contains while
      transported.\n   First, the container key data payload may be encrypted.\n   In
      this case, no transport layer security is required.  However,\n   standard security
      best practices apply when selecting the strength of\n   the cryptographic algorithm
      for key data payload encryption.  A\n   symmetric cryptographic cipher SHOULD
      be used -- the longer the\n   cryptographic key, the stronger the protection.
      \ Please see\n   Section 6.1 for recommendations of key data payload protection
      using\n   symmetric cryptographic ciphers.  In cases where the exchange of key\n
      \  encryption keys between the sender and the receiver is not possible,\n   asymmetric
      encryption of the key data payload may be employed, see\n   Section 6.3.  Similar
      to symmetric key cryptography, the stronger the\n   asymmetric key, the more
      secure the protection.\n   If the key data payload is encrypted with a method
      that uses one of\n   the password-based encryption methods (PBE methods) detailed
      in\n   Section 6.2, the key data payload may be subjected to password\n   dictionary
      attacks to break the encryption password and recover the\n   information.  Standard
      security best practices for selection of\n   strong encryption passwords apply.\n
      \  Additionally, it is strongly RECOMMENDED that practical\n   implementations
      use PBESalt and PBEIterationCount when PBE encryption\n   is used.  A different
      PBESalt value per PSKC SHOULD be used for best\n   protection.\n   The second
      approach to protecting the confidentiality of the key data\n   is based on using
      lower-layer security mechanisms (e.g., [TLS],\n   [IPsec]).  The secure connection
      established between the source\n   secure perimeter (the provisioning server
      from the example above) and\n   the target perimeter (the device attached to
      the end-user computer)\n   utilizes encryption to protect the messages that
      travel across that\n   connection.  No key data payload encryption is required
      in this mode.\n   Secure connections that encrypt and digest each message provide
      an\n   extra measure of security.\n   Because of the fact that the plaintext
      PSKC is protected only by the\n   transport layer security, practical implementation
      MUST ensure\n   protection against man-in-the-middle attacks.  Authenticating
      the\n   secure channel endpoints is critically important for eliminating\n   intruders
      that may compromise the confidentiality of the PSKC.\n"
    title: 13.1.  PSKC Confidentiality
  - contents:
    - "13.2.  PSKC Integrity\n   The PSKC provides means to guarantee the integrity
      of the information\n   it contains through the use of digital signatures.  It
      is RECOMMENDED\n   that for best security practices, the digital signature of
      the\n   container encompasses the entire PSKC.  This provides assurances for\n
      \  the integrity of all attributes.  It also allows verification of the\n   integrity
      of a given PSKC even after the container is delivered\n   through the communication
      channel to the target perimeter and channel\n   message integrity check is no
      longer possible.\n"
    title: 13.2.  PSKC Integrity
  - contents:
    - "13.3.  PSKC Authenticity\n   The digital signature of the PSKC is the primary
      way of showing its\n   authenticity.  The recipient of the container SHOULD
      use the public\n   key associated with the signature to assert the authenticity
      of the\n   sender by tracing it back to a pre-loaded public key or certificate.\n
      \  Note that the digital signature of the PSKC can be checked even after\n   the
      container has been delivered through the secure channel of\n   communication.\n
      \  Authenticity guarantee may be provided by [TLS] or [IPsec].  However,\n   no
      authenticity verification is possible once the container is\n   delivered at
      the recipient end.  Since the TLS endpoints could differ\n   from the key provisioning
      endpoints, this solution is weaker than the\n   previous solution that relies
      on a digital signature of the PSKC.\n"
    title: 13.3.  PSKC Authenticity
  title: 13.  Security Considerations
- contents:
  - "14.  Contributors\n   We would like Hannes Tschofenig for his text contributions
    to this\n   document.\n"
  title: 14.  Contributors
- contents:
  - "15.  Acknowledgements\n   The authors of this document would like to thank the
    following people\n   for their feedback: Apostol Vassilev, Shuh Chang, Jon Martinson,\n
    \  Siddhart Bajaj, Stu Vaeth, Kevin Lewis, Philip Hallam-Baker, Andrea\n   Doherty,
    Magnus Nystrom, Tim Moses, Anders Rundgren, Sean Turner, and\n   especially Robert
    Philpott.\n   We would like to thank Sean Turner for his review in January 2009.\n
    \  We would also like to thank Anders Rundgren for triggering the\n   discussion
    regarding to the selection of encryption algorithms\n   (KW-AES-128 vs. AES-128-CBC)
    and his input on the keyed message\n   digest computation.\n   This work is based
    on earlier work by the members of OATH (Initiative\n   for Open AuTHentication),
    see [OATH], to specify a format that can be\n   freely distributed to the technical
    community.\n"
  title: 15.  Acknowledgements
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [FIPS197]  National Institute of Standards,
      \"FIPS Pub 197: Advanced\n              Encryption Standard (AES)\", November
      2001.\n   [HOTP]     M'Raihi, D., Bellare, M., Hoornaert, F., Naccache, D.,
      and\n              O. Ranen, \"HOTP: An HMAC-Based One-Time Password\n              Algorithm\",
      RFC 4226, December 2005.\n   [IANAPENREG]\n              IANA, \"Private Enterprise
      Numbers\", <http://www.iana.org>.\n   [ISOIEC7812]\n              ISO, \"ISO/IEC
      7812-1:2006 Identification cards --\n              Identification of issuers
      -- Part 1: Numbering system\",\n              October 2006, <http://www.iso.org/iso/iso_catalogue/\n
      \             catalogue_tc/catalogue_detail.htm?csnumber=39698>.\n   [OATHMAN]
      \ OATH, \"List of OATH Manufacturer Prefixes (omp)\",\n              April 2009,\n
      \             <http://www.openauthentication.org/oath-id/prefixes/>.\n   [PKCS5]
      \   RSA Laboratories, \"PKCS #5: Password-Based Cryptography\n              Standard\",
      Version 2.0, March 1999,\n              <http://www.rsasecurity.com/rsalabs/pkcs/>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3023]  Murata, M., St. Laurent,
      S., and D. Kohn, \"XML Media\n              Types\", RFC 3023, January 2001.\n
      \  [RFC3688]  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              January
      2004.\n   [RFC4288]  Freed, N. and J. Klensin, \"Media Type Specifications and\n
      \             Registration Procedures\", BCP 13, RFC 4288, December 2005.\n
      \  [RFC4514]  Zeilenga, K., \"Lightweight Directory Access Protocol\n              (LDAP):
      String Representation of Distinguished Names\",\n              RFC 4514, June
      2006.\n   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n
      \             Encodings\", RFC 4648, October 2006.\n   [RFC5646]  Phillips,
      A. and M. Davis, \"Tags for Identifying\n              Languages\", BCP 47,
      RFC 5646, September 2009.\n   [RFC5649]  Housley, R. and M. Dworkin, \"Advanced
      Encryption Standard\n              (AES) Key Wrap with Padding Algorithm\",
      RFC 5649,\n              September 2009.\n   [SP800-67]\n              National
      Institute of Standards, \"NIST Special Publication\n              800-67 Version
      1.1: Recommendation for the Triple Data\n              Encryption Algorithm
      (TDEA) Block Cipher\", NIST Special\n              Publication 800-67, May 2008.\n
      \  [W3C.REC-xmlschema-2-20041028]\n              Malhotra, A. and P. Biron,
      \"XML Schema Part 2: Datatypes\n              Second Edition\", World Wide Web
      Consortium\n              Recommendation REC-xmlschema-2-20041028, October 2004,\n
      \             <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.\n   [XMLDSIG]
      \ Solo, D., Reagle, J., and D. Eastlake, \"XML-Signature\n              Syntax
      and Processing\", World Wide Web Consortium\n              FirstEdition REC-xmldsig-core-20020212,
      February 2002,\n              <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212>.\n
      \  [XMLENC]   Eastlake, D., \"XML Encryption Syntax and Processing.\",\n              W3C
      Recommendation, December 2002,\n              <http://www.w3.org/TR/xmlenc-core/>.\n
      \  [XMLENC11]\n              Reagle, J. and D. Eastlake, \"XML Encryption Syntax
      and\n              Processing Version 1.1\", World Wide Web Consortium WD WD-\n
      \             xmlenc-core1-20090730, July 2009,\n              <http://www.w3.org/TR/2009/WD-xmlenc-core1-20090730>.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [CAP]      MasterCard International, \"Chip
      Authentication Program\n              Functional Architecture\", September 2004.\n
      \  [IPsec]    Kent, S. and K. Seo, \"Security Architecture for the\n              Internet
      Protocol\", RFC 4301, December 2005.\n   [NIST800-57]\n              Barker,
      E., Barker, W., Burr, W., Polk, W., and M. Smid,\n              \"NIST Special
      Publication 800-57, Recommendation for Key\n              Management Part 1:
      General (Revised)\", NIST Special\n              Publication 800-57, March 2007.\n
      \  [OATH]     \"Initiative for Open AuTHentication\",\n              <http://www.openauthentication.org>.\n
      \  [PSKC-ALGORITHM-PROFILES]\n              Hoyer, P., Pei, M., Machani, S.,
      and A. Doherty,\n              \"Additional Portable Symmetric Key Container
      (PSKC)\n              Algorithm Profiles\", Work in Progress, May 2010.\n   [RFC3986]
      \ Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, January
      2005.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing
      an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n
      \             May 2008.\n   [TLS]      Dierks, T. and E. Rescorla, \"The Transport
      Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August
      2008.\n   [XMLNS]    Hollander, D., Bray, T., and A. Layman, \"Namespaces in\n
      \             XML\", World Wide Web Consortium FirstEdition REC-xml-\n              names-19990114,
      January 1999,\n              <http://www.w3.org/TR/1999/REC-xml-names-19990114>.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - "Appendix A.  Use Cases\n   This section describes a comprehensive list of use
    cases that\n   inspired the development of this specification.  These requirements\n
    \  were used to derive the primary requirement that drove the design.\n   These
    requirements are covered in the next section.\n   These use cases also help in
    understanding the applicability of this\n   specification to real-world situations.\n"
  - contents:
    - "A.1.  Online Use Cases\n   This section describes the use cases related to
      provisioning the keys\n   using an online provisioning protocol.\n"
    - contents:
      - "A.1.1.  Transport of Keys from Server to Cryptographic Module\n   For example,
        a mobile device user wants to obtain a symmetric key for\n   use with a cryptographic
        module on the device.  The cryptographic\n   module from vendor A initiates
        the provisioning process against a\n   provisioning system from vendor B using
        a standards-based\n   provisioning protocol.  The provisioning entity delivers
        one or more\n   keys in a standard format that can be processed by the mobile
        device.\n   For example, in a variation of the above, instead of the user's\n
        \  mobile phone, a key is provisioned in the user's soft token\n   application
        on a laptop using a network-based online protocol.  As\n   before, the provisioning
        system delivers a key in a standard format\n   that can be processed by the
        soft token on the PC.\n   For example, the end user or the key issuer wants
        to update or\n   configure an existing key in the cryptographic module and
        requests a\n   replacement key container.  The container may or may not include
        a\n   new key and may include new or updated key attributes such as a new\n
        \  counter value in HOTP key case, a modified response format or length,\n
        \  a new friendly name, etc.\n"
      title: A.1.1.  Transport of Keys from Server to Cryptographic Module
    - contents:
      - "A.1.2.  Transport of Keys from Cryptographic Module to Cryptographic\n        Module\n
        \  For example, a user wants to transport a key from one cryptographic\n   module
        to another.  There may be two cryptographic modules, one on a\n   computer
        and one on a mobile phone, and the user wants to transport a\n   key from
        the computer to the mobile phone.  The user can export the\n   key and related
        data in a standard format for input into the other\n   cryptographic module.\n"
      title: A.1.2.  Transport of Keys from Cryptographic Module to Cryptographic
    - contents:
      - "A.1.3.  Transport of Keys from Cryptographic Module to Server\n   For example,
        a user wants to activate and use a new key and related\n   data against a
        validation system that is not aware of this key.  This\n   key may be embedded
        in the cryptographic module (e.g., a Secure\n   Digital (SD) card, USB drive)
        that the user has purchased at the\n   local electronics retailer.  Along
        with the cryptographic module, the\n   user may get the key on a CD or a floppy
        in a standard format.  The\n   user can now upload via a secure online channel
        or import this key\n   and related data into the new validation system and
        start using the\n   key.\n"
      title: A.1.3.  Transport of Keys from Cryptographic Module to Server
    - contents:
      - "A.1.4.  Server-to-Server Bulk Import/Export of Keys\n   From time to time,
        a key management system may be required to import\n   or export keys in bulk
        from one entity to another.\n   For example, instead of importing keys from
        a manufacturer using a\n   file, a validation server may download the keys
        using an online\n   protocol.  The keys can be downloaded in a standard format
        that can\n   be processed by a validation system.\n   For example, in a variation
        of the above, an Over-The-Air (OTA) key\n   provisioning gateway that provisions
        keys to mobile phones may obtain\n   key material from a key issuer using
        an online protocol.  The keys\n   are delivered in a standard format that
        can be processed by the key\n   provisioning gateway and subsequently sent
        to the mobile phone of the\n   end user.\n"
      title: A.1.4.  Server-to-Server Bulk Import/Export of Keys
    title: A.1.  Online Use Cases
  - contents:
    - "A.2.  Offline Use Cases\n   This section describes the use cases relating to
      offline transport of\n   keys from one system to another, using some form of
      export and import\n   model.\n"
    - contents:
      - "A.2.1.  Server-to-Server Bulk Import/Export of Keys\n   For example, cryptographic
        modules, such as OTP authentication\n   tokens, may have their symmetric keys
        initialized during the\n   manufacturing process in bulk, requiring copies
        of the keys and\n   algorithm data to be loaded into the authentication system
        through a\n   file on portable media.  The manufacturer provides the keys
        and\n   related data in the form of a file containing records in standard\n
        \  format, typically on a CD.  Note that the token manufacturer and the\n
        \  vendor for the validation system may be the same or different.  Some\n
        \  crypto modules will allow local PIN management (the device will have\n
        \  a PIN pad); hence, random initial PINs set at manufacturing should be\n
        \  transmitted together with the respective keys they protect.\n   For example,
        an enterprise wants to port keys and related data from\n   an existing validation
        system A into a different validation system B.\n   The existing validation
        system provides the enterprise with a\n   functionality that enables export
        of keys and related data (e.g., for\n   OTP authentication tokens) in a standard
        format.  Since the OTP\n   tokens are in the standard format, the enterprise
        can import the\n   token records into the new validation system B and start
        using the\n   existing tokens.  Note that the vendors for the two validation\n
        \  systems may be the same or different.\n"
      title: A.2.1.  Server-to-Server Bulk Import/Export of Keys
    title: A.2.  Offline Use Cases
  title: Appendix A.  Use Cases
- contents:
  - "Appendix B.  Requirements\n   This section outlines the most relevant requirements
    that are the\n   basis of this work.  Several of the requirements were derived
    from\n   use cases described above.\n   R1:   The format MUST support the transport
    of multiple types of\n         symmetric keys and related attributes for algorithms
    including\n         HOTP, other OTP, Challenge/Response, etc.\n   R2:   The format
    MUST handle the symmetric key itself as well of\n         attributes that are
    typically associated with symmetric keys.\n         Some of these attributes may
    be\n         *  Unique Key Identifier\n         *  Issuer information\n         *
    \ Algorithm ID\n         *  Algorithm mode\n         *  Issuer Name\n         *
    \ Key friendly name\n         *  Event counter value (moving factor for OTP algorithms)\n
    \        *  Time value\n   R3:   The format SHOULD support both offline and online
    scenarios.\n         That is, it should be serializable to a file as well as it\n
    \        should be possible to use this format in online provisioning\n         protocols.\n
    \  R4:   The format SHOULD allow bulk representation of symmetric keys.\n   R5:
    \  The format SHOULD allow bulk representation of PINs related to\n         specific
    keys.\n   R6:   The format SHOULD be portable to various platforms.\n         Furthermore,
    it SHOULD be computationally efficient to process.\n   R7:   The format MUST provide
    an appropriate level of security in\n         terms of data encryption and data
    integrity.\n   R8:   For online scenarios, the format SHOULD NOT rely on transport\n
    \        layer security (e.g., Secure Socket Layer/Transport Layer\n         Security
    (SSL/TLS)) for core security requirements.\n   R9:   The format SHOULD be extensible.
    \ It SHOULD enable extension\n         points allowing vendors to specify additional
    attributes in the\n         future.\n   R10:  The format SHOULD allow for distribution
    of key derivation data\n         without the actual symmetric key itself.  This
    is to support\n         symmetric key management schemes that rely on key derivation\n
    \        algorithms based on a pre-placed master key.  The key\n         derivation
    data typically consists of a reference to the key,\n         rather than the key
    value itself.\n   R11:  The format SHOULD allow for additional life cycle management\n
    \        operations such as counter resynchronization.  Such processes\n         require
    confidentiality between client and server, thus could\n         use a common secure
    container format, without the transfer of\n         key material.\n   R12:  The
    format MUST support the use of pre-shared symmetric keys to\n         ensure confidentiality
    of sensitive data elements.\n   R13:  The format MUST support a password-based
    encryption (PBE)\n         [PKCS5] scheme to ensure security of sensitive data
    elements.\n         This is a widely used method for various provisioning\n         scenarios.\n
    \  R14:  The format SHOULD support asymmetric encryption algorithms such\n         as
    RSA to ensure end-to-end security of sensitive data\n         elements.  This
    is to support scenarios where a pre-set shared\n         key encryption key is
    difficult to use.\n"
  title: Appendix B.  Requirements
- contents:
  - "Authors' Addresses\n   Philip Hoyer\n   ActivIdentity, Inc.\n   117 Waterloo
    Road\n   London, SE1  8UL\n   UK\n   Phone: +44 (0) 20 7960 0220\n   EMail: phoyer@actividentity.com\n
    \  Mingliang Pei\n   VeriSign, Inc.\n   487 E. Middlefield Road\n   Mountain View,
    CA  94043\n   USA\n   Phone: +1 650 426 5173\n   EMail: mpei@verisign.com\n   Salah
    Machani\n   Diversinet, Inc.\n   2225 Sheppard Avenue East\n   Suite 1801\n   Toronto,
    Ontario  M2J 5C2\n   Canada\n   Phone: +1 416 756 2324 Ext. 321\n   EMail: smachani@diversinet.com\n"
  title: Authors' Addresses
