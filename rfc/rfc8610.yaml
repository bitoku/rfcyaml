- contents:
  - "    Concise Data Definition Language (CDDL): A Notational Convention\n         to
    Express Concise Binary Object Representation (CBOR)\n                        and
    JSON Data Structures\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document proposes a notational convention to express Concise\n
    \  Binary Object Representation (CBOR) data structures (RFC 7049).  Its\n   main
    goal is to provide an easy and unambiguous way to express\n   structures for protocol
    messages and data formats that use CBOR or\n   JSON.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8610.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Requirements Notation ......................................5\n      1.2.
    Terminology ................................................5\n   2. The Style
    of Data Structure Specification .......................5\n      2.1. Groups and
    Composition in CDDL .............................7\n           2.1.1. Usage ..............................................10\n
    \          2.1.2. Syntax .............................................10\n      2.2.
    Types .....................................................11\n           2.2.1.
    Values .............................................11\n           2.2.2. Choices
    ............................................11\n           2.2.3. Representation
    Types ...............................13\n           2.2.4. Root Type ..........................................14\n
    \  3. Syntax .........................................................15\n      3.1.
    General Conventions .......................................15\n      3.2. Occurrence
    ................................................16\n      3.3. Predefined Names
    for Types ................................17\n      3.4. Arrays ....................................................18\n
    \     3.5. Maps ......................................................19\n           3.5.1.
    Structs ............................................19\n           3.5.2. Tables
    .............................................22\n           3.5.3. Non-deterministic
    Order ............................23\n           3.5.4. Cuts in Maps .......................................24\n
    \     3.6. Tags ......................................................25\n      3.7.
    Unwrapping ................................................26\n      3.8. Controls
    ..................................................27\n           3.8.1. Control
    Operator .size .............................27\n           3.8.2. Control Operator
    .bits .............................28\n           3.8.3. Control Operator .regexp
    ...........................29\n           3.8.4. Control Operators .cbor and .cborseq
    ...............30\n           3.8.5. Control Operators .within and .and .................30\n
    \          3.8.6. Control Operators .lt, .le, .gt, .ge, .eq,\n                  .ne,
    and .default ..................................31\n      3.9. Socket/Plug ...............................................32\n
    \     3.10. Generics .................................................33\n      3.11.
    Operator Precedence ......................................34\n   4. Making Use
    of CDDL .............................................36\n      4.1. As a Guide
    for a Human User ...............................36\n      4.2. For Automated Checking
    of CBOR Data Structures ............36\n      4.3. For Data Analysis Tools ...................................37\n
    \  5. Security Considerations ........................................37\n   6.
    IANA Considerations ............................................38\n      6.1.
    CDDL Control Operators Registry ...........................38\n   7. References
    .....................................................40\n      7.1. Normative
    References ......................................40\n      7.2. Informative References
    ....................................41\n   Appendix A. Parsing Expression Grammars
    (PEGs) ....................43\n   Appendix B. ABNF Grammar ..........................................45\n
    \  Appendix C. Matching Rules ........................................47\n   Appendix
    D. Standard Prelude ......................................52\n   Appendix E. Use
    with JSON .........................................53\n   Appendix F. A CDDL Tool
    ...........................................56\n   Appendix G. Extended Diagnostic
    Notation ..........................56\n     G.1. Whitespace in Byte String Notation
    .........................57\n     G.2. Text in Byte String Notation ...............................57\n
    \    G.3. Embedded CBOR and CBOR Sequences in Byte Strings ...........57\n     G.4.
    Concatenated Strings .......................................58\n     G.5. Hexadecimal,
    Octal, and Binary Numbers .....................59\n     G.6. Comments ...................................................59\n
    \  Appendix H. Examples ..............................................60\n   Acknowledgements
    ..................................................63\n   Contributors ......................................................63\n
    \  Authors' Addresses ................................................64\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   In this document, a notational convention to express Concise
    Binary\n   Object Representation (CBOR) data structures [RFC7049] is defined.\n
    \  The main goal for the convention is to provide a unified notation\n   that
    can be used when defining protocols that use CBOR.  We term the\n   convention
    \"Concise Data Definition Language\", or CDDL.\n   The CBOR notational convention
    has the following goals:\n   (G1)  Provide an unambiguous description of the overall
    structure of\n         a CBOR data item.\n   (G2)  Be flexible in expressing the
    multiple ways in which data can\n         be represented in the CBOR data format.\n
    \  (G3)  Be able to express common CBOR datatypes and structures.\n   (G4)  Provide
    a single format that is both readable and editable for\n         humans and processable
    by a machine.\n   (G5)  Enable automatic checking of CBOR data items for data
    format\n         compliance.\n   (G6)  Enable extraction of specific elements
    from CBOR data for\n         further processing.\n   Not an original goal per
    se, but a convenient side effect of the JSON\n   generic data model being a subset
    of the CBOR generic data model, is\n   the fact that CDDL can also be used for
    describing JSON data\n   structures (see Appendix E).\n   This document has the
    following structure:\n   The syntax of CDDL is defined in Section 3.  Examples
    of CDDL and a\n   related CBOR data item (\"instance\"), some of which use the
    JSON form,\n   are described in Appendix H.  Section 4 discusses usage of CDDL.\n
    \  Examples are provided throughout the text to better illustrate\n   concept
    definitions.  A formal definition of CDDL using ABNF grammar\n   [RFC5234] is
    provided in Appendix B.  Finally, a _prelude_ of\n   standard CDDL definitions
    that is automatically prepended to, and\n   thus available in, every CDDL specification
    is listed in Appendix D.\n"
  - contents:
    - "1.1.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
      in all\n   capitals, as shown here.\n"
    title: 1.1.  Requirements Notation
  - contents:
    - "1.2.  Terminology\n   New terms are introduced in _cursive_, which is rendered
      in plain\n   text as the new term surrounded by underscores.  CDDL text in the\n
      \  running text is in \"typewriter\", which is rendered in plain text as\n   the
      CDDL text in double quotes (double quotes are also used in the\n   usual English
      sense; the reader is expected to disambiguate this by\n   context).\n   In this
      specification, the term \"byte\" is used in its now-customary\n   sense as a
      synonym for \"octet\".\n"
    title: 1.2.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  The Style of Data Structure Specification\n   CDDL focuses on styles of specification
    that are in use in the\n   community employing the data model as pioneered by
    JSON and now\n   refined in CBOR.\n   There are a number of more or less atomic
    elements of a CBOR data\n   model, such as numbers, simple values (false, true,
    nil), text\n   strings, and byte strings; CDDL does not focus on specifying their\n
    \  structure.  CDDL of course also allows adding a CBOR tag to a\n   data item.\n
    \  Beyond those atomic elements, further components of a data structure\n   definition
    language are the datatypes used for composition: arrays\n   and maps in CBOR (called
    \"arrays\" and \"objects\" in JSON).  While\n   these are only two representation
    formats, they are used to specify\n   four loosely distinguishable styles of composition:\n
    \  o  A _vector_: an array of elements that are mostly of the same\n      semantics.
    \ The set of signatures associated with a signed data\n      item is a typical
    application of a vector.\n   o  A _record_: an array the elements of which have
    different,\n      positionally defined semantics, as detailed in the data structure\n
    \     definition.  A 2D point, specified as an array of an x coordinate\n      (which
    comes first) and a y coordinate (coming second), is an\n      example of a record,
    as is the pair of exponent (first) and\n      mantissa (second) in a CBOR decimal
    fraction.\n   o  A _table_: a map from a domain of map keys to a domain of map\n
    \     values, that are mostly of the same semantics.  A set of language\n      tags,
    each mapped to a text string translated to that specific\n      language, is an
    example of a table.  The key domain is usually not\n      limited to a specific
    set by the specification but is open for the\n      application, e.g., in a table
    mapping IP addresses to Media Access\n      Control (MAC) addresses, the specification
    does not attempt to\n      foresee all possible IP addresses.  In a language such
    as\n      JavaScript, a \"Map\" (as opposed to a plain \"Object\") would often\n
    \     be employed to achieve the generality of the key domain.\n   o  A _struct_:
    a map from a domain of map keys as defined by the\n      specification to a domain
    of map values the semantics of each of\n      which is bound to a specific map
    key.  This is what many people\n      have in mind when they think about JSON
    objects; CBOR adds the\n      ability to use map keys that are not just text strings.
    \ Structs\n      can be used to solve problems similar to those records are used\n
    \     for; the use of explicit map keys facilitates optionality and\n      extensibility.\n
    \  Two important concepts provide the foundation for CDDL:\n   1.  Instead of
    defining all four types of composition in CDDL\n       separately, or even defining
    one kind for arrays (vectors and\n       records) and one kind for maps (tables
    and structs), there is\n       only one kind of composition in CDDL: the _group_
    (Section 2.1).\n   2.  The other important concept is that of a _type_.  The entire
    CDDL\n       specification defines a type (the one defined by its first\n       _rule_),
    which formally is the set of CBOR data items that are\n       acceptable as \"instances\"
    for this specification.  CDDL\n       predefines a number of basic types such
    as \"uint\" (unsigned\n       integer) or \"tstr\" (text string), often making
    use of a simple\n       formal notation for CBOR data items.  Each value that
    can be\n       expressed as a CBOR data item is also a type in its own right,\n
    \      e.g., \"1\".  A type can be built as a _choice_ of other types,\n       e.g.,
    an \"int\" is either a \"uint\" or a \"nint\" (negative integer).\n       Finally,
    a type can be built as an array or a map from a group.\n   The rest of this section
    introduces a number of basic concepts of\n   CDDL, and Section 3 defines additional
    syntax.  Appendix C gives a\n   concise summary of the semantics of CDDL.\n"
  - contents:
    - "2.1.  Groups and Composition in CDDL\n   CDDL groups are lists of group _entries_,
      each of which can be a\n   name/value pair or a more complex group expression
      (which then in\n   turn stands for a sequence of name/value pairs).  A CDDL
      group is a\n   production in a grammar that matches certain sequences of name/value\n
      \  pairs but not others.  The grammar is based on the concepts of\n   Parsing
      Expression Grammars (PEGs) (see Appendix A).\n   In an array context, only the
      value of the name/value pair is\n   represented; the name is annotation only
      (and can be left off from\n   the group specification if not needed).  In a
      map context, the names\n   become the map keys (\"member keys\").\n   In an
      array context, the actual sequence of elements in the group is\n   important,
      as that sequence is the information that allows\n   associating actual array
      elements with entries in the group.  In a\n   map context, the sequence of entries
      in a group is not relevant (but\n   there is still a need to write down group
      entries in a sequence).\n   An array matches a specification given as a group
      when the group\n   matches a sequence of name/value pairs the value parts of
      which\n   exactly match the elements of the array in order.\n   A map matches
      a specification given as a group when the group matches\n   a sequence of name/value
      pairs such that all of these name/value\n   pairs are present in the map and
      the map has no name/value pair that\n   is not covered by the group.\n   A simple
      example of using a group directly in a map definition is:\n                             person
      = {\n                               age: int,\n                               name:
      tstr,\n                               employer: tstr,\n                             }\n
      \                Figure 1: Using a Group Directly in a Map\n   The three entries
      of the group are written between the curly braces\n   that create the map: here,
      \"age\", \"name\", and \"employer\" are the\n   names that turn into the map
      key text strings, and \"int\" and \"tstr\"\n   (text string) are the types of
      the map values under these keys.\n   A group by itself (without creating a map
      around it) can be placed in\n   (round) parentheses and given a name by using
      it in a rule:\n                             pii = (\n                               age:
      int,\n                               name: tstr,\n                               employer:
      tstr,\n                             )\n                          Figure 2: A
      Basic Group\n   This separate, named group definition allows us to rephrase\n
      \  Figure 1 as:\n                                person = {\n                                  pii\n
      \                               }\n                      Figure 3: Using a Group
      by Name\n   Note that the (curly) braces signify the creation of a map; the\n
      \  groups themselves are neutral as to whether they will be used in a\n   map
      or an array.\n   As shown in Figure 1, the parentheses for groups are optional
      when\n   there is some other set of brackets present.  Note that they can\n
      \  still be used, leading to this not-so-realistic, but perfectly valid,\n   example:\n
      \                            person = {(\n                               age:
      int,\n                               name: tstr,\n                               employer:
      tstr,\n                             )}\n              Figure 4: Using a Parenthesized
      Group in a Map\n   Groups can be used to factor out common parts of structs,
      e.g.,\n   instead of writing specifications in copy/paste style, such as in\n
      \  Figure 5, one can factor out the common subgroup, choose a name for\n   it,
      and write only the specific parts into the individual maps\n   (Figure 6).\n
      \                         person = {\n                            age: int,\n
      \                           name: tstr,\n                            employer:
      tstr,\n                          }\n                          dog = {\n                            age:
      int,\n                            name: tstr,\n                            leash-length:
      float,\n                          }\n                      Figure 5: Maps with
      Copy/Paste\n                          person = {\n                            identity,\n
      \                           employer: tstr,\n                          }\n                          dog
      = {\n                            identity,\n                            leash-length:
      float,\n                          }\n                          identity = (\n
      \                           age: int,\n                            name: tstr,\n
      \                         )\n                 Figure 6: Using a Group for Factorization\n
      \  Note that the lists inside the braces in the above definitions\n   constitute
      (anonymous) groups, while \"identity\" is a named group,\n   which can then
      be included as part of other groups (anonymous as in\n   the example, or themselves
      named).\n"
    - contents:
      - "2.1.1.  Usage\n   Groups are the instrument used in composing data structures
        with\n   CDDL.  It is a matter of style in defining those structures whether\n
        \  to define groups (anonymously) right in their contexts or whether to\n
        \  define them in a separate rule and to reference them with their\n   respective
        name (possibly more than once).\n   With this, one is allowed to define all
        small parts of their data\n   structures and compose bigger protocol data
        units with those or to\n   have only one big protocol data unit that has all
        definitions ad hoc\n   where needed.\n"
      title: 2.1.1.  Usage
    - contents:
      - "2.1.2.  Syntax\n   The composition syntax is intended to be concise and easy
        to read:\n   o  The start and end of a group can be marked by \"(\" and \")\".\n
        \  o  Definitions of entries inside of a group are noted as follows:\n      _keytype
        => valuetype,_ (read \"keytype maps to valuetype\").  The\n      comma is
        actually optional (not just in the final entry), but it\n      is considered
        good style to set it.  The double arrow can be\n      replaced by a colon
        in the common case of directly using a text\n      string or integer literal
        as a key; see Section 3.5.1.  This is\n      also the common way of naming
        elements of an array just for\n      documentation; see Section 3.4.\n   A
        basic entry consists of a _keytype_ and a _valuetype_, both of\n   which are
        types (Section 2.2); this entry matches any name/value pair\n   the name of
        which is in the keytype and the value of which is in the\n   valuetype.\n
        \  A group defined as a sequence of group entries matches any sequence\n   of
        name/value pairs that is composed by concatenation in order of\n   what the
        entries match.\n   A group definition can also contain choices between groups;
        see\n   Section 2.2.2.\n"
      title: 2.1.2.  Syntax
    title: 2.1.  Groups and Composition in CDDL
  - contents:
    - '2.2.  Types

      '
    - contents:
      - "2.2.1.  Values\n   Values such as numbers and strings can be used in place
        of a type.\n   (For instance, this is a very common thing to do for a key
        type,\n   common enough that CDDL provides additional convenience syntax\n
        \  for this.)\n   The value notation is based on the C language, but does
        not offer all\n   the syntactic variations (see Appendix B for details).  The
        value\n   notation for numbers inherits from C the distinction between integer\n
        \  values (no fractional part or exponent given -- NR1 [ISO6093];\n   \"NR\"
        stands for \"numerical representation\") and floating-point values\n   (where
        a fractional part, an exponent, or both are present -- NR2 or\n   NR3), so
        the type \"1\" does not include any floating-point numbers\n   while the types
        \"1e3\" and \"1.5\" are both floating-point numbers and\n   do not include
        any integer numbers.\n"
      title: 2.2.1.  Values
    - contents:
      - "2.2.2.  Choices\n   Many places that allow a type also allow a choice between
        types,\n   delimited by a \"/\" (slash).  The entire choice construct can
        be put\n   into parentheses if this is required to make the construction\n
        \  unambiguous (please see Appendix B for details of the CDDL grammar).\n
        \  Choices of values can be used to express enumerations:\n            attire
        = \"bow tie\" / \"necktie\" / \"Internet attire\"\n            protocol =
        6 / 17\n   Analogous to types, CDDL also allows choices between groups,\n
        \  delimited by a \"//\" (double slash).  Note that the \"//\" operator\n
        \  binds much more weakly than the other CDDL operators, so each line\n   within
        \"delivery\" in the following example is its own alternative in\n   the group
        choice:\n                   address = { delivery }\n                   delivery
        = (\n                   street: tstr, ? number: uint, city //\n                   po-box:
        uint, city //\n                   per-pickup: true )\n                   city
        = (\n                   name: tstr, zip-code: uint\n                   )\n
        \  A group choice matches the union of the sets of name/value pair\n   sequences
        that the alternatives in the choice can.\n   For both type choices and group
        choices, additional alternatives can\n   be added to a rule later in separate
        rules by using \"/=\" and \"//=\",\n   respectively, instead of \"=\":\n                 attire
        /= \"swimwear\"\n                 delivery //= (\n                 lat: float,
        long: float, drone-type: tstr\n                 )\n   It is not an error if
        a name is first used with a \"/=\" or \"//=\"\n   (there is no need to \"create
        it\" with \"=\").\n"
      - contents:
        - "2.2.2.1.  Ranges\n   Instead of naming all the values that make up a choice,
          CDDL allows\n   building a _range_ out of two values that are in an ordering\n
          \  relationship: a lower bound (first value) and an upper bound (second\n
          \  value).  A range can be inclusive of both bounds given (denoted by\n
          \  joining two values by \"..\"), or it can include the lower bound and\n
          \  exclude the upper bound (denoted by instead using \"...\").  If the\n
          \  lower bound exceeds the upper bound, the resulting type is the empty\n
          \  set (this behavior can be desirable when generics (Section 3.10) are\n
          \  being used).\n         device-address = byte\n         max-byte = 255\n
          \        byte = 0..max-byte ; inclusive range\n         first-non-byte =
          256\n         byte1 = 0...first-non-byte ; byte1 is equivalent to byte\n
          \  CDDL currently only allows ranges between integers (matching integer\n
          \  values) or between floating-point values (matching floating-point\n   values).
          \ If both are needed in a type, a type choice between the two\n   kinds
          of ranges can be (clumsily) used:\n                int-range = 0..10 ; only
          integers match\n                float-range = 0.0..10.0 ; only floats match\n
          \               BAD-range1 = 0..10.0 ; NOT DEFINED\n                BAD-range2
          = 0.0..10 ; NOT DEFINED\n                numeric-range = int-range / float-range\n
          \  (See also the control operators .lt/.ge and .le/.gt in\n   Section 3.8.6.)\n
          \  Note that the dot is a valid name continuation character in CDDL, so\n
          \     min..max\n   is not a range expression but a single name.  When using
          a name as\n   the left-hand side of a range operator, use spacing as in\n
          \     min .. max\n   to separate off the range operator.\n"
        title: 2.2.2.1.  Ranges
      - contents:
        - "2.2.2.2.  Turning a Group into a Choice\n   Some choices are built out
          of large numbers of values, often\n   integers, each of which is best given
          a semantic name in the\n   specification.  Instead of naming each of these
          integers and then\n   accumulating them into a choice, CDDL allows building
          a choice from a\n   group by prefixing it with an \"&\" character:\n              terminal-color
          = &basecolors\n              basecolors = (\n                black: 0,  red:
          1,  green: 2,  yellow: 3,\n                blue: 4,  magenta: 5,  cyan:
          6,  white: 7,\n              )\n              extended-color = &(\n                basecolors,\n
          \               orange: 8,  pink: 9,  purple: 10,  brown: 11,\n              )\n
          \  As with the use of groups in arrays (Section 3.4), the member names\n
          \  have only documentary value (in particular, they might be used by a\n
          \  tool when displaying integers that are taken from that choice).\n"
        title: 2.2.2.2.  Turning a Group into a Choice
      title: 2.2.2.  Choices
    - contents:
      - "2.2.3.  Representation Types\n   CDDL allows the specification of a data
        item type by referring to the\n   CBOR representation (specifically, to major
        types and additional\n   information; see Section 2 of [RFC7049]).  How this
        is used should be\n   evident from the prelude (Appendix D): a hash mark (\"#\")
        optionally\n   followed by a number from 0 to 7 identifying the major type,
        which\n   then can be followed by a dot and a number specifying the additional\n
        \  information.  This construction specifies the set of values that can\n
        \  be serialized in CBOR (i.e., \"any\"), by the given major type if one\n
        \  is given, or by the given major type with the additional information\n
        \  if both are given.  Where a major type of 6 (Tag) is used, the type\n   of
        the tagged item can be specified by appending it in parentheses.\n   Note
        that although this notation is based on the CBOR serialization,\n   it is
        about a set of values at the data model level, e.g., \"#7.25\"\n   specifies
        the set of values that can be represented as half-precision\n   floats; it
        does not mandate that these values also do have to be\n   serialized as half-precision
        floats: CDDL does not provide any\n   language means to restrict the choice
        of serialization variants.\n   This also enables the use of CDDL with JSON,
        which uses a\n   fundamentally different way of serializing (some of) the
        same values.\n   It may be necessary to make use of representation types outside
        the\n   prelude, e.g., a specification could start by making use of an\n   existing
        tag in a more specific way or could define a new tag not\n   defined in the
        prelude:\n      my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!\n
        \     breakfast = cereal / porridge\n      cereal = #6.998(tstr)\n      porridge
        = #6.999([liquid, solid])\n      liquid = milk / water\n      milk = 0\n      water
        = 1\n      solid = tstr\n"
      title: 2.2.3.  Representation Types
    - contents:
      - "2.2.4.  Root Type\n   There is no special syntax to identify the root of
        a CDDL data\n   structure definition: that role is simply taken by the first
        rule\n   defined in the file.\n   This is motivated by the usual top-down
        approach for defining data\n   structures, decomposing a big data structure
        unit into smaller parts;\n   however, except for the root type, there is no
        need to strictly\n   follow this sequence.\n   (Note that there is no way
        to use a group as a root -- it must be\n   a type.)\n"
      title: 2.2.4.  Root Type
    title: 2.2.  Types
  title: 2.  The Style of Data Structure Specification
- contents:
  - "3.  Syntax\n   In this section, the overall syntax of CDDL is shown, alongside
    some\n   examples just illustrating syntax.  (The definition does not attempt\n
    \  to be overly formal; refer to Appendix B for details.)\n"
  - contents:
    - "3.1.  General Conventions\n   The basic syntax is inspired by ABNF [RFC5234],
      with the following:\n   o  Rules, whether they define groups or types, are defined
      with a\n      name, followed by an equals sign \"=\" and the actual definition\n
      \     according to the respective syntactic rules of that definition.\n   o
      \ A name can consist of any of the characters from the set {\"A\" to\n      \"Z\",
      \"a\" to \"z\", \"0\" to \"9\", \"_\", \"-\", \"@\", \".\", \"$\"}, starting\n
      \     with an alphabetic character (including \"@\", \"_\", \"$\") and ending\n
      \     in such a character or a digit.\n      *  Names are case sensitive.\n
      \     *  It is preferred style to start a name with a lowercase letter.\n      *
      \ The hyphen is preferred over the underscore (except in a\n         \"bareword\"
      (Section 3.5.1), where the semantics may actually\n         require an underscore).\n
      \     *  The period may be useful for larger specifications, to express\n         some
      module structure (as in \"tcp.throughput\" vs.\n         \"udp.throughput\").\n
      \     *  A number of names are predefined in the CDDL prelude, as listed\n         in
      Appendix D.\n      *  Rule names (types or groups) do not appear in the actual
      CBOR\n         encoding, but names used as \"barewords\" in member keys do.\n
      \  o  Comments are started by a \";\" (semicolon) character and finish at\n
      \     the end of a line (LF or CRLF).\n   o  Except within strings, whitespace
      (spaces, newlines, and comments)\n      is used to separate syntactic elements
      for readability (and to\n      separate identifiers, range operators, or numbers
      that follow each\n      other); it is otherwise completely optional.\n   o  Hexadecimal
      numbers are preceded by \"0x\" (without quotes) and are\n      case insensitive.
      \ Similarly, binary numbers are preceded by \"0b\".\n   o  Text strings are
      enclosed by double quotation '\"' characters.\n      They follow the conventions
      for strings as defined in Section 7 of\n      [RFC8259].  (ABNF users may want
      to note that there is no support\n      in CDDL for the concept of case insensitivity
      in text strings; if\n      necessary, regular expressions can be used (Section
      3.8.3).)\n   o  Byte strings are enclosed by single quotation \"'\" characters
      and\n      may be prefixed by \"h\" or \"b64\".  If unprefixed, the string is\n
      \     interpreted as with a text string, except that single quotes must\n      be
      escaped and that the resulting UTF-8 bytes are marked as a byte\n      string
      (major type 2).  If prefixed as \"h\" or \"b64\", the string is\n      interpreted
      as a sequence of pairs of hex digits (base16; see\n      Section 8 of [RFC4648])
      or a base64(url) string (Section 4 or\n      Section 5 of [RFC4648]), respectively
      (as with the diagnostic\n      notation in Section 6 of [RFC7049]; cf. Appendix
      G.2); any\n      whitespace present within the string (including comments) is\n
      \     ignored in the prefixed case.\n   o  CDDL uses UTF-8 [RFC3629] for its
      encoding.  Processing of CDDL\n      does not involve Unicode normalization
      processes.\n   Example:\n                    ; This is a comment\n                    person
      = { g }\n                    g = (\n                      \"name\": tstr,\n
      \                     age: int,  ; \"age\" is a bareword\n                    )\n"
    title: 3.1.  General Conventions
  - contents:
    - "3.2.  Occurrence\n   An optional _occurrence_ indicator can be given in front
      of a group\n   entry.  It is either (1) one of the characters \"?\" (optional),
      \"*\"\n   (zero or more), or \"+\" (one or more) or (2) of the form n*m, where
      n\n   and m are optional unsigned integers and n is the lower limit\n   (default
      0) and m is the upper limit (default no limit) of\n   occurrences.\n   If no
      occurrence indicator is specified, the group entry is to occur\n   exactly once
      (as if 1*1 were specified).  A group entry with an\n   occurrence indicator
      matches sequences of name/value pairs that are\n   composed by concatenating
      a number of sequences that the basic group\n   entry matches, where the number
      needs to be allowed by the occurrence\n   indicator.\n   Note that CDDL, outside
      any directives/annotations that could\n   possibly be defined, does not make
      any prescription as to whether\n   arrays or maps use definite-length or indefinite-length
      encoding.\n   That is, there is no correlation between leaving the size of an
      array\n   \"open\" in the spec and the fact that it is then interchanged with\n
      \  definite or indefinite length.\n   Please also note that CDDL can describe
      flexibility that the data\n   model of the target representation does not have.
      \ This is rather\n   obvious for JSON but is also relevant for CBOR:\n                           apartment
      = {\n                             kitchen: size,\n                             *
      bedroom: size,\n                           }\n                           size
      = float ; in m2\n   The previous specification does not mean that CBOR is changed
      to\n   allow using the key \"bedroom\" more than once.  In other words, due
      to\n   the restrictions imposed by the data model, the third line pretty\n   much
      turns into:\n                             ? bedroom: size,\n   (Occurrence indicators
      beyond one are still useful in maps for groups\n   that allow a variety of keys.)\n"
    title: 3.2.  Occurrence
  - contents:
    - "3.3.  Predefined Names for Types\n   CDDL predefines a number of names.  This
      subsection summarizes these\n   names, but please see Appendix D for the exact
      definitions.\n   The following keywords for primitive datatypes are defined:\n
      \  \"bool\"  Boolean value (major type 7, additional information 20\n      or
      21).\n   \"uint\"  An unsigned integer (major type 0).\n   \"nint\"  A negative
      integer (major type 1).\n   \"int\"  An unsigned integer or a negative integer.\n
      \  \"float16\"  A number representable as a half-precision float [IEEE754]\n
      \     (major type 7, additional information 25).\n   \"float32\"  A number representable
      as a single-precision float\n      [IEEE754] (major type 7, additional information
      26).\n   \"float64\"  A number representable as a double-precision float\n      [IEEE754]
      (major type 7, additional information 27).\n   \"float\"  One of float16, float32,
      or float64.\n   \"bstr\" or \"bytes\"  A byte string (major type 2).\n   \"tstr\"
      or \"text\"  Text string (major type 3).\n   (Note that there are no predefined
      names for arrays or maps; these\n   are defined with the syntax given below.)\n
      \  In addition, a number of types are defined in the prelude that are\n   associated
      with CBOR tags, such as \"tdate\", \"bigint\", \"regexp\", etc.\n"
    title: 3.3.  Predefined Names for Types
  - contents:
    - "3.4.  Arrays\n   Array definitions surround a group with square brackets.\n
      \  For each entry, an occurrence indicator as specified in Section 3.2\n   is
      permitted.\n   For example:\n                     unlimited-people = [* person]\n
      \                    one-or-two-people = [1*2 person]\n                     at-least-two-people
      = [2* person]\n                     person = (\n                         name:
      tstr,\n                         age: uint,\n                     )\n   The group
      \"person\" is defined in such a way that repeating it in the\n   array each
      time generates alternating names and ages, so these are\n   four valid values
      for a data item of type \"unlimited-people\":\n      [\"roundlet\", 1047, \"psychurgy\",
      2204, \"extrarhythmical\", 2231]\n      []\n      [\"aluminize\", 212, \"climograph\",
      4124]\n      [\"penintime\", 1513, \"endocarditis\", 4084, \"impermeator\",
      1669,\n       \"coextension\", 865]\n"
    title: 3.4.  Arrays
  - contents:
    - "3.5.  Maps\n   The syntax for specifying maps merits special attention, as
      well as a\n   number of optimizations and conveniences, as it is likely to be
      the\n   focal point of many specifications employing CDDL.  While the syntax\n
      \  does not strictly distinguish struct and table usage of maps, it\n   caters
      specifically to each of them.\n   But first, let's reiterate a feature of CBOR
      that it has inherited\n   from JSON: the key/value pairs in CBOR maps have no
      fixed ordering.\n   (One could imagine situations where fixing the ordering
      may be of\n   use.  For example, a decoder could look for values related with\n
      \  integer keys 1, 3, and 7.  If the order were fixed and the decoder\n   encounters
      the key 4 without having encountered key 3, it could\n   conclude that key 3
      is not available without doing more complicated\n   bookkeeping.  Unfortunately,
      neither JSON nor CBOR supports this, so\n   no attempt was made to support this
      in CDDL either.)\n"
    - contents:
      - "3.5.1.  Structs\n   The \"struct\" usage of maps is similar to the way JSON
        objects are\n   used in many JSON applications.\n   A map is defined in the
        same way as that for defining an array (see\n   Section 3.4), except for using
        curly braces \"{}\" instead of square\n   brackets \"[]\".\n   An occurrence
        indicator as specified in Section 3.2 is permitted for\n   each group entry.\n
        \  The following is an example of a record with a structure embedded:\n       Geography
        = [\n         city           : tstr,\n         gpsCoordinates : GpsCoordinates,\n
        \      ]\n       GpsCoordinates = {\n         longitude      : uint,            ;
        degrees, scaled by 10^7\n         latitude       : uint,            ; degrees,
        scaled by 10^7\n       }\n   When encoding, the Geography record is encoded
        using a CBOR array\n   with two members (the keys for the group entries are
        ignored),\n   whereas the GpsCoordinates structure is encoded as a CBOR map
        with\n   two key/value pairs.\n   Types used in a structure can be defined
        in separate rules or just in\n   place (potentially placed inside parentheses,
        such as for choices).\n   For example:\n                           located-samples
        = {\n                             sample-point: int,\n                             samples:
        [+ float],\n                           }\n   where \"located-samples\" is
        the datatype to be used when referring to\n   the struct, and \"sample-point\"
        and \"samples\" are the keys to be used.\n   This is actually a complete example:
        an identifier that is followed\n   by a colon can be directly used as the
        text string for a member key\n   (we speak of a \"bareword\" member key),
        as can a double-quoted string\n   or a number.  (When other types -- in particular,
        types that contain\n   more than one value -- are used as the types of keys,
        they are\n   followed by a double arrow; see below.)\n   If a text string
        key does not match the syntax for an identifier (or\n   if the specifier just
        happens to prefer using double quotes), the\n   text string syntax can also
        be used in the member key position,\n   followed by a colon.  The above example
        could therefore have been\n   written with quoted strings in the member key
        positions.\n   More generally, types specified in ways other than those listed
        for\n   the cases described above can be used in a key-type position by\n
        \  following them with a double arrow -- in particular, the double arrow\n
        \  is necessary if a type is named by an identifier (which, when\n   followed
        by a colon, would be interpreted as a \"bareword\" and turned\n   into a text
        string).  A literal text string also gives rise to a type\n   (which contains
        a single value only -- the given string), so another\n   form for this example
        is:\n                         located-samples = {\n                           \"sample-point\"
        => int,\n                           \"samples\" => [+ float],\n                         }\n
        \  See Section 3.5.4 below for how the colon (\":\") shortcut described\n
        \  here also adds some implied semantics.\n   A better way to demonstrate
        the use of the double arrow may be:\n             located-samples = {\n               sample-point:
        int,\n               samples: [+ float],\n               * equipment-type
        => equipment-tolerances,\n             }\n             equipment-type = [name:
        tstr, manufacturer: tstr]\n             equipment-tolerances = [+ [float,
        float]]\n   The example below defines a struct with optional entries: display\n
        \  name (as a text string), the name components first name and family\n   name
        (as text strings), and age information (as an unsigned integer).\n                          PersonalData
        = {\n                            ? displayName: tstr,\n                            NameComponents,\n
        \                           ? age: uint,\n                          }\n                          NameComponents
        = (\n                            ? firstName: tstr,\n                            ?
        familyName: tstr,\n                          )\n   Note that the group definition
        for NameComponents does not generate\n   another map; instead, all four keys
        are directly in the struct built\n   by PersonalData.\n   In this example,
        all key/value pairs are optional from the\n   perspective of CDDL.  With no
        occurrence indicator, an entry is\n   mandatory.\n   If the addition of more
        entries not specified by the current\n   specification is desired, one can
        add this possibility explicitly:\n                          PersonalData =
        {\n                            ? displayName: tstr,\n                            NameComponents,\n
        \                           ? age: uint,\n                            * tstr
        => any\n                          }\n                          NameComponents
        = (\n                            ? firstName: tstr,\n                            ?
        familyName: tstr,\n                          )\n            Figure 7: Personal
        Data: Example for Extensibility\n   The CDDL tool described in Appendix F
        generated the following as one\n   acceptable instance for this specification:\n
        \        {\"familyName\": \"agust\", \"antiforeignism\": \"pretzel\",\n          \"springbuck\":
        \"illuminatingly\", \"exuviae\": \"ephemeris\",\n          \"kilometrage\":
        \"frogfish\"}\n   (See Section 3.9 for one way to explicitly identify an extension\n
        \  point.)\n"
      title: 3.5.1.  Structs
    - contents:
      - "3.5.2.  Tables\n   A table can be specified by defining a map with entries
        where the\n   key type allows more than just a single value; for example:\n
        \                        square-roots = {* x => y}\n                         x
        = int\n                         y = float\n   Here, the key in each key/value
        pair has datatype x (defined as int),\n   and the value has datatype y (defined
        as float).\n   If the specification does not need to restrict one of x or
        y (i.e.,\n   the application is free to choose per entry), it can be replaced
        by\n   the predefined name \"any\".\n   As another example, the following
        could be used as a conversion table\n   converting from an integer or float
        to a string:\n                      tostring = {* mynumber => tstr}\n                      mynumber
        = int / float\n"
      title: 3.5.2.  Tables
    - contents:
      - "3.5.3.  Non-deterministic Order\n   While the way arrays are matched is fully
        determined by the PEG\n   formalism (see Appendix A), matching is more complicated
        for maps, as\n   maps do not have an inherent order.  For each candidate name/value\n
        \  pair that the PEG algorithm would try, a matching member is picked\n   out
        of the entire map.  For certain group expressions, more than one\n   member
        in the map may match.  Most often, this is inconsequential, as\n   the group
        expression tends to consume all matches:\n                            labeled-values
        = {\n                              ? fritz: number,\n                              *
        label => value\n                            }\n                            label
        = text\n                            value = number\n   Here, if any member
        with the key \"fritz\" is present, this will be\n   picked by the first entry
        of the group; all remaining text/number\n   members will be picked by the
        second entry (and if anything remains\n   unpicked, the map does not match).\n
        \  However, it is possible to construct group expressions where what is\n
        \  actually picked is indeterminate, but does matter:\n                            do-not-do-this
        = {\n                              int => int,\n                              int
        => 6,\n                            }\n   When this expression is matched against
        \"{3: 5, 4: 6}\", the first\n   group entry might pick off the \"3: 5\", leaving
        \"4: 6\" for matching\n   the second one.  Or it might pick off \"4: 6\",
        leaving nothing for the\n   second entry.  This pathological non-determinism
        is caused by\n   specifying \"more general\" before \"more specific\" and
        by having a\n   general rule that only consumes a subset of the map key/value
        pairs\n   that it is able to match -- both tend not to occur in real-world\n
        \  specifications of maps.  At the time of writing, CDDL tools cannot\n   detect
        such cases automatically, and for the present version of the\n   CDDL specification,
        the specification writer is simply urged to not\n   write pathologically non-deterministic
        specifications.\n   (The astute reader will be reminded of what was called
        \"ambiguous\n   content models\" in the Standard Generalized Markup Language
        (SGML)\n   and \"non-deterministic content models\" in XML.  That problem
        is\n   related to the one described here, but the problem here is\n   specifically
        caused by the lack of order in maps, something that the\n   XML schema languages
        do not have to contend with.  Note that\n   RELAX NG's \"interleave\" pattern
        handles lack of order explicitly on\n   the specification side, while the
        instances in XML always have\n   determinate order.)\n"
      title: 3.5.3.  Non-deterministic Order
    - contents:
      - "3.5.4.  Cuts in Maps\n   The extensibility idiom discussed above for structs
        has one problem:\n                        extensible-map-example = {\n                          ?
        \"optional-key\" => int,\n                          * tstr => any\n                        }\n
        \  In this example, there is one optional key \"optional-key\", which,\n   when
        present, maps to an integer.  There is also a wildcard for any\n   future
        additions.\n   Unfortunately, the data item\n                      { \"optional-key\":
        \"nonsense\" }\n   does match this specification: while the first entry of
        the group\n   does not match, the second one (the wildcard) does.  This may
        very\n   well be desirable (e.g., if a future extension is to be allowed to\n
        \  extend the type of \"optional-key\"), but in many cases it isn't.\n   In
        anticipation of a more general potential feature called \"cuts\",\n   CDDL
        allows inserting a cut \"^\" into the definition of the map entry:\n                       extensible-map-example
        = {\n                         ? \"optional-key\" ^ => int,\n                         *
        tstr => any\n                       }\n   A cut in this position means that
        once the member key matches the\n   name part of an entry that carries a cut,
        other potential matches for\n   the key of the member that occur in later
        entries in the group of the\n   map are no longer allowed.  In other words,
        when a group entry would\n   pick a key/value pair based on just a matching
        key, it \"locks in\" the\n   pick -- this rule applies, independently of whether
        the value matches\n   as well, so when it does not, the entire map fails to
        match.  In\n   summary, the example above no longer matches the specification
        as\n   modified with the cut.\n   Since the desire for this kind of exclusive
        matching is so frequent,\n   the \":\" shortcut is actually defined to include
        the cut semantics.\n   So, the preceding example (including the cut) can be
        written more\n   simply as:\n                        extensible-map-example
        = {\n                          ? \"optional-key\": int,\n                          *
        tstr => any\n                        }\n   or even shorter, using a bareword
        for the key:\n                        extensible-map-example = {\n                          ?
        optional-key: int,\n                          * tstr => any\n                        }\n"
      title: 3.5.4.  Cuts in Maps
    title: 3.5.  Maps
  - contents:
    - "3.6.  Tags\n   A type can make use of a CBOR tag (major type 6) by using the\n
      \  representation type notation, giving #6.nnn(type) where nnn is an\n   unsigned
      integer giving the tag number and \"type\" is the type of the\n   data item
      being tagged.\n   For example, the following line from the CDDL prelude (Appendix
      D)\n   defines \"biguint\" as a type name for an unsigned bignum N:\n                           biguint
      = #6.2(bstr)\n   The tags defined by [RFC7049] are included in the prelude.\n
      \  Additional tags registered since [RFC7049] was written need to be\n   added
      to a CDDL specification as needed; e.g., a binary Universally\n   Unique Identifier
      (UUID) tag could be referenced as \"buuid\" in a\n   specification after defining\n
      \                           buuid = #6.37(bstr)\n   In the following example,
      usage of tag 32 for URIs is optional:\n                        my_uri = #6.32(tstr)
      / tstr\n"
    title: 3.6.  Tags
  - contents:
    - "3.7.  Unwrapping\n   The group that is used to define a map or an array can
      often be\n   reused in the definition of another map or array.  Similarly, a
      type\n   defined as a tag carries an internal data item that one would like
      to\n   refer to.  In these cases, it is expedient to simply use the name of\n
      \  the map, array, or tag type as a handle for the group or type defined\n   inside
      it.\n   The \"unwrap\" operator (written by preceding a name by a tilde\n   character
      \"~\") can be used to strip the type defined for a name by\n   one layer, exposing
      the underlying group (for maps and arrays) or\n   type (for tags).\n   For example,
      an application might want to define a basic header and\n   an advanced header.
      \ Without unwrapping, this might be done as\n   follows:\n             basic-header-group
      = (\n               field1: int,\n               field2: text,\n             )\n
      \            basic-header = [ basic-header-group ]\n             advanced-header
      = [\n               basic-header-group,\n               field3: bytes,\n               field4:
      number, ; as in the tagged type \"time\"\n             ]\n   Unwrapping simplifies
      this to:\n                            basic-header = [\n                              field1:
      int,\n                              field2: text,\n                            ]\n
      \                           advanced-header = [\n                              ~basic-header,\n
      \                             field3: bytes,\n                              field4:
      ~time,\n                            ]\n   (Note that leaving out the first unwrap
      operator in the latter\n   example would lead to nesting the basic-header in
      its own array\n   inside the advanced-header, while, with the unwrapped basic-header,\n
      \  the definition of the group inside basic-header is essentially\n   repeated
      inside advanced-header, leading to a single array.  This can\n   be used for
      various applications often solved by inheritance in\n   programming languages.
      \ The effect of unwrapping can also be\n   described as \"threading in\" the
      group or type inside the referenced\n   type, which suggested the thread-like
      \"~\" character.)\n"
    title: 3.7.  Unwrapping
  - contents:
    - "3.8.  Controls\n   A _control_ allows relating a _target_ type with a _controller_
      type\n   via a _control operator_.\n   The syntax for a control type is \"target
      .control-operator\n   controller\", where control operators are special identifiers
      prefixed\n   by a dot.  (Note that _target_ or _controller_ might need to be\n
      \  parenthesized.)\n   A number of control operators are defined at this point.
      \ Further\n   control operators may be defined by new versions of this\n   specification
      or by registering them according to the procedures in\n   Section 6.1.\n"
    - contents:
      - "3.8.1.  Control Operator .size\n   A \".size\" control controls the size
        of the target in bytes by the\n   control type.  The control is defined for
        text and byte strings,\n   where it directly controls the number of bytes
        in the string.  It is\n   also defined for unsigned integers (see below).
        \ Figure 8 shows\n   example usage for byte strings.\n                   full-address
        = [[+ label], ip4, ip6]\n                   ip4 = bstr .size 4\n                   ip6
        = bstr .size 16\n                   label = bstr .size (1..63)\n                    Figure
        8: Control for Size in Bytes\n   When applied to an unsigned integer, the
        \".size\" control restricts\n   the range of that integer by giving a maximum
        number of bytes that\n   should be needed in a computer representation of
        that unsigned\n   integer.  In other words, \"uint .size N\" is equivalent
        to\n   \"0...BYTES_N\", where BYTES_N == 256**N.\n     audio_sample = uint
        .size 3 ; 24-bit, equivalent to 0...16777216\n                Figure 9: Control
        for Integer Size in Bytes\n   Note that, as with value restrictions in CDDL,
        this control is not a\n   representation constraint; a number that fits into
        fewer bytes can\n   still be represented in that form, and an inefficient
        implementation\n   could use a longer form (unless that is restricted by some
        format\n   constraints outside of CDDL, such as the rules in Section 3.9 of\n
        \  [RFC7049]).\n"
      title: 3.8.1.  Control Operator .size
    - contents:
      - "3.8.2.  Control Operator .bits\n   A \".bits\" control on a byte string indicates
        that, in the target,\n   only the bits numbered by a number in the control
        type are allowed to\n   be set.  (Bits are counted the usual way, bit number
        \"n\" being set in\n   \"str\" meaning that \"(str[n >> 3] & (1 << (n & 7)))
        != 0\".)\n   Similarly, a \".bits\" control on an unsigned integer \"i\" indicates\n
        \  that for all unsigned integers \"n\" where \"(i & (1 << n)) != 0\", \"n\"\n
        \  must be in the control type.\n                      tcpflagbytes = bstr
        .bits flags\n                      flags = &(\n                        fin:
        8,\n                        syn: 9,\n                        rst: 10,\n                        psh:
        11,\n                        ack: 12,\n                        urg: 13,\n
        \                       ece: 14,\n                        cwr: 15,\n                        ns:
        0,\n                      ) / (4..7) ; data offset bits\n                      rwxbits
        = uint .bits rwx\n                      rwx = &(r: 2, w: 1, x: 0)\n                Figure
        10: Control for What Bits Can Be Set\n   The CDDL tool described in Appendix
        F generates the following ten\n   example instances for \"tcpflagbytes\":\n
        \     h'906d' h'01fc' h'8145' h'01b7' h'013d' h'409f' h'018e' h'c05f'\n      h'01fa'
        h'01fe'\n   These examples do not illustrate that the above CDDL specification\n
        \  does not explicitly specify a size of two bytes: a valid all-clear\n   instance
        of flag bytes could be \"h''\" or \"h'00'\" or even \"h'000000'\"\n   as well.\n"
      title: 3.8.2.  Control Operator .bits
    - contents:
      - "3.8.3.  Control Operator .regexp\n   A \".regexp\" control indicates that
        the text string given as a target\n   needs to match the XML Schema Definition
        (XSD) regular expression\n   given as a value in the control type.  XSD regular
        expressions are\n   defined in Appendix F of [W3C.REC-xmlschema-2-20041028].\n
        \    nai = tstr .regexp \"[A-Za-z0-9]+@[A-Za-z0-9]+(\\\\.[A-Za-z0-9]+)+\"\n
        \                  Figure 11: Control with an XSD regexp\n   An example matching
        this regular expression:\n                       \"N1@CH57HF.4Znqe0.dYJRN.igjf\"\n"
      - contents:
        - "3.8.3.1.  Usage Considerations\n   Note that XSD regular expressions do
          not support the usual \\x or \\u\n   escapes for hexadecimal expression
          of bytes or Unicode code points.\n   However, in CDDL the XSD regular expressions
          are contained in text\n   strings, the literal notation for which provides
          \\u escapes; this\n   should suffice for most applications that use regular
          expressions for\n   text strings.  (Note that this also means that there
          is one level of\n   string escaping before the XSD escaping rules are applied.)\n
          \  XSD regular expressions support character class subtraction, a\n   feature
          often not found in regular expression libraries;\n   specification writers
          may want to use this feature sparingly.\n   Similar considerations apply
          to Unicode character classes; where\n   these are used, the specification
          that employs CDDL SHOULD identify\n   which Unicode versions are addressed.\n
          \  Other surprises for infrequent users of XSD regular expressions may\n
          \  include the following:\n   o  No direct support for case insensitivity.
          \ While case\n      insensitivity has gone mostly out of fashion in protocol
          design,\n      it is sometimes needed and then needs to be expressed manually
          as\n      in \"[Cc][Aa][Ss][Ee]\".\n   o  The support for popular character
          classes such as \\w and \\d is\n      based on Unicode character properties;
          this is often not what is\n      desired in an ASCII-based protocol and
          thus might lead to\n      surprises.  (\\s and \\S do have their more conventional
          meanings,\n      and \".\" matches any character but the line-ending characters
          \\r\n      or \\n.)\n"
        title: 3.8.3.1.  Usage Considerations
      - contents:
        - "3.8.3.2.  Discussion\n   There are many flavors of regular expression in
          use in the\n   programming community.  For instance, Perl-Compatible Regular\n
          \  Expressions (PCREs) are widely used and probably are more useful than\n
          \  XSD regular expressions.  However, there is no normative reference\n
          \  for PCREs that could be used in the present document.  Instead, we\n
          \  opt for XSD regular expressions for now.  There is precedent for that\n
          \  choice in the IETF, e.g., in YANG [RFC7950].\n   Note that CDDL uses
          controls as its main extension point.  This\n   creates the opportunity
          to add further regular expression formats in\n   addition to the one referenced
          here, if desired.  As an example, a\n   proposal for a \".pcre\" control
          is defined in [CDDL-Freezer].\n"
        title: 3.8.3.2.  Discussion
      title: 3.8.3.  Control Operator .regexp
    - contents:
      - "3.8.4.  Control Operators .cbor and .cborseq\n   A \".cbor\" control on a
        byte string indicates that the byte string\n   carries a CBOR-encoded data
        item.  Decoded, the data item matches the\n   type given as the right-hand-side
        argument (type1 in the following\n   example).\n      \"bytes .cbor type1\"\n
        \  Similarly, a \".cborseq\" control on a byte string indicates that the\n
        \  byte string carries a sequence of CBOR-encoded data items.  When the\n
        \  data items are taken as an array, the array matches the type given as\n
        \  the right-hand-side argument (type2 in the following example).\n      \"bytes
        .cborseq type2\"\n   (The conversion of the encoded sequence to an array can
        be effected,\n   for instance, by wrapping the byte string between the two
        bytes 0x9f\n   and 0xff and decoding the wrapped byte string as a CBOR-encoded\n
        \  data item.)\n"
      title: 3.8.4.  Control Operators .cbor and .cborseq
    - contents:
      - "3.8.5.  Control Operators .within and .and\n   A \".and\" control on a type
        indicates that the data item matches both\n   the left-hand-side type and
        the type given as the right-hand side.\n   (Formally, the resulting type is
        the intersection of the two types\n   given.)\n      \"type1 .and type2\"\n
        \  A variant of the \".and\" control is the \".within\" control, which\n   expresses
        an additional intent: the left-hand-side type is meant to\n   be a subset
        of the right-hand-side type.\n      \"type1 .within type2\"\n   While both
        forms have the identical formal semantics (intersection),\n   the intention
        of the \".within\" form is that the right-hand side gives\n   guidance to
        the types allowed on the left-hand side, which typically\n   is a socket (Section
        3.9):\n        message = $message .within message-structure\n        message-structure
        = [message_type, *message_option]\n        message_type = 0..255\n        message_option
        = any\n        $message /= [3, dough: text, topping: [* text]]\n        $message
        /= [4, noodles: text, sauce: text, parmesan: bool]\n   For \".within\", a
        tool might flag an error if type1 allows data items\n   that are not allowed
        by type2.  In contrast, for \".and\", there is no\n   expectation that type1
        is already a subset of type2.\n"
      title: 3.8.5.  Control Operators .within and .and
    - contents:
      - "3.8.6.  Control Operators .lt, .le, .gt, .ge, .eq, .ne, and .default\n   The
        controls .lt, .le, .gt, .ge, .eq, and .ne specify a constraint\n   on the
        left-hand-side type to be a value less than, less than or\n   equal to, greater
        than, greater than or equal to, equal to, or not\n   equal to a value given
        as a right-hand-side type (containing just\n   that single value).  In the
        present specification, the first four\n   controls (.lt, .le, .gt, and .ge)
        are defined only for numeric types,\n   as these have a natural ordering relationship.\n
        \                    speed = number .ge 0  ; unit: m/s\n   .ne and .eq are
        defined for both numeric values and values of other\n   types.  If one of
        the values is not of a numeric type, equality is\n   determined as follows:
        text strings are equal (satisfy .eq / do not\n   satisfy .ne) if they are
        bytewise identical; the same applies for\n   byte strings.  Arrays are equal
        if they have the same number of\n   elements, all of which are equal pairwise
        in order between the\n   arrays.  Maps are equal if they have the same number
        of key/value\n   pairs, and there is pairwise equality between the key/value
        pairs\n   between the two maps.  Tagged values are equal if they both have
        the\n   same tag and the values are equal.  Values of simple types match if\n
        \  they are the same values.  Numeric types that occur within arrays,\n   maps,
        or tagged values are equal if their numeric value is equal and\n   they are
        both integers or both floating-point values.  All other\n   cases are not
        equal (e.g., comparing a text string with a byte\n   string).\n   A variant
        of the \".ne\" control is the \".default\" control, which\n   expresses an
        additional intent: the value specified by the\n   right-hand-side type is
        intended as a default value for the\n   left-hand-side type given, and the
        implied .ne control is there to\n   prevent this value from being sent over
        the wire.  This control is\n   only meaningful when the control type is used
        in an optional context;\n   otherwise, there would be no way to make use of
        the default value.\n               timer = {\n                 time: uint,\n
        \                ? displayed-step: (number .gt 0) .default 1\n               }\n"
      title: 3.8.6.  Control Operators .lt, .le, .gt, .ge, .eq, .ne, and .default
    title: 3.8.  Controls
  - contents:
    - "3.9.  Socket/Plug\n   For both type choices and group choices, a mechanism
      is defined that\n   facilitates starting out with empty choices and assembling
      them\n   later, potentially in separate files that are concatenated to build\n
      \  the full specification.\n   Per convention, CDDL extension points are marked
      with a leading\n   dollar sign (types) or two leading dollar signs (groups).
      \ Tools\n   honor that convention by not raising an error if such a type or
      group\n   is not defined at all; the symbol is then taken to be an empty type\n
      \  choice (group choice), i.e., no choice is available.\n            tcp-header
      = {seq: uint, ack: uint, * $$tcp-option}\n            ; later, in a different
      file\n            $$tcp-option //= (\n            sack: [+(left: uint, right:
      uint)]\n            )\n            ; and, maybe in another file\n            $$tcp-option
      //= (\n            sack-permitted: true\n            )\n   Names that start
      with a single \"$\" are \"type sockets\", starting out\n   as an empty type,
      and intended to be extended via \"/=\".  Names that\n   start with a double
      \"$$\" are \"group sockets\", starting out as an\n   empty group choice, and
      intended to be extended via \"//=\".  In either\n   case, it is not an error
      if there is no definition for a socket at\n   all; this then means there is
      no way to satisfy the rule (i.e., the\n   choice is empty).\n   As a convention,
      all definitions (plugs) for socket names must be\n   augmentations, i.e., they
      must be using \"/=\" and \"//=\", respectively.\n   To pick up the example illustrated
      in Figure 7, the socket/plug\n   mechanism could be used as shown in Figure
      12:\n                     PersonalData = {\n                       ? displayName:
      tstr,\n                       NameComponents,\n                       ? age:
      uint,\n                       * $$personaldata-extensions\n                     }\n
      \                    NameComponents = (\n                       ? firstName:
      tstr,\n                       ? familyName: tstr,\n                     )\n
      \                    ; The above already works as is.\n                     ;
      But then, we can add later:\n                     $$personaldata-extensions
      //= (\n                       favorite-salsa: tstr,\n                     )\n
      \                    ; and again, somewhere else:\n                     $$personaldata-extensions
      //= (\n                       shoesize: uint,\n                     )\n     Figure
      12: Personal Data Example: Using Socket/Plug Extensibility\n"
    title: 3.9.  Socket/Plug
  - contents:
    - "3.10.  Generics\n   Using angle brackets, the left-hand side of a rule can
      add formal\n   parameters after the name being defined, as in:\n      messages
      = message<\"reboot\", \"now\"> / message<\"sleep\", 1..100>\n      message<t,
      v> = {type: t, value: v}\n   When using a generic rule, the formal parameters
      are bound to the\n   actual arguments supplied (also using angle brackets),
      within the\n   scope of the generic rule (as if there were a rule of the form\n
      \  parameter = argument).\n   Generic rules can be used for establishing names
      for both types and\n   groups.\n   (At this time, there are some limitations
      to the nesting of generics\n   in the CDDL tool described in Appendix F.)\n"
    title: 3.10.  Generics
  - contents:
    - "3.11.  Operator Precedence\n   As with any language that has multiple syntactic
      features such as\n   prefix and infix operators, CDDL has operators that bind
      more tightly\n   than others.  This is becoming more complicated than, say,
      in ABNF,\n   as CDDL has both types and groups, with operators that are specific\n
      \  to these concepts.  Type operators (such as \"/\" for type choice)\n   operate
      on types, while group operators (such as \"//\" for group\n   choice) operate
      on groups.  Types can simply be used in groups, but\n   groups need to be bracketed
      (as arrays or maps) to become types.  So,\n   type operators naturally bind
      closer than group operators.\n   For instance, in\n      t = [group1]\n      group1
      = (a / b // c / d)\n      a = 1 b = 2 c = 3 d = 4\n   group1 is a group choice
      between the type choice of a and b and the\n   type choice of c and d.  This
      becomes more relevant once member keys\n   and/or occurrences are added in:\n
      \     t = {group2}\n      group2 = (? ab: a / b // cd: c / d)\n      a = 1 b
      = 2 c = 3 d = 4\n   is a group choice between the optional member \"ab\" of
      type a or b and\n   the member \"cd\" of type c or d.  Note that the optionality
      is\n   attached to the first choice (\"ab\"), not to the second choice.\n   Similarly,
      in\n      t = [group3]\n      group3 = (+ a / b / c)\n      a = 1 b = 2 c =
      3\n   group3 is a repetition of a type choice between a, b, and c; if just\n
      \  a is to be repeatable, a group choice is needed to focus the\n   occurrence:\n
      \     t = [group4]\n      group4 = (+ a // b / c)\n      a = 1 b = 2 c = 3\n
      \  group4 is a group choice between a repeatable a and a single b or c.\n   A
      comment has been that the semantics of group3 could be\n   counterintuitive.
      \ In general, as with many other languages with\n   operator precedence rules,
      the specification writer is encouraged not\n   to rely on them, but to insert
      parentheses liberally to guide readers\n   that are not familiar with CDDL precedence
      rules:\n      t = [group4a]\n      group4a = ((+ a) // (b / c))\n      a = 1
      b = 2 c = 3\n   The operator precedences, in sequence of loose to tight binding,
      are\n   defined in Appendix B and summarized in Table 1.  (Arities given are\n
      \  1 for unary prefix operators and 2 for binary infix operators.)\n       +----------+-------+---------------------------+------------+\n
      \      | Operator | Arity | Operates on               | Precedence |\n       +----------+-------+---------------------------+------------+\n
      \      |    =     |   2   | name = type, name = group |     1      |\n       |
      \   /=    |   2   | name /= type              |     1      |\n       |   //=
      \   |   2   | name //= group            |     1      |\n       |    //    |
      \  2   | group // group            |     2      |\n       |    ,     |   2   |
      group, group              |     3      |\n       |    *     |   1   | * group
      \                  |     4      |\n       |   n*m    |   1   | n*m group                 |
      \    4      |\n       |    +     |   1   | + group                   |     4
      \     |\n       |    ?     |   1   | ? group                   |     4      |\n
      \      |    =>    |   2   | type => type              |     5      |\n       |
      \   :     |   2   | name: type                |     5      |\n       |    /
      \    |   2   | type / type               |     6      |\n       |    ..    |
      \  2   | type..type                |     7      |\n       |   ...    |   2   |
      type...type               |     7      |\n       |  .ctrl   |   2   | type .ctrl
      type           |     7      |\n       |    &     |   1   | &group                    |
      \    8      |\n       |    ~     |   1   | ~type                     |     8
      \     |\n       +----------+-------+---------------------------+------------+\n
      \                Table 1: Summary of Operator Precedences\n"
    title: 3.11.  Operator Precedence
  title: 3.  Syntax
- contents:
  - "4.  Making Use of CDDL\n   In this section, we discuss several potential ways
    to employ CDDL.\n"
  - contents:
    - "4.1.  As a Guide for a Human User\n   CDDL can be used to efficiently define
      the layout of CBOR data, such\n   that a human implementer can easily see how
      data is supposed to be\n   encoded.\n   Since CDDL maps parts of the CBOR data
      to human-readable names, tools\n   could be built that use CDDL to provide a
      human-friendly\n   representation of the CBOR data and allow them to edit such
      data\n   while remaining compliant with its CDDL definition.\n"
    title: 4.1.  As a Guide for a Human User
  - contents:
    - "4.2.  For Automated Checking of CBOR Data Structures\n   CDDL has been specified
      such that a machine can handle the CDDL\n   definition and related CBOR data
      (and, thus, also JSON data).  For\n   example, a machine could use CDDL to check
      whether or not CBOR data\n   is compliant with its definition.\n   The need
      for thoroughness of such compliance checking depends on the\n   application.
      \ For example, an application may decide not to check the\n   data structure
      at all and use the CDDL definition solely as a means\n   to indicate the structure
      of the data to the programmer.\n   On the other hand, the application may also
      implement a checking\n   mechanism that goes as far as checking that all mandatory
      map members\n   are available.\n   The matter of how far the data description
      must be enforced by an\n   application is left to the designers and implementers
      of that\n   application, keeping in mind related security considerations.\n
      \  In no case is it intended that a CDDL tool would be \"writing code\"\n   for
      an implementation.\n"
    title: 4.2.  For Automated Checking of CBOR Data Structures
  - contents:
    - "4.3.  For Data Analysis Tools\n   In the long run, it can be expected that
      more and more data will be\n   stored using the CBOR data format.\n   Where
      there is data, there is data analysis and the need to process\n   such data
      automatically.  CDDL can be used for such automated data\n   processing, allowing
      tools to verify data, clean it, and extract\n   particular parts of interest
      from it.\n   Since CBOR is designed with constrained devices in mind, a likely
      use\n   of it would be small sensors.  An interesting use would thus be\n   automated
      analysis of sensor data.\n"
    title: 4.3.  For Data Analysis Tools
  title: 4.  Making Use of CDDL
- contents:
  - "5.  Security Considerations\n   This document presents a content rules language
    for expressing CBOR\n   data structures.  As such, it does not bring any security
    issues on\n   itself, although specifications of protocols that use CBOR naturally\n
    \  need security analyses when defined.  General guidelines for writing\n   security
    considerations are defined in [RFC3552] (BCP 72).\n   Specifications using CDDL
    to define CBOR structures in protocols need\n   to follow those guidelines.  Additional
    topics that could be\n   considered in a security considerations section for a
    specification\n   that uses CDDL to define CBOR structures include the following:\n
    \  o  Where could the language maybe cause confusion in a way that will\n      enable
    security issues?\n   o  Where a CDDL matcher is part of the implementation of
    a system,\n      the security of the system ought not depend on the correctness
    of\n      the CDDL specification or CDDL implementation without any further\n
    \     defenses in place.\n   o  Where the CDDL specification includes extension
    points, the impact\n      of extensions on the security of the system needs to
    be carefully\n      considered.\n   Writers of CDDL specifications are strongly
    encouraged to value\n   clarity and transparency of the specification over its
    elegance.\n   Keep it as simple as possible while still expressing the needed
    data\n   model.\n   A related observation about formal description techniques
    in general\n   that is strongly recommended to be kept in mind by writers of CDDL\n
    \  specifications: just because CDDL makes it easier to handle\n   complexity
    in a specification, that does not make that complexity\n   somehow less bad (except
    maybe on the level of the humans having to\n   grasp the complex structure while
    reading the spec).\n"
  title: 5.  Security Considerations
- contents:
  - '6.  IANA Considerations

    '
  - contents:
    - "6.1.  CDDL Control Operators Registry\n   IANA has created a registry for control
      operators (Section 3.8).  The\n   \"CDDL Control Operators\" registry has been
      created within the\n   \"Concise Data Definition Language (CDDL)\" registry.\n
      \  Each entry in the subregistry must include the name of the control\n   operator
      (by convention given with the leading dot) and a reference\n   to its documentation.
      \ Names must be composed of the leading dot\n   followed by a text string conforming
      to the production \"id\" in\n   Appendix B.\n   Initial entries in this registry
      are as follows:\n                       +----------+---------------+\n                       |
      Name     | Documentation |\n                       +----------+---------------+\n
      \                      | .size    | RFC 8610      |\n                       |
      .bits    | RFC 8610      |\n                       | .regexp  | RFC 8610      |\n
      \                      | .cbor    | RFC 8610      |\n                       |
      .cborseq | RFC 8610      |\n                       | .within  | RFC 8610      |\n
      \                      | .and     | RFC 8610      |\n                       |
      .lt      | RFC 8610      |\n                       | .le      | RFC 8610      |\n
      \                      | .gt      | RFC 8610      |\n                       |
      .ge      | RFC 8610      |\n                       | .eq      | RFC 8610      |\n
      \                      | .ne      | RFC 8610      |\n                       |
      .default | RFC 8610      |\n                       +----------+---------------+\n
      \  All other control operator names are Unassigned.\n   The IANA policy for
      additions to this registry is \"Specification\n   Required\" as defined in [RFC8126]
      (which involves an Expert Review)\n   for names that do not include an internal
      dot and \"IETF Review\" for\n   names that do include an internal dot.  The
      expert reviewer is\n   specifically instructed that other Standards Development\n
      \  Organizations (SDOs) may want to define control operators that are\n   specific
      to their fields (e.g., based on a binary syntax already in\n   use at the SDO);
      the review process should strive to facilitate such\n   an undertaking.\n"
    title: 6.1.  CDDL Control Operators Registry
  title: 6.  IANA Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [ISO6093]  ISO, \"Information processing --
      Representation of\n              numerical values in character strings for information\n
      \             interchange\", ISO 6093, 1985.\n   [RFC2119]  Bradner, S., \"Key
      words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,
      RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC3552]  Rescorla, E. and B. Korver, \"Guidelines for Writing RFC\n              Text
      on Security Considerations\", BCP 72, RFC 3552,\n              DOI 10.17487/RFC3552,
      July 2003,\n              <https://www.rfc-editor.org/info/rfc3552>.\n   [RFC3629]
      \ Yergeau, F., \"UTF-8, a transformation format of\n              ISO 10646\",
      STD 63, RFC 3629, DOI 10.17487/RFC3629,\n              November 2003, <https://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\",
      RFC 4648, DOI 10.17487/RFC4648, October 2006,\n              <https://www.rfc-editor.org/info/rfc4648>.\n
      \  [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n
      \             Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,
      January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n   [RFC7049]
      \ Bormann, C. and P. Hoffman, \"Concise Binary Object\n              Representation
      (CBOR)\", RFC 7049, DOI 10.17487/RFC7049,\n              October 2013, <https://www.rfc-editor.org/info/rfc7049>.\n
      \  [RFC7493]  Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493,\n              DOI
      10.17487/RFC7493, March 2015,\n              <https://www.rfc-editor.org/info/rfc7493>.\n
      \  [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC
      2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May
      2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8259]
      \ Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n              Interchange
      Format\", STD 90, RFC 8259,\n              DOI 10.17487/RFC8259, December 2017,\n
      \             <https://www.rfc-editor.org/info/rfc8259>.\n   [W3C.REC-xmlschema-2-20041028]\n
      \             Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes\n              Second
      Edition\", World Wide Web Consortium Recommendation\n              REC-xmlschema-2-20041028,
      October 2004,\n              <https://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [CDDL-Freezer]\n              Bormann, C.,
      \"A feature freezer for the Concise Data\n              Definition Language
      (CDDL)\", Work in Progress,\n              draft-bormann-cbor-cddl-freezer-01,
      August 2018.\n   [GRASP]    Bormann, C., Carpenter, B., Ed., and B. Liu, Ed.,
      \"A\n              Generic Autonomic Signaling Protocol (GRASP)\", Work in\n
      \             Progress, draft-ietf-anima-grasp-15, July 2017.\n   [IEEE754]
      \ IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE\n              Std
      754-2008.\n   [JCR]      Newton, A. and P. Cordell, \"A Language for Rules\n
      \             Describing JSON Content\", Work in Progress,\n              draft-newton-json-content-rules-09,
      September 2017.\n   [PEG]      Ford, B., \"Parsing expression grammars: a recognition-\n
      \             based syntactic foundation\", Proceedings of the 31st ACM\n              SIGPLAN-SIGACT
      symposium on Principles of programming\n              languages - POPL '04,
      DOI 10.1145/964001.964011,\n              January 2004.\n   [RELAXNG]  ISO/IEC,
      \"Information technology -- Document Schema\n              Definition Language
      (DSDL) -- Part 2: Regular-grammar-\n              based validation -- RELAX
      NG\", ISO/IEC 19757-2,\n              December 2008.\n   [RFC7071]  Borenstein,
      N. and M. Kucherawy, \"A Media Type for\n              Reputation Interchange\",
      RFC 7071, DOI 10.17487/RFC7071,\n              November 2013, <https://www.rfc-editor.org/info/rfc7071>.\n
      \  [RFC7950]  Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n
      \             RFC 7950, DOI 10.17487/RFC7950, August 2016,\n              <https://www.rfc-editor.org/info/rfc7950>.\n
      \  [RFC8007]  Murray, R. and B. Niven-Jenkins, \"Content Delivery Network\n
      \             Interconnection (CDNI) Control Interface / Triggers\",\n              RFC
      8007, DOI 10.17487/RFC8007, December 2016,\n              <https://www.rfc-editor.org/info/rfc8007>.\n
      \  [RFC8152]  Schaad, J., \"CBOR Object Signing and Encryption (COSE)\",\n              RFC
      8152, DOI 10.17487/RFC8152, July 2017,\n              <https://www.rfc-editor.org/info/rfc8152>.\n
      \  [RFC8428]  Jennings, C., Shelby, Z., Arkko, J., Keranen, A., and C.\n              Bormann,
      \"Sensor Measurement Lists (SenML)\", RFC 8428,\n              DOI 10.17487/RFC8428,
      August 2018,\n              <https://www.rfc-editor.org/info/rfc8428>.\n   [YAML]
      \    Ben-Kiki, O., Evans, C., and I. Net, \"YAML Ain't Markup\n              Language
      (YAML[TM]) Version 1.2\", 3rd Edition,\n              October 2009, <https://yaml.org/spec/1.2/spec.html>.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Appendix A.  Parsing Expression Grammars (PEGs)\n   This appendix is normative.\n
    \  Since the 1950s, many grammar notations are based on Backus-Naur Form\n   (BNF),
    a notation for context-free grammars (CFGs) within Chomsky's\n   generative system
    of grammars.  The Augmented Backus-Naur Form (ABNF)\n   [RFC5234], widely used
    in IETF specifications and also inspiring the\n   syntax of CDDL, is an example
    of this.\n   Generative grammars can express ambiguity well, but this very\n   property
    may make them hard to use in recognition systems, spawning a\n   number of subdialects
    that pose constraints on generative grammars to\n   be used with parser generators;
    this scenario may be hard for the\n   specification writer to manage.\n   PEGs
    [PEG] provide an alternative formal foundation for describing\n   grammars that
    emphasizes recognition over generation and resolves\n   what would have been ambiguity
    in generative systems by introducing\n   the concept of \"prioritized choice\".\n
    \  The notation for PEGs is quite close to BNF, with the usual \"Extended\n   BNF\"
    features, such as repetition, added.  However, where BNF uses\n   the unordered
    (symmetrical) choice operator \"|\" (incidentally notated\n   as \"/\" in ABNF),
    PEG provides a prioritized choice operator \"/\".  The\n   two alternatives listed
    are to be tested in left-to-right order,\n   locking in the first successful match
    and disregarding any further\n   potential matches within the choice (but not
    disabling alternatives\n   in choices containing this choice, as a cut (Section
    3.5.4) would).\n   For example, the ABNF expressions\n      A = \"a\" \"b\" /
    \"a\"    (1)\n   and\n      A = \"a\" / \"a\" \"b\"    (2)\n   are equivalent
    in ABNF's original generative framework but are very\n   different in PEG: in
    (2), the second alternative will never match, as\n   any input string starting
    with an \"a\" will already succeed in the\n   first alternative, locking in the
    match.\n   Similarly, the occurrence indicators (\"?\", \"*\", \"+\") are \"greedy\"
    in\n   PEG, i.e., they consume as much input as they match (and, as a\n   consequence,
    \"a* a\" in PEG notation or \"*a a\" in CDDL syntax never\n   can match anything,
    as all input matching \"a\" is already consumed by\n   the initial \"a*\", leaving
    nothing to match the second \"a\").\n   Incidentally, the grammar of CDDL itself,
    as written in ABNF in\n   Appendix B, can be interpreted both (1) in the generative
    framework\n   on which RFC 5234 is based and (2) as a PEG.  This was made possible\n
    \  by ordering the choices in the grammar such that a successful match\n   made
    on the left-hand side of a \"/\" operator is always the intended\n   match, instead
    of relying on the power of symmetrical choices (for\n   example, note the sequence
    of alternatives in the rule for \"uint\",\n   where the lone zero is behind the
    longer match alternatives that\n   start with a zero).\n   The syntax used for
    expressing the PEG component of CDDL is based on\n   ABNF, interpreted in the
    obvious way with PEG semantics.  The ABNF\n   convention of notating occurrence
    indicators before the controlled\n   primary, and of allowing numeric values for
    minimum and maximum\n   occurrence around a \"*\" sign, is copied.  While PEG
    is only about\n   characters, CDDL has a richer set of elements, such as types
    and\n   groups.  Specifically, the following constructs map:\n       +-------+-------+-------------------------------------------+\n
    \      | CDDL  | PEG   | Remark                                    |\n       +-------+-------+-------------------------------------------+\n
    \      | \"=\"   | \"<-\"  | /= and //= are abbreviations              |\n       |
    \"//\"  | \"/\"   | prioritized choice                        |\n       | \"/\"
    \  | \"/\"   | prioritized choice, limited to types only |\n       | \"?\" P |
    P \"?\" | zero or one                               |\n       | \"*\" P | P \"*\"
    | zero or more                              |\n       | \"+\" P | P \"+\" | one
    or more                               |\n       | A B   | A B   | sequence                                  |\n
    \      | A, B  | A B   | sequence, comma is decoration only        |\n       +-------+-------+-------------------------------------------+\n
    \  The literal notation and the use of square brackets, curly braces,\n   tildes,
    ampersands, and hash marks are specific to CDDL and unrelated\n   to the conventional
    PEG notation.  The DOT (\".\") from PEG is replaced\n   by the unadorned \"#\"
    or its alias \"any\".  Also, CDDL does not provide\n   the syntactic predicate
    operators NOT (\"!\") or AND (\"&\") from PEG,\n   reducing expressiveness as
    well as complexity.\n   For more details about PEG's theoretical foundation and
    interesting\n   properties of the operators such as associativity and distributivity,\n
    \  the reader is referred to [PEG].\n"
  title: Appendix A.  Parsing Expression Grammars (PEGs)
- contents:
  - "Appendix B.  ABNF Grammar\n   This appendix is normative.\n   The following is
    a formal definition of the CDDL syntax in ABNF\n   [RFC5234].  Note that, as is
    defined in ABNF, the quote-delimited\n   strings below are case insensitive (while
    string values and names are\n   case sensitive in CDDL).\n     cddl = S 1*(rule
    S)\n     rule = typename [genericparm] S assignt S type\n          / groupname
    [genericparm] S assigng S grpent\n     typename = id\n     groupname = id\n     assignt
    = \"=\" / \"/=\"\n     assigng = \"=\" / \"//=\"\n     genericparm = \"<\" S id
    S *(\",\" S id S ) \">\"\n     genericarg = \"<\" S type1 S *(\",\" S type1 S
    ) \">\"\n     type = type1 *(S \"/\" S type1)\n     type1 = type2 [S (rangeop
    / ctlop) S type2]\n     ; space may be needed before the operator if type2 ends
    in a name\n     type2 = value\n           / typename [genericarg]\n           /
    \"(\" S type S \")\"\n           / \"{\" S group S \"}\"\n           / \"[\" S
    group S \"]\"\n           / \"~\" S typename [genericarg]\n           / \"&\"
    S \"(\" S group S \")\"\n           / \"&\" S groupname [genericarg]\n           /
    \"#\" \"6\" [\".\" uint] \"(\" S type S \")\"\n           / \"#\" DIGIT [\".\"
    uint]                ; major/ai\n           / \"#\"                                 ;
    any\n     rangeop = \"...\" / \"..\"\n     ctlop = \".\" id\n     group = grpchoice
    *(S \"//\" S grpchoice)\n     grpchoice = *(grpent optcom)\n     grpent = [occur
    S] [memberkey S] type\n            / [occur S] groupname [genericarg]  ; preempted
    by above\n            / [occur S] \"(\" S group S \")\"\n     memberkey = type1
    S [\"^\" S] \"=>\"\n               / bareword S \":\"\n               / value
    S \":\"\n     bareword = id\n     optcom = S [\",\" S]\n     occur = [uint] \"*\"
    [uint]\n           / \"+\"\n           / \"?\"\n     uint = DIGIT1 *DIGIT\n          /
    \"0x\" 1*HEXDIG\n          / \"0b\" 1*BINDIG\n          / \"0\"\n     value =
    number\n           / text\n           / bytes\n     int = [\"-\"] uint\n     ;
    This is a float if it has fraction or exponent; int otherwise\n     number = hexfloat
    / (int [\".\" fraction] [\"e\" exponent ])\n     hexfloat = [\"-\"] \"0x\" 1*HEXDIG
    [\".\" 1*HEXDIG] \"p\" exponent\n     fraction = 1*DIGIT\n     exponent = [\"+\"/\"-\"]
    1*DIGIT\n     text = %x22 *SCHAR %x22\n     SCHAR = %x20-21 / %x23-5B / %x5D-7E
    / %x80-10FFFD / SESC\n     SESC = \"\\\" (%x20-7E / %x80-10FFFD)\n     bytes =
    [bsqual] %x27 *BCHAR %x27\n     BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC
    / CRLF\n     bsqual = \"h\" / \"b64\"\n     id = EALPHA *(*(\"-\" / \".\") (EALPHA
    / DIGIT))\n     ALPHA = %x41-5A / %x61-7A\n     EALPHA = ALPHA / \"@\" / \"_\"
    / \"$\"\n     DIGIT = %x30-39\n     DIGIT1 = %x31-39\n     HEXDIG = DIGIT / \"A\"
    / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n     BINDIG = %x30-31\n     S = *WS\n
    \    WS = SP / NL\n     SP = %x20\n     NL = COMMENT / CRLF\n     COMMENT = \";\"
    *PCHAR CRLF\n     PCHAR = %x20-7E / %x80-10FFFD\n     CRLF = %x0A / %x0D.0A\n
    \                          Figure 13: CDDL ABNF\n   Note that this ABNF does not
    attempt to reflect the detailed rules of\n   what can be in a prefixed byte string.\n"
  title: Appendix B.  ABNF Grammar
- contents:
  - "Appendix C.  Matching Rules\n   This appendix is normative.\n   In this appendix,
    we go through the ABNF syntax rules defined in\n   Appendix B and briefly describe
    the matching semantics of each\n   syntactic feature.  In this context, an instance
    (data item)\n   \"matches\" a CDDL specification if it is allowed by the CDDL\n
    \  specification; this is then broken down into parts of specifications\n   (type
    and group expressions) and parts of instances (data items).\n   cddl = S 1*(rule
    S)\n   A CDDL specification is a sequence of one or more rules.  Each rule\n   gives
    a name to a right-hand-side expression, either a CDDL type or a\n   CDDL group.
    \ Rule names can be used in the rule itself and/or other\n   rules (and tools
    can output warnings if that is not the case).  The\n   order of the rules is significant
    only in two cases:\n   1.  The first rule defines the semantics of the entire
    specification;\n       hence, there is no need to give that root rule a special
    name or\n       special syntax in the language (as, for example, with \"start\"
    in\n       RELAX NG); its name can therefore be chosen to be descriptive.\n       (As
    with all other rule names, the name of the initial rule may\n       be used in
    itself or in other rules.)\n   2.  Where a rule contributes to a type or group
    choice (using \"/=\" or\n       \"//=\"), that choice is populated in the order
    the rules are\n       given; see below.\n   rule = typename [genericparm] S assignt
    S type\n        / groupname [genericparm] S assigng S grpent\n   typename = id\n
    \  groupname = id\n   A rule defines a name for a type expression (production
    \"type\") or\n   for a group expression (production \"grpent\"), with the intention
    that\n   the semantics does not change when the name is replaced by its\n   (parenthesized
    if needed) definition.  Note that whether the name\n   defined by a rule stands
    for a type or a group isn't always\n   determined by syntax alone: e.g., \"a =
    b\" can make \"a\" a type if \"b\"\n   is a type, or a group if \"b\" is a group.
    \ More subtly, in \"a = (b)\",\n   \"a\" may be used as a type if \"b\" is a type,
    or as a group both when\n   \"b\" is a group and when \"b\" is a type (a good
    convention to make the\n   latter case stand out to the human reader is to write
    \"a = (b,)\").\n   (Note that the same dual meaning of parentheses applies within
    an\n   expression but often can be resolved by the context of the\n   parenthesized
    expression.  On the more general point, it may not be\n   clear immediately either
    whether \"b\" stands for a group or a type --\n   this semantic processing may
    need to span several levels of rule\n   definitions before a determination can
    be made.)\n   assignt = \"=\" / \"/=\"\n   assigng = \"=\" / \"//=\"\n   A plain
    equals sign defines the rule name as the equivalent of the\n   expression to the
    right; it is an error if the name was already\n   defined with a different expression.
    \ A \"/=\" or \"//=\" extends a named\n   type or a group by additional choices;
    a number of these could be\n   replaced by collecting all the right-hand sides
    and creating a single\n   rule with a type choice or a group choice built from
    the right-hand\n   sides in the order of the rules given.  (It is not an error
    to extend\n   a rule name that has not yet been defined; this makes the right-hand\n
    \  side the first entry in the choice being created.)\n   genericparm = \"<\"
    S id S *(\",\" S id S ) \">\"\n   genericarg = \"<\" S type1 S *(\",\" S type1
    S ) \">\"\n   Rule names can have generic parameters, which cause temporary\n
    \  assignments within the right-hand sides to the parameter names from\n   the
    arguments given when citing the rule name.\n   type = type1 *(S \"/\" S type1)\n
    \  A type can be given as a choice between one or more types.  The\n   choice
    matches a data item if the data item matches any one of the\n   types given in
    the choice.  The choice uses PEG semantics as\n   discussed in Appendix A: the
    first choice that matches wins.  (As a\n   result, the order of rules that contribute
    to a single rule name can\n   very well matter.)\n   type1 = type2 [S (rangeop
    / ctlop) S type2]\n   Two types can be combined with a range operator (see below)
    or a\n   control operator (see Section 3.8).\n   type2 = value\n   A type can
    be just a single value (such as 1 or \"icecream\" or\n   h'0815'), which matches
    only a data item with that specific value (no\n   conversions defined),\n      /
    typename [genericarg]\n   or be defined by a rule giving a meaning to a name (possibly
    after\n   supplying generic arguments as required by the generic parameters),\n
    \     / \"(\" S type S \")\"\n   or be defined in a parenthesized type expression
    (parentheses may be\n   necessary to override some operator precedence), or\n
    \     / \"{\" S group S \"}\"\n   a map expression, which matches a valid CBOR
    map the key/value pairs\n   of which can be ordered in such a way that the resulting
    sequence\n   matches the group expression, or\n      / \"[\" S group S \"]\"\n
    \  an array expression, which matches a CBOR array the elements of which\n   --
    when taken as values and complemented by a wildcard (matches\n   anything) key
    each -- match the group, or\n      / \"~\" S typename [genericarg]\n   an \"unwrapped\"
    group (see Section 3.7), which matches the group\n   inside a type defined as
    a map or an array by wrapping the group, or\n      / \"&\" S \"(\" S group S \")\"\n
    \     / \"&\" S groupname [genericarg]\n   an enumeration expression, which matches
    any value that is within the\n   set of values that the values of the group given
    can take, or\n      / \"#\" \"6\" [\".\" uint] \"(\" S type S \")\"\n   a tagged
    data item, tagged with the \"uint\" given and containing the\n   type given as
    the tagged value, or\n      / \"#\" DIGIT [\".\" uint]                ; major/ai\n
    \  a data item of a major type (given by the DIGIT), optionally\n   constrained
    to the additional information given by the uint, or\n      / \"#\"                                 ;
    any\n   any data item.\n   rangeop = \"...\" / \"..\"\n   A range operator can
    be used to join two type expressions that stand\n   for either two integer values
    or two floating-point values; it\n   matches any value that is between the two
    values, where the first\n   value is always included in the matching set and the
    second value is\n   included for \"..\" and excluded for \"...\".\n   ctlop =
    \".\" id\n   A control operator ties a _target_ type to a _controller_ type as\n
    \  defined in Section 3.8.  Note that control operators are an extension\n   point
    for CDDL; additional documents may want to define additional\n   control operators.\n
    \  group = grpchoice *(S \"//\" S grpchoice)\n   A group matches any sequence
    of key/value pairs that matches any of\n   the choices given (again using PEG
    semantics).\n   grpchoice = *(grpent optcom)\n   Each of the component groups
    is given as a sequence of group entries.\n   For a match, the sequence of key/value
    pairs given needs to match the\n   sequence of group entries in the sequence given.\n
    \  grpent = [occur S] [memberkey S] type\n   A group entry can be given by a value
    type, which needs to be matched\n   by the value part of a single element; and,
    optionally, a memberkey\n   type, which needs to be matched by the key part of
    the element, if\n   the memberkey is given.  If the memberkey is not given, the
    entry can\n   only be used for matching arrays, not for maps.  (See below for
    how\n   that is modified by the occurrence indicator.)\n       / [occur S] groupname
    [genericarg]  ; preempted by above\n   A group entry can be built from a named
    group, or\n       / [occur S] \"(\" S group S \")\"\n   from a parenthesized group,
    again with a possible occurrence\n   indicator.\n   memberkey = type1 S [\"^\"
    S] \"=>\"\n             / bareword S \":\"\n             / value S \":\"\n   Key
    types can be given by a type expression, a bareword (which stands\n   for a type
    that just contains a string value created from this\n   bareword), or a value
    (which stands for a type that just contains\n   this value).  A key value matches
    its key type if the key value is a\n   member of the key type, unless a cut preceding
    it in the group\n   applies (see Section 3.5.4 for how map matching is influenced
    by the\n   presence of the cuts denoted by \"^\" or \":\" in previous entries).\n
    \  bareword = id\n   A bareword is an alternative way to write a type with a single
    text\n   string value; it can only be used in the syntactic context given\n   above.\n
    \  optcom = S [\",\" S]\n   (Optional commas do not influence the matching.)\n
    \  occur = [uint] \"*\" [uint]\n         / \"+\"\n         / \"?\"\n   An occurrence
    indicator modifies the group given to its right by\n   requiring the group to
    match the sequence to be matched exactly for a\n   certain number of times (see
    Section 3.2) in sequence, i.e., it acts\n   as a (possibly infinite) group choice
    that contains choices with the\n   group repeated each of the occurrences times.\n
    \  The rest of the ABNF describes syntax for value notation that should\n   be
    familiar to readers from programming languages, with the possible\n   exception
    of h'..' and b64'..' for byte strings, as well as syntactic\n   elements such
    as comments and line ends.\n"
  title: Appendix C.  Matching Rules
- contents:
  - "Appendix D.  Standard Prelude\n   This appendix is normative.\n   The following
    prelude is automatically added to each CDDL file.\n   (Note that technically,
    it is a postlude, as it does not disturb the\n   selection of the first rule as
    the root of the definition.)\n                  any = #\n                  uint
    = #0\n                  nint = #1\n                  int = uint / nint\n                  bstr
    = #2\n                  bytes = bstr\n                  tstr = #3\n                  text
    = tstr\n                  tdate = #6.0(tstr)\n                  time = #6.1(number)\n
    \                 number = int / float\n                  biguint = #6.2(bstr)\n
    \                 bignint = #6.3(bstr)\n                  bigint = biguint / bignint\n
    \                 integer = int / bigint\n                  unsigned = uint /
    biguint\n                  decfrac = #6.4([e10: int, m: integer])\n                  bigfloat
    = #6.5([e2: int, m: integer])\n                  eb64url = #6.21(any)\n                  eb64legacy
    = #6.22(any)\n                  eb16 = #6.23(any)\n                  encoded-cbor
    = #6.24(bstr)\n                  uri = #6.32(tstr)\n                  b64url =
    #6.33(tstr)\n                  b64legacy = #6.34(tstr)\n                  regexp
    = #6.35(tstr)\n                  mime-message = #6.36(tstr)\n                  cbor-any
    = #6.55799(any)\n                  float16 = #7.25\n                  float32
    = #7.26\n                  float64 = #7.27\n                  float16-32 = float16
    / float32\n                  float32-64 = float32 / float64\n                  float
    = float16-32 / float64\n                  false = #7.20\n                  true
    = #7.21\n                  bool = false / true\n                  nil = #7.22\n
    \                 null = nil\n                  undefined = #7.23\n                          Figure
    14: CDDL Prelude\n   Note that the prelude is deemed to be fixed.  This means,
    for\n   instance, that additional tags beyond those defined in [RFC7049], as\n
    \  registered, need to be defined in each CDDL file that is using them.\n   A
    common stumbling point is that the prelude does not define a type\n   \"string\".
    \ CBOR has byte strings (\"bytes\" in the prelude) and text\n   strings (\"text\"),
    so a type that is simply called \"string\" would be\n   ambiguous.\n"
  title: Appendix D.  Standard Prelude
- contents:
  - "Appendix E.  Use with JSON\n   This appendix is normative.\n   The JSON generic
    data model (implicit in [RFC8259]) is a subset of\n   the generic data model of
    CBOR.  So, one can use CDDL with JSON by\n   limiting oneself to what can be represented
    in JSON.  Roughly\n   speaking, this means leaving out byte strings, tags, and
    simple\n   values other than \"false\", \"true\", and \"null\", leading to the\n
    \  following limited prelude:\n                      any = #\n                      uint
    = #0\n                      nint = #1\n                      int = uint / nint\n
    \                     tstr = #3\n                      text = tstr\n                      number
    = int / float\n                      float16 = #7.25\n                      float32
    = #7.26\n                      float64 = #7.27\n                      float16-32
    = float16 / float32\n                      float32-64 = float32 / float64\n                      float
    = float16-32 / float64\n                      false = #7.20\n                      true
    = #7.21\n                      bool = false / true\n                      nil
    = #7.22\n                      null = nil\n             Figure 15: JSON-Compatible
    Subset of CDDL Prelude\n   (The major types given here do not have a direct meaning
    in JSON, but\n   they can be interpreted as CBOR major types translated through\n
    \  Section 4 of [RFC7049].)\n   There are a few fine points in using CDDL with
    JSON.  First, JSON\n   does not distinguish between integers and floating-point
    numbers;\n   there is only one kind of number (which may happen to be integral).\n
    \  In this context, specifying a type as \"uint\", \"nint\", or \"int\" then\n
    \  becomes a predicate that the number be integral.  As an example, this\n   means
    that the following JSON numbers are all matching \"uint\":\n      10 10.0 1e1
    1.0e1 100e-1\n   (The fact that these are all integers may be surprising to users\n
    \  accustomed to the long tradition in programming languages of using\n   decimal
    points or exponents in a number to indicate a floating-point\n   literal.)\n   CDDL
    distinguishes the various CBOR number types, but there is only\n   one number
    type in JSON.  The effect of specifying a floating-point\n   precision (float16/float32/float64)
    is only to restrict the set of\n   permissible values to those expressible with
    binary16/binary32/\n   binary64; this is unlikely to be very useful when using
    CDDL for\n   specifying JSON data structures.\n   Fundamentally, the number system
    of JSON itself is based on decimal\n   numbers and decimal fractions and does
    not have limits to its\n   precision or range.  In practice, JSON numbers are
    often parsed into\n   a number type that is called \"float64\" here, creating
    a number of\n   limitations to the generic data model [RFC7493].  In particular,
    this\n   means that integers can only be expressed with interoperable\n   exactness
    when they lie in the range [-(2**53)+1, (2**53)-1] -- a\n   smaller range than
    that covered by CDDL \"int\".\n   JSON applications that want to stay compatible
    with I-JSON (\"Internet\n   JSON\"; see [RFC7493]) may therefore want to define
    integer types with\n   more limited ranges, such as in Figure 16.  Note that the
    types given\n   here are not part of the prelude; they need to be copied into
    the\n   CDDL specification if needed.\n               ij-uint = 0..9007199254740991\n
    \              ij-nint = -9007199254740991..-1\n               ij-int = -9007199254740991..9007199254740991\n
    \         Figure 16: I-JSON Types for CDDL (Not Part of Prelude)\n   JSON applications
    that do not need to stay compatible with I-JSON and\n   that actually may need
    to go beyond the 64-bit unsigned and negative\n   integers supported by \"int\"
    (= \"uint\"/\"nint\") may want to use the\n   following additional types from
    the standard prelude, which are\n   expressed in terms of tags but can straightforwardly
    be mapped into\n   JSON (but not I-JSON) numbers:\n      biguint = #6.2(bstr)\n
    \     bignint = #6.3(bstr)\n      bigint = biguint / bignint\n      integer =
    int / bigint\n      unsigned = uint / biguint\n   CDDL at this point does not
    have a way to express the unlimited\n   floating-point precision that is theoretically
    possible with JSON; at\n   the time of writing, this is rarely used in protocols
    in practice.\n   Note that a data model described in CDDL is always restricted
    by what\n   can be expressed in the serialization; e.g., floating-point values\n
    \  such as NaN (not a number) and the infinities cannot be represented\n   in
    JSON even if they are allowed in the CDDL generic data model.\n"
  title: Appendix E.  Use with JSON
- contents:
  - "Appendix F.  A CDDL Tool\n   This appendix is for information only.\n   A rough
    CDDL tool is available.  For CDDL specifications, it can\n   check the syntax,
    generate one or more instances (expressed in CBOR\n   diagnostic notation or in
    pretty-printed JSON), and validate an\n   existing instance against the specification:\n
    \                  Usage:\n                   cddl spec.cddl generate [n]\n                   cddl
    spec.cddl json-generate [n]\n                   cddl spec.cddl validate instance.cbor\n
    \                  cddl spec.cddl validate instance.json\n                        Figure
    17: CDDL Tool Usage\n   Install on a system with a modern Ruby via:\n                             gem
    install cddl\n                     Figure 18: CDDL Tool Installation\n   The accompanying
    CBOR diagnostic tools (which are automatically\n   installed by the above) are
    described in <https://github.com/cabo/\n   cbor-diag>; they can be used to convert
    between binary CBOR, a\n   pretty-printed hexadecimal form of binary CBOR, CBOR
    diagnostic\n   notation, JSON, and YAML [YAML].\n"
  title: Appendix F.  A CDDL Tool
- contents:
  - "Appendix G.  Extended Diagnostic Notation\n   This appendix is normative.\n   Section
    6 of [RFC7049] defines a \"diagnostic notation\" in order to be\n   able to converse
    about CBOR data items without having to resort to\n   binary data.  Diagnostic
    notation is based on JSON, with extensions\n   for representing CBOR constructs
    such as binary data and tags.\n   (Standardizing this together with the actual
    interchange format does\n   not serve to create another interchange format but
    enables the use of\n   a shared diagnostic notation in tools for and documents
    about CBOR.)\n   This appendix discusses a few extensions to the diagnostic notation\n
    \  that have turned out to be useful since RFC 7049 was written.  We\n   refer
    to the result as Extended Diagnostic Notation (EDN).\n"
  - contents:
    - "G.1.  Whitespace in Byte String Notation\n   Examples often benefit from some
      whitespace (spaces, line breaks) in\n   byte strings.  In EDN, whitespace is
      ignored in prefixed byte\n   strings; for instance, the following are equivalent:\n
      \     h'48656c6c6f20776f726c64'\n      h'48 65 6c 6c 6f 20 77 6f 72 6c 64'\n
      \     h'4 86 56c 6c6f\n        20776 f726c64'\n"
    title: G.1.  Whitespace in Byte String Notation
  - contents:
    - "G.2.  Text in Byte String Notation\n   Diagnostic notation notates byte strings
      in one of the base encodings\n   per [RFC4648], enclosed in single quotes, prefixed
      by >h< for base16,\n   >b32< for base32, >h32< for base32hex, or >b64< for base64
      or\n   base64url.  Quite often, byte strings carry bytes that are\n   meaningfully
      interpreted as UTF-8 text.  EDN allows the use of single\n   quotes without
      a prefix to express byte strings with UTF-8 text; for\n   instance, the following
      are equivalent:\n      'hello world'\n      h'68656c6c6f20776f726c64'\n   The
      escaping rules of JSON strings are applied equivalently for\n   text-based byte
      strings, e.g., \"\\\" stands for a single backslash and\n   \"'\" stands for
      a single quote.  Whitespace is included literally,\n   i.e., the previous section
      does not apply to text-based byte strings.\n"
    title: G.2.  Text in Byte String Notation
  - contents:
    - "G.3.  Embedded CBOR and CBOR Sequences in Byte Strings\n   Where a byte string
      is to carry an embedded CBOR-encoded item, or\n   more generally a sequence
      of zero or more such items, the diagnostic\n   notation for these zero or more
      CBOR data items, separated by commas,\n   can be enclosed in << and >> to notate
      the byte string resulting from\n   encoding the data items and concatenating
      the result.  For instance,\n   each pair of columns in the following are equivalent:\n
      \     <<1>>              h'01'\n      <<1, 2>>           h'0102'\n      <<\"foo\",
      null>>    h'63666F6FF6'\n      <<>>               h''\n"
    title: G.3.  Embedded CBOR and CBOR Sequences in Byte Strings
  - contents:
    - "G.4.  Concatenated Strings\n   While the ability to include whitespace enables
      line-breaking of\n   encoded byte strings, a mechanism is needed to be able
      to include\n   text strings as well as byte strings in direct UTF-8 representation\n
      \  into line-based documents (such as RFCs and source code).\n   We extend the
      diagnostic notation by allowing multiple text strings\n   or multiple byte strings
      to be notated separated by whitespace; these\n   are then concatenated into
      a single text or byte string,\n   respectively.  Text strings and byte strings
      do not mix within such a\n   concatenation, except that byte string notation
      can be used inside a\n   sequence of concatenated text string notation to encode
      characters\n   that may be better represented in an encoded way.  The following
      four\n   values are equivalent:\n      \"Hello world\"\n      \"Hello \" \"world\"\n
      \     \"Hello\" h'20' \"world\"\n      \"\" h'48656c6c6f20776f726c64' \"\"\n
      \  Similarly, the following byte string values are equivalent:\n      'Hello
      world'\n      'Hello ' 'world'\n      'Hello ' h'776f726c64'\n      'Hello'
      h'20' 'world'\n      '' h'48656c6c6f20776f726c64' '' b64''\n      h'4 86 56c
      6c6f' h' 20776 f726c64'\n   (Note that the approach of separating by whitespace,
      while familiar\n   from the C language, requires some attention -- a single
      comma makes\n   a big difference here.)\n"
    title: G.4.  Concatenated Strings
  - contents:
    - "G.5.  Hexadecimal, Octal, and Binary Numbers\n   In addition to JSON's decimal
      numbers, EDN provides hexadecimal,\n   octal, and binary numbers in the usual
      C-language notation (octal\n   with 0o prefix present only).\n   The following
      are equivalent:\n      4711\n      0x1267\n      0o11147\n      0b1001001100111\n
      \  As are:\n      1.5\n      0x1.8p0\n      0x18p-4\n"
    title: G.5.  Hexadecimal, Octal, and Binary Numbers
  - contents:
    - "G.6.  Comments\n   Longer pieces of diagnostic notation may benefit from comments.
      \ JSON\n   famously does not provide for comments, and basic diagnostic notation\n
      \  per RFC 7049 inherits this property.\n   In EDN, comments can be included,
      delimited by slashes (\"/\").  Any\n   text within and including a pair of slashes
      is considered a comment.\n   Comments are considered whitespace.  Hence, they
      are allowed in\n   prefixed byte strings; for instance, the following are equivalent:\n
      \     h'68656c6c6f20776f726c64'\n      h'68 65 6c /doubled l!/ 6c 6f /hello/\n
      \       20 /space/\n        77 6f 72 6c 64' /world/\n   This can be used to
      annotate a CBOR structure as in:\n      /grasp-message/ [/M_DISCOVERY/ 1, /session-id/
      10584416,\n                       /objective/ [/objective-name/ \"opsonize\",\n
      \                                   /D, N, S/ 7, /loop-count/ 105]]\n   (There
      are currently no end-of-line comments.  If we want to add\n   them, \"//\" sounds
      like a reasonable delimiter given that we already\n   use slashes for comments,
      but we could also go, for example,\n   for \"#\".)\n"
    title: G.6.  Comments
  title: Appendix G.  Extended Diagnostic Notation
- contents:
  - "Appendix H.  Examples\n   This appendix is for information only.\n   This appendix
    contains a few examples of structures defined\n   using CDDL.  The theme for the
    examples is taken from [RFC7071],\n   which defines certain JSON structures in
    English.  For a similar\n   example, it may also be of interest to examine Appendix
    A of\n   [RFC8007], which contains a CDDL definition for a JSON structure\n   defined
    in the main body of that RFC.\n   These examples all happen to describe data that
    is interchanged in\n   JSON.  Examples for CDDL definitions of data that is interchanged
    in\n   CBOR can be found in [RFC8152], [GRASP], and [RFC8428].\n   [RFC7071] defines
    the \"reputon\" structure for JSON using somewhat\n   formalized English text.
    \ Here is a (somewhat verbose) equivalent\n   definition using the same terms,
    but notated in CDDL:\n                 reputation-object = {\n                   reputation-context,\n
    \                  reputon-list\n                 }\n                 reputation-context
    = (\n                   application: text\n                 )\n                 reputon-list
    = (\n                   reputons: reputon-array\n                 )\n                 reputon-array
    = [* reputon]\n                 reputon = {\n                   rater-value,\n
    \                  assertion-value,\n                   rated-value,\n                   rating-value,\n
    \                  ? conf-value,\n                   ? normal-value,\n                   ?
    sample-value,\n                   ? gen-value,\n                   ? expire-value,\n
    \                  * ext-value,\n                 }\n                 rater-value
    = ( rater: text )\n                 assertion-value = ( assertion: text )\n                 rated-value
    = ( rated: text )\n                 rating-value = ( rating: float16 )\n                 conf-value
    = ( confidence: float16 )\n                 normal-value = ( normal-rating: float16
    )\n                 sample-value = ( sample-size: uint )\n                 gen-value
    = ( generated: uint )\n                 expire-value = ( expires: uint )\n                 ext-value
    = ( text => any )\n   An equivalent, more compact form of this example would be:\n
    \                       reputation-object = {\n                          application:
    text\n                          reputons: [* reputon]\n                        }\n
    \                       reputon = {\n                          rater: text\n                          assertion:
    text\n                          rated: text\n                          rating:
    float16\n                          ? confidence: float16\n                          ?
    normal-rating: float16\n                          ? sample-size: uint\n                          ?
    generated: uint\n                          ? expires: uint\n                          *
    text => any\n                        }\n   Note how this rather clearly delineates
    the structure somewhat\n   shrouded by so many words in Section 6.2.2 of [RFC7071].
    \ Also, this\n   definition makes it clear that several ext-values are allowed
    (by\n   definition with different member names); RFC 7071 could be read to\n   forbid
    the repetition of ext-value (\"A specific reputon-element\n   MUST NOT appear
    more than once\" is ambiguous).\n   The CDDL tool described in Appendix F generates
    as one example:\n                  {\n                    \"application\": \"conchometry\",\n
    \                   \"reputons\": [\n                      {\n                        \"rater\":
    \"Ephthianura\",\n                        \"assertion\": \"codding\",\n                        \"rated\":
    \"sphaerolitic\",\n                        \"rating\": 0.34133473256800795,\n
    \                       \"confidence\": 0.9481983064298332,\n                        \"expires\":
    1568,\n                        \"unplaster\": \"grassy\"\n                      },\n
    \                     {\n                        \"rater\": \"nonchargeable\",\n
    \                       \"assertion\": \"raglan\",\n                        \"rated\":
    \"alienage\",\n                        \"rating\": 0.5724646875815566,\n                        \"sample-size\":
    3514,\n                        \"Aldebaran\": \"unchurched\",\n                        \"puruloid\":
    \"impersonable\",\n                        \"uninfracted\": \"pericarpoidal\",\n
    \                       \"schorl\": \"Caro\"\n                      },\n                      {\n
    \                       \"rater\": \"precollectable\",\n                        \"assertion\":
    \"Merat\",\n                        \"rated\": \"thermonatrite\",\n                        \"rating\":
    0.19164006323936977,\n                        \"confidence\": 0.6065252103391268,\n
    \                       \"normal-rating\": 0.5187773690879303,\n                        \"generated\":
    899,\n                        \"speedy\": \"solidungular\",\n                        \"noviceship\":
    \"medicine\",\n                        \"checkrow\": \"epidictic\"\n                      }\n
    \                   ]\n                  }\n"
  title: Appendix H.  Examples
- contents:
  - "Acknowledgements\n   Inspiration was taken from the C and Pascal languages, MPEG's\n
    \  conventions for describing structures in the ISO base media file\n   format,
    RELAX NG and its compact syntax [RELAXNG], and, in\n   particular, Andrew Lee
    Newton's early proposals on JSON Content Rules\n   (JCR) as found in draft version
    four (-04) of [JCR].\n   Lots of highly useful feedback came from members of the
    IETF CBOR WG\n   -- in particular, Ari Keranen, Brian Carpenter, Burt Harris,
    Jeffrey\n   Yasskin, Jim Hague, Jim Schaad, Joe Hildebrand, Max Pritikin, Michael\n
    \  Richardson, Pete Cordell, Sean Leonard, and Yaron Sheffer.  Also,\n   Francesca
    Palombini and Joe volunteered to chair the WG when it was\n   created, providing
    the framework for generating and processing this\n   feedback, with Barry Leiba
    having taken over from Joe since then.\n   Chris Lonvick and Ines Robles provided
    additional reviews during IESG\n   processing, and Alexey Melnikov steered the
    process as the\n   responsible Area Director.\n   The CDDL tool described in Appendix
    F was written by Carsten Bormann,\n   building on previous work by Troy Heninger
    and Tom Lord.\n"
  title: Acknowledgements
- contents:
  - "Contributors\n   CDDL was originally conceived by Bert Greevenbosch, who also
    wrote\n   the original five draft versions of this document.\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Henk Birkholz\n   Fraunhofer SIT\n   Rheinstrasse 75\n
    \  Darmstadt  64295\n   Germany\n   Email: henk.birkholz@sit.fraunhofer.de\n   Christoph
    Vigano\n   Universitaet Bremen\n   Email: christoph.vigano@uni-bremen.de\n   Carsten
    Bormann\n   Universitaet Bremen TZI\n   Bibliothekstr. 1\n   Bremen  D-28359\n
    \  Germany\n   Phone: +49-421-218-63921\n   Email: cabo@tzi.org\n"
  title: Authors' Addresses
