- title: __initial_text__
  contents:
  - '               A Syntax for Describing Media Feature Sets

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   A number of Internet application protocols have a need to provide\n\
    \   content negotiation for the resources with which they interact [1].\n   A\
    \ framework for such negotiation is described in [2], part of which\n   is a way\
    \ to describe the range of media features which can be handled\n   by the sender,\
    \ recipient or document transmission format of a\n   message.  A format for a\
    \ vocabulary of individual media features and\n   procedures for feature registration\
    \ are presented in [3].\n   This document introduces and describes a syntax that\
    \ can be used to\n   define feature sets which are formed from combinations and\
    \ relations\n   involving individual media features.  Such feature sets are used\
    \ to\n   describe the media feature handling capabilities of message senders,\n\
    \   recipients and file formats.\n   An algorithm for feature set matching is\
    \ also described here.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction.............................................3\n\
    \     1.1 Structure of this document ...........................3\n     1.2 Document\
    \ terminology and conventions .................4\n     1.3 Discussion of this\
    \ document ..........................4\n   2. Content feature terminology and\
    \ definitions..............4\n   3. Media feature combinations and capabilities..............5\n\
    \     3.1 Media features .......................................5\n     3.2 Media\
    \ feature collections and sets ...................5\n     3.3 Media feature set\
    \ descriptions .......................6\n     3.4 Media feature combination scenario\
    \ ...................7\n        3.4.1 Data resource options............................7\n\
    \        3.4.2 Recipient capabilities...........................7\n        3.4.3\
    \ Combined options.................................7\n     3.5 Feature set predicates\
    \ ...............................8\n        3.5.1 Comparison with directory search\
    \ filters.........8\n     3.6 Describing preferences ...............................9\n\
    \     3.7 Combining preferences ...............................10\n   4. Feature\
    \ set representation..............................11\n     4.1 Textual representation\
    \ of predicates ................11\n     4.2 Interpretation of feature predicate\
    \ syntax ..........12\n        4.2.1 Filter syntax...................................12\n\
    \        4.2.2 Feature comparison..............................13\n        4.2.3\
    \ Feature tags....................................13\n        4.2.4 Feature values..................................14\n\
    \          4.2.4.1 Boolean values                              14\n          4.2.4.2\
    \ Numeric values                              14\n          4.2.4.3 Token values\
    \                                15\n          4.2.4.4 String values         \
    \                      15\n        4.2.5 Notational conveniences.........................15\n\
    \     4.3 Feature set definition example ......................16\n   5. Matching\
    \ feature sets...................................16\n     5.1 Feature set matching\
    \ strategy .......................18\n     5.2 Formulating the goal predicate\
    \ ......................19\n     5.3 Replace set expressions .............................19\n\
    \     5.4 Move logical negations inwards ......................20\n     5.5 Replace\
    \ comparisons and logical negations ...........20\n     5.6 Conversion to canonical\
    \ form ........................21\n     5.7 Grouping of feature predicates ......................22\n\
    \     5.8 Merge single-feature constraints ....................22\n        5.8.1\
    \ Rules for simplifying ordered values............23\n        5.8.2 Rules for\
    \ simplifying unordered values..........23\n   6. Other features and issues...............................24\n\
    \     6.1 Named and auxiliary predicates ......................24\n        6.1.1\
    \ Defining a named predicate......................24\n        6.1.2 Invoking named\
    \ predicates.......................25\n        6.1.3 Auxiliary predicates in a\
    \ filter................25\n        6.1.4 Feature matching with named predicates..........25\n\
    \        6.1.5 Example.........................................26\n     6.2 Unit\
    \ designations ...................................26\n     6.3 Unknown feature\
    \ value data types ....................27\n   7. Examples and additional comments........................27\n\
    \     7.1 Worked example ......................................27\n     7.2 A\
    \ note on feature tag scoping .......................31\n   8. Security Considerations.................................34\n\
    \   9. Acknowledgements........................................34\n   10. References.............................................35\n\
    \   11. Author's Address.......................................36\n   Full Copyright\
    \ Statement...................................37\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   A number of Internet application protocols have a need to\
    \ provide\n   content negotiation for the resources with which they interact [1].\n\
    \   A framework for such negotiation is described in [2].  A part of this\n  \
    \ framework is a way to describe the range of media features which can\n   be\
    \ handled by the sender, recipient or document transmission format\n   of a message.\n\
    \   Descriptions of media feature capabilities need to be based upon some\n  \
    \ underlying vocabulary of individual media features.  A format for\n   such a\
    \ vocabulary and procedures for registering media features\n   within this vocabulary\
    \ are presented in [3].\n   This document defines a syntax that can be used to\
    \ describe feature\n   sets which are formed from combinations and relations involving\n\
    \   individual media features.  Such feature sets are used to describe\n   the\
    \ media handling capabilities of message senders, recipients and\n   file formats.\n\
    \   An algorithm for feature set matching is also described here.\n   The feature\
    \ set syntax is built upon the principle of using feature\n   set predicates as\
    \ \"mathematical relations\" which define constraints\n   on feature handling\
    \ capabilities.  This allows that the same form of\n   feature set expression\
    \ can be used to describe sender, receiver and\n   file format capabilities. \
    \ This has been loosely modelled on the way\n   that relational databases use\
    \ Boolean expresions to describe a set of\n   result values, and a syntax that\
    \ is based upon LDAP search filters.\n"
- title: 1.1 Structure of this document
  contents:
  - "1.1 Structure of this document\n   The main part of this memo addresses the following\
    \ main areas:\n   Section 2 introduces and references some terms which are used\
    \ with\n   special meaning.\n   Section 3 introduces the concept of describing\
    \ media handling\n   capabilities as combinations of possible media features,\
    \ and the idea\n   of using Boolean expressions to express such combinations.\n\
    \   Section 4 contains a description of a syntax for describing feature\n   sets\
    \ based on the previously-introduced idea of Boolean expressions\n   used to describe\
    \ media feature combinations.\n   Section 5 describes an algorithm for feature\
    \ set matching.\n   Section 6 discusses some additional media feature description\
    \ and\n   processing issues that may be viewed as extensions to the core\n   framework.\n\
    \   Section 7 contains a worked example of feature set matching, and some\n  \
    \ additional explanatory comments spurred by issues arising from\n   applying\
    \ this framework to fascimile transmissions.\n"
- title: 1.2 Document terminology and conventions
  contents:
  - "1.2 Document terminology and conventions\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119.\n      NOTE:  Comments like this provide additional nonessential\n\
    \      information about the rationale behind this document.  Such\n      information\
    \ is not needed for building a conformant\n      implementation, but may help\
    \ those who wish to understand the\n      design in greater depth.\n"
- title: 1.3 Discussion of this document
  contents:
  - "1.3 Discussion of this document\n   Discussion of this document should take place\
    \ on the content\n   negotiation and media feature registration mailing list hosted\
    \ by the\n   Internet Mail Consortium (IMC):\n   Please send comments regarding\
    \ this document to:\n      ietf-medfree@imc.org\n   To subscribe to this list,\
    \ send a message with the body 'subscribe'\n   to \"ietf-medfree-request@imc.org\"\
    .\n   To see what has gone on before you subscribed, please see the mailing\n\
    \   list archive at:\n      http://www.imc.org/ietf-medfree/\n"
- title: 2. Content feature terminology and definitions
  contents:
  - "2. Content feature terminology and definitions\n   Feature Collection\n     \
    \ is a collection of different media features and associated values.\n      This\
    \ might be viewed as describing a specific rendering of a\n      specific instance\
    \ of a document or resource by a specific\n      recipient.\n   Feature Set\n\
    \      is a set of zero, one or more feature collections.\n      NOTE:  this term\
    \ is used slightly differently by earlier work on\n      Transparent Content Negotiation\
    \ in HTTP [4].\n   Feature set predicate\n      A function of an arbitrary feature\
    \ collection value which returns\n      a Boolean result.  A TRUE result is taken\
    \ to mean that the\n      corresponding feature collection belongs to some set\
    \ of media\n      feature handling capabilities defined by this predicate.\n \
    \  Other terms used in this memo are defined in [2].\n"
- title: 3. Media feature combinations and capabilities
  contents:
  - '3. Media feature combinations and capabilities

    '
- title: 3.1 Media features
  contents:
  - "3.1 Media features\n   This memo assumes that individual media feature values\
    \ are simple\n   atomic values:\n      o  Boolean values.\n      o  Enumerated\
    \ values.\n      o  Text string values (treated as atomic entities, like enumerated\n\
    \         value tokens).\n      o  Numeric values (Integer or rational).\n   These\
    \ values all have the property that they can be compared for\n   equality ('='),\
    \ and that numeric and ordered enumeration values can\n   be compared for less-than\
    \ and greater-than relationship ('<=', '>=').\n   These basic comparison operations\
    \ are used as the primitive building\n   blocks for more comprehensive capability\
    \ expressions.\n"
- title: 3.2 Media feature collections and sets
  contents:
  - "3.2 Media feature collections and sets\n   Any single media feature value can\
    \ be thought of as just one\n   component of a feature collection that describes\
    \ some instance of a\n   resource (e.g. a printed document, a displayed image,\
    \ etc.).  Such a\n   feature collection consists of a number of media feature\
    \ tags (each\n   per [3]) and associated feature values.\n   A feature set is\
    \ a set containing a number of feature collections.\n   Thus, a feature set can\
    \ describe a number of different data resource\n   instances.  These can correspond\
    \ to different treatments of a single\n   data resource (e.g. different resolutions\
    \ used for printing a given\n   document), a number of different data resources\
    \ subjected to a common\n   treatment (e.g. the range of different images that\
    \ can be rendered on\n   a given display), or some combination of these (see examples\
    \ below).\n   Thus, a description of a feature set can describe the capabilities\
    \ of\n   a data resource or some entity that processes or renders a data\n   resource.\n"
- title: 3.3 Media feature set descriptions
  contents:
  - "3.3 Media feature set descriptions\n   A feature set may be unbounded.  For example,\
    \ in principle, there is\n   no limit on the number of different documents that\
    \ may be output\n   using a given printer.  But to be practically useful, a feature\
    \ set\n   description must be finite.\n   The general approach to describing feature\
    \ sets is to start from the\n   assumption that anything is possible;  i.e. the\
    \ feature set contains\n   all possible document instances (feature collections).\
    \  Then\n   constraints are applied that progressively remove document instances\n\
    \   from this set;  e.g. for a monochrome printer, all document instances\n  \
    \ that use colour are removed, or for a document that must be rendered\n   at\
    \ some minimum resolution, all document instances with lesser\n   resolutions\
    \ are removed from the set.  The mechanism used to remove\n   document instances\
    \ from the set is the mathematical idea of a\n   \"relation\";  i.e. a Boolean\
    \ function (a \"predicate\") that takes a\n   feature collection parameter and\
    \ returns a Boolean value that is TRUE\n   if the feature collection describes\
    \ an acceptable document instance,\n   or FALSE if it describes one that is excluded.\n\
    \                     P(C)\n       P(C) = TRUE <- : -> P(C) = FALSE\n        \
    \              :\n           +----------:----------+  This box represents some\n\
    \           |          :          |  set of feature collections (C)\n        \
    \   | Included : Excluded |  that is constrained by the\n           |        \
    \  :          |  predicate P.\n           +----------:----------+\n          \
    \            :\n   The result of applying a series of such constraints is a smaller\
    \ set\n   of feature collections that represent some media handling capability.\n\
    \   Where the individual constraints are represented by predicates that\n   each\
    \ describe some media handling capability, the combined effect of\n   these constraints\
    \ is some subset of the individual constraint\n   capabilities that can be represented\
    \ by a predicate that is the\n   logical-AND of the individual constraint predicates.\n"
- title: 3.4 Media feature combination scenario
  contents:
  - "3.4 Media feature combination scenario\n   This section develops some example\
    \ scenarios, introducing the\n   notation that is defined formally in section\
    \ 4.\n"
- title: 3.4.1 Data resource options
  contents:
  - "3.4.1 Data resource options\n   The following expression describes a data resource\
    \ that can be\n   displayed either:\n   (a)  as a 750x500 pixel image using 15\
    \ colours, or\n   (b)  at 150dpi on an A4 page.\n      (| (& (pix-x=750) (pix-y=500)\
    \ (color=15) )\n         (& (dpi>=150) (papersize=iso-A4) ) )\n"
- title: 3.4.2 Recipient capabilities
  contents:
  - "3.4.2 Recipient capabilities\n   The following expression describes a receiving\
    \ system that has:\n   (a)  a screen capable of displaying 640*480 pixels and\
    \ 16 million\n        colours (24 bits per pixel), 800*600 pixels and 64 thousand\n\
    \        colours (16 bits per pixel) or 1024*768 pixels and 256 colours\n    \
    \    (8 bits per pixel), or\n   (b)  a printer capable of rendering 300dpi on\
    \ A4 paper.\n         (| (& (| (& (pix-x<=640)  (pix-y<=480) (color<=16777216)\
    \ )\n                  (& (pix-x<=800)  (pix-y<=600) (color<=65535) )\n      \
    \            (& (pix-x<=1024) (pix-y<=768) (color<=256) ) )\n               (ua-media=screen)\
    \ )\n            (& (dpi=300)\n               (ua-media=stationery) (papersize=iso-A4)\
    \ ) )\n   Note that this expression says nothing about the colour or grey-scale\n\
    \   capabilities of the printer.  In the scheme presented here, it is\n   presumed\
    \ to be unconstrained in this respect (or, more realistically,\n   any such constraints\
    \ are handled out-of-band by anyone sending to\n   this recipient).\n"
- title: 3.4.3 Combined options
  contents:
  - "3.4.3 Combined options\n   The following example describes the range of document\
    \ representations\n   available when the resource described in the first example\
    \ above is\n   sent to the recipient described in the second example.  This is\
    \ the\n   result of combining their capability feature sets:\n         (| (& (pix-x=750)\
    \ (pix-y=500) (color=15) )\n            (& (dpi=300) (ua-media=stationery) (papersize=iso-A4)\
    \ ) )\n   The feature set described by this expression is the intersection of\n\
    \   the sets described by the previous two capability expressions.\n"
- title: 3.5 Feature set predicates
  contents:
  - "3.5 Feature set predicates\n   There are many ways of representing a predicate.\
    \  The ideas in this\n   memo were inspired by the programming language Prolog\
    \ [5], and its\n   use of predicates to describe sets of objects.\n   For the\
    \ purpose of media feature descriptions in networked\n   application protocols,\
    \ the format used for LDAP search filters [7,8]\n   has been adopted, because\
    \ it is a good match for the requirements of\n   capability identification, and\
    \ has a very simple structure that is\n   easy to parse and process.\n"
- title: 3.5.1 Comparison with directory search filters
  contents:
  - "3.5.1 Comparison with directory search filters\n   Observe that a feature collection\
    \ is similar to a directory entry, in\n   that it consists of a collection of\
    \ named values.  Further, the\n   semantics of the mechanism for selecting feature\
    \ collections from a\n   feature set is in many respects similar to selection\
    \ of directory\n   entries from a directory.\n   A feature set predicate used\
    \ to describe media handling capabilities\n   is implicitly applied to some feature\
    \ collection.  Within the\n   predicate, members of the feature collection are\
    \ identified by their\n   feature tags, and are compared with known feature values.\
    \  (Compare\n   with the way an LDAP search filter is applied to a directory entry,\n\
    \   whose members are identified by attribute type names, and compared\n   with\
    \ known attribute values.)\n   For example, in:\n      (& (dpi>=150) (papersize=iso-A4)\
    \ )\n   the tokens 'dpi' and 'papersize' are feature tags, and '150' and '\n \
    \  iso-A4' are feature values.  (In a corresponding LDAP search filter,\n   they\
    \ would be directory entry attribute types and attribute values.)\n   Differences\
    \ between directory selection (per [7]) and feature set\n   selection are:\n \
    \     o  Directory selection provides substring-, approximate- and\n         extensible-\
    \ matching for attribute values.  Such matching is\n         not provided for\
    \ feature set selection.\n      o  Directory selection may be based on the presence\
    \ of an\n         attribute without regard to its value.  Within the semantic\n\
    \         framework described by this document, Boolean-valued feature\n     \
    \    tests can be used to provide a similar effect.\n      o  Directory selection\
    \ provides for matching rules that test for\n         the presence or absence\
    \ of a named attribute type.\n      o  Directory selection provides for matching\
    \ rules which are\n         dependent upon the declared data type of an attribute\
    \ value.\n      o  Feature selection provides for the association of a quality\n\
    \         value with a feature predicate as a way of ranking the selected\n  \
    \       value collections.\n   Within the semantic framework described by this\
    \ document, Boolean-\n   valued feature tests can be used where presence tests\
    \ would be used\n   in a directory search filter.\n   The idea of extensible matching\
    \ and matching rules dependent upon\n   data types are facets of a problem not\
    \ addressed by this memo, but\n   which do not necessarily affect the feature\
    \ selection syntax.  An\n   aspect that might bear on the syntax would be specification\
    \ of an\n   explicit matching rule as part of a selection expression.\n"
- title: 3.6 Describing preferences
  contents:
  - "3.6 Describing preferences\n   A convenient way to describe preferences is by\
    \ numeric \"quality\n   values\".\n   It has been suggested that numeric quality\
    \ values are potentially\n   misleading if used as more than just a way of ranking\
    \ options.  For\n   the purposes of this memo, ranking of options is sufficient.\n\
    \   Numeric quality values in the range 0 to 1, with up to 3 fractional\n   digits,\
    \ are used to rank feature sets according to preference.\n   Higher values are\
    \ preferred over lower values, and equal values are\n   presumed to be equally\
    \ preferred.  Beyond this, the actual number\n   used has no significance defined\
    \ here.  Arithmetic operations on\n   quality values are likely to produce unpredictable\
    \ results unless\n   appropriate semantics have been defined for the context where\
    \ such\n   operations are used.\n   In the absence of any explicitly applied quality\
    \ value, a value of\n   \"1\" is assumed.\n   Using the notation defined later,\
    \ a quality value may be attached to\n   any feature set predicate sub-expression:\n\
    \      (| (& (pix-x=750) (pix-y=500) (color=15) );q=0.8\n         (& (dpi>=150)\
    \ (papersize=iso-A4) )     ;q=0.7 )\n   Section 3.7 below explains that quality\
    \ values attached to\n   sub-expressions are not always useful.\n      NOTE: \
    \ the syntax for quality values used here taken from\n      that defined for HTTP\
    \ 'Accept:' headers in RFC 2068 [9],\n      section 3.9.  However, the use of\
    \ quality values defined\n      here does not go as far as that defined in RFC\
    \ 2068.\n"
- title: 3.7 Combining preferences
  contents:
  - "3.7 Combining preferences\n   The general problem of describing and combining\
    \ preferences among\n   feature sets is very much more complex than simply describing\n\
    \   allowable feature sets.  For example, given two feature sets:\n      (& (a1);q=0.8\
    \ (b1);q=0.7 )\n      (& (a2);q=0.5 (b2);q=0.9 )\n   where:\n      feature a1\
    \ is preferred over a2\n      feature b2 is preferred over b1\n   Which of these\
    \ feature sets is preferred?  In the absence of\n   additional information or\
    \ assumptions, there is no generally\n   satisfactory answer to this.\n   The\
    \ proposed resolution of this issue is simply to say that no rules\n   are provided\
    \ for combining preference information.  Applied to the\n   above example, any\
    \ preference information about (a1) in relation to\n   (a2), or (b1) in relation\
    \ to (b2) is not presumed to convey\n   information about preference of (& (a1)\
    \ (b1) ) in relation to (& (a2)\n   (b2) ).\n   In practical terms, this restricts\
    \ the application of preference\n   information to top-level predicate clauses.\
    \  A top-level clause\n   completely defines an allowable feature set;  clauses\
    \ combined by\n   logical-AND operators cannot be top-level clauses (see canonical\n\
    \   format for feature set predicates, described later).\n      NOTE: This memo\
    \ does not apply specific meaning to quality values\n      or rules for combining\
    \ them.  Application of such meanings and\n      rules is not prohibited, but\
    \ is seen as an area for continuing\n      research and experimentation.\n   \
    \   An example of a design that uses extended quality value semantics\n      and\
    \ combining operations is \"Transparent Content Negotiation in\n      HTTP\" [4].\
    \  Other work that also extends quality values is the\n      content negotiation\
    \ algorithm in the Apache HTTP server [14].\n"
- title: 4. Feature set representation
  contents:
  - "4. Feature set representation\n   The foregoing sections have described a framework\
    \ for defining\n   feature sets with predicates applied to feature collections.\
    \  This\n   section presents a concrete representation for feature set\n   predicates.\n"
- title: 4.1 Textual representation of predicates
  contents:
  - "4.1 Textual representation of predicates\n   The text representation of a feature\
    \ set is based on RFC 2254 \"The\n   String Representation of LDAP Search Filters\"\
    \ [8], excluding those\n   elements not relevant to feature set selection (discussed\
    \ above), and\n   adding elements specific to feature set selection (e.g. options\
    \ to\n   associate quality values with predicates).\n   The format of a feature\
    \ predicate is defined by the production for\n   \"filter\" in the following,\
    \ using the syntax notation and core rules\n   of RFC 2234 [10]:\n      filter\
    \     =  \"(\" filtercomp \")\" *( \";\" parameter )\n      parameter  =  \"q\"\
    \ \"=\" qvalue\n                 /  ext-param \"=\" ext-value\n      qvalue  \
    \   =  ( \"0\" [ \".\" 0*3DIGIT ] )\n                 /  ( \"1\" [ \".\" 0*3(\"\
    0\") ] )\n      ext-param  =  ALPHA *( ALPHA / DIGIT / \"-\" )\n      ext-value\
    \  =  <parameter value, according to the named parameter>\n      filtercomp =\
    \  and / or / not / item\n      and        =  \"&\" filterlist\n      or     \
    \    =  \"|\" filterlist\n      not        =  \"!\" filter\n      filterlist =\
    \  1*filter\n      item       =  simple / set / ext-pred\n      set        = \
    \ attr \"=\" \"[\" setentry *( \",\" setentry ) \"]\"\n      setentry   =  value\
    \ \"/\" range\n      range      =  value \"..\" value\n      simple     =  attr\
    \ filtertype value\n      filtertype =  equal / greater / less\n      equal  \
    \    =  \"=\"\n      greater    =  \">=\"\n      less       =  \"<=\"\n      attr\
    \       =  ftag\n      value      =  fvalue\n      ftag       =  <Feature tag,\
    \ as defined in RFC 2506 [3]>\n      fvalue     =  Boolean / number / token /\
    \ string\n      Boolean    =  \"TRUE\" / \"FALSE\"\n      number     =  integer\
    \ / rational\n      integer    =  [ \"+\" / \"-\" ] 1*DIGIT\n      rational  \
    \ =  [ \"+\" / \"-\" ] 1*DIGIT \"/\" 1*DIGIT\n      token      =  ALPHA *( ALPHA\
    \ / DIGIT / \"-\" )\n      string     =  DQUOTE *(%x20-21 / %x23-7E) DQUOTE\n\
    \                    ; quoted string of SP and VCHAR without DQUOTE\n      ext-pred\
    \   =  <Extension constraint predicate, not defined here>\n   (Subject to constraints\
    \ imposed by the protocol that carries a\n   feature predicate, whitespace characters\
    \ may appear between any pair\n   of syntax elements or literals that appear on\
    \ the right hand side of\n   these productions.)\n   As described, the syntax\
    \ permits parameters (including quality\n   values) to be attached to any \"filter\"\
    \ value in the predicate (not\n   just top-level values).  Only top-level quality\
    \ values are\n   recognized.  If no explicit quality value is given, a value of\
    \ '1.0'\n   is applied.\n      NOTE:  The flexible approach to quality values\
    \ and other parameter\n      values in this syntax has been adopted for two reasons:\
    \  (a) to\n      make it easy to combine separately constructed feature predicates,\n\
    \      and (b) to provide an extensible tagging mechanism for possible\n     \
    \ future use (for example, to incorporate a conceivable requirement\n      to\
    \ explicitly specify a matching rule).\n"
- title: 4.2 Interpretation of feature predicate syntax
  contents:
  - "4.2 Interpretation of feature predicate syntax\n   A feature set predicate is\
    \ described by the syntax production for '\n   filter'.\n"
- title: 4.2.1 Filter syntax
  contents:
  - "4.2.1 Filter syntax\n   A 'filter' is defined as either a simple feature comparison\
    \ ('item',\n   see below) or a composite filter ('and', 'or', 'not'), decorated\
    \ with\n   optional parameter values (including \"q=qvalue\").\n   A composite\
    \ filter is a logical combination of one or more 'filter'\n   values:\n   (& f1\
    \ f2 ... fn )   is the logical-AND of the filter values 'f1',\n              \
    \         'f2' up to 'fn'.  That is, it is satisfied by\n                    \
    \   any feature collection that satisfies all of\n                       the predicates\
    \ represented by those filters.\n   (| f1 f2 ... fn )   is the logical-OR of the\
    \ filter values 'f1',\n                       'f2' up to 'fn'.  That is, it is\
    \ satisfied by\n                       any feature collection that satisfies at\
    \ least\n                       one of the predicates represented by those\n \
    \                      filters.\n   (! f1 )             is the logical negation\
    \ of the filter value\n                       'f1'.  That is, it is satusfied\
    \ by any feature\n                       collection that does NOT satisfy the\
    \ predicate\n                       represented by 'f1'.\n"
- title: 4.2.2 Feature comparison
  contents:
  - "4.2.2 Feature comparison\n   A feature comparison is defined by the 'simple'\
    \ option of the syntax\n   production for 'item'. There are three basic forms:\n\
    \   (ftag=value)        compares the feature named 'ftag' (in some\n         \
    \              feature collection that is being tested) with\n               \
    \        the supplied 'value', and matches if they are\n                     \
    \  equal.  This can be used with any type of\n                       feaure value\
    \ (numeric, Boolean, token or\n                       string).\n   (ftag<=value)\
    \       compares the numeric feature named 'ftag' with\n                     \
    \  the supplied 'value', and matches if the\n                       feature is\
    \ less than or equal to 'value'.\n   (ftag>=value)       compares the numeric\
    \ feature named 'ftag' with\n                       the supplied 'value', and\
    \ matches if the\n                       feature is greater than or equal to 'value'.\n\
    \   Less-than and greater-than tests may be performed with feature values\n  \
    \ that are not numeric but, in general, they amount to equality tests\n   as there\
    \ is no ordering relation on non-numeric values defined by\n   this specification.\
    \  Specific applications may define such ordering\n   relations on specific feature\
    \ tags, but such definitions are beyond\n   the scope of (and not required for\
    \ conformance to) this\n   specification.\n"
- title: 4.2.3 Feature tags
  contents:
  - "4.2.3 Feature tags\n   Feature tags conform to the syntax given in \"Media Feature\
    \ Tag\n   Registration Procedure\" [3].  Feature tags used to describe\n   capabilities\
    \ should be registered using the procedures described in\n   that memo.  Unregistered\
    \ feature tags should be allocated in the \"URI\n   tree\", as discussed in the\
    \ media feature registration procedures memo\n   [3].\n   If an unrecognized feature\
    \ tag is encountered in the course of\n   feature set predicate processing, it\
    \ should be still be processed as\n   a legitimate feature tag.  The feature set\
    \ matching rules are\n   designed to allow new feature tags to be introduced without\
    \ affecting\n   the validity of existing capability assertions.\n"
- title: 4.2.4 Feature values
  contents:
  - "4.2.4 Feature values\n   A feature may have a number, Boolean, token or string\
    \ value.\n"
- title: 4.2.4.1 Boolean values
  contents:
  - "4.2.4.1 Boolean values\n   A Boolean is simply a token with two predefined values:\
    \ \"TRUE\" and\n   \"FALSE\".  (Upper- or lower- case letters may be used in any\n\
    \   combination.)\n"
- title: 4.2.4.2 Numeric values
  contents:
  - "4.2.4.2 Numeric values\n   A numeric value is either a decimal integer, optionally\
    \ preceded by a\n   \"+\" or \"-\" sign, or rational number.\n   A rational number\
    \ is expressed as \"n/m\", optionally preceded by a \"+\"\n   or \"-\" sign. \
    \ The \"n\" and \"m\" are unsigned decimal integers, and the\n   value represented\
    \ by \"n/m\" is \"n\" divided by \"m\".  Thus, the\n   following are all valid\
    \ representations of the number 1.5:\n      3/2\n      +15/10\n      600/400\n\
    \   Thus, several rational number forms may express the same value.  A\n   canonical\
    \ form of rational number is obtained by finding the highest\n   common factor\
    \ of \"n\" and \"m\", and dividing both \"n\" and \"m\" by that\n   value.\n \
    \  A simple integer value may be used anywhere in place of a rational\n   number.\
    \  Thus, we have:\n      +5 is equivalent to +5/1 or +50/10, etc.\n      -2 is\
    \ equivalent to -2/1 or -4/2, etc.\n   Any sign in a rational number must precede\
    \ the entire number, so the\n   following are not valid rational numbers:\n  \
    \    3/+2, 15/-10      (**NOT VALID**)\n"
- title: 4.2.4.3 Token values
  contents:
  - "4.2.4.3 Token values\n   A token value is any sequence of letters, digits and\
    \ '-' characters\n   that conforms to the syntax for 'token' given above.  It\
    \ is a name\n   that stands for some (unspecified) value.\n"
- title: 4.2.4.4 String values
  contents:
  - "4.2.4.4 String values\n   A string value is any sequence of characters enclosed\
    \ in double\n   quotes that conform to the syntax for 'string' given above.\n\
    \   The semantics of string defined by this memo are the same as those\n   for\
    \ a token value.  But a string allows a far greater variety of\n   internal formats,\
    \ and specific applications may choose to interpret\n   the content in ways that\
    \ go beyond those given here.  Where such\n   interpretation is possible, the\
    \ allowed string formats and the\n   corresponding interpretations should be indicated\
    \ in the media\n   feature registration (per RFC 2506 [3]).\n"
- title: 4.2.5 Notational conveniences
  contents:
  - "4.2.5 Notational conveniences\n   The 'set' option of the syntax production for\
    \ 'item' is simply a\n   shorthand notation for some common situations that can\
    \ be expressed\n   using 'simple' constructs.  Occurrences of 'set' items can\
    \ eliminated\n   by applying the following identities:\n      T = [ E1, E2, ...\
    \ En ]  -->  (| (T=[E1]) (T=[E2]) ... (T=[En]) )\n      (T=[R1..R2])         \
    \   -->  (& (T>=R1) (T<=R2) )\n      (T=[E])                 -->  (T=E)\n   Examples:\n\
    \   The expression:\n      ( paper-size=[A4,B4] )\n   can be used to express a\
    \ capability to print documents on either A4\n   or B4 sized paper.\n   The expression:\n\
    \      ( width=[4..17/2] )\n   might be used to express a capability to print\
    \ documents that are\n   anywhere between 4 and 8.5 inches wide.\n   The set construct\
    \ is designed so that enumerated values and ranges\n   can be combined in a single\
    \ expression, e.g.:\n      ( width=[3,4,6..17/2] )\n"
- title: 4.3 Feature set definition example
  contents:
  - "4.3 Feature set definition example\n   The following is an example of a feature\
    \ predicate that describes a\n   number of image size and resolution combinations,\
    \ presuming the\n   registration and use of 'Pix-x', 'Pix-y', 'Res-x' and 'Res-y'\
    \ feature\n   tags:\n      (| (& (Pix-x=1024)\n            (Pix-y=768)\n     \
    \       (| (& (Res-x=150) (Res-y=150) )\n               (& (Res-x=150) (Res-y=300)\
    \ )\n               (& (Res-x=300) (Res-y=300) )\n               (& (Res-x=300)\
    \ (Res-y=600) )\n               (& (Res-x=600) (Res-y=600) ) ) )\n         (&\
    \ (Pix-x=800)\n            (Pix-y=600)\n            (| (& (Res-x=150) (Res-y=150)\
    \ )\n               (& (Res-x=150) (Res-y=300) )\n               (& (Res-x=300)\
    \ (Res-y=300) )\n               (& (Res-x=300) (Res-y=600) )\n               (&\
    \ (Res-x=600) (Res-y=600) ) ) ) ;q=0.9\n         (& (Pix-x=640)\n            (Pix-y=480)\n\
    \            (| (& (Res-x=150) (Res-y=150) )\n               (& (Res-x=150) (Res-y=300)\
    \ )\n               (& (Res-x=300) (Res-y=300) )\n               (& (Res-x=300)\
    \ (Res-y=600) )\n               (& (Res-x=600) (Res-y=600) ) ) ) ;q=0.8 )\n"
- title: 5. Matching feature sets
  contents:
  - "5. Matching feature sets\n   This section presents a procedure for combining\
    \ feature sets to\n   determine the common feature collections to which they refer,\
    \ if\n   there are any.  Making a selection from the possible feature\n   collections\
    \ (based on q-values or otherwise) is not covered here.\n   Matching a feature\
    \ set to some given feature collection is\n   essentially very straightforward:\
    \  the feature set predicate is\n   simply evaluated for the given feature collection,\
    \ and the result\n   (TRUE or FALSE) indicates whether the feature collection\
    \ matches the\n   capabilities, and the associated quality value can be used for\n\
    \   selecting among alternative feature collections.\n   Matching a feature set\
    \ to some other feature set is less\n   straightforward.  Here, the problem is\
    \ to determine whether or not\n   there is at least one feature collection that\
    \ matches both feature\n   sets (e.g. is there an overlap between the feature\
    \ capabilities of a\n   given file format and the feature capabilities of a given\
    \ recipient?)\n   This feature set matching is accomplished by logical manipulation\
    \ of\n   the predicate expressions as described in the following sub-sections.\n\
    \   For this procedure to work reliably, the predicates must be reduced\n   to\
    \ a canonical form.  The canonical form used here is \"disjunctive\n   normal\
    \ form\".  A syntax for disjunctive normal form is:\n      filter     =  orlist\n\
    \      orlist     =  \"(\" \"|\" andlist \")\" / term\n      andlist    =  \"\
    (\" \"&\" termlist \")\" / term\n      termlist   =  1*term\n      term      \
    \ =  \"(\" \"!\" simple \")\" / simple\n   where \"simple\" is as described previously\
    \ in section 4.1.  Thus, the\n   canonicalized form has at most three levels:\
    \  an outermost \"(|...)\"\n   disjunction of \"(&...)\" conjunctions of possibly\
    \ negated feature\n   value tests.\n      NOTE:  The usual canonical form for\
    \ predicate expressions is\n      \"clausal form\".  Procedures for converting\
    \ general predicate\n      expressions are given in [5] (section 10.2), [11] (section\
    \ 2.13)\n      and [12] (section 5.3.2).\n      \"Clausal form\" for a predicate\
    \ is similar to \"conjunctive normal\n      form\" for a proposition, being a\
    \ conjunction (logical AND) of\n      disjunctions (logical ORs).  The related\
    \ form used here, better\n      suited to feature set matching, is \"disjunctive\
    \ normal form\",\n      which is a logical disjunction (OR) of conjunctions (ANDs).\
    \  In\n      this form, the aim of feature set matching is to show that at\n \
    \     least one of the disjunctions can be satisfied by some feature\n      collection.\n\
    \      Is this consideration of canonical forms really required?  After\n    \
    \  all, the feature predicates are just Boolean expressions, aren't\n      they?\
    \  Well, no: a feature predicate is a Boolean expression\n      containing primitive\
    \ feature value tests (comparisons),\n      represented by 'item' in the feature\
    \ predicate syntax.  If these\n      tests could all be assumed to be independently\
    \ TRUE or FALSE, then\n      each could be regarded as an atomic proposition,\
    \ and the whole\n      predicate could be dealt with according to the (relatively\
    \ simple)\n      rules of Propositional Calculus.\n      But, in general, the\
    \ same feature tag may appear in more than one\n      predicate 'item', so the\
    \ tests cannot be regarded as independent.\n      Indeed, interdependence is needed\
    \ in any meaningful application of\n      feature set matching, and it is important\
    \ to capture these\n      dependencies (e.g. does the set of resolutions that\
    \ a sender can\n      supply overlap the set of resolutions that a recipient can\n\
    \      handle?).  Thus, we have to deal with elements of the Predicate\n     \
    \ Calculus, with some additional rules for algebraic manipulation.\n      A description\
    \ of both the Propositional and Predicate calculi can\n      be found in [12].\n\
    \      We aim to show that these additional rules are more unfamiliar\n      than\
    \ complicated.  The construction and use of feature predicates\n      actually\
    \ avoids some of the complexity of dealing with fully-\n      generalized Predicate\
    \ Calculus.\n"
- title: 5.1 Feature set matching strategy
  contents:
  - "5.1 Feature set matching strategy\n   The overall strategy for matching feature\
    \ sets, expanded below, is:\n   1. Formulate the feature set match hypothesis.\n\
    \   2. Replace \"set\" expressions with equivalent comparisons.\n   3. Move logical\
    \ negations \"inwards\", so that they are all applied\n      directly to feature\
    \ comparisons.\n   4. Eliminate logical negations, and express all feature comparisons\n\
    \      in terms of just four comparison operators\n   5. Reduce the hypothesis\
    \ to canonical disjunctive normal form (a\n      disjunction of conjunctions).\n\
    \   6. For each of the conjunctions, attempt to show that it can be\n      satisfied\
    \ by some feature collection.\n      6.1  Separate the feature value tests into\
    \ independent feature\n         groups, such that each group contains tests involving\
    \ just one\n         feature tag.  Thus, no predicate in a feature group contains\
    \ a\n         feature tag that also appears in some other group.\n      6.2  For\
    \ each feature group, merge the various constraints to a\n         minimum form.\
    \  This process either yields a reduced expression\n         for the allowable\
    \ range of feature values, or an expression\n         containing the value FALSE,\
    \ which is an indication that no\n         combination of feature values can satisfy\
    \ the constraints (in\n         which case the corresponding conjunction can never\
    \ be\n         satisfied).\n   7. If the remaining disjunction contains at least\
    \ one satisfiable\n      conjunction, then the constraints are shown to be satisfiable.\n\
    \   The final expression obtained by this procedure, if it is non-empty,\n   can\
    \ be used as a statement of the resulting feature set for possible\n   further\
    \ matching operations.  That is, it can be used as a starting\n   point for combining\
    \ with additional feature set constraint predicate\n   to determine a feature\
    \ set that is constrained by the capabilities of\n   several entities in a message\
    \ transfer path.\n      NOTE: as presented, the feature matching process evaluates\
    \ (and\n      stores) all conjunctions of the disjunctive normal form before\n\
    \      combining feature tag comparisons and eliminating unsatisfiable\n     \
    \ conjunctions.  For low-memory systems an alternative approach is\n      possible,\
    \ in which each normal form conjunction is enumerated and\n      evaluated in\
    \ turn, with only those that are satisfiable being\n      retained for further\
    \ use.\n"
- title: 5.2 Formulating the goal predicate
  contents:
  - "5.2 Formulating the goal predicate\n   A formal statement of the problem we need\
    \ to solve can be given as:\n   given two feature set predicates, '(P x)' and\
    \ '(Q x)', where 'x' is\n   some feature collection, we wish to establish the\
    \ truth or otherwise\n   of the proposition:\n      EXISTS(x) : (P x) AND (Q x)\n\
    \   i.e. does there exist a feature collection 'x' that satisfies both\n   predicates,\
    \ 'P' and 'Q'?\n   Then, if feature sets to be matched are described by predicates\
    \ 'P'\n   and 'Q', the problem is to determine if there is any feature set\n \
    \  satisfying the goal predicate:\n      (& P Q)\n   i.e. to determine whether\
    \ the set thus described is non-empty.\n"
- title: 5.3 Replace set expressions
  contents:
  - "5.3 Replace set expressions\n   Replace all \"set\" instances in the goal predicate\
    \ with equivalent\n   \"simple\" forms:\n      T = [ E1, E2, ... En ]  -->  (|\
    \ (T=[E1]) (T=[E2]) ... (T=[En]) )\n      (T=[R1..R2])            -->  (& (T>=R1)\
    \ (T<=R2) )\n      (T=[E])                 -->  (T=E)\n"
- title: 5.4 Move logical negations inwards
  contents:
  - "5.4 Move logical negations inwards\n   The goal of this step is to move all logical\
    \ negations so that they\n   are applied directly to feature comparisons.  During\
    \ the following\n   step, these logical negations are replaced by alternative\
    \ comparison\n   operators.\n   This is achieved by repeated application of the\
    \ following\n   transformation rules:\n      (! (& A1 A2 ... Am ) )  -->  (| (!\
    \ A1 ) (! A2 ) ... (! Am ) )\n      (! (| A1 A2 ... Am ) )  -->  (& (! A1 ) (!\
    \ A2 ) ... (! Am ) )\n      (! (! A ) )             -->  A\n   The first two rules\
    \ are extended forms of De Morgan's law, and the\n   third is elimination of double\
    \ negatives.\n"
- title: 5.5 Replace comparisons and logical negations
  contents:
  - "5.5 Replace comparisons and logical negations\n   The predicates are derived\
    \ from the syntax described previously, and\n   contain primitive value testing\
    \ functions '=', '<=', '>='.  The\n   primitive tests have a number of well known\
    \ properties that are\n   exploited to reach a useful conclusion; e.g.\n     \
    \ (A = B)  & (B = C)  => (A = C)\n      (A <= B) & (B <= C) => (A <= C)\n   These\
    \ rules form a core body of logic statements against which the\n   goal predicate\
    \ can be evaluated.  The form in which these statements\n   are expressed is important\
    \ to realizing an effective predicate\n   matching algorithm (i.e. one that doesn't\
    \ loop or fail to find a\n   valid result).  The first step in formulating these\
    \ rules is to\n   simplify the framework of primitive predicates.\n   The primitive\
    \ predicates from which feature set definitions are\n   constructed are '=', '<='\
    \ and '>='.  Observe that, given any pair of\n   feature values, the relationship\
    \ between them must be exactly one of\n   the following:\n      (LT a b): 'a'\
    \ is less than 'b'.\n      (EQ a b): 'a' is equal to 'b'.\n      (GT a b): 'a'\
    \ is greater than 'b'.\n      (NE a b): 'a' is not equal to 'b', and is not less\
    \ than\n                or greater than 'b'.\n   (The final case arises when two\
    \ values are compared for which no\n   ordering relationship is defined, and the\
    \ values are not equal; e.g.\n   two unequal string values.)\n   These four cases\
    \ can be captured by a pair of primitive predicates:\n      (LE a b): 'a' is less\
    \ than or equal to 'b'.\n      (GE a b): 'a' is greater than or equal to 'b'.\n\
    \   The four cases described above are prepresented by the following\n   combinations\
    \ of primitive predicate values:\n      (LE a b)   (GE a b) | relationship\n \
    \     ----------------------------------\n         TRUE      FALSE  | (LT a b)\n\
    \         TRUE       TRUE  | (EQ a b)\n        FALSE       TRUE  | (GT a b)\n\
    \        FALSE      FALSE  | (NE a b)\n   Thus, the original 3 primitive tests\
    \ can be translated to\n   combinations of just LE and GE, reducing the number\
    \ of additional\n   relationships that must be subsequently captured:\n      (a\
    \ <= b)  -->  (LE a b)\n      (a >= b)  -->  (GE a b)\n      (a = b)   -->  (&\
    \ (LE a b) (GE a b) )\n   Further, logical negations of the original 3 primitive\
    \ tests can be\n   eliminated by the introduction of 'not-greater' and 'not-less'\n\
    \   primitives\n      (NG a b)  ==  (! (GE a b) )\n      (NL a b)  ==  (! (LE\
    \ a b) )\n   using the following transformation rules:\n      (! (a = b) )   -->\
    \  (| (NL a b) (NG a b) )\n      (! (a <= b) )  -->  (NL a b)\n      (! (a >=\
    \ b) )  -->  (NG a b)\n   Thus, we have rules to transform all comparisons and\
    \ logical\n   negations into combinations of just 4 relational operators.\n"
- title: 5.6 Conversion to canonical form
  contents:
  - "5.6 Conversion to canonical form\n      NOTE: Logical negations have been eliminated\
    \ in the previous step.\n   Expand bracketed disjunctions, and flatten bracketed\
    \ conjunctions and\n   disjunctions:\n      (& (| A1 A2 ... Am ) B1 B2 ... Bn\
    \ )\n        -->  (| (& A1 B1 B2 ... Bn )\n                (& A2 B1 B2 ... Bn\
    \ )\n                 :\n                (& Am B1 B2 ... Bn ) )\n      (& (& A1\
    \ A2 ... Am ) B1 B2 ... Bn )\n        -->  (& A1 A2 ... Am B1 B2 ... Bn )\n  \
    \    (| (| A1 A2 ... Am ) B1 B2 ... Bn )\n        -->  (| A1 A2 ... Am B1 B2 ...\
    \ Bn )\n   The result is in \"disjunctive normal form\", a disjunction of\n  \
    \ conjunctions:\n      (| (& S11 S12 ... )\n         (& S21 S22 ... )\n      \
    \    :\n         (& Sm1 Sm2 ... Smn ) )\n   where the \"Sij\" elements are simple\
    \ feature comparison forms\n   constructed during the step at section 5.5.  Each\
    \ term within the\n   top-level \"(|...)\" construct represents a single possible\
    \ feature set\n   that satisfies the goal.  Note that the order of entries within\
    \ the\n   top-level '(|...)', and within each '(&...)', is immaterial.\n   From\
    \ here on, each conjunction '(&...)' is processed separately.\n   Only one of\
    \ these needs to be satisfiable for the original goal to be\n   satisfiable.\n\
    \   (A textbook conversion to clausal form [5,11] uses slightly different\n  \
    \ rules to yield a \"conjunctive normal form\".)\n"
- title: 5.7 Grouping of feature predicates
  contents:
  - "5.7 Grouping of feature predicates\n      NOTE:  Remember that from here on,\
    \ each conjunction is treated\n      separately.\n   Each simple feature predicate\
    \ contains a \"left-hand\" feature tag and\n   a \"right-hand\" feature value\
    \ with which it is compared.\n   To arrange these into independent groups, simple\
    \ predicates are\n   grouped according to their left hand feature tag ('f').\n"
- title: 5.8 Merge single-feature constraints
  contents:
  - "5.8 Merge single-feature constraints\n   Within each group, apply the predicate\
    \ simplification rules given\n   below to eliminate redundant single-feature constraints.\
    \  All\n   single-feature predicates are reduced to an equality or range\n   constraint\
    \ on that feature, possibly combined with a number of non-\n   equality statements.\n\
    \   If the constraints on any feature are found to be contradictory (i.e.\n  \
    \ resolved to FALSE according to the applied rules), the containing\n   conjunction\
    \ is not satisfiable and may be discarded.  Otherwise, the\n   resulting description\
    \ is a minimal form of that particular\n   conjunction of the feature set definition.\n"
- title: 5.8.1 Rules for simplifying ordered values
  contents:
  - "5.8.1 Rules for simplifying ordered values\n   These rules are applicable where\
    \ there is an ordering relationship\n   between the given values 'a' and 'b':\n\
    \      (LE f a)  (LE f b)      -->  (LE f a),   a<=b\n                       \
    \            (LE f b),   otherwise\n      (LE f a)  (GE f b)      -->  FALSE,\
    \      a<b\n      (LE f a)  (NL f b)      -->  FALSE,      a<=b\n      (LE f a)\
    \  (NG f b)      -->  (LE f a),   a<b\n                                   (NG\
    \ f b),   otherwise\n      (GE f a)  (GE f b)      -->  (GE f a),   a>=b\n   \
    \                                (GE f b),   otherwise\n      (GE f a)  (NL f\
    \ b)      -->  (GE f a)    a>b\n                                   (NL f b), \
    \  otherwise\n      (GE f a)  (NG f b)      -->  FALSE,      a>=b\n      (NL f\
    \ a)  (NL f b)      -->  (NL f a),   a>=b\n                                  \
    \ (NL f b),   otherwise\n      (NL f a)  (NG f b)      -->  FALSE,      a>=b\n\
    \      (NG f a)  (NG f b)      -->  (NG f a),   a<=b\n                       \
    \            (NG f b),   otherwise\n"
- title: 5.8.2 Rules for simplifying unordered values
  contents:
  - "5.8.2 Rules for simplifying unordered values\n   These rules are applicable where\
    \ there is no ordering relationship\n   applicable to the given values 'a' and\
    \ 'b':\n      (LE f a)  (LE f b)      -->  (LE f a),   a=b\n                 \
    \                  FALSE,      otherwise\n      (LE f a)  (GE f b)      -->  FALSE,\
    \      a!=b\n      (LE f a)  (NL f b)      -->  (LE f a)    a!=b\n           \
    \                        FALSE,      otherwise\n      (LE f a)  (NG f b)     \
    \ -->  (LE f a),   a!=b\n                                   FALSE,      otherwise\n\
    \      (GE f a)  (GE f b)      -->  (GE f a),   a=b\n                        \
    \           FALSE,      otherwise\n      (GE f a)  (NL f b)      -->  (GE f a)\
    \    a!=b\n                                   FALSE,      otherwise\n      (GE\
    \ f a)  (NG f b)      -->  (GE f a)    a!=b\n                                \
    \   FALSE,      otherwise\n      (NL f a)  (NL f b)      -->  (NL f a),   a=b\n\
    \      (NL f a)  (NG f b)      -->  (NL f a),   a=b\n      (NG f a)  (NG f b)\
    \      -->  (NG f a),   a=b\n"
- title: 6. Other features and issues
  contents:
  - '6. Other features and issues

    '
- title: 6.1 Named and auxiliary predicates
  contents:
  - "6.1 Named and auxiliary predicates\n   Named and auxiliary predicates can serve\
    \ two purposes:\n      (a)  making complex predicates easier to write and understand,\
    \ and\n      (b)  providing a possible basis for naming and registering feature\n\
    \           sets.\n"
- title: 6.1.1 Defining a named predicate
  contents:
  - "6.1.1 Defining a named predicate\n   A named predicate definition has the following\
    \ form:\n      named-pred =  \"(\" fname *pname \")\" \":-\" filter\n      fname\
    \      =  ftag        ; Feature predicate name\n      pname      =  token    \
    \   ; Formal parameter name\n   'fname' is the name of the predicate.\n   'pname'\
    \ is the name of a formal parameter which may appear in the\n   predicate body,\
    \ and which is replaced by some supplied value when the\n   predicate is invoked.\n\
    \   'filter' is the predicate body. It may contain references to the\n   formal\
    \ parameters, and may also contain references to feature tags\n   and other values\
    \ defined in the environment in which the predicate is\n   invoked.  References\
    \ to formal parameters may appear anywhere where a\n   reference to a feature\
    \ tag ('ftag') is permitted by the syntax for '\n   filter'.\n   The only specific\
    \ mechanism defined by this memo for introducing a\n   named predicate into a\
    \ feature set definition is the \"auxiliary\n   predicate\" described later. \
    \ Specific negotiating protocols or other\n   specifications may define other\
    \ mechanisms.\n      NOTE:  There has been some suggestion of creating a registry\
    \ for\n      feature sets as well as individual feature values.  Such a\n    \
    \  registry might be used to introduce named predicates corresponding\n      to\
    \ these feature sets into the environment of a capability\n      assertion.  Further\
    \ discussion of this idea is beyond the scope of\n      this memo.\n"
- title: 6.1.2 Invoking named predicates
  contents:
  - "6.1.2 Invoking named predicates\n   Assuming a named predicate has been introduced\
    \ into the environment\n   of some other predicate, it can be invoked by a filter\
    \ 'ext-pred' of\n   the form:\n      ext-pred   =  fname *param\n      param \
    \     =  expr\n   The number of parameters must match the definition of the named\n\
    \   predicate that is invoked.\n"
- title: 6.1.3 Auxiliary predicates in a filter
  contents:
  - "6.1.3 Auxiliary predicates in a filter\n   A auxiliary predicate is attached\
    \ to a filter definition by the\n   following extension to the \"filter\" syntax:\n\
    \      filter     =/ \"(\" filtercomp *( \";\" parameter ) \")\"\n           \
    \         \"where\" 1*( named-pred ) \"end\"\n   The named predicates introduced\
    \ by \"named-pred\" are visible from the\n   body of the \"filtercomp\" of the\
    \ filter to which they are attached,\n   but are not visible from each other.\
    \  They all have access to the\n   same environment as \"filter\", plus their\
    \ own formal parameters.\n   (Normal scoping rules apply: a formal parameter with\
    \ the same name as\n   a value in the environment of \"filter\" effectively hides\
    \ the\n   environment value from the body of the predicate to which it\n   applies.)\n\
    \      NOTE:  Recursive predicates are not permitted.  The scoping rules\n   \
    \   should ensure this.\n"
- title: 6.1.4 Feature matching with named predicates
  contents:
  - "6.1.4 Feature matching with named predicates\n   The preceding procedures can\
    \ be extended to deal with named\n   predicates simply by instantiating (i.e.\
    \ substituting) the predicates\n   wherever they are invoked, before performing\
    \ the conversion to\n   disjunctive normal form.  In the absence of recursive\
    \ predicates,\n   this procedure is guaranteed to terminate.\n   When substituting\
    \ the body of a precdicate at its point of\n   invocation, instances of formal\
    \ parameters within the predicate body\n   must be replaced by the corresponding\
    \ actual parameter from the point\n   of invocation.\n"
- title: 6.1.5 Example
  contents:
  - "6.1.5 Example\n   This example restates that given in section 4.3 using an auxiliary\n\
    \   predicate named 'Res':\n      (| (& (Pix-x=1024) (Pix-y=768) (Res Res-x Res-y)\
    \ )\n         (& (Pix-x=800)  (Pix-y=600) (Res Res-x Res-y) );q=0.9\n        \
    \ (& (Pix-x=640)  (Pix-y=480) (Res Res-x Res-y) );q=0.8 )\n      where\n     \
    \ (Res Res-x Res-y) :-\n         (| (& (Res-x=150) (Res-y=150) )\n           \
    \ (& (Res-x=150) (Res-y=300) )\n            (& (Res-x=300) (Res-y=300) )\n   \
    \         (& (Res-x=300) (Res-y=600) )\n            (& (Res-x=600) (Res-y=600)\
    \ ) )\n      end\n   Note that the formal parameters of \"Res\", \"Res-x\" and\
    \ \"Res-y\",\n   prevent the body of the named predicate from referencing similarly-\n\
    \   named feature values.\n"
- title: 6.2 Unit designations
  contents:
  - "6.2 Unit designations\n   In some exceptional cases, there may be differing conventions\
    \ for the\n   units of measurement of a given feature.  For example, resolution\
    \ is\n   commonly expressed as dots per inch (dpi) or dots per centimetre\n  \
    \ (dpcm) in different applications (e.g. printing vs faxing).\n   In such cases,\
    \ a unit designator may be appended to a feature value\n   according to the conventions\
    \ indicated below (see also [3]).  These\n   considerations apply only to features\
    \ with numeric values.\n   Every feature tag has a standard unit of measurement.\
    \  Any expression\n   of a feature value that uses this unit is given without\
    \ a unit\n   designation -- this is the normal case.  When the feature value is\n\
    \   expressed in some other unit, a unit designator is appended to the\n   numeric\
    \ feature value.\n   The registration of a feature tag indicates the standard\
    \ unit of\n   measurement for a feature, and also any alternate units and\n  \
    \ corresponding unit designators that may be used, according to RFC\n   2506 [3].\n\
    \   Thus, if the standard unit of measure for resolution is 'dpcm', then\n   the\
    \ feature predicate '(res=200)' would be used to indicate a\n   resolution of\
    \ 200 dots-per-centimetre, and '(res=72dpi)' might be\n   used to indicate 72\
    \ dots-per-inch.\n   Unit designators are accommodated by the following extension\
    \ to the\n   feature predicate syntax:\n      fvalue     =/ number *WSP token\n\
    \   When performing feature set matching, feature comparisons with and\n   without\
    \ unit designators, or feature comparisons with different unit\n   designators,\
    \ are treated as if they were different features.  Thus,\n   the feature predicate\
    \ '(res=200)' would not, in general, fail to\n   match with the predicate '(res=200dpi)'.\n\
    \      NOTE:  A protocol processor with specific knowledge of the feature\n  \
    \    and units concerned might recognize the relationship between the\n      feature\
    \ predicates in the above example, and fail to match these\n      predicates.\n\
    \      This appears to be a natural behaviour in this simple example, but\n  \
    \    can cause additional complexity in more general cases.\n      Accordingly,\
    \ this is not considered to be required or normal\n      behaviour.  It is presumed\
    \ that an application concerned will\n      ensure consistent feature processing\
    \ by adopting a consistent unit\n      for any given feature.\n"
- title: 6.3 Unknown feature value data types
  contents:
  - "6.3 Unknown feature value data types\n   This memo has dealt with feature values\
    \ that have well-understood\n   comparison properties: numbers, with equality,\
    \ less-than, greater-\n   than relationships, and other values with equality relationships\n\
    \   only.\n   Some feature values may have comparison operations that are not\n\
    \   covered by this framework.  For example, strings containing multi-\n   part\
    \ version numbers: \"x.y.z\".  Such feature comparisons are not\n   covered by\
    \ this memo.\n   Specific applications may recognize and process feature tags\
    \ that are\n   associated with such values.  Future work may define ways to\n\
    \   introduce new feature value data types in a way that allows them to\n   be\
    \ used by applications that do not contain built-in knowledge of\n   their properties.\n"
- title: 7. Examples and additional comments
  contents:
  - '7. Examples and additional comments

    '
- title: 7.1 Worked example
  contents:
  - "7.1 Worked example\n   This example considers sending a document to a high-end\
    \ black-and-\n   white fax system with the following receiver capabilities:\n\
    \      (& (dpi=[200,300])\n         (grey=2) (color=0)\n         (image-coding=[MH,MR])\
    \ )\n   Turning to the document itself, assume it is available to the sender\n\
    \   in three possible formats, A4 high resolution, B4 low resolution and\n   A4\
    \ high resolution colour, described by:\n      (& (dpi=300)\n         (grey=2)\n\
    \         (image-coding=MR) )\n      (& (dpi=200)\n         (grey=2)\n       \
    \  (image-coding=[MH,MMR]) )\n      (& (dpi=300) (dpi-xyratio=1)\n         (color<=256)\n\
    \         (image-coding=JPEG) )\n   These three image formats can be combined\
    \ into a composite capability\n   statement by a logical-OR operation (to describe\
    \ format-1 OR format-2\n   OR format-3):\n      (| (& (dpi=300)\n            (grey=2)\n\
    \            (image-coding=MR) )\n         (& (dpi=200)\n            (grey=2)\n\
    \            (image-coding=[MH,MMR]) )\n         (& (dpi=300)\n            (color<=256)\n\
    \            (image-coding=JPEG) ) )\n   The composite document description can\
    \ be matched with the receiver\n   capability description by combining the capability\
    \ descriptions with\n   a logical AND operation:\n      (& (& (dpi=[200,300])\n\
    \              (grey=2) (color=0)\n            (image-coding=[MH,MR]) )\n    \
    \     (| (& (dpi=300)\n               (grey=2)\n               (image-coding=MR)\
    \ )\n            (& (dpi=200)\n               (grey=2)\n               (image-coding=[MH,MMR])\
    \ )\n            (& (dpi=300)\n               (color<=256)\n               (image-coding=JPEG)\
    \ ) ) )\n   -->  Expand value-set notation:\n      (& (& (| (dpi=200) (dpi=300)\
    \ )\n            (grey=2) (color=0)\n            (| (image-coding=MH) (image-coding=MR)\
    \ ) )\n         (| (& (dpi=300)\n               (grey=2)\n               (image-coding=MR)\
    \ )\n            (& (dpi=200)\n               (grey=2)\n               (| (image-coding=MH)\
    \ (image-coding=MMR) ) )\n            (& (dpi=300)\n               (color<=256)\n\
    \               (image-coding=JPEG) ) ) )\n   -->  Flatten nested '(&...)':\n\
    \      (& (| (dpi=200) (dpi=300) )\n         (grey=2) (color=0)\n         (| (image-coding=MH)\
    \ (image-coding=MR) )\n         (| (& (dpi=300)\n               (grey=2)\n   \
    \            (image-coding=MR) )\n            (& (dpi=200)\n               (grey=2)\n\
    \               (| (image-coding=MH) (image-coding=MMR) ) )\n            (& (dpi=300)\n\
    \               (color<=256)\n               (image-coding=JPEG) ) ) )\n   -->\
    \  (distribute '(&...)' over inner '(|...)'):\n      (& (| (dpi=200) (dpi=300)\
    \ )\n         (grey=2) (color=0)\n         (| (image-coding=MH) (image-coding=MR)\
    \ )\n         (| (& (dpi=300) (grey=2) (image-coding=MR) )\n            (& (dpi=200)\
    \ (grey=2) (image-coding=MH) )\n            (& (dpi=200) (grey=2) (image-coding=MMR)\
    \ )\n            (& (dpi=300) (color<=256) (image-coding=JPEG) ) ) )\n   --> \
    \ continue to distribute '(&...)' over '(|...)', and flattening\n        nested\
    \ '(&...)' and '(|...)' ...:\n      (| (& (dpi=200) (grey=2) (color=0) (image-coding=MH)\n\
    \            (| (& (dpi=300) (grey=2) (image-coding=MR) )\n               (& (dpi=200)\
    \ (grey=2) (image-coding=MH) )\n               (& (dpi=200) (grey=2) (image-coding=MMR)\
    \ )\n               (& (dpi=300) (color<=256) (image-coding=JPEG) ) ) )\n    \
    \     (& (dpi=200) (grey=2) (color=0) (image-coding=MR)\n            (| (& (dpi=300)\
    \ (grey=2) (image-coding=MR) )\n               (& (dpi=200) (grey=2) (image-coding=MH)\
    \ )\n               (& (dpi=200) (grey=2) (image-coding=MMR) )\n             \
    \  (& (dpi=300) (color<=256) (image-coding=JPEG) ) ) )\n         (& (dpi=300)\
    \ (grey=2) (color=0) (image-coding=MH)\n            (| (& (dpi=300) (grey=2) (image-coding=MR)\
    \ )\n               (& (dpi=200) (grey=2) (image-coding=MH) )\n              \
    \ (& (dpi=200) (grey=2) (image-coding=MMR) )\n               (& (dpi=300) (color<=256)\
    \ (image-coding=JPEG) ) ) )\n         (& (dpi=300) (grey=2) (color=0) (image-coding=MR)\n\
    \            (| (& (dpi=300) (grey=2) (image-coding=MR) )\n               (& (dpi=200)\
    \ (grey=2) (image-coding=MH) )\n               (& (dpi=200) (grey=2) (image-coding=MMR)\
    \ )\n               (& (dpi=300) (color<=256) (image-coding=JPEG) ) ) ) )\n  \
    \ -->  ... until normal form is achieved:\n      (| (& (dpi=200) (grey=2) (color=0)\
    \ (image-coding=MH)\n            (dpi=300) (grey=2) (image-coding=MR) )\n    \
    \     (& (dpi=200) (grey=2) (color=0) (image-coding=MR)\n            (dpi=300)\
    \ (grey=2) (image-coding=MR) )\n         (& (dpi=300) (grey=2) (color=0) (image-coding=MH)\n\
    \            (dpi=300) (grey=2) (image-coding=MR) )\n         (& (dpi=300) (grey=2)\
    \ (color=0) (image-coding=MR)\n            (dpi=300) (grey=2) (image-coding=MR)\
    \ )\n         (& (dpi=200) (grey=2) (color=0) (image-coding=MH)\n            (dpi=200)\
    \ (grey=2) (image-coding=MH) )\n         (& (dpi=200) (grey=2) (color=0) (image-coding=MR)\n\
    \            (dpi=200) (grey=2) (image-coding=MH) )\n         (& (dpi=300) (grey=2)\
    \ (color=0) (image-coding=MH)\n            (dpi=200) (grey=2) (image-coding=MH)\
    \ )\n         (& (dpi=300) (grey=2) (color=0) (image-coding=MR)\n            (dpi=200)\
    \ (grey=2) (image-coding=MH) )\n         (& (dpi=200) (grey=2) (color=0) (image-coding=MH)\n\
    \            (dpi=200) (grey=2) (image-coding=MMR) )\n         (& (dpi=200) (grey=2)\
    \ (color=0) (image-coding=MR)\n            (dpi=200) (grey=2) (image-coding=MMR)\
    \ )\n         (& (dpi=300) (grey=2) (color=0) (image-coding=MH)\n            (dpi=200)\
    \ (grey=2) (image-coding=MMR) )\n         (& (dpi=300) (grey=2) (color=0) (image-coding=MR)\n\
    \            (dpi=200) (grey=2) (image-coding=MMR) )\n         (& (dpi=200) (grey=2)\
    \ (color=0) (image-coding=MH)\n            (dpi=300) (color<=256) (image-coding=JPEG)\
    \ ) ) )\n         (& (dpi=200) (grey=2) (color=0) (image-coding=MR)\n        \
    \    (dpi=300) (color<=256) (image-coding=JPEG) ) ) )\n         (& (dpi=300) (grey=2)\
    \ (color=0) (image-coding=MH)\n            (dpi=300) (color<=256) (image-coding=JPEG)\
    \ ) ) )\n         (& (dpi=300) (grey=2) (color=0) (image-coding=MR)\n        \
    \    (dpi=300) (color<=256) (image-coding=JPEG) ) )\n   -->  Group terms in each\
    \ conjunction by feature tag:\n      (| (& (dpi=200) (dpi=300) (grey=2) (grey=2)\
    \ (color=0)\n            (image-coding=MH) (image-coding=MR) )\n         (& (dpi=200)\
    \ (dpi=300) (grey=2) (grey=2) (color=0)\n            (image-coding=MR) (image-coding=MR)\
    \ )\n             :\n            (etc.)\n             :\n         (& (dpi=300)\
    \ (dpi=300) (grey=2) (color=0) (color<=256)\n            (image-coding=MR) (image-coding=JPEG)\
    \ ) )\n   -->  Combine feature tag comparisons and eliminate unsatisfiable\n \
    \       conjunctions:\n      (| (& (dpi=300) (grey=2) (color=0) (image-coding=MR)\
    \ )\n         (& (dpi=200) (grey=2) (color=0) (image-coding=MH) ) )\n   Thus,\
    \ we see that this combination of sender and receiver options can\n   transfer\
    \ a bi-level image, either at 300dpi using MR coding, or at\n   200dpi using MH\
    \ coding.\n   Points to note about the feature matching process:\n      o  The\
    \ colour document option is eliminated because the receiver\n         cannot handle\
    \ either colour (indicated by '(color=0)') or JPEG\n         coding.\n      o\
    \  The high resolution version of the document with '(dpi=300)'\n         must\
    \ be sent using '(image-coding=MR)' because this is the only\n         available\
    \ coding of the image data that the receiver can use\n         for high resolution\
    \ documents.  (The available 300dpi document\n         codings here are MMR and\
    \ MH, and the receiver capabilities are\n         MH and MR.)\n"
- title: 7.2 A note on feature tag scoping
  contents:
  - "7.2 A note on feature tag scoping\n   This section contains some additional commentary\
    \ on the\n   interpretation of feture set predicates.  It does not extend or\n\
    \   modify what has been described previously.  Rather, it attempts to\n   clarify\
    \ an area of possible misunderstanding.\n   The essential fact that needs to be\
    \ established here is:\n      Within a given feature collection, each feature\
    \ tag may have only\n      one value.\n   This idea is explained below in the\
    \ context of using the media\n   feature framework to describe the characteristics\
    \ of transmitted\n   image data.\n   In this context, we have the requirement\
    \ that any feature tag value\n   must apply to the entire image, and cannot have\
    \ different values for\n   different parts of an image.  This is a consequence\
    \ of the way that\n   the framework of feature predicates is used to describe\
    \ different\n   possible images, such as the different images that can be rendered\
    \ by\n   a given recipient.\n   This idea is illustrated here using an example\
    \ of a flawed feature\n   set description based on the TIFF image format defined\
    \ for use by\n   Internet fax [13]:\n      (& (& (MRC-mode=1) (stripe-size=256)\
    \ )\n         (| (& (image-coding=JBIG-2-LEVEL) (stripe-size=128) )\n        \
    \    (image-coding=[MH,MR,MMR]) ) )\n   This example is revealing because the\
    \ 'stripe-size' attribute is\n   applied differently to different attributes on\
    \ an MRC-formatted data:\n   it can be applied to the MRC format as a whole, and\
    \ it can be applied\n   separately to a JBIG image that may appear as part of\
    \ the MRC data.\n   One might imagine that this example describes a stripe size\
    \ of 256\n   when applied to the MRC image format, and a separate stripe size\
    \ of\n   128 when applied to a JBIG-2-LEVEL coded image within the MRC-\n   formatted\
    \ data.  But it doesn't work that way:  the predicates used\n   obey the normal\
    \ laws of Boolean logic, and would be transformed as\n   follows:\n      --> [flatten\
    \ nested (&...)]:\n          (& (MRC-mode=1) (stripe-size=256)\n             (|\
    \ (& (image-coding=JBIG-2-LEVEL) (stripe-size=128) )\n                (image-coding=[MH,MR,MMR])\
    \ ) )\n      --> [Distribute (&...) over (|...)]:\n           (| (& (MRC-mode=1)\
    \ (stripe-size=256)\n                 (& (image-coding=JBIG-2-LEVEL) (stripe-size=128)\
    \ ) )\n              (& (MRC-mode=1) (stripe-size=[0..256])\n                \
    \ (image-coding=[MH,MR,MMR]) ) )\n      --> [Flatten nested (&...) and group feature\
    \ tags]:\n           (| (& (MRC-mode=1)\n                 (stripe-size=256)\n\
    \                 (stripe-size=128)\n                 (image-coding=JBIG-2-LEVEL)\
    \ )\n              (& (MRC-mode=1)\n                 (stripe-size=256)\n     \
    \            (image-coding=[MH,MR,MMR]) ) )\n   Examination of this final expression\
    \ shows that it requires both '\n   stripe-size=128' and 'stripe-size=256' within\
    \ the same conjunction.\n   This is manifestly false, so the entire conjunction\
    \ must be false,\n   reducing the entire predicate expression to:\n          \
    \ (& (MRC-mode=1)\n              (stripe-size=256)\n              (image-coding=[MH,MR,MMR])\
    \ ) )\n   This indicates that no MRC formatted data containing a JBIG-2-LEVEL\n\
    \   coded image is permitted within the feature set, which is not what\n   was\
    \ intended in this case.\n   The only way to avoid this in situations when a given\
    \ characteristic\n   has different constraints in different parts of a resource\
    \ is to use\n   separate feature tags.  In this example, 'MRC-stripe-size' and\
    \ '\n   JBIG-stripe-size' could be used to capture the intent:\n      (& (& (MRC-mode=1)\
    \ (MRC-stripe-size=256) )\n         (| (& (image-coding=JBIG-2-LEVEL) (JBIG-stripe-size=128)\
    \ )\n            (image-coding=[MH,MR,MMR]) ) )\n   which would reduce to:\n \
    \          (| (& (MRC-mode=1)\n                 (MRC-stripe-size=256)\n      \
    \           (JBIG-stripe-size=128)\n                 (image-coding=JBIG-2-LEVEL)\
    \ )\n              (& (MRC-mode=1)\n                 (MRC-stripe-size=256)\n \
    \                (image-coding=[MH,MR,MMR]) ) )\n   The property of the capability\
    \ description framework explicated above\n   is captured by the idea of a \"feature\
    \ collection\" which (in this\n   context) describes the feature values that apply\
    \ to a single\n   resource.  Within a feature collection, each feature tag may\
    \ have no\n   more than one value.\n   The characteristics of an image sender\
    \ or receiver are described by a\n   \"Feature set\", which is formally a set\
    \ of feature collections.  Here,\n   the feature set predicate is applied to some\
    \ image feature collection\n   to determine whether or not it belongs to the set\
    \ that can be handled\n   by an image receiver.\n"
- title: 8. Security Considerations
  contents:
  - "8. Security Considerations\n   Some security considerations for content negotiation\
    \ are raised in\n   [1,2,3].\n   The following are primary security concerns for\
    \ capability\n   identification mechanisms:\n      o  Unintentional disclosure\
    \ of private information through the\n         announcement of capabilities or\
    \ user preferences.\n      o  Disruption to system operation caused by accidental\
    \ or\n         malicious provision of incorrect capability information.\n    \
    \  o  Use of a capability identification mechanism might be used to\n        \
    \ probe a network (e.g. by identifying specific hosts used, and\n         exploiting\
    \ their known weaknesses).\n   The most contentious security concerns are raised\
    \ by mechanisms which\n   automatically send capability identification data in\
    \ response to a\n   query from some unknown system.  Use of directory services\
    \ (based on\n   LDAP [7], etc.) seem to be less problematic because proper\n \
    \  authentication mechanisms are available.\n   Mechanisms that provide capability\
    \ information when sending a message\n   are less contentious, presumably because\
    \ some intention can be\n   inferred that person whose details are disclosed wishes\
    \ to\n   communicate with the recipient of those details.  This does not,\n  \
    \ however, solve problems of spoofed supply of incorrect capability\n   information.\n\
    \   The use of format converting gateways may prove problematic because\n   such\
    \ systems would tend to defeat any message integrity and\n   authenticity checking\
    \ mechanisms that are employed.\n"
- title: 9. Acknowledgements
  contents:
  - "9. Acknowledgements\n   Thanks are due to Larry Masinter for demonstrating the\
    \ breadth of the\n   media feature issue, and encouraging the development of some\
    \ early\n   thoughts.\n   Many of the ideas presented derive from the \"Transparent\
    \ Content\n   Negotiation in HTTP\" work of Koen Holtman and Andy Mutz [4].\n\
    \   Early discussions of ideas with the IETF HTTP and FAX working groups\n   led\
    \ to further useful inputs from Koen Holtman, Ted Hardie and Dan\n   Wing.  The\
    \ debate later moved to the IETF 'conneg' working group,\n   where Al Gilman and\
    \ Koen Holtman were particularly helpful in\n   refining the feature set algebra.\
    \  Ideas for dealing with preferences\n   and specific units were suggested by\
    \ Larry Masinter.\n   This work was supported by Content Technologies Ltd and\
    \ 5th\n   Generation Messaging Ltd.\n"
- title: 10. References
  contents:
  - "10. References\n   [1]  Hardie, T., \"Scenarios for the Delivery of Negotiated\
    \ Content\",\n        Work in Progress.\n   [2]  Klyne, G., \"Requirements for\
    \ protocol-independent content\n        negotiation\", Work in Progress.\n   [3]\
    \  Holtman, K., Mutz, A., and T. Hardie, \"Media Feature Tag\n        Registration\
    \ Procedure\", BCP 31, RFC 2506, March 1999.\n   [4]  Holtman, K. and A. Mutz,\
    \ \"Transparent Content Negotiation in\n        HTTP\", RFC 2295, March 1998.\n\
    \   [5]  \"Programming in Prolog\" (2nd edition), W. F. Clocksin and C. S.\n \
    \       Mellish, Springer Verlag, ISBN 3-540-15011-0 / 0-387-15011-0,\n      \
    \  1984.\n   [6]  Masinter, L., Holtman, K., Mutz, A., and D. Wing, \"Media\n\
    \        Features for Display, Print, and Fax\", RFC 2534, March 1999.\n   [7]\
    \  Wahl, M., Howes, T. and S. Kille, \"Lightweight Directory Access\n        Protocol\
    \ (v3)\", RFC 2251, December 1997.\n   [8]  Howes, T., \"The String Representation\
    \ of LDAP Search Filters\",\n        RFC 2254, December 1997.\n   [9]  Fielding,\
    \ R., Gettys, J., Mogul, J., Frytyk, H. and T. Berners-\n        Lee, \"Hyptertext\
    \ Transfer Protocol -- HTTP/1.1\", RFC 2068,\n        January 1997.\n   [10] Crocker,\
    \ D., Editor, and P. Overell, \"Augmented BNF for Syntax\n        Specifications:\
    \  ABNF\", RFC 2234, November 1997.\n   [11] \"Logic, Algebra and Databases\"\
    , Peter Gray, Ellis Horwood\n        Series: Computers and their Applications,\
    \ ISBN 0-85312-709-3/0-\n        85312-803-3 (Ellis Horwood Ltd), ISBN 0-470-20103-7/0-470-\n\
    \        20259-9 (Halstead Press), 1984.\n   [12] \"Logic and its Applications\"\
    , Edmund Burk and Eric Foxley,\n        Prentice Hall, Series in computer science,\
    \ ISBN 0-13-030263-5,\n        1996.\n   [13] McIntyre, L., Buckley, R., Venable,\
    \ D., Zilles, S., Parsons, G.\n        and J. Rafferty, \"File Format for Internet\
    \ Fax\", RFC 2301, March\n        1998.\n   [14] Apache content negotiation algorithm,\n\
    \        <http://www.apache.org/docs/content-negotiation.html>\n"
- title: 11. Author's Address
  contents:
  - "11. Author's Address\n   Graham Klyne\n   Content Technologies Ltd.        5th\
    \ Generation Messaging Ltd.\n   Forum 1                          5 Watlington\
    \ Street\n   Station Road                     Nettlebed\n   Theale           \
    \                Henley-on-Thames\n   Reading, RG7 4RA                 RG9 5AB\n\
    \   United Kingdom                   United Kingdom.\n   Phone:     +44 118 930\
    \ 1300      +44 1491 641 641\n   Facsimile: +44 118 930 1301      +44 1491 641\
    \ 611\n   EMail:     GK@ACM.ORG\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
